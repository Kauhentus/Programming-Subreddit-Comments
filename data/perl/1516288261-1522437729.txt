I develop a product where all the heavy lifting is done in Perl 5. The first version of this product was written in C back in 2000 and I used Perl to automate testing. I need to use a lot of these devices together so I expanded testing to include one Perl app on Linux. We decided to create a J2EE web server piece using this one Perl app as a data collector. I needed CGI config pages, email notification, heart beat, etc and I wrote those all in Perl. I moved to using mostly Perl for the next revision of our device. It is faster for me to add functionality using Perl than C. I have maybe half-million or more lines of Perl 5 code that does REAL work 24x7 for those that depend on what it does. These folks work 24x7 too. I looked at Python years back, but I needed a strong community support. I needed a mature CPAN type repository. I believe, but there could be doubt, that I use the Perl module Expect more than anyone else. Python at that time did not have pyexpect. Same went for Ruby. The Perl 6 development cycle had me looking at abandoning Perl 5 many many times. Python looks better each year. I compile over 200 CPAN modules when I do a firmware build. I use DBI and various DBD drivers. I use XML, JSON, XS, SOAP::Lite, etc. My #1 issue today is that developers are abandoning their projects on CPAN. SOAP::Lite is a fine example of this. Net::Pcap is another. When I upgraded our firmware build to 5.22.3 I had many issues. So many in fact that I had to include a PERL_TEST variable in our Makefiles to not test certain modules. They would fail in areas, but will work with our code. Our current firmware runs on 2 pieces of hardware. Both X86. One with 1G of ram the other 2. The previous is older and discontinued by the manufacture, but I still code for it. It is i586 (not i686). My confusion about Perl 6 is that I am not sure where I'd even start. In our build I am compiling MoarVM and Parrot as extra packages. I can load them remotely outside of firmware. Even if I overcome that obstacle I still have issues with all the modules I NEED. I'm mostly a one man shop and Perl 6 reminds me so much of my own shortcomings when it comes to completion. I have many projects that have been in testing for years, but are not complete... 
One of my biggest issue with my programs is memory size over time. Once a system boots it is intended that some Perl programs run 24x7. They'll have a worker function that is called from a while() loop which sleeps N seconds left after execution of the worker(). One way I handle memory issues over long periods is to fork() the worker. The only long running Perl program is simply the main() function which does the execute and sleep loop.
&gt; Show me something awesome being done with Perl 6 that illustrates the benefit I will see in moving from Perl 5 to Perl 6. I don't think that's the best way to look at it. Perl 6 is a different language, so it should be compared to other 'different' languages. Why should I choose to move to Perl 6 instead of Python or whatever else is out there?
In Perl 5 you can use [List::Util::pairs](https://metacpan.org/pod/List::Util#pairs) or [List::Util::pairmap](https://metacpan.org/pod/List::Util#pairmap) use List::Util qw/pairmap/; my @a = pairmap { [ $a, $b ] } split " ", "3179500 3241420 3179500 3241820 3180300 3240926 3180300 3242314"; In Perl 6, you can [rotor](https://docs.perl6.org/routine/rotor) over [words](https://docs.perl6.org/routine/words): "3179500 3241420 3179500 3241820 3180300 3240926 3180300 3242314".words.rotor: 2
The first index would reference the pair and the second index would reference the item in that pair. So if you want to print the X and Y of a second pair in the array, you'd use: say "\$x is $a[1][0] and \$y is $a[1][1]" And to create them you'd either push the pair arrayref: push @a, [42, 70]; Or assign it to some index: $a[1] = [42, 70]; Or rely on autovivification and assign individual items: $a[1][0] = 42; $a[1][1] = 70; Personally, I'd use hashrefs instead of arrayrefs for inner structures. It'd be clearer to write: push @a, { x =&gt; 42, y =&gt; 70 }; $a[1]{x} = 42; $a[1]{y} = 70; say "\$x is $a[1]{x} and \$y is $a[1]{y}" Perhaps [`perldoc perlreftut`](https://perldoc.perl.org/perlreftut.html) could be of help in understanding these structures.
&gt; It's been getting harder and harder to find people able and willing to work on the Perl 5 core. At this moment, there are 3 people paid to work on the internals, and they are responsible for most of the improvements. However, funding these people is becoming harder and harder. No new people have stepped up to work on the Perl 5 internals to my knowledge: they are all die-hard decade long Perl 5 developers. And why not **sponsor an initiative** inspired on *Kernel Newbies* to bring new Perl core developers? In case there is no budget available for that, why not have a special track on YAPCs/Videos/Tutorials just for this matter? I mean, there are alternatives to bring new P5P, and I can only agree with "No new people have stepped up to work on P5 internals", after Perl Foundation have tried all the possible alternatives to achieve that. The presentation from James E Keenan - "How Do We Assess and Maintain the Health of the Perl 5 Codebase?" is of good start, for instance.
But that number change from 5 to 7 helped perception. Which gets more attention, "PHP 7 increases performance" or "PHP 5.4 increases performance"?
P6 is being touted, without a shred of evidence, as the replacement for P5. Otherwise what's the point of porting P5 code to P6?
This "the same mindset" sounds like another "meme" (or possibly "narrative") the P6 advocates are trying to force on people. I wonder whether they're discussing it even now in their private chat. Too bad it's not sticking. Change the name of your product.
Are you still trying to push the "ship has sailed" (and implicitly it's too late) narrative? That's a little.... disingenuous. Change the name of your product.
It's all about *how* you look at things. &gt; Have you looked at how to declare a class method in Perl6? All methods are class methods by default in P6: class Dog { method legs { 4 } } # class method class Dog { method legs (Dog:) { 4 } } # same class Dog { method legs (::?CLASS:) { 4 } } # same If you want to require that a `Dog` method only gets called on an undefined `Dog` (because, while it makes sense that `Dog`s as a *class* have 4 legs, particular dogs might have, say, three legs, and you don't want the `legs` method working for particular dogs because of that possibility) then you must add a `:U`: class Dog { method legs (Dog:U:) { 4 } } # only accepts an undefined dog Now we can understand the relatively obscure case you started with. One might write a method like I just did (that only accepts undefined objects of the `Dog` class) and then want to cut and paste it into another class: class Cat { method legs (Dog:U:) { 4 } } # only accepts an undefined dog To have that work you'd have to s/Dog/Cat/. If you want to avoid having to do that editing you can write the type constraint using dynamic look up of the enclosing class: class Dog { method legs (::?CLASS:U:) { 4 } } # only accepts an undefined Dog class Cat { method legs (::?CLASS:U:) { 4 } } # only accepts an undefined Cat Perhaps having `(:U:)` there mean `(::?CLASS:U:)` would be nice but my point is that you've deliberately picked an unusual way to declare a class method without noting that it's unusual. &gt; Don't get me started on twigles. I see from another comment you've made about them that you are again misunderstanding or mischaracterizing how P6 works. First, *all* attributes are private and one can optionally add a public accessor. To add a public accessor requires changing just *one* character, total. You do not have to change any other existing code. It can't get simpler than that. If you remove a public accessor then you have to change any code that uses the public accessor. If code using the public accessor has access to the private attribute (in which case, why didn't you just directly use the private attribute?) then you have to change a single character per access. It can't get simpler than that. --- In looking at P6, as in anything else, *how* you look at things can completely change what you see.
Which still doesn't explain why we have such a syntactic mess for a feature that other languages have done for decades without being a syntactic mess. At best, twigles are still a syntactic mess, too. It makes their access level effectively part of the variable name. Perl6 should have been backing away from these sorts of things.
true, it was an impressive performance improvement, but the 5 to 7 helped market it. How long should a language be stuck on a major version number...
&gt; My #1 issue today is that developers are abandoning their projects on CPAN Please hold out a bit longer. Work is being done in the background to address this accelerating trend.
You said that once you tell people about Perl 6, they believe Perl has a future. What are you telling them about Perl 5? They don't read your blog.
It is not a new version, or a major version release. It is a new language and it is extremely different, regardless of any "mindset" similarities you claim. I don't use it because I don't have a reason to learn a new language. That it's incorrectly claiming to be Perl is a separate issue which sours me on collaboration and makes my daily life more difficult.
This is a non sequitur. You mention Perl 5 many times in your blog post, particularly with the false claim that it's at end of life, and that migrating its code to another language will somehow preserve it. Separately your comment above implies that people are being led to believe that Perl 6 is the future of Perl, rather than Perl's actual continual development, which is what she was responding to.
I will note that in many cases, where projects are abandoned, a more well-maintained project exists in that space, because someone still has that itch to scratch. For example, XML::Compile::SOAP is a very well-maintained SOAP interface with a responsive author. It's also common for those with need of an abandoned module to request permissions on it to continue the maintenance, or if the author is completely unresponsive, [take it over entirely](https://www.cpan.org/modules/04pause.html#takeover).
*disingenuous* You are trying to promote a narrative that Perl 5 is still there, sort of, but with a "runtime ... nearing the end of its life". And that Perl 6 is a viable replacement. Change the name of your product.
To avoid doubt: the above was intended as a description of how a pitch to convert a Perl 5 codebase to Perl 6 would sound. Not a description of the state of Perl 6 itself.
It's not perfect, but [CPAN Ratings](https://cpanratings.perl.org/) (linked on the left sidebar on metacpan pages for modules) can be, and quite often is, used by users to mention alternatives. As far as finding the right module for a task, it unfortunately just comes down to trial and error, or asking those with more experience. (This reddit or the [IRC](http://webchat.freenode.net/?channels=%23perl) are good places to ask)
Yes. This worked much better and is working. It wasn't even that much reworking, I just added the use line and about 4 new lines; but I stuck it in at the end, so it shouldn't break any of the other stuff.
I think that blogs.perl.org and perl.com still have different use cases. perl.com is and has been more of a news site, that fell into disuse and so absorbed perltricks.com. blogs.perl.org is more of a collection of many individual blogs, rather than a face of perl itself. The redesigned perl.org is very nice though, and you can suggest improvements (like better version release visibility) at https://github.com/perlorg/perlweb/.
&gt; For example, XML::Compile::SOAP is a very well-maintained SOAP interface with a responsive author. I want to jump in here and underline this point. Mark Overmeer is **amazing**, and his work has been my lifeline more than once. A few years back, he was able to add support for a particular XML feature in a matter of weeks, which saved my project and its entire application (one of the last remaining services that that company ran on perl). It's worth noting that this company had been considering for a while to abandon perl entirely, but I was able to finish this project (and have it start earning money), because of Mark's assistance, long before a competing team had even figured out how to get started with a rewrite in node.js.
A quick way to get a feel for which modules the program uses would be: egrep -r '^\s*use\b' . Assuming the current directory contains the main program and not too many other files other than programs. Then use either plenv or perlbrew, along with cpanm, to build a personal copy of Perl and install the required modules into that.
Yes, it *is* too late. Looking back is always 20/20. Nothing disingenuous about it. The situation now is different from 10 years ago.
Perl 6 is a logical progression from Perl 5. Read the RFC's. See how Perl 5 is trying to implement Perl 6 features and failing. Smart match anyone? Subroutine signatures? Moose? And you're saying Perl 5 and Perl 6 do *not* have the same mindset?
You don't seem to be able to differentiate between Perl 5 the language and perl5 the runtime. My claim is that the perl5 runtime is nearing its end of life. I think there is a future for Perl 5 the language.
&lt;holly&gt;That ship has sailed&lt;/holly&gt;
 public static fromIngredients() { } All I wanted was to declare a method as a class method and have the code be self-documenting as such. The `static` keyword isn't a great choice for this, but it'll do.
That doesn't function *even remotely* the same as the Perl 6 code you posted.
But it does what I wanted. Edit: the [docs say](https://docs.perl6.org/language/objects#Class_and_Instance_Methods): &gt; Providing an invocant in the method signature also allows for defining the method as either as a class method, or as an object method, through the use of type constraints. The ::?CLASS variable can be used to provide the class name at compile time, combined with either :U (for class methods) or :D (for instance methods). So forgive me for taking the docs at their word.
That's just an argument for whether to use long words or short symbols to encode features. Long words are easier to read by novices; short symbols are faster to type by experts. It's always a trade off in language design. Can't say I benefited much in long-word languages when I had to read their code without knowing the language. You can surmise a hint of what the routine does based on its name, but you still have to look it up in the docs to actually understand what the code does. FWIW: Perl 6's grammar is lexically mutable and you could make a slang that makes `public static fromIngredients() { }` parse and mean what you want.
* Smart match: no thanks * Subroutine signatures: several options, just fine * Moo starts up quicker and works great: just fine All the worthwhile ideas created in the 15-year brainstorming for P6 are available today in Perl. Change the name of your product.
That seems about as true as the Perl "runtime ... nearing the end of its life". Change the name of your product.
What *can* I tell them about Perl 5? What has Perl 5 brought us since 5.12 (which to me is the cut-off point where Perl 5 decided to go at it on her own). Yearly updates with Unicode updates, pluggable keywords, postfix dereferencing, the `package { }` syntax, marking smart match as experimental. Apart from the Unicode updates, which I see as maintenance, many people could very well live without these changes. So, what do *you* think I should tell them about Perl 5? And why are *you* not telling them that at Perl events, or at non-Perl events, or anywhere? Or writing blog posts?
&gt; And why not sponsor an initiative inspired on Kernel Newbies to bring new Perl core developers? Budget is not the problem, as far as I know. Finding people able and willing to do the work, **is**. &gt;Perl Foundation have tried all the possible alternatives to achieve that. This is not about the Perl Foundation. This is about the Perl 5 Porters. And yes, the influx of new people to Perl 5 Porters has been very minimal in the past years.
&gt; And that is where we disagree. This is nothing more than the same FUD that has been around for decades. It **was** FUD 10 years ago. It isn't anymore, I'm afraid. 
&lt;holly&gt;That ship has sailed&lt;/holly&gt;
I'm sorry that you are clinging to that line. When will P6 be as fast at the Sieve of Eratosthenes? Is there a timeline for that?
Yeah, most of the discussions happened last summer. For the update... the discussed resolution to the naming Issue is still targeted for 6.d release. There's [one blocker](https://github.com/rakudo/rakudo/issues/1289) for 6.d release. Once that's resolved, there's a [few simple commits to implement](https://github.com/perl6/6.d-prep/blob/master/TODO/FEATURES.md). Then, there's 3000 commits of 6.d spec to review. I started reviewing around Christmas and reviewed 20% of the spec so far. I don't know if any other devs will wish to review the spec before we release—currently I'm the only reviewer. Once that's done, we can cut 6.d. No dates. We're going with "it's ready when we're happy with it".
Perl 5 is not dead. It will live on for quite some time due to all the code that's out there. But the fact remains , Perl 5 is not growing its user base. It's not advancing. It's not. It's not. Everyone who commented on the article is obviously passionate about their language. You can continue to have these wars about Perl6 . It killed Perl 5. It's not a Perl 5 upgrade it's a new language. Continue to do this for 10 more years why don't you , until so much more time has passed that nothing advances. It's now 2028 and where are you now Perl 5? What do you think is going to happen? Perl 6 stops development and everyone goes back to Perl 5? At some point you need to take that leap. It may not be what you want. It'll go against your core beliefs. Perl 6 may not be better than Perl 5. But if there is any chance, any chance for the Perl community to get out of this infinite loop of nothing, is to take be open to Perl 6. It has some momentum. It may not be much , but its 100 times more momentum than Perl 5. The ideas to have Perl 5 run on the Perl6 run time. Why not. The MoarVM is advancing. Why not port Perl 5 modules to Perl 6? doesn't mean you have to use Perl 6. It just opens the door. Your efforts to stop or fight Perl 6 is not going to benefit Perl 5. It's not. How has it gone for you so far? How has this war benefited Perl5 users? Go with the momentum . Not saying switch to Perl 6. But be open to ideas like running on the moarVM etc.. Or stay in your infinite loop of nothingness..
Am I missing something that it has to be done in that order? **Why not get the community feedback *on naming* and Larry's response immediately?** If it does, can you tell us why?
&gt; be open to Perl 6. It has some momentum. Evidence? You need to change the name of your product.
That is your opinion, and I severely disagree, thus in my opinion your continued assertions are harmful.
Running on moarVM would be great, but has nothing to do with whether I would use Perl 6. If Perl 5 dies, I will most likely not move to Perl 6, and that decision would not be based on the name. Trying to pretend Perl 5 and Perl 6 are the same will not accomplish anything. The Perl philosophy has always been pragmatism.
Because it's a complex and highly inflammatory issue, with as many opinions as there are participants, achieving desirable resolution to which has failed numerous times in the past. You can garner that just from the responses you got in other comments on this very post. Delaying the final decision until 6.d sets a definite point when the resolution is to be decided upon and lets people brew their thoughts on the matter. Coinciding the resolution with the second stable language release also gives the decision more visibility. Easy does it.
&gt; Your efforts to stop or fight Perl 6 Nobody wants to stop Perl 6. They just want Perl 6 to not harm Perl 5.
Repeating yourselves is not doing either argument any favors.
As a sidebar, I have always liked this aspect of Perl 6, since I disagree with many syntactical and naming choices, so if I did someday use the language I would probably invest some effort into redecorating it. It's nice that it's possible, but I still begrudge a bit that it's necessary.
exactly my point. Keep the infinite loop going. Helps no one.
I'm not sure of how all Perl 6 is harming Perl 5. If the naming decision caused this 10 years ago, well maybe it was a bad idea. Problem is complaining still not does no one any good. If Perl 6 changed its name to Rakudo and Perl 5 next release is named Perl 7, do you think Google will port all python to Perl 7? Will Facebook dump PHP for Perl 7? Will Perl 7 rise to 3 on tiobe? We both know these things will not happen. So where do we go from here? The author of the article main goal was to break out of the infinite loop we are in . that's all. Moving beyond the naming choices , what do Perl 5 users suggest to break out of the infinite nothingness loop? How can Perl 6 help Perl 5? What are your ideas to break the loop ? 
Products change names all the time. It is never too late.
&gt; All I wanted was to declare a method as a class method method fromIngredients() { } # class method It really can't get much simpler. (This is a repeat of the first line of code in my prior comment since it seems you did not read it.) &gt; and have the code be self-documenting as such. It's in a class. It's a method. It's a class method unless you explicitly declare it to be otherwise. How is it not self documenting? &gt; The static keyword isn't a great choice for this, but it'll do. If you really insist on adding boilerplate, then: subset static of Mu:U ; method fromIngredients (static:) { } # not an instance method
&gt; All I wanted was to declare a method as a class method method fromIngredients() { } # class method I don't see how it can get simpler. &gt; and have the code be self-documenting as such. The surrounding *class* uses a `class` keyword. The *method* declaration uses the keyword `method`. I don't see how it can get simpler. &gt; The static keyword isn't a great choice for this, but it'll do. If you want to reject calling a method on an instance and you like `static` for that, then perhaps: subset static of Mu:U ; method fromIngredients (static:) { } # not an instance method (But why would you reject calling a class method on an instance? What do you gain from doing so? If it really matters that if you call `.legs` on a `Dog` instance you'll get the answer `4` even if that particular dog has only three legs, isn't it better to change the `.legs` method *body* to return the exact number of legs the particular dog has, rather than reject calling `.legs` on an instance? Anyway, if you really, really feel the need to lock a method down so it won't even accept an instance as the invocant, then you can, and almost no one writes `::?CLASS:U` for doing that.)
Calling this language Perl 6 will not do any good to it. Perl 5 people like me have taken a look at it and found out that it is NOT Perl. I have coded in Perl 5 for 20 years and I just do not want to have anything to do with Perl 6, simply do not like it. I'll switch to Python before P6. New young people. There's incredible stigma of old, ugly and 'avoid at all costs' currently about all things Perl among these. Calling your new language Perl just kills all your chances to get these interested in the language. So why, please explain me, why you so insist on calling it Perl ? What is the point, what is the advantage you getting. You can clearly see the hostility your letter brought onto you and P6 from at least Perl community here. Rename, leave us alone and let us release Perl 7 so we can 1) Continue using the language we love with all CPAN modules working (and XS/SWIG/etc) 2) Have at least a chance in a blue moon to start changing this horrible stigma that kills Perl slowly by thousand cuts, robbing people who spent their whole careers coding in Perl 5 of their livehoods. 
The `static` keyword doesn't block you from calling the method on an instance. It says that you can call it without an instance, and it won't touch any instance vars. 
&gt; Budget is not the problem, as far as I know. Finding people able and willing to do the work, is. Liz, lets do this, I guess I did no make myself clear. Can the Perl Foundation sponsor a initiative to find/bring Perl 5 core developers into the game? My small Open Question to the Perl Community: How can we find/bring new Perl 5 Porters to join into Perl development process? 
&gt; do you think Google will port all python to Perl 7? Will Facebook dump PHP for Perl 7? Will Perl 7 rise to 3 on tiobe? None of those things is relevant.
 class c { method foo { } } That's a class method. What a mess!
&gt; Perl 5 people like me have taken a look at it and found out that it is NOT Perl. To be fair, some Perl 5 people have looked at Perl 6 and decided that it IS Perl. I have many friends who have gone this route ([liztormato](https://www.reddit.com/user/liztormato)) is one of them). I can't see it myself, but let's not pretend that everyone sees it the same way.
&gt; Providing an invocant in the method signature ... ... is **optional**. If you omit it, or omit its type, you get the default type. By default a method in a class is a class method. If you write some instance specific code in a method it stops being just a class method and becomes an instance method too. If code is executed on the instance path, you'd better have passed an instance or P6 will complain at run-time. On rare occasions it can make sense to typecheck the invocant at compile-time to enforce use with just an instance, or never with an instance. P6 makes that easy. &gt; The ::?CLASS variable can be used to provide *the class name* at compile time Right. But guess what. **So can the class name**: class foo { method bar (foo:) { } } (I don't know why `::?CLASS` is given such prominence on that page. If your comments in this thread had been that the doc is weak, rather than the language, I'd not have said a word.)
This seems like an excellent suggestion - we have the CPAN PR challenge, why not do the same for Perl? Lots of potential areas of improvement that don't need a deep understanding of the internals.
Constant subs, lexical subs, signatures, bitwise operators, refaliases, key-value slices, various security and performance improvements... but that's just the core, most of the interesting things happen in CPAN (and this is a *good* thing).
&gt; It says that you can call it without an instance This is the default in P6. &gt; and it won't touch any instance vars OK. That's different. One way to write that: class Dog { multi method legs ( Dog:D: ) { self.WHAT.legs } multi method legs ( Dog:U: ) { say "can't silently touch instance vars" } } This is clearly verbose compared to the `static` keyword you're explaining. It's easy to imagine some syntax sugar that improved on this. More importantly (imo) this doesn't stop someone writing code that attempts (and fails) to refer to an instance var. That would require some code that checks whether a method's body contains any such references. I'm pretty sure that could be written as a compile time trait in a userland module that's applied something like: class Dog { multi method legs is static { #`[ checks no references to instance vars] } } 
&lt;holly&gt;That ship has sailed&lt;/holly&gt;
I totally agree. How much different is that from "Place a moratorium on new features, with development confined to maintenance on the current runtime."? Which statement a lot of people appear to hate me for?
So you're saying that having a moratorium on new features in Perl 5, the language on the perl5 runtime, would not interfere with interesting things happening on CPAN. So why don't we ""Place a moratorium on new features, with development confined to maintenance on the current runtime." ?? It would apparently not hurt development of Perl 5 as an ecosystem.
"The ::?CLASS variable **can** be used to provide the class name at compile time," (emphasis added). It does not state that it must be used.
&gt; It's been getting harder and harder to find people able and willing to work on the Perl 5 core. At this moment, there are 3 people paid to work on the internals, and they are responsible for most of the improvements. However, funding these people is becoming harder and harder. No new people have stepped up to work on the Perl 5 internals to my knowledge: they are all die-hard decade long Perl 5 developers. Oh, I wasn't aware that p5p were looking for more people. From observation there at least feels like quite a good constant stream of contributions from allsorts. If I'd been aware more folks were required I'd have applied yesterday.
I believe it *would* interfere. See the current discussion on the async/await keywords for an example. There's a general policy of implementing in CPAN first, where possible: sometimes it's not. Even with a small team of active committers, perl5.porters have been doing a good job of balancing backward compatibility with useful improvements. I have no interest in calling for a moratorium on that valuable work - it'd be ineffective at best, but I'd suggest also somewhat insulting to their efforts. You were asking what to tell people about Perl 5 - CPAN activity would be a good source.
A lot of the comments make is sound as if the mere fact that a programming language with the name 'Perl 6' exists is at the core of Perl 5's problems, and if you could just take back the name, everything would be fine. That's a pipe dream, because the problem is not the marketing, but the technology: A turtle will still be a turtle (old, ugly and slow) even if you name it 'Racer'. If you added proper support for things like types, classes, signatures, etc to Perl 5 (cf Reini Urban's [cperl](http://perl11.org/cperl/STATUS.html) for his shot at this), *then* you could start thinking about how to work around the existence of Perl 6 as far as marketing Perl 5 is concerened - and that is a problem that can be solved. Calling it something like, say, *Perl 5k* might work. 
Maybe this kind of thinking has motivated Perl 11 development . 
That flexibility does seem like it would create a maintenance nightmare for anyone who wants to e.g. fix a bug / add a feature for your code.
Asking for evidence helps no-one? If you were correct, that P6 had momentum, surely you'd be shouting about all the evidence?
&gt; I see it as actually very simple Seems to me if the two of us cannot even agree on the complexity of the issue, it's a much tougher task for hundreds of people to agree on how to resolve it. &gt; I am 100% sure that 6 months, which it's already been, is plenty of time It is. The [blocker](https://github.com/rakudo/rakudo/issues/1289) I pointed to is what's causing the delay. &gt; Wouldn't that then end up getting actioned only on the next big release? No, it'll be actioned on *this* release. [It's](https://github.com/perl6/6.d-prep/tree/master/TODO#language-extended-naming) part of the [6.d release TODO list](https://github.com/perl6/6.d-prep/tree/master/TODO#list-of-todo-items-required-for-6d-language-release) &gt; Can you see that this resembles, even if that's not the intent, trying to defer this critical matter endlessly? I'm not concerned about what the delays resemble. Anyone with sufficient interest in expediting the matter can volunteer to resolve the release [blocker](https://github.com/rakudo/rakudo/issues/1289).
Thanks for clarifying the sequencing! To clarify further, are you saying that the opinion-canvassing can't go on concurrently with deciding something about `$*PERL`?
See the references to being ugly and/or slow. Without proper support at the vm level, less ugly tends to correlate with slower.
&gt; you saying that the opinion-canvassing can't go on concurrently It can and it is. People suggest new names all the time (most recent [40 minutes ago](can't go on concurrently )) and others suggest why renaming/aliasing is pointless or should not happen. I have this post with its comments logged in my list of things about the naming discussion already. What will have to wait until 6.d release is presenting all the salient facts to Larry and for him to decide whether to create an alias and what it should be—picked from suggestions or invented on his own.
I know. The issue is that XS isn't simple, and therefore isn't going to be as simple to translate as pure-Perl modules.
They don't need to be rewritten as pure Perl 6, they can be written as pure C.
&gt; It can and it is. Glad to hear it. Is there some forum where the alternative names are being captured, then voted on? Seems to me like a subreddit (if that's the right name, I'm new) would be perfect, as you could literally just comment them, then they'd be voted on. That would be the most perfectly transparent thing, too. I note (and I'm not trying to single them out, it's just an example) that `stmuk` seems to me to be showing the signs of "motivated reasoning": starting from the conclusion ("don't rename P6") and working backwards from there, with lots of assertions.
You say "slow". Do you have an answer to the "Sieve of Eratosthenes" (I do not enjoy typing that) point? When will P6 get quick at that?
Sorry, I don't get what you're trying to say... Perl 6 can call into C for the same reasons one would use XS to call C from Perl 5. No 0ne here is talking about pure Perl 6 implementations. The difference between them is that XS is a PITA and unnecessary for Perl 6. If XS is doing more than just integration, you write that in C and call that in Perl 6, which is much much much easier than writing XS.
I have never heard about this before. Thanks! So, here is the list for January 2018 - [CPAN Pull Request](http://cpan-prc.org/2018/january.html) 
I'm glad to read this follow up/clarification. I feel better about both projects and the communities that support them.
The part about being slow sadly applies to both Perl 5 and Perl 6. Other dynamic languages competing in the same space have gotten some nice performance boosts over the years, which Perl 5 largely missed out on. That's actually something the Perl 6 redesign was supposed to address (various choices were made to allow better optimizability in principle), but such a performance improvement has yet to manifest in Rakudo in practice. You can write perfectly reasonable Perl 6 code that runs 10x or even a 100x slower in Rakudo than an equivalent Perl 5 version. As to your specific problem about the *Sieve of Eratosthenes*, I'd have to see some code. One possible problem is that Perl 6 uses bigints by default, so unless you added type annotations, that would be an obvious first guess.
I already saw those two threads. They were both discussion. Why not have a new thread with just "What to call the language/environment currently known as 'Perl 6'?"? One option could still be "Perl 6", obviously. You'd have to make clear the rule was only new names, to avoid discussion/flamewars.
&gt; Have the compiler enforce the fact that these methods can't access instance members class FREZIK { method foo (FREZIK:) { } # class method that can't access instance vars } &gt; Give a clear, self-documenting signal to your users that it's OK to call this without an instance class FREZIK { method foo (FREZIK:) { } # class method that can't access instance vars } &gt; The first one presumably isn't where Perl6 is going with it. Why would you presume P6 isn't going some particular place when your P6 "knowledge" is not based on asking P6ers and understanding P6 but rather guesswork after reading docs with a closed mind? P6 is going wherever P6ers take it. Aiui the compiler would enforce the precise formulation you're demanding if someone wrote and used [a compile-time trait](https://docs.perl6.org/type/Sub#index-entry-trait__mod_(declarator%29) that queues a walk of the AST generated for the method that fails at compile if there are any references to instance vars. (Compared to what a mere user can do with most compilers, this is a most remarkable capability.) &gt; If you're going to do the second, then the method of doing it should be easy to read. It *is* easy to read, as shown above. If you want the precise formulation you demand then someone needs to write the checker along with a trait to apply it: method foo is freziked { } # method that's compile time checked as frezik wants
Anyone is free to start one of those, I think. Just no one did.
Sorry for taking the docs at their word.
How does that C code work on, say, the javascript VM? And if you're restricting to places where you have a C compiler, why port anything at all? `use Module:from&lt;Perl5&gt;` and (apparently, never tried it) the module works without any changes. 
Well, if the plan is to let go of the Perl 5 VM, that's does exactly the opposite.
"like me"
May I propose þerl as a new name? (Read: Therl). The "þorn" is just a funny P, reflecting the fact that Perl6 is optimized for fun https://perl6.org/fun/ (and Unicode)
For the future reader, nearly all open source project are always in need of help. If there is something you'd be interested and/or willing to contribute to please ask!
Perl 6 (i.e. no rename)
Done: https://www.reddit.com/r/perl/comments/7rjr8u/new_name_for_perl_6_languageenvironment/
&gt; XS modules aren't a problem. If the goal is to deprecate the Perl runtime, you've also deprecated XS. All of it gets thrown away and has to be reimplemented completely on a new platform. You won't have a lot of CPAN until that's done. What's the equivalent of creating a new SV on MoarVM? What's the equivalent of modifying its reference count, or upgrading it to hold a PV? What's the equivalent of creating a glob, or dereferencing a reference, or populating a hash, or walking the list of pads attached to a CV?
ZofLang :)
Cool. Though you may want to beef up the description a bit for people who haven't read this comment thread to know what's that all about.
Beryl
Could you suggest some text? It would probably want a link to your P6 posting which I can't find.
Llama
Go ahead and add that on the "new name for P6" thread: https://www.reddit.com/r/perl/comments/7rjr8u/new_name_for_perl_6_languageenvironment/
Well, you can always use NativeCall and implement it in C ;) But I agree that this is the real issue here: Often, Rakudo is just too slow. If an acceptable answer to the question *How do I speed up my Perl 5 code?* would be *Port it to Perl 6!*, the discussion we're having would likely look very different. PS: I just took the following Perl 5 implementation of the *Sieve of Eratosthenes* from Rosettacode use Time::HiRes qw(time); sub sieve { my($n) = @_; my @composite; for (my $t = 3; $t*$t &lt;= $n; $t += 2) { if (!$composite[$t]) { for (my $s = $t*$t; $s &lt;= $n; $s += $t*2) { $composite[$s]++ } } } my @primes = (2); for (my $t = 3; $t &lt;= $n; $t += 2) { $composite[$t] || push @primes, $t; } \@primes; } my $N = 5000000; my $start = time; my $primes = sieve($N); my $end = time; print $primes-&gt;[-1], "\n"; printf "%.2fs\n", $end - $start; and translated it to Perl 6 use v6; sub sieve($n) { my @composite; my $t; loop ($t = 3; $t*$t &lt;= $n; $t += 2) { if (!@composite[$t]) { loop (my $s = $t*$t; $s &lt;= $n; $s += $t*2) { @composite[$s]++ } } } my @primes = (2); loop ($t = 3; $t &lt;= $n; $t = $t + 2) { @composite[$t] || push @primes, $t; } @primes; } my $N = 5000000; my $start = time; my @primes = sieve($N); my $end = time; print @primes[*-1], "\n"; printf "%.2fs\n", $end - $start; Perl 5 took about 1.4s, Rakudo needed about 60s, with or without type annotations. That is indeed unacceptable.
Wouldn't it have been better to post this in /r/perl6?
I hate being quoted :) How about just `[...] proposals for new name to help with [alias name decision during 6.d release](https://github.com/perl6/6.d-prep/tree/master/TODO#language-extended-naming)` (linking to the TODO item for alias naming in the 6.d-prep repo)
I'm aware. I don't see it happening any time soon because $drama.
I view it as something that all Perl users have a stake in, hence I chose this, the "all Perl" subreddit.
Capricious ANalytical Tool of Enumerating Repetitive Binary URbane Yaks (Canterbury)
I did this. However, this does leave the problem that all you are proposing is an alias, which leaves unsolved the big problem: not allowing a release of 5.30 as "Perl 30". I'm assuming you are against that?
Damian picked perhaps the most effective way to communicate what he's done so far by focusing on ways his work allows folk to introduce P6ish syntax into P5. But Keyword::Declare et al have the potential to be a lot more consequential in the near term (5 years) than that because it more or less retrofits P5 with lisp syntactic macro capabilities. (They are currently constrained to keywords but note the exchange in the Q+A session at the end.) Thus one can ignore P6 entirely and the work he presents in the video is still very clearly about providing the biggest change since 1994 to P5's practical options for evolving its syntax.
More light without heat! Awesome.
What would it need to enable a reunification of cperl back into perl?
I appreciate your perspective on this Zoffix, and I hope more of the community shares it, but I think the author's intent was clearly shown to be how we interpreted it in the followup in the #perl6 channel and the reddit post.
While we have a stake in it not being Perl 6, many of us have no stake in the language, so I would prefer the Perl 6 community choose their name.
&gt; A lot of the comments make is sound as if the mere fact that a programming language with the name 'Perl 6' exists is at the core of Perl 5's problems, and if you could just take back the name, everything would be fine. That's a bit of a projection; I don't think anyone has claimed that Perl 6's name confusion is the only reason Perl 5 is not the popular kid.
Verify that cperl is actually able to deliver on its promises. Decide if this is the direction the Perl-community wants to go. Get over the fact that rurban thinks the current p5 maintainers completely incompetent and isn't shy about that opinion.
As a start, Reini would need to stop insulting the entirety of p5p at every opportunity.
Q6 or P++
&gt; Running on moarVM would be great, but has nothing to do with whether I would use Perl 6. Yes, and those who wish to stick with P5 shouldn't have to write P6. Based on my read of her OP and also her follow ups in this thread, that was actually a big part of Lizmat's thinking in the OP. But that has very clearly gotten lost in the telling. (Understatement of the century.)
Full rename to allow release of a future version of Perl 5 as Perl 7+
Fair enough that this is your preference. I have added an option of "full rename".
I'd like to see the behaviour of `cperl` available to `perl` with a CPAN module. Perhaps it's an impossible dream!
But what would that help? What has fundamentally changed with Perl 5 since the 2000s, when Perl 6 was envisioned as the cure to its ailments?
Interestingly, your thought underlines the fact that P6 and P5 are genuinely separate languages. I am sticking with the thought that stakeholders (those with a stake) should participate.
A new version was (sort of) announced! So a lot of (business) people waited until it came out before doing things. A long(, long, long) period of time passed, during which the people waiting gave up. That's the fundamental change.
What are some features that could be considered game changers? Bug fixes are nice and all, but won't help you regain mindshare...
&gt; Interestingly, your thought underlines the fact that P6 and P5 are genuinely separate languages. This is, as far as I can tell, an undisputed fact among anyone who actually has looked at both languages.
Or highlight the quoted passage before you hit the `reply` button, and it'll quote that part automatically.
Subroutine signatures are very close to becoming non-experimental (one of the last blocking issues is being resolved in the next development release, which means it may be possible to make them non-experimental in Perl 5.32). However, I'm not really sure why regaining mindshare needs to be a priority.
ArrowLang.io (io for being trendy?)
&gt; But I agree that this is the real issue here: Often, Rakudo is just too slow. FWIW, it's often helpful to drop code that's uber slow in [an Issue](https://github.com/rakudo/rakudo/issues/new) so core devs could examine it and see what can be improved.
Quark
XLang
I would say that the pluggable keywords API is, single-handedly, the most interesting feature added there. While it isn't useful *on its own* to end users, it gives CPAN authors (of whom myself and MAUKE are just two examples) the ability to experiment and create new core-like features purely in CPAN modules. This is where a lot of the attention has been for a while now - things like my Syntax::Keyword::Try or Future::AsyncAwait, or MAUKE's Function::Parameters. In the latter's case it has been one of the driving factors in eventually getting those signatures supported in core, and in the former two cases of my own they're still pushing development by adding new features needed to support them into core. You might argue that since they're CPAN modules, they're not part of core. That is technically true, but it fails to take account of the very close association between those modules and the perl core. The **deep** level of integration that these modules (the async/await one especially) have to perform with the core in order to let them work almost makes them part of core, part of core development, while not forcing the developers of such to have to commit their lines into perl5.git, not (and this is the crucial part) forcing every user of perl into that particular implementation. In effect, the pluggable keywords API turns CPAN authors into p5p core developers for free. These modules become a testbed, a way for CPAN as an ecosystem to experiment with what as a whole we feel might be useful behaviour, syntax, features, whatever. Once an idea converges these can be pulled back in as core features if the group as a whole feels it worth it - as already happened in the case of Function::Parameters becoming signatures, and I hope to look into sometime this year for the try/catch syntax. I humbly submit that perl 5 core development is verymuch alive and well, it's just that the vast majority of lines of commit to it happen on CPAN modules, not perl5.git directly, so it might be harder to see that from the outside. Perl 5 necessary has to work this way due to the huge amount of existing deployment across the world and accumulation of code. We can't afford the easier methods of experimentation that the greenfield Perl 6 can use because of its much smaller existing codebase.
On a related note, I might resume tracking the [performance of string operations](https://gist.github.com/cygx/9c94eefdf6300f726bc698655555d73b#file-graph-md). Not much was happening over the last six months, but I saw a nice improvement between 2017-12-01 and 2018-01-17. I'm keeping my finders crossed that's indicative of things to come ;)
Well you can cut that by more than half by using a buf8 instead of an Array. It implements Positional, so you just have to change the sigils to scalar (which actually looks quite confusing). But as for the rest... no idea. I played around a bit with sieving a buf8 in memory, and that is *only* 10 times slower than the perl5 code. But then to quickly traverse that buf, I'd need to do a loop over it (which is extremely slow) or treat the buffer as an ASCII string and let the regex engine do the magic. But in my version those conversions don't seem to work. (And there's no Buf.subbuf-rw, so I can't generate larger wheels dynamically, which is a bloody shame).
Please don't call out users to complain about downvotes. Downvotes are anonymous, so you have no information to imply anything about another user. This is rude.
What will be the alias name for Perl 6? Is it rakudo?
Yes, that was a component of the post. That is not the component of the post that most are responding to (however, there was a response to it on p5p, which is much more qualified to comment on the validity of that proposition).
I thought rakudo already sticks.
Thank you.
That's an interesting datapoint. Using my @composite := buf8.allocate($n); will significantly improve performance, whereas my uint8 @composite[$n]; (which is what I had already tried instead) will not.
To be clear, I wasn't complaining about the downvote. I respect the right of folk to just downvote to express their opinion. I respect their right to do so anonymously. I still do not know who downvoted me, nor do I care about it (nor downvotes in general), nor would I had have been upset if grinnz had chosen not to reply, just disappointed. I hoped /u/grinnz might be willing to be more forthcoming if in fact they had seen my comment, and would understand that I did not care about the downvote and that they do not need to reveal whether or not they downvoted, and indeed that is the outcome. I note that you consider my action in this instance rude even though I considered it polite; I note that you are the moderator and I a mere commenter so your view prevails; I trust that you accept I am not intending any rudeness in this comment; and I thank you for moderating /r/perl.
That's awesome, as I don't recall anything string-specific going in in the past month :) There's definitely lost of unconquered perf land still to explode. The [pure-NQP version of the *Seive*](https://github.com/rakudo/rakudo/issues/1421#issuecomment-359065388) runs in just `0.49s`, so I'd imagine there's plenty of headway can be made to chop down the `60s` pure Perl 6 version takes.
I suggest that Perl 6 be renamed to either Camelia or Rakudo.
Rakudo
&gt; Porting Perl5 to a modern VM, treating it like one of the many platforms Perl5 already supports, seems like a good idea to me. When all the modern VM brings to the table is being 10 times slower, I am not so sure it is a good idea.
Oh come on people...why are you downvoting the post? If you don't want it to be renamed, then upvote the "no rename" reply. 
It'll get better. In the meantime, you can still run it natively like you do now.
Kyō (興, Japanese for joy/fun/delight)
Yes. This is the fastest I could come up with: sub sieve($n) { my buf8 $composite = buf8.allocate($n); loop (my $t = 3; $t*$t &lt;= $n; $t += 2) { if (!$composite[$t]) { loop (my $s = $t*$t; $s &lt;= $n; $s += $t*2) { $composite[$s] = 1 } } } gather { take 2; loop ($t = 3; $t &lt;= $n; $t = $t + 2) { $composite[$t] || take $t; } } } 7.7s on my machine. The gather avoids extending and pushing on an array, so that saves a little bit too. For reference: the perl5 version does it in 0.29s. Were this perl5, I'd now try to inline as much as possible because the most expensive thing in perl5 (after methods) is entering scopes. But I have no experience about what makes MoarVM code slow or fast. 
I wonder how Larry feels about all of this
&gt; I wonder how Larry feels about all of this. See https://www.youtube.com/watch?time_continue=4885&amp;v=E5t8qaAGw9w
Well that about settles it for me. I don't have the expertise to contribute to the sort of modules that would make using Perl 6 a reality for me, but if it ever gets to the point where I can develop real world web applications easily and reliably the same way I can in Perl 5, I'd be happy to invest as much time as possible in porting my application logic over. But until then, I'm going to have to stick with Perl 5 as my language of choice
Glad to hear about the alias. Hopefully Perl 5 porters will use it as chance to release most recent Perl 5 as Perl 7 with add best 'modern perl' modules added into core so the community can market it as a new page.
That's fine :) Give it a whirl some time in the future. For Web, [Cro](http://mi.cro.services) is what the cool kids seem to use.
&gt; I would like Perl 6 to be able to become backwards (or sideways..seeing as Perl 6 is not Perl 5's descendant) capable so that it can use Perl 5 modules It already can.
Q) Who, outside Perl, know what "Rakudo" is? Surely, by rebranding, the odds are the "new brand" will be obscure and unknown like Rakudo is. And for the "in group", the new brand won't take hold, and they'll still refer to it as "perl 6", creating confusions when they interact with people who don't know "perl 6" and "$newnamehere" are the same language. Same crap happens with business rebrands: They cost *millions* if not *billions* of dollars to do. And yet, despite our local National Telco rebranding from "Telecom" to "Spark", you still have a regular case of people referring to it as "Telecom". And we also have "Shell" stations rebranded as "Z", but in everyones head, the word for that yellow fuel station is still "Shell". You might find you have to work for them before you encounter the "right name" frequently enough for it to stick. But for your target audience, all you've done is add another hurdle in brand adoption: By confusing both your potential clients and your existing ones!
Q is P+1.
Yep, next letter ....
just 6. Here are 6 reasons. 1) No reason a programming language has to match (A..z)+ 2) Identifies a language that is a constant (as opposed to a variable) 3) Is more likely to be distinct, recognisable, and mark a radical difference in other programming paradigms 4) Perl 5 fans will know it is derivative of Perl, Perl haters will say "Pheww..at least it's not Perl." 5) A Butterfly has 6 legs, as does Larry riding a camel. 6) Lastly, in Swedish it is "sex", and who doesn't like Swedish sex? 
6lang (pronounced Slang)
As in Beryl the Per(i)l. Why has this suggestion been downvoted so many times? Sheesh
Granted to an extent I'm somewhat missing the days where "Perl is Dead" or "Perl is dying" and we just decided not to care about it, because it was irrelevant. Lets take a smaller language, like: `sed` `sed` is ubiquitous. Its hardly talked about as the hot new thing, it hardly ever changes, and nobody cares. From the perspective of fashion chasing modernista's: &gt; seds dead baby, seds dead. ( And I want it on a shirt ) But its *objective* utility to every systems admin worth their salt is hardly disputable. So yeah, I don't really want to change the branding we use behind Perl at least, that was a fools errand that's only made Perl 5 worse: Trying to keep up with the Jone's and be cool is a betrayal of what Perl is supposed to be. If anything, we should be doubling down on the "Perl is boring and never changes, its dead, and dead is an asset". Not being fancy because managers are not smart enough to adopt something that was made longer than a month ago ... 
To declare a method as being a private method you use `!`, to declare an attribute as private you use `!`. To call a private method you use `!`. To access the private (actual) instance attribute you use `!`. When you declare an attribute as being public, a method of the same name gets generated. Which you can then call the same as a public method with `.`. So using `!` and `.` to declare private and public attributes is both short and consistent. When you are accessing the actual (private) instance attribute (so you can change it even if it isn't marked `is rw`) you always use `!`. If you want subclasses to be able to intercept the access, you use `.` so that it calls the generated public method instead. (Technically `$.foo` will always call the method `foo` even if there was never an attribute `$.foo`)
You are wasting your time.These are Larry Wall’s languages and he gets to name them, not you.
This could probably catch on. I really like it! It was mentioned in this blog post: https://rakudo.party/post/6lang-The-Naming-Discussion-Update#the6lang
Or even "Peril 6"! We could send out stickers with an "i" on for people's books etc. or they could just write the "i" on in biro!
Yes, I forgot where I had seen it, thanks for the source.
`::?CLASS` `::?PACKAGE` and `::?MODULE` replaces `__PACKAGE__` from Perl 5 (With the addition that it isn't just the name). There is also `$?FILE` and `$?LINE` which replaces `__FILE__` and `__LINE__` Notice that there is a consistency that compile-time values have a twigil of `?` A class with `:D` appended to it marks it as only accepting defined values, `:U` for undefined, and `:_` for the default of accepting both. So `42 ~~ Int:D` returns `True` while `42 ~~ Int:U` returns `False` If we were writing `Int:D` inside of the `Int` class declaration we can use `::?CLASS:D` which would allow us to copy it wholesale into another class without changing anything. (so you don't need an IDE) Note that `Int:D` (and `Int:U`) is actually a value that you can pass around. (Which means `::?CLASS:U` is too) my $a = Int:D; my $b = 42; say $b ~~ $a; # True Which means `::?CLASS:U` is **not** a special case that only works for the definition of class-only methods. Is there another language that doesn't have a special case for marking class-only (static) methods, and instead reuses another feature?
If there was another language that was more Pythonish than Python, it would never be anything more than an also-ran. I mean why would you use something that is basically Python, but with fewer modules when you could just use Python? This is basically the problem Python 3 has been trying to overcome. Instead, how about we try something unique, and possibly make a new niche. (I don't know of another language that brings in useful features from many languages and brings them together in a similar way as Perl 6; so there is our niche)
To add to that, I can think of few things more perlish than to have arcane punctuation represent features and changes in behavior. https://perldoc.perl.org/perlvar.html
Like C++, and C, and C# and F#, and R...
I don't know of another language that brings in so many features from other languages and has a class-based parsing engine baked in.
p6
Oh, silly me. I forgot about those. That completely disproves my point. /s
That's an interesting take. I wasn't NUTS about the "dying language" narrative, but I had gotten used to it. I think the frustrating thing about this is it goes from dying a natural death to something that feels more like a -- dare I say it? -- "death panel," to clear the decks for the brave new future. Now I realize there was a post today that says that's not what's happening. But it feels the way it feels.
That's why Go is often referred to as Golang now. Examples don't prove or disprove an abstract idea.
And he will. Based on the description, this post is collecting community favourites for [the alias](https://www.youtube.com/watch?time_continue=4885&amp;v=E5t8qaAGw9w).
It's a new language, and it is also Perl. Perl, since it's very inception, has been about bringing together features from other languages. Perl 5, for instance, brought in the object system of Python. Perl 6 does this to a much greater degree while making the syntax more consistent where it should be consistent, and less consistent where it shouldn't be (`eval "…"` and `eval {…}` for example are now `EVAL "…"` and `try {…}`). Frankly, I think it would have been a mistake to release it even a year earlier, as that would have left it as a significantly worse language than it has become. (pre-GLR)
Of course they can. "All sheep are purple." "Nope. Here's a white one." Anyway, just like you can google F# stuff, you will be able to google P++ stuff (if the name catches on.)
"All sheep are purple" is not an abstract idea. It is a concrete one. An assertion of fact. Do you not know the difference between abstract and concrete? Here is a hint: they are opposites. Your analogy is not valid. A more appropriate analogy would be if I had said, "sometimes sheep don't look white" and you said "but there many white sheep". You haven't proved or disproved anything.
Imagine the damage that will be done to the brand that is *Perl* if its newest incarnation drops it as a brand. What's worse is Perl 5 can't drastically change its name without potentially losing one of its strongest selling points, backwards compatibility. (at least from a manager's viewpoint) So just changing the name may damage Perl 5 more than keeping it as it is. Perhaps the best way forward is for both to come up with secondary names, and agree to start aggressively promote both secondary names at some future date. Maybe v6.d and a version of Perl 5 could be released on the same day the promotion starts. Then we could have a combined announcement of new versions and new alternative names. I think this would do a great deal to show that neither language is dead or dying, and might be enough to quell some of the other misconceptions. It would need the support of the whole Perl community, and for the constant bickering to stop. So probably won't happen, but one can dream.
&gt; What are some features that could be considered game changers? Because so much of my perl development is for cpan (where backwards compatibility is paramount), and most of the rest is for my employer which is still on a somewhat oldish version for various reasons, I do not pay a lot of attention to Perl's recent features... Instead, I value it for "*making simple things trivial, and difficult things possible*".
Who is Holly?
Moose is very widely used in production. By what measure is it a failure?
I don't think it is a non-starter per se. The attempt most likely will be extremely difficult if the goal is to preserve the entire perky feature set. Perl 5 language is tied to the way it is written, any attempt of rewriting will involve a discussion of language normalization, ie. breaking changes. That , is a non-starter. Rather than moving to a VM, I wonder it is possible to develop an optional JIT, even for a very narrow subset of the op tree, e.g. arithmetics involving only simple variables. It can be developed as a optimization option that can be eventually scaled up. 
This is essentially what perlito is.
XS is a hack into perl's internal structure. It can be used to interface c library at large is merely a side effect. Perl chose XS for its (camel) philosophy of effectiveness at cost of esthetics. With VM, the same philosophy will produce a VM XS equivalent. Of course it is possible to implement without XS, either with extra API factory (the Java way), or skip the hacking feature altogether. Either way, it will not be the same perl . 
Python 4.
Actually I was review his comment of "treating it like one of the many platforms Perl5 already supports" and was thinking porting the perl's C code to Java is probably doable. It will run on JVM, with its JVM XS interface. The code will be interpreted on top of Java byte code. It is funny just thinking about it -- but I guess it is no funnier than people want to compile firefox to run in chrome.
Along those lines... https://gfx.github.io/perl.js/
Good to learn! thx.
Yep, I'll check again after another 15 years.
Making it "official" is not what will determine how difficult it will be to Google. Its popularity will. 
Okay, thank you and good luck with your niche.
Inline perl 5 is amazing 
That's fine! 
Roku It's a four-letter word. It's Japanese for "six". It's similar to Rakudo.
þerl
Done!
Thanks!
[removed]
&gt; In effect, the pluggable keywords API turns CPAN authors into p5p core developers for free. And I welcome that. This comes much closer to the model that Perl 6 is using. A Strawberry Perl 5 Project would also be "just a module" that one can load when necessary. `Inline::Perl5` already **is** such a module. &gt; I humbly submit that perl 5 core development is verymuch alive and well. If you're going to include CPAN development as part of the core of Perl 5, I'm going to disagree with you. Having said that, if that is *your* definition of Perl 5 core development, I *would* be against a moratorium on Perl 5 core development. From my point of view however, I would consider changes to the core of Perl 5 that you would need for such experimentation in module space, very close to maintenance, and thus not affected by a moratorium.
Time will tell
&lt;holly&gt;That ship has sailed&lt;/holly&gt; In case you don't get the reference: https://youtu.be/nyKF2qd0-iQ?t=184
Am I reading correctly here that the NQP version is already faster than the Perl 5 version???
Perm.
So you benefit most from Perl 5's stability, not its new features. Which is, what **I** think currently most of the redeeming features of Perl 5. Which I propose Perl 5 Porters should focus on.
These are **not** additions to the core language. These are **not** part of the Perl 5 core. In fact, I would say these are prime examples of people trying to backport Perl 6 features to Perl 5 and failing.
https://youtu.be/nyKF2qd0-iQ?t=184
Yeah, like 2x-3x faster.
&gt; A large amount of XS modules are not for interfacing with C libraries. They are for interfacing with the Perl source code. These cases should be easily handled, because Rakudo Perl 6 has great introspection capabilities. Case in point: `Sub::Name`: http://modules.perl6.org/dist/Sub::Name:cpan:ELIZABETH/lib/Sub/Name.pm6 Note that most of the complexity in those 14 lines of code, is handling the fact that `Pair`s are first class citizens in Perl 6 (so `"a","b"` is different from `a =&gt; "b"` in Perl 6). The fat comma in Perl 6 is a constructor for a pair, not an indicator for the compiler to create a list where the left hand side is auto-quoted.
I will address points in the response separately to allow for better focused threads. &gt; XS is a series of macros and functions that expose the internals of the Perl VM and (some/most of) its APIs. In Perl 6, functions that expose the internals of the VM, are mostly part of the language, in that they are exposed as methods on the MOP (Meta-Object Protocol). For instance, suppose you want to find out the **name** of a variable that is being passed to you in a subroutine: ` sub the-name(\a) { a.VAR.name }; say the-name my $foo; # $foo say the-name my @bar; # @bar` You don't need to have any XS for that in Perl 6
https://en.wikipedia.org/wiki/XY_problem
Fixed. Just had to move this out of the loop: $pdf-&gt;update(); 
This code ran for 10.8 seconds on my machine, unaltered. I've changed the code a bit to circumvent many of the known bottlenecks at the moment. This puts the code now at 2.3 seconds (on my machine), or roughly 4.5x as fast. Still 6x as slow as Perl 5, this is true. sub sieve($n) { my buf8 $composite := buf8.allocate($n); my int $t = 3; while (my $q := $t * $t) &lt;= $n { unless $composite[$t] { my int $t2 = $t + $t; my int $s = $q - $t2; $composite[$s] = 1 while ($s = $s + $t2) &lt;= $n; } $t = $t + 2; } my int @result = 2; $t = 1; @result.push($t) unless $composite[$t] while ($t = $t + 2) &lt;= $n; @result } Actually, this code uncovered a bug, which I just fixed: https://github.com/rakudo/rakudo/commit/efed4105da . Why is my version faster: well I looked at the --profile output and saw several pieces of code not getting optimization and worked around that. Over time, spesh and JIT will take care of more and more of these cases and provide performance improvements without you having to think of it.
Who attempted to make Moose part of the Perl core? MOP is the attempt to write something coreable, and the coring has not been attempted yet.
It hardly seems appropriate to be proposing design strategies for a group you are callously dismissing all of the contributions of.
Perhaps I am. But we won't know unless we try, right? My example was indeed a trivial case. More complex cases will require more effort, indeed. But if you compare the [Perl 6](http://modules.perl6.org/dist/Sub::Name:cpan:ELIZABETH/lib/Sub/Name.pm6) code with the [Perl 5 code](https://st.aticpan.org/source/ETHER/Sub-Name-0.21/Name.xs) I'd definitely would like to maintain the Perl 6 version more than the Perl 5 XS version.
Sorry, let me rephrase again: "But attempts to make it something more coreable have failed miserably, multiple times." The result is the same: Moose is still not part of Perl 5 core. Whereas that **was** the ultimate goal of MOP.
I read the letter and most of the comments here and realized there's nothing I want to say that I didn't already say two years ago in [Perl 5 and Perl 6 are mortal enemies](http://www.dagolden.com/index.php/2589/perl-5-and-perl-6-are-mortal-enemies/).
&gt; You don't need to have any XS for that in Perl 6 That's irrelevant. NQP exposes a MOP, but that has nothing to do with millions of lines of XS code that call, for example `SvGROW` or `SvIOK` (see [perlapi](http://perldoc.perl.org/perlapi.html). What's your plan for dealing with those macros? What preprocessor will be in place to parse arbitrary C code which also uses XS macros, and what's the translation layer between the effects of those macros (including macro expansion side effects) and whatever NQP exposes in its MOP? &gt; We already have a DBIish that uses NativeCall quite extensively. That's irrelevant. Does it support, for example, `PrintError` and `RaiseError`? If not, that's a lot of code that either won't work or will need to be rewritten to use the new API. &gt; the original author did not want to repeat the mistakes he made when he developed DBI in Perl 5 If the "new" DBI is not 100% feature compatible with the existing DBI, it will break existing code. Does DBIish provide a 100% compatible version of `looks_like_number`? Does DBIsh provide an implementation of the `ChildHandles` attribute with its weak reference behavior? Does NQP/Moar support weak references? How *exactly* is lexically-scoped reference counting implemented with NQP/Moar? Is timely, lexically-scoped destruction no longer a thing? Is every scope in this hypothetical reimplementation required to have enter and leave guards to provide timely destruction semantics? How does this interfere with any theoretical escape analysis or lifetime hoisting or box elision performed by an advanced optimizer? Won't that slow down every basic block because of the memory model mismatch between the semantics of Perl the language and its new VM target? &gt; If you were, why are you not participating in the CPAN Butterfly Plan? Because I think it's a terrible idea with ill-defined parameters, an incredibly difficult technical challenge chasing down bug-for-bug compatibility, no clear understanding of the goal, and a huge waste of time and energy. Once you have a workable parser for the C language, extend it to parse arbitrary XS, support `ppport.h`, then you can get into interesting semantics like supporting the global value of `$/` or `$.` or even `$&amp;`. You can figure out the right way to support multiple MROs. You can get `INIT` and `CHECK` and `BEGIN` all firing in the right order and the uplevel semantics of `import` and `$^H` correct. You can figure out how to modify the regular expression engine to support `/d` operations and how to enable the `re` pragma, including `debug` mode. Oh! Don't let me forget about thread support, or `-DDEBUGGING`, or the fact that XS lets you temporarily swap out the C function pointer for opcodes created during the rest of the lexically scoped parsing, which makes things like NYTProf and Devel::Cover work. That's only a few of the things I can think of off the top of my head that either work or they don't, and if they don't work, you suddenly have millions of lines of code right now that don't work, but at least you've wasted a lot of time and energy getting to this point. &gt; And you want to infer that I'm clueless about marketing? You're putting words in my mouth and I'd rather you don't do that, but I'm flat out saying that I don't believe you understand the problem. &gt; What have you done for Perl marketing lately? I've written a couple of posts here about why I think your idea is misguided, uninformed, incredibly wasteful, and otherwise harmful. &gt; I think I at least deserve a little bit more respect from you I've given your proposal more time and respect than it deserves. &gt; You'd rather want that we stop selling your book? I've given it away from the start.
&gt; It'll get better. How? The platforms are fundamentally incompatible at the memory level. Either you throw away all XS code entirely (how do I twiddle bits in a bitfield in multiple compatible structs in NQP?) or you reimplement the semantics of one platform on another (how do I model reference counting and weak references and timely destruction in an actively garbage collected platform?). I started to address the latter for `Inline::Parrot` (and that was going the *easy* way). This is difficult work.
I have already figured out that you give very little consideration to concerns of others and only interested in pushing your own agenda. Not be be surprised to be repaid with the same coin.
Re: Re: "This mirrors the conversations about CPAN for Perl 6 and the way that was imposed on Perl 5 to Perl 5's detriment..." -- Okay, "impose" may not be the right word, but that's what it looked like from the outside. I admit that the wider Perl community is absolutely terrible about communicating things that affect the community as a whole. Re: "... to Perl 5's detriment" -- When the Perl 6 distributions started appearing on PAUSE (first with `PSIXDISTS`, then in the `Perl6` directory), it caused quite a stir: Sites like MetaCPAN, and services like CPAN Testers were not ready for them. I wasn't involved with toolchain things at that time, so I don't really know what was done to communicate that Perl 6 dists would be appearing on CPAN. All I saw was the Perl 5 toolchain group grousing about the emergency patches they needed to make to fix the problems with non-Perl-5 distributions being released to CPAN. The Perl 6 community needed something (a library distribution network), and the Perl 5 community was forced to do work (fixing code that assumed CPAN was for Perl 5). And there's why I used the word "imposed": All I saw was the result of the change to PAUSE to accept Perl 6 uploads, and nothing about the development that led to it. I remember no news, no announcements (not even after-the-fact), no communication about it. The change was released to production without comment, fanfare, or warning. In that regard, your post is great: You're announcing a development project and inviting collaboration. We need more of that. And since it's on Perl.com, the Perl communities can expect it to be common knowledge for community members. We need some kind of community announcement platform, and I really hope the Perl.com re-release is the beginning of more open communication in our communities (but, considering the nature of some of the comments here, I fully understand and accept that it will not be, that open communication is difficult and fraught with peril, that there are some deep wounds in our community, and that makes me very sad). Re: "Re: "some benefit from this melding of communities" You can't force communities to meld. Communities consist of individuals who make choices." -- This is true, communities are not joined by force. They're joined through common cause and shared experiences. And that's one reason, I think, why your post received the response it did: The Perl 5 community has had different experiences than the Perl 6 community, and since the two communities have diverged for so long, those differences are wider than one might think. Both communities have different opinions of the other project's history and future. If we want to work together, we need to be conscious and accepting of these differences. "Your project will never be important" is a terrible, hurtful thing to say, as is "your project is at its end". Telling people their work is meaningless is no way to convince them that other work will be more meaningful. Clearly from this thread, both projects' communities are terrible at this. The free software community as a whole is terrible at this, so we're in good company. So, we've all got to do better. Not technically, but socially, communally. It's going to be difficult, but we can't keep losing community members through insensitivity and perpetuating flame wars. How many contributors did we lose to this reddit thread? How many potential contributors saw this argument and will never consider us again? In the end, it won't matter which project is technically superior if nobody's left to give a shit.
Camelia
&gt; This is, as far as I can tell, an undisputed fact among anyone who actually has looked at both languages. I'll direct your attention to the blurb for this very subreddit: "The Perl Programming Language, including both Perl 5 and Perl 6."
&gt; Someone commented that no new Perl 5 feature has been successful since LW began work on Perl 6. That's an odd statement. I'm thinking Moose, DBIx::Class, Mojolicious, NYTProf, defined-or, substitute-and-return, pluggable keywords, foldcase, named captures, hash complexity hardening, the feature pragma, lower memory use, Plack/PSGI, Test::Builder, cpanm, and a few more things I use all the time. (Yes, I deliberately mentioned CPAN modules at the start and end. Understanding why is left as an exercise for the reader.)
I certainly understand that's a fear of the Perl 6 community. I'd describe it, perhaps along these lines: &gt; Perl 5 enters rapid decline as companies and sys-admins shift to newer languages and its aging community starts retiring. Perl 5 developers still in their employment years jump to new languages with better economic prospects and stop participating in the community. With the most promising converts and future volunteers gone, Perl 6 struggles to attract interest and resources, demotivating existing Perl 6 developers. While a committed few keep hacking on it, the broader tech world forgets about it.
&gt; Someone commented that no new Perl 5 feature has been successful since LW began work on Perl 6. I know of at least one person who [pushes this narrative](http://perl11.org/blog/p5p-incompetence.html). &gt; I suppose that memory management and concurrency would be the two features that would make me switch, assuming comparable performance in the common use-cases. A far as I can see, Perl 6 does indeed have the better concurrency story to tell. Performance, however, is still an issue, and it is an open question if the theoretically achievable speed-up will manifest in practice any time. The fact that NQP or, in some cases, even Perl 6 code can outperfom Perl 5 show that the potential is there, but that has been the case since the Parrot days when people got excited about PIR microbenchmarks...
I really hope that subroutine signatures will work out fine, so far it's looking good. That's also one of the must-haves. Other things where Perl 5 really needs to improve: * The string/bytes distinction. There is simply way too much that can go wrong here at the moment, with accidental concatenation of strings and bytes leading to encoding messes all over * A good syntax for classes and attribute, in core. Yes, "in core" matters, otherwise your project ends up using Moose, Mojo::Object, Mo and Moo all in the same process (brought in through different dependencies), and that simply isn't a productive state, nor good for teaching and marketing * a better concurrency story (yes, that's something where Perl 6 really does do better) On the meta level, I get the impression that Perl 5 lacks a coherent vision and steering in the language development process. But, not being subscribed to p5p, that might not be the case, and it simply isn't communicated to the outside well enough for me to pick it up.
I can see the point in naming some of the CPAN modules as language features, but DBIx::Class? I know of no other community where an ORM, even a good one, is celebrated as a language feature.
To be a little more fair about PIR microbenchmarks, the point (which was often missed, yes) was that the overall architecture of the system allowed a theoretical maximum performance much higher than the theoretical maximum of Perl's implementation at the time. If and when that new architecture could use the modern optimization strategies you can find in a JVM or JavaScript VM, further improvements would be possible.
Regarding the communities: I could not have said it better.
&gt; But, not being subscribed to p5p, that might not be the case [Judge for yourself](https://www.nntp.perl.org/group/perl.perl5.porters/2017/12/msg248481.html)
At least some of [Perl 6's colonpair shortcuts](https://twitter.com/zoffix/status/839807414211854337). Boolean ones in particular. This is the one thing lacking I notice right away when switching from Perl 6 to Perl 5 code because its lack makes my code a lot more verbose.
Agree with the notion that if p5p do something like bumping the major version it must be taken extremely seriously. My comment just expresses my support for such move should p5p consider to do it. Moving to P7 with use strict and warnings by default, sub signatures, Moo/Moose/Mouse included into core and market this as 'Modern Perl' with full compatibility with P5 CPAN is something I personally would like to see. Will it help to start reversing the damage Perl is suffering currently ? I don't know, but it should be a good start. Too many nice features had been added to P5 in recent years and they are not really visible from outside and bumping the version/books/blogs/and may be something new in the machine learning area for perl ? (one can only hope) should help. 
Couple random notes not intended for discussion: [Japanese word rakudo means comic in English](https://translate.google.com/#ja/en/rakudo) according to trans.google.com; perhaps 'kudo' is as attractive as 'rakudo', especially if folk prefer to keep 'rakudo' for the compiler.
Thank you for your thoughtful comment. It is refreshing. &gt; The Perl 6 community needed something (a library distribution network), and the Perl 5 community was forced to do work (fixing code that assumed CPAN was for Perl 5). The Perl 6 community already had an ecosystem operational, based on GitHub. It was felt at the QA Hackathon in Lancaster that it *if* Perl 6 would not use CPAN, the two communities would divert even further and there would be no chance of joining them ever anymore. One of the problems of PAUSE at the time (which has since been fixed by the work of Kenichi Ishigaki), was that there was no development system on which things could be tried out. There was only the live system. I assume everybody will agree that that is not an ideal situation to be in. On top of that, that piece of the code base was about 20 years old at the time. And there were no tests. I agree there has been insufficient communication. I am not sure that that can be blamed on Perl 6. &gt; a terrible, hurtful thing to say, as is "your project is at its end" Point taken, although I don't think I quite said it like that. I have used perl5 (the runtime) for over 17 years on a daily base for a living. After that I have worked with / on Perl 6 for almost 5 years now, of which the last 3 years with MoarVM. And I must admit, things were **not** looking good when Perl 6 was still based on Parrot. It only really started to get much better as soon as MoarVM became available. And now with MoarVM maturing, things are really going to get better. In another thread, Zoffix showed that a sieve of Erastothenes written in NQP, is between 2x and 3x as fast as the one written in Perl 5 (running on the perl5 runtime). In the end, it is *that* type of speed improvement you should be expecting from running Perl 5 on an NQP / MoarVM based backend. I don't think I'm too pessimistic when I say that we cannot expect such type of speed improvement from the current perl5 runtime. Am I wrong? I also feel a bit that you're blaming the messenger here. The opinion that the perl5 runtime is nearing its end of life, is not an opinion I developed by myself, but is an opinion I formed after having used perl5 for 17 years, being subscribed to p5p for over 15 years, and having been in many on and offline discussions with current and former p5p members, and which is shared by at least a number of current p5p members. Let me stress here, to make this absolutely clear, this is **NOT** about Perl 5 as a language. The idea of being able to run Perl 5 code on anything other than the perl5 runtime, may be strange to many long-time perl programmers. But I hope that once one gets passed the initial WAT, it should just be a matter of DWIM. I mean, if you're transporting goods from A to B. Does it really matter if the truck runs on diesel, or is electrical? All that matters is that it gets from A to B in time and is in good shape, right? &gt; In the end, it won't matter which project is technically superior if nobody's left to give a shit. Very much indeed. Let's work together to that end!
You're not wrong, Walter, you're just an asshole.
Thank you. I'll take that as a compliment. :-)
Saving Perl 5 from the death by thousand cuts is a possible future experiment.
Everything in cperl
*
This is not intended as another PONIE project. A Butterfly Perl 5 Project would do a clean room re-implementation of the Perl 5 **Programming Language**. It would not attempt to do XS as far as I'm concerned. Most user Perl 5 code out there in the world, does **not** have its own dedicated XS code. If it does, then the Butterfly Perl 5 Project is not for you. If it doesn't, then all you need is to have a version of CPAN modules providing the same API as the original CPAN modules (which may or may not have XS components). So yes, you throw away XS code entirely. And good riddance I'd say to that. I don't think anybody is really happy with XS, which after all is an interface that got hacked together in a few days just prior to releasing Perl 5. If you're deep into XS code usage in your own Perl 5 code, to me that means two things: - apparently Perl 5 is not fast enough for you - you're suffering from [Stockholm Syndrome](https://en.wikipedia.org/wiki/Stockholm_syndrome) with regards to XS And yes, it will never be a bug for bug complete reimplementation of Perl 5. But then again, every new version of Perl 5 isn't either.
**Stockholm syndrome** Stockholm syndrome is a condition that causes hostages to develop a psychological alliance with their captors as a survival strategy during captivity. These feelings, resulting from a bond formed between captor and captives during intimate time spent together, are generally considered irrational in light of the danger or risk endured by the victims. Generally speaking, Stockholm syndrome consists of "strong emotional ties that develop between two persons where one person intermittently harasses, beats, threatens, abuses, or intimidates the other." The FBI's Hostage Barricade Database System shows that roughly eight percent of victims show evidence of Stockholm syndrome. It was formally named in 1973 when four hostages were taken during a bank robbery in Stockholm, Sweden. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
In understand.
&gt; If and when that new architecture could use the modern optimization strategies you can find in a JVM or JavaScript VM, further improvements would be possible. [MoarVM](http://moarvm.org/features.html)
&gt; the modern optimization strategies you can find in a JVM or JavaScript VM
You're not paying attention. XS does three things. If you get rid of it, you don't have Perl, you don't have CPAN, and you're left with something that trivially looks like Perl until you try to use: * File::Glob * PerlIO * DBM modules * POSIX * Sys::Hostname * Hash::Util * re * Devel::Peek * arybase * mro * I18N::Langinfo * Fcntl ... and that's just browsing a few core modules. Now you personally may never use them, but imagine all the programs in the world that stop working because file locking suddenly isn't supported. (And, no, linking to Moar on Github and saying "it supports file encodings" or "someone else can write POSIX bindings" is handwaving.)
&gt; All of the other ones are basically a SMOP. Great! [Keep going](http://cpansearch.perl.org/src/ABIGAIL/perl-5.27.8/ext/POSIX/POSIX.xs). Then there's a lot of CPAN code to search before you can declare victory, to mention nothing of DarkPAN code. [You don't have to take my word for it, though](https://www.nntp.perl.org/group/perl.perl5.porters/2018/01/msg248863.html).
*
&gt; I've given it away from the start. Are you implying that we're charging for freebies??? Do you want me to make the invoices public that your company Onyx Publishing has sent my company? And the payments my company has made?
What are you on about? I thought everyone here knew that the text of every edition of Modern Perl has always been available online, that the source code has been on GitHub from almost the start, and that I've made sure that epub and PDF versions are free downloads for every edition. I appreciate everyone who's bought copies to resell or give away, but if you decide to stop doing it for whatever reason, it doesn't affect me because I don't care about the little bit of money it brings in and because people already have ways to get the book for free.
Of course, once you do all that, you still have to address what I wrote in my first post in this sub-thread, namely that you're going to have a lot of bottlenecks to work around because of the semantic mismatch between Perl and Moar. Are you going to allocate big blocks of memory, pin them in the GC, and handle reference counting manually so that timely destruction works the same way in the reimplementation? That's not likely to be fast. Are you going to create your own version of SV, IV, PV, NV, etc that Moar doesn't know about so that autopromotion and dualvars and coercion continue to work in the reimplementation? That's not going to be fast. Are you going to extend Moar's JIT just for these new data structures so that they can participate in unboxing and lifetime analysis and allocation elision? That's going to be a lot of work. Are you going to share these data structures across language barriers for interoperability? That's going to get into issues of representation, coercion, canonical representation of data (oh, that's going to get fun when it comes to flags like `IOK` and `POK` crossing the barrier, and certainly they'll be *interesting* when you try to use them for type hinting for JIT), and, of course, memory management (what happens when you try to mark a value in Rakudo when its provenance is Perl and it's reference counted?). That's going to be a lot of work. How are you going to manage the Perl stack `@_`? How does `caller($n)` work? How does `caller` work when you're temporarily in the `DB::` package? What happens when you call into Perl from a Rakudo continuation, and you suspend that continuation for later resumption? How does a Perl exception work? How does it propagate? What if there's a language boundary in the middle? I suppose you could handwave all of these questions away and say "Interoperability isn't a goal", but you still have to deal with the very real question about which language's semantics are primary on the platform, because that really does govern the memory model and what types of optimizations you have.
You don't need the class name at compile time. You don't have that in your Java example.
If you expect this string to contain multiple line endings, include the /m modifier on the regex to match all of them: s/(ð$)/θ/mgi;
It wasn't a fully fleshed out example. In Java, the class name would be implicit when you call a method without otherwise specifying the namespace. Naturally, a class method can't call an instance method.
Probably has something to do with encoding. The following program: my $str = 'boop test meowð'; my $str = "boop test meow\ð"; $str =~ s/^\w+\s//; $str =~ s/\s\w+ð$//; print $str . "\n"; produces: ð meowð but the following: use utf8; my $str = "boop test meow\ð"; $str =~ s/^\w+\s//; $str =~ s/\s\w+ð$//; print $str . "\n"; produces: meow Does that help?
In order to make sure you are matching the characters you want, make sure to `use utf8;` in the script (so the source code, including regexes, is decoded from UTF-8), and also decode your input from UTF-8 as you read it from the file (either by setting the `:encoding(UTF-8)` layer on the filehandle you open, or running each line through `my $decoded = Encode::decode('UTF-8', $input)`. (And you will also probably want to encode the results back to UTF-8 for however you are outputting them.) If only one of these things is occurring, your regexes won't match the input characters.
In the CPAN Butterfly Plan, we're just going to basically port / re-implement upstream CPAN modules (and some Perl 5 core features, such as `tie`). We make sure the API is the same, and the semantics are the same as much as possible. For a Butterfly Perl 5 Project, we would be going a little further, as being able to parse and compile a large set of Perl 5 code. But being bug-for-bug compatible, is **not** a goal. That **would** be insane. Because even Perl 5 is not bug-for-bug compatible between versions either. So, coming back to the CPAN Butterfly Plan. For that we're only interested in API and semantics, **not** in internals. To answer your questions: &gt; ...handle reference counting manually... There's not going to be any reference counting. Reference counting is something that does not work well in a fully threaded environment, as that would require either a lot of locks, or at least a lot of `cas` semantics. Which is a lot cheaper still, but still comes with a cost. &gt; ...so that timely destruction works the same way in the reimplementation... There will not be any timely destruction as part of the CPAN Butterfly Plan. FWIW, I don't see this happening for the Butterfly Perl 5 Project either. Guaranteed timely destruction requires reference counting, and that just does work well in a threaded environment (and I consider Perl 5 `ithreads` **not** a threaded environment. In perl5 if you have 5 threads running and 1 shared variable, how many times does that variable exist in memory? **6** times). &gt; Are you going to create your own version of SV, IV, PV, NV, etc No. &gt; ...so that autopromotion and dualvars and coercion continue to work... Autopromotion is already built into Perl 6. Dualvars already exist in Perl 6, but they're called allomorphs. Coercion of allomorphs is automatic. &gt; Are you going to extend Moar's JIT just for these new data structures so that they can participate in unboxing and lifetime analysis and allocation elision? No. &gt; Are you going to share these data structures across language barriers for interoperability? There is no language barrier at runtime, so everything **is** already shared. &gt; How are you going to manage the Perl stack @_? Like any other arguments to a subroutine / method. &gt; How does caller($n) work? Based on the `Backtrace` core module, unless we get better direct support for `caller` first. &gt; What happens when you call into Perl from a Rakudo continuation, and you suspend that continuation for later resumption? Again, at runtime it's all the same bytecode executing. So continuations will work, as they already do with e.g. `gather` and `take`. &gt; How does a Perl exception work? How does it propagate? What if there's a language boundary in the middle? Exceptions work and can be propagated. Again, there won't be a language boundary in the middle. &gt; ...you still have to deal with the very real question about which language's semantics are primary on the platform, because that really does govern the memory model and what types of optimizations you have. The CPAN Butterfly Plan piggybacks on Rakudo Perl 6 and MoarVM. It uses Perl 6 features as much as possible, only using `nqp` when really necessary. For anything like accessing external libraries, `NativeCall` and perhaps some associated helper libraries, will be used. No changes to MoarVM or Rakudo Perl 6 will be made, unless it is clear that it must be done in core and cannot be in an external module. I have good hopes that that won't be necessary.
no, unfortunately, if I use UTF-8 globally, the whole script stops working, with warnings of 'wide characters'. Yet I have no issue with symbols like á é í ó ö ú æ œ θ, super- and subscripts, etc. The only two symbols giving me trouble are Ðð and Þþ, (for some reason, the case is not ignored, even though as you can see I specified the /i argument. I have tried \z and it didn't work either.
I tried using UTF-8, it just screws up everything, giving me the wide character error. I am using a multitude of other 'special' characters, and they all work without any issues. As for \z , I tried that also, didn't work..
A static method is not a class method in Java. A class method is dynamically dispatched on the *class object* while an instance method is dynamically dispatched on the *instance object* and a static method is *not dynamically dispatched*.
I wonder whether some of the problem with this ongoing situation is that Larry (pbuh) is: * the IP owner for "Perl" * seemingly not interested anymore in what happens to Perl 5 * not economically dependent on what happens to Perl 5 - in other words, economically his interests and the interests of the Perl 5 folks do not align
`^` and `$` refer to the beginning and end of the entire input (or a line if `/m` is set), not the beginning or end of a word. You probably want `\b`, which matches a word boundary -- `ð\b` will match a `ð` at the end of a word, for instance.
&gt;&gt;no warnings 'utf8'; Solved. Seriously, though--are you sure that thorn is the last character in the string? Did you `chomp` it?
yes, I chomped all the substitutions in that loop. As I said, it seems to be a software problem, because everything works as it is supposed to on another computer. 
As stated by others, `use utf8;` really only enables you to use utf8 text in the source file. To process Unicode properly, you need to decode from the (presumably) utf8 input files and re-encode to utf8 output streams (for your terminal, or output file), otherwise you will be getting that 'wide character in print' warning. Look into the [utf8::all](https://metacpan.org/pod/utf8::all) module for a maybe-easier way to set this up.
&gt; being able to parse and compile a large set of Perl That sounds like [RPerl](http://rperl.org/). Perhaps teaming up would be of benefit.
The experimental thing can is minor imo. I don't like XSD or for that matter DTD but I work with 3rd parties API who still use XSD a lot. So I think this is a good intro for someone whose never seen dinosaur Schemas. The author mentions XML::Simple elsewhere I saw recently, so it would have been good to mention that and any alternatives also :)
* gradual typing * generators 
First class support for try catch.
Depends if the DBs you use are in the list of supported ones https://github.com/perl6/DBIish/tree/master/lib/DBDish
Me neither. When I was in college, I had a few language design courses which stressed what a horrible idea relevant white-space was (and gave examples of failed languages that used it). I've never understood why Python caught on with such a horrible fundamental design flaw.
Ah, that's why I got that weird "cannot unbox to native integer" error all the time? That explains a lot. Thanks for looking into this. I didn't even know about the --profile switch. I understand that's intended to be the NYTProf replacement? Is there an equivalent for B::Concise as well?
got it: $text =~ s/\[HYPERLINK: \S+\]//g; closed.
I personally don't feel the language itself needs to change much....too much change and things break and we end up with something that is not Perl 5. Damien Conway's [DIOS](http://search.cpan.org/~dconway/Dios-0.000007/lib/Dios.pm) seems like something that may make Perl much easier to use. 
&gt; If I'm not mistaken, there is none. Yup. I used to volunteer lots of my time for packaging. That's a fool's errand because there is no buy-in from the cabal, they just install to the home directory and think that's fine. They do not know what packaging is or does. They are not interested in reducing friction and demolishing hurdles so that the software is brought into the hands of as many interested users as possible and that it may be installed with just one command or mouse click. Perl 6 is a fun toy – not a product – and disavows any serious aspects of software distribution because that's booooooooring. When I started, the software was not in a state that packaging was even possible. Every single time I set aside some time to make another attempt, I encountered problems and was never fully successful. I diligently filed bugs in core software and toolchain, but the turnaround is on the order of months and years. I later noticed that this is the wrong way. What you need to do to be successful is to be an antagonistic arsehole, start to hound and pester people and make a loud ruckus on public places like reddit and conferences because only that gets the squeaky wheel greased. But that is not enjoyable to me, it's so tiresome and destroys everyone's mood. What I need is a champion like masak used to be. The champion provides the buy-in and takes care that bugs and tickets relevant to the topic at hand get adressed in a timely manner. But proper product management is booooooooring, everyone would rather just play with the toy. If anyone is interested in packaging, find me on IRC, I can teach you the necessary stuff in a fraction of the time I needed to learn it myself.
 Of course it won't be the same, the objective is to make it better.
&gt; `s/[HYPERLINK: \S+]//g` No. `[ ... ]` gives you a character class. The way you have it, it includes all nonspace characters and the literal space. Therefore, all you end up with are newlines. What you want is probably more like `s/\[HYPERLINK: \s+ [^\]]+ \] \s+ //xg;`
The problem with "better" is it is subjective. Agree to differ can be a good start.
started to heavy breathe over this since I missed the last SLC one, told my wife she then told me it was the same time as her family reunion and we haven't seen these people for years. :( so sad because I haven't been to one of these yet and use Perl every day. frustrated. I will try to make one or two days we'll see.
This could be due to line endings. Files created on windows may end up with \r\n line endings, and depending on how you are reading those lines, they may not be stripped off. $ will ignore the trailing \n, but not the \r. It may help to examine the content of the strings more carefully. You should be able to see things like non-printables easier with something like: use Data::Dumper; $Data::Dumper::Useqq = 1; print Dumper($var);
&gt; In Java, the class name would be implicit when you call a method without otherwise specifying the namespace. P6 operates basically the same way by default. This is natural in the [class-based OO](https://en.wikipedia.org/wiki/Class-based_programming) paradigm, as supported by P6, though not assumed, and as supported and more or less assumed by Java. &gt; Naturally, a class method can't call an instance method. What's natural depends on one's frame of reference. P6 has a unique ability to naturally mix and match classes and objects from multiple ostensibly incompatible OO systems from arbitrary languages and libraries. To facilitate this, the overall P6 design is such that *standard* P6 does not *implicitly assume* an *automatic imposition* of a *hard-and-fast distinction* between methods some might call "class methods" and others they might call "instance methods". Instead, the P6 design supports, on the one hand, high level interop between languages (whether they are based on this paradigm or that, static or dynamic or both, exceptions based or not, etc.) coupled with reasonable related default type-checking and optimization strategies; and, on the other hand, *arbitrary user definable compile-time checking* written in high level P6 code that can be bundled into modules. Neither `v6.c` (the current P6 language standard) nor any Rakudo P6 compiler to date, ships with built in code that imposes the static constraint that you've characterized as natural. But a relatively straight-forward path to adding such a check already exists.
FWIW, anonymous packages do exist: https://metacpan.org/pod/Package::Anon (and building on that, https://metacpan.org/pod/Class::Anonymous)
hmmm, yes, I see. Thanks, I'll give it a try
I recall a similar "call for cooperation" from somewhere else, but, at least, that had the benefit of having been made by "*a fictional alien group that appear as recurring antagonists in the Star Trek franchise*", so it was somewhat amusing.
I understand your desire for something new to teach/write blogs/books about, but there's a bunch of Perl 5 programmers that just want to code in the language they love.
Lang6
Yep thanks for all those packages! Now with containers around, default install isn't so much a problem; I help maintain perl5 for Docker, and that along with other solutions like plenv/perlbrew, makes it easy to reach out to a perl (and to be more specific, to a particular version) when users need it. Perhaps my point is more about the old impression of having such a Perl be ready without a separate install step in the first place, and more than that, having reached that step primarily because Perl reached that state of adoption through being useful first.
Good stuff :-)
Great Scott!
A good build and deployment solution for applications written in perl that given an app organized like a typical CPAN dist, a .cpanfile and a few other config values will: * build the perl I specified * "build" my app * install 3rd party modules alongside said app * bundle it all in a tar/zip for easy deployment to another system (assuming identical OS to the build system. I have build and used a bunch of homegrown systems over the years but would like to find one that works like this, with a lot more collaborators. Documentation and particlalry examples are key. It would make it easier to provide packaged software solutions and do automated upgrades/downgrades into clusters.
More modern cars have ODB-II, which is standardized enough that it can pull this sort of thing without much difficulty. Problem is, ODB-II started being mandated in the US in 1996. The DeLorean is much older than that, so everything has to be custom.
This is heavy...
They are *not* in core language because someone who thinks that is always right does not changes his mind. Side note: you did not responded me about sponsoring new developers for core development. Now, I understand why.
sudo ln -s /opt/rakudo-star-2017.10/bin/perl6 /usr/bin/p6 maybe ;) sudo ln -s /opt/rakudo-star-2017.10/bin/perl6 /usr/bin/bighero6 
Gah! Comic Sans! How could you! 😂
It would be handy if going to `https://rakudup.github.io/rakudup` in browser would show the source instead of offering to download a binary file...
Not sure if I should report the bug that Comic Sans MS doesn't exist on linux
Yes it does. In the msttcorefonts package.
There are rpms available. 
I created account just to comment on this (which is also first post I read on reddit). I am no one in perl community but have been learning and using perl5 for few years now. And I love it! All I got from the letter and discussion here is that I'll have start learning python3. No way I'll invest time/effort to learn perl6 which can't help me find a job. Perl5 is doing great as of now and I still get job offers but I think I'll have to plan for future by learning python3. I know Python also has same problem of python 2 vs 3. But all I know is that 2 &amp; 3 are not that different as perl5 vs 6. A no one like me care about how I can get job using the language that I know/learn. Note: Author seem more true to herself on IRC than here. And her tone seem to have changed after someone provided a link to IRC discussion.
Proposal for reassignment: http://lists.scsys.co.uk/pipermail/dbix-class/2018-January/012740.html mst's response: http://lists.scsys.co.uk/pipermail/dbix-class/2018-January/012770.html Current DBIx::Class permissions: https://cpanmeta.grinnz.com/perms#=DBIx::Class
Is this related to the `DBD::MariaDB` stuff going on?
Completely unrelated
Next time somebody proposes that they take over someone else’s CPAN publishing rights, there should be a requirement that this person delivers a tar ball within a calendar month. If not, then the change ought to be reverted to the previous owner. No exceptions. 
6lerp, pronounced Slurp
I didn't participate in the vote, but I'm glad all parties came to an agreement and I'm glad ribasushi is still interested in maintaining the project.
Since the virtues of this choice may not be obvious to everyone, I'll enumerate them here: * The letter-number pattern is common: i5, m4, L4, G7, B52 * P6 is already in use as a shorthand/nickname * No need to argue about capitalization, P6 is 75% less likely than PERL6 to upset case curmudgeons. * Consistent with language versioning, e.g. 6.d * Consistent with Camelia logo * Close enough to perl6 that it will be easy to explain. * Has the potential to resolve the name conflict with minimal intervention
.oO ( Rakudo and Raptor )
perlverts
+50
I left a comment on the blog itself, but wanted to reiterate that this is awesome. When I first saw async/await for javascript I didn't understand why it was anything transformative, as it's really just syntactic sugar.. but once you start using it you can see how it really cleans up your code and renders it as or almost as readable as synchronous code.
Meh.... Here is an awk one liner awk -F '^"|","|"$' '{print $2,$3}' whatever.csv 
I haven't used it yet but from examples it's apparent how helpful the concept of "pause this subroutine and come back later" is to our synchronous thought processes.
Err... NAT
Thank you for this well-reasoned response, jnthn.
What about it?
In the light of what has happened lately, this was quite refreshing to read. 
Welcome to planet Perl! One way of writing this in perl5: #!/usr/bin/env perl use strict; use warnings; # Declare a hash for word =&gt; count lookups - http://perldoc.perl.org/perldata.html my %word; # From right to left: # @ARGV is the list of files from commandline # map { local $ARGV = $_; &lt;&gt;} is a way to read the lines for each file into a list # map { /(\w+)/g } extracts a list of words (defined as sequences of a-zA-Z0-9_ characters) from each line # ++$word{$_} for increments the count for each of the words in the final list ++$word{$_} for map { /(\w+)/g } map { local $ARGV = $_; &lt;&gt; } @ARGV; # Display the results, most popular first print "$_ =&gt; $word{$_}\n" for sort { $word{$b} &lt;=&gt; $word{$a} } keys %word; It can be neater, though - even for something as simple as this I'd use modules such as [List::UtilsBy](https://metacpan.org/pod/List::UtilsBy#rev_nsort_by) and [Path::Tiny](https://metacpan.org/pod/Path::Tiny#lines,-lines_raw,-lines_utf8). This version would mainly be suitable for writing directly on the commandline and for use on a small number of files. With large amounts of data it uses more memory than it should. Note that this is perl5. Given the Cixl name, I'd imagine that a Perl6 version would be of more interest - presumably someone will oblige! 
You're advocating a liberal "let's wait until the kid is actually shot" stance.
Much appreciated! Pretty compact :) Cixl is currently around 4 times slower than Perl for this task. I noticed two things missing from your solution though, it doesn't lowercase the words and it doesn't sort words with equal counts alphabetically. Would you mind having another look so we can get a fair comparison?
 perl -e'++$word{lc $_} for map /(\w+)/g, &lt;&gt;; print "$_ =&gt; $word{$_}\n" for sort { $word{$b} &lt;=&gt; $word{$a} or $a cmp $b} keys %word' &lt; file1 ... fileN 
 .put for words».uc.Bag.sort({ -.value, .key })».&amp;{ .key ~ ' =&gt; ' ~ .value } ; The rest of this comment explains how I arrived at the above P6 statement. I started with: .put for words ; `.put` is a method that coerces its *invocant* to a string, displays it, and appends a newline. The invocant, if explicit, is to the immediate left. In this case there is no explicit invocant so `.put` instead acts on the implicit *it* (aka "the current topic"). So read `.put` as "put it". `for` in the middle of a statement does the operation on its left for each element in the list on its right. `words` yields a list of the words read from stdin (which in turn automatically comes from the files you pipe in to the script). (In more detail, `words` calls a method on [`$*ARGFILES`](https://docs.perl6.org/language/variables#Dynamic_variables), specifically [`IO::CatHandle.words`](https://docs.perl6.org/routine/words#(IO::CatHandle%29_method_words).) This gets us something like: foo bar foo baz bar qux ... The above first version of the statement displays the words in the input, in the order they're encountered, one per line. Continuing: .put for words».uc ; This prints exactly the same list, in the same order, but with the words uppercased. (`»` invokes the operation that follows it on each element of the list that precedes it. `»` also tells the compiler that it has the right to do the operations in parallel if it wants to. Regardless of whether the compiler actually does them in parallel or not, the end result is returned in the same order as the input. That doesn't matter in this case given the histogram end result we're heading toward but I'll return to this point.) To get a histogram, `.Bag` the list: .put for words».uc.Bag ; At this point we've got something like: FOO 3 BAR 1 BAZ 12 ... Now sort the list by descending count: .put for words».uc.Bag.sort: &amp;{ - .value } ; `&amp;{ ... }` is an anonymous closure (function). The code in the closure reads as "negate its value" where "it" is the histogram entry, the entry's key is the word and its value is the count for that word. So the sort is by the count, in descending order. Finally, improve the sort closure to include a secondary sort by the word itself (and stick it in parens so we can follow it with a chained inline method closure) and append said closure that switches to the format chosen by /u/tm604: .put for words».uc.Bag.sort(&amp;{ -.value, .key })».&amp;{ .key ~ ' =&gt; ' ~ .value } ;
THE =&gt; 42 IN =&gt; 15 .PUT =&gt; 9 A =&gt; 9 FOR =&gt; 9 IS =&gt; 9 TO =&gt; 8 THAT =&gt; 7 THIS =&gt; 7 ; =&gt; 6 IT =&gt; 6 OF =&gt; 6 WORDS =&gt; 6 ITS =&gt; 5 ON =&gt; 5 ' =&gt; 4 .KEY =&gt; 4 BY =&gt; 4 CLOSURE =&gt; 4 LIST =&gt; 4 SO =&gt; 4 SORT =&gt; 4 } =&gt; 4 ~ =&gt; 4 ... =&gt; 3 .VALUE =&gt; 3 AND =&gt; 3 AS =&gt; 3 BAR =&gt; 3 FOO =&gt; 3 METHOD =&gt; 3 SAME =&gt; 3 &amp;{ =&gt; 2 -.VALUE, =&gt; 2 =&gt; =&gt; 2 ABOVE =&gt; 2 AT =&gt; 2 BAZ =&gt; 2 BUT =&gt; 2 CASE =&gt; 2 COMPILER =&gt; 2 DESCENDING =&gt; 2 DISPLAYS =&gt; 2 DOES =&gt; 2 EACH =&gt; 2 ELEMENT =&gt; 2 END =&gt; 2 FROM =&gt; 2 HISTOGRAM =&gt; 2 I =&gt; 2 IF =&gt; 2 INVOCANT =&gt; 2 LIKE: =&gt; 2 OPERATION =&gt; 2 ORDER =&gt; 2 PARALLEL =&gt; 2 READ =&gt; 2 RESULT =&gt; 2 SOMETHING =&gt; 2 STATEMENT =&gt; 2 WITH =&gt; 2 WORD =&gt; 2 })».&amp;{ =&gt; 2 "IT" =&gt; 1 "NEGATE =&gt; 1 "PUT =&gt; 1 "THE =&gt; 1 $*ARGFILES, =&gt; 1 (AKA =&gt; 1 (AND =&gt; 1 (FUNCTION). =&gt; 1 (IN =&gt; 1 (WHICH =&gt; 1 (» =&gt; 1 - =&gt; 1 .BAG =&gt; 1 /U/TM604: =&gt; 1 1 =&gt; 1 12 =&gt; 1 3 =&gt; 1 ACTS =&gt; 1 ACTUALLY =&gt; 1 ALSO =&gt; 1 AN =&gt; 1 ANONYMOUS =&gt; 1 APPEND =&gt; 1 APPENDS =&gt; 1 ARRIVED =&gt; 1 AUTOMATICALLY =&gt; 1 CALLS =&gt; 1 CAN =&gt; 1 CHAINED =&gt; 1 CHOSEN =&gt; 1 CLOSURE) =&gt; 1 CODE =&gt; 1 COERCES =&gt; 1 COMES =&gt; 1 COMMENT =&gt; 1 CONTINUING: =&gt; 1 COUNT =&gt; 1 COUNT, =&gt; 1 COUNT: =&gt; 1 CURRENT =&gt; 1 DETAIL, =&gt; 1 DO =&gt; 1 DOESN'T =&gt; 1 ENCOUNTERED, =&gt; 1 ENTRY'S =&gt; 1 ENTRY, =&gt; 1 EXACTLY =&gt; 1 EXPLAINS =&gt; 1 EXPLICIT =&gt; 1 EXPLICIT, =&gt; 1 FILES =&gt; 1 FINALLY, =&gt; 1 FIRST =&gt; 1 FOLLOW =&gt; 1 FOLLOWS =&gt; 1 FORMAT =&gt; 1 GET =&gt; 1 GETS =&gt; 1 GIVEN =&gt; 1 GOT =&gt; 1 HAS =&gt; 1 HEADING =&gt; 1 HISTOGRAM, =&gt; 1 HOW =&gt; 1 I'LL =&gt; 1 IMMEDIATE =&gt; 1 IMPLICIT =&gt; 1 IMPROVE =&gt; 1 INCLUDE =&gt; 1 INLINE =&gt; 1 INPUT, =&gt; 1 INPUT. =&gt; 1 INSTEAD =&gt; 1 INVOCANT, =&gt; 1 INVOKES =&gt; 1 IO::CATHANDLE.WORDS.) =&gt; 1 IT". =&gt; 1 IT, =&gt; 1 IT. =&gt; 1 ITSELF =&gt; 1 KEY =&gt; 1 LEFT =&gt; 1 LEFT. =&gt; 1 LINE. =&gt; 1 LIST, =&gt; 1 LIST: =&gt; 1 MATTER =&gt; 1 MIDDLE =&gt; 1 MORE =&gt; 1 NEWLINE. =&gt; 1 NO =&gt; 1 NOT, =&gt; 1 NOW =&gt; 1 ONE =&gt; 1 OPERATIONS =&gt; 1 OR =&gt; 1 ORDER, =&gt; 1 ORDER. =&gt; 1 P6 =&gt; 1 PARENS =&gt; 1 PER =&gt; 1 PIPE =&gt; 1 POINT =&gt; 1 POINT.) =&gt; 1 PRECEDES =&gt; 1 PRINTS =&gt; 1 QUX =&gt; 1 READS =&gt; 1 REGARDLESS =&gt; 1 REST =&gt; 1 RETURN =&gt; 1 RETURNED =&gt; 1 RIGHT =&gt; 1 RIGHT. =&gt; 1 SAID =&gt; 1 SCRIPT). =&gt; 1 SECONDARY =&gt; 1 SPECIFICALLY =&gt; 1 STARTED =&gt; 1 STATEMENT. =&gt; 1 STDIN =&gt; 1 STICK =&gt; 1 STRING, =&gt; 1 SWITCHES =&gt; 1 TELLS =&gt; 1 THEM =&gt; 1 THERE =&gt; 1 THEY'RE =&gt; 1 TO. =&gt; 1 TOPIC"). =&gt; 1 TOWARD =&gt; 1 TURN =&gt; 1 UPPERCASED. =&gt; 1 US =&gt; 1 VALUE =&gt; 1 VALUE" =&gt; 1 VERSION =&gt; 1 WANTS =&gt; 1 WE =&gt; 1 WE'RE =&gt; 1 WE'VE =&gt; 1 WHERE =&gt; 1 WHETHER =&gt; 1 WITH: =&gt; 1 WORD. =&gt; 1 WORDS».UC =&gt; 1 WORDS».UC.BAG =&gt; 1 WORDS» .UC.BAG.SORT(&amp;{ =&gt; 1 WORDS».UC.BAG.SORT({ =&gt; 1 WORDS».UC.BAG.SORT: =&gt; 1 YIELDS =&gt; 1 YOU =&gt; 1 » =&gt; 1
To back up what [hobbified wrote](https://www.reddit.com/r/perl/comments/7t8l66/what_is_connection_recieved_from/dtb3t69/), please don't use the TutorialsPoint site. They have no interest in keeping their tutorials up to date. As far as I can see, they're just there in order to make money from the adverts.
A lot of it depends on what you consider "words". This code is assuming it's sequences of word characters but sequences of non-space characters is another common definition (you could replace \w+ with \S+ in the regex for that). The count loop could easily be written in Inline::C here as well, or the whole thing for that matter. Also, it gets a lot more complicated (and harder to code in C) if we leave ASCII land, though this perl code would still work if you add the switch -CS to decode STDIN from UTF-8 and encode STDOUT back to UTF-8.
I wish these blog posts had better descriptive titles.
&gt; The requirement to make several requests to other services hurt us though. The kicker was, we had to make the requests concurrently and compute concurrently on the responses. This was because the data needed for one request was coming from two separate data stores that could be fetched and processed and rendered concurrently. In other words, we needed threading. Threading would be great for this, but since it sucks in Perl, forking is another viable option and has far less performance drawbacks in Unix. IO::Async and Mojo have [wrappers](https://metacpan.org/pod/IO::Async::Function) to make it [as easy](https://metacpan.org/pod/Mojo::IOLoop::Subprocess) as using threads for that purpose.
I wonder how Mojolicious' non-blocking user-agent would have performed on a single thread.
Wouldn't every `fork()` call multiply the program memory use? The other challenge that comes to mind is passing data back from a child process to the parent in a fast, safe way. 
Thanks for the reference, I agree that does look promising! This: &gt; This module lifts this restriction under two very specific but useful conditions: firstly, the coro thread executes in XS code and does not touch any perl data structures, and secondly, the XS code is specially prepared to allow this. Would require you to code any processors in XS (C + macros) though. I'm sure a few of us are tempted to use it, but I suspect most orgs would run for the hills.
&gt; Minor style problem: package names should reflect the purpose, not a particular mechanism of the implementation. Remove the Role part from the package name. I agree myself; I just wanted to point out that those were roles in the example. :) &gt; Try and think along this line: [...] This makes a lot of sense! Thanks!
I would also run for the hills, but for reasons specific to that author and implementation.
The non-blocking user agent unfortunately does not solve the problem of needing concurrent computation. Event loops can only concurrently wait for things. Hence my suggestion of trying to leverage forking in my other comment.
I heart SQLite so much.
I didn't put it in the article, but one reason we didn't use Coro is we've been burned in the past when it broke with a new Perl release and we weren't able to upgrade our Perl until we removed it.
Yesm and speaking of naming [there's this nice talk](https://www.youtube.com/watch?v=CzJ94TMPcD8) about the hardships of it.
You could create an attribute, with that JSON::XS object as a default value (using a builder, preferably; you can even import the builder from a central "base" library). That way, you always have the object when needed, but when you're testing or refactoring, you can easily substitute it with something else.
It's nice environment... very useful tool!!
Yes, quite refreshing, I agree.
SQLite is amazing for a "standalone" executable... and a small one at that. To be able to implement an **entire** DB engine in ~1MB is nuts. Do the new releases change that much? At this point it seems pretty mature and stable. I'm not sure how much room for improvement there really is. 
Sure - lots of performance improvements, and new extensions and features (the JSON1 extension and WAL logging were added this way). It is certainly mature and stable, but that doesn't mean the developers aren't adding new things. http://sqlite.org/changes.html has all the high level changes each release brings.
If Perl officially adopts Moose and encourages everyone to use it in everything, the camp of minimalists will throw a never-ending fit. Moose is too heavy-weight for Perl.
That's easy to fix. Stop saying, "No remote workers," and suddenly you're rolling in developers. 
Pretty sure part of the reason "perl" is a highly paid language is because it's a utility thing. I am a skilled sysadmin who uses perl loads. If you think of me as a just a perl developer, then frankly I am overpriced. 
[Tie::Hash::Indexed](http://p3rl.org/Tie::Hash::Indexed) is faster.
Also good suggestions for recruiters: - Consider replying to your applicants. If an application from a perl dev with 20 years of experience and a good match of desired skills doesn't at least get a reply from you, that's embarrasing. (I'm not saying this is generally the case, but it was my experience for my last two perl applications) - Also tell potential applicants up front if you are able to hire people from other countries. It's annoying to find that out after you prepared your CV files and went through the cumbersome form filling and upload process, that 'remote' only means "Oh, we only meant US people". - Allow remote, like ew73 already said.
Unfortunately, that hasn't been the case at my consulting company. It's not enough by itself. There's also some people who honestly don't care for the work-at-home lifestyle (not me, but I know they exist). I do think that if you combine it with reaching out to non-Perl developers, while having a training program that expects that a good dev can pick up the language, being remote and having a good salary and benefits can keep the resumes rolling in.
Convincing my boss that I can make good use of remote perl talent is hard. Lots of people list perl on their resumes but when asked they don't know what Moose or Catalyst are. As always [Sturgeon's law](https://en.wikipedia.org/wiki/Sturgeon%27s_law) applies 
**Sturgeon's law** Sturgeon's revelation (as originally expounded by Sturgeon), commonly referred to as Sturgeon's law, is an adage commonly cited as "ninety percent of everything is crap". It is derived from quotations by Theodore Sturgeon, an American science fiction author and critic; while Sturgeon coined another adage that he termed "Sturgeon's law", it is the "ninety percent crap" remark that is usually referred to by that term. The phrase was derived from Sturgeon's observation that while science fiction was often derided for its low quality by critics, the majority of examples of works in other fields could equally be seen to be of low quality, and that science fiction was thus no different in that regard from other art forms. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
As a bioinformatician who learned to love Perl there just isn't a market for us entry level Perl Developers. I've been trying to make the transition but maybe since I'm a recent grad it just looks like I'm looking for anything. Maybe I'm being pessimistic because I haven't received a response but it just seems that way.
How do you suggest someone who has been coding in Perl for bioinformatics break into this field? Ive sent dozens of applications for strictly Perl Developer jobs and I haven't received a single response. I grew to love it after creating functions for my professor's Bioperl wrapper application. It seems that the demand is high for just mid-senior level developers in NYC.
I would first build up a portfolio of useful things on cpan. Proof of work is work a hundred resumes.
How you managed to ignore OO style ? Any serious size codebase can't avoid that.
Its a challenge also for Perl developers seeking jobs like me, who is in a country where Perl opportunities have all but dried up, and have to look at either (a) moving out to somewhere that has such opportunities, or (b) find someplace that offers remote work. Thankfully, I'm currently on (b), and while (a) is an attractive option, under my current circumstances I'd prefer not moving around for the time being. FWIW, diversifying my own skills to work on other opportunities is a given; it seems an easy flip for me to go into a sysadmin/devops role, but I like to work more on developing with Perl (in whatever form, be it 5 or 6) as much as I can.
Which tools?
That's completely different from not being familiar with something...
The Perl 6 port of Perl 5 CPAN modules are also a great way for Perl 5 programmers to learn about the differences between Perl 5 and Perl 6. The modules come with good documentation on this ([one such example](http://modules.perl6.org/dist/List::Util:cpan:ELIZABETH)). Nice work, Liz!
Moose and Catalyst are not perl. If you are interested in persons with experience using particular frameworks or modules then it should be part of the listing's basic requirements.
Yes. But it doesn't have the extra utility methods. Not that I've ever needed those. 
If the file handle is never closed, there will be no EOF, then it will stall waiting for IO indefinitely. So it depends what your shell prog and shell args are. Also - you'd be far better off using lexical filehandles: open2 ( my $output, my $input, "command here" ); print {$input} "Stuff\n"; while ( &lt;$output&gt; ) { #more stuff; } But you may find `IO::Select` to be useful here, because you can use the `can_read` method (with a timeout) to see if a fh is currently readable. 
To be honest, I'm new to the Perl scene and I bought a couple of books and I've gone through 2-3 of them already. This thread basically convinced me to go with another scripting language. Outside of software maintenance and "prototyping", I think Perl 5 and 6 is essentially dead. 
I've often found that these issues depend on what the particular program is trying to do. Have you tried IPC::Open3 and reading STDERR too? Maybe the program is stuck trying to tell you something.
I don't know why I never thought of that. Thanks! I just assume that many people are comfortable with using different modules on CPAN.
and strict and warnings.
If the program exits you'll see eof after reading the remaining buffered output.
FWIW there's [Docker Hub](https://hub.docker.com/_/perl/) images of perl, covering almost all releases down to 5.8.9, and latest releases now also being built on arm64 and other architectures.
Some languages don't have OO at all - Clojure, Elixir, Go. Yes, you can avoid it and what's more your codebase can be smaller and more manageable. Take it a step further and use immutable data types and testing/maintenance is much easier.
Maybe they knew what Symfony was and were happily productive with it.
As someone who used to be a BIoinformatician too and so had to use Perl in the job, then got separated from that company.. I thought my days were numbered until a company in another industry with such aged systems written in Perl found me.
Confirm this. I'm with a company whose codebase stretch back 20-30 years.... my gahd. Looks like I was the first to introduce object-oriented principles, but in an altogether new project.
&gt; If the file handle is never closed, there will be no EOF, then it will stall waiting for IO indefinitely. This turned out to be the issue, thanks!
Look at CPAN. How many purely functional modules are there ? 
But there'll be a trademark fight with the set-top box.
In Perl 5 land, it has been a big, constant problem that Perl is defined by `perl`. Larry wants to keep far away from that this time. (So do some other people who don't get the last word, but Larry is reason enough.)
Cache invalidation is one of the two big unsolved CS problems. I don't see that as being any better or worse than any other potential system. What I think will limit it is authentication/authorization. The whole point is to never hit application code, but if you have to do something more sophisticated than HTTP Basic Auth, that will be hard to do. It's most useful for an internal microservice that's sitting behind a firewall, accessible only to your other internal servers, and serving data that mostly stays the same.
Could somebody explain to me what all the moose references mean? I'm not understanding all these references to moose. Is this just for comedic effect, or am I not understanding something? 
_perly_bot automatically posts any and all content from blogs.perl.org Given the low frequency of that content ,and the lack of upvote on all these Moose posts perhaps just use your own judgement on how much you want to understand. Looks like a Moose dev has decided to blog daily. The lack of people doing that in the Perl community ends up making them dominate this Reddit. But its not because a human has decided that is particularly interesting. One of the few other people I've noticed with a high frequency blog is Andrew Shitov, but he's posting about Perl 6 daily which is not to everyone's taste either https://perl6.online/
Ok thanks, high functioning autism != high functioning understanding of subtlety. Thanks for clearing that up for me. 
not sure if you mean: my $sql = 'select id,page, ...'; my $sth = $dbh-&gt;prepare($sql); $sth-&gt;execute; while(my $row = $sth-&gt;fetchrow_hashref){ print "value of id is: ", $row-&gt;{id}; print "value of page is: ", $row-&gt;{page} } 
yes that is what I mean, but I was told fetchrow_hashref was slow and not to use it. So I wasn't sure if there was a way to use map. while(my $row = $sth-&gt; fetchrow_array(){ map here then push to array }
The pure perl implementation of fetchrow_hashref basically does what you're trying to do. I've never heard of it being "slow", though From DBI/PurePerl.pm: sub fetchrow_hashref { my $h = shift; my $row = $h-&gt;fetch or return; my $FetchCase = shift; my $FetchHashKeyName = $FetchCase || $h-&gt;{'FetchHashKeyName'} || 'NAME'; my $FetchHashKeys = $h-&gt;FETCH($FetchHashKeyName); my %rowhash; @rowhash{ @$FetchHashKeys } = @$row; return \%rowhash; } 
I remember the DBI docs used to say that it's slow. Now, they say there would be a fairly significant boost if they reused the ref, but it would probably break scripts if they made that change. In practice, I've never noticed any performance difference between this and the fetchrow_array.
If you want to use a hash without the overhead of fetchrow_hashref, you can reuse the same hash for each fetch by using bind_columns. The other trick is to put the list of selected columns in perl so that you only define them once. Then you can use that list to generate the SQL. See: https://www.perl.com/pub/2001/03/dbiokay.html/#binding%20columns
my $fields = $sth-&gt;{NAME}; for my $each (@{$fields}){ print $each; } Mix with fetchrow_hashref and don't forget to alias your column returns with 'as'. Forgive syntax posting from phone....
You can run `perldoc -f grep` in your terminal to get [documentation for grep](http://perldoc.perl.org/functions/grep.html) It'd just be something akin to: say for grep /foo|bar|baz/, @files
I want to say everything *but* foo, bar, and baz, though.
This produces the expected results. Thank you!
The DBI docs were mostly written decades ago and really should have a "for dummies" section. The only thing you really need to know is that you should just start with -&gt;do() or -&gt;selectall_arrayref() (selectcol_arrayref() and selectrow_hashref() are also quite useful) depending if you need data back, and only bother with preparing queries manually if you need to bind specific types or have a specific performance concern with a query you run many times.
&gt; The only thing that matters is whether the person who takes over comes up with a deliverable. This is open source. Anyone can come up with a deliverable; there is zero limitations on this.
Yes, indeed. That's what I'm trying to say. 
Use a file lock or a Unix socket
Sometimes the easiest option is to have processes communicate over pubsub provided by a broker process such as Redis, PostgreSQL, or [mercury](https://metacpan.org/pod/mercury).
Unfortunately saying people shouldn't think something isn't going to change the reality of how people interpret project names and versions.
A long time for sure. But Perl 6 is a project made to be there for a long time. I think it will be fixed soon enough. 
Isn't K a proprietary language? The version numbering of proprietary software seems like a confusing example; I'm old enough to remember Windows, Word Perfect, Oracle, Visual Basic, Java, and a few other things....
K is a language with many implementations. While there is a company selling K4 interpreters, the largest K3 implementation, Kona, is open-source. K5/K6 have multiple actively developed implementations of which the largest -- oK -- is open-source, too.
Or maybe inotify2 (module in CPAN). Have each child wait for the file to be closed, then do its stuff. Best as a oneshot watch, restarted after closing the file, so they don't trigger themselves, only each other.
&gt; people outside of the community would think Perl6 has to deprecate It's not *would* think. [They *do* think](https://github.com/github/linguist/issues/3637#issuecomment-319026186). Hell, even people *in* the community [are confused that it would](https://www.reddit.com/r/perl6/comments/7s9yj6/201804_its_time_for_optimism_weekly_changes_in/dt8vw9y/). Just because it hasn't happened to `$foo` is not evidence that it can't ever happened.
I don't think I'd like this as a stand-alone solution because it doesn't scale. inotify will let you know that the file has changed, but that doesn't help you handle contention over the file. If two (or more) processes are watching the inotify queue they may both try to read and update the file at the same time, which would be a disaster. inotify combined with file locks will make the processes a lot more responsive than just relying on locks alone, but it's also a lot more complicated -- so I don't think it's appropriate for a beginner like OP.
I got this far. The program alternates the counter in a file, but I still can't get the processes to talk to each other, so they do double the work specified. use strict; use warnings; use diagnostics; use POSIX ":sys_wait_h"; # for nonblocking read print "How many times should the process increment?: "; #print first message my $input = &lt;&gt;; #user int value my $int_val = 0; #initial int value my $j = 0; my $i = 0; my $out = 'message.txt'; open(OUT, '&gt;', $out) or die("Can't create $out.\n"); open (FILE, '+&gt;message.txt') or die "Can't open file: $!"; #create file print FILE "$int_val\n"; #write integer zero to file my %children; $SIG{CHLD} = sub { # don't change $! and $? outside handler local ($!, $?); while ( (my $pid = waitpid(-1, WNOHANG)) &gt; 0 ) { delete $children{$pid}; cleanup_child($pid, $?); } }; for (my $i = 0; $i &lt; ($input/2); $i++) { my $pid = fork(); die "cannot fork" unless defined $pid; if ($pid == 0) { my $in = 'message.txt'; open(IN, $in) or die("Input file $input not found.\n"); while (my $line = &lt;IN&gt;) { $line++; open (OUT, '+&gt;message.txt') or die "Can't open file: $!"; #create file print OUT $line; } ++$j; print "($j) The child incremented the file\n"; close(IN); close(OUT); exit 0; } else { $children{$pid}=1; my $in = 'message.txt'; open(IN, $in) or die("Input file $input not found.\n"); while (my $line = &lt;IN&gt;) { $line++; open (OUT, '+&gt;message.txt') or die "Can't open file: $!"; #create file print OUT $line; } ++$j; print "($j) The parent incremented the file\n"; close(IN); close(OUT); # system($command); waitpid($pid,0); } } 
I read about that, but the process confuses me. Can you show me an example so that I can understand?
That's a terribly complicated answer for a beginner. Why not point him/her into a reasonably simple direction that's going to teach him some basics, like file locking or IPC? Adding a database layer will send them off on a tangent that will probably confuse them for far too long, without helping them address some basics knowledge. We all take the basics for granted, or some more likely forget about them (just like most of us would struggle for a bit to write a sorting algorithm from scratch without a book or Google) but every expert had to learn the basics, too, and should be able to guide others into them.
Unfortunately what he is trying to do is not a task suited for beginners, and any option will require some study, trial and error, and probably some further help. The database options are most useful when you are already using one of those databases of course, so you aren't introducing new layers.
Knowing *about* a framework isn't the same as having used it. I'm not terribly concerned about a candidate who hasn't used Catalyst, as he can learn on the job -- after all, there is documentation, and a codebase that already uses it to learn from! But I *would* be concerned about not having heard of it at all. Perl without CPAN is much diminished, and I'm concerned if the candidate has only been working with diminished Perl.
Absolutely. It's even on Perl6's website on the front page. 
*"Anyone who's familiar with Perl is not affected by the issue that only impacts those who aren't familiar with Perl"...* 
I think the idea is that the OP learns about locking and IPC, not that they offload half the task to a few hundred thousand lines of code written by someone else. socketpair seems like a good way to go. Having said that this is to do with locking etc. You could actually do this *without* locking. I think. Fork Parent process sleep 1, opens file, writes first value to file, closes it. Sends "I did it" to child. Both processes While limit not reached Wait for "I did it" from other Open file, Read value from file, write back incr value to file, close it Send "I did it" to other While end 
Have a look at socketpair
Holy smokes, that's spectacular. Interesting that Perl6 uses '»' instead of 'map' or 'parallel-map' for the name of that operation. Can you use &gt;&gt; instead? 
Will there ever be a Perl 7? Or is Perl 5 always staying Perl 5 and Perl 6 always staying Perl 6?
`IO::Socket` does not deal with an unnamed socketpair, because it's a built-in function: http://perldoc.perl.org/functions/socketpair.html You don't even need to use a module, in Perl batteries are included... No, that's Python, sorry. In Perl you get a nuclear power station instead. :)
Sounds like you need to store the reference to the array as the hash key. Dereference to print it. 
When did perltricks.com move to perl.com? Is there an announcement I can read? 
You can't just push an array on to an already existing hash (well not and expect it to do what you want). You probably want to store an arrayref in the hash instead. Something like ``` $key{my_array} = \@archivedetails. ``` Then to pull it out you do: ``` my @array = @{$key{my_array}}; ```
https://www.perl.com/article/welcome-back-perl-com/
You can also create/access anonymous arrays directly in the hash; $foo{array} = ["this", "that", "other thing"]; foreach my $bar in (@{$foo{array}}) { print "Bar is: [$bar]\n"; } 
yes, thought it might be something like that. thanks
thanks
thanks
&gt; Holy smokes, that's spectacular. cf ["quite remarkable to fit that much context in so few characters"](https://www.reddit.com/r/ProgrammingLanguages/comments/7t9tp1/a_word_histogram_script/dte04eh/) and ["I see that perl people did not learn anything from perl5 decline ;)"](https://www.reddit.com/r/ProgrammingLanguages/comments/7t9tp1/a_word_histogram_script/dte04eh/). &gt; Interesting that Perl6 uses '»' instead of 'map' or more accurately 'parallel-map' (or parmap, pmap, etc...) for the name of that operation. Oops, I forgot to return to that point in my previous post. * To a newbie, `»` is a very simple construct. It's just a data iterating construct, a way to say "do the single thing on the right for each element of the list of things on the left". * Explicitly evoking parallelism in the operator's name would pretty much force someone to at least momentarily think about parallelism when encountering it, which is typically unnecessary cognitive complexity, especially for a newbie to P6, double especially for a newbie to programming in general. * If, despite the foregoing, @Larry had chosen to explicitly evoke parallelism anyway, it would presumably have had to emphasize that it's only *possible* parallelism based on speculative optimization. Perhaps `possibly-parallel-map` or `ppmap`? * Even `.ppmap({.uc})` is significantly longer, uglier, and cognitively challenging than `».uc`. In contrast, a newbie can pretty much just *ignore* `»`s and code will still read well. &gt; Can you use &gt;&gt; instead? Yes, you can use `&gt;&gt;` instead of `»`. That said, `»` is not a weird Unicode character. It's supported as the character corresponding to the decimal integer `187` in the encoding schemes used for the vast majority of today's extant text.^1 ---- '»...' approximates to syntactic sugar for `hyper.map(*...)`. So I could have written eg: .put for words() .hyper .map( { .uc } ) .Bag .sort( { -.value, .key } ) .hyper .map( { .key ~ ' =&gt; ' ~ .value } ); If either of the `hyper`s is deleted you're just removing hints to the compiler that it's allowed to parallelize the `map`s. ---- ^1 Summarizing info gleaned from wikipedia... Unicode, since 1991, has included `»` as codepoint 187 as part of the "Latin-1 Supplement" block that's basically Unicode's adoption of ISO-8859-1. In turn, ISO-8859-1 is essentially same as Windows-1252. Unicode Latin 1 aka Windows-1252 aka ISO-8859-1 is: * "probably the most-used 8-bit character encoding in the world"; * The standard encoding specified for HTTP MIME types beginning with "text/"; * The standard encoding specified for textual HTTP headers; * The standard character repertoire specified for HTML 3.2 documents. (4.0 went Unicode.) * The encoding most commonly *assumed* for text on Unix and Microsoft Windows in the absence of locale or other information. (This is gradually being replaced by Unicode encodings, primarily UTF-8.)
I just had to refresh my memory on this and similar data structures in perl. I found the answers by looking up `perl hash of lists` and, for my purposes, `perl list of hash`. I think there are man pages for those. The results were very helpful. The syntax is a bit awkward, but you've gotten good answers already. 
Here are some core perldocs that have relevant info: http://metacpan.org/pod/perldata https://metacpan.org/pod/perlref https://metacpan.org/pod/perllol
Is this homework? the bullet points make me think that it is, and if that's the case it would be polite to tell us. I think you might be overthinking this a bit. I don't think there's any need for communication between the two processes other than a blocking lock on the file. I'd solve this problem something like this: #!/usr/bin/perl use strict; use warnings; use feature 'say'; use Fcntl qw[:DEFAULT :flock]; my $max = shift || 10; my $file = 'count.txt'; my $proc = fork ? 'Parent' : 'Child'; while (1) { sysopen my $fh, $file, O_RDWR|O_CREAT or die "Can't open file: $!\n"; flock $fh, LOCK_EX or die "Can't lock file: $!\n"; my $num = &lt;$fh&gt;; $num //= 0; last if $num &gt;= $max; say "$$ [$proc]: Writing file"; seek $fh, 0, 0; truncate $fh, 0; print $fh ++$num; close $fh; sleep 1; } It's possible I've missed something in your spec that means it can't be this simple. 
I think the [data structures cookbook](https://perldoc.perl.org/perldsc.html) is a very useful resource here.
socket, connect, bind, etc. are all built in too, and yet... In this case a wrapper that hides the protocol etc. and just gives you a pipe like interface would be nice because I'm lazy.
Thanks for the longer explanation. I guess the bit that strikes me as odd about Perl 6 and the use of Unicode characters is that they're not on my US keyboard. &gt;&gt; is hold shift, hit period key twice, release shift. '»' is hold-ctrl, hold-shift, hit 'u' key, release all three keys, type 0, 0, b, b, press spacebar. The » is more compact on screen, but that's more awkward to do and to remember. And as someone new to Perl 6, '&gt;&gt;' already has several other possible meanings from shell scripting and C++, 'append', 'input', and 'bit shift'. Now, I imagine a horde of people using Perl 6 might never need to deal with C++ input handling or shifting bits in any of the C-derivatives. But appending content in a shell script is a common thing, so I think the naming collision is still unfortunate. I prefer the hyper.map option. Thanks again for the thorough explanations. 
You don't want to store the reference as a *key*, store it as a **value**. You're probably thinking the right thing but you should learn to be particular about the terminology. It sounds like you've already got the basic idea down: use a hash as a data structure to store a bunch of attributes. Now you just need to work on your understanding of references so you can create complex data structures: arrays of hashes, hashes of hashes, arrays of hashes of arrays, etc.
I think the perllol doc is the one I was recalling. Thanks for this list, though. I'm a little rusty with advanced perl, I used to be quite adept. 
&gt; I guess the bit that strikes me as odd about Perl 6 and the use of Unicode characters Please indulge a nit, just to get it out of the way: this isn't really about Unicode.^1 &gt; [some characters are] not on my US keyboard. Like pretty much any other proglang, all P6 code can be typed, and looks at least OK, using standard 7 bit ASCII characters. This isn't any help to someone with, say, a chinese keyboard, but works reasonably well for someone with, say, a US keyboard, with `&gt;&gt;` being about the worst case. &gt; `&gt;&gt;` is hold shift, hit period key twice, release shift. Most P6 devs who care about such things [create a keyboard shortcut](https://docs.perl6.org/language/unicode_entry). Even devs who haven't bothered to install a shortcut still only have to hold and release shift, while press one key twice in between. Do you know a language that supports a parallel map operation, with its parens or whatever else it uses to syntactically fit with the mapped operation, in *less* keystrokes? Here's `&gt;&gt;`, plus the existing alphabetic alternative already built in to P6, plus what it could look like if as brief as seems possible: data&gt;&gt;op ; data.hyper.map(*op); data.pmap(*op); &gt; And as someone new to Perl 6, '&gt;&gt;' already has several other possible meanings from shell scripting and C++, 'append', 'input', and 'bit shift'. Oh, sure. Any use of words, or imagery, or symbols that shifts their meaning has a cost. It had better darn well be worth it. &gt; the naming collision is still unfortunate Well, it was done with eyes wide open. It's not like @Larry didn't know shell and C derivatives far better than most programmers alive. It was considered worth the pain. &gt; I prefer the hyper.map option. :) P6 is about being extremely reasonable and practical, even if it can appear to be the opposite. &gt; Thanks again for the thorough explanations. You're welcome. :) ^1 To quickly reiterate something I was obliquely pointing out in my previous reply, this isn't about Unicode: * `»` isn't a "Unicode character" (unless one defines all characters, even `a`, `b`, etc. as Unicode, which renders the Unicode labeling moot). * `»` was already a very common character around the world by the time its encoding as decimal `187` emerged as the consensus de facto standard worldwide in 1985. This was years before the earliest activities that led to the creation of the Unicode consortium and its standards in the 90s. At this point in 2018 it's one of the most ubiquitously used characters outside of 7 bit ASCII in terms of input, fonts, and correct handling by the vast majority of software, new and old alike. 
What a *darn* shame.. *** ^^Darn ^^Counter: ^^59660
Moose shed their antlers every winter, and grow back in the spring covered in vascularized velvet for blood flow.
bad bot, but you made me laugh
Thank you ether\_reddit for voting on AnimalFactsBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
ether_reddit has been unsubscribed from AnimalFactsBot. I won't reply to your comments any more.
well that's a bit of an overreaction :( what if I want blue-footed booby facts, or panther facts?
That does look like a great reference. 
That does look like a great reference. 
&gt; When I iterate through the items in {SummaryText} I get the output: ARRAY(0x7fc763e0a0d8) `$key{SummaryText};` is a key holding a reference to an anonymous array. If you want to iterate over its content you must first direference it with something like `@{$key{SummaryText}}` and then loop over its elements. As for how your data structure should look like, I think a hash representing the root directory should do the work where a key is either the name of a subdirectory which holds a reference to an anonymous array of anonymous hashes containing the files' details or the name of a file which holds a reference to an anonymous hash containing the file's details. For example, a directory with the following file structure dir/ |---- mammals/ |---- giraffe.txt |---- whale.txt |---- birds/ |---- eagle.txt |---- computer.txt |---- retrowave.txt could be represented by the following data structure: my %dir = ( "mammals/" =&gt; [ { size =&gt; 15, MD5 =&gt; 'dac9630aec642a428cd73f4be0a03569', filename =&gt; 'giraffe.txt', owner =&gt; 'LW', permission =&gt; 'rx', summaryText =&gt; ["Hey, we're elephants, we love giraffes."], }, { size =&gt; 20, MD5 =&gt; '5aa90e2b89e67b8c30b995ce16863e31', filename =&gt; 'whale.txt', owner =&gt; 'JE', permission =&gt; 'rw', summaryText =&gt; ["This file is about mammals."], }, ], "birds/" =&gt; [ { size =&gt; 12, MD5 =&gt; 'b2df7bd755e831752e533934475aede7', filename =&gt; 'eagle.txt', owner =&gt; 'AL', permission =&gt; 'x', summaryText =&gt; ["This file is about eagles."], }, ], "computer.txt" =&gt; { size =&gt; 15, MD5 =&gt; '30fd3933f4f6b3aeece038dad5b576bb', filename =&gt; 'computer.txt', owner =&gt; 'LW', permission =&gt; 'rw', summaryText =&gt; ["What's my file extension?"], }, "retrowave.txt" =&gt; { size =&gt; 20, MD5 =&gt; '6052a5b3295f8c7c35718c4351d5976a', filename =&gt; 'retrowave.txt', owner =&gt; 'JE', permission =&gt; 'rw', summaryText =&gt; ['this is retrowave', 'this is supposed to be a summary'], }, ); If you want to add a new file to a subdirectory: my %lion; $lion{filename} = 'lion.txt'; $lion{size} = 18; $lion{owner} = "AT"; $lion{MD5} = "8c7c35718c4351d5976a6052a5b3295"; $lion{summaryText} = ["This file is about a lion."]; # Pushing it to the subdirectory mammals/ push @{$dir{"mammals/"}}, \%lion; Iterating over the main directory and its subdirectories: for (keys %dir) { if (ref $dir{$_} eq 'ARRAY') { for my $file (@{$dir{$_}}) { print $file-&gt;{filename}, "\n----------------\n"; printf("%-12s %10s\n", "Size:", $file-&gt;{size}); printf("%-12s %10s\n", "Owner:", $file-&gt;{owner}); printf("%-20s %10s\n", "MD5:", $file-&gt;{MD5}); printf("%-20s %10s\n", "Summary text:", $file-&gt;{summaryText}-&gt;[0]); print "\n"; } } if (ref $dir{$_} eq 'HASH') { my $file = $dir{$_}; print $file-&gt;{filename}, "\n----------------\n"; printf("%-12s %10s\n", "Size:", $file-&gt;{size}); printf("%-12s %10s\n", "Owner:", $file-&gt;{owner}); printf("%-20s %10s\n", "MD5:", $file-&gt;{MD5}); printf("%-20s %10s\n", "Summary text:", $file-&gt;{summaryText}-&gt;[0]); print "\n"; } } And you get something like this if you wanted to print it out: retrowave.txt ---------------- Size: 20 Owner: JE MD5: 6052a5b3295f8c7c35718c4351d5976a Summary text: this is retrowave eagle.txt ---------------- Size: 12 Owner: AL MD5: b2df7bd755e831752e533934475aede7 Summary text: This file is about eagles. giraffe.txt ---------------- Size: 15 Owner: LW MD5: dac9630aec642a428cd73f4be0a03569 Summary text: Hey, we're elephants, we love giraffes. whale.txt ---------------- Size: 20 Owner: JE MD5: 5aa90e2b89e67b8c30b995ce16863e31 Summary text: This file is about mammals. lion.txt ---------------- Size: 18 Owner: AT MD5: 8c7c35718c4351d5976a6052a5b3295 Summary text: This file is about a lion. computer.txt ---------------- Size: 15 Owner: LW MD5: 30fd3933f4f6b3aeece038dad5b576bb Summary text: What's my file extension? 
It's good when brands are honest and clear. Perl 6 and Perl 5 are two distinct languages. Yes - they both share the "Perl Way" - but the two languages are different - the Perl Foundation should be clear and unambiguous about that. "Perl" is a master brand and we need distinctive sub-brands for the respective language(s) and Perl-related projects, conferences etc. The Apache foundation have done this really well. The goodwill in the "Apache Way" is protected by the "Apache" master trade mark - in combination with the numerous Apache subprojects: Apache Ant, Apache Cassandra, Hive, HBase, Ignite etc etc. Subprojects are free to come up with their own sub-branding. The Apache community ecosystem is thriving and growing. Who would have thought it was once 'just' a web server? They protect the Apache way through their management of the "Apache" master mark - while creating a thriving space for sub-projects to grow. The Perl community and its numerous subprojects can grow likewise. The honest reality is the "Perl" trade mark has outgrown its original use - a designator of just one computer language. "Apache" is now much more than just a webserver. "Perl" is now much more than just one language runtime. Let's be honest about that. Just like the master "Apache" trade mark. "Perl" is a master trade mark of the "Perl Way". We should create distinctive, sub-brands for each language/project - ideally something non-numeric to avoid "versioning" the brands into the future. This will mean honest communication in marketing, effective branding and no collisions on the command-line! I wish the Perl Foundation would take the lead here and get a grip of this. Taking inspiration from the Apache Foundation's master brand model would be great for Perl. There is lots of opportunity here for clarity, honesty and growth. 
Cache invalidation only gets complicated when you need the answer to be 100% accurate every time. If you can tolerate a little bit of eventual consistency (and ***very*** often applications can), you don't necessarily have to think about co-ordinating the consistency yourself, just make sure the caching of the element is time based (say, no more than 30 seconds or so). You still get the drastic speed benefits of caching, but without the hassles of implementing the logic to the same degree. The way you're implementing it here, though, Nginx cannot handle that logic for you. You're dropping a file in place that Nginx will take as the gospel truth in perpetuity, until the back-end application decides to do some clean-up work, and you're going to have to put something specific in place there to handle it. The application logic is arguably going to get needlessly complicated. Unless you're spinning up a brand new perl process on every single request, I can almost guarantee you'll find using a simple cache in perl will be almost as quick as Nginx (and will make any metrics generation story a lot simpler) If you are really determined to use Nginx to cache your response, you would probably find it a lot easier to leverage Nginx's native fast_cgi caching. Digital Ocean has a good write-up on how to do this here: https://www.digitalocean.com/community/tutorials/how-to-setup-fastcgi-caching-with-nginx-on-your-vps That gives you all the caching without having to do *anything* on the back end. No dropping files around, just give nginx a directory, size and time limit in the config file and away you go.
I have to agree, that's a pretty good idea. 
Well put. Use the Perl name as the the parent framework for all the Perl projects. Perl5, Perl6 , Rakudo compiler, Moarvm etc..
[removed]
I'm sorry, I did read your earlier comment about » as decimal 187 in the standard ISO-8859-1... so I don't know why I was so incorrect with my comment when I really meant "non vanilla ASCII characters". I wrote keyboard driver mappings character mappings, most often in that standard, for international keyboards almost half a lifetime back. And it's hilarious that I forgot Larry Wall, of all people, was the one that decided to apply the » operator that way. Obviously he understood at least as well as anyone else the operator overloading he was consciously choosing to do.
`push` is not being used to push an array onto a hash. You have misread it. @archivedetails is the top-level array. Its members are refs to the per-file hashes. 
&gt; When I iterate through the items in {SummaryText} I get the output: ARRAY(0x7fc763e0a0d8) If you mean that `$archivedetails[0]-&gt;{SummaryText}` returns `ARRAY(0x7fc763e0a0d8)`, that is what it is supposed to do. You need to go into that array and work with its contents. If you are in fact getting into that array, looking at `$archivedetails[0]-&gt;{SummaryText}-&gt;[0]` and you're still seeing `ARRAY(0x7fc763e0a0d8)`, that means you have stored arrayrefs into your SummaryText array, which it sounds like you don't intend to do. I recommend reading [perlreftut](http://perldoc.perl.org/perlreftut.html) to get clear about nesting data structures.
I'm sure it helps that K3, J, and APL do not *look* like one name with different version numbers :-)
thanks
&gt; The honest reality is the "Perl" trade mark has outgrown its original use - a designator of just one computer language. That's not clear to me at all.
Unfortunately there is no way to tell what the context of an expression is in general until that expression is actually evaluated. Consider: sub foo { @stuff } foo(); my $count = foo(); my @things = foo();
Thank you. Your comment sounds like exactly what I need to head in the right direction. I will post code, if I get it working. This IS homework, so I don't want the answer. The solution posted by davorg does not always alternate child &amp; parent anyway, but I appreciate everyone's help. This assignment has been really stressing me out. Thanks! 
It's always list context. Where the context changes is the three `foo()` expressions.
Incorrect. Context doesn't exist until runtime, when foo is called.
I was not told this was a learning exercise, so I gave answers for solving this problem in the real world.
I've been assuming all along that this is a uni / college assignment, I might well be wrong. 
You might have to do some more reading for that one. It's not a system call though. 
&gt; in general That does not prevent OP from coming up with a solution that's "only" 90% automated; in a sufficiently advanced text editor the remaining missing highlighting could be displayed as "unknown until runtime" and could be provisionally manually resolved by the user.
I've given this some tought when working on a hobby project of mine; it's a typical frontend application that talks to something backend to retrieve its data. However, the backend data repository is subject to change. Right now it's a database, but not long from now it will be _both_ a database and a REST endpoint. So my idea was to create a backend layer/API (on top of the _actual_ data) so that I only need to change that, instead of having to change that _and_ the frontend code. Is this in line with the repository pattern? And are there any good examples in Perl (and Moose) out there?
No, they don't. I'm not sure where you are getting this idea. Additionally these are only one very trivial example; you can have infinitely more complex expressions, with unknown context because they will be returned (or not, if void context) from a do block, an eval block, etc, and these situations can be nested in one another.
Sure, you could guess pretty well for some cases, if that is helpful to you.
You're right. The docs of `return` explicitly state that the context is variable and is decided in runtime. I Plus, I just found out arrays vs lists keep their identity across a function return and behave differently in the scalar context of the function call: perl -le 'sub a { @a = qw(foo bar baz); @a } sub l { qw(foo bar baz) } print scalar a; print scalar l' prints 3 baz 3 is array in scalar context (size), "baz" is list in scalar context (last element). So can we have a bright-red background color for expressions in runtime-context? :D
Yep, that difference is actually because as I mentioned if you evaluate a "list" in scalar context it's not even a list, but a series of items combined by the scalar comma (first sentence of https://metacpan.org/pod/perlop#Comma-Operator). `qw(foo bar baz)` of course has no actual comma but is special cased to work the same way (https://metacpan.org/pod/perlop#qw/STRING/). *Everything* is in runtime context, I think the difference you're looking for is expressions you can guess the context of based on their surroundings, like explicit assignment to a scalar or a list. Here's another fun one I just thought of. foo(@array) You would expect `@array` to be list context, as most functions work this way by default. But prototypes can screw this up. sub foo ($) { ... } This will now evaluate @array in scalar context.
Yes, I mean whether you can tell/guess the context statically or not. That prototype example is scary. Perl is just an infinite source of fun, isn't it?
I prefer to think of it as "resistant to static analysis". (Which is why the old saying goes "only perl can parse Perl".)
thanks. i'll try that
Not equivalent exactly, because the focus of perl is considerably broader than `R`. But in terms of creating an application on a server, you can do some nice things using Mojolicious. 
You might be able to plug pdl into IPython. See also App::Prima::REPL 
What is your goal? What is R Shiny?
Selenium and PhantomJS were the ways to run javascript in headless applications, but now chrome headless (like the module you mentioned) is the way. Another implementation is at https://github.com/jberger/Mojo-Chrome (not yet on CPAN) but I haven't tried either one.
[WWW::Mechanize::PhantomJS](https://metacpan.org/release/WWW-Mechanize-PhantomJS) - headless WebKit is another option, which I used a few times for scraping.
You’d use jupyter these days. https://github.com/EntropyOrg/p5-Devel-IPerl
So I have near zero Application UI development skills. I actually have very little Perl skills, but I can cut and paste other people's ideas and code. So borrowed [Joukes Wx tutorial](https://www.perl.com/pub/2001/09/12/wxtutorial1.html/) and [jmlynesjr's wx examples](http://www.perlmonks.org/?node=More%20WxPerl%20Examples) to create something that can convert +------------------------+ |T Calculator | +M-----------------------+ | [ ] | | { V }{ % }{ C }{AC } | | { 1 }{ 2 }{ 3 }{ + } | | { 4 }{ 5 }{ 6 }{ - } | | { 7 }{ 8 }{ 9 }{ * } | | { . }{ 0 }{ = }{ / } | | made with GUIdeFATE | +------------------------+ into a graphical interface. A visual interface editor without needing anything more than a text editor. Of course likely to be buggy, may be useful for other noobs, but hopefully will teach me something and make graphical application development much quicker.
As a noob programmer, with little graphical interface design skills, but an ability to cut and paste other peoples hard work and knowledge, I am trying to develop a simple way to create graphical applications using nothing more than a text editor. Credits to [Jouke's wx Tutorial](https://www.perl.com/pub/2001/09/12/wxtutorial1.html/) and [James M. Lynes, Jr.](http://www.perlmonks.org/?node=More%20WxPerl%20Examples) in creating this module that can convert something like: - +------------------------+ |T Calculator | +M-----------------------+ | [ ] | | { V }{ % }{ C }{AC } | | { 1 }{ 2 }{ 3 }{ + } | | { 4 }{ 5 }{ 6 }{ - } | | { 7 }{ 8 }{ 9 }{ * } | | { . }{ 0 }{ = }{ / } | | made with GUIdeFATE | +------------------------+ into something that looks like a desktop application... Criticism and suggestions welcome.
This is a really cool concept. I'm going to have to give it a try. A screenshot of the rendered conversion in the github repo could be helpful, too.
New to github as well. just figured out how to do what you suggest...;)
Very neat! GUI in perl has never been a simple task. Just a few stylistic criticisms (let me know if you want clarification/reasoning for any): 1. You should really use strict and warnings in each file, and don't use -w in the script's shebang. 2. I'd recommend putting MyFrame in its own .pm file, and namespacing it like GUIDeFATE::MyFrame (so it would go in GUIDeFATE/MyFrame.pm). 3. The convention is to put all perl modules in projects under a lib/ directory. Then in your main script you can do `use lib 'lib';`, or run it like `perl -Ilib calculator.pl` to load it for that execution. 4. It's best to use `parent` rather than `base` as it's much simpler; you are already using it in some places, so just make it consistent. 5. There's no reason to do `package Main;` in the script. The default package is `main` (note the casing) and scripts should not generally change packages. Additionally this causes you to not be able to use the `$frame` variable you imported into `main` just above. 6. No need to use GUIDeFATE twice in the script; one `use` statement with the import args you want is enough.
I'll second the "this is cool" vote. Maybe take a look at http://perldoc.perl.org/perlnewmod.html for some ideas on how to stuff it into CPAN. 
Yeah, R itself has a much more specific scope than Perl itself, as /u/sobrique has said. Shiny is a "web framework" for R, so that is, of course, more limited than any framework for Perl. Because there are fewer things you need to be able to express in a web context. Basically, everybody making a web frontend for R is coming from _essentially_ the same place (not to take away from R's power or anything). With Perl, on the other hand, you never know what might be needed, because you can be dealing with system admin stuff, used car inventories, picture galleries, genetic data, census data, income tax preparation... literally anything. I guess my main question is the standard one: What is it you're actually trying to achieve? Is it something that is very much like what we see in Shiny, but you would just rather write Perl than R? I think big difference between Shiny and pretty much any web framework in any full-featured language (like Perl, Ruby, Python, Node, etc) is that Shiny concerns itself with the front-end in a way that doesn't make sense in frameworks for languages with a larger scope. Because it can. For the reason I stated earlier -- because they know that most users of R are doing the kind of stuff -- they can make pretty good predictions about the kind of user interfaces that will be needed. You could do that in a Perl framework, but it's a much better idea to leave that to existing front-end frameworks. Like bootstrap, as a pretty generic example. JQuery-UI is another one. Interestingly, I looked at some HTML source of some apps in the Shiny gallery, and Shiny seems to make use of Bootstrap. So Shiny has its own UI layer, which abstracts the usage of Bootstrap (and other things, I guess), so make it relatively simple to get from your R code to a front-end. That's cool. But if you were going to do that with Perl, then you would have a framework that does only some of that. For example, here's what I do: I use Dancer for the routing and controller code. Dancer supports different kinds of templates, including one called Template Toolkit, which is the one I use. Once I'm in the HTML code in the template, then I'm outside the scope of anything in Perl, and from there I use Bootstrap, for starters. As a data source, I might be using Redis, or if I need something relational I'll use MySQL, and for the Perl side of that I use Rose::DB::Object (lots of people use DBIx::Class). I have no idea if any of this is helpful, so I'll shut up now :) 
A long time ago, I used WWW::Mechanize::Plugin::JavaScript for this, and it worked better than I expected. Looks like it's been pulled and superseded by [WWW::Scripter](https://metacpan.org/pod/distribution/WWW-Scripter/lib/WWW/Scripter.pod). I suspect direct browser integration will work better, but I think it's cool that you can go without.
No if you want those Shiny widgets for interactive data visualization/exploration. For generic web server app, Mojolicious can do more than what's in the R space. 
Thanks..this is exactly what I need. I am rather poor at understanding ideal coding styles, namespaces and file locations, so your advice is useful. About having two pm files, (as I say I got this from a tutorial by Jouke written in 2001)...I am not sure if it would be better to try and merge the packages into one, nor am I sure how I would do it. Ultimately I would be trying to be able to create TK, GTK, ncurses or HTML interfaces, based on the environment.
Ok will try, thanks. A menu bar is also my next target. I want to try and accommodate the ability to draw on a surface of the window in Perl (viewing images, drawing graphs, sprites etc).
Gtk3 WebKit2 bindings for example: https://github.com/potyl/Webkit
Perl 6's assortment of sigils, twigils, and sigil-less terms does a fine job for me. If I wanted to indulge I could wish for a *'definite-assignment'* sigil/twigil: something that stays as a type object by default, but on assignment/binding accepts only definite values. Without thinking much on what it'd look like, say, let it be `$D|` for definite, `$U|` for type objects, then this: class Foo { has Int $D|.foo; } Would be equivalent to this: class Foo { has Int $.foo; submethod TWEAK () { %_&lt;foo&gt;:exists and -&gt; Int:D $!foo {}(%_&lt;foo&gt;); } method foo is rw { Proxy.new: :FETCH{ $!foo }, :STORE(-&gt; $, Int:D $!foo {}) } } So essentially it's a `:D` type-smiley constrained variable but whose default-default is a type object: .foo.say with Foo.new: :42foo; # :D ok .foo.say with Foo.new; # missing OK (try Foo.new: :foo(Int)) orelse say 'typecheck failure'; with Foo.new { .foo = 42; .foo.say; (try .foo = Int) orelse say 'typecheck failure'; } 
That'd be pretty cool actually :D
This. Is. Cool. I won't repeat prior stylistic comments, except to emphasize 'use strict', 'use warnings', no -w and '#!/usr/bin/env perl' Reading one of your comments about extending to TK, GTK, etc, start thinking NOW about how you'd break this code up to support that. Start looking around at other modules that do environment abstractions and see how to split up the code so that you can just plug in TK, GTK at a later date, OR, maybe SOMEONE ELSE can contribute TK or GTK. I would pursue that, before dealing with menus or fonts. I wouldn't want to create all that stuff and then have to unwind it later. Now's a good time to modify the architecture - not too early (you have something to work with), not too late (code not that big yet)
I'm sorry, but these titles are becoming more ridiculous. I feel like hiding the post instead of being compelled to read it. This is not good for Moose. 
Sigils represent a formalized kind of [hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation). It's turned out that such things are easy to get wrong and hard to be as useful as they are intended. On the other hand good notations make reasoning about code easier. I'll be interested in seeing unicode wingding characters start appearing in this role. 
**Hungarian notation** Hungarian notation is an identifier naming convention in computer programming, in which the name of a variable or function indicates its intention or kind, and in some dialects its type. The original Hungarian Notation uses intention or kind in its naming convention and is sometimes called Apps Hungarian as it became popular in the Microsoft Apps division in the development of Word, Excel and other apps. As the Microsoft Windows division adopted the naming convention, they used the actual data type for naming, and this convention became widely spread through the Windows API; this is sometimes called Systems Hungarian notation. Hungarian notation was designed to be language-independent, and found its first major use with the BCPL programming language. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Honestly? My idealized version would be to make sigils completely optional. Here's why. Sigils in Perl5 were intended to be a visual marker for determining types. crashorbit already mentioned Hungarian notation. Since Perl5 has the 3 built-in types scalar, array and hash, it's three sigils to distinguish those. But since you know Perl, you immediately know that this is a lie. There are more than 3 built-in types, which you see by taking references of various things. There are also regexp objects, formats, globs, coderefs, lvalues, and version objects among other stuff. Those just don't have a dedicated sigil and work just fine. Code and globs even have their own sigil, you just rarely see them. And it gets really muddy when using objects because all classes behave differently but are lumped together by the common type that their reference has: scalar. So you say: Aha, but Perl5 has 3 different _contexts_, and you can see the context from the used sigil. To access a scalar value from an array or a hash you have to use a $-sigil. Makes perfect sense. But there's no hash-context. Instead there's list, scalar and void context. So that doesn't work out too well either. And in Perl6 it's not only different but also inconsistent because Perl6 allows you to overload operators. So to access a scalar from an array you write @array[$index], but to access a scalar from a buffer you write $buffer[$index], because the buffer is an object, stored in a scalar with a post-circumflex[] method. Makes sense internally, but is bonkers when justifying sigils. So what do sigils actually do in Perl5? They resemble shell, make syntax-highlighting easier, and make runtime access slightly faster because the type of the requested element can be predicted by the parser. In an idealized world I'd don't need the first, and get the other two by having the language statically parseable. Perl5 will never be fully statically parseable without seriously restricting the language both practically and in design, but I'd argue that all real life production code comes with implicit guarantees for types anyway, otherwise it's not realistically maintainable. Making it easier to capitalize on these implicit type guarantees, both when parsing to find errors early, and during runtime to find errors and speed up execution would be something I'd really like, but which sigils in their current form simply can't deliver. Twigils on the other hand do have their value, and that is for making universal methods and variables without having to worry too much about screwing up the namespace down the line. There's I'd say it's a tradeoff between cognitive load (use English exists ofr a reason) and what you can do with it. I don't think I have a preference on this one.
Precisely, sigils are useful because they give the person *reading* the code an immediate, obvious hint about what kind of thing they're looking at. The main problem with them in perl5 land, in my opinion is that for any serious work, you tend to want to use references to everything, so everything has a $ on it, and to distinguish *what* you're taking a reference to you're left hacking in your own hungarian, or living without. I'm still learning my way around perl6, so no comment as of yet, except that I appreciate that the sigils are more stable (if you want to do, say, a text search on an array named @array, it's useful to be able to search on that without worrying about the alternate form $array[$i]). My policy: Use sigils whenever a reference isn't explicitly needed-- e.g. a sub that creates a data-structure should use @ or % internally, and then return a reference to it. Use a naming convention to indicate when a scalar is really a reference to a composite entity. Damien Conway recommended "_ref", but I think if you're going to go that far you might as well use "_aref" and "_href" to distinguish. I find that just using plural names on composites, and singular ones for individual items clarifies things pretty well. foreach my $item (@{ $items }) { ... } 
They also provide namespacing: sub xyz {} and $xyz for example. This is one of the features I miss the most in, say, C++ or Python.
Thank you. Sound advice.
Well that error is because you're missing the closing single quote for the awk command on the `my $times2` line. You're also missing the backslash before `$0` on that line. I'm not sure what is going on with the `$times1` line my $times1 = `awk -F'[: ]' '%H:%M:%S &lt;= $systime &amp;&amp; %H:%M:%S &gt;= $subsys What is using `%H:%M:%S` in a comparison supposed to do here? If you're shelling out to date and awk - it would probably simplify things to just write it as a shell script instead. 
I agree. There is not really any perl here. Here it is as a shell script: systime=$(date -u +"%H:%M:%S") subsys=$(date -u -v-600S +"%H:%M:%S") times1=$(awk -F'[: ]' '%H:%M:%S &lt;= "$systime" &amp;&amp; %H:%M:%S &gt;= "$subsys" { print }' /dir/dir/somelogfile) times2=$(awk -v start="$subsys" -v end="$systime" -F'[:]' '\$1\$2 &gt;= start &amp;&amp; \$1\$2 &lt;= end {print $0}' dir/dir/somelogfile) echo echo "$times1" echo "$times2" This can all be done in perl of course but it would look quite different.
I have looked a few posts in this series and I can't even figure out what it's about. It seems to be a long rambling novel chronicling the refactoring of some random application that does nothing in particular.
Without the current sigils of Perl5, a few very useful things would stop working: * Variable interpolation into strings * Addressing hashes with unquoted word-character strings * Unquoted word-character strings before fat commas `=&gt;` That would be hell.
Sure, but there are other ways to get that features. Ruby does a great job at 1 and 3, Lua solves point 2 neatly.
As others have pointed out, you're really not writing Perl here. A more Perlish solution would look something like this: #!/usr/bin/perl use strict; use warnings; use Time::Piece; use Time::Seconds; my $now = localtime; my $then = $now - (10 * ONE_MINUTE); while (&lt;&gt;) { my $time = ...; # code to extract timestamp from log record if ($then-&gt;strftime('%H:%m:%s') &lt;= $time and $time &lt;= $now-&gt;strftime('%H:%m:%s')) { # $time is in the last ten minutes } We've used [Time::Piece](https://metacpan.org/pod/Time::Piece) to get the times and you should note that the `while (&lt;&gt;)` construct reads data a record at a time from the file that is given on the command line (and stores it in `$_`). So if you put this code in `filter_time` and the log file is called `something.log`, you can then run this as: $ ./filter_time something.log It's up to you to a) write code that extracts the timestamp from each record of the log and b) do whatever needs doing if the record is in the last ten minutes.
You'll want the "w:pgSz" element from the document part. This page explains: http://officeopenxml.com/WPsection.php If you want, you can add support to extract metadata like this from Document::OOXML - I'll happily add it to the release if you can supply me with a pull request or patch :)
thanks for the info. that's very useful. I've no idea what you mean when you say pull request or patch. I'll see if I can parse the XML myself. thanks again
These are being posted by a bot. Either complain to the blog poster, or get whoever is running the bot to ignore his posts.
&gt; scalar, array and hash There's also subs.
I'd say all features should be targeted at the user ( especially in Perl ). Having such a big thing as sigils just for implementors is not a good idea. However, I -- as a user -- like sigils, because they make the nouns stand out and that's pretty helpful. I program a lot in APL and in this language expressions like a b c are ambiguous. It could either mean apply a to the argument list b c, apply a to b of c, the list a b c, the infix operator b applied to a and c, or a fork. With sigils it would be a $b $c, a b $c, $a $b $c, or $a b $c respectively. That's a feature for the user. 
What's with the obsession with moose feces in these articles?... That's literally a picture of moose shit used as a closing statement to a technical article.
nothing really changed, but you can use [WebKit2](https://webkitgtk.org/reference/webkit2gtk/stable/index.html) via [Glib::Object::Introspection](https://metacpan.org/pod/Glib::Object::Introspection) Glib::Object::Introspection-&gt;setup(qw[basename WebKit2 version 4.0 package WebKit2]); my $v = WebKit2::WebView-&gt;new;
Be careful with the case of your strftime sequences; you want `%H:%M:%S`, the lowercase versions mean very different things.
Seriously. **HOW THE HELL DO YOU PUT A PICTURE OF MOOSE POOP IN A PERL CODING BLOG**? This is not good for Moose. At all.
&gt; Getting there though, can be tiresome. I open a new browser tab, start typing “metacpan”, my browser then autocompletes it to the most recent metacpan address I viewed, which is inevitably not the one I want, so I highlight the module name in the URL, and replace it with the one I’m looking for. Chrome has very nice behavior for this. If you tab-complete metacpan.org (after visiting the site a few times) it will turn it into a working metacpan search right in your address bar.
Very cool. I can't wait to give it a shot when I've got the spare time! Nice to have more options to consider for prod deployments.
You can add keyword searches to Firefox and Chrome. In Firefox add a bookmark: `https://metacpan.org/search?q=%s` With the keyword `cpan`. Whatever you type after that will be filled into the `%s`. In Chrome, you add it as a new search engine with the same string above.
I usually type !perl Foo::Bar in the address bar and let DuckDuckGo open the metacpan page for me. 
These articles * are hard to read * every 2nd sentence or so starts with "Well" * need much more punctuation * use profane language * need a table of contents * need better titles * I'm tired of Moose!!
Let's say you did not understand a whole field (chemestry for example). Quora and google makes you search, search, post messages and wait a long time for a reply to give you a short text. Quora and google makes you read a ton of things. All by yourself. At the end of the week you did only a little bit of progress. This is long, lonely and painful. This program makes you call immediatly with skilled HUMANS. You just sit, relax and enjoy talking to them and will be dedicated to you to make you master the field. isn't it right ?
Hi everyone, thanks for the replies. I apologize if this wasn't perl and was posted in the wrong sub. Also, thanks everyone for the replies, it is really appreciated. 
Explanation: /u/treenaks maintains the Perl library [Document-OOXML](http://p3rl.org/Document::OOXML). He invited you to [contribute](http://enwp.org/Pull_request) an [improvement](http://enwp.org/Patch_%28computing%29) with the intention of incorporating the improvement into the library, and eventually releasing a newer improved version, so that its users may benefit from the change: getting the page size and orientation with some simple API calls instead of manually parsing the XML. Asking for a patch is a fairly common thing to do in our culture. Since you did not know what a patch is, it looks to me that you currently likely do not have enough knowledge to make a meaningful contribution. But it's a small enough hurdle to overcome if you are interested and already know some Perl. I invite you to learn how to prepare a patch, [Perlmonks](http://perlmonks.org/?node=Seekers%20of%20Perl%20Wisdom) or [your local user group](http://pm.org/) are glad to help.
That's not what we meant by it isn't Perl; indeed the code you pasted is Perl, and we don't mind. However most of the actual logic is shelling out so it's not very different from a bash script that's designed to do that. See /u/davorg's comment for an example of how you'd normally do things in Perl.
Thanks for pointing out my ridiculous errors. I've corrected them now, but I've left the epoch solution as an exercise for the reader :-)
I don't know the rules that well, but yeah, I can see why we might not want to have double-posts of every Perl question on stackoverflow. But, uh... your project doesn't even use Perl. The CGI script is written in bash, and all it does is print out "hello world", so it always "works". However, it certainly isn't stopping a bot. It's not doing anything.
What would be the pros and cons of running an app.psgi via this new nginx capability, vs. Starman, Hypnotoad etc.?
Oh yeah, good point. It's been so long since I did old-school CGI, I didn't even think about the headers. Right, so "success" is as simple as "I sent a request".
Huh?
Probably the same person who has been posting continuous Moose articles and has been getting downvoted lately. Report and move on.
Post better content instead of complaining.
To make it clear, this is not an extension for the Nginx Web server. It's an application container, a separate product. You can't serve non-Perl apps with Starman and Hypnotoad, at least without serious contortion. The real competitor is [uWSGI](https://uwsgi-docs.readthedocs.io/en/latest/LanguagesAndPlatforms.html), and [Unit](https://unit.nginx.org/#supported-application-languages) is late to the table.
Instead of going for quantity-over-quality, you could slow down, write one post per week, and have the entire week to go over the writing as well as what you're trying to say. Two weeks ago, a person [politely pointed out](https://www.reddit.com/r/perl/comments/7tj5ui/little_moose_tries_to_run/) the titles could be more descriptive about the content of the articles. 10 days ago, [a person with autism asked for clarification of the titles](https://www.reddit.com/r/perl/comments/7uqzb4/proper_moose/). Instead of taking that feedback into account, you went onto a scatological spree that culminated with [a literal picture of shit in your blog post](https://www.reddit.com/r/perl/comments/7wrxid/osti_d%C3%A9pais_de_marde_dorignal/). And today, you even went as far as mock that autistic person for pointing out a flaw in *your writing*, while [posting yet another worthless post](http://blogs.perl.org/users/byterock/2018/02/yamp.html) that trolls the other people who gave you feedback. Sorry, it's not *"r/perl lately"*. You just can't take a hint.
How does Unit compare with uWSGI? That's what I'm using.
Hashes are inherently unordered, but you can sort its values: my @sorted = sort { $a-&gt;{found_count} &lt;=&gt; $b-&gt;{found_count} } values %master;
Barring the application of something like Tie::Hash::Sorted (which comes with a major performance impact) a Perl hash can't be sorted in situ, and retrieval of elements by iterator is not guaranteed to have a consistent sequence. In your case you need to sort at access time with a custom sort function. foreach my $key ( sort { $a-&gt;{$key}-&gt;{found_count} &lt;=&gt; $b-&gt;{$key}-&gt;{found_count} keys %master ) { print Dumper($master{$key}); #do whatever } If you need to operate on sorted hashes frequently but your data needs to be able to be quickly updated by key (index), a technique that is frequently used is to store the data in a hash of hashes and then store an array of hash refs sorted however you want so that you maintain access to the data both by key and in sorted order. Of course it will be up to you to keep these consistent with one another.
Kick-ass regexes, scope not defined by indentation.
It works, and there's lots of ways to get things working. The programming world is grossly faddish and trend-obsessed, the beginnings of sanity is to get off of that merry-go-round. If you're using perl you'll never have to work with perl-haters, 
It usually takes me less time to code something in Perl than I expected. In a language like Java it always takes longer.
Are you use ironperlguy is byterock? You seem to be jumping to quite a few conclusions here.
What's not to like ? I think that people who don't like Perl never gave it any substantial time.
The OP is the person using the language directly disparaging members of community based on their medical conditions, which I called out. I couldn't care less whether they are or not byterock. They chose to defend them and haven't objected to the other commenters equating the two. That's sufficient-enough evidence for me. 
Perl's TIMTOWTDI lets you use it a lot like a natural language. In Perl I can I "speak". In many other language, I "code". 
I'm disappointed that so little response was given to the statement &gt; I mean, there isn't even arguments to functions It's an underhanded critique hiding behind the skirts of the question in the previous sentence that at least superficially appears honest. He could have formulated it as another question, e.g. "Is it true that there isn't even arguments to functions?", or "I can't believe there isn't even arguments to functions! Tell me it ain't so." I think that if answers do not address all the points a critic is making, they give a wishy-washy impression, and let him get away with his badmouthing, intentional or not. You didn't perhaps notice, but your brain did. We should be wise to those shenanigans, and not let outdated or untrue info to go unchallenged, especially since [in Perl you have a copious amount of choice of solutions for the problem space of signatures](https://stackoverflow.com/a/18390800/46395). And that's why I like Perl, it gives you the means to achieve the functionality Kavorka provides. Node.js for instance does not have the means, as there is no built-in macro system or the like in ES, so you need to use an external thing like sweetjs or babel, but they're all incompatible with each other. ---- Thanks for reading the rant to the end, I offer my [meme tax](https://i.imgur.com/vwqUzWB.jpg)
It was tte first language I learned. Very useful on Linux.
Perhaps people saw that that point was already addressed in [an answer on that page, from Dec '17](https://dev.to/val_baca/comment/1hai): &gt;| There isn't even arguments to functions &gt; Not true. It's just packaged differently.
Eh, I spent 3-4 years writing perl for 8h/day and loved it. Then I inherited someone else's (significant) codebase and understood the pain the power can bring. I ended up rewriting significant portions as it was faster than figuring out then existing properly.
I prefer Perl for the same reason I prefer English. It's my first language, and I'm able to truly express myself in it, better than in any other language. Just as with English, you can tell other languages are not my first. My phrasing is clumsy, my pronunciation is wrong, and I have to carry a dictionary with me everywhere I go. I can order off the menu, but I can't tell anybody what I _really_ thought of the food. More than that, though: Seriously, one-liners. I have not seen anything that does one-liners as well as Perl. I can just throw it into a pipeline, just like any other command.
I like the siguls, or rather I dislike when the lack of siguls makes data ambiguous in other scripting languages. With perl, by the time I got to the perl manual on lists of lists, lists of hash, hash of lists, etc... it was pretty much game over. Could do anything in perl.
Generally true, but the flexibility of perl does exacerbate the issue. With great power comes great responsibility, and perl generally gives the writer more leeway to confuse the future reader than most popular languages.
The real strength is in the combination of strict and lexical scoping. Variables defined exactly for the scope they are needed in, and compile-time errors when you screw that up.
If I don't like a feature, there are other ways to do it. If I don't like a syntax, I can roll my own. Perl feels a lot more like lisp than most expect. 
That answer is weak sauce marketing-wise, that's what I had in mind when I mentioned "little response".
`¯\_(ツ)_/¯` I guess not everyone wants to make their every interaction as if they were the Chair of Marketing at The Perl Foundation. A language is just a tool. Many don't swear their undying allegiance to The One True Lang when they choose to code in a Perl. Commercializing all interactions and obsessing about "marketing" takes quite a chunk out of actually having fun using the language, IMO.
You dropped this \ *** ^^To ^^prevent ^^any ^^more ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¯\\\_(ツ)_/¯`
You're stupid, bot.
ITT: why people like themselves. 
For me it's the quick access to powerful text-processing features, including but not limited to regular expressions - kinda like "awk" on steroids. 
They also say in the book: "Although Perl has been eclipsed by modern languages like Python and Ruby in most domains, it remains the king of quick-and-dirty text wrangling."
Because of modules [like this](https://metacpan.org/pod/Acme::Bleach) and programs [like this](https://metacpan.org/pod/rxrx). (Oddly enough, they're both by Damian Conway). 
Apparently, this will be the last installment for a while. I just hope the while is really, really long.
Seems to be some sort of ORM, but it's hard to tell without some structure whatsoever: what happened last time, what's up next...
This is a very cool concept. I wonder how you intend to link the graphical elements into the code? Say in the calculator example, how will the eventual program know what to do on button click and what should be shown in the text box? Solve that as cleverly as you have the layout and you might really be on to something!
Sorry for being off topic, but... &amp;nbsp; I hate you guys! :( &amp;nbsp; I sorta fell in love with Perl about 2 years ago, after I completed some tutorials online. It felt very powerful, fast, expressive.. &amp;nbsp; I almost felt I could do almost anything with it. Then, I started looking at code from the CPAN. I realized I was some 3-4 months of learning to even call myself a Perl newbie. I mean it felt that a lot of documentation (tutorials) online is outdated, and CPAN modules lack some basic information for noobs. Basically, 2-3 days later I felt like an idiot :) &amp;nbsp; So I am jealous of you guys, who managed to move past where I've been, and thrived :). &amp;nbsp; Currently I work as a sort of an automation engineer in Windows, using Powershell.
Actually each button press calls a function in the main program. The function name is "btn&lt;id&gt;" or "menu&lt;id&gt;" etc. When the window is generated, currently, the console reports each widget found, the reference to that widget and the associated function called. See [this example screenshot](https://github.com/saiftynet/GUIDeFATE/blob/master/test%20v0.0.2.png). You just have to code what happens when you click that button....I will be auto-generating these functions in a future iteration. 
Don't give up on it! Perl works when you know it inside and out but it still works when you don't. Even now I learn new things every day that make me look back at my previous code and go "well damn, that could have been way simpler/better". Also check the tutorials in the sidebar for some non-outdated ones!
Just block the bot so you don't see its posts.
I think there's a syntax error in third example. You can't omit type when using a type smiley (there's no clear default type for them, when you consider invocants, signature unpacking, and parametarization). Also, `:_` type smiley is discarded during parse stage (since that's the default), so specifying it is kinda pointless.
But the bot posts blog entries from other authors, doesn't it? 
I also posted it as a comment on blogs.perl.org
Wx? Is it available? I use ActivePerl and the only options I have are Tkx and Prima which gives me a runtime error with images. 
[Wx](http://www.wxperl.it/p/download.html) is available for [Windows](http://ppm.wxperl.it/). GUIDeFATE also uses [Wx::Perl::Imagick](http://search.cpan.org/~jouke/Wx-Perl-Imagick-0.02/lib/Wx/Perl/Imagick.pm) rather than Wx::Image. As for the TK version of this, I am just learning how TK works. Your advice would be appreciated. 
&gt; So the dilemma today is to decide what to call my next series ... Let's please dispense with the drama ... A conundrum does not a dilemma make.
Ah, I had seen that but for some reason I couldn't make it work at the time. I'll try again. Tkx is kind of a PITA to be honest, because there is zero documentation; you need to figure out how to translate Tk to Tkx. Most of the time is pretty straightforward but at times you need to use some arcane spells to make it work. 
I'd probably use a hash to determine the result, not elsifs. my @figures = qw( rock paper scissors lizzard spock ); my %beats = (rock =&gt; {scissors =&gt; 'crush', lizzard =&gt; 'crush'}, paper =&gt; {rock =&gt; 'cover', spock =&gt; 'disprove'}, scissors =&gt; {paper =&gt; 'cut', lizzard =&gt; 'decapitate'}, lizzard =&gt; {spock =&gt; 'poison', paper =&gt; 'eat'}, spock =&gt; {scissors =&gt; 'smash', rock =&gt; 'vaporize'}); my $computer = $figures[ rand @figures ]; ... if ($beats{$player}{$computer}) { say "You $beats{$player}{$computer} me!"; } elsif ($player eq $computer) { say "Draw."; } else { say "I $beats{$computer}{$player} you!"; } 
Much more efficient, thanks...will update the code for v0.0.4
&gt;kinda pointless Says the person proposing changing the default from :_ (whatever) to :D (defined). It specifies you don't care even if the default becomes requiring objects be defined if you don't say anything.
Increasingly programming has become about *signalling* - letting everybody know how smart, or educated, or privileged you think you are. Forums are getting snobby, righteous, preachy, and outright nasty. Way back when I did engineering the people I studied with couldn't care less about looking good or what people thought of them - they just wanted to learn and find the best answer to any problem. Nowadays we're increasingly seeing people who are obsessed with how they are perceived and want everybody to know exactly how great they are. And that makes programming forums rather distasteful as the joy of discovery has gone when others can't wait to judge anybody that fails to send the right signals.
Java requires everything to be typed twice - something Scala hoped to avoid - except that Scala had a host of other issues one needed to deal with - not least being a second-class language on the JVM.
&gt; using Powershell If you actually feel you're more productive using Powershell than Perl then you're crazy. Powershell *was* modelled on Perl, it is true, but the developers of Powershell introduced so many unusual default behaviours that the ecosystem is impossible to use beyond the most simple of scripts. Powershell is *stupid slow* - loops are so painful in Powershell that the only way to process any lengthy array is to add a C# .Net class to your script for processing that array. Meanwhile Perl does loops orders of magnitude faster than Powershell code. Powershell is completely unable to process text. It is literally impossible to output without Powershell introducing newline characters where it thinks you need them. This Powershell will *never* be capable of handling text files - something Perl *excels* at. A Powershell object - the fundamental unit used for practically everything - is so unwieldy as to be entirely impractical. It is memory hungry and painful. Do you really want to be piping an object to `Add-Member` every time you want to add a key to a hash? Perl's hash type is fast and efficient. I'm genuinely interested to know how you a) can tolerate working in Powershell, b) could possibly believe Powershell is *easier*?
&gt; Says the person proposing changing the default from :_ (whatever) to :D (defined). ??? what?
No, it isn't. The proposal is for `@` and `%` sigils to require a definite object and sticking a `:_` doesn't counteract that (the type smiley applies to a type, not a sigil). But why am I the person proposing it?
Sorry, my mistake. What type smiley one use if they wanted to specify "don't care if it's defined or not"?
In the proposed behaviour for `@` and `%` sigils? You'd use a `$` sigil or go sigilless and specify `Positional` or `Associative` roles as a type constraint respectively. The default behaviour is to accept both instances and type objects, so you don't need any type smileys (as mentioned earlier, the `:_` is simply discarded by the parser. Please note that `:D` specifies whether an object is [definite](https://docs.perl6.org/language/mop#index-entry-syntax_DEFINITE-DEFINITE), not [defined](https://docs.perl6.org/routine/defined). Definite objects *can* be undefined (e.g. `Failure` objects are).
Thanks for the terminology correction. Isn't it the case of creating a new type smiley to get the old behavior? Since the syntax will be changing anyway?
There won't be any change to syntax [in this proposal](https://github.com/perl6/6.d-prep/blob/master/TODO/FEATURES.md#sigils-imply-d). The only change is for `%` and `@` sigils to require instances rather than type objects. So this: &lt;Zoffix__&gt; m: my @a := Array; &lt;camelia&gt; rakudo-moar af4dfe827: OUTPUT: «1␤» Would throw like this: &lt;Zoffix__&gt; m: my Positional:D $a := Array; &lt;camelia&gt; rakudo-moar af4dfe827: OUTPUT: «Type check failed in binding; expected Positional:D but got Array (Array)␤ in block &lt;unit&gt; at &lt;tmp&gt; line 1␤␤» And it'll be done to prevent issues like this, where the user expecting a `Positional:D` instead gets the 1-el-list behaviour from the type object: &lt;Zoffix__&gt; m: my @a := Array; say @a.elems &lt;camelia&gt; rakudo-moar af4dfe827: OUTPUT: «1␤» If you *do* want that behaviour in 6.d, you'd use this: &lt;Zoffix__&gt; m: my Positional $a := Array; say $a.elems &lt;camelia&gt; rakudo-moar af4dfe827: OUTPUT: «1␤» Or this: &lt;Zoffix__&gt; m: my Positional \a := Array; say a.elems &lt;camelia&gt; rakudo-moar af4dfe827: OUTPUT: «1␤» -------------- The type smileys aren't involved at all in the proposal at all. The author of the proposal simply used `"imply :D"` as as shortcut to say `"imply requiring instantiated objects"`
Ok, the @ and % restriction makes it much narrower than I expected, thanks for the clarification.
Allow me to introduce myself :) Been working as a sysadmin/or similar positions for the last ~10 years in Windows environments. After a few years of learning how to do things manually, I came across vbscript, which I really hated for the lack of documentation and online help. I started learning it, and it seemed rather fast and powerful, as you sorta had access to some internal functions of the OS. Or at least that's how I felt. Then, I started looking at powershell. And started learning it. I can't say I enjoyed myself learning it. I had some C/C++ background and I felt some of the type conversions and things it allows you to do, or expects were.. blasphemy! Also the fact that the modules, even those that come from Microsoft have different syntax from the standard language, or from one another. But, I enjoyed the ease, how simple it accomplished many things. I mean once you get over the particularities, you can grow and really do some interesting stuff with it. On performance, yeah.. I realize it is very lazy, in comparison to almost any other scripting language. And I consider Perl a programming language, (generally I think that if a language allows you to call executables directly without using specialized functions, it will be a scripting language, otherwise it's a programming language). So to answer your second question directly, powershell was and is easier for me, because it allows me to get the job done easier, since I managed to learn as much as I needed to accomplish until now. Nevertheless, I still feel that there is much more to gain from Perl. I think I didn't have the resources at hand when I started learning it, and I'm afraid I don't have the time now, as we speak. Hoping that after I've finished my projects at work, I'll be able to go back and try again. I guess I'm not an intelligent person, just a hard working guy. Hopefully I'll get it eventually :)
Thanks, Zoffix.
Well... this is a somewhat rose-colored view of the past I'm afraid. The net at least as far back as the usenet of the mid-80s seemed full of guys posturing about how smart they are-- that was one of the main psychological motives people had for posting things... And just speaking for myself, that jazz never particularly bothered me: I wanted to hear from people who knew what they were talking about, I never cared much about how polite they were about it. Anyway, it is a point that technical people almost invariably make technical decisions for non-technical reasons (and then typically pretend otherwise). E.g. I met someone the other day who said they stopped using perl because they didn't like the way people reacted to him when he said he was a perl programmer. 
I added a short review of this post here: http://blogs.perl.org/users/byterock/2018/02/distzilla-a-bath-for-your-distro.html#comment-1796972 
FWIW, [Wx failed to install on my computers](http://paste.scsys.co.uk/572662?tx=on) for years now. The situation is pretty bad: * https://matrix.cpantesters.org/?dist=Wx * https://rt.cpan.org/Public/Dist/Display.html?Name=Wx You need to be aware that by depending on Wx the usefulness of your programs is greatly diminished because a great number of your potential users will be unable to install them.
[This page](https://code.activestate.com/ppm/Wx/) allows some versions to be downloaded, and you may need Alien::wxWidgets. But i can see this will be difficult for many users (yourself and Daxim both have issues). I will look into other GUI tool-kits that have up to date Perl resources. 
&gt; Tk backend...would that work for your systems better? Tk installs fine, but I personally don't want to use Tk applications. They look like shit (e.g. ignore font and application styling preferences), don't integrate into the desktop well, its widgets are few and at best only half as [accessible](http://enwp.org/a11y) as a modern UI toolkit. &gt; you have installed Alien::wxWidgets before installing Wx? Yes. That's not the problem.
Even if you could I wouldn't advise it. Apache is not a general purpose service manager. If your system happens to use systemd it's very simple to write a service file for a hypnotoad app, there's an example in the [cookbook](https://metacpan.org/pod/Mojolicious::Guides::Cookbook#Hypnotoad).
&gt; Btw there are more personal programming journals rather than than an instructional Blog. Unfortunate that blogs.perl.org is rather ill-equipped to handle someone deciding to blog for completely different reasons than everyone else on the site.
is kind a constant? Try: $info{ 'kind' } = 'WTN' if $id =~ /^\d{10}$/; 
Hmm, I think I'd just write a simple script to do that. Maybe: #!/bin/sh start_something &amp;&amp; service httpd start;
My first move is usually `du -ks /* | sort -n`. Not only do I specifically target the drive root, but I tell `du` to not summarize _everything_, but to summarize everything directly under the root separately. I don't ever bother with getting the usage of _individual files_. I deal with directories only, until I have better targeted where the problem is. This means I don't have a problem with sorting, because the list returning by `du` is always quite short, and easy to sort. Then, 99% of the time, I target the directory on the bottom of that sorted list (which, very often, is `/home`, I'm afraid. So then I repeat the command, but add `/home` to it: du -ks /home/* | sort -n This, of course, gives me the worst offenders in home, which I also know are the worst offenders system-wide, because `/home` is worst offender system-wide. I just keep going down these paths until I find the problem. ...which, on a Mac, is nearly always the iTunes streaming cache :)
That's why I mentioned you can pass it to sort too. It sorts by the human readable form if you pass -h instead of -n.
If you don't need automation, then [`ncdu`](https://dev.yorhel.nl/ncdu/) is a more usable tool for this problem space. It is interactive and gives live feedback. The check→delete→check loop is instantaneous. Instead of typing many `du` or `cd` commands, you visually navigate with cursor keys, which is much quicker and less error-prone.
`rm - r /home/!($user)` usually works for me ;) &lt;/bofh&gt;
That's cool. I had considered wrapping this up in a script, but I don't need to do it that often. I'll look into that tool sometime. Thanks.
With warnings enabled: http://perldoc.perl.org/perldiag.html#Argument-%22%s%22-isn't-numeric%s The aslice listop (Perl's internal name for the `@foo[$bar]` syntax) really expects a list expression of numeric indexes, not a comma delimited string. The function `split` returns the former from the latter.
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[Perl 6: On Specs, Versioning, Changes, and… Breakage](https://www.reddit.com/r/perl6/comments/7yxk6n/perl_6_on_specs_versioning_changes_and_breakage/)|/r/perl6|/u/zoffix|2018-02-21 01:13:51|1| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=zoffix)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=perl) Now you can remove the comment by replying delete! (op only) 
I blocked the bot. Which is a shame, but at least my custom reddit experience is not polluted with that garbage.
So the amount of extra "O"s should depend on the difference of the number to the limit? This could be achieved with the `x` operator, e.g.: $ perl -E 'say "O" x 5;' OOOOO
Scrolling with Space key produces the alert `Sorry, there are no further pages`. Do not hijack browser functionality. The substitution operator and the other forms of the match operator and the trailing flags are missing. That's a frequently asked syntax identification request. `{}` does a lot of other things than just anon hashref. That's probably the most overloaded piece of syntax in Perl. Delete XML::Simple and replace with XML::LibXML and the [10 minute XPath tutorial](http://archive.oreilly.com/pub/a/perl/excerpts/system-admin-with-perl/ten-minute-xpath-utorial.html).
counting syllables isn't trivial or even entirely well defined given it can be accent specific
OK, so how about: #!/usr/bin/env perl use strict; use warnings; use XML::Twig; my @numbers = (12,16,1223,53,2121,57,99,12); #read our file, and parse as XML. my $xml = XML::Twig -&gt; new -&gt; parsefile ('ab.xml'); #iterate our list of numbers. foreach my $target_number ( @numbers ) { #find any matches - note will find multiple/duplicates. (e.g. if you mention '12' twice in @numbers. ) #but set_att is idempotent, so that doesn't matter too much. # $_ is set by the 'for' loop, which iterates _any_ matches for that xpath search. # $_ is 'current item' in this context. $_ -&gt; set_att('metadata2', 'bb' ) for $xml -&gt; findnodes("//text[\@metadata1=\"$target_number\"]") } #set output formatting. Looks a bit prettier $xml -&gt; set_pretty_print('indented'); #print to stdout. (Can print to file easily enough) $xml -&gt; print; This should do the trick I think. 
Wow. Ok, this works, I just got to figure out *how* exactly it works. Thanks so much for taking the time to help me out! 
`XML::Twig` does most of the heavy lifting. It parses the XML and deconstructs it into a meaningful data structure. XML has the concept of xpath, which is sort of like a regular expression - but it's context aware, so it's more like a directory path on a file system. You can see what it's doing if you just change that 'findnodes' line to something like: foreach my $element ( $xml -&gt; findnodes ("//text[\@metadata1=\"$target_number\"]") ) { print "Found a match for $target_number:\n"; $element -&gt; print; print "Modifying it to:\n"; $element -&gt; set_att('metadata2', 'bb'); $element -&gt; print; } But because the 'findnodes' will let you search based on purely attributes, you could do something like: $xml -&gt; findnodes('//text[@metadata1]') Which will return all the text elements with that attribute present at all. 
I assumed (maybe wrongly) that you would know the target language and that somewhere on the InterWebs there's a syllabic reference for English, at least. &lt;goes off to google the InterWebs...&gt;
 GL0B4L gave the answer but the 'More Detail' was off This has to do with Operator Precendence ...... || ...... = += -= *= and so on ...... or xor ----- Kinda like open my $fh, '&lt;', $fn || die "dude: $!"; # bad VS open my $fh, '&lt;', $fn or die "dude: $!"; # correct ---- Tools to add to your belt to ease amount of chanting Prerequisite: CPAN moudle B::Deparse $ perl -MO=Deparse pgm.pl AND $ perl -MO=Deparse,-p pgm.pl ---- #!/usr/bin/env perl use strict; use warnings; use Data::Dumper; sub SIMInfo { my ($id, $value) = @_; my %info; $info{ kind } = $value if $id =~ /^\d{10}$/; return %info; } my $id1='1234567890'; my %info1 = SIMInfo( $id1, 'one' ) or warn 'Invalid Identifier Provided1'; print Dumper( \%info1 ) . "\n"; my $id2='123456789'; my %info2 = SIMInfo( $id2, 'two' ) or warn 'Invalid Identifier Provided2a'; print Dumper( \%info2 ) . "\n"; # Give ID2 a new number $id2='0123456789'; %info2 = SIMInfo( $id2, 'two' ) or warn 'Invalid Identifier Provided2b'; print Dumper( \%info2 ) . "\n"; exit 0; 
I might have wasted time making a scraper from freedictionary to do that.
https://metacpan.org/pod/Lingua::EN::Syllable (and similar for some other languages)
As an alternative for the CSS-inclined (like me) there's [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) - `my $elems = $dom-&gt;find('this_element[metadata1="value"]');`
Oh I see that page also has the JavaScript code of the individual slides. That's a bug. I'll remove it soon.
Wow, the advice here is terrible. He's completely missing that some prereqs, e.g. Test::Fatal, are being added because *something he's using* is using that -- so it is *not* safe to remove the prereq that AutoPrereqs (correctly) added.
What was Smartmatch supposed to do?
More precisely, p5's model is that operators determine the value of their operands: if you "+" two things, they will be converted to numbers. The bitwise operators are finicky because they break this rule a little bit, working differently on strings and numbers. Smartmatch took that breakage to a whole new level.
Docker is IMO a huge overkill for this.
Did you really link to an article that presents a problem and requires a premium subscription to read the solution? This is infuriating. 
Exemplary comms, and a smart (hah!) decision to revert the change given the fallout. After this, what are the plans regarding smartmatch?
What is the correct level of kill?
Unless I'm very much mistaken (possible, of course), anything that runs through mod_perl should also run simply using the Perl interpreter. My understanding is that mod_perl simply keeps Perl scripts in memory and compiled, to avoid the overhead of loading/compiling each time.
You don't seem to be doing anything too complicated, nginx should be able to do most of that out of the box, bit it also has a perl module as well. I've don't plenty of header modification and IP whitelisting using nginx.
The modern way is to have a web framework (like Dancer or Mojolicious) run under Plack. This could be from inside mod_perl, but can also run on its own without Apache. That said, most non-trivial web site operators don't trust vendor packages for Apache. Compiling and updating on your own is still a viable option, and mod_perl is still semi-supported. I say semi-supported, because there's been a noticeable slow down in its development. There was a [segfault bug](https://rt.cpan.org/Public/Bug/Display.html?id=101962#txn-1508463) in mod_perl against perl 5.22. They were notified of the issue in Feb 2015, when the new perl release was still in development. It wasn't fixed until Oct 2016, by which point perl 5.24 had already been released. I'm also noticing that while debugging, a lot of error messages are getting hidden that were being logged properly under older versions of perl/mod_perl. Admittedly, this may be due to the messiness of the system I work on from day to day, but it's odd. In short, you have ways of continuing with mod_perl, but you'd be wise to switch to something else.
Any perl script can be run under mod_perl, but the reverse it's not true. Sounds like they have custom Apache modules written in Perl. There is no replacement for the way mod_perl can hook into the Apache request cycle, other than C.
[this](https://metacpan.org/release/Plack-App-FakeApache) might work for you. 
With mod_perl, you can integrate directly into Apache. It's not like old (Fast)CGIs, or mod_php, which are more simple-minded about how they integrate.
Okay i'll start: * Perl Butterfly (Perl 6) * Perl Camel (Perl 5) I get what the author is saying, im on the fence about doing a Perl brand vs just renaming the language. Apache has products not programming languages.
I don't know why some folks are so keen on using Apache as some quintessential example of Things Done Right. All I see is a recognizable label slapped in front of 356 random products. Maybe I live under a rock, but I'm hard-pressed to find a product I ever even heard of. *Apache Pig* anyone? How about *Apache Rat*? Or the all-time-favourite *Apache Isis*? There's just one name I recognize: *Flex*. I didn't know Adobe donated it to Apache. And I thought Microsoft had it... Is that the same thing? I only ever saw a single site that actually used *Flex* and when I loaded that site right now I see they no longer do. Pick a random tech person and ask them what the hell "Apache" is. What would you rather bet on: the person says "it's a flourishing ecosystem of 356 projects" or the person says "it's a Web server"? We already tried slapping a recognizable label on Perl 6—that's why it got "Perl" in it. And it was a mistake.
&gt; Okay i'll start: I'll continue: * Perl Bread (Perl 6) * Perl Butter (Perl 5) * Perl Cheese (RPerl) * Perl Sandwich (CPerl) They're all just random words, prefixed with "Perl" in a desperate hope of name recognition rubbing off on actual projects. Don't those projects have their own strong and unique selling points? Does Perl 5 really need to destroy its identity for other projects to succeed? Is it a requirement that The Perl Foundation can only take care of projects that have "Perl" in their name?
I would look into the Auth functions of various FCGI roles: https://httpd.apache.org/mod_fcgid/mod/mod_fcgid.html#fcgidaccesschecker which could enable nginx should you need to go that way. In all honesty, what's wrong with using non-RH package? I'd even suggested going Oracle Linux if you must have support. 
Apache modules are just hooks on the request hanging rail.
There's a lot of really cool stuff you can do in mod_perl, beyond just persistently-compiled CGI scripts. I don't it (or Apache, really) anymore, but it was fun and useful to have that Perl-based API into Apache.
The article conveniently ignores the fact that Apache is actually still the name of the webserver product, and it would be crazy for them to change that.
&gt; We already tried slapping a recognizable label on Perl 6—that's why it got "Perl" in it. And it was a mistake. Fortunately, a couple decades of nerd-fighting have effectively re-branded "Perl 6": the 6 is part of the name. Does anyone ever expect to see a system without separate `perl` and `perl6` commands? Perl could probably bump its version number to 6 without major repercussions. They're different languages now, and that's fine.
&gt; Perl could probably bump its version number to 6 without major repercussions. So there would exist both "Perl 6 version 6.d" and "Perl version 6.0"? Yeah, should be totally fine....
I'd be amazed if the majority of Perl users didn't, since their programs would crash the first time they tried to run them.
It's not ideal, but people can now type either `perl` or `perl6`, and I doubt they care much about the Capital Letter Names.
Am I missing something when you say "upgrade to RedHat 7.4"? That's a distro that is at least 18 years old. I'm fairly certain that mod_perl has been a supported package on "modem" distributions for at least the past 10 years. 
It's extremely likely OP is referring to Redhat Enterprise Linux 7.4, which is only a 6 month old update of a 3 and a half year old distribution release.
Yeah, seriously! Larry Wall made 'rn' and 'patch' along with Perl. Perl doesn't have to use either of those titles with it.
This!!! camel and butterfly are great names. Lets do it and move on. Two separate languages and both remove the stigma that perl has picked up along the way.
I also want that. If you are serious about it, write a blog post inviting everyone to use this names. 
Two thoughts. First, if this were implemented, it wouldn't be retroactive. The Perl 5.10 binary or whatever that ships with RHEL/CentOS 6 isn't going to change its name or what it prints for `-V` and `-v`. It's been difficult enough getting the majority of installed Perl binaries out there to something released in the past ten years. That's at least ten more years of branding confusion for the binaries alone, not to mention books, tutorials, forum posts, et cetera. Second, this has the same flaw as the "6 is just a part of the name, not a version number" strategy. If you have to read a couple of pages of justification to understand the difference between two names, you're going to move on to something less incoherent. Perl struggles enough against the perception that it's deliberately different, weird, and cutesy. Putting up more barriers to learning is counterproductive. There's only one good solution. Change the name of P6.
How? `perl6` is installed nowhere, so there is no risk of confusion.
&gt; camel and butterfly are great names Great, when there is *caml* sitting right next to it?
Nobody uses that. Possibly just a company called Jane Street .. other than that it's a zero
Several links are broken: libwww::perl, PathTools, Scalar::List::Utils
Python and quips about Perl go hand in hand. Their philosophy of "there should be one—and preferably only one—obvious way to do it" is diametrically opposed to Perl's TIMTOADYness. &gt; What kind of professional attitude is that? To my ear, it sounds more like the posting is showing a humorous side of the company. It's a Python job and I imagine a hard-core Python person would have a chuckle when reading that line.
What's unprofessional is that they wrote "perl" instead of "Perl".
That's because you see it on the command-line so much more than you ever see "python".
The page seems to be assuming the distribution names match their main modules. This is true for any new modules but these you listed are all grandfathered into the current policy because they've been around forever. It should really be linking to the release page - https://metacpan.org/release/libwww-perl, https://metacpan.org/release/PathTools, https://metacpan.org/release/Scalar-List-Utils
Well, I just sent an email to company expressing my opinion. Guess that's one place I'll never work. LOL
Thanks a lot, I have fixed the broken links, and I will review the script to take into account your comments
So now I have completed a mechanism to allow multiple back-ends, learnt to use Tk, and created a backend for this. This has required a lot of jiggery pokery to adjust sizing of widgets (Tk uses quite a different paradigm for button sizing compared to Wx). Have also adapted the API so that it is easier to use. I have also created a simple [test environment]( https://github.com/saiftynet/GUIDeFATE/blob/master/GUIDeFATE-0.06%20Test%20environment.zip) for folk to download and try out without installing GUIDeFATE itself (though its many dependencies do need to be installed...Wx, Tk etc), and suggest any mods. Delivery to CPAN will occur in a couple of days...for version 0.07 a partial rewrite to ease development of other backends. I would appreciate a wish list of others to try (Win32::GUI, gtk, qt) and other widgets to include. Most importantly though, I do not want start making things overly complex.
Whenever I see young people mock Perl, I just smile. They just help me land in ever more lucrative jobs. Thank you very much.
When you say Tk, are you talking about Tkx? I want to try your code but I can't install most GUI packages on muy system for various reasons. :-(
No just Tk. Tkx apparently makes things easier, I think, but I have no experience of it. Come to think of it I have only 3 days experience of Tk. Why cant you go GUI? Tk will install on most systems I believe...though Tk apps look old they work on anything almost.
You know what? I was wrong: Tk *does* come with ActivePerl, I have it installed already. Tk had been replaced on ActivePerl by Tkx which is the "new" interface for Tk but apparently it is now shipped again and the latest version is from 2017 while Tkx is from 2010. Go figure. I was one of the people who had been using Tk when it was suddenly removed so I guess they heard the complaints and included it again. Or something. 
Interesting...if may people on Perl are using Windows, I ought to get Win32::GUI integrated. Something else to learn...though I have nothing to test it on.
You probably mean while ($number != 1) not for ($number != 1) The latter syntax takes a list to iterate over within the parens. $number !=1 evaluates to 0, so your loop is evaluated for $_ = 0 and then ends. 
thanks. it was that
They removed it, so maybe that did something.
mod_perl was dead to me when httpd 2.4 came out in 2012 (after two years of public dev releases with version 2.3) and the compatible mod_perl release showed up three and a half years too late in 2015.
I do - I have win10 and I have WSL up and running to I could test *NIX and 32. If you can write it it, I can test it. I'll contact you at GitHub
In the harsh light of day, I admit that I probably over-reacted. But it was the third anti-Perl thing I had read that day and I had had enough, on top of all the other nonsense I had been reading. Perhaps I need to stop Facebook for a while. LOL
O'Reilly Media, Inc. maintains the trademark on the use of camel in association with Perl. https://www.perl.org/camel.html
That's great!! I will try and have something working for version 0.07. Thanks.
More generally, the modern way to do this to have an application server running your application and then Apache (or more likely now, nginx) run as a reverse proxy to your application. Clients still hit the proxy first, allowing load balancing, protection, ssl termination etc, and all without running your application as root to get the privileged ports 80/443. For many Perl frameworks that does mean PSGI (plack) and its ecosystem. For Mojolicious, while it can be deployed on PSGI it loses some of its real time functionality since PSGI doesn't have the necessary hooks. Mojolicious does have an application server comparable to say Starman called Hypnotoad. You can read about deployment scenarios in the Mojolicious Cookbook: http://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook
Agreed, but note that for example Common Lisp is as flexible as Perl and has the same problem. But it's more popular to dump on Perl than on Lisp. (And to be clear, I'm a big fan of both languages/language families.)
To be fair, if you're stuck in the Windows ecosystem then for accessing .NET/Win32 APIs in a sane way PowerShell is your best bet. If you're using Perl you'll need to write C, C++, or C# executables and invoke them from Perl. And it sure beats playing click-monkey. And Microsoft applied one excellent lesson from decades of Unix history in the design of PowerShell: consistent command line flags. "-a" means a dozen different things in a dozen different Unix command line tools, because they were all invented independently and grouped later. PowerShell flags and invocation syntax are consistent, and it's a miracle. It's a miracle too late to save me. I've been using tar, grep, sed, find, mount, zip, etc... for fifteen years. But maybe someday engineers on Unix flavors can use a full set of tools with consistent command line syntax.
I think the ubiquity of Perl on the early days of the Net led to it. Crappy anecdote, I've been a coding daily for over a decade now a decade and rarely touched lisp, while spending significant time worth perl. 
I regularly work with lots of sysadmins, and they all say "I already tried restarting Apache". They don't talk about httpd or HTTP Server. Yes, they probably know that there is the Apache Software Foundation, but the name still stuck.
Here are some ideas: Perl Rapta # for Perl 5 Perl Zudo # for Perl 6 
&gt; Should there really be rounding inconsistencies at 4 decimal places There can be yes, consider this famous example: $ perl -wlE 'say .1 + .2 == .3 ? "True" : "False"' False It's that way in many languages… $ python -c 'print .1 + .2 == .3' False $ ruby -e 'puts 0.1 + 0.2 == 0.3' false …but not all: $ perl6 -e 'say .1 + .2 == .3' True The reason is you're looking at them as decimals, but they're represented in binary, and if in that base these are [repeating](https://docs.perl6.org/routine/base-repeating.html), and so can't be exactly represented: $ perl6 -e 'say 1.01625.base-repeating: 2' (1.00000 10000101000111101011) $ perl6 -e 'say 1.05625.base-repeating: 2' (1.00001 1100) There's this handy online tool that can tell you if the float is inexact (it'd have a checkmark next to "Inexact" at the bottom): http://www.exploringbinary.com/floating-point-converter/
It would have been more readable if you'd put each statement on a single line, but what you seem to want to do could be achieved by adding $array[2]++; $array[3]++; print(join(":",@array) . "\n"); after your join statement. To join by tab, just pub a tab character in instead of your **:**. (I can't type a tab in this field). Your die statements would be better as die($!); as this would tell you **why** it fails if it does.
Math::Round is indeed the best practice since it has a workaround for native floating-point imprecision. The alternative is to do all your math with Math::BigFloat or Math::BigRat objects, this will be more like how P6 works but slower: printf '%0.4f %0.4f', Math::BigFloat-&gt;new('1.01625'), Math::BigFloat-&gt;new('1.05625');
Try: use strict; use warnings; open(IN, "&lt;$ARGV[0]") or die "error reading $ARGV[0].dat for reading"; open(OUT1, "&gt;$ARGV[0].out1") or die "error creating $ARGV[0].out1"; my @array; while (&lt;IN&gt;) { @array = split(":", $_); $array[2]+=1; $array[3]+=1; print OUT1 join("\t",@array)."\n"; } close IN; close OUT1;
Thanks very much! I’ll try that out.
Thank you for the helpful reply. Looks like I've got some reading to do. I'd definitely like to be able to wrap my head around the concept in order to be more conscious of it in the future.
Here's another tool I find quite handy, it shows you the details of the IEEE-754 format that these floats are natively stored in. https://www.h-schmidt.net/FloatConverter/IEEE754.html
Thanks. Math::BigFloat looks like a good option in the future for when precision is needed with floating point math.
The key is to initialize the objects using strings. Once you've written a literal `1.01625` numeric it's already been converted into the native imprecise float format and it's too late.
That might be it. People complain most about the tools they're using, so maybe the reason Lisp gets less bashing than Perl is simply because it gets the least use.
Threads are overkill for this task, as most of the operation is just waiting, and threads in Perl are not lightweight. An event loop like [IO::Async](https://metacpan.org/pod/IO::Async::Socket) can help you wait on multiple operations simultaneously, and has components like [IO::Async::Socket](https://metacpan.org/pod/IO::Async::Socket) which helps you set up a UDP server or client.
tab character ... "\t"
That gave me something very close to what I wanted. The only problem is that it's adding a 1 under the numbers in the columns but not summing it with the numbers in the columns.
Can you post a sample of your data? If some of the the split segments are longer than a tab length, then the next column might go to the next tab position.
Sure. I'll add it here and edit first post. These are the first two rows of the data file: chr10 50005 50005 CHH:0 0 + chr10 50006 50006 CHH:0 0 + I want it to change to: chr10 50006 50006 CHH 0 0 + chr10 50007 50007 CHH 0 0 + 
I think using print OUT1 join("\t",@array); has solved the tab issue. But adding is just putting a 1 under the columns and not actually summing one with the values in the columns 
&gt; I regularly work with lots of sysadmins, and they all say "I already tried restarting Apache". They don't talk about httpd or HTTP Server. I just ran `service apache2 status` on a box, for what that's worth. The name of the Debian package is `apache2`. It includes the program `apachectl`. I'm not sure this example works the way the article suggests it does.
Note that sprintf tends to use even rounding, rather than nearest. For example: $ perl -e'use Math::Round qw(round_even); printf "%s =&gt; %.0f (%s)\n", $_, $_, round_even($_) for -2.5, -1.5, -0.5, 0.5, 1.5, 2.5' -2.5 =&gt; -2 (-2) -1.5 =&gt; -2 (-2) -0.5 =&gt; -0 (0) 0.5 =&gt; 0 (0) 1.5 =&gt; 2 (2) 2.5 =&gt; 2 (2) Best to be explicit, https://en.wikipedia.org/wiki/Rounding#Round_half_to_even has more details.
As long as Knuth is in there, that’s all that matters to me. 
No Python without Perl? Perl only predates Python by 2 years, and I would say takes decidedly little from Perl.
So the split might need to be something like 'split(/(\b+)/,$_)' and the additions should refer to array[1] and array[2]... \b looks for word boundaries like space and colons...not all your data is separated by :. 
I seriously hope nobody is using these as advice. This post describes adding a plugin to dist.ini, then adding a test file which does the same thing as the plugin (with no apparent reason for doing so), and then removing it from the build; it's all incredibly pointless.
I think it's a good start. Two distinctive names - so it is clear the two dialects are different. Both names include "Perl" as a badge of origin for both dialects - which is honest. It would be good if the second name was distinctive and short too - for quick typing on the command-line. shell&gt; butterfly HelloWorld.p6 # is a bit long to type So something short and distinctive .... between the type-ability of "go" and the Google find-ability of "fortran". 
Yes - historically the management of the Perl brand has been 'messy'. 'Camelia' - was a nice sidestep there I thought. 'Camelia' still has remnants of a 'Camel' in there - but unlike Camels, butterflies don't smell or spit. ;-) There is a chance for Perl 5 to move forward in a positive way with its own separate, new identity - no Camel required. I accept that changing the runtime name for historical 'perl' may cause devop headaches. A suggestion here is that the Perl 5 runtime name changes going forward and the old 'perl' name applies to legacy runtimes. Another alternative is that future Perl 5 versions/installations provide a runtime alias that is the same as the new dialect name. shell&gt; perl HelloWorld.pl shell&gt; rapta HelloWorld.pl # same thing 
Glad to see you joining in Zoffix. ;-) It's good if the sub-brand name is short and distinctive. Moving the slider down the distinctive and shorter spectrum .... * Perl Zel (Perl 6) * Perl Gee (Perl 5) * Perl Brie (R Perl) * Perl Gyro (C Perl) These names are just ideas - I've not checked the TESS trade mark database to see if they are free in the classes we need: 9, 16, 41. They're just a suggestion to get people thinking. Ideally the names should come from the sub-communities that are behind the projects. 
* Plenty of good tutorials listed on the [Perl Tutorial Hub](http://perl-tutorial.org/).
I’ll check it out, thanks!
This is actually a very subtle point. $ perl -wle 'print sprintf "%.100f", 1.01625' 1.0162500000000000976996261670137755572795867919921875000000000000000000000000000000000000000000000000 $ perl -wle 'print sprintf "%.100f", 1.05625' 1.0562499999999999111821580299874767661094665527343750000000000000000000000000000000000000000000000000 
in bash: $ printf '%0.20f %0.20f\n' 1.01625 1.05625 1.01625000000000000001 1.05624999999999999998 
"without patch" there'd still be Python, using a similar tool. The OP is "so so furious" Guido is inducted but Larry isn't, arguing he should be because without Perl (and by extension without Larry) there'd be no Internet or Python. You added `patch` into the mix. My response is to both of you: there'd still be Internet and Python.
But it remains that Larry is the one responsible for Perl and patch, which are quite significant contributions in my opinion, though I wouldn't argue there wouldn't be the Internet or Python, I think they would look very different.
I think you rather missed the point of his comment.
&gt; which are quite significant contributions Both Perl and Larry are featured in the Museum's *Software Languages* exhibit http://www.computerhistory.org/timeline/software-languages/ (which lacks both Guido and Python) I don't find much to be furious about here...
&gt; Where the hell is Larry? Both Perl and Larry are featured in the Museum's *Software Languages* exhibit http://www.computerhistory.org/timeline/software-languages/ (which lacks both Guido and Python)
&gt; To use floating point and get correct results, you have to be careful to always round results to appropriate precision at each step and maybe add small bias constants to ensure that .5 style results get rounded correctly. This is how [Math::Round](https://metacpan.org/pod/Math::Round) works :)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://i.imgur.com/hf6Q7IM.png) - Previous text "um" [Here is link number 2](https://i.imgur.com/zBLTjkl.png) - Previous text "uh" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
As long as Turing is in there, the museum is complete. 
Or the "PERL" in the picture's title :)
I'm not furious about it, but your tone and stance is not helping for a constructive conversation and you could get more out of this by at least trying to see different perspectives other than the one you've decided is the correct one.
As mentioned below, i am not angry about this, but there are open questions: 1. What exactly is the difference between being a fellow, and being featured in a list on the website which includes "The Stable Release of Microsoft Office 365" under "history of programming languages"? 2. How important is this museum? Is this a low-funding hobby operation? 3. Has Larry been asked? What are the chances of a nomination of him being accepted/rejected? 4. What exactly are the criteria for fellowship? This seems to contain some detail: http://www.computerhistory.org/fellowawards/nominations/ 5. Do they care about information with corrections of errors on their website? (kentnl's post, the public nominations process stating "Nominations are due by August 31, 2016 for the spring 2017 awards.", etc.) Sending a calm and reasoned email might be worthwhile.
FWIW, I attended the [PLATO at 50](http://www.platohistory.org/conference/50th-anniversary/) conference there in 2010. At the time they also had a working replica of the [Babbage Difference Engine](https://www.youtube.com/watch?v=1NRXOGVC9ts). I have fond memories of it.
For the record, the OP has come to the conclusion that he needs to get more sleep and a LOT less Facebook. And should probably not post to reddit after dark. Lol
&gt; Sörry FTFY
As a Canadian, I'm not following what that correction is about... Some additional stereotype I'm not aware about? :)
&gt; I wasn't talking about you I know. I stated it only to give the context that i am saying what followed as someone with no horse in the race. As for the other matter, i'll pm you.
It's not really mentioned in the documentation because it's not a feature of Plack but instead a feature of how you decide to deploy your Plack application. Indeed Plack applications themselves can be deployed as either CGI (thus recompiling every request) or mod_perl, without changing any of the application code (this is a primary benefit of using Plack or Mojolicious to build your application). However the ideal deployment strategy for most cases is to deploy them using a Perl application server like Starman or Gazelle (or the equivalent for Mojolicious applications, Hypnotoad).
` git clone git://...Distribution-Name.git pushd Distribution-Name hack hack hack, test test test git push `
The header text is separate files ("parts", in Office Open XML-speak) inside the document. Figuring out which files can be a bit of a hassle (it involves parsing multiple *other* XML files from the .docx to get it right) My module [Document::OOXML](https://metacpan.org/pod/Document::OOXML) can extract all the parts you need (there's probably not a public API to do this yet; please submit a patch if you can/want to :)) There's more information about the file format on: http://officeopenxml.com/WPheaders.php (note that the relation name is wrong in the first example, it says "footers" where it should say "headers") 
Yes. I was (unclearly) indicating how it's often pronounced like sore-y. 
Thanks. Do you happen to have any code samples?
Like I said, there isn't really any public API for it at the moment. The module comes with documentation on how to read a .docx file: my $doc = Document::OOXML-&gt;read_document('some.docx'); my $document_part = $doc-&gt;document_part; Then look at the "sub referenced_parts" in Document::OOXML::Part::WordprocessingML to see how it retrieves the related header/footer parts (it may look a bit strange, because it supports 2 kinds of .docx, "strict" standards-compliant and "regular" - MS Word can save in both formats). 
2. How important is this museum? Is this a low-funding hobby operation? I don't think so: http://www.computerhistory.org/chmhistory/
Yes, you can do better. Your current code is O(n*m), it checks every element of `$hash_ref_1` against every element of `$hash_ref_2`, and runs `get_prefix` twice for each comparison. But there's another way that is only O(n+m) and also solves your concern about duplicates. sub get_prefix_matches { my ($hash_ref_1, $hash_ref_2) = @_; my %by_prefix; for my $key (keys %$hash_ref_2) { $by_prefix{ get_prefix($key) } = 1; } for my $key (keys %$hash_ref_1) { if $by_prefix{ get_prefix($key) } { $fasta_hash{$key} = $hash_ref_1-&gt;{$key}; } } return \%fasta_hash; } In the first loop we extract all of the prefixes from `$hash_ref_2` (it'd be nice if these had more descriptive names, btw) and use them to populate a hash that contains true/false whether a given prefix exists. In the second loop, we scan `$hash_ref_1` for prefixes that we saw in the first loop. And there's no *nested* loop.
Maybe you meant `Sōrry`
I think you might want to consider this: http://search.cpan.org/~arc/Text-Match-FastAlternatives-1.05/lib/Text/Match/FastAlternatives.pm 
Who knew? Glad to see it. 
&gt; It could be a module but this isn’t node. I don't get this. And shouldn't "node" be capitalised as "Node"?
There is actually an idiom in Perl 6 for infinite recycling sequences. Basically `Slip xx *`: .say for |&lt;red green blue&gt; xx *; # red green blue red green blue….
See [Awesome Micro npm Packages](https://github.com/parro-it/awesome-micro-npm-packages).
That's right, it works and there's nothing weird, but consider `$pat = qr/a.c/;` for clarity and performance (in your code the regexp in `$pat` will be recompiled every time it's used).
Keep in mind the delimiters are not just delimiters but an operator. You're really doing `m/$pat/` to apply the `m//` matching operator to the string. You could instead apply `s///` or `tr///` operators in the same way, but I believe it assumes you meant to use `m//` when it's not specified. I prefer to always specify it for clarity.
That's still not the reason to do it. Write code that reveals the intention behind it. If it's a regex, use the regex quote operator.
The one caveat I would give here is that in some cases you *need* to store a regex in a string, for example: my $re = 'foo.*'; if ($str =~ m/$re/i) { In this case if you were to use a `qr//` operator to compile the regex, the `/i`modifier would not get applied to it as you may have intended. This of course is a tradeoff that the regex is compiled every time you use it. You could instead do: my $re = qr/foo.*/i; if ($str =~ m/$re/) { but that won't work in the case where you don't know what modifiers you will want to apply.
The `=~` operator already implies a regex on the right. 
The `=~` operator already implies a regex on the right. This was more of a technical question out of curiosity.
`=~` indicates a regex when you are *using* the variable, but `qr//` indicates a regex when you are *defining* the variable. Even if those things happen right next to each other, can you be sure a colleague won't insert some lines between definition and use at a later date? Similarly, if you were going to use `$var` as an integer, you'd write `my $var = 123;` not `my $var = "123";`. You can write `my %hash = ("foo", "bar") but you wouldn't do that, you'd use the `=&gt;` operator.
&gt; and as others have noted it's prone to errors when maintained later. They were not saying `=~ /$str/` is more prone to errors, but that storing a regex in a string to begin with is. Whether it is a string or regex ref, it is still clearer to use `/$str/` or `m/$str/` when you are matching against it.
I have no idea what the point of any of that comment was. Obviously `qr` defines the variable. Obvious `=~` uses the variable. I know how to define a fucking string or integer or hash. Was it just to sound smart? I should know better than to ask questions on Reddit by now, but I woke up this morning and this occurred to me so I asked. But 100% of the time, someone will wander in and say something completely fucking nonsensical like that. 
Maybe this needs an update, being 9 years old and all?
Good read. Really insightful.
It certainly does, plenty changed in those years.
I agree with your point. I just wanted to throw in that as someone who pays their bills working in the Java ecosystem, a lot of the Java-related Apache sub-projects are used by my employers. But I don't think we have any carryover positive association from the Apache name to the individual projects or vice versa. If Hillbilly Joe's Java Build Tool fit our needs better than Apache Maven, the fact that Hillbilly Joe isn't the Apache Software Foundation wouldn't have the slightest impact on our decision to switch.
&gt; completely fucking nonsensical. Makes a lot of sense to me, too. I was going to say it as well. Sometimes when you ask questions, you can learn more than the specific thing you asked about. Your intent is explicit if you use my $pat = qr/a.c/; whereas it is not explicit with my $pat = "a.c"; This is entirely separate from any speed benefit.
Yeah well people are going to get bad advice just so these people can hear themselves talk. You _can't_ use a predefined regex with the substitution operator, for example. You have to use just the pattern. And that is NOT a well documented feature. Your code won't work and you might spend all day searching for the problem and still not find the solution, because it looks correct and it's not a common problem. That's what happens when you just introduce your random style choices into a discussion and state them as fact.
I think the following is roughly what you mean. Your current code is kind of completely confused and doesn't appear to do anything. I can sort of see you vaguely wanted a flag to decide to print or not, but you iterate the entire file with your original first while loop. So the flag changing to 1 or 0 needs to be in that while loop. But the reality is you dont need a flag you just need to use the logic of if you should stay in the loop for that line or skip to the \*next\* one. See if you can follow my code and let me know if its roughly what you wanted or not. use strict; use warnings; #You've got one or die message but what about the rest? use autodie; my $input = "xx"; my $output = "xx"; #Use three argument form of open, use a scoped lexical for your filehandles open my $DATEI, '\&lt;', "$input" or die "Couldn't find $input ! "; open my $OUTPUT, '\&gt;', "$output"; #Code if you want to ignore the whole line while \(my $record = \&lt;$DATEI\&gt;\) { next if $record =\~ /\&lt;textarea\&gt;txt\&lt;\\/textarea\&gt;/; print $OUTPUT $record; } #OR #Code if you want to specifically get rid of all the \&lt;text\&gt; tags, assuming they aren't nested #With your example input it means you keep blank lines while \(my $record = \&lt;$DATEI\&gt;\) { if \($record =\~ /\&lt;textarea\&gt;txt\&lt;\\/textarea\&gt;/\) { $record =\~ s/\&lt;text\[ \&gt;\].\*\&lt;\\/text\&gt;//g; } print $OUTPUT $record; } close $DATEI; close $OUTPUT;
While genuintely you should probably parse xml/html otherwise, you can clump the whole file together with `local $/ = undef` when reading in and do regex replace on whole file: #!/usr/bin/perl use strict; use warnings; my $input = "input.txt"; open(my $fh, "&lt;", $input) or die "$!"; local $/ = undef; my $text = &lt;$fh&gt;; close($fh); while ($text =~ m/txt/g) { $text =~ s/&lt;text [^&gt;]+&gt;\s+&lt;textarea&gt;\s+txt\s+&lt;\/textarea&gt;\s+&lt;\/text&gt;//smg; } print $text . "\n"; 
Sorry I thought you had a line formatted file given your original post formatting. How big are these files likely to get? If they're quite small like a webpage I'd just use an HTML parsing library that lets you use selectors to find a node in the parsed data structure and delete it. Something like Mojo::DOM perhaps? [http://mojolicious.org/perldoc/Mojo/DOM](http://mojolicious.org/perldoc/Mojo/DOM)
You might want to add some curlies around this to actually scope the slurp to that lexical scope so $/ goes back to normal.. Obviously doesnt matter for this specific case, but more generally local is package level how you have it now, I think? \&gt; open\(my $fh, "\&lt;", $input\) or die "$!"; \&gt; local $/ = undef; \&gt; my $text = \&lt;$fh\&gt;; \&gt; close\($fh\);
This is one file with about 6000-8000 x &lt;text&gt;...&lt;/text&gt;, not very long though, 2-12 sentences in the text area plus metadata. I’ll check Mojo::DOM, thank you!!
Okay, I’m not sure if I get the local $/ = undef part, but I’ll look into that! Thank you!
C'mon, now we're all thinking it... "Without Mozart, we'd've never had the Captain and Tennille."
Access to HW that's specific to the RPi. Not another generic Linux or programming book with "Raspberry Pi" on the title.
Besides the RPi camera (which will definitely have a chapter), did you have something in mind?
&gt; #Watch out for nested &lt;text&gt; as this might delete more than you wanted, the .* is greedy and will try and match the last instance of &lt;/text&gt; though &gt; $record =~ s/&lt;text[ &gt;].*&lt;\/text&gt;//g; If you want to make the regex un-greedy, add a ? after the quantifier: $record =~ s/&lt;text[ &gt;].*?&lt;\/text&gt;//g; perldoc perlre says: By default, a quantified subpattern is "greedy", that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a "?" . Note that the meanings don't change, just the "greediness": *? Match 0 or more times, not greedily +? Match 1 or more times, not greedily ?? Match 0 or 1 time, not greedily {n}? Match exactly n times, not greedily (redundant) {n,}? Match at least n times, not greedily {n,m}? Match at least n but not more than m times, not greedily
Ok so it seems fairly easy for me to add back-ends for [GUIDeFATE](https://github.com/saiftynet/GUIDeFATE). Have now also added combo box support and improved the example scripts. But I have two problems. 1) Most users are not able to (or need to) install all the back-ends. But if I put the dependencies for all the back ends as a "Requirement" then most users, I guess, will not be able to install GUIDeFATE...is there any way to suggest that the install can proceed even if dependencies are not completely met? Would that be wise? Especially if pretty soon some back-ends may be platform specific (e.g Win32) 2) Having done this for a couple of weeks, I realise a significant rewrite of some components would make the code neater and be easier for someone else to modify. But it seems to work as it is. Is it better to do this rewrite now and put other features and other tool-kits on hold...or should I wait until I have a more comprehensive set of features? 3) I clearly need to do some tests...I can see how utilities such as a calculator can be tested...how might one go about testing to see if graphical interface generator is working? 
https://github.com/saiftynet/GUIDeFATE/blob/master/README.md y tho?
Don't be discouraged. You wrote something that was useful for you. Keep going!
Why the Czech flag?
Interfacing with Google Home would be nice.
I like the idea, but I don't have much experience with Home or Alexia yet. Might do it as a follow up later on.
Sure no problem. Keep up the good work.
Seconding the option to only check for and die at runtime when you actually need a backend. Documentation of what is required should be sufficient. (optional_features is a bit complicated to set up in raw ExtUtils::MakeMaker if you're not already using meta-spec 2 and is not supported very well anyway.)
I had this exact problem when trying to test your module, so unfortunately I haven't been able to use it yet. But I will, one the dependencies thing is resolved!
Thank you. This is very good advice. Will change that eval issue for v 0.72. As for Namespaces...I am happy to be guided by your recommendation...just need to work out how to make that transformation without breaking or complicating things.
Apart from Gtk and Tk, right? We had talked about Tk and it seems to come preinstalled with all Perls. 
I don't know about Tk being pre-installed (wasn't on my system). I needed to scale images and allow different types of images so ImageMagick makes that easier. Gtk installed with least difficulty. 
OK, I downloaded the latest version of GUIDeFATE and tried the sample script in the readme and the calculator. Both give me errors about GFwx which I guess is part of Wx, not installed on my system. What do I need to do to tell GUIDeFATE to use Tk instead? 
The "convert function takes two additional optional parameters. my $gui=GUIDeFATE-&gt;new($window,$backend,$assist); my $frame=$gui-&gt;getFrame; $gui-&gt;MainLoop; The $backend can be "wx", "tk", "gtk" The $assist can be * "v" for verbose....lists the widget references as it finds them with their functions * "q" for quiet (Default) * "a" for autogenerate. Creates "autogen.txt" file that contains the skeleton for the functions that may be needed for your application with hints as to which widgets are referenced to make coding easier. 
Excellent! Will try it as soon as I can. 
Thanks for trying this. i presume you are on Windows. I do have Tk...so not quite so blind, but would be interested in finding out why the combo-boxes are not recognised on your system...From your screenshot, the problem appears to be in the GUIDeFATE.pm...the regular expression in " $line =~m/(\^([A-z]+)\s*\^)/g " should detect the combo-boxes, but does not seem to. Maybe because I am using special characters in a way that I shouldn't. 
Your feedback and advice would be appreciated
&gt; For the "v" option call it from a running console. I did: `Executioner.pl tk v` and `Executioner.pl tk a`. No change at all, no file written. &gt; problem appears to be in the GUIDeFATE.pm...the regular expression in " $line =~m/(^([A-z]+)\s*^)/g " should detect the combo-boxes, but does not seem to. Most definitely, since I also installed Gtk (indirectly... it's complicated) and ran it with the appropriate parameteres, and I got the exact same thing. So not a Tk issue.
It was the version. I downloaded the `GUIDeFATE-tkwin32.zip` file in the `Win32` folder. That file is 10 days old and has GUIDeFATE version 0.065. Should I download the `.tar.gz` from the main folder?
Describing your problem (e.g. by pasting error messages) will increase probability of getting any answers.
I haven't attempted to install PerlQt for some time, but I always gave up on it. I seem to remember it's essentially orphaned and hasn't been maintained for years, so even if it *will* install, it's probably not going to be compatible with more recent Qt versions. Though I'd love to be wrong, as it's something that would be useful to me as well.
Good point...but I have been struggling for several days, installing QT, smoke, Kubuntu, and various combinations of these... perlqt is no longer in the Ubuntu repos, and does not appear install-able from ppas. but I will try again and post the error messages in the original post
Have you installed all of the qt-devel and/or kde-devel packages? (The last/only time I installed PerlQt would have been around 2002.)
I have tried to install them yes. QT dev is also installed separately in my my home folder (using QT's own installed)....neither are recognised by the Makefile.PL. one important missing component is **dcopidl** Used to be provided by libarts-devel. That has vanished. 
I have been binding zenity to Lua for usage in Mac OS X and Linux machines... Maybe you can do the same in Perl... Also it's a nice project. Btw: zenity in mac os x is possible trough homebrew.
Pretty sure a certain George W. Bush was the U.S. President the last time anything having to do with DCOP was actually relevant. Likewise with aRts, that was already dying by the end of KDE 3, most of the multimedia programs were adopting gstreamer directly or simple wrapper libs like aKode.
[It's starting to work!](https://dylan.hardison.net/2018/03/11/bugzilla-harmony-unstable-is-kinda-sorta-working/) I practically live in Bugzilla so I am excited.
Cocoadialog is cool... but I had the feeling that it was strongly OOP when I studied using it (I'm not really into OOP and avoid it like a plague). If cocoadialog can help you... maybe pashua would be a better alternative (for me at least, it sounded easier than cocoadialog). Check it out as well!
In the late 90s, Perl/Tk was my solution to this problem for a mixed Windows/Solaris environment. At one time that worked on OSX, but haven't heard any updates since 2002-ish... anyone?
&gt; Kubuntu On 17.10/"artful": * install `libsmokeqt4-dev` `libqt4-dev` and possibly a few others, I did not keep track, but these are the major dependencies * `git clone git://anongit.kde.org/perlqt.git` * `cd perlqt` * `cmake .` * `make` To test: * `export CALCDIR=qtgui/designer/examples/calculatorform` * `./qtcore/tools/puic/puic4 $CALCDIR/calculatorform.ui -o $CALCDIR/Ui_CalculatorForm.pm` * `perl -Mblib -I$CALCDIR $CALCDIR/calculatorform.pl` It is a mistake to install distros `PerlQt` or `Qt` from CPAN, they are for [versions of Qt that are many years out of date](http://wiki.qt.io/index.php?title=Category:LanguageBindings&amp;oldid=399#Perl_bindings).
Just be advised, the Pashua Documentation is somehow lacking. The Demos helped me way more than the documentation (lack of it).
Thanks I will try tonight. I suspect I have tainted my machine with multiple attempts, and my results may not be representative. With your permission, I would like to include your instructions on the github page for other users.
Using a webapp with Platypus looks like a good option. The WebView you would just need to have the script \`print "Location:[http://localhost:8000](http://localhost:8000)\\n"\` after starting the local webservice. Bundling Mojolicious to be standalone inside of the Resources folder of the Platypus app doesn't look too hard check out carton\+mojolicious. Honestly this really is the simplest \*least\* overkill way to do a GUI now. You also have the advantage what you've done immediately works anywhere, Platypus just makes it look like a native app.
teaser! "In the autumn, we started work on our next Perl 6 product – which we’ll be announcing in just a couple more weeks"
Very interested to see how this turns out!
/u/nanis, the majority of your audience is classical Western educated and exceedingly likely to never even have heard of Khayyam and Sabbah before. I wish you would allow everyone to share in your happiness and write in a way that is conducive to understanding and explain the Perl simile. Which parts of the biographies apply to it?
i see that one of your modules has a replace_text function. can this be used to make words in a document bold?
Indeed. My first gut reaction is that he means God / Satan. I hope that that is not what he meant.
Have never used this module so not sure how it works, but it was the only thing I could find in relation to editing word docs with Perl [](http://search.cpan.org/~johanl/Win32-Word-Writer-0.02/lib/Win32/Word/Writer.pm)
Thanks but I'm on a Mac.
I don't do much async programming but it sounds like something is blocking Twiggy's event loop
I read this as: * Perl (5), Khayyam: Reflective, contemplative, wide-thinking * Perl6, Sabbah: Dictatorial, single-minded in that Khayyam the poet regards the found world as a source of mystery and wonder to be transcended (just as the original Perl regards the found Unix-ish world of C and shell scripts as something to be built upon), while Sabbah regards the world as something to be reordered, tamed, and bound to a new ideology unrelated to what has come before.
I don't think so - it replaces text, on an XML level. The basic concept should be usable to add bold bits though (split runs so the "to be bolded" text is in its own run, add "boldness" to that run's properties, I think).
Would it be a lot of work for you to add this (ability to make text bold/change colour)? I've looked at the code but I just don't have the OOXML understanding or XML skills to make this change.
I can have a look this weekend. Hardest part will be selecting the text to make bold - would a regular expression work for your use case?
It's all Larry Wall. He still holds BDFL status over Perl5 too. Perl5 tries all the time to copy Perl6 features only to learn they can't really implement them because it would break too much stuff.
This sounds like something that's going to require a tool other than Perl to do it. Perhaps the Mac scripting engine?
Yes, a regular expression. But really all we really want to bold/colour are individual words (or maybe groups of words concurrent in the text. Maybe ±40 words scattered throughout an ±800 word text. If you could have a look, we'd greatly appreciate that. A function to bold or colour words. To give you some context as to why we want this; we are a university and in the teaching material we present to learners, we want to highlight key words in the text which are important for them at their current level of study. We're not some mega-corporation. Maybe that helps Thanks in advance Fuzzy
I'd probably move the websocket code into a seperate daemon using net::websocket::server and front both with nginx, also I'd probably switch starman for monoceros or gazelle, because of the need for speed. 
Check for a line in your inline javascript that starts with a % or otherwise causes the EP engine to interpret as Perl. The "Bad name after ___" is a Perl diagnostic (see: `perldoc perldiag`) so the following bit of code would indeed trigger that warning: %= javascript begin $var = 'myvar'; % $sym = mypack::$var; % end
&gt; let me emphasize that I would never liken a mortal being to God, therefore the God/Satan comparison is not valid Not following that logic: since when are Perl 5 / Perl 6 mortal beings? 
I think I have a basic version working. Tomorrow or Friday I'll write some tests and make a new release.
I just uploaded the new release with the "style_text" feature. It may take a few minutes for it to pop up on CPAN.
just playing with it now. initial signs are sound. huge thanks.
just playing with it now. initial signs are sound. huge thanks.
[This](https://gist.github.com/lindleyw/c69e511b4e40f89a42feeb0221b5dd7d) seems to work just fine; how does your code differ?
&gt; I ... don’t think that 3.14 is 3. While some languages use the word "coercion" to mean something closer to "convert", its usage in P6 is intended to match the English word "coerce", i.e. to imply force. To me it makes sense that `3.14` is *forced* to convert to `3` rather than just being rejected. That said, Brad's SO answer shows that you aren't forced to stick with the built in notion of coercion but can instead customize it as needed.
Thanks for your efforts, but I think this is a problem with perl 5.18.1: https://irclog.perlgeek.de/mojo/2013-09-29/text &gt; 12:25 moritz woah wat? "panic: sv_setpvn called with negative strlen -2 at /home/moritz/perl5/perlbrew/perls/perl-5.18.1/lib/site_perl/5.18.1/Mojo/Exception.pm line 41. &gt; 12:27 marcus moritz: phear &gt; 12:27 * moritz upgrades mojolicious and hopes it will magically go away &gt; 12:27 moritz that was perl v5.18.1 and Mojolicious (4.26, Top Hat) &gt; 12:28 moritz + EV 4.15 &gt; 12:29 moritz still there &gt; 12:29 moritz :/ &gt; 12:36 moritz ok, I've golfed it down to less than 20 lines &gt; 12:39 moritz https://gist.github.com/moritz/6752178 here is the golfed-down thing &gt; 12:39 moritz should I submit that as a bug somewhere? &gt; 12:40 sri yes, to p5p &gt; 12:40 sri panic is by definition not our bug &gt; 12:41 marcus if you break Perl, you get to keep both parts? &gt; 12:41 moritz unless it's an EV bug &gt; 12:41 moritz is that used somehow? &gt; 12:41 marcus moritz: then it's *definitively* not our bug. &gt; 12:41 marcus also, good luck :p &gt; 12:41 sri may the flying spaghetti monster have mercy on your soul &gt; 12:42 * moritz asks in #p5p if that's known somehow &gt; 12:42 sri i bet p5p expects it to be golfed down further though &gt; 12:43 moritz sri: right, which is why i ask if it's known before I go to the trouble of doing it &gt; 12:43 sri btw. i get it on osx with 5.18.1 too &gt; 12:44 moritz \o/ reproducible 
That's precisely how I'd do it except I'd probably have Catalyst for the request/response server and Mojo for the websocket handler - Dancer2 is fine as a request/response system but PSGI's async spec is mediocre and AnyEvent is basically a footgun.
The behaviour described is basically designed in, running blocking request/response code in the same process as an event loop inevitably causes that.
Yes. The main Dancer2 request/response handling of normal HTTP requests.
What makes you think that is related? That's completely different from the error you mentioned.
Got it, sorry if I seem like a noob but I've not coded perl in over 10 years and have been spoiled by python. 
&gt;They see Perl 6 as the replacement because 6 &amp;gt; 5 It's as simple as that. The moment v.X+1 of a product is announced, v.X dies. Perl 6 has been killing Perl 5 for years.
Sometimes evolutionary experiments fail. If Perl 6 is an experiment that the majority of the Perl community feels has failed then the logical way forward is to make a clean break. This is especially true if "leadership" has pitched its tent in the experimental Perl 6 camp and have, as a result, effectively abandoned Perl 5. There is no sane reason for the Perl 5 community to voluntarily self-terminate by continuing to follow the dictates of such "leadership". Solution: Perl 5 needs to undergo a major version change — go straight to Perl 7, claim the namespace and get on with its life. Perl 6 can do as it pleases. Hindsight allows us to clearly see that it was a huge mistake to name the experiment Perl 6. The mutation of the language was too large. The community and has been fractured. The popularity of Perl has suffered as a direct result. If Perl 6 is as good as its proponents seem to think it is, then it should be able to stand on its own feet. Personally, I would like to see Perl 6 rename itself "Rakudo" or something. Even "Rakudo Perl" would be acceptable. So long as it doesn't have a version number that competes with Perl 5/7/whatever. The version number issue is supremely important. 2 kills/cannibalises 1. 3 kills 2. 4 kills 3. 5 kills 4. 6 is killing/cannibalising 5. It has to stop.
should have been clearer. if I remove all JavaScript includes from the template, so it's just HTML and some embeded variables and just load the template, this is the exact error I get.
&gt; Brad Gilbert shows the long hard way Christoph also showed the short, simple way: `Numeric() $ where Int` &gt; It turns out that this feature is broken and doesn't have a timeline for repair […] My advice is to not use this at all. It's not broken. It works exactly as designed in 6.c language. The ticket you link to explicitly refers to your proposal as "extending features" and it's unfortunate you're giving that advice.
&gt; About method Int () { 'Hello' }, I'm inclined to have the compiler automatically add a return type if the method name is the same as an existing class That feels like a lot of WAT for little DWIM. For example, core `Numeric` types have `.Bridge` method. So does this method have a return type constraint? class Foo { method Bridge {} } We can't tell by just that code alone. We need to know the exact language/compiler version along with the exact versions of all the loaded modules, along with any code that precedes it. As such, you can't safely use any acronym-based methods: class Message { method HTTP {} } Because what if language 6.f decides to implement class `HTTP` in core? Moreover, this construct wouldn't have a type constraint either, since `Bridge` type isn't known when `Foo` is compiled: class Foo { method Bridge {} } class Bridge {} Even worse, this doesn't have a type constraint enforced either, because Bridge isn't known at compile time: require ::('Bridge'); class Foo { method Bridge {} } And despite users being able to specify things like `my int $` and `method int (--&gt; int) {}` they won't get automatic return type constraints because there's no class `int`. Looks like a lot of caveats and special cases, all just to save the user typing `--&gt; Int`.
Perhaps an `is coercable` trait on a class could convey the meaning. On the other hand, it might be too much of a DWIM, indeed. Perhaps we should just document this has a piece of rope to shoot your foot off with.
I've never used Test::Class or similar so I can't really provide feedback, but it's nice to see more things built on the new Test2 framework.
First, look for something like "js::$" in your HTML, based on the error message you had. Otherwise: Strip away every bit of your source until you have the smallest possible program that exhibits the problem, and post a link to gist/pastebin here so we can see what's happening. You can almost certainly omit all the Javascript bits. Also, have you tried Perlbrew to run a newer version of Perl? 
If adoption is a goal, add a tutorial for migrating tests from Test::Simple/Test::More. Show how using TTx avoids their flaws.
At work, we use version numbers. Each structure knows its version (one of the mandatory keys in the hash). Modules exist named UpdateFrom_1.23 etc. which provide code to upgrade to the next version, so you can load arbitrarily old data (there's a limit related to our backup retention policy).
8 months late IS pretty belated...
Not really familiar with the problem space, so from a purely module-distribution point of view: I would have your COPYRIGHT section say COPYRIGHT AND LICENSE, and use http://dev.perl.org/licenses/ as the license link (since the license is not only the Artistic license); and have the full text of the Perl 5 license in your LICENSE file (you can generate such by installing App::Software::License and running `software-license --holder='Samuel Smith' --year=2018 --license=Perl_5 --type=license &gt; LICENSE`).
What you actually need is LWP::Protocol::https. Crypt::SSLeay is an antiquated implementation and you don't want to use it, LWP::Protocol::https now defaults to using IO::Socket::SSL if available (and will try to install it if you don't have it). Recent versions of SOAP::Lite will install the correct modules so make sure you are up to date, the latest version is [1.26](https://metacpan.org/release/SOAP-Lite). The specific error message you mentioned means that whatever line of code is referenced tried to run `LWP::Protocol::https::Socket` and either that package does not exist or it doesn't have a `new` method. SOAP::Lite is a very crufty distribution that has been completely rewritten a few times so you should make sure you have the latest version before anything else can really be debugged.
It is a bit of a mischaracterization to call all the questions brian d foy asked as “gotchas and design flaws”. Some of them are gotchas, some are design limitations, some are bugs, but the majority are from his lack of knowledge. Which is to be expected as he's trying to document things which may not be fully documented yet.
Is this the equivalent of [Catalyst::Model](http://p3rl.org/Catalyst::Model) or something more complicated?
I'd mostly agree with that. I went through all my StackOverflow Perl 6 questions and categorized them. I wouldn't say "my lack of knowledge" so much as my "reliance on the documentation". Because I'm writing a book aimed at the casual user I rely on the docs much more than the most people do. IRC logs, synopses, and many other extra sources aren't helpful to this audience. 
The mortals spoken of are Omar Khayyam and Hassan Sabbah. 
I have only read "the definitive guide to catalyst", and not really used it but it seems to have a more correct concept of what a "model" is. This plug in doesn't really do much more than call an external object, so I wouldn't call it complicated. But to delve into software engineering terms about what a "domain model" is and the correct context, that might get complicated, or at least opinionated :) I had to go with the name "DomainModel" as dancer2-plugin-model was already taken, but I think I am still using the term correctly (one reason I haven't uploaded it yet in cased I change my mind).
He labelled the link as “gotchas and design flaws”, which any reasonable person would infer to mean that they are entirely or at least mostly “gotchas and design flaws”. Basically he kind of did imply that even if it wasn't intentional. Almost everyone who has put significant effort into the project could take that as personal slight at any rate. Which I obviously did because it bothered me enough to overcome my social anxiety to post in the first place. The sentence after “lack of knowledge” was indicating documentation deficiency, which would make it more difficult to gain knowledge. I intended for that to come across as the main reason for you lacking knowledge, sorry that wasn't more clear. It is always good for someone who lacks knowledge to shine a light on what documentation is unclear or misleading as people who already know can't easily see them from that perspective. Basically every action (both yours and everyone else's in response) that has come from your effort is a good thing, and I really didn't like it to be turned into a bad thing because of how it was labelled. I mostly just did a quick scan of the questions to get an impression of them. To be fair I am more likely to see an “unconsidered dark corner” as a design limitation because I have been using the language regularly. Also some of them I have come across before, and I am more likely to assume “lack of knowledge” on my part than bug or dark corner. So when I see you asking about it, I would be more likely to classify it as I first assumed of myself.
You will want to test for word boundies (\b) s/\b inMyWorld \b//gx To test: https://regex101.com/r/vdaTW7/2 I also used the /x flag to ignore white space and make it easier to see the difference between \b and the string you are looking for.
s/'InMyWorld '/' '/ I think that works
[Crossposted to PerlMonks](http://www.perlmonks.org/?node_id=1211372/).
What does output look like? Does it actually listen on 8080? What does nginx proxy config look like?
One thing to try is to see if running the script's own preforking web server (I think it's Morbo underneath?) actually works. Presumably something like './script/hello_world daemon' ?
what interface is hypnotoad listening on? (sudo netstat -plnt) Note . you've copy pasted a config block that expects hypnotoad to listen on localhost only. The way I read that config is that nginx expects a request to http://myapp, and that needs to resolve to localhost/127.0.0.1. What does mojo.mydomain.com resolve to?
daemon is a command that runs a basic server. prefork is similar but runs a preforking server. Morbo is a server that manages a daemon process and restarts it when it detects file changes, for use in development only. Hypnotoad is a server based on the prefork server that additionally allows you to perform hot-restarts (restart the server with new code without dropping active connections). You can test mojo apps without using any of those, though: /path/to/script/myapp get /
Bad Gateway is usually returned by nginx when it can't reach the backend server, so the first step is to check the nginx error log and make sure that your app is reachable on port 8080 locally.
Pretty brief, but it gets the point across and communicates the gotchas. My personal preference for exception-style programming in perl is [Try::Tiny](https://metacpan.org/pod/Try::Tiny). There are a billion other modules on CPAN of course.
Wow, not OP but thank you for the great information! May I ask what you'd recommend for production? Thank you in advance.
Hypnotoad is almost always the right choice for a production webserver. The hot-restart functionality is designed for deploying updates without downtime.
Wait for the next article... or give [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) a try now... :)
In older Perls, `$@` could be empty after eval if a destructor is called at the end of the eval that calls another eval. Therefore, testing for `$@` after eval is not safe. You should always use eval { ... ; 1 } or handle_error($@); See also [Bug in eval in pre-5.14](http://www.perlmonks.org/?node_id=1153468). 
Wow, next is a loop seeking missile: #!/usr/bin/perl use strict; use feature qw/say/; use warnings; sub c { next; say "c" } sub b { c; say "b" } sub a { b; say "a" } for (1 .. 2) { a; say "in loop"; } output: Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. And if it doesn't find a loop, it will destroy your program: #!/usr/bin/perl use strict; use feature qw/say/; use warnings; sub c { next; say "c" } sub b { c; say "b" } sub a { b; say "a" } a; output: Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Exiting subroutine via next at t.pl line 7. Can't "next" outside a loop block at t.pl line 7.
**Advantages of Syntax::Keyword::Try** * It's a keyword, so doesn't require a trailing semicolon. * `return` works like it should, which is *very* nice for clean flow control. **Advantages of Try::Tiny** * It's an expression, so the return value of the `try` or `catch` can be used. This is also very nice. 
Thank you for your response. The output looks like: [Wed Mar 21 08:27:35 2018] [info] Listening at "http://*:8080" nging proxy_params (couldn't find anything that says proxy config) says: proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; 
Thank you for your response. Here's what happens when I get /: [Wed Mar 21 08:31:15 2018] [debug] GET "/" [Wed Mar 21 08:31:15 2018] [debug] Routing to controller "HelloWorld::Controller::Example" and action "welcome" [Wed Mar 21 08:31:15 2018] [debug] Rendering template "example/welcome.html.ep" [Wed Mar 21 08:31:15 2018] [debug] Rendering template "layouts/default.html.ep" [Wed Mar 21 08:31:15 2018] [debug] 200 OK (0.006006s, 166.500/s) This is followed by the html that I expect to see in my browser.
Thanks for contributing! You can see that I took your advice and posted the results above.
Thanks for your response. Here's the (partial) output of the netstat command you suggested: Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 1035/nginx -g daemo tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 4820/hello_world tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1035/nginx -g daemo The other copy of nginx on 443 is where our current CGI-based stuff lives. I'm hoping that once I get everything going in Mojo I can move everything to 'normal' https easily.
Where is the part that tells nginx where to proxy to?
When I run the mojo get command, it returns the html that I expect to see in my browser (Welcome to the Mojolicious real-time web framework!).
Fair enough. I think we're all good here :)
Then the issue is in your nginx configuration.
This behavior is certainly underdocumented.
The purpose of involving nginx at all is to access your app via 443. It proxies from there to your app listening on 8080.
&gt; Finally, we decided to use Cpanel::JSON::XS (as it fixes some flaws of JSON::XS) and enhance it by a type-enforcing system. This was what we did, too. Specifically, we wrote a type-enforcing system around `JSON::Schema`, where each service had a schema defined, and then the converter walks the tree and converts the types as needed. Speed seems to be acceptable for us. It also solved some of our old problems with booleans. Most JSON encoders in Perl will handle booleans if you go out of your way to give it one, but it's too easy to let it pass through as a 1 or 0.
Never intentionally, but I could easily see it causing a bug.
universal ctags is a more actively maintained fork https://ctags.io/ Oddly distros don't seem to have picked up on it!
This seems like a question better suited for the [p5p list](https://lists.perl.org/list/perl5-porters.html) or [irc channel](https://kiwiirc.com/client/irc.perl.org/p5p).
This is a bug. https://rt.cpan.org/Public/Bug/Display.html?id=119709
Well i didn't assume that was the intent there, but this was never different from the very first release on, and it doesn't look likely to be fixed anytime soon.
Hmm, the puzzle did tell me to use Perl, but sadly, this is the only thing I was given. Thanks anyway, I’ll just keep trying.
Given that it's from a set of puzzles, I suspect it's supposed to connect with another part of the puzzle. It might capture a specific set of characters when matching against a piece of text from another part of the puzzle, for instance.
Thank you! I’ll look into that!
It looks like there are a couple of asterisks in the expression (not a surprise), which cause parts of the expression to be *indented*. These could also be underscores, but they're probably asterisks. Could you please post it as code? You do that by putting 4 spaces the beginning... like this
Given the author, it's likely to be fixed as soon as someone capable of doing so appears.
 /\W{2}([Waded])[^ b-n]*.([Educated]*)\S{3,9}.\w.([\w]*).*([Defendant])\x64[\Wise]*([WISELY])+.+?(?!\w{2,}).\w{5,7}?(..).+?(?!\w{2,}).\w{5,7}?(.)([\w]*)[\D2]*[\d,]+([Franklin]*)[\D257]*/ 
/\W{2}([Waded])[^ b-n].([Educated]*)\S{3,9}.\w.([\w]*).*([Defendant])\x64[\Wise]*([WISELY])+.+?(?!\w{2,}).\w{5,7}?(..).+?(?!\w{2,}).\w{5,7}?(.)([\w]*)[\D2]*[\d,]+([Franklin]*)[\D257]*/ 
 /\W{2}([Waded])[^ b-n]*.([Educated]*)\S{3,9}.\w.([\w]*).*([Defendant])\x64[\Wise]*([WISELY])+.+?(?!\w{2,}).\w{5,7}?(..).+?(?!\w{2,}).\w{5,7}?(.)([\w]*)[\D2]*[\d,]+([Franklin]*)[\D257]*/
Tools like https://regex101.com/ can help you understand what each pattern is trying to match, so you don't have to decipher the expression. Here's the output: `/\W{2}([Waded])[^ b-n].([Educated])\S{3,9}.\w.([\w]).([Defendant])\x64[\Wise]([WISELY])+.+?(?!\w{2,}).\w{5,7}?(..).+?(?!\w{2,}).\w{5,7}?(.)([\w])[\D2][\d,]+([Franklin])[\D257]*/` * `\W{2}` matches any non-word character (equal to [^a-zA-Z0-9_]) * `{2}` Quantifier — Matches exactly 2 times * 1st Capturing Group `([Waded])` * Match a single character present in the list below `[Waded]` * `Waded` matches a single character in the list `Wade` (case sensitive) * Match a single character not present in the list below `[^ b-n]` * ` ` matches the character ` ` literally (case sensitive) * `b-n` a single character in the range between `b` (index 98) and `n` (index 110) (case sensitive) * `.` matches any character (except for line terminators) * 2nd Capturing Group `([Educated])` * Match a single character present in the list below `[Educated]` * `Educated` matches a single character in the list `Educate` (case sensitive) * `\S{3,9}` matches any non-whitespace character (equal to `[^\r\n\t\f\v ]`) * `{3,9}` Quantifier — Matches between 3 and 9 times, as many times as possible, giving back as needed (greedy) * `.` matches any character (except for line terminators) * `\w` matches any word character (equal to `[a-zA-Z0-9_]`) * `.` matches any character (except for line terminators) * 3rd Capturing Group `([\w])` * `.` matches any character (except for line terminators) * 4th Capturing Group `([Defendant])` * `\x64` matches the character `d` with index 6416 (`10010` or `1448`) literally (case sensitive) * Match a single character present in the list below `[\Wise]` * 5th Capturing Group `([WISELY])+` * `.+?` matches any character (except for line terminators) * Negative Lookahead `(?!\w{2,})` Assert that the Regex below does not match * `.` matches any character (except for line terminators) * `\w{5,7}?` matches any word character (equal to `[a-zA-Z0-9_]`) * 6th Capturing Group `(..)` * `.+?` matches any character (except for line terminators) * `+?` Quantifier — Matches between one and unlimited times, as few times as possible, expanding as needed (lazy) * Negative Lookahead `(?!\w{2,})` Assert that the Regex below does not match * `\w{2,}` matches any word character (equal to `[a-zA-Z0-9_]`) * `{2,}` Quantifier — Matches between 2 and unlimited times, as many times as possible, giving back as needed (greedy) * `.` matches any character (except for line terminators) * `\w{5,7}?` matches any word character (equal to `[a-zA-Z0-9_]`) * `{5,7}?` Quantifier — Matches between 5 and 7 times, as few times as possible, expanding as needed (lazy) * 7th Capturing Group `(.)` * `.` matches any character (except for line terminators) * 8th Capturing Group `([\w])` * Match a single character present in the list below `[\w]` * `\w` matches any word character (equal to `[a-zA-Z0-9_]`) * Match a single character present in the list below `[\D2]` * `\D` matches any character that's not a digit (equal to `[^0-9]`) * `2` matches the character `2` literally (case sensitive) * Match a single character present in the list below `[\d,]+` * `+` Quantifier — Matches between one and unlimited times, as many times as possible, giving back as needed (greedy) * `\d` matches a digit (equal to `[0-9]`) * `,` matches the character `,` literally (case sensitive) * 9th Capturing Group `([Franklin])` * Match a single character present in the list below `[Franklin]` * `Franklin` matches a single character in the list `Frankli` (case sensitive) * Match a single character present in the list below `[\D257]*` * `*` Quantifier — Matches between zero and unlimited times, as many times as possible, giving back as needed (greedy) * `\D` matches any character that\'s not a digit (equal to `[^0-9]`) * `257` matches a single character in the list `257` (case sensitive)
Thanks!
use "use lib qw(/path/to/library1 /path/to/library2);" at the top of your entry scripts. this is essentially the same concept as installing. 
A regex matches a string. So you are probably supposed to use the context of the clue to find the string it matches. Can you give us more info on the context?
Perfect! Finally It worked, tks
sadly, this was all I was given, but I've been working on finding word this matches to and i think I'm on the right track
Yes, maybe. But hey, maybe someone knowledgeable sees it here as well.
If there is no context, then I would try running /usr/share/dict/words through it.
Nothing in /usr/share/dict/words matches. That means it is probably a phrase, not a word. Are you sure there is no context? How was it presented to you? 
All I was shown was a blank page with just the code, but it’s alright, I just solved it. Thank you so much!
WedneSdaY?
Yep, that was it! I’m sure it took me whole lot longer than you to get there. Thanks!
&gt; Is `(?&lt;day_of_year&gt;\d{3})` trying to match `-01`. No, it's trying to match three digits, which is why it isn't working.
That was my first thought so I tried to match 2 digits. Not working as well. (?&lt;day_of_year&gt;\d{2}) 
Because you aren't matching the dash between the year and day.
The parentheses define what data is being captured. Put it outside them.
I thought I tried that. But its working. I should be able to get the rest. Thanks for the help.
Aside from the regex questions, that's an ISO8601 format so there are many tools to easily parse that without stumbling through the format yourself. For example [DateTime::Format::ISO8601](https://metacpan.org/pod/DateTime::Format::ISO8601).
Came here to say exactly this. Vastly superior to regex. 
I came up with: `^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d{3})`. For this type of thing I highly recommend [regexpal.com](https://www.regexpal.com/) This is the above example: https://www.regexpal.com/?fam=102920
I think you're after something along the lines of this that I've just knocked up for you. I've followed the general rules for the most popular ISO8601 (up to the second) since I've very rarely seen the time zone specified, but you use the second snippet if you really want. The vast majority of people using 8601 will use UTC, since they're bothered about people reading it later: perl -e 'my $date = "2009-01-10T18:50:30.000Z"; if( $date =~ /^(?&lt;year&gt;\d{4})-(?&lt;mon&gt;\d{2})-(?&lt;day&gt;\d{2})T(?&lt;hour&gt;\d{2}):(?&lt;min&gt;\d{2}):(?&lt;sec&gt;\d{2})/ ) { foreach my $k (sort keys %+) { print $k, ": ", $+{$k}, "\n";} }' With TZ, optional perl -e 'my $date = "2009-01-10T18:50:30.000Z"; if( $date =~ /^(?&lt;year&gt;\d{4})-(?&lt;mon&gt;\d{2})-(?&lt;day&gt;\d{2})T(?&lt;hour&gt;\d{2}):(?&lt;min&gt;\d{2}):(?&lt;sec&gt;\d{2})\.?(?&lt;tz&gt;\d{3,4}Z)?/ ) { foreach my $k (sort keys %+) { print $k, ": ", $+{$k}, "\n";} }'
[Time::Moment](https://metacpan.org/pod/Time::Moment) also takes ISO8601 as a constructor: use Time::Moment; my $t = Time::Moment-&gt;from_string($datetime);
Looks like the regexp question has already been answered, but as I don't see anybody else explicitly mentioning it ... with that date format the second number is going to be the month, not the day.
You need to be more specific. What are the steps to recreate this problem. You mention Windows Subsystem for Linux, but the error message sounds like it is from some perk installation on Windows that doesn't have a full set of build tools included.
Inspired by the sentence "this was all I was given", I tried to match the regex against itself...
I use active state perl and installed directly in windows 10 using the chocolaty package manager
Trying to use perl in Windows through Ubuntu running as WSL, is probably too convoluted. Perl runs on Windows without Ubuntu...Strawberry Perl or ActiveState both deliver a comprehensive versions of perl with all the build tools necessary. Once these are installed, open a command line and install your module using `ppm install Clone` or `cpan install Clone` 
I now have a Windows License, so could develop a back-end that is more reliable for Windows users wishing to try [GUIDeFATE](https://github.com/saiftynet/GUIDeFATE) . So now Win32 joins Gtk, Qt, Wx, Tk as potential usable back-ends. Of course only a handful of widgets are possible a menu, simple messageboxes, buttons, single and multi-line text boxes. A few example applications include now a Image Magick GUI scripting tool, allowing all (100 or so) functions to be scripted. [Try](https://github.com/saiftynet/GUIDeFATE/tree/master/Win32) without installing GUIDeFATE first please, and let me know if it works for you. (You need Perl, ImageMagick-Perl and Win32::GUI)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/saiftynet/GUIDeFATE/tree/master/Win32) - Previous text "Try" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Do you have the build-essentials package installed? Ubuntu has a bunch of perl modules in it's package manager too. Probably better to install that way if what you need is one of them.
What a fascinating library.
Easiest way is to have a separate checkout where you make your changes first and git pull to the checkout that's in use once it's tested.
YESSSSSSSS
It's not that easy. After an upgrade, the internal data structures might be different than before, so a simple "undo" might not work: if you stored the structures offline somehow (session, database, ...), the app wouldn't be able to work with them.
I think that's an option I was considering. But where you said checkout, I was thinking branch. Maybe 😀 Agree having a dev branch then cherry picking commits into the main branch, which I think is similar to what you're suggesting, may be an option. But it doesn't address the problem of making a change the end user, who is not command line capable (did I forget to mention that?), can back out changes if they make using the app confusing. Classic case is I might rewrite a piece of functionality late at night, get up, go to work, can't monitor is changes have been well received when the end user tries to use the app next morning. Functionality may work fine but user confusion with how to use it may render it effectively a bug. Would be great to have the chance to undo until I can introduce the new functionality when more time is available.
Have Dev, Staging, and Production branches. Maybe your Dev branches are just short-lived feature branches made off of master, you can test the app there, and merge to the production branch when you are happy. If something is really wrong on the production branch, you can reset it to the previous commit. That way, it reverts the entire feature rather than expecting your user to know how many commits to back up through to get back to the previous behaviour.
Does this one user really care that much to worry about this? Just search "git workflow" and start using it. If the user complains and you really want to help them for whatever reason, just deploy a front end just for them with the old website.
So how about tagging stable versions and having them available on different URLs? - https://your.app/v2018-03-01/ - https://your.app/v2018-03-11/ - https://your.app/v2018-03-23/ That way it's all statically available, no messing around with git, people get to choose when they want to drop back to an older version for a specific page or feature. With something like this you'd typically keep the last N versions, cleaning up older ones on deployment. Could even have a [bookmarklet](https://support.mozilla.org/en-US/kb/bookmarklets-perform-common-web-page-tasks) for "load this page in last version" if the users find URLs confusing - that way it's just one button away. Auto-fallback should also be possible in the client-side code, unless it's the client-side code that breaks!
Awesome! You're definitely getting there. The `Executioner.pl` script launches [flawlessly](https://i.imgur.com/5vEQlaC.png) from the test folder. It only launches the examples if I *don't* select a backend in the dropdown, though. If I select a backend, a console window flashes and disappears. Obviously I'm getting an error but I can't see it because the console disappears so fast. The ImageMagick example fails to load images with a series of errors. [This is what I get as soon as I launch it.](https://i.imgur.com/eBUGTho.png) Then I choose any image (the lizard, for example) but I get the scissors every time, with more errors. [Screenshot.](https://i.imgur.com/2vMBntg.png) 
That's a really cool idea, thanks. I'm pretty green with tags in git but hopefully should be easy enough to pick up. Suspect could also be easy enough to redirect to the different URLs from within the webapp as well. Thanks for the help! Much appreciated.
&gt; It’s worth noting that the first implementation of Perl 6 was written in Haskell. Fourth. Why does this myth persist?
Not only the first implementation of Haskell was written in Perl6, the two languages were developed side by side for a long time. Perl6 used to be the only big application developed in Haskell too, driving the development of the compiler.
Thanks for that. Can you tell me which Perl and image magic you are using? The scissors are what is left in GFtmp.bmp if you run rasps. Image magic loads the image, resizes it, saves to GFtmp.bmp and win32loads the bmp. In your case Image::Magick fails. It took me quite a while to get it to work. I will check what I need to do tonight.
Ah, that must be it, because you are using Strawberry Perl and I'm using ActivePerl. In ActivePerl (and it took me a while to realize this), ImageMagick is actually in a differently named package, `PerlMagick`, but the modules when installed are the same. 
Hi :\)
Audrey Tang (now minister for digital development in Taiwan) was at one point responsible for revitalizing development of both. She was the main Perl6 developer and a member of the Haskell' Committee (responsible for language development). I found this interesting interview that shows it was all intertwined back then: https://www.perl.com/pub/2005/03/03/pugs_interview.html. They go from development of one to the other from question to question.
If you find a recipe to get it working, then please let me know. I started off using ActiveState...but could not get it working. Strawberry Perl has its own binaries for ImageMagick, and I presume ActiveState may have its way of doing things as well. 
I've been doing some things on the Raspberry Pi in Perl. And it's pretty doable, but of course almost everything out there is Python oriented. I contributed mainly in the hope of growing the ecosystem for Perl on the RPi a little bit. And the project "Indoor Grow Room" may come in handy if I do a mini-greenhouse on my balcony as I'm thinking of doing this fall.
Create an [ODG](http://enwp.org/.odg) or HTML document, then run [unoconv](http://dag.wiee.rs/home-made/unoconv/).
Code is mostly for READING. Neither of those help, in fact, I would say just the opposite.
Because it increases the barrier for collaboration significantly. Perhaps emoji is easy for _you_ to use, but it's not easy for me, and probably many other people. Also, A-Za-z0-9 is an expansive enough character list that there's _NO_ need for emoji.
I have a Haskell book from 2007. It's a nice, concise little book. The last page of the book contains a key telling you how to translate *every* example in the book into valid code, because the author preferred his typesetting style to actual code you could type and run.
&gt; Not only the first implementation of Haskell was written in Perl6 By my count, there had been at least *three* implementations of P6 before Pugs came along.
PDF::API2 could do it
Audrey Tang was perhaps involved in revitalizing Haskell, but I don't think it's fair to say she was responsible it. She was only one of fifteen members of the Prime committee. Pugs was really only active for a couple years (2005-2007) and if you look at the Haskell mailing lists they were quite active and had little to no mention of Pugs. Haskell's been driven by academic and niche industry players pretty consistently for its entire lifespan. Perhaps Pugs was the largest visible project, especially for Perl people, but I don't think it made as much of an impact as you imply.
Thanks GlauchanGuy. Any pointers?
One thing that may not be completely clear: in Perl, classes are sets of values (i.e., types). In Haskell, classes are sets of *types*. When a Perl class is the natural fit for your problem, a Haskell type class is almost always the wrong solution. Usually, when a Perl class is the right fit for your solution, a Haskell record is the right fit, as well.
Key-value pairs are also usually the wrong thing in Haskell; you probably want a record here, too: 🧑🏻 ⟹ ( commitment =&gt; 𝑐, move =&gt; 𝑚 ) in Haskell should probably be 🧑🏻 ⟹ Msg{ commitment = 𝑐, move = 𝑚 } with data Msg = Msg{ commitment :: Int, move :: Coint } 
[PDF::Create](http://search.cpan.org/~manwar/PDF-Create-1.43/lib/PDF/Create.pm) seems to have everything you need and the man file describes exactly how to do it.
thanks
Well, practical implementation.
She wrote the first big application that run on it. Perl6, therefore Tang, drove Haskell development at the time.
Do records in Haskell have objected-oriented features, i.e. inheritance (with subsequent resolution)?
I don't see the relevance. Are you just trying to put down Haskell?
No, I'm asking a genuine question.
Haskell doesn't have introspection. Inheritance isn't really a valid concept here; it's specific to class-based languages, which this is not. Haskell records do late binding, yes, which is why I think they're the right thing when objects are the right thing.
Right. Let's say I'm writing a Unix-like kernel in Haskell. I wrote remote file system code and a local file system code. Now I need to write the VFS that will accept messages from those other subsystems that tell how to do file operations on them (list, read, write, etc). With OO languages, the usual way is to create a class that others inherit from, and they can add their own specific bits to it. Do you have a pattern that would give me something like that in Haskell?
Found out why the launcher could not launch anything...the combo was return the index rather than the content. Corrected that in GFwin32, and uploaded it the base of the github section. Have also modified the executioner to reduce the number of options to back-ends that are available. (Gtk is always there because checking if it is available using `eval "use GFgtk" ` seems to cause a crash)
Yes, records. I'm not sure what you're asking. Since you mention Unix, do you happen to know how device drivers were handled in the original Unix (or in Plan 9)? Devices were implemented by C structs full of function pointers. Records full of closures will do exactly the same job in Haskell. data File = { read :: Int -&gt; Ptr Byte -&gt; IO Int, write :: Int -&gt; Ptr Byte -&gt; IO (), seek :: Int -&gt; IO (), tell :: IO Int, close :: IO () } NB: terrible linked-list-based code follows. Haskell doesn't seem to have an equivalent to C++ vectors, and I didn't feel like making a syntax up. It doesn't affect the point. memoryFile :: IO File memoryFile a = do buf &lt;- newIORef [] ix &lt;- newIORef 0 return File{ read = \ n p -&gt; do s &lt;- readIORef buf i &lt;- readIORef ix let l = min n (length s - i) forM_ [0..l - 1] $ \ j -&gt; pokeElemOff p j (s !! i + j) writeIORef ix (i + l) return l , write = \ n p -&gt; do s &lt;- readIORef buf i &lt;- readIORef ix s1 &lt;- forM [0..n-1] $ \ j -&gt; peekElemOff p j writeIORef buf (take i s ++ s1 ++ drop (i + n) s) writeIORef ix (i + n) return () , close = return () -- not needed for this device } Do you want to be able to implement custom operations on a device? (Which is not Unixy). That would explain why you care about introspection, but it requires actual dynamic typing to do in Haskell.
Labeling them as gotchas is the exact sort of rhetoric that Perl 5 programmers who want Perl 6 to just disappear would use. That is a position I don't really understand as the reasons I love Perl 5 and want it to continue to exist and flourish are also reasons I feel the same for Perl 6. Any rhetoric that in anyway puts down either will likely get a response from me. I think the number of questions that couldn't even apply at all to other programming languages, because they don't have a particular feature, would be more revealing. (I don't know of another language that brings in so many features from so many sources while making them seem as if they always belonged together.) If you are doing the most exploring, you are the most likely to find the edges of cliffs. If you made a commit on any of the Perl 6 related repositories (including PUGS), it should have shown up in the [2015.12 Rakudo release announcement](https://raw.githubusercontent.com/rakudo/rakudo/2015.12/docs/announce/2015.12.md). I know that a lot of work was put in to massaging the data to try to include everyone and get their real names. Since you don't appear to be in there, perhaps you used a different username / email address and it wasn't noticed for the shear volume. (There is one notable exception of chromatic where there was code written to explicitly remove him at his request) If you make a commit to even just fix a typo in the documentation, you should be acknowledged in the next release announcement. (You may want to add yourself to CREDITS) If your contributions were of a nature other than a commit, that would be why you weren't included. It's not that such contributions are not valued, they are just harder to find. If you could locate your contributions it could be useful to make sure such contributions aren't overlooked in the future. As to the remark from Zoffix (brokenchicken), he regularly takes things more personally than I think is healthy; and I have occasionally called him out on his remarks, only to have him basically yell at me. If I had seen that remark in a reasonable time-frame, I might have said something. That stated, while I disagree with the words chosen, I will note that no one seemed to disagree with his sentiment. I'm sure that I've said or written things that came across worse than I intended; perhaps some reflection on your part might be productive. (In fact recently I have attempted to start to make up for something I said two decades ago. I won't go into details as it involves another person, other than to say that I regretted it immediately.) What I meant is that the people who regularly use Perl 6 can't easily determine in what ways the documentation is lacking as we already know the information that it skips over. So I appreciate the value of the results of brian d foy's work at least as much as the labor. If nothing else it can indicate what needs to be added to the docs so that the people who do the most work on the internals don't have to spend as much time helping new users learn the language because they misunderstood a feature. I think that Perl 6 will at least have a value in how it changes the perspective of the designers of new languages in the future, in the same way Perl 5 has. (I have seen PowerShell code that looks very Perlish.) Most languages tend to limit what you can do, while Perl 6 tries to make it easy to expand it in ways that weren't expected. I have seen an attempt to bring Perl 6 grammars to Python, so it is already starting to affect languages outside of Perl. (In addition to Moose and the implementations of it in other languages.) I have never talked about valuing labor for its own sake, nor would I. Or valuing something based on the amount of labor that went into it, outside of art. (I regularly tell my dad to stop doing what he is doing because the result isn't valuable enough, and/or is likely to be undone in a short time-frame.) People are using Perl 6 in production, so any labor that directly or indirectly lead to them being able to use the language is valuable.
I know that's how it works in C. What I want beyond what C has to offer is type checking and enforcement of interfaces. Every file system has always implemented custom operations, in every Unix, ever. Even "Everything is a file" only works if you don't look behind the curtain (i.e. don't call operations that won't work in all files, like escape and formatting codes). 
I would say the opposite. People complain because it's harder to type, but the fact that code is mostly for reading means that the fancy characters are a good thing.
I'm not familiar with usability of PDF libraries but just a note that [Imager](https://metacpan.org/pod/Imager) is usually easier to install than imagemagick bindings. [Docs on scaling](https://metacpan.org/pod/Imager::Transformations#scale())
I don't know what you're trying to say. What do you mean by "type-checking and enforcement of interfaces"? Something non-Unixy, I expect. But we're straying from Haskell vs Perl.
I dunno. By the time I stopped contributing to Pugs, the test suite took eight hours to run. Granted, the fact that an independent, reusable test suite came out of Pugs cannot be overstated... but "practical" is overselling the performance of just about every P6 implementation I can remember, let alone any other practical concerns.
Well, it did run, which was more than ever before, I think.
I have yet to come across code that used Unicode which was harder for me to read or modify, outside of missing glyphs in my fonts. It seems to me that you don't trust others to make choices which have the possibility of making code less readable. (or more readable) That sounds more like the Python view than the Perl view. I must just have a higher trust of other programmers.
[`b2gills` says](https://www.reddit.com/r/perl/comments/84arjd/what_is_perl_6_to_perl/dwdw30a/): &gt; As to the [remark from Zoffix (brokenchicken)](http://colabti.org/irclogger/irclogger_log/perl6?date=2017-02-02#l1102), &amp;hellip; I will note that no one seemed to disagree with his sentiment. &amp;hellip; perhaps some reflection on your part might be productive. This comes across as if you are saying that it is OK for me to be attacked using a racial/ethnic slur because Larry Wall and others did not disagree with it. And, that I need to reflect on why I invited such an attack. Please tell me that the choice that specific insult, in preference to all others one could have come up with, and the subsequent lack of disagreement with it (as you put it) are not rooted in their perception of the racial/ethnic background of a Muslim immigrant. Also, would you mind looking up if anyone else has been attacked using racist/ethnic/sexist slurs on #perl6? Why are we here? Because you told me using the word "gotchas" and "flaws" in referring to Perl 6's traps for the unwary might hurt the feelings of people who put so much work into it. I am seriously indifferent to their feelings, because they did not disagree with a such a nasty public attack.
The most interesting thing is the comparison between Perl and C.
Structs of function pointers is way to write object-oriented code in C. That is also how it could be done in assembly. So the way to work around it not being a first class feature is to have a record full of closures.
I didn't see it as a racial/ethnic slur. I saw it as a general distaste for your personality and behaviour that was taken too far. I do say that assuming I meant something as distasteful as what you think I meant is not doing you any favors in my mental view of you. I'll have you know that I was willing to date a Muslim woman of mixed descent that I talked online with. (I'm still not sure what I said or did in our skype call for her to ghost me, but it definitely wasn't because of what I said about her ethnicity or religion because I said nothing about them because neither matter to me.) Also I had no idea that you weren't a white Christian. (Perhaps if I looked at a bigger picture that might have changed.) You seem as though you might have as big a chip on your shoulders as Zoffix.
Haskell has static typing, so something like: x = object.read() object.write(something) can be turned into: x = read object write object something There can be several functions that have the same name and are distinguished by the compiler through having different types for their parameters. When you then want to add a new type of "object", you write new functions with the same name. To make this work in a way that you do not have to change the code that's just interested in using any "object" that implements certain methods, there's something that's kind of like interfaces in other languages.
Thanks, that would work indeed.
This isn't the right thing to do in my case. There are multiple messages sent: # Send the commitment and the move in the clear to Rob 🧑🏻 ⟹ ( commitment =&gt; 𝑐, move =&gt; 𝑚 ); # Rob sends his randomness in the clear to Alice my ℤ𝑞 \𝑠ᵣ = CHOOSE-RANDOMNESS(🧔🏾); 🧔🏾 ⟹ ( randomness =&gt; 𝑠ᵣ ); # Alice sends her claim to Rob my ℤ𝑞 \𝑠ₐʹ = CLAIM(🧑🏻); 🧑🏻 ⟹ ( randomness =&gt; 𝑠ₐʹ ); Doing it your way I would have to define a stringification for each type of Msg. They're meant to output something like: &gt;&gt;&gt;=====Alice sends====&gt;&gt;&gt; move: Heads commitment: 0x72559a4e9babdd92d44e3b0c81c2099c210fdc69a632b6c4d977fc045de611f9699545cb954845b3dcb4bf433630d028b87b044dc44cf17493206f6febcc0d1682510e132b3acb117e9916a5d1bc44a2b447dce08fe137121a2773ed994b95d9033586f7afa9dda864522283abd0d185f46482be97cd7334bcfa983423e610bae65eb85a2a65b80ec4e5d446b59c554b3f675e58e233986df171da9a6a08fabae1874fb92b8b4400f27ee0a83df7b7061e3ea2e95bf5977ecab4cb465d1fb0f8 ==========================
[`b2gills` says](https://www.reddit.com/r/perl/comments/84arjd/what_is_perl_6_to_perl/dwe9ald/): &gt; I didn't see [ape] as a racial/ethnic slur [Help yourself](https://www.google.com/search?q=ape+as+insult). &gt; I'll have you know that I was willing to date a Muslim woman of mixed descent Wow ... just wow.
There might be an interesting connection there. Cardano, the project I'm writing about, is now considered the leading project in Haskell. They even hired [Phil Wadler](https://www.youtube.com/watch?v=ofN8ui2oH8Y) to design their smart contracting language. Recently I heard Charles Hoskinson the CEO of IOHK who founded the Cardano project say something like "A minister in the Taiwanese government has approached us to build a blockchain voting system" \(or something similar\). I can't remember where now. I wonder if Audrey is involved because of her relationship to the Haskell community.
Notice that I said I didn't see it as a racial/ethnic slur, not that I don't. I have heard about that, once or twice, years ago. Honestly when I read it in this context I considered it more like someone using the word “ding bat” until you reminded me. Frankly if you lived where I do, you would probably get more tired of everyone waving at you, and saying hi than of any insults. Basically such things are the last things that I think of as they are almost as rare as hen's teeth around here. I regularly watch a YouTube channel where he calls himself a 200lb gorilla. (AvE) The nickname my mother regularly used to call me is monkey-butt. Not exactly “ape” per-se, but I have literally heard both many, many more times than I have heard anything of the sort being used derogatorily. (Technically I don't think that I've heard it spoken) I don't watch sports at all, let alone foreign sports, so how exactly would I know that is even a thing? This is literally the first I've ever heard of that. Frankly if I saw that, I would be more likely to think it was a similar activity to throwing tomatoes or flowers. Sure it's terrible that such things happen, but short of me moving to a place where it actually happens and making a stink; what more exactly can I do to reduce it? (again noting that I said that I might have said something if I saw it in a reasonable time frame) I am not aware if the comment was intended as you took it. I will say that if I see it again, and realize its connotation, that I will say something. Seriously though; why would I argue anything close to saying that everyone on #perl6 is the worst kind of racist? (Answer: I wouldn't.)
I see a new catchphrase: If your Perl code is not beautiful you're doing it wrong - there is another, nice way. There Is Another Nice Way I like that. That being said, I'd love to see what the numbers would be today.
+1
Your anthology of uses of similar words/phrases notwithstanding, here is how it looks from where I am standing: "Ape" is an insult of European origin used to describe peoples they consider to be inferior, subhuman. Someone whom I have never met called me the "pet ape" of a good friend of mine who is of European origin. This was done in my absence, behind my back, not during a heated argument between me and this person. The only thing this person knows about my background is my name, which is of Arabic origin. The insult "pet ape" embodies the assumption that I cannot be an equal of my friend brian. As you point out, none of the Perl 6 developers who were on #perl6 at the time disagreed with the characterization of me as a sub-human being subjugated to a person of European origin. Instead, they sought to console the person who hurled this insult. Before I found out [I was called a "pet ape"](http://colabti.org/irclogger/irclogger_log/perl6?date=2017-02-02#l1102) behind my back, I had already noticed that I had been called ["brian's pet" on #perl6](https://www.nu42.com/2017/02/perl6-programmer-frowning.html) which was bad enough. Why am I rehashing this? Because you said I was hurting Perl 6 developers' feelings by referring to Perl 6 "gotchas". As I said, if you'd like to quibble about exactly how many of the problems are due to "gotchas" versus "bugs" versus "design problems" versus PEBCAC, feel free to do that. I am indifferent to the feelings of Perl 6 developers for the reasons I stated. My criticism of anything Perl 6 related never included any personal insults. If pointing out technical issues and discussing them hurts their feelings, so be it. But, I no longer have much appetite for looking at anything Perl 6 related. After all, the world is full of imperfect but useful languages, Perl among them, that help me get stuff done. 
No, that means I have to learn what all the fancy characters mean. I think this is just a personal preference thing.
Somewhat tangential, but just in case anyone's trying to find documentation on this: the terminology here is slightly unusual, `AAry` is normally called a hash in perl. The order changes when items are added or removed, so it doesn't really behave like an array. - http://perldoc.perl.org/perldsc.html - http://perldoc.perl.org/perldata.html
I didn't know that. I won't try learning those now.
There is enough stupid shit happening in the US for me to even remotely care about most of the stupid shit happening elsewhere. (outside of violence, and such) Here ape is use to refer to … you know apes. (and gorillas and monkeys, the education system is not as good as it could be) It is also occasionally used as a classification of species within which Human is a subspecies. ... That's where I last heard of ape in reference to a[ll] human[s], it was Aron Ra talking about his series “A Systematic Classification of Life”. (also american) I saw pet and thought of a person following another like a puppy, not because of an actual power dynamic but because the follower looks up to the other person. Sort of similar to a teachers pet, but not quite. Are you going to now say that you don't look up to brian at all? I don't know how you could look at that exchange and think they were consoling him. They were telling him he shouldn't take things so personally. He regularly takes things too personally. Perhaps the people who responded also have the same blindspot as I did about that statement, and so didn't chastise him. I have previously chastised him for remarks he's written in the presence of a person new to the channel, only for him to attack me. I did that even though I was certain he would. It was more important to me that such actions were shown to be unacceptable. He has since reduced his presence on #perl6, I think in part because of his realization that he was taking things too personally. As I said, if I had seen it in a reasonable timeframe I would have likely said something. If you aren't going to take others feelings into consideration can you blame them if they do basically the same to you. (Ignoring Racism for the moment) (I have yet to stop trying to take your feelings into consideration. Perhaps I could try harder, but you are trying my patience, and calling me racist. Hopefully you will understand if my give-a-fsck is on the fritz.) I will grant that the statement used against you was far from great, and perhaps had worse intent than I had originally considered. Basically, because I am so far removed from the form of racism you are talking about that I didn't immediately see the statement as such; that somehow makes me racist? (I would like to point out that I do not remember at any point restating it, even when I didn't think about the racism angle.) I'm sure many of the questions were about features that Perl 5 doesn't have, even in module form. So they are “gotchas” that apply to Perl 5 in an even more extreme way than Perl 6. How would you feel if someone made a public sentiment of that with such a denigrating tone as yours. There are also features of Perl 5 that are just as bad or worse than those questions, for example scalar vs list context which has resulted in lots of bad press for Perl when such a mistake was found in Bugzilla. I think a feature which has caused security problems to be more of a gotcha than any of the questions being discussed. My problem with the original statement is entirely about the tone, not about pointing out that Perl 6 isn't as good as it could be.
This is not a particularly impressive sample. The information you're covering is all generic; none of it is specific to Perl, or to your book. Additionally, I can see a couple of strange misconceptions in your writing, such as: &gt; The initial offerings were the Pi Model A and B in 2012. The initial offering was the Model B. The Model A didn't become available until early 2013. &gt; The Model A had 256MB of RAM for $25, while the Model B had 512MB for $35. The original release of the Model B had 256 MB of RAM. [This was upgraded to 512MB in late 2012.](https://www.raspberrypi.org/blog/model-b-now-ships-with-512mb-of-ram/) &gt; The CanaKit micro USB power adapter is the standard way to power the Pi. CanaKit is one of many Amazon sellers of Raspberry Pi accessories. There is nothing especially "standard" about their power adapter.
&gt; Here ape is use to refer to … First, I think you confused the concept of something being "of European origin" with being exclusively of Europe: "*And by making it seem as if people of a non-European origin were more like apes than humans, these different theories were used to justify plantation slavery in the Americas and colonialism through the rest of the world.*" Second, please don't act as if I do not belong "here". Third, it sounds like you are saying in my primitive ways I probably did not understand "pet ape" was actually a compliment, and I should apologize for taking offense. Are you, maybe, friends with [Pamela Taylor](https://www.washingtonpost.com/news/post-nation/wp/2016/12/27/the-nonprofit-director-who-called-michelle-obama-an-ape-in-heels-has-lost-her-job-for-good/)? &gt; So they are “gotchas” that apply to Perl 5 (sic) in an even more extreme way than Perl 6. How would you feel if someone made a public sentiment of that with such a denigrating tone as yours. As I pointed out, I know Perl is not perfect, I do not pretend it to be, and I do not feel the need to attack people who might criticize a programming language. In the past, I have indeed [answered](https://www.nu42.com/2011/06/is-this-why-perl-sucks.html) [such](https://www.nu42.com/2015/06/quorum-creators-cannot-write-quorum.html) [criticism](https://www.nu42.com/2015/06/then-they-came-for-java-and-ruby.html) with reasoned discussion. You also say: &gt; calling me racist I never called you or anyone else racist. I said I am indifferent to the feelings of people who have no problem with someone attacking me using a racist/ethnic slur. Although, statements such as "*I'll have you know that I was willing to date a Muslim woman of mixed descent*" don't make you look good.
Here are the docs for File::stat for reference: [File::stat](https://metacpan.org/pod/File::stat) You can use [stat](https://metacpan.org/pod/perlfunc#stat) without that module but the object oriented interface is much less error prone. On a separate topic, I would recommend considering making it a real [module](http://metacpan.org/pod/perlmod) - requiring a perl script into another perl script was something you did in Perl 4 because modules didn't exist yet. Mostly you just change the file extension to .pm, give it a package name matching the file path, and add the containing directory to your @INC using [lib](https://metacpan.org/pod/lib) or wrappers like [lib::relative](https://metacpan.org/pod/lib::relative) or [the -I switch](https://metacpan.org/pod/perlrun#-Idirectory) or [PERL5LIB](https://metacpan.org/pod/perlrun#PERL5LIB).
Out of curiosity, I've decided to try 2 benchmarks on my machine, but reducing it to 1/4 of the string size since I don't have all that free time to spare waiting for benchmark results. This is perl 5, version 16, subversion 3 (v5.16.3) built for darwin-2level exec.tm.sec str.length 2sec 256kb 9sec 512kb 21sec 768kb 37sec 1024kb real 0m38.127s user 0m37.402s sys 0m0.164s node -v v9.8.0 exec.tm.sec str.length 1sec 256kb 7sec 512kb 29sec 768kb 61sec 1024kb real 1m3.537s user 0m45.787s sys 0m23.746s I usually believe these regex string tests are more revealing of the regex implementation than of the language, compiler or framework itself.
Note that the latest release of perl, 5.26.1, does that benchmark about 2.5x faster than 5.16.3 :-)
http://pugs.blogs.com/pugs/2010/04/how-to-implement-perl-6-in-10.html enjoy.
The little block reading `01f9d1` is different from the little block reading `01f9d4`, and it signifies something different. The little circles with colors that may or may not be different, depending on your color vision, signify something else, if they're indeed different. I don't know why this code even needs comments; the variable symbols are basically self-describing.
This is a good question to answer. I would have liked to see an article in the link rather than a promotion of an event. 
Considering that liz was the one who wrote a [very controversial open letter](https://www.reddit.com/r/perl/comments/7r1b33/an_open_letter_to_the_perl_community/), I'm sceptical about this talk.
Would you care to elaborate on your skepticism? Because the last thing I want to achieve is more controversy. And not giving that presentation is an option.
Hi Liz, I think you should give the talk. You are passionate about the subject and many people share your passion. It would be a good forum for discussion of the issues that cause "controversy". You and I both know that success of a language is down to demonstrable usefulness and pragmatic superiority rather than programming paradigms. 
I can't travel due to family commitments, is this going to be available online afterwards? If so, please update this thread with a link :)
I'm not sure there's going to be a video made of it. I do intend to be giving this presentation more often in the future, updating it as I go along.
Liz is great. She's done a lot more than that letter.
I'm just afraid that you will propose another idea that benefits Rakudo at the expense of Perl 5.
I made a personal choice as to what language I would code my business processes, and I decided Perl 5. It is a stable well supported language, simple to learn, and ticks all the boxes I wanted for a cosing language. I won't use Perl 6 because it is a new language, and I am not keen on complicating my systems with multiple different languages. Despite the unfortunate rejection of Perl by a large majority of coders in favour of popular languages such as Python, I am loyal to Perl 5 and that will be the language I shall use in all my projects. 
It's worth pointing out liz also [does a lot of stuff](http://news.perlfoundation.org/2015/09/community-heroes-liz-and-wendy.html) *for* the benefit of Perl 5.
This post is slightly misleading, it's quoting a phrase from the synopsis. The title of the talk is (currently) "The Future of Perl Is Here". Presumably it starts with a link to https://metacpan.org/pod/Future =)
Leonerd would of course love that. But no. Although I *will* mention Future.pm in my presentation.
Yes, but it's also clear she does not share all of the Perl 5 community's current interests.