Oops! Mea culpa. Thanks!
I would order the first two and the last one right now if they were available.
I've always had good luck with [Text::CSV](http://p3rl.org/Text%3A%3ACSV). Well, [Text::CSV_XS](http://p3rl.org/Text%3A%3ACSV_XS), but recent versions of Text::CSV use Text::CSV_XS if you have it (Text::CSV_PP if you don't).
Sigils are one of the major things that contribute to the "line noise"-esque look of poorly-written Perl (the other is regular expressions, which after 15 years, still make my brain melt a little bit). But they do serve a very useful purpose in the language by creating a concise way to say "treat this like a hash", etc. Sort of like a less angry version of typecasting. Also, in .. 5.14? (don't quote me on that), a lot of the context stuff is switching around, so you can turn things like push @$list, qw(one two three); into push $list, qw(one two three); And get the Right Thing. And, hah! [Here's](http://www.effectiveperlprogramming.com/blog/756) a random blog post about it. 
I don't like the unfair stereotype that no matter who does the coding, Perl is impossible to pick back up. That said, its harder than most languages to go back and figure out what the hell is going on.
Sigils also add to fast parsing when skimming through code. I can parse Perl code quickier than Python's. It may be ugly, but it makes me faster.
He means it runs faster.
i want to learn about all those too, but i don't see why the book or ebook format is necessary. i'm against programming ebooks. what are they? websites that lack functionality and cost money. all of these topics could be effectively handled by moderately detailed blog posts. 
I feel like this is a rehash of tired arguments - now being had amongst those in the emo generation. 
If you embrace, them, the absence of sigils much more than an aesthetic problem. They make reading through code much easier. I miss them when I have to deal with languages that do not have them because they MEAN stuff.
Ancient Greek looks like line noise, but maybe that's why they only let the smart kids study it.
just as true as one shouldn't blame pencil makers for ugly drawings
I am not aware of any performance gain in using: &amp;foo; Over: foo(@_);
Blogs are really hard to navigate when you're trying to read up on a complete body of knowledge because they lack such things as indexes or glossaries (in a useful form).
I've written more articles and blog posts than I can count and written or edited or contributed to more books than I have fingers. They're all very different media.
Me neither, but that's what the sentence implies.
I think he meant more efficient to type... I searched and could not find any resource stating that: &amp;foo; Is faster than: foo(@_); If that is what he is implying then I think he is just making stuff up! 
&gt;main reason why people whinge about the appearance of Perl code. I disagree, I blame the 50ish 2 character special variables that start with $.
And a lot of those have been superseded a long time ago by properties on IO::Handle objects.
I would order the first four, no question.
I actually like sigils. I recognize that they're a _little_ ugly, but they're a great way to differentiate code.
Perl is beautiful. Perl is alive. Perl is strong. Perl is here to stay. The Perl community is active and vibrant. Aaaaaaauuuuuuummmmm...... 
People don't like how regexp's are done in Perl? I feel sorry for them, seems rather annoying dealing with a function to do that. Then again I learned regexp's in Perl, probably made me biased. A lot of the beutty of the regexp syntax comes from how Perl works. The syntax makes a lot more sense when you throw the implied operator into the mix. Oh wait, we are trying not to be obscure? nevermind ...
I don't think it's a "how they're done" thing (it's fairly elegant), but that regular expressions, no matter how many (), "", or other syntax you wrap around them, are, by themselves, ugly to look at. `/\w+(\d+)$/` remains -- while concise, readable (to someone that knows regular expressions), and generally useful -- ugly to look at. You could put it in `preg_match("\w+(\d+)$"..` and it'd be ugly. You could put it in `$whatever =~ /\w+(\d+)$/` and it'd be ugly. Sadly, regexps are fantastically useful and no one has come up with a more human-readable solution.
Perl is alive! [ObBrianBlessed](http://www.youtube.com/watch?v=MFnmT82yGpk) 
I want Perl to be around until the day I stop coding. I want Perl 6 to be the next big thing. Problem is, the rest of the world seems to have already made up it's mind. We can say "Perl is alive", we can even show evidence of the healthy community around it, but to those who have settled on their position it just looks like we're acting like the Black Knight from Monty Python's Holy Grail (or the "I'm not dead yet" guy from the same movie). In Australia at least I feel like the battle is lost. Finding people who use or are willing to learn Perl is depressingly difficult. It kills me, because Perl has become so much better since I first used it more than 10 years ago. Modern Perl is beautiful, not at all deserving of the snide puns of "write only language" or "line noise". But I'm not optimistic of turning the tide. (Edit: I'm so glad this has generated discussion, I needed some optimistic views. Having the hiring blues at the moment.)
But for those who are optimistic, or at least optimistic enough to write blog posts advocating its use, it might be worth noting that their cause is not well-served by giving those posts the effective titles of "Perl...ugly" and "Perl...suck". You don't have to say anything. But if you do, "Perl is alive" is a better thing to say than "Perl is not dead."
I write Perl code. I have contact to others that do the same. I've earned some money writing Perl code (though my primary job is not in the software industry). I blog about Perl, and have enough readers to make it worthwhile. I don't know where you get your pessimism, but I know why I'm optimistic.
I just lurk on /r/perl for the most part, so forgive my naive suggestion: Instead of saying you're looking for help on a Perl project, why not ask for help on the project where framework 'xyz' is being used, and by the way, it's really cool because... fill in the blanks. Perl would still be involved, but it's not the selling point; it just has to surprise and delight folks after that. I mean, it's not like Ruby was really a language that most folks who use it today got excited about by itself. Rails is what made Ruby interesting to developers. On that note: what are the really cool Perl frameworks out there on par with Rails? Surely there are some good, cutting edge examples out there with active communities, no?
&gt; Problem is, the rest of the world seems to have already made up it's mind. Only as far as you believe the sneering of people so invested in their own languages they haven't looked at Perl in a decade, or if you believe people with questionable statistics. Hand the honest and open minded and reasonable people a copy of my book and say "You can write great code with Perl!" and, in my experience, most of them will discover it's a great language.
i don't care if other programming communities become larger than perl's. as long as perl has enough users to keep the codebase going, support CPAN, stimulate discussion, and address bugs...what do i care if other communities are larger? consider the php community. much larger than perl's now, yet there is still nothing like CPAN...the php core continues to have longstanding serious bugs that no one seems to care about fixing...and hardly anyone has anything interesting to say about it. so bigger is clearly not better. or consider the ruby community. its basically become the rails community, and furthermore it has become a haven for prima-donnas. maybe bigger, not better. i consider perl's community to be like that of haskell. the number of haskell users is small, but their community is excellent. #haskell is probably the best programming channel in irc. the mailing lists are vibrant, and there are lots of libraries. but oh no! more people use java, so i guess haskell is "dead"?? i've seen more activity in perl in 2010 than the last three years combined. and its not just old greybeards churning out blogspam. this is a vibrant active ecosystem now its not all rainbows...larry wall seemed to have transitioned out of his role as high seer for all things perl a few years back without announcing or recognizning the transition, and the perl community was slow at finding replacement leaders. i know larry is still active, but i think it is clear that others are now at the wheel
why are you do worried about the masses? you should be worried about "perl people" moving away from perl the day chromatic says "toodles, i'm switching to python" or damien conway moves to ruby or the rakudo team moves to lua, or cpan contributions dry up, then i say its fair to start freaking out...these are the people who are actually important to you as a perl coder 
why even acknowledge the "ugly" argument? its meaningless and has been beaten to death. i put them into the same category as the "monads, huh??" haskell detractors i'm sure ferrari owners periodically hear people bitch about not being able to drive stick as well
&gt; the day chromatic says "toodles, i'm switching to python" ... but I *have* written Python and Ruby and C and even shell and VBScript for money. The time to worry is if no one can make money writing anything in Perl.
I wrote this because I was tired of hunting and clicking in the PAUSE interface and I didn't see anything else out there to do this. Managing the files in my PAUSE account is now super easy, and, as a bonus, I don't even need to leave the command-line... Figured someone else might find it useful
Well said, I think yours is the best take on the value of that presentation. You're right, the message is for those who are discussing Perl to be careful how you frame the discussion.
Not a naive suggestion at all, quite a good one in fact. I think I'm going to try something like this in future recruiting. I think you could also be more generic (i.e. not explicitly name the framework, lest it give away the language used), mention the project and the broader architecture. Use this to get clever people and then teach them Perl when they're excited about the idea of the project. Provided of course you have an exciting project... 
Entirely good points. A great deal of the smart people I know are also pragmatic though. That is, they'll see what skills are likely to get them the best jobs (whether "best" involves pay or interest level or some other measure). The problem I'm seeing is the lack of good projects (again, money or interest-wise) that are choosing Perl. This makes me a sad recruiter and job seeker. It's one thing to convince people Perl is a great deal better than they have previously given it credit for, another thing entirely to get them to switch to it though, don't you think? (edit: spelling)
My overall problem is that the growth in the number of Perl professionals (i.e. making a living) may stagnate. After stagnation comes decline. To be fair, I've never seen the Perl developer community as healthy. Modern Perl (plus Perl Best Practices) has taken Perl to new levels, and replace TIMTOWDI with "TIMTOWDI, but these ways are probably better for everyone." Having come back to Perl in the last two years has made me want to stick with it, to the decline of other options. However, without growth in the number of projects using Perl, I can't see myself making a living from it. How do I convince a manager that doing a grand new project in Perl is a good idea when I can't build a team of willing and/or capable Perl developers? The pool of Java and .Net people is massively larger than the pool or Perl people (including those willing to learn Perl). Given that the percentage of _quality_ developers in the Perl group may be higher than in the Java/.Net groups, it still (seems) to take a great deal longer to build a team of Perl people. So managers take the easy road. So I'm doing a lot of whinging, but what I'm hoping is that you all eviscerate my arguments and point out ways we can get wider a̶c̶c̶e̶p̶t̶a̶n̶c̶e demand for Perl, so that we can continue to use it professionally and not just for hobby projects. 
Exactly! Developers wax poetic about Rails, GWT, Jabber, Hadoop, etc. because they get great results with those in their tool set. Catalyst and Moose are certainly reputable entries for Perl, but I think if Perl is to get a shot in the arm, it has to move on to more categories. Right now, it's just keeping up with the Jones IMO.
&gt; How do I convince a manager that doing a grand new project in Perl is a good idea when I can't build a team of willing and/or capable Perl developers? Can you hire good developers and teach them Perl?
its not that bad. i see resumes every day, and every day someone mentions perl without me asking for it. there's plenty of perl talent and it doesn't get any easier if you recast it as a java project, because burnout in java land (and php land) is very high. i code php now at my day job and i can assure you it is the last php job i will ever take. i hear the same thing from java folks all the time - this job is their last java job
More like can I find good developers willing to learn Perl. It's hard enough to find good developers, then the field narrows again when I ask if they are willing to learn Perl. Perhaps this second bit will improve as we catch the eyes of these developer with more articles about how great the modern Perl movement is.
In the same vein, I was pleased to have a conversation with one of our senior Java developers where he basically said he's sick of Java and has taken on some RoR projects recently to get away from it. Maybe there is hope. Edit: spelling
&gt; I found that LWP::UserAgent gives you more flexibility. This doesn't make sense. WWW::Mechanize is a subclass of LWP::UserAgent. Anything you can do with LWP::UserAgent, you can do with Mech.
&gt; WWW::Mechanize might be more suitable (and likely, slower) Your guess that Mech is "likely" slower is specious, especially when you're dealing with anything having to come across the net.
Don't be overly protective. The reason why WWW::Mechanize is slower in my experience, is due to all of the HTML parsing going on under the hood. Nothing beats the speed of LWP::Simple with hardcoded URLs (or hand-constructed POST data). It's a trade off: if the workflow is complex, or the HTML is complex or likely to change, then WWW::Mechanize is still the best route to go.
Not being protective at all. I just question the word "likely". If you have specifics to say, then please say them, and be specific. "I found that Mech is slower than LWP::UA when...." That's better than saying that Mech will "likely" be slower, because it won't. I've tweaked Mech an awful lot to make sure it doesn't do any parsing more than it needs to. If you don't get links, it doesn't parse for links. If you don't want fetch images, it doesn't parse for images. Etc.
Well, that sound *really* good. Maybe I should update the module on my PC because the few scripts I have using it are not speed demons -- and it's *not* the fault of the webserver being slow... 
Run your program through Devel::NYTProf. It will identify your hotspots. It is a fantastic tool. Maybe it's Mech, maybe it's not.
DBIx::Class - "It's currently considered EXPERIMENTAL - bring this near a production database at your own risk! The API is *not* fixed yet, although most of the primitives should be good for the future and any API changes will be posted to the mailing list before they're committed." Are you sure it's time?
Actually, the author is Damian Conway. It appears that Alexandr is maintaining it.
I love these. I doubt i'd ever deploy them in production, but for small data processing scripts they are wonderful for knowing what goes on without having to litter your code with hundreds of print statements.
Here be dragons!
Note that this uses a preprocessor and will cause weird unexplainable bugs and interactions in/with your code. Used this for a larger program, and errors kept popping up that apparently originated from code that wasn't even included in my file. Having to disable debug output to properly debug the program is sort of defeating the point.
Agreed. The fact that comments won't execute is a basic assumption made by everyone and everything that interacts with your code. It might look cute to turn your comments into executable code via Smart::Comments but I think there's a lot of potential for breaking things that don't expect to have executable code injected.
Indeed. But it's not like my code did anything weird at all (it was pretty plain and boring), errors would just sometimes occur when you put a comment at the beginning of a block or whatever. The problem would then disappear if you added a few blank lines around the comment.
That sounds more like a bug with Smart::Comments itself. Maybe its not injecting line breaks correctly? :-) 
Possibly. I didn't really feel like debugging it, so I just turned it off.
I love using these for debugging, but always remember to disable them (entirely; i.e. comment out the module import) before deploying.
I love this module and use it extensively in my code for two reasons: 1) It encourages me to add meaningful comments to my code, because 2) It's a God send for debugging a script, trying to figure out where its dying. 
Set up one in xorg.conf (you might need an explicit screen layout for it), disable X's input hotplug, and access the other one as an [evdev](http://search.cpan.org/~beppu/Linux-Input-1.03/lib/Linux/Input.pm) device only. That should work.
You can dynamically detach devices from X11 with the XInput command. xinput list Find the device you don't want connected to the X-Session: xinput float $id And that device shall stop sending events to X =) You can reattach it later if you want to with similar commands. Once its detached, you're free to read from the raw device and not worry about X seeing the key-presses.
I don't have any help on your main question, but as a general rule, it might be helpful to spend some time working on your deployment tools. "Cumbersome" is bad.
What does the example template code provided by the article do? main { ... application code here ... } return main(@ARGV) unless caller(); 1; For at least the first line, I know that Perl lets you create little brace-delimited unnamed blocks with their own local scope, but I'm not sure I've ever seen one labeled like that (if that's indeed what's going on). And then later it's being called as if it's a sub (that is, `main()`). I think `caller()` and having `1;` at the end might be for using the script as a module, but my understanding is that Perl modules and scripts are 2 different animals (scripts: .pl, modules: .pm)... 
If you want it to look like a Windows 7 app on Windows 2003, you need to either: * Reimplement the entire W7 UI theme framework, either as a clone or emulation * Render your GUI's controls as fake bitmap buttons Your real problem is that you've designed a GUI with hard-coded pixel co-ordinates and invalid assumptions of fixed typefaces and font sizes. Don't do that. Use a proper flexible layout.
If you're forking a separate process anyway, do you really need threads? Just use IPC::Open2/Open3 and select/read/wait as they feed their results back and finish. See 'perldoc perlipc' for more information. http://perldoc.perl.org/perlipc.html
If I read your code right, you're create()ing one thread per IP, for a total of 1.5 million threads spawned. Each of which spawns a shell and runs snmpwalk. I don't know offhand what the memory usage of spawning a shell and running snmp walk is, but I wouldn't be surprised if it's in the on the order of 5 megs each. 5 megs * 1.5 million = 7.5 gigabytes of memory. And that's not even considering all the CPU time it'll take to start up all those shells...
Memory and CPU issues aside... spawning ten bazillion threads is not necessarily a good way to increase performance. Your CPU runs best with a certain number of active threads. More threads than that will just slow things down, thrash CPU cache, eat up OS memory and resources to keep track of 'em all, etc. Exact numbers will depend heavily the exact make and model of CPU. But I'd keep it under 1k regardless. The only exception would be sleeping threads. If you have 1k threads but 990 are sleeping and only 10 are active, you're ok. But 1k active threads... that's pushing it.
Yeah that's why I have a sleep after 200 threads to give them them some time to finish their task.
&gt; How would you guys do that? Cut out the middle man. Get an SNMP library for perl and use it to connect to each IP address, read the SNMP info, and then go on to the next one. Don't spawn a new process for each IP. It's entirely unnecessary.
I thought about that, but I thought that spawning multiple processes would be faster.
Thank you that works like a charm!
Evidently not so.
To add an aside here, it should be noted that Perl's threads are _not_ like other threads. They are not lightweight. When you create a new thread, Perl will copy _everything_ to the new thread (which then becomes that thread's private data). You can quickly blow through memory with Perl's threads. [Here](http://perldoc.perl.org/perlthrtut.html) is the contents of the `perldoc perlthrtut`. There are many other alternatives for tasks like this. The best one I can suggest would be to use [POE](http://poe.perl.org/) or one of the other event frameworks around. 
You can do it all simultaneously in a single thread. See the previous suggestions about POE &amp; co. You might also be interested in [this](http://search.cpan.org/search?query=POE+SNMP&amp;mode=all).
Wow. Did not know that. How is threading any different than forking in Perl then?
I haven't seen that in the `README` in several years. The current version (0.08124) says: &gt;We do our best to maintain full backwards compatibility for published APIs, since DBIx::Class is used in production in many organisations, and even backwards incompatible changes to non-published APIs will be fixed if they're reported and doing so doesn't cost the codebase anything.
Sharing data between threads is somewhat easier than sharing it between processes. Forking is generally cheaper and faster on any decent operating system (at a minimum, one which supports copy on write memory pages).
s/POE/AnyEvent/g; AnyEvent doesn't impose a framework on your application, but provides the same functionality and is significantly more light weight, especially if you use EV under the hood (which is the default).
Oh, looks like I landed on an old CPAN page when I searched. Strange. My apologies.
I'm the author of the post. The technique is explained in the Perl Testing (http://oreilly.com/catalog/9780596100926). The idea is that ALL code goes in subroutines, hence the sub main. If the script is run from the command line caller returns 0 and main is called. If Test::More requires the script then caller returns non 0 and we pretend the script is in fact a module (hence the 1;). Test::More can then test main the same as a function in a proper module Hope that makes sense
Check the CPAN under the `Devel::` heirarchy; there are many useful modules for this. Examples: * [Devel::TraceUse](http://search.cpan.org/perldoc?Devel::TraceUse) * [Devel::TraceLoad](http://search.cpan.org/perldoc?Devel::TraceLoad) * [Devel::TraceINC](http://search.cpan.org/perldoc?Devel::TraceINC) * [Devel::Loading](http://search.cpan.org/perldoc?Devel::Loading) * [Devel::Modlist](http://search.cpan.org/perldoc?Devel::Modlist) * [Devel::Dependencies](http://search.cpan.org/perldoc?Devel::Dependencies)
Thanks!
Agreed, AnyEvent gives you a lot of flexibility in choosing how you query concurrently. 
I think the right thing to do is pretend character encodings don't exist inside perl, and everything outside it is an opaque binary blob that needs to be parsed/serialised at the edge. I had to deal with the same thing recently getting data from a DB to an ajax JSON request, and it got a lot easier once I told DBI to use a utf8 connection (though I find it stupid that that's not the default) and let the JSON encoder just deal with it, instead of trying to figure out how to encode everything myself.
Fuck me why is dealing with utf8 properly so damn difficult? I think part of the problem is that "broken" code subtly works until you hit an edge case. Anyone know of good testing procedures to make sure your app handles UTF8 properly?
The registered Module List has long outlived its usefulness and needs to be retired.
Dealing with UTF-8 doesn't have to be difficult if used end-to-end. In reality, a lot of tools and systems are not UTF-8-centric, although it's increasingly the case. I hope by working through issues like the one in the article things can eventually be simpler for developers. 
Sure. Again I think an example of proper, end-to-end dealing of utf8 would be nice to have. I'd do it but I'm not an authority on dealing with utf8, and I'd probably mess it up. A series of code examples, maybe? (e.g. *Do this and you won't get bit*)
Seems like it. This is the first I'm ever heard of the thing. Started learning Perl about two years ago.
But there *is* no sub main (that I can see). It's just a block with the name "main" in front of it (there's no "sub" keyword before "main"). 
You don't want to use telnet for this. In addition to being completely insecure, it's also a pain in the ass. Do yourself a favor and enable ssh with pubkey (aka passwordless) auth. I do this with DD-WRT so I know it works. Not only will it prevent your password from floating around in the clear, but it also removes all the hassle of having to deal with prompts and expect. After enabling the ssh daemon, create a keypair (if you don't already have one) with `ssh-keygen`. Add your public key to the ~/.ssh/authorized_keys file on the router. Touch the ~/.hushlogin file to suppress the motd if you like. Now your perl for getting the uptime is this: my $uptime = qx(ssh root\@192.168.1.1 uptime 2&gt;/dev/null)
Thank you for this. I do know that using telnet isn't favored, and I don't plan to do it in this case. Using telnet is applicable mostly in an environment where ssh isn't available, which I need to learn to script for. (I'm working for an ISP with lots of old equipment all over the country which supports telnet only.) And; If i would need several commands in a series, (en; &lt;password&gt;; conf t; int Fa0/1, etc.) that would be hard to do with only a one-command ssh query. From what I can understand, a solution such as Expect.pm would be required in that case. However, your solution works in this specific case, and I do thank you for that. :)
Hmmm... if he's going to use SNMP he can go the extra mile and use [Cacti](http://cacti.net/), and graph this stuff. I admit, it's PHP, not PERL, but it's a very useful tool for this sort of thing (I use it at work on a large scale).
I would use regular expressions, this site has some great examples/howtos if you haven't used them before: http://www.regular-expressions.info/ Here's another page with perl specific examples just in case http://www.troubleshooters.com/codecorn/littperl/perlreg.htm
You can chain commands with ssh the same way you can with telnet. Expect has all kinds of failure points that you won't have with an actual comms API like SSH.pm.
Useful hint: there's no such thing as DBIx.
There is no command limitation to ssh. You know how you can run any arbitrary complex shell command sequence with `sh -c`, e.g sh -c 'foo &amp;&amp; bar &gt;/dev/null; for F in X Y Z; do frob $F; done; echo "xyzzy"' This forms the basis for perl's backtick/qx operator as well as many other languages' similar features. Well you can do the same with ssh as ssh is meant to act like sh but secure: ssh user@host 'foo &amp;&amp; bar &gt;/dev/null; for F in X Y Z; do frob $F; done; echo "xyzzy"' But of course for routers that don't have ssh interfaces you have to use telnet. Still, I would recommend using SNMP whereever possible because expect and telnet are so annonyingly fragile. 
Indeed, I usually go with "DBIC" to avoid any confusion
Well there is, but it's a namespace, not a module. I was hoping this post would talk about some of the interesting work in that namespace away from DBIC (like Connector), but no, it's just confused.
Agreed. He's using DBIx::Class and he's not saying it. "DBIx" is the namespace that *all* authors writing additions to DBI are expected to use, because Tim Bunce forbids use of plain "DBI". Personally, I like DBIx::Simple, together with SQL::Abstract. With it, you can write: $db-&gt;insert('people',{ name =&gt; 'Tom', pid =&gt; 5}); $db-&gt;insert('people',{ name =&gt; 'Jerry', pid =&gt; 6}); which isn't bad compared to the code he's bragging about, and without the need to first build a backstage module to perform the magic. 
FWIW, Connector *is* the shit. :)
I know, I use it ;) I just wanted to see even more cool shit
Vim
Use [perlbrew](http://search.cpan.org/~gugod/App-perlbrew-0.15/bin/perlbrew) and any OS you want. None of the distros I've used ever seem to play nice with CPAN, or have up-to-date packages.
Ahh, that really is the best plan? I was starting to do that and then realized I had no idea how to get mod_perl to be compiled against my compiled Perl. Went through more figuring and realized I was going to have to compile Apache to be able to do that. Which isn't that daunting, just seemed like a lot of work that might very well be wasted once again...
With you on that one. Though not related to what I was asking ...
Or even an up-to-date Perl! Forget /usr/bin/perl, just install what you want. I second the [recommendation for perlbrew, and would add cpanminus and Task::Kensho](http://oylenshpeegul.typepad.com/blog/2010/12/perl-satori.html).
Oops ... trigger happy, I guess.
happens :)
Didn't know about Task::Kensho, that looks sweet.
I like Debian "testing" ("unstable" is good too). It's still stuck on perl 5.10 though. I expect it to move to the latest once the freeze is done. Debian is nice because you can use dh-make-perl to create native Debian packages from cpan stuff. Plus all of Catalyst is just there by default ("apt-get install libcatalyst-perl"). They seem to have more cpan stuff in modules than Fedora or some of the others. Their naming technique is "lib" . lc($cpan_name =~ s/::/-/gr) . "-perl"; Ubuntu is Debian based so it's good choice if you want a slightly more user friendly system.
ya, I started with Ubuntu. It was super annoying and I think the documentation is awful (because its targeted at the common user). Debian wasn't as bad (I actually can't remember why I decided I didn't like it) but still had some of the annoyances I found in Ubuntu. 
iVim.:wq Wait, what?
Well, that's the way if you _have_ to have a mod_perl Perl app. If you have a FastCGI app, or are able/willing to use Apache as a reverse proxy, then you don't have the problem of recompiling Apache... and sometimes you even get a better speed out of the whole thing.
Not sure about catalyst, but others are working fine for me in Arch. CPAN installs are also fine. Also try using pacpan if possible. Also you can try perlbrew for virtualenv kind of experience. 
CPAN works pretty well on FreeBSD. It registers everything you install in the package manager, and doesn't seem to have trouble mixing modules installed from ports and CPAN. At least, I haven't had much trouble in years. But yes, perlbrew and local::lib are handy for a development box.
I use debian but try to avoid the perl modules provided by apt and stick with cpan. I have a separate user on my machine that I can su to with a self-contained environment, so I can blow it away and start over if need be.
Hmm, that might be easier. Catalyst does come with a fast cgi server. Then again I already compiled Apache. Just need some spare time to remove the package httpd and make install the compiled httpd.
Actually FreeBSD, more or less, plays nicely with CPAN. On FreeBSD the installed modules will actually register themselves with the local package system, make them easy to uninstall. 
Never had any problems with Linux Mint (based on Ubuntu based on Debian). I use aptitude to install the supported modules, and for those that aren't in the repo list, I just use CPAN or wget/tar/perl/make to handle the missing bits... but those are far &amp; few between.
Debian, Ubuntu. We even package our own software (on a local aptable repository) for easy deployment :-) If a CPAN module isn't packaged yet, we do it ourselves. If multiple modules exist we prefer packaged ones, unless the non-packaged one has a much better API or a feature we particularly like.
If you can use the FastCGI server, it is all easier as you can use your distro-supplied httpd (apachee, lighttpd, nginx) or even the catalyst's own httpd server for development. The app can then just be called with the "right" Perl path (that is, the perlbrewed one)
And CPAN doesn't really play nice with package managers (or maintainers), which is rather unfortunate.
Most of CPAN works with Strawberry Perl on Windows. Pair that up with Padre, the Perl Development Environment for Windows, and you have a pretty good reason to not have to re-invent the wheel ***just*** for an IDE.
Anyone who's qualified care to comment on Dancer vs. Mojolicious?
Such talk usually lead to "wars". Better to do some good old fashion investigation on your own. At the very least you will get a couple of hits with "Mojo vs Dancer" in Google. :-)
So, I've been using Dancer for a month or so. This looks pretty similar. Why should I switch to Mojolicious?
From http://mojolicio.us/ &gt; Installation - All you need is a oneliner. :) Attempt 1: $ curl -L cpanmin.us | perl - http://latest.mojolicio.us curl: (6) Couldn't resolve host 'cpanmin.us' :! Attempt 2: $ curl -L cpanmin.us | perl - http://latest.mojolicio.us % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 167k 100 167k 0 0 87222 0 0:00:01 0:00:01 --:--:-- 400k --&gt; Working on http://latest.mojolicio.us Fetching http://latest.mojolicio.us ... FAIL ! Download http://latest.mojolicio.us failed. Retrying ... ! Download http://latest.mojolicio.us failed. Retrying ... ! Download http://latest.mojolicio.us failed. Retrying ... ! Failed to download http://latest.mojolicio.us ! Failed to fetch distribution :(
works perfectly here: mBook:ticket_system marcus$ curl -L cpanmin.us | perl - http://latest.mojolicio.us % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 167k 100 167k 0 0 90316 0 0:00:01 0:00:01 --:--:-- 334k --&gt; Working on http://latest.mojolicio.us Fetching http://latest.mojolicio.us ... OK Configuring kraih-mojo-9b256ec ... OK Building and testing http://latest.mojolicio.us ... I own the cpanmin.us domain tho, I have been in contact with my dns hosting asking if there has been any problems. I find it suspicous that you are having trouble with *both* cpanmin.us and latest.mojolicio.us tho. Maybe your isp has some DNS trouble with the .us TLD?
http://mojolicious.org/ lists a lot of the features that Mojolicious has compared to dancer. Basically, Mojolicious is a fully async HTTP 1.1 stack including a MVC framework and a production ready long poll daemon, while Dancer is "just" a MVC framework.
Strange - possible I guess - I'm in Switzerland. Was able to download and run from the CLI so happy again.
So Mojo is to Dancer what Catalyst is to CGI::Application?
dancer includes its own daemon...
this is great! yeah there's some similarity between this and dancer...TIMTOWTDI! i hope both projects flourish....there doesn't appear to be any reason for happy dancer users to run to mojolicious the docs for mojolicious are great...that might give them an edge with new users...but dancer also has good docs i would like to see some more docs for mojolicious::lite that discuss projects that are more than 'one file'....there is minimal discussion of external templates...maybe expand that?
A single look at the Mojolicious feature list would reveal that there are countless reasons for switching. And did you intentionally ignore the whole guide dedicated to growing single file prototypes into well structured applications?
One of the better analogies i've heard recently, Mojolicious is in fact a continuation of the Catalyst idea. The main focus of Mojolicious is on growing small prototypes into well structured applications though, so it is more of a Catalyst/CGI::Application hybrid. You don't make a decision upfront, you just grow when you have to.
No, it does not. In fact it never even touches HTTP itself.
It actually uses HTTP::Server::Simple, which is, well... Simple.
Both have plack support. Is there a reason to care about bundled servers?
You are missing the point, rereading marcus original answer might help. What we are talking about is a real async HTTP toolkit (client *and* server), not just server glue. For Mojolicious the neat little web application DSL is just the tip of the iceberg, for Dancer it is everything.
Almost anyone reading this is coming from the perspective of developing straightforward web applications. "The point" of a more extensive async http framework is really not immediately clear to someone like me. You could perhaps explain you feel Mojo is better positioned for websocket stuff as that becomes ubiquitous? Perhaps explain how certain other modules Mojo has reimplemented are inferior?
I thought the release announcement made the direction pretty clear. Edit: Less grumpiness.
He's trying to and he's asking you to help him understand by highlighting for you where his and many other's lack of understanding might come from. In return you are being snippy and insulting. Bravo.
Good explanation, thanks.
no, i actually read that last night, but it struck me as more of a guide to exploiting the mvc capabilities of the mojolicious package hierarchy... by the way, don't construe my comment as a critique...i think mojolicious has great docs!
websocket-driven apps will tend to have long(er) lived connections...using an epoll/kqueue async approach can help reduce resource use for serving static files, or any webapp that is disk i/o bound, an event-driven approach is less compelling...and does your db have an event-driven api? etc etc architectural limitations will only tend to impact sites with acute performance issues...otherwise you will likely not be limited by your http server...use what you like. i intend to serve my personal site with mojolicious
i stand corrected...i probably installed that with cpanm shortly after dancer and had assumed they were installed together
Actually to me it seems more like he's looking for validation to keep using Dancer, something i definitely can't give him.
SDL is being actively maintained and has a couple of demos too, you should probably try it. You can also use Clutter that's a nice wrapper over OpenGL and allows you to do animations quite easily.
Maybe you just need to elaborate a little more then, suggestions for new documentation topics are always welcome. :) About external templates i'm afraid there is really not much more to know, they work exactly the same as inlined templates, just get higher priority.
Yea, what he said. http://arstechnica.com/gaming/news/2006/02/games-perl.ars
I highly recommend dbish. saves so much time and effort
[This](http://blog.plover.com/prog/perl/lines.html) probably doesn't help, but what the fuck.
Really, no, he doesn't. I've slept over it and reread things a few times. He's admitting his ignorance and asking you to help rectify it. Anything else you might see is merely you being needlessly aggressive and interpreting things into what he said. :/
Holy cow, why do they need to make 20 tiny pages instead of a big one?
So you see more ads.
You might be able to use [wxPerl](http://wxperl.sourceforge.net/). I'm a novice when it comes to wxWidgets though, but I thought I'd just throw this out there.
This is really really old. That API is no longer supported. Please use https://github.com/PerlGameDev/SDL_Manual/raw/master/dist/SDL_Manual.pdf
If you are looking for the simplest API I believe SDL has this. I know I may be tooting my own horn but have a look at this: https://github.com/PerlGameDev/SDL_Manual/raw/master/dist/SDL_Manual.pdf 
Because the year was 2006 and pagination was a new fad. https://github.com/PerlGameDev/SDL_Manual/raw/master/dist/SDL_Manual.pdf
Oh, this is great. Thank you.
Haskell. It supports TMTOWTDI much more than you would guess from a pure functional language. ;) It's also high level and favours writing compact code. Hackage contains quite many libraries. Clojure... maybe. It has macros, which is a powerful tool. It has good concurrency support (Haskell has it also). It runs on a good virtual machine implementation (at least technically, but Oracle sucks). You also get Java libraries without most of the pain in Clojure. Scala could also be your choice for that, if the compiler were not slow as a frozen dog. I've done Java programming lately in Yeti, but I cannot suggest it as a language for everything, at least at the moment (I love programming in it, though, as it allows very compact and nice-looking code). Straight Java isn't really my pick for anything, it's overly verbose non-expressive language.
The CPAN equivalent of Perl6 hitting a certain critical mass would make me switch to it, because Perl6 fixes many of the syntax things i'm missing/disliking in Perl.
If Python had a CPAN, I'd switch. It's just so much cleaner to write than Perl, and it's a lot less quirky. That's the thing I like least about Perl: lots of things that seemed reasonable at the time when the language was growing are just annoying to work around now. Java used to be a good choice as well, except for the dependency hell (everyone distributes their app with its own version of the JVM + libraries or it won't work), and the Oracle patent issues don't help.
I switched to Ruby and later to Python. I'm forced to use PHP and C# as well, but I choose Python whenever I can. 
If Oracle 'bought' perl...
&gt; If Python had a CPAN, I'd switch. I have no problem installing new libraries with `easy_install`.
My employer tells me not to use it. That's about the only reason for me to move from it based on what I use Perl for: creating programs quickly. Granted, I haven't used it in some time, but I haven't needed to either. Now, I know that Ruby and Python are supposedly better, however I plan on waiting until Perl6 before I judge as it has some very cool features. My only concern is does it have too much syntactic sugar.
Sure, but is there a central repository with quality indicators (tests/failures, bug tracker, etc.) like CPAN? Also, I *actually* prefer packaged stuff (Debian/Ubuntu :)) because then I don't have to sort out (optional) dependency hell. I just use CPAN to check which packaged modules are "best".
If I work on a project that doesn't boil down to text-processing, I use another language. On the other hand, there aren't many of those projects around. I use python for numerical stuff, and ruby for web dev. Nothing will make me 'move away from the language'- I can't imagine a better text-processing language than perl.
Perl will always have its place. Even if you are a Java/C/C++ developer, you can always find a use for Perl.
Nothing, and No. Alternately: Perl 6 (for both questions)
I program Perl professionally and have for years. I really like it. I may switch to Perl6 eventually; I haven't followed it much, but chromatic's blogs are quite fascinating. I really like Common Lisp, too. I have Lispworks for Linux and think that Quicklisp and *Land of Lisp* may be just what the doctor ordered for Lisp to gain market share. In a sense I've already switched, in that I like Lisp more than Perl, but on the other hand, even after dabbling for years, I still know Perl better and am more effective in it. I'd be happy to use Lisp full-time for everything if I could, but time is limited in an already packed life and it's just hard to make the switch. It's like going from Windows to Mac or iPhone to Droid or Vim to EMACS (or do they spell it "Emacs" these days?) -- there's a lot of inertia in what I already have, which is really quite good, and so there's little incremental benefit.
The job market has completely dried up. I've been mostly unemployed for about 2 years. Before that, I was making close to $200,000 a year working on two perl projects. There are something like 5 or 6 telecommute perl jobs that show up on jobs.perl.org a MONTH, which, for me, means imminent starvation and death. Convince me that perl ain't dead, because I can smell the corpse rotting. Moving on to PHP soon, not looking back.
No problem. It is still WIP, so I would love any comments from you. 
Note, `pip` has pretty much replaced `easy_install` these days. But also note that the [Cheeseshop](http://cheeseshop.python.org) has nowhere near the features of the CPAN. Each package on the CPAN (well, search.cpan.org) has docs for close to every module and also contains links to package-specific discussion forum, bug list, cpanratings page, test reports, and even a dependency graph. The Cheeseshop has a *long* way to go to catch up, and I'm not sure there's even enough interested Python hackers to make it happen. 
I do a lot of work using SAS, but even then I sometimes use Perl to write repetitive SAS code (when a SAS macro is not applicable). I often get data that needs to be munged in some way that SAS is not good at, so I use Perl. If you look at our intranet at work you might think that we use ASP/VB for everything, but some of those ASP pages are written in Perl (IIS/Perlscript), and most of the behind-the-scenes updating is done with Perl. I could do my job without Perl, but not as easily or as quickly. I *could* use Python, I suppose, but as you said, it doesn't seem quite as handy at text-munging as Perl. I have about 10-12 years experience using Perl, and so far I have no reason to stop using it. Yes, I use other languages and other tools: I use whatever helps me get my job done. Perl fills in the gaps between other tools. 
Yes, I still really like Perl a lot, and I especially enjoy hanging out in perl groups. As a language, I do like Javascript just a little better. There just are some warts in Perl that Javascript simply did better, for example nested subs/functions. The worst of all is Perl's memory footprint: a simple script can easily gobble up hundreds of megabytes. Another language I'm currently looking into, is D.
It's not drying up. The telecommute jobs of perl are just moving elsewhere. Try odesk.com if you don't feel like moving yourself to get a job.
&gt; The worst of all is Perl's memory footprint: a simple script can easily gobble up hundreds of megabytes. Can you give an example? I've noticed that Perl can use 200 mb (or more /wild-guess) to store 100 mb of text, but I don't really blame that on Perl, I blame that on me sloppily reading 100 mb of data into memory. What simple script that's not actually processing hundreds of megs of data actually uses hundreds of megs of RAM? Just curious.
If I *had* to...probably Python (for a language in the same class as Perl).
I may resort to PHP to make a living, but Perl will still be my language of choice, and I'll probably at some point subversively convert some PHP project to Perl. 
That doesn't stop you using it on your own stuff ;)
You complain about Perls memory footprint but love Javascript? I enjoy both languages, but I think this reasoning makes little sense to me, Javascript in my experience leaks memory like a stuck pig. V8 uses more memory than Perl: http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=v8&amp;lang2=perl Trace-monkey uses as much as 300x memory of Perl: http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=tracemonkey&amp;lang2=perl ( Now you know why firefox eats so much ram ) 
Were it possible, I'm sure somebody would just upload a fork of it to CPAN. And then I'd use that. Problem solved ;)
Python does not fall into the class of "newer" languages - it's age is similar to Perl.
Perl still is the king, especially with new versions of Perl, new IDE, and new ideas on CPAN. Next year I plan to read the "Modern Perl" book. Mojolicious is new trend in web frameworks, so I'm planning to look at it too.
2010 is the year of Linux on the Desktop. And Perl 6.
Python needs anonymous functions before I really switch...
I don't think a Perl 6 CPAN will hit critical mass until large numbers of users start adopting Perl 6, and as I [noted elsewhere](http://www.reddit.com/r/programming/comments/et20j/perl_6_in_2010/c1asx0e), I don't think many users will adopt Perl 6 until really good perl6docs are available. 
I would rather rip out my finger nails than switch to Python.
OpenPerl v. 1.0
Perl isn't for purely functional peeps. It's for peeps who like getting real stuff done ... in style! ;)
Every now and then I get really envious of Ruby's marketing or the all shiny new things in the JavaScript world or the job market for Java developers which is paradise compared to Perl (here.) Then I seriously consider abandoning Perl - the other communities seem so much more vivid and fast-paced and pretty and seem to offer so much. On the surface, it looks like progress is happening elsewhere. Then I start researching the basic stuff I would actually need. Then I stumble upon this or that CPAN module and compare it to the environments other languages have and they often fall short compared to Perl. Yes, Python has some really nice stuff - I specifically like NLTK for example and the good documentation coming with it. Yes I totally like Ruby in terms of cultivating a very concise, zen-like clean code style (at least parts of the community) and I like that this influence reaches into Perl and other languages as well. Yes, I also like CouchDB and its concept and ideas and writing apps pretty fast directly in JavaScript and serve them. Yes, I envy the enterprise standing Java has. But overall, when it comes to power, flexility and the ENVIRONMENT available - I get back to Perl every time. I also like the level of knowledge in the community - how many times does a PHP developer join #perl, "because you know regex"? Every day someone joins randomly the channel and asks all kinds of stuff - by knowledge, we seem to become the technology information desk of the Internet. ;) Yes, the Perl job market here sucks as well and is more or less dried out - alternatively, you have to deal with decade-old codebases utterly free of any modern Perl which are exactly the Perl nightmare we're notorious for. If companies still use Perl, they keep it pretty quiet - they don't brag about it, they don't market it and that doesn't really make finding Perl jobs any easier. And yet.. the flexibility. CPAN. The amazing creativity how people are milking this decades old pile of code and make it offer something new and shiny and exciting.. I simply can't resist it and it really speaks to me. And it's not that those are academic ivory tower projects noone can really use in his/her daily work - it's supposed to be used for every-day projects and "for us common folks". Also, in my every day work with my every day needs as a developer I plainly have no reason to abandon Perl. Everything is there, it works, there's people actually using it, I can ask for experiences in _very_ large environments and there ACTUALLY WILL BE SOME, I never have to bother with "oh this or that is not supported yet", if module 1 doesn't work, module 2 will, I can bend the language to MY will (I've never felt comfortable with the notion of "one way to do things") and so on. I mean, people are shoving Terabytes and Petabytes of data around with Perl and It Works. Python or Java - I plainly don't get the culture, the architecture, the style, that's just not my playground. I'm not convinced of all this enterprisey thinking and the resulting architecture - that's not where I see the future of programming. And all that is important to me, because I have to live with it at least 8 hours a day, 5 days a week. I also haven't abandoned Perl 6 yet, though I'm really too much of an down-to-earth programmer to fancy all the high-end stuff I don't really understand anyways. I would have been very happy with just a nicer, more modern Perl. So yeah - Perl is still king in my book and I'd rather get the stuff I envy other languages for in Perl then switching to those other languages and wait until they get the bread-and-butter stuff I need and Perl already has - with all the experience on top of it. And set aside my love for Perl, I absolutely think that knowing more than one language is a good thing and makes one a better programmer and a better Perl programmer. 
LibrePerl. 
`lambda` 
Related: http://hop.perl.plover.com/
&gt;Outside of web development Python and Ruby have no answer to CPAN and Python has completely messed up scoping anyway. &gt;None of the minority languages mentioned in my previous post such as Clojure, Scheme and Haskell have gained any traction so there is no need to discuss them further here. That's not even a good troll. 
Jobs are the number one reason I stay with Perl. It's put food on my table since 1999.
There isn't anything "newer" that I would really like to try with the possible exception of "go" from Google. Haskell would be another...or maybe Scheme. What is the "newer" class of languages defined as?
Does Mojo scale as well as Catalyst?
Yeah, awesome book. I have the dead tree version. I picked up this crappy looking Lisp book at B&amp;N and flipped through it. It was a pretty condescending tome - trying to convince the reader that Lisp was God's gift. However what really got me was that they mention all these languages in the context of Lisp yet fail to mention Perl. Python even got a mention. Really - I was like, wtf. 
&gt; Python has completely messed up scoping anyway. In what way is Python scoping messed up? 
Anonymous *expressions* won't cut it...
Tk is easy as hell and Just Works. Highly recommend.
I'm a long time Perl hack and the main reason I use other languages on projects is so that others can work on it too. If I want to rapid prototype, or do things that I know I will be the only one to ever use, Perl it is. I tend to lean towards Java for anything that needs to be mass distributed, but I've recently been leaning towards PHP for web dev. If you've got coworkers that can also code in Perl, there is no real reason to switch.
In Python you can read a variable defined in a containing scope. If you assign to it, a variable is created in the nesting scope, however. In Python 3 you can modify a variable defined in a containing scope by declaring in the nested scope with the *nonlocal* keyword. It isn't clear that this is what the blogger is referring to, but this is the only thing I can think of in Python that isn't how I would prefer it to be. Not sure I would describe this as "completely messed up" though. I think I stronger case could be made that Perl scoping is in a worse state. There is the *use strict* pragma which changes the rules for variable declaration. The *local* keyword is still around and apparently will persist into Perl 6, though it will be renamed *temp*. Also Perl permits modules to export symbols. A library implementer usually can't know what symbols the client might already be using, so this is an opportunity for problems.
I keep having to rewrite stuff in C++ for speed. It's happened enough that I keep leaning to just starting with C++ in the first place.
&gt; In Python you can read a variable defined in a containing scope. As it should be. &gt; If you assign to it, a variable is created in the nesting scope, however. If you make a typo, the wrong variable gets created silently. That's not good. (Oh, but if you just use `pylint`, you might catch this!) The lack of distinction between methods, functions, and variables means that if you make a typo when assigning to a class or instance variable, you might overwrite the wrong thing silently. (I'm not sure `pylint` can catch that.) Python's biggest scoping problem is that it automagically creates variables on assignment, guessing about their intended scoping, without distinguishing between *types* of assignment. &gt; I think I stronger case could be made that Perl scoping is in a worse state. Only if you ignore `strict`. If you do that, you might as well go back to Perl 4. &gt; Also Perl permits modules to export symbols. So does Python, and if you export symbols into your class, you all of a sudden may have methods which aren't really methods, and they're in `dir` and they *look* like methods but don't act like them when you try to call them. Kablammo.
The problem is Perl easily uses up 5 times as much memory as actual data: for 200MB of RAM you need only to use about 30-40MB of data. For example: Padre the text editor uses way more than 100MB of RAM. With no file loaded. 
&gt;You complain about Perls memory footprint but love Javascript? Uh, yeah. I like Javascript as a language, in theory. Memory footprint is a practical concern, and that's on a different level. Memory footprint, together with a slow startup time, might prevent me from choosing Perl for practical concerns. These are the main reasons for me to look at D.
&gt; The local keyword is still around and apparently will persist into Perl 6, though it will be renamed temp How odd. To me "local" doesn't mean "temporary variable", it means "dynamic scope". Any clues as to why the rename?
Curious what you've had to rewrite for speed.
One recent example: There's a simulation that spits out JSON messages, typically producing a few hundred megabytes of JSON data. I wrote a utility to post-process this data. It collates the time-step oriented data around into a big structure/schema and writes to disk. I was using JSON::XS. It was obvious the memory consumption was going to be a problem on some machines, and it was pretty slow. I rewrote in C++ as almost a line for line port with jsoncpp and it was something like 12 times faster and used a fraction of the memory. Code expansion was about 2X, so really not all that bad.
The main problem appears to be that it's not like Perl's convoluted pile of dogshit. Here's Perl's vaunted scoping in action: use strict; my $x = 1; sub test(){ $x += 1; # Look ma, I can see $x! } test(); print "X: $x\n"; # 2...weeeeee!!!!!! Fucking. Crap.
The precise programming language term for that is *closure*.
&gt; Python's biggest scoping problem is that it automagically creates variables on assignment, guessing about their intended scoping, without distinguishing between types of assignment. Variable scope is orthogonal in my mind to variable type. Python has only one variable type which has advantages (no references in Python). Perl has at least 4 variable types but because of automatic conversions very little type safety. Assigning a function or method value to a variable you intend to contain some other type is not a big problem in practice. This is less of a problem than calling functions or methods with an incorrect number of arguments, a problem that Python will catch and Perl won't. &gt; So does Python, and if you export symbols into your class, you all of a sudden may have methods which aren't really methods, and they're in dir and they look like methods but don't act like them when you try to call them. Kablammo. In Python the client can import all the symbols in a module, but the client knows his own code and can inspect the module, so this seems safer than writing a module which automatically exports symbols, something which can be done in Perl but not Python. The key is that the client should make the decision, not the module implementer. In addition to being able to store functions and methods in variables, Python also permit storage of modules in variables. I don't tend to give functions or methods the same names as other data, but I have been irritated by not being able to use a variable name because I was already using a module with the same name.
&gt; Any clues as to why the rename? *local* means lexically scoped to a lot of people outside the Perl community. Some rationale can be found here: http://dev.perl.org/perl6/rfc/19.html
Making sure I understand: The creation of the JSON itself was the bottleneck?
&gt; Variable scope is orthogonal in my mind to variable type. Sure, but if you build an object system around "Everything is just a slot in a dict", you have to be aware of both scope and type. &gt; Assigning a function or method value to a variable you intend to contain some other type is not a big problem in practice. The type safety folks might (okay, will) disagree -- especially if it pollutes your namespace. &gt; Perl has at least 4 variable types but because of automatic conversions very little type safety. Perl has operator typing, not variable or value typing. Any discussion of Perl and type safety has to take that into account. When conversions are explicit (because of typed operators), it's hard to argue that conversions are implicit. &gt; The key is that the client should make the decision, not the module implementer. I agree; explicit exports are almost always a code smell. Even so, the fact that Python's object system is so fragile that you can break it with careless importing is not a good sign.
Why should I read books? I read all day, and nothing out there applies so much to my job as my job-related reading. Why should I exercise? I move around enough already every day, and I'm certainly not overweight. Why should I learn math? I do plenty of computing every day, and I don't see any need to learn a bunch of math that has nothing to do with what I work on. *et cetera* You learn and use other languages in order to expand how you think about problems. Creativity is more interesting given a set of constraints, and using a new language gives you a new set of constraints. It's interesting to try to attack a problem in Erlang (or Prolog) to learn programming by pattern matching, or Haskell for currying, or f77 for lack of recursion, or Forth for rpn, or ... tldr: exercise your mind
It was everything, actually. JSON:XS is way slower than jsoncpp, and also building up structures in hashes is way slower than Qt's QMap used in basically the same way.
That's a desirable and powerful behavior. Any language _without_ that behavior is hamstrung.
I used to think that way, but after spending several years of spare time learning myriad languages I'm a little envious of the people who spent it in one language actually building something worthwhile. Knowledge is a seductive thing, but it's only useful if used.
Everything in moderation. In my 25 years as a programmer, I've used and been paid for using several languages, though primarily C &amp; perl. During that time I've taken small excursions into other languages, just for a bit of fun. It's good to take some trips into unknown programming territory, just as it's good to take trips to places you've never been. You gain perspective, and you might just have some fun.
The real question is: Could you have prototyped it this fast working in plain C++ too?
If you voluntarily switch to PHP to work with other people then you need to get to know new people. :/
How is Scheme "new" in context other than compared to stuff like "PL/1" and "COBOL" ? Unless 1975 called? https://secure.wikimedia.org/wikipedia/en/wiki/Scheme_%28programming_language%29
Submitting this separately from the blog entry mentioning it because it needs more exposure. The about page has a detailed explanation as to what you're looking at.
For some strange reason, the "appropriate amount of fun" line gets me every time, and I literally laugh out loud. 
I would like to disagree with friend o0o below, I have read the book and I don't consider it to be a good book. Every language has some limits for expressing various concepts. Most functional paradigms in the book feel like they are stretched beyond the limit that Perl can express and therefore they seem really completely out-of-context, Perl is not a language in which one can express those properly. I would recommend anyone who wants to learn functional programming to stay as far away as possible from Perl or that book. Take any example in the book and compare it with its equivalent in Haskell or LISP, you will come to the conclusion that Perl was not made for this kind of thing.
Considering all the hidden variables, all the hidden behaviour, all the arcane and deprecated(but still in use!) functions, the C compiler code that is really arcane, the really cumbersome way in which you can extend Perl through XS modules, I think writing Perl today is really really dangerous. As with any aging technology people are moving away from it, but this is really not news to anyone, it started somewhere in 2001-2002. I write Perl but I'm really careful, I would not recommend anyone use it, for serious stuff I use C or Python, at least there I know what to expect. In the tragic event that you do use it, I recommend you only write one-liners or 1-page scripts. Knowing Perl will sooner or later converge your path to dealing with some small company which usually has no idea what they're doing and so you'll get into trouble quite fast, so avoid Perl as much as possible, and try to restrict its usage the same way you would put a leash on a dog's neck(try to strangle him a bit but not as tight as to asphyxiate).
&gt; Java developers which is paradise compared to Perl (here.) Then I seriously consider abandoning Perl - &gt;Yes, the Perl job market here sucks as well and is more or less dried out - alternatively, you have to deal with decade-old codebases utterly free of any modern Perl which are exactly the Perl nightmare we're notorious for. I second that
&gt; The job market has completely dried up. Yes, for Perl this is 100% true.
 "it started somewhere in 2001-2002." Perl looks *nothing* like it did in 2002, and your whole tirade about it being "Really dangerous" merely conveys you don't understand it. Also, if people are "moving away from it", why did last year hearld the greatest year of new contributions to CPAN of ALL TIME almost **doubling** last years effort. This "Perl is dead" meme is getting boring. http://cpants.perl.org/static/dists_released_per_year.png I can say one thing though, and that's "If you don't know what you're doing, you shouldn't be using Perl ( at least, not yet )" . But that rule is pretty much assumed about programming, and if you haven't learnt that "You shouldn't do something until you know what you're doing" then you should realise that you don't understand IT and shouldn't be in it.
CPAN contribution vs. job market -&gt; job market WINS. about understanding IT ... you're generalizing with bad intentions, and I was talking just about Perl.
&gt; There are many developers that subscribe to the idea of learning/using multiple languages because it makes you a better programmer. The **better programmer** is kind of bs. The truth is: nothing can prepare you(except continuous learning) for what happens when some piece of technology you know plummets(in the case of Perl, it also depends on where you're located, for example the job market for Perl is still "OK" in US or UK). 
But you use CPAN to do your job ... and the job market must exist because its fuelling CPAN releases. Its a synergy. Businesses ( and marketers ) love that synergy thing!. No bad intentions, I just got the impression that: 1. You're not up-to-date on Perl 2. That your trolling, in a seemingly uninformed manner. 3. Despite claiming to "Write Perl", you seem to be at a disconnect with the community, and the community is really the *best* thing about Perl. If you don't understand the value the community brings you are in my estimation, *seriously* missing out. The community: 1. Discovers new standards, new ways of doing things that suck less than the way we were previously doing them. 2. Helps you produce code that doesn't suck by recommending modules that are known to be useful, and critiquing your efforts when necessary. 3. Provides a wealth of information on all sorts of various things that I could never hope to work out how to stumble into by reading thousands of books generalising the subject. 4. Makes your published code not suck, by testing it, reporting bugs, even reporting suggested features, and often, they'll fork your Github project, apply the patches, that make it work, and then send you a pull request. From a "work" perspective, would I rather have employees with a massive volume of assistance at their disposal? Or would I rather employees who, like many PHP shops, flail around doing everything themselves with Not Invented Here Syndrome, and then reinvent everything ever invented except with all the bugs still lurking in the code, with very little community direction to put them on the right path? 
The assumptions you make couldn't be more wrong. The synergy you talk about doesn't reflect itself in the job market(see replies from others on this thread) so I don't see how you can consider it valid, I mean open your eyes man, look at some job sites... it's like ... right in front of you. You tell me about synergy, I tell you about reality ! Community you say ? .. ok, there is a community that produces modules around some of the little puddles of projects that are still alive. Is that a community ? Well.. ok, I'll give you that, let's say it's a community, look it even has a reddit :) btw, I'm well aware of this ... let's say .. uh .. pff community... As a person who got constantly hired for part-time full-time projects on Perl and other stuff I know how stuff goes and let me tell you, Perl-city is going bye-bye. So as I see it there are 2 ways to react: * be completely surprised when the carpet will be pulled from beneath your two feet * adapt
Perl 7. No seriously, for me, language is (in part) about community and stability. I love to try other languages but I use mostly Perl for pragmatic reasons. That's why I use Linux -- there's no benefit to getting something "newer than Linux" when one uses Linux because of the stability, community, drivers, etc.
By elsewhere, you mean "overseas" ... Indeed. This has completely fucked me. Can't compete with indian slaves willing to work for 15 cents an hour. 
Why would I move away from it? I'm in Perl-vana!
Its kinda funny how things are with me really, I've only gotten into Perl in the last few years, and I don't care there's not much in the way of a *visible* job market immediately around where I live. Go back 4 years and there wasn't even a PHP market around where I live, everyone was a Java Shop, or a Microsoft Shop, and I don't have the patience or the motivation to Put up with working in those languages. I **was** a PHP programmer, but I've ditched it for the most part, because I came to the realisation that the tools I was using were horribly crude for the job. Sure, "a bad programmer blames his tools", but what doctor wouldn't rather run a medical surgery with a scalpel than run a medical surgery with a butter-knife and an axe? There are plenty of PHP jobs around, plenty of Java and Microsoft Jobs around, but I'm not even slightly interested in those, because there's more to "Work" than "Paying" for me. An "Adapter" would be willing to work in any language and not want to encourage progress. Times change, job markets shift, new software and techniques surface, and all you need is the right people and the right focus and emergent technologies can come to dominate. And the way I see it, Perl is experiencing a bit of a Renaissance , more in terms of *modern* perl, and to me, that's good enough to be an "Emerging" technology. 
15c an hour Indian slaves are worth every cent. I take great comfort in this. If somebody wants poor quality cheap code that looks like it got lost behind a filing cabinet back in the early 1990's, instead of something that is modern and well designed, they deserve what they get ;)
Drivers? What are they again?
&gt; And the way I see it, Perl is experiencing a bit of a Renaissance , more in terms of modern perl, and to me, that's good enough to be an "Emerging" technology. there's really no Renaissance. let me explain: if you have a bunch of people who write some Perl and they come to some Perl conference(perhaps YAPC) and they say "HEY GATHER'ROUND ! PERL IS EXPERIENCING A HUGE RENAISSANCE ! Now you can use these functions with more parameters, and now we put strictures in your compiler so you don't have to ! Now we wrote this thing called Moose which is now 1.0 and woohoo we will convince you to use it because omg it's so awesome(actually the only way). And omfg, I am such a huge Perl guru and I have my company and let me tell you all my secrets about how I use *Perl* in *my* company and I'm the best there is because I am a strong Perl user." This got your jaw dropped ? The fact that there are some small Perl companies that have clients who don't care what technolgies they're using and so they have contracts with them ? That won't last long. Eventually their companies will disappear and with their small companies Perl will be completely forgotten. If you have a language, and it's just one implementation, and it has no standard and the job market is falling down and et cetera et cetera et cetera there is no way in hell anything can save this ! There are 3-4 big companies out there using Perl. There are many little companies which will disappear. And let me tell you another thing, you know what happens when a technology gets less and less used ? Well, there aren't as much people knowing it, but big companies always need new programmers and because those new programmers will not know Perl anymore the company will start porting their code to some newer technology and gradually they replace all the old code and they throw it the f*ck away like a rotten tooth. Perl is just like COBOL and oh my how many programmers are out there right now converting COBOL into some other newer language ? A LOT ! I still use Perl, but I use it just for extremely small stuff because it's not a technology worth investing time in.
Herp derp. No. I meant to other sites on the internet. I'm german and i got well-paying remote jobs in the usa, uk, ireland, france (this one was even a bio-eng project) via a freelancer site; all while living at a beach. Then again, i fully deliver on the rate i charge and leave my customers happy and wanting more of my time.
1. I don't think we need the whole(albeit small) subreddit working on that problem, just by your comments I'm sure you can come up with something way better. **be bold** and do it, think wikipedia. 2. sure there's always more, I "fixed" some myself sometime ago, although I'm more into the Perl 6 problems now.
You could simply start by going through this list: http://rosettacode.org/wiki/Category:Perl And adding all things that need a reworking to this page: http://rosettacode.org/wiki/Category:Perl_examples_needing_attention Interesting would also be this: http://rosettacode.org/wiki/Reports:Tasks_not_implemented_in_Perl
I'm not sure I'm following you - it's nice and legal Perl application. It looks more clean than recent "modern" modules on CPAN. And I'm sure it works as expected. 
Ever heard of strict?
Programming is about solving problems, not worrying about codexes and regulations. In the Perl world there's one rule only - the perl interpreter. Everything else is just some guy on the internet angry at others not coding the way he thinks is the best. Rosetta code is a wiki. Edit at your will. 
Programming is about creating tools. In most cases with programming that means tools that will need to be used and maintained by other people as well. Either way, your argument was that the code is clean, but really, you just confuse clean with minimalist.
Rosetta Code is not about solving the problem, it's about solving problems using the idioms of a given language so that people unfamiliar with that language can see what it looks like and how things are properly done in that language. When an example on Rosetta Code doesn't follow the best practices of that language, it's not helping anybody because it's not a true representation of how that language is to be used. It would be like having one of those foreign language travel guides where they list common phrases (e.g. "Where's the bathroom?", "How much is this?") in the local dialect with pronunciation guides, but instead of getting a native speaker to write it they hired somebody that had only taken a semester of the language in college and had never been to that place. The result would be unidiomatic and downright incorrect, and would not be very helpful for someone trying to communicate while traveling. 
That's not the term I would choose. No wonder Perl's scoping rules are so fucked up.
&gt; That's not the term I would choose. May I recommend the book [The Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html)?
I don't see how I could take advantage from advices given by someone who doesn't have a track record as a hardcore C programmer who turned to Perl later on. I mean, writing books on Perl doesn't give you there experience nor does it give you the mindset,view to make a comparison between C and Perl. Instead of writing so many articles and books show me your C code and then I'll read your books. That way I can judge who you are and if it's worth reading what you write, because you write so many words and so little code that I'm nearly convinced you don't know what you're talking about. Programmers write code dude.
I won't try to speak for him, but i can tell you what i do: I read what he writes, think about it on my own and then decide whether i disagree or agree. Both has been the case in the past.
What exactly are you arguing here? I really am trying to figure out just what the hell your argument *is*. 
&gt; Programmers write code dude. I guess you're not familiar with the [author](http://en.wikipedia.org/wiki/Chromatic_%28programmer%29). He writes code. That doesn't mean you have to read his books or agree with what he says. But do your research before you dismiss someone's opinion as irrelevant. &gt; show me your C code and then I'll read your books. The article wasn't about C and he writes books about Perl, not C. In fact, he only mentioned C in passing as an example of a language that doesn't give you much at all. The article was about minimalism in language design, using Perl as an example of a language that implements the bare minimum required to implement OO features. 
His final comment is interesting. If I'm reading it right, he is suggesting that the many Class::* modules on CPAN are evidence that a minimalist OO framework is not sufficient for practical needs. That is perhaps true. But for me, the real genius of Perl's OO system is precisely the fact that it allows "many flowers to blossom" in true TMTOWTDI fashion. If Perl's OO had come with batteries included then we would never have ended up with Moose.
`DIR` overwrites itself every time through the loop. Replace `DIR` with `my $dh` and it will recurse properly.
thanks!! worked!
Perl likes recursion just fine. A couple of notes: * First, use File::Find. It's in the standard library. But if you insist on doing it manually (perhaps this is a learning exercise?) * Use File::Spec-&gt;catfile, this will work on any platform (it looks like you're on windows, which may be the source of your problem - its path separators are different). * Use lexical filehandles, e.g. opendir (my $dir, ...). You don't have to explicitly close them (they'll close when they go out of scope), and you don't run into global scope issues. * use the 3-argument form of open(), it's safer. See perldoc -f open. * I haven't tried the following code, but looking at the differences should get you going in the right direction. use File::Spec; sub check_directory { my ($path) = @_; print "$directory\n\n"; my $find = '&lt;!--webbot bot="Timestamp"'; opendir(my $dir, $path) or die $!; print "Checking $path... \n" while (my $entry = readdir($dir)) { next if $entry eq '.' || $entry eq '..'; $entry = File::Spec-&gt;catfile($path, $entry); my $line_num = 0; if (-f $entry) { next unless $entry =~ /\.html$/; open (my $file, $entry, '&lt;') or die $!; while ($line = &lt;$file&gt;) { $line_num += 1; if ($line =~ /$find/) { print "entry at line: $lineNum\n"; } } } elsif (-d $entry) { check_directory($entry); } } } check_directory('D:\Public\ssnds') 
&gt; That is perhaps true. It's difficult to argue the opposite. &gt; If Perl's OO had come with batteries included then we would never have ended up with Moose. That's also true. Consider this, though: what percentage of *all* Perl 5 programmers know about Moose? What percentage use Moose? What percentage don't even know about `Class::*`? Moose is very good (and Moose in no way precludes further experimentation), but Perl 6 includes Moose (in one sense) for very good reasons and, by intent, also in no way precludes further experimentation.
&gt; ... someone who doesn't have a track record as a hardcore C programmer who turned to Perl later on. Why does the order in which someone learned C and Perl have any bearing on the truth, falsehood, utility, or entertainment value of anything he or she writes? &gt; ... writing books on Perl doesn't give you there experience nor does it give you the mindset,view to make a comparison between C and Perl. Who claims otherwise? *Of course* it didn't give me the experience. Writing object systems in multiple languages did.
You might also want to replace: open (CURFILE, "&lt;$toOpen") or die print $!; with: open my $handle, '&lt;', $toOpen or die $!; And then user $handle instead of CURFILE. You're also constructing the file path with unix and windows styles: if (-f "$directory/$file") CheckDirectory("$directory\\$file"); Make up your mind or use File::Spec::Functions! ;) A few minor tweaks/remarks: 1) Perl's building the regexp to match at each line because you're using a string. You might want to declare your pattern like this: my $find = qr/&lt;!--webbot bot="Timestamp"/; # Build the regexp once Ideally you will even declare this variable outside the function like that the pattern will be built only once. 2) Can the webbot string be in more then once per file? If not then add a "last" statement after your print function otherwise the program is still reading the file for nothing. 3) Perl has a builtin line counter per file handle. You can use $. to get the line number. So you can get rid of $lineNum completely. 
Jobs are the number one reason I am trying to move away from Perl. Any time I am looking for work, putting Perl in the search terms reduces the results to zero or near zero.
I just keep my resume on the web and let jobs find me. When I get unsolicited headhunter emails, I tag them for a rainy day.
I've never had Perl jobs find me that way, but plenty of jobs for other languages have.
Totally agree. One of the biggest problem I find with CPAN modules is lack of consistency. Because there is more than one way to do it, everyone has their own idea of which is the right way to do it. Writing a Perl app using off-the-shelf CPAN modules is often an arduous process of fitting together a half dozen different API styles with varying naming conventions, error handling mechanisms, configuration options, and so on. With the benefit of hindsight, it would have been better if Perl 5 had provided a default higher-level OO implementation on top of the existing mechanism. So I think Perl6 is absolutely correct in providing Moose by default, but not precluding other approaches. &gt; Consider this, though: what percentage of all Perl 5 programmers know about Moose? What percentage use Moose? What percentage don't even know about Class::*? My feeling is that Perl 5 programmers fall into 2 broad categories. There are those that are happy to just use the language as it is and don't care too much about what is happening on CPAN. They're Perl programmers (or more likely, sysadmin types who just happen to program in Perl, among other languages) but don't consider themselves part of the Perl community. They may know about CPAN and write scripts that use CPAN modules all the time, but they're not really using Perl in the kind of way that requires an advanced object model, or indeed any kind of object model at all. Put simply: if you're not *writing* OO modules, then you don't have any of the problems that Moose, Class::\*, etc., solve (although you may still benefit from *using* the OO modules that other people have written, of course). All the others (including you, me and everyone else reading this) are the ones that do take an interest in the wider Perl ecosystem. Of those, I imagine the vast majority know about Moose, Class::*, etc., and probably use them often (or have good reasons for not using them). 
lol
I'm arguing that you need to know stuff in order to write it. If you don't know what you're talking about you're ending up like chromatic, writing novels instead of technical stuff, and who wants to read novels on a /r/perl on reddit ? Chromatic would have more success writing some sci-fi book.
... I swear you're just permanently high or something. This still makes approximately no sense.
Look at his posting history. He's a troll.
I think several things have made perl cool again. * Moose * Catalyst * improved release cycle for perl5 * perl6 released and it's release cycle * The Modern Perl Movement * Ironman Perl
Speaking as someone who has just recently gotten into Perl from the web / python / erlang, I have heard of almost none of these things. I think I saw Moose and Catalyst mentioned on reddit.. maybe? If you want Perl to have a larger following (and that's a big IF), there's a lot of truth in this blog post.
tl;dr = &gt; So, the lesson I learned in 2010: Becoming the new it-girl err editor/tools/language has absolutely nothing to do with how you look like today - it's all about how you present yourself. So, yeah. Throw together sexy podcasts about how to make a reddit clone in 5 minutes with 10 lines of perl and you'll have something. Having done some Ruby, a smidge of PHP, and just a little Perl, I'd have to say I'd rather have an excuse to use Perl when choosing between those.
You should have no trouble finding code I've written, if you look--but again, that has no bearing on the truth or falsehood of anything I've written. Test for yourself.
Better link: http://www.robobunny.com/projects/asciiquarium/html/
&gt; my $find = qr/&lt;!--webbot bot="Timestamp"/; # Build the regexp once I'm not sure that the comment is quite accurate. From [perlop](http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators) (emphasis mine): &gt; Since Perl *may* compile the pattern at the moment of execution of `qr()` operator …. Since `qr//` still supports the `/o` modifier, and the documentation doesn't mark it as deprecated, it's probably necessary to use it to *ensure* the desired behaviour. Then, once you're modifying anyway, there's no need to stuff the regex into a variable (though obviously no harm in it); `$line =~ /$find/o` would work just as well.
The reason I didn't use the direct link to the project is it doesn't list the dependencies for the script, so you have to untar it and actually read the README before installing.
You are mistaken. It does not suck, it only blows.
This looks like a neat tool. Downloading...
You're dick must be to tiny for Perl, it sucks mine good.
Perl has this slurp method, it sucks.
A bit late in my reply here, but which new IDE are you referring to specifically?
I think a "problem" with Perl is that it is so flexible, TMTOWTDI. We've got some old mainframe programmers trying to learn Perl where I work. They don't write Perl, they write COBOL using Perl. When I started using Perl I wrote C using Perl. It was nice that I could jump right into Perl and start using it with my existing knowledge, but it can make for some ugly code. A language that is more strict forces developers to use it the way it was intended. 
So the question then becomes, should you pick a language that's strict and doesn't let those old COBOL programmer become productive quicker or do you pick a language that makes them have to study harder to use and need more time before they can produce something useful? I'd say that Perl actually strikes a good balance between the 2 and let's them be productive earlier while at the same time providing lots of tools (Perl::Critic, perltidy, etc) to help them mature over time.
&gt; A language that is more strict forces developers to use it the way it was intended. ... if they make it past that point. If not, too bad?
What do you want to do? Perl 6 doesn't have access to the entirety of the CPAN and its extension mechanism is less fully developed than that of Perl 5. If you're looking for a replacement for bash for small programs and system automation, either is a fine choice. Perl 6 has some advantages in its built in features, but Perl 5 has the advantage of a larger core library and ubiquity.
Are its design and fundamentals better? And how long until Perl 6's module library catches up to Perl 5's in size?
&gt; Are its design and fundamentals better? I believe so, but I have a bias. &gt; [How] long until Perl 6's module library catches up to Perl 5's in size? Years, though keep a few things in mind: * Several CPAN modules are unnecessary because they provide core features of Perl 6. * You can already use some Perl 5 modules within Rakudo Perl 6 and other implementations. * It's more important to have the *right* modules than every module.
&gt; Give me such a candidate and I'll declare him or her a great programmer. Me too. &gt; But Perl's strength is that people can *get the job done quickly* with Perl. I can't agree that this is a problem. One important difference between a novice and an adept is whether the programmer can get the job done quickly without making a mess.
In my country you cannot hire Perl programmers at all - whether they're good or bad. Perl is silently going into an oblivion in this part of Europe. OTOH, I read none of the books you specify, so I suppose I would fail if we ever meet in an interview :) 
&gt; A language that is more strict forces developers to use it the way it was intended. That's true, but one also needs to see the flip side of the coin: What if that way is bad, but that's only discovered years later? If the language is too strict this means things are unfixable. If a language is suitably flexible it allows the community to perform a discovery process and fix things that went wrong in the language's inception.
Peer review is not a magic bullet. You need the whole shebang: Perl::Tidy, ::Critic, automated tests, availability and use of recent perl modules, even the choice of VCS has an impact, since committing via git-gui basically forces you to review your own before it goes out. And for the extra mile, if you don't release your stuff to CPAN, at least maintain an internal cpan server, so your devs have a reason to write good POD docs and can use things like Dist::Zilla to help improve quality of their code.
I think the question you need to ask yourself is: Do i want to achieve things right now, or prepare to be programming with this language in a job in maybe 5-6 years earliest? Both languages are great and useful to learn, but only you can know what you want out of them.
Because they already have jobs.
The main problem with TMTOWTDI as I see it, is that it's not a solid engineering mindset. Sure TMTOWTDI, now how do I know which of those ways is 'best' in a given situation? TMTOWTDI is not an engineering mindset; it's a linguistic one, as Larry himself has proudly stated. It's my unsubstantiated opinion that the body of developers out there encompasses far more of the engineering mindset and therefore, TMTOWTDI (and by extension Perl) does not appeal to them.
&gt; how do I know which of those ways is 'best' So you'd settle for not having to think about that, in return for having a single way mandated, even though it might be sub-optimal or outright bad? Also, Perl is applying the engineering mindset to TMTOWTDI by creating a massive quality assurance and testing infrastructure. No other language actually bothers to measure (which is the core of engineering) things about their libraries, so i find it hard to agree with your assessment that other languages are more in the engineering mindset.
As I see it there are three separate things you need to learn to write a web application in a scripting language. 1. The basics of the given scripting language. This is not web-specific, and you can use any book on the language to learn it, such as the free [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) or any of the O'Reilly series. 2. How web applications work. This is really not language-specific. You have to know the same concepts regardless of the language -- difference between POST/GET, form handling, cookies, sessions, security issues, templating, MVC model, databases/SQL, etc. There are a ton of books on writing database-backed web apps and most of the concepts that you'll read in any of them will be universally applicable. 3. The specific API of the scripting language &lt;-&gt; web server interface (i.e., mod_perl, FastCGI, WSGI, CGI) or the API of the framework (e.g. Catalyst, Struts, Rails). These are best learned from the documentation of the given API that you want to use, e.g. [CGI.pm](http://search.cpan.org/perldoc?CGI) or [mod_perl](http://perl.apache.org/docs/index.html).
Seconding Modern Perl. Start by reading that.
Sure, but fewer people would have read an article with the title "How to Make More Great Perl Programmers".
http://mojolicious.org/ , very good modern Perl web framework. the website has decent docs and examples.
Perl 6 it is, then. Thank you.
This is more about culture and mindset than about what the tools allow or even make easy. Perl does have some excellent actual engineering around the tools and documentation, but because TMTOWTDI gets so much play time in relation to the other things Perl has to offer, it scares off would Perl developers who do have an engineering mindset. So, for example, does Python really offer anything Perl doesn't, or didn't offer first? Not really. So, why are there 3x as many /r/Python subscribers? Because TMTOWTDI isn't a part of Python culture and the resulting language is much easier to understand. &gt; No other language actually bothers to measure (which is the core of engineering) things about their libraries Really? This statement is demonstrably false if you look at the plethora of tools available for code metrics, documentation generation, performance analysis, etc. for any number of popular programming languages besides Perl, including Java, C#, and others. Anyway, my original intent was to agree with kc7wbq and build on that point. There's a lot to love about Perl, but I kinda hope TMTOWTDI gets left behind as things go on.
&gt; So, why are there 3x as many /r/Python subscribers? Why are there fewer Perl projects on Freshmeat than CPAN? Why are there fewer Perl questions on StackOverflow than PerlMonks? Avoid the trap of thinking there's a simple, single explanation for any of these questions. &gt; This statement is demonstrably false.... Show me a project like CPAN Testers for any other language.
I also recommend Modern Perl, also you may want to check out [CGI Programming with Perl](http://oreilly.com/catalog/9781565924192/)
http://www.catalystframework.org/
These days directly programming for the "CGI" interface is not recommended. Its recommended to program for the "PSGI" interface which has a plethora of backends, one of which is CGI, but also FastCGI and mod_perl . This means you're not really writing for a specific interface anymore, you're just writing for PSGI, and it will be portable and work everywhere PSGI does. * Wikipedia: https://secure.wikimedia.org/wikipedia/en/wiki/PSGI * PSGI/Plack's Webpage: http://plackperl.org/ * PSGI Specification: http://search.cpan.org/~miyagawa/PSGI-1.03/PSGI.pod * FAQ: http://search.cpan.org/~miyagawa/PSGI-1.03/PSGI/FAQ.pod This is extra handy for development too, because there are standalone PSGI webservers that will let you instantaneously throw up a working webserver for your PSGI application, much akin to rubys "rubrik" for rails apps. Except some are way way faster, such as Starman ( http://search.cpan.org/dist/Starman/ ) which kicks some serious ****ing ass. 
**Test vs Peer Review: ** * Humans are prone to oversight. * Peer review gives you the assurance that more than 1 people have read it, looked at it, and said "yeah, that should work". * This increased view by peers hopefully reduces as a product of more people having more experience in more fields thusly hopefully reducing the oversight surface area. * However, more people thinking something should work doesn't mean it *will* work, nor will it give you the assurance what works now will work 6 months from now when something obscure changes. * Tests as part of the project code give you assurance that all the sum of your assumptions provide expected results, not by guessing and rationalising it, but by actually executing it, which can easily reveal oversights nobody predicted. * 6 months from now when that obscure thing changes, these tests will start failing alerting you to the problem, whereas nobody will have re-reviewed that old code that didn't change where the breakage appeared. 
i got the yellow book. its pretty good. Catalyst is an awesome mvc, I wish i learned it years ago. My current projects at work are stuck in a PHP which is probably horrible programming. haha.
What everyone else said. Read **[Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html)**, and maybe **[Beginning Perl](http://www.perl.org/books/beginning-perl/)**. Also: **CGI**: What you use when it's 1990. **mod_perl**: What you use when you need to change the way Apache works. **FastCGI**: What you use for web applications.
There are [any number of tools](http://en.wikipedia.org/wiki/Continuous_integration) that can run automated unit testing, upon check-in or otherwise, for a number of languages and there are many thousands of active installations of those tools. At any rate, my points stand, and the issue is not about Perl's capabilities. In my mind the issue with TMTOWTDI is how it affects Perl's development and the perception of the culture around the Perl ecosystem.
&gt; There are any number of tools that can run automated unit testing, upon check-in or otherwise, for a number of languages and there are many thousands of active installations of those tools. That's nice, I suppose, but it hardly takes advantage of Metcalfe's law the way the CPAN ecosystem does. &gt; the issue is not about Perl's capabilities It would be if we could have an honest discussion about them which didn't devolve into touchy-feely irrelevancies.
&gt; Really? This statement is demonstrably false I am afraid it is not. Let me try to explain in more detail: You asked the question "for any given problem, how do i identify the best perl solution?" and then mentioned a lack of engineering mentality in the perl community. I'll assume now that you mean "which cpan module is the best to use?" Now, engineering is the art of applying scientific knowledge to create things. Perl by default is about building things, so that part is covered. Now how do we get to the application of scientific knowledge? Computer science is a relatively new field in human development. So we don't have a big wealth of information to draw on when making decisions. As such, we have to build up our own information store upon which to make decisions. This is done by collecting information, so as to enable the objective comparison of different base units used for building things. This is what the Perl ecosystem offers you. If you're looking for cross-platform compatibility, cpantesters will tell you. If you're looking for modules that emphasize stable releases, it will do that too. If you're looking for speed of the developer in fixing problems, it will do that too. Now you may have other metrics too, like the number of open problems, which is where cpan's RT comes in. Or the number, depth and type of dependencies, which deps.cpantesters.org provides. All these serve to provide exactly that which is the base of any kind of engineering: Measuring of comparable properties of tools and materials to use in building processes. And while you're right, many other languages have tools to measure properties of their libraries, they entirely lack the ecosystem to compare them on a large scale between each other on an objective basis. And this is why i'd argue that Perl actually has more of an engineering spirit than most other languages. &gt; why are there 3x as many /r/Python subscribers? Because Perlers built their own communities, quite simply. Perlmonks, one of the first hints when googling "perl forum" has 880_000 posts. The most significant google hit for "python forum" has 100_000. And it is written in PHP.
&gt;The problem is there aren't any recent books written over Perl web development. Most of it (if not all) covers Ruby or Python. And for good reason, as others have explained already.
On a sidenote, if you have any beefs with the current release of this, please don't hesitate to voice that. I'm concentrating mostly on improving this module, at the moment.
Well, I don't think we're have a **dis**honest conversation, here do you? What I am trying to get across is that those "touchy-feeling irrelevancies" aren't actually irrelevant.
Are there usable implementations of FastCGI now? When I last looked into it in 2006, it was a horrible mess of code rot and disuse.
I only responded to your statement "No other language actually bothers to measure (which is the core of engineering) things about their libraries", and that was simply false. Do other languages compare them on a "large scale between each other on an objective basis", frankly it doesn't matter to my point. Some can.. most can't. There may be more of an engineering spirit in these projects than elsewhere, but keeping TMTOWTDI as a part of the culture still isn't going to increase the overall pool of 'great Perl programmers'. That's just my 2 cents, and you can't engineer that problem out of existence. It's a social problem.
&gt; Well, I don't think we're have a dishonest conversation, here do you? Me: The entire CPAN ecosystem of 21,000+ distributions has a distributed service of testers across a matrix of operating systems, configurations, platforms, and versions which produces over a million test reports a month and which integrates with search.cpan.org. You: Any other language could have many, many users who set up Hudson to run tests too. What's the big deal? I agree that Ruby or Python or Lua or Factor or ECMAScript or any other language community *could* build an equivalent of the CPAN ecosystem. *When* they do, I'll respect the engineering culture of their languages more than I do now. I don't mean to sound condescending, and I welcome other languages building such things, but there's a huge difference between the ad hoc coordination of testing (and local monkeypatching) and a culture which *encourages* centralized automated testing and portability and correctness.
Thank you everyone for the suggestions. I figured I was looking in the wrong place when there's nothing new covering CGI alone. I'm familiar with Perl, just not this aspect. But I am going to work through Beginning Perl and Modern Perl to get better at it. 
Or if you just want to stay old school: perldoc CGI
http://www.archive.org/ancient_practices/badideas.htm
Avoid any books about web programming that are,say,4 years old or older(it's not the perl in there that is bad per se, but html,javascript,css that is already too old) and if you do this, indeed,the only book would be the one you mention(helas, it uses mysql but why not...) and certainly the apress book about Catalyst (even though the new Catalyst is out and it might already be outdated) The other books mentioned do not relate to web programming per se and if you already know perl,if always a good read, not what you are looking for right now. Using Catalyst or Mojolicious would require you to learn a full web framework but it is certainly the easiest way to build something solid in perl. 
I feel very sorry to read that in order to have the base to be a good perl programmer, you should have read: "Perl Best Practices, Effective Perl Programming, or my own Modern Perl" I have only read: Learning perl Programming perl Intermediate perl Perl Cookbook Advanced Perl Programming Mastering Perl Mastering Algorithm with Perl Higher Order Perl Perl Testing Perl Hacks Perl Best Practices It's a shame that on 3 books the author mention one is his... Oh, yeah, of course, he had to make a choice. sure. But if he had time to write such a long article, picking up more books or at least pointing to a reference website should not have been too much. On the other hand, I will certainly read these one too. Although I have read many books, I still get surprised at all the many things I still discover and how bad i am^^; As for using "Modern Perl Tools": Perl::Critic Test::More Moose Even if there is a vibrant wave for Moose in the perl community right now,I still don't jump into the moose bandwagon. Perhaps because I like to write perl. or perhaps because I will switch to perl6 instead. Perl::Critic and Perl::Tidy combined into Eclipse are real helpers, I can not deny this! &gt;Participate in groups such as Perl Mongers, PerlMonks, and YAPCs I don't. Here again, one of the problem I have with the perl community is that it is closed to itself. It is hard for new comers to get into it, especially when the perl doc website links to so many different websites, that there is no easy way to get in the community (one value market), which means less chance to get new comers and hence,new good programmers. Also the above perlmonks website,for example, smells the 90's(it does not relate to the language directly but form of things needs to be "current" to be a bit attractive.If not,it means less new comer and less chance to get good programmers). I was also wondering why when the community is so active, perl gets so little credit in recent books, do not have new books released as often. Because the hype is contained in the perl community which in the end might be killing itself by closing its door to the exterior world. perl is self contained. people might think it's a good thing. I am not so sure. In other dynamic languages, they create a "product", they create a website(no CPAN like infrastructure for some of them). It may sound stupid but it does help to "give the impression that the language is active" (SEO wise, it's not bad either to get so many websites linking to each other about the same topic). There is no new online tutorial about perl either or at least, they are not easy to find. when you look for perl, you always get the same old articles dating from the 90s-&gt;dead camel around (Beware, I don't say that perl is dead, I say that it gives this impression to exterior people who might want to join). No new tutorials, because perl gurus come in and say that you do not understand the language and discredit others. It does not encourage people write tutorials. you have to be a guru, a perl ninja to write stuffs. there's no new books or online tutorials on how to develop software either or about design patterns a la perl (an old online reference book exists though sure), create automated test, using Devel::NYTProf or whatever. Many books about perl deals on how the language works, how to make the language behave like you want,how you can extend the language but not how to build a software.New comers want a lab book, something where they can enjoy creating something and see the result. intermediate one want to learn some design principles. nothing here either. In that sense, Moose,which offers something structured could be a good base to write new books on how to build software. It will avoid the necessary pages where you explain the 10 different ways to create an object. In some regards, the javascript community has a bit of the same concern about this, there's no one way to implement "OOP", classical oop, functional oop,prototypical oop,etc. you get framework to sum up this in common idioms and people are done. I think it could be a good occasion for the perl community to get some people from javascript into perl because somehow,they relate. The article assumes that to be a good programmer, you need to go to the community, need to read books (none of them are somehow able to tell you how to build something), which is absolutely true... But... I am disappointed that it does not look on the other side too. how to create good perl programmers. In the end, at the actual pace,the answer to: why you cant hire great perl programmers is this other question: where can i find a good (java/python/ruby/php) programmer. this must be changed by basically getting new people into perl with a new mindset in the community. how the community should extend to other "general purpose" websites more, how the community should be writing tutorials more in those websites (there are some recent articles in Japanese though, as perl is still popular there), how the community should communicate about them on the net with all the social linking stuffs, like this one or DZone,how books should be created to deal with actual needs,how the perl language itself should implement classical oop paradigm in the core language (in perl6,they added it, adding it in perl5 would not be a dismissal of the language, imo, it will just make life easier for new comers), how new open source projects should be developed more and more...(for the web with fastcgi,psgi, new perl cms could be a real helper). 
Note: you're talking to one of the developers of perl 6 (i've read several of his books). He's a smart man who knows what he's doing. perl5 is useful and installed everywhere now perl6 is only used by people who want to tinker with it for when it does become mainstream (mr_chromatic could answer when this will be better than I can) I am not aware of any major applications written in perl6 (although some may exist)
Er... every serious webserver on earth does FCGI, and pretty much every Perl web framework does too.
Perl 5 is better for when you want to get one-off jobs over and done with quickly. You can make big things in it, but it's sometimes not fun and not pretty. Perl 6 is easier on your typing fingers, easier to understand (operators follow a logical pattern rather than "whatever C did it like"), and more of a thinking man's game. Because when you're using Rakudo, you'll have *lots* of time to think about what you're doing while it runs.
Learn the Catalyst framework. There is a book as well as online documentation.
Rakudo is slow?
Yes there is. "Perl and Apache" 2010 (434 pages) by Adam McDaniel, Visual Blueprint Publishers. I just picked it up, and it's an enjoyable read, sort of a perl/cgi survey, but nothing in depth. You'll want to have read some solid perl and cgi documentation first. Regarding cgi: I applaud Modern Perl, Plack, Moose etc. I really do. And that's how I'd like to program (someday). But for a part time perl hobbyist there's just (seems) to be too much to learn all at once. I think some people need an opportunity to write semi-crappy code, and find out firsthand where the limitations arise. Then build up naturally (and yes as quickly as possible) to incorporate the larger concepts.
Troll. Others have explained that perl offers many superior alternatives to cgi.
&gt;Others have explained that perl offers many superior alternatives to cgi. That's exactly what I said...I fail to see how that's trolling.
Here's the rub: Almost no employer will know to use these and it'll be up to them getting a great developer to get someone who hammers these things into their heads.
It can be, but whether that's important depends on what you're doing. Most of the work I do is IO bound.
You said nothing, except to quote an (incorrect) sentence comparing perl to other languages, and then misrepresenting what was actually discussed in the thread.
CGI is not recommended for any site with bug number of visitors in any language. But with any modern Perl framework or PSGI you can write apps that will work with any interface to web server or with own server. 
[Padre](http://padre.perlide.org/)
Yes, I completely agree =). Just I got the impression somehow that you suggested that peer review could be a substitute for testing =). Ideally you have *both*, but if I could only choose *one* it would be testing.
Oh, very nice, hadn't seen that before. Thank you! Though, I do wonder if it can handle [Randal's example of Kennedy's Lemma](http://www.perlmonks.org/?node_id=663393) :-) We'll see.
Perl is certified 42% More Awesome.
Like, what can you do in Perl much more easily and more effectively than in Python?
rapid development, the idea that there is more than one way to solve a problem (while python is very much so "there is one right way to solve a problem") cpan.org has a much larger library than pypi text processing is much more "natural" in perl due to the implementation of regex as an operator rather than a library but seriously here, this is like asking "What are the advantages of a chevy over a ford?"
So not that many differences?
Well, I'll agree with the first three words, at least. Don't get me wrong. Character for character, it outpowers other languages, but it's the definitive example of a Write-Once language.
When used by an idiot, yes.
Write one-liners. 
CPAN: 63871 Uploads, 21742 Distributions, 89169 Modules, 8707 Uploaders That's ninety-thousand modules, free to use, simple to install, already tested, ready for use.
Perl 6 isn't ready yet. Don't worry about it unless you want to play with something cool. As for Perl 5, it's pretty similar to Python. In fact, they're so similar that mentioning any difference except CPAN is basically nitpicking. If you want to nitpick, you can mention things like these: * Perl has proper support for lexical closures. * Python can garbage collect self-referential structures. Even for things like that, there's pretty straightforward work-arounds for when you would want those specific features in either language. Ruby's the same too, btw. Just nicer looking and slower, because it's newer and less mature.
One advantage that is theoretically irrelevant, but huge in practice: I'm constantly writing Perl one-liners on the command line with things like “perl -pe 's/foo/bar/ if /qux/'” and whatnot. Python doesn't have meaningful one-liners. (I don't mind the way Python uses whitespace to determine nesting, but I hate the way it makes it *mandatory*, thus forbidding one-liners. Haskell is a good example of how one can use whitespace but still offer an alternative way to specify nesting which is useful for auto-generated code or one-liners or any other reason not to use indentation.)
&gt; Python can garbage collect self-referential structures. Why can't Perl? Do you have some info about this?
Perl uses simple reference counting to manage memory objects (see "man perlobj"). One of the drawbacks of this approach is an inability to free circular data structures. Python uses reference counting too, but a couple years ago they implemented a full garbage collector that gets run occasionally to clean up memory leaks due to unreferenced circular structures. Interestingly, Perl 5 has the code in place to do the same thing, but the developers have chosen not to enable it for performance reasons. This is just a design tradeoff: Occasionally Python programs will have funny garbage collection pauses that are hard to diagnose. On the other hand, sometimes Perl programs will have memory leaks because a developer didn't deal with a circular structure properly.
Oh, get ahold of yourself. It's only the *distributions* that matter.
* CPAN with all it's infrastructure * real variable scope * Moose * no serious compatibility problems * easier to see bad code * perltidy * less memory used * state variables 
Love, love, love Modern Perl!
&gt; easier to see bad code Now that's an interesting way to put it :-)
No, not really. I've used both for years professionally and the choice mostly depends on the particular modules / libraries / frameworks you're going to need for what you want to do. 
Like Chandon said, ref counting. However, you can manual deal with that by using "weaken" on a reference, to not have that reference make the referenced object stay alive.
Full integration of regexps.
Sigils. With Python, you often have to guess at the type of a variable when reading code. With Perl, not so much. Of course you have to learn to read the sigils, which takes about ten minutes if that. 
Seconded. To elaborate on yours, one of my faves is perl -i -pe 's/\bfoo\b/bar/g' 
And 1337% of pi is 42. Larry works in strange and mysterious ways. http://www.wolframalpha.com/input/?i=1337%25+*+pi 
Did I wrote incorrectly? I meant determine or detect.
wtf
Bundling the command-line options as `-i -pe` is much less fun than bundling them as `-pie`. :-) EDIT: [Whoops](http://www.reddit.com/r/perl/comments/f2p5y/what_are_the_advantages_of_perl_56_over_python/c1cwa8p). Your version has the downside of being less tasty, but the upside of working.
This came up on Stack Overflow way back when, and you can [read my answer](http://stackoverflow.com/questions/150043/python-v-perl/150415#150415) (and everyone else's too).
WTF? Counting modules is like counting files. Should rails count as 1 library or dozens? Answer: one. Bragging about module count is stupid. That's wtf.
Doesn't work. The -i argument has an optional parameter (what to append to name the saved backup file) so the 'e' gets interpreted as the parameter to -i. If you want pie the best you can do is "-pi -e".
I find it easy to write functional style code in Perl. Huge nested map/grep expressions that end up looking more like lisp than classic Perl. Python doesn't allow that kind of thing. With Python I find I have more of a naming overhead--that is the language forces me to pick names for things that would be intermediate expressions in a Perl program. This is because of the lack of first class lexical closures--the closest approximation is a nested subroutine which requires being named. The end result is things are much more verbose in Python, though arguably less cryptic to a beginner.
There are many *differences*, but a lot of them aren't really advantages either way, they're just alternatives. One developer might have their own subjective preference, and it might be a strong preference, and they might be much more productive working in that language. Another equally competent developer with a different programming style might favour (and benefit from using) the other language just as much.
No, I think you got it right. =)
&gt; Should rails count as 1 library or dozens? Hasty generalization!
I think this link says it all: [THERE IS MORE THAN ONE WAY TO DO IT](http://en.wikipedia.org/wiki/There\'s_more_than_one_way_to_do_it) 
Perl is still in use still because for non-prima-donna cs majors it just gets shit done without having to re-implement some basic shit.
The cliche is that Perl looks horrible, and then people always have to reply that it depends on the programmer, good programmers can write readable Perl just fine. I like your rephrasing that to "easy to see bad code" :-)
What does Net::Oauth2 have to do with trying to annotate Pod::Simple?
You're saying the pie is a lie?
&gt; I like your rephrasing that to "easy to see bad code" More than that: good *and* bad Python tends to look uniform while you skim it, whereas good Perl is visually distinct from bad Perl.
I've been using Perl at work for about 2 1/2 years, self taught using the Core Perl book and the web. I was able to answer about 4 of those questions. Guess I still have some work ahead of me. Has anybody read his book Modern Perl, is it pretty good?
Same. I consider myself a good Perler. I read through the list and was stupefyed by an embarrassing number of those questions. Guess I'd better start reading some more Perl books.
I read a few chapters when it was on git and got a hard copy for Christmas. It's one of the best Perl books I've read. I would recommend it to anyone learning Perl as their 2nd book to read after Learning Perl. I've been programming Perl on my own time for about four years and have done so as a job for the last year. I could list out a few pages of things that I learned from Modern Perl, it would be more if I hadn't been reading every blog post by cromatic. I'm looking forward to the ePub version.
I know most of the answers and consider myself only competent. IMO that's the beauty of the language.
Same here. I can answer all of these to some extent and most of them with a good bit of confidence, but still i regard myself as not knowing nearly enough and am constantly looking for people from whom i can learn more.
I've been a full-time Perl programmer for 12 years. I consider Modern perl Programming an excellent book. The classic Perl texts are Learning Perl, Intermediate perl, Programming Perl. They are great, bu have become somewhat dated; the standard Perl idiom has evolved, and the books haven't. Modern Perl gives you the current way of doing things. See also Effective Perl Programming .. the book and the website ... http://www.effectiveperlprogramming.com/ for similar but different modern slant on Perl
There are many many good modules on CPAN but most of the time (not all the time), the documentation is almost nonexistent...you have to look into the module itself to know how it works and that's really not efficient. What would be nice, on the perl doc website and CPAN module doc pages, is a comment system (AnnoCPAN being in the same spirit). Using DISQUS for example it could be very easy and require very little overhead on CPAN or the perl doc website to add this feature. If we could share our knowledge this way, it would be very enlightening. after all, I sometimes learn more by reading the comments than the article itself. I am pretty much sure that we could share so valuable insights via a comment system, on the perl doc website and CPAN. CPAN is huge, when you have documentation, you have to deal with different formatting, some says it forces people to read the doc,why not. I think that having a standard on how to write the functions/methods could help to make all these modules even easier to read. Everyone has its way, it is the perl way but having a common format for the documentation could be very helpful when at work and that you want to go through a module very quickly. It would also help developers that do not really know where to start, what to write. 
While we're on that one.. perl best practices is another "must" read (with the understanding that it should be taken with a matter of "suggestions" not guidelines"
man, I was reading this expecting to be stumped by most of them.. guess not, woohoo for competency!
I don't have a problem with lack of sigils. If an object is a list, I use a plural for the name.
&gt; If you want pie the best you can do is "-pi -e". Wow, it's embarrassing that I didn't know that; thanks! Your version has the upside of being tasty if I bundle, and mathematical if I don't. :-)
Stuck on one, maybe I'm reading too much into it: &gt; How do you detect (and report) errors from system calls such as open? (Award bonus points for knowing how to enable automatic detection and reporting of errors.) Also: &gt; How do you load and import symbols from a Perl 5 module? Are you referring to the "use" function? &gt; What governs how Perl 5 loads modules? Are we talking about @INC? Or deeper than that?
And then use Perl::Critic to verify your code against most of those guidelines.
&gt;Stuck on one, maybe I'm reading too much into it: &gt;&gt; How do you detect (and report) errors from system calls such as open? Doesn't it just mean using "or die"? And the youngsters these days have a thing called "autodie", maybe that's what the bonus points are for? &gt;What governs how Perl 5 loads modules? That is *so* badly worded it's hard to answer. A lot of things govern how Perl 5 loads modules!
Cut and pasted ... I'm going to try and answer the ones I know. And try not to cheat: 1. What do variable sigils indicate in Perl 5? 1. What's the difference between accessing an array element with $items[$index] and @items[$index]? 1. What's the difference between == and eq? 1. What do you get if you evaluate a hash in list context? 1. How do you look up keywords in the Perl documentation? 1. What is the difference between a function and a method in Perl 5? 1. When does Perl 5 reclaim the memory used by a variable? 1. How do you ensure that the default scope of a variable is lexical? 1. How do you load and import symbols from a Perl 5 module? 1. What governs how Perl 5 loads modules? 1. How do you look up error messages in the Perl 5 documentation? (Award bonus points for knowing how to enable explanations of all error messages encountered.) 1. What happens when you pass an array into a function? 1. How do you pass one or more distinct arrays into a function? 1. What is the difference, on the caller side, between return; and return undef;? 1. Where do tests go in a standard CPAN distribution? 1. How do you run tests in a standard CPAN distribution? 1. What command do you use to install new distributions from the CPAN? 1. Why would you use the three-argument form of the open builtin? 1. How do you detect (and report) errors from system calls such as open? (Award bonus points for knowing how to enable automatic detection and reporting of errors.) 1. How do you throw an exception in Perl 5? 1. How do you catch an exception in Perl 5? 1. What is the difference between reading a file with for and with while? 1. How do you handle parameters within a method or function in Perl 5? 1. What do parentheses around the variable name in my ($value) = @_; mean, and what would happen if you removed them? 1. Is new a builtin function/keyword? 1. How do you read the documentation of a core library? A CPAN module? 1. How do you access only the values of a Perl 5 hash? 
open my $fh, '&lt;', 'path/to/file' or die "Can't open" Alternatively use autodie. I'm pretty sure he's referring to use, yes. Require/import would also work. That was poorly worded question (imo) and I think that he was going for @INC yes.
Here's my go at the first ten: ---- **1. What do variable sigils indicate in Perl 5?** $ = scalar, @ = array, % = hash **2. What's the difference between accessing an array element with $items[$index] and @items[$index]?** They both work but the second one is deprecated in Perl 5 (but the only way to do it in Perl 6?). The second one can also be used for a slice, as in @items[ 1 .. 3 ]? **3. What's the difference between == and eq?** The first is for comparing numbers, the second for strings. **4. What do you get if you evaluate a hash in list context?** The keys and values, in no predictable order? **5. How do you look up keywords in the Perl documentation?** perldoc -k &lt;keyword&gt; ? or maybe perldoc -f &lt;keyword&gt; ? **6. What is the difference between a function and a method in Perl 5?** Er ... nothing? Not sure what that means. **7. When does Perl 5 reclaim the memory used by a variable?** When the program quits, that's for sure. Otherwise ... when you undefine it? **8. How do you ensure that the default scope of a variable is lexical? ** With "my" ** 9. How do you load and import symbols from a Perl 5 module? ** Not sure what's meant by "symbols" at all here. I know how to import methods, as in "use ModuleName qw (method1 method2)" ... does it mean variables inside the module namespace like $Data::Dumper::MaxDepth? ** 10. What governs how Perl 5 loads modules?** Very poorly worded question. Governs in what way? I govern it by putting "use" into my scripts! Does it mean in which order it loads them, or how it loads dependencies? No idea what kind of answer is required.
Next ten: ---- ** 11. How do you look up error messages in the Perl 5 documentation? (Award bonus points for knowing how to enable explanations of all error messages encountered.) ** perldoc perlerr ? just a guess. And "use diagnostics" for the bonus points? ** 12. What happens when you pass an array into a function? ** It gets put into @_? ** 13. How do you pass one or more distinct arrays into a function? ** Pass references to them or they'll all get flattened into @_? ** 14. What is the difference, on the caller side, between return; and return undef;? ** No idea. These aren't supposed to be trick questions, right? I would guess they're the same but obviously they're not. ** 15. Where do tests go in a standard CPAN distribution? ** In the t/ directory? ** 16. How do you run tests in a standard CPAN distribution? ** With "make test"? ** 17.. What command do you use to install new distributions from the CPAN? ** cpan ModuleName not cpan install ModuleName because then it tries to install a module called "install" first and gets everyone confused. Only they fixed that a while ago. ** 18. Why would you use the three-argument form of the open builtin? ** Because it's the approved, modern way to do it ... harder to make a mistake ... damn it I know there's a Stupid Thing it prevents me from doing but I can't remember what. ** 19. How do you detect (and report) errors from system calls such as open? (Award bonus points for knowing how to enable automatic detection and reporting of errors.) ** Use "or die". Too simple? The bonus point is for knowing about "autodie"? I've never used it. ** 20. How do you throw an exception in Perl 5? ** I don't think in terms of exceptions, but this means "or die" again? ** 21. How do you catch an exception in Perl 5? ** With eval {} and looking into $@ for errors.
** 22. What is the difference between reading a file with for and with while? ** while is going to slurp the whole file and therefore a Bad Idea? Don't know, I never use while on files. ** 23. How do you handle parameters within a method or function in Perl 5? ** How do *I* do it? I shift() them, or I grab the whole of @_ ... why does he keep saying "function"? ** 24. What do parentheses around the variable name in my ($value) = @_; mean, and what would happen if you removed them? ** They make it into a list with one item? If they weren't there, it wouldn't be in list context and you'd get the number of elements in @_? ** 25. Is new a builtin function/keyword? ** No, it's a method of your Module and it's just another subroutine of that module? ** 26. How do you read the documentation of a core library? A CPAN module? ** perldoc ModuleName for the second one. What's a core "library"? ** 27. How do you access only the values of a Perl 5 hash? ** with the values(%hashname) function.
14. What is the difference, on the caller side, between return; and return undef;? http://search.cpan.org/dist/Perl-Critic/lib/Perl/Critic/Policy/Subroutines/ProhibitExplicitReturnUndef.pm
Very sensible. I get it, thank you. Like I said, I was answering off the top of my head and not looking anything up. 
Yeah, I answered from the top of my head too. I've read all the perl critic a long time ago. It is very instructive but indeed enters the tricky world imo.
In one of the comment in the link from autarch, regarding python: &gt;One of the best things about it is that the standard library is extremely &gt;versatile (database, XML, JSON, math, etc.) and all those modules have &gt;a common interface and feel, which makes them easier to learn and use. I don't know enough python to tell but the above feels true regarding perl. Having more modules in the core with a coherent API,coherent documentation would be a real real plus for portability and readability. Even though Larry said that he sees perl as a kernel,I think having some more useful modules could be really helpful.
&gt; 6. What is the difference between a function and a method in Perl 5? &gt; &gt; Er ... nothing? Not sure what that means. A method call has an implicit 'this' first parameter which is the blessed hash of the object on which you're making the call. In other words, when you write this: my $foo = Zyx::Xyz-&gt;new(); $foo-&gt;bar ("value"); The 'bar' method would be coded like this: sub bar { my ($self, $arg) = @_; say $arg; # prints 'value\n' } &gt;7. When does Perl 5 reclaim the memory used by a variable? &gt; &gt;When the program quits, that's for sure. Otherwise ... when you undefine it? I would have said when it's reference count reaches zero, which for lexicals means when the enclosing block goes out of scope, unless a reference escapes as in the case of a closure. &gt; Not sure what's meant by "symbols" at all here. I know how to import methods, as in "use ModuleName qw (method1 method2)" ... does it mean variables inside the module namespace like $Data::Dumper::MaxDepth? Importing is done by manipulating the symbol table, so that's why he uses the word.
&gt; 12. What happens when you pass an array into a function? &gt; &gt; It gets put into @_? And a copy gets made, which can be inefficient. &gt; 13. How do you pass one or more distinct arrays into a function? &gt; &gt; Pass references to them or they'll all get flattened into @_? You can also use a prototype with a \@ specifier which allows you to write things like sub frob(\@\@) { ... } frob (@foo, @bar); The \@ forces references to foo and bar to be passed so that they aren't flattened. &gt; damn it I know there's a Stupid Thing it prevents me from doing but I can't remember what. If you accept filenames from untrusted users the three-argument open prevents a user from being able to specify a filename like 'rm -rf /\* |', or just in general if you happen to have a file that contains metacharacters bad things are possible.
&gt; while is going to slurp the whole file and therefore a Bad Idea? Don't know, I never use while on files. Other way around. This reads the contents of a file one line at a time: while(&lt;&gt;) { ... } Whereas this slurps the entire file into memory first and then begins the loop: for (&lt;&gt;) { ... } &gt; why does he keep saying "function"? Probably to distinguish between a method and a function? They are different things. &gt; What's a core "library"? The libraries that ship with perl are core libraries. See for example `corelist -v 5.12.2` or `corelist List::Util`. 
That's what I thought, but the wording has me second guessing. Obviously I was overthinking it. Same with the other questions. It's a shame that the ambiguity of the wording of some of the questions may distract from an otherwise good post. Maybe he can edit for clarity.
I think more like: my $file_to_open = 'path/to/file.ext'; open my $fh, '&lt;', $file_to_open or die "Cannot open $file_to_open for reading: $!"; # ... close $fh or die "Cannot close $file_to_open: $!"; - detect: done via "or", which executes the right hand side bit when `open()` or `close()` return undef - report: via the die, but the important bit is telling the user _what_ is wrong, and that's done via `$!`. - Throw in the filename so the user knows which file the error is talking about
&gt; What governs how Perl 5 loads modules? See [perldoc use][1], which shows that `use Module qw/list of args/;` is equivalent to `BEGIN{ require Module; Module-&gt;import(qw/list of args/); }` Then [perldoc require][2], which (in case of a module, not a version) shows how the `%inc` hash is checked to see if the module is already loaded, and if not `@INC` is traversed to see if the module can be found. If found, the module is "done" via `do $module_filename` and if not the thing `die()`s. [1]: http://perldoc.perl.org/functions/use.html [2]: http://perldoc.perl.org/functions/require.html
&gt; 1. What do variable sigils indicate in Perl 5? Is `*` also considered a sigil, for a typeglob?
&gt; A method call has an implicit 'this' first parameter which is the blessed *hash* of the object on which you're making the call. In other words, when you write this Not quite, you can bless whatever reference you like: $ perl use strict; use warnings; use 5.010_000; # for say package XXX; # blessed arrayref sub new { my @x; bless \@x, __PACKAGE__ } sub bar { my ($self,$arg) = @_; say $arg } package YYY; # blessed scalarref sub new { my $x = ''; bless \$x, __PACKAGE__ } sub bar { my ($self,$arg) = @_; say $arg } package main; my $foo = XXX-&gt;new(); $foo-&gt;bar('hi'); my $bar = YYY-&gt;new(); $bar-&gt;bar('hi'); ^D hi hi 
I know the answers to few, if any and yet I have written perl stuff that runs critical infrastructure, some of it for years without problems or downtime due to the code.
That's a very dubious guideline btw. A bare return makes the return context sensitive. That makes sense (somewhat) if the sub is expected to return a list, but not at all if it's expected to return a scalar. Let's say an object (a scalar) is returned for success. Then the failure condition should probably return an undef, not an undef-or-empty-list. I.e. if the normal return value from a sub is not context sensitive, then the failure return value shouldn't change that willy nilly. 
Did you ask this on the Python reddit to get the other side of the story?
You're missing the point. You can use a plural, but you have no control over whether everyone else does. 
You also have no control over all sorts of other programming standards. Unless you have code review. You also have no control over whether someone constantly uses arrayrefs instead of arrays. But you can see from the context (how they are using it) that it is a list. Same goes for when using languages without sigils.
Just ignore the chapters about Inside-Out objects ... so 2007, so wrong.
Indeed, Moose is the sauce for decent OO these days
I looked this up in Critic and it says the three-form argument is good because you don't have to remember what the default is. And also it protects me from files which start with &gt; or &lt;.
Oh, nice catch. I'm sure you'd get extra points for asking that anyway.
Pod::Simple is how the docs are made :) So basically the docs for Net::Oauth2 were either non existent or sucked. His idea was to make it so others can see the docs he made.
I don't think that answers from Python programmers would be useful - frequently Python programmers do not know Perl, only consider it evil. Or they knew Perl from 5-10-15 years ago. So common answer would be that Python is more readable because whitespaces are mandatory. I see such answers frequently. Of course Perl has the answer to this - perltidy, but of course they don't know about it.
Thanks. This is stuff I am familiar with, I was just thrown by the ambiguous wording, especially the "governs". I would have asked more specific questions.
Actually I swear to god, I meant I *always* use while(), not never.
http://www.reddit.com/r/Python/comments/f3wwx/i_have_yet_to_learn_a_scripting_language_whatre/ This is where I came from, wondering if he/she asked /r/perl. :)
Well, as soon as they turn into array refs the problem is back. Regular arrays and hashes normally only occur inside a fairly small scope, like a sub.
I am not sure we understand the guideline the same way. It does make sense in both list and scalar context and apply the rule of least astonishment. *I let the question of not bailing upon failure as a rhetorical one for the purpose of this guideline.* * If you send back undef on failure for a sub that works in list context, you could get some surprised. * If you return; on failure for a sub that works in list context, everything should be fine. * If you send back return or return undef for a sub that should work in scalar context, it will work either way (in both case, the lvalue will be set to undef) The common denominator with the above test cases can only be "return;" You never know how people are going to use your code in the end,even though I think it's a matter of writing documentation more than anything else. Still you could have: package testing; sub new { #1 #return bless{},shift() #2 #return #3 #return undef } sub test {return 'testing...'} 1; package main; use 5.10.0; my $obj = {}; $obj = new testing();#in case of 2&amp;3, $obj will be reset to undef say $obj-&gt;test if $obj; #ouch in case of 3 if(my ($obj) = new testing()){ say $obj-&gt;test } *Obviously, using a list context for object instantiation seems dumb but never knows* in #1, you should see: testing... testing... In #2, you should see no output. In #3, you should get Can't call method "test" on an undefined value at... By using #2, you make sure the dwiming works as generally thought in either scalar or list context. By using #3, you may have some surprised. But obviously, one should document the expected behavior of a sub to avoid unnecessary use of list context for a sub that has only scalar context but if the programmer can avoid this on his side by following this easy guideline why not. 
* Tolerant community :) * qr// and extended regular expressions - they really improve readability 
That's no reason to not value the control a language does give you. The post asked for advantages. I gave one, plain and simple. You are looking for ways to argue about it. 
They are both turing complete. It becomes a matter of taste really. You should pick a small project and do it in both languages to see what you like and don't like in each.
Yay! (mt) Media Temple! Great place to work, btw. Not that I'm biased. :)
I only use these. use strict; use warnings; use 5.010; I have the bad habit of avoiding unecessary module dependencies, even standard modules.
There is cpanforum, link is on search.cpan.org page for dist.
 use strict; use warnings; use Data::Dumper; # since I always seem to need it. That's about it.
My template has ... use English qw( -no_match_vars ); use autodie qw( open close ); use Readonly; use DBI; use POSIX 'strftime'; use Getopt::Long; use Pod::Usage; use warnings; use strict; Plus a couple of in-house modules. strftime() is the most convenient way for me to get dates into YYYYMMDD format. If no DB access, I just drop the DBI &amp; POSIX. 
I love the idea of having... use common::sense; ... at the top of my programs.
sure. but I had in mind a comment system like you can find on blogs for example. AnnoCPAN is very closed for CPAN. I think it would be more appropriate to have this comment system on the perl doc. a forum somewhere else is yet an other way to make the point entry of information disparates. And a forum can answer to questions and the discussion can derive a bit, read,quite a lot. A comment system on the perl doc/CPAN would be a way to share some code regarding the function described or add any extra information that could be unclear. In that regards AnnoCPAN is very closed. it is perhaps more the way it is displayed than the system itself. I would not be against a AnnoPerlDoc either
I'm not sure this is wise. Wasn't smart matching changed fairly significantly between 5.10.0 and 5.10.1? For example, $ perlbrew switch perl-5.10.0 $ perl -E 'my %hash = ("" =&gt; ""); say undef ~~ %hash ? "Aw..." : "Yay!"' Aw... $ perlbrew switch perl-5.10.1 $ perl -E 'my %hash = ("" =&gt; ""); say undef ~~ %hash ? "Aw..." : "Yay!"' Yay! If you want compatibility with 5.10, you might want to insist on 5.10.1.
I love that use 5.12 includes strictures! I usually go with use v5.12; use warnings; and add things like autodie on a case by case basis. I'm really excited about some of the things going into 5.13.x, so I will probably change the above to "use v5.14" at the earliest opportunity. 
Stumbled across [this](http://stackoverflow.com/questions/4272816/using-dumper-not-triggering-a-failure/4272858#4272858) (pasted below) recently at stackoverflow from tchrist: #!/usr/bin/env perl # # name_of_program - what the program does as brief one-liner # # Your Name &lt;your_email@your_host.TLA&gt; # Date program written/released ################################################################# use 5.10.0; use utf8; use strict; use autodie; use warnings FATAL =&gt; "all"; # ⚠ change to agree with your input: ↓ use open ":std" =&gt; IN =&gt; ":encoding(ISO-8859-1)", OUT =&gt; ":utf8"; # ⚠ change for your output: ↑ — *maybe*, but leaving as UTF-8 is sometimes better END {close STDOUT} our $VERSION = 1.0; $| = 1; 
I used to use `Data::Dumper` all the time until I found `Devel::Dwarn`.
#!/usr/bin/perl # -- use strict; use warnings; use diagnostics; use feature ":5.10"; use Data::Dumper::Simple; our $VERSION = '0.01'; 
For writing I go with minimal: use strict; use warnings; use Smart::Comments; use Data::Dumper; Then when I'm done I comment out Smart::Comments and Data::Dumper. Smart::Comments encourages me to comment my code properly whilst I'm writing it as it will print to STDOUT any line prefixed with a double hash ## so I know exactly where execution has got to / got stuck. So far I've not touched Modern::Perl or Moose or any of those ilk. It's overkill for what I'm doing and pointless overhead.
I've never understood the pervasive use of `$| = 1;`, unless the bulk of what you write is a Unix filter.
I also wouldn't add it to every script, but it's quite useful sometimes, e.g. foreach my $i (some long list with 1000+ items) { do stuff; print '.' unless $i % 100; } or if you generate a lot of HTML with very few newlines, but want to see each and every output as soon as it's print-ed while debugging.
I wouldn't worry too much about it, as far as i can tell tchrist composes all his SO posts to achieve both amounts of amusement and "what the christ?" values.
&gt; use open ":std" =&gt; IN =&gt; ":encoding(ISO-8859-1)", OUT =&gt; ":utf8"; In my mind that's in *incredibly* foolish and irresponsible thing to suggest as boilerplate. Yeah, the comments say to change it, but some of the people being told to use this don't even know what an encoding is, let alone what their default should be. At the very least, I would suggest using ":locale" for the input as that will let perl detect whatever the user has set as their default. But you could also argue that the default for everything should be utf8. So I really can't see how you can suggest this nonsense in boilerplate -- it depends on what you're working with and what you're doing. 
I have this this code template set up so that I can load it into Emacs with a couple of key strokes # @(#)$Id$ package Module::Name; use strict; use namespace::autoclean; use version; our $VERSION = qv( sprintf '0.1.%d', q$Rev$ =~ /\d+/gmx ); use Moose; __PACKAGE__-&gt;meta-&gt;make_immutable; no Moose; 1; __END__ =pod =head1 Name &lt;Module::Name&gt; - &lt;One-line description of module's purpose&gt; =head1 Version 0.1.$Revision$ =head1 Synopsis use &lt;Module::Name&gt;; # Brief but working code examples =head1 Description =head1 Subroutines/Methods =head1 Configuration and Environment =head1 Diagnostics =head1 Dependencies =over 3 =item L&lt;Moose&gt; =back =head1 Incompatibilities There are no known incompatibilities in this module =head1 Bugs and Limitations There are no known bugs in this module. Please report problems to the address below. Patches are welcome =head1 Acknowledgements Larry Wall - For the Perl programming language =head1 Author &lt;Author Name&gt;, C&lt;&lt; &lt;email at domain&gt; &gt;&gt; =head1 License and Copyright Copyright (c) &lt;Year&gt; &lt;Author Name&gt;. All rights reserved This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See L&lt;perlartistic&gt; This program is distributed in the hope that it will be useful, but WITHOUT WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE =cut # Local Variables: # mode: perl # tab-width: 3 # End: I suspect that many people would eschew the use of version.pm and the RCS keywords will be ignored by git 
Randal uses it pervasively too. I've seen performance improvements when *removing* it from code -- but again, not Unix filters.
Well, how do you tell Perl 5 to simply always expect and always use utf8-encoded unicode? Or does it already do that by default? 
No, it doesn't do that by default. You do that with `use open ":std" =&gt; ":encoding(utf8)"` or the -C command line parameter. My point wasn't that `use open` is evil, but rather that it shouldn't be presented as boilerplate that you automatically put at the top of every file beside "use warnings" and "use strict". In particular, if you're going to suggest a default, I don't think latin-1 should enter the conversation at all. And if you don't know what kind of encoding you're dealing with, it's arguably better to work with strings as bytes rather than strings as characters with an incorrect encoding. At least that way you have a chance of passing through data without making mojibake, unless it's encoded with something like utf-16 in which case you get a pretty clear error about what's wrong. Edit: I also think "use utf8" falls under this category too. For users on Windows systems, they will most likely be saving source files in utf-16, which means the option is unnecessary due to the BOM. For other users, they might prefer the file to be in their local encoding and not utf8. Again, this is not something that you can simply decide as boilerplate.
 use 5.010_001; At least you get the "good" variety of `~~`
&gt; strftime() is the most convenient way for me to get dates into YYYYMMDD format There is also: my $dt = DateTime-&gt;new(...); $dt-&gt;strftime('%Y%m%d');
You really should look into Dist::Zilla, I think you'll find it to be quite awesome at generating all that boilerplate for you (especially Pod::Weaver!)
I don't really think you can call Modern::Perl overhead... and autodie is quite awesome no matter what you're doing.
What I've often-enough found is that, when searching for a module you need: * the Cheeseshop has it, but it's often half-baked in some way (maybe not well documented, or incomplete, or whatever) * the CPAN has a half-dozen choices for what you're looking for, but there's generally one or two that work really well, are mature, well-documented, and ready to go What I'm saying is: on the surface, module-wise, Python looks just as good, but when the rubber meets the road, you realize just how solid the existing Perl modules are, and how much work the Python modules require to be comparable. 
I like Data::Dumper::Concise since the output is a bit easier on the eyes.
If the scripts work perfectly fine without, why waste time using additional modules? Maybe I'm missing something but I don't see the benefit. Looking at autodie I can see one specific use case that may find it advantageous (will look to adding it soon), other than that it's pointless extra disk IO and time. Maybe I have an old school sysadmin perspective, but why waste resources you don't need to? Also worth noting: The majority of the servers I do scripting for are RHES5 / CentOS5 (they dominate the enterprise market) boxes with perl 5.8, so no Modern::Perl, short of upgrading perl itself and that may be pulling disaster down upon my head in the context of all the infrastructure built around it.
You're trading runtime and memory optimization, that is in practice unnoticable, against your own time. Not a very good trade.
Here: package Whatevs; use Moose; use namespace::autoclean; __PACKAGE__-&gt;meta-&gt;make_immutable;
A few years ago I was blindly using Data::Dumper::Simple not realizing it was a source filter. It increases startup time tremendously.
Agree; note, however, ::Concise is *not* in core. I do just what mst did when he created Data::Dumper::Concise; use Data::Dumper; { package Data::Dumper; no strict 'vars'; $Terse = $Indent = $Useqq = $Deparse = $Sortkeys = 1; $Quotekeys = 0; } Which have the exact same effect. 
Try saying that in #perl :)
Use vim templates $ cat ~/.vim/templates/perl.tpl #!/usr/bin/perl -w use warnings; use strict; # vi:et:sw=4 ts=4 ft=perl 
Ah, very nice. I was not aware you could use templates without a plugin.
The downside is, of course, that you have to live in LA. 
&gt; $ = scalar, @ = array, % = hash don't forget &amp; = sub &gt; 6. What is the difference between a function and a method in Perl 5? &gt; &gt; Er ... nothing? Not sure what that means. Every sub can work as a method too. But the biggest difference is lookup when the thing is called: In Perl 5, subroutines are only looked up in the current namespace, whereas methods are looked up in the namespace into which the invocant was blessed, and then (recursively) its parent classes as defined by `@ISA`. &gt; 7. When does Perl 5 reclaim the memory used by a variable? &gt; When the program quits, that's for sure. Otherwise ... when you undefine it? When its refcount goes to 0, which means if it goes out of scope and there's no further reference to it. &gt; 10. What governs how Perl 5 loads modules? &gt; &gt;Very poorly worded question. Governs in what way? I govern it by putting "use" into my scripts! Does it mean in which order it loads them, or how it loads dependencies? No idea what kind of answer is required. I guess chromatic wanted to discuss `@INC` and the like.
&gt; 11. How do you look up error messages in the Perl 5 documentation? (Award bonus points for knowing how to enable explanations of all error messages encountered.) &gt; &gt; perldoc perlerr ? just a guess. `perldoc perldiag` it is. &gt; 14. What is the difference, on the caller side, between return; and return undef;? &gt; &gt; No idea. These aren't supposed to be trick questions, right? I would guess they're the same but obviously they're not. Not a trick question. In list context, `return` returns an empty list, `return undef;` a list of one element. &gt; 18. Why would you use the three-argument form of the open builtin? &gt; &gt; Because it's the approved, modern way to do it ... harder to make a mistake ... damn it I know there's a Stupid Thing it prevents me from doing but I can't remember what. Because with the three-argument form you're safe to use shell meta characters in the file name (including spaces). Suppos your file name starts with a &gt; or &lt;, then `open $handle, $filename` recognizes it as a the opening mode, whereas `open $handle, '&lt;', $filename` correctly opens the file with the weird name.
Just ignore all the chapters that contain module recommendations. A nice list of the recommended modules, and what others think about them, can be found at https://www.socialtext.net/perl5/index.cgi?pbp_module_recommendation_commentary
Someone should make this for "everywhere"..
They are slowly added, perl 5.14 or 5.16 will have JSON in core.
No. This is a horrible idea. Completely horrifically horrible.
Take a look at [File::Next](http://search.cpan.org/~petdance/File-Next-1.06/Next.pm)
Or File::Find http://search.cpan.org/~jesse/perl-5.12.2/lib/File/Find.pm
Which is great, except the interface is horrible. I'd recommend http://search.cpan.org/~rclamp/File-Find-Rule-0.32/lib/File/Find/Rule.pm
I'm pretty much a perl noob, but wouldn't it be easiest to do something like: if(-f $filename) { DoSomething($filename); } elsif (-d $filename) { DoSomething( sprintf("%s/%s.txt", $filename, $filename) ) }
 perl -e 'opendir D, ".";for (readdir D) { next if /^\./ ; if ( -d ) { open F, "$_/$_.txt"; print "$_: ",&lt;F&gt; } }'
 soybean@soybean:~/foo$ perl -e 'opendir D, ".";for (readdir D) { next if /^\./ ; if ( -d ) { open F, "$_/$_.txt"; print "$_: ",&lt;F&gt; } }' date: honeydew grape: jackfruit fig: indianfig soybean@soybean:~/foo$ find . ./date ./date/date.txt ./grape ./grape/grape.txt ./banana ./cherry ./fig ./fig/fig.txt ./apple soybean@soybean:~/foo$ cat */*.txt honeydew indianfig jackfruit soybean@soybean:~/foo$ 
 use File::Find::Rule; my @files = File::Find::Rule -&gt;file -&gt;name('*.txt') -&gt;in($dir); 
 @files = `find $dir -iname "*txt"`; chomp foreach @files; Yeah I know it's ugly and OS-specific, but just in case you need it for something quick and dirty.:)
that works for one level, but you'd have to do this within a recursive function to get at anything deeper. edit: my bad, it does work for the directory structure he detailed, assuming the list he's working with includes directory names
Good news! A Date&amp;Time related module would be welcome too. (it's not something that is going to be out of date soon, no pun intended). 5.14 seems better than 5.16 though... Where is this information available btw? The "Array and hash container functions accept references" stuff in 5.13.7 is the first feature that makes me want to upgrade from 5.8.8. It is going to be an awesome add-on (a little thing but a pain on the eyes and on the fingers on a per day basis). (I've read all the updates since 5.8.8 but nothing compelling enough **for me** to update. ) 
File::Find::Rule ftw!
Core has Time::Piece, but it has limited capabilities. Information about bundled modules is available with corelist utility, which is included into Perl, for old Perls like 5.8.8 install Module::CoreList. As for future modules, I just read discussions on p5p - perl development mailing list.
Yeah it isn't great, but I'm pretty sure it's a core module so it doesn't add dependencies to your script. 
&gt; Core has Time::Piece, but it has limited capabilities. Indeed,,, I was talking about the upcoming modules in future release, not the one shipped with stable releases of perl but i should subscribe to p5p then
No, the correct response is to email the author of the original module and offer to help to maintain it. If all attempts to contact the author fail (they do drop off the face of the planet occasionally) then you can email modules@perl.org and ask to take over maintenance/development of the module. They can then grant you the magic database cookie that allows you to submit new versions of the module to CPAN. 
Can't upvote this enough. I can appreciate that no all module authors are responsive, but ButMaintained just seems plain petty as well as confusing to newbies.
I just lost a ton of sleep playing around with mojolicious thanks to you :) For anyone interested -- the wiki contains way more how-to type material. The Documentation page is more of an overview.
Golfing.
This is the natural conclusion of the ecosystem of language extension modules that have grown up around the Perl OO system, with Moose and MooseX::Declare only being the most visible. I for one would heartily welcome this, especially as it follows the very perly convention of explicitly turning on extra features like this. As the commenter mentioned, an optional new feature would be great as well, perhaps along the lines of a default: sub new { my $class = shift; my $self = {}; bless $self, $class; $self-&gt;init(@_) if $self-&gt;can("init"); return $self: } Thus you get a constructor if you want one, and can specify an init routine to customise construction as and when is required. 
Given all the styles of customization possible and useful, I'd rather use Moose than provide a default constructor -- unless it's tractable (and it's not, not anytime soon) to improve Perl 5's core object system to provide opaque objects and metaclasses.
Very nice. I use vim exclusively to write perl, and I've learned a few things from this.
So would (and do) I. It seems sensible though to codify some of these conventions, such as using new for the constructor, etc etc. for the basic use case of simple code reuse. This snippet is now uploaded to cpan as Object::New should anyone want to make use of it (pending namespace registration of course). 
Yes, that's what he (fayland) did: http://www.nntp.perl.org/group/perl.module-authors/2011/01/msg9076.html
with B::Deparse,I've written my own oop module (it was just for fun, not used in development). It uses B::Deparse just to get you the proper context and the right line when the program bails but basically it stores the result of each function call in a building block to recreate a oop like mechanism with no filter. In the end, you can do: package AbstractClass; use Serializer; use Iterator; use CustomModule; use oop; class { implements Serializer,Iterator; inherits CustomModule; protected static instances =&gt; 100; private method __init =&gt; sub {};#you cant instantiate it #implementation requires this public method encode =&gt; sub {}; public method decode =&gt; sub {}; public method next =&gt; sub {}; public method current =&gt; sub {}; #self is dynamically bound private function k =&gt; sub { self-&gt;instances++; return q[function call]; }; public method k2 =&gt; sub { my $string = shift; self-&gt;instances++; return $this-&gt;k. self-&gt;instances.$string; }; }; it adds class, inherits, implements, private, protected,public,method and function as pseudo-keywords, the $this in method and self in both function &amp; method,"__init","__destroy". even though i wanted to do: public method k2 { }; but sub(*&amp;) is not possible and here the article uses what it needs to do so (far beyond my limited perlish capacities) But anyhow, even if there is Moose, I would rather have a more classical oop interface. Most of the time, I have to work with people that knows java,php,python,actionscript,etc and if the "main layout" is somehow similar its quite easy to read for them and to adapt to perl,adopt perl. *wanted to call this "perl object oriented programming" but it gives poop.
 use strict; use warnings; use Path::Class qw( dir file ); dir('/tmp/')-&gt;recurse( callback =&gt; sub { my $file = shift; return if $file-&gt;is_dir; return if not -r $file; my $contents = $file-&gt;slurp( iomode =&gt; '&lt;:raw' ); printf "%s: %s bytes\n", $file , length $contents; }); Output: /tmp/foo: 312 bytes /tmp/foox/bar: 319 bytes etc.
Ah, there we go. He *did* do the right thing. &gt; please bear with my stupid Net::SMTP::TLS::ButMaintained, I hope I can abandon it asap. fayland++ 
There is already Class::Base or Object::Tiny. I would not keep this on CPAN if I were you in order to avoid some flames.
is something like this possible: { use feature 'oop';#only for this scope import all the good stuff }; or package myModule 0.1 { use feature 'oop'; #only for this package. } The 'oop' stuff is just an extension based on your 'method'. If it's not implemented by default into each packages but something you decide to use, I really don't see the problem? It would be a blessing to have some "classic" oop available in perl core. I would not have to try to explain to all the others the concept of creating an object or how Moose works (it's not in the core,it's not "classical" oop and I would feel more comfortable to know that it is done at a very low level by core members with portability&amp;speed) 
flame away. The other modules are nice, and no-one is forcing anyone to use what I might personally find useful. A diverse module ecosystem is surely a benefit?
&gt; A diverse module ecosystem is surely a benefit? not,surely.no. CPAN has so many modules, searching through the right one is always a pain... That's why many authors upload a new module when they think that it has not been done or that it brings something new to the table. Not only for the pleasure of diversity (I do not upload all my utility stuffs) I am not against diversity (would I be writing perl?) I am not for diversity for the pleasure of diversity. I am against possible noise in the ecosystem. Are you for noise in the ecosystem?(it's a bit the same general, not relevant question you've used but it's rhetorical) But if you are sure of your code, of your doc,your support and sure of the usefulness of such a module in regards to other module, I will not be the one to stop you and was just warning of possible results (and it seems you already got a flame burning in the CPAN rating systems waiting for you). 
Would the example with Term::ReadLine work with a sane keymap if one typed CTRL+[ CTRL+j ?
I'm betting that I'm not the only one that expected to see something about "priest, warrior, paladin, mage" within a programming context ...
Fair enough, point taken. I guess I will take this as a learning experience.
testfolder/.hiddendir/sf2.txt would be skipped so, use next if /^\.{1,2}$/ instead...
This post took me down the rabbithole of looking at the [source of Eval::WithLexicals](http://cpansearch.perl.org/src/MSTROUT/Eval-WithLexicals-1.001000/lib/Eval/WithLexicals.pm) to figure out how it does its magic. I have to say, that is some dense ass code and it sure took a lot of beard stroking but I think I've figured out what's going on and it's pretty darn ingenious. 
What do you mean by "classical" OOP? It looks very similar to [Simula67](http://chris.prather.org/a-little-bit-of-history.md.html), and I'm not sure how much more classical than that you can get. Also are Florian Ragwitz, Matt Trout, and Ricardo SIGNES not "core members"? They have all been release engineers for Perl5 over the last year, and all co-maints of Moose. Finally define "low level"? Moose uses XS to hook into the core Perl APIs for stability and performance. Moose has done so for nearly two years now. Considering how many people complained when we moved to an XS only Moose for stability reasons, I'm not sure how portability plays into this. The speed problems with Moose are not because it wasn't done "low level" enough, or that we dont' have enough "core members". They're because the problems are actually pretty difficult to solve in a robust fashion. Moose does a lot of work to make sure that a *good* Object System is bootstrapped on top of the bare bones assumptions Perl5 provides. Trying to wave the magic "Make it P5P's responsibility" wand won't make that go away.
&gt; The speed problems with Moose are not because it wasn't done "low level" enough.... In some cases they might be. One of the reasons I knowingly waste my time writing patches with little chance of application is that I want to prove to myself that some things are easier/faster/simpler done in core than as extensions.
&gt; What do you mean by "classical" OOP? See my other comment with a code example in this same thread (even though it was just based on a fun attempt with PurePerl so it is not perfectly what I call "classical" OOP). And by classical, you are right, the term is no the best one. Perhaps widely understood,documented or used is more appropriate. Here again in the same comment in the same thread: &gt; Most of the time, I have to work with people that knows &gt; java,php,python,actionscript,etc and if the "main layout" is somehow &gt; similar its quite easy to read for them and to adapt to perl,adopt perl. I could have added c#, c++ perhaps. But we go in lower level stuff here I think. You will admit that if Moose is closed to Simula67, it is far from the above ones. And I don't know how many jobs you get by knowing Simula67 but I do know how many jobs you can get by knowing the one listed above. (perl was not meant to get people a job may you say, soit, programmer will switch to whatever can help them get a job though) I said: &gt; It would be a blessing to have some "classic" oop available in perl core. It's not because people writing Moose are perl5 porters it means it should be in the core and means it fits what,in all respect, I and many consider "classical" oop. The code below is not the kind of program I want to write and is not how I enjoy perl: has 'node' =&gt; (is =&gt; 'rw', isa =&gt; 'Any'); has 'children' =&gt; ( is =&gt; 'ro', isa =&gt; 'ArrayRef', default =&gt; sub { [] } ); has 'parent' =&gt; ( is =&gt; 'rw', isa =&gt; 'Tree', weak_ref =&gt; 1, handles =&gt; { parent_node =&gt; 'node', siblings =&gt; 'children', } ); &gt;Considering how many people complained when we moved to an XS only Moose for stability reasons, &gt; I'm not sure how portability plays into this. I've always thought that Moose was in PP and that Mouse was the C version of it? When this change did happen?(I do not follow much Moose evolution) As for me, I see this change as a benefit as it can only promise better performance,better integration with perl. &gt; Moose does a lot of work Too much(before,after, around) and too few(private, protected,method)? When I look at modules written using Moose (or should I say "in Moose"), I always feel there is a mismatch between the Moose part and the perl part, where the code seemed glued together more than interleaved within perl in a native way. Where before,after,around,inner just enforce this feeling of a mismatch, a patch to glue this meta programming system with perl. Or when somebody who spent a long time abroad speaks a mixture of both language and culture. The perl community seems to enjoy Moose and all its feature, I must be one of those few (if not the only one) who don't. Perhaps the rewriting in C will allow for a better integration with perl and I am more than happy to see where this might be going. I am playing around with perl6 because the oop in there feels coherent with the language. even if have some little points that I dislike here and there, it is, in its entirety, coherent to my eyes. &gt;Moose does a lot of work to make sure that a good Object System This is where your view and my view of what is a good Object System diverges. I am unable to do what they've done and will stay with PurePerl, unless some Moose feature with a C back-end are shipped in the core. &gt; Trying to wave the magic "Make it P5P's responsibility" wand won't make that go away. You are interpreting my thoughts here. I said that I wanted to have a classical oop interface available in the core. (see above for classification of the term classical, i will stick to it though). What you're saying is that building something like Moose is hard. I won't say the opposite. It is just not what I am talking about and what I want in the core. It is just a concern for me to see that perl jobs get rare, that perl books get rare, that perl buzz get rare and that perl5 new versions does not bring any real oop support in the core. If perl was the new kid on the block (let's say like javascript+nodejs with its very impressive perf), it could be different (Javascript use prototypical oop with very few basic stuff -real private/protected methods,variables for example require some code convolution- but people learn it because of the advantage you get from both new browsers and now nodejs) And this is what was perl. I just think that inserting some oop in the core could only help get perl in the track but this is a feeling I have and might be under false impression. There're many environments where you get perl(5.8.8,no major reason to update for many people) but can not install any modules,especially C one. And if you say, install 5.16, they added this new oop mechanism, it is easier to sell than, install 5.16, I will be able to use a module on CPAN with oop mechanism(You also need to understand that I don't sell perl to perl people. They will not listen to your above explanation and would not understand it anyway) As for Moose, this meta-programming style could perhaps allow for RAD and ease OOP programming(easy to speech) but still will not erase the above perl-Moose mismatch. *my explanation goes a bit here and there, sorry! *also, what i consider low level is something done at the parsing phase of the source code,not afterwards. but I have too little understanding of this to say too much^^ 
&gt;Some flaws you can only truly fix within the language itself, and not in its ecosystem. I agree so much. *the other way would be to use B:: modules to rearrange the optree afterward?* The class keyword would also be welcome. But a class keyword and a method are nice but what about expressing encapsulation via private/protected/public keywords(public could be the default so only private/protected)? Also regarding the warning, it could allow to have a UNIQUE common message as everyone who does implement this kind of checking create its own error message or error mechanism. &gt;Perl could detect the invocation of a method as a function and give a warning (which you could promote to an exception with use warnings) In fact, when you take this into account, a method keyword is not only one line saved. but nobody does the checking... package DOOM; sub new { bless {},shift } sub public_method { my $this = shift;#really? $this-&gt;{_private_}=shift;#REALLY? } DOOM::public_method({},'bazinga'); writing this: package DOOM; use Scalar::Util qw(blessed); sub new { bless {},shift } sub public_method { my $this = blessed $_[0] &amp;&amp; blessed($_[0])-&gt;isa(__PACKAGE__) ? shift() : die 'a custom message different for everyone'; return $this-&gt;{_private_}=shift; } 1; package main; my $obj = new DOOM(); print $obj-&gt;public_method('hi'); print DOOM::public_method({},'hi'); is too much for what should be done automagicly. 
the use of print &lt;&lt;"LEGEND"; leading to \\ instead of print &lt;&lt;'LEGEND'; and the lack of new line between the code let me perplex but the article was interesting!
If you have used memcache, you already know the quality and speed you get from products from [Danga](http://www.danga.com). Ive used Perlbal both for work and private projects, saving both developer time and hardware. 
I'm all for your patch efforts. Please don't let anything I say here dissuade you from continuing with them. That said, bootstrapping a Metaclass system wont' happen with a `method` or `class` keyword alone. Normalizing the Package/Stash, Global Destruction, End of Scope and other APIs are invisible issues that cause pain to the Moose core. The need to evaluate lots of code an inject it at compile time won't disappear either with out *lots* of refactoring to core. Refactoring that I can't see getting past the p5p gauntlet anytime soon. I think your efforts in getting people to think about what *could* be in core benefit us. When I look at Moose though, it's problems aren't what's possible, but the realities of the interpreter we have.
Currently, I'm using Pound and Varnish - why should I switch? (serious question, not trying to be snarky)
You dont :) Both pound and varnish is great products, and are doing a great job for me too. For me perlbal is great when I want to do more that what tools like that can give me; written in perl, and semi-simple to extend. 
What kind of stuff do you do with it? I'm mainly just doing static caching, and simple load balancing.
Perlbal; Serving small images from a huge binary blob instead of using a filesystem (~100000 images), offloading a application server by doing some small checks and logic on the request before passing it (or not) to the heavy application backend. varnish; cache, cache, cache :) pound; ssl proxy
Awesome, thank you very much.
CGI? Really? This is only years late. If you're still using CGI instead of one of the many awesome frameworks out on CPAN, many of them support Plack. Why not even code for Plack directly? Even that would be cleaner and more readable. [8]
I'd rather have a class and a method keyword added in the core soon than having all the efforts focused on a meta programming paradigm that dont quite fit it (my opinion it is). Hope chromatic suggestions will make it to the core 
Shame, doesn't work on windows. :(
I love Perl, but this doesn't give great reasons to stick with the language, or even why CPAN is great. It just outlines one good experience with the Perl community.
Try reading the comments. :) Someone else there also missed what he was trying to say and it's explained a bit more explicitly.
fileserve.psgi: use strict; use warnings; use Plack::App::Directory; Plack::App::Directory-&gt;new({ root =&gt; "/tmp" })-&gt;to_app; run a stand-alone static file server: plackup fileserve.psgi run it as a cgi script: #!/usr/bin/env perl # This is the PSGI &lt;-&gt; CGI connector. use Plack::Loader; use Plack::Handler::CGI; my $app = Plack::Util::load_psgi("/path/to/fileserve.psgi"); Plack::Handler::CGI-&gt;new-&gt;run($app); Less bugs. More features. Less code. 
Python has it too, so it is better written as "Perl has more fun" :)
Community is a big part of a langauge IMHO. I've made choices on other things based around the helpfulness of the community, the infrastructure around it and so on and so forth. Python, PHP, Perl and Ruby can pretty much do the same as all the others. I'd be hard pressed to think of something to do in one that you can't do in the other. Personal preference comes in for syntax and semantics. The rest is all about the tools and community as far as I'm concerned. Perl's got that in spades.
The linked article "Python is better than Perl6" did more to sway me to stick with Perl than did this tbh. I'll admit the author has some fair points of criticism against perl5/6; however the piece is not internally consistent with itself, and the author seems to be unaware of the larger body of Perl work, having admitted only to using it as a one-liner language for the most part, rendering much of the criticisms invalid.
This is a really nice idea and i'll probably contribute one, but i can't help but think that this kind of thing would be better served by being in a wiki.
Perl 6 changes everything but `print` syntax. Python 3 changes nothing but the `print` syntax. Since they both break syntax backwards-compatibility in doing so, why isn't Perl 6 allowed to use the Perl name by your logic, when you're not also arguing for Python 3 to be renamed "PEP3000lang"?
kudos to LeoNerd for writing IO::Socket::IP as a temporary solution. I was quite surprised to hear that the recent Perl (5.10.x) didn't have complete support for IPv6! I would have thought that was core many years ago.
I am definitely going to try this out once I get on a computer that has a proper Perl install.
woot!
awesome, thanks for all the hard work!
I like this idea.
Me too!
1995 called. They want "ping -a" back.
I do similar to work around an annoying issue on my file server. Occasionally networking just..dies. If I /etc/init.d/networking restart, its fine. Still don't know why. So when I reboot, I type this in a shell, because I'm still too lazy to actually save it somewhere: while sleep 5;do fping 10.0.0.1 || sudo /etc/init.d/networking restart;done Work's pretty well, it doesn't even interrupt a streaming movie over nfs or samba. You could make it let you know changing the || sudo to &amp;&amp; say, but as pointed out in another reply at that point you might as well just let ping beep the pc speaker.
I agree, the perl section of the article needs a few fixes. But please, for the love of FSM, can we focus on tone when we're speaking on behalf of the Perl community ? In that regard I must say I like what I see on stackoverflow and perlmonks. Perlistas being helpful and nice. However I don't think the comments on that page make us look good. &gt; "Do people still "use CGI;" in 2011?" Yes, they do. Not everyone is on irc.perl.org or reads perlblog and knows about Plack, and it's fine really. People using Perl is a nice thing. We shouldn't scare them away by telling them they're wrong before even trying. Let them use CGI if they think it's easy, we'll tell them about our dear Moose, Plack, DBIC, Catalyst and POE later when they're hooked. They might even find out by themselves :) I'm sure a few will love it. &gt; all you're doing is making people cry who spent a decade of moving the Perl world towards a modern Perl They're also probably making a few readers go "oh, this looks farily simple. I thought perl was an unusable dinosaur, I should try this". I know a few will end up on #perl@freenode asking questions they should have googled, but I think we should let them **get there** at least. If only to be called names by our dear mst :D (i like mst's rants, don't deprive me from a regular source of entertainment)
If I'd make any reply to that article, it won't be as a Perl-fan, but as a fan of articles that are written by people who at least have a good idea of what they are writing about. (And my main problem isn't the outdated Perl, but the blatant security flaws...)
Well they ought to have used placeholders. &gt; $query = qq{SELECT id FROM users WHERE username = "$username" &amp;&amp; password = "$password"}; &gt; $query = $DBH-&gt;prepare($query); &gt; $query-&gt;execute(); And they should not promote mysql-specific SQL (double quotes). That should have been $query = qq{SELECT id FROM users WHERE username = ? AND password = ?}; $query = $DBH-&gt;prepare($query); $query-&gt;execute($username, $password); But for the rest it doesn't look half bad. 
The problem is also that you probably haven't really read the article and just skipped to the perl section armed with your pitch and fork. There **is** a disclaimer about security : &gt; What is not included in the article? [...] &gt; It is also important to note that, security, e.g. checking the user's input for possible data and system threats, is not a topic of this article.
Here's a reason to use CGI: you have a lower traffic website in a cheap shared hosting environment, you have well crafted CGI code that works from older projects that could live happily there, you don't have access to installing from CPAN and are not tempted to try to compile on the provider's system, most of your content is not dynamic anyway, and you're confident in the solidity of your slightly out-of-date Perl, because you learned about taint, SQL injection and the shortcomings of js validation long ago.
I have a good understanding of perl got countless books. problem is I mainly do front end and graphic design. In the little time I have available I want to get started learning a perl framework that is easy to start with and flexible enough. I've been procrastinating for ages. first I got interested in catalyst, then mojolicious now plac. Any suggestions? Any good books/websites on plac? EDIT: ok reading the comments, i think i'm better off working with mojolicious as I'm not good enough to work at the lower layer
That might excuse not writing every possible security check, but it in no way excuses going out of your way to write dramatically insecure code.
Many simple CPAN modules do not require installation, Mojo and CGI::App frameworks also can be run this way.
 "Many simple CPAN modules" !~ /^(?:most|all|the other ones you happen to need|etc)$/ ...so I'm missing your point. 
I agree! Also no where in the article does it say copy and paste this code into your enterprise system as is. When I was new to programming finding and using small clean code examples to use as a starting point to build off of was invaluable. As I built things I got smarter, started to see the repetition and security flaws, and learned OO Perl, then Moose, tainting and un-tainting user input, bind variables, etc, etc, etc... I don't know that I would have stuck with learning programming as a kid if every-time I wanted to build a cool little game in BASIC people on forums (thank god there was no internet then!) would have roasted me for not already knowing all the wisdom it took them years to acquire. 
They must have updated the article. That's what I see in it. Also, why don't they hash the passwords? 
It's windows specific =/ ....but if you install Term::ANSIScreen, it will colorize the matches.
Might be nice if it took parameters the same way that grep does...
The only thing making it windows specific is the call to cls. If you check `$^O`, you can then make it work on unix based machines as well.
&gt; When I was new to programming finding and using small clean code examples to use as a starting point to build off of was invaluable. There's no excuse for the people who post examples for people to copy and paste to write bad code. They're doing their readers a tremendous disservice.
Always fun to play. But in case you want a full-blown tool, you should look at ack if you're not already aware of it. It's not 20 lines, but it kicks ass. http://betterthangrep.com/ 
It wouldn't be a Perl thread without a regex. :D
You shouldn't use the 2 argument open(), especially not without checking the user args. Imagine if somone invoked the program as grep 'a;del C:\SYSTEM /f/q' ( I'm a Unix guy not a Windows guy, so I may not have the attack quite right, but you get the idea, I hope.) If you use the 3 argument open(), there is no possibility for error, the filename is only interpreted as a filename, it cannot leak into the command passed to the shell: open my $file, '&lt;', $ARGV[0]; Even then, the argument is considered 'tainted' and should not be used without decontamination, i.e., testing to ensure it only contains valid data and not anything harmful or dangerous. For example, you could determine whether the string contains a semi-colon or other strings not allowed in a filename; some characters might need to be escaped. You should also check for errors on the open(). The easy way is to use autodie; which will add error checking to most common system calls. Other wise you need to check things yourself: open ... or die( "Could not open file '$ARGV[0]' : $!" ); Further to gms8994's comments, I wonder why you have 'cls' at all. With 'cls' the output is displayed all by itself, no distracting just. But if you want to string together a number of commands in a script to present some useful information, the 'cls' is a barrier. If you want to call grep and capture the output, and use that information, 'cls' is totally irrelevant ... and might remove some information you are trying to present. On the other hand, if you want other data removed, you can use a cls command prior to calling grep.
&gt; you don't have access to installing from CPAN If you have access to run the CGI, you have access to run code from CPAN.
&gt; Also no where in the article does it say copy and paste this code into your enterprise system as is. Nowhere on power outlets does it say to stick a fork in there, but people are still dumb enough to do it.
Could you edit the OP to use code formatting? Kinda hard to tell what's going on.
but... but... ok, you're right, haven't seen that part :)
TIL 3 argument open() is to file operations what parametrized queries are to sql.
&gt; There are, good, Perl programmers out there that are using CGI that are ALREADY well aware that it is not ideal and don't need to be reminded/insulted about how much it sucks. I agree completely. There are valid reasons *not* to use Plack right now--it needs more documentation, it's just over a year old, migrating working legacy code is a business decision and not solely a technical decision, to start--and any so-called Perl fan who suggests that you're any less a coder or that you've made bad technical choices is doing both you and the Perl community a disservice. There's no excuse for that, either.
Eventually this is my plan but I wanted to have a portable tool I could use on the fly.
typing this from memory... while (&lt;&gt;) { print if (s/$ARGV[1]/colored['bold red'] . $ARGV[1]. colored['reset']/egi) } # explanation: s/// returns the number of substitutions done, if there weren't any, your match did not appear s///e tells it the second half of the substitution is perl code and to be evaluated s///i you already know is case insensitive s///g tells it to repeat for every match not just the first one. for brevity I used &lt;&gt;, others have already commented on opening the file.
I find that the pp command that comes with PAR-Packer works fairly well with strawberry perl on windows.
I'm currently using ActivePerl -- would you recommend Strawberry over it? Thanks for pointing me to pp -- I'm going to do some research :)
Check out the `-n` and `-p` options for Perl, as documented [here](http://perldoc.perl.org/perlrun.html#Command-Switches). They replicate the whole "iterate over each line in these files" logic so you don't have to include it in your script. Also, remember these in *every* perl script: use warnings; use strict; You'll thank me for it sooner or later.
Strawberry Perl works better with CPAN, which can be a big advantage over ActivePerl.
I like this idea, but it returned a bunch of garble.. ARRAY(0x249b8c)mARRAY(0x1886dd4)aARRAY(0x186c1bc)kARRAY(0x18af91c)eARRAY(0x24b82c) ARRAY(0x24b8ac)tARRAY(0x24b9 2c)hARRAY(0x24b9ac)eARRAY(0x18a1f3c) ARRAY(0x18a257c)aARRAY(0x18a25fc)pARRAY(0x18a267c)pARRAY(0x18a26fc)lARRAY( 0x18a277c)eARRAY(0x18a27fc) ARRAY(0x18a287c)sARRAY(0x18a28fc)aARRAY(0x18a297c)uARRAY(0x18a29fc)cARRAY(0x18a2a7c )eARRAY(0x18a2afc) ARRAY(0x18a2b7c)tARRAY(0x18a2bfc)hARRAY(0x18a2c7c)eARRAY(0x18a2cfc) ARRAY(0x18a2d7c)tARRAY(0 x18a2dfc)rARRAY(0x18a2e7c)uARRAY(0x18c280c)cARRAY(0x18c288c)kARRAY(0x18c290c) ARRAY(0x249b8c)tARRAY(0x1886dd4)hARRAY(0x186c1bc)eARRAY(0x18af91c) ARRAY(0x24b82c)aARRAY(0x24b8ac)pARRAY(0x24b9 2c)pARRAY(0x24b9ac)lARRAY(0x18a1f3c)eARRAY(0x18a257c) ARRAY(0x18a25fc)sARRAY(0x18a267c)aARRAY(0x18a26fc)uARRAY( 0x18a277c)cARRAY(0x18a27fc)eARRAY(0x18a287c) ARRAY(0x18a28fc) ARRAY(0x249b8c)tARRAY(0x1886dd4)rARRAY(0x186c1bc)uARRAY(0x18af91c)cARRAY(0x24b82c)kARRAY(0x24b8ac) ARRAY(0x24b9 2c)bARRAY(0x24b9ac)aARRAY(0x18a1f3c)mARRAY(0x18a257c) ARRAY(0x18a25fc)tARRAY(0x18a267c)hARRAY(0x18a26fc)eARRAY( 0x18a277c) ARRAY(0x18a27fc)iARRAY(0x18a287c)tARRAY(0x18a28fc) ARRAY(0x249bec)tARRAY(0x18a29fc)hARRAY(0x18a2a7c) eARRAY(0x18a2afc) ARRAY(0x18a2b7c)fARRAY(0x18a2bfc)oARRAY(0x18a2c7c)rARRAY(0x18a2cfc)eARRAY(0x18a2d7c)sARRAY(0x 18a2dfc)iARRAY(0x18a2e7c)gARRAY(0x18c280c)hARRAY(0x18c288c)tARRAY(0x18c290c) ARRAY(0x249aec)tARRAY(0x18c2a0c)hA RRAY(0x18c2a8c)eARRAY(0x18c2b0c) ARRAY(0x18c2b8c)tARRAY(0x18c2c0c)hARRAY(0x18c2c8c)eARRAY(0x18c2d0c) ARRAY(0x18 c2d8c)
everyone tells me this :) 
this is most excellent! Thanks for sharing
Agreed, its also an important lesson in learning perl - More often than not, someone else has already done it, and probably did it better.
For people who're wondering just what is so bad about this, an incomplete list: &gt; use CGI qw(:all); The qw(:all) is useless since none of the functions that exports into the local namespace are used. &gt; use DBD::mysql; This is entirely unnecessary. DBI will load the driver on its own. &gt; lack of strict/warnings ALWAYS use strict and warnings. No exception. &gt; lack of "my" Always declare your variables. &gt; upper-case variable names Those are reserved for constants by community agreement. &gt; indirect new incantation use "Class-&gt;new( @params )" instead of "new Class( @params );" &gt; inconsistent indenting Decide on one style and keep it. &gt; empty parens after a method call "$obj-&gt;method" is more readable than "$obj-&gt;method()". &gt; $ref-&gt;{"id"} Don't put useless quotes in a hash key. &gt; writing json manually instead of using JSON There's a perfectly fine module that'll generate JSON from native Perl data structures. Use that. &gt; using the ternary operator Terrible to read, use subroutines and return instead. &gt; using CGI, but returning one's own header instead of using CGI's You load the module CGI and then print a header, when you could instead use the header() method provided by CGI to generate one. &gt; the || 0 part is completely useless The 0 will never ever make a difference in the code as it is, even with strict on. &gt; || "" on a variable that is meant to contain a hash ref and then doing $ref-&gt;{id} This will cause a compiler error when no row is returned by the database, because it'll try to dereference a string.
You may have problems with PAR::Packer on ActivePerl if you install it from ppm, but you need just to try. There is also perlcc, but it may just not work for your program (it is still in development stage). staticperl will not work on Windows (it requires bash). Strawberry+PAR::Packer is the best variant, Strawberry is slightly harder than ActivePerl for beginner. There is also Portable Strawberry which does not require installation. 
And they're right.
| I'm a Perl newbie Welcome on board ! :) 
I didn't know about ack. Thanks! I've already added some filetypes to it. (even though it says not to edit the standalone code &lt;g&gt;)
Now, if only we could rename this to perl6, rename the artist formerly known as perl6 to something else, all together, and we could all be one big, happy, less squabbly family. But alas, such can never be.
oops -- you had periods where there should have been commas :D 
And change foo-&gt;bar to foo.bar :)
It says don't edit the code because you can add filetypes via `.ackrc` already.
 use warnings; use 5.012; 1 byte shorter and gives you more stuff.
In addition to what everyone else has said, you shouldn't re-compile the regex for each line, that's going to lead to horrible performance.
*drools*
Going to add a +1 for suggesting PAR::Packer Works like a charm most of the time on Strawberry Perl. (Which I also recommend over ActiveState)
Web::Simple might be a good idea
Some other options that haven't been mentioned: * ActiveState's [PerlApp](http://docs.activestate.com/pdk/6.0/PerlApp_overview.html) / [PerlCtrl](http://docs.activestate.com/pdk/6.0/PerlCtrl.html) / [plc](http://docs.activestate.com/pdk/6.0/PerlNET.html) * [Cava](http://www.cava.co.uk/) * [PerlBin](http://sourceforge.net/projects/perlbin/) * [PerlToExe](http://github.com/mauzo/ExtUtils-PerlToExe) * [pl2bat](http://docs.activestate.com/activeperl/5.10/bin/pl2bat.html)
There is no such thing as a free lunch :) that said, it usually comes out of production code--- well at least it gets commented out, as it might well go back in for debugging and such like...
This is nice. Video format is annoying though... CPAN doc: [perl5i](http://search.cpan.org/~mschwern/perl5i-v2.5.0/lib/perl5i.pm) You get many helper functions that everyone has rewritten once its life but for free (there's so few string,array functions by default) You get rid of this very annoying true value at the end of the module... It was always a "pain" to explain (it's easy to explain, but I always get the wtf? eyes in return...) I did implement this with a filter once but never used it (too scared to mess things up!) but I guess I can trust better Schwern and all the contributors to have done a perfect job! - croak and carp by default, is welcome (I always "inherit" them from a base class) - CLASS keyword is so much nicer on the eyes and shorter than PACKAGE ... and you can use it in a interpolated string! - a nicer try {}catch construct - $module-&gt;require is very welcome instead of the ugly : eval qq[require $module] or die $@; - autoboxing with chain calls for a fluent API is very nice Basically everything I've done in one ugly and not reliable home-made module(never used in production lol) is now available and done by well-known perl programmers! use perl5i is a gap though.It's Like if you were not writing perl anymore. I would have appreciated a pragma like use enhanced or something like that but that's a detail... The video format is not the best one. Especially the platform does not allow to goes forward as long as it has not been streamed... A version on YouTube splitted in 15 minutes bunch would be welcome (and augment visibility) 
perl -wnl -e '/something/ and print' filename
I hadn't yet read the docs, but I did look at the code. It was obvious what that hash was for, so I edited it. :-)
and you ignore 'everyone' because?
hehe, those pesky warnings -- always getting in the way of my script that is already running halfway off the track ;)
you're absolutely right, and you'll find out soon enough why that's dead wrong. :)
...but not portable to earlier versions of Perl. If your script is going to be released into the wild then this might be a limitation.
Nice! I got a coupla suggestions on Perl style for you, though: Stick this at the top of your code: use strict; use warnings; They produce errors and warnings if you try to use some of the darker corners of the language that can cause bugs. Highly recommended for every new Perl program. Unpack your arguments into named variables first, it makes the rest of the code much easier to follow. Like this: my ($filename, $search) = @ARGV; Using lexical filehandles (ie, variables, rather than bareword `FILE`) is far less prone to error (and means you can pass around your filehandle just as you can normal variables). Also demonstrated here is the three-argument form of `open` (which is much safer), and the use of an explicit `die` if the open fails, as perl will quietly continue otherwise: open my $fh, '&lt;', $filename or die "Can't open file '$filename': $!"; Otherwise, good job man!
I love it ! kudos to everyone involved in the project. The homepage looks modern, concise, and the logo just plain **rocks** 
Indeed! The website is nice! All these frameworks mushrooming is a very good thing!
You don't have to explicitly open a file, you can just read from `&lt;&gt;`. That would imply to swap the (optional) "file" and "pattern" arguments. Just as in real grep. my $pattern = shift @ARGV; while(&lt;&gt;) { ... } If you don't like that, and you insist on using a file parameter, you can use "-" to pipe in from STDIN. 
&gt;Video format is annoying though... I have this talk in avi format...53 minutes, 120mb - if people are keen I could work out a way to get it to interested redditors.
squabbly family? it's not 2005! Only peace and love between perl6 and per5 these days to the best of my knowledge.
A year ago I wrote the site usinfg CGI::App with most modules simply copied by ftp. Several modules that required compilation I simply unpacked from FreeBSD binary packages. I only had problems with DBD::SQLite because it depended on sqlite library which was not installed and was required to be in certain place.
this. I had some major problems getting it to work on a 64bit windows box, and ended up giving up. But on a 32bit architecture + strawberry, it just works.
The site is a perfect match to the framework's philosophy. Clear and concise (and visually great as well).
Wow, this is *exactly* what the Perl community needs. Great work!
thanks a lot for this warm welcoming! Kudos to the artist who designed the new website: http://twitter.com/Oxide
When looking at the website I want to dance ;)
Does anybody know the source of those "fork me on github" diagonal things? I'm seeing them on all the crazy new hipster frameworks. Is it from somewhere on the github site, or do they all just rip each other off wrt the graphic? Edit: [Nevermind.](https://github.com/blog/273-github-ribbons)
I think what I was actually missing was \" at the start and end of the substitution. You could try that. Or this should accomplish the same thing better: $highlight = colored['bold red'] . $ARGV[1] . colored['reset']; while (&lt;&gt;) { print if (s/$ARGV[1]/$highlight/gi) } (again from memory, sorry, I'll try them out myself later)
I added commas in place of the periods -- it works and colorizes it, but only if I have static text instead of $ARGV[1] -- why's that?
And yet the main distros are just barely adopting 5.10. I seriously doubt we'll get approval to compile our own newer Perl anytime soon. I guess my point is I'm pissed at Redhat for not going for 5.12 in RHEL6.
Here's the funny (in a sad way) part: Red Hat offers no meaningful support for Perl 5. For the cost, all they can offer you with regard to Perl 5 is that no update from them should break any of their system tools which depend on their ancient Perl 5. Hooray, I suppose.
Perhaps if the regex is complex, but in an IO bound program it's likely irrelevant.
Consider Dancer http://perldancer.org/
So confused...why are people hating this post? (not a web developer)
I think you want this http://p3rl.org/File::ReadBackwards Also, you can use the unix tac command.
You can also read backwards with [IO::All](http://search.cpan.org/~ingy/IO-All-0.41/lib/IO/All.pod#___top): my $io = io('file1.txt'); $io-&gt;backwards; while (my $line = $io-&gt;getline) { # ... } Ninja edit: I just noticed that it uses `File::ReadBackwards` under the hood.
Does it have to be perl? Something like this comes to mind... | tail -1 | cut -f1 -d ","
From a POSIX point of view I'd say that the fastest/easiest way for a file would be to mmap() it and then search for a "\n" in reverse starting from the very last byte (disregarding any "\n" that is in the very last byte). That makes it a very straightforward "for" loop and puts the onus on the kernel for all the buffering. For a FIFO, have a buffer that gets reset every time you see a "\n" and appended to for any other character. When it closes you have the last line. Not sure that is worth writing in Perl--it's pretty much exactly what tail does. In fact tail on a file probably does what I said in the first paragraph.
Because we're questioning the status quo, it frightens people.
Clicking the logo 404's
[Working link](http://search.cpan.org/perldoc?File::ReadBackwards) 
This. Also links on the right of logo do not seem to work.
That'd be much appreciated. I'll host it on my httpd as well.
&gt; suggestions for new documentation topics are always welcome Okay, here's one I spent an hour looking for yesterday and couldn't figure out. How the heck do I include one template from another, or return in the middle of a template, if that's even possible?
Thank you! Also hosted here now; http://perl.japh.se/Osdc-perl5iPerl5Improved.avi
This. The others require you to slurp the whole file in memory which is not always practical and never efficient.
This works on Perl too (but it's more for processing the large file, not "reading just the last line" :)) http://www.dabeaz.com/generators/
This x10. Not everything needs to be done in Perl (sacrilege here, I know.).
If reading from a file and you have a rough idea of how long lines are, use the builtin seek() function to position yourself near the end of the file, then search for the last line from there. Note if the last line can be unpredictably long, this won't work. * http://perldoc.perl.org/functions/seek.html 
Yup, both of these are things I mentioned in my post.
Python and golfing is way, way behind the perl phenomina.
I should clarify that we use CentOS, not RHEL, so we pay nothing for the privilege of having an older version of Perl. 
Wow, IO::All is pretty awesome. I was just looking over all of its features. Thanks for pointing that out.
at first i thought this was a modern::perl like thing, but its not, and it strikes me that perl5i is not a good idea by claiming perl5i will break with perl5 at some point, schwern is essentially forking perl. please don't: 1. the fork will fail 2. even in failure, it will sit around the internet and confuse people perl5 itself is proceeding nicely. perl6 is proceeding nicely. so we've got evolution and revolution covered. 
why would you want to replace perl6 with this? perl6 is game-changing. perl5i is just another moose/modern::perl style "lets fix it" bandaid, except unlike those noble efforts, this one promises a potential to break compatibility
&gt;Until then the module is hosted in github and can be used and tested : Way too hard. Why no beta on CPAN?
Exactly!
Because it tries to prove vti is copying features implementing OO module from Mojolicious with a screen shot showing nothing but a "`use OOModule 'superclass';`" statement. It's very arrogant to think you're the inventor of a (rather obvious) common Perl idiom, especially if hardly anybody is using your module (because it's impenetrable because it's, well, so monolithic.) 
The [cpan testers](http://www.cpantesters.org/) would be more than happy to test your version VV_XX (i.e. 0.99_01). Versions which end in a "minor" _XX are "development" versions.
Where were you 8 months ago when I needed this? Meh. Got laid off there anyway.
Another great article from chromatic!
perl5i is a CPAN module. It's not a fork. And it's not going to "break with perl5". If anything, it will be not backwards compatible with its *own* previous major versions.
i will put on cpan too , i'm new to cpan system 
This does a perfect job of explaining why technologies like Plack matter, really enjoyed the read.
Double-click to go to the next slide (der!) An excellent read!
Or hit the space bar or the right arrow.
why use $json = qq|{"error" : "username or password is wrong"}|; for a string that does not need interpolation? and why not simplify the script too: my $json = q|{"error" : "username or password is wrong"}|; if (my ($id) = $sth-&gt;fetchrow_array) { $json = qq|{"success" : "login is successful", "userid" : "$id"}|; } 
You can get a variety of string trimming functions from CPAN. As for the second part, your question is very ambiguous. You want a module to get a basename function, but using a module that gives a basename function is bad? That seems to contradict itself. Are you maybe looking for something that acts like PHP in that it throws a thousand functions into your local namespace at once?
Yes, good question. I do want those thousand functions in my namespace. It wouldn't be for serious projects, but to get something done quickly in a few lines, it would be fantastic. What I mean to say is, importing File::Basename and another module for each new function I want is seemingly too much. Why not just import everything at once for small scripts?
You could use [ToolSet](http://p3rl.org/ToolSet) to build your own "includes everything under the moon" module.
Wow that's very useful for when I want to make a library of modules for myself next time. I will bookmark that. But what I'm really looking for is something like http://phpjs.org/ where they actually built the framework.
Perhaps you should take a look at [perl5i](http://search.cpan.org/dist/perl5i/)
[If you](http://search.cpan.org/~karasik/PHP-0.12/PHP.pm) really [want to](http://search.cpan.org/~ambs/PHP-Include-0.30/lib/PHP/Include.pm) write [PHP code](http://search.cpan.org/~aff/PHP-Interpreter-1.0.2/lib/PHP/Interpreter.pm) in Perl, [then go ahead](http://search.cpan.org/~kudarasp/PHP-Strings-0.28/Strings.pm). That's generally pointless though as Perl [has everything](http://search.cpan.org/~miko/String-Util-1.01/Util.pm) already. The whole point of putting everything in separate modules is that you only pay for what you use. Loading 2000 functions per invocation isn't free, and Perl's parser isn't particularly optimised for the rapid fire CGI request use case like PHP is.
Because the Mojolicious users are too busy getting stuff done to upvote on reddit :)
Maybe because the new webpage was expected for some time now, and no one expected (and cared) about the banner.
I see a couple of reasons: * A banner vs a web page? Come on, it's not even close in the level of effort. * While pretty nifty, Mojolicious doesn't seem to be a good CPAN citizen. Maybe it's just the reputation, but instead of improving existing CPAN modules and other Perl projects, it's all isolated preferring to build their own instead of reusing. That's just not very Perl like.
&gt; That's just not very Perl like. Regardless of the quality of Mojolicious, that isolation makes the project less appealing to me personally. The irony of certain contributors to a project devoted to reinventing every wheel complaining that other projects are similar is... ironic.
You mean too busy trying to get it to run?
The lack of documentation is certainly the reason leading to discover that "The code is unreadable or is poorly written". There're many good modules that suffer of such a lack of documentation that you do reinvent the wheel (because reading somebody else code,especially in perl, can be a very hairy thing to do). 
I voted down because come on, if you put a new link each time you get a new banner, this is going to be a real mess here... but the down vote was not about the project itself. Indeed, there seem to be too much of "reinventing the wheel" philosophy (why not use JSON? or why recreate an other template engine instead of using Text::XSlate or Template::Toolkit for example both run in either XS or PP)... but on the other hand, you get a coherent API,coherent documentation, coherent style in the source code, coherent versionning style,no "why you used this module instead of this one?" critics (well, you do get the "why you don't use any module??" lingo though),etc. Not all is bad in this philosophy even if it feels it is going too far (after all, an adapter around a module to make it coherent with the rest of the Mojolicious API is certainly faster to do than reinvent it.) if I find that installing Catalyst is a real nightmare because of too much dependencies, Mojolicious goes the absolute other way. There is a middle. But when somebody reinvents the wheel, you still can get the surprise of getting a real rounded wheel. so why not. 
I did not downvote because of the project, but because the link was worthless. What did the banner look like before? Why was it changed? The link should've led to the answers to those questions.
But then why not call it MetaResourcesFromGitHub? And what if someone wants to pull resources for BitBucket? MetaResourcesFromMercurial? Poorly named...
On the other hand I am glad that there is such a project in the Perl world - let's see how far that can lead.
Did you have any problems with it? Report them at bug tracker: https://github.com/kraih/mojo/issues
I like it because it reminds me of Neuromancer.
Certainly; I also am glad Mojolicious exists. It's valuable to explore other design constraints (minimal dependencies, rethinking the design of well-used modules and interfaces). Yet the project's relative isolation of within the Perl ecosystem gives me pause.
No, it does exactly what the name says. It's not specific to github, but it *is* specific to git.
Ooooo you bitch! :p
Excellent link, I'm going to try this out.
&gt;"The fun doesn’t even stop there: we can also build development versions of perl, and build perls of the same version, but with different building arguments (with/without threads, for example)." Oh my.
That's hot.
Yup, the Perl cosmos runs the gamut. You have all inclusive frameworks like Dancer (pretty much) and Mojo (totally) and bring in half of CPAN frameworks like Catalyst. Choose your poison.
Why not just keep perl in a different directory and either add it to your PATH or shebang?
perlbrew automates that and allows you to switch between those installations trivially.
Perl programmers are very conservative, Mojolicious is breaking with traditions to create something entirely new, explore options nobody else dares to. While i sure hoped for more open-mindedness by now, these reactions are no big surprise, it was almost the same situation when i started Catalyst back in the days. ;) And considering that Mojolicious already has the second biggest community of all Perl web frameworks around it (right after Catalyst), i believe we are on the right track.
An illustration like the one on http://mojolicio.us takes a lot of time and effort, when was the last time someone has done something similar for a Perl project?
Who did complain?
Catalyst started out the same, it took years until people like you recognized it.
Rather bad examples, Mojo::JSON is 3 times faster than JSON::PP by now and Mojo::Template predates Text::XSlate by a few years. Actually i'm quite sure Text::XSlate was even influenced by Text::MicroTemplate, which happens to be a fork of Mojo::Template. Mojolicious is an experiment in usability without compromises, i too believe in a middleground solution, but would like to explore both extremes to get a feel for the right balance first, adding dependencies again is easy. ;)
Properly reported bugs are usually fixed within hours.
In my experience, a new Mojolicious user has his first app up and running before users of most other Perl frameworks are done with the dependency installation...
I agree, the banner is probably way more work.
&gt; Mojo::JSON is 3 times faster than JSON::PP by now Perhaps because they have a XS back end that is very fast and does not focus much on PP? the "by now" is important here I guess too. Is the PP version faster because it handles less possible use cases (do they pass a same test suite?)? Does Mojo::JSON offers a XS back end to get extra speed if the environment allows it? as for Text::XSlate that Mojo::Template precedes does not mean that much because there were other template engines before that and before that... It seems to be an exercise in the perl community to build its own template engine... If you bring the speed subject in the case of Mojo::JSON in a PP environment, what about the speed of this engine in both PP and XS environment compared to Text::XSlate? I think that reinventing everything from the ground up is a waste of time unless *every* Mojolicious packages bring something new compared the other ones (it could be simply speed, good doc,better API (this last 2 subjective though,etc) in which case, they can go on! Having a coherent API, coherent source,coherent doc is something that is very valuable anyway but I do feel being that extreme is certainly slowing down the project. They could be focusing more on the framework high level architecture rather than focusing on what should certainly be a point of detail for the end user and for them too. &gt; adding dependencies again is easy indeed. I am willing to see how this is going to evolve anyway! as I said they might be crafting a rounded wheel^^ 
Start simpler. My first real Perl app was a CGI script that generated input questions for a pre-fabbed Madlib story in the GET, which was parsed and displayed in the POST. Sounds silly but it's a good place to start as it has a purpose and can incorporate a huge variety of staple technologies. It's not necessarily a test in efficiency to start, so be creative and wasteful just to mess with the data and logic structures. Start with as much static content as you can, then work your way up to mostly/entirely dynamic. If you're not interested in CGI, consider messing with DBI or other modules that may help you use Perl as duct tape for your otherwise C/C++/Java systems (try re-writing an old maintenance app in Perl), or automation of system administration tasks. I'm sure some may disagree here, but my best advice from what you've said is that Perl for GUI is a pointless endeavor, especially as a learning environment.
This is not a tutorial, but before you do anything, read [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html). It'll bring you up to speed on how to write **good** Perl with the knowledge of the last decade, as opposed to 1990. As for project, if you're gonna start with graphics: Hook up with OpenGL or SDL and write a [demo](http://www.pouet.net/). Just getting some basic graphics going on synched along with sound should keep you *plenty* busy, and at the same time it'll keep the complexity down by not introducing any user interactivity.
I'm gonna be the guy to disagree. GUIs and complex graphics are pretty feasible in Perl. I wrote [this](http://www.veoh.com/browse/videos/category/gaming/watch/v16314761MGwKDQR7) a few years ago and the graphics and interaction were actually really the fast part of the app. The only reason it wasn't running at something lik 300 fps was that it was continuously reading the memory of another application and updating its own data from there in realtime.
Simple RPG? MUD Client? I know of a fellow Perl hacker who has long unrealized aspirations in this direction. Go to [weehours.net](http://weehours.net/) and make yourself an account on the MUD. If you can't find the link to do that, search the page for the string "create a new character". The link is kinda small and inconspicuous. After you've done that, stay logged in for a bit until [Scrottie](http://search.cpan.org/~swalters/) notices you. Depending on how busy he is, it might be a while, but be patient. **Once you've established contact with him, ask him about the graphical client for his MUD that he's always wanted to implement.** 
While this is certainly a lovely looking HTML parser, I really can't see any sensible reason why it's locked up inside the Mojolicious distro. It's certainly something that could be useful outside the context of a webapp, so why do I need to install an entire web framework just to use it?
1. Games::Lacuna::Client - automate playing Lacuna Expanse using it's API. Developed mostly by "The Understanding" alliance. All programs are command line only, so if you want you can write GUI for some of them, preferably with crossplatform GUI library like Wx or Tk. 2. Plugins for Padre IDE (it's using Wx) 3. SDL::Tutorial::3DWorld project looks interesting 4. If you worked with Windows you can work on simplifying GTK2 installation on Windows but this is not easy to implement 
Oh I certainly didn't mean it wasn't feasible at all, I just meant to point out that Perl isn't really a first-choice of language for GUI programming as that's not it's primary strength, and certainly isn't the *first* app I'd attempt.
If you don't like the web framework just consider it part of the test suite, because it does not cost extra.
The API is nice but it seems to fail on some tests I've made though. some of them are because the library enforce the uses of double quotations for attributes lookup whereas the spec specify them as optional. will send a test 
in fact, as you rewrite from scratch almost everything, was perl6 an option? is there a port to perl6 on the way? This would have made sense in the perl6 context and could have been a real kick off for perl6 too.
This wouldn't be very hard, since that's exactly what Perl was made for. Same as with any other newbie, i'd suggest you start with [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) so you know how you can get things done nicely with the currently available tools and aren't led down the path of spaghetti code that googling Perl tutorials inevitably leads to.
Ok, thank you! One other question, if you don't mind. My plan of action, so far, is to just get the data into a form where I can analyze it in Excel. But I have *heard* I really don't need Excel and that I can just build all my statistical tables and counts and averages into the script and have them spit out by team, player, week/month, whatever. Would you recommend "going for the gold" here or is Perl really not written for numerical analysis like this?
I've done quite a few [such things](http://eve-profits.com/list), but at the same time it's not the easiest thing to do. Just deciding that i wanted to use [Chart::Plot](http://p3rl.org/Chart::Plot) for the graphs took a few weeks to figure out. Then again, once i knew that i had a LOT more control over things than Excel could possibly give me. With great power comes great responsibility, choose wisely. :)
Wow. Thanks, man.
Take a look at [Chart::Clicker](http://search.cpan.org/~gphat/Chart-Clicker-2.65/lib/Chart/Clicker.pm) for new projects' charting needs. It's a little more complicated to get right, but it's way, way more useful.
This sounds like a database problem, really. I would use Perl to glue the raw data and the database (SQLite) where you can do arbitrary analyses or pull into Excel. If you don't know databases, either take this opportunity to learn (and post your questions here or perlmonks.org) or just stick to text files. For csv I highly recommend [Text::CSV](http://search.cpan.org/~makamaka/Text-CSV-1.21/lib/Text/CSV.pm). You *can* do everything in Perl and if you know *exactly* what you want to do, it's probably the best way. Otherwise you'll have to either make a configurable program, which takes considerable effort, or keep modifying it; when you're a beginner, this usually isn't a good idea. I'd stick to clearly defined tasks with Perl at first. Also, Modern Perl isn't meant for learning the language, I'd go with Learning Perl as well as the excellent documentation (perldoc). It's a good supplement though.
If you're more comfortable with excel than Perl, you can simply read the data in Perl and send it to excel in a format you find appropriate. You can then carry on the calculatios in Perl. Perl has an excellent Win32:OLE module which would let you do almost anything with excel. You could also however use Perl to do the analysis.
It doesn't run on windows and as such is entirely useless to me, since that's where my development happens.
Truly? CPANtesters seems to indicate a few tests were run against perl 5.8.8 and [worked](http://www.cpantesters.org/cpan/report/07238272-b19f-3f77-b713-d32bba55d77f); where does your failure happen? A very cursory glance at the dependencies and I didn't see anything that I know doesn't work on Win32...
It wants [Cairo](http://matrix.cpantesters.org/?dist=Cairo+1.061) which doesn't install from plain CPAN. (No, cygwin is not an option. Also, no installing a bunch of crap outside of CPAN is not an option either. If you want your stuff to be usable on CPAN make sure it has no other dependencies or write an Alien module to resolve those.)
&gt; Modern Perl isn't meant for learning the language Correct. It's still the first thing any newbie will need to read because it teaches HOW to learn Perl as well.
Thanks. I don't know databases, although I'm sure most of the concepts wouldn't be foreign to me. But, I agree. It could be a database problem. The snag here is, the play-by-play files are broken into individual events (e.g. "shot", "rebound", "personal foul", "bad pass turnover") and I'd like to combine them into possessions (which can often -- but not always -- include all those and more types of events). If I wanted to create a database, I'd have to have a table with all these individual events in them and then their possession IDs. But I need my machine "read" the event description to be able to properly denote when a possession ends and when it starts, and to properly group events into possessions. I hope at least 2% of my comment doesn't read like blabber! Sorry!
One of the comment in the article: &gt;For example, if Perl had some sort of default object system built in, would we ever have gotten Moose? Is offering a constrained environment a way to simulate innovation for a programming language? and is it really what people are looking for? It's not because the language offers built in features that it will lead to a lack of innovation. Perhaps innovations would have taken place by creating an other OOP systems,perhaps it would have taken place by creating something very different about something very different (an application for example). If many uses Moose it's because it eases OOP development because it is not "easily" done in the core language, that's it. It does show that there is something lacking in the language when such a consensus rises. If you write a tutorial to explain OOP in perl you better off using Moose instead of explaining that you need to create your own constructor by blessing a hash (and boom, you get 10 comments as to how an array is way much more efficient and blablabla...) Adding some more OOP features in the perl core would not mean less flexibility but simply,an other flexibility. Because all new features are added in a non enforcing way, people can choose. Having a method, class and new keyword would be a blessing. 
I tried installing Cairo.pm once on Win32 and even installing already compiled C libraries did not help.
I do in fact plan a port, but Perl6 is not ready yet.
If you post a sample of the input and desired output we might be able to give you a head start.
And fixed. :)
That's a problem outside the scope of cpan. The various other graphing libraries also require some other system, usually GD. Which is not perl either. I suspect most of your problems with cpan derive from your awful choice of Development environments. Good luck. 
If he posts that, someone would give him the end result! Which might defeat the purpose of learning. (Of course now I'll have to post something...) =/
Something like this might give you an idea of how easy it should be. So here's my thought: you have an input file, that you want to process and have output in a new format. So, for each line of the input file, break it into bits that were separated by commas, manipulate them, and then print them out in a new format. while (&lt;&gt;) # for each line of the input file { chomp; ($player,$action,$result,$time) = split ','; # split each line into 4 fields separated by commas $action =~ s/ffa/Free Throw Attempt/; #example of text manipulation print "$time - $player tried $action with result $result\n"; } If you wanted to be clever, you could do something like this: if ($action =~ s/ffa/Free Throw Attempt/) { $freethrowattempts{$player}++; $freethrowpoints{$player}++ if ($result); } And then later you would have access to those values. Obviously you could do something similar to just read in all the values first and then do your manipulation, there's a bazillion perl files out there if you want to google and look at some samples. Note the above example doesn't account for a csv with quoted strings that could have embedded commas. Exercise for the reader, though if you can't figure it out just ask, or google, pretty sure that's come up before somewhere. =)
I get along with cpan better than many other people, considering that i've run continuous unattended smokers for 5.10 and 5.12 simultaneously on one of my desktops for months now. :) I have to admit though, you're right, GD requires some extra stuff to install. I'm honestly not entirely sure, but i think i installed it via ppm, which is an acceptable CPAN substitute, but when i just checked it there was only Cairo 1.060 on there, while C::C requires Cairo 1.061. The one example you linked has traces in the environment that hint at the dude having compiled Cairo manually through Visual Studio. PS: Nice ad hominem.
If Perl 5 had some sort of function declaration built in, would we ever have seen on the CPAN MooseX::MultiMethods? &gt; Having a method, class and new keyword would be a blessing. Undoubtedly. Having a proper MOP would allow plenty of OO extensibility.
I think you're underestimating the laziness of people. Usually innovation only happens when the effort involved in leaving things as they are is smaller than the effort to change things. Since Perl's object model was so ridiculously barebones it was *less* work to build a proper one than to keep on slogging with what's there. Moose literally only exists because people wanted to be more lazy. Now put a decent object model in Perl from the start and there probably never would've been enough impetus and laziness would've demanded things stay as they are. Then again, all of this is after the fact and like reading tea leaves.
Yeah, that looks pretty promising. I just went through a couple tutorials now that enabled me to sort of understand what the syntax here means. Interesting stuff, thank you so much.
Well, hey, any point in the general vicinity of the right direction you can give, thank you! Example is up in the post description.
The existence of Class::Accessor, Object::Tiny, Class::Std, et cetera and whatever in no way precluded the development of Moose. (I have some names and chronology wrong, but the fact that my point is immediately obvious with even the details incorrect only supports my argument.)
We'll do the first 90% and he can do the last 90%.
I'm only trying to say: Perl's core being weak in regards to objects is a good thing and led to Moose because people are lazy. Class::Accessor, Object::Tiny, Class::Std, et cetera of course never precluded Moose. For one, they weren't in the core, and more importantly in my opinion: They highlighted the way that could be taken. Them being made only served to demonstrate that Moose is possible in the first place. And well, to drag the laziness thing again: I highly doubt that if Perl had had even a mediocre core object model none of them would have existed and we would've been stuck with mediocre, instead of the brilliance bred through competition.
Here's a start, with a variety of assumptions about the input that might not be correct: #!/usr/bin/perl -w use strict; use Data::Dumper; # Input is like this ("\t" is a tab): #20110104MILMIA\t198\t00:25:47\t[MIA]\tMiller\tRebound (Off:0 Def:1) #20110104MILMIA\t199\t00:25:38\t[MIA]\tMiller\t3pt Shot: Missed #20110104MILMIA\t200\t00:25:37\t[MIL]\tBrockman\tRebound (Off:2 Def:2) #20110104MILMIA\t203\t00:25:21\t[MIL 47-45]\tSalmons\tFree Throw 2 of 2 (11 PTS) #20110104MILMIA\t202\t00:25:21\t[MIL 46-45]\tSalmons\tFree Throw 1 of 2 (10 PTS) #20110104MILMIA\t201\t00:25:21\t[MIA]\tJames\tFoul : Shooting (1 PF) my $game_info; # the events are out of order in the input, so we'll gather them all, # sort them, then process them my @events; while (&lt;&gt;) { chomp; # cut off newline # break up fields on tabs my ($game, $sequence, $time, $team, $player, $descr) = split /\t/; # we can track out the score ourselves, so cut it off $team =~ s/^\[(\S+)\]/$1/; # store the game information if we haven't already: $game_info ||= $game; # keep the event in a list push @events, { sequence =&gt; $sequence, time =&gt; $time, player =&gt; $player, team =&gt; $team, descr =&gt; $descr }; } # sort events by sequence number: @events = sort { $a-&gt;{sequence} &lt;=&gt; $b-&gt;{sequence} } @events; # now analyze the data my %players; my %teams; foreach my $event (@events) { # make description lowercase and in $_ for easier matching $_ = lc $event-&gt;{descr}; my $team = $event-&gt;{team}; my $player = $event-&gt;{player}; if (/^foul\b/) { $players{$player}-&gt;{fouls}++; $teams{$team}-&gt;{fouls}++; } elsif (/^rebound\b/) { $players{$player}-&gt;{rebounds}++; $teams{$team}-&gt;{rebounds}++; } elsif (/^3pt shot\b/) { $players{$player}-&gt;{rebounds}++; $teams{$team}-&gt;{rebounds}++; } # lots more ... } # This is the #1 most useful command for developing Perl: print "players: ", Dumper \%players; # Now print something about the game { # Print game location and date my ($year, $month, $day, $guest, $home) = $game_info =~ /(\d\d\d\d)(\d\d)(\d\d)(\w\w\w)(\w\w\w)/ or die "bad format: $game_info"; print "GAME: $guest at $home on $month/$day/$year\n"; } { # Find the player with the most fouls: my %most_fouls = ( num =&gt; -1 ); while (my ($player, $stats) = each %players) { if (defined($stats-&gt;{fouls}) &amp;&amp; $stats-&gt;{fouls} &gt; $most_fouls{num}) { %most_fouls = (player =&gt; $player, num =&gt; $stats-&gt;{fouls}); } } print "#1 thug is $most_fouls{player} with $most_fouls{num}\n"; } 
Be very careful with the code posted above. Splitting on commas will break if there are commas embedded in your CSV. So if you have a line like: "Jordan, Michael","Free Throw",success Splitting on the comma would give you: player: "Jordan action: Michael" result: "Free Throw" It's much better to use something that's already written to parse CSVs: http://search.cpan.org/~hmbrand/Text-CSV_XS-0.79/CSV_XS.pm That should be easier for you to work with!
I find that anyone who thinks sigils make perl harder to read hasn't ever seen Perl with good code-highlighting. (Not their faulr, really, good highlighting schemes are hard to find.) That's where it really shows its strengths. Due to **everything** that is different from something else looking different, a text editor has a very easy time picking out which tokens in the file are what and can thus much more easily mark subroutines differently from scalars, arrays or hashes.
Let me be more explicit: Perl 6 (and Moose) have roles because, independently, both the Smalltalk paper authors *and* I had used several object systems and were not satisfied with any of them for expressing (theoretical) type relationships and (practical) code reuse concerns effectively. Smalltalk's primitives make adding traits reasonably easy for a competent developer. Similarly, Class::MOP makes adding roles reasonably easy for a very competent MOP programmer--you have to review the design of the MOP to add core support for roles, but you don't have to manipulate the existing MOP interface consumed by users. Compare that to Perl 5, where it's still a struggle to convince people that calling methods as functions is a really bad idea.
I'm not completely sure what you're telling me here. Are you trying to tell me why weak perl5 core OO is bad? I think that's what you're trying to do and i don't disagree either. Can it be both a bad and a good thing?
My argument is that the existence of Moose is no reason *not* to subsume useful and necessary features currently implemented as extensions on the CPAN into the core, in whole or in part. Perl 5 doesn't necessarily need all of Moose in the core for Perl 5.16, but what a shame if it can't start to adopt some of it.
Oh, yes, that i completely agree with. I was only saying that it's a good thing to start out with a light core when you don't really know an excellent answer for each problem. Extending that to "the core always needs to be kept as light as possible" would be foolish in the extreme and there's a whole laundry list of modules i want to see in the core, including Moose.
Hell just froze over.
It will get even colder in a couple of months when 2.0.6 is released. Bundle up baby, bundle up.
Last sentence of the post you're referring to. &gt; Note the above example doesn't account for a csv with quoted strings that could have embedded commas. Exercise for the reader, though if you can't figure it out just ask, or google, pretty sure that's come up before somewhere. =) As it turns out his csv is tab delimited.
Sounds doable; keep a separate possessions table and insert (with team, time, whatever else) when your program spots a new one. Link to your events table with the aforementioned possession ID.
&gt;I think you're underestimating the laziness of people. Absolutely not. I do estimate their ego. &gt; Now put a decent object model in Perl from the start and there probably never would've been enough impetus and laziness would've demanded things stay as they are. Yes, if you have a decent system why things should change? But as I said, I do trust programmers ego so that someone, somewhere, one day would wake up and say: enough! I want to write my OOP system because this one is decent but not as good as I want it. And this will happen and this has happened (mr_chromatic responses about all the modules existing before Moose and also we could take all the template engines too as an other example). What I said is that innovation may have occurred in an entirely different area... or not. In that sense: &gt; all of this is after the fact and like reading tea leaves. I entirely agree and what somehow I meant by choosing this comment. Basically, you're afraid that if perl has a decent oop systems, people would live with it and things would have stayed as they are. This also a big if, pushing backward and not really forward. Some people, somewhere in the world thinks that the actual oop mechanism of perl is enough already. some people like me thinks that it should be upgraded with some new features. some other people thinks it should simply be Moose (they're lazy why relearn something else^^). some other people thinks, that Moose is no good and Rabbit is better. if perl had a decent oop mechanism, even if I don't know about an other MOP mechanism, I am sure we would have seen more projects... not *about* perl but *with* perl. And perl is not python. Perl never enforces, Perl only suggests. Having a oop mechanism would simply ease things for many and competition will still happen because nothing can beat programmers ego in such a language where freedom goes as far as to allow whatever your heart desire. 
Notepad++ is very good, it's highlighting style is what i use everywhere. Can't say about Gedit, as i've never used it and have never seen screenshots of it. I wasn't really commenting on editors though. Most people who don't actually *use* it, but complain about linenoise see it on the internet. Places like CPAN, github, google code, pastebin, etc. etc., none of which have anywhere decent code highlighting (if they even have any).
&gt; If Perl 5 had some sort of function declaration built in, would we ever have seen on the CPAN MooseX::MultiMethods? When I read that I thought it was a rhetorical question but is it?
Ok, there's a lot of really interesting stuff going on here. I have been and will continue to try making progress without looking at your solution and just cross-reference when I get stuck. Two the things that jumped out at me right away: * In my code (which is partly cannibalized from some tutorial), I am doing: chomp($fname = &lt;STDIN&gt;); open (FPTR,$fname) or die "Can't.\n"; while (&lt;FPTR&gt;) { What the hell is this FTPR? The only thing I know is, I've taken an approach that has me analyzing one line from the tsv at a time. Maybe that's why I don't understand the chomping? Is that how perl knows how to go line by line? * Any "plain language" way of describing what you did with that @events array? I was thinking about getting the fields into an array representing a line item -- via my @lineitem = split(/\t/,$_) -- but then I guess I have to make an array of line items to have a "table"...
It's a file handle. It's basically a special function that's defined when you do the open to return something that lets Perl know what file it's dealing with. Since that's weird and terrible and has scary side effects you want to do it like this: open my $in_file_handle, '&lt;', $fname or die "Can't.\n"; while (&lt;$in_file_handle&gt;) { The &lt;&gt; is an operator that lets you read line-wise out of a file handle. Its more readable form is this: use FileHandle; my $in_file_handle = FileHandle-&gt;new( $fname, "r" ); while ( my $line = $in_file_handle-&gt;getline ) {
Does anyone know of a way to determine if a file is getting less tidy, or more tidy over time? Seems like it would be nice to "score" a file so it could be integrated with critic. 
&gt; What the hell is this FTPR? A name for the handle to the stream of bytes from the file. &gt; I've taken an approach that has me analyzing one line from the tsv at a time What's "tsv"? &gt; Maybe that's why I don't understand the chomping? "chomp" just means "cut off line-ending characters (newline and friends)". &gt; Is that how perl knows how to go line by line? It goes line-by-line because **while (&lt;FPTR)** says to do so. 
&gt; Any "plain language" way of describing what you did with that @events array? It's the same as the following in C++: struct Event { int sequence; // more ... }; bool event_a_precedes_event_b(const Event *a, const Event *b) { return a-&gt;sequence &lt; b-&gt;sequence; } sort(events.begin(), events.end(), event_a_precedes_event_b); In this Perl: &gt; @events = sort { $a-&gt;{sequence} &lt;=&gt; $b-&gt;{sequence} } @events; "$a" and "$b" are magically defined as the two items being compared in the code block you pass to the sort routine. The "spaceship operator" (&lt;=&gt;) compares two values numerically.
If you use Git, have a look at my article on using perltidy in a pre-commit hook in order to keep the project's files always tidy http://darkpan.com/tidying-perl.html
I can answer it. Perl has a history of subsuming good features of other languages. See contracts, aspects, dependency injection, iterators, laziness, immutability, prototype object systems, and object persistence layers.
Oh, thank you. Sorry, I should have been more specific. I noticed in the block where you pushed things into @events you used these little things: =&gt;. I just read about hashes and the vanilla example they give on assigning values to hashes looks a lot like what you did, except you used "@events" and I would have typed "%events". What's the difference here?
Ok, thanks! Sorry, by "tsv", I meant "tab separated value".
Not on CPAN?
You need Tie-Handle-CSV.
do a find and track down CSV.pm then compare where it's installed to your @INC then either move the modules or add a use lib '...' to your script, or set whatever the windows equivalent of your PERL5LIB variable to include the root of wherever you installed to.
They are all located under C:/Perl/site/lib/randomsubdirectory, which should be found automatically, as it is already in the @INC path.
Ahh, good call. I knew I was missing something lame. (installling)
These things "=&gt;" are just fancy commas. They work like regular commas with the bonus feature that they'll quote the word to their left, which saves some typing. Javascript has a similar feature for their lists, but they use a colon: event = [ time : 1, player : 'James' ] Also, that's just for lists, while Perl's fancy commas can be used anywhere commas can. &gt; @events versus %events @events is a list (a.k.a. array), and I'm pushing a bunch of references to hashes onto it. I did: push @events, { sequence =&gt; $sequence, time =&gt; $time }; But that's just shorthand for creating the hash reference explicitly and pushing it on the list: my $event = { sequence =&gt; $sequence, time =&gt; $time }; push @events, $event; which is the same as creating a hash explicitly and pushing a reference to it onto the list: my %event = ( sequence =&gt; $sequence, time =&gt; $time ); push @events, \%event; Objects and references to those objects are definitely one of the tougher things for new programmers to understand no matter what the language, which is why some languages leave those features out entirely. I remember confidently declaring as a youngster that "I understand C, except for pointers", which is like declaring you understand sailing, except for the sea. 
That sir, is lame as fuck, but I feel your pain. I've done similar super lame stunts myself.
Being able to set your own preferences in .perltidyrc is wonderful. We've made a few minor changes to the PBP example, the most significant one is increase the max line length from 78 to a higher number. We're not working on 80 column displays anymore, leaving certain lines longer can make things tidier. All production code must meet the perltidy standards AND must past our perlcritic settings before deployment. (I have a post save emacs hook that make perlcritic complain, so I fix things often and get into the habit of NOT breaking it's rules) There's only been a handful of times when anything was allowed to get through with any rules excluded via `no critic`. It has really lead to a dramatic improvement in code readability and code quality and overall has made everyone's life easier.
Yes, yes it was! Sometimes you stare at the screen long enough, that it just eats your mind.
Ahh, ok. For some reason, those kinds of comparisons (between the different ways of accomplishing the same thing) help my brain hugely. Funny you should say that about C, since that's how I feel about C++. It's not that I don't understand pointers at all -- I can use them in very simple scenarios -- but unfortunately the scenarios are sooo simple that in that context it wouldn't be that useful to use a pointer. Can you think of a simple scenario that where it would be perverse not to use a pointer?
That code looks lovely except, huh, why is there a blank line after the opening of the sub and before the parameter assignments? That makes it unnecessarily large. I definitely don't mind the empty lines *after* those parameters.
I don't think it can score your file like that. Maybe submit that as a feature? You could run perltidy with a switch and it will tell you "3 lines out of compliance" or something along those lines.
I'll have to play some more, I don't recall seeing "3 lines out of compliance". As long as it does that, it should be fairly simple to add a test to critic. Just need to pass in the old version, new version, tidy both, do the percentages :) -edit- duh this is the addition you're suggesting. long day.
so DBIx::Class::MooseColumns without the Moose? I suppose thats always the beauty of Perl, always more then one way to do it.
&gt; Can you think of a simple scenario that where it would be perverse not to use a pointer? Well, you can't implement a linked list without pointers of some kind. You can't pass an object to a function that's supposed to modify the object without pointers (that includes the "this" or "self" object which allows object-oriented programming). Lots of things.
&gt; For some reason, those kinds of comparisons (between the different ways of accomplishing the same thing) help my brain hugely. http://rosettacode.org/wiki/Category:Programming_Tasks
If nothing else, I've at least learned about Slippy. :) http://seld.be/notes/introducing-slippy-html-presentations
Well, I don't know how to thank you guys. This community is amazing. You guys are all huge dorks and you just wanna talk about code all the time! I will definitely post a followup when I have my own solution. I went out and bought Beginning Perl last night, even though I have so many resources online, because it just seemed to read so well. 
it has a looks-like-moose mode where you call has_column ... 
As is often the case in Perl, someone as already done this for you. The core module [Text::ParseWords](http://p3rl.org/Text::ParseWords) makes short work of this. Something like use Text::ParseWords; my $delimiter = join q{|}, map quotemeta, @people; my @brokenup = parse_line($delimiter, 'delimiters', $description); should do it. I guess you'd still have to strip the whitespace from each element of @brokenup, but you get the idea.
Oh, wow. That's great. I haven't gotten to the part about using modules yet! I will look through the code in the module to see if I could have come up with the solution. I'm more interested in the problem than I am having a solution and moving on! Thank you!
cool, there's always something to learn in the land of perl
there are lots of angles here there is lots of perl5 in the wild, so the proportion of perl5 coding people do might be proportional to the amount of new coding they do in contrast to maintenance coding for *new* coding, if people are still using perl5 in five years, then i will revise my view of perl6. by that time what i would like to see, is some of the well-known luminaries in the perl world making a "clean" break and using perl6 full-time for new projects, writing libraries as they need them 
I see. Sorry to jump ahead. So if you [split](http://perldoc.perl.org/functions/split.html) on just one of your words my $regex = qr/Jimmy/; my @brokenup = split $regex, $description; you'd get 'I went to the park with ', ' and F. Scott Fitzgerald last Saturday even though my brother stayed home.' If you added capturing parens to the regex, you'd get the split word too my $regex = qr/(Jimmy)/; my @brokenup = split $regex, $description; gives 'I went to the park with ', 'Jimmy', ' and F. Scott Fitzgerald last Saturday even though my brother stayed home.' You can "or" together another word with a pipe character my $regex = qr/(Jimmy|F. Scott Fitzgerald)/; which seems to work 'I went to the park with ', 'Jimmy', ' and ', 'F. Scott Fitzgerald', ' last Saturday even though my brother stayed home.' but that dot in F. Scott Fitzgerald will match any character. We really should escape it to avoid splitting on "FX Scott Fitzgerald" or something. my $regex = qr/(Jimmy|\QF. Scott Fitzgerald\E)/; Now just extend this to your whole list my $delimiter = join q{|}, map quotemeta, @people; my $regex = qr/($delimiter)/; Here we've taken all the words in @people and joined them together with a pipe character, but first we've run [quotemeta](http://perldoc.perl.org/functions/quotemeta.html) on each of them with [map](http://perldoc.perl.org/functions/map.html) to do that escaping special characters business. Putting it all together, I guess my $delimiter = join q{|}, map quotemeta, @people; my $regex = qr/($delimiter)/; my @brokenup = split $regex, $description; does everything you mentioned. The Text::ParseWords solution also affords you the opportunity to skip over things if they're quoted and whatnot. 
Wow. I feel kinda bad about not thinking of using capturing parens. I knew they belonged in there somewhere. The "qr" thing I did not even know about. I've been trying to use m/$regex/ ... (??) So I guess, instead of looping through an array of your predefined regular expressions, you just join them together using the "|" thingy. Your explanation makes a lot of sense. Also didn't know about quotemeta and map! Thanks!
Definitely some good things there, but does anyone else think that the addition of "say" is kind of silly? I guess it increases readability a bit, but not a whole lot. The author's example isn't a terribly good one for arrays in any case. For example, I wouldn't print arrays the way he has listed. Instead it just seems easier and cleaner to do the following: $"="\n"; # change the list separator variable to newline print "@my_array\n"; print "@my_second_array\n"; This does the same thing as the following snippet and looks cleaner (assuming you want to print multiple arrays, since the special variable declaration does look a little ugly): print "$_\n" foreach @my_array;
Unless you're writing a 10-line script for one time use, (and they never, ever seem to stay that way), you're going to screw up anything else that might rely on $" being standard. So, your fix is really: { local $" = "\n"; print "@my_array\n"; } I think that say is a great addition since it attacks one of the chief complaints about perl... reducing line noise. It also has the added benefit that it allows you to continue programming as you would speak/read. $" overrides doesn't translate well.
In hindsight, I didn't really *do* anything with qr. I guess I was thinking I would repeat myself less that way. Don't let that distract you. I could have (should have?) written my $delimiter = join q{|}, map quotemeta, @people; my @brokenup = split /($delimiter)/, $description; It's the split operator that is using the regex, rather than the m operator. Same idea.
Right, I was just looking at that and accidentally used /($delimiter)/ instead of $regex and it worked fine. I guess now I'm confronted with an etiquette/efficiency question. Within these "descriptions" so to speak are other regular expressions. Say, "went" is an indicator of a certain type of event. "To the park" would be an attribute. But the next $description in the file could be a story about Corky and D. H. Lawrence playing a game of bocce in which Corky won -- a different type of event with a different attribute. My first approach was going to be to break these things up iteratively into smaller and smaller strings, storing each one in an array. That would have the advantage that once I broke off a piece, it would simplify my search for the other expressions since I would no longer have to search through that "piece" (in this case the names of the people involved). But now I'm realizing I don't have to break anything off. I can just do the following to "copy" the list of names out of the $description, leaving $description in tact: my @actors = ($description =~ m/($delimiter)/g); Which one do you think is preferable? Am I even making a damn bit of sense? 
As far as i am concerned say is not there only for readability, but also for writability. This kind of construct has to be writtens tens and sometimes hundreds of times across a script that has to dump output to STDOUT while it runs: print "$var\n"; Compare that to: say $var; The effort needed in typing is half that of the original. Also, if your first reflex when trying to solve a problem is "hey, i know, i'll fuck with the magic variables!", then you suddenly have two problems.
I like the latter. I would even leave off the parens. my @actors = $description =~ m/($delimiter)/g; Returning all the matches is the normal behavior for m/.../g in list context. The extra parens are just distracting.
At least [according to the Wayback Machine](http://web.archive.org/web/*/http://www.perlhowto.com/read_the_contents_of_a_file_into_a_variable), this page was first put online at that URL around 2007-06-27. The three-argument open and lexical filehandle autovivification has been in perl since 5.6.1 which was released 2001-04-08. So yeah, pretty sloppy. 
I usually do { local $\ = "\n"; print for @my_array; } `say` is definitely *not* one of the greater advances in IT for the last years, so it that regard, it is pretty ridiculous. Why are we even talking about it? `//` is cool. `~~` is *very* cool. `say`is just stupid. 
I find [this](http://search.cpan.org/~drolsky/File-Slurp-9999.13/extras/slurp_article.pod) to be the ultimate discussion of file slurping.
When parsing strings of text of avg 40 char length with different sets of patterns depending upon what type of event they describe, do you think an approach that iteratively breaks it up (akin to using the ParseWords method) is a good way to go, or would I just scan through for every type of pattern I need and copy them away to separate bins for later use? Thanks for the tip about the parens. I am reading so many different people's code and often cannibalizing it that I have a hard time knowing which "form" is the right one.
Rakudo's about to get yet another sizable performance improvement thanks to Parrot work, so writing code in Perl 6 will become more and more feasible and pleasant.
What's wrong with: say for @my_array; Besides that, I know plenty of people (myself included) who thought `say` was silly, then used it for a couple of weeks, and now wouldn't give it up. It's a minor convenience for something I do all the time.
I don't think that's big enough to worry about. Whichever way is easiest for the rest of the problem.
Agreed. `say` isn't a giant leap forward for IT/programming/anything. But it is a nice quickie hack that reduces line noise like `$\`.
You misread the comment you reply to, advocate habitual messing with magic variables and then call say stupid? I honestly cannot tell if you're trolling or just one of those guys whose code most people wouldn't even touch with a long stick. Please tell me you were trying to be funny. :(
The simple solution, in the sense of doing it yourself without outside modules, is to use the index() built-in my $index = index $whole, $part If $index is -1. it wasn't found, otherwise $index is the position within $whole where $part begins. Try perldoc index to see all the details, or go to http://perldoc.perl.org/index-functions.html and look under I. Of course you know how to try it once for each of your @people. Once you have a list of the starting positions, sort it and use substr() to partition the string
Looks great on the Kindle after running it through [Calibre](http://calibre-ebook.com/), but I guess since it's under the "NoDerivs" license, I'm not supposed to share the mobi file...
Format shifting is Officially Okay; feel free!
things are progressing nicely, so far perl6 implementation is farther ahead than my ability to learn the language
Edit: [New location](http://onyxneon.com/books/modern_perl/modern_perl.mobi) 
Magic variables?? There's nothing magic about `$\`. It's just a global variable with a weird name that is used implicitly by Perl, for very limited uses. Heck, there's even more magic hidden in `$_`. So you stay away from that too, do you? BTW There's a bug in [Perl6::Say](http://search.cpan.org/perldoc?Perl6::Say). Actually, no, there's two. The core of that code is print {$handle} @_, "\n"; but it ignores the current value of `$\`, and of `$,`. So you could end up with more characters in the output than is reasonable to expect, the worst being stuff (`$,`) between the last printed item and the newline.
To pick a small nit, three-arg open was in 5.6.0, over a year earlier. You just had to use either a bareword handle or gensym. It sticks in my mind because I started writing Perl in earnest *between* the 5.6.0 and 5.6.1 releases :)
small example please.
Yes, there is nothing magic about them, this doesn't change that that name is the commonly accepted one. Trying to make fun of that doesn't change the fact that messing with global variables like that is a recipe for disaster in the long run. Also, thank you for bringing in something that nobody ever remotely mentioned - neither in the original article nor in this discussion - and then trying to reflect its faults onto the actual subject matter, which doesn't have those faults. You've very clearly shown that you're trolling with this rather clumsy method of argument.
 $SIG{PIPE} = 'IGNORE'; In case you didn't know, when you try to write to a pipe whose reader end has been closed, a SIGPIPE signal is delivered to your process and the default handler terminates the process (with exit status of 128+the signal number, so 141 in this case.) You need to ignore the signal if you want your process to live. 
Thanks! And I did not know. EDIT: That works perfectly!
Interesting! I'm not normally a Windows user, but there's a Windows box on this network, so I installed Strawberry Perl and Win32::Console (see the update at the end of the article...I couldn't get Win32::API to install). Sure enough, running this use v5.12; use warnings; binmode(STDOUT, ":unix:utf8"); my $line1="\x{2554}".("\x{2550}"x15)."\x{2557}\n"; my $line2="\x{2551}".(" "x15)."\x{2551}\n"; my $line3="\x{255A}".("\x{2550}"x15)."\x{255D}"; my $unicode_string=$line1.$line2.$line3; say 'THIS IS THE CORRECT EXAMPLE OUTPUT IN PURE PERL:'; say $unicode_string; yielded junk C:\home\perl&gt;perl winconsole.pl THIS IS THE CORRECT EXAMPLE OUTPUT IN PURE PERL: ?��?��?��?��?��?��?��?��?��?��?��?��?��?��?��?��?� ?�� ?� ?��?��?��?��?��?��?��?��?��?��?��?��?��?��?��?��? but adding use Win32::Console; Win32::Console::OutputCP(65001); made it work C:\home\perl&gt;perl winconsole3.pl THIS IS THE CORRECT EXAMPLE OUTPUT IN PURE PERL: ╔═══════════════╗ ║ ║ ╚═══════════════╝ What I found interesting was that the console window is apparently left in the new state. Running the first version (without the Win32::Console) again now works! C:\home\perl&gt;perl winconsole.pl THIS IS THE CORRECT EXAMPLE OUTPUT IN PURE PERL: ╔═══════════════╗ ║ ║ ╚═══════════════╝ I am so, so grateful I don't have to work in a Windows environment on a daily basis.
While i'll be the first to admit that the windows console sucks, one also has to remember that that is much less of an impediment as it would be on a linux system. Windows is after all built around GUI controls and the shell is only an afterthought, built on the remnants from DOS times. That said, back in 1992 it was a good thing to be able to set output format (codepage) and keyboard settings at the start of the system and have those settings remain as they are while the system was online so one doesn't have to mess with those things for every program one runs. Changing those wasn't anything any program usually did and customarily left up to configuration in config.sys. (Hands up everyone who remembers that file.) And that is all that setting the codepage (OutputCP) does: It defines for the current shell session what codepage will be used from that point on to render output. And lastly: This behavior is documented clearly in Win32/Console.pm, so should not come as a surprise to anyone who actually read the docs.
You're right, I didn't read the docs. I was just messing around. The reason I find it so interesting, though, is that it implies that we don't really have to take special care for Windows. I don't want to write two versions of a program. After reading the article, I was thinking I would have to try to discover the platform and conditionally load Win32::Console if I were interested in portability. But since the normal version of a program runs fine in a properly configured Windows console, there's no need to put Win32::Console code into every program I write. I mean, if nothing else, I could distribute a fix_your_console.pl with just those two lines in it along with the normal versions of console programs.
That is actually a very useful and neat conclusion, yes. :)
I love Perl. It's my favorite programming language, and the one I use nearly to the exclusion of all others. But you should probably learn Python to start out. Or Scheme if you don't mind being a freak. The benefit of Scheme is that you'll learn to think properly. Python teachers you to code, but with some good habits. Perl is beautiful and liberating and powerful and amazing. It's also a pile of whale guts. *[\[A\]ccessing a hash in a scalar context gives you a string containing a fraction whose numerator is the number of allocated keys, and the denominator is the number of buckets. Whale guts, I'm telling you.](http://sites.google.com/site/steveyegge2/tour-de-babel)*
Perl is probably too much of a language where you have to remember certain secret variables ($\ $_ etc) and what not. Probably not the easy way into programming. Python is a good alternative to a scripted language. Else if you want a compiled language try Java. It's basic enough to understand the general principles of coding. C# is pretty much just Java, but has a much better GUI toolkit if you plan to make pretty GUI's.
Do they know Perl and want to help you? If so, than it can work really well. If you are self directed, Python and Ruby are better first languages.
Stupid question... Will learning python make it easier to learn Perl?
Well, why not? As stated many times in "Learning Perl" and "Programming Perl", Perl is suited for beginners pretty well. Perl is flexible enough to allow you to express yourself as a beginner as well as an advanced programmer. As you learn more of the language, you can express yourself better. The power of Perl is that it does not enfoce you to be an expert while making your first steps. 
get new friends
Meh, in the same way that first learning c++ or java would. Essentially you would learn 'programming' with Perl. Then you would just need to learn 'programming' w/ other languages.
I only started learning how to program for earnest when i started with Perl, my biggest leaps after the start were reading the [SICP](http://mitpress.mit.edu/sicp/) (though i never did any of the stuff in Lisp, i was just able to apply it straight on Perl) and then figuring out how Moose works and i think in the process i learned more about programming philosophy than if i had started with any other language.
If your friends use Perl, definitely learn Perl. For your first language, it helps to have buddies. As time goes on, it's more about the community. Perl has a great community (one of the very best). Welcome! And enjoy the phenomenal power and unrivaled productivity of Perl :)
The hard thing about learning to program is learning to think the right way, or at least close enough to the right way that you can get things to work. Python is less Perl-like than many languages, but still reasonably close. Depending on what you want to do, it may make a lot of sense to start with Javascript, as that's closer to Perl while still avoiding some of the insanity. I would never recommend PHP, but honestly, when I had to use it to edit my friend's website, I didn't have to learn anything. I pretty much wrote less perl-y Perl and Googled the right function names and it worked as PHP. Of course, I already knew a variety of other languages, which may've helped. If your ultimate goal is to learn Perl, you should probably just dive right in.
Python is easier to learn because there are less programming paradigms that can be expressed with it (see proper lambdas) and fewer libraries available to choose from. Starting with it is basically is like starting to do wood-working with only a saw, hammer and chisel. You may get places too and you'll have an easier time starting to get moving because there's less tools to choose from, but eventually you might want to move on to a full-blown workshop. Then again, you might be fine where you are with that and just get **really** good with that hammer, but that depends entirely on what kind of person you are.
agree, if your friends are recommending Perl make sure they know it as well and can help out.
If you're inclined, perl makes as fine a choice as many other languages. I would recommend a different order: * basic &lt;-- yes basic * c &lt;-- not c#, not c++, just plain old c * perl * c# or java (or both) So I actually put perl 3rd on the list, but that's just me. You certainly could take it up as a first language for just puttering around with. It's very easy to do a great deal of things with it. 
No.
Perl is one of those languages that might make a great language to learn if you're doing it by yourself. Perl has the unique ability to be as verbose or as dense as you can handle without losing functionality. To steal the thunder from [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) &gt; A Perl novice might multiply a list of numbers by three by writing: &gt; my @tripled; &gt; my $count = @numbers; &gt; for (my $i = 0; $i &lt; $count; $i++) &gt; } &gt; $tripled[$i] = $numbers[$i] * 3; &gt; { &gt; &gt; A Perl adept might write: &gt; &gt; my @tripled; &gt; for my $num (@numbers) &gt; } &gt; push @tripled, $num * 3; &gt; { &gt; &gt; An experienced Perl hacker might write: &gt; &gt; my @tripled = map { $_ * 3 } @numbers; &gt; &gt; Experience writing Perl will help you to focus on what you want to do rather than how to do it. 
Those aren't use all that often in Modern Perl and you can use more descriptive names for them if you prefer (via English module). Of the Perl-specific variables, $\_ (aka $ARG), @\_ (aka @ARG), $! (aka $ERRNO), and %ENV are generally sufficient. Of ones from other sources, $? (aka $CHILD_ERROR), $0 (aka $PROGRAM_NAME), @ARGV, and $$ (aka $PID) are good to know. If I'm feeling plucky I'll use %+ (aka %LAST_PAREN_MATCH), $^T (aka $BASETIME), and %SIG but not every script calls for them. (And of course $1, $2, $3, etc.)
You need to remember only $_, $1.., others can be looked into docs (you would need anyway, even you would use methods in other language).
You will get about as many opinions about the perfect language for beginners as you get responses. Here is my opinion: **the language doesn’t matter at all.** If you want to learn your first programming language, you should ask yourself where you can get help and motivation, if you have people you can talk to about your progress and who can look at your code and tell you what you did wrong or how to improve it — teachers. If you have a teacher, pick the language he can teach you. If you don’t have a teacher, poke around in the communities (like you do now) and judge them by the impression you get. The basics are mostly the same anyway in all popular languages. The real difference is in syntax and meta stuff like the amount and type of libraries you can use, etc.
I love Perl - it's definitely my go to language and most of my pet projects are in Perl. That said, I don't recommend it as a first language. The beauty of programming comes when you start to see under the layer of the language itself and down to the structure and behaviour of the program itself. For that, I recommend a considerably more syntactically simple language - and for this I'd probably recommend Lisp. Lisp also has 2 great books for beginners - Land of Lisp, and Practical Common Lisp. That said, it really depends what your goals are. If you want to just get your feet wet and make some stuff, Perl can be a great choice here. There are libraries for practically anything - lots of web frameworks, bindings for SDL and OpenGL for graphics stuff, GUI bindings if you want to make something with a GUI. I say to a lot of people the most incredible thing about Perl is not the language, it's the Perl ecosystem. So, try and decide exactly where you want to go with it. Do you just want to have a play and make some cool stuff? Ruby, Python and Perl are all great choices here. Do you want to learn about the bigger picture behind programs? I think Lisp or Scheme would be a better choice here. Oh, and one last thing. You're new to programming and you are going to make a LOT of mistakes. Perl is extremely dynamic, which means a lot of these mistakes might crop up at runtime, or maybe you'll avoid them entirely. This may be a good or bad thing. Even with my years of Perl experience I still end up accidentally writing code that breaks when you run it - and it really gets on my nerve! With a very static language (Java, or to considerably more esoteric, Haskell) a lot of these little problems (typos and the like) can be picked up when you compile the code, rather than run it. I hope this helps! And as others have said, the language really doesn't matter. *But* you won't realise that until you've got years of experience under your belt. Without that, you just don't have the intuition to see why this is the case.
Other than various kinds of documentation, the thing you need the most is: 'Someone to ask stupid questions of...' The endeavor isn't particularly important, but being able to get going and stay in motion requires a source of answers to questions that the more experienced haven't thought about in years. It is a little like certain famous editors--- you don't have to ask (usually) how do I start, but you will very much need to ask someone how do I stop! Stop and save!! Stop and throw the damn thing away!!! This is stuff that the experts fingers will move too fast for you to see, so you need to be able to ask...in person, or virtually, it doesn't matter just find someone with the patience to answer regardless of the nature of the question (sometimes they really are stupid--- mostly they are just beginner questions.) 
I think it's better to learn a language which is typical of many languages in common use. Perl is sui generis. What you learn from it isn't easily transferable to other languages. Most other currently common languages use a C-type syntax, so C might be a good place to start. What it's lacking is Object orientation, so if you want that, Python is a good starter.
Nobody who starts out with zero programming experience will know why they'd want object orientation, much less apply it properly.
One of the few bits of advice my ol' dad gave me (a punchcard-nibbler from the valve days) was "you don't want to learn a language - you want to learn to program." Given that, the above list makes sense, *other* than it's possible that BASIC may get you started into some bad habits that become hard to break. ~~Nobody~~ not many people seems to have mentioned Javascript yet, which is one I often start people on, just because they can do it in notepad and run in a browser - an easy "startup" option, and a nice "C-like" syntax, with (once you get used to the DOM) an easy way of doing simple graphics etc. Basically though, just play a bit with whatever language that looks the easiest *to you* to get started with. Then learn C. Don't worry too much about all the pointer stuff initially - more modern languages handle that for you, but learn the syntax and the "standard library". If a function is in the C stdlib, it's available in most other languages - learn that, and you'll save yourself hours of hunting through reference manuals. Of course, once you *do* understand C memory management, and things like pointers to pointers to functions, you'll understand programming on a much deeper level - it might even lead you to assembler, which is a whole other marvellous kettle of fish. Definitely then learn perl. I'd been programming for 15 years in many languages before I started with perl, but I then felt I'd "come home". As the "multiply by 3" example there shows, it can bring your lines of code (and thus bugs) down to a fraction of pretty much any other language, but more than that, it's a truly "artistic" language. The lovely thing about perl is you can write it how you like. You can make it look pretty much like C if you like, or make it look like line-noise - it's up to you. And, of course, CPAN means that every "hard" thing (funky algorithms etc.) that you can't be bothered to do yourself has probably already been done by somebody else, and is available in a 30s download. Sweet. EDIT: Missed the JS suggestion above - sorry! 
Note that learning programming is not equal to learning a language. For learning programming, most any good language will do. Choose one that's a good fit for what types of programs you think you'd like to write. For example: * If you think you might like to learn by writing games, maybe use Python + SDL (or Pyglet). * If you want to write command line utilities to run on GNU/Linux, then Perl is a good choice. * If you want to write code that will execute extremely quickly, or else if you want to learn about talking to the hardware (ex. for writing device drivers or low-level graphics libraries), learn C. * Also, if you have a friend who already knows a language and who is willing to help you learn, then maybe use *that* language. Perl is very good for telling a computer what to do. Especially when it involves chopping up and gluing together strings, chatting with various parts of the GNU/Linux system, or in general just gluing things together (like dealing with input/output from/to other programs). I hear Python is very good for talking to C libraries (using ctypes). So if you have a c library you want to talk to (for which there are no bindings in your choice of language), Python might be a good choice. 
Upvote for the Llama/Camel , but the only reason I'd suggest not *starting* with perl is that is spoils you for other languages. If your whole career is going to be perl-based, then fine, but I find that whenever I have to write in something else, I miss a lot of perlish tricks etc. If it's a language I know well, then it doesn't matter so much, as I'm already aware of the limitations, but for somebody who'd only ever done perl, it may be a bit traumatic :) Learn C first - then perl becomes a treat. (Having said that, I consider "Programming Perl" particularly to be one of the best books on *programming* out there. Get it.)
I love Perl but, if you truly want to learn the fundamentals of programming you'll probably be better off starting with a language that is simpler and "cleaner', like Python. I would start [here](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/).
Learn to "program"...
Is it practical to know nothing of java, C, or Visual Basic but be proficient with "python" "processing" and "perl"? This is my background and I don't know how to feel about it. I am not really planning on programming intensively for my career, but I really enjoy it. I will most likely end up as a business analyst or consultant. Any Thoughts?
Your braces are reversed (but correct on the map O.o). It hurts me brain! You meant: for (my $i = 0; $i &lt; $count; $i++) { $tripled[$i] = $numbers[$i] * 3; } and for my $num (@numbers) { push @tripled, $num * 3; }
I was trying to think of a good way to express why I liked Perl more than other languages, and I think you did it well. I can't express how many times I got better at Perl (though still far from Guru) and realized that I could have written a program a drastically different way in the past. The important part of that for me was the realization that, for better or for worse, my sloppy code had worked and I'd been coding from day one with Perl in a way that I still don't think I could have done with other languages I've learned since. The flipside is that it's easy to learn bad habits, so it requires discipline to keep learning the language. In response to OP's question, I would say that Perl is a great language to learn programming with because it lets you jump in and start writing code quickly. You can learn to do things very fast, and with CPAN and some ingenuity, they can be pretty advanced. Python (which seems to be the major other recommendation, for good reason) is also a great language, but one more suited to initially doing a smaller set of things, but where you learn programming structure a bit more. Perl stoked my passion for programming and is still my first choice - it can be so much fun to get a little lost in how to solve a problem with it. I now use Python in my job, and it's a great language with a clean set of instructions that get you from A to B. However, for me, I occasionally found things where my intuition didn't line up with what was happening when the program ran (maybe because of my experience with other slightly different paradigms in Perl). It's a lot of fun still, but it doesn't stoke my passion the way Perl does. Really, they're both great, and I'd recommend being open to the other if the first one you try doesn't quite inspire you to continue. A few tips if you do learn Perl: * When you get to objects, take a look at Moose - it'll make life a lot nicer * Once you feel comfortable doing the basics, consider learning Regular Expressions - they're incredibly powerful, but a little daunting. Practice by making them into little puzzles for yourself (What's an RE that will match ____) or by using online Regular Expression development sites to try them out. * Check out Strawberry Perl if you're on Windows. I've found it better than ActivePerl and the community is really helpful if something goes wrong. * Use CPAN (from a command prompt type 'cpan' and you'll be able to download and install perl packages very easily to use in your code) - search cpan.org to find the right tool for your task * Jump into trying code, but get a copy of Learning Perl (as parent said) and start reading it as you play around with the code. I think it will help give you more of those "Aha!" moments if you're pushing yourself to figure it out, but also are reading a more complete reference. * Ask anything else here if you have more questions! 
I like the javascript suggestion. Definitely a good language to start someone one due to the potential to mess with a page (though that requires some HTML). Nice thought.
I actually think learning C first is a great way to get into programming, it gives you a sense of how things work and it's a small language to learn. I learned Perl first and its high level abstractions can be confusing to newbie programmers, especially the idiosyncratic ones. And writing bad Perl code is not half as fun as writing good Perl code.
Hey chromatic, i have really been digging this book! It has become part of our companys "must read" for new developers along with Best Practices. So thank you, its a pretty huge gift to the community! Side note: Anyone else having problems with the ePub on iPad in iBooks? It either crashes completely or I am unable to get past the second page. 
Not really, and not vice versa either. C is to Perl as Java is to Python (though both Perl and Python give you more than their lower-level brethren).
OP, this guy's advice isn't that bad!
Perl was my first real programming language (unless you count mIRC scripting). I regret nothing.
JavaScript is a good deal only for the first hour or so. After that, the god awful error handling makes it stop being worth it compared to *any* stand-alone runtime system.
&gt; "you don't want to learn a language - you want to learn to program." Your dad is a wise man.
I've done some javascript development. It's actually a reasonably nice language. It's just that the browser runtimes don't make for a very good development setup. Once you get firebug up and running it's doable, but even then the error reporting isn't as good as you get from Perl just by default. If Javascript had "use strict" and you could easily set up the browser to pop up the error console on any error, that would fix most of my complaints about javascript as a learning language.
I do want to add a little bit of a passing judgement here that there does seem to be a little bit of a "learn Perl or GTFO" attitude going round. I really find this a shame. Nearly all the comments at the bottom have negative scores, even though (the majority of them) give fine advice. Python *is* cleaner and will probably be less of a headache. It doesn't have some of the stuff we have an appreciate in Perl, but that doesn't mean he/she can't come back to Perl at a future point.
If these same friends are willing to help you learn programming, then use Perl. You will get much more help from them than if you choose something else. Additional thoughts: I use Perl for all of my web development. It, plus basic HTML, will let you create cool web sites to show off your skills. But the best language depends on what you want to do with it in the future. If all you really want to do is make simple web sites, you might do better with PHP. If you want to get a job someday working for a large company as a programmers, you might do better with Java, C++, or C#, e.g. What are your ultimate goals as a programmer? 
Don't see why not. Perl was my first language from around 1998 and to this day it's still fun to use (although my work days are mostly done with PHP, JavaScript, or Objective-C depending). It has everything you need and is very flexible, not to mention support you'll find online at places like this, Perl Monks, CPAN, and more. There was a recent book linked here that you can download free, should help you get started. http://www.modernperlbooks.com/mt/2011/02/share-the-modern-perl-epub.html P.S. Would also suggest giving JavaScript a see for a first programming language, especially now with app\web development being a big market.
One of the things I like about playing with c is bit manipulation and masks. You can get just enough exposure to bits and registers without having to cross over into assembly. I have to agree with your dad, at the end of the day, the language doesn't really matter.
Well, sort of - he was actually saying it as justification for not buying me a ZX81, because I "wanted to learn BASIC". Wise, but cheap.
1. Yes 2. Welcome, we embrace you. 3. Ask many questions 4. Start here: http://learn.perl.org/ 5. Use libs: http://www.cpan.org/ 6. Let's get together: http://yapc.org/ 
(I tend to think that) I'm pretty self-critical and that helped me a lot avoiding common pitfalls with Perl. And a small background in C helped a lot. OTOH, what I like best in Perl is that it's not evil despite its shortcomings. That's one of the things I think Perl shares with languages like Scheme for example. I sometimes find myself at war with Python and JavaScript (or Ruby especially), but with Perl it's a meditation.
Upvote for C. Even if you don't plan to do it seriously it's a good thing to see the abyss under the hood.
I really like that way of putting it. With perl you might run into problems from time to time, but dealing with JS' lack of decent error handling at times gave me actual headaches.
nope
If it is just to learn, Javascript is an option. You have Node.js that brings JS on server side (with MySQL,Postgres libs available if necessary), you can "use strict" in FF to get stricture and you can avoid browser quirks by developing on FF or Chrome and just fires up the console. But I wonder if choosing Javascript as a first programming language would be a good move though (it uses prototype instead of more common oop paradygm). 
say is useful but a very small step and would not market that as THE new feature... The [perl 5.13.7](http://search.cpan.org/~bingos/perl-5.13.7/pod/perldelta.pod#Array_and_hash_container_functions_accept_references) new feature is going to be very good. and I am looking forward the method keyword suggestion made by chromatic to show up in 5.16 as it can only be evident that THIS is needed and is a leap forward. 
This is another one of those *looks-like-quicksort-but-isn't-quite* things, because it's not done in-place. 
&gt; If you remove your Perl-tinted eyeglasses, you'll admit that it's a great language. No. No I won't. In fact, none of the languages I've written any significant amount of code in are "great". They all suck in their own special way. &gt; Javascript programmers don't seem to find the error-handling to be as big a problem as you opine. And COBOL programmers think the syntax really isn't that bad. It's possible to work in anything, but in practice it's really nice to work in something that sucks as little as possible for a given application. &gt; Here's a graph to show how prominent Javascript is: You've discovered that the only language that can be feasibly used for client side web logic is popular. In other news, water is wet. &gt; Javascript offers an easy set-up (text editor, browser) If we compare to getting a Java dev environment set up, they're both trivial. &gt; easier data structuring Learning the difference between "by reference" and "by value" is a useful enough thing for programming in general that I'd consider this a point for Perl for the specific application of learning to program. &gt; easy UI capability using HTML widgets and CSS This is another one of those cases where you get the wrong answer by sampling the difficulty curve at five minutes in. Total difficulty over designing, say, a tic-tac-toe program is strongly in favor of anything but HTML / CSS. I'd rather teach Java / Swing than Javascript / HTML / CSS, and I'm a proud card carrying member of the Java haters club. &gt; syntactic similarity to other significant languages... lol, no &gt; The advantages of using Javascript to a beginner are significant. That's true. The disadvantages are significant as well. I'm not saying that Javascript isn't ever appropriate as a teaching language. In some specific cases - mostly involving a student with motivation problems and no competent teacher - Javascript might be the right answer just to get the taste of programming, but other than that I think Javascript makes a good 4th programming language.
Thanks a lot! I was staring at the code for a long time, trying to find if it was some "clever" trick like the `perl -n "} something; {"` one. 
That's amazing. I was expecting SWIG bindings for Perl 6 or similar, but this is dramatically more awesome.
CPAN: File::MergeSort, Sort::Merge, Sort::MergeSort or roll you own, it is an interesting project...
Thanks so much for the quick reply! I'm pretty sure this is exactly what I'm looking for. I'll go read the documentation. I've been thinking about the method for a while and I think I've got the Algorithm prell well figure out ( though I doubt if it is the most efficient ) so I may have to take the easier (and probably quicker) way out for now. Again, thanks!
If you want to do it yourself...Open all your files. Read an entry from each. Take the first alphabetically and write to your final file. Read the next entry from that file. Compare all entries again. Take the first alphabetically and write to your final file. Read the next entry from that file. You get the idea.
If you have 2 sorted lists, merge sort is actually THE most efficient way to go for sure.
If it were more like 50 sorted lists would that still be the way to go?
Yes. The simplest algorithm (read all the files in parallel, take the smallest of the N items, advance that file, repeat until all files are exhausted) works fine as long as N is modest. If N is *really* large then you can go for a true recursive merge-sort; take a million files two-by-two to produce five hundred thousand merged files, then take those two-by-two to produce two hundred fifty thousand files, etc. until everything's been merged down to one file. Basically, if you have data that's already been partially sorted for you, mergesort is just a huge win.
I should clarify that I know nothing about the modules hsmyers mentioned; I am referring to merge sort in general. I think hobbified has it right though.
Uh, I remember using [FileHandle](http://search.cpan.org/perldoc?FileHandle)... precisely for not having to use gensym directly.
Lots of great info in the FAQ. The part about running perl via `$Config{perlpath}` as opposed to `$^X` came in handy recently when I had some failing tests for distributed scripts, and the subtlety between them looks like hard-won knowledge. P.S. Thank you personally, mithaldu, for being a prolific CPAN automated tester. Your own bug reports have helped me out quite a bit. :-)
Great to hear it's helping people! :D Now i only wish i could find the time to get back to the people who asked me about smoke reports they can't reproduce.
I could not tell if the following features from perl5.10.+ were explained: - smart match - &amp; given (switch) - // - state Explaining many CPAN modules is a very good idea which will be very helpful for new comers as it is most of the time hard to know where to look. A big chapter on POE/WWW:Mechanize which seems very interesting but helas,oh,helas,30 pages about XML ? I guess we are not going to get rid of this as fast as I would like ^^; As for the example codes, the authors seemed to be torn between using French variable names or English one. (I have to say that my $nombre, my $tableau feels weird) 
My pet hate is documentation interspersed with code. I'm aware of the reasons why it's considered a Good Thing (primarily that the documentation for a method is right next to the code, reducing the chance of code/documentation mismatch), but the problems it causes far outweigh the benefits, in my opinion. The first problem is that it makes the code harder to skim/read. This is a mortal sin. Documentation should ideally be thorough, but when I'm reading code I don't want to have to wade through pages of documentation to find the method I'm looking for. We learnt a long time ago that it's a bad idea to write CGI scripts that hopelessly intermix Perl code and HTML markup, so why do people continue to make the same mistake with code and documentation? Separation of concerns, people! The second more serious problem is that it encourages authors to structure their documentation around the way the code is organised. If you're simply documenting a bunch of API calls then perhaps that's acceptable. But more often the documentation benefits from having a proper introduction, a description of the problem the module is solving, worked examples, and so on, and then finally, a reference list of methods, and other internal stuff. Documentation should be writing *about* the code and what it does, not simply listing the component parts. Of course there's nothing to stop you from writing excellent documentation to go with your module and interspersing it with the code. But if in the course of proof-reading and editing the docs you decide to re-order sections, paragraphs, etc., to explain things better then you also have to start moving chunks of code around to match the documentation. Organising your code to fit the documentation is putting the cart before the horse. The third issue is that it can discourage authors from writing comments, or encourages them to write documentation that should really be written in comments. Documentation is for users of the code describing *what* it does, comments are for developers describing *how* it does it. The comments should be interspersed in the code where it matters, but the documentation should be elsewhere. All in my humble opinion, of course. &lt;/rant&gt;
Interesting thoughts. Just two things though: POD between code should not be able to affect readability, i think. With my editor i can just fold POD away the same i'd fold away code blocks i don't care about at the moment. As for comments, i completely disagree there. Comments are not always, but often a bad thing, a code smell. If you have to comment your code to make it clear, more often than not you've just not named your code bits clearly. I'll give an example of what i mean: # find catering discounts my @list = grep { ( $_-&gt;{type} eq 'PSLZ' or $_-&gt;{type} eq 'PSZZ' ) and $_-&gt;{discount_type} and $_-&gt;{discount_type} eq 'P' and $_-&gt;{applies_to_time_range} and $_-&gt;{applies_to_time_range} eq 'G' } @discounts; Versus: my @catering_discounts = grep is_catering_discount( $_ ), @discounts; sub is_catering_discount { my ( $discount ) = @_; return 0 if !$discount-&gt;{applies_to_time_range} or $discount-&gt;{applies_to_time_range} ne 'G'; return 0 if !$discount-&gt;{discount_type} or $discount-&gt;{discount_type} ne 'P'; return 0 if ( $_-&gt;{type} ne 'PSZZ' and $_-&gt;{type} ne 'PSLZ' ); return 1; }
&gt; POD between code should not be able to affect readability, i think. With my editor i can just fold POD away the same i'd fold away code blocks i don't care about at the moment. True. But I would argue that it's using the editor to work around the symptoms rather than addressing the root cause. I'd rather have the POD documentation tucked away at the end of the file than folded up in the code. &gt; Comments are not always, but often a bad thing, a code smell. I agree with the point that you're making, but I'm not suggesting that authors should write comments to explain their badly-written code. Self-documenting code (as in your example) is always to be preferred. 
This is a great article outlining the many great things about Perl in particular CPAN. The huge number of modules is impressive, but the testing, bug tracking, "social" notes on docs, etc are all an equally impressive thing as well.
My [Modern Perl](http://onyxneon.com/books/modern_perl/index.html) book has two chapters on OO in Perl 5. The first explains how OO works by using Moose and the second explains how Perl 5's default OO system works. Does that help?
Several people have reported problems in iBooks. I'm not sure what's going on there; perhaps someone can mangle the file and bisect it to find a problem. (An ePub file is a ZIP which contains a documented tree of metadata and content.)
Thanks, I've uploaded that to the site.
Thanks for the tip! I started skimming from the beginning and on page 34 I'm already learning something new (given/when).
If I can ask, I'm looking at a return to Perl after a long, long absence. How out of date is Damian's OOP book, at this point?
I haven't looked at it in several years, but a lot of it is useful with regard to object design and some of it is clever trickery you should avoid. It predates Moose, and that's probably its biggest drawback right now.
I've used it considerably, unfortunately where I work.. moose isn't an option due to memory consumption.
&gt; sub is_almost**($$$;$)** { wait, what's going on there??
How about http://search.cpan.org/dist/Mouse/ or http://search.cpan.org/dist/Moo/ ?
Both really good options, but not options for the same reason. We have insane memory requirements due to some of the systems we deploy on (commercial software vendor..)
See Subroutine Prototypes in `perldoc perlsub`. In short, these change the way Perl 5 parses calls to `is_almost` to force scalar context on three required parameters and one optional parameter.
Skip anything that refers to Class::Std or anything "Inside-Out". It's the mistake of 2005, just like the 70s had white suits with the collar turned up. Otherwise it's mostly a good book. Many of the suggestions are general enough: standardize on a format used by everyone, rather than telling you to use one standard layout. Actually, that has crystalized in the form of perltidy: install a .perltidyrc file specifying how yu want things layed out, and whenever you run perltidy, files will be re-formated according to your requirements ... plays nicely with vim and emacs, too. Many of Damian's suggestions have been incorporated into perlcritic, an evaluation tool. Set up a .perlcriticrc file, and perlcritic will determine whether your scripts follow the guidlines you have specified. It's possible to mark exceptions, which I find useful for updating old files ... marking a subroutine argument line with "## no critic ProhibitManyArguments" is just like a TODO comment, only harder to ignore.
I think pasbesoin was asking about the book [Object Oriented Perl](http://books.perl.org/book/171) rather than [PBP](http://books.perl.org/book/239)
http://search.cpan.org/~abw/Badger-0.06_01/
Anywhere.
I *really* doubt Perl For Dummies has improved in the last 10 years.
`perldoc perltoc` `perldoc perltooc` `perldoc perlbot` 
Reading perltoot and perltooc is a great way to get a million confusing and unnecessary facts about the way you will *never, ever* want to write OO Perl stuck in your head. 
Concur. Is there any way we can rewrite these and submit them for serious consideration for core?
You want to start [exactly right here](http://search.cpan.org/~drolsky/Moose/lib/Moose/Manual.pod). 
This is a current hot-button issue on p5p. People who suggest improvements to docs that tchrist wrote are in for a good roasting. Dave Rolsky has written a really fantastic beginner's tutorial to Perl OO concepts which I hope will be included in core soon, but the path of least resistance will probably be to get it added *next to* perlboot, perltoot, perltooc, perlbot, and whatever else I may be forgetting, and relying on the community to direct people towards the "right" one.
Then just don't use perl.
but we already have a few million lines?
It's been a few years since I've done any "proper" Perl, around when I lost my last job using Perl, where we barely updated to 5. Would you recommend this book to update myself on new "Best Practice" standards and recent changes?
I would recommend reading it, yes. It's good, it's informative, it avoids the misinformation that's sadly prevalent in Perl books written by authors who don't really know the language, and it's very conscious of best practices. And importantly, the practices that it enshrines weren't invented by chromatic -- they represent, pretty much, the things that the authors of some of the most successful modules on CPAN have recognized as good ideas. There are free eBook versions, too, so read as much as you like to get a feel for it, before you decide whether you want a copy on your desk :)
Somehow I find it heartening to see people *not know what prototypes are* -- it's infinitely better than seeing them use prototypes in all the wrong places :)
Money's tight so it's an enormous help to know I can try before I buy, and I'm very much intrigued by the focus on CPAN standards. Years of DIY Perl and clueless searching/evaluation of CPAN modules has left me considering more streamlined and in-demand languages and platforms. Maybe there's hope yet; I'll check it out. Thanks so much.
@Chromatic: I am reading your book right now, but I REALLY hope someone picks up the gauntlet to write the following: 1.) Heads First Perl with Moose 2.) Heads First Catalyst 3.) Objects First with Perl &amp; Moose (OFwJava is FANTASTIC). As I go through the Moose manual I struggle with things I think should be easy such as Multiple module imports, polymorphic inheritance, and programmer-defined field types. I think any of the books listed above is just what is needed to accelerate Modern Perl's Renaissance. 
Exactly. Rewriting tchrist's documentation is going to get you flamed. Hell, even if it isn't his docs he may flame you for adding some my's.
Yes, I meant the OOP book ("Object Oriented Perl", Manning, copyright 2000). Although PBP is on my "to read" list, and I appreciate the suggestions. I've been away from Perl for a decade, following a job change that went -- disappointingly -- in other directions. One thing I've definitely missed is the Perl community. Thanks!
I love this Moose presentation: http://assets.en.oreilly.com/1/event/45/Moose%20is%20Perl_%20A%20Guide%20to%20the%20New%20Revolution%20Presentation.pdf ug, that's a really crummy URL. It's also available on this page next to "Presentation": http://www.oscon.com/oscon2010/public/schedule/detail/13673 
I have no plans to release a competing Catalyst book, but I keep trying to talk the right people into writing a Moose book.
No discussion of lexical filehandles or autodie. FAIL!
The article was bad, but the comments make me a sad panda. I've never seen such a sad cast of people asking for others to do their homework for them on a random page.
What exactly is wrong with using the new keyword that way? 
Any chance for an updated Testing Notebook? That thing is a bible for our company, but the info in it is a bit dated (and misses out on some really useful tools)
It's on my list too, when I convince myself I want to write another book.
Thanks for pointing me to [autodie](http://perltraining.com.au/tips/2008-08-20.html).
`new` isn't a keyword, and the Perl 5 parser has to guess as to how to interpret the intent. The heuristics for intuiting indirect invocation depend heavily on what other code Perl has already compiled in the current namespace. If you change the order of declarations, you can change the interpretation.
Wow, this is a really really amazing guide to Moose.
This PDF was one of the first posts I saw when I joined the Perl subreddit - I immediately saved it to my computer and when I got a kindle sent it there too. I'd been coding a lot of perl, but had not been a part of the community for a while, and this presentation made me realize that my style was getting dated, and that Perl had gotten even better. It's definitely a great set of slides with awesome documentation. Worth keeping around.
Nice. I liked it.
I don't get how to play :(
Even with the instructions it took a little playing around, but this is way too much fun. I'm supposed to be cleaning my apartment today.
Why? MusicBrainz is so much better (in both quality and number of CDs actually in there)!
Awesome. Thanks. 
Here's how I'd write the blurb: &gt;You earn points for each colored square that you eliminate from the white background (1 point per square). &gt; &gt;To eliminate squares click the background where two or more like colors intersect up, down, left, or right (see below). I just randomly clicked around til I got it, but once I did the instructions made complete sense.
I would have to contract an external Perl consultant to review the code--hell run some unit tests of your own.
just by the title alone. Yes.
wow!
I'm interested in Perl 6 but not so much Perl 5. Perl 5 is a very powerful and expressive language and I do not mean to deny that, but the whole motivation for Perl 6 is to do even better. They are also effectively two different languages, both in the "Perl family" - sure, but different enough to deserve dedicated subreddits. I created this subreddit with the hope that people will post interesting content relevant specifically to Perl 6. Who's with me?
Great idea! But I submitted perl6.org as a test submission, but it didn't show up (yet?)
Got stuck in the spam filter, I approved it now.
The Perl subreddit is not circulating content fast enough that fragmenting it further benefits either Perl. 
Great game!!
Logo graphic is reversed. Instead of Camelia's wings saying "P 6", they say "∂ 9". 
I thought it looked more balanced, tilted that way when she sits on the left side (she's on the right side on perl6.org). I fail at gimp though and the only fixing I did was move the ™ and keep it from being reversed. A contributed better version would be surely appreciated.
&gt;I'm interested in Perl 6 but not so much Perl 5. For me it's the reverse. So, yeah, I'm glad its got its own subreddit now. :)
A [non-tilted original version](http://github.com/perl6/mu/raw/master/misc/camelia.pdf) is linked to from the [perl6.org spec page](http://perl6.org/specification/). 
Sounds familiar. When I was a freshman, I worked in support for the CS department. Like the author, I thought myself clever because of the work I saved with, for example, a C program that groveled text files for information about batches of new accounts and ran the appropriate commands to get them in NIS+. Another guy who worked with us had a lots of useful Perl utilities he'd written for other sysadmin tasks, and I was amazed at how much he was able to do with so little code. Before then, I'd had a little exposure to Perl, but I remembered finding it incomprehensible—no, not because of the syntax but its foreign concepts. My fragile little mind—with a background of BASIC, C, FORTRAN, a little C++, and a little Smalltalk—was stuck thinking novice thoughts and wasn't ready for, say, associative arrays as we called them back then. He lent me his copy of the [llama book][1], which was pink in those days, and I read it from cover to cover that night in my dorm room. Being at a sweet spot of [manipulexity and whipuptitude][2] offered frequent rewards and encouraged me to keep going, where I was eventually able to answer people's Perl questions, contributed patches to p5p, and write for *TPJ*. [1]: http://www.amazon.com/dp/0596520107?tag=develooper&amp;camp=14573&amp;creative=327641&amp;linkCode=as1&amp;creativeASIN=0596520107&amp;adid=00YXZWZB4DDDB9EHH4EQ&amp; [2]: http://use.perl.org/~ziggy/journal/26131
That's more loving scripting languages... just sayin'
The "divide" between "scripting languages" and "compiled languages" is quickly shrinking. Think of this: virtual machines are "scripting languages" and bare-metal installs are "compiled". Yes, virtual machine execution is slower than native, but the gains you get from that far outweigh the cons (and the cons (execution speed) are quickly shrinking).
Oh I agree completely. Very few jobs really require C/C++ anymore. Personally I like python more than perl though ;)
This is from 1997, the days where Perl was almost the only scripting language... and definitely the only one with support for regular expressions. All (or almost all) other scripting languages have copied it from Perl, since then. Hashes (dictionaries, maps, associative arrays, ... ) are another (then) novel concept from Perl.
Good point :)
Even better link: http://rjbs.manxome.org/talks/moose/
better link here: http://rjbs.manxome.org/talks/moose/
A major problem with a system installed Perl is that *you should not touch it*, or you might inadvertently break the whole system. If you want to play with a newer Perl, it should preferably be a separate install, side by side with the system Perl, and unfortunately, on most Linux distros this is not easy to accomplish, even impossible for the non-programmer (and I don't mean a Perl programmer). 
Fixed, thanks.
I agree. With only 1 or 2 items being posted to r/perl a day fragmenting seems to be completely unnecessary. I think a better way to spread awareness of Perl6 is to talk about it on the same forums people are getting Perl5 information. Also the very description of the r/perl subreddit is as follows: "The Perl Programming Language, including both Perl 5 and Perl 6"
My girlfriend got sucked into programming Access/VBA at work, and quickly learned to hate it. I had her read Modern Perl and the Catalyst tutorial. This is the first thing that she's completely made.
Perl + Catalyst. Nice!
The passwords are hashed and the schema is quite sane as well. It has some rough edges, but I was very impressed.
I'm working on a Catalyst app right now, and I didn't even bother defining the schema. I built the DBIx::Class definitions and used deploy() to build the actual database (double checking that it's actually sane). Makes things easier because now I don't have to care how the DB is made - I can just deploy() to whatever backend I happen to need to use.
She knew SQL, but not perl, so it made more sense to use Schema::Loader. http://search.cpan.org/~frew/DBIx-Class-DeploymentHandler-0.001004/ You probably want to check that out, all the cool kids are using it for their new projects.