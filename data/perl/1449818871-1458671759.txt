The question is how the bees got in and how P5P is now a hive filled with bees. It seems this problem wasn't always the case, and is a growing one, so once upon a time, either the bees weren't a problem, or there were no bees, or the bear never fell into any hive. ^( I seem to be too good at ruining analogies )
It is getting old and much of it is not done in the "Modern Perl" way but it is still a tremendous reference book that saves me a bunch of time. If I'm doing a one-off script, I'll often just lift from PCB and tweak as needed. If its for a larger, more permanent project, I can start there and move it to more modern Perl as needed. Admittedly there are parts of it that are sorely in need of rewriting and it does not use any of the newer, better functions that have been introduced but there is still nothing like it overall.
I agree-- I'd just want a Perl 5 focused book. I would be interested in an updated copy. 
So like a Rosetta Stone of Perl5 and Perl6... 
&gt; I seem to be too good at ruining analogies Nope, not good enough. I implore you to keep practicing ;)
&gt; Rosetta Stone of Perl5 and Perl6 [But we have one of those, already.](http://rosettacode.org/wiki/Category:Perl_6) 
I'm just waiting for Nicholas Cage to turn up for some reason
How does it compares, quality-wise, to the cookbook?
from perldoc -f rename: Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries [...] For a platform independent "move" function look at the File::Copy module. 
I don't know what "across file system boundaries" is supposed to mean. Does that mean copying from a FAT32 partition to NTFS or something? That's rare enough that you can use a module in that case.
It can simply mean a different partition: % perl -wE'rename "/tmp/testfile", "/home/user/testfile" or die $!' Invalid cross-device link at -e line 1. Both partitions are ext4.
My familiarly with TPC is from way back in 1999, and, along with the Camel Book, was what I used to learn Perl on the job. TPC came in handy, as I could literally copy and paste solutions to the small problems I had - and in turn, learn by doing. I learn mostly by doing, rather than merely reading. You can also feel that the book was written by multiple authors, so there's a TMTOWTDI feel to it. Think of it, maybe, as a best-of, of Perl patterns. Modern Perl is a different style of book and I was a different Perl developer when I read it. What it really proved to me was a way to get up to speed on newer developments and ideas of how to use a language I was already very familiar with. Even though I was familiar with Perl, it's such an expressive language, it's easy enough to keep on your own track of how to do things, and not grow as a developer. MP was a way to break out of my own conventions and allow me to critically think how I can use perhaps better ways to do things. It's going to be a little more editorialized on the author's opinion of good ways to do things (not that it doesn't give alternatives on some subjects). I think the major problem with TPC is that it's a little long in the tooth, so if you use it, you're going to use Perl as it was before Perl 5.6. To wit of all that, I recently picked up The PHP Cookbook, to try to get me up to speed with PHP. It worked well enough, but wasn't as fun to read as the Perl version - I'm not really sure why. Maybe I was a little surprised how awkward some of the PHP was, to get your sh*t done - but that also could be me being more of a champion of Perl, than PHP. (grain-of-salt) 
[removed]
This is very well done, thanks. The brick wall I continue to run into with regard to perl web development is safe database connection pooling. Even just to create a quick dashboard view into what's going on with some backend app's (java) oracle db never performs very well for more than a few concurrent users. Spring Boot just makes this so easy nowadays that's it's quickly becoming my go-to despite how cool Mojolicious and Dancer are to work with.
PDF somewhere? Dealing with LinkedIn/SlideShare is annoying and usually harmful.
Guessing you don't trust the "Download" link on SlideShare which serves a PDF then?
Thanks for posting. I'm the author (Christian), new redditor on that occasion. I posted it on [HN](https://news.ycombinator.com/item?id=10611266) a few weeks ago. Give me a piece of code and I'll tell whether I would write it differently using functional-perl idioms (I'll give you working code if it's not too much work). Also, feel free to ask me anything ;)
LinkedIn's business model is an aggressive mix of spam and web tracking, so I try to avoid them, and still sometimes have to delete their junk email (I'm still not reading that, guys ;-). SlideShare probably provides analytics or "social" or something, but serving up a plain old PDF is basically free these days, so I just don't see SlideShare's benefit.
Looks like the P6 peeps already took it onboard https://perl6advent.wordpress.com/2015/12/07/day-7-unicode-perl-6-and-you/#comment-14382
&gt; I first noticed Perl6 was acting as if different EOL conventions did not exist about two years ago Minor point: the article you linked was published a year ago. &gt; I am uncomfortable with what seems to be a "everything is Unix" assumption in perl 6. Hopefully you've since figured out that there is no such assumption. (The common sense evidence is that the #1 Perl 6 dev has used Windows almost exclusively for the better part of a decade.) &gt; It seems, from a distance, to a person not familiar at all with how Perl6 internals development works Following discussion on #perl6, Larry Wall, Perl's author, made the final calls on how best to handle the issues related to the commits you linked. This is the general pattern for Perl 6 language design decisions. &gt; they seem to have settled for manipulating string literals in a program Have you read the "Line endings" section in [a recent blog post by jnthn](https://6guts.wordpress.com/2015/11/21/what-one-christmas-elf-has-been-up-to/)? &gt; PS: You can discuss this issue on /r/perl. Minor point: The link you provided goes to a reddit about another of your posts on /r/perl6.
self!somemethod does what again? It's that just for methods that are declared with a bang to make them private to the current class?
I submitted a bug report, they added it to the list of blockers for release. It was important to me to figure out if this was a mistake or a conscious design decision, but I did not feel it was worth wasting Perl6 devs' time to figure *that* out. Note that [lending a hand when I can][1], and publicly speculating on certain issues are not mutually exclusive. My [bug report][2] succinctly summarizes the issue: &gt; EOL conversion should only happen at input-output boundaries. That's all the devs need, and they could, of course, contact me if needed, or consult the blog post for the more long-winded explanation. I don't think it is necessary for me to chase after people on IRC, and waste their time during the countdown to Christmas. [1]: https://github.com/perl6/roast/pull/87 [2]: https://rt.perl.org/Public/Bug/Display.html?id=126881
I still support a couple of CGI scripts. I've identified security issues in them that are nearly impossible to fix because of the script design. None of them are because it's using CGI, but because people weren't programming defensively 15 years ago when the scripts were written. They're made for intranets, made to be run behind passwords so that at least they're secure from the outside. Even so, there might be times when someone wants to expose the script to the world for customers to use and they don't know the flaws. If a site isn't taking the time to stay current with perl features and best practices then it's a pretty good bet their CGI programs are near-unmaintained. In this case, it seems the gamebase64.com author had been using PHP for 10 years and not really touched his CGI perl stuff because it just worked. Even schmorp said that he has only used CGI twice, decided it was crappy and not touched it, but for some reason he believes it should be continually supported in it's shitty state. We could say breaking an old perl site is a tragedy, especially if it's now being moved to PHP, but I don't think much is lost here. As an example, if perl still ran 20% of the web just because geocities was powered by perl then it's not a feature worth hyping, it's a legacy. I do think that documentation for moving away from CGI is very bad. Most people assume you're not using the HTML generation functions and just give you "simple" instructions like "setup a new perl based webserver. Forward things to it with 10 lines of obtuse things you add to your apache config" While that may provide the best performing solution, the easier route for most people to start with would be converting to Mojolicious::Lite and leaving the script in cgi-bin/ until they grow used to the newer ways. Yes, the newer ways are 10 years old, but if you went CGI -&gt; PHP and now you're back in perl you need some adjustment time.
&gt; While that may provide the best performing solution, the easier route for most people to start with would be converting to Mojolicious::Lite and leaving the script in cgi-bin/ until they grow used to the newer ways. Yes, the newer ways are 10 years old, but if you went CGI -&gt; PHP and now you're back in perl you need some adjustment time. You can use [Mojolicious::Plugin::CGI](https://metacpan.org/pod/Mojolicious::Plugin::CGI) to run the cgi scripts from within your Mojolicious app. This allows you to migrate, piece by piece, from the old scripts to the new whilst you get up to speed. Gives you easy a/b testing as well as easy access to [Test::Mojo](https://metacpan.org/pod/Test::Mojo). This isn't just theory either, it was the subject of a [talk](https://leejo.github.io/using_mojolicious_for_fun_and_nonprofit_an_update/#/) i gave at LPW three days ago, an update to a talk from 18 months ago, about how we moved from a legacy CGI.pm app to Mojolicious using this very method. [This](https://www.givengain.com/) is the result. IIRC both Dancer and Catalyst have plugins to wrap cgi scripts too. If you're using mod_perl then this solution might not be as trivial.
&gt; I do think that documentation for moving away from CGI is very bad. Most people assume you're not using the HTML generation functions and just give you "simple" instructions like "setup a new perl based webserver. Forward things to it with 10 lines of obtuse things you add to your apache config" I kind of agree with that. Whenever I suggest that someone moves to a PSGI/Plack solution they immediately assume that it's going to be really difficult. It isn't, but we really haven't done a good job at demonstrating that. I'll give some serious thought to how we might address that. But, I'm afraid I am one of those people who assume that you're not using the HTML generation functions. After all, we've been recommending that you don't use them for well over ten years :-)
Every even half-decent hosting service I've ever used has given me the option of installing a selection of Perl modules from the control panel. So I'd be fairly surprised if the person he uses as an example wasn't able to get it installed that way. And even if *that* isn't an option, there's no reason why modules can't be uploaded to your web-space and used from there, which is something I've often done where I need specific modules that my host doesn't provide. That said, CGI.pm is one monster of a module if like me all you use if for is to grab POST or GET data, which is why I've replaced it on most of my sites with a custom module that **purely** provides that functionality. (Not *nearly* generalised enough to publish though).
Yeah. So Centos 6 includes Perl 5.10.1, which *should* include CGI as standard. But the perl RPM produced by the Centos team (and, presumably, they're just copying RHEL here) has many "non-essential" modules removed. But they still have the "perl-CGI" package available. You can (or your hosting provider can) install it easily with `yum install perl-CGI`. Perhaps a better idea is to install the "perl-core" RPM - this is a "meta-RPM" which will install all of the missing modules. I don't really mind them shipping a cut-down version of Perl. I do mind them doing it in an RPM that is called "perl".
Oops, I guess I was thinking of centos5. Either that or they're using older versions of cpanel that clobber /usr/bin/perl. Those perl RPMs take their crappiness all the way upstream from fedora - http://pkgs.fedoraproject.org/cgit/perl.git/tree/perl.spec?h=f21 They're still all built as part of the same compilation process but packaged into separate RPMs for @reasons
Yeah. Centos 5 was all kinds of disastrous for Perl RPMs :-/
Face it. [CGI.pm sucks.](https://www.youtube.com/watch?v=jKOqtRMT85s) Nobody should be using it. It's arcane and monstrous. It needs to DIE DIE DIE DIE DIE DIE IN A FUCKING FIRE! And hopefully, one day, we will stop talking about it.
Oh look. Another quality shit post by Marc Lehmann. From the same guy that gave us [this auto-die code](https://metacpan.org/source/MLEHMANN/AnyEvent-7.11/lib/AnyEvent.pm#L1435) or ["stableperl"](http://blog.schmorp.de/2015-06-06-a-stable-perl.html) or [common::sense](https://metacpan.org/pod/distribution/common-sense/sense.pod#WHAT-OTHER-PEOPLE-HAD-TO-SAY-ABOUT-THIS-MODULE).
It is what I've used, but not proper pooling per se. You can't really control the maximum amount of concurrent handles allowed out of the box, for example (as far as I am aware). So you have to do a lot to avoid spawning a lot of connections against the db. One old Mojolicious example using DBIx::Connector I have kicking around which is likely awful. It was used to pull info out of various environments and display them on a data table, which is what the whole env/leg junk is about: # We want to use separate state variables named like env_leg for each environment's dbh so we're not constantly re-initializing them and unnecessarily spawning new processes. # There's no fancy syntax to iterate or create state variables in list context so we have to write it all out. $self-&gt;helper(all_dbhs =&gt; sub { state $dbhs = { prod_a =&gt; state $dbh_prod_a, prod_b =&gt; state $dbh_prod_b, stage_a =&gt; state $dbh_stage_a, stage_b =&gt; state $dbh_stage_b, }; }); # Initialize db connection. $self-&gt;helper(new_dbix =&gt; sub { my ($self, $env, $leg) = @_; DBIx::Connector-&gt;new( 'dbi:Oracle:' . $env_conf-&gt;{'ora'}-&gt;{'envs'}-&gt;{$env}-&gt;{$leg}-&gt;{'sid'}, $env_conf-&gt;{'ora'}-&gt;{'credentials'}-&gt;{'user'}, decrypt($env_conf-&gt;{'ora'}-&gt;{'credentials'}-&gt;{'pass'}) ); }); # Get a DB Handler $self-&gt;helper(db =&gt; sub { my ($self, $ora) = @_; my $env = $ora-&gt;{'env'}; my $leg = $ora-&gt;{'leg'}; # Initialize the DBIx::Connector connection if hasn't been done yet. if (not $self-&gt;all_dbhs-&gt;{$env . '_' . $leg}) { $self-&gt;all_dbhs-&gt;{$env . '_' . $leg} = $self-&gt;new_dbix($env, $leg); } # Calling -&gt;dbh here rather than at the DBIx::Connector-&gt;new (new_dbix helper above) will handle reconnecting for us without spawning new processes. # Otherwise we would be holding onto the same dbh and it would become stale after some time and never reexecute the status/connection check to know if it's alive. return $self-&gt;all_dbhs-&gt;{$env . '_' . $leg}-&gt;dbh; }); # DB Select Query $self-&gt;helper(db_select =&gt; sub { my ($self, $application, $type, $bind, $ora) = @_; my $query = $app_conf-&gt;{$application}-&gt;{'queries'}-&gt;{'base'} . $app_conf-&gt;{$application}-&gt;{'queries'}-&gt;{$type}; my $dbh = $self-&gt;db($ora); my $alter = $app_conf-&gt;{$application}-&gt;{'queries'}-&gt;{'set_schema'} . $ora-&gt;{'schema'}; $dbh-&gt;do($alter); $dbh-&gt;selectall_arrayref($dbh-&gt;prepare_cached($query), undef, @$bind); });
You can maximise(ish) the number of concurrent connections by Chucking your DBIx::Connector instances into a Cache::LRU and having some respawn behaviour baked into your module that's responsible for making the connection will limit the number of connections. As far as I can tell having a non-deterministic possible number of connections is an artifact of a bad architectural problem (e.g. multitennancy in a forking scenario where the number of tennants and forks can be arbitrararily high).
To be fair if you've made some bad architectural decisions in the past (e.g. failure to refactor from CGI.pm to mod_perl properly) then moving to PSGI *is* hard. However for the most part it's pretty trivial and your developer staff will thank you for doing so, prior experience with CGI.pm or otherwise.
&gt; I am going to consider any release to be successful. Fwiw, aiui: In terms of what Larry is focused on, namely drawing a testable line in the swirling sands that nails down a 1.0 of a language specification, not a compiler, it will be a success by "definition". That "definition" is a set of tests tagged `6.c` or somesuch. This is scheduled to be ready by the end of this year. He thinks said test suite can serve as a form of electronic "specification" and as a first line of QA of a compiler. I'm confident they will actually release that "definition" in the next few weeks and Larry will consider that to be accomplishing the "get ready to party" 2015 goal. Larry thinks establishing this 6.c suite of tests (in combination with a compiler that passes them, a compiler community happy to provide ongoing support for that compiler, and a longer term commitment^1 to compiler updates that don't regress relative to them) is a pivotal next step in Perl 6's evolution. It remains to be seen whether it has any significant impact, positive or negative, on adoption^2, but it makes a lot of sense to me as the next logical step for Perl 6. ---- ^1 Anything remotely like LTS would require formal announcement of such, with a specific date, and credible players and resources backing the announcement. I can't imagine Larry and his ragtag band of a couple hundred volunteers going there so it'll be interesting to read what guarantees, if any, Larry is willing to declare in his Perl 6 advent post. Personally, I'd be very happy if for now any such commitments remain grounded in [-Ofun](http://perl6.org/fun/). ^2 After about 4 years of relatively flat or slightly upward measures of interest and community activity, this year has seen clear but not spectacular growth in interest and activity. For example, this year the average peak number of users on the #perl6 channel each day has grown from around 200 to around 300 and the /r/perl6 subscriber count has grown from around 300 to around 500.
RT#126881 has been resolved. I hope I get a chance to test it before Christmas. It looks good. https://rt.perl.org/Public/Bug/Display.html?id=126881 Thank you to Perl6 developers.
Search the internet for information about 'trapping signals'. Long story short, there are more than a few ways to do it with perl.
Do you think hand-feeding people answers is helpful? edit: This is getting some love, so I figured I'd take a second to explain; More people than you think have no idea how to search the internet. Why? Because they have never had to learn, which is why many of them are here on reddit asking questions that can easily be found via popular search engines. By not hand-feeding answers, there's an opportunity for them to ask for clarification if they don't understand 'search for $TERMS', so someone could perhaps point them in the right direction and / or explain how search engines work. Sure, it seems silly to not understand that, but some people clearly seem to not understand it and are capable of learning and bettering themselves. In this instance, I didn't assume the OP didn't know how to search the internet, but that they were confused about what the terminology for 'ctrl-c' was in programming.
What am i missing? are there any good guides for this? I have been googling like crazy for a guide and cant find anything
Nah, but I think you're a dick.
&gt; are there any good guides for this? Well, back in the olden days when CGI was still a reasonable approach to writing web applications, [Ovid's CGI course](http://ovid-cgi-course.perl-begin.org/cgi-course/) was generally considered to be pretty good. It may still work for you.
OK. The schmorp blog picks up on a web page written by someone who apparently no longer does Perl for a living and is clearly mistaken as to the reason why he wasn't able to set up some site. Because the garbled reasoning at this URL can be used to feed schmorp's need to complain about stuff, he goes ahead and does that. If I may say so, the real error here is reading schmorp's blog. 
You summarized this perfectly.
Well, it's true that the whole blog post was triggered by schmorp's. But the first two-thirds of it don't mention him and (I hope) contain useful information that many people might not be aware of. Perhaps it could help a web hosting company understand why their Perl support completely broke when they upgraded to Centos 6. The CEO of Blacknight has already asked his tech team to consider following my suggestions. And the final paragraph is something that I hadn't considered until I was writing the post. We've assumed that a "Perl 5.22 web hosting crisis" was just around the corner. But it turns out that there's also a "RHEL6 web hosting crisis" that has been with us for a few years. And the fact that we haven't noticed is an interesting datapoint. Perhaps it means that the number of people using Perl on hosting services like this is far smaller than we've previously assumed. So yes. Generally, not reading schmorp's blog is a fine plan. But on this occasion I think it led to something useful.
File this with: "I don't do X so therefore no one else must do X. X is dead!" Like my wife who wants to cancel our phone line. She does not use so no one else does. I had to explain to her that I use modems to connect to older remote devices for configuration. I also have a device connected via modem for testing. 
I'm not saying that CGI is dead. I'm saying that I'd like it to be dead. I'm saying that it should be dead. But I realise that it isn't and therefore I'm trying to ensure that it is supported as widely as possible for as long as possible.
&gt; In this instance, I didn't assume the OP didn't know how to search the internet, but that they were confused about what the terminology for 'ctrl-c' was in programming. Why not answer both questions? "What you're looking for is called 'trapping signals'. You can find information with `perldoc -q signals`."
Oh yeah, Google Plus... That's still a thing.
the article author should mention that he is also the module author
&gt;Perl reminds you, "Hey! Hey! Lots of me is just a little wrapper around C library stuff!" Isn't that great? You know what else is great? Perl, being an interpreted language, means using the latest code in your environment can be as simple as a 'git pull'. The comment is on point but overly sarcastic as if to speak down about perl in general. Isn't it also great the author could TIMTOWTDI this solution? You can tell us what problem you're solving without all the flair.
Congrats!! It's remarkable to do something that lasts 20 years and is adopted by other programming languages. Randal must be ver proud of himself.
I would counter that the reason for text streams is the lack of a useful distinction in the data structure the data is being stored into. Perl 6 seems to instead of using a translation layer to handle text input and output, use a storage medium with that built in(if choosing to store in a String), or one without that feature if storing raw data (Buf). I think I like this from an encapsulation perspective, and from a separation of concerns perspective. IO does IO, Strings do text and characters, and Bufs and Blobs do data. Whether it's how it has been historically done is irrelevant to whether I think it makes sense, so I like in that respect. Unfortunately this is the real world, and dealing with how things have been historically done can matter. That said, i'm not sure the way Perl 6 has implemented it is all that bad. If you want Perl 5 or "traditional" or "historical" string usage, use Bufs. If this becomes too much of a pain, someone will create a P5Str type purely for dealing with this.
&gt; What are the options for smaller systems? Something written in raw Plack wouldn't be very heavy. And you'd get all the advantages of PSGI. * Easier debugging and testing * Access to loads of useful middleware * Easy deployment in whatever environment you want - from CGI to mod_perl or even a stand-alone daemon running behind an nginx proxy. 
You underestimate what's possible with even cheap web hosting platforms. VMs are the norm. Even without VMs, you still have plenty of room to do a lot with your web space. As far as experience goes, if somebody wants to play around with CGI/PSGI with Perl, there's plenty of other easier options, and it shouldn't be CGI.pm. Besides, if these cheap shared web hosting platforms want to stay in business, they'll make sure that their servers have the right tools for web scripts.
I caved on [Plack::Middleware::SSI](https://metacpan.org/release/ZARQUON/Plack-Middleware-SSI-0.12) and took on comaint seeing as it didn't seem to require anyone's permission to do so.
You overestimate the ability of people to figure out how to help themselves. Many of these people have nothing or very little to do with Perl, and even the most basic (to you and me) steps in getting something like plenv set up are huge obstacles. Lots of ambient knowledge goes into making things like that seem obvious and simple.
FWIW I’d be very grateful if you switched to [Speaker Deck](https://speakerdeck.com/). At least as a reader I have found that place a far more agreeable experience.
Who was on the selection committee? I take critic on one poor selection choice.
I don't think so no. http://modules.perl6.org/#q=qt Where did you see modules for older versions of qt?
System perl, CGI.pm and [a prayer](https://youtu.be/2U_JpBr157A)... the battle cry of the no-stack perl developer. 
OP here, just thought i'd check back after a bit. FYI, you have to know what you're searching for. I had had several searches for kind of generic, 'how to make a perl script not stop on ^C' to no avail. A couple permutations later and I got fed up with searching, and decided to ask people how to do it. I did need to look up things on 'trapping signals' and that info was very helpful btw.
You can use PySide and PyQt via Inline::Perl5 and you can use [electron](http://modules.perl6.org/dist/Electron) for GUIs as well. Both should give you a lot more freedom than our GTK::Simple currently does.
Thanks for the new edition, chromatic! As a new Perl programmer, I wanted to tell you we still exist and your work is extremely helpful. Between your book and Perl Best Practices, I have been able to pick up the language quickly and have been using it professionally without missing a beat. Coming from SQL and a smattering of 'Hello Worlds' in a number of other languages, your book was perfectly suited to move me beyond the basics and give me the tools needed to start building some very powerful things. Thanks for advancing Perl and staying active in the community. 
A few people have mentioned that to me. I guess it's a question for p5p or TPF to look into.
Can perl 5 be considered a good investment, considering that perl 6 is approaching?
I wrote my own photo manager (browsing/cataloging) application in Perl (using SDL::Perl). Is there something wrong with me?
This isn't an answer to your question, but I've repeatedly had lousy experiences using C++ GUI toolkits from scripting languages. As soon as I've tried to do anything beyond bare-bones I've repeatedly hit bugs and incorrect documentation. Sticking to C++ for the GUI layer and embedding perl as appropriate makes the most sense to me. There's also the issue that GUIs of any complexity especially call out for extensive compile time checking more than a lot of other code.
I'll be the one to say (as no one has yet) that the two are different (related and confusingly named) languages. Perl 5 isn't going ~~anywhere~~ away!
I don't know, I think tsee deserves the award just for putting up with your abusive behaviour.
Wow that sounds complex and quite cool!
Sorry, but it's the other way round. Try to see it from my POV, having to experience constant abusive behavior by totally incompetent and arrogant leaders who managed to run to ship into the ground. Never ever was a member of the cabal punished for their abusive behavior, even if there is now a CoC, and I'm the one getting called for criticising their abuses and incompetence. Evident double standards. The last time with I module I was trying to fix is suddenly getting a hostile take-over, and now the API is broken of course. I had to rename it, but that is no good solution neither. What happened to the ones producing this hostile takeover. Was this ever addressed? Why is someone with a history of not being able to maintain critical modules allowed to go on with "critical document patches" (fixing a typo)? I will not stop criticising the bad apples until their commit bits get taken away and they will not be able to continue their damage. I have no problem with tsee. I only have a problem with the bad apples. You should too, but as I wrote toxic behavior is apparently rewarded in the perl community. Hence my criticsm. You are affected after all. But apparently nobody cares and is buying their marketing nonsense which is far from the reality.
&gt; pre-increment and pre-decrement are now a bit faster yet. (TimToady) Faster than before (`++$myval`)? Faster than post incrementing (`$myval++`)? Faster than self incrementing by 1 (`$myval += 1`)?
I'm saying that in practice trying to use Qt or Wx from perl or python is not a great idea. The bindings just don't work as well as is advertised. I think in practice Tkx is probably the best way to write a GUI in pure perl. Just doing it in C++ with QtCreator is probably the best way of all. QtQuick is a fantastic way to make GUIs these days. Then if some of the tasks the application does are best done in perl, call out to perl either by embedding or IPC.
Thank you, sir! 
Set a new seed when forking. Explicitly call the rand function you need, dont use wrappers.
That's very nice. I guess the "Int" version is less than one order of magnitude slower than perl 5. And the native "int" version is quite a bit faster than perl 5.
I wonder why the `+=` operator is so punishingly slow - especially in comparison to `$i = $i + 1`!
Well, it's already optimized via a little cheat. Here's the detailed explanation: += itself isn't a dedicated operator. instead, METAOP_ASSIGN will be called on &amp;infix:&lt;+&gt; and the result is what is applied to $i and 1. Kicking out the cheat that's in the optimizer gives us an even worse result: timo@schmetterling ~/p/rakudo (nom)&gt; time perl6 -e 'my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 6.72user 0.01system 0:06.75elapsed 99%CPU (0avgtext+0avgdata 77324maxresident)k timo@schmetterling ~/p/rakudo (nom)&gt; time perl6 -e 'sub METAOP_ASSIGN(\op) { -&gt; Mu \a, Mu \b { a = op.( a // op.(), b) } }; my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 17.79user 0.02system 0:17.83elapsed 99%CPU (0avgtext+0avgdata 86012maxresident)k As you can see, as soon as a custom METAOP_ASSIGN exists in a scope, the optimizer will say "well, all bets are off". Otherwise it generates code equivalent to this: timo@schmetterling ~/p/rakudo (nom)&gt; time perl6 -e 'my Int $i = 0; Nil while ($i = ($i // &amp;infix:&lt;+&gt;()) + 1) &lt; 10_000_000' 6.32user 0.02system 0:06.35elapsed 99%CPU (0avgtext+0avgdata 78356maxresident)k timo@schmetterling ~/p/rakudo (nom)&gt; time perl6 -e 'my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 6.73user 0.02system 0:06.76elapsed 99%CPU (0avgtext+0avgdata 77168maxresident)k The thing is, we can't reliably do METAOP_ASSIGN without making an extra call to op.() to get the neutral element to use when the container we assign into is undefined at that point - because *= would have to work with 1 and += has to work with 0, but ~= has to work with "", not 0 or 1. Right now I'm working on a patch that may make the closure created by METAOP_ASSIGN a bit cheaper. I'll report my findings later.
The whitespace... is everywhere...
 s/RT/LT/g; Does that do what you want? Changing the $_ variable via regex means $nope is no longer part of the string. 
i'm going to show how much of a Noob I am. $_ is used in many scripts I work on but I didn't write them. I borrow code and understand 80% of what is going on but I don't really know what the $_ does. I know if I remove it I get an error and the script doesn't even want to run. And the script is doing almost everything I need it to do.
$_ is a special variable: http://www.tutorialspoint.com/perl/perl_special_variables.htm
Do you have the whole of your script? Including how @data is originally defined.
I posted the rest of the script if that helps.
Of course. Because money is the only real reason for anything right? /s As opposed to having motives where money is useful to achieve them. As opposed to having motives where the lack of money is prohibitive. Obviously, people can make money working for an employer in the context of writing code that an employer deems necessary. Why is it so hard to imagine a reality where that employer is CPAN, or an organization that represents CPAN, collects donations to further the objectives of that employer, and then uses those donations to fund staff who can further a list of goals that CPAN/Organization considers useful? Or is work only deemed relevant when the organization funding it is a for-profit ?
previous thread: http://redd.it/1mkdl4 I am not affiliated with Booking except as a user of their Web site and as a reader of their tech blog and as an attendee of a Perl QA hackathon that happened to be hosted in their Amsterdam office. I consider myself part of the Perl community, and have often come into contact with employees. &gt; the only people that seem to be defending them are current employees -- I'm worried they have a bit of Stockholm Syndrome It's easy to make up a claim, but difficult to disprove. That pendulum swings both ways; I might claim as well the commenters on Glassdoor and b.p.o are clueless dweebs that would stir shit up at any place with misleading information, and now both me and you are none the wiser. By talking to B. employees (Abigail, potyl, tsee, book, avar, sawyer_x) or reading their public statements (nperez, dgryski), I did not get the impression that they live in a state of repression or confusion. They all knew what they were getting into, as B. makes their culture and expectations perfectly clear beforehand, especially with Abigail's public talks. I feel dumb for writing [apologia](http://enwp.org/apologia) as an outsider because I'm bound to misremember or have outdated notions and thus get things wrong, so anyone with more clue than me please send corrections, but here it goes. &gt; no tests, no code review, no QA Sounds scary without context, but it's really just a different way to work than you are used to. You need to realise that these industry best practices *are* situational; B. is an outlier and if they say it makes sense business-wise to replace them with different processes (such as the huge focus on A/B experiments) then you got to provisionally accept that. Specifically, no QA is wrong as there is a quick feedback loop after code deployment that catches errors better than CPAN style formal automated testing. &gt; copy-pasting code There's also the platitude that B. is in the business of offering hotel room reservations, not writing well-factored code. The argument goes like this: implementing requirements fast pays off right now and certainly as it earns money, but well-factored code does not; it has no intrinsic value and its advantage over the dirty code might pay off only in the future and not with certainty. There hasn't been a pressing need to refactor. If it ever becomes one, it's easy to hire more developers. A small portion of the overall code that deals with delicate parts of the infrastructure involves a great deal of thinking and planning does not need to rush and does use the traditional best practices. &gt; huge influx of new developers with no training into a giant legacy code base with mountains of technical debt, bad management, high turnover of developers I cannot comment on that part. Would love to hear some facts in naked numbers so it can be compared with the rest of the industry. &gt; The justification they provide is "Our methods must work, because we're very successful and make a lot of money." So…? I'm at a loss why you merely mention this without follow-up. Do you want to argue it's not true? &gt; I found their official(-looking) GitHub account ( https://github.com/bookingcom ) , but it's empty, which doesn't bode well for the quality of their code if they haven't managed to clean anything up for public consumption. The conclusion is fallacious, you cannot deduce that from an empty git repo. B.'s public contributions are elsewhere and ample. Look at what exists to judge its quality, not at what not exists.
This "question" seems to be trolling ...
&gt; Perl 5 isn't going anywhere Now I KNOW you meant that in a good way, but visitors to the site may misinterpret that!
Interesting. I didn't find prior editions particularly obfuscated. But I've recently gotten rid of almost all of my books for a move cross-country, so I have a delightful excuse to buy 4th edition :) Looking forward to it. 
&gt; http://www.tutorialspoint.com/perl/perl_special_variables.htm tutorialspoint is on the [rejected list](http://perl-tutorial.org/rejected/) of perl tutorial sites. Perhaps there are some [better ones](http://perl-tutorial.org/) that could be referred to instead?
hehe, yeah. fixed
But notice that they're all closed!
That's how I remember hearing it. As I said, I welcome any corrections or updates. Are you from Booking? I also heard that one program manager doing something with databases forbids his team to copy-paste, and some devs have taken up the habit to subvert the culture by refactoring the commit they were working on if it does not take any significant extra time, and calling it unforking.
It sounded so dumb and shallow I wasn't sure it was a serious "argument".
Thanks a lot for asking this question. It made me go in, look at the code more precisely, and find a nice little semantic improvement that also happens to give a tiny speed boost: Currently, METAOP_ASSIGN was generating a call to //, which is our "defined or" operator. That asks the object for its definedness by calling its .defined method. Among other things, that's a way to defuse a Failure. So code like $foo = Failure.new(); $foo += 1 used to turn the failure's "handled" flag on and it wouldn't be thrown. After investigating the METAOP_ASSIGN code, TimToady told me it would be saner to use .DEFINITE instead of .defined. Not only is .DEFINITE much simpler (as it doesn't involve an actual method call; it's more like a macro), but in the case of Failure it's also better behavior. Here's some new timings for you: Newest commit: timo@schmetterling ~&gt; time perl6 -e 'my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 4.37user 0.02system 0:04.40elapsed 99%CPU (0avgtext+0avgdata 77716maxresident)k Older version still using // time perl6 -e 'my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 6.83user 0.01system 0:06.85elapsed 99%CPU (0avgtext+0avgdata 77744maxresident)k In-between: .DEFINITE, but no short-cut in the optimizer time perl6 -e 'my Int $i = 0; Nil while ($i += 1) &lt; 10_000_000' 16.19user 0.02system 0:16.23elapsed 99%CPU (0avgtext+0avgdata 93980maxresident)k 
I've heard everything daxim reports as well.
&gt; I didn't find prior editions particularly obfuscated. My thoughts changed when I realized that a lot of readers of the HTML edition didn't speak English as a first language and weren't necessarily adults with secondary education (more readers were under 18 than I expected). I'm content to explain a concept (even make a forward reference) and expect readers to keep up, but I thought some of the jargon was unnecessary and could be replaced by clearer explanations.
&gt; Thanks for advancing Perl and staying active in the community. I appreciate the kind words and am heartened to hear that you found it valuable.
Ah. Fair enough. I'm definitely not a part of that readership demo.
oh, god damn it, RT. Not making the ticket numbers clickable in the "dependency on ticket #*** removed" ... &gt;:(
Why is the fact that the work in Perl a major downside? I could say that about any company and any language, but from me it would be pure hyperbole. "The fact that Facebook works in PHP is a major downside." Is there something I'm missing or do you just not like Perl?
thanks. too bad about the politics. booking.com needs to make it easier to find the list of projects they have released and support. why keep saying you dont have tests or code review if you do?
If some bugs have been removed from the list then they are no longer bugs that are blocking the 2015 release of Perl 6. So I stand by my description. All of the tickets that were blocking a 2015 release of Perl 6 have been closed. But, yes, the list of bugs that needs to be fixed soon after the release has grown :-) I'm hearing that the official release will be at about midnight EST tonight.
The 5 "bad apples" are easy to check out. What good have they done, what bad have they done. Over the last 13 years. How much better would the product be without the constant danger that they will come up with something similar to their previous contributions. How would the code base and the feature list look like? It's pretty easy, given their track record. I'm not counting those who like to call other people "assholes", as the guy in question here. This is only the side-effect of the toxic culture. Then the number would be much higher. You''ll have a hard time to argue, because with a clear todo list (perl6 minus the incompatibilities) exactly 2 features were developed successfully: say and defined-or. Effort: 2hrs. This is the glorious outcome of 13 years work. Everything else was a desaster.
Ouch, the videos are still reminiscent of the "90's quality" videos that past Perl workshops/conferences had :-) The Dancer conference's videos are nice though (although the audio could still be improved). 
Wow. For real? 
I find the attempts to muzzle you by way of this notion of civility intolerable. That doesn’t mean I don’t find you a pain in the arse, for other reasons. Those people may or may not have been a disaster, but the notion that if only Perl&amp;#160;5 had just had competent maintainers it could have been turned into Perl&amp;#160;6 piecemeal is ludicrous. Larry himself realised it is not possible – that is why he started from scratch. Or maybe he is incompetent too. But the claim you are making there is a nutshell summary of your own incompetence: you do not understand the design of Perl&amp;#160;5. And speaking of track records, you have one too. The first time I noticed you was when you came on p5p and started yelling about how moronic the implementation of `defined` in perl is, and it took a long and massive thread to get you to understand the simple fact that `defined` in Perl&amp;#160;5 is not the same thing as the `defined` from typical Lisps. Most recently I remember you criticising the new refaliasing feature being different from Perl&amp;#160;6 binds – even though that was the starting point for the design, and it only changed when it was discovered that that design cannot work in Perl&amp;#160;5. (Because Perl&amp;#160;5 flattens lists and Perl&amp;#160;6 does not, basically. Which is a design choice that affects so many other design choices that if you wanted to change that one bit you would have to redesign the entire language. Which is how Perl&amp;#160;6 happened. Larry understands this; you do not.) In the years between there have been a number of other cases of both of these patterns: instances of you insisting that Perl&amp;#160;5 is broken in some way because you failed to understand its design at a level above the implementation, and instances of you forgetting history (including your own role in current circumstances that frustrate you, such as in the case of the B parent op thing). You are as incompetent at understanding Perl&amp;#160;5 conceptually as some other people are at implementing the language. And when you are wrong, it is nigh impossible to get you to understand. (Just something as trivial as explaining `defined` to you took a massive thread. As for your years of claims that Perl&amp;#160;6 is a TODO list for Perl&amp;#160;5, there is no end in sight. Several huge disasters in Perl&amp;#160;5 happened precisely when people tried to treat Perl&amp;#160;6 as a TODO list – which you’ve shown no sign of realising.) (I have toyed with the notion that this might be a case of you being too smart for your own good. I’m not sure.) But the worst thing is that you will insist on having the argument (a number of which you are right about, mind you, but not all of them (and there are some where I cannot say)) at every opportunity. And I mean *every. Single. Opportunity*. Then people go “oh no, that guy again” and invent insufferably hypocritical measures of control to sanctify their own knee-jerk reactions by shifting the blame – not saying that they *won’t* deal with you, but that they *can’t*. It’s a shame. You have considerable skills in areas that no one else in the inner sphere of Perl&amp;#160;5 has, and there are a number of your criticisms that need to be addressed. But everyone is too stuck in their psychological scripts for communication to be possible.
Any time you work with other people, you have to suffer indignities and injustices. Human decision making processes are biased, approximate, and subject to manipulation. We evolved all of our crazy game theory antics just to influence decision making (especially decision related to mate selection). Some species cooperate perfectly among their ranks (ants, bees); others wage furious turf battles (Tazmanian devils, who like to bite each on the face to the point where a communicable cancer evolved to spread via face bites). We're somewhere in the middle. It's not ideal. Maybe in a few hundred million years, ants will all be way better at group programming projects than us. But for right now, suffering injustices gracefully and being stubborn about being nice is one of the best strategies for good programmers to use to get good technology adopted. It may seem like your opposition has their heels dug in, but usually in cases like this, they forget about the whole thing from one day to the next, or one year to the next. Patience in situations like this pays off in spades. Much of their resistance is reactionary, from social cues, knee-jerk reflex, misinterpreting signals, etc. I just read the P6 quasi-announcement from https://perl6advent.wordpress.com/2015/12/24/an-unexpectedly-long-expected-party/, and it has this gem in it: &gt; Be careful. We’ve gotten really, really good at ignoring certain kinds of people. Don’t be one of them. It's impossible to pay attention to everything. Especially people who work with tech a lot will stop paying attention to social stuff, intentionally or unintentionally. Everyone stops paying attention to people and things. But the real message I'm taking from that is just to what a degree Perl is a social construct. It's the same with other communities around other technologies, but the social constructs value different things. Stepping in and out of Java is always eye opening. It's very much also a shared social system, but one with starkly different shared values. You do brilliant work. I know that things have been mishandled by the porters. But I'd really like to see you do the things you can do -- those things within your reach -- that help keep the porters from confusing social signals and making poor choices.
[**@TimToady**](https://twitter.com/TimToady): &gt;[2015-12-25 22:11:20 UTC](https://twitter.com/TimToady/status/680511168713064448) &gt;Perl 6 goes live at 2015\-12\-25 22:00 GMT, a test suite and compiler, as promised. God bless us, everyone! ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3y81oj%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
If I hadn't attended YAPC this year, I would have had no clue Perl 6 planned to released today. And even then I've been quite confused by the recent announcements.
They've been working up to this for some little while. The first fairly firm announcement was in a talk by Larry Wall at FOSDEM early this year. https://archive.fosdem.org/2015/schedule/event/get_ready_to_party/
Considering the initial promise was by Christmas (but not specifying which), I find this release date to be quite satisfying. Last YAPC I attended was in 07. One of these days I should go again. Maybe now I won't be one of the two youngest there lol
Indeed I didn't say any such thing - as far as I could remember. In fact, I not only have more of a temper than Sawyer (so assumed there would have been a misstep of mine years back) but also am of the opinion that Sawyer deserves the White Camel infinitely more than I do. This is because I work with him and see him do great community and advocacy work every day. I was unaware of the incident you describe and it sounds very out of character. On top of that, out of the three recipients, I'm the closest to the non-group of people you'd call the porters. Thus my conclusion. I apologise for jumping to false conclusions like that. My plea to use your anger in different and more productive ways than striking up unrelated discussions remains. 
Woo! And also hoo!
Umm...just about nobody was waiting for a name change. That was settled long ago.
This is exactly the attitude that is continuing to kill the Perl community. ("Why are you still developing for Perl 5? When Perl 6 is coming out.") Fifteen years of the Osborne effect. Gee thanks.
Given his first comment, he wasn't paying much attention anyway.
Try what? And I was talking about modules loaded not distros installed. Should’ve been clearer, sorry.
Use my $var outside any sub or other code blocks. For an OO class, define it as a field in the new() sub.
It will be in the Location header, assuming the response has proper 30* codes and headers, so: my $ua = Mojo::UserAgent-&gt;new; my $location = $ua-&gt;get( "http://www.foo.com" ) -&gt;res-&gt;headers-&gt;header( "location" ); Note that you can also follow redirects with Mojo::UserAgent: $ua-&gt;max_redirects( $max_redirects_to_follow );
&gt; If Perl or its community were dead With all due respect, that's not what the poster claimed. You may disagree with their wording, but it's not a fair restating of their argument.
I can just paraphrase the last line in "Gone With The Wind", here: "Frankly my dear, I don't give a damn."
&gt; The double diamond operator &gt;&gt;&gt;&gt;. o_0
The post had no coherent argument other that they didn't like the name or logo. Neither of which is very interesting or important. Blaming Perl 6 for the alleged decline of the Perl community is nonsense too.
Any post starting with "with all due respect" isn't! It's you who has been attempting to defend an indefensive couple of posts with a pig headedness apparently resulting from your own bitterness about the project. You aren't adding usefully to this discussion. This is sad since your "Modern Perl" book is a good one and one I continue to recommend. He said people had been been saying "Why are you still developing for Perl 5? When Perl 6 is coming out." Which they haven't. Enough negativity and whining anyway. Perl 5 and 6 were both named by Larry Wall who has the sole right to do this with the vast majority of the Perl community I've met at YAPCs and workshops excited about the new member of the family which will stand or fall on its technical merits only and not snide forum comments about its name or logo.
I'm a big fan of Damian Conway. I met him, and I even gave him a ride from a Boston Perl Mongers event to his hotel because I wanted to hear more of his brain. Nevertheless, I feel like this post should have been more internal. I'm not opposed to him thanking everyone that got this finished. I am merely tired of hearing how wonderful this event is. I like Perl 6. I may like it even more when someone builds a Raduko MSI package of the Xmas release. For now I'm still using the September beta and Atom as an editor (since I have no time to build my own syntax highlighting XML for Notepad++). I just... fourteen years. This is up there with Chinese Democracy and actual democracy in China. There should be some sheepishness from the leads. There should be... ...I'll say it: Perl 6 needs some other name. Why not dredge up Parrot from the original 2001 presentations? Why a new name? For the same reason Python 3 should have its own name. There are too many business and production-sensitive environments that will never see this interpreter. There are enough differences between the languages, and there are enough reasons to disassociate from an aging though wise parent. Think of all the brands that dominated the market in 2001 that would hinder one's progress via association: Palm (gone), Blackberry (wishes it were gone), The Nashville Network (Spike? Esquire Channel?), the CIS (thanks, Putin), Nick Cage. I almost wish Raduko weren't the name of a specific build process. I have no idea what the kanji characters mean on the Raduko logo, but it sounds badass and ready to tumble with my regex problems. I want to stop thinking about Perl 6 as something that took longer to create than the original process from Perl 0 to Perl 5. Is that selfish of me? I just know there will be a decade of meetings about adding this tool to production environments when "we already have Perl... yeah, 5.12 or something".
Which similar stuff? From my reading, it doesn't look like Perl 6 was designed to do similar stuff to Perl 5. For simple system administration or even for quick web development, I don't see how Perl 6 is better than Perl 5 (but am open to being educated by those who do). Instead, Perl 6 is going in other directions. It has the ability to easily define grammars and use them to parse input. That is a significant advance from the old regexp parsing. For people who need this kind of thing, it probably beats the hell out of using yacc. It has an advanced concurrency model. Maybe that will open new programming paradigms on multi cpu systems? Or do you have a much better tool to do that?
&gt; I get that it used to be among the few choices very early in dynamic web and advanced scripting You didn't get what Perl 6 is then. It's not Perl 5 +1 in version number. It's a completely new language. Similar to how C# is not C but is very much in the C family. The tonnes of posts are because Perl 6 has finally set in stone what the language is through a versioned specification. Now I can write a program which is specifically valid Perl 6.C and any compiler that supports that should be able to handle my code. Before now anyone has been a little more at the mercy of compiler implementers changing the language from underneath them. In the last 5 years I've changed my code more often to keep up with language change than feature changes I wanted to make, that is no longer true! It marks the start of a period where a wider audience can pile on and start to build great things. I'd pick Perl 6 right now for any task where I want to get some simple text manipulation done as quickly as possible. At least quickly as possible in my time rather than CPU time. If CPU time is relevant I would still go for Perl 5 at the moment. It's slightly faster to write Perl 6 than Perl 5 without the need for reaching to CPAN. The quick and dirty version is easier to scale up at a later date too and starts cleaner. Especially if you start out with a basic Grammar and make it more detailed when necessary. A simple regex can be broken out into a grammar easily enough too. For other general reasons maybe check out: https://wendyga.wordpress.com/2015/12/25/why-would-you-want-to-use-perl-6-some-answers/ Not much in Perl 6 isn't possible in Perl 5, it's just it is often a built in and more consistent to use with other things in the language.
&gt; Why a new name? For the same reason Python 3 should have its own name. In practice, this hasn't been a big issue for the Python community. Most modern distros have the Python binaries listed as "python2" and "python3" in `$PATH` with plain old "python" defaulting to whatever the distro thinks the default should be. If you have a script that doesn't work in both environment, all that has to be done is change the shebang lines.
When I hear "Perl", to me it means Perl 5. The spirit of Perl (5) and Perl 6 are so different, I do not plan to move on to Perl 6 for a long time. But I hope a few new ideas will be implemented in Perl as well.
I think beginners should start with strict and warnings on. It will save many troubles at every step on the path. The posting examples do not use it.
Wow anyevent is cool.
&gt; I want to stop thinking about Perl 6 as something that took longer to create than the original process from Perl 0 to Perl 5. Perl 6 did indeed take a long time. It's a fact. It'd be silly to try hiding facts behind words.
Perl has been destroyed. Again. Worth it. 
Don't think so. One was purely an escaping problem, the other one (file ARGV redirect) seems more interesting. The talk itself was pretty clownish staged, could be done in 5 minutes but hey, its the big stage...
Doesn't sound like it to be honest. http://blogs.perl.org/users/joel_berger/2015/12/response-to-the-perl-jam-2.html
more library and project issues and confusion on the presenter's part? i had kinda figured CCC held the bar higher than this. it's not even interesting, and should have been a couple of pull requests instead.
Learn to love Data::Dumper
There's a lot of misunderstanding in this :(
guess people like him has now a specific classification. https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
Also see Test::PostgreSQL for setting up a database. Should save a few lines in the test script. Just watch out for the odd renaming choice (used to be called Test::postgresql, and the old version is still hanging around on cpan)
&gt; This is exactly the attitude that is continuing to kill the Perl community. ("Why are you still developing for Perl 5? When Perl 6 is coming out.") seems to me to be pretty much precisely 'blaming perl 6'. If you read it differently, I'm sure an alternative expansion would be welcome to extend the conversation, rather than merely insulting steve's reading comprehension. I find your bitterness about perl6 to be entirely understandable, but would prefer it if you stopped taking it out on the people who are, for whatever reason, enjoying perl6 anyway.
You're missing the point. He's not doing things like "ha ha, Perl is so unreadable" or "Perl is lame because it doesn't have type checks on subroutine argument lists", but actually making claims about vulnerabilities that don't actually exist.
&gt; If you read it differently, I'm sure an alternative expansion would be welcome to extend the conversation The charitable reading of the post in question is that "the notion that Perl 5 is obsolete is from outside the Perl community, and it hasn't been dispelled adequately". My post, on the other hand, claims that "Well everybody who thinks that is ignorant and uninformed and divisive and actively hurting things" is an unpleasant and defensive attitude that isn't helping either.
Obvious troll is obvious. 
https://media.ccc.de/v/32c3-7130-the_perl_jam_2#video It is a pretty humorous talk. It would be nice if he had disclosed that he was discussing known patched issues from historical versions of CGI.pm. It is unfortunate that the example from the historical CGI documentation leads into magical behavior of open(). Also we are too trusting of hash key contents. We need to fix that. In a twisted way we can take this as an endorsement for perl: In "just 5 lines" we can enable a remote system exploit that takes other programmers much more code to accomplish. Still it is worth taking his comments seriously and do what we can to fix them. It's also worth doing a google search and seeing what else "Netanel Rubin" has been up to. 
Think of it this way. You and I and pretty much everyone here know that that external perception is fundamentally flawed. To me, that suggests that our approach at changing that perception hasn't worked as well as we'd hoped. Perhaps it's my impatience, but I think it's worth asking if there's something we could do differently that would be more effective.
What I mean is, that the entirety of this code: sub Iterator (&amp;) { return $_[0] } sub NEXTVAL { $_[0]-&gt;() } sub make_rand { my $seed = shift || (time &amp; 0x7fff); return Iterator { $seed = (29*$seed+11111) &amp; 0x7fff; return $seed; } } my $rng = make_rand(); while (&lt;&gt;) { my $random = NEXTVAL($rng); print "\nrandom=$random"; } works fine for me. From your post, it looks like you tried to run the snippets in isolation, which will not work. Higher Order Perl builds a lot of syntactic sugar along the way and expects you to carry that with you. You understood correctly. The NEXTVAL function just invokes the coderef passed to it. The reason HOP defines these functions is so that you can think about your code in abstractions, because you will go insane trying to understand the Hamming generator or even a Y-Combinator without them. EDIT: woops, wrong code snippet.
Well, YAPC conferences are almost entirely volunteer-driven too, but we've had a pretty good record of only picking good presentations and rejecting the kooks.
Welcome; we have cookies! :D
&gt; We should be able to turn the cheek better but I'm not going to say the reaction is unmerited. It's not like we started using the internet yesterday, being able to shrug off trolling should be part of everyone's Zen training by now. I'm more concerned about someone asking me how things like the diamond operator are controlled for in real programs, because I know my production code uses &lt;&gt; and I have to manually check the sources of their arguments. Fun fact? Bugzilla has (or more accurately: had half a decade ago when I last read their code) tests that explicitly disallow 2-arg opens in the code. If someone had committed an open($fh, 'ipconfig |') explicitly the tests would have told him to fix it. But the implicit version with &lt;&gt; sneaks by. And I have to side with Rubin there, that's shit. If there is a way to systematically fix this, I don't know it.
Okay, but you knew it wasn't really going to happen though. I would have like them to change it too.
OK, it might have been a humorous talk like last year, but I still don't see what specific feature of core Perl makes it suck. Half of the talk consists of talking about functions with variable parameter types. That's definitively not a Perl specialty. Just look at jQuery or pretty much every other JavaScript framework. Maybe that's less frequent in Python, but in principle, all scripting languages are guilty here. The other half of the talk consists of exploiting CGI.pm again, not Perl core. The only thing I can take away from these talks is that not using CGI.pm was a good decision.
Charlie Stross is an old-time Perl coder, and I'm sure his books mention it here and there. And if you haven't read his books, they're great. Stephen Fry mentioned once that his father programmed in Perl, but said that he himself wasn't smart enough for it.
Uh, what. Stephen Fry is several years older than I am, and I'm a perl veteran (about 20 years).
&gt; The other half of the talk consists of exploiting CGI.pm again, not Perl core. I thought the problem he was talking about last year was in Bugzilla's reimplementation of CGI.pm, not the one in the core.
There are two rocks in that bag of fluff. * Hash keys and values need to be edit checked too. * &lt;$x&gt; might be too magical. Especially if $x contains user input. That turns out to be quite a bit of substance for a CCC talk.
Absolutely.
Thank you, I will check out Stross' books.
http://xkcd.com/208/ http://xkcd.com/224/ http://xkcd.com/312/ http://xkcd.com/353/ http://xkcd.com/519/ http://xkcd.com/1171/
[SQL::Abstract](https://metacpan.org/pod/SQL::Abstract) might be what you're looking for.
I guess I would first question the intention of when a user doesn't fill out the field. It seems you want to to do dynamic SQL because you only want to update certain fields. Wouldn't it be more appropriate to pass null or empty string in as the field?
Probably the best Perl6 release article I've read to date. Thanks for posting!
&gt; attacking people -not- working on aspect X of a given project for the project's failures at X I'm quite content to agree to disagree over whether this happened.
The Perl 6 website has had an update which adds a banner announcing the release, in case that is of any help to Johan. It wasn't completely clear to me whether he was uncertain whether the release took place, or was underwhelmed for other reasons. [Screenshot](http://imgur.com/kpHAqGV)
Is there a list of all the opted in authors/dists anywhere?
not yet no, since the opting-ins are steadily trickling in. At some point the list will appear on cpan-prc.org
[Rakudo 2015.12](https://github.com/rakudo/rakudo/blob/nom/docs/announce/2015.12.md) has been released [roast](https://github.com/perl6/roast) - the test suit that defines the programming language that is Perl 6.c will be released in a few days. [Rakudo Star](https://github.com/rakudo/star) (compiler+some modules+docs) will be released mid January, followed by Windows binaries within a week or so.
I wouldn't call DBIx::Class "the easiest way", or any ORM for that matter. Something like [SQL::Abstract](https://metacpan.org/pod/SQL::Abstract) would be easier for a DBI user. But if we insist on an ORM, [DBIx::Simple](https://metacpan.org/pod/DBIx::Simple) or [DBIx::Lite](https://metacpan.org/pod/DBIx::Lite) are much simpler and easier to use, and there are more I believe.
This is about business, not faith. As a developer you can have faith. As a business owner you need measurables.
Push them into an array as you build the query then pass the array into execute.
As the buzz of [#32c3](https://www.flickr.com/groups/32c3/pool/) quiets down in my head, I am looking back at my “perling” during the outgoing year. If there is one thing that overshadowed anything else I did or planned to do – it is the linked set of emails, and the initiatives it did (and perhaps is yet to) trigger. At the dawn of 2016, the issues I highlighted are more pressing than ever, and what's worse new structural threats emerged since my writeup. If you find yourself nodding to many of the points made in the linked gist – forward it to your [japh](https://en.wikipedia.org/wiki/Just_another_Perl_hacker)-ey colleagues and friends, and more importantly **get involved**. In case you find yourself utterly confused by the conflicting signals coming out of [#toolchain](https://chat.mibbit.com/?channel=%23toolchain&amp;server=irc.perl.org) – pay special attention which way /u/kentnl, /u/a-p, /u/neilb and /u/genehack are leaning in various forums. Use your head, resist unproven hype, and question or just route around luminaries. Here is to 0x7E0! P.S. This year was my first visit to the [Chaos Communication Congress](https://en.wikipedia.org/wiki/Chaos_Communication_Congress) which is, hands down, the best tech conference I have attended to date. If you are a true geek and/or need a good excuse to escape traditional late-winter family gatherings – join me next year at #33c3 \o/
I'm querying based on user input, not updating. Thanks.
JT, your arguments can and have been made about any language less than a year old. Go, Rust, and others are finding a place now. Perl6 may eventually as well but I doubt it will happen in the first week after it's official release.
&gt; So you could put in a config for: I know, but that's limited to vim only; what if I'm using another program? (less, or calling grep withing the bash command line, for example) The idea is to have all these new characters, that presumably will be highly used, available at the lowest level (the keyboard itself).
One solution is to use a bit of sql trickery like this: and TABLE..keyN = coalesce ("$input_keyN", TABLE..keyN) That is, if the input value is NULL, then the clause become an identity and so it does not have an impact on the resultset.
So, I was able to replicate the second example with a handcrafted HTTP request, but I get somewhat mixed results. Running locally under MAMP Pro the "payload" in the query string gets executed. Trying the same on my 'real' webserver ot does not. The pipe sign at the end gets automatically escaped (\|) in @ARGV. Yet, in the demo the pipe gets executed. Why? File permissions? Different user (MAMP: me vs. httpd:nobody)?
FYI: Kent Fredric put a detailled teardown of the talk on github. https://gist.github.com/kentfredric/8f6ed343f4a16a34b08a
I'm aware of star wars. Just wasn't sure you were going there for pure humor purposes. I take this particular discussion berry seriously. 
Not true. It couldn't have been made of Perl 5, because it had a migration plan. There were warts, but in general it just worked. The problem is that Perl 6 has is a whole new language with an existing name. 
Perl was already being used 20+ years ago, it's not that bizarre.
&gt; JT, your arguments can and have been made about any language less than a year old. The higher-order discussion can be very instructive, though. JT's asking "What's the business case for this?" and he's getting in response "Here's a list of features" and "Here's a list of features that we hope will be implemented effectively in the next year or so". That gulf in marketing is huge. It's a solvable problem, but it won't be solved unless someone really takes the time to address it fully.
Apparently this relates to http://blogs.perl.org/users/joel_berger/2015/12/response-to-the-perl-jam-2.html
And, more specifically [this](https://media.ccc.de/v/32c3-7130-the_perl_jam_2#video).
I think the migration plan was "your script _shouldn't_ break ... sometimes that's unavoidable. You're welcome to help us figure out why and fix it though!" I think that's the plan we're still using. I'm actually quite happy with that plan because in my experience it's better than "crap that broke? bruh! that sucks." vibes I've gotten elsewhere. That however isn't really a _plan_ so much as a migration _hope_. So the Perl6 people have a migration _hope_ ... they hope that the list of technical features will make people who end up using it for business curious so that they can defer this marketing the way every other language basically does. Show me the marketing material for a language in a similar place as Perl6. Let's say Clojure, Rust, or Crystal. I'd pick on Go but it had a built in business case at Google. I'd pick on Swift but again Apple had a built-in business case. I'm not aware of the one that Rust has, so where's it's argument for adoption? What was Ruby's? or Python's? Did they actually make a business case or did they have technical arguments (Perl done right or One Obvious Way to Do it) and let the migration cases come later? Don't just throw rocks at someone else's house. Criticize constructively. 
If you use '«' in your program, you need to be able to grep for it from the Unix shell. 
&gt; That depends on the business! That's what makes it false! He propped it up stating "in my business it's A or B" and make that the argument that there wasn't sufficient data for _any_ business to make a decent decision on. You make a valid point though. The messaging so far is all aimed at the technical wonders and none of it on the practical results. There are a distinct shortage of what in the corporate world would be white papers explaining why this is amazing in a way you can explain to the product manager. My problem is what's the justification for publicly throwing rocks at it for not having them in the first week since release? Is this something that is commonly shipped with new open source projects? That doesn't actually ring true with _my_ experiences over the last 15 years but I could be wrong. Should Perl6 be held to a higher standard for some reason? Because of it's notoriously long development process, specifically the Rakudo* ... I'll go with debacle honestly because that's how _I_ feel about it though there are people who may (rightfully) take exception to that description. Because it's a language named "Perl"? Turns out Perl isn't so postmodern that we can completely reject authorial intent. Which in some ways is kind of postmodern of it. Complaining about it at this point is like being that guy who told J.K. Rowling why Snape really died. The discussion of rock throwing hows and whys really isn't important though. You _are_ correct that there should be more posts from an angle of what _should_ be a business use case. How Perl6 stands up to the expectations and where it (still) falls down. Hopefully now, finally, they should start appearing as more people start poking at it because of their bolder claims of stability and readiness this week. I also note we have _both_ said this before and been wrong.
You do realize the irony here is that looks like a list of technical data points. I just happen to have enough of a background those would be important for a financial app.
&gt; I just happen to have enough of a background those would be important for a financial app. That's why I listed them despite technical data points. You and I can both intuit exactly why they're important, while not leaving everyone else out to wonder why I'm so concerned about a complete audit trail which forbids modifications, preferring only updates.
&gt; That's what makes it false! He propped it up stating "in my business it's A or B" and make that the argument that there wasn't sufficient data for any business to make a decent decision on. I think you're stating it stronger than JT did, but he can argue his point better without me putting words in his mouth. &gt; My problem is what's the justification for publicly throwing rocks at it for not having them in the first week since release? I'm not surprised that the release announcements have been confusing or that the promotion has focused on producing laundry lists of features. I personally raised this issue multiple times before and after Rakudo Star in 2010. I thought one of the reasons for Rakudo Star was to gather this sort of feedback. (Maybe that's unfair of me; it was certainly one of *my* reasons for supporting the idea of Rakudo Star.) My experience suggests that there's not much desire in the P6 community for these discussions. It's a pity; there've been so many interesting new technologies and languages which have gained acceptance in the past 15 years to give plenty of examples of how to market a new technology well and poorly.
&gt; I'm wondering why is there so much hype? Yes, I'm sure the Perl6 hype dwarfs that of iPhone6. /s I think that the five or fifteen people posting about Perl6 are genuinely excited about the language.
&gt; I think you're stating it stronger than JT did Entirely possible. JT is a bold guy, it's part of his charm, he tends to make strong statements like this. But in this case I think there is a bit of oratorial overreach [citing the original article here]: &gt; I’m likely never going to use it, and I think the same is true for the &gt; other established businesses using Perl 5. Here's why: &gt; &gt; There is no real migration path from Perl 5 to Perl 6. If you have &gt; any significant code base in Perl 5 you’re going to keep working in Perl 5. &gt; &gt; If you decide to up and rewrite your entire system, are you going to &gt; choose Perl 6? As amazing as Perl 6 is, I don’t think so. I think it's fair that it _could_ be read strongly even if that wasn't JT's intention (yeah I'm as post-modern about authorial intention as the next guy ... deal with it). I'll let him clarify his own point and intent though.
Hopefully this series will be more objective and be more suitable for a general audience than [my last](https://www.reddit.com/r/perl/comments/3yxqeg/nice_detailed_examination_of_the_claims_in_perl/) , which was mostly my stream of consciousness as I watched the video. 
Yeah, right. I kind of agree. However perl6 is similarly optimised for whipituptitude as perl5 is. Once a critical mass of people start whipping up async/parallel/unicode/parsing things fast with perl6 it might start getting some traction in the business world.
Thanks unsupported image format is returned. Not sure how to continue from here - Alien::SDL2 installs fine " Using source code build jpeg(v9) tiff(v4.0.3) png(v1.6.3) SDL2(v2.0.0) SDL2_image(v2.0.0) ogg(v1.3.1) vorbis(v1.3.3) SDL2_gfx(v20130301-hg) " So not sure why it wont
&gt; Yes, I'm sure the Perl6 hype dwarfs that of iPhone6. Based on number of posts and people who still actively use perl, the percentage is probably higher :D 
&gt; Obviously, the test has to be performed before the action, so why would it be placed after it? You have one right there. Could have written that: *Why would the test be placed after the action, since obviously the test has to be performed first?* yet it seems you chose to put the conditional at the end. Perl has a few quirks that follow patterns of languages such as English, this is just one of them. Personally I find code like next ITEM unless /^text/; easier to read than the if(condition) next; version from other languages, since this way maps very closely to an equivalent line in the specification saying * Skip this item unless it starts with "text" Your example (numeric comparison aside) might not be the most readable way to write that code - in general I find putting the conditional at the end works better when the emphasis should be on the action rather than the conditional. "$obj-&gt;save unless $readonly", "return unless $stuff_to_do;" maybe.
&gt; I would argue on that, what feature is there that really stands out from other languages? I'd suggest listening to Jonathan Worthington, Larry Wall or Curtis Poe, http://ftp.heanet.ie/mirrors/fosdem-video/2015/devroom-perl/perl6_for_mortals.mp4 I would say many features that mesh smoothly, shameless borrowing and reinterpreting features from other languages. It will be interesting to see how the interoperability tools for programming across perl5 / per6 boundaries work out. That will let small bits of clever perl6 code get into perl5 programs, and vice versa, so perl6 code can build off of the perl5 code base. 
One minor quibble. You do not necessarily know anything about my awareness or interest in marketing Perl. This remains a bit of a minefield, to say the least.
Because it's how it's spoken in English and some people find things expressed more naturally that way at times? This is why I used the postfix conditionals when I do There's more than one way to do it :)
From [a recent HN exchange about this](https://news.ycombinator.com/item?id=10711320): If all someone wants to express to a reader is literally `if x then y` then `y if x` doesn't really help. But we typically don't write trivial one-liners with single letter names for conditions and actions. In actual programming there are times when it's more like a series of lines, each of which is something akin to 'if some-expression-that's-so-much-longer-than-a-single-letter-that-you-start-to-consider-factoring-it-out-in-to-another-variable-or-function then some-function-or-flow-control'. And when that happens there are times where by far the most important thing a writer wants to first bring to the attention of a reader (eg themselves, later) is some-function-or-flow-control. Sticking with made-up examples for a moment, there's: if long-complex-conditional----that-you-might-start-to-read-thru-in-an-attempt-to-understand-the-code-you're-reading---is-true then blow-rocket-up vs blow-rocket-up if long-complex-conditional----that-you-don't-need-to-read-and-understand-to-understand-that-the-rocket-will-blow-up-if-it's-true----is-true Or it takes me I estimate less than a second to know the gist of the overall control flow of this fragment from [a recent Advent of Code entry](https://www.reddit.com/r/adventofcode/comments/3viazx/day_5_solutions/cxnt51w): next unless (() = /[aeiou]/g) &gt;= 3; next unless /(.)\1/; next if /ab|cd|pq|xy/; $count++; I can immediately see that it increments `$count` unless it bails out of the containing loop (`next`s) due to any of several (complicated looking) conditions. In contrast, it might well take me more than a second to figure that out if they'd written: unless (() = /[aeiou]/g) &gt;= 3 { next } ; unless /(.)\1/ { next }; if /ab|cd|pq|xy/ { next}; $count++; While these examples are pretty weak, I have hope that they might at least give you pause for thought.
Those other languages fidnt share a name with a predecessor 
I will always love and respect Perl -- it got me back into coding after a 20-year hiatus. That said, I do not know anyone younger than me who uses it on a regular basis, and even I find myself migrating to PHP CLI for text processing nowadays. :/
What's up with all this CGI bashing, anyone who is serious about web development will not use CGI. It should not be killed CGI is one of the reasons Perl is popular in the first place and Perl's stability and backward compatibility with older versions is one of the main reasons we still use Perl in 2016.
Others have made the common arguments, I would say that there IS one notable difference: the scoping implications. In a normal conditional the test is scoped into the block. That means if you want to create a new variable and then test it you can't do this unless (my $arg = $hash{arg}) { die 'arg is required' } # $arg is not in scope here you have to do something like this: my $arg = $hash{arg}; unless ($arg) { die 'arg is required' } # do something with $arg while if you use a postfix conditional statement the test is scoped the same as the surrounding code die 'arg is required' unless my $arg = $hash{arg}; # do something with $arg Personally I like this better.
They obviously need to be called pearls.
&gt;&gt; I just compared the time to square each of the members of an array of length 100, either by looping through it, or by using map. Unfortunately, no - I don't think you did: &gt; Yes, for starters $a and $b are never used, and are both set to 100 :P not that it matters too much here, but depending on environmental factors I'd expect more like undef - that's in scalar context, so it'd be acting as the $line1 .. $line2 operator. Anyway, the code might run, but it's not much good as a benchmark - in the second case @b is always empty because @a is empty, in the first one @b ends up as an array with 100 zeroes. If you want counter-examples where map is slower: $ perl -e'use Benchmark qw(:hireswallclock cmpthese); cmpthese -5, { for =&gt; sub { my @x = (1..100); my @y = (1..100); for (0..$#x) { $y[$_] = $x[$_] * $x[$_] } }, map =&gt; sub { my @x = (1..100); my @y = (1..100); @y = map $x[$_] * $x[$_], 0..$#x }, map2 =&gt; sub { my @y = map $_ * $_, 1..100; }, for2 =&gt; sub { my @y; push @y, $_ * $_ for 1..100 } }' Rate map for map2 for2 map 36263/s -- -26% -36% -57% for 48754/s 34% -- -14% -42% map2 56995/s 57% 17% -- -32% for2 83985/s 132% 72% 47% -- but it'd be safer to include checks on the data - getting the wrong answer quickly isn't much good to anyone! 
He's declaring $a and $b as arrays... but incorrectly. He should use square brackets if he wants them to be array refs, or the @ to declare them as straight arrays. Anyways, he needs to be doing all this shit in PDL if he's concerned about speed at all. Id like to get PDL comparison times for him, but his posted code is so bad I can't figure out what the he'll he's even trying to do. That first while loop... doesn't seem to go anywhere. 
Just to clarify, the list of 1 .. 100 on the right hand side will evaluate to 100 in scalar context. This is what I meant ;) Edit: Which was of course wrong, it ends up being the flip flop operator in that case. I guess I loaded the ol' mental footgun
Ah yes, the flip flop. God dammit :(
Did you look at the [code repo](https://github.com/davorg/easy-psgi)? There are plenty of examples in there. But basically, create a Plack::Request object from the first argument passed to your PSGI app subroutine. use Plack::Request; my $req = Plack::Request(shift); That object has a `parameters()` method which returns a hash ref (actually a [Hash::MultiValue](https://metacpan.org/pod/Hash::MultiValue) object). So, to get a parameter called "foo", you can use: my $foo = $req-&gt;parameters-&gt;{foo};
OK, I fixed my stupid error, and made @a and @b arrays, which is what I intended in the first place. The times are not that much different, the loop is 28 microseconds, the map 21 microseconds.
As mentioned by at least one other commenter, this syntax is known as postfix conditional. The consensus amongst right-thinking software developers (i.e. those who agree with me) is to use this style very sparingly, where it enhances clarity. If you don't like this construct you do not have to use it at all. I think you'll get used to it, though. I vaguely remember having similar thoughts years ago. 
I did go through the docs but thanks. Thats a nice example, i might start shifting from cgi.
Awesome, ive been looking for something like this. Thanks, can't wait to get started
That's a very nice looking web REPL you have there. Before I show this to anybody else, is the back end a vanilla VM or other fairly self-contained, walled-off system? :-)
Use `parameters-&gt;get('key')` and `get_all` rather than the hash interface. 
Thanks.
wow, I find that rather confusing, there certainly are times that you want that scoping. if (my $arg = $hash{arg}) { # do something with $arg here } # this scope is kept clean How could one do something similar to this in perl6 and keep their scope clean if desired?
Although this thing is good looking it has a few problems. It makes some rather sever assumptions about what is "correct". For example in the second page I tried `reverse 'onion'` and told me I was incorrect; it wanted `reverse "onion"`. That said it is also just using Safe for application safety (which IIUC isn't really enough) and is using CGI.pm which is no longer in favor. I'd be happy to show you how to port this to Mojolicious if you are interested.
Perl made available in this way is not likely to be the same as Perl on the command line. Getting close is good enough. It's just a taster. Safe.pm is &lt;handwave&gt;not enough&lt;/handwave&gt; but if tryperl.pl is inside a container or otherwise a throwaway server, the world won't end. I pity anybody who does anything nice/interesting/cool and happens to also use CGI.pm from now on. If you want to see this done in Mojolicious, it's not really fair to bikeshed. There's a link to the repo, fork it. :-) 
I'd be interesting in seeing how a PSGI-CGI wrapper would guard against attacks on `ARGV`, in all of the following cases: @ARGV=("echo hacked|"); while(&lt;&gt;) { @ARGV=("echo hacked|"); while(&lt;ARGV&gt;) { @ARGV=("echo hacked|"); my $filehandle = "ARGV"; # Should not be legal under strict while(&lt;$filehandle&gt;) { # but still is 
Ok I will do thank you :)
I can understand why you'd want to use `get_all()`. But I don't see what advantage `get()` gives you over raw hash access.
Mainly because refactoring from cgi param calls is much easier with get rather than hashed access. And it's a signal to the maint programmer that what you have here is not a straight hash.
Any of the modern perl frameworks. Perhaps [Mojolicious Lite](http://mojolicious.org/) since you can do the single file app then too which is relatively close to what you appear to be used to already. Agree the actual interface being more like the TryRuby is really nice with a tutorial story that leads the user. 
&gt; I pity anybody who does anything nice/interesting/cool and happens to also use CGI.pm from now on Though looking at the source, I'd say CGI is not really what puts me off. The code style is a bit verbose, and even though it probably achieves its task alright, I'd hope that there could be a better way of organising it than that. Its not so much "Bad", just would be unfortunate if somebody were to read it and use it as their example for what Idiomatic 2016 Perl5 looks like, and were to think it wise to emulate that style.
cperl preserves hash key taintedness. It was a one-day fix. https://github.com/perl11/cperl/commit/e427942dcc31c0c66ac9e6e8e4f25b2a388288d5 I even caught 2 failing tests in the lib/locale.t core testsuite. 
Would be interesting to see the performance difference between | With Patch | Without Patch ---|---|---- With Taint On | ??? | ??? With Taint Off | ??? | ??? At least so we can argue if the performance penalty is real vs imagined.
My statement stands. Please don't discourage a keen programmer in this way.
Look at the changes. A few branches added to the run-time whenever accessing a hash key. Slower, but for sure less than &lt; 1% slower. I haven't timed it though. It's a security fix, so I cannot argue with less performance. BugZilla needs it desperately. Look what kind of workarounds they did to workaround this missing feature.
I went back to read the above-linked page properly, since several people have linked to it recently. I admit to skim-reading it the first time or two. It wasn't very engaging, after all whinging sometimes seems to be what we programmers do best so there is a lot of it around, and this particular complaint was pretty fuzzy around the edges. That's fine - this is Mr Vromans' own website and i'm perfectly happy for him to write anything he likes on it. Especially since he is the author of the Perl 5 Pocket Reference book, which was probably the best value for money Perl book I ever had. Johan++. 
Looking at the diff, I agree with Reini that it would be less than a percent of slowdown if measurable at all. Can't speak to the effectiveness of the change since I only took a quick look.
Yeah, that subject was too hard in this context. I may touch on that again later, but I'm focusing on the "How can Perl/Perl community be better" parts first.
Everything is insecure if you dont handle user inputs correctly. Some simple sanitization and extra thought when designing your app and this should be a non issue.
Ahhh necroposting. Sorry for that. Didn't realize anyone had written a Bah Humbug about Perl 6. I tweeted that I had zero fucks to give about Perl 6 and I am maybe *maybe* up to half a fuck now. I love Perl 5 and I always will. But I'm always always going to choose some other language for most things that I do on a team - and I say this as a full time Erlang developer which is not the most well known (or well liked) language on the planet. Outside of semi-obscure functional languages (Erlang, Clojure, OCaml, F#) the one I really write code in much is golang. I am interested in Rust too, tbh but I haven't really found much reason to use it in a project yet. So Perl 5 for my own personal side projects and stuff and scripts that are &lt;100 lines of code to Just Glue Something together. (If I have to share it with my team, I will probably use python though.) So, yeah, good job Perl 6 team. Wish you were done like 12 years ago. *shrug* Good luck and everything but I don't really see a *compelling* reason to use it myself.
I agree. No idea what taint-mode does or why I should give a shit. Worked at multiple perl companies. We never used it. In fact, relying on it seems haphazard.
No, it's a mandatory security feature p5p was not able to implement in the last 15 years, even if trivial. There's no performance penalty.
The good part is it would never bother you unless you wanted it to. Because Taint mode is turned on globally, and turned on at the command line. Don't want to deal with Taint Mode, Don't turn it on. Do want a bit of a safety net when you suck at programming: Do turn it on. But nobody is forcing you to use taint.
`chomp` modifies the specified variable in place, and returns the number of characters removed. So there are two things wrong with your third example. First, in order to modify in place, the prototype of `chomp` forces passing a reference to the argument you supply, so you have to pass an lvalue. (Or you can pass no arguments in which case `$_` is operated on instead.) For example, if `foo()` was a function that returned a string, you couldn't write `chomp(foo())` because the string returned by the function is an rvalue. It's a temporary value that has no name, and therefore it makes no sense to be able to take a reference to that in order to modify it, since you'd never be able to see the result as the last reference to it is about to disappear. This works the same in C — suppose you had some function `void bar(int *)` that wants a pointer to int, and you have some function `int bar(void)` that returns int. You can't write `foo(&amp;bar())` because the return value of `bar()` is an rvalue and you can't take the address of that. `&lt;STDIN&gt;` is really a function call (i.e. `readline(*STDIN)`), just like `bar()`, and the taking-address-of is implicit rather than explicit, but it's the same idea. But secondly, even if that was not an issue, `chomp()` returns the number of characters removed which is not at all what you want to use as the condition for your `while` loop. 
Thank you for all the answers, I am not sure I understand but I see that it is more complicated than I originally thought. I need to learn more I guess.
I honestly agree with many of your points. However i remain in the position that you keep shooting yourself in the foot by the way in which you conduct your attempts to change something. Particularly: &gt; shouting matches Yes, they can be useful in some circumstances. However the vast majority of the people who i know to get things done, do so by remaining calm and taking care not to burn away the other party even in the most ridiculous circumstances. Primary source: Family members working as train conductors and ensuring the safety of the lives of hundreds of passengers each day, getting through their daily work routinely while handling calmly and in a friendly manner drunk people, belligerent people, slow people or people who barely speak the common language. If they can deal with that, you should be able to handle the perl community elegantly.
&gt; No, it's a mandatory security feature p5p was not able to implement in the last 15 years, even if trivial. Unnecessary. Please refrain.
Not 100% sure, but if you used finddepth() and stored directories you don't want, maybe something like: my %hasSRT; sub want { if ($_ =~ m/\.srt$/){ $hasSRT{$File::Find::dir} = 1; } if (-d $File::Find::name and not exists $hasSRT{$File::Find::dir} ) { push(@files, $File::Find::name); } } Untested, but maybe something like that. Depth first makes sure we find *.srt file before the directory itself. (edit: its exists, not defined. how embarrassing)
that works ... thank you
You don't have to use types if you don't want. `my $foo = 42;` still works just fine. 
You're not likely to need to explicitly specify numeric types like this very often. The convenience is in omitting them entirely. Make them visually distinct with an initial capital letter does not seem like such a hardship given that.
There's a wide gulf between forcing someone to "keep up" and waiting for several months without as much as an acknowledgement. For you to equate the two is cruel and dishonest.
Thank you a lot soconn :)
Thank you, that helps. It makes sense that you can't chomp a file handle but that you could chomp $_ 
Thank you Joel Berger for the feedback :) reverse 'onion' does not move you to next level because I haven't put the regex to recognize it (but interpreter returns well noino), and you're right there's still a lot to add on this side to make the interpreter look like "smart". I already answered other topics, but if you would like to comment my mojolicious implementation, please do, I would be happy to know and fix the code.
No thank you Reese. First 20 lessons/pages completed, so far very good
&gt; Obviously to delete shellcode. But what if the shellcode consists of word chars only and is expanded somewhere else? (responding as a non-moderator now) I've always been intrigued by your suggestion that it's possible to inject shellcode into a Perl process's memory space, but I really think you're overstating things with it. I understand your argument that anything passed to a system call without regard for C-style NULL byte string terminators could be a vector for shellcode, but I think you have to demonstrate an arbitrary remote code execution vulnerability that has a chance of hitting that memory space. I acknowledge that it's *possible in theory*, but there's a lot of heavy lifting to get there. With that all said, tainting hash keys makes sense to me.
 #!/usr/bin/perl -w use strict; use DateTime; use File::Slurp; my @lines = read_file('hackos.txt'); chomp @lines; my ($actual, $expected) = map { my ($d, $m, $y) = split(/ /, $_); DateTime-&gt;new( year =&gt; $y, month =&gt; $m, day =&gt; $d) } @lines; my $fine = 0; if (DateTime-&gt;compare( $actual, $expected) == -1) { print "$fine\n"; } else { my $duration = $actual-&gt;subtract_datetime($expected) ; if ($duration-&gt;months) { $fine += (500 * $duration-&gt;months); } elsif ($duration-&gt;days) { $fine += (15 * $duration-&gt;days); } print "$fine\n"; } 
What exactly *is* /u/_perly_bot ? If it just auto-posted everything on blogs.perl.org, then... okay, whatever, that site's unbelievably broken, at least it can have a comment section over here. But the "bot" posts seemingly random stuff, including [content-free blog spam](https://www.reddit.com/r/perl/comments/3zk4zg/perl_6_grammars_redux/), and doesn't seem to obey the normal Reddit bot rules.
Haha - well you've certainly got the primitives necessary to make quaternions if you want. Would make a good blog post. :)
It's not that shellcode is executed often with such apps. In this bugzilla case it is: https://bugzilla.mozilla.org/show_bug.cgi?id=1221518 but there is a simple quoting issue, exploitable with as unauthenticated user. CVE-2015-8508 But these are the 19 affected bugzilla bugs: https://bugzilla.mozilla.org/buglist.cgi?quicksearch=taint It can be XSS (the most common case and easiest to exploit), SQL injection or shellcode, esp. open | or &lt;&gt; as in the PerlJam2 talk. 
I wondered if there was anything like that
https://github.com/Util/Perl6-Math-Quaternion
If you could get schmorp, that would be fun, i'm sure. :D
Then why check out a post with Perl 6 in the title or comment about it...? Especially if the most important thing you have to say is the language has too many capital letters in. Moose is equally capitals heavy. I manage to successfully write English fast enough which has plenty of capital letters in... So don't really see any intelligible argument here unless you only ever program on a mobile phone or tablet?
This post misses out all the [native numeric types](http://design.perl6.org/S02.html#Native_types) which are worth a mention too. As well as packed arrays of those types being contiguous in memory. So `my int8 @matrix[10;10];` will only take up a single contiguous block of 100 bytes of RAM like in C. 
Moose isn't Perl. And Perl 6 has its own sub, so maybe the better question is why post it here?
If I understand it correctly, this is the newer version: https://tablets.perl6.org/
 #!perl use strict; use warnings; use feature 'say'; my ($d1, $m1, $y1) = split ' ', readline; my ($d2, $m2, $y2) = split ' ', readline; my $fine = 0; unless ($y1 &lt;= $y2 and $m1 &lt;= $m2 and $d1 &lt;= $d2) { $fine = $y1 &gt; $y2 ? 10000 : $m1 == $m2 ? 15 * ($d1 - $d2) : 500 * ($m1 - $m2) } say $fine
Hardware-native types are coming up in a future post. :)
You're still not understanding that there was nothing at all wrong with what I shipped. You're trying to hang me for an imagined crime.
https://github.com/dnmfarrell/Perly-Bot
I dunno the stats look really quite good!
 $foo.numerator $foo.denominator OK, got it. But then we have this: $c.re $c.im If we're going to spell `numerator` and `denominator` in full (which I think is a good idea) then we should spell `real` and `imaginary` in full, too. $c.real $c.imaginary I'd accept `$c.imag` as a short form of `$c.imaginary` but the two letter forms are just too cryptic (especially when `re` is already associated with `regular expression`).
Ah, right, that makes sense then. Thanks for the clue. 
The single-page version is convenient, and gives an idea how large the language is.
Given that choice, I would have the same preference. So do you think that was the choice in this case? If so, then why? Can you explain in what way the module have been *broken* if it had simply been left unchanged for 5.22 – rather than just missing a feature… under certain build configurations… which are non-default? I am not asking rhetorically. I have looked at the specifics of the situation and come to the conclusion that there there was no urgency to make any change in particular. Did I miss any reason to conclude otherwise?
Do you actually use B::Utils for anything? Reini is a known big stakeholder in that set of modules. Was there reason not to wait for his input? I have followed (and for this discussion, re-examined) the specifics of the situation and found that there was no urgency to make any change in particular. B::Utils already had a heuristic that was not affected by DaveM’s new feature and would have continued to work even on perls built with `PERL_OP_PARENT`. Which is a non-default build configuration. *Eventually* it would have become necessary to cover this ground, as `PERL_OP_PARENT` is presumably supposed to become default at some point, but I certainly didn’t see any reason that this *had* to be in 5.22. And possibly it could have been done via an interface that didn’t overlap with the old one… if anyone had thought it through enough, which Reini himself didn’t do either (given that he first wanted it one way and then another, then he forgot what he himself had said, and here we are). And to come back to “patch or STFU” again: there exist two variants of this interface already – this is irreversibly a fact of life now. What good will it do to change this interface *again*?
Cruel and dishonest. Really. So let’s talk about feelings. How do you think Reini *feels* about this situation? How does this compare to the cruelty Ether has had to endure? Do you consider it OK for him to be made to feel that way? So let’s talk about dishonesty. 1. Did the circumstances actually warrant proceeding after months without feedback? 2. Whom did she address her “patch or STFU” challenge to and when and where?
&gt; but it will always been seen as that language 'that was in development for a decade'. Why is that a bad thing? I think it's a good think. If I hear, say, a digital camera, that has been in development for over a decade, is being released, I will seriously consider it. Same with any other tool or whatnot that requires any level of research and engineering. Why should we not expect such a thing from a programming language?
&gt; replaced with something that I'll like as much as Perl Why not Perl 6 though? Are you saying you don't like it as much as Perl 5?
I don't.
&gt; Why is that a bad thing? One word: Duke Nukem Forever. Ok, that's three words. All kidding aside though, "agile" is en vogue these days. I think a decade release cycle will be seen as anything but agile. The other side of the coin, if the camera has been in development for a decade, are they not using decade old technology? Taking the DNF example, they released a game in 2011 based on early 2000's technology, had it been released on say the N64 it would have been ahead of its time, but as it stands we received a substandard game. Is it actually a bad thing that it's been in development for so long? No, I don't think so. We need to hire some hipsters who've never heard about Perl5 and let them "discover" this crazy new language called perl6. ;)
I am having a lot of trouble enjoying Perl6 right now. I think it has really taken that "write only language" criticism of Perl5 to an entirely new level. Far too many operators, and using Unicode characters as alternate ways of writing operators like "&gt;&gt;"? I have seen a lot of really bizarre design decisions so far.
&gt; Every time a new Java comes out New Java isn't generally **completely** incompatible with old Java.
Like I said, I did some googling and added some potentials I found :-)
If you think that delivering quality software trumps the need for basic human decency, then I hope you're in the wrong community.
The article you link to makes me think that she's *exactly* the kind of person who we should be listening to.
i think it's ugly. probably a side effect of it being spec'd 15 years ago when perl wasn't modern. it inherited all that, seriously, how is this https://github.com/tokuhirom/p6-HTTP-Parser/blob/master/lib/HTTP/Parser.pm6#L52 any better than http://geekshumor.com/wp-content/uploads/2013/06/perl-scripts-done.png it's everything we've all said perls not for the last 5+ years
We are definitely framing this whole thing wrong. We have two choices: * Replacement: Perl 6 is, eventually, the replacement for Perl 5 * Separate: Perl 6 is an unfortunately named but completely separate language from Perl 5 Most people outside of Perl 5 and Perl 6 go with Replacement just by looking at the names. Various insiders switch at random between Replacement and Separate, and I think that is the core mistake. This article has a very important sentence: &gt; "First, a postulate: given the language similarities, the people that will find it easiest to learn Perl 6 are today's Perl 5 developers." This is it -- this is the mistake where we are getting both messages at once, and the rest of the article paints a dark picture of a world (unfortunately most likely the one we live in) in which crossing these messages happens. The mixed message is a net negative for both languages. In reality there are SO MANY differences between Perl 5 and Perl 6 it is NOT a good postulate! I suggest that if you take a random [Perl 5, Ruby, Python, PHP, Javascript, R] programmer, the Perl 5 programmer might actually have MORE trouble than others due to misleading overlap and jarring differences. A developer that uses a lot of Moose might have less issues... or again might end up with the differences shocking rather than enlightening. I actually think the Ruby developer will have the LEAST trouble learning Perl 6, building on tons of overlap (everything is an object!), a shared history (sure, /foo/ is a regex, drop it in. Couple sigils here and there never hurt anybody), and similar culture (TIMTOWTDI is a motto for both). But the Ruby developer won't expect things to be mostly the same between Perl 6 and Ruby, unlike a naive Perl 5 developer. I recommend you each shape your language to do two things. First stick strongly with Separate, second focus on the Polyglot nature and audience: ---- *Perl 6 is a new and interesting language. It happened to be created by the creator of Perl 5 and an overlapping community, and has an unfortunate name. It is a Practical Research Language, aiming to be both cutting edge and useful. It is of interest to all dynamic-language programmers, and is especially interesting for the polyglot: you'll see familiar bits from Haskell, Perl 5, Ruby, Python, CLOS, ... plus lots of original ideas. Things that you can use, or at the very least learn and take back to your work. You can use Perl 6 now to solve small tasks, and join at the ground floor to build up the ecosystem and culture towards solving larger and larger problems.* ---- One of the cultural things that I think can set Perl 6 apart is in being module-level polyglot. From Perl 5 or Ruby you can invoke Python code (both have libraries to support this that I've used) -- but you'd be hard pressed to get that put into production at your work. But NOBODY should ever implement pyplot again! If we can make doing "use matplotlib::pyplot:from&lt;Python&gt;" a socially-acceptable thing in Perl 6, we might be able to convince other communities to do the same... and do something amazing: revolutionize sharing cross-language modules. Perl 6 isn't the research language for Perl 5. It is a research language for ALL languages to learn from. Perl 6 is the Borg of Languages, pulling in concepts and features to create a glorious monster. Maybe the first assimilated was Perl 5, but it clearly didn't stop there. We need to let go of its roots. Embrace that Perl 6 is Separate from All, Replacement for None. 
Don't move the goalposts. I wasn't talking about the details of the situation. I was talking about your claim that she had issued a statement equivalent to: “keep up ... or suffer ...” Don't try to distract from the words you wrote. Reini wasn't forced to "keep up". All he needed to do was say "can't right now, give me some time please" when she asked for a rebase. You don't get to play "But Timmy hit Bobby too and teacher did not yell at him."
I see it as a mindset thing. I suspect Perl 6 will fit the brain of Perl 5 programmers similarly – if only in the mental training not to recoil at sigils.
My refusal to let you move the goal posts does not constitute a moving of the goal posts on my part. I’m telling Ether that she hit Reini – even if it was after several months of waiting for him to say “please don’t hit me”. She responds with “do something first or STFU” and I say that that is bothersome. You’re saying that this is cruelty towards Ether on my part, because Reini had several months to say “please don’t”. Your priorities are bizarre. (Who is the teacher anyway? You’re just one of the kids, and the kids are all grown enough they should have an internal locus of authority and not be dependent on a guardian.)
&gt; it's everything we've all said perls not for the last 5+ years Well formed? Readable? seriously what are you talking about? Find me a better HTTP parser to compare it to. I went looking for one in Python but wanted to stab myself before I even found where the parsing was being done.
&gt; Our raison d'être is to deliver quality software to invisible masses of users, often at the expected price of discomfort to individual contributors. That's not what *I* signed up for.
Do the people who depend on your software know that?
&gt; Whom did she address her “patch or STFU” challenge to and when and where? That was entirely addressed to you, in this reddit thread, and nowhere else, because you were flinging insults without understanding the original context of the modules involved. If you want to read the history, you can look at: https://rt.cpan.org/Ticket/Display.html?id=100508 and https://github.com/jbenjore/B-Utils/pull/10 and http://www.nntp.perl.org/group/perl.perl5.porters/2015/07/msg229514.html I'm really getting tired of being castigated for things that didn't happen, and in some cases being accused of the exact opposite of what I actually did. Also, even if an entirely botched release had been made, things *could* have been rectified quickly, had a level of civility been maintained in the discourse. That didn't happen; I can only conclude that some would rather argue about power and control and "incompetent p5porter managers" rather than maintain technical excellence. (edit: added RT link containing the original FatherC patch for 5.22.)
I dunno - I personally value blunt yet unemotional honesty. I'm not so tied to my work that I get emotional about it. I want to learn and get better. I care about my work, but I don't get emotionally attached to particular lines of code. I'd rather someone rip apart my work and help me to make myself better.
Being nice to someone and protecting the fee-fees is all well and good until your company loses millions of dollars because of a bug they introduced. People get emotionally tied to code. Saying you introduced a bug isn't an insult. Brutal but honest criticism isn't an insult. but a lot of people will take it as such. I see it this way: quality software is the goal. Not calling someone out when they are full of shit is pandering. Either you fix it yourself and ruin someone else's learning opportunity, or you are allowing someone to stay in a position that they shouldn't be in which causes the team to be held back.
&gt; I have looked at the specifics of the situation and come to the conclusion that there there was no urgency to make any change in particular. Did I miss any reason to conclude otherwise? Given it was a patch from FatherC, I don't think it's unreasonable for ether to've assumed that the patch was likely both correct and worth having - especially given her willingness to take further patches and act as release minion as required. Any issues could easily have been fixed had they actually been reported constructively - we spoke to more than one porter trying to work out if there was actual technical content mixed in with reini's screaming, but nobody could translate, and then he started shouting about incompetence, forked, and refused to help further. In the same situation, I'd've assumed Father C's work was both correct and worth having too - I'm absolutely sure his judgement has a far higher hit rate than mine when it comes to core level stuff, after all.
&gt; Brutal but honest criticism isn't an insult. Okay, good: you're doing your argument a disservice with the excluded middle fallacy here.
That's just unkind, and doesn't contribute to the discussion.
[Key graphic](http://s3.amazonaws.com/marquee-test-akiaisur2rgicbmpehea/EsAgzz8fQSa0anxT4hw6_Kim%20Scott%20Figure%202.jpg) And a relevant quote lest you think it too squishy an article: &gt;If you can't offer radical candor, the second best thing you can do is be an asshole 
&gt; Some people are offended and feel disrespected with the least mention of criticism. Sure, but focusing solely on that is doing your argument a disservice.
&gt; I see scenario 4 as the most likely. I'm genuinely concerned about this as well, and unfortunately also see it as the most likely outcome. It's really a shame, and it's something I'd really like to be seen to be proven wrong on. All the optimistic comments in opposition to what feels like the most likely outcome seem very hollow to me. It's hard enough to get people excited about Perl 5 these days, Perl 6 has done nothing but make this even harder (while simultaneously being something most non-Perl developers seem completely content to ignore).
&gt; I sometimes wonder if the folk who'll be most comfortable learning Perl 6 will be those already willing to accept that the strings 您好, こんにちは, 안녕하세요, or नमस्ते are not actually line noise and can become natural, familiar, attractive, and clear, even if they currently look ugly and confusing. Did you intend this to sound as condescending as it does?
&gt; She responds with “do something first or STFU” and I say that that is bothersome. That is not all she said though. Her entire response was the following, and directed at you, with all parts being equally important and as far as i know her, honest: "If my crime is that I stepped in when no one else would, then call me guilty -- or at least take it up with the PAUSE admins. Otherwise.. give me a patch already or STFU." I understand selective reading can happen to the best by accident (it's happened to myself more often than i care to admit, and i consider myself below average) and ask you consider that it might've happened to you here, causing you to draw a conclusion much more severe than merited.
That is definitely one of the angles, and I'm trying to expand it by adding more language bindings such as [Inline::Ruby](https://github.com/awwaiid/p6-Inline-Ruby). Once the Perl5 binding is just [one amongst many](https://gist.github.com/awwaiid/01fe0e56e2c1220548a1), it will be obvious that the Perl5 relationship isn't so special. Similarly I'm starting to add docs that approach from different angles, like this [Ruby-and-P6-nutshell](https://github.com/perl6/doc/pull/288/files) overview. Though as I alluded to above, when it comes to the motivation to do these language bindings my quest is actually a bit wider -- I'd like module-level reuse to be more widely adopted in all languages.
No. I don't see a condescending read of it but given that you've copied it I'll just delete it from the original to avoid unintended harm. Thank you.
there is some merit to that. i have been writing perl6 now for a few months...getting pretty good at it...but now and then i will stumble across some and wonder if i am even reading perl6. but, i also treat perl6 as brain-candy and not a real production tool yet. frankly the other side of this is Go...because they say no to many (interesting) features, it is almost impossible for an intermediate Go coder to be confused by reading someone else's Go. but that comes at the price of the language being..."too simple"
I wouldn't say I have an objective to make enemies, but if I had a choice between: - A community that had troubles from time to time based on the struggle to produce quality software - A software development system where we had predictable bugs introduced from time to time based on the struggle to provide a perfect community I'd probably choose the former. After all, CPAN is a community of programmers, for programmers, oriented around the common goal of producing good software for the CPAN ecosystem. Its not a community that existed without a programming language, and without an ecosystem, and then decided it might just start including programming. I'm fine with doing the best we can to have a great community, but promoting community at observable expense to the software we develop seems a poor choice, given where we are and what we are doing and the ecosystem that relies on us. **edit:** lest there be any confusion about the possible notion that I'm suggesting that community is irrelevant, let me clarify I hold "The community" as a very high regard, and I will sacrifice myself where necessary in order to help the community. I just hold "the code" as a threshold of importance *higher* than that goal I'm willing to sacrifice myself for. In part, because the more time we spend trying to solve community issues and bitching about who is at fault, the less time we spend solving the actual problems. And I really do get utterly sick of all the infighting and egotistical wankfests. Biting your tongue and not talking about a technical issue because of your expectation that somebody might have a bad day if you so much as **try** to point out the technical issue is pretty much the worst thing I can imagine for producing quality software. 
&gt; the specifics of the situation and found that there was no urgency to make any change in particular Given the RT issue in question, the participants in that RT *conveyed* a sense of urgency, even if that urgency was imagined. So somebody responding in haste to a communicated sense of urgency is not necessarily the actors fault, but a complicated problem where the actor is operating in "good faith", but the signals they were using to act upon were made in error.
nobody is saying to bite your tongue on technical issues, this is a multi dimensional problem, not a single dimensional one see https://www.reddit.com/r/perl/comments/3zyqfk/female_keynotes_for_yapceu_2016/cyr3zpq
these days? Just use perl 6
Are you possibly joking? Perl6 isn't even remotely close to usable for anything but toy projects, and it's not like porting an existing codebase of any size to Perl6 will ever be feasible.
I'm pretty familiar with the state of Perl 6. I've been writing code under it for a while now. I've had pull requests merged. But let's be realistic here. It's very slow, hugely lacking in modules (~500 modules on modules.perl.org) and under such rapid development that you can't expect basic things like Panda or p6doc to function properly from day to day. Documentation is in a pretty dismal state as well, with developers frequently having to dig through ancient papers to find what obscure syntax is actually doing. I think it's pretty interesting, but you'd have to be crazy or not concerned about money to be putting up real world projects using it at this stage.
I have a hierarchy of needs, and generally, putting food on the table comes ahead of supporting software for people I've never met who do not pay me. However, because I do not have one foot in the poorhouse, I *have* occasionally taken unpaid time off work to catch up on open source projects -- and, here's a shocking newsflash! -- the projects I prioritize are the projects where I receive gratitude and appreciation for my work, rather than insults and accusations.
&gt; I'd rather someone rip apart my work and help me to make myself better. So would I. There are better and worse ways to do that though.
I expect the few people who know have been sworn to secrecy. The dates are near-finalized, though, and have been leaked a bit more widely.
It really isn't as bad as you're making out. I hope to have my first production system using it in a few months. The module ecosystem is pretty narrow and there are still some ugly bugs, but it's absolutely worth putting some time into.
perl5i is based on Damian Conway's now retracted initial plans for perl6 in perl5, but only partially. This was the original plan: https://web.archive.org/web/20040207072905/http://www.yetanother.org/damian/Perl5+i/ [cperl](https://perl11.org/cperl/) is a modern followup, but also not there yet. perl5i wanted to do everything in modules, cperl wants to do most in core, because you won't get a proper OO and type system with modules only. And esp. no performance.
I think you overreacted by deleting it. It's a point that asian programmer's may find unicode operators more attractive (or less off-putting at least), and there's a lot of asian programmers (and most likely there will be even more). 
&gt; the projects I prioritize are the projects where I receive gratitude and appreciation for my work, rather than insults and accusations. Exactly! I'm baffled by the idea of other commenters here that you can't have a healthy technical community *without* insults and accusations.
It's going to be on that island that the Cards Against Humanity people bought.
Could you provide some non-hypothetical examples? The topic seems to have drifted a long way from the original post anyway, but I'd suggest that specifics may be a better basis for discussion than these generic terms such as "basic human decency" and "insults and accusations".
What are "fee-fees", anyway? I assume you refer to the word "feelings". Your tone led me astray. I first interpreted your sarcastic slang as referring to "females", and I am not certain that that was entirely incorrect. The word "brutal" here is just unnecessary. It is entirely possible to criticise code (or anything else) in a constructive, respectful way without damaging the self-confidence of the human involved. It is entirely possible that the human, being a human, may take offence anyway. At which point reassurance may be provided and you may possibly move on together in pursuit of what you say is the goal: quality software. 
Maine?!
Simple programs that do nothing but compile themselves can take a full second or more, while a virtually identical perl5 program may compile and run in 50 milliseconds. Here's a trivial p5/p6 comparison: perl6 my $c = 0; while (my $word = lines()) { if $word ~~ /10/ { $c++; } } say $c; and perl5 use strict; my $c = 0; while (&lt;&gt;) { if (/10/) { $c++; } } print "$c\n"; run against 100,000 random numbers: $ perl -e 'use v5.10; foreach (1 .. 100000) { say int rand 1000000; }' &gt; words $ time perl6 p6 &lt; words 4930 real 0m4.307s user 0m4.256s sys 0m0.048s $ time perl p5 &lt; words 4930 real 0m0.022s user 0m0.020s sys 0m0.000s And without any input, to demonstrate the compile time: $ time perl6 p6 &lt; /dev/null 0 real 0m0.190s user 0m0.172s sys 0m0.016s $ time perl p5 &lt; /dev/null 0 real 0m0.002s user 0m0.000s sys 0m0.000s edit: this is maybe a more perl6ish way to do that #!/usr/bin/env perl6 my $c = 0; for lines() { if $_ ~~ /10/ { $c++; } } say $c; which is 2x as fast as the while loop, but still 100x slower than perl5 time perl6 p6 &lt; words 4930 real 0m2.061s user 0m2.032s sys 0m0.028s
Good to know. So good for pratice and getting familiar with perl6 but still not ready to take over from perl5.
While those performance numbers are accurate, or even slightly charitable. Being fast is the last thing that will be focused upon. In terms of the actual language I personally feel it's absolutely ready to take over. YMMV.
Thanks! It really is just a small piece of glue, though. autobox is where the magic is. I wonder if the author of that attends conferences. I'd love to shake their hand.
&gt; Could you provide some non-hypothetical examples? I think mithaldu's asking a different question. In almost 20 years of F/OSS experience, I personally can't think of a single example I've witnessed of someone feeling "driven away" from contributing because of polite feedback on a patch. I say "polite" feedback, because to my mind "your mother should get a retroactive abortion" is not polite feedback on a patch.
&gt; I don't see a condescending read of it The suggestion that a significant proportion of decent programmers in this Unicode-aware world might consider non-ASCII text to be "ugly".
Thanks for explaining this interpretation. (I don't actually understand how you get to it but at least I now know it's as far away from my intended point as doomvox's interpretation.) Fwiw the paragraph was originally going to look more like: I sometimes wonder if the folk who'll be most comfortable learning Perl 6 will be those already willing to accept that code like `m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h` (Haskell) or `my $path = (~$/).subst(/'%' (&lt;[0..9 A..F a..f]&gt; ** 2)/, -&gt; $/ {chr(:16(~$/[0]))}, :global);` (Perl 6) or `(!R)@&amp;{&amp;/x!/:2_!x}'!R` (K) is not actually line noise and can become natural, familiar, attractive, and clear, even if it currently looks ugly and confusing. (But then I decided I preferred to abstract away from code identified with any particular programming language(s) and then away from code at all -- because my point was really about how aesthetic sensibilities are influenced by familiarity or unfamiliarity of symbols and some folk are more willing than others to compensate for the disquiet of unfamiliarity.)
I don't think you recognise that you look very much like someone who intentionally hijacked the comments for Neil's well-intentioned blog posting, and for ill rather than good. Several people disagreed with you, so perhaps their views have some merit. The passive-aggressive bit at the end doesn't do you any justice at all, dude. Let us be friends.
&gt; I don't think you recognise that you look very much like someone who intentionally hijacked the comments for Neil's well-intentioned blog posting, and for ill rather than good. I do not "recognize" it, and moreover: I resent the accusation of "ill rather than good".
I regret that you resent that, but it doesn't change how I perceived it. 
How long do you think it will be until it is similarly performant to perl5 though? It seems like it is a long way away.
I don't think anyone's claiming that people would be driven away by polite feedback? And yes, I'd agree that your example is neither polite nor appropriate. Is that a real example or an extreme hypothetical? If the former, do you have a link? Did anyone speak up about it at the time? You're suggesting that hypothetical examples aren't useful - or at least the one given so far. I agree. I'd hope that we have few enough cases that it would be possible to put together a list - "look, here's where people acted unacceptably, don't do this". I should have said *specific* non-hypothetical examples. Otherwise I don't really see where this conversation is going - is the issue that the Perl community does not do a good job of making people feel welcome, or that people try to contribute and are driven away? If so, can we resolve that on a case-by-case basis? 
So this sounds like the opposite of the "technical trumps social" thing. Do you have a link to the RT or github issue for this one?
Social means were used, but in the mind of Reviewer technical issues were addressed. Technical trumped basic decency. Also, I'd rather not drag this further off-topic by delving into the mud. 
It's very hard to say. The two perls are vastly different beasts. If you profile your code above you'll find that it's already doing optimisations. It's just that (I'm mostly guessing here) perl5's regex engine is very much simpler and more straightforward than 6's.
I mentioned all details necessary and claim this is real and not hypothetical. Believe me or not. 
Quote: &gt; phonebooth.pl sits there reading characters from the keyboard (the phone keypad) and responding to them by playing MP3 files, or recording and saving new ones. Most of the MP3 files are pre-recorded. &gt; &gt; I launch it as a getty from /etc/inittab on console 0 so that the machine boots up into the Perl script: 1:2345:respawn:su phonebooth -l -c 'cd ~jwz/src/phonebooth &amp;&amp; ./phonebooth.pl' 
The situation was real, and was not even an isolated incident.
Two comments up OP also asked what is \a
&gt; Is that a real example or an extreme hypothetical? If the former, do you have a link? I misquoted slightly, but you can read the original words of [Linus Torvalds on the GCC mailing list, in the thread "Re: [RFC][PATCH 0/5] arch: atomic rework"](https://gcc.gnu.org/ml/gcc/2014-02/msg00217.html). &gt; Did anyone speak up about it at the time? [Lennart Poettering wrote about this behavior in the Open Source community, citing Linus's words as an example](https://plus.google.com/app/basic/stream/z13rdjryqyn1xlt3522sxpugoz3gujbhh04). &gt; You're suggesting that hypothetical examples aren't useful Let me be more clear. I'm suggesting that a hypothetical example of "but what if someone feels *triggered* that someone else criticizes a patch" is very hypothetical and unhelpful, whereas it took me only a couple of seconds to find just the single example I provided.
As /u/JoshWithaQ notes, my comment was a reply to /u/josephismyfake saying "There is one more thing similar \a. What is that?" 
Yes, feelings. Brutal does not have to mean rude. I use the word brutal in the sense of Brutalism, as in the class of architecture. To be more clear, it means highly functional, simplistic, and eschewing unnecessary ostentation. A brutal criticism would be: &gt;Commit rejected, style guidelines not followed. Refer to &lt;insert link here&gt; page 6 Compare that to: &gt;Sorry Billy, I can't accept your code. I really want to, but it's really important that our method names follow the naming convention that we are using. We are doing pascal case rather than camel case for class names - that means your classes should start with a capitol letter. If you take a few minutes and fix your class then send it again, I'll be able to accept. Sorry about that, and thanks! Your change looks good! The first is exactly what needs to be said and is the sort that I prefer. It gives you a reason for your commit being rejected along with instructions for fixing it - no bullshit, no pandering. As a QA, I occasionally do code reviews and that first example is exactly how I write them. I have offended people with that sort of review before, however. The second one is pandering, condescending bullshit. You talk that way to a child, not an adult developer (male or female). On the other hand, I'm not talking in favor of this sort of criticism: &gt;I wrote the style manual for a fucking reason. Read it before you send me more spam, ya twat. That said, there ARE those out there that I feel need to read that message on occasion. I'd never condone it, but sometimes there's only one way to get through to someone...
Probably nothing. I'm just trying to explore the ways Perl 6 might achieve adoption by businesses. Although to be honest, Perl 5 async is horse shit compared to Javascript (although is getting better now that we have a decent promises module). On paper at least, Perl 6 might be better.
&gt; I misquoted slightly, but you can read the original words of Linus Torvalds on the GCC mailing list, in the thread "Re: [RFC][PATCH 0/5] arch: atomic rework". &gt;&gt; Did anyone speak up about it at the time? &gt; &gt; Lennart Poettering wrote about this behavior in the Open Source community, citing Linus's words as an example. Thanks - so someone did speak up, but not in the thread. I find that disappointing. I'd hope that we do better in the Perl community if it happens in any of our fora. &gt; Let me be more clear. I'm suggesting that a hypothetical example of "but what if someone feels triggered that someone else criticizes a patch" is very hypothetical and unhelpful, whereas it took me only a couple of seconds to find just the single example I provide Not sure what *triggered* means here, but to quote the original comment: &gt; Biting your tongue and not talking about a technical issue because of your expectation that somebody might have a bad day if you so much as try to point out the technical issue is pretty much the worst thing I can imagine for producing quality software. This is not an extreme hypothetical. It's happening right now, in this very thread.
Its true that Future has been around for quite a while now, but I didn't know about it until early last year despite being active in the Perl community and discussing and writing async apps with many other Perl devs. In the end you can achieve the same stuff in every language. I think my problem with Perl 5 is that all the examples I've ever seen for async in Perl 5 (and therefore all the async code I've written in Perl 5) have been convoluted, messy, hard to test, and just downright bad. While all the examples I've seen for Javascript inside of nodejs or out have been the opposite. No I don't just mean node. In JS you're not having to pick your event loop. Nearly all IO is non-blocking by default. Then you throw in promises (which Future does) and async is not only easy but almost magical. One of the nice things about Perl 6 is that its async examples are clean and easy to understand. But then Perl 6 also brings in multi-core parallelism. This is relatively easy to achieve in Javascript via web workers (and similar things in node), but Perl 6 seems (on paper) like it will make it even better. Perl 5 again makes this possible, but its far from ideal. Anyway, we're way off topic from my original post which was about the possible business cases for adopting Perl 6. =)
I'd still like to see examples of the async code - I have no interest in perl6, they have their own subreddit, so perl5 async would seem to be quite on-topic here! JS [the language](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) doesn't really do I/O - that's the job of the implementation (by which I mean node.js or similar). As such I think there are quite strong parallels with, say, perl5+IO::Async. Thread support in perl5 would have been nice, but by the time I need the extra CPU power it's usually time to move to C++ anyway.
Mostly that the core language takes into account multi threading and has well defined behaviours with respect to parallel execution. So you know when something is and isnt guaranteed to be an ordered result or execute in order. Like the randomising of P5 hash keys this means you write your single thread code in a way that can grow to multi threaded without a lot of rewriting because your code already assumes multi threading. An example if you call a hyper method on a list even single threaded that will execute in random order, despite returning an ordered result: `@list&gt;&gt;.say` This catches new people out sometimes but once theyre aware of the behaviour all their code is written with parallel execution in mind.
as a oneliner: perl -lne'$prefix = $_ if /^Totals/; print "$prefix $1" if /^Stmts\s+(.*)/;' or if you already have the array: my %totals; # Record an array of numbers for each type (instances, files) my $prefix = 'unknown'; for my $line (@array) { $prefix = lc $1 if $line =~ /^Totals BY (\w+)/; # Set prefix if we have a line starting with "Totals" $totals{$prefix} = [ split ' ', $1 ] if $line =~ /^Stmts\s+(.*)/; # Record numbers if we have a line starting with "Stmts" } print $_ . ": " . join(',', @{$totals{$_}}) . "\n" for sort keys %totals; 
Go to jwz.org. Click 'hacks'.
&gt; On the other hand, I'm not talking in favor of this sort of criticism: &gt; &gt; I wrote the style manual for a fucking reason. Read it before you send me more spam, ya twat. Same here - this kind of answer should invariably be strongly discouraged in a technical discussion (and as far as my memory serves me - I practice that myself). Though I stop short of "Person is unpleasant =&gt; Person has nothing of value to contribute". We (not just Perl, the wider "we") mix these two concepts too liberally. Postel's law and all that ;)
Are you saying both companies use mainly those tools?
He wouldn't be because neither company is. Both are using custom in house stacks for the most part. I believe DuckDuckGo is using Starman for at least it's user contribution platform, but beyond that I'm really not sure of specifics.
i think you mean catalyst, not starman. https://github.com/duckduckgo/community-platform
Actually I wasn't thinking about the community platform itself at all but rather the thing you download to write plugins for DDG directly. But yes Catalyst too :)
&gt; It's happening right now, in this very thread. Where? I've read these comments multiple times and I still don't see it.
the RT mithaldu's talking about - he shared the link privately, it's something that I think would be sensible to follow up on, but he's made it clear that I'm doing more harm than good so I'm stopping here.
I appreciate that you're getting the message, but either you're misreading chromatic a little, or just missing a detail in interpretation. Maybe i can clear up this bit of the conversation a little. That issue isn't dropped because someone else might have a bad day if it's talked about, but because the person raising it was made to have a bad day when they talked about it. So, yes, tongue biting is happening, however the root causes for it that you and chromatic have in mind are diametrically opposed, at least in that instance.
My opinion would be to install VirtualBox, set up a Linux VM, and install BioPerl on that. I've had mixed experiences with OS X. You may also find that some of the C programs BioPerl modules depend on will compile more reliably under Linux.
I am a beginner and can only talk as a beginner: having checked so many possibilities, my personal opinion is Perl. It has the charms, the speed, the power, and its community is simply the best I have found. 
Thank you!
&gt; Sereal Thank you, and thanks for mentioning Sereal. I did not know about it (https://github.com/Sereal/Sereal). It looks really nice.
Gah, I *really* need to release another BioPerl.. :)
I think Bash is very good for beginners.
Damnit.. now I need to go play with Perl 6. 
Yes, please! There are still some areas for improvement, particularly in GFF file handling (not your fault, column 9 is a disaster). If only GFF would disappear.
Where does Perl 6 require you to use so many Capital Letters? Aside from class names (which are capitalized by convention already in Perl 5) and a few miscellaneous operators, I can't think of very many places.
True and False as booleans to name a couple more. Types `WHAT`
Not even a page into the blog post and he's accusing Perl developers (who by now if they've been developing are well into their 40s and have kids of their own) of being misogynist. Thanks mate, I don't know what I did personally to deserve your thinly veiled contempt.
It could be a lot better, it could be worse. I've never been overly fond of Duke, Sun's rather meh mascot for Java (http://www.oracle.com/us/technologies/java/duke-424174.html). I don't remember people caring all that much about the logos for languages when I was spending more time with C, C++ and Java. These days devs seem to need a cuddly toy to go along with their favourite technology or they have a conniption. :-p
The set of features together theoretically make an interpreter possible that compared to existing dynamic interpreters is much faster, catches way more errors at compile time, and is more scalable over compute resources. The interpreter currently is stupid slow, as best I can tell, but that might get fixed and Perl6 might be at the top of the benchmarks heap, like within reach of Java speeds, but obviously far more terse and expressive. Yet also much better at preventing bugs than simple dynamic languages. As a language I think Perl6 looks great. From my perspective I'm just stuck waiting for an implementation I can trust and consider fast enough. I've zero interest in hopping on IRC to nail down implementation bugs in my language.
The standard reply to that is "I'm just a user" despite being a programmer &gt;;3
A harsh and "ribald" culture is about driving away certain people. This is the unstated truth that "both sides" only tacitly acknowledge. The real point is that you absolutely do have to drive these people away or they will ruin your project or company. They are leftist entryists who will generate endless drama and distraction. The most effective organizations of our era have been tough places with a lot of "rudeness." It's not a coincidence.
&gt; The most effective organizations of era have been tough places with a lot of "rudeness." That sounds like the sort of claim that needs a lot of cited evidence.
This article would have been better if it had acknowledged criticism without strawmanning it and then immediately brushing it aside.
I believe you've misread that sentence as there was no acusation. Implied or otherwise. And the quote is directly from the linked document explaining the rationale behind the logo.
All of that criticism has been thoroughly addressed elsewhere in FAQs, blogs, IRC, and common sense. The article was not about addressing any them.
&gt; All of that criticism has been thoroughly addressed elsewhere in FAQs, blogs, IRC, and common sense. I disagree. Take, for example, questions about the version number. Why are there multiple version numbers for the spec, the compiler, the Star release? What's the plan for those in the future? Who's in charge of updating sites like perl6.org and rakudo.org so that the download links work? Handwaving those away as "Well there was a discussion on IRC and all criticism is whining anyhow" is hurting your project, in my opinion.
&gt; why you're expecting to see a release of something that was never released? Think about it from the perspective of a *new user*. For bonus points, think about this from the perspective of a new user *using Windows*. I don't know how to be any clearer than this.
Yup. :'(
&gt; you agree that there's room for improvement in the documentation and link structure though? Yes, I agree. From the perspective of a Windows user the instructions can be clearer, as there's no R* release with a 6.c compiler. I've mentioned this in the channel and hopefully it'll get rectified soon.
Thanks. That's now been posted on the #perl-release and a volunteer showed up, seeking a commit bit to make the instructions clearer.
Also Inf and NaN.
If you tried to use the same snarky argument to try and explain the gender bias in care-giving professions no-one would take you seriously as it's a shallow and intellectually dishonest way of thinking.
very nice
 &gt;Perl 6 was designed to be one-pass parsed. I'm not an expert either but I can't imagine that parsing of all things is the bottleneck in any programming language.
&gt; The C and C++ languages are even more like Perl, name-wise, but I don't remember all that much carping about naming. An insubstantial rejoinder. The author certainly knows that C and C++ preceded web searching, and that it is unlikely that Dennis Ritchie or Bjarne Stroustrup anticipated these confusions. &gt; Check out that Go gopher. I don't happen to like it a lot, but there are easy-to-find images of people getting it tattooed on various parts of their anatomy. I can only find one: https://twitter.com/kelseyhightower/status/588715318589140992 
Yes, we're all unfortunately in the same position in this field. So, the more volunteers the better :)
Actually I find these days it isn't too much of a problem on OS X to get the most commonly used bioinformatics tools compiled and working. The main issue I have found is volunteers/contributers who can help with perl TBH, lots of folks have moved to python. Also one key reason I'm looking heavily into Perl 6, e.g. the option to tap into other languages (and their tool chains, e.g. numpy/scipy, etc), it simply breaks the lock a single language has on a domain. 
Yeah there is "gender bias" mysogeny is a hatred of women and sexism is the specific judgement and preconception of someone based on their sex. You can have gender bias without people being explicitly sexist or mysogenistic. If you look at the data for women graduating with computer science degrees there was a sharp start of the decline relative to other subjects during the early 80s. Before I was even born in fact. So I've lived with a systematic gender bias in the field that has nothing to do with me or the people around me being mysogenistic!
&gt;An insubstantial rejoinder. The author certainly knows that C and C++ preceded web searching, and that it is unlikely that Dennis Ritchie or Bjarne Stroustrup anticipated these confusions. The confusion isn't that important. I managed to work on C (mainly) and C++ in the 1990s, and the world didn't end. C didn't go away, even though C++ was a superset of it. The two are still quite close, though they have drifted slightly. This is essentially covered by my 3rd point. I believe the decision-maker (i.e. not us) knows all of the above too, and it's his call. No matter how daft you and eleventy-twelve other people think it is. &gt;I can only find one: &gt;https://twitter.com/kelseyhightower/status/588715318589140992 Oh, you may have me there. I'll tweak the wording slightly.
SQLite FTW
&gt; I propose instead of this we should split the test phases yet again to this: &gt; &gt; user tests &gt; author tests &gt; release tests This is how things are today. &gt; Current perl recommendations encourage people to disable testing (as a user) because it's slow. Where are you seeing this? It's certainly not a common recommendation. I would never turn off testing unless I'm installing into a production environment where I've already done full testing on the *identical* environment already. 
It's fun to see Perl at MS but line 11 makes us all sad: #use strict;
Fix it and submit a PR. Probably want to keep dependencies to core-only though. 
Wonder if this means that DBM::Deep may finally be able to support transactions with SQLite.
No one is losing their shit. Its just interesting to see they used Perl at all for a project that didnt really warrant it. Its not like open source MS code appears everyday.
[removed]
Thanks! These posts are basically my learning process. I'm writing as I figure stuff out.
I think C is a good place. I teach bash to kids though. It's a good place to start as well. Why did so many people choose python?
I... not sure how to interpret this post, seems like it could be both/either 'awesome job' or 'really?!?'. Or a reaction to all the recent back-and-forth between p5 and p6. Or a mistaken 'Submit' on a partial post. Anyone know aristotle enough to clarify?
&gt; perl and web development Any particular reason you're doing this on Windows? &gt; I'm thinking about just giving up and installing a linux VM on my computer just for perl. Don't do this just for Perl, do this for web development in general. Unless you have some great need to be deploying things on Windows servers, I'm not sure why you'd invite the hassle. &gt; If you guys suggest switching to linux what is the best option for a windows user like me? Any distro will probably do, although you don't need a GUI at all. I run my home VM's as CentOS, but all web development I end up doing directly on my remote development server (currently Amazon EC2 running Amazon's Linux AMI). I assume people will probably recommend a variety of the popular distros. You probably can't go wrong with CentOS, Debian, or Ubuntu (the latter of which is probably best if you want a GUI environment, which you probably don't even though you think you might).
I can't help with Windows, but if you go for linux as a VM then go for whatever distro you've got in production. If you're going for a replacement for Windows, then go for a desktop-orientated flavour of it. Fedora for Redhat/Centos, Ubuntu for Debian, generally. 
! Installing the dependencies failed: Module 'Plack::Middleware::FixMissingBodyInRedirect' is not installed, Module 'Plack' is not installed, Module 'Plack::Middleware::RemoveRedundantBody' is not installed ! Bailing out the installation for Dancer2-0.166000.
isn't this just a command line shell?
yea I would like to keep the windows but have the linux for work. Fedora and Ubuntu are just guis for those distros?
It's more like a UNIX-y environment within windows. See here for more [info](http://lmgtfy.com/?q=what+is+cygwin)
It would be much easier for people to help if you could upload the full installation log to a pastebin somewhere. There isn't much context there
Install a VM of the same stack you will deploy. If you plan do deploy on CENTOS, setup a VM of CENTOS. You spinning your wheels to learn how to make this work on Windows is zero value, you are never going to deploy on Windows and the community isn't used to even considering how things will work on Windows. 
Wat?I would understand this if it was a camel.
Don't worry about it. Perl 6 was finally released recently, but Perl 5 will continue to be the most widely known and supported version of Perl for the foreseeable future. Version 6 has a lead developer/architect whose main platform is Microsoft Windows, so I understand it is fairly well supported there. If you want help with strawberry Perl you have to provide a *lot* more detail about what you did and the responses you received. Sharing log of the installation process would be most useful.
sorry still very new at this. I will do that thank you.
The velociraptor has come to mean specifically Perl 5, where the camel and the onion refer to all of Perl (including 6). Incidentally the camel is owned by O'Reilly so the Onion is really what you SHOULD use for Perl as a whole. Futher /u/matthewt and others have given an effective "State of Perl 5" but called "State of the Velociraptor" at YAPC conferences giving yearly progress. http://mdk.per.ly/2011/03/02/evolution-of-the-velociraptor/ http://mdk.per.ly/2011/05/28/cry-havoc-and-let-slip-the-raptors/
People don't like the butterfly, but I still think it's not too late for TPF to adopt a better logo. 👯
No, they're the more desktop-orientated versions. You can put a gui on CentOS or Redhat or Debian, but they're prettier and less clunky on Fedora and Debian, and things (like web browsers) are newer, so it's all a bit less of a faff to use.
&gt; I have a cheap server I bought that I was going to setup FreeNAS for Plex and storage, but now I'm wondering if I should use it as a linux box for work instead of VM on my laptop. Not sure the specs of that box, but you could theoretically run it as an ESXi server and run a couple VM's (including one for FreeNAS, which I'm not at all familiar with, but they do claim support for running under a VMWare VM). Then again, for web development stuff specifically you might just want to grab an inexpensive VPS or take advantage of something like Amazon's free tier of AWS services (for up to a year) and do all of your web development work in the cloud, leaving your home server free to do what you want with. Totally up to you, but this might be less overall effort for a minimal cost. &gt; Is there a specific distro that would be ideal to setup a remote environment that I can log into from any computer to work on? Any of the ones I listed should be fine. Again, you probably want to avoid a GUI entirely and do your work from a command line. In this manner, all you need is an SSH client on Windows (PuTTY or any of its variants will do, also check out mRemoteNG for free or XShell if you don't mind spending a few dollars). If you're already comfortable with Redhat, go ahead and get CentOS (it's essentially the same thing), or Amazon Linux AMI, which is also Redhat based (I believe), if you go the AWS EC2 route. &gt; I've been trying to use RealVNC to work off my work laptop from my home computer, but I can't stand how it's dependent on screen capture. The plus side to the kinds of things it sounds like you're trying to do is that you don't need a GUI at all, so you won't need VNC or anything like that, you just need to SSH to the Linux machine and do what you need to do on the command line. Hope this helps a little, good luck!
This was super helpful! Thank you very much
Now I love Perl even more.
but it lets you install unix programs?
I installed that same version. I am running Win 10 Home. I also used cpanm first. It's frustrating seeing how on the matrix other testers got it to work for this version and I can't.
i uploaded it
quick question I'm looking into installing ESXi but some tutorials say I need vCSA, but that is not free. Do I need that for my purposes?
[removed]
[removed]
These actually look really nice, I'll definitely find a few places to slap some of these. Thanks!
I see a few lines of this: `Terminating on signal SIGINT(2)` This is you hitting CTRL + C correct? Why are you doing this if so?
The problem with teaching python first is it's use of white space is so different from other popular languages like C and C++ and perl. I am still a beginner though so my experience is limited.
Right-click daemon.t and kill it.
you may want to look at remote debugging where you run your perl interpreter in Linux but debug it with Komodo under Windows: http://docs.activestate.com/komodo/4.4/debugperl.html
I don't think I follow what you are saying. Are you saying task manager to end task?
oh I think I get it. I used process explorer and saw that dmake instantiated perl.exe for testing so I ended that and the testing continues now.
The Factor programming language also uses a raptor: factorcode.org I don't think there are still many users. It is interesting in that it is a Forth like stack language with functional and OO features with an image and is pretty fast.
Have you considered using something like [ExpanDrive](http://www.expandrive.com/)? It supports mounting a remote SFTP folder on Windows.
I like how python is at the bottom with almost no negatives to it. That right there made me go "yeah.. I can't take this article seriously"
&gt; Perl is sometimes semi-jokingly referred to as a "write-only" language. That is, its syntax is so bizarre that code written in Perl is essentially unreadable by other programmers and thus not editable by other programmers. This sort of code is sometimes referred to as "line noise." *deep sigh* This is true only if: - You're looking predominantly at intentionally obfuscated code - You're a novice who has not bothered to learn Perl yet I'm not sure which part of this large paragraph is part of the "Semi-Joke", but **this joke needs to die** because people keep treating it as a serious criticism of the language when its really a stand-in for "Waah, learning is hard, lets not do that, and lets judge C because it doesn't look like Ruby and is thus weird" I also did some statistical studies on a wide codebase of Perl ( my `@INC` ) and found that the line-noise prevalence was nowhere near that which it was accused of: 1.0 % : 2410416 x char 49 : 1 1.1 % : 2594921 x char 61 : "=" 1.1 % : 2684166 x char 95 : "_" 1.1 % : 2709633 x char 112 : "p" 1.2 % : 2818643 x char 58 : ":" 1.2 % : 2952175 x char 104 : "h" 1.2 % : 2995621 x char 45 : "-" 1.3 % : 3151943 x char 109 : "m" 1.3 % : 3283418 x char 36 : "\$" 1.3 % : 3291138 x char 102 : "f" 1.4 % : 3339529 x char 39 : "'" 1.4 % : 3355931 x char 117 : "u" 1.5 % : 3638254 x char 99 : "c" 1.6 % : 4016055 x char 100 : "d" 1.9 % : 4598003 x char 44 : "," 2.0 % : 4786703 x char 108 : "l" 2.2 % : 5472272 x char 48 : 0 2.6 % : 6279579 x char 110 : "n" 2.6 % : 6306811 x char 111 : "o" 2.7 % : 6625715 x char 105 : "i" 2.8 % : 6872608 x char 114 : "r" 3.0 % : 7315145 x char 115 : "s" 3.1 % : 7522087 x char 97 : "a" 3.6 % : 8711403 x char 10 : "\n" 3.7 % : 8972142 x char 116 : "t" 5.4 % : 13289205 x char 101 : "e" 24.2 % : 59186425 x char 32 : " " By this analysis, the language could be criticised for being "Mostly whitespace" Though it is curious how the top 8 alphabetic characters were etasrion Which mimics English, but surprisingly, when written backwards, could be mistaken for something else: noirsate noi&lt;r&gt;s&lt;at&gt;e noise So ... there's a strange kind of truth here. 
I skimmed the headers first. Those are all extremely successful languages. Sure, VB6 and Perl are probably the underdogs nowadays but were very influential in their prime. Next you tell me there are people who hate pizza, noodles or hamburgers.
We "hate" all of them. Familiarity and all that.
While I am guilty of having uttered many of them on occasions, reading these cliches one after another on the same page made me understand how silly they actually are. All of them.
They did mention one thing that is totally true in my experiences. All the people that hate Perl are usually the ones who have not actually used it much at all, and pretty much anyone who actually uses it likes it. /downvoted anyway...its poorly written blogspam full of useless info 
Have you got DBI installed? DBD::mysql is just the specific driver for DBI which handles MySQL. You have to have the DBI module as well.
Just installl virtualbox on your existing computer and install any one of the many mature linux distro's in it. Away you go. There's ActiveState Perl for Windows, but I can't think of why you'd want to wrestle with that just to poke around with a tool originally built for unix-like OS's.
Your lab should purchase and install a few nodes of NEC SX series: https://en.wikipedia.org/wiki/NEC_SX-6 About this many nodes should be good: https://upload.wikimedia.org/wikipedia/commons/b/be/Earth_simulator_ES2.jpg Yeah, basically forget the cloud, Raspberry Pi, Mac, or Linux. You need an Earth Simulator to run Perl.
as a mac user I am obliged to try and shill you an apple product. You should totally buy a nice mac. i do some biological data analysis and have found that a MBA handles all of my (rather modest) needs. Runs python and perl and matlab if i need it. 
I'll tell my PI to put in an order. Our Mac's at the lab are always tied up so might as well upgrade.
using [Vagrant](http://www.vagrantup.com) with cygwin has been a success for me. combined with Virtualbox and some sort of Linux base image (available online), it's simple to spin up a VM for immediate use, and trivial to discard it. rebuilding allows reversion to a known good state in seconds. shared folders will allow your code to persist through rebuilds. the shell provisioner means you don't even have to execute your code manually, too. a lot less hassle than managing a custom installed VM.
Window is fine if you are developing Perl apps for data crunching and the like. I wouldn't bother with Unix/Linux unless you want to get into running a web server or service. I'd use ActiveState Perl on any old Windows laptop. Perl is designed to be portable, so any app you write in Windows should run in a Unix world (assuming you adhere to recommended ways of writing file paths, e.g.). For example, you'd write the path 'c:\foo\bar' as '/foo/bar'.
Even better: write the path as $path and populate it from @ARGV or something like [Config::Tiny](https://metacpan.org/pod/Path::Tiny) - No more problems with escaping backslashes or spaces :-)
I wouldn't bother with a Raspberry Pi if you want to run bioinfo software. Most of them have Intel SSE specific optimisations and other stuff specific to Intel, without those a lot of tasks will take you hundreds of times longer on a similar perf CPU. Nerfing the horse power and the architecture means you could be waiting for the age of the universe to produce a phylogenetic tree etc. especially with no RAM.
One vote against Cygwin. I hate it. It's clumsy at best. I'd rather either use Perl under Windows, or a Virtual Machine with Linux.
+1 for ActivePerl. Works very well for me. Although I do miss perlbrew on Linux. 
Is your DB column storing the value as a string? If so, try: if ($data{$key} &amp;&amp; $data{$key} ne '0.00') Perl will treat a string that has only a zero (ie. '0') as zero/false. But not so with the '0.00' string, so you need to explicitly check for that.
vim-perl already has TT2 highlighting as well. https://github.com/vim-perl/vim-perl/blob/master/syntax/tt2.vim
The value is being stored in the database as a float and when I check for 0.00 it fails.
Unix / Linux is common in science, so it's useful to learn it. On the other hand, you don't want to get overwhelmed, distracted from your primary goal, learning Perl. As with anything you learn from the inner-tubes, there's the danger of confusing modern tutorials and obsolete ones, quality material and substandard stuff. Of course, perl has lots of "official" tutorials ( the 'manual', 'reference' and 'modules' sections at http://perldoc.perl.org/ ). O'Reilly books are wonderful, but watch out for the old editions. "Modern Perl" (https://pragprog.com/book/swperl/modern-perl-fourth-edition) is excellent!
It seems a bit disingenuous to pick two problems for which there exist Perl 6 core methods that perform the task.
Why are you copying the query result records field by field onto each other? If your query result was 1, 2, 3 11, 12, 13 21, 22, 23 you would set %return = ( column1 =&gt; 1, column2 =&gt; 2, column3 =&gt;3 ); then overwrite that with %return = ( column1 =&gt; 11, column2 =&gt; 12, column3 =&gt;13 ); and then overwrite with %return = ( column1 =&gt; 21, column2 =&gt; 22, column3 =&gt;23 ); Hopefully it's just this contrived example. What you really want is fetchrow_hashref() or better yet, selectall_hashref(), to aggregate all that prepare / execute / bind stuff.
I think the main issue is when I query the database and set the result to the hash. I think the value is set to 0 instead of 0.00. If I print out the values before any checking/modification they print as 0. Here is my code when I check after assigning the query to the hash: ` if (defined($data{$key})) { print "$key\n"; if ($data{$key} ne '0.00') { print "$key is NOT 0.00\n"; } else { print "$key is 0.00\n"; } } ` 
I would probably write the first one as: u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' l = 'abcdefghijklmnopqrstuvwxyz' o = '' for a,b in zip(u,l): o += a+b print o and... I'm not sure how I'd write it clearly in perl 5 (I haven't started into perl 6) just because you can write something on one line, doesn't mean you should. (also... I understand the author is joking) EDIT: lineend broke formatting
Readability is definitely a subjective topic. I find the amount of things I have to parse and juggle in memory while understanding a piece of code is a crucial metric. In the first example, the Python version has many more elements to memorize than one operator, method call, and a subroutine call of the Perl 6 version. At the same time, the for loop in the Python version is highly idiomatic, and thus doesn't require individual parsing and memorization, and as such, the Python version can be perfectly readable to a competent Python programmer. That's the subjectivity.
You could write the python code like this if you have a problem with `for` loops: from itertools import chain ''.join(chain(*zip(u, l))) 
Or this (someone pointed it out elsewhere): use List::UtilsBy 'zip_by'; say join '', zip_by { @_ } map [split //], $u, $l;
Try `$data{$key} == 0` instead of the `ne '0.00'` at the moment you are doing a string comparison. 
The thing that's really floored me so far is the X metaoperator. Want to see the distribution of possible values for rolling 2d6? Do a cross with the addition operator:- $ perl6 &gt; (1..6 X+ 1..6).sort (2 3 3 4 4 4 5 5 5 5 6 6 6 6 6 7 7 7 7 7 7 8 8 8 8 8 9 9 9 9 10 10 10 11 11 12) it's really cool, and I can't imagine doing it in other languages without some tedious looping.
Errm. `(?k:)` is not a core Perl 5&amp;#160;feature. But the `X` hyperop is a core Perl&amp;#160;6 feature. All you are saying is “I don’t know the language so I don’t know how to read what you just wrote”. There is nothing obscure about `X+` to someone who knows Perl&amp;#160;6 – just like a Python programmer can read those comprehensions in his sleep, in contrast to /u/zoffix finding them linenoisy.
wat. I think the reality is different people find different things more readable. If you grew up in an operator heavy language you really like the linenoise. It's the same with braces and semicolons those are essentially noisy but people who started in C style languages find it challenging to leave them behind. The problem I had with the examples in this blog post is all of the keyword/builtins have really unintelligible names for me. So if you don't know them already its hard to guess what the line of code does. Like 'rotor' and frankly even 'roundrobin' I can't be certain exactly what they do. But the point of learning a language is once you do know what those builtins do you likely remember them since they have a semantic name. Zoffix is trying to make the point that once you know what those words mean its highly readable and you know the code is correct because there is little else thats been written explicitly by the programmer. In the Python examples you *get* what list comprehensions are and roughly what the for might be doing if you didn't. But the programmer still had to think and write that code which could be bugged.
Each to their own of course but I'm surprised about a couple aspects of your comment. **`zip` vs `Zop`** I can see the sense in consistently using only the `zip`, `cross`, etc. functions and banning the `Z`, `X` etc. ops and metaops in a codebase as part of a policy of reducing operator use. But if a codebase uses, or is expected to use, the `Z` metaop, then I and/or other devs would presumably need to be reasonably comfortable with it, and then I'd be inclined to use the regular `Z` op instead of the `zip` function to keep things simple and consistent. **Constant vs Container use of sigilless variables** A sigilless variable is permanently bound at initialization. If it's bound to a data value (not a [Container](http://doc.perl6.org/language/containers)) then it will of course behave like a constant, eg: my \u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; u = 'abcdefghijklmnopqrstuvwxyz'; # Generates an error But if it's initialized to, say, a [Scalar container](http://doc.perl6.org/type/Scalar), then it will behave like a regular variable, eg: # Bind to `$`, an anonymous Scalar container: my \u = $ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; u = 'abcdefghijklmnopqrstuvwxyz'; # Works fine my \array = [1,2,3]; array[1] = 'foo'; # works fine say array; # [1 foo 3] I think the constant and container uses of sigilless variables are equally respectable.
The disingenuous part is deducing from those two examples that Python is "The New etc." It's a weak argument that hurts the point you're trying to get across more than it helps. I mean, I was amazed that Perl 6's method of calculating Fibonacci numbers in a lazy list is even shorter than Haskell's. But it's just a side effect of how certain operators were designed. You cannot deduce from that that Perl 6 is better/worse than Haskell.
We have requirements to ensure data stored in files makes in into the database. I am working on a script to automate the process of validating the data stored matches the data in the file. 0 and 0.00 are the same numbers, but they are stored in the file and database as 0 and 0.00. So I was not sure if there is a way to check and print those values as 0 and 0.00 instead of just 0. I hope that makes sense,
Yeah zero is zero numerically in Perl regardless of floating point or integer... If your database record is a float it will always be the 0.00 case anyway. Not sure what the problem is anymore? Perhaps you can say just what you want to do in simplistic English without any code.
I appreciate the feedback and the query is limited to one return I just threw that one in as an example. ## The solution I have has worked for me in the past to dynamically create a hash based on the return instead of hard coding the table names for generic queries like select * from table. ## I am not the best with DBI and most documentation I have found has been very vague about the other hash options. Do you have any examples or tutorials for fetchrow_hashref or selectall_hashref? Thanks again, 
That was painful to read. I understand a casual author not quite getting the distinction between lists and arrays. But calling both operators and methods "operands," and calling conditionals "loops" is kinda beyond the pale. 
MMORP6G heh
Great news! But are they saying it's Orlando, or more specifically, Disneyworld?
There is also a *roundrobin* recipe in the itertools docs: https://docs.python.org/3/library/itertools.html#itertools-recipes
I love perl
You could perl on a pi. That isn't too much of an investment.
&gt; For the most part, there's no need to learn some new arcane thing to hack on the innards of the compiler. Except: learn Perl 6.
Obviously the audience in question are Perl 6 users who already know Perl 6 -_-
Slight shame about the (free) registration required to read the full article. But good to see Perl 6 getting some wider coverage.
Looks to me like he patched a module. It might be a module that's distributed with perl6, but that doesn't mean that perl 6 is written in perl 6 any more than having, eg, File::Basename bundled with perl 5 means that perl 5 is written in perl 5.
Actually it was more like modifying utf8::upgrade as it is internal to the compiler.
The other piece of code I mentioned was directly part of the List type code. Still Perl 6.
Yes, but most *popular* languages at the moment aren't "compiled" and have runtimes that aren't implemented in the language in question. Java is C, Python (CPython, the one mostly used) is C, Ruby MRI is C (and none of the other ones are Ruby), PHP (Zend) is C, Perl 5 is C. JS runtimes are mostly C++, some C.
Hi raiph, When I see you write unkind phrases like "lesser 'evils' like &lt;person_name&gt;", I think your attempt at levity will fall on deaf ears.
Certainly true, but extending core types in the language itself isn't a new thing. Any language which can't support that is particularly limited. (One could also discuss the lessons of JavaScript, where not only is implementing the language in itself a demonstration of the power and evolution of the language, it's been, for years, the best way to make the language as a whole faster.)
Has Perl 6 made Perl more modern? I haven't touched or looked at Perl 6 yet
IMHO it's the lack of widely used applications. Or niches. People don't learn PHP because they want to write code in PHP, they learn PHP to be able to write Wordpress plugins. Ruby? Rails (ok, a framework, not an application, but one that was a fresh breeze, and marked very well). Swift? iOS development. JS? The browser. Perl has a few niches (bio informatics, text processing, admin stuff, CGI), but it's not the only viable alternative in any of those, and they don't seem to be trending very much.
&gt;Has Perl 6 made Perl more modern? Perl 6 is a complete different language than Perl 5 (don't let the the naming fool you). Semantics, et al, are different in Perl5 v Python v Perl6. In fact, I think Larry would have been better off naming Perl6 something entirely else to avoid the confusion To answer your question... yes, Perl6 is a much more modern language than Perl5 (you can google the features). However, they are mutually exclusive.
Well you can't really self-implement an interpreter or virtual machine, because it needs to be natively compiled. Java obviously doesn't implement the JVM in Java, but it does implement javac, the compiler in Java. Since AFAIK P6 doesn't have a native compiler, I assume none of the VMs it targets are implemented in P6 either. &gt;Ruby MRI is C (and none of the other ones are Ruby) I know even less about Ruby than I do about Perl 6, but a quick Google leads me to believe that there is a version of Ruby written in Ruby called Rubinus (which apparently has an incredibly vague and pretentious website.)
&gt; bio informatics Came here to say this. Lots of good stuff written in perl for comp bio work.
Because everything you want to do in Perl you can do cleaner in Python. I can't think of any reason off the top of my head I would choose Perl over Python unless there was some module that only Perl had.
&gt; why the hell is creating a new object called 'blessing' it Because we're taking an existing reference and adding a module name onto it like a tag. The "object creation" bit is an abstraction one layer above, which has blessing as one of its component parts. (The other parts are creating the reference itself and storing the correct data values in it.)
Perl 6 is essentially a brand new language, from which Larry Wall has borrowed the least valuable asset from Perl: Its name.
Ah, sonny come sit around the fire and I'll tell you a story. Twenty years ago, Perl was King. Perl, more than any other language, *enabled* the World Wide Web as we know it. Once web browsers developed the CGI interface to scripts, you could write code to accept HTML requests and parse them, spitting out a page. Perl 4 and, even better, Perl 5 when it rolled out, were so terrific, so powerful, so *learnable*, that almost anyone could start writing truly mind-boggling things in them right away. And everyone did. Hell, I got on that bandwagon too -- in 1995 I wrote a planning tool for the [SOHO](https://en.wikipedia.org/wiki/Solar_and_Heliospheric_Observatory) using CGI and Perl scripts that populated web forms and used them as a front end to interact with a database. There was even a popular-level abbreviation for that style of development: "[LAMP](https://en.wikipedia.org/wiki/LAMP_(software_bundle))" -- Linux, Apache, MySQL, and Perl. *Everyone* who was anyone was writing LAMP stuff for the web, and/or hacking text processing in Perl. My first compiler project was written in Perl, since it's such an awesome environment for text processing. The problem came because Perl is the programming equivalent of English. It's very easy to learn enough English to get by. In some ways, English is the best pidgin language ever invented. In fact, pidgin "[Engrish](https://en.wikipedia.org/wiki/Engrish)" speakers outnumber native English speakers worldwide by a factor of more than 3. But mastering English is very hard, because there are so many layers of different languages all glommed together. That means two masters of the English language can communicate very richly - there's room for at least three layers of meaning in most statements. Perl is the same way: it has many different languages all glommed together, so anyone can pick it up fast and Get Things Done quickly. If you learned programming with [Pascal](https://en.wikipedia.org/wiki/Pascal_(programming_language\)) (as many did), you write procedural, structured Perl. If you learned shell scripting, you write shell-like Perl scripts. If you learned Lisp, you write lisp-like Perl scripts. Etc., ad nauseum. A true Perl master can communicate a *lot* to fellow coders with idiom and nuance. But 99% of the Perl code written in the 90s, and most Perl code written today, is not written by masters. It was/is written by people with little discipline, because coding structure, architecture, and discipline are things you *learn*, and most users of Perl in the 1990s "just picked it up to get stuff done". Those people, largely, wrote unmaintainable hacks. And if Perl is a leading environment in efficiency and flexibility, it is also the undisputed world champion environment for ability to support horrible, evil, hard to parse obfuscations and spaghetti. By about 1998 or 1999 people were starting to call Perl a "[write-only language](https://en.wikipedia.org/wiki/Write-only_language)". That WOL aspect was worsened by PHP, a morass of spaghetti hacks designed to make templating CGI tasks easier. PHP was never designed, it just grew and metastasized. But it made a bunch of stuff easier – so it became a "killer app" for Perl, and exploded in complexity, ugliness, and popularity. Like Perl, the PHP world became dominated by horrible hacks written by people who "picked it up one day" and never learned how to architect, test, or structure their code. I remember attending one of the live debates between Guido (author of Python) and Larry (author of Perl) about language design. Perl was deliberately designed to be flexible. Python was deliberately designed to be a "[bondage-and-discpline language](http://c2.com/cgi/wiki?BondageAndDisciplineLanguage)" (like Pascal) in which you could do things exactly one way. At the time, that seemed a little ludicrous to me -- but I remember thinking, even as a proficient Perl coder, that maybe Guido had a point. There is a ton of barely readable Perl code around, because Perl does nothing to stop you from writing horrible code, and many coders don't bother to try writing good code. Then around 2000-2003, people in CS departments started *teaching Python as a first programming language*, because it enforced structure and fit their pedagogy. Once that happened, Python (which is equivalent to Perl in most of its functionality, though not as liquid in its syntax) skyrocketed in popularity. That has happened before. Pascal itself, the granddaddy of the B&amp;D languages, was intended as a teaching tool only — but once enough people learned it in CS classes, people tried to use it for real work. Folks even wrote *operating systems* (like MacOS) in it, though that seems absolutely stupid in retrospect. Python is enjoying that same boost now: enough people know it as their first programming language, that it is used for many things -- even things for which it is not well suited. Nowadays, Python is commonly accepted as the *lingua franca* of the programming world, because -- while it is not nearly as expressive or flexible as Perl -- it enforces a degree of maintainability that is not enforced by Perl. Most existing Python code is readable by most Python users. Most existing Perl code is not readable to a large fraction of Perl coders. Put another way: Perl took the approach that "Hey, we're not the code police, code how you want and live with the consequences". Python took the approach that "Hey, we *are* the code police, you should write in a common style even if it's not the right one for your particular brain". It turns out that you don't need as much skill to become proficient at Python as at Perl, and that is enough to make the difference in popularity. Perl 6 also gave us a powerful "[Osborne effect](https://en.wikipedia.org/wiki/Osborne_effect)": a lot of wind went out of Perl 5's sails, popularity wise, when Perl 6 was announced. And we've all been hanging fire enduring taunts about working in a "dead language" *for a friggin' decade* while Larry and the rest of the Perl 6 team have been working on their pet project. If Larry had called Perl 6 anything other than "Perl" the world might be a lot different now. So... to sum up: * Perl is very flexible, which requires discipline. Most people are (or, during Perl's heyday, were) not disciplined, and so much existing Perl code is horrible to maintain. * Python is more disciplined: it forces people to write code a certain way, and makes it easier to teach and encourage disciplined coding. * Python is a better teaching language because of the discipline, so schools adopt it. * Because most folks coming out of college "speak" Python, many projects are written in Python as a default language. * Perl 6 sucked the air out of the Perl 5 community for a looooong time. 
Perl's lack of popularity is complex. I'll start with freedom. Freedom is a wonderful thing to have. I happen to live in the US, and some of us can't shut up about freedom. Some people believe that you should have as much freedom as possible. Freedom to smoke weed, for example. Freedom to do anything. Most people believe that freedom should have limits. Like, you shouldn't be able to smoke weed, for whatever reason. Some of those people are just assholes, but most of them have a reason -- something they're trying to protect you from. Perl is a freedom-loving language. You want to treat your numbers as strings on one line, and do math with them with them on another? Fine, you can do that in Perl. You want to write an entire script in one line? Or write it as ASCII art? Fine. Do you want to invent a 39th way to do something that can already be done 38 ways? Fine. There are those who believe those things are dangerous, particularly when *your* code is handed off to somebody else to maintain. And those people have a point. Some of those people believe it so strongly that they believe that _the language you use should not allow you to do those things_. It is an understandable point of view, but not one that we all share. One of my favorite things about Perl it its flexibility. It doesn't mean I should write shitty, badly-formatted or dangerous code. That's where best-practices come in. But I not believe that the language itself should be the enforcer of best practices. When freedom is greater, then you tend to have more people who abuse that freedom. This is true in Perl as well. Because Perl allows you to write code that does stupid things, many people have. There are many examples of wonderful and beautiful Perl code, and there are many examples of monstrosities that should never have to be maintained by anybody. Those examples have driven a lot of people from the freedom camp to the control camp, which has led them to other languages. I said I would start with freedom, which implies that I have a lot more to write. But I'll try to wrap it up. Lots of people are annoyed by the "excessive punctuation" in Perl. Why do we use $ for scalars, @ for arrays, and % for hashes? For those of us who are used to it, it makes sense. But I can understand why people get annoyed at things like that. I heard somebody make this criticism of Perl not long ago: "it's excessive reliance on regular expressions." Of course, that is a misunderstanding. It's not that _language_ is overly reliant on regexes. It's that Perl's support of regexes is so well done that we tend to use them a lot. Because of that, it's true that Perl developers tend to be better at regexes than others. And there are also probably situations where you don't need a regex, but you use one anyway, because it comes naturally. Some people would lump complex regexes into that general "ugliness" criticism, which you hear a lot about Perl. And speaking of ugliness, there's PHP. PHP is interesting, because it was born out of Perl. It's a nephew of Perl that got out of control. It started off as a really easy subset of Perl that was written specifically to make websites (Perl was not), so it got really popular. It had far fewer features than Perl, but that was the idea. Over time, many of those features have been added to PHP, but in ways that are inconsistent. So PHP can be infuriating to Perl developers, as it is to me. I think PHP turns out some of the ugliest and stupidest code imaginable, but enough about absolute facts. One final point. People are unlikely to hate a language they have never been exposed to. It's why I don't hate Visual Basic. I've never really used it. But I do hate Java, not for any particularly good reason, but because a long time ago, I had periods of time where I had just enough exposure to Java that it really pissed me off, because it didn't behave the way I expected. So now, I have the (perhaps irrational) view that "Java sucks," which of course probably is not objectively true (and that thing I said about PHP... that was a joke, of course). So for the exact same reason that I hate Java, lots of people hate Perl. It didn't meet their expectations, or it provided too much freedom, or it was ugly, or it wasn't "compiled", or it was "slow". Meanwhile, lots of other comparable languages have popped up. Let's take Ruby and Python as examples. I am in no position to say that there's anything at all that you can do in Perl, that you cannot do in Ruby or Python (except [Autovivification](https://en.wikipedia.org/wiki/Autovivification), which is incredibly useful and a nice party trick, and I use it all the time). My desire to use Perl instead of those other languages has everything to do with my knowledge of, and my comfort with, Perl. Fortunately, I still have plenty of opportunity to use Perl, even though the company I work at is -- strangely -- a PHP shop :)
I like Perl too, and your writeup makes sense. I'm going to keep at it, even if the syntax at times seem exotic. This part is still "foreign" to me, or is a in jest? &gt;Freedom is a wonderful thing to have. I happen to live in the US, and some of us can't shut up about freedom. 
dont sweat it, perl python and ruby are basically the same with slightly different upsides and downsides. 
The lack of a modern IDE and/or debugging tool is definitely driving me away from Perl. I can't believe how free and full-featured PyCharm is. I've never found anything equivalent for Perl. Debugging javascript through a browser is easier than debugging Perl.
Python is also an excellent application extension language due to the uniformity. Perl otoh is best for containing the mess and the horror. 
Show us an example then ;)
&gt; Why is Python more attractive and popular? * **It comes with a REPL** Omg lol!! Just open an editor put in your code and run it wtf do u need a repl for lol??? `¯\_(ツ)_/¯` * **It comes with modules for dealing with common file formats** &gt; How do you parse CSV in Perl? Use **Text::CSV** Use **Text::CSV_XS** &gt; But they don't come with Perl by default!! How do I install them? Use **cpan** Use **cpanm** &gt; I tried using cpan but I get permission denied, how do I install modules into my home directory? I get cpanm command not found? Set up a **local::lib** and use **App::cpanminus** &gt; **FUUUUUUUUUUUUUUU** &gt; How do I parse JSON in Perl? Use **JSON::XS** Oh wait no don't use that it's written by Satan himself!!! use **Cpanel::JSON::XS** Actually, wait no use **JSON::MaybeXS**... maybe? &gt; Do they come with Perl? **FUUUUUUUUUUUUUU** &gt; How do I parse XML with Perl? Use regular expressions!!!!! Use **XML::Simple**. **SORRY NO USING XML::SIMPLE IS A MORTAL SIN** use... eh I dunno... **XML::Twig**? **XML::LibXML**? Just don't use **XML::Simple**. Infact why are you using XML at all? Pls schtap `¯\_(ツ)_/¯` &gt; How do I parse them in Python? import csv, json, xml.etree.ElementTree Other modules for common tasks include **datetime** and **sqlite3**. * **Installing 3rd-party modules is straightforward** pip install modulename --user * **Libraries** **pandas**, **requests**, **scrapy**, **click**, **arrow**, **NumPy**, **SciPy**, **IPython**, ... * **The language** &gt; How do I count how many times an item occurs in an array? $ perl -le 'my @nums = (1, 2, 1, 1); print scalar grep { $_ == 1 } @nums' 3 $ python -c 'nums = [1, 2, 1, 1]; print nums.count(1)' 3 &gt; How do I test for substring existence? **Perl** if index('foobar', 'foo') != -1 if 'foobar' =~ /foo/ **Python** if 'foo' in 'foobar' &gt; How do I test if something exists in an array? **Perl** if (grep { $_ == 3 } @nums) { ...; break } use List::Util 'any'; if (any { $_ == 3 } @nums) { ... } **Python** if 3 in nums: &gt; How do I get the first index of an item in an array? **Perl** my @items = (1, 2, 'c', 'd'); my $where = (grep { $items[$_] eq 'c' } 0..$#items)[0]; **Python** items = [1, 2, 'c', 'd'] where = items.index('c') &gt; How do I process 2 arrays in parallel? **Perl** my @a = (1, 2, 3); my @b = (4, 5, 6); for my $i (0..$#a) { my $x = $a[$i]; my $y = $b[$i]; print "$x $y\n"; } **Perl again** # use List::SuperfuckincalifragilisticexpialidociousUtils ':all'; use List::MoreUtils qw&lt;natatime zip&gt;; my @a = (1, 2, 3); my @b = (4, 5, 6); my $it = natatime 2, zip @a, @b; while (my @vals = $it-&gt;()) { print "@vals\n" } **Python** a = [1, 2, 3] b = [4, 5, 6] for x, y in zip(a, b): print('{} {}'.format(x, y)) &gt; How do I process a file line-by-line? **Perl** my $filename = 'whatever'; open my $fh, '&lt;', $filename or die "$!\n"; while (&lt;$fh&gt;) { ... } close $fh; **Python** filename = 'whatever' with open(filename) as fh: for line in fh: ... &gt; How do I process a file all at once? **Perl** my $filename = 'whatever'; open my $fh, '&lt;', $filename or die "$!\n"; my $contents = do { local $/; &lt;$fh&gt; }; close $fh; **Perl again** use File::Slurp; ... **Actually wait no File::Slurp is broken!! use File::Slurp::Tiny!!** **Actually no wait again File::Slurp::Tiny is now broken too, use File::Slurpy::Super::Slurper!!!** die 'fml' **Python** filename = 'whatever' with open(filename) as fh: contents = fh.read() &gt; How do I create a function with default arguments? **Python** def foo(name='Bob', age): ... **Perl** sub foo { my @args = @_; die "Oh just fuck it I give up.\n" }
Readability also involves syntax. If you say syntax has no bearing on readability, have a look at brainfuck. Perl has more complicated syntax than Python, even the Perl community can agree on that. I think that is a factor in the current popularity of the Perl.
This is a good read on the topic by Eric S Raymond http://www.linuxjournal.com/article/3882
I think GP understands the *what* behind it, he was more ranting about the 'cuteness' of calling it 'bless.' Don't get me wrong, I love perl and I work in it every day, but there are a lot of aspects of perl that seem overly personal and underly professional.
If I can't easily set a breakpoint, especially in a dynamically typed language, I probably have to work too hard to be productive; especially during the learning curve. One could argue that this difficulty has its benefits, and I would agree; however, when such difficulties are mandatory, they manifest as product disadvantages instead of features suitable to a general purpose language (as Perl has positioned itself to be).
&gt; the loop is just nicely hidden Is it actually a simple loop though? By expressing intent rather than listing steps, the backend can do whatever it likes to zip those two lists.
The WOL criticism of Perl is a little unfair. *Every* language turns into WOL when it tries to do string manipulation. Perl was too powerful in this respect, and it was always the chosen one to perform the most difficult of parsing. Its power led to developers "quickly" writing these chunks of code .. bc you have to turn to this technique where API's are lacking. Also, re Python being more readable: I've find large Python project are actually quite *un*readable. All software suffers from this to some degree, but Python seems to get very ugly at some point. Well-written Perl kicks its butt in the readability stakes big time. Most people don't realize this bc they use Perl for quick and dirty work 
That is a good point. There's room to disagree, I think.
&gt; there are a lot of aspects of perl that seem overly personal and underly professional. Well, programming as a whole tends to be a bit childish in a fun sort of way...
Fair enough.
also `$DB::single=1` and then run your test harness under `perl -d`. Unfortunately there are a lot of people around stuck on ancient infrastrucutre (cough CGI.pm and mod_perl I'm looking at you) who are so used to the depauperate environment they don't give themselves the chance to look at better tooling :(. As with many things, perl's debug tools are insanely great ... the knowing where to look can be tricky.
My point here is that I haven't seen any serious incompatibility issues with Python point releases, so if the problems were between Python 2/3 then the appropriate comparison would be Perl 5/6. But, I'm not a huge Python programmer, I spend most of my time in Perl/JS/Cxx.
&gt; Actually wait no File::Slurp is broken!! use File::Slurp::Tiny!! Actually no wait again File::Slurp::Tiny is now broken too, use File::Slurpy::Super::Slurper!!! What about the python ecosystem prevents this from happening, too? In perl, I believe it has something to do with the policy (or absence of) for dealing with "abandoned" projects. edit: &gt; How do I create a function with default arguments? sub foo { my $name = shift || 'Bob'; my $age = shift; ... }
last time I used a hash slice "`@foo{key %$foo} = values %$foo`" I documented what the exotic syntax was doing. the one line of extra comment was much better than the alternatives. As an alleged "expert" I want to see documentation explaining the need for the hash slice, not just for the less familiar programmers coming after me, but also for my own poor little brain.
Your array manipulation is bogus. You should not be doing that in perl or python. 
Just fyi, CGI is an interface to web SERVERS not browsers
&gt; Debugging javascript through a browser is easier than debugging Perl. I've had different experiences. One of my pet projects is something of a game built on a mathematical puzzle. At first, I set out to build it entirely client side, and I pretty much did. And it was pretty cool up until the random bugs started showing up. Bear in mind, this thing was using 100s of interconnected dom elements, and the bugs weren't showing up until after several dozen clicks. My attempts to debug it trying to keep track of the state of those 100s of dom elements one click at a time proved futile. At that point I said screw it, I'm just going to rewrite in Perl, tie it to some jQuery and try to keep the overhead low.
How do you find PAR and perl packager ? Ive never had an issue bundling up an exe for win32.
Fair enough.
The only criticism i have really is cpan does need a cleanup. A community effort to flag modules as obsolete and point to the newer better modules is a good option. But the reason cpan needs a cleanup is because it is so vast and offers a stupendous amount of libraries for every conceived scenario a programmer ever had. I have a gut feeling this will be a big advantage of perl6. Relevant libraries will be ported and dormant / redundant onces naturally will not. For all the claims of people stating perl6 is not perl, i dont see it myself. I see it as an overhauled perl5 with all the modern fixes we have been wanting at the cost of removing backwards compatibility for some of the more esoteric quirks of perl5. So currently we are in a transitional state which always sucks but hey, better days are ahead of us. Regarding messy code.... this happens when a learner with no discipline develops instead of an experienced coder. All the people crying about how messy X perl codebase is are usually working on a project that was developed under a tiny budget with no room for anything but meeting deadlines and feature requirements. Perls low barrier to entry coupled with its vast librarys and excellent crossplatform support results in a lot of code that is 'write only' simply because of the environment it was developed in.
I used to write a lot of perl and quite liked AnyEvent and Coro (by Satan himself as pointed out in another thread) One big difference is that python tends to have a core way to do things rather than relying on a moudle. This leads to fewer problems like those currently occupying Coro/core. Although twisted is external to python, yield and iterators are core and a pretty good multiprocessing framework is included. No need to determine the political relationship between the author and core. 
Perl's repl is built in. Just debug an empty program: perl -de0 For best results, make sure readline support is configured for the debugger.
That particular example of default parameters does probably not work as intended, it looks like `$name` is optional and will be assigned 'Bob' unless specified, while `$age` is mandatory. In reality though what happens is: `foo('Arthur', 42) → $name = 'Arthur', $age = 42` `foo('Arthur') → $name = 'Arthur', $age = undef` `foo(42) → $name = 42, $age = undef` *...uh* `foo() → $name = 'Bob', $age = undef` Bob has no age, Bob is *eternal*... Partially this behaviour aligns with a lot of other languages, where mandatory parameters have to be specified before optional ones. Additionally, you probably want `//` rather than `||` in this case, since the former checks for definedness rather than truth. If you really want to mix things up you could do something like: sub bar { my ($mandatory1, $mandatory2, %optional) = @_; print "mandatory1 = '$mandatory1'\n"; print "mandatory2 = '$mandatory2'\n"; for (keys %optional) { print "optional: $_ -&gt; $optional{$_}\n"; } } bar(42,64,name=&gt;'Ford',age=&gt;'dunno'); 
That is the current Python equivalent of the WOL problem. Because Python is designed to be easy to pick up, but testing, architecture, and design remain hard, there are a ton of non-fixed libraries out there. CPAN is no longer more comprehensive than the Python repositories, but the testing infrastructure more or less ensures that most things will work right.
Got to agree with this. Look at what's happening with Elixir right now, lots of developers looking at the Phoenix framework, seeing Elixirs potential for high-performance, massively parallel computing, and they're adopting it based on that killer-app. As you mentioned, same goes for Ruby/Rails, Swift/iOS and JS/Browser. If your language has at least one clear use case where it's obviously better than the competition then chances are strong for it to get adopted and sustain a community. Perl? Not so much. I like it personally, but there's no one killer app, no particular library which blows the competition out of the water. And so usage is dropping over time.
Seems to me like Lua is now the go to language for embedding.
Speaking of CGI.pm, what is the proper replacement for it? I really don't need anything more than parse GET/POST data.
Actually, not much new stuff in bioinformatics uses Perl any more. These days it's mostly Python or R. 
I've read some of esr's Perl code. He somehow manages to write C-like code in Perl. :-)
As far as scripting, you do see more Python than before, but Perl is still heavily used. Much of the new stuff people ubiquitously use today is written in C or C++, and if I had to bet, i'd guess in the future you'll seen more go.
I have a somewhat similar experience – in my last project I got tempted by all the hype around React and tried to do a lot of the app in JS/React. I do like React (JSX) but ended up moving logic from JS to a Perl backend in frustration – simply to get the robustness, devel speed and ease of testing Perl offers. 
That is impossible to read on mobile
[Here you go](https://www.reddit.com/r/perl/comments/3vnsiw/suspending_efforts_on_my_riba2016_crowdfunding/)
http://imgur.com/XSFQpv4 for me
It looks like you are using chrome on android and have selected the non-default option "request desktop site". Unselect this. I've tried it in standard browsers on IOS and Android and it looks fine.
Because it's a fun language to code in. I still write in Perl, even when outside of it's niche usecase. There's no practical reason to it, except that I just love the language.
&gt; my $filename = 'whatever'; &gt; with open($filename) -&gt; $fh { &gt; while $fh.get -&gt; $line { &gt; .... The read-by-lines is much easier in P6 than your example, as IO::Handle has a .lines method that returns a lazy list: for 'whatever'.IO.lines -&gt; $line { ....
It depends very much on what you do. A lot of the sort of thing I have to deal with contain sample implementations and libraries in technologies such as Java and .NET. I'm not using Microsoft technologies anywhere so Java is a very strong choice. Secondly, on Linux you'd typically never install the Oracle JDK but the openjdk, so Ask toolbar or every other client-side ailment is completely irrelevant.
Before you had PHP... before you had python, rails, javascript... Before you had Apache, Mosaic, or Gecko... There was perl. While there may be a large communal dream where perl suddenly becomes a myth rather than ubiquitous, that will remain a dream for at least the foreseeable future. I can't disagree with the replacement of some rather old tools which are losing out to the otherwise more powerful... but it also stands strong in others. The reason is the same as the answer to the question "Why learn more than one language?" If you are actually confronted with that opportunity, or, if you've suddenly observed value in another language for a very particular *thing*... Some languages specialize very well on specific things. Some might regex better than others. Some may handle strings, some may be better at arithmetic, some may handle floating point ops better... some may factor, some may be more secure. The truth is, Perl was written in a time where *some* needs were *weighted* greater than *others* and therefore *tends* to excel at those functions. Couple that with the example it has set as being one of the first instances of ubiquitous deployment amongst systems and it's easy to see why Perl was used to write almost every utility in linux that wasn't written directly in C/C++ (or TCL). Besides, I kind of see Perl in the same way I see C... something of a, badge of honor? Trial of skill? If you say you know perl, and you get through the questions, I don't know that I really care if you've even heard of whatever cockamamie language we've written some silly app in, I'm sure you can do it.
I am a very bad programmer - and it is not my job... I reuse other people's code, often without fully understanding how it works... Whenever I have an idea for something, it turns out that there are at least two or three libraries on CPAN that do it. Also, I often attack a problem using long multiple-pipe command in Bash scripts that fast become slow and undebuggable... So I use Perl instead and development of ad-hoc tools is much saner... Funnily, is seems that Perl was born by people following that same path - so I guess I'm on the right path for myself ! It may not be fashionable but I'm a happy Perl newbie in 2016 ! I have been a Perl script kiddie for two decades now... I still love not knowing what I'm doing and having fun at it ! Well... Not sure I'm the best product advocate for Perl - but those are my reasons !
Very interesting read. I foolishly tried to follow the hyperlinks just to be reminded of the fact that this article is nearly 20 years old :P
Thats a very pessimistic view of scientific discovery. No perhaps we will never be able to predict the exact nature of a being via its decoded genome but we have gained tons of very useful knowledge from the study of human genomes. Risk factor analysis for certain cancers for one. I also know of researchers who sequence cancer genes and make pattern matching algorithms so they can detect that gene quickly; that way when they are cutting that cancer out of you, they can quickly determine how deep to cut to remove all cancerous tissue. Sounds like something we shouldn't have wasted money on though.
Which parts are bogus and what's bogus about them?
&gt; Java programmers look for employers that let them do things right, and they can, because they're in demand and have a degree (generally). Another reason: there are a lot more Java jobs, so there are more employers who do things well (not as a percentage of the whole, just numerically 100/250 doing this well is greater than 10/25) and a lot more opportunities for good Java developers to be picky.
Lincoln Stein is also a thoroughly nice guy. For such an enormous fish in bioinformatics, he carries his reputation and achievements extremely lightly.
(NOTE: I haven't looked into Perl 6, and used Perl 5 for a short while before deciding I hate it. This comment is purely based on P5) Its syntax is ungodly, first of all. &gt;You can literarily do anything with it; stuff you shouldn't really be able to do... There is a good reason you shouldn't be able to do that stuff. &gt;Why isn't Perl favored as a scripting language? Why is Python more attractive and popular? I know only a bit of Python- but I feel that Perl is just so much more powerful &amp; has tons of more options... I don't know about Python, but I've found that the Ruby libraries and gems are much larger in quantity, smaller in dependencies, and better in quality. Many of the popular Perl CPAN modules are broken, or have so many dependencies that they break without anyone even realizing. Additionally, writing scripts is much easier in Ruby and Python because of their very basic syntax and predictability in their code. I've found myself writing code that works the first time much more frequently in Ruby than I did with Perl. &gt;Why isn't Perl CGI favored in web development? Why is PHP more favored?... Perl can do what PHP does, and infinitely much more. By "much more" do you mean you can sacrifice an entire database with Perl? Yeah... Okay then. &gt;I'm genuinely curious. I'm not trying to prove anything, I'm just curious why Perl isn't as popular as other languages - when it does tons more... It really doesn't do more than other languages. Most mainstream commercially used languages can do just as much as the next guy: Perl, Java, Ruby, Python, PHP, etc. &gt;I just don't understand why Colleges and Job's are all about Python, Ruby, PHP etc... Perl is dying, and Perl 5 is horrible. Python, Ruby, and PHP are much more stable and widely used, therefore colleges teach them. It'd be like teaching Ruby for game development instead of Java or C++; Ruby just isn't ready for that yet.
There are a few minor things that Perl 5 is better for than Perl 6, of those I have needed precisely zero in the last 5 or more years. Everything else Perl 6 is just as good, if not better than Perl 5. The main reasons I would choose Perl 5 over Perl 6 for a new codebase currently is speed, ease of deployment, and CPAN (that is getting to be less of a problem). Whenever I am writing Perl 5 code, the Perl 6 equivalent often pops into my head, and I generally think that it is clearer. I really like both languages, and I get annoyed when anyone dismisses either language without actually learning them. For simple administration stuff there are MAIN subs which make it easy to create command line programs. There are so many useful additions that even just a list of them could be a large blog post.
What's the name of your company? Is it public? Sounds like a good short sale target. That's a nice list of diseases that, like cystic fibrosis and sickle cell anemia, were reasonably well understood thirty years ago. We're talking about the idea that sequencing an undiagnosed person would allow you to make useful predictions. It simply hasn't worked, and despite your emotional energy you've done nothing to dispel.
:S glhf
Got me interested so I decide to take a look at the oldest versions I could find of the links, the waldo.wi.mit.edu downloads work! [http://www.tpj.com](https://web.archive.org/web/19970414004739/http://tpj.com/) - 1997 [http://stein.cshl.org](https://web.archive.org/web/19981212021252/http://stein.cshl.org/) - 1998 [http://waldo.wi.mit.edu/ftp/distribution/software/rhmapper](https://web.archive.org/web/19980114172147/http://waldo.wi.mit.edu/ftp/distribution/software/rhmapper/) - 1998 
It is clear that you know very little about genomics.
Quoting from http://search.cpan.org/~stevan/perl/pod/perl5234delta.pod &gt; my $_ was introduced in Perl 5.10, and subsequently caused much confusion with no obvious solution. In Perl 5.18.0, it was made experimental on the theory that it would either be removed or redesigned in a less confusing (but backward-incompatible) way. Over the following years, no alternatives were proposed. The feature has now been removed and will fail to compile. Well..
The change is not the removal _of `$_`_ but about the removal of _lexical `$_`_, i.e. `my $_`: https://metacpan.org/pod/distribution/perl/pod/perl5100delta.pod#Lexical-_ is where it was introduced (5.10.0)
Ah, totally misread that there. Thanks
Could someone elaborate what the relation of Rakudo and Rakudo Star is? I used rakudobrew and installed Perl 6 via `build moar`. Do I have Rakudo Star now?
Ok. So it's Rakudo with "batteries included"?
Yup I think it even literally says that somewhere on the Rakudo site :3
very welcomed
Pretty much what brazen_nippers said. From what I hear, I'd also add web stuff, although I never did it personally.
No you’re not mistaken. After all, the protection of lexical `$_` comes from the fact that it’s lexical; using another lexical variable offers the same protection. It just doesn’t offer the same convenience, which occasionally would be nice… but eh. More to the point though, `map`, `grep` and the statement modifier form of `foreach` don’t *let* you choose something other than `$_` for their iterator variable – and so that is where the issue most often bites. (I.e. a `map` or `grep` over a function which somewhere down the call stack causes a modification of `$_` that someone forgot to protect.) This aspect of those constructs (that they’re hardwired to `$_`) is basically why the whole idea came up, and at the same time, those very same constructs are the reason that the idea was a failure…
Ahhh, I see. I forget about foreach using the $_ since I code around it when I need to change scope.
When will be the unsigned integer bug solved?
What's your opinion of the always-lexical `$_` in Perl 6?
&gt; When reading shit code, it's generally immediately ovbious when you're reading shit perl code. Shitty python is less easy to spot until later on :P. Perhaps perl is more prone to false positives, while python is more prone to false negatives. 
There were many CPAN tests that broke with the 5.18 release. Almost all of them were actually already broken, they just muddled by because small hashes always gave the same random order of the keys every time they ran. There was code that kicked in when hashes went over a certain size that rehashed them with a hashing function that randomized things, so they were already broken. (see perlsec) With 5.18 the hashing was switched with one that was always randomized. Even people who arguably knew what they were doing were caught with this change. ( If you actually look into it, it is obvious this should have been done much earlier )
It is better suited for it because of it's simplicity, which makes it easier to optimize, and quicker to parse. The game Factorio is almost entirely written in Lua, and it stays fairly performant given its complexity. There is also a large modding community around it. As far as I know that community doesn't have the same interoperability problems that the Minecraft modding community has. (Minecraft is made in Java) I have also heard that a part of ZFS that either already uses Lua, or will use it for combining multiple operations into a single atomic operation (as far as the rest of the operating system is concerned anyway).
Thanks.
I recommend Dancer2
I also like Dancer2. A simple tutorial: http://perlmaven.com/hello-world-with-dancer2
Aside from the typo it is valid perl. @foo{keys %$foo} = values %$foo The left side is a hash slice. Specifically, the hash %foo with keys given by the hashref $foo is assigned the corresponding values of the hashref $foo. I guess this might be used to merge two hashes. Another way to write it would be (and I changed the name of %foo to %hash and $foo to $hashref to make it less confusing): $hash{$_} = $hashref-&gt;{$_} for keys %$hashref;
Free shipping coupon until Feb 3rd: http://www.spreadshirt.com/spreadshirt-coupons-C3627
&gt; @mac = map { hex("0x".$_) } split(':', $TargetMac); This will convert a MAC address stored as a string in $TargetMac, e.g. "DB:8F:98:9F:DC:62", in a list of integers stored as an array in @mac, e.g. (219,143,152,159,220,98). I hope that's useful! In return, I'd be curious to see how you created an UDP server in Javascript.
try out nodejs it will blow your mind at the ease at which you can develop stuff. 
also I dont get those data types :/ arff
In the last example, he loops through them all after all, saying you can do that "if you want to write a lot of code." I disagree. my $max = 0; for my $key(keys(%{$test})) { $max = $key if (!$test-&gt;{$max} || ($test-&gt;{$key} &gt; $test-&gt;{$max})); } print "$max\n"; I am glad that he makes the point early on that, essentially, "Something does have to loop through the entire hash, since the hash itself doesn't maintain a max value. The question is whether _you_ have to write the loop code or not.
Careful with the keys there. What if a key that happens to be false also happens to have the maximum value? That's why we have defined(). ;) 
Thanks for this awesome plugin! 
This feature list is very impressive, great work!
This looks like a reasonable article answering your question http://www.perl.com/pub/2005/06/16/iterators.html
/u/srvsh hits most of it. In Perl 5, iterators aren't really a "thing". In other languages where interfaces are more pronounced, it makes much more sense. I was in the same boat as you. I never really understood a lot of HOP until I used a different programming language. Looking back, I think the idea of HOP is admirable, but with my personal experience, I didn't gain a lot of insight. Or at least not the same insight I gained by executing on its ideas outside of Perl. An iterator isn't about savings; it's about the interface. Again, this concept of interfaces, not so prominent in Perl 5 (short of Moose or convention).
It's useful when the data is going to potentially expand memory quite a bit when it's loaded. Consider a database system where we make a query and then get an iterator back: my $iter = query( 'SELECT * from TABLE' ); while( my $row = $iter-&gt;() ) { print @$row; } Behind the scenes, the call to `query()` did not need to fetch the complete result set at once and keep it in memory. It can call `$sth-&gt;fetchrow_array` within the iterator, allowing it to keep memory use down to a single row at a time. This gets even more dramatic if the iterator is going to do calculations on the result, or bless the result into an object, or something else that would take up more time and memory.
&gt; HOP isn't recommending you use them for simple array access, but teaching you how to use them via simple example. This is less obvious than I would like to think. I hadn't thought about that before, and it probably explains a lot of bad code I've read through the years (in many languages). People using the examples, in real world situations, where they simply aren't needed, because that's how / where they learned to use them.
For a calling graph, you might consider running a profiler on your code and then running it through gprof2dot or something similar. The Devel::NYTProf profiler for perl is also really awesome. Dunno of doxygen options off the top of my head though
Are you able to run the code in a controlled environment? I have dealt with quite a few situations where it is either impossible to run code due to various reasons such as external dependencies being impossible to satisfy, intricate requirements to set up the scaffolding necessary etc. In those cases, it becomes necessary to resort to unconventional methods to try to deduce what happens in a program. It is hard to make general statements because the presence or absence of a module may change the meaning of a particular part of Perl code, but it is possible to glean enough understanding. Of course, if you can actually safely run the code in the intended way, do so. I all cases, I would recommend doing everything in a VM with no network connection lest the code reach out and touch a live system somwhere.
Beware, the call graph can be ginormous. Also note that NYTProf can output files for us in kcachegrind. http://kcachegrind.sourceforge.net/html/Home.html 
There aren't any yet but I'd expect them to appear in http://video.fosdem.org/2016/h2214/ 
I'll keep an eye out. Many from last year were never uploaded.
Typically you find the answers right in the documentation: http://search.cpan.org/dist/Pod-Usage/lib/Pod/Usage.pm#DESCRIPTION
I am amazed how readable that code is. Lovely, thanks!
Now it feels real.
Perl 6 isn't Perl, and there's no way in hell that I'll ever use it.
Not even if they change the logo?
What do you mean? Perl 6 abandons a lot of the things that make Perl worth using for me over other languages. 
You're right, and I'm reminded of a quote from myself: &gt;Perl 6 isn't Perl, and there's no way in hell that I'll ever use it.
perldoc perlpod
Thanks!
Good suggestion. Added. Thanks.
That's the expected behavior. Matches are non-overlapping. The first match spans from Abc to Bzz, so after that replacement is performed, the search resumes at Tad, and there are no matches to be found there. The replacement text is not considered for matching because it was part of the previous match, and matches are non-overlapping. All regex engines work this way, it's not just Perl. Whatever you're trying to do, there's probably a better way to do it. Try to explain the problem you're trying to solve, not how you think it needs to be solved. It looks like you're dealing with nested pairs of things, and regular expressions are notoriously bad for those kinds of problems. (They can be dragged kicking and screaming into service, but it's not pretty.) 
It's OK if you don't want to use it, but taking a big dump in an announcement thread is rather obnoxious. This is a major milestone accomplishment for the Rakudo team.
This is a Perl subreddit and this is about a completely different language.
It's more of an accumulation of different things. First off, I really don't like object orientation in general, and Perl 6 is essentially an OO language. I also really like how sigils are used in Perl 5, and the fact that Perl 6 is changing that is a deal breaker. At this point, there is basically no reason to even have sigils in Perl 6, because their only function no longer exists. Other things are the changing of seemingly every single operator for no apparent reason, or the mandate of where and how to use whitespace. In essence, I don't like Perl 6 because it's a kludgy attempt to make a language like Python or Ruby that just looks like Perl on the surface.
&gt; t's a kludgy attempt LOL that's funny. I believe they took a long time to do a well thought out language. There is nothing about Perl 6 that makes you program in an OO manner. It makes it easier (and nicer) to do so but you aren't forced to. 
&gt; Can I find a job using Perl? Yes. Go to any Perl conference near you (YAPC, YAPC::EU, or one of the more regional/national Perl Workshops), you'll find lots of companies looking for Perl developers. There's also https://jobs.perl.org/ &gt; Will I be stuck there if I do? No. In my experience, few jobs are "pure" Perl jobs. You use lots of other technologies, and often also other programming languages. You can slowly drift into other technology stacks, or apply elsewhere; the experience with all those technologies often matters as much as the primary language, sometimes more.
&gt; essentially removing whatever matched for B\w+ So you don't want ligne starting with **B** ? Try this : perl -i.bak -la -ne 'print $F[0] if $F[0] !~ /\^B/' YourFile
My $work is currently looking for a build engineer with Perl chops: https://www.maxmind.com/en/careers See "Junior-level GeoIP Release Engineer". There are jobs out there where you'll code a lot of Perl, but you'll likely (hopefully) get to learn and apply other languages as well.
Definitely don't limit yourself to just one language. Learning more languages will expand the way you think so that you can have the same sort of freedom in other languages (although there's no guarantee you'll get along well with *every* language, I don't think anyone does). That said, yes, there are Perl jobs out there, and there will be for quite some time, no matter what. Yes, you put yourself at a *little* bit of a risk of being pigeonholed, but 1. No one will hold what you do as a junior against you too much if you want to get into something else later, as long as you're skilled. 2. If you find another language you enjoy, and you work on personal projects, open-source projects, or work projects in that language, that will be plenty to open the door at an interview to showing that you're capable in that language. So basically my advice is, don't worry about it. The way to avoid getting railroaded is to always be learning, and that's part of being a good programmer anyway.
I edited my self post, take a look, it's not quite that simple.
Nobody thinks to mention Booking because they're advertising themselves a lot anyhow; and nobody thinks to mention ddg because they employ few people, for low rates, in a self-described "cowboy programming" environment.
Thanks for your response. Yes I agree with everything you mentioned, especially the part about constantly learning to be a good programmer. I will definitely try to contribute to some open source projects, or do my own projects!
From a quick glance, it seems [DBIish](https://github.com/perl6/DBIish) does support prepared statements. You should be using those rather than attempting to build the SQL query and ~ your data into it. Also, `//` is the defined-or operator and it is awesome. Instead of `%hash{$field}.defined ?? %hash{$field} !! 'NULL'` you can just say `%hash{$field} // 'NULL'` ... although I suspect `.execute` with a `.prepare`d statement will translate a Nil value to 'NULL' appropriately, so you shouldn't need to do that either.
Sad news. I am a paying subscriber of Perl Maven Pro. I like Perl Maven Pro, as it is focussed solely on Perl. Not Perl 6, Javascript or others. I really would not like it, if it would become diluted with other aspects, even if more popular or modern. Perl is so unique that deserves a focussed site like Perl Maven. Of course, the webmaster must do what brings more money. But, personally, no offense meant, I would cancel my subscription in case of merging with other sites, as that would mean dilution and diminishment of that Perl-only focus which is what I like, and why I pay $9/month.
[removed]
Yeah, I saw that shortly after posting the question. I'll have to figure out how to do this when preparing a multiple insert statement (it contains about 700-1000 inserts per transaction, and I'm joining them via `union all select`, which appears to be the only way of achieving multiple inserts in SQLite).
This is something we've known of a long time. I wrote about it for [Mastering Perl](http://www.masteringperl.org) in [The Storable Security Problem](http://www.masteringperl.org/2012/12/the-storable-security-problem/). In short, Storable trusts that the namespaces in the frozen data are safe to load. Since a user can edit that to be anything, they can force Storable to load any module they like.
Yeah, everything should be one line! Let me test this with some more data and get back to you. Edit: Given this input: @interface CKBalloonImageView : UIView { UIImage *_image; } @property (nonatomic, retain) UIImage *image; @property (nonatomic) Foo *other; @property Bar *theBar; - (UIEdgeInsets)alignmentRectInsets; - (id)image; - (void)setBounds:(CGRect)arg1; - (void)setFrame:(CGRect)arg1; - (void)setImage:(id)arg1; - (void)setOther:(id)asdf; - (void)foo; - (void)setTheBar:(id)adsf; - (CGSize)sizeThatFits:(CGSize)arg1; @end I get this output: @interface CKBalloonImageView : UIView { UIImage *_image; } @property (nonatomic, retain) UIImage *image; @property (nonatomic) Foo *other; @property Bar *theBar; - (UIEdgeInsets)alignmentRectInsets; - (id)image; - (void)setBounds:(CGRect)arg1; - (void)setFrame:(CGRect)arg1; - (void)foo; - (void)setTheBar:(id)adsf; - (CGSize)sizeThatFits:(CGSize)arg1; @end So it's missing that last property. Any idea why?
Yeah, it's a pretty interesting exploit but it relies on several WTF [are you doing!?] things to be available: 1) An old perl - doesn't seem to work on recent perls although could probably be made to do so quite trivially (?). 2) Trusting user input - if you're doing a round trip like this then sign the thing doing the round trip with a cryptographically secure mechanism and check incoming state data matches the signature *before* you do anything else with it. 3) Using Storable - specifically related to 2. 4) Using fatalsToBrowser in a live environment. - in fact, echoing *any* sort of warnings or errors like this back to the browser in a live environment is just asking for trouble. However, given how much old perl running on old perls there is out there on the net it wouldn't surprise me if this is exploitable on many a webserver. Update your perl! Stop using CGI.pm! Don't trust user input! Yadda yadda, and so on...
Perlapp from activestate ( http://www.activestate.com/perl-dev-kit ) has a cross compile capability and I believe you should be able to compile a windows executable from Linux. ( I haven't had a reason to use the cross compile feature, so don't know how well that works - but for windows exe on windows it's fine). 
Yeah when it finds the setter is lowercases it and checks if has been seen e.g `exists $prop{"\L$1"}` So with `- (void)setTheBar:(id)adsf;` it checks for `thebar` The problem is the property is `*theBar;` - I made the assumption they were all lowercase as per the initial example. The solution is to lowercase the property name when it is being stored: perl -nle '$prop{"\L$1"}++ if /^\@property .+?(\w+);$/; print unless /^- \(void\)set([^:]+)/ and exists $prop{"\L$1"}'
I would suggest breaking this down into a series of steps. That makes your problem much smaller (i.e., how do I accomplish step 1?)
i'm not quite understanding this part: split(/\s+/, $_); basically this is what i have to do and i'm still confused :( ... Try This: Use your editor of choice to implement the Perl program described below. Remember to begin all scripts with the following three lines: #!/usr/bin/perl use strict; use warnings If you need additional diagnostics to debug a problem, optionally include this line: use diagnostics; #optional, helps with debugging Write a program named parseBlastOutput.pl that: Reads in /scratch/SampleDataFiles/sampleBlastOutput.txt For each line, split the line on whitespace using this line of code right after chomp: my @blastFieldArray = split(); The percent identity (you'll learn more about this when we get to BLAST) will be at index 2 of @blastFieldArray. Save it in the variable $percentIdentity. If $percentIdentity is greater than 75, print the query ID, subject ID, and percent identity to a file named firstThreeBlastColumns.txt. As with percent identity you'll learn about these fields when we get to BLAST, but for now you just need to know that they will be in positions 0, 1, and 2 of @blastFieldArray.
and this is what i have so far: #!/usr/bin/perl use warnings; use strict; use diagnostics; my $blastOutputFile = '/scratch/SampleDataFiles/sampleBlastOutput.txt'; my $blastRewriteFile = 'blastRewrite.txt'; open (BLAST,"&lt;",$blastOutputFile) or die $!; while (&lt;BLAST&gt;){ chomp; my @blastFieldArray = split () ; 
I strongly urge you to read the modern perl book (free) http://modernperlbooks.com Or, if you don't mind paying $33, Learning Perl is a quick and easy way to get going with perl doing exactly what you need, explaining how it works and is fast and easy to learn from the book. O'Reilly sells DRM free ebooks you can download. http://shop.oreilly.com/product/0636920018452.do 
`Role::Tiny`'s docs do lack any mention of what happens when composition and inheritance are mixed. Composition wins over inheritance. I think of it like CSS, the "nearest" definition wins Class &gt; Role &gt; Superclass. This is how `Moose` has behaved since forever, and I believe it is documented there. It is also documented in the original paper on traits. It would not be amiss though for someone to add a one line patch to the beginning of the `Role::Tiny` docs stating this fact.
 split(/\s+/, $_); is the same as split(); When you did your **&lt;BLAST&gt;**, the next line got put into the special variable **$_**, which kinda means "a pronoun for the thing I'm working on." Either version of **split()** will break up the line using the regex **/\s/**, which means "split on any whitespace". Then your field array will have just the fields for that line. Your next step might be to operate on that array before getting the next line. It could look like this: for my $field (@blastFieldArray) { print ("Line $. field: $field\n"); } You might also want to index it by number, like **$blastFieldArray[0]** is the first element etc. As an aside, when you're doing code on reddit, put 4 blank spaces before every line so the formatter doesn't kill you.
Well if it's case-sensitive there would be no matches. image =&gt; setImage other =&gt; setOther theBar =&gt; setTheBar
Well you could just add another regex test to match those cases e.g. perl -nle '$prop{"\L$1"}++ if /^\@property .+?(\w+);$/; print unless /^- \(void\)set([^:]+)/ or /^- \([^)]+\)([^;]+);$/ and exists $prop{"\L$1"}' 
When educating people about Perl in 2016, Please: - use `my $fh` instead of `FH` in `open` and friends. - use 3-argument `open( my $fh, '&lt;', $path )` notation for open instead of 2-argument `open( my $fh, $path )` ( for security reasons ) - use examples involving `strict` and `warnings`, or at least, code that would be safe under those pragmas. We don't want to be teaching Perl style as it was back before Perl 5.6 ☺ ( which is turning 16 this year )
&lt;3
Yeah... It's been at least 5 years since I've done any real Perl work for production use.
Actually I've just noticed this is broken (due to operator precedence) - it deletes all setter lines. If you're using multiple patterns you'll need parens around them e.g. perl -nle '$prop{lc $1}++ if /^\@property .+?(\w+);$/; print unless (/^- \(void\)set([^:]+)/ or /^- \([^)]+\)([^;]+);$/) and exists $prop{lc $1}'
I think you're making life unnecessarily hard for yourself by trying to do this in a single regex. Perl isn't sed, you can use actual programming constructs if you need them :-) I'd try something like this: #!/usr/bin/perl -i.bak my %properties; while (&lt;&gt;) { if (/\@interface/) { # We're in a new interface; reset the set of properties. %properties = {}; } if (/\@property \w+ \*(\w+)/) { warn "Found property $1\n"; $properties{lc($1)}++; } unless (/\(void\)set(\w+)/ and $properties{lc($1)}) { print; } } For each interface we look at, we store the properties we find in the keys of a hash (this is a standard Perl idiom for representing sets, providing fast insertion, delete and lookup). Then if we encounter a setter corresponding to a property we've previously found, we don't print out that line. This assumes line-oriented input (each `@interface`, `@property` or setter declaration is on its own line). The `-i.bak` in the shebang line means "operate in-place on files, backing up the original versions as `$filename.bak`". Ideally, one should use a real parser rather than regexes for operating on tree-structured input like programming languages. But I can't immediately find an Objective-C parser on CPAN, and writing one yourself would probably be too much effort given what you're trying to do.
I guess I expected that attempting to consume a role which provided a method that already existed in the current class would fail noisily. Then again, I haven't tried that particular thing before.
I hope you keep these up, I'm definitely learning from them.
OK... yeah, thanks. I was wondering what I was missing. Presumably it was an accidental submission?
Or a defect, since the submitter is a bot :)
Being a little clever with zero width lookahead to emulate ucfirst: perl -0pe '1 while s/\@property[^;]*?(\w)(\w*)\s*;.*?\K^- \(void\)set(?=[A-Z])((?i)\1)\2\b[^;]*;//msg' Being more clever using (??{ code }) to convert ucfirst into a pattern: perl -0pe '1 while s/\@property[^;]*?(\w+)\s*;.*?\K^- \(void\)set(??{ ucfirst $1 })\b[^;]*;//msg'
It's quite annoying that `_perly_bot` still doesn't seem to look for something like `perl` tag or category of blog posts before submitting the blog posts here.
Nice [tt](https://metacpan.org/pod/App::tt) app
This is perfect ! I appreciate the write up I spent a few hours reading earlier today and couldn't crack which direction to head in . Thanks again 
No problem, hope this works well for you.
I so far really like the pinto option and its ability for different repositories i.e. testing, development, stable
Another way which I think is simpler is to use [OrePAN](https://metacpan.org/pod/orepan.pl). You just `mkdir DIRNAME` a directory, and start adding files with `orepan.pl --destination DIRNAME --inject FILEPATH --pause SOMEID`. The resulting `DIRNAME` is now a DarkPAN (a CPAN-like mirror). You can install modules from here using `cpanm --mirror DIRNAME`.
Honestly, for 90% of my jobs like this at work, I just include a version of the module that will work on all of our systems directly with the perl script in the working directory of the script. No reason to get overly complicated. This is only necessary for non-core modules anyway. I guess if you need to do this constantly than doing a more formal method wouldn't be a bad idea. You could also make a super simple repository of modules without needing anything special simply by making a directory somewhere on each system with the modules placed there (still means you have to distribute the module files to that directory somehow though), and then add a "use lib '&lt;directory&gt;'" line to all of your perl scripts you distribute. This at least prevents you from needing to use cpan, you can just copy the module files directly to each server if necessary.
It's a flag/setting for Perlapp that is probably used to warp the application as a Windows executable. http://docs.activestate.com/pdk/9.5/PerlApp.html#perlapp_top 
Hi Olaf, didn't realize you took over maintenance of OrePAN2. It's been a couple of years since I last tried OrePAN2. Last time I tried it, it tends to reindex very slowly for some reason. Perhaps now I should give it another go. What would you say are the benefits for user to switch to OrePAN2 if OrePAN already works for her?
Hi perlancar, To be honest, I haven't really looked at the original OrePAN, so I can't say what the benefits are. I just inherited an app that used OrePAN2 and had to get some changes in. :) OrePAN2 did have some real speed problems initially, but those have been largely addressed now, I think. https://github.com/tokuhirom/OrePAN2/issues/11
Doc updated. https://github.com/moose/Role-Tiny/pull/3
Can you post it to a gist or something? It's hard to say why it's failing without seeing the implementation. 
At a quick glance, it all looks reasonable. Assuming there's nothing wrong with the Perl installation on your Pi, I would start inserting lines before the subroutine calls into those subroutines to see where things are going wrong. 
Thanks for the suggestion. Found a couple things as I keep moving through, but it looks like this should ultimately get me through it.
And the recipe is here: https://github.com/rakudo/star/blob/master/tools/star/mac-dmg.pod There is a [package_darwin_dmg.pl] (https://github.com/rakudo/star/blob/master/ports/darwin_dmg/package_darwin_dmg.pl) script
I don't think a quick hack along the lines of "lets just assign it all back to the first person" is a good idea. I think github style organizations might be needed just to keep things working in the long run. One thing that should be noted is that CPAN was built when nobody had a distribution platform (ftp sunsite.unc.edu or it's equivalent doesn't count) Now we need less of a distribution platform and more of a meta database. So what if CPAN/PAUSE treated the SCM location as authoritative for both the source and the organization structure? That would require PAUSE to support OAuth with various places (bitbucket, gitlab, github), and some way in the META file to indicate a maintainer relationship (probably not possible with pure OAuth to do groups, but you could have a set of allowed usernames in the META file) Also, tangential to this: PAUSE needs a REST API. It's not a crucial thing, but cpan-upload and pause-cleanup scripts are kinda hackish with LWP or WWW::Mechanize.
Sorry I edited it straight away when I saw the mess.
 print "Processing file: @mkv_list[$j]\n"; Possible unintended interpolation of @mkv_list in string at foo.pl line 52. If you access an array element you have to write $ instead of @ my @mkv_list = ...; my $file = $mkv_list[$j]; print "Processing file: $file\n"; 
For `system("ffmpeg -i '$in_file' -c copy '$out_file'");`, you're using the 1-argument form of `system` that goes out to the shell; you're then running into problems because after you've interpolated your variables in there, the shell sees a line like ffmpeg -i 'you'll never encode this file.mkv' -c copy 'you'll never encode this file.mp4' which understandably doesn't have balanced quotes for bash to interpret. Instead, you want to use the [multiple-argument form of system](http://perldoc.perl.org/functions/system.html), which circumvents the shell to run `ffmpeg` directly:- system("ffmpeg", "-i", $in_file, "-c", "copy", $out_file); This way you can specify exactly what the arguments to ffpmeg are without having to go around shell quoting rules. 
Ok I have deleted the arrows and replaced with comments, as well as getting rid of the \*\*. It should be fine to copy and paste now. I'll work on fixing those errors, it looks like they are all the same thing (Global symbol requires explicit package name). Cheers
The functions of providing uniqueness and searchability the names in Perl 5 serve have been given to `:auth` adverb and `tags` META file key. So there's no reason to use ridiculously long and expressive names so common in Perl 5 land. 
I have better things to do with my life than look through your entire script. Next time please reduce it to the smallest possible case that still exhibits the error before posting. In doing so you'll probably solve the problem yourself anyway and learn something in the process.
I see your problem has been solved, but here's one more bit of hopefully useful constructive criticism of your code. Instead of writing C-style for loops to iterate over an array, like this: for ( my $j=0; $j &lt;= $#somearray; $j++ ) { do_something_with( $somearray[$j] ); } use the foreach loop, thus: # Does exactly the same! foreach my $item ( @somearray ) { do_something_with( $item ); } If you don't actually need the index (as you don't in many of the for loops in your code) this way of iterating over an array is much easier to read, and less prone to typos in your code. Also `system("rm '$in_file'");` is better written as `unlink($in_file);`.
Thanks mate. Always happy for some constructive criticism. I am very new to perl and still have a lot to learn.
I realise `for` &amp; `foreach` are synonyms in Perl, but I like to use `for` for C-style loops and `foreach` for item iteration, as above. Partially because I now mainly write C#, where `for` and `foreach` are definitely not synonyms, and partially because I think `foreach` in the latter context is more English-like, but also because I think that for beginners it's easier to remember if you have separate key words for separate constructs; `for` for counting, `foreach` for iteration. But yes, it's 4 characters less, and equally correct, to write: for my $item ( @some_array ) { ... } 
Okay I've been doing too much Perl, I spotted that as soon as I saw the first error message and went back to check line 21 (almost always if you get a ton of crazy errors the line referenced in the very first one contains a daft syntax error).
Not too much Perl. There should be a Perl critic policy that says something about assignment used in a place looking for a boolean value (I can't find one offhand). Perhaps even any assignment that is not a top level operation of the parse tree for that statement...
[String::ShellQuote](http://search.cpan.org/~rosch/String-ShellQuote-1.04/) is what you want. use String::ShellQuote; my $safefile=shell_quote( $file ); system( 'foo '.$safefile ); 
This reminds me, is there a way to apply the same logic as -E inside a script, yet? I want to be able to say: ($_=$])=~s/(?&lt;=\.)(\d{3})(\d+)/"use v"+($1+0).".".($2+0)/ee; $@ and die $@; But of course, that doesn't work because the use pragma is scoped to the eval. 
Why not just use this: use feature ':all'; EDIT: Also, if you want to just dynamically specify required version, without importing its features (which doesn't make any practical sense but is a nice exercise), you can do something like this: require eval "$^V"; 
wasn't there when I looked a while back. Thanks for the update! 
&gt; code golf HOW HAVE I NEVER HEARD THIS TERM?!?!! I'm kind of a weird programmer, so I've put really dense weird code in production before, think ugly template stuff that can't be written cleanly in under 100 lines. I totally play code golf: if it does one specific step or thing, it deserves to be one line, even if that involves five levels of brackets and parens. This enforces a powerful but simple rule: anyone modifying this line/step MUST read and understand the entire line/step, or replace it entirely.
Or go 6y: $ perl6 -e '.say for 1, 1, *+* ...^ * &gt; @*ARGS[0]' 21 1 1 2 3 5 8 13 21
Is it just a personal choice that he checks a reference type like: ref $somearrayref eq ref [], instead of ref $somearrayref eq 'ARRAY'?
I agree it is nice once in a while, perhaps initialization of a local is ok. Assignment to an existing is very easy to glance at and think it is some other operator (usually pattern matching or equality) with an equals sign. 
I can't think of any reason it would be better other than thinking that the string comparison may not be accurate for some reason in a future perl release but the data type would never change so comparing the actual return values may seem wiser than comparing a return value to a manually crafted string. Total speculation.
I've never used it but I think [this](https://metacpan.org/pod/Number::Spell) module fully implements the functionality provided by this script? Edit: Though [this](https://metacpan.org/pod/Lingua::EN::Numbers) looks better Edit2: There are many solutions on CPAN
Thanks!
This is great feedback!
What, no mention of https://metacpan.org/pod/indirect and the most convenient mechanism of pulling that in for dev time only, https://metacpan.org/pod/strictures ?
I haven't compared the two modules, but I think the Lingua:: namespace is better. There are modules in there to convert numbers to other languages. Hopefully you could just plug-in the new language module and get results in that language.
pos($dna1) is the index of the end of the match. $-[0] will produce the index of the beginning of the match. Looking for pattern1 = GA[ACTG]TC Pattern GA[ACTG]TC found GAGTC at residue 364 Looking for pattern1 = GA[ACTG]TC Pattern GA[ACTG]TC found GAATC at residue 379 Looking for pattern1 = GA[ACTG]TC Pattern GA[ACTG]TC found GAATC at residue 580 Looking for pattern2 = GCC[AT]GG Pattern GCC[AT]GG found GCCTGG at residue 888 By my count, GAATC does in fact begin at string index 379, so perl is doing what it should. To get the numbers you're looking for, you could do $-[0]+1: while($dna1 =~ /(GA[ACTG]TC)/g) { print("Looking for pattern1 = GA[ACTG]TC Pattern GA[ACTG]TC found ", $1, " at residue ", $-[0]+1, " \n"); } while($dna1 =~ /(GCC[AT]GG)/g) { print ("Looking for pattern2 = GCC[AT]GG Pattern GCC[AT]GG found ", $1," at residue ", $-[0]+1, " \n"); }
Ah. I was trying to figure this out myself. Weird that we have a function pos() for the end and a perlvar $- for the start.
There's also the perlvar @+ for the end of the match, so there is normal consistency. pos() is ... separate
The point of pos() is more to tell a tokenizer where it last left off rather than telling you where the match started.
&gt; So to show our gratitude, we’ll discount our normal fees by 40% to any Perl event that wants to run on TTE. It's great to give back like this.
My guess is that you're not matching the prompt. On the "errmode return" when it doesn't match a prompt it returns false but you're not checking for that. In die mode, when it doesn't match the prompt the script dies.
Five years ago I reviewed the modules on CPAN for doing this: http://neilb.org/reviews/spell-numbers.html As a result I adopted Lingua::EN::Numbers, so I could fix a couple of bugs. Overall I think it's still the best module for this task.
So am I understanding that the script should be expecting a return message (in this case, a success message is "200 ok") that I'm not checking for?
Thank you for this article. I have come to learn that Perl has been giving so much to the whole programming community at large, that every single aspect is worthy of careful study. Perl has influenced and it is still influencing so many other languages, and it will continue to do so for the foreseeable future. Some say Perl is dying, but I cannot agree with that, on the contrary. Professionally using other languages, including Common Lisp, it seems Perl is more similar in that respect to Common Lisp, where the deepest roots of Perl culture will guarantee a very healthy and wholesome longevity. Sure, if one is attracted by the latest gadget, let him go on his way and have fun with it. But when and where power and expressivity and flexibility matters, let one be rooted in Perl. Perl has some of its solid foundations in linguistics, where names do count. Based on that, I wish the Perl "Raptor" devs would perhaps consider adopting a version numbering like the Mozilla people did (when they jumped to a faster version numbering, around Firefox 8, like "Firefox 44.0.2"), or the Emacs developers did ("Emacs 25.0.91"). Let the "5" be dropped, and start using something like "Perl 22.1", "Perl 23.5", etc. As names are quite important, sometimes evolving one makes a difference. In any case, I am very much grateful to Perl. I do not think any other language can offer so much, even now. Not only as toolchain, but also as arsenal of powerful ideas and long-reaching design.
Minimal performance impact; doesn't need to parse code, but hooks into the actual "do an indirect call" logic itself; with strictures it's only activated at dev time; much faster than running a whole P::C suite thus instant feedback; you can combine it with P::C with no ill effects or downsides.
C and C++ compilers often warn about assignment in boolean context, and you can silence the warning by adding extra parenthesis. Personally, I'm not a fan of the extra parens, but it is possible to have a similar warning that allows similar code.
So, what was your rationale for adopting a module that you don't actually like and suggest people don't use? Why not let someone who actually uses it maintain it?
&gt; Why not let someone who actually uses it maintain it? I do use it. It's still present in some of the critical systems at my day job.
/r/shittyprogramming is that-a-way
I fail to see how is this notable. On one side, none of the people who install (buy?) VS2015 are doing it in order to get `perl` on their machines. On the other, machines with VS2015 are still an insignificant minority of all Windows machines; you can't count on `perl` being on Windows. If `perl` was "spreading to Windows" by being included into standard Windows installation, there would be something to talk about. EDIT: Hello Downvote brigade! Let me remind you the reddiquette: &gt; Think before you downvote and take a moment to ensure you're downvoting someone because they are not contributing to the community dialogue or discussion. If you simply take a moment to stop, think and examine your reasons for downvoting, rather than doing so out of an emotional reaction, you will ensure that your downvotes are given for good reasons.
So you replace it with "first install VS2015 from..."? Maybe I miss something but why should you be sending Perl scripts to non-perl developers who don't have Perl installed?
See [VS Community Editions](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx): &gt; Any individual developer can use Visual Studio Community to create their own free or paid apps.
So it's free. But so is Strawberry/ActiveState. What's so great about having a perl distribution in a system that people don't plan to use for perl in the first place?
Yeah activestate sucked. I'm not really defending them; I'm just saying perl in WSH made it accessible and useful to fiddle with -- much more so than something that happens to get installed alongside VS because an auxiliary utility has a dependence on it. In your scenario you have to convince people to install a specific version of VS-- it's not particularly different. 
I fail to see the benefit as well, and there's no need to claim that this is a bad or horrible thing, just pointing out the exaggerated enthusiasm. Perl is not "spreading to Windows" because of this. 
If you have an alternative, I'm all ears. The current code base is extremely old and CGI is used extensively throughout. I'm currently rewriting some of the old forms to make them more maintainable and it was my "learning project" to fix prior developer mistakes and learn Perl as I go. ( Coming from the outside, if you will. ) The current form has the ability to upload a bunch of files for a product and as far as I can tell, the `upload()` method accepts a single parameter to define the form field name that the file is coming in under. Unfortunately, The only snippet of documentation related to this method that I can find is [here](http://search.cpan.org/~leejo/CGI-4.26/lib/CGI.pod#Processing_a_file_upload_field) and [here](http://perldoc.perl.org/CGI.html#PROCESSING-A-FILE-UPLOAD-FIELD) which tell me how to use it, but doesn't explain what the parameter list is, nor what options I have (if any.)
Thanks. Will check it out.
Virtual hosting is pretty cheap these days, and far more capable. The one downside is doing your own sysadmin work.
In the past, I have changed `use CGI ':standard';` to `use CGI()`. If there are no string evals, `perl -c script.cgi` should help you locate where you need to look.
CGI is pretty bad. And I really don't recommend reading the source, it's horrible. If you're in a position to, it's fairly easy to make it saner by deploying over plack rather than straight CGI into web server. You get better deployment choices too. Here's a sample development server script I put together. https://gist.github.com/singingfish/4d2d031faa089d24620f Ideally you'd use that as a starting point to be able to use the much nicer Plack::Request and Plack::Response interface as you maintain your work.
His problem isn't a CGI issue even though CGI was mentioned. It's an issue with imports, but really it's an issue with documentation. It's hard to say where the problem could be resolved. It would be nice if the Exporter had a function that listed what variables and functions have been exported. Then you could say "require Module; Module-&gt;what_does_this_export();" Since there are multiple exporters I bet at least one of them has this. Since documenting each function isn't mandatory, you wouldn't be able to get a list of functions and their descriptions. If you could then it would be easier to say "please see the documentation for :standard"
CGI is still maintained bruh
This. I thought HTML generation was a bad idea even at the time I used this module in the early 2000s. use CGI (); my $q = CGI-&gt;new; ... and nothing else.
The module? I can remember a time when it was considered foolish *not* using CGI.pm.
Very nice. Thanks!
Hello, customer, we think you should spend $50,000 to update your web site. There won't be any change in what it does, we're just going to change the way it does it. Oh, and there's this bridge in Brooklyn you can have real cheap, as well.
Eh... You're doomed.
I don't even know where to start? Do you even know perl? If not, why are you trying to apply for a job that clearly wants you to prove that you know perl?
I've never heard of writing a resume in any programming language before, sounds like just a bunch of print statements. This is probably just a weed out stage to get rid of people who can't edit in plaintext and run a script from the command line. Start here http://perldoc.perl.org/perlintro.html They start almost right away with print statements. Just make a script to print each line of your resume.
Seriously? I think we can be a little more helpful. Let's start with a few links: http://search.cpan.org/~bobtfish/Text-Markdown-1.000031/lib/Text/Markdown.pm https://daringfireball.net/projects/markdown/ https://daringfireball.net/projects/markdown/syntax
Do you know if the resume should simply be written in Perl (kind of like a jokey thing) or actually generated (in some other format) using Perl? If the latter, do you know the expected format? Should it render from Markdown to something else or actually write Markdown?
It's obviously not a logical program...
https://application.adadevelopersacademy.org/ Step 2. Write resume in Markdown and submit on GitHub Gist. I downloaded Markdown already, but in order to read the pl file, I had to download Perl
Markdown is a document format. perl is not required, only a text editor. Step 2 on that web page links you to a web page that explains the format.
oh, it said on the markdown installation "Markdown requires Perl 5.6.0 or later. Welcome to the 21st Century. Markdown also requires the standard Perl library module" That's why I thought Perl was required.
Been programming in Perl since '95. Been reading this sub for 2 years. This sub is generally dead and I have since switched to Python. Suddenly, out of the blue, a beginner makes a post that generates the most activity this sub has seen in a while and we shoot her down with negativity? Really? I remember where I started and his confused I was.
You can use Markdown sandbox like [this one](http://daringfireball.net/projects/markdown/dingus) to write what you need on the web and see the result.
I'm just being foolishly pedantic, but in CV is in LaTeX, which is a programming language 🙂
1. Learn how to post code on Reddit please. 2. you've got an extra bracket here: if($introns =~ (/GT.*AG/) ^ but if you actually had the code above, then you should be getting "syntax error at &lt;your file path&gt; line 8, near ") {" and also I'm guessing you want to print, not `$introns` (your input string) but the *match* found in your input string, in which case you want if($introns =~ /(GT.*AG)/) { print $1; } and you should be very careful about that dot-star. It will capture the *longest* matching string, not the shortest. 
&gt; if($introns =~ (/GT.*AG/) Teach me :)
You've got an extra bracket, at the point where my little caret on the next line is pointing. Anyway I've updated my post a bit, you should reload maybe.
Disclaimer, I am new to perl and have no clue about the strings you will be inputting, but it might be better to find each index of GT and AG rather than using regex which I think does a left to right search then exits. I think the following code would suit your purposes: #!/usr/bin/perl use strict; use warnings; my $string = 'AATGGTTTCTCCCATCTCTCCATCGGACATAAAGTAATACAGAATGATCTAACGAAAATGGTAGCTCCCATCTCTCCATCGGCATAAAAATACAGAATGATCTAACGAA'; my $start_intron = 'GT'; my $end_intron = 'AG'; my $offset = 0; my @start_indexes; my @end_indexes; print "Intron string:\n$string\n"; for (1 .. length($string)) { print '-'; } print "\n"; # Find all GT indexes within string my $result = index($string, $start_intron, $offset); while ($result != -1) { push @start_indexes, $result; $offset = $result + 1; $result = index($string, $start_intron, $offset); } # Find all AG indexes within string $offset = 0; $result = index($string, $end_intron, $offset); while ($result != -1) { push @end_indexes, $result; $offset = $result + 1; $result = index($string, $end_intron, $offset); } foreach my $start_index (@start_indexes) { foreach my $end_index (@end_indexes) { if ($end_index &gt; $start_index) { print "Start index = $start_index\nEnd index = $end_index\n"; print substr($string,$start_index,$end_index+2-$start_index) . "\n"; } } } 
Put down the snake and come back to mother. This subredddit ain't head. It's been pretty active since the introduction of perl6.
Anyone have a path to Android perl? If I had perl on an Android phablet, I just might put my laptop on a shelf. But I can not find a reasonable way to Android perl. But I do not drive semi, and even if I did I would be too busy surfing and talking on my phablet. [edit no -&gt; on ]
[IPC::Open3](http://search.cpan.org/~shay/perl-5.22.1/ext/IPC-Open3/lib/IPC/Open3.pm).
It doesn't seem to me that IPC::System::Simple can capture both STDOUT and STDERR without using redirection. I think perhaps /u/tarje 's suggestion is easiest.
This is what you want probably. You shouldnt need to be concerned with soaces between parameters. You can open a stream to the file/command youre executing and pipe a blob of data or a JSON string right in through STDIN.. Open3 will give you separate stream handles for STDOUT/STDERR too which is why i use so often.
take a look at Proc::Reliable
It is interesting to see some apparently mature coders bashing Perl. So much insecurity, somehow revealing of a deeper love/hate relationship, and a secret envy. To me Perl is more than a programming language. It is real culture, a very nice community (the nicest!), a source of constant learning and professional growth, and a tremendous amount of fun. For that, thank you Perl, I love you.
It wasn't mentioned there, probably because it is still marked experimental, but Subroutine Signatures are in core now (since 5.20 release, I think). rjbs talks about them here: https://www.youtube.com/watch?v=D1LHFKGHceY&amp;t=38m53s He's fun to listen to.
Peer review wouldn't have helped in this case. From the wording of the guy introducing him they were completely on board with this shit.
Look into tie.
This is probably the best answer. Everyone should avoid rolling their own unless it's necessary.
It depends on the reviewer(s) they choose of course. In academia they would choose reviewer in the target subject area. Of course this isn't academia.
If it's your own code that is generating the global state hashref - it would be much better to just create an object to handle the data collection through object methods. However, TIEHASH is an alternative and fits your description to overload a built in variable type.
If you've not worked with tied variables before, you might find this PerlTricks.com [article](http://perltricks.com/article/magical-tied-scalars/) useful. (disclosure, I'm the site editor)
Thanks! Actually, after reading some of the responses, I found your article. It was very useful!
Okay, I should clarify. Some people use backticks: my $output = `ls -ltr`; It's quick and easy, but some would say it's dangerous and could affect performance. Since you've apparently ruled this out, I'm just wondering why. Where do your requirements come from? Are you trying to maximize performance in a long-running process, or ...?
I've read so often, one shouldn't use backticks, so I didn't. Capture tiny is a good solution. I've also tried IPC::System::Simple but it wasn't that simple since someone messed around with a function for error capturing and that did interfere somehow. Thanks again for all the help.
No, they're not. Here's a little example demonstrating it: C:\&gt;perl -le "$n = 100_000; @x = grep {$x&lt;$n} map {$x++} 1..$n; print $x; print 0+@x;" 100000 0 If any of the grep blocks had been executed before the last map block, then at least some elements would have made it into @x, but none did.
They're all separate operations that loop over their entire input and place their entire output on the stack before returning.
Oh... that looks like it will work for me. Thanks!
FWIW In Perl 6, map and grep are lazy. But join produces a string, and strings are always eager, so there's no way that join can be lazy.
Download Strawberry portable. Extract. Install module(s). Copy entire directory over.
You might find my [article on tied hashes](http://perlhacks.com/articles/perl-com/changing-hash-behaviour-with-tie/) to be useful.
thanks!!
PerlMonks is a good place, and I have found very useful and constructive critique right here on /r/perl. I consider myself an absolute beginner, I must say the Perl community is super excellent.
Have you tried /r/perl on Reddit? :)
I would agree out of the languages I have worked with in the past the perfect community has been the most receptive. 
Haha I have posted here when I had issues and got amazing help. I wasn't sure if it was okay just to post code for general critique. 
I will have to hop on this thanks 
I don't know how much traffic it gets but there is a site that is related to StackOverflow where code review is on topic: http://codereview.stackexchange.com/, you could probably then link it here.
Yeah, some do. I don't know if it's The Right Place or not, but I have seen it done.
Hi David! Original CpanParty Idea is explained at this post - http://blogs.perl.org/users/melezhik/2016/02/3part---cpan-modules-third-party-testing.html feel free to ask me further details ( by email or other ways ) regards Alexey
While there are various 'sets' of rules you can use with perlcritic, it is based on Damian Conway's Perl Best Practices. Unfortunately, best practices have changed in the past 10 years, and he had some personal idiosyncracies. If you read the documentation, you can set up your config file to ignore certain rules, or modify others. But perlcritic will tell you to use meaningfully named constants rather than hard-coded values, but it won't tell you how to make your code clear and understandable, let alone idiomatically Perlish, rather than Java written in Perl. 
How often do you actually need that degree of precision? Considering Math::Decimal128 is 6 weeks old, not many people are using it, I imagine.
Supposedly, Decimal128 (in general) is popular in finance, as it can represent fractional currency units exactly. 
Feel free to post it here also - I'm sure you'll get some replies.
To me Perl is not just a language but also a "culture" (see for example Larry Wall's article in "Games, Diversions &amp; Perl Culture", but the whole book is very nice). Perhaps that is not easy to say for many other languages, as they may be still younger. Because also of that culture, Perl will possibly embrace a very long longevity status. Maybe it won't be as popular as the latest fashionable kid on the block, but it will be used by discerning coders that, even in the future, will value the extreme power of a "synthetic" language like Perl.
&gt; a real culture A culture of what, exactly? &gt; That can't be said for many other languages. This is awfully myopic.
Thanks, I'll look into it. I never saw the readonly message, but I haven't really started good enough tests yet. 
As far as the individual criticisms of modules go, attacking Mark Lehmann's development practices and inability to work with others is totally ligit. Refusing to work with p5p on Coro has real consequences in terms of future-proofing your code. Deliberately breaking AnyEvent when a certain module is loaded has already had real consequences for people using that system. When I first saw the attack on Lehmann in the AnyEvent review, I passed it off as a personality conflict that didn't involve me. Now I agree with it wholeheartedly. I'm working towards removing or limiting the use of his modules for both work and home projects. A smart person can be a powerful force. A smart person *who knows how to work with other smart people* is unstoppable. That said, should cpanratings be kept around just because the negative Lehmann reviews happen to have a point? I don't think so.
Maybe people huge amounts of cash might be interested in Decimal128, but they generally aren't using Perl. I work in finance, with stock market data. We store data in ordinary databases, Sybase, Oracle, etc, using integer or floating point types. If you need to deal with huge numbers, there's also BigInt.
As far as I can understand, this behavior was introduced more recently. And, I am not 100% certain it is actually the *best* possible trade-off. It is the chosen trade-off, and I accept that I have to live with it, but I am not sure it is the best. Also, I started using DOS in the late 80s, and the search order for executables has evolved since then. See also [Order of Precedence in Locating Executable Files][1] and [The Windows NT Command Shell][2]. The situation is made more interesting by the fact that having `test.exe` and `test.bat` or any other executable extension doesn't seem to have the same effect. [1]: https://support.microsoft.com/en-us/kb/35284 [2]: https://technet.microsoft.com/en-us/library/cc723564.aspx
I am an avid Emacs user. This is an old module (2001), but I could not believe my eyes when I saw Perl can be so deep in the Emacs eco-system. This module allows Perl code to call functions and access variables of Lisp. Perl will never cease to amaze.
My favorite big integer is: perl -MMath::BigInt=lib,GMP -le '$x =Math::BigInt-&gt;new(6); print $x**$x**$x'
MST ran into the AnyEvent behavior that dies if IO::Async::Loop::Event is loaded: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=706453 Lehmann also doesn't like rt.cpan.org. I get that not everybody is going to like rt.cpan.org, but you can make it go away on search.cpan.org with a simple config change to the META of the module. When this is pointed out to him, he [starts calling the messenger an asshole](https://rt.cpan.org/Public/Bug/Display.html?id=72637). JSON::XS does not handle NaN/Inf/-Inf values correctly; these are not valid JSON numbers. Encoders should output them as null. The decoder portion of JSON::XS does not accept them (correctly), which means round-tripping is broken (that is, `decode( encode( NaN ) )`). This has been a bug for a long time, and it's fixed in the Cpanel::JSON::XS fork along with quite a few other pesky, longstanding bugs. Coro relied on some internal perl interfaces that were not promised to stay the same, and didn't stay the same in 5.22. Now, considering what Coro does, it probably does need to rely on these things more than the average module, but the solution is to work with the p5p developers to make that happen. Instead, he complains, forks off "stableperl" and sits in the corner with a frowny face. Which is a shame, because perl could use a better multiprocessing system than `fork()` and its shitty excuse for threads. See https://www.reddit.com/r/perl/comments/38wgsl/mlehmann_forks_perl_creates_stableperl/ for more details.
Probably best to make a gist? http://gist.github.com You can add multiple files into a single gist.
Neigh.
"tainting hash keys involves a huge performance penalty" is actually wrong. It was trivial to implement in cperl and involves no penalty at all. It rather closes another taint-bypassing security hole, from which now only /^(.*)$/ is left.
Since this is very new almost nobody uses it. Perl users which traditionally need high or full precision usually use bigint/bigfloat/bigrat, which is in core forever, and has some high performance backends (e.g. GMP). perl6 supports arbitrary precision (i.e. auto bigint/bigfloat) out of the box, as common lisp.
"Perl #125833 (leading semicolons in require)." is about a 4 year old CVE for leading double-colons in require, for which a patch exists for 4 years, and some simplier patch is now finally applied. Which still does not fix the security problem btw. They still argue that's not security-relevant, but that's the usual upstream theatre denying the problems. Mixing up semi-colons with double-colons also does not help raising awareness. This was the original fix, never applied, and probably forgotten (as applied in cperl Sep 2015) commit 4083f85ac5b024f7485e5ab9bd1c0485dd887bba Author: Nicholas Clark &lt;nick@ccl4.org&gt; Date: Wed Jun 27 23:34:04 2012 +0200 Validate the module filename created for bareword require. Validate the generated filename after translation of '::' to '/' (and possible conversion from VMS to Unix format) to keep the code simpler. Reject empty module names, module names starting with '/' or '.' (ie absolute paths, hidden files, and '..'), and module names containing NUL bytes or '/.' (ie hidden files and '..'). Add a test for Perl_load_module(), and check that it now rejects module names which fall foul of the above rules. This fixes RT#776270 and CVE-2012-3878 module loading security weakness
I recently vowed to learn how to get work done within a windows environment, and having always sort of eyed PPT from a distance, I thought that might make a nice gap filler towards learning to use native Windows things. The PPT version of make relied on https://metacpan.org/pod/Make, which didn't build on Windows with the latest Strawberry perl until today. There are some additional tests that fail, mainly related to path issues, some of which I believe are all fixed in https://github.com/briandfoy/PerlPowerTools/pull/33. I have some additional changes that allow all tests to pass, but I wasn't clever enough yet to work out how to submit a second pull request that didn't also include the changes of the first PR.
I think reviewing authors is fair. Part of the module's usefulness depends on the willingness of the author to engage with users in a constructive way. Warning people away from toxic authors is very useful.
You're right, not all CCC members are on board of this. In this case i was referring specifically to the organizers of the conference, who have greenlighted this kind of thing 2 years in a row.
It may also be of interest the [Emacs interface to same Dash API docset](https://github.com/areina/helm-dash).
I do understand the issues involved. However, note that it is the underlying filesystem (I am not sure whether it matters if short-names are enabled or not) that prevents the co-existence of a directory called `install` and a file named `INSTALL` in the same place. You would not be able to create those in the same location with or without Cygwin. On the other hand, one does expect whatever one puts in to an archive file to come out unscathed. And, I am not trying to re-litigate the decision: Here is a behavior I would not have expected -- on the basis of which I erroneously filed a failing test report and a bug report against Perl's `File::Which`. Keep this in mind if you rely on `MinGW` or `Cygwin` based utilities in your `%PATH%` ... BTW, since this happened with the `tar` that came with `git` that is distributed by Microsoft alongside Visual Studio, I expect this will eventually bite other people as well.
Would this be useful in exploiting vulnerabilities? Seems kind of like a little Bobby tables type of thing
Handy for interpolating complex expressions.
All I need to do is pass the array @readArray by reference, change the first element, then return the array. It isn't working, please help.
Because your parameter isn't in `$_`, it's in `$_[0]`. 
Sorry for the horrible formatting. Look here for a better display. http://pastebin.com/ZgbpAkLR
Perl subroutine arguments live in the array named **@_** -- of which **$_[0]** is the first element.
Yes, certainly, @_ not @$ Sorry for really embarassing typos
`@_` is the array of parameters. To access a single element of that array you use `$_[0]`. `@$_` is the scalar variable`$_` dereferenced as an array, which isn't anything reasonable. Also, the final line of subroutine is kind of pointless. The idiomatic way to write what you mean in Perl is: sub passByReference { $_[0] = "changed\n"; } Here's a quick test program: sub passByReference { $_[0] = "changed\n"; } my @array = qw(1 2 3 4 5 6 7); passByReference(@array); use Data::Dumper; print Dumper(\@array);
If it's not linked from the search.cpan.org/MetaCPAN pages, it's unlikely that people will go out of their way to use RT. Sure, there will probably be someone who tries, but it's going to be a trickle. For most open source projects, maintainers are happy to get a decent bug report *at all*, and aren't going to be particularly bothered by the specific system. I also find it hypocritical for Lehmann to complain about it being "unethical" to have RT "forced" on him, while also having AnyEvent die if it's loaded alongside another module that he doesn't like.
Do you want to modify the original array, or do you want a copy of it? This is how I would do the former. You don't need to return anything because you're modifying the original array through the reference. sub pass_by_ref { my $arr_ref = shift; $arr_ref-&gt;[0] = "changed\n"; } my @arr = qw(1 2 3 4); pass_by_ref(\@arr); print "@arr"; 
Okay when I print $1 it's still the same. For "Encoded %s pictures" $1 is "150" and $2 is empty. For "( fps %s )" $1 is "fps 12" and $2 is "12". $num is always the same as $1. 
&gt; You need to get the result of the match using $1. That's not their issue. They are effectively using `$1` because they're assigning the result of evaluating `=~` in list context which results in a list of the contents of each capture group. &gt; You also need to not use a non clustering match, so don't put "?!" after the opening bracket. No, their use of `?:` is correct. The inner set of parentheses does not need to be a capture group, only the outer set. 
The expected result is that he only extracts the number. Which worked for one example but not the other. But with /u/Rhomboid's solution it's working as intended now. 
&gt; should i be escaping those too? That depends. Is it possible that they could contain metacharacters? Do you intend for those metacharacters to be active in such a case? 
What are metacharacters? They can potentially contain the same lines as the example I posted. So I guess they do contain metacharacters. 
A metacharacter is one that means something other than its literal value. For example, a period in a regular expression does not mean a period, but any character. If you want a literal period, you have to escape it.
Ah. Okay. Thank you very much. Then I'll have the escape them. 
Cool trick!
This will help me stop using chopsticks with my remote control?
😀
I've merged everything so send more changes if you have them.
I'd love to have the toolkit in CPAN. Especially if it did not depend on bindings to windows only binary libraries and would work well from anywhere perl can run. I would use it from solaris, linux and AIX myself.
Definitely. I've been using the Office365 Graph API from Perl scripts on my Linux servers a bit, but its limited with what can be done using confidential client OAuth2 flows. Having a CPANed module to do the Graph API would be great, especially as Microsoft staff have indicated to us that the RESTful Graph API is seen as the way of the future in Microsoft now. Just to be really Evil at the moment I'm also hacking on Exchange Web Services to Office 365 using SOAP::Lite. That's.... er, "interesting" (read: I may smash my screen with my forehead in the next couple of hours).
Cool. You fixed some of the things already, so I'll retest when I make it back home this weekend and have access to a windows box again.
IMHO it gives Perl users a more forgiving search interface: &gt; $ dasht 'arr y' perl &gt; Manipulating **Arrays of Array**s in Perl Perl guide &gt; TAP::Parser::Iterator::**Array** Perl module &gt; Tie::**Array** Perl module &gt; want**array** Perl func Compare with `perldoc`: &gt; $ perldoc array &gt; No documentation found for "array". &gt; &gt; $ perldoc Array &gt; No documentation found for "Array". &gt; &gt; $ perldoc -r array &gt; No documentation found for "array". &gt; &gt; $ perldoc -r Array &gt; &gt; finally, success! YMMV.
Interesting. I've never seen this before.
For once, an useful blog post!
Also see baby cart: https://metacpan.org/pod/distribution/perlsecret/lib/perlsecret.pod#Baby-cart
because you're only passing one argument, and you're accessing the second. &gt; $ARGV[0] is the first argument, not the program's command name itself
Or you can use `shift` to get the command line arguments. my $days_to_subtract = shift; I'd write your program something like this: #!/usr/bin/perl use strict; use warnings; use 5.010; use File::Basename; use Time::Piece; use Time::Seconds; my $me = basename $0; my $days = shift || die "Usage: $me days_to_subtract\n"; my $fmt = '%m/%d/%Y'; # Illogical middle-endian nonsense! my $then = localtime(time - $days * ONE_DAY); say $then-&gt;strftime($fmt);
You performed a hostile takeover of a module, about which you have no idea about, and which was actively being worked on. You didn't understand the problem in this pull request, which I was trying to fix. (haven broken it upstream, yes, but it should be at least fixed where it matters). You broke the API, you published this broken API without any need, and all B::Utils users have now to check for two cases when using the new parent. Before only one, and with my version it stayed of course the same. With my version, people have to change the name. They are fucked. You didn't even contact the maintainer, a friend of mine, who was busy with private problems this time. When being criticised you lied: The urgent need was a "critical doc fix", which was a typo in the pod. When being criticised you went to p5p to help you out, and they continued their lies on a technical level, so everybody now thinks that your are right. What a theatre. Thanksfully I don't have to care for those folks anymore, but lying is a bit worse than pure incompetence and arrogance. My core design decision was wrong, but at least I fixed it in the module, which everybody should use for backcompat. Now people cannot use it because you broke the API. You did the same before with Sub::Name, where I politely stayed out, but designed the needed features, and implemented it. You are still not able not maintain it, and it's still missing support for binary names for such a trivial module to get and set cv names. What about my fix for this? Letting it die might be your preferred solution, but it is not a solution. Despite of all your incompetence you aggressively take over dozens of modules, day in day out. But the biggest problem is the modules@ list, who just stole this module from the maintainer without any idea. I find it highly disrespectful, besides punishing all the users. 
That is easier, thanks :-)
I'm trying to write a daemon that will run on one of our Linux servers to create and update Unified Group calendars (this is for my University's timetabling, as the TPTB have decided to move from Google Apps for Education where the API just works to Office 365). The Graph API looked like it had everything I needed, but unfortunately the operations on Unified Group objects is limited when you're using the confidential client OAuth2 flow. If you try to retrieve calendar and event objects using the documented API calls and you've used confidential client OAuth2 flow, you just get a weird error that the SMTP address doesn't have a mailbox associated with it. The Unified Group is working OK with OWA, and indeed by hacking around to find the calendar ID I can use EWS SOAP calls to create events in the calendar (so there definitely is a calendar folder associated with it). I've raised the issue on Stack Overflow and a [Microsoft chap said it was a known issue that was on their roadmap to fix](http://stackoverflow.com/questions/34041517/create-groups-calendar-events-fails/34166268?noredirect=1#comment56117993_34166268) at some point. Unfortunately until they do Graph API is rather hobbled for backend servers such as mine that are interacting with Unified Groups without user intervention, which is a real shame.
I have for the life of me been having issues making this array work. Its supposed to go though a list of subs ripping the info provided from reddit. For some reason it only goes through the first sub then quits. Every external sub that's called from his script works fine as they re used throughout the site. I have a feeling its something with the OUTER: while (1) { but I'mnot to sure when it comes to outter's and so forth. Also, there is supposed to be another / in the line "@subReddits = qw/Sub1 Sub2 Sub3 Sub4 Sub5;" its written correctly in our code but when removing some things I must've removed the /
Thanks for your replay! The slimmed down contents of link_ripper are at http://pastebin.com/a4n1Sc8d There are several of the same thing looking for different domains. There is no exit or die statements in link_ripper only make use of the next statements. The scripts relies on the response from reddit to end the loop and or there was some code i left out that check for posts in the db already. After 10 in a row it exits. As for the random next, I think I put that there just for testing to see if i could get a different response.
Why do you need a separate file for a subroutine? Also, you're not reading anything into sub link_ripper. I'm assuming you want $url and $link_domain to actually contain something before the regexp check?
* Please learn to indent your code. Even if you're happy working with code that looks like this, it's polite to reformat it before asking other people to look at it. * Please add `use strict` and `use warning` to all of your Perl programs. * It's generally a good idea to load all of your modules at the top of your code. Having a load of `use` statements at line 50+ is just going to confuse you. * Having loaded CGI.pm, you can use `print CGI-&gt;new-&gt;header` to create the content-type header. You should really create a CGI object (`my $cgi = CGI-&gt;new;`) and then call the method on that (`print $cgi-&gt;header`) but as you're not using the CGI object anywhere else in your code, just creating a throwaway object is sufficient (but it makes me wonder why you even loaded the CGI module if you're not using it). * The definition of `@subReddits` on line 14 is missing a closing `/`. This may be at the heart of your problem, as (bizarrely) the code still compiles - so who knows what it's doing! * You haven't needed to use ampersands to call Perl subroutines since Perl 5 was released in 1994. The fact that you do (`&amp;allchiver`, `&amp;linkripper`) makes me worry about the quality of the resources you are using to learn Perl. * The complex date/time formatting code between lines 28 and 46 can all be replaced with: use Time::Piece; my $now = localtime; my $time = $now-&gt;strftime('%H:%M:%S'); my $date = $now-&gt;strftime('%m/%d/%Y'); # Warning: Illogical date format! my $datet = $now-&gt;strftime('%a %b %d %Y'); None of this is likely to cause the problem that you describe. But if you were to clean up these issues, then it would be far easier to find your real problems. There are some great Perl tutorials at [Perl Maven](http://perlmaven.com/). I strongly suspect they're better than whatever you are currently using.
The IRC ones are a good example of why not to ask the perl channel for help. It's autism central in there.
havnt tried it yet but it should work just fine. i like my mod_security for pub facing sites so im using apache2.
Sounds just like map. 
Sort of, but map doesn't retain the intermediate value and pass it back in to the reducing function however. Reduce goes from a list to a scalar, map goes from a list to a list.
Oh I see now. Skimmed your example waay to fast, haha. Thanks for the clarification! 
Mmmmm, delicious heuristic parsing. This sub has previously convinced me that no indirect 'fatal'; Is a good idea
This makes much more sense when you think about the weird syntax of `print` when you specify a file handle: print STDERR "Hello, world\n"; That seems kind of weird right? The part about there being no comma there makes it seem like this is not an ordinary function call. But it is, just using dative syntax: STDERR-&gt;print("Hello, world\n"); (I think in older versions you had to `use IO::Handle` to be able to write it explicitly like that, but not with newer versions.) 
&gt; Congratulations. You found a program where you need to add a semi-colon in order do get the compile to fail. best part of thread.
That's what I thought too, but it's actually returning a null for each intervening non-match and entering the block on non-matchs, so I had to add the test for $1.
Yes, Thank you! That got rid of the syntax error. I thought that extra semicolons were just treated as null statements, but as you point out, it usurped the position of the 'else'.
&gt; The while loop will terminate as soon as the regex fails to match a word. Bad phrasing by me; it's more accurate to say *"The while loop will terminate as soon as the regex has matched all of the words"*.
Personally, I would not know firsthand, but I would also assume that based on benchmarks seeing somewhere. But I believe Caddy is making lots of progress in that area, too.
... because you put an unnecessary question mark after the brackets. You made the match optional.
What you defined is equivalent to a 2-dimensional array of size 1x2. For just a flat array, as I suspect you intended, leave out the square brackets. And to reference your array elements, you need to use the scalar symbol '$'. my @arr = (['test1','test2']); print $arr[0][0];
Wouldn't that be ``$trial_array[0]-&gt;[0]``?
&gt; This makes a list: &gt; my @trial_array = () Well, `()` creates an empty list. You then store it in an array. &gt; This is a reference to a list with 2 elements. &gt; ['test', 'testing'] No. It's a reference to an array with two elements. You can't take a reference to a list. &gt; What your code actually made is a list, which has as its first element a reference to a list of 2 elements His code built an array, which has as its first element a reference to an array with two elements. &gt; `my @list = ( 'test', 'testing' );` `@list` is a potentially confusing name for an array variable :-) In Perl, [arrays are not lists](http://friedo.com/blog/2013/07/arrays-vs-lists-in-perl).
That's JSON code. Look up the JSON module. You can convert it to an arrref or hashref and work on it from there. 
You need a [JSON](https://metacpan.org/pod/JSON) decoder.
Yup, you guys nailed it. JSON code. Installed the JSON pm and I'm good to go. Thanks a bunch Connir, exodist and davorg. 
Thanks for the comments guys, I tried to play around with it but I'm still stumped. For example, how would I write a perl statement which use reduce to print the sum of all odd numbers within [1..100]? It all has to be in a single statement so I can't use arrays (I don't think). No regex either
The `-&gt;` part is frequently optional in Perl, when it's clear that the expression to the left is a ref. It makes for more readable code, IMO. For example, `$a[0]-&gt;[1]-&gt;[2]` is the same as `$a[0][1][2]`, and `$b{hello}-&gt;{world}` is the same as `$b{hello}{world}`. But in the case of `$c-&gt;[0]` the `-&gt;` is required, since it shows that $c is a ref. 
You need to understand what it means to be Turing complete. The VM, and even the language itself is Turing complete. More than just compiling Perl 6 in ECMAScript, you can compile ES6 in ES5. And, that's all the rave right now. http://babeljs.io/ &gt; If my Perl 6 code uses two dimensional arrays and two dimensional arrays are not part of the javascript standard code base, how does the javascirpt interpreter know how to compile and use two dimensional arrays??? In Perl5, a two dimensional is written as an Array of ArrayRefs. You do the same thing. Write a translation layer that stores two dimensional arrays as AoA's. You include all the bounds checking and such, it's fairly easy. The only thing you can't do is get the same performance out of it -- so it's slow. Usually not a problem. Also, multidimensional arrays can always be flattened into a single array. It's just for convince that they're multidimensional. They're laid out in memory the same way (as a single-block allocation).. Array[2][2] for instance has 3 values on x, and 3 on y. 0 | 0 1 2 1 | 0 1 2 2 | 0 1 2 but you can always just fuck around with indexes.. 0 1 2 3 4 5 6 7 8 One can assume how `new Array[2][2]`, becomes `new Array[8]`, and then the indexing is translated back too... You can fold compile time translations and runtime translations shouldn't be that slow. If that's not substantial enough, keep in mind all of the things we do in perl because perl sucks. In Haskell you have Sets. A Set, as in math, is always unique. How do you do that in Perl? You abuse hashes because Perl doesn't have a native Set type. my %z; $z{$_}=undef for qw/ foo bar baz baz foo /; my @set = keys %z; Well, in the above you're doing it manually. You're answering the same question. How do you emulate Sets in Perl when CORE Perl lacks it. But you can fairly easily translate from Haskell syntax to the above hack. If you write a library that does it, you're well on your way to answering this question.
The processor in your computer doesn’t even know what arrays are at all, let alone two-dimensional arrays. Yet Perl&amp;#160;6 programs run on your computer… how? By implementing their semantics on top of the capabilities offered by your processor. Same thing goes for running Perl&amp;#160;6 programs under Javascript. You have to realise that this doesn’t translate the Perl&amp;#160;6 program to Javascript in a way that looks anything like if a human had written that Javascript code.
[DynaLoader](https://metacpan.org/pod/DynaLoader) maybe?
DynaLoader does this, but also calls a probably not-existing boot_Name function, and will fail then. So you have to suppress this error. You just care about being loaded, and it is. Or try any FFI package in perl, there are plenty of them.
The example I listed above I just silenced that via `eval`, but yeah its good to highlight explicitly.
Perl 6 is the cancer that killed Perl 5. It never delivered it's promises about parrot and being backward compatible. Took ages to develop while it's name declared Perl 5 to be deprecated. Being all talk about the most awesome features ever and never delevering production ready things for over a decade after it was announced destroyed it's image for me completely. The language might be nice and all and even productive now, but the damage is done. YMMV
I agree, but I really think Perl 5 will survive Perl 6.
Where is the excitement? I don't see it on any general programming forum such as /r/programming or hacker news. I don't even see much excitement for perl6 on this sub.
Thank you :P this worked wonderfully!
If no one was writing about Perl, it certainly would be dead :) Instead, the indicators I'm seeing suggest that Perl adoption has stabilized in the past couple of years and might even be picking up. I know at least one of our clients has said they were tired of getting burned by "the next great thing." They wanted something they could rely on. This plays in our favor.
Just do the compression level in the method call like in my untested example. Oh, and read the documentation (of addFile). One of the great things about Perl is that it comes with quite good documentation; `perldoc Archive::Zip`.
I support chdiring. But I recommend using [File::chdir](https://metacpan.org/pod/File::chdir) to manage that as it gives you a lexically scoped current working directory.
Holy crap I would love to move to France to work for these guys.
I work pretty much exclusively with Perl at work and love every minute of it.
I think people confuse equilibrium with death. I know tons of places using Perl, they have no intention of switching away any time soon. I know no new places picking up Perl. Things are calm and steady. 
&gt; it mostly works "Mostly works" was not the promise. It's a shame (but not a surprise) you have to throw shade at Parrot, which had very similar code working in 2006. In particular, I'd solved the problem of GC/RC impedence between libperl and Parrot years before Moar was even a plan.
&gt; Perl adoption has stabilized in the past couple of years You know, biologists have a special definition for the word "stable". Then again, so do doctors.
prob not the best way but I used... my @filename = split(/\//, $file); $zip-&gt;addFile( "$file", "$filename[$#filename]", 9 )
http://metacpan.org/pod/DBI http://metacpan.org/pod/DBD::ODBC 
Good point. I guess I'll stop writing comments about it here, and go back to writing Perl code at work, where it gets used in numerous production roles.
me too
[Stop reinforcing the frame.](https://chrishardie.com/files/framing-lightning.pdf) I saw this talk at YAPC::NA 2010. Yet we're still doing it. I just registered for YAPC::NA 2016. I expect I'll see more frame reinforcement again this year.
I started with C, then moved to Perl because why write in C when you can write in Perl? Then PHP came along and I mostly write in PHP now for web stuff but all the backend stuff (cron jobs, system tasks, etc) are all written in Perl. Why? Because it's the better tool for the task.
I love Perl. But aside from Matt's Script Archive, it wasn't early web novices, it was mod_perl &amp; Perl 6 that gave Perl a bad name. mod_perl was a beast, in both a good &amp; bad sense. It was incredibly powerful. And if you ran anything at scale, you had to use it. Forking CGI processes just wasn't an option. But it both lacked the simplicity of mod_php and some of the benefits of early servlet containers. Notably, inadvertently persistently data from query to query was a frequent problem. Perl 6... well. We all know the story there. I had the hardest damn time introducing new blood to Perl after it was announced. "Why should I bother learning Perl 5 if 6 is coming? I'll just wait for that." And of course rather than wait, they moved on to something else. At the end of the day, the whole thing just makes me sad. Perl **should** have been the de facto language of the web. My two cents, as someone who started with Perl 4, and did/does a lot of Perl hacking starting in the early 90s. 
He's not arguing that perl shouldn't be dead (because it's so great), but instead he's arguing that the impression that people have, that perl is dead in the industry, is wrong. 
Thank you, I love Perl. Having colleagues fighting with the "latest" tech, I see how many times they secretely envy Perl coders. Perl is alive and kicking, at least in my corner of the world.
&gt; he's arguing that the impression that people have, that perl is dead in the industry, is wrong. I know. I don't mean to criticise the message so much as the fact that we seem to keep remaking this argument amongst ourselves. I wonder if the fact that so many of the Perl related posts I come across are repeating the "it's not dead yet" mantra suggests it's not in as great a shape as each of these posts go on to argue.
&gt; throw shade at Parrot I can't see anything in my post that is critical of Parrot. Sorry if you feel that it was. I only meant to highlight that the community haven't given up on the ideals when Rakudo targeted Parrot. Saying something exists now in response to someone saying it doesn't since the move from Parrot doesn't feel totally unjustified? The "mostly works" is I haven't used it on big stuff so can't comment. How about "works on everything I have ever used it for including Perl 5's version of Inline::Python to open a Qt GUI".
Yeah, and those p5p jerks and their Perl 5.22 are siphoning away all of the Perl 5.8 developers. Seriously, Perl 6 was started with the intent of becoming the new version of Perl; backward compatibility was even planned (remember ponie?). The long development time and poor (at least initially) backwards compatibility have led people to say they are separate languages, but that was never the intent. I think Larry still wants to see them merge back together.
As if to illustrate the OP's title point, YouTube has decided that since I am interested in Perl videos, [I must also be interested in terrible CGI](http://i.imgur.com/YdcNhn3.png).
Five years ago they brought in some Java programmers to replace our Perl system. Needless to say they aren't done yet and the applications they did build are having so many problems there is now talk of moving those applications to Perl. Of course, two years ago we got a new head of development that liked C#, so the diverted even more resources to trying to build out a new implementation in C#. I expect them to be talking about moving anything they manage to get into prod to Perl in a few more years. Perl's only problem is finding developers. You can't throw a stone without hitting ten Java developers. The downside is that all ten will suck. If you spent the time to find a (truly) good candidate in Java, the search time would be comparable to finding a good candidate for Perl. But HR doesn't seem to get that. They see all of the warm bodies that apply for a Java position and rejoice (even if they build a [dead sea](http://brucefwebster.com/2008/04/11/the-wetware-crisis-the-dead-sea-effect/)).
Perl is not an enterprise language. It forgives idiots and idiots are cheap and plentiful
Out of curiosity, what drove that decision to strip Perl out of the environment? We use Perl pretty heavily where I work, but it has kind of a bad reputation because the person who wrote most of it years ago didn't do a very good job. Now I'm left trying to replace his code with something more reliable, legible, and maintainable (a pretty fun job actually).
I did as well. Unfortunately I've now inherited a system that was moved from Perl to Python and I can't figure out why there is so much buzz about Python. It's a good language, but I was expecting amazing things that I'm not seeing.
There were a few reasons, but the primary one was Perceived value. The owner was getting ready to retire by selling 51% of the company. During dilligence, investors were turned off by the flagship product being in a "dead language". There *was* a need to rewrite, as the entire team had agreed. The core app was 7 years old and forked per client due to lack of multi-tenancy. Java was originally thrown away as a worthless option because anyone who is honest will agree it's a terrible fit for web apps. Then several investors came in and said "you're not Java or .NET? I'm not sure we'll value a legacy product that highly" (paraphrased I'm sure). Since we were a linux shop, the ownership (as much the old non-tech president as the VP of software engineering) picked Java. To defend perl, I worked on a product there that was sold as a loss-leader to sell the flagship solution, and that's still in place in perl. It's a "newer" tech stack of Catalyst with DBIx::Class.
Exactly my point
Unless you're moving from php to a real programming language, there isn't really a whole lot about language A vs language B that will make your job amazingly better if you're competent with fundamental programming concepts and not just the idioms of a particular language.
I think I can answer that. There's three really large advantages javascript carries that many companies think outweigh the costs. 1. Consistency. There's some pretty big advantages (in web apps specifically) to sharing libraries between the front- and back-end. The rapid growth of browserify evidences that. I write a piece of business logic, and it isn't just executed consistently, but identically, in both locations. If you've ever seen webpage elements look different before and after you use them, that's why. 2. Speed. The new javascript interpreters benchmark so much faster than most interpreted languages, it's a different world. The difference is *usually* so big that the javascript might as well be a compiled, statically-typed, binary language... minus all the disadvantages of using those. I see benchmarks where even phantomjs, with all its "i'm a browser!" overhead is 20x faster than perl, and node.js on V8 is more like 40x faster than perl. I have more, but I have to hop..sorry.
Exactly. I don't see that as unabashedly positive. The nature of my work has changed a lot in 16 years.
Jnap left? Shit. 
Same here. I was extremely intimidated by Perl when I started this job, since my first real exposure to the language was also my first exposure to regexes that I hacked together in grad school to analyze an old dataset. Perl has its quirks (as does any other language), but it's really fun to write and build. At my job we are completely rebuilding our data pipeline - we stuck with Perl because other hot new languages used for the same thing like Python wouldn't cut it performance-wise (according to the bosses). Perl can be pretty when written well. 
&gt; the only reason i used perl is catalyst, but now jnap has left that's dead as well Are you sure? He still [releases](https://metacpan.org/author/JJNAPIORK?sort=[[2,1]]) modules and updates for Catalyst
Funny you mention PHP as not being a real programming language. One of my previous employers switched their entire system from Perl to PHP a few years after I left. I'm actually surprised they pulled it off and did as well as they did.
$filename[-1] is the last item, and easier on the eye, IMO. File::Spec has class methods to split and join paths in a portable way. Also, there is no need to put scalars between "", so the last line could be written as: $zip-&gt;addFile( $file, $filename[ -1 ], 9 );
Imagine how dead it will look in 5-10 years when all those packages become abandoned (and they will be).
[Image](http://imgs.xkcd.com/comics/exploits_of_a_mom.png) [Mobile](https://m.xkcd.com/327/) **Title:** Exploits of a Mom **Title-text:** Her daughter is named Help I'm trapped in a driver's license factory\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/327#Explanation) **Stats:** This comic has been referenced 1198 times, representing 1.1541% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d13jf2g)
Ah, having co-workers dealing with that, I could not agree more.
I came to this thread to make this exact point. I thought most of the article was good, except "Perl is not dead" and "Programming in Perl may not be as "hip" as...". Who says Perl isn't hip? *I* sure think Perl is hip. Perl is awesome, Perl is vibrant, Perl has a great support community, Perl puts food on my table -- it's *hella* hip.
Pretty sure they do a lot of remote work. Moving to France may not be required.
A lot of reasons. 1. A small web-app is often smaller than just the boilerplate in a Java web app. 2. There's really no definitive advantage to Java as a language in the domain of web-apps (if you're anything but IObound, the app was the wrong choice... and the more useful/powerful template systems lend themselves better to dynamic languages) 3. There are undeniable disadvantages to using Java. I can write my whole damn MVP before a Java team gets the core code up. They don't meld with the usual advantages of Java... If I really care about scalability, horizontal scalability is a lot more core to web apps. I see teams of 20 Java developers fail in 3 years to replicate a 2-3 dev perl app written in 12 months... Node developers can keep up with that *and* grow scale, in closer to that 12 months than 3 years.
I heard that a lot, too. The VP of Software spoke to a .NET consulting firm about Rails, and they concluded that rails couldn't scale to *their* level of traffic. My next company had a 2-dev Rails app that had daily hits far in excess of that company's full-saturation-target (that is, if they'd somehow 100% share of their market)
Please don't ruin this for me.
I tend to disagree. I can agree that the standard spring and servlet type of development would fit those assessments, but things like Play, and Spark really limit the amount of boiler plate you need. Then there's the whole area of jooq/jool/javaslang/pcollections which do all kinda of neat things that bring java closer to being up to speed with the fluidity of C#. I moved away from perl mostly because my job didn't require me to use it anymore, but I found the tooling and features of Java to really beat the pulp out of what perl had at the time. Moose is still far and above a lot of OO things, but it's not compelling enough for me to keep developing with perl as seriously as I had in the past. 
Perl is indeed fun to write. I seem to write little scripts for personal stuff much faster and better than with Python or Bash. I am not sure why people think Perl is a hard language to read and i agree that it can look quite nice when properly written. 
They're big into the expat thing too. If moving to France is what you really want to do, they'd probably help with that too.
&gt; java is a terrible fit for web apps Web apps usually evolve quickly and Java's syntax doesn't make that evolution easy. It's a very wordy language.
&gt; The downside is that all ten will suck. I haven't worked with any great Perl developers either.
&gt; What's an enterprise language then? Something that can supports scaling from an organizational perspective. And something that supports concurrency and heavy real-time traffic.
I went to the first Perl Conference and proudly wore my Perl Monger t-shirts to all the Linux Install Fests back in the day. I regret that not all of the programmers of my generation met your lofty standards, but I'm officially done being blamed (at least in part) for the "death" of a language that I still use every day. Between Perl6 being in development for over 15 years and the explosive growth of so many other languages in the same space, the need for yet more blogs placing blame on the legions of exited nerds that loved Perl is minimal. 
I'm wondering if there's a baby in the bathwater, here. Unless you are suggesting that CPAN magically has the same *number* of quality packages as its competitors, the point is that there's fewer quality perl packages than the equivalent in other languages. CPAN is showing an incredible amount of stagnancy, which amounts to the majority of my post. Number of packages is just one element to evidence that. Number of new packages is another (or... has computer science, patterns, and critical interfaces really reached its entirety of all knowledge in 2011?) I was there before it happened... CPAN really was [God's gift to programmers](https://xkcd.com/224/). To pretend that it still holds that position in the modern world is pretty silly. The numbers just don't show it. The experience just doesn't show it. I have years of production experience in perl, and I felt the dying of libraries, and the capabilities of them start to fall behind. It's not just about new things. I love perl, but I wouldn't put my career on the line to adopt perl as a new language at a company like I would have in the past. Of course you still *can* do everything in perl, but that argument was used against perl with older languages, too.
[Image](http://imgs.xkcd.com/comics/lisp.jpg) [Mobile](https://m.xkcd.com/224/) **Title:** Lisp **Title-text:** We lost the documentation on quantum mechanics\. You'll have to decode the regexes yourself\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/224#Explanation) **Stats:** This comic has been referenced 99 times, representing 0.0953% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d14536h)
&gt; Are you suggesting that there's still more life in CPAN than in npm, rpm, or pypi? No, just that Node/JS/NPM seems to gather far more useless toys than any other language or package manager. Pypi and CRAN are normally a bit better than CPAN for my particular needs, while CPAN seems to have broader coverage. None of that has much to do with the total number of packages or the rate of uploads.
Or maybe you met them, but didn't realize it?
&gt; I see benchmarks where even phantomjs... is 20x faster than perl, and node.js on V8 is more like 40x faster than perl. Doing what sorts of things?
Perl can be found in "Most Dreaded" "Losers" and also "Top Paying Tech". That's some hilariously bad marketing if hardly anyone on SO uses/knows Perl, but thinks it's awful, despite being one of the more employable languages...
What's your question?
&gt; link-shortening industry are we talking about the same thing, i.e. unique "hashes" for urls? if so isn't there already a known *optimal* way of doing this? that is, sort the parameters and use a pseudo hash function, and that's it? or if you have access to storage of some kind, then any short unique value could be used to map to urls, or am i missing something here?
Using Moo/se::Role you can package the declaration of complex attributes (type, set/getter layout, requiredness, laziness, programmatic defaults, triggers) or even method modifiers (around, before, after), and apply them to any class you like with a simple call of `with "Foo::Bar::Role";`. This will set up setters/getters and configure the constructor appropiately. Plus, when composing multiple roles into a class at the same time, they'll be collision-checked as well. Roles can also declare dependency on specific methods existing in the target class; and be composed into other roles, thus providing a very handy repackaging functionality. I've yet to see this functionality in other languages.
Yes, same here. It is quite funny, outside they brag so much about how javascirpt/ruby/python rules, but in the privacy of their cubicles they go back to Perl and deeply enjoy it, if not revel into it. It is like they are ashamed not to be hip, but then, when it is time for really solid work, they resort to Perl. I do not chide nor envy them, it is tough to write in those other langauges, SO boring! Sometimes that famous Comic about [God Himself using Perl](https://xkcd.com/224/) comes to mind, though! 
[Image](http://imgs.xkcd.com/comics/lisp.jpg) [Mobile](https://m.xkcd.com/224/) **Title:** Lisp **Title-text:** We lost the documentation on quantum mechanics\. You'll have to decode the regexes yourself\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/224#Explanation) **Stats:** This comic has been referenced 100 times, representing 0.0963% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d14cii9)
Well put, Perl is so much more fun!
&gt; one of the more employable languages How do you figure? In my large metropolitan area, which was formerly a Perl haven, currently has zero listings on Perl jobs.
Clarified, in the context of work. Their work wasn't anything to write home about.
&gt; Out of curiosity, what drove that decision to strip Perl out of the environment? I'm a freelancer. With the single exception of my current clients, everyone I have worked for in the last eight years is has either given up Perl completely or has made some moves towards replacing Perl. (I hope this has nothing to do with the quality of my code!) The two most common reasons seem to be: * Difficulty of finding Perl developers * Being taken over by another company that imposes their tech stack.
I agree, but then there aren't as many Perl devs either as there once were. I'd rather be one of many well paid experts than a cog in the PHP+JavaScript full stack machine. I think perhaps everyone focuses on web programming assuming there is nothing else. But there is a lot of technical scientific programming that goes on. Perl is hugely useful for dealing with myriad crap text formats from labs, doing basic stats and interacting with a central database. I work for a new company using Perl. So guess my situation is biased to thinking these jobs are common. They are common in locations where biotech is a big deal, unlikely to be local to you by chance though.
Can you please provide specific examples of this?
Please don't spread lies about my friends just because their personal lives get in the way for a while. And no, his personal life is not any of your business either.
&gt; I'd rather be one of many well paid experts than a cog in the PHP+JavaScript full stack machine Couldn't agree more! 
https://www.reddit.com/r/perl/comments/427kq8/why_isnt_perl_more_popular/cz8h5dz
&gt; Something that can supports scaling from an organizational perspective. Perl has modules, classes, great testing tools. I work with approximately 70 devs on a large Perl application ... what specific characteristic of an "enterprise" language does Perl not support?
I'm not saying Rails is super-scaleable either... But this company had such a low ceiling it wouldn't have really mattered... but they had a few badly written libraries and envisioned that slowdown meant they were at the peak of their product's scale potential. 
&gt; it's perfectly capable Then why aren't more people using it than Ruby?
Yeah code coverage is a fair point. Devel::Cover is pretty good but the nature of Perl limits what's possible. 
Good answer, thanks. I would argue "yes" for Perl in 2,3,5,6 and 7, but it's subjective for sure. For #4 Perl definitely doesn't have mega-corp support of Facebook and Google but CPanel, Booking.com, Ziprecruiter.com, BlueHost, DuckDuckGo, SocialFlow are a few companies that come to mind as Perl shops. Obviously many large companies have a Perl team (e.g. Apple).
i read this as: our docs are so good we don't need to use SO for anything Perl related.
I meant examples of specific Python things you think Perl doesn't offer, without the editorializing by someone who isn't that good at Perl. Although if you also agree with the sentiment of "only builtins may apply", then this discussion isn't useful.
The cool thing about `Acme::` is that it is for jokes whose authors recognize them as such. The random JS guy I picked on doesn't acknowledge that his modules are useless jokes. My impression is that NPM somehow attracts more packages coded up in a drunken Friday night, or submitted to cynically pad a résumé, or simply written by clueless people reinventing wheels, than any other repository. I don't have statistics to back this up. I'll look for substack's modules the next time I wade into JS -- thanks!
&gt; Things that bother me about languages with not great type systems (an argument not exclusive to Perl) Excellent list. The only thing I could add is "semi-structured data expressed as strings", though Perl's been a little bit better about it in the past couple of years. That's faint praise, however.
In addition to what /u/mithaldu said, we have a system of Type Constraints, which, for the uninitiated, is: - A collection of Symbollically named, Composable, Reusable, self-describing validations that describe and enforce constraints. This is a lot like the Type systems of statically typed languages in application, but it is more nuanced in its ability to match different conditions a "native" type may fall under, and I'd even say in practice, is *more powerful* than any static languages type system. These "Type Constraints" can then be associated with attributes, and the then add validation to each and every `set_attribute` call, and each and every attribute assignment during `new`. This allows you to add layers of *optional* safe guards to your interface, without lots of boiler plate. -- To see what I mean, in Java, you need to do stuff like this frequently: void set_foo( String bar ) { if ( bar == null ) { // throw } if ( bar.length == 0 ){ // throw } // goodness knows what else } And you have to re-do that every place you enforce the same "type" of input, complete with matching exception throwing logic and consistent error messages. Under a Type Constraint world, this becomes: // pseudocode subtype NonEmptyString as String where { this != null or throw { "Expected non-empty string, got null" }; this.length != 0 or throw { "Expected non-empty string, got 0-length string" }; }; // Option one void set_foo( bar ) { assert_NonEmptyString(bar); } // Option two void set_foo( NonEmptyString bar ) { } Except its even more powerful than that, as well we need to do is: // again, more pseudocode attribute NonEmptyString foo :rw; And then people passing `foo` to the constructor gets that validation, and people calling `set_foo(value)` gets that validation. This is an incredibly addictive way of making your interface more predictable, and is one of the features that keeps me using Perl. **Every time I look outside Perl**, I find their object systems are **missing giant features Moose offers**, and although many of them are getting 3rd party libraries that compare with Moose in some way, I'm yet to find one that combines Moose style OO and Type Constraints. I can find both parts in some description independently, but I can't find any where they're usable together.
But if you're building something, the last thing you want is the things you're using to change underneath you. Resisting change in that way is of course, a **good** thing, because it resists the kinds of changes that necessitates yet more changes. This is the kind of *empowering* stability that empowers *others* to make changes by the predictably stable ground work. As a person who was recently in a [violent earthquake zone](https://en.wikipedia.org/wiki/2011_Christchurch_earthquake), I can attest, changes at the foundation level is a really bad thing, and the consequences of those changes have long-lasting negative side-effects which humans are still poorly adapted for. 
Its funny you mention substack. Because I knew them first from their [involvement with the Perl community](https://metacpan.org/author/SUBSTACK), before node really exploded and he became a celebrity =) Obviously an authors skill is self-evident here. But I can't help wondering if Perl culture influenced his choices in some way. 
&lt;nobrain&gt; &gt; Ruby is dead-ass easy to get into. See, ruby is dead! &lt;/nobrain&gt;
No, you don't.
We have Type Constraints. They're not *compile* time Type Safety, but they're a good compromise, and they also fill gaps where many "Type Safe" languages fail. ( Like strings can be null, etc ) I mentioned this in in detail in reply to [another comment](https://www.reddit.com/r/perl/comments/4ap9q5/perl_is_not_dead_it_was_early_web_novices_that/d14vx2t)
I've personally started feeling that some of those "Smart" tools can be more harm than good. For instance, I can see the advantage of tab completion in an IDE when you're forgetting if the function name is "URI" or "URL" at the end, like: object.add_url(foo) But that convenience I find backfires, because it encourages/enables you to write code that you can't fit in your head, and can lul you into making bad API design choices and hard to remember method names, which lead you to become **dependent** on tab completion. For instance, if somebody made the API sin of accidentally calling one function: add_url(foo) And another function remove_uri(foo) Tab completion would paper over that difference enough you might not notice its there, or might not care to fix it. And I say this because I **constantly** struggle to name things well, and I **constantly** have problems where I accidentally design things with a degree of naming inconsistency. I don't need tools that enable me to make this problem worse ;) But its of course, a personal preference. 
I have to say though, its slightly better than a lot of the alternatives. "Line based only" coverage is a thing I see very often, but Devel::Cover supports much more nuanced detailed coverage, like coverage of condition permutations and independent expressions. 
Oh yeah, no-one is doing anything particularly new and exciting in this area. I mean that the companies providing the service change regularly. At it's height, WWW::Shorten supported about a dozen services. Two-thirds of those have now closed down.
&gt; metaCPAN page suggests he never released any modules in perl (which both of us know to be false). It seems to be true, at least, there's nothing released under his own name, the [backpan dir is missing](http://backpan.perl.org/authors/id/S/SU/) 
I was speaking of the plan, not the reality. The plan was to have ponie (a Perl 5 compiler that targeted Parrot). I was responding to /u/z27's comment about a "secret agenda". There was no secret. Perl 6 was supposed to be the next Perl. It was supposed to have backwards compatibility through separate compilers targeting the same VM. These plans have not yet come to fruition, but they were never secret and I think Larry still wants the two languages to merge.
I never saw the appeal for javascript. I have used it once and found it a chore and quite boring to use. My last job I primarily used C# and, after using Perl, i wonder how I tolerated it as much as I did. C# was a fine langauge, do not get me wrong, but it felt like a mess to me after switching to Perl.
I cannot write Python in any text editor or IDE unless its VIM with my vimrc file converting tabs to 4 spaces. Other editors just treat the return key as a tab character which drives me nuts! I am much more productive in Perl.
What this guy said.
&gt; I don't need tools that enable me to make this problem worse How about tools that help you fix that problem everywhere, at once?
Very few people are excited about perl6, please just change it's name so the general public can stop thinking it has anything important to do with perl.
&gt; But if you're building something, the last thing you want is the things you're using to change underneath you. If the nature of my work changes -- say, if single-process code suddenly gets no Moore's Law advances for the foreseeable future -- then I should hope my tools can keep up.
Neat. I haven't seen that one yet, I obviously don't do java enough. A quick skim of the documentation suggests it does what I expect of such a thing, but I'd have to use it to get a more accurate impression.
134 comments about a flashpoint topic and we've managed to keep it civil and enlightening, thanks everyone
&gt; But if the same tool was too easy to use, you'd be using the inherently dangerous tool frequently enough that it could cause more problems. What's dangerous about automatic refactoring? I remember the Perl world saying, for at least 15 years, "You'd better have a really good test suite so you can make changes without worrying about breaking things". What's the effective difference?
&gt; But I don't think when people are talking about stability in terms of programming Of course! Ovid and I were being more than a little facetious in our one-liners. Yet the problem remains that a lot of the things I wanted to see in Perl 10 years ago still aren't there. Rakudo addresses some of them, but it's a huge step backwards in almost every way for the things I liked about Perl 10 years ago (documentation, libraries, community, stability, future). I spent a lot of time advocating for Perl to change in ways I wanted it to change. Some of them worked (regular release cycle, WSGI equivalent, better testing). Some of them didn't. There's a limit to how far any one person's influence can extend and how much you can expect any one person to fight a system that resists change. I'd like to be in a position where my team could have dozens of modern Mojolicious apps doing what we need to do, but it's been less and less practical for all sorts of reasons that have nothing to do with "the interface existing code relies on" not changing and everything to do with everything else around the language ecosystems. *That* is what I wish had changed a decade or more ago, but it didn't and here we are.
I feel its more a temptation to use automatic refactoring when its not needed, or the temptation to under-think code with the safety net of "I Can just auto-refactor it later". Tests are great. Really. But tests only cover so much of your code, and bugs can always sneak past tests. Tests for me seem like they'd be more a *discourager* of heavy refactoring than an encourager. And they rather aught to. Because its not always obvious that you're not testing some sort of mechanic that somebody was using, which then evaporated because somebody thought they'd click the "auto-refactor" button in their IDE. ( And the IDE can't refactor 3rd party code it doesn't know exists ) But the point is of course not that they *are* always bad tools, but they *can* be, and this becomes increasingly so in the hands of a novice.
/u/dnmfarrell the first thing any user of Perl on Fedora should do is to install `perl-core`. That's the package that contains all of the modules that were removed (probably illegally) from the default perl package. For Ubuntu users, less required but still useful is to install `perl-doc` which provides perldoc.
DynaLoader can load arbitrary shared object files into the current process (assuming your system can do so). The function you are looking for is [`DynaLoader::dl_load_file`](https://metacpan.org/pod/distribution/perl/ext/DynaLoader/DynaLoader_pm.PL#dl_load_file) you can see an example of its use in [Alien::Base](https://metacpan.org/source/PLICEASE/Alien-Base-0.028/lib/Alien/Base.pm#L156). That example also shows how to resolve path lookups and keep track of library references in the global symbols for book-keeping purposes.
I haven't tested it, but this should get you started: for my $item (@{ $data-&gt;{'data'}{'children'} }) { print "Unrecognised data type?" if $item-&gt;{'kind'} ne 't3'; print $item-&gt;{'data'}{'title'}; }
Im not so much excited as hopeful. Perl5 needs an overhaul and i like that perl6 is perl like. Not having a production ready perl6 though, kills any interest i have in using it. I dont have spare time to fiddle with concept languages that I cant use for work.
At first I moved away from using Mojo::UA/DOM for this when working with HTML rather than JSON, I'm on an embdedded platform and it was really slow. Tested this and it seems to work fine. Thanks for the tip
Works perfectly. Thanks.
Oh right, forgot to mention one more thing: using some personal, but opened SVNs or even more legacy VCS instead of github. 
&gt; That sounds like a lot of excuses That's one way to describe "we have invested a lot of time and money in Not Perl and there's no order of magnitude improvement in paying to switch to Perl", but it's a reductive and dismissive phrasing.
Undefined values won't match any of those strings, so the 'defined $upd_cat' check should not affect behaviour - it'd avoid an "uninitialised value" warning, however. tl;dr that should already work, I think the problem is elsewhere. this in particular looks suspicious: $updated = $today since it will set $updated to $today, if you wanted to compare that'd be $updated eq $today same as earlier in the line, or possibly $updated == $today if you wanted to compare as numbers.
It wouldn't be an error in other languages. In most situations you'd get a similar error only if you had never defined the variable. A variable that's been created is by definition (in English) defined. But if it has no value, that would be a null value. It's just a weird way to do it. If I create a room with nothing in it, that doesn't mean the room doesn't exist. Just that it's empty. 
Both the `while (&lt;...&gt;)` and the `print` are using the special variable `$_`. [`perldoc -v '$_'`](http://perldoc.perl.org/perlvar.html#%24_) explains a bit.
As others have said, many operators will - in the absence of an operand - operate on `$_`. Which operators do this is a process of discovery, and in general, being explicit is always better then implicit. However, it's a nice-to-have when you're quickly whipping things up. Typically you'd use it inside a `for` or `while` loop for ( @array ) { chomp; # chomps $_ print if /pattern/; # prints $_ if $_ =~ /pattern/ } It's also nice for quickly dumping arrays; print for @array; # same as `print $_ for @array;` PS. `$_` in perl is the concept of a Pronoun ("it" or "this"). It's useful in the same way it is in English. You wouldn't say `"I picked up the note, tore the note up and put the note in the bin; I didn't think about the note again."` Instead you'd say `"I picked up the note, tore it up and put it in the bin; I didn't think about it again"`.
&gt; Perl 6 is the cancer that killed Perl 5. Perl 5 is under vigorous development, and significant features have been borrowed from Perl 6. 
What other languages call a null value, Perl calls undef. That's just what Perl calls it, but it's the same idea. 
While using the implicit assignment to $_ is great for a one-liner or a very short disposable program, I would avoid it in production code. And any program you write that does something useful, quickly turns into production code. For one thing, using an explicit variable makes the loop self-documenting .... it's not just an anonymous $_, it's an $address, or a $first_name. And while "print if /pattern/" is useful for debugging, production output is usually more sophisticated, involving parts of this and parts of that, and a bit of Wednesday Adams.
I find it most useful in production when it's used to good effect with a post-while and post-for, where it's easily identifiable and the chances for misinterpretation are smallest. For example: # Make sure an array of hashes has a numeric value # for a specific member field $_-&gt;{foo} //= 0 for @array_of_hashes;
In code what /u/Rhomboid is saying the OPs code is equivalent to the more explicit: open(my $FH, '&lt;', 'short.txt'); while($_ = &lt;$FH&gt;) { print $_; } close $FH; I'd personally use $line as a variable over $_ if the while is longer and more complex.
Do you have use warnings FATAL =&gt; 'all'; or similar in that script? If so, the "Use of uninitialized value" warning will be upgraded to a fatal error. It'd be easier to help with the full script and output, of course.
And similarly in nested grep {} or map {} chains.
First option complains that the search pattern is not terminated. Any idea why that would be?
That's a warning, not an error. If you add a print statement at the end, it should still run. The two main options are to ensure that the variable is always initialised, or add no warnings 'uninitialised'; to avoid that warning.
Typo as below perhaps? $lemon s//= ''; looks like a regex substitution pattern (but isn't correct). Correct would be: $lemon =~ s/&lt;match criteria&gt;/&lt;replacement string&gt;/;
Highjacking, just wanted to tell about [B::Deparse](http://perldoc.perl.org/B/Deparse.html) that is the backend compiler used to produce perl code. You can use it on the command line like this: $ echo 'while(&lt;&gt;){print}' &gt; file.pl $ perl -MO=Deparse file.pl while (defined($_ = &lt;ARGV&gt;)) { print $_; } test.pl syntax OK Now its clearly how `print` knows what to print :-) 