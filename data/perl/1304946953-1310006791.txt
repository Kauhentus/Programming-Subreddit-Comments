&gt; on Nginx and it will be even nicer! it was not clear! I meant it would be nicer to see the results via Nginx rather than Feersum... 
2017 will be the year of Perl 5.10.
Thankfully CENTOS6 will have 5.10 like RHEL6 does. 
Meh, the world ends next year right? ;)
That's not what I saw. Miyagawa was providing benchmarks to illustrate potential performance increases by moving to PSGI due to the ability to deploy on alternate backends. You were stating that if PSGI could provide increased performance you would be interested in it. Miyagawa illustrated that PSGI can not only perform as fast as CGI.pm's FCGI performance (which I think he's shown with all the various hoops you have had him jump through), but that because PSGI allows you to deploy via Feersum, Starlet, Starman, and other setups you can potentially perform significantly *better* than FCGI without altering your application. One of the points here is that PSGI and FastCGI/CGI are not simply apples to apples comparisons. 
You are entirely free to prefer CentOS. It has a lot of things going for it, stability being one of the largest. My point is that your decision to use CentOS, and CentOS's system perl should in no way mean that I am now obligated in some way to support your deployment situation with my modules for free. 
While 5.12 is standard. 
Props to you for having the patience to put up with people who insist on using dinosaur software.
&gt;The Perl 5 porters officially ended support for Perl 5.8 on November 5, 2008. It doesn't matter if some other company promised you support for Perl 5.8. **I** don't have to make sure my CPAN modules support 5.8, that's $other_company's job.
In a rational world you would be right. Of course, in a rational world people would realize that a *supported* Perl 5.8 on CentOS or RHEL means only that RHEL might release more patched versions of Perl 5.8.
CentOS... the IE6 of servers.
I hadn't read this comment before I wrote my latest article. Too amusing.
Shouldn't that be RHEL? CentOS just copies whatever RHEL does. And in fact, I don't think any distros are really any different. Are SLES or Ubuntu much different?
Hell yes. SAMV++
So, looking at the [test reports](http://matrix.cpantesters.org/?dist=threads-tbb+0.01) this doesn't seem to run anywhere. Anyone who isn't uploading tests able to actually install this?
Is there more to this than an eval wrapper?
It works fine here. The machines must simply not have the Intel Thread Building Blocks library installed.
&gt; PSGI allows you to deploy via Feersum, Starlet, Starman Would you compare Nginx to those servers? Would you deploy live your application with such servers? Do they reach the level of functionality of Nginx,Apache? Have they been deployed on huge scale projects over the world? It's not that I want to disrespect the people working on them but all of them still need some time before getting the scale of more mature servers. So would I deploy my app with such servers? No. Would you? Then, if I don't deploy my apps on such servers, why would I care about their speed? Being able to deploy on thousands of related projects but none of them being ready for live deployment is not something I am looking into... But I can see that you can deploy on many servers, that's nice, not really what I care for though... Indeed, miyagawa has been very kind as to the data he provided and I am grateful for his time! 
&gt; Would you deploy live your application with such servers? Yes, I have a couple of projects running on Starman and Twiggy live, both for my hobby and production environment for my previous employer, and it's been fast, really stable and easy to troubleshoot. [One of them](http://sunaba.plackperl.org/) has a twiggy server running for 9 months, no downtime, no memory leaks. And I know dozens or more of companies, [including the tech giants with millions of user base in Japan](http://bulknews.typepad.com/blog/2010/03/perl-and-plack-big-in-japan.html) use PSGI based web applications on their production environment - some of them use Starman behind perlbal, some of them use FastCGI + Apache, others Twiggy behind nginx, etc. etc. &gt; Do they reach the level of functionality of Nginx,Apache? With tons of Plack middleware that does basic stuff from serving static files and basic authentication to really incredible things like debugging panel, OpenID authentication and API throttling, etc. etc, my answer is absolutely yes, but I know YMMV. And *even if* your don't believe that, you can still deploy PSGI apps on Apache, or run Starman behind nginx/perlbal, or run it with FastCGI behind lighttpd - with absolutely zero changes. P.S. Your argument just gets down to "For me, FastCGI is almost always available and CGI.pm is just fine" and "I see some benefits of PSGI but none of them look attractive to me". It's perfectly valid for you to say so, but at the same time, that totally doesn't validate you to say "There's absolutely NO benefits *for anybody* to switch to PSGI". There are many, many reasons for developers, framework authors, middleware module writers and devops people to love PSGI because of all things i explained on this thread. At least I just want to make sure about it.
&gt; With tons of Plack middleware that does basic stuff from serving static files and basic authentication to really incredible things like debugging panel, OpenID authentication and API throttling, etc. etc, my answer is absolutely yes, but I know YMMV. Then I think the benchmark will give something else in the end (when we add all the middleware to get a Nginx/Apache like env). But that's good to know that these servers are being used in live projects though. I still would not. not right now anyway. &gt; "There's absolutely NO benefits for anybody to switch to PSGI" In fact, I was really wondering, why yet an other layer... If I were to build a new app from scratch I would look into PSGI I think though (and indeed, I did check it even though everything works fine because I was hoping for more speed or what the...) Because everything you described here could be done under the CGI protocol. But I came to think that this PSGI protocol brings easier post process hooks to the final data/webapp(would it be status code,headers and the body) that would be a pain to create in CGI. From this ease of post-processing you can get all the extra middleware stuff (well, i am certainly oversimplifying here...) and then the PSGI protocols can be handy. 
&gt; Would you compare Nginx to those servers? No^1 but neither are you. I will however compare the FastCGI daemon to them. &gt; Would you deploy live your application with such servers? Yes. [This website](http://superawesomecool.org) is deployed using Nginx + Starman. &gt; Do they reach the level of functionality of Nginx,Apache? Yes actually they do for my purposes. Do you use all of the features of Apache? For example have you written a custom configuration handler in Apache? I have. It is easier to patch Starman. Even if you determine that these deployments are not mature enough for you right now, one day they may become mature enough. It costs relatively little right now to enable your applications for PSGI. Doing so will allow you to continue testing alternative deployments. &gt; But I can see that you can deploy on many servers, that's nice, not really what I care for though... But here is the truth. You're not interested in the main benefit of PSGI, there for you decided to question it's validity at all. If you're not interested in alternatives PSGI isn't for you. ^1: Actually I might. I know people who have deployed with the Perl server attached directly to port 80. [edit: *not* mature ... *not*]
&gt; But that's good to know that these servers are being used in live projects though. I still would not. not right now anyway. Totally fine. Being conservative isn't bad :) You can start with FastCGI/nginx combo that you trust, and try Starman or whatever servers much later when you think it gets *more mature* - up to you. Again, no code changes required when you make a trial. &gt; But I came to think that this PSGI protocol brings easier post process hooks to the final data/webapp(would it be status code,headers and the body) that would be a pain to create in CGI. Absolutely! &gt; From this ease of post-processing you can get all the extra middleware stuff (well, i am certainly oversimplifying here...) Exactly, and middleware for pre-processing, too. (Although pre-processing might be less painful to do in CGI since it's just a global %ENV) &gt; and then the PSGI protocols can be handy. *grins* 
I am just slow to get things... thank you for the time you spent btw
And 5.14 is out.
I really should get some sleep and stop being so grumpy. 
&lt;insert Perl 6 joke here&gt; Edit: Man! I was just kidding around, but seem to have hit a sore spot... I've been using Perl since '92 &amp; have been waiting for Perl 6 just as long as anyone. 
I totally agree with what someone posted in the Mojoliciuos discussion: You can't expect to use Modern Perl modules in Ancient Perl compiler. When you do, it leads to ridiculous situations like this one.
Really lazy, dewd.
CentOS is outrageously conservative
I didn't find your comment bad at all, and I'm a Rakudo developer, so I'm giving you an upvote just for justice :)
&gt; In seven years, when CentOS 5.6 reaches the end of its supported life span The blogger doesn't seem to know what he's talking about. The CentOS life cycle matches the Red Hat life cycle dates, and both are based on the **major** version, not the minor one. The release of 5.6 has no effect on the life cycle, which began its 7 year countdown at the launch of 5.0. So what is the current state of the cycle? Checking [here](https://access.redhat.com/support/policy/updates/errata/), we see that version 5 launched March 15, 2007. By March 31, 2014, it will be out of support. However, version 6 already launched, and it uses Perl 5.10. While CentOS 6 is still playing catchup, RHEL6 is available for use (with Scientific Linux 6 as a free counterpart). Besides the factual inaccuracies, the author seems to be missing the point of an enterprise distribution. It's supposed to stay relatively stable and static aside from receiving security patches and bug fixes for an extended period of time. It's supposed to sit there and more or less continue doing whatever it was doing with as few changes as possible. New installations, new development, new software, and (most importantly) new CPAN modules are likely to use the latest release of the distribution. Just because CentOS 5 will be supported for another 3 years isn't going to stop people from moving to CentOS 6, just as people are already using CentOS 5 in preference over CentOS 4 (which will still be supported until next year). (Some will notice that there's an extra 3 years of support that Red Hat offers beyond the 7 year cycle. However, that's extremely limited support, and CentOS only covers the main 7 year cycle.)
&gt; The blogger doesn't seem to know what he's talking about. Your satire detector has come unplugged. &gt; Besides the factual inaccuracies, the author seems to be missing the point of an enterprise distribution. I know exactly what the point of an enterprise distribution is. It's what you install if you want nothing to change. I admit, I fail to understand which part of that means that you should be able to install new versions of software from the CPAN on an enterprise distribution installed specifically such that nothing should change. &gt; Some will notice that there's an extra 3 years of support that Red Hat offers beyond the 7 year cycle. Sure, and that gets you to 2017. &gt; Just because CentOS 5 will be supported for another 3 years isn't going to stop people from moving to CentOS 6... Just because CentOS 6 will be out won't stop people from not moving away from CentOS 5 until they absolutely have to. Remember the point of an enterprise distribution. Besides all of that, the real point is very simple: if you don't want true enterprisey, you can't be installing new software, so don't complain if the people who donate new software under very liberal licences aren't falling all over themselves to make sure it runs on enterprisey systems which, by design, will never run new software.
&gt; New installations, new development, new software, and (most importantly) new CPAN modules are likely to use the latest release of the distribution. That's a pretty naive assertion. Last October i hired on to a job where i was supposed to write modern automation tools in Perl. The target platform? Perl 5.6. I may be writing new tools, but it must run along all their old tools since they don't have the damn *resources* to upgrade machines. No, it's not as easy as running yum upgrade, thanks to major revisions becoming stuck in time. They have to migrate the entire software pieces running on those machines to new ones, including accounts and permissions and crontabs and whatever the hell and THEN test every single thing to make sure it's not breaking on the new OS version. And it's not just one machine, we have 20+ machines running alone for my department and 100+ for the rest of the company. And besides all that upgrading work also needs to happen somehow.
What's the consensus about using ActivePerl for Linux servers? They provide an RPM and they stay up-to-date on the latest Perl.
Thanks. :)
Grr. Should be Acme::AnyEvent::Kanye. Sigh.
Good job. Got a chuckle out of this one. Should be in Acme:: though
Absolutely. As someone running smokers i do not want to see things like this outside of Acme::.
i'm guessing its the auto complete engine integrated into visual studio
I think it's intended to be useful, even though its cutesy name and its absolutely unclear documentation.
[This](http://cpansearch.perl.org/src/NUFFIN/AnyEvent-Kanye-0.02/lib/AnyEvent/Kanye.pm) is the source link. It does nothing useful.
 /~~~\ /~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ |. .| / O HAI! It looks like you're writing a program! \ | | /\ Do you want to: \ | o | \ * Blue screen? | \___/ \ * Format your hard drive? / \ * Allow SQL injection on the public internet? / \___________________________________________________/
W... T... F. I hadn't looked at the source, but I do have a lot of respect for the author, so I'm a bit disappointed he just slammed this into an ordinary namespace.
Not the generation that writes Perl.
What's the difference between this module and any other module that builds and tests successfully but is of no value to you?
The intent. Modules outside of Acme:: are usually intended to be of some use to someone, even if it is only one person. Modules may not actually reach that goal and that person may not be me, but the intent is there and I would like to help with that. This module just plain lacks the intent. (Yes, you might want to nitpick my words and argue semantics. If you feel the need to do *that*, please just don't. I am being curt and intend the obvious meaning, not the all-encompassing one.)
&gt; This module just plain lacks the intent. I guess I just don't see a problem here, even if it has no intent of being "useful".
The problem is *time*. I run two smokers on windows and i've never seen them actually catch up with CPAN. (I only saw that happen when i had a single smoker running.) I had to jump hoops to get them to actually smoke new modules from time to time and i'm still busy jumping hoops to fix brokenness in CPAN.pm to be able to stop them from spinning their wheels needlessly. Modules that are meant to be useless, but do not allow me to filter them easily waste time and that is a problem not really for me, but for all the people who try to create useful things and need on smoke reports. I hope this makes at least a bit of sense. :)
I just bought the book from Amazon. :B
For the rest, just head over to irc.perl.org
If you made `@currency` into a hash, you wouldn't have to loop over its elements to find a match *and* you would trivially be able to determine whether the user input were a currency you knew how to handle. Then again, you already have all of that data as the keys of `%rates`, so you only need `@currency` in your output. You can generate it as `my @currency = keys %rates;`.
As mr_chomatic points out, this isn't the best way to do this in Perl. Here's a more Perlish version: #!/usr/bin/perl my ($from, $to, $amount); my %rates = ( pounds =&gt; 1, dollars =&gt; 1.6, marks =&gt; 3.0, "french francs" =&gt; 10.0, yen =&gt; 174.8, "swiss francs" =&gt; 2.43, drachma =&gt; 492.3, euro =&gt; 1.5, ); my $currencies = join ', ', sort keys %rates; do { print "Enter your starting currency (choose one: $currencies): \n"; $from = &lt;STDIN&gt;; chomp $from; } until $rates{$from}; do { print "\nEnter your target currency (choose one: $currencies): \n"; $to = &lt;STDIN&gt;; chomp $to; } until $rates{$to}; do { print "\nPlease enter your amount (numeric values only): \n"; $amount = &lt;STDIN&gt;; chomp $amount; } until $amount =~ /^\d+$/; $rate = $rates{$to} / $rates{$from}; print "$amount $from is ", $amount*$rate, " $to.\n";
One of the biggest problems with perl 5.8 is that its regex engine is recursive, and can cause perl to segfault when matching a too long string. This is a real problem if you use regexes to parse any user-entered data (and what else would you use in Perl?). So if you pass a long URL to a web framework which uses regexes for routes, you have to be very careful to keep it from segfaulting. (This was why Mojolicious deprecated support for 5.8 recently). Then there a lot of nice features (//, //=, say(), \K in regexes) in 5.10, and some major speedups like trie optimizations for alternations of literal strings in regexes. As a "consumer" you should really move away from 5.8 because it is no longer supported by p5p. Bugs won't get fixed.
Thanks, Reddit, for being good sports with my Digg-esque bad ascii art.
Yup, that's much better. Saves me having to comment.
&lt;3 &lt;3 &lt;3 &lt;3 This is awesome! A few concepts are a bit above my head (haven't really delved into regexes yet), but this explains so much. Thanks!!
So this is like pythons virtual environments cool!
yes. It is a similar tool to virtualenv for python, or rvm for ruby. 
&gt; I'm also pretty sure that there would be the new ones if we try to use a hundred mysql installations (one per host) instead of one. That's why i was suggesting to prepare an rpm (or whatever) package with the settings tuned to what you need and all the necessary steps done during install. Also, please, not MySQL, it's the PHP of databases. :( &gt; you are still answering the wrong question. &gt; it definitely doesn't solve my task in the simplest way, so I won't be able to look at its code and learn. You're right, i wasn't saying it's the simplest or that you could learn programming concurrency from it. I was saying it'd solve the problem of how to log concurrently with the least work necessary, making your time free to work on other problems. If you have no other important problems that you'd rather spend time solving then my advice is of course completely wrong. :) &gt; Also (surprise!) it relies on files, too. I was wondering if someone'd pick up on that. :D Yes, it uses files, but not as a the primary mechanism. For databases files are only backups to be used when there's not enough memory, or when the database needs to go down. The actual storage is in memory. ;) Either way, your situation is complex and i may be ignorant about important aspects of it and a bit stubborn too. I look forward to hearing what your solution ended up being no matter what it is. :)
Hey, great looking website! I'm going to have to remember to link to that when I'm talking about perlbrew, rather than p3rl.org/perlbrew [like I do now](http://www.reddit.com/r/programming/comments/h92t7/using_rvm_for_ruby_and_virtualenv_for_python_and/c1tluaj)
Heh. I actually use [pythonbrew](https://github.com/utahta/pythonbrew) rather than virtualenv for Python. [My life has never been simpler](http://oylenshpeegul.typepad.com/blog/2011/02/what-no-new-version-of-ruby.html)!
This is the best Perl module of all time! OF ALL TIME! [Edit: downvote? seriously? It's a joke, man!]
Can you elaborate on the Intel TBB library? Be gentle because I'm not even done with the Llama book yet. Is it a module? On CPAN? Pre-installed on Macs?
The article is now just a link farm page. Anyone have a mirror?
Look up something related to the job for which you're applying, or their industry.
All over it, but I'm also interested in understanding the range of what CPAN has to offer.
Name it. Any problem that someone has solved with Perl probably has something to deal with it. Personally, I've put code on CPAN for handling library book data formats, testing Perl code, searching source code and scraping web pages, but there are zillions of others as well.
Take a look at the descriptions of 1. Devel::NYTProf - Profiling, 1. Text::CSV - Handling CSV Files 1. File::Spec (or better, Path::Class) - For file handling 1. Scalar::Util, List::Util, Regex::Common - For freq. used scalar and list operations and regular expressions. 1. Smart::Comments - For more helpful comments during debugging. 1. Perl::Critic - To analyze and critique your code for best practices. 1. PerlTidy - Not a module, it's a script to format and tidy up your code. Then there are the usual heavyweights: CGI, DBI, WWW:Mechanize, HTML::Treebuilder et al. You'll get to know about them when you need them. In any case, the best module is one that gets your work done, just be aware of the options out there. As a rule of thumb, before you do something think if someone else might have needed to do it too, and if the answer is yes, search CPAN.
Task::Kensho is a good collection of modules to get you started. If you continue doing Perl development, at some point you will probably want to use a good number of these modules: http://search.cpan.org/~apeiron/Task-Kensho-0.31/lib/Task/Kensho.pm
see also Task::
ACME::Dot!
In no particular order: Moose POE DBI Devel::REPL List::Util List::Moreutils List::Compare Log::Log4perl Memoize Regexp::Common WWW::Mechanize 
Thanks a lot! Some of those solve problems I was thinking about (smart::comments)
Acme::EyeDrops Moose LibXML Catalyst 
I interview a lot of people for Perl positions. I recommend: - Moose - DBIx::Class - Catalyst - Plack - Test::More - WWW::Mechanize Which is the standard web stack.
I get a 404
It is not really perl thing. It is more of a C++ thing. This guy has wrapped it for use with perl. If you're not doing scientific computing or writing servers I wouldn't worry about it. It's for doing a certain kind of concurrency. 'fork' will take you very far before you need something like this.
Thanks! I'll look into it.
Yay, new syntax we can use to prevent code from compiling on older Perls. 5.12 gave us "package NAME VERSION", now we have "package NAME [version] {...}"
5.10 is already not supported? Wow, I have to update. Great job Perl developers! Edit: This was not sarcasm and I did not mean to be bitter. I was genuinely surprised that 5.10 is not supported already, and I was enthused at this new release. I assume my 9 downvoters did not grasp this.
&gt; Wow, I have to update. Updating every six stable releases seems reasonable.
I have to admit being a little confused by recent version numbers. 5.10 was huge. 5.12 and 5.14 seem like relatively minor increments, considering how historically 5.8 chugged along for ages.
Releases are not done by content anymore, but by calendar.
Indeed it does. Hopefully this has a ripple effect as the releases come out. This being "upgrades in the field".
My $work is still stuck on 5.8.8 (5.8.5 on some production boxes!) :( :(
Don't worry, it'll all catastrophically fail one day as a result and you'll get your chance to upgrade it. Just brush up on perlbrew before it happens.
I am curious. What happens when Perl 5 hits the last number in its series when Perl 6 is already taken? Does it just to Perl 7? Does it start taking a date like "Perl 5 20110514"? 
&gt; $self-&gt;state( 'FETCHED' ); On a tangential note... using strings as magical values like this is an accident waiting to happen. If `'FETCHED'` has a special meaning then it should be defined as a package constant, like so: use constant { FETCHED =&gt; 'FETCHED' }; Or if you have a bunch of them and you're particularly lazy (like me), you can let [Badger::Class](http://badgerpower.com/docs/Badger/Class.html#section_words) relieve you of some typing. e.g. use Badger::Class words =&gt; 'FETCHED FAILED FARTED`; Within the package you can use these constants directly. $self-&gt;state( FETCHED ); Not only does this save typing a couple of quote characters, but more importantly, it ensures you get a warning if you accidentally mis-spell the word. $self-&gt;state( FELCHED ); # compile time warning Outside of the package, you can call it as an object/class method to return the "magical" string value. if ($object-&gt;state eq $object-&gt;FETCHED) { ... } This will give you a runtime warning in the case of typo accidents (not as good as a compile time warning, but still better than nothing, which is what you get when you're using strings). More philosophically, it provides a better encapsulation of the module. You could, in theory at least, change the value of `FETCHED` to be some other string constant and your code would continue to work (whether or not that would be advisable in practice is a different matter). That said, in the above example I would probably also add an `is_FETCHED` method to hide the messy detail of the string comparison (I might want to switch to using numerical constants instead of strings at some later date). sub is_FETCHED { shift-&gt;status eq FETCHED; } A little tedious perhaps (unless you have your favourite class meta-programming module create the methods for you), but worth it in the long run, IMHO. (with apologies to chromatic for picking on an element of his code that he wasn't writing about) 
I think Perl 5 doesn't care what the second version number is. It could go up to Perl 5.98, then 5.100, 5.102, 5.104, etc.
Ah...ok.
Urm, yeah... a *lot* of Linux distros still use perl 5.8 as the core version.
Well, CentOS is the only significant distribution left on it. And that should change when CentOS 6 finally gets released. Lots of people don't upgrade though.
The entire application is one big state machine. When I formalize the states and their transitions, I'll probably extract them into a single place and use some sort of database enumeration to manage their names. I've considered extracting behavior specific to specific stages into roles applied at runtime (what Moose calls "traits"), but there's a cuteness barrier I haven't yet decided to vault. Hiding state checks behind methods (`$obj-&gt;is_valid`) *does* work nicely though.
* [Try::Tiny](http://search.cpan.org/dist/Try-Tiny) - a small and robust try/catch implementation * [Ouch](http://search.cpan.org/dist/Ouch) - a small exception object that works well w/ Try::Tiny * [IO::All](http://search.cpan.org/dist/IO-All) - this provides the most concise API for doing file i/o I have ever seen. * [AnyEvent](http://search.cpan.org/dist/AnyEvent) - this gives you the most concise API for doing event-based programming in Perl. Also, if you code to this API, your code will be portable to many different event loops which AnyEvent has drivers for. * [Coro](http://search.cpan.org/dist/Coro) - Whenever I use AnyEvent, I also use Coro to give me coroutines. AnyEvent and Coro work well together. * [Data::Dump](http://search.cpan.org/dist/Data-Dump) - its output is formatted better than Data::Dumper. * [Devel::Declare](http://search.cpan.org/dist/Devel-Declare) - this is about as close to lisp macros a non-lisp language will ever get. I've never done anything custom with Devel::Declare, but I have used: * [Method::Signatures::Simple](http://search.cpan.org/dist/Method-Signatures-Simple) - new syntax for declaring method parameters * [Function::Parameters](http://search.cpan.org/dist/Function-Parameters) - new syntax for declaring subroutine parameters * [MooseX::Declare](http://search.cpan.org/dist/MooseX-Declare) - new syntax for defining Moose classes 
One very recent module that I like is: * [Data::Object](http://search.cpan.org/~fried/Data-Object/) - It lets you access nested data structures using method notation rather than chaining a whole bunch of {}-&gt;[]-&gt;{} together. It's a little easier on the eyes and fingers at the expense of being slower to execute.
No one has mentioned the venerable [LWP](http://search.cpan.org/~gaas/libwww-perl-6.02/), yet. It is the workhorse behind many web scrapers. The thing that impressed me about it recently was that it was architected with enough foresight so that when something like AnyEvent and Coro came around, someone could write [LWP::Protocol::Coro::http](http://search.cpan.org/~ikegami/LWP-Protocol-Coro-http/) and make LWP-based code work well with AnyEvent and Coro.
Version numbers in Perl are usually in this format: x.yyy.zzz This means that Perl 5 can go up to 999.
Why not link directly to the source?
He wants traffic to his blog, perhaps.
That time is still here. 
The only people who are ashamed to use any tool in the programmers tool belt are posers. The same people who use a screwdriver to hammer a nail.
I'd unfortunately contest otherwise. We use perl as our primary development language at work but when I go to meetups or confs and the question comes up about what language do you develop in I get alot of strange looks and questions about why we are using such old technology.
What's so hard about telling them that Perl is anything but old? I know most Perl programmers like being nice, but if you don't disagree with people they're unlikely to learn new things.
http://www.youtube.com/watch?v=JLMd0tIVWKU As Zefram presented at YAPC::EU 2010, these years a 79 cols x 23 lines useful Perl script is all the rage. One-liners are so last century.
Try offsetting that by going to a local Perl mongers meeting then :)
I honestly do not remember ever being ashamed of Perl nor have i ever observed anyone else being ashamed about it.
For those of you that don't remember, until circa 1997, programs that implemented 'strong' cryptography were considered munitions and were illegal to export, i.e. let people outside the US download. I guess the logic was we didn't want our enemies to have this vital technology, but that was completely silly because you could freely send a book that contained a description of how to write the code but you couldn't actually send code. At one point near the beginning of its existence, to get PGP disseminated worldwide I believe Phil Zimmerman had to print out his source code on paper and mail it to someone in Europe who scanned, OCRd, and then compiled it and put the binaries on a ftp site. So for example when you went to download Netscape Navigator there would be a version labeled 'domestic' that could do 128 bit SSL and a version labeled 'export' that could only do 40 or 56 bit. If I recall correctly this also hampered e-commerce as it was known that 56 bit RC4 was terrible security but you couldn't assume that users had a browser capable of more. Eventually the bureaucrats got their heads out of their asses and realized what a ridiculous farce this was, but prior to that we had to put up with it. So this email signature was a way to thumb your nose at authority by including a program capable of 'strong' crypto at the bottom of every email or Usenet post that you made. A similar thing happened with the DVD encryption algorithm CSS, as the DMCA categorized tools that could bypass CSS as illegal so you had people writing tiny CSS decrypters and putting them on shirts and mousepads and the like to thumb their noses at authority for wearing illegal code. 
That actually doesn't answer the question. Does their asking make you feel ashamed you used Perl? I hope not. Perl is an awesome language and it is getting better with every release.
Perl was my first language. Though I haven't used it in years, I'll always have respect for it. The shit you could accomplish back then (late 90's) with just a few lines of Perl felt god-like; particularly in the hands of a sys admin. Perl made me a programmer; literally. I learned it to help my admin duties, but ended up changing careers.... Now I write .NET blah blbbblbhalblah, with gobs and gobs of frameworks and bullshit programming patterns.... a hollow, sell-out. All of the sudden I miss those Perl days. 
Who's ashamed of perl now?
Our local PM has been dead for a number of years, RIP Brisbane.PM
Definitely not ashamed, but I do feel like a bit of an evangelist preaching the good book of perl to the masses. 
No problem at all with explaining the benefits of perl to people, I've gotten rather rehearsed at it and will put it up against any other language in use, it's just unfortunate that perl is a dirty word to the uninitiated who associate it with unreadable code and bad design practices.
It's never too late to enjoy perl.
I've been programming since the 80s and spent the 90s in C/C++ and then Java. I'm finally learning perl. It's great.
"When was the last time your gcc was updated?" "5.14 was released last week."
WTF! I promote Perl everywhere. Its an awesome language.
IOW, people who tried learning Perl, gave up, and labeled it bad?
Cascading Style Sheets?
That's a completely unrelated CSS. [Content Scramble System](http://en.wikipedia.org/wiki/Content_Scramble_System) is the algorithm used to encrypt DVDs and [DeCSS](http://www.cs.cmu.edu/~dst/DeCSS/Gallery/) was the code that caused the shitstorm. (Check out the [perl code on a tie](http://www.cs.cmu.edu/~dst/DeCSS/Gallery/qrpff-tie-huge.gif).) 
I figured it was unrelated. Thanks for the explanation and the links.
I went through Basic, Pascal, C++ and now have been using Perl for 10 years. It's great :-) I'm still learning new things. CPAN is gold. The language itself is very forgiving with the little things, that makes development time shorter. I benefit enormously from the use of lists, hashes and regexes.
i shit you not. conversation i had on friday: me: "client provided the data in a list form, i need it converted to pull into two oracle tables.. these two fields to table x, the rest into table y." java dude: take me about 8 hours to write and 4 hrs to qa.. pl sql dude: about 8 hrs.. i'll race java dude for fun.. account manager: i can do that crap in excel in about 6 hrs.. wtf! me/eng manager(perl dude): uhhh... thanks... (completed in 30 min... 15 min was qa).. side note: everyone thought my code was ugly and the output sucked because of the lack of color.. i'll let you guys figure out who had which opinion.. fml
Get into your mental time machine, take a good look at that page, and follow some of the links that are still alive. * Note that there's not one bleep about ugliness. In fact, they seem to be unashamedly reveling in their obfuscated code. * Note that more than one person saw it fit to tattoo this obfuscated code onto their bodies. * Note how playfully they are using their programming knowledge to [implement freedom](http://en.wikipedia.org/wiki/Cypherpunk#Privacy_of_communications). (use Laws::That::Can't::Be::Broken; no [Politics](http://en.wikiquote.org/wiki/Buckminster_Fuller#Grunch_of_Giants_.281983.29);) **What else can we learn from our history?**
I once worked for a large company that needed an internal web application writing. I knocked up a working prototype in a week using Perl, showed it to the department in question, and told them I'd need another 3 weeks to bring it up to production quality and add some of the bells and whistles they wanted. Instead they handed my prototype over to a team of 3 Java programmers and said "Ha ha, look what the old Perl dinosaur made... copy this, but do it in Java because it's so much better than Perl, har har har enterprise framework herpey derpey doo". A year and a half later (after racking up ~4 man years and about £400k) they scrapped the project because the team still hadn't produced a working web app. Partly because they were inexperienced programmers, partly because they chose the wrong language, partly because they kept changing frameworks and widget libraries, partly because management kept interfering, and partly because they spent a significant part of their time in meetings talking about all the fantastic enterprise leverage that they would facilitate when they were done. 
Remember that good feeling, and bring it back. (Thank you for understanding what I wanted to communicate.)
If it's not too much to ask, could you post your code on [gist.github.com](https://gist.github.com/) and link to it on this thread? The task seems straightforward, and I'm curious to see what could possibly be ugly about your solution. Thanks in advance, and if it *is* too much to ask, no worries. It's just that your post made me curious.
 cant share code. hopefully the below gives you an idea. input: data_name_1 single_value data_name_2 single_value data_name_3 multi_value data_name_4 multi_value etc data_name_5 single_value data_name_1 single_value data_name_2 single_value data_name_3 multi_value data_name_4 multi_value etc data_name_5 single_value repeat set X number of times need to: convert to column data: for each multi value create row and repeat all single values.. used a hash to assign all the values as they are recognized then convert the multis to arrays.. loop through accordingly to generate the column/flat file layout tabs and char delims.. some data cleaning along the way.. the usual chomps etc. output something like this: data_name_1, data_name_2, data_name_3, data_name_4, data_name_5 single_value,single_value,single_value,single_value,single_value single_value,single_value,single_value,single_value,single_value
I hope they respected you enough to use your solution. I doubt your solution was actually ugly judging by the way your wrote your description.
Fell in love with this the first time I read it. Makes a lot of sense.
I love Perl, it definitely still has its place in many things I do.
Unrelated, but I was in a training class once where the instructor kept referring to web CSS as "cascading spreadsheets". Drove me crazy, especially as this was a class for using SAS on the web. (Don't use SAS for web stuff. SAS is great in its own way, but it really sucks for web stuff.)
Lack of color? It's just data, where does the color come in? Or is that the Excel person coloring the columns?
Saved for home viewing. Websense blocks the article, says it's "hacking". Stupid Websense.
I use this for every script I write for the command line.
IOW, If the only tool you have is a hammer, everything looks like a nail.
&gt; CPAN is gold. [yes] [yes] ... &gt; The language itself is very forgiving with the little things, that makes development time shorter. I benefit enormously from the use of lists, hashes and regexes. It's still a giant opaque blob to me at the moment, but it's made a lot of things go quickly. All the special variables keep me feeling like a solid mental model for perl will still take some time.
Call me a noob, but I've never seen much need to do anything too "crazy" with switch operators. Comparing one numeric value to a list of possibilities (as in C), or do the same for strings. Regular expressions being the most crazy I ever get. It may be broken when you really push it to its limits, but when are some of these things actually practical to do in real code?
The problem is less in whether they're useful or not. The problem is that the whole thing is massively inconsistent and conflictingly documented. The linked email is just the latest in a whole flood of issues tchrist is uncovering in given. 
Websense is the TSA of the internet. My high school used to block pages that contained the string "p*arse*".
I'll be interested to see how the community at large reacts to this - specifically whether some concerns arise that haven't yet been thought of. Otherwise, this seems like a pretty sane and reasonable plan. This might even make a good template for other large framework teams to follow.
It would have been nice to have some tests that showed examples of where it was broken.
&gt;&gt; CPAN is gold. &gt; [yes] &gt; [yes] &gt; ... Simple remedy: alias cpan="curl -L http://cpanmin.us | perl - " Which will download a minimal zero config cpan client that defaults to auto follow.
After some difficulties, I installed Perl::Critic, bought Pearl Best Practices, and am building a program for critiquing. I think this will really accelerate my learning.
As mentioned, the documentation is inconsistent and conflicting making it hard to figure out what it's meant to do in the first place. Without that knowledge it's hard to formulate meaningful tests/fixes. Tchrist has been busy working these things out on p5p for weeks now. Try looking at the thread list in the linked archive and searching them for "given" if you'd like to see his other threads.
My general experience is that it DWIM, so it would just help me understand the problem if there were concrete examples. It's just a suggestion, I don't understand the issue enough to evaluation the correctness of the rant.
Oh, but it *is* **[hacking](http://en.wikipedia.org/wiki/Hacker_(programmer_subculture\)#History)** in the best sense of that word. Perl is a hacker-friendly language.
What incentives can we give people to NOT give up? What could be compelling enough to make an otherwise neutral person stay? What is missing in the beginner's life?
Nice job. Solid and simple steps. Thanx.
I know that and you know that, but the humorless droids who configure Websense *don't*.
Many moons ago, when I was in a position to write new code and use modern Perl and swoon in how awesome it is, I sat down and actually read about `given` and `when`, and came to the general conclusion, "That's overly complicated, I hope it gets sorted out soon." I also opted to stick with my old standby: for( $foo ) { /test/ &amp;&amp; do { something(); last; }; do { default; stuff; }; } Ugly, verbose, but manages to get the job done without the "what.. the fuck?" bugs.
"massively inconsistent and conflictingly documented" is very different from "basically completely broken". It does what I need it to and I'm glad to have it.
I completely agree. I don't think I've been bitten by any of the bugs, and thus it is in no way "basically completely broken". No need to exaggerate there, OP. (But thanks for the link, it was a very interesting read!)
I have found that trial and error works most of the time when dropping support for something.
CentOS: Behind, Backward, and Proud Of It!
IMO that would be better written as if ( $foo =~ /test/ ){ something(); } else { something_else(); } And if you wanted to use given/when, it'd be: given( $foo ){ when( /test/ ) { something(); } default { something_else(); } }
Can you feel the confidence of the Perl programmers of that era?
&gt; "*Dancing* in the *clouds*" This is probably another Dancer + DotCloud blog post. *Clicks* Yup. Still DotCloud is damned cool, just wish they'd show you how to send a Catalyst app to it at least once.
There are some ex-Perl programmers who have told me in private that they would not start a new project in Perl these days.
[app::perlbrew](http://search.cpan.org/~gugod/App-perlbrew-0.21/lib/App/perlbrew.pm) It allows you to manage multiple perl installations in your $HOME.
I think the best solution in such cases is something like this: print run_child( $ARGV[0] ); sub run_child { local $_ = $_[0]; return fake_run() if /test/; return run(); } Mainly because naming such decision blocks with subs helps make code easy to read. Especially if they become 20 line monstrosities. Now here's where the fun begins. What if i want to use the smart match implicitly? That means: What if i want to replace the if with a when? You can't. It's a syntax error. The only thing you can do is this rather ugly thing: sub run_child { given ( $_[0] ) { when ( /test/ ) { return fake_run(); } default { return run(); } } } Braces ahoy, me mateys!
http://onionstand.blogspot.com/2011/04/catalyst-in-cloud.html
"another", yes ;) http://blogs.perl.org/users/marco_fontani/2011/04/dancing-on-a-cloud-made-of-pearls.html
It's ugly because extracting the sub params is ugly. How about given (shift) in this case?
Uh, this is still ugly as sin: sub run_child { given ( shift ) { when ( /test/ ) { return fake_run(); } default { return run(); } } } when compared to: sub run_child { local $_ = shift; return fake_run() if /test/; return run(); } Though, thanks for pointing out shift. In this case it really is the correct tool.
That's different from shame. I wouldn't start a project in Flash these days, but I'm not ashamed to say I know ActionScript.
Try to find one with a relatively recent version of Perl. Too many seem to use 5.8. I'm tired of writing a script, only to have to go through and replace all my defined-ors when I deploy it somewhere. Edit: And make sure you can install CPAN modules.
Personally i'd go full hog and get a VPS with linode. They start at 20$/month and you've got full root.
I'm loving dotcloud
I don't know if these are the best, but if you just want to get your feet wet, there are some free options here: http://shells.red-pill.eu/ 
Hmm. Considering I've never had a website or used a server before (other than localhost through Apache), I wonder if this might be a little advanced?
nether.net in 1998
It really isn't that hard. Take the plunge. $20. Join the linode IRC chat room. Learn how to ask intelligent questions. You will have all the help you need and you will learn a ton.
If you use something like Dancer/Mojo/Catalyst you can use the development servers you're given with the frameworks to start out with. No need to install a web server. And for things like databases, you only need to google "&lt;linux os you use&gt; mysql install" and you'll find heaps of instructions.
This is what I'm doing, it is very nice setup.
I think in simple cases like this one it doesn't really matter which one you pick.
Started on linode a couple weeks ago. Moved from another VPS host. Linode is pretty damn cool.
Check out dreamhost. Their plans are 10 dollars a month, but are great shared hosting for newbies and advanced users on a budget. You get shell access to linux servers, can install cpan modules into your user folder (a little clunkily, but their wiki has a guide), and when the old version of perl on my machine became incompatible with their SQL servers, they handled it well by migrating my account to a faster server with a newer version of perl installed (transparently, no side effects). If you're just looking to get your feet wet, they are a great because they will scale with you for a while until you need a VPS or cloud-style solution like others were suggesting. I won't taint my recommendation with my referral link. Here's their homepage: http://www.dreamhost.com/
I'm currently in a trial period with dreamhost and am having a heck of a time trying to get DBIx::Class working. I managed to install it in my home directory, along with a couple dependencies, but it's still not working. Just simply won't connect to the mysql database and i'm kinda stumped. Thinking about jumping ship to a host that will install (or has installed) DBIx::Class and all dependencies as root.
So, I had that problem one day with the straight DBI. It turned out that they had changed the SQL servers and perl DBI was unable to support it. I feel like that's less likely if you have a new copy of DBIx::Class, but you might contact their support and see if you are on a server that supports that. Also check the info about your SQL server (the name should be in your control panel). It's possible something is inconsistent, and usually they are good enough to help you out if there is something they can do.
Well, obviously. Use your imagination a bit and stretch that out to a 20 line monstrosity as i originally said. I didn't want to paste huge blobs here on reddit to make a point that's just as obvious with a simple code sample.
I've been out of the hosting biz for about 3 years, but I used to be lead programmer at a host that got bought out by Endurance International Group. Stay away from these guys. They operate [a lot of different brands you might recognize](http://www.webhostingtalk.com/archive/index.php/t-755802.html) (and that list is out of date), and they're all exactly the same with a different face. Their Perl environments are basically non-existent. Sorry I don't have any positive advice, but my negative advice is to stay the crap away from these guys. They're too big for their own good, and they ran my old brand into the ground by slowly pulling back all of the policies that made us stand out. You'll find yourself in a shrinking room.
http://www.rootbsd.net
1. Using whitespace to form your code blocks is awful unless for some reason you miss the days of punchcards. Really, I never looked into it further than that. No language has a feature that is *so awesome* that I'll be OK with abandoning curly braces or something similar.
I visited r/python for the first time today because of your link, and I had no idea their subreddit had ~21K readers versus our ~4K readers.
:(
First pass comprehension maybe? In Perl I know when I see a variable. Python I have to stare at it a bit longer. They are both good languages. Pick the one that fits your brain.
* CPAN with all it's infrastructure * no serious compatibility problems * real variable scope * state variables * easier to detect bad code * Moose * perltidy * less memory used * more readable regexes (qr// and 'x' modifier) 
This is a ridiculous argument. Python code is short, terse and easy to read. Perl, by contrast, is a write-only language.
* **Perl can be poetic.** (For all the flack that Perl gets for unreadability, there was actually a lot of thought that went in to naming to aid readability and poetic flow.) * **Perl is Unix-friendly.** (Beyond its superficial resemblance to shell scripting, it installs files (including man pages) in ways that follow old Unix tradition.) * **Perl has a nice syntax for closures.** (When it comes to closure syntax: Perl &gt; Javascript &gt; Ruby &gt; Python.) * **Perl culture allows for TMTOWTDI.** (This can be a double-edged sword, but I would rather have freedom and take responsibility for it rather than not have it.) 
CPAN. That's it. Really though, if you're going to compare something to perl, ruby is much more like perl in it's language design.
 my $thing; $thing = sub { return $thing; }; But this is almost certainly a bad idea.
I don't like threads like this. Let Python be Python. Let Perl be Perl. Whatever you choose to use, just do good work, and try not to be so tribal. In the grand scheme of things, Python is not an enemy. Python is just another Free, dynamic language, and it just goes to show that TMTOWTDI is inescapable even if you [don't believe in it](http://mail.python.org/pipermail/python-list/2005-November/964100.html). ;) If we believe in TMTOWTDI, we should let them do it their own way and not begrudge them for being different.
It's only write-only if you write shitty perl.
They're working hard, but they're not 'trying' too hard. There is a **natural grace** to their tone and attitude. They're relaxed. They're not at all defensive, and they're totally self-assured.
Is there any particular reason why your suggestion is a bad idea other than the whole scenario being a bit contrived? Edit: By the way, thank you. Implemented your suggestion and it works!
I hate to be the one posting "This", but I wish I could upvote you twice.
Well, it creates a circular reference, so the $thing sub won't ever get garbage collected. At least, I don't think it will. But mostly yeah, it's a bit contrived.
Try copy/pasting python code. If it messes with the whitespaces, as copy/pasting often do, it becomes _impossible_ to be sure what the code was. Relying in whitespace to code is a retarded idea. Why don't you go for [this language](http://en.wikipedia.org/wiki/Whitespace_programming_language) already?
Is there a way to address the circular reference? Maybe provide a way for it to be cleaned up properly?
I've been learning perl for the last few weeks (I was writing Python before) and I have this input. Perl is a dead language. A poor language that is absolutely *nothing* more than a better bash. The most trivial of applications are a cluster fuck of unreadable code in perl. 1. You can't specify arguments to functions so I can put `shift` anyway in the code and make an undocumented parameter magically appear. That's underreadable, unmaintainable shit. 2. It has a few native datatypes...scalar, list, reference, hash etc in order to downplay the fact that the datatypes are handled behind the scenes. Similar things have been done in php, visual basic, and Python, with success....but perl is broken so you're forced to specify a datatype everytime you use it. For example...to pass two arrays to an function I must turn them into scalar references. Then I have to specify their type when I extract them with this like this: `my @arr = @{ $_[1] };`. That's more unreadable shit. Remember I'm talking about working with a fucking array and a function. Perl code doesn't scale past that without become stupidly complex. Other languages have dropped the bullshit to push forward best practice, to allow you to write code that works with defined data types so you understand the performance (aka. .NET collection classes, Python documentation on it's effeciency) and still allow you to write business logic which is readable. Perl has failed to achieve this. Perl developers say `use strict` and things to force variable declaration but what's the point when I could use an array like $arr and pull out it's size. It's just confusing....but more than that.... it's needlessly confusing...and the Perl community are defending something that's ugly and unmanageable. If Perl break backwards compatibility there is no reason for someone to use it...hense Perl 6 forever being unfinished. Perl is around just because it was useful at one point in the past, that is as a glue language for Unix. The syntax `$output = \`program args\`` is great and so is the regex syntax. But you fucked the rest of it, from OO to newer data types and as a result, the drawbacks outway the good. I question why people choose to use such a language in this day and age for non trivial applications and the normal reply is that it was great way back when and the developer who has `years of experience` (and yet hasn't stayed with the latest trends) knows perl well. Perl has nothing to offer in this day and age. It's on its way out. -- This is how I use Python having written code in it professionally for 2.5 years. I've also written .NET code professional for 2 years... Python is a short, terse, readable language. It's got the power of Java and .NET but the syntax is shorter. It uses whitespace rather than braces. I don't need to explicitly define the datatype either so it's shorter. However it isn't taking after Perl. It doesn't have that unreadable interpolation that Perl allows. I can just say var = Object() rather than object var = new Object(). It's just cleaner and shorter. It doesn't force you to write Object Oriented code either. You can write just functions and modules and APIs without having to use the singleton pattern and manage instances everywhere. You can use tuples and dictionaries to make lightweight classes. Everything is quicker, leaner and more easy to read and write. It also has a great community who are interested in new techniques, frameworks, generic programs, scalable code and "just getting things done". They look at other languages, like Ruby, learn, apply, break backwards compatibility if need be. There active and try and fail at things. It's a great community to be a part of and they're bringing good solutions to people.
Flip side of the conversation http://www.reddit.com/r/Python/comments/hee3t/why_is_python_better_than_perl/
 Scalar::Util::weaken($thing) would probably do just fine, if it does indeed create a circular reference. But I'm not positive that it does.
I've used Python for two and half years...I think it's fair to say you're plain wrong.
First question - why? Second question - what are you trying to accomplish? This is doable, but very obfuscated and horrible.
you should reply to OP with that, it deserves to be at the top.
&gt; Perl, by contrast, is a write-only language. If you have a problem reading good Perl perhaps you should find another profession.
Ha ha ha. I can read C, C++, Assembly, Python, .NET, Java, SQL, Prolog, Haskell and all sorts. You aren't going to shake the confidence of someone with 10 years of experience. Perl is a joke.
&gt;I can read C, C++, Assembly, Python, .NET, Java, SQL, Prolog, Haskell and all sorts. You aren't going to shake the confidence of someone with 10 years of experience. As long as we're walking the 'years of experience' dog around here now, I figure I'll do the same. I've written software that's in operations in outer space in C/C++/assembly, written code in every modern popular scripting language, and maintained operations systems for mission critical systems. I'm weighing in at around 16 years of experience in software and know anyone worth a shit will tell you the same thing. Every language has it's appropriate application. To declare one shit 'just because' shows your insecurities, not how bad the language is. You aren't going to shake someone with much more experience than you. GTFO with that nonsense. &gt; Perl is a joke. Gotcha. Having a massive repository of pre-packaged modules to do pretty much anything you want is certainly a joke. Idiot.
&gt; Every language has it's appropriate application That *was* true of Perl. Now it isn't. People's failure to move on shows there aren't truly interested in writing the best possible software they can. &gt; To declare one shit 'just because' shows your insecurities, not how bad the language is. There is another reply on this thread where I justify the reasons why Perl is crap.
&gt; I've been learning perl for the **last few weeks** (I was writing Python before) and I have this input. And now it's fairly clear as to why your comments on Perl thus far are so short sided.
&gt; People's failure to move on shows there aren't truly interested in writing the best possible software they can. This has absolutely nothing to do with my last reply. Have you looked into any of the modern perl extensions since you're so interested in 'moving on'? I bet not. Perl is great because you can either hack shit out super quick OR create well documented, fantastically maintainable, fast code. It's readable, ridiculously scalable and easy to use. I'll refrain from Python bashing because I haven't used the language long enough to evaluate it. &gt; There is another reply on this thread where I justify the reasons why Perl is crap. I saw that. You've been *using* it for two weeks. You cannot evaluate a languages potential in all possible applications in a matter of *fucking weeks*. Get over yourself.
Reddit is written in Python, no big surprise there. https://github.com/reddit/reddit
Thanks, but I'm sure he'll see it regardless of its position.
&gt; They look at other languages, like Ruby Funnily enough in this context, Ruby is basically a love declaration to Perl and has drawn most of itself from Perl.
This is so wrong, ignorant and misinformed I don't even know where to begin.
Speak for yourself. I have no problem reading Perl.
It reminds me of prepubescent children who dismiss something because they tried it once and didn't like it, e.g., brocolli. *Brocolli is a dead vegetable.*
It does create a circular reference, but not the kind that weaken will help with. The reference is via lexical closure -- the anonymous sub holds a reference to `$thing` because it closes over it, and `$thing` holds a reference to the anonymous sub. Doing use Scalar::Util 'weaken'; my $thing; $thing = sub { return $thing }; weaken $thing; causes `$thing` to become `undef` right at the `weaken` line before you can ever use it, and use Scalar::Util 'weaken'; my $thing; $thing = sub { weaken $thing; return $thing }; does nothing useful whatsoever (there's still a circular reference because the problem isn't with the reference that the sub returns but the one it closes over).
You forgot to bless it, but that's trivial: my $thing; $thing = bless sub { return $thing }, "SomeClass"; 
You should read [Higher Order Perl](http://hop.perl.plover.com/), it's a great book that includes some of this kind of stuff. There's a free PDF right on that page, but HOP is a book that's much more suited to reading on paper.
So... Is it a problem, per se? Like if the variable that holds the blessed coderef I created goes out of scope or is undef'ed... Will the coderef still refer to the variable it closed over, SOMEWHERE?! Dun dun dun...
Yes, that's the point.
Is there a way to accomplish what I want without a circular reference?
Here, I upvoted for you.
I hadn't considered that aspect before. Still, I think the Python has much more momentum at this stage. Google trends shows Python ahead... In SF, there are way more people at Python user group meetups than the SF Perl group... The other problem is there are so many bad Perl programmers that you invariably end up working on some horrible code. I'll probably start doing new projects in Python after 11 years using Perl.
It really hadn't occurred to me that you could bless a code reference. Is there an example of this being especially useful? I'm trying to think of one but I'm drunk.
This isn't an [an XY problem](http://www.perlmonks.org/index.pl?node_id=542341), is it?
python is a perfectly suitable, high performance scripting language that is totally boring
agreed. unlike ruby, python isn't trying to take perl and soften certain parts python people have a different idea about programming languages and they aren't trying to make a perl-alike...kudos to them
so what? both communities are big enough to sustain themselves
Whoa, guys, hold on. He has been using Python for *two and a half years*. The experience he gained from his time writing in The Holy Language clearly gives him more than enough gravity to speak The Truth.
The manual way to allow a circular reference to be garbage collected is to break the cycle when you're done with it. Something like: $thing = undef;
&gt; He has been using Python for *two and a half years*. ... but has never copied/cut and pasted code?
You think you're being witty and smart but all you do is dance around the fact that you won't take a critical eye to your own programming language. That no Perl developer will. Seriously no Perl developer is willing to say: a) Perl 5 is backwards compatible and contains things that make it ugly b) We bought out Perl 6 because Perl 5 wasn't perfect. The only arguments I get are 'I still use it', 'it isn't as bad as you think'. spoken by mindless fucking hacks who think they can hide behind the "All programming languages are good for one thing" arguments.
While python may be [growing faster](http://www.indeed.com/jobtrends?q=perl%2C+python&amp;l=&amp;relative=1), Perl still has [twice as many job offers](http://www.indeed.com/jobtrends?q=perl%2C+python&amp;l=). (Note that the scale of these graphs is 5 years.)
All variables are objects in python, hence why there is no distinction. 
Not in the bay area, and not if you don't count QA or Sys-Admin jobs...
That doesn't matter to me when I am just reading the code to figure out what it does. I have to mentally stop and make sure something is a variable or not. I don't do that with Perl. Once again, use the one that fits your brain better. They are both good languages.
You've been downvoted to oblivion in both r/python and r/perl for your ignorant and childish interpretation of Perl. Why do you continue to blather on when it's clear everyone in both communities thinks you're full of shit? &gt; The only arguments I get are 'I still use it', 'it isn't as bad as you think'. spoken by mindless fucking hacks who think they can hide behind the "All programming languages are good for one thing" arguments. Again you are in no place to evaluate a language you've been using for **two weeks**. You've not checked out any of the resources which make coding modern perl awesome, nor have you even touched CPAN, yet you continue to blather on about how Perl is shit. I'd really hate to have an employee like you.
No, I don't think so.
... you would prefer a $ in front of every single thing? How would that help? I get it for languages that have literals or at least a strict separation of definitions and instances, but for python it makes no sense. 
perl is poetic with namning variables.... all fifty of them 
&gt; Seriously no Perl developer is willing to say.... Well I'm not *Scottish*, but....
All sigzero is saying is that the variables in perl are very easy to discern as they are explicitly prepended with a sigil. You are acting very defensive even though sigzero admits both languages are good. S/he thinks they both fit different brain styles, and I agree.
I used cpan two days ago to install YAML and Perl::Critic. I was going to install Moose today, when I noticed this. Should I change it back? I tried using cpan5.10.0, but it fails because permission is denied to ~/.cpan/FTPstats.yml too.
I struggle with this all the time. I am not an expert but from what I've gathered it can sometimes be an issue with the latest release or, more frequently, some permissions on your machine are screwed up. I don't touch anything on cpan without going back to my disk utility, repairing permissions, and then rebooting (but that's probably an outgrowth of my own ignorance more than on anyone else's part). Techniques I've tried in the past: * just type "sudo" before everything. I have no idea what this does and it's probably dangerous but I'm a shoot first ask questions later kinda guy (and "sudo" sorta reminds me of "sumo", which is something I am comfortable with). * repair permissions on your hard drive if you're an OS X user. This is kinda my ace in the hole, if aces were deuces and didn't do shit. * update CPAN. File this under "solutions to problems you need to solve before you can use said solution". * install cpanm and use the cpanm command to install the module. May not work, but there's always a chance you get a completely different error, which keeps things spicy and unpredictable...
The article: &gt; I hacked jslinux, so I injected Perl5 binary to jslinux!! You can run Perl5 on browser!!!!!!!!!!!!!!!!!!!!!11111
I also agree both languages are good and that it depends on what your brain is used to, my point is that it's not about the symbols being there or not, it's about the language design behind the syntax. Saying the lack of symbols makes it hard to read is like saying you don't like riding a bike because it doesn't have a airbags. It's not *supposed* to be a car :p
There are bad parts of Perl. I won't even try that. But it's clear that you don't understand Perl thoroughly enough to make real criticisms of the language. Yes. The object system is annoying, and there's a lot of boilerplate code required to use vanilla Perl objects. But with all this boilerplate, you get a lot of flexibility. So much flexibility, that it becomes trivial to write your own object system on top of the existing one. The biggest gripe I have with Perl are all of the functions polluting the main:: namespace, as well as all of the functions that feel the need to modify variables in place. Perl can be a very ugly language if the person writing it is unfamiliar with modern Perl concepts and techniques. Perl can be very ugly if people don't use strict, warnings, or require a newer version of Perl. But it can also be so, so beautiful and so useful. Thanks to POE, I was able to throw together a very extensible score bot for a hacking competition in an afternoon. It's shit like that that keeps me coming back to Perl. Also the fabulous community.
Err, I think sigzero, and myself, are saying that it *is* the sigil that makes it easier to read. They make the variable stand out from the rest of the code.
Worst case scenario: just rm -rf ~/.cpan It's a minor inconvenience, but it won't break anything.
And now we have gone in a circle... 
&gt; The biggest gripe I have with Perl... Reference syntax! (partially improved in 5.14)
&gt; you won't take a critical eye to your own programming language. That no Perl developer will. Bullshit. I can even prove that you're as wrong as you could possibly be: http://blogs.perl.org/users/ovid/2011/04/ch-ch-ch-ch-changes.html That blog entry is FULL of perl developers harping on problems with the language. Also, i DARE you to try and make a .self post here on perl reddit and ask "What parts of perl do you think are terrible?" I guarantee you you will get at least ten responses detailing gripes perl programmers have with the language.
If you've done some programming before -- or if you know a little bit about Unix culture, especially from the command line -- you may appreciate my book [Modern Perl](http://onyxneon.com/books/modern_perl/index.html). It attempts to teach *how* Perl 5 works and how to use it productively. All electronic versions of the books are free and freely redistributable.
There is a background process on OSX that goes around "fixing" various permissions for you. However, you shouldn't be installing cpan modules into your system perl anyway. Install a new perl into /usr/local, and switch to that one as your primary.
&gt; just type "sudo" before everything. I have no idea what this does and it's probably dangerous If you don't know what it does, you shouldn't be using it. 'sudo' runs the command under the root user (and with root permissions), which means it can alter any information on your computer at all, including vital system resources. Don't muck with anything under /usr/bin or /usr/lib, including perl. Install a new perl and mess around with that one.
If you have some programming experience I'd strongly suggest [Learning Perl the Hard Way](http://greenteapress.com/perl/). Take a look at it and see if you're comfortable with it. Other than that, perldoc is your friend. It also has an excellent and accesible [intro](http://perldoc.perl.org/perlintro.html) to perl for beginners. Once you are comfortable with that, you can take a look at the more specific [tutorials.](http://perldoc.perl.org/index-tutorials.html) 
Are those symlinks? On my Linux systems those 807-byte files all are, maybe you just have a braindead `ls`.
http://learn.perl.org/
1. Don't install CPAN modules into your system's @INC. If you *must*, use `sudo cpan ...` instead. 2. Use `local::lib` to maintain your CPAN modules in your users' directories.
http://perldoc.perl.org/perltoot.html http://perldoc.perl.org/index-language.html Seriously. Read it all over and over again, noone gets it the first 100 times through.
Not as far as I'm aware.
++ ! Modern Perl is a great book.
Something like this? wget http://www.cpan.org/src/perl-5.14.0.tar.gz tar -xzf perl-5.14.0.tar. cd perl-5.14.0 ./Configure -des -Dprefix=/usr/local make make test make install 
I wish I had more than a fuzzy idea of what you'er talking about. As it stands, I don't think I'd know how to follow your advice. I installed 5.14 in ~/localperl/bin. Should I add this directory to my $PATH variable? 
`local::lib` is a CPAN module that allows you to install and maintain your own, per-use, `lib/` for your perl installation, while gracefully falling back to system libraries. It does this by doing a whole bunch of fucking with your environment, `@INC`, and `PERL5LIB`, etc. The doc page: [http://search.cpan.org/dist/local-lib/lib/local/lib.pm](http://search.cpan.org/dist/local-lib/lib/local/lib.pm)
Go with either a your own perl build installed in your home directory *or* local::lib. Doing both is probably redundant. Use perlbrew if you want to have a newer version of perl installed in your home directory. Just make sure you're using the "~/perlbuild/bin/cpan" executable and not they system one when you install stuff. In other words make sure your home directory perl executables come first in your $PATH. Then your modules will get installed in "~/localperl" (actually something like ~/perlbrew/blah). If your system perl is modern enough for your needs I just suggest using local::lib to keep only modules in your home directory. I have a little shell script to set up everything I truly use with local::lib. If install a lot of stuff willy nilly while testing out modules then I can just blow away ~/perl5, run my script, and I'm back to the slimmer set of modules I need, all up to date. ## cpanm cd /tmp curl -O https://github.com/miyagawa/cpanminus/raw/master/cpanm chmod +x cpanm ./cpanm local::lib ./cpanm App::cpanminus cd ~ ## add this to bashrc if not already there eval $(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib) cpanm App::cpanoutdated cpanm App::Ack cpanm DBD::Pg cpanm Fey::ORM cpanm Fey::Loader::Pg cpanm Dancer::Template::Mason2 cpanm Dancer::Session::Cookie # etc... 
Author appears to be East Asian (Japanese?). So the Engrish is basically expected. --- That being said, that is damned cool.
http://perlmeme.org/
Well, for half that price ($9.99/mo) you can go with a VPS from Pinellas hosting. All things considered, that's not much more than shared hosting is going to cost you, and you'll have full root access to your own box. My experience with Pinellas has shown some light, intermittent downtime, but no worse than any shared host I've ever used, plus their support replies are prompt, in clear English, and directly from the guys addressing the problems. [Pinellas Hosting](http://www.pinellashosting.com/) Might seem overwhelming at first to dive into a VPS, particularly if you haven't had any admin experience, but this is a great way to learn. The limitations of shared hosting rear their ugly face sooner than you'd like once you get started, and at this price you can't really lose. I'd be more than willing to help you with some tips to get rolling out of the gate if you're interested, too. Let me know!
use perlbrew: http://search.cpan.org/~gugod/App-perlbrew-0.21/lib/App/perlbrew.pm
One day computers will be fast enough that an implementation such as this, both cool, and technically ridiculous, would become the popular and dominant application development platform. Oh wait, that's happened already... with javascript. Further down the rabbit hole we go! Develop a cgi application in microperl running in JSLinux running on Firefox.. ..in Wine.. Under Ubuntu Linux.. ..Running on a Virtual Machine That you've SSH'd to from your Windows XP workstation That you've logged into via RDP.. From your IPAD. ..Emulator/SDK. Running on a Mac.
The "growing faster" part should be all the more reason to not be complacent. Perl could use something magical to capture the hearts of ...our future friends. Where will our **creative** sparks come from?
I can't upvote this enough. **GET [perlbrew](http://www.perlbrew.pl/) and [cpanm](http://search.cpan.org/~miyagawa/App-cpanminus/) ASAP!** 
I mostly like local::lib except that it moved my cpan home (on my mac) to "Application Support" (IIRC, anyways in a directory with spaces in the name). The outcome is many modules won't install because they can't handle the space. I've seen numerous references to the problem, but no clear "fix". How do I move the cpan home back permanently to ~/.cpan without more headaches?
If you're in Arizona, Scott Walters will be giving a class on exactly this topic (Perl &amp;&amp; Bioinformatics) in the very very near future. I believe it will be an extension course at Arizona State University. I'll see if I can find a link for you.
Without trying to sound too harsh, read the docs. &gt; In order to install local::lib into a directory other than the default, you need to specify the name of the directory when you call bootstrap, as follows: &gt; perl Makefile.PL --bootstrap=~/foo
lol.. dam true.. 
perltoot is about the worst place to begin learning perl.
why not perlme.me
Start with book 'Learning Perl', it's great for beginners, even Larry Wall (creator of Perl) recommends it if you're looking for a carefully paced tutorial. 5th edition is from 2008. 
++ upvote. Most online perl tutorials are outdated. Modern Perl fixes that.
http://www.google.com/search?source=ig&amp;hl=en&amp;rlz=&amp;=&amp;q=perl+bioinformatics+tutorial&amp;aq=5&amp;aqi=g10&amp;aql=&amp;oq=perl+bio
Don't be a wuss!
I think that's a bad idea. I work in perl bio informatics and the code i encounter there is some of the worst in existence.
Hot damn. $@ preservation and s/foo/bar/r sound awesome. Too bad I'll be at 5.8 for the foreseeable future. Now if only we can get: sub foo($x,$y,$z) { ... } 
God, I wish I was -- something targeted like that would be ideal. Alas, I live in Washington, DC. Thanks for the thought, though. 
Harsh is OK, I can take it. :) From the docs: &gt; By default local::lib installs itself and the CPAN modules into ~/perl5. Which is what happened, my modules are in ~/perl5, but the cpan configuration file is in "~/Library/Application Support/.cpan" rather than ~/.cpan. So there is something else going on (something to do with the File::HomeDir module?). I'll re-read the docs and try to sort it out. 
The local/lib.pm must been somewhere in your current `@INC`, as listed when you run `perl -V`. Once that's done, you can follow the directions for setting up your environment, which is roughly, put the output of running `perl -I/path/to/lib -Mlocal::lib` in your .bashrc or similar file. The easiest way to do that, of course, would be to just do it over again and point your bootstrap at the right place.
Done. So far, it is awesome. I hope this is the last time I have to install all of these modules. It takes way longer than I expect. Now, what is cpanm in relation to cpan? No more typing "yes" every 5 seconds?
I finally figured this one out and it is great! Glad I got it. This should be the first one anyone gets.
There's still time! http://www.nyas.org/Events/Detail.aspx?cid=47df333c-89cf-45bb-9199-f426c764867f
Go to Perlmonks.org. Its a great community where people are encouraged to help one another and assholes and spammers don't last long. 
&gt;If you don't know what it does, you shouldn't be using it. Hey, I'm pretty sure this is my computer. I bought it and it even says my name when I open up the Finder!
As someone new to Perl, thank you. This book is better than the majority of college programming textbooks I've had to pay $100+ for.
It's a lightweight, module installation tool that requires no configuration and no baby-sitting. I highly recommend it.
Comments seem a better source than the post they are commenting on.
* The for loop having an always-true conditional. First off, the "equivalent" while code would be: my $i = 0; while ( $i++ ){ ... } The declaration and initialization of $i is explicit, and while I prefer this form most of the time, I kinda like the for (my $i = 0 ; 1 ; $i++ ) form. * (?:) Who the fuck *doesn't* know about this?? * Dummy variables Okay, so some people don't realize you can do this: my ($foo, undef, $bar, undef, undef, $baz) = example();
That was a rather bleak post. I think a better way to write cleaner perl code is to read a well known book on Perl. Any general Perl book from O'Reilly would do the trick.
If this is what the writer learned lately, they must have just started programming a week or two ago...
Haha so true! That's the main reason I write my blog posts, to learn from others.
And we wonder why perl has such a negative reputation...
Who is this collective "we" you are referring to? And can you please provide evidence that abrupt people in the perl community are more numerous than those in any other community.
&gt; And can you please provide evidence that abrupt people in the perl community are more numerous than those in any other community. Why does that matter? The original comment was rude and uncalled for even if Perl has the most polite community on the planet.
Because I view philiph's response to it as being equally flippant. I don't see the Perl community as being more or less disrespectful than other communities, rather it was philiph's knee jerk reaction to a possible jerk, which every community has.
Perl has a negative reputation? You mean like *every single language out there* ?
And that being said, you don't have to use undef either, you can do this as well: my ($foo, $bar, $baz) = ( example() )[0,2,5]; Which is actually quite common in POE land, since you do something like this qwuite often: my ($self, $kernel, $heap, @args) = @_[OBJECT, KERNEL, HEAP, ARG0 .. $#_];
Wait, am I the jerk you two are referring to? I sure hope not! :O
Debuggers are fantastic tools. When I was in school no one ever taught us what a debugger was, how to use the debugger, or how helpful the debugger can be. I had to learn it on my own time, granted this was not a bad thing. I did a lot of learning/self teaching outside of the class room. Was this just my experience? or are there any other people that have the same story? Using a debugger is a fairly useful skill. I don't always use a debugger, for whatever language I'm writing in, but when my code it not running the way that I think it is or rather should be, it is nice to be able to step through my code and see what is happening and where it's happening. EDIT: Clarification. 
chromatic *did* [say](http://www.reddit.com/r/perl/comments/hgtvr/some_things_ive_learned_lately_about_writing/c1vbhyl) "The original comment was rude and uncalled for", but I'm not sure he's referring to me. I sure hope not, as I don't really see anything particularly rude about [my first comment](http://www.reddit.com/r/perl/comments/hgtvr/some_things_ive_learned_lately_about_writing/c1vbc8a) :( Edit: formatting, and I think he was actually referring to [philiph](http://www.reddit.com/r/perl/comments/hgtvr/some_things_ive_learned_lately_about_writing/c1vbevh)
I had the same experience - in college I was just taught to use 'printf debugging'. I didn't find out about debuggers for years.
&gt; Who the fuck doesn't know about this?? that's rude, just own it. You see, on the internets, you may write: Who the fuck **doesn't** know about this?? But it will be interpreted as: Who the **FUCK** doesn't know about this?? In meat-space, you can curse and be cute. On the internet, cursing is generally considered rude, particularly while offering otherwise constructive criticism.
Yeah, I sort of learned that on my own too. I can't tell if that was what my professors wanted? or what they expected? I did a lot of `printf` debugging, assertions, and debugging with comments. I gradually became more comfortable with the debugger, but even now I still use a combination of all of those to debug my code. I am some what of an eclectic software developer. That having been said, I rather enjoyed the screencast; very informative. 
Hmm, I've tended to interpret that as the former, which is why I threw it out so casually. /me keeps a mental note.
More than that, there's enough in perlre that it's easy to come across something incredibly useful that you didn't know. Goodness knows that happens to me still sometimes even reading perlfunc.
Learned w/o one also. I think it was the best way to learn. 
Thanks for posting this! Sorry to see you getting flak about it. TIL that you can use "?:" in this way. I've been using Perl for years and I'm sure there are several things I've never learned that would've come in handy one time or another but because the use cases are rare (for what I do) I've never dealt with them. THis is one of them. As they say, there's ten ways to do anything in Perl, and each way will have its staunch defenders. I'm personally in the "make it readable or comment the obscure bits" camp when it comes to any language, especially Perl, sometimes I don't choose the most compact construction available. Next time I run across the need for this sort of thing I'll have an alternative to something more complicated. 
When it comes to powerful scripting languages, Perl *does* get more complaints (and outright aversion) in my experience, due to its tendency towards obscure constructions and weak typing. Contrast that to Python, which is very regimented and structured (though I think the indentation thing borders on absurdity, but that's my preference for C-like syntax showing as well). There are other strengths and weaknesses (Python is a clear winner in terms of Unicode, IMHO) but Perl's flexibility is its greatest weakness. It can easily be a maintenance nightmare for someone new to a given script or library to maintain that code (even if they are a seasoned Perl dev). Its doesn't *have* to be... but all to often it is. That's my two cents on it. Personally Perl gets the job done for me and if I'm careful it's understandable to others trying to parse through my code (with comments as needed), and if I keep in mind the differences between constructions that would seem to be functionally identical but aren't.
Really useful tut. Been writing perl for 12 years and still didn't know how to use the damn thing. Feel ashamed :)
So, you'd be happy speaking to someone in French, Russian, Chinese, or in fact any language that is not your native tongue, since the semantics are pretty close and it's just a syntactical difference?
I like that it talked about cleaning up Perl, and then ignored the official Perl style guidelines (`perlstyle`). :-) 
Good on you for having the balls to put your code out there for public criticism. I hope you learned something.
The real nice part about the perl debugger: It's not written in stone (C), instead it's an actual perl module: DB.pm This means that not only can you mess with the debugger, you can use the things it does to do entirely other things. Devel::NYTProf and Devel::Cover for example make use of that. Another very awesome use is that you can make the debugger communicate not via the command line, but via a network socket, and then write a debugging client that can connect to that. This way you can do things like debugging in your favourite editor, or debugging a script that's running on a server on the other side of the world.
&gt; I'm personally in the "make it readable or comment the obscure bits" camp Very often a comment is just a sub routine name waiting to be set free. ;)
I see what you mean, but I'm thinking about comments that are more descriptive than: ######################### # Sum all the vectors! ######################### sub SumVectors { .... } 
Duck Duck Go uses Perl? No wonder I like it better than Google :P
Ew, you spilled some camel-casing over there... Anyhow, it is amazing how stuff i mention that's most simple in my mind get's misunderstood. I meant stuff like this: sub get_player_vector { # prepare vectors ( 20 lines follow ) ... # sum all the vectors (20 more freaking lines!) ... return $vector; } Some people might call that well-documented code. I call it code in need of refactoring. In that case BOTH of these 20 line blocks really want to be subs and not just commented blobs in your code. :)
That is *awesome*. TIL
I've encountered that before as well. I've always regarded people like that as the mall ninjas of the development community. 
My favourite example: http://www.google.com/#sclient=psy&amp;hl=en&amp;biw=838&amp;bih=874&amp;source=hp&amp;q=%25INC&amp;aq=f&amp;aqi=g5&amp;aql=&amp;oq=&amp;pbx=1&amp;bav=on.2,or.r_gc.r_pw.&amp;fp=3897923a35f9f5e8 https://duckduckgo.com/?q=%25INC
I see what you mean.
There's a [Starting from Scratch](http://perldoc.perl.org/perlmacosx.html#Starting-From-Scratch) section in the `perlmacosx` perldoc file. 
wow, really cool. I am going to start using this for my big projects.
I learned debugging with a different language that had slightly more robust tool. All of the concepts and functionality were the same, but more GUI oriented. One advantage of this is that you could always see the source code. Is there any way to hook the Perl debugger to an external tool. Eclipse, maybe?
You probably don't have to worry about it. If you use your own perl (either compiling manually or perlbrew) then it will use it's own module directories and whatnot, so don't really worry about pooing all over the system perl.
Are your prints firing? Also, using alternate delimiters would make your regex more readable. Instead of s/\\/\//g you can use s?\\?/?g or any of a number of other delimiters.
Thanks for the reply, this is the first time I've touched a piece of perl, and I'm no coder, so I apologise in advance I confuse you with my layman's descriptions... I can get the first print to run, if I take out all the commented lines prior. I then tried adding a print "$arcDir" in various places to see if I can get it dump the folder its working from. I inserted it after every $arcDir = ... line to see if it turns up, no dice. If it put it directly after the first print statement it kills the script because the $arcDir variable does not yet exist. I also tried commenting out the 3 reg exps to see of I could atleast get it to fold so I can see where it gets too... again, no dice.... I hope this answers your question. 
Do you just want an arc extractor, or do you just want this script to run?
I actually want to get into the arc files I have here. My experience is that they are not the same as standard arc files... I have tried a couple of apps (winzip, 7a, winrar) to open them, with no avail. 
I fail to see how using the OS X-provided Perl would "screw up your permissions and all that crap". Unless you are definitely having a permissions-related problem (which people rarely have) then proceed as always.
The problem isn't permissions; it is binary compatibility. Apple (along with many other vendors) has a history of [breaking the system version of Perl](http://www.theregister.co.uk/2009/02/16/apple_update_perl_breakage/) if you install your own modules into it. This is because OS X does not have a proper packaging system, but even Redhat's and Canonical's system Perl can break on update if you install modules into it from CPAN (rather than from their package repos). The proper thing is to use local::lib or roll your own version of Perl (for instance with perlbrew).
DOS vs. Unix line endings?
I didn't look into it too far, but I did see that the line breaks appeared to be expressed as a default null character in other txt/log files I looked at. I shall check tomorrow in more detail and report back. 
The problems sound fairly easy. I would just jump into it and start attempting it. It sounds like they want you to use binary-search in the first problem. I'm curious how you will be tested on this... is this homework assignment?
No, not homework. I actually have a friend who does some development work for different clients and he's convinced that I can pick this stuff up without too much trouble as he's looking for some help. This is his idea of a "see how you like it" quiz. My role's traditionally been in systems administration, and I have absolutely **zero** programming experience. That said, I'm a very quick learner and I feel confident that if I applied myself I'd be able to pick this up. It's really just a question of time... I work 45 hours a week already and go to school for further technical certifications (MCITP.) I think Perl would be a fantastic addition to my toolset, but I don't want to spend 8 hours figuring these problems out if it's going to take me a month to really learn the basics of Perl properly. I have heard that Perl is sysadmin friendly, too. After getting Perl going on my PC last night, I spent about two hours reading tutorials and I'm still pretty bewildered, unfortunately.
[perldoc perlintro](http://perldoc.perl.org/perlintro.html) should help you get up to speed and give you enough basic knowledge to get going with those problems. 
Thanks, I've actually read through that once on my way into work. I think I need to read it again (and maybe then 2 more times) and plug the snippets into an editor to experiment a bit. 
I would read something else meant for someone with no programming experience. That perl intro looks geared more towards people with some programming experience from another language. Try something like this: http://www.perl.org/books/beginning-perl/ And you should try to find a good chunk of a few hours to sit down and devote to learning this. You can't really rush through it as the field of programming brings some new concepts which are quite crucial to grasp early on.
I'd work on a problem that would help you out at work or something you're independently interested in. Perl is great for parsing log files and definitely worth it for doing that unless you're a sed/awk guru already. Related to your first problem, be sure to read up on perl built-in data structures (hashes in particular). Once you've got nested data structures straightened out, there's little you can't do in perl.
How does [Modern Pearl](http://onyxneon.com/books/modern_perl/index.html) fit into this picture?
Regards the array search sub, change the return to undef and leave it zero indexed which is a bit more natural for arrays. Always having to subtract one in order to lay your hands on what you want gets old fast. Not to mention that 0 may not mean what you think it means, but undef does!
By closures, do you mean anonymous functions?
Yes.
Perl is easy to start and hard to master. You'll be able to build useful stuff fairly quickly, but grokking it whole will take years. Meanwhile: Ask questions. Perl is a very interactive language and any perler will love to help another understand new things.
Modern Perl is a book that will give you a bird's eye overview on the language and explains some of the things that are traditionally hard to grok from other resources in very accessible ways. Definitely give it a read, but skip over the things that look like they might go too deep and revisit them later. The entire book is great.
EXPORT_OK could result in a smaller footprint if I understand it correctly--it will only import the code that the user specifies rather than everything in EXPORT. One example of this is POSIX. From [CPAN](http://search.cpan.org/~jesse/perl-5.14.0/ext/POSIX/lib/POSIX.pod): &gt;Everything is exported by default with the exception of any POSIX functions with the same name as a built-in Perl function, such as abs, alarm, rmdir, write, etc.., which will be exported only if you ask for them explicitly. This is an unfortunate backwards compatibility feature. You can stop the exporting by saying use POSIX () and then use the fully qualified names (ie. POSIX::SEEK_END). POSIX is fairly huge, and it just dumps all of itself into whatever imports it. Also, it makes for greater readability so you know where the imported functions are coming from. If you're looking at someone else's code where they've imported a bunch of modules, sometimes you don't know what got imported from where.
I encountered a CPAN module a couple of weeks ago which had a symbol named `new` in `@EXPORT`. Debugging that was not fun.
Suppose package `Foo::Bar` and package `Bar::Baz` both have a function named `process()` which they both put in @EXPORT. Now as a user of their code, I cannot use both modules at the same time without them stepping over each others' toes as both want to insert a function by the same name into the namespace and only one can win. It is possible to get around this by doing things like `use Foo::Bar ();` to force it not to try to export anything, but that should not be necessary. @EXPORT_OK works on the principle that a module should ideally not pollute the global namespace at all, and that users have to ask specifically for what they need. This puts the burden on the user for determining which package wins when both have a function with the same name. This is another reason why it's encouraged to use the object-oriented interface of a module (when available), as this doesn't require any symbol table manipulation. That is, I can access both modules' `process()` functions: my $foo = Foo::Bar-&gt;new; $foo-&gt;process ("foo"); my $bar = Bar::Baz-&gt;new; $bar-&gt;process ("bar"); Edit: I'd like to address this misconception: &gt; requires the user to individually import each variable or function, which requires private knowledge of the module being accessed. Firstly, it does not require naming each individual function. Most modules provide tags like `:all` or `:most` so that users who want everything can get it with one word. Secondly, it does not require private knowledge of the module. The functions available to be exported (and supported tags) are to be listed in the module's documentation, which is part of the public API of a module. This again is another reason why the OO interface is preferred by many, as it doesn't have any of these problems. 
Thank you for the detailed reply. In this case, I'm inheriting something in which variables are in EXPORT_OK, so that's why I was saying that everything has to be individually imported. EXPORT_OK is basically an array of vars in this case, and I don't think the module is a proper module. I'll look for :all or :most, though. Thanks!
That's a good point, thank you for pointint that out!
That's just dumb. Was the author a troll? If the package was named "bridge", then perhaps.
&gt; binary-search No, they want you to use basic string comparisons. A binary search would require a tree structure; this is just hunting through a sorted list until you either find the string you're looking for (in which case you return the index), your search string is less than the element you're looking at (since the list is sorted, you've passed the point where the search string would be found, so return -1), or you fall off the end of the string (return -1). Protip: Use the spaceship operator ( &lt;=&gt; ) for MAXIMUM SPEED.
What is this "undef" nonsense? /C programmer
I'd like to comment on the "private knowledge" claim. Either way, you need to know the names of the functions you want to call, so @EXPORT has no advantage here.
It is otherwise a fine module. I forget what it was, but other than the obvious, Mrs. Lincoln enjoyed the play very much.
You define the tags yourself with %EXPORT_TAGS. And variables don't really work any differently than functions in terms of exporting, so for example: %EXPORT_TAGS = (all =&gt; [qw($somescalar %somehash @somearray $anotherscalar)], some =&gt; [qw($somescalar $anotherscalar)]); Would allow users of your module to write use Some::Module qw(:all); ...and have those four variables imported into their namespace. Also, even if the module hasn't defined any tags, you can use a regexp to select everything, so use Some::Module qw(/./); ...would result in everything in @EXPORT_OK being imported even if the module didn't define an `:all` tag. See `perldoc Exporter` for details. 
It sure sounds like homework, but here's an answer for your first request. EDIT: I've added comments to every line.. looks noisy but it may help. EDIT2: Removed the incorrect check for empty array. (there was a "return 0 if not $top;" before the while) sub array_search { my ($needle, $haystack) = @_; # assign arguments $needle is the string $haystack is an array ref my ($bottom, $top) = (0, @{$haystack}-1); # $bottom and top are the bounds of the array 0, n-1 while( $bottom &lt;= $top ) { # while there is stuff to look through my $middle = (($top-$bottom)&gt;&gt;1)+$bottom; # find the midpoint between bottom and top. my $test = $needle cmp $haystack-&gt;[$middle]; # compare the value at the midpoint against $needle return ++$middle if not $test; # if we found the needle in the haystack at [$middle], return $middle+1 (the 1 based index). if ( $test &lt; 0 ) { # if the $needle was less than the value at [$middle] set the new top $top = $middle - 1; } else { # if the $needle was more than the value at [$middle] set the new bottom $bottom = $middle + 1; } } return 0; }
Don't use either, if you don't have to.
undef EXPR undef Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using "@"), a hash (using "%"), a subroutine (using "&amp;"), or a typeglob (using "*"). (Saying "undef $hash{$key}" will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see delete.) Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable or pass as a parameter. Examples: undef $foo; undef $bar{'blurfl'}; # Compare to: delete $bar{'blurfl'}; undef @ary; undef %hash; undef &amp;mysub; undef *xyz; # destroys $xyz, @xyz, %xyz, &amp;xyz, etc. return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it; select undef, undef, undef, 0.25; ($a, $b, undef, $c) = &amp;foo; # Ignore third value returned Note that this is a unary operator, not a list operator.
I'm going to keep this in mind, thank you. Seems to fall in place with the "basics" I've been learning thus far. 
Well, I'm on chapter 3 of [Beginning Perl](http://www.perl.org/books/beginning-perl/) as per borick's advice for noob friendly instruction. I'm hoping that five or so chapters in I'll start to be able to understand the questions above, even if I'm getting the wrong answers. Thanks so far for all the advice!
As mentioned previously, it's more job-related than homework, and unforunately if I don't understand the program it's going to do me absolutely no good going further. That said, I appreciate your input as to one possible answer to this problem. I'll use it as something I can reverse-engineer; as soon as I can understand what you wrote (I don't!) I'll be one step closer to my goal. EDIT: Wow, thanks so much for the #comments memorylane! That's a tremendous help for my comprehension. Give that this is my first ever Reddit thread, I assume that an upvote would be the appropriate response? Thanks!
The main thrust of my limited IT career has been systems administration thus far. I currently oversee a couple of offices and around 200 PCs as a consultant for a medium sized firm. I've noticed in reading about Perl that it seems to be a natural compliment to the sysadmin field. Given how how hot the developer field is looking these days, I figure it can't hurt to have some programming know-how.
 Here's a straight forward implementation of the second problem. EDIT: added comments to each line sub int_counter { my %counts; while(&lt;&gt;) { # Read standard input my $line = $_; # $_ is the current line of standard input for my $match ($line =~ m/(\d+)/g) { # for every sequence of contiguous digits in the current line $counts{$match}++; # increment the count of the digit seen } } my @results; for my $key (sort { $a &lt;=&gt; $b } keys %counts) { # Iterate through the counts in numerical order push @results, $key . ': ' . $counts{$key}; # store the results like '12: 1' in @results } return join(' ', @results); # join all results with a space so you'll get '12: 1 34: 2' } It could be much more concise, but the point here is clarity so the above is as verbose and straightforward as I can get it.
No, thank you. Verbose is good! I'm still trying to wrap my head around the differences of %,@,$! string(?), array, variable...
$calars : $x = 5; $y = "hello"; @rrays : @foo = ($x,$y,"bar"); %ashes : %foo = ("keyname1"=&gt; $x , 'keyname2 =&gt; $y); # =&gt; is just a fancy comma (ok, it's a rubbish 'h', but you get the idea :) )
 echo This is test data 12 -34 abc56 A float: 780.34 | \ perl -nE'$x{$&amp;}++while/\d+/g;@x=map{"$_: $x{$_}"}sort keys%x;say"@x"' ...someone had to :p 
I'd say either your cat's been walking on your keyboard, or this is some ninja-perl in action?
Wow, totally missed the letters as symbols thing until you pointed that out, as if I've never seen leetspeak before in my life. That's definitely going to help, thanks! (Good thing "thank you's" aren't in short supply or I might run out in this thread) Am I correct in assuming that @foo is an array named foo and could be named "doo/poo/soo", and the same with %foo being a hash named foo? Is foo (foo()?) a function, or just used to demonstrate a concept?
It's Perl-golfers that give the language most of it's bad rap, I suspect. zomg line noize!!!.11!!1....wait, it does what?! (solves part2, I hope) To be helpful though, here's what might be a handy test function for you for part 1: https://gist.github.com/990187 
The main point of the =&gt; is that it automatically quotes the previous token. So you'd use: %foo = ( unquoted =&gt; 'but', 'commas', 'require', some =&gt; "quoting" ); 
there's always `$[` -- http://perldoc.perl.org/perlvar.html#%24ARRAY_BASE Although it's deprecated in 5.12 :(
pourquoi?
That's true enough, but in this case I'm maintaining some legacy ... stuff. So the export_ok array is actually part of a config file, and I'm just maintaining another file that calls that one, so it would be nice if I didn't have to worry about the variables changing. 
I've been looking at "perldoc Exporter" and will look some more! The main issue is that this is all legacy stuff, so I am not at liberty to change too much. I just changed "export_ok" to "export" and am testing that right now.... The thing is, if it *were* my module, I'd be taking all of y'all's advice and then some :-)
Nice one. I can't get it any shorter and it's correct against the input you've stated, but on my browser the original post has a newline before "A float". So if you allow for newlines, then you can add an END{ before the @x and } before the terminal ' Either way it beats my one liner by a lot of strokes. perl -E 'map{$x{$\_}++}(map{/(\d+)/g}&lt;&gt;);say join(" ",map{"$\_: $x{$\_}"}sort keys%x);'
I try to use @EXPORT_OK as much as possible instead of @EXPORT. It is better for backward compatibility. If you decide to add something to @EXPORT in a newer version of your module, your user's program might break because he might have a function with the same name on his namespace. True, you can always do 'use Foo ()' to avoid importing stuffs, but this is not a very common idiom.
If i have any say in the project, use of @EXPORT is banned. For a very simple reason too: Using @EXPORT_OK exclusively for exports means that each imported thing has to be mentioned up top once at least. This way you can always look at the top of the file to figure out where "process()" in line 500 came from. If it's imported via @EXPORT you get to spend an hour grepping and evaluating your code-base and CPAN to figure out which one it is. Also, please don't use Exporter if you have a choice. Sub::Exporter and Sub::Exporter::Simple are much nicer.
I'm a bit surprised you think binary search requires a tree structure.
Attempt the simple solution first, but the proper solution uses something like this: http://en.wikipedia.org/wiki/Binary_search_algorithm - especially once the size of the array grows to a huge number! "In computer science, a binary search or half-interval search algorithm locates the position of an item in a sorted array." (first line of the link)
You often don't want to walk all over the user's package like an elephant, with all your exports. The user probably only wants a few of them and doesn't expect any of the others, and they might conflict with his own subs. The danger is very real if your module gets extended over time and new (exported) subs are added, and an upgrade of your module might break his stuff. A nice compromise is to use tags (start with ":", see [Exporter](http://perldoc.perl.org/Exporter.html#Specialised-Import-Lists)) so you can let the user import many related subs with just one tag.
&gt;EXPORT_OK could result in a smaller footprint if I understand it correctly--it will only import the code that the user specifies rather than everything in EXPORT No, that's wrong. No matter how many functions get exported, they *all* get loaded. So the footprint is virtually identical. Importing them does nothing but making an alias to the existing routines, to the same name in your own package. The reason to limit the export is to avoid unexpected name clashes.
Frankly, I prefer to not export at all, instead, I use the fully qualified name. MyModule::subroutine() rather than subroutine() That also encourages me to keep module names short, so it doesn't goll the way across the page.
That doesn't really scale well when you need to rename a module for whatever reason.
Related: [Why the Lacuna Expanse is good for Perl][1] by JT Smith [1]: http://blogs.perl.org/users/jt_smith/2010/10/why-the-lacuna-expanse-is-good-for-perl.html
There are a lot of excellent reasons given here. I just wanted to add one minor, but not insignificant reason: code readability. When you come across code like this: use Foo; use Bar; use Blah; use Yadda; do_awesome_stuff(); do_more_stuff(); In large legacy code bases this can lead to a lot of wasted time grepping to find the origin of those exported subs. This, on the other hand, makes it immediately apparent where they come from: use Foo 'do_awesome_stuff'; use Bar 'do_more_stuff';
I understand the sentiment of this, but in practice I think Tom's preference saves FAR more time when working in a large codebase. If you're renaming a module, you're already grepping every source file to find the ones using it. While editing that 'use'/'require' line in the file, it only takes an extra few moments to do a search/replace for fully-qualified function calls and variables. What this buys you, though, is a great deal more readability. Especially when you're working with other peoples code which might have sub names that aren't totally descriptive, or (more commonly) are applicable to several package names. Totally contrived example to illustrate the point: use Tree; use Dog; bark(); In large, especially old "legacy" code bases, this sort of scenario happens a lot. And when you're trying to grok other peoples' code it often leads to a lot of wasted time tracking down the source of the function.
 #!/usr/bin/env perl while (&lt;&gt;) { chomp; print if /^Server Adminitrator/ &amp;&amp; /Storage Service EventID/; } Does the above do what you need?
prbly not: Adminitrator [sic]
The ^ character matches at the beginning of a line. It will never match because you are looking for a space before that even happens. Change it to / Server Administrator:/ and see how that works.
Sub::Exporter deserves mention in this discussion, as it allows the caller to rename on import (or prefix). This can help to resolve the conflicts mentioned elsewhere in the thread.
The space was put there for formatting on reddit. I didn't know at the time how to get the code to look ok. I'ved edited it to make it correct now that I know how
I was kidding, but I'm sure others will appreciate the explanation :)
Oh, you're right. I was thinking of a [binary search tree](http://en.wikipedia.org/wiki/Binary_search_tree). It's been at least 15 years since my last CompSci course.
&gt; the proper solution Be wary of the "proper" solution... I've seen plenty of instances where someone implemented the "optimal" solution incorrectly when the simpler yet non-optimal solution would have worked just fine and not cost me hours of troubleshooting. Not that you *shouldn't* use the optimal solution, but if you know this is a one-time search through a reasonably short list, you might be better off just writing my $i=0; for ($i=0; $i&lt;scalar @searchArray; $i++) { if ($searchArray[$i] eq $searchString) return $i; } return undef; and calling it a day rather than wasting your time doing it "optimally." Doubly so if you have to sort the array first.
&gt; No matter how many functions get exported, they all get loaded. Unless they're autoloaded.
 for (1..2**31) { last if $_ &gt; 100; print $_ } There's a stupid way to write a mostly-infinite loop without having to define another variable.
Use Catalyst until you've got the webapp that you want. 
That looks much nicer than the "`find . -name *.pm | xargs -L 1 perl -c`" I've been using.
I feel like an idiot for asking but... what is this? How does it relate to Apache, Perl, and the things I am ignorantly trying to do? How can I find out more? Thanks for your help!
It's a MVC framework, written in perl. It has its own installer, it has its own small-scale web server built-in... not production worthy, but good enough to debug. When you get your application the way that you like, then you can worry about getting it working in apache. It'd mean either mod_perl, or maybe you go with lighttpd and fast cgi. It's been a couple of years. But you definitely want to use Catalyst. If the webapp will only ever have a few concurrent users and someone will be available to babysit, you might even just use the built-in server restarting it occasionally if it crashes or whatever. http://www.catalystframework.org/
I'd throw Dancer into the mix if Catalyst isn't your style. After dancer is installed you type `dancer -a appnname` and it will create a skeleton app setup. Then `cd dancer` and `perl bin/app.pl` and it's running. In your browser go to `http://localhost:3000` and you'll see it running. After you get it working and running from there (it's a lot easier when you can `debug` something and see it as it happens, then you can move it to Apache or what have you for deployment.
The whole point of having operators that take `$_` as a default is that you don't have to be so verbose and litter everything with `$_`. Explicitly including it just makes the code look fugly and unidiomatic. This is so much cleaner and easier to read without all the extra noise: while (&lt;&gt;) { print if /Server Adminitrator/ &amp;&amp; /Storage Service EventID/; } If you're trying to be explicit so that there's no confusion about what the code does, I think you're going overboard. Anybody reading perl has to know about `$_`, there's simply no way around that. Besides, your version still relies on knowing the magic that `while (&lt;FH&gt;)` puts each line in `$_` so it seems counterproductive to your cause to allow that magic but not allow other magic. And again, very unidiomatic. 
A linear search would work, but then there'd be no reason to mention that the strings in the array are sorted. The statement "The array may potentially contain a large number of elements, and the function should be written to manage this efficiently." also strongly implies something other than a linear search.
*(this is more of an OS X question, so you might try questions like this in /r/apple or /r/applehelp in the future)* In order to get Perl running on your local machine, you will have to edit your Apache config on OS X for the current user. Enable "web sharing" in System Preferences, then edit `/etc/apache2/users/yourusername.conf` and add `ExecCGI` to `Options`. For example: &gt; `Options Indexes MultiViews ExecCGI FollowSymLinks` I think that's it, but I haven't touched my Apache setup under OS X in a while. Pretty sure the `AddHandler` stuff is all set (you should have `/etc/apache2/other/perl.conf` already) as well as having the CGI module already loaded in the main `/etc/apache2/httpd.conf`. So all the hard stuff's done, you just need to flip the switch and for that you will need `sudo`.
You _have_ to "fudge with the system configuration" and "use 'sudo' a bunch of times", depending on what exactly you want to do. I think you can serve CGI scripts in any language from ~/Sites/cgi-bin or something by default, as well as possibly a few other places. Otherwise you HAVE to change Apache's configuration, which HAS to be done with sudo or any user on the machine could arbitrarily change the configuration.
I'm embarrassed to admit, I barely understand what "apache" is, much less adding "Catalyst" and "Dancer" on top of that. How does this all fit together?
Friends don't let friends use ActiveState.
Why not? I prefer ActivePerl because of excellent PPM support, PerlEx and graphical Perl Critic.
Just for the record, Catalyst also has a local httpd script. perl script/yourapp_server.pl Then go to http://localhost:3000/ :)
I'm more familiar with Dancer, having just completed a few small projects with it. I'm sure Catalyst offers similar things, but I can't directly speak to that. Perl Dancer is a lightweight framework for web applications. You can find a lot of documentation, examples, etc. at their [homepage](http://perldancer.org/). What this does is makes it easy for you to concentrate on your application code rather than on how to simply make it work. Dancer handles picking which `sub` to call when it receives a request. It takes HTTP `post` or `get` requests and pulls out the parameters (eg `GET /post?name=foo&amp;subject=bar&amp;message=blahblahblah`) and easily lets you get access to those variables. Frameworks like these also give you a lot of utility functions, like automatically handling sessions, making file uploads painless, and makes `ajax` very easy to implement. (`ajax` is a way to send data back and forth without having to reload the page.) So if you have a perl system using Dancer, how do people actually get to use it? Well, for development purposes Dancer contains a micro web server. It runs as a normal application and shows you the requests that have come in, how it interpreted them and which `sub` it routed it to, as well as any `debug` statements or related problems in the code. This is **great** for development purposes, but it really only handles one connection at a time so it's not something that you'd use for a live system. ----- Apache is *the* webserver. It runs a majority of websites (~54% says [netcraft](http://news.netcraft.com/archives/2010/06/16/june-2010-web-server-survey.html)). It's been built to be fast, stable, and secure. Unless you have any specific reason to use anything else, this is the way you want to run your system once you're happy with the way it works in development. It can handle many, many simultaneous connections. On most linux distros you can easily install apache (usually the package name is `apache2`, and on Debian and related packed (like Ubuntu) you can do `sudo apt-get install apache2` for redhat and other `yum install apache2` will most likely do it.). And configuring it to run your Dancer site is fairly simple as well, the documentation is very thorough. Of course Apache isn't the *only* way to go. There are some ultra-high performance systems, but they tend to be a lot more complicated and are only worth it if you absolutely have to eek out every last bit. ------- So, back to Dancer. Dancer provides a tool to set up a skeleton application, appropriately called `dancer`. To set up a framework you'd type `dancer -a &lt;appname&gt;` . `&lt;appname&gt;` can be "myapplication" or "domainname" or better for more complicated projects "Division::Group::Project". But for your first app start we'll go simple and use something that doesn't contain "::", at least not until you understand module layout. This will create a directory named &lt;appname&gt;. Inside that will be a new tree of files and directories. So fire up a text editor and let's take a look at them. * `appname/` - The main directory holding our code * `appname/bin` - `bin` usually means binary, but now really just means executable. In here is a file called app.pl - All it does by default is load your system and start the built in micro server. from `appname` just type `./bin/app.pl` and it'll start one on port 3000, so you need to go to `http://localhost:3000` to see it. * `appname/config.yml` a configuration file in [YAML](http://en.wikipedia.org/wiki/YAML) format. Lots of options in here. You can enable or disable settings from here. * `appname/environments/` This lets you set different configuartions based on if you're in a a development or production environments (like if to display errors or not) * `appname/views` - Views let you create your HTML output as a template allowing you to separate code from design. So instead of making your Dancer code generate all the HTML, instead you tell it something like `template mypage.tt, { user =&gt; "ArguingWithVirgins", karma =&gt; 50 };` and it would render a page putting your name where `user` is in the template, etc. This is great from a design idea, you can make different html frontends off the same backend * `appname/public` - This is the general file area for things that don't need running. You'd put images, static pages, CSS or Javascript files here. The webserver just serves them up as normal without doing anything special to them. -------- I hope that was at least a little informative. Let me know if I can clear anything up, I sorta suck at explaining things, but i'm trying to get better.
Oh, i figured it did. I'm just not as familiar with it and can't speak for it. I'm glad to see multiple perl frameworks out there. Something for everybody.
While this isnt Perl related, you might want to check out [remake](http://bashdb.sourceforge.net/remake/) which is a version of make that supports debugging. Also, If you dont get that, I find "make -p" a useful tool to look through makefiles.
Only problem I know of with ActivePerl is that their Tkx module doesn't compile on any Perl but theirs (in my experience, it gives segfaults all over; tried on various versions of Fedora Linux with whichever Perl comes with them). So their in-house Perl modules aren't "CPAN-friendly", even though they are on CPAN.
&gt; So it is with some reluctance that I tell you that Aspect.pm is unfreakingbelievably good for Monkey Patching. Now don't do it. Seriously. Ah, oh well. 
Because the approach is inferior. PPMs were always a sin of convenience. Why would I want to use a binary repo that supports half of CPAN, when I can use Strawberry which supports damn near all of it. And, seamlessly at that. cpanp + Strawberry = Win ActiveState = 1998
Maybe Perl coders don't feel the need for a community? I've been coding Perl since '94, and only wandered in here today out of curiosity.
You do realize that they'd been shipping with gcc for a long time now and are able to do anything Strawberry does, with the added bonus of having a convenient fallback for things that are difficult to compile (DBD::mysql) even on linux?
That would make a great comeback...if you were arguing with a guy claiming that C was newer than Perl...who would be an idiot.
No shit, dude. People would get tattoos like this up their arm, just to stick it to The Man: a:hover {background-color:#fc0; text-decoration:blink; border:2px solid black;} It was mad days I tell ya...mad!
There are no ex-Perl programmers...that's like "ex-alcoholic". Say rather that they are in recovery from a powerful religious experience which proved ultimately too intense for their pedestrian requirements ;-)
If you don't know how the perl script was invoked you can try make -n which will echo the commands "make" would run without actually running them. Alternatively if you want to step through the perl script while "make" is invoking it. Then try replacing the PERL=/usr/bin/perl definition with PERL=/usr/bin/perl -d Then every time perl is called from the makefile you'll be in the debugger.
Have you considered skipping the Excel macro altogether and just having Perl write the spreadsheets? Spreadsheet::WriteExcel has a few warts here and there, but I've had pretty good results using it to create Excel workbooks.
That is a great module. I use it to do reports on some database stuff that I parse.
I used to do stuff like that. It was error prone and slow. Skip the excel macros and just output an xml/xlsx excel file using an existing library or roll your own.
legend_dairy you're justifiably pulling your hair out because the VBScript looks fine. It's likely some mystery bug which only presents itself when running VBScript within perl. So just create the workbook in perl, as ErasmusDarwin suggested, which seems to be the more straight forward way. Here's a perl version of your VBScript. \#!/usr/bin/perl -w use strict; use File::Spec; use Spreadsheet::WriteExcel; sub csvs_to_workbook { my ($dirname, $workbook_filename) = @_; unless ( File::Spec-&gt;file_name_is_absolute( $workbook_filename ) ) { $workbook_filename = File::Spec-&gt;catfile( File::Spec-&gt;curdir, $workbook_filename ); } my $workbook = Spreadsheet::WriteExcel-&gt;new( $workbook_filename ); die "Could not create workbook ($workbook_filename): $!" unless $workbook; opendir(DIR, $dirname) || die "Could not open directory ($dirname): $!"; while( my $filename = readdir( DIR ) ) { next unless $filename =~ /^(.*)\.csv$/i; my $worksheet = $workbook-&gt;add_worksheet( $1 ); my $dir_and_filename = File::Spec-&gt;catfile( $dirname, $filename ); open( FILE, '&lt;', $dir_and_filename ) || die "Could not open ($dir_and_filename): $!"; my $row = 0; while(&lt;FILE&gt;) { chomp; my $col = 0; for my $cell (split ',') { $worksheet-&gt;write( $row, $col++, $cell ); } $row++; } close(FILE); } closedir DIR; $workbook-&gt;close(); } csvs_to_workbook( '/tmp', 'some.xls' ); 
Strawberry Perl has done a great job in improving the CPAN shell on Win32. The nice thing about open source is that work is now in ActivePerl. ActivePerl, mingw, CPAN ... just works! ActiveState has been around since the 90s making Perl work on Win32 (and more). Its the better route for professional development.
if you want to handle newlines, I'd use the [eskimo greeting](http://www.catonmat.net/blog/secret-perl-operators/#eskimo) 'operator' perl -nE'$x{$&amp;}++while/\d+/g;@_=map{"$_: $x{$_}"}sort keys%x}{say"@_"' I just realised that `map` doesn't have to take a block argument, you can use the EXPR version to save another char: perl -nE'$x{$&amp;}++while/\d+/g;@_=map"$_: $x{$_}",sort keys%x}{say"@_"' 
Great link. eskimo operator.. goatse operator!! LOL What about s///e instead of while. perl -nE'$x{$&amp;}++while/\d+/g;@\_=map"$\_: $x{$\_}",sort keys%x}{say"@\_"' v.s. perl -nE's/\d+/$x{$&amp;}++/ge}{@\_=map"$\_: $x{$\_}",sort keys%x;say"@\_"' If you allow redundant terminal spaces and no terminal new line then this is a bit shorter. perl -nE's/\d+/$x{$&amp;}++/ge}{print "$\_: $x{$\_} "for sort keys%x' but strictly speaking it's wrong, due to the terminal whitespace in output
Hmm, i'll do some tests tomorrow with some different data sets. I'd love to be able to just do everything in PERL, but i'm starting to get overwhelmed with the language. To be honest, I got hired for this job with zero programming experience and have been trying to pick it up on the fly, and thanks to all of the amazing community i've been able to more or less teach myself. But I feel that i'm getting to the point where i either need a very good guru to hold my hand or some amazing book to finish explaining how to use modules and whatnot. Regardless, thank you very much Erasmus and memory! Edit: the script is performing admirably, thanks again for the help!
&gt; Do I need the &lt;&gt; on line 54? Is that where I am supposed to put the URL? 1. Don't edit the script. 2. You probably want to type this in a terminal / command prompt: perl photoreflect -d "http://whatever" 100 3. You probably have to get the URL by navigating directly to a thumbnail (see below). My guess is that you're using the wrong URL because the instructions are very specific (see in bold below). 4. Type "perl photoreflect" by itself, and it will dump out these instructions to you: Usage: photoreflect &lt;first-image-url&gt; &lt;num-images&gt; Download a set of photoreflect images without watermarks Set debug mode **Go to the first image page of a photoreflect photo set.** **You *must* go to this image by clicking on the thumbnail page, do not navigate to it from another image using the next/prev buttons.** The second arg is the number of images in the set, or the number you want. You will likely need to put the url in quotes (depending on your shell)
Thanks for the help! Can you tell me from the output if I am missing a module or library etc? &gt;C:\Users\###\Documents&gt;perl pr.pl -d "http://www.photoreflect.com/store/Orderpa &gt;ge.aspx?pi=1MI5001F000000&amp;po=0&amp;pc=185" 185 &gt;[pr.pl] http://www.photoreflect.com/store/Orderpage.aspx?pi=1MI5001F000000&amp;po=0&amp; &gt;pc=185 &gt; &gt;[pr.pl] pi = 1MI5001F000000 &gt;[pr.pl] c = 0 &gt;[pr.pl] Img: http://www.photoreflect.com/prbin/prpv.dll?photo?s=-1&amp;i=1MI5001F000 &gt;000&amp;p=0 &gt;1MI5001F000000.jpg &gt;'lynx' is not recognized as an internal or external command, &gt;operable program or batch file. &gt;'i\' is not recognized as an internal or external command, &gt;operable program or batch file. &gt;The system cannot find the path specified. &gt;[pr.pl] ERROR: Error from GET -H 'user-agent: Mozilla/5.0': &gt; code: &gt; 
&gt; `for my $cell (split ',') {` If your CSVs have any text fields then this isn't very safe. It will fail if someone uses a comma in a text field, and look funky if the text field is quoted. For instance: Date,Notes,Score 2011-05-27,"I was going to rate this higher, but I don't like blue",7 First problem, `comment` will contain `"I was going to....` not there's a quote at the beginning but not the end. And if you look where you expect score you get ` but I don't like blue"` Oops! Pretty much never try to parse things by yourself unless absolutely required. use Text:CSV (or CSV_XS) to correctly parse CSVs. Similarly `join(','@string)` will NOT always produce valid CSVs. use Text::CSV_XS; my $csv = Text::CSV_XS-&gt;new ({ binary =&gt; 1 }) or die "Cannot use CSV: ".Text::CSV-&gt;error_diag(); open my $fh, "&lt;:encoding(utf8)", "test.csv" or die "test.csv: !"; while (my $row = $csv-&gt;getline ($fh)) { for my $cell (@{$row}) { .... } } Is a much better way. No need to worry about odd characters, embedded newline, or any other strange thing. It'll save a lot of headaches. 
Who's the photographer?
Greetings. 1. You got that error because you're on Windows and there is no executable named "lynx". 2. I use Linux, so I installed lynx. But I just got a redirect to a URL which is obviously intended for a Windows executable probably written for the photographer. 3. My apologies that I don't have more time to look into this but why not just take the brute force approach? They have disabled right-click but you can still hit your PrintScrn button and paste into Paint, and then crop. Tedious but presumably your sister is willing to do that? Sorry I can't be of more help but this could be one of those rare cases where manual effort is well worth the result.
Also, edit out the personal identifying information in your post!
White Snow Images. Our local DA just found her living in AZ(we live in NY). She is in deep sh*t. Once she is extradited back here prb also a class action suit against her with the other 10 or so brides she ripped off.
Sorry you got caught with a bad one. Not all of us wedding photographers are like that. Good luck getting your photos.
Ya thanks it looks like I will be prtscrning away :)
thanks!
That script doesn't appear to work anymore. Or at least the example link it gives in a comment to a 'non-watermarked copy' still has watermarks. Most likely they changed their protection scheme when they realized how easy it was to get around. I can get you the pictures *with* watermarks with ten minutes of work, if you want them. edit: It's really weird to open a link from a random script on the internet and see a picture of someone you used to be friends with.
Strawberry includes many CPAN modules and several of them fail on perl 5.14.0. But we are working on it. Win32::Exe is already fixed.
VSS forever! :p
Have a look at *Learning Perl* and *[Modern Perl](http://www.modernperlbooks.com/mt/2010/11/the-book-is-out.html)*. Both of those (especially MP) will teach you to use CPAN modules effectively. [Also: it's a minor nit, but please don't call it PERL. It's not really an acronym. Use Perl for the language and perl for the interpreter.]
That regex just means "until $amount has only digits". If you want to accept decimals, then you'd use something like $amount =~ /^[\d.]+$/
Try just doing it. Get a reference book and a tut book then tackle a problem. Here is a fun one: run a script that will pick 10 random project guttenberg titles, analyze the text and generate an index/ doc structure.. Basically create a table of contents.., publish the results in marked up HTML pages for viewing. Go the distance and make the page pretty. Can't use the table of contents from the files already. Must parse the entire file
I'm not 100% positive, but I believe subs are not garbage collected. They always maintain a refcount. Also - destroy is never called on a blessed coderef. I say this because I wrote a class which returns a blessed coderef and wanted to do some cleanup on DESTROY. To my dismay, DESTROY was never called. Using Devel::Refcount and weaken I was able to verify that even when nothing else held a reference to the coderef, it still maintained a positive refcount and thus never garbage collected. 
I recently created a number of modules which help with mocking modules for tests. The one module in particular returned a blessed coderef. The purpose was to act as a wrapper around another subroutine. You could then call methods on that subroutine to test different things. For example, say you had a module called Acme::Foo with a subroutine bar(). My module would return a new subroutine that wrapped the original bar() subroutine. You can still call the subroutine/method like you normally would: Acme::Foo::bar(); # normal invocation my $foo = Acme::Foo-&gt;new; $foo-&gt;bar(); # method invocation However, because that subroutine is actually a blessed coderef, you can call methods on it. I have an "expects" method which will check to make sure the parameters being passed meet certain expectations. The code below would make sure that "Hello World!" was a parameter when bar() is called. (&amp;Acme::Foo::bar)-&gt;expects([ 'Hello World!' ]); The modules aren't on CPAN yet, but I'm hoping to get them up there soon. If you want an actual snippet of code you can run, I can share more. Perl lets you do some crazy (fun) stuff.
I've included some same code to illustrate what I meant. It looks like when you create a subroutine, it starts with a refcount of 2 instead of the normal 1 as with other references. use Scalar::Util 'weaken'; use Devel::Refcount 'refcount'; print "INITIALIZATION\n"; my $sub = sub { }; printf( "\tSub: ref = '%s'; initial refcount = '%d'\n", ref $sub, refcount($sub) ); my $hashref = {}; printf( "\tHashref: ref = '%s'; initial refcount = '%d'\n", ref $hashref, refcount($hashref) ); weaken $sub; weaken $hashref; print "AFTER WEAKEN\n"; printf( "\tSub: ref = '%s'\n", ref $sub ); printf( "\tHashref: ref = '%s'\n", ref $hashref ); Above will output the following: INITIALIZATION Sub: ref = 'CODE'; initial refcount = 2 Hashref: ref = 'HASH'; initial refcount = 1 AFTER WEAKEN Sub: ref = 'CODE' Hashref: ref = '' Edit: improved formatting.
&gt; Any help on where I went wrong? This file is half shell script and half Perl. Perl 5 has no `head` keyword, for example, and its `grep` keyword has the forms: grep BLOCK LIST grep EXPR, LIST It doesn't take options like the Unix command. With that said, you *can* execute programs from Perl 5 with the backticks or `qx//` operator (see the "Quote-Like Operators" section in `perldoc perlop`, for example), but you're probably better off opening iterating through your files individually and processing as you go. If you always know the position of the domain name (or can always extract it) from each line in `alldom.txt`, you can read the lines of `unqdom.txt` into a hash and then use that hash to count the occurrences of each domain name in `alldom.txt`. I'd take that approach. &gt; Does Perl interpret the placement of ++ before or after the variable like Java? $y = $x++ ... will assign the current value of `$x` to `$y`, *then* increment the value of `$x`. Contrarily: $y = ++$x ... will increment the value of `$x`, *then* assign the incremented value to `$y`. I've written a book called [Modern Perl](http://onyxneon.com/books/modern_perl/index.html) which you may find helpful. It's available in several electronic forms for free.
Do you mind posting a sample of these files?
&gt; you are trying to use the unix utilities head, tail and grep as if they where Perl functions. That is not the case. I think the OP's script used the qx// operator, i.e. $unqval = `head -n $count unqdom.txt | tail -1`; However, in markdown the \` means `inline code` and must be quoted if you want a literal backtick, which OP did not do. OP: to post code on reddit without it being mangled all to hell you need to preface each line with four blank spaces. 
That was a real splash of water to the face. Thank you, perl5porters! 
Best advice I have is add these two lines to your script and try to understand resulting errors/warnings. use strict; use warnings;
Don't use bare &lt;&gt;, it does NOT always mean &lt;STDIN&gt;
&gt; So I picked up Perl... I hear that ruby cures that ;)
Related username? :)
Blew my mind.
Point 50 in particular is disturbing. 50\. Code that believes that stuff like /s/i can only match "S" or "s" is broken and wrong. You’d be surprised. Does anyone know what else it would match? I tried the greek sigma and the other char he mentioned in point 8 under Assume brokenness. They didn't match. EDIT: Answer below. TL;DR = Hit char=(S), hex=0x53, dec=83 Hit char=(s), hex=0x73, dec=115 Hit char=(ſ), hex=0x17f, dec=383 ...
Well, the [ß](http://en.wikipedia.org/wiki/%C3%9F) would be the obvious one.
/s/i doesn't seem to match ß for me. Neither does it match "ꜱ" aka [smallcaps](http://en.wikipedia.org/wiki/Smallcaps) I tried via #!/usr/bin/perl -w use 5.014; use utf8; use open qw( :encoding(UTF-8) :std ); #open I, "&lt;:encoding(utf8)", "/d/data" or die "$!"; while(&lt;&gt;) { chomp; print "saw ($_) "; if ( /s/i ) { print "HIT\n"; } else { print "MISS\n"; } } So I'm using 5.14, I tried the direct open I, and while(&lt;I&gt;), my terminal is set to utf8 and my test file has σ ß ς ꜱ s S But all I get is saw (σ) MISS saw (ß) MISS saw (ς) MISS saw (ꜱ) MISS saw (s) HIT saw (S) HIT I don't think it's title case either. The original post mentions there's titlecase lowercase and uppercase, but AFAIK titlecase is [just a few characters in some languages](http://www.fileformat.info/info/unicode/category/Lt/list.htm).
See the [if](http://search.cpan.org/perldoc?if) module. You could also do this yourself if you separate `use` into `require` and (optionally) `import`.
Haven't actually tried it but I would just do this: use 1 if $ENV{1}; use 2 if $ENV{2}; use 3 if $ENV{3}; etc
The if module is ideal-est. However, if that doesn't work, you can do: BEGIN { if ( $ENV{1} ) { eval "use 1;"; } else { eval "use 2;"; } } You will want to check $@ and the like.
That's a syntax error because `use` isn't exactly a statement.
I'm not sure how "action if condition" is different from "if condition then condition", can you clarify that for me? I may wind up with require and import though, thanks for the lead!
`use` is special syntax. When the Perl *parser* sees it, it runs *only that `use`* immediately. That's why you need the `BEGIN` block around the entire `if`/`elsif`/`else`/ chain -- but it's not sufficient. The `if` module takes advantage of this feature to load other modules conditionally.
Thanks a lot! I'll try that out.
You can change encoding defaults in Notepad++ under "settings". You can also view "control chars" by clicking the paragraph icon. There's also an option somewhere to convert line endings to unix/win/mac
Replace both occurrences of "sum" by "$sum". The '$' is required on references to variables, not just on declarations (I'm guessing about what your misconception was). An identifier not preceded by '$', '@', '%', or something similar is called a "bareword"; barewords are not permitted in most contexts. (A subroutine name, when the subroutine declaration is visible, is a case where barewords are permitted.)
Wow. Thanks. I actually knew that but I just overthinking it I guess.
That takes care of the bareword error, but it'll still loop forever because you never change the value of $sum. You're also computing it twice per loop. Maybe #!/usr/bin/perl -w use strict; use Memoize; sub fib { if($_[0] == 0) { return 0; } elsif($_[0] == 1) { return 1; } else { return fib($_[0] - 1) + fib($_[0] - 2); } } memoize('fib'); my $i = 1; while((my $sum = fib($i++)) &lt; 4000000) { print $sum . "\n"; } [Memoize](http://search.cpan.org/~flora/Memoize-1.02/Memoize.pm) is a transparent cache for values returned, given input values. So fib() is only ever evaluated once per input value. 
A minor point: I think that "use warnings;" is generally considered to be better than "-w". The difference is that "-w" imposes warnings on "use"d modules, some of which might have good reasons not to enable warnings. ("use warnings;" didn't work prior to Perl 5.006; that shouldn't be an issue these days.)
You're right, it doesn't, but that doesn't necessarily mean you shouldn't use it. It means to read from any files named on the command line, if any, or from stdin if there are none (that's a bit of an oversimplification). Which is very often exactly what you want.
Listen to chromatic. He's smarter than the rest of us. However, if your usage lends itself towards using Moose, `Class::MOP` has `Class::MOP::load_class()` which may be useful. See the documentation: [http://search.cpan.org/~flora/Moose-2.0007/lib/Class/MOP.pm#Utility_functions](http://search.cpan.org/~flora/Moose-2.0007/lib/Class/MOP.pm#Utility_functions).
In order to make matching as accurate as possible (e.g. if Joe and Joey are two different names, you want to make sure that `/Joey/` is tested before `/Joe/`, sort the list of search patterns by length. @names = sort { length($b) &lt;=&gt; length($a) } @names;
TIL On a related tangent, I've been on more than a few Apache servers that seemed to *require* the -w flag on the shebang line, have you seen this? So I've gotten into the habit of always using -w no matter what.
Here you go. I'm pretty sure the '12-10-10: ' in your example output was supposed to be a date based upon the input line, but the example input line had no such data.. so I just put it in there raw. #!/usr/bin/perl use strict; use warnings; use Data::Dumper; sub get_names { my $file = shift; my $names = {}; open(NAMES, "&lt;:encoding(UTF-8)", $file) || die "Could not open ($file): $!"; while(&lt;NAMES&gt;) { chomp; $names-&gt;{$_} = 1; } close(NAMES) || die "Could not close ($file): $!"; #print "Names are " . Dumper($names) . "\n"; return $names; } sub process_log { my ($file,$names) = @_; open(LOG, "&lt;:encoding(UTF-8)", $file) || die "Could not open ($file): $!"; my $line = 0; while(&lt;LOG&gt;) { chomp; $line++; if ( /^Last seen \[([^\]]+)\] from \[([^\]]+)\]$/ ) { my ($name, $ip) = ($1, $2); if ( $names-&gt;{$name} ) { print "12-10-10: Last seen user $name from [$ip]\n"; } } else { print STDERR "Line:$line did not match expected regex $_\n"; } } close(LOG) || die "Could not close ($file): $!"; } sub main { die "usage: $0 file_of_names log_file" unless @ARGV == 2; my $names = get_names( $ARGV[0] ); process_log( $ARGV[1], $names ); } main();
&gt; He's smarter than the rest of us. More stubborn perhaps. I keep forgetting about `load_class()` when I need it most.
&gt; ... have you seen this? I've seen the case where the difference between Unix and Windows line endings was significant. When the shebang line ends with the unexpected line character--mostly (always?) Windows systems--the process launcher can get confused. Adding flags that `perl` must process fixes it. There may be a `mod_perl` configuration setting in play though.
You're welcome. Thanks for the offer, but I'm surely not local.. [no earthquakes here](http://www.reddit.com/r/AskReddit/comments/ftmyc/building_a_first_aid_kit_need_ideas/c1j64gf). Cheers.
MOOOSE! I still am curious about this stuff... It's an OOP framework right?
Aha, it was probably a line ending issue then. I don't think I've seen this come up since back when 1) I used Windows as my primary OS, and 2) I used some random company's shared web hosting. Since moving to Linux and running my own Linux servers I haven't seen the issue come up again (but I've also been in the habit of always adding -w too, so never thought to test it). After posting that I tested removing the -w on one of my CGI scripts and it didn't break. :)
Also you can print combinations of variables and strings using . I think this would work for subs as well? print fib(sum) . "\n";
Agreed, but here it would just be confusing, unless you explicitly want that behaviour you should specify it as &lt;STDIN&gt; At least, imo :)
Not recommending this at all for numerous reasons but here you go: perl -E"say grep{s/^Last seen user (${\join '|', grep {chomp} `type names.txt`}) from \[(.+)\]$/$1=$2/o} &lt;STDIN&gt;" &lt; lines.txt &gt; ips.txt Also, does anybody know why my s//**o** doesn't DWIM (not that I can see anywhere in any doco that suggests it would or should)?
This is a bit out of place, but I wanted to mention your book helped me improve the code I'm currently working on. The line about not using class functions except for constructors helped me remove a module from my structure and simplify things. In addition, the part about passing immutable objects into constructor and performing all validation there really clued me into some OO problems I've been having for a long time. Great book!
I'm so glad I stumbled upon this thread. I was just "require"ing some Moose classes and felt I must be doing something wrong. I tried searching on the net for a way to dynamically load Moose classes but could not find anything... just refactored using Class::MOP::load_class() - so much better! Thanks!
You also can, and probably should, give print() a list of arguments rather than concating them yourself. print fib($sum), "\n";
You should unpack subroutine arguments into variables, rather than referencing elements of @_. The rare exception is when performance is an absolute priority ... in which case you should be using Inline::Asm. &lt;code&gt; sub fib { my ( $number ) = @_; return $number if $number &lt;= 1; return fib( $number - 1 ) + fib( $number -2 ); } &lt;/code&gt; Occasionally, using a routine twice makes code clear, but saving a subroutine return value in a variable is generally more efficient &lt;code&gt; my $N = 1; FIB: while ( my $sum = fib( $N ) ) { print "fib( $N ) =&gt; $sum.\n"; last FIB if $sum &gt; $LIMIT; } &lt;/code&gt;
Very nice and clean, I love to see examples like this :)
"type" is not an executable, it appears to be a bash built in function. But when called within back ticks it gets an error. So, this is for windows right? Ok I replaced "type" with "cat". And now I see you're building one big regex with all names pipe delimited. And I also see why you're annoyed that /o doesn't work and force the regex to be compiled only once. (I had to google "perl o modifier" once "man perlre" didn't list o in its modifier summary; TIL /o). Next there are some minor typos. flip "Last seen user " to "Last seen \[" and add the matching "\]". You've already got the \[\] around the ip. So yeah it works. $yoghurt_fiend-&gt;geek_points++ Unix version. perl -E'print grep{s/^Last seen \[(${\join "|", grep {chomp} `cat names.txt`})\] from \[(.+)\]$/$1=$2/o} &lt;STDIN&gt;' &lt; lines.txt &gt; ips.txt And in hindsight, I see the "12-10-10:" in the original post was an example of input which differed from its other example input and there is no example output format. So your user=ip is valid output, whereas my output is just a bizarre misinterpretation.
No kidding! So does that basically pass an anonymous array to print? Is there any particular change in functionality?
`$sum` not `sum`
what about use utf8::all; ?
Probably missing something, but here's what I've come up with. #!/usr/bin/perl use 5.010; use autodie; use Regexp::Assemble; use Regexp::Common qw(net); my $names_re = Regexp::Assemble-&gt;new-&gt;add_file('file1.txt')-&gt;re; open(my $log_file, '&lt;', 'file2.txt'); while (&lt;$log_file&gt;) { if ( /Last seen (?&lt;name&gt;$names_re) from (?&lt;ip&gt;$RE{net}{IPv4})/ ) { say "$+{name}: $+{ip}"; } }
Just to point out, you don't necessarily need Perl for this: $ cat names | while read NAME ; do egrep "user $NAME\b" logfile ; done | awk '{print $5, $7}' &gt; names_and_ips Or somewhat faster: $ PATTERN=`cat names | tr "\n" "|" | sed 's/|$//'` $ egrep "\b($PATTERN)\b" logfile | cut -f 5,7 Or even: $ grep 'Last seen' logfile | cut -f 5,7 | sort -u &gt; all_last_seen $ sort -u names | join - all_last_seen &gt; names_and_ips I certainly encourage you to learn Perl, as it is infinitely handy. However, it's also good to be able to do simple things directly from the command-line :-)
Or, with perl &gt;= 5.10: use 5.010; # put this at the top of your code file say fib($sum); # appends the \n for you
`print` takes a list of arguments. (The difference between a list and an array is significant.) The only change you might see between providing a list to `print` and using string concatenation to provide a single argument is that string concatenation enforces a scalar string context on `fib($sum)`. In this case it's not relevant, but evaluation context is important to understand. Consider: my @args = qw( foo bar baz ); print @args, "\n"; print @args . "\n";
Yes.
Interesting, thank you! As for lists, you make a good point. Here's my understanding for anyone else interested, correct me if I'm wrong: 1.) All arrays are lists 2.) All hashes are lists 3.) Hashes and arrays differ only by interpretation 4.) An array is a list where every-other value in the list is an index. An array is a list that looks like: index, value, index, value, etc 5.) A hash is a list where every-other value in the list is a key. A hash is a list that looks like: key, value, key, value, key, value. This is why you sometimes have to force interpretation as an array or hash, so that perl knows how to handle the list. Something like that, anyway?
Never heard of say. Nice!
&gt; All arrays are lists Not really. An array is a first-class data structure of elements accessible by integer indexes. In list context an array evaluates to a list of its elements. You can also assign a list to an array's elements. &gt; All hashes are lists Again, not precisely true. In list context, a hash evaluates to a list of key/value pairs. &gt; Hashes and arrays differ only by interpretation I don't know what that means. Perl 5's internals have completely separate data structures for arrays and hashes. There is no internal data structure which represents a list--there is no such thing as a first-class list data structure in Perl 5. You encounter lists in two places in Perl 5. One of them is a list of comma-separated expressions. Perl represents that in the optree (the internal representation of a program and its execution order). The other is the stack which holds arguments and return values. You *can* access the latter via `@_` when accessing the arguments to a function, but `@_` is an array and you deal with it as an array. If that's still seriously muddy (and it's not easy to grasp the first time), consider this: print $item; print $foo, $bar, $baz; print @items; print @items, $foo, $bar, $baz; In every case, `print` takes a list--even if the obvious reading to someone who doesn't know that `print` takes a list makes it look like `print` can take a single variable *or* a list. In every case, `print` takes a list of zero or more elements.
Thanks for the detailed reply! I think that my interpretation of array vs hash vs list is still muddied. Due to things like "wantarray" which really just checks for list context, combined with looking at arrays and hashes in the debugger gave me the impression that there were two things in perl: scalars and lists. "hash" and "array" are just ways of interpreting lists. As opposed to C, in which IIRC they are completely different data structures?
&gt; Due to things like "wantarray" which really just checks for list context.... `wantarray` has one of the worst names in Perl 5. Its documentation has said "This function have been named `wantlist`" for at least a decade. That definitely confuses novices. &gt; ... gave me the impression that there were two things in perl: scalars and lists In one sense, you're right. There are three separate amount contexts: no things (void), one and only one things (scalar), and zero or more things (list). Perhaps it's unfortunate that Perl 5 uses scalar to describe an amount context as well as a first-class variable type. My book [Modern Perl](http://onyxneon.com/books/modern_perl/index.html) explains context very early. (You can download a free PDF or ePub version from there.) Perhaps that will help clarify the relationship between context, lists, hashes, and arrays.
IIRC, "Cream" is also used for a popular, custom/stuff-added version of Vim. http://cream.sourceforge.net/ In that Cream is an editor that is / could be used to edit Perl, your name choice might be a bit confusing. I was trying to think of a baked product that includes strawberries, but "strawberry compote" doesn't quite seem to cut it. How about "Stawberry Pop"? ["More sweetness", "with sugar", or similar catch-phrase] (Pop == soda, depending upon your demographic.) Edit: Or just "Stawberry Pie", maybe. Edit, again: Missed the obvious: "Strawberry Jam".
Indeed. One that, like most things in Perl, you can use only the features you are comfortable with and do everything else the "old fashioned" way. It's got a lot of dependencies, though, so be aware when deploying a new project with Moose; people will complain that they have to download a lot of crap.
Or "Strawberry Fields", "fields" as in "field full of Perl modules". And shorter "Perl SF" ofcourse :) 
Yeah, Cream is out. I like "Strawberry Jam" very much though I am not sure if you meant the food or the session. As in Strawberry Jam Session where all the CPAN modules play together?
Very nice and modern framework for Perl. Cool.
&gt; What would you suggest if I only needed the top 50 highest domain name occurrences? You need to sort the keys of the hash based on the values of the hash. With the keys in sorted order, you can loop through them and access their values: my @top_domains = sort { $counts{$a} &lt;=&gt; $counts{$b} } keys %counts; `sort` isn't obvious the first time you look at it, but when you look at it right to left it makes more sense.
I was thinking of the food. But, whatever works! (multiple interpretations/puns FTW) P.S. TMTOWTDI P.P.S. But I was also definitely thinking of the pieces "jamming together", as in a music session. I'm just not familiar with a pre-existing, formal definition of "Strawberry Jam Session". A cultural reference that I missed?
I found the characters which match /s/i, e.g perl 5.10 the below #!/usr/bin/perl #for my $code (0x53, 0x73, 0x17f, 0xfb05, 0xfb06) { for my $code (0x0..0x10FFFF) { my $char = chr($code); printf("Hit char=($char), hex=0x%x, dec=%d\n", $code, $code) if $char =~ /s/i; } I suggest you run it with 2&gt;/dev/null, here's the output perl 5.10 Hit char=(S), hex=0x53, dec=83 Hit char=(s), hex=0x73, dec=115 Hit char=(ſ), hex=0x17f, dec=383 Hit char=(ﬅ), hex=0xfb05, dec=64261 Hit char=(ﬆ), hex=0xfb06, dec=64262 While Perl 5.14 /s/i matches only the first three above 0x53, ox73, 0x17f, which agrees with java. // java search for "s" characters.. turns up 3 "s" characters public class S { public static void main(String args[]) { for( int i = 0; i &lt; 0x10FFFF; ++i ) { String s = new String( Character.toChars( i )); if ( "s".equalsIgnoreCase(s) ) { System.out.printf("Hit ("+s+"), hex=%4x, dec=%5d, is an s\n", i, i); } } } }
Thanks for the additional information! 
Interesting++ but++ the++ constant++ pluspluses++ were++ a++ little++ distracting++
DBD::MySQL compiles perfectly fine on Strawberry 5.12, or on Linux with the MySQL headers. &gt; DBD::MySQL 4.019 will not build on any version of Strawberry Perl. This has been reported to the author. (4.018 will build, and is included with Strawberry Perl.) Just use 4.018 it's only one minor version away from HEAD. See the [bug info here](https://rt.cpan.org/Public/Bug/Display.html?id=68503). 
In future it is planned to regularly release Strawberry Perl Professional which will include Padre and several other Perl development tools.
That seems to be a Perl 6 &amp; Parrot community practice. It can be a little much, but I appreciate the effort people in those communities seem to put into making others feel appreciated for their work. That's something I'd really like to see backported to Perl 5!
Thanks for this tip, by the way. Memoizing is great. I reworked the algorithm in Ruby: require 'memoize' include Memoize def fib(n) return n if (n &lt; 2) fib(n-1) + fib(n-2) end i = 1 memoize :fib; while (sum = fib(i)) &lt; 4000000 puts sum i += 1 end
Yes, now have fun compiling it when you don't have the headers and aren't root. I said difficult, not impossible.
No. I am just mixing the words.
... You can't link into anything anything without the headers. This is hardly an argument against Strawberry, or MySQL.
Or use word boundaries.
I use strawberry when forced on Windows side also i recommend Strawberry usage with Firebird driver https://github.com/mariuz/perl-dbd-firebird 
These are not one liners.
They're not very impressive either
FTA: $ perl -MList::Util=sum -E 'say sum(1..1000)' Or, you could impress an employer with actual *efficiency*: $ perl -e 'print $ARGV[0] * ($ARGV[0] + 1) / 2 . $/' 1000 Crappy algorithms aren't going to impress anyone, no matter how many language tricks you pull out of your bag.
I added a note to clarify that the one-liners are not one-liners, and neither are they impressive. ಠ_ಠ The subject was stolen from the [original article](http://solog.co/47/10-scala-one-liners-to-impress-your-friends/) about Scala - I mainly wanted to compare the Perl implementation to the Scala one.
Most of these aren't one liners, they're just expressions. Most of them can also be written better... Here you're iterating twice for no reason.. perl -E 'say for map { $_ * 2 } 1..10' Just do -E'say $_*2 for 1..10' Your algo for checking if a word exists in a string is slow. If one liners don't matter... my %tweet_words; $tweet_words{$_}=1 for split /\W/, $tweet; say $tweet_words ? "found [$_]" : "not found [$_"] for @wordlist; List::Util is nice, but for one liners this will achive the same effect. perl -00E'my $foo = &lt;&gt;; print $foo' foobar.txt Again, you seem to be hellset on using `for` and `map`... you should pick. say for map { "Happy Birthday to " . ($_ == 2 ? "dear Name" : "you") } 0..3; but rather, say "Happy Birthday to " . ($_ == 2 ? "dear Name" : "you") for 0..3;
Geez, nitpicking is fine but just be nice about it. He was simply following the format of the other articles, and made no claim to be writing the most efficient code.
Question: Should I be doing something different with the file header that tells the program which Perl to use? #!/usr/bin/perl 
*Somebody's* internet penis was feeling awfully small today~
The &lt;SOURCE&gt; bit in the while loop actually reads a line, so you're reading twice per loop. That's why you only see results for lines 2 and 4. You can read once and assign to a variable: while (my $line = &lt;SOURCE&gt;) { my @counter = ($line =~ /^\s+\d+/ig); print "result @counter\n"; } Or you can drop it entirely. The line is automatically stored in the '*$_*' variable and $_ is the default variable for regular expressions. This does the same thing as above: while (&lt;SOURCE&gt;) { my @counter = (/^\s+\d+/ig); print "result @counter\n"; } If your input is a whitespace-separated list of fields, you can use [split](http://perldoc.perl.org/5.8.8/functions/split.html) to get the fields out: while (&lt;SOURCE&gt;) { chomp; # remove trailing \n my ($counter) = split; print "result $counter\n"; } Finally, if you opened SOURCE yourself, you should use the [three argument form of open](http://stackoverflow.com/questions/1479741/why-is-three-argument-open-calls-with-lexical-filehandles-a-perl-best-practice) where possible.
No problem! Let me know if anything I've posted is unclear :)
 # Switch perl in the $PATH perlbrew switch perl-5.12.2 perl -v This will switch between the perl versions So if you want to switch to lets say version 5.10.1 perlbrew switch perl-5.10.1 perl -v You would get perl version 5.10.1
I switched 5.14 Should I stop writing the header with the location of Perl in my programs?
 # Switch perl in the $PATH perlbrew switch perl-5.12.2 perl -v This will switch between the perl versions So if you want to switch to lets say version 5.10.1 perlbrew switch perl-5.10.1 perl -v You would get perl version 5.10.1
Did not know about the implicit whitespace-splitting of *split*. Cool.
Yeah, that's right. You and everyone else are free to respond in your next coding interview, "Sure, I'd sum a thousand consecutive integers with an O(n) iterative solution, in Perl!" Look, I *have* a good job. Plenty of people reading these boards are trying to learn how to make something of themselves as developers. If you think I'm doing this "for me," you have a ridiculously overvalued sense of Reddit karma.
To add to this, it makes things a lot clearer if you do something like `while( my $line = &lt;SOURCE&gt; ) { `and operate on `$line` instead of implicit `$_` -- I've found I make far fewer mistakes by being explicit.
Seconded. I did start doing that this way after reading Perl Best Pratices, it's much clearer.
Try replacing "print $rcon-&gt;response();" with: my $resp = $rcon-&gt;response(); $resp =~ s/^.*Players //; print $resp; **Edit:** Ignore me. I was misled by the formatting screwiness in the question. Looks like frodwith has the right idea.
for whatever reason, the formatting of your question looks a bit screwy. But if it's in two lines, you could go: my @lines = split /\n/, $rcon-&gt;response; print $lines[1];
I don't care how simple your program is. If it's in a file, put this line at the top of it. Do this always. use strict; 
Frankly I don't know who you're doing this for, if not yourself. I never said anything about impressing an employer in the post. I wasn't looking for efficiency, I was comparing syntax and style. And I sincerely doubt that anyone looking for a job would chance upon my post and assume that my solutions would be optimised for performance, since I made no such claim.
I'm unclear on why anyone cares about Nelson's opinion. So he doesn't like Perl. I don't like beets. It's a big world.
I believe Aristotle intended this as an object lesson rather than a serious rebuttal of an informed opinion.
Assuming your script is above in its entirety and not just a "this is what I think the problem is" sort of paste, your output comes from print $rcon-&gt;response(); `$rcon` is an object, created by the `Rcon::HL2-&gt;new()` method. Since `Rcon::HL2` isn't on CPAN, if you want to alter the output directly, consult the documentation for `Rcon::HL2`. The easiest way, assuming you're got a fairly complete Perl install, would be to use `perldoc Rcon::HL2`. Failing that, go looking for `Rcon/HL2.pm` somewhere, open it in your favorite text editor, and start looking for `sub response` and start editing.
Thank you, and thank everybody too. I feel a bit dumb once I saw the solution. But yes, it's in 2 lines. I also went and took it a little further now, split()'ing the one response line and rewriting it into rrdtool-esque response files, and now all I have to do is fight with cacti. Yay! and boo! Thanks, many times thanks. 
Thanks, this module doesn't have much to it - basically "send this to the server using this password, and wait for the response". So all that logic is now left to me. But with the help of here and a few friends I got it figured out, and of course felt stupid afterwords. But hey, I learn a little, not so bad hehe. 
If you have a lot of stats and which to order them in a neatly matter, there is always [Text::Table](http://search.cpan.org/~shlomif/Text-Table-1.122/lib/Text/Table.pm)
`&lt;pre&gt;` tags with variable width font. Argh.
Fantastic to see this book being updated! Thanks Tom Christiansen for all the time into this.
Wow, very polished. In particular I noticed some distributions have source/bugs links pointing to github rather than RT. Moving away from RT perhaps? There is a lack of integration with the rest of the CPAN ecosystem though, particularly AnnoCPAN, test results (inline rather than externally linked) and module reviews.
I've had 'em all - even though they're not all still in my collection ('sniff), so I'll be getting this one too even though I'm not doing as much Perl as I used to.
Where? All code containers are &lt;div&gt; elements, with monospaced fonts as far as I can see...
[Not here](http://i.imgur.com/3SMpE.png)
I know what to tell my girlfriend to get me for my birthday :D
So, is a "Rouge Cuts" going to hit Safari, per chance?
At first "blush", I would say probably likely.
Oops! Good riposte! s/Rouge/Rough/ 
i suddenly have an erection
That is unexpected. Nice.
I am with you on those beets. :) 
You have Javascript disabled, I guess? It seems that the syntax highlighting is done client-side, and for some reason the highlighting code also applies the correct font. I opened an issue on GitHub for you: https://github.com/CPAN-API/metacpan-web/issues/39
 @$name = qw(this will work); will work. But you are almost always better off using $array{$name} = [ qw(will this work) ]; for reasons that have been explained many times; you might want to look at [Why it's stupid to `use a variable as a variable name'](http://perl.plover.com/varvarname2.html) for example. 
That will work. But, that's called a symbolic variable. It's generally not a good idea. What you really want is: use strict; use warnings FATAL =&gt; 'all'; my %stuff; my $name = 'array'; $stuff{$name} = [qw( this is better )]; print "@{$stuff{'array'}}\n"; Much much better.
Hello. It's possible, but by god you shouldn't be doing it like this. This should work: no strict qw/refs vars/; $name = "array"; @{"$name"} = qw/foo bar baz/; # quotes are optional print @array, "\n"; Output would be "foobarbaz\n" But don't do that.
There's more than one way to do what you're trying to do. Here's another way: my @array = qw/ will this work /; my $name = 'timmy'; my %name2aref; $name2aref{ $name } = [ @array ]; Then, when you want to access values in timmy, use: my $one_way = $name2aref{ timmy }-&gt;[0]; my $two_way = shift @{ $name2aref{ timmy } }; If you have a list of names: @names = qw&lt; timmy tommy jimmy bobby &gt;; for ( @names ) { my $name = $_; my @words; @words = @{ $name2aref{ $name } } if $name eq 'timmy'; say "Timmy's words are @words!"; }
Best news I've heard in a long time! I'm buying every single one of those. _Really_ psyched.
You'll be happy to hear that I haven't used symbolic references since you kindly explained that to me.
I believe PHP call these "variable variables," and even they (*even PHP*) generally agree that it is a bad idea to use them.
[Why it's stupid to `use a variable as a variable name' ](http://perl.plover.com/varvarname.html)
This is as much about perl as a spring is about a mechanical pencil.
Well, I finally got around to trying it out. The 'if module' works, but i can't seem to get it to work with "use lib". Do you have any ideas? I tried "use condition, fullpath.pm =&gt; args" but that didn't work, I also tried "use condition, lib path" to no avail. Right now it seems that "require" and then "module-&gt;import" is the best option (as per http://www.perlmonks.org/?node_id=238691). Thanks for your input!
&gt; The 'if module' works, but i can't seem to get it to work with "use lib". Without seeing your code, I can only say that: use lib 'some/path/here/'; use if $condition, module =&gt; qw( import list ); ... *should* work in almost every case. Be careful that `module` in that second line should be the Perlish name of the module and not its path. 
The problem being that the "lib" has to change as well, but "module" is different. Basically, the module is the same but lies in different locations. (This isn't my code, I'm just latching on to an existing system)
You can do something like: BEGIN { my $lib = ...; eval "use lib $lib"; } ... but there's definitely a complexity tax once you start down that road.
yeah...that's kind of what I wound up doing. Except that "eval use.." didn't really work. For now it's "require" for me! Thanks a lot for your input!
[Original thread](http://www.reddit.com/r/perl/comments/ho8yx/)
Basically do this: * Use the glob() function to get a list of files matching *.JPG * Use a for() loop to iterate over the list of files, and: * Use a regular expression to create a new filename in the new format you want. * Use the rename() function to do the renaming.
using standard modules: #!/usr/bin/perl use File::Copy; use File::Find; find(\&amp;wanted, qw(.)); sub wanted { return unless /DSCF/; (my $new = lc $_) =~ s/DSCF/XY/i; move $_, $new; } edit: must be called from the directory in which the pictures reside, didn't test it
 #!/usr/bin/env perl use strict; use warnings; opendir(my $dir, '.'); my @files = readdir($dir); closedir($dir); foreach (@files) { $_ =~ /(DSCF(\d+)\.jpg)/; rename($1, "XY$2.jpg"); } 
You don't have to even use Perl, just use the built-in linux command rename: rename .JPG .jpg *.JPG rename [what-to-change] [what-to-change-it-to] [what-files-to-change] edit: if you need to run this in perl, just enclose it in backticks to run a system command: `rename .JPG .jpg *.JPG`
`rename 's/^DSCF(\d+)\.JPG/XY$1.jpg/' *.JPG` — `rename` is a commandline utility that comes with perl.
Doing it one location at a time from the shell: ls *JPG | perl -ne 'chomp; $a=$_; s/DSCF(\d*).JPG/PREFIX$1.jpg/; print "mv $a $_\n" if($1&gt;=MIN &amp;&amp; $1&lt;=MAX);}' | sh To make sure you're not doing anything stoopid, leave off the "|sh" at the end the first time around. (Of course, replace PREFIX, MIN, and MAX with the appropriate values). 
Oldie but goodie: [UGU's rename.pl](http://www.unix.com/unix-dummies-questions-answers/4170-transformation-capital-letter.html)
.JPG should be in caps in regex (or add /i). Also, won't that try to rename . and ..?
rename being a perl script - one worth looking at for how to do just such a thing.
 $ for f in DSCF*.JPG; do n=XY${f#DSCF}; mv "$f" "${n%JPG}jpg"; done If it's just a one-time thing no need to write a Perl script.
...and then run rename again... rename DSCF XY *.jpg 
Better if the first line of the loop was.... next unless $_ =~ /(DSCF(\d+)\.JPG)/;
Or even better: next unless /^(DSCF(\d+)\.jpg)$/i;
TIL.
or replace both lines with... rename($1, "XY$2.jpg") if /(DSCF(\d+)\.JPG)/; Golf - yay!
forgot the ^ and $ Might not be entirely necessary, but if somehow a file named "fooDSCF0000.JPGbar.txt" got in there, I'd rather it not be renamed.
I understand not writing a 1,000 line Java program for a one-time renaming program but the amount of times I've written one-time Perl scripts is ludicrous! I might be misreading you but you seem to suggest that writing a Perl script is hard or somehow needlessly complex? Obviously each to their own but I can't think of an easier way - even knowing Bash!
For huge directories: opendir(my $dir, '.'); while (readdir) { rename($1, "XY$2.jpg") if /^(DSCF(\d+)\.JPG$)/; } (And don't bother with closedir.)
you might be able to do this with pure bash, let me throw this out without testing it much, but this might work for i in `find . -regex ./DSCF.*\.jpg`; do eval "mv '$i' 'XY${i:6}'"; done; it will only work if you're in the directory, basically, what this does is execute a find to get all of the files you want to move, then loops through them, constructing the `mv` command as appropriate for each. It does this by substituting the current file name, then hacking off the first six characters (the `./DSCF` part), then eval'ing that command. it didn't do the substitution correctly w/o the eval, but for a one-line one-off bit of bash, it ain't bad. This could be made better by using `sed` to construct the command, and also making it handle being in arbitrary dir's better. but it's a one-liner. :) Oh, wait, this is /r/perl. Let me make that a perl script... perl -e "system \"for i in `find . -regex ./DSCF.*\.jpg`; do eval \\\"mv '$i' 'XY${i:6}'\\\"; done;\"" Ought to do it. :) 
I didn't think to use plain old globs, I used find in my comment above. This is better. I take it the `${v#STRING}` and `${v%STRING}` hacks off `STRING` from the beginning/ending of `$v`? I haven't seen those before, but if that is true, you just blew my mindhole.
rename is not a perl script. It's a gnutools c program. I think debian and variants use a rename script but in the rest of linux land it's the gnu c thing.
I have perl installed on multiple platforms and have never seen such a utility. I believe there is a rename script by larrry wall, but it does not come with perl.
Sometimes it’s called `prename`.
Hmm... okay, it *used* to be shipped with Perl from 1989 until 2000, but has since been split out under independent maintenance. Sorry for the confusion.
So much cleaner than I normally do, which is something like for i in D*JPG;do mv $i "$(echo $i | sed s/DSCF/HERRO/g)";done
I am a perl programmer but there is a much easier way to do this without perl. ls DSCF\*.JPG | sed 's/DSCF\\(.*\\).JPG/mv DSCF\1.JPG XY\1.JPG/' | sh does the job nicely. However, if you using this to help learn perl, then it isn't much help. :) 
For someone learning Perl, this is the best answer. I know we can all do it with one line, but as a learning exercise, I think this is your ticket. Except I'd use a foreach loop instead of a for. 
I don't get it.
OP had two requirements in his rename - JPG to jpg and DSCF to XY. JohnStow is talking about the second one, though your syntax is probably enough.
If you want a simple, working, safe solution: mmv (apt-get install mmv should do the trick) mmv -n 'DSCF*.JPG' 'XY#1.jpg' (-n for "dry-run", will show you what is going to happen)
TIL indeed. Been using perl for years and never knew about this 'rename' command. When I saw the heading, I was going to suggest writing a perl script ;)
That's it. v="abcdefabcdef" echo ${v%def} # abcdefabc echo ${v%def*} # abcdefabc echo ${v%%def*} # abc echo ${v#abc} # defabcdef echo ${v#*abc} # defabcdef echo ${v##*abc} # def echo ${v:3} # defabcdef echo ${v:3:6} # defabc echo ${v/abc/ghi} # ghidefabcdef echo ${v//abc/ghi} # ghidefghidef There maybe other but I've never used them. These is already pretty powerful :-).
I'm not saying writing a Perl script is hard or complex or anything. It's just that since your already in your shell, it's faster than opening your editor, writing the few lines of Perl and then run the script. Plus it stays in your Bash history so you can ^r for it quickly. As I'm writing this I realize maybe some people are not already in a shell when they want to do this, if they use a graphical file manager for instance. But I don't even have one installed on my computer so for me it's really faster this way. To be honnest, I think it's mostly a matter of taste, I won't fireup Perl for such simple tasks I can do in bash (and if I have to do it often it will be a shell script). :-)
So, the statement that it's not a perl script is demonstrably not true. It may *also* be a C program, but here it's perl... $ head /usr/bin/rename #!/usr/bin/perl -w # # This script was developed by Robin Barker (Robin.Barker@npl.co.uk), # from Larry Wall's original script eg/rename from the perl source. # # This script is free software; you can redistribute it and/or modify it # under the same terms as Perl itself. # # Larry(?)'s RCS header: # RCSfile: rename,v Revision: 4.1 Date: 92/08/07 17:20:30 
Debian-based versions of Linux install Larry Wall's rename by default. Redhat-based ones install a different rename utility.
Holy crap. Array slicing is awesome. Gentlemen, ladies, redditors, UPVOTE THIS PERSON.
I was under the impression that for and foreach are the same thing, and that it is just a style preference? Though the book I'm using to learn Perl from is a bit out of date.
I wrote this little perl script: https://github.com/gabrielrussell/gabriel-s-unix-toys/blob/master/emv Which writes a directory listing into a temp file, and then lets you edit the file, and then it performs the renames for you. This lets me do renames like those in question with a few keystrokes. I run emv, ( which runs vim, for me ) and type out the ex mode regex substitutions, make sure everything looks good and write and quit. It uses position in the file, so if you delete a line from the beginning of the buffer, and paste it in at the end, you'll effectively do a circular shift all of the filenames to the next file. But, then this also works great for the case where I have two files that have each others names. A quick swap of lines and I'm done.
oooooooh now i get it. thanks.
You're right! $ head /usr/bin/rename @$$Q�t/lib64/ld-linux-x86-64.so.2GNU 9�gx ��'���u$��H�6=��O+V&gt;,��%|X__gmon_start__libc.so.6__printf_chkexitsetlocalestrrchrdcgettextstrlenstrstr__errno_location__fprintf_chkmallocstderrrenamebindtextdomainstrerror__libc_start_mainGLIBC_2.2.5GLI BC_2.3.4ui �ti ��`X`�`�`�`�`�`` ` 8`@`H`H��C���=H���5� �%� @�%� h������%� h������%� h������%� h�����%� h�����%� h�����%� 
It's a style/ readability thing for me. I just find this cleaner. I use foreach loops probably 99.9% of the time when I need to loop over a list of things. I looked at the code I have at work, and don't have any Perl 'for' loops in the last 6 months. foreach my $photo ( @photos ) { # rename your $photo here compared to for ( $x = 0; $x &lt; scalar ( @photos ); $x++ ) { rename $photos[$x] here 
[rename](http://search.cpan.org/~rmbarker/File-Rename-0.05/rename.PL)
But can't you do a for loop with the same syntax as the foreach loop in your example? for my $photo (@photos) { #rename photos } Page 17 of this [PDF](https://docs.google.com/viewer?url=http%3A%2F%2Fblob.perl.org%2Fbooks%2Fbeginning-perl%2F3145_Chap04.pdf) is where I'm getting that from. 
Those are not secrets, just type `man bash`, there are also `^` and `^^` to convert to uppercase, `,` and `,,` convert to lowercase (they work as `%` and `#`) and `${#var}` which returns le length of `var`. And some ways to have default values (`${var:-valueIfEmpty}`, `${var:=valueAndAffectIfEmpty}`, `${var:?errorIfEmpty}` , `${var:+valueIfNotEmpty}`). Many of those also works on arrays and not just strings. Also `${!foo@}` will expand to the name of all variables starting with "foo" (for instance `echo ${!SH@}` expands to "SHELL SHELLOPTS SHLVL" in my shell). For more bash fun, just go through the man pages :-).
`for` and `foreach` are indeed synonyms. I never type the extra four characters in `foreach` except to explain that `for` is always shorter. (In my book [Modern Perl](http://onyxneon.com/books/modern_perl/index.html) I try to refer to the manual iteration as a C-style loop and the implicit iteration as an iteration loop, but the terms `for` and `foreach` are well ingrained in Perl culture.)
Unfortunately, the man pages are long, and sometimes the good stuff gets buried. :) Also, typing `man &lt;anything&gt;` is an admission of defeat. However, that's super awesome stuff. Bash is such an underrated and oft-forgotten language. 
Well I wasn't expecting a response from the author of a Perl book! I'll have to take a look at your book the next time I dabble in Perl. It's very cool of you to offer it for free in the hopes of donations.
Crazy. TIL, then. I first learned Perl 10-12 years ago and just checked out my old O'Reilly books and they didn't have examples of this use of 'for', which makes your book completely useful. :) 
They've been synonyms as long as I can remember. See the first sentence of the *Foreach loops* section on page 100 of the second camel, for example: *The **foreach** keyword is actually a synonym for the **for** keyword, so you can use **foreach** for readability or **for** for brevity.*
So an answer on a perl forum about renaming files using perl, referencing a perl script that renames files is wrong, but a [claim](http://www.reddit.com/r/perl/comments/hvtdk/batch_renaming_image_files_from_dscfjpg_to_xyjpg/c1ytdpb) that "rename is not a perl script. It's a gnutools c program." is defensible in the face of evidence that this, while true for some domains, is not true universally. I look forward to never having to maintain anything you write based on your grasp of logic and how it interacts with non-canonical cases. Thank you for playing.
Thanks, I was going to ask same question as OP here. But I think I will wait for 6th edition of this book.
Why cramfs, and not something more modern with better compression like squashfs?
Unfortunately, this comment won't be helpful, but more of an "I can relate." I've been tinkering with some microcontrollers recently, and I started wishing that, instead of having to use C++, I could use Perl.. On a Harvard architecture with 32K of storage, 2K of RAM.
Take a look at [Perlduino](http://www.perlworkshop.nl/nlpw2011/talk/3277) Unfortunately that's the only link in english I can find, but I should have some old code from Martin, can send it to you if you wish.
Please do! I had assumed that the non-compiled nature of Perl meant it would never work on an Arduino; how silly of me..
You might want to try [staticperl](http://search.cpan.org/perldoc?staticperl).
'microperl' compiles to ~1.6MB on my Linux system and 'miniperl' is 1.2MB (both dynamically linked) so it is likely possible. You wouldn't have modules with either of those but 'miniperl' has most of the usual features.
cpan.org seems fine. 
working for me. What kind of problem are you having? I recently had to configure some things when I was sitting behind a web proxy. 
Fixed -- thanks
Who are you replying to?
Try [select](http://perldoc.perl.org/functions/select.html).
[This comment](http://www.reddit.com/r/perl/comments/hvtdk/batch_renaming_image_files_from_dscfjpg_to_xyjpg/c1yxoq0). Maybe you didn't mean it to come across as a snide comment, but that's certainly how I read it - sorry if it was not intended.
And for an OO interface, [IO::Select](http://perldoc.perl.org/IO/Select.html) is nice.
 use List::AllUtils qw( any ); while ( my $line = &lt;INPUT&gt; ) { chomp $line; if ( any { $line eq $_ } @list ) { print "$line matches\n"; } } There are other ways. This is the clearest expression of your stated intent.
is there any way this is possible without the use of any cpan modules? i am using this command on multiple machines and cannot install it on all of them. thanks for the help, if it comes to it i can probably do it some long way, but i have about 30 words to match so i obviously don't want 30 lines of code (that has to be reused multiple times)
Just winging it here: sub any (&amp;@){ my ($test, @list) = @_; for(@list){ return 1 if $test-&gt;($_); } return 0; } (Or just steal the code from the source to List::MoreUtils, which probably looks very similar to that.)
If you're lucky enough to be developing for someone who has _upgraded their fucking perl_ in the last five years, you can use smart matching. "foo" ~~ [qw/foo baz/]; # True "bar" ~~ [qw/foo baz/]; # False
Tangental to your question, but current best practices is to use [three argument open](http://www.modernperlbooks.com/mt/2010/04/three-arg-open-migrating-to-modern-perl.html) with lexical scoping. open my $INPUT, "&lt;", "/bla/bla/bla"; while(&lt;$INPUT&gt;){ ... } close $INPUT;
Pretty damn close (although `List::MoreUtils` uses a much faster XS version by default): sub any (&amp;@) { my $f = shift; return if ! @_; for (@_) { return 1 if $f-&gt;(); } return 0; } And in case anyone out there isn't aware of `perldoc -m`, now you know. It's incredibly handy to peek at the source of a module. 
First, I'd question if using Perl here is wise. It seems like an extra step. You've obviously got the scancodes for your keyboard. Modern linux distros handle (at least in X) multimedia keys fine. In gnome, just fire up the "keyboard shortcuts" from some system menu, and start mashing keys. An ubuntu-specific alternative (and one I had to use for my MS media keyboard) was a program called "KeyTouch" (packaged as 'keytouch' and 'keytouch-editor', they do what you'd suspect). As for the script itself: * Stop using global file handles. Use things like `open my $in, "&lt;"` and so forth. * Read up on [POE](http://poe.perl.org/). Rewrite your script in a daemon-y way, waiting for events instead of a constant loop. At the very least, it makes changing things easier, and gives you the ability to do a clean shutdown.
If speed is an issue then convert the list to a hash: my %days_hash = map { $_ =&gt; 1} @days; And now you can check if a value is in the list very efficiently by: if (exists $days_hash{$_}) { .... If you *really* want to go the regex route, and there should be a very good reason as there are many better ways, then you'll need to do something like: my ($days_re) = map qr/$_/, join "|", map quotemeta, @days; And then in your loop: if (/$days_re/) { ... 
Just copy the code. That's the point of FOSS. But, if you're unable to control the Perl you're using, then you have a bigger problem. Just saying.
Idiomatic (for me) way to do that first bit: my %days_hash; @days_hash{@days} = 1; Only fills the first one with "1," and the rest are "undef," but exists() still returns what you'd expect. (And you don't really need to call it _hash. It's pretty obvious when you either give it the % sigil or curly-braces.)
:cry: - enforced 7 year old version of perl user here.
&gt;Modern linux distros handle (at least in X) multimedia keys fine. That may be so but not in case of this keyboard. Granted I use gentoo but I tested it under Linux Mint and none of the multimedia keys would work as well. That's why I had to make a script. And thanks for the link, I never tried to do anything with the objective oriented side of perl. I'll give it a try.
Thanks man, I'll have to investigate that.
It appears I was wrong. Using the keytouch-editor I managed to get the keys I needed to work. Thank you kind and wise sir for your help.
Wrong again, it appears X doesn't support scancodes above 255, which means keytouch can recognize them but can't map them. Ah well.
also the op is opening the INPUT file for writing not reading ( open ( INPUT , "&gt;/bla/bla/bla") ; )
&gt; It was his dad, a proficient Perl programmer, who got him coding on early Perl apps at seven. A year earlier, his mum had started him on HTML. Wow, what great parents! 
this worked, thanks!
got this working as well, will probably use this instead since its faster. thanks both of you guys.
use smart match use 5.010; @days = ( "monday", "tuesday", "sunday" ) ; $_='monday'; if ($_ ~~ \@days) { say $_; }; 
&gt; And you don't really need to call it _hash When I first typed out the comment I wrote `my %days = ... ` but I reconsidered as having several variables with the same name is a tad confusing and not exactly something you want to encourage, at least in my book. 
You can run a chain of Unix commands in the shell, using the system command: system "p4 change -o | sed -s'/enter description here&gt;/$argv[1]/' | sed '2027,$d' | p4 submit -i"; or you can figure out the P4::C4 set of modules at CPAN, and do it in pure Perl.
I read that as "teen sluts" ... 
If you care about the values ... @days_hash{@days} = (1) x @days; On the left hand side, @days is expanded into the set of values. On the right hand side the 'x' is a list repetition operator, it will turn the list (1) into ( 1, 1, ... , 1 ) containing the number of elements specified by the value on the right hand side of the 'x'. This scalar context causes @days to report the number of elements it contains, producing a '1' value for each hash tag.
I always use a plural word for arrays, which makes it reasonable to use the singular for one element: for my $day ( @days ) { .. } Hashes usually map a tag T to a value V, so I often use the domain and range type names joined with '_4_' : my $month_num = $month_num_4_month{$month_name}; 
Nice. I knew 'x' was a string replication operator, but I didn't know it worked in list context. Awesome.
That's true.
This is awesome. Really happy for this dude.
I don't know much about sed, I think that second command deletes anything from line 2027 onward. I'm not sure why that's needed in the context of your Perforce commands. Are you really submitting changelists that have more that 2027 changes? Anyway, this is how I'd do it: $description = "Change description goes here$/"; $cutoff = 2026; ## minus 1 because perl lists start at element 0 open($change, "-|", "p4 change -o"); @changelist = &lt;$change&gt;; close($change); ## replace the description map { s/^\s+&lt;enter description here&gt;\s*$/$description/; } @changelist; ## cut off anything past line 2027 splice(@changelist, $cutoff) if @changelist &gt; $cutoff; open($submit, "|-", "p4 submit -i"); print $submit @changelist; close($submit);
Yes that is correct, it is deleting anything from line 2027 onward. I am submitting some large changelists. The point of the script was to break them up into chunks so I don't hold file locks for too long. I will try that code. Thanks for the help!
I was trying to avoid the Unix chain. The reason I needed to change to perl was because I was submitting files to Perforce that had funky file names, like .$0. CSH was interpreting that as an argument.
I dislike this kind of naming. It seems overly verbose to me. That said, it's interesting that you use 4. At work, there's a guy who uses 2, but in the opposite order as you. So: key2value, value4key. Drives me crazy. In this case, the hash doesn't map a key to a value. It's just acting as a pure hashed list of items. What would you call it then?
Why the hostility? Lots of people can't upgrade their Perls for any number of reasons.
&gt; any number of reasons Name five.
way to go, i saw Phenona awhile back. Good idea.
What's wrong with `scalar grep /$test/, @days`?
wallpaper'd!
Except for a little bit of elaboration on the extended regex zero width matches, this is just the output of `perldoc perlcheat`. No need for an image of that... 
I prefer the 4 because the flow matches the logic: $value = value4arg $arg rather than $value = arg2value $arg In general, I try to use names that make a reasonable sentence reading the code. If there is a business logic interpretation for the hash, that is the best name, otherwise I use the mapping names above. So what is the business logic of this pure hash? What is the interpretation of the values?
- Hard to install - e.g. no root, compiler etc... - Ops won't support it because they say so (no rpm/deb, policy, bad day, name it) - no expert on hand, so the entire stack is in poor shape - operating system not supported yet, possibly ever again - a bug is now a feature that's depended on - i've seen encoding behaviour changes between versions of ruby make an upgrade not fun 
App::perlbrew. Install the latest perl in your home directory and use it in whichever subset of scripts you want.
TIL that TIL is an acronym for Today I Learned! (sorry for an off-topic comment)
If we are golfing :) /\d+\./ &amp;&amp; rename $_, "XY$&amp;jpg" should do it.
Fore! /\d+\./ &amp;&amp; `mv $_ XY$&amp;jpg` 
Changelog link?, even the [Perlmonks post](http://www.perlmonks.org/?node_id=910077) doesn't name the bugs fixed.
http://search.cpan.org/~jesse/perl-5.14.1/pod/perldelta.pod 
welcome! 
Perl is a swiss army knife. Incredibly versatile, but might be taken from you at airport security.
This sort of blog post is really refreshing to see. Thanks for writing it and I hope you have fun with perl.
That's true! And its community is amazing, I wish there was a CPAN for Java, a central repository to find all about Java libraries, though there are Maven repositories and Apache, it is not the same. 
Thank you! I sure will have fun with it, but I am concerned that I may get too used to the Perl "laziness" and won't come back to Java anymore :-)
That's brian d foy, not Brian d Foy. :-)
You are right darkon, fixed :-) Thanks for pointing it!
Google "Modern Perl" and "Enlightened Perl" and spend some time studying Moose and Catalyst. Perl has come a very long way from those early days. For command line programs, take a look at App::Cmd and MooseX::App::Cmd.
CPAN is like a secret weapon.
Or : &gt; du -h | sort -h See the manpage : &gt; -h, --human-numeric-sort &gt; &gt; compare human readable numbers (e.g., 2K 1G) 
Thanks. Most useful in combination with `du -hS`.
Your template isn't bad at all, but betrays the fact that you don't seem to know about certain tools available on CPAN. :) I'd suggest to look at the following modules for inspirations: - [GetOpt::Long::Descriptive](http://p3rl.org/GetOpt::Long::Descriptive) - [App::Cmd](http://p3rl.org/App::Cmd) - [MooseX::App::Cmd](http://p3rl.org/MooseX::App::Cmd) - [MooseX::GetOpt](http://p3rl.org/MooseX::GetOpt)
Thanks for your CPAN suggestions. What you stumbled upon was something I forgot to write in the documentation. The goal of the template is to use only Standard Modules. I updated the github page and the included README to reflect this. Thanks for checking it out.
So I looked at the man page and saw the above feature. I have not looked at the sort manpage in a while and I do not remember that feature before. So I did a git clone of coreutils and looked it up and found it was only added in April 2009. commit 159faba1376ffd5a46fe4bbc780d85dd3e502cea Author: Michael Speer &lt;&gt; Date: Mon Apr 27 14:51:29 2009 +0100 sort: new --human-numeric-sort option to sort KiB MB etc. edit: removed the email address I pasted in by accident
welcome, i recommend looking at catalyst, moose, dbix::class and modern perl.
My suggestion is to use `env` in the shebang instead of hardcoding a path. That way you get whatever perl binary is first in the PATH instead of forcing the system perl to be used. This makes it friendly to those that have multiple versions installed. 
I did a little bit of multi agent systems programming at university using, I seem to remember, AgentSpeak and JASON. I'd be interested to see what you're working on, any plans to put it on github or anywhere public?
First off I really doubt you spend an hour's worth of grepping to find a reference. Secondly, use the damn debugger! Simply set a break point in the function you're interested in and continue. You'll arrive there and the debugger will say what file that came from - problem solved, in under 30 seconds!
Also, see the [perldelta](http://search.cpan.org/~dagolden/perl-5.15.0/pod/perldelta.pod)
shout out to the testers. you found bugs in my crap.
that's not a good solution for production though. I have to include one of any number of modules, so it would be easier if they used "EXPORT" instead of "EXPORT_OK". As is, I have to look into each module and manually get the variables. At the moment, this means I have to have 5 copies of the script, one for each module. (as a "get this done" kind of thing) 
Another possible approach (which I haven't actually tried) is to use "du -b" to list sizes in bytes, sort the output numerically, and then filter the output of sort through something that converts the raw byte sizes to something human-readable. Note that "-b" implies "--apparent-size", which can skew the results; if you just want actual disk usage in bytes, use "-B1" or "--block-size=1". This all assumes the Gnu Coreutils version of du, though the idea is probably even more applicable to non-Gnu versions that might not have "-h".
Give them specifics, and maybe they'll be able to tell that story in their blog posts.
Why is $$ writeable now? Does it actually modify the PID at the OS level? I guess I just don't see the purpose of allowing code to mask the pid, but I'm sure there's some good reason I can't think of.
It also says "$$ no longer caches PID", so I suppose it's now just like a regular variable?? I know that will break a lot of my code and I don't like it a bit *sigh* *edit* according to [this bugreport](http://rt.perl.org/rt3/Ticket/Display.html?id=85520) it has just been changed to a call to getpid. This strikes me as a much more sensible thing to do :) 
People were finding various sneaky ways to make it writable, so this just make it more straightforward. I believe if you fork, it gets reset again.
Two things- * **Padre is awesome.** What is it on Windows, Strawberry with Cream? Anyway, I thought it would be a waste of time, and instead I've been really productive on it. Like just hit-the-ground-running productive. * **It needs non-I-threaded Perl support.** Padre won't run on a default OpenBSD installation because it includes Perl without I-Threads, and Padre demands this. I use both Windows and OpenBSD throughout the day, and it would be nice to kick back on the porch after work with my OBSD4.9 crap-lap and hack on some code. But I can't :/ *&lt;ensuing tears well up&gt;*
If the world were just you, or just me, this would suffice. We use the equiv at patch.com for ruby (though it only works on bash/zsh). We all have our requirements for a job. Maybe you must be able to wear jeans, or work 10-6 instead of 9-5. Perhaps you want root to your machine. Sometimes, someone will just say no and maybe they have a great reason. Maybe it's a bad one. But thems the breaks. 
&gt; It needs non-I-threaded Perl support I don't know how well it works on the BSDs, but have you investigated using [App::perlbrew](http://search.cpan.org/perldoc?App::perlbrew)? Have enough time and the right tools to compile perl already installed, etc. etc.
So, instead of fixing the bug, they just made the bad behavior ok? I still don't get it. Or did they basically make it a no-op, so you can write to it but it always returns the proper pid?
OP, perhaps pick a more descriptive title next time. I had no idea this was about Padre.
I think it's not about padre. it's about the youtube channel about Perl. it just happens that the top video on the channel is about Padre.
As shi said, the link itself goes to Gabor's youtube channel where he does screencasts about Perl, even if the reddit extension only picks up the first video in the channel.
Oh, I didn't know that, sorry. I have RES and I watched the video inline. Sorry again.
It's fine, i was expecting this to happen. :)
why not just use Devel::REPL/re.pl?
Because Devel::REPL has 5,000 dependencies.
What are the advantages of Devel::REPL over the built-in debugger?
AFAIK with the recent changes Alias made to Padre you can replace the threads with some other library for multitasking. I guess it could even work without any multitasking if you are ok with temporary freezes here and there. It "just" needs someone to actually implement this feature and then change the Makefile.PL to allow you to decide during installation.
Java sounds like it has really good Unicode support, but other than that it's rather opposite a dynamic language. Good reading.
CPAN to the rescue!
Java thinks that it's acceptable to call a bastardized version of CESU-8 "UTF-8". That's good Unicode support?
No, it doesn't support Unicode all that well. The supported version in Java 6 (the current version) is 4.0, over eight years old. Java 7 (about to be released) will support Unicode 5.1 (3 years old). Perl supports Unicode 6.0, the latest release (8 months old). Also, their regexp engine doesn't support Unicode character classes at all. Lastly, they use UTF-16 internally, which means you'll have to decode an encode a lot as almost everyone uses UTF-8 for interexchange. Perl is way better at Unicode than Java IMO.
Interesting read but my overall impression of that article is that the author is frustrated because perl is different that what he is used to with C#, as if it shouldn't have been expected. I mean, I can kinda sympathize with him on some points but mostly they are just growing pains that I would expect to go through when learning any language, not just perl.
hmm I did not see that in the post. I saw issues that people see (or imagine) or not see before they'd even touch Perl and I see issues with the learning curve. I am sure both could be improved.
Compared to many other languages, yes, even if not versus Perl.
Great post. Thanks for sharing.
That was almost puerile. Chromatic, you're a smart guy, you can do better than that.
Perl 6 is a community-driven project. If this random blogger doesn't like the direction *his precious Perl name* has gone in *without his consent*, tough. He only has his own antisocial tendencies to blame. Same for [everyone else](http://xkcd.com/359/) who brings this topic up all the time.
Not a random blogger, check out his work on CPAN: http://cpan.mirror.facebook.net/authors/id/A/AM/AMBS/
Oh, I take that back then. Second paragraph stands though.
Thanks for the feedback. I'll try to be more puerile next time. Maybe fewer *Foucault's Pendulum* references?
I can certainly understand the frustration on his part. People are making something new, for free, for everyone to use. It must be a bummer for others to nitpick instead of chipping in to help. Hang in there, chromes.
&gt; It must be a bummer for others to nitpick instead of chipping in to help. It happens. I don't particularly care about that. The desire to change the name of "Perl 6", however, distracts from real problems. Even if you could convince Larry (and that's not going to happen), you wouldn't solve anything useful.
&gt; JavaScript is Perl 4 awful in writing large projects, but it spins the pork pie hat of every skinny-jeans hipster in the tech world because it's there. I like that line.
Motherfucker, it's Saturday! That is all.
&gt; Perl 5 has no Larry. That Larry doesn't have to be the Larry, but a sufficient quantity of Perl 5 hackers must respect the new Larry as a suitable Larry. Does this imply Larry Wall doesn't work on Perl 5 anymore?
He has given advice on a couple of Perl 6 features added to Perl 5, but he spends his time working on the design of Perl 6 these days.
The problem is this line in `Pod::Simple::HTML::general_url_escape()`: $string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg; This use of `unpack` does not split up a unicode character into its individual utf-8 bytes, i.e. this prints 105 instead of C4,85 $ perl -E 'say join ",", map sprintf ("%02X", $_), unpack "C*", "\x{0105}"' 105 This explains the %105 output, as it's trying to escape a single char of value 0x0105 instead of the two bytes. You can tell `unpack` to do this with the `U0` prefix: $ perl -E 'say join ",", map sprintf ("%02X", $_), unpack "U0C*", "\x{0105}"' C4,85 or in other words: $ perl -E 'say join "", map sprintf("%%%02X", $_), unpack "U0C*", $1 while("\x{0105}" =~ m/([^\x00-\xFF])/g)' %C4%85 Send the author an email or [open a bug report here](https://rt.cpan.org/Public/Dist/Display.html?Name=Pod-Simple). 
Yeah, but replacing general_url_escape() with working function doesn't solve the problem. You can see in my post that i replaced general_url_escape() with working function (taken from CGI.pm) but problem still exist.
~~The one in CGI.pm is not unicode-aware, so it's not going to do the right thing either.~~ Edit: Okay, that's incorrect. I must have been thinking of something else, as `CGI::Util::escape` does support unicode. However, the problem is that the `$string` passed to `general_url_escape` is not actually a string but a `Pod::Simple::LinkSection` object that has a stringification method so that it behaves like a string. When `CGI::Util::escape` tries to do this: sub escape { shift() if @_ &gt; 1 and ( ref($_[0]) || (defined $_[1] &amp;&amp; $_[0] eq $CGI::DefaultClass)); my $toencode = shift; return undef unless defined($toencode); utf8::encode($toencode) if ($] &gt;= 5.008 &amp;&amp; utf8::is_utf8($toencode)); `utf8::is_utf8($toencode)` is true but `$toencode` is not a string so this fails. If you change your overridden escape method to force stringification before making the call, then everything works: sub general_url_escape { my($self, $string) = @_; $string = escape($string . ''); return $string; } 
For me outputs right escape sequence :F
Yeah, you're right. You must have replied just as I was editing my comment, reload the page. 
Thanks a lot for help, now it works fine :D
Arador, interesting comparison. It would be nice to see a table of programming languages, version of them and the unicode support they have. Would make a great post.
yeah we use that method for debugging web apps running under apache, its very neat
awesome
$perl6 = "TextMate 2"
Fantastic that a new edition is out and up to date with version 5.14. But, really now.... 6th edition? Does anyone else think this just might have a slightly confusing effect on folks? "Hooray, Learning Perl for 6!" "No, it's edition 6 of learning Perl 5" Heads explode.
Kazam looks easier for you tube stuff. I also remember a java screen recorder that let you add channels like you camera to the capture for linux. But I can't find it now :-(
Duke Nukem Forever released check http://twitter.com/#!/slashdot/status/76780008428929024 Perl6 released check http://perl6.org/ the path is contributing and migrating code from 5 to 6 the same like python community does with 2 to 3 migration http://python3wos.appspot.com/ , the two projects will be run in paralel for at least 10 years , no harm is done by running one instead of the other 
To do it completely transparently, you need something like: my $want = wantarray; my (@ret, $ret); eval { if ( $want ) { @ret = other_function(@args); } elsif ( defined $want ) { $ret = other_function(@args); } else { other_function(@args); } }; if ( my $e = $@ ) { # Handle error somehow } if ( $want ) { return @ret; } elsif ( defined $want ) { return $ret; } else { return; } 
Problem is, then I'd have to modify infinity calls to this part of the code to pass in $what. It's not really an option. One weird thing is that I replaced $ret with @ret everywhere in my code, and while this appears to work just fine with a short test script I wrote, it sends the product into an infinite loop?? sigh.... WTF. Edit: Okay, the infinite loop is apparently from something else I modified... so maybe catching it as an array *was* the solution. Back to troubleshooting I guess :/ Edit2: damn db returning infinite results :p Edit3: wantarray is exactly what I needed, I didn't realize what you were doing there, THANKS! 
$want is defined locally here, it's not passed in. It just stores the value of wantarray locally. (You can't call wantarray inside the eval, because you need the context of the subroutine, not the eval).
... **googles wantarray o_O THIS!!! Thank you! 
To add a bit more explanation to what is going on, each call is perl has a 'context', which is pretty much 'array', 'scalar' or 'void'. It's possible that your 'company::DB::dbSQL' does the same thing in all contexts, in which case using: @ret = company::DB::dbSQL(...) will be fine. But if: 1) there are any places in your codebase where this method is called in scalar context (e.g. $val = company::DB::dbSQL(...)) *and* the dbSQL() function is sensitive to this, then you need the more complete version given above. This link: http://perl.plover.com/context.html covers it in a little more detail. (As do any perl books or tutorials, I would hope).
Please note that you should be checking the return value of eval directly, not checking $@. The [Perl-Critic policy for this](http://search.cpan.org/dist/Perl-Critic/lib/Perl/Critic/Policy/ErrorHandling/RequireCheckingReturnValueOfEval.pm) has details on why.
Perl 6 != Perl The title is not right.
Well, yeah... Except virtually *everybody* in the Perl 6 world is also active in the Perl 5 world.
This blog post gets off track and rambles. Not sure what its point was. But I did have a thought come up when reading this. With Perl5, there's only *the* Perl5, the C code that's been compiled on lots of platforms. Only one interpreter full of its own quirks, and code that uses the quirks is likely to run everywhere Perl5 runs. Perl6 though has multiple implementations. I'm worried that this will fracture Perl6 in the way that C and C++ are fractured by multiple compilers (code written to be built with gcc will often have problems being built by other compilers, leaving developers who care to write handfuls of extra #ifdef's to work around the quirks of each compiler).
Bart != Larry
&gt; I'm worried that this will fracture [Perl 6]... The test suite and spec will help, hopefully more than the C and C++ test suites and specifications.
Thoughtful post. :) Some comments: &gt; Daily articles Luckily not quite daily. There has been a long lull and then one post which was answered rather harshly, leading to a bunch of follow-up posts. So no worries, this is just a phase. :) &gt; Now I don't think that anyone here believes that Perl 5 will be dead in the water when Perl 6 comes about. I don't think many other people inside Perl think this either. In fact, honestly, i'd love if Perl 6 was production-ready today, because it has so many nice things. My worry is more that it will take another 20 years to be ready, 20 years in which Perl 5 will be perceived to be in the shadow of a greater entity.
&gt; But refusing to accept that one day Perl 6 WILL be here (and be Perl), seems kinda ridiculous. Exactly!
Hear, hear. I develop Perl/PDL (perl for scientific computing), and for a long time we wrung our hands about how Perl 6 was going to affect us. Then we learned to just solve our own problems and keep moving. The Perl 5 ecosystem is still thriving, as far as I can tell. CPAN keeps growing (good God, it's about to eat Cincinnati...), we keep getting fanmail on the PDL list, and life generally keeps getting better. If everyone in the Perl community would just stop worrying, we could keep focusing on making/keeping Perl 5 great. (Makes me think of Germany: strongest economy in the world, but they are full of angst because there's nowhere to go but down...) 
&gt; (Makes me think of Germany: strongest economy in the world, but they are full of angst because there's nowhere to go but down...) Haha, not to derail this, but there's reason there to worry since the government is busy making wages crash.
Are you referring to the radical idea of imposing a minimum wage?
Nah, the complete opposite. German government made it a lot harder to actually survive on unemployment benefits by cutting them and refusing to adapt them to inflation. This lead to many people with families being forced to take jobs with ridiculously low wages, which allowed companies to keep lowering them. And since the calculation of unemployment benefits is based off the lowest income levels of society, this will only make it possible for the government to lower them even more. This creates a nasty cycle that has actually damaged european economy as a whole, since other countries buy german goods, but germans are less likely to spend abroad, making germany a sort of black hole which cannot be corrected for since everyone uses the Euro. Minimum wage is meant to stop this cycle.
Ah, interesting. Thanks!
Perl 5 and Perl 6 are two entirely different languages, sort of the way C and C++ are different languages. Perl 5 has a very active development team at the moment, roughly with a new, stable release every spring and development releases on the 20th of every month. [Details](http://dev.perl.org/perl5/news/2010/perl-5.12.0.html). 
Are you stupid? "Counterfactual Perl 6" is not the same as a title as "Counterfactual Perl".
well apparently larry wall's thoughts appear to be clear - perl6 is perl6, perl5 is perl5. presuming he continues to feel this way, this debate looks to be over regardless of merits. in any case, this has become a stupid distraction
i don't think many perl5 people are disgruntled or negative toward perl6. it is clear that perl6 development mostly draws distinct resources, and nothing in perl5-land is being choked off due to perl6. if anything, disgruntlement may stem from the fact that many perl5 people hoped to have perl6 stable by now. don't let any of the fuming bother you, sometimes bored people just look for something to grouse over.
but perl6 isn't vaporware. perl6 is a freebsd port for me. that isn't vaporware. is it complete? no. not by any definition. but even then, if your definition presumes that perl6 modules will one day be as numerous as perl5 modules...no language will ever be done there was a point when perl6 was vapor. probably around 2004. in 2011, its chugging along. it will arrive at the station.
Even when Perl 6 is production ready, Perl 5 will still be worked on as an independent language right? The developers of Perl 5 haven't just been speeding up the development cycle because they got tired of waiting on Perl 6?
maybe we should rename it to avoid confusion
1. Make a poor decision that angers your community. 2. Your community complains about said decision and appeals for reconsideration. 2 seems kind of inevitable after 1.
cool project I might try it out at work
Exactly.
I wish I was, but my job has transitioned towards systems administration and the company won't send me. I only got to go once, and that was back in 2007 (because it was locally here in Houston). It was great! I wish I could go again. P.S. If anybody remembers, I was one of the two young guys there. (Not the one who gave the first lightning talk on why everybody sucked, though, that was my friend lol)
I'm here.
Nope but you've reminded me I need to register for YAPC::Europe still!
Greetings! I'm in Chromatic's talk right now, along with as many people as can fit in the room. And there's a good 250 people at the conference in all, which is pretty reasonable for a ::NA.
I'm here. Just enjoyed Rocco's Reflex talk.
[Text::CSV](http://search.cpan.org/perldoc?Text::CSV)
Can you provide more details? Thank you in advance.
If newlines matter, I think you should be better off using something like `\x0D\x0A` or another way to represent \r\n, because \n in Perl isn't always what you expect. See [Newlines in perlport](http://search.cpan.org/~jesse/perl-5.14.1/pod/perlport.pod#Newlines)
Then don't `chomp`, but delete "\r" and "\n" characters instead. If you're reading line by line, they'll *always* be at the end of the string. tr/\r\n//d 
mv .cpanm .cpanm-old mkdir .cpanm go from there you can always move the old dir back
now go back to trigger_error debugging in php
I'm here. Was just at the bar, now in bed.
This is probably Darwin's answer to the 3 regular library locations defined during Perl compilation. They are (abstractly): core, site, and vendor perl. I assume that core in your case is `System/Library/Perl`, site is `Library/Perl`, and vendor is `Network/Library/Perl` (or the last two possibly reversed). These are done to keep the concepts of things that come with Perl, things that you install on your local host, and things that (possibly) your distribution installs, or someone else installs on your behalf, but doesn't want intermingled with the standard modules. These are *set* at compile-time (but I believe during `make install` or `Build install` with `ExtUtils::MakeMaker`/`Module::Build`, one can specify/define which abstract location to install to). You can change them if you recompile Perl (although there may be other ways with which I'm not not familiar; hopefully others will provide further detail if there are other ways to set them). ETA: The `darwin-thread-multi-2level` subdirectories are created under each of these for XS/binary/system-dependent module implementations.
Ok. I think I FUBAR'd things to the point that I'm going to do a clean install of OS 10.6 tonight. Problem is, I don't know the 'clean' way to proceed from there. I'd like to just sequester all 'my' modules in some neat, organized area but the module installation process seems to toss them into whatever folders it wants.
Well, it's not "wherever it wants"; they're defined in different locations for the reasons given above, and if you rely on the default build of Perl that comes with your OS, you're letting someone else set it for you. If you want them all intermingled (core, site (e.g. for CPAN), and vendor (optional during compilation, but Darwin seems to define it)), you can specify them all to point to the same location if you want to compile Perl yourself. Compiling Perl is pretty user-friendly, so it's not a big deal, but it really sounds like you're tilting at windmills here. The most important thing is that all of these paths are in the `@INC` path (you can see it with `perl -V`). Where they're at shouldn't make much difference to you, as it's transparent when you're executing a Perl program (the order they're specified in may affect one-time loading performance microscopically, though you can tweak your `@INC` path manually at runtime anyway if you feel like micro-optimizing, so it doesn't matter). In short, don't worry about it. They're probably all on the same filesystem anyway, so let Perl/CPAN manage its own module hierarchy. ETA: If you really want to sequester things you install yourself, look into `local::lib` from CPAN, and `perldoc lib` (though the latter is more for project/module/script-specific path setting.) Futzting with recompiling perl, while not difficult, will from a system management standpoint become something you have to do regularly, whereas `local::lib` will let you manage it on a per-user basis, and can avoid the compilation step.
These locations are all configure options when you build perl; look at the output of `perl -V` to see how your perl was configured at build time. It has nothing to do with desires of CPAN or the modules. Blame the person that built your perl, i.e. Apple. If you build perl yourself and use the default prefix of `/usr/local`, everything will go under that.
Apologies if I'm coming across as antagonistic. I certainly welcome people to enlighten me here and I thank you for the help you've provided so far. So if the OS 10.6 build defines where each module goes, * Does it modify the @INC path when it places the module into a new location? If not, how can I modify @INC? * Doesn't that mean the same module on the same OS should be placed in the same location? I have experienced cases where the same module has been installed in two different locations. I am guessing that in some of these cases, it could be because a separate module required it and couldn't find the original so system Perl placed a redundant copy where the module being installed *could* find it -- which ends up being a separate folder. Or at least that's my 'guess' at what's going on. * Is there any chance that the modules could contain directives that will prompt perl to change permissions, or in any way compromise the normal working of my OS? * One final concern (related to bullet #2): some CPAN modules fail to make or install properly. I appreciate that this can happen from time to time. But is it possible that in some cases they are failing because Perl/CPAN is not managing the module hierarchy properly? For example, if I have several Math folders isn't there a chance that Perl/CPAN might try to install Math::SomeModule::NextLevelModule into a folder that doesn't contain SomeModule? Thanks again for your persistence. Your comments have been really valuable to me.
OS 10.6 will define where the modules go *collectively*, at compile time, via setting the 3 aforementioned module directories, as part of the Perl build process, if you choose to use their distributed version(s) of Perl. * Not sure what you mean by "modify", it sets the paths, though Larry and the other Perl maintainers might set up some per-OS defaults. `@INC` is initially defined at compile time (though it is modifiable at runtime, as a "normal" array, so you can modify it in a `BEGIN` block (or with the aforementioned `use lib`, the preferred way). * Generally, yes, but it's can vary on version, or Perl build, or however the OS/distribution/whoever compiles the latest distributed version of Perl feels like that day. * `ExtUtils::MakeMaker` and `Module::Build` (I believe) have settings that let the user specify which of the 3 "sections" in which you wish to install the pending module, but I think they generally tend to install to the aforementioned `site` directory, if unspecified. * Failed module builds/installs are unrelated, and can be for any reason under the sun. Just use CPAN's `local::lib`, it's going to be the easiest for you.
Ok, I understand. I don't mean to characterize OS X, Perl, CPAN, or its modules as having desires or intentions. Obviously that's an offshoot of my frustration, which I blame on myself. One thing I tried to do was configure perlbrew. Now, clearly I didn't do it properly and probably glossed over some part of the documentation that would have steered me right, but even in that case, installing cpanm in my own brewed version of Perl, some modules got placed out there in the ether... seemingly as determined by my system Perl's configuration. Admittedly, that's not a question, but I feel I've FUBAR'd my system Perl so much that my installation of perlbrew doesn't work properly. Is that a possibility?
Thanks again, infidel. I will try local::lib going forward.
I am here
1. I doubt it is anything but a vocal minority that cares about this. 2. The decision was made 10 years ago so it is a bit late to be complaining now.
I am very impressed! Nice url, too. &gt;If a game like that is possible in Java, it should also be possible in Perl. Why?
Most of the hard work is up to OpenGL.
Bravo! nice work!
If there is one way to do it in Java, there is at least one other way to do it in Perl. :)
If there is one way to do it in Java, there is at least one other way to do it in Perl. :)
Once you have a clean system again, doing an initial setup of Perl is quite easy and manageable these days: $ curl -L http://xrl.us/perlbrewinstall | bash $ source ~/perl5/perlbrew/etc/bashrc $ perlbrew install-cpanm $ perlbrew install 5.14.1 $ perlbrew switch 5.14.1 $ cpanm Task::Kensho
This is awesome. A long time ago, [Tels](http://bloodgate.com/) was making a 3D first-person sneaker game in Perl. Seems he eventually abandoned the project, and it's not mentioned on his site anymore. A dozen CPAN modules came from his project though, like Games::3D and SDL::App::FPS (though most of these aren't registered namespaces). Nice to see somebody actually create something playable. :)
Disclaimer: not a real "Java developer" though I know the language. I see Java and Perl as being similar in many regards. And one similarity is that nobody would recommend using either one of them for making games with (though this never stops the Java guys from trying anyway). Also it can be argued they're similar in terms of how "fast" they are (Perl isn't faster than raw C, and Java isn't faster than most other languages either). People say "Perl is too slow for 3D games" (or they used to, anyway. No citations on this, I may have read this claim somewhere). So if Java can do it, Perl can too.
Thanks mr_chromatic ... I ran out of time with work. Meaning to do this. I felt bad I didn't get a chance to give it justice as much as I would hope. 
&gt;nobody would recommend using either one of them for making games with There's a book for that I've got: http://www.amazon.com/Black-Art-Java-Game-Programming/dp/1571690433 I've used Java to write a 2D game engine (like Bitmap Brothers Xeno one)........ it's fine. What do you think is wrong with Java?
I wonder if there's a Windows bin of this game?
It's Perl...what binary do you need...?
Hrm, doesn't work here: https://gist.github.com/619ab290d508e1ad416f
&gt; presuming he continues to feel this way, this debate looks to be over regardless of merits. If there's a broad consensus in the community, Larry usually can be swayed.
The author and a few of us are working to get the distribution set up. However you have to be aware it isn't a complete game yet. (Author's words not mine). He is right about not wanting to release it too early and lose the interest. Especially with end game users on windows. However the code is up for game devs to jump on.
Usually when I see somebody posting on a programming forum that they're gonna use Java to make a game, everybody tells them they should use something else. I know there's some books on the subject, but it doesn't seem to be a very popular choice for making games.
You need OpenGL headers. 
I **have** OpenGL headers. Just not the right ones apparently. Any idea where i can get them?
Minor footnote: you can also use the Linux utility known as dos2unix.
Sometimes you're working in an environment in which you can't install CPAN modules. Think: a locked-down corporate server or an embedded system.
&gt; Without them, you're virtually guaranteed to run across a mysterious bug within your first dozen lines of code. I've seen it happen! It seems a bit contradictory to claim something will almost definitely happen, then follow it up with a testimonial that you've seen it happen. It kind of by itself suggests that you're maybe just talking about an infrequent occurrence that is particularly frustrating. What it really does is show that the whole item is a bit too vague to understand what it actually means. There needs to be a good "what can go wrong" scenario for every item in this list, but especially the first one. That said, I was once involved in the guilt of this worst practice on a scale of tens of thousands of active users of a CGI app. I could never attribute any problems encountered to the absence of strict. I can't believe that over 7 years of active development and over 1 million lines of code we were just lucky.
&gt;for works just as well. Seeing foreach in code is a very good indicator &gt;that someone either learned Perl ten years ago or ten minutes ago. That seems a very personal comment. Not supported by any valuable argument (if for is faster more reliable or whatever, it would make sense). It is shorter? Really? is that a valuable argument?? we added use English to have more semantics. foreach is in the same category I think. You can use which one you like more. nothing to do with your level of expertise imo. 
You've been lucky. I've gotten bugs in my code due to lack of warnings even. (Undefined value being elevated to 0 when it should've been skipped. Was really bad since it changed the way how prices of items were calculated.)
I take issue with the C-style `for` being in the "absolutely must avoid" category. Yes, I totally get where you're coming from; it pains me as well to see something like this: my @something = .... for (my $i = 0; $i &lt; @something; $i++) { do_something_with ($something[$i]); } That's the mark of someone that's not familiar with idiomatic perl. However, there are times when you need the numerical index of the current element in the array, such as when you want to use the corresponding element in the same position of a different array. There's the "keep track of it manually" option: my $index = 0; for my $elem (@firstlist) { do_something_with ($elem, $secondlist[$index++]); } This is clunky as hell because it's not clear at first glance that `$elem` and `$secondlist[$index]` are corresponding elements. If you had written `$firstlist[$index]` and `$secondlist[$index]` then it would be. Plus, if you have to use `$index` more than once you have to ensure that it's only incremented once so you have to keep the `++` on the last use, which is something that's easy to overlook if you later come back and try to refactor. So in that case it would be better to have the increment as its own statement at the end of the block instead of trying to be clever and doing the use-and-increment at once: my $index = 0; for my $elem (@firstlist) { do_something_with ($elem, $secondlist[$index]); do_something_else_with ($elem, $secondlist[$index]); $index++; } But now you've just reinvented the C-style `for` loop, but poorly. The increment is at the end of the block which means if the block is long it's not inherently clear at the start that you're looping over elements. And the lexical `$index` does not go out of scope at the end of the block the way it would with `for (my $index ...`, which means that you have this variable hanging out for the rest of the enclosing scope. If you have another similar loop you're forced to decide whether to reuse `$index` (in which case you skip the `my` declaration which breaks symmetry) or create a new variable of a different name like `my $index2` which is offensive for so many reasons. I don't see how anyone can argue with a straight face that the above is better than for (my $index = 0; $index &lt; @firstlist; $index++) { do_something_with ($firstlist[$index], $secondlist[$index]); do_something_else_with ($firstlist[$index], $secondlist[$index]); } Of couse, you can skip the C-style `for` by doing this: for my $index (0..$#firstlist) { do_something_with ($firstlist[$index], $secondlist[$index]); do_something_else_with ($firstlist[$index], $secondlist[$index]); } Personally I don't find that much more readable. I find that `$index &lt; @list` is more readable than anything like `0..$#list`, especially if list as an array reference, resulting in punctuation vomit: `0..$#$aref` is just a bit too much even for perl. As an aside, I always have to ask myself whether `for(0..something)` results in a temporary list being created (bad) or whether perl sees it for the C-style loop that it is. I seem to recall the answer is that it does for non-ancient versions, but it was an issue for older ones. And if I have to ask myself whether perl can tell that this is a C-style loop why not just write it as a C style loop? And yes, before you say it there is `List::MoreUtils`: use List::MoreUtils qw/each_array/; ... my $iterator = each_array (@firstlist, @secondlist); while (my ($first, $second) = $iterator-&gt;()) { do_something_with ($first, $second); do_something_else_with ($first, $second); } This is neat, but to me it looks like it's trying too hard to be cute. There's also the problem that the lexical iterator's lifetime exists after the loop. Also it seems that there would be a lot more overhead doing it this way as there's at least one more function call per loop iteration. Maybe that's not a problem as it's implemented in XS, but it seems like a long way to go simply in the name of never using a C-style `for`.
You realize you can also write it like this? for my $index ( 0 .. $#journals ) { Or even this? my $last_journal_index = $#journals; for my $index ( 0 .. $last_journal_index ) { Also, about the last thing: If the iterators lifetime bothers you you can just do this: use List::MoreUtils qw/each_array/; { my $iterator = each_array (@firstlist, @secondlist); while (my ($first, $second) = $iterator-&gt;()) { do_something_with ($first, $second); do_something_else_with ($first, $second); } }
Okay, so at first I thought you were suggesting that I wasn't aware of `for(0..$#array)` when it was clear from my comment that I was, but it turns out you were only referring to the fact that you can have spaces around the `..` operator. Well, yes. Of course. I still find `for(0 .. $#$aref)` a little too punctuation-y. And yes, putting something in its block does solve the problem of scope, but it does not look very aesthetic to me due to the indentation, and it seems like it's just bending over backwards to avoid a C-style `for`, which is why I think that dogmatically forbidding C-style `for`s is a mistake. I freely admit that I use 0..$#foo all the time because it allows the statement modifier version of these loops: something($foo[$_], $bar[$_]) for (0..$#foo); Since you can't do the C-style `for` as a statement modifier (right?) you had to do it that way. 
Most of these I agree with but the one that confused me was his take on the default variable. My thing about the default variable is, it's most useful when it makes code simpler (and, ostensibly, easier to read -- although I may be alone on that one, apparently). Hence I tend to use it precisely in cases where it saves me from calling things out: while ( &lt;$fh&gt; ) { next unless /^\d/; say for split; } is just easier to read than while ( &lt;$fh&gt; ) { my $line = $_; next unless $line =~ /^\d/; my @numbers = split /\s/, $line; for my $num ( @numbers ) { say $num; } } I haven't been writing Perl for that long and I admit that's a contrived example but I'm just fascinated that this guy has the exact opposite philosophy on the default variable. Good post, interesting.
Another option: use 5.012; use warnings; my @ar=('a','b','c'); while (my ($i,$elem)=each @ar) { say "\$ar[$i]=$elem"; } 
This. You're right, he's wrong :)
Except that I'd sort of recommend against using bulitin each at all ever. The iterator is attached to the variable, and that's bad, mkay?
Did he wear a mask? I always assume the attempt to remain anonymous is perpetuated in person. Didn't go - maybe next year.
I think that this is horseshit. If you're too "outside" to know where to find the Perl community, then I think that it's your problem. I like that Perl works mostly behind the scenes, supporting most of the interwebs and infrastructure upon which most of the less humble (but less prideful) languages rest. I have better shit to do than to answer questions - they should be posted at Perlmonks anyway.
Many of these "worst practices" are seriously debatable. Don't use "eval"? Uh? don't use qx but "open", uh? don't use foreach? don't use $_? Sorry sir, I don't buy it.
Great points in the article, but I wasn't keen on the condescending, snarky attitude.
i do understand that it is out of favor to use "&amp;sub_name()" but i dont really understand why. to me, it makes it very clear that it is invoking a sub-routine as opposed to a host of other things... and its not like it really lengthens anything by much. is there a real reason people shouldn't use it, other than personal aesthetic taste?
That's the one that jumped out at me, as well.
It bypasses prototype checking (and possibly changes context due to that, if you do pass arguments), and if you forget the `()`, it implicitly smuggles in `@_` to the subroutine. It's not really more clear, imho.
No, he's just zis guy, you know?
Please elaborate where you say "Uh?" You may understand the obviousness of your disagreement, but others likely don't.
The OP obviously starts from the POV of someone writing some sophisticated and/or big application. However most applications and particularly most Perl scripts are simple, short tools, they aren't multi-threaded, they don't scale and don't need to, and they can stick to simple, old-timer stuff such as catching exceptions with a simple "eval" block, and running system commands with the compact, simple and readable "qx()". Because if you want to get really anal, then it's definitely bad practice not to use autodie because who knows when a "print" to a file fails because of an IO error, full disk, etc? By this account there are numerous other grave sins. Let me tell ya something, bro: you'll have to take my TIMTOWTDI from my dead, cold hands.
However prototypes definitely are missing from this list of horrible, must-die, don't-touch-with-a-ten-yards-pole worst practices :)
down vote because the last words in the article are "Just sayin'."
Honestly, for me it boils down to how much i have to read and how readily i can parse it subconsciously. With for `my $x ( 0 .. $last )` I can read it instantly as "for each $x, going from 0 to $last". Meanwhile with a C-style loop i have to read more and the form is not as easily parsed and depending on how it's implemented requires some longer thinking to ensure you actually read it right.
You have to admit that Stackoverflow is easier to use and has a more modern design compared to Perlmonks. I'm not a big fan of the more obnoxious Web 2.0 features, but it doesn't feel like I'm browsing it over a dial-up connection either. And he's only offering a suggestion. If you don't feel like visiting Stackoverflow, then don't. He didn't say it was every loyal Perl hacker's duty.
&gt; It is shorter? Really? is that a valuable argument? No, the argument is that it is longer without providing any extra value for being longer. There is an important difference here. Anything can be made shorter and can easily decreased in value when being shortened. But it's a bit harder to add meaningful value to something when increasing its length. Right now in Perl there is no difference between for and foreach, and neither of them is harder to recognize. This means that they are equal in all important measures aside from one: Effort needed to write/parse by a human. If there is no disadvantage to the shorter version then that one should be used. Lastly: Some people actually do think that for does C-style loops and foreach does array iteration. It's good to wean them off that misbelief.
"If you're not already in the club i do not want you in the club anyway!" Terrible attitude there.
*Perl gives you too much freedom! Don't use that freedom, and don't use another language that takes away the freedom and makes you write better code!*
Also, it postpones the function lookup to runtime, making it slower and breaking stuff like namespace::clean.
Perlmonks is a horrible website. If I see "Some notes below your chosen depth have not been shown here" one more time I'm gonna scream Is the bandwidth really that expensive? What the fuck is going on over there? Perlmonks is horrible. Horrible horrible horrible. You should be ashamed for mentioning it.
You can change the chosen depth to whatever you want.
There's more than one way to do it, but some of these ways *do* suck.
&gt;The guts of Perl's OO are messy, bug-prone, and not much like any other language. What? Messy how? Bug-prone how? Sure, classes in Perl are a bit more DIY than in most other languages, forcing you to explicitly bless references and stuff, but I don't see how they're messier or more bug-prone.
Some of those ways veer dangerously close to [this](http://suptg.thisisnotatrueending.com/archive/14157022/images/1299493659604.jpg), however.
Hmm, are you sure? http://perldoc.perl.org/functions/each.html
I dunno. I recall having to use them for something once in a really narrow edge case (though I don't recall why now, and my `glimpse` doesn't index non-words), so I'm glad they're in there, even if I almost never use them. Of course, I wish they worked more usefully...
This nice thing about this sort of pattern is that it becomes easy to parallelize it. Also, you want: $sub-&gt;($_) if $_-&gt;noteType == 1; 
Access Denied Sorry, Anonymous Monk isn't allowed to use that page as it is only useful for registered users. If you Login or Create A New User then you can access the page. 
They discourage encapsulation, which is at least within a derivative of bug-prone.
Oh cry me a river that a site expects you to make a user object so it can store with that user what prefs he wants.
You're right, I guess StackOverflow does the same thing --oh wait, no it doesn't Enjoy your insular community -- the Internet is not in 1996 anymore, there are better ways to do things
Actually it does. You don't get to post, vote, ask, change settings or anything without registering.
You can see all the posts without registering. That's what matters.
You can still see all the posts on PM. You just have to click on the title of the post above the hidden line. Your complaint is as if you were to complain on a forum that threads are split into pages.
I use "foreach" when iterating a list and "for" when topicalizing as it makes it easier to distinguish.
I had the same reaction. String eval is incredibly useful to make compiled subroutines. I have a filter that wraps each code hook (the code of which is loaded from XML) in a function that calls a compilation/replacement subroutine so that if that hook is never called then it is never compiled.
Using "open" with a pipe instead of system() also introduces the problem that you must read the command's output (or provide input) or the command will stall. Often I really want its output on the terminal like system() does. I do prefer multi-arg system() but if I'm using the shell's stdout/stderr redirection then I oblige it.
I do also think,and that is absolutely a personal opinion, that perlmonks is an awful website. It was perhaps nice in the late 90s though. Was too young to appreciate. I like to use stackoverflow better because it's easy to see the right answers, the ui is simple but effective and **it's not only about perl**. Unfortunately, I don't use only perl at work so it's useful to have a place where I can learn about/lurk different languages. Perl community is self contained and not opened to outside enough. I think the author has a valid argument on that side. For example, everything used to be CPAN only. now, Dancer,Mojolicious and the likes create their own websites and brand not only their framework but Perl has an entity on the web. I think this is the way to go.
It's true that it's incredibly easy to shoot oneself in the foot using eval, particularly string eval. However powerful tools are dangerous by nature; nobody would pretend you should cut trees with a nail cutter because chainsaws are too dangerous.
nice.
I was sure, but it seems I was wrong, I'll remove that post at it's useless.
*Everybody* was wearing a shirt that said "I'M HIRING" on the back; you'll have to be more specific! ;)
Whoever creates a language gets to name it whatever they want to. Sort of like naming your kid.
There are also a couple of alternatives to bcrypt: PBKDF2 and scrypt. Both show up in searches on cpan. 
It mentions salts don't help, but that's only true if you store the salt. if you simply iterate the salt each time you test a password, then it makes the worktime for both the test and a bruteforce attack n times longer. For example, the user sets the password "foobar", we store sub random_salt() { pack("L".int(rand(MAX_SALT))); } sub hash_pw { $pw = shift; hash($pw . random_salt()); } which might reduce to: hash("foobar\x2f\x17\x89\x2b"); , then we discard random_salt(). Now when we check the supplied password "foobar": sub check_pw() { my ($pw, $hash) = @_; for($i = 0; $i&lt;MAX_SALT; $i++) { return 1 if $hash = hash($pw . pack("L", $i)); } return 0; } The idea being that since the salt is not stored, the attacker has to compute MAX_SALT times as many hashes for each password, and we reach a compromise where MAX_SALT hashes isn't too expensive for us, but MAX_SALT*$nr_passwords is too expensive for the attacker. The defect in this approach is that it also increases the occurence of hash collisions by MAX_SALT, but if your hash function is already broken by reducing it's complexity by 2**32 , then it wasn't a very secure hash function to begin with, a collision could of equally been reached by the attacker simply trying more hashes in the first case. All we are doing is increasing the password complexity to be closer to the hash complexity,as the problem with stored hashes isn't the security of the hashes themselves, but the limited expected input space for user passwords. If users picked stronger passwords to begin with, we would not have a problem, but we can mitigate it by appending a fixed size random space to password, and iterating across that every time we perform a verification. **NB:** I wouldn't actually use the code above, as the performance would be suboptimal, and the use of rand() as demonstrated above may not exhibit a random distribution or even cover the whole integer space expected (or it might, I just don't know). I would likely write library functions to perform the hashes in C or assembler and wrap them in a perl module. **EDIT:** perhaps I'm using the wrong term here, and it's not a salt, and should be called a pad, I'm not sure. Anyone?
It is not a problem with OpenGL headers. The Construder.dll is failing to build. I am not sure why. 
I'm skeptical about this claim: &gt; A modern server can calculate the MD5 hash of about 330MB every second. If your users have passwords which are lowercase, alphanumeric, and 6 characters long, you can try every single possible password of that size in around 40 seconds. I wrote a Perl script that attempts to calculate every possible password for this criteria. It takes *magnitudes* more than 40 seconds just to make the list of possibilities, let alone attempt to hash them each one at a time. The author seems to be confusing "time it takes to md5sum a text file containing all possible passwords" with "time it takes to hash each password one by one." Perl may be slower than C, but *that* much slower? Or is my code wrong? #!/usr/bin/perl use Digest::MD5 qw(md5_hex); my @lower = qw(a b c d e f g h i j k l m n o p q r s t u v w x y z); my @num = qw(0 1 2 3 4 5 6 7 8 9 0); my @pool = (@lower, @num); my $pool_size = scalar(@pool); my $len = 6; print "Calculating all $len char passwords from a pool of base $pool_size\n"; # keep track of indexes my @index = (0) x $len; print "Index: @index\n"; my $bm = time() + 1; my $gen = 0; OUTER: while ($index[0] &lt; $pool_size) { # Make the password. my $pass = join("", map { $pool[$_] } @index); $gen++; if (time() &gt; $bm) { print "$gen passwords per second.\n"; $gen = 0; $bm = time() + 1; } # print "Pass: $pass (index: @index)\n"; # Add to the last character. for (my $i = scalar(@index) - 1; $i &gt;= 0; $i--) { if ($index[$i] &lt; $pool_size - 1) { $index[$i]++; last; } else { # Last one? if ($i == 0) { # Done. last OUTER; } # roll it over $index[$i] = 0; } } } print "Done.\n"; On my system this generates up to 625,000 passwords per second, which would still take over 1 hour. 
Some googling turned this up: http://www.elcomsoft.com/lhc.html probably someone out there that has made a free version of it. Doesn't seem so hard. BTW, I think the comment was more that you could create a giant database of precomputed MD5 hashes, index them, then just look up the hash to find the password. It's why you should use extra characters; most of the cracking tools out there can bite off a plain word password as easily as a password with text gibberish. [a-z0-9] 
Well, from what i can see it is not trying to link the right .lib/.a, because those are ultimately responsible for providing the right code for those references.
Oh noes!! I'd love to go but I have exams that week! :(
So shiny you won't believe it's Perl.
More readable, and almost the same speed: #!/usr/bin/env perl use 5.012; use warnings; use Digest::MD5 qw(md5_hex); use Time::HiRes qw(time); my @chars = (0..9, 'a'..'z'); my $length = 6; my $start = time(); my $total = @chars ** $length; my $pass = ' ' x $length; for my $count ( 0..$total ) { # $pass++ for my $pos ( 0..$length-1 ) { my $index = ($count/@chars**$pos) % @chars; substr($pass, -($pos+1), 1) = $chars[$index]; last if $index; # no carry } #say $pass . ':' . md5_hex($pass); if ( ($count % 1000000) == 0 ) { my $run = time() - $start; warn sprintf('%d done (%0.2f elapsed, %d per second)', $count, $run, $count/$run); } } Digest::MD5's overhead is around 50% when that one line is uncommented.
The voice/music mixing at the beginning is really bad. :/
I have to disagree, while i'm sure it could be improved it is surely not "really bad".
No, sorry, his voice is so quiet over the loud music that there are entire phrases i cannot make out. That qualifies solidly as really bad. Well, assuming that you wanted people to understand it.
We had to ban each() where I work. A while back, we had a bug under mod_perl where it seemed that not all the data was being processed under all the requests. After an truly epic debugging session, I nailed it down to an each() statement in a while() loop, where the loop would sometimes exit due to an error. There's an internal variable on arrays used by each() to remember where it is, and that var wasn't being reset reliably. So what happened is that you'd do one request that causes the error, stopping the search in the middle of the complete iteration. On the next run, it would pick up where the previous request left off instead of starting from the beginning. Part of the resolution for this was to tell people not to use each() anymore.
Not to mention that Apache::Registry simply would not work without it, as well as any tempting systems with embedded Perl (ignoring the debate of that being a good idea or not).
Disabling strict refs is fine, though it should be done in a small, tight block. It has the advantage of waving a big flag around that says "warning, something tricky is going on here which you need to understand before you mess with it". The alternative syntax lacks that warning, yet is no less tricky.
I was there :-)
But it's much faster if you're doing the math on a GPU (graphics chip).
Look for a tutorial on CGI---Google something like: 'Perl CGI tutorial' and see what hits you get. If the link mentions Perlmonks then the advice is probably pretty good. If fact you could go there and do what they refer to as a 'Super Search' for CGI tutorial and take a look. In short, what you are talking about is first a textbox, actually two of them. That gets submitted to a perl script. The script will validate and store data somewhere, could be a database, could be a flat file. If the entry makes it past the validation, the script will serve up the next page. That is very vague, but in sum more or less what you are going to be doing...oh---good luck! Probably shouldn't take anymore classes from this particular instructor again, just saying...
yea. i don't plan to take any more classes from him. the class description basically said that it was going to prepare us for the Network+ exam.... I figured out how to do it with PHP and a SQL databse, but we is adamant about having it in perl.
You know, there are tons of perl jobs in houston. PM if you're interested.
Complain about him, right now, to the college. Seriously. I worked in a college where that kind of crap took place and it was poisonous. He's teaching the wrong thing, *and* he's not even teaching it, he's just telling you to use Google? Fuck everything about that. Get three or four other students together, write stuff down, then go and talk to whoever's in charge of this teacher. Get the college to give you another class, for free. All that aside, one good way to do sessions with Perl is with the CGI::Session module. Start [here.](http://search.cpan.org/~sherzodr/CGI-Session-3.95/Session/CookBook.pm#MEMBERS_AREA)
Sounds like someone promised a web site to his wife so she can sell her crocheted cat paw warmers.
Good luck
If programming is a prerequisite, I would say its okay and a good challenge. One of the best lessons I ever got was from my oop(using cpp) class, professor said "build this app in 2 weeks using anything but cpp, you will be graded on risk taking and your justification of language/technology selection"
cgi and cgi::session should do the trick, cookies are fun once you get through the initial hurdle.
As any other screencast this could be improved too but overall I think it is very good. Way better than my first attempts.
Well yeah, the video as a whole is really well done and makes me want to use Mojo. I was only talking about "the beginning", i.e. the first few seconds where i can literally not hear everything he says. Edit: FWIW: I did not downvote Szab's post.
what is that supposed to mean?
Post talks about Perl 5 and Perl 6. Its primary point is to encourage discussion of the direction of Perl 5 development. It characterizes the debate about the names of Perl 5 vs Perl 6 as a distraction.
Every time I see this announcement, I think that Learning Perl 6 has been released. And then I cry. And then I think about how much I want a camel book for Perl 6. And then I cry some more.
this book seems to be universally loved, and with good reason. very few people are going to read programming perl cover-to-cover before they start to code. this book really does give you what you need to get going
Sent you a PM with my contact info. However wouldn't mind helping you through this as doing it for you would defeat the purpose of this, well horrible, lesson. Hit me up if you would like :)
What is new in the book?
In the mean time you can dry those tears on [Programming Perl 4th Edition](http://oreilly.com/catalog/9780596004927)... coming soon.
You cruel, cruel tease.
The required headers and libraries are all included in Alien::SDL but they are not being found. All those OpenGL function calls in the build log are actually coming from the file 'render.c' which is failing to compile because it cannot find 'SDL_opengl.h' (or the associated library). It looks like a problem with 'makefile.pl'. When you run 'perl makefile.pl' do you get a message saying: 'Note (probably harmless): No library found for -lSDL'.? I.e - the (probably harmless) message of death. I have yet to encounter a (probably harmless) notification that was actually harmless. I will try to debug it and get back to you if I succeed.
I ... have no idea why anyone would be downvoting you. Thanks for thinking about it and looking into things. As for SDL, yes, that message occurs. I added a paste of the whole process to gist: https://gist.github.com/619ab290d508e1ad416f Alien::SDL is installed though: Alien::SDL is up to date (1.427). and lives in c:\Perl\site\lib\auto\share\dist\Alien-SDL\1.427_a1ddf79e\
5.10 is no longer supported either, you should be recommending 5.12 or later. Edit: Also, a good video, thanks
Good point, the Mojolicious website and README have been updated.
It should be simple with a framework like [Mojolicious](http://search.cpan.org/dist/Mojolicious/) or [Dancer](http://search.cpan.org/dist/Dancer/).
Where can I see the results?