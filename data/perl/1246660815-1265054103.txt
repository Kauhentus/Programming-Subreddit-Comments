5.10.1 is just a milestone. Then my question will become "When's 5.12?" For all of the wailing and gnashing of teeth about how difficult it is to upgrade to new versions of Perl, it's *impossible* to plan upgrades without some idea of when new versions will come out.
True, but there needs to be the first step so there's less gnashing of teeth and more incentive to help it move.
That's true. Very little helps motivate new contributors more than a new stable release.
Okay, I'm bored, so let's give this douche a beat-down &gt; The Perl community needs to discuss the DarkPAN and the present and future of the language and its ecosystem in much more productive ways than accusations, hyperbole, and strawmen. Coming from this author, I'm not sure how to respond, unless "breathtaking and shameless dishonesty, and willful denial of others' interests" doesn't count as "accusation, hyperbole, and strawmen." And if it doesn't, well... you're still guilty of the former. &gt; My motives are simple: I want regular releases of Perl 5. Is that so? Write a shell script to create a "ChromaticPerl" release every 3 months, host it on your server, and see how many people bother to download it. &gt; I want the default behavior of Perl 5.12 to encourage modern Perl programming practices. Where by "modern" you mean "what you like." Please see above. &gt; I want Perl 5 to be a better language for creating interesting new programs than for maintaining clunky old programs. A lot of people don't want this, and don't think the two goals are mutually exclusive. &gt; Here are some selected quotes from RafaÃ«l Garcia-Suarez's The DarkPAN matters: &gt; "DarkPAN is just a slang word to express the fact that Perl 5 is now currently used all over the world in production and sometimes critical systems..." Kind of like "modern" is slang for "what chromatic likes." But people only tend to give a shit about one of these things... &gt; Pick on me instead then. If you don't like my opinions, feel free to revert all of my patches over the past eight years. Duly noted. $ git log | grep -i '^author: chromatic' | wc -l 66 $ git log | grep -i '^author:' | wc -l 32528 And how much of that 0.2% is test patches that will never be installed on most systems? &gt; see also RT #50528 -- a bug almost six years old that's been present in eleven stable releases of Perl 5. (I wasted the time to look at this. It's some trivial crap involving formats and prototypes, which will affect precisely one person.) &gt; Note, however, that a regular release policy could revert accidental breakages on a known, fixed schedule. And introduce new ones, *mutatis mutandis*. &gt; In other words, this is an attempt to diffuse the real issue. The question is not and has never been "Should existing code randomly stop working?" Instead the question is "Can the defaults change in such a way that existing code will still work with perhaps a one-time, one-line change?" In other other words, the question is "should existing code maybe or maybe not stop working every $n days, because $someone thought that would be a good idea?" &gt; I wrote code. Rejected. Probably because it didn't do anything useful. You wanted to see the word "class" a lot in your (and, worse, everyone else's) Perl code, but there seemed to be neither a consensus nor a clue about what it should mean. &gt; Jonathan Leto put together a potential Perl 5.10.1 release Until he steps up and accepts it, I will go on ignoring the martyrdom you have thrust upon him. &gt; I can predict the day and date of Parrot releases into the next century. Can you predict the date of the first one when the main "programming" activity isn't either re-implementing trivial examples for Reddit, or working around unimplemented features? &gt; The number of contributors to Parrot grows over time, as does the frequency of commits. Parrot right now supports features that the Perl 5 VM will never support, and that feature list will only increase over time. "Features" like this? $ time perl5.10.0 -E 'say (1 + 1)' 2 real 0m0.120s user 0m0.003s sys 0m0.006s $ time ./perl6 -e 'print (1 + 1)' 2 real 0m0.939s user 0m0.829s sys 0m0.097s Or this? $ time ./perl6 -e 'print 1.CLASS' Method 'CLASS' not found for invocant of class 'Int' real 0m0.898s user 0m0.792s sys 0m0.093s &gt; Dismiss all of that because Parrot (some stuff)... No, people dismiss Rakudo and Parrot because they don't implement many frequently-used features of Perl 6 and Parrot, and because they regularly break the things they *do* implement. (EDIT: formatting.)
&gt; In other other words, the question is "should existing code maybe or maybe not stop working every $n days, because $someone thought that would be a good idea?" That's also a strawman, sweetums. A fair few of those test patches I wrote could *verify* if existing code might accidentally stop working. &gt; people dismiss Rakudo and Parrot because they don't implement many frequently-used features of Perl 6 and Parrot I have no idea what this means. &gt; ... and because they regularly break the things they do implement. Please feel free to file bugs if this happens. (As we keep trunk passing 100%, everyone will be very interested to find out when it happens.)
Whatever you say, hot cheeks... &gt; A fair few of those test patches I wrote could verify if existing code might accidentally stop working. How many were ever useful (i.e. ever actually failed)? And anyways, were those not in the "fair few" just fancy fluff? &gt; I have no idea what this means. Then you are either deliberately or actually obtuse. [Try here](http://www.google.com/search?q=rakudo+perl+workaround). (And to be honest, I had forgotten that `.CLASS()` was now `.WHAT()`. My bad.) &gt; Please feel free to file bugs if this happens. How's this different from "code or STFU?"
&gt; How many were ever useful (i.e. ever actually failed)? I don't know; I suspect it's uncountable. You could contact the thousand or so authors of any patch committed in the past eight years and ask them if the tests have caught any regressions. &gt; And anyways, were those not in the "fair few" just fancy fluff? That's a philosophical question about the value of regression tests to help measure stability and backwards compatibility. I can't answer that for you. &gt; Then you are either deliberately or actually obtuse. "Parrot doesn't implement many frequently-used features of Parrot" makes no sense to me. &gt; Try [a Google search for "Rakudo perl workaround". Okay, that makes more sense. Several of those are workarounds in Rakudo for missing features. I'm not talking about Rakudo. Everyone knows it's still under development and it's not complete, just like every other project under development. Some of those are workarounds for problems and missing features in Parrot as well. I'm not claiming that Parrot is perfect or complete or bug-free. (I've never claimed that.) I claim that Parrot gets measurably better every month due in large part to our regular release and support and deprecation policies. Feel free to ask the other couple of dozen Parrot committers if they agree; they'll be much easier to find than the few hundred people who've submitted patches to Perl 5 over the past few years who may have found tests I've written useful. &gt; How's this different from "code or STFU?" If you know of bugs, please file them. Don't play coy ("Oooooh, you losers have bugs in your code! Everything you say about software development is wrong!"). Let us know. We'll fix them.
&gt; If you know of bugs, please file them. Don't play coy ("Oooooh, you losers have bugs in your code! Everything you say about software development is wrong!"). Let us know. We'll fix them. If I just wanted to win (or were named "Pudge"), I'd crop this to "Oooooh, you losers have bugs in your code! Everything you say about software development is wrong," write "strawman," and leave it at that. But anyways... What matters to me (and to others, I suspect) is when your specs (1) describe a platform on which I can build long-lasting software, and (2) specify something that mostly corresponds to actual code. By "long-lasting," I mean that I write it, determine that it works well enough (via your preferred TDD or something else), put in a crontab, and forget. As far as I can tell, Perl 6 still has a ways to go, and the distance has been so great for so many years that it's rarely worth checking in.
&gt; As far as I can tell, Perl 6 still has a ways to go... You're completely right. That's not in dispute. I'm arguing that the regular, measurable progress on a monthly basis is worth considering, whatever you believe about the goals of the project, its future, or its eventual worth.
Fair enough, though I'm more interested in progress towards being a powerful and reliable platform than simple accretion of changes. And for predictability, I prefer code with consistently high quality to code consistently released at regular intervals. I offer Emacs, GHC, gcc, and Darcs as examples of consistently high release quality. Like most software, they don't follow strict time-based release schedules, but unlike most software, one can generally count on the releases not to suck. Furthermore, they all have public repositories and (except for Emacs) test suites for those who want to measure their rate of progress.
I can understand your point as well. Parrot and Rakudo are comparatively immature compared to the projects you mention. I believe that their release schedules contribute greatly to their eventual stability and maturity -- you eat an elephant one bite at a time -- but even so, the vision of a project and its technical quality are also very important to its quality and efficacy as a whole.
Err, index.php5? How about MojoMojo?
Who the hell only has to work in one language? The problem isn't the silly perl bashing (although the translation to perl is very nice), it's that the fundamental question in the original referenced post is a load of crap. If you're still searching for The One True Language, you've already lost the plot.
So, which criticism was he complaining about? The chromatic "quit worrying about being compatible with mysterious 10-year old code that doesn't expect Perl to ever change" or the people who were against such ideas, worrying about being compatible with code that's so old that the maintainers would never even try to upgrade Perl to begin with? Or is there other criticism flying around of which I'm unaware?
It was an evolution and it certainly sounds like it wasn't a singular individual or complaint. At: http://use.perl.org/~chromatic/journal/39228 he expressed the feeling that these attacks were personal (see the top comment on that link).
Seems straightforward: chromatic has an endless capacity to shout the same thing over and over. rgs has a finite tolerance for repetitive shouting. chromatic believes endless shouting will give him what he wants. rgs may, sadly, have made this possible.
&gt; chromatic believes endless shouting will give him what he wants. Out of your selective view of history, this sentence is the least correct.
Interesting read. I still think DarkPAN is an overstated problem. People with old code are running old versions of their distro and old version of Perl because they can't be bothered to risk breaking anything. I don't know of any serious sysadmin who would upgrade perl without testing his code against it on a dev box somewhere beforehand. If he is that stupid, he's gonna have a lot worse problems than suddenly having strict turned on for him. I also don't see how they could be construed as personal attacks. They are attacks on a mentality and a blindness to reality, if anything, and certainly are directed towards more people than just him. I don't always agree with chromatic, but I do agree in this case. Quit holding Perl back for the sake of something that may or may not exist, and if it does exist, will be on servers that aren't going to upgrade Perl anyway.
I think you're not giving chromatic enough credit here, or assuming his intent is different than it is. At the very least, chromatic has always been civil in every interaction I've read (maybe I missed some, I don't pay much attention to p5p). My feeling, as an interested outsider, has been that chromatic is "banging the drum", so to speak, for ideas he thinks are valuable. He wants to see the pace of development in Perl 5 speed up a bit and happen a bit more predictably, which is a reasonable desire. Honestly, we *are* still handling our own function arguments with clunky boilerplate in 2009; something is wrong with the development process if that kind of thing can stick around for ten+ years after everybody knows it's ugly and sub-optimal. Developers from other languages coming to Perl look at that one thing and can think nothing but, "That's just stupid." And they're right to think it. And, there is still a major performance bug in 5.10. As an Open Source developer on several large all-volunteer projects, I definitely see a lot of positive value, and very little negative value, in frequent releases, even if they aren't scheduled precisely. I think chromatic is quite clearly right on this count. Another point to think about...as an interested outsider, I've been getting the impression for several years now that Perl 5 is in "maintenance mode". Meaning, "dead but still being propped up". Going to YAPC this year and last, and seeing what folks are doing with Perl 5, convinced me that there are at least some people who don't think of it that way. But, I suspect a lot of new developers looking at Perl for the first time would get that impression and never look far enough to learn otherwise.
Response from mr_chromatic?
I've already written voluminously on the subjects I care about here; I have no desire to discuss individuals.
Based on the timing, I suspect it was the [PerlBuzz news roundup](http://perlbuzz.com/2009/07/perlbuzz-news-roundup-2009-07-05.html) given his [prior blog post](http://consttype.blogspot.com/2009/07/perlbuzz-is-no-longer-useful.html). But I'm just speculating.
&gt; At the very least, chromatic has always been civil in every interaction I've read. To his credit, and unlike myself, chromatic is very civil. But, as a partisan, he steadfastly refuses to seek compromise, or accept a consensus with which he disagrees. &gt; Honestly, we are still handling our own function arguments with clunky boilerplate in 2009; True, but these things take time. People are still doing their own type inference in C++ (until C++0x), and writing their own basic string manipulation code in Scheme, pattern matching in Ruby, etc. It's ugly, but it's a fundamental part of Perl, and there are many choices (Pass by reference, or by value? Allow named parameters?) &gt;... I've been getting the impression for several years now that Perl 5 is in "maintenance mode". Meaning, "dead but still being propped up". Ideally, Perl would be like (AFAICT) Haskell, innovating while supporting previous versions (i.e. Haskell 98). But I'm statisfied with it being like C, C++, Java (well, mostly), Standard ML, Common Lisp (mostly, but for different reasons), OCaml, Erlang, and all the other languages that remain alive, but don't regularly break things. You know, languages people use to write software. 
&gt; But, as a partisan, he steadfastly refuses to seek compromise, or accept a consensus with which he disagrees. I could give you examples where that's not true, including (I believe) at least one discussion between us. (You may suggest that I use "consensus" as a weasel word to mean that because I don't agree, there's no consensus... and you're probably right far too often.) &gt; It's ugly, but it's a fundamental part of Perl, and there are many choices (Pass by reference, or by value? Allow named parameters?) The simple just-start-with-something solution is to make: sub foo ($bar, @baz) { ... } ... the equivalent to: sub foo { my ($bar, @baz) = @_; .... } That won't handle everything, and it'll need extension in the future, but that covers easily 90% of functions in Perl 5 right now.
That seems reasonable, and dodging prototypes shouldn't be too hard. Why not code up a patch for 5.12? Given the aliasing discussion, it seems timely.
&gt; Why not code up a patch for 5.12? Because I don't *want* to start fights on p5p and I don't want to go through that work (again) for another rejected patch. I don't mind fixing a bug now and then or improving a piece of documentation, but I could fix five or six bugs in Parrot in the same time period and not have to argue with anyone. It's demotivating work... yet I'll probably eventually poke at it again when my curiousity over how to make it work gets the better of me. (I patched the optree constructor today to enable `strict` by default; it's a branch in my GitHub repository.)
any plans of hosting it somewhere ?
More fighting in the perl community. They're using git now, why not just fork? Chromatic can make his repo, RGS can keep the main branch and see who gets more commits/usage.
A few weeks back chromatic blogged [thusly](http://www.modernperlbooks.com/mt/2009/06/the-value-of-a-pumpking.html) &gt; I've written critically about the existing Perl 5 development process here, and I expect to do so in the future. I want to be very clear about one fact, however. &gt; I have nothing but respect for anyone who voluntarily does the job of a pumpking. It is a difficult, thankless position. It requires someone with an amazing attention to detail and a superhuman ability to manage a lot of fiddly, underappreciated work. &gt; Past, present, and future pumpkings deserve our praise and support and thanks. &gt; I'm critical of the process by which we develop Perl. I have no intention to criticize the people who develop Perl, and I offer my most sincere apologies and appreciation to everyone who's felt criticized or attacked or slighted. It's a real shame that rgs has resigned. Doubly so if he did so because of what he perceived to be personal attacks coming from chromatic. 
Apologies for the self-reply but I figured out the utf8 thing... /* negative key_len is used to indicate UTF8 string */ if (SvUTF8(key_sv)) key_len = -key_len; value = hv_fetch((HV *) SvRV(root), key, key_len, FALSE); Silly me for not guessing sooner! Use a negative key length to indicate a UTF8 string! Incidentally, this was cargo-culted from another Perl module. The Perl API documentation doesn't mention it at all as far as I can tell. Perhaps that means I'm doing it the wrong way? I wish I knew. Either way, I'm afraid it's another -1 for hacking in Perl XS. 
Yes, we intend to set up a live site with it once it is good enough. But at the moment, we don't have a lot to show for. If you're interested in it, you should download the code, install the dependencies, and run it locally.
I totally understand; as I said elsewhere here, contributing core patches to Perl is a pain. However, your simple solution above is also conservative: it is consistent with the rest of Perl, could easily be made 100% backward compatible (for people not stupid enough to name their single parameters things like "`$;`" and "`$@`"), and (this is a guess) would not be a huge patch. Superficially, it looks similar to replacing { package X; ... } with class X { ... } However, first, there is more of a consensus on parameter passing in Perl than on how to do objects, so more people will be able to use it. Second, it can be more naturally extended along with the rest of the language. If Perl got a "class" keyword now, it would soon need a "use class" pragma to choose how to do it. Edit: Slap-fight with markdown...
&gt; ... could easily be made 100% backward compatible... I wish that were true, but (I believe) 5.10 added a warning for subroutine prototypes which contain non-prototype characters. That may have happened sometime in the 5.8.x branch. Thus such a change may need a deprecation cycle (likely "deprecate the warning in 5.12, enable the feature by default in 5.14") or a `use feature` switch to enable it.
That's why I never use warnings. (Too soon for jokes?)
Ah, crap. It's actually an error (in 5.8.8): % perl -le 'sub foo($foo) { "$_[0]." } print foo 2,3' Malformed prototype for main::foo: $foo at -e line 1. Still, "make something that was an error do something useful" counts as compatibility.
Right, I remember now. Thus I have the choice of working on a patch right now that may or may not get applied and may be available in a stable release of Perl 5 in two years (at the soonest), or adding features to and fixing bugs in Parrot which will be available in a stable release in two weeks. I'd very much like to add a few features to Perl 5 -- it has a lot more users than Parrot right now, and I can reduce the amount of pain in the world a huge amount if I remove a little bit of pain from every user -- but the risk/reward calculation doesn't work out that way very often.
I don't know how to make my agenda and clearer and less hidden.
PHP needs to die
Honestly, who cares about a few megs of memory usage from a bunch of small mod_perl apps when 4 gigs of ram goes for less than a hundred bucks today?
&gt; They're using git now, why not just fork? I have no desire to create a fork, much less maintain one. I have even less desire to gauge the rightness or wrongness of an idea by its popularity.
It's not about memory usage. Easier to install and can be used by isps like mod_php.. mod_perl would be massive for most, until they really need something bigger/better.
That would be a lot of work, but only until the idea was established. Linus' git speech at google explains what I mean. If the idea is "right" it will help the most people, who will then vote with their feet. It may not produce the best solution (i.e. Java, one of the worst languages is most popular) but it can allow people to get what they want who would otherwise not get it.
That bites me at work constantly. The conflation of variable definition and assignment is a waste of time, and for what? 
To avoid manifest typing, I believe.
Like the mighty cockroach, I think it's going to be around for a while whether you like it or not.
I hope he adds an option to disable the splash screen. Preferrably inside the splash screen. I know it's the first thing i disable and that any app that has one is one that makes me angry whenever i start it.
Thanks to **mr_chromatic** for posting this. It's a pretty rough first version. Any suggestions on how to improve it, keeping within the context of introducing output, variables, and input to new Parrot users who have little exposure to other languages?
FAIL. &gt; Bit's and Pieces about not alot.... Apostrophe FAIL. The plural of "bit" is "bits."
So, can't they just patch Exporter to add: no strict 'refs'; Or am I missing something?
Yes, that would work. autarch posted a couple of patches to p5p to do that today. One question is whether that's worthwhile. Another question is about the best way to do it. A final question is whether it's worth doing or discussing before the 5.10.1 release. (The patches wouldn't go into 5.10.1, I'm certain -- and I agree with that.)
So, the basic complaint is that it's a bad idea because it would expose bad code in core perl modules? I'm confused. Seems like they could easily turn off strict refs where they needed to do so, then fix any issues discovered by the test suite. The module would be better off for it, regardless of whether strict is on by default or not.
&gt; So, the basic complaint is that it's a bad idea because it would expose bad code in core perl modules? I wouldn't call it "bad code". "Unnecessarily lax" is more accurate. There may be bugs and maintainability problems hidden by the laxness, but modifying existing code carries with it some degree of risk. I addressed this idea in more detail in [A Stupid Experiment in Reliability and Maintainability](http://www.modernperlbooks.com/mt/2009/07/a-stupid-experiment-in-reliability-and-maintainability.html).
Just link to the site next time :) [perlmeme.org](http://www.perlmeme.org/) I tend to lose interest if it takes more than one click :p 
I thought that this description is interesting.
Since I don't hack on Perl's internals, I can't say whether this is a valid recommendation, but from an outsider perspective, it seems much more reasonable than what currently happens.
&gt; The result of them (for whatever reason) not doing this is that your internal usage of a data element can greatly differ from external usage of the same element. This is an API disconnect that does not sit well with me. I don't see this one as a problem at all. Autobox is *another way* to write stuff that can already be done. It's not exactly new syntax under the hood, but to the coder using it, it might as well be. If my caller doesn't "use autobox" then presumably they don't tend to use autobox, but they can use the data they get from me the same way they always would have. *My* use of autobox doesn't affect them at all, unless they read my code. Sounds exactly right.
Is anybody willing to join this open source project ? Its procedural Perl based and may contain lots of bugs :-). Check the wiki for more details.
&gt; Currently I think Rakudo throws an exception if the file cannot be opened but I think the spec says that it should just return undef. I hope so much that this is not true.
Actually it's somewhere in the middle ;-) If 'use fatal' is in scope, then it throws an exception. If not, it returns an unthrown exception (which also happens to be an undef value). When you use that value as a file handle to read from it will throw the exception, including the original (not printed) error message from open(). When you just check if it's True or False it won't throw an exception.
OK, now *that* sounds really nice :) Seems to me like the best of both worlds: easy checking using "open ... or die ... " if I want to, *and* exceptions thrown if I don't care to. Cool!
There's one thing the author doesn't say about postgres: it doesn't remain binary compatibility between sub-major releases (for example 8.2 to 8.3) which makes postgres' stability look a bit less awesome. But still valuable thoughts.
Personally, I feel like it is too dark and Slashdot-y. I liked the crisp, light old look.
Gah! I always thought perldoc was one of the best-designed sites on the web.
I also like the old look better. I was unpleasantly surprised by the new look earlier today.
Nice summary, but what are the reasons behind these changes?
It's certainly needed.
I'm disappointed that Larry (@Larry?) caved and went back to "regex". Perl 6 rules are even less like regular expressions than classic Perl regexes have ever been, and I was happy with a name that avoided the "regular expression" confusion entirely while making it clear that this was a new and shiny thing.
I thought that was the type of sandwich Sarah Palin makes after the hunt.
Every link in the article is actually a link to itself :/.
The links look fine here now.
If nothing else, it would help end the widespread perception that nothing new is happening with Perl. If major advances got major version numbers, it would send a signal to the outside world that Perl continues to grow and evolve to meet the needs of today's programmeres.
Shout out to trout from shadowcat, this is shotgun from #perl. Upvoted. 
I'm personally a fan of `done_testing;`
I like test plans, but `done_testing;` is definitely a good feature.
One mark of a truly terrible website is having popup ads triggered by mouseover.
A way to easily use irregular expressions would be nice.
What do you mean by "irregular expressions"?
I know, I know, I know... I want Perl 5 to be a programming language
Not sure. But I know what I want Perl 6 to be. Done.
expressions that are irregular 
It is interesting that so much of the discussion surrounding the future of Perl 5 development has to do with simply not breaking existing (old?) stuff. I find this strange. Not because I want things to break, but because of the amount of negative emotion in evidence. As if people can't just stick with older, known-good versions. Perhaps that is rather simplistic? Probably so. Having perused some threads on this issue in the 'perl5-porters' mailing list (where many big names in Perl hang out), I can say that there seems to be a certain small but sharp quantity of fear and/or territorial pissing that gets mixed in whenever this subject arises. I understand that, to an extent, but it still reads to an outsider like an unappealing insularity.
Not just to outsiders....
&gt; It is interesting that so much of the discussion surrounding the future of Perl 5 development has to do with simply not breaking existing (old?) stuff. How often does upgrading your C compiler break your code? What is your reaction when it does?
How often is the C standard revised? How long until popular C compilers support all of C99?
We're not discussing C compilers. One of the items under discussion here is removing several features from Perl, some of which were marked as deprecated over a decade ago, but never removed. At issue: how much more warning does one need before a particular language feature is removed? 
Not very. Until C99 is useful. Why is so much software written in C? Because it's (1) available everywhere, and (2) stable. Perl also has both of these things now.
That depends on what kind of language you want it to be. Ruby is conducting an interesting experiment now: Ruby 1.8 vs. Ruby 1.9 vs. JRuby vs. whatever the RubySpec people think of as "Ruby." I think that this clusterfuck will ensure that Ruby remains an irritating niche language experiment, but we'll know in another few years.
Do we really need surveys and market research to answer that question? There are now several languages occupying Perl's particular niche, and many of them can do exactly the same job, while being easier to learn and less crufty. This has lead to businesses picking other languages, and programmers wanting to learn other languages. Is there really anything more to it?
I believe the purpose of such a survey is to ask more than one person for opinions.
good question. I think the hiring process doesn't work and douche bags who ask puzzle questions or implement a linked list and/or a tree type questions deserve the employees they get. What they should ask is "How have you managed to not kill any/every idiot manager who posits 'If FaceBook can do it, we should be able to do it too' at a meeting where you are trying to solve actual problems with your systems?".
Yes! Really bloody difficult. We tend to see either ex-sysadmins who have dabbled with it for a bit (and don't really know what they're doing), complete idiots who've read a "learn Perl in 15.3 seconds" book four years ago and nothing since, or people that seem reasonably competent, but don't really want a job writing Perl.
Testing candidate's skills is really really *really* important. We give people a list of half a dozen really easy scripts to write (most of which could probably be one-liners). It's fucking astonishing how few actually manage to do a decent job of it.
Minor point here, I think one of the things people get hung up on in an interview is being right or wrong. Often more interesting than whether a person is totally right or wrong is how they came to their answer, or if they admit they don't know it, how they go about doing that. From there you can talk about how they would find out, and things like that. I think this is a really common problem with people relatively fresh out of school. Their whole notion of a test is to be graded on correctness. If your superiors have to grade your work for correctness, then you're not very valuable, because the answers all have to already be known. Another thing school teaches people is that it's better to guess or fake it than it is to admit not knowing. That's really really bad when engineering systems. Like smellycoat says though, in order to find out how a person deals with not knowing something, you have to actually test them to some extent.
It is really hard to find good programmers. Good programmers are self motivating, self organizing, succinct, constantly learning, but never distracted. Good programmers can communicate well, and strongly command their spoken language. They do not launch into hyperbole when probed for more information, and actually consider your inability to understand them on a point *their* fault for not communicating well enough to you. Good programmers know that poorly written code is a function of a poor understanding of the problem. Good programmers can read code like you read prose, and not merely decode it. Good programmers will estimate their time accurately and work well with others. They will also be very social, and good at singing or cooking or dancing, but are also highly focused. They *might* also use perl.
No, I'm right here. Go to this site: perlmonks.com Most of them are better than I am.
I still contend that the conditions of an interview are far enough from a work day that many test are not valid, for instance the best developer I know always uses the book or a reference site for syntax, params and library functions, etc - a programmer half as good and half as experienced might look better than he does on the in-interview work.
"Often more interesting than whether a person is totally right or wrong is how they came to their answer" I think the interviewers like to tell themselves that - but I still doubt the ability of the interviewer to correctly correlate the candidate's "problem analysis methodology" to their ability to slog through the actual mix of tasks and challenges that they will actually face in the day-to-day job. 
I agree entirely. We send our tests to candidates before we do interviews, as a crude (but relatively effective) "idiot filter". Any half-decent programmer should at least be able to have a reasonably in-depth conversation about how they'd go about solving a problem. Though I do agree that expecting them to produce code without access to the resources they'd normally have is asking a little too much.
I have never been successful in any attempts to glean insight into *how* a candidate approaches a problem. I did try a few times, but have since given up. Having thought about it, I don't really know how *I* go about solving programming problems, I don't think there's an easy formula for doing so. For me, the most important thing when trying to make a decision on a candidate is looking at something they've written. It's surprising how much you can tell about a person from 100 lines of their code. Really, the interview is to: * Ensure they actually wrote the code they submitted themselves * See if they understand some concepts that can't easily be tested in a short script * Convince me they're not a complete headcase (that happens more than you might think)
Thanks for being one of the few people I have seen online admit this. I think the ability to assess programming ability based on some of the stuff I have seen and read about interviewers doing is far fetched at least - if any of the drivel from the interviewing experts was true, they would have the tightest group of expert programmers anywhere. I have issues with US management in general and hiring practices in specific - the size of egos and smugness of many US hiring managers/interviewers does not match the success and quality of the teams they build with their phenomenal abilities to analyze candidates. The more likely case is that better programmers are attracted to interesting projects and/or companies with great compensation packages. Zappos has the right idea with paying people to quit. http://blogs.harvardbusiness.org/taylor/2008/05/why_zappos_pays_new_employees.html
Posted this long comment. -------------- I think the biggest problem with Perl's image is that it doesn't fit a specific problem area. Perl is not necessary or even considered popular or 'best' for web applications. This stopped more or less after CGI scripts got modernised and PHP came along. Perl isn't particularly good at building User Interfaces, making it a very unlikely choice for GUI applications. Perl can do all these things, in great part thanks to CPAN, but, as a general programming language, it's not known to be the master of any of these. The area where Perl keeps being strong are the usual: system administration, bioinformatic and general scripting for small jobs (and sometimes bigger ones). In short: niches. There is nothing wrong with that and it's going to keep people using Perl for solving lots of problems for a long time to come but unless Perl becomes really good at solving problems that mainstream developers, those who write line of business apps for instance, care about, then Perl is going to stay low key. Again, nothing wrong with that. Maybe we should, as a community, dare to confront other languages and frameworks head-on and *prove* that Perl is a 'better' (faster to develop, offers better performance, better reliability, better maintainability, better testability, better integration, etc) option than other offerings in some areas. Instead, we tend to keep talking about Perl like a general-purpose thing that's kindof pretty good but maybe a bit too general to attack any narrower-purpose offering head-on. In the end, for Perl to win the hearts of the masses, it needs to solve today's problems better than what the masses are using. Maybe Perl's problem is an issue of defining what it's supposed to be for.
I'd say it's problem is that it *isn't* better at any of these things. "better maintainability"? You can't be serious. How many modules do you need to include just to get on par with most other languages?
&gt; Matt is looking for help with his module. You always can find user mst on irc.perl.org to chat about this. Warning! Warning! Danger, Will Robinson! 
That's a fair point, but it's an uneven one. The core `strict` pragma, when enabled, adds features I miss in Python and Ruby.
I was mentioning the advantages *that we have to prove* to make the case that Perl is a better solution for a given problem space.
Grassroots "pinko" marketing vs. hiring a marketing manager for Perl technologies? Lively conversation about the perceptions of Perl and how to improve them. 
&gt; What really worries me is that the attackers claim that the passwords were stored UNENCRYPTED. We tell each and every wannabe-coder to salt and encyrpt passwords, and the perlmonks code doesn't? If that is true, the monastery has a really big problem, and just changing our passwords once or twice is just trying to cure the symptoms. QFT
I want to downmod this for the shitty title, but people deserve to know that their accounts could be compromised, so I won't. Instead I'll just bitch.
The accounts are most definitely compromised.
Agreed, but people seeing the post on reddit might or might not *have* said accounts; that's what I was trying (poorly) to express.
This is an embarrassment. I cannot believe a site run by programmers, for programmers, could have been storing plaintext passwords. I honestly cannot believe this.
I agree with the author's thesis, but I have to admit that my initial reaction was to think "Ugh. Yet another line I'm supposed to put at the top of *every* non-trivial program I write in Perl."
Everything Engine is an ancient pile of nearly-unmaintained cruft, written in the kind of Perl that we always try to discourage others from writing... and that's what Perlmonks runs on.
because it can?
Perlmonks is making light of this, but they really should send out a mass mailing notifying all of their users of the breach.
They seem so laid back about it. Nonchalant. I can picture one of the admins holding some champagne laughing about it as I type. Like, NO, you leaked our passwords! It's not funny or ok!
They did. They've changed all passwords for users that hadn't changed it themselves already, and mailed them info on how to get in again.
It's the site's admins that chose to use those words on the site, in an attempt to lighten up the situation. It appears there hasn't been done any real damage on the site.
It's not unmaintained. New patches are added every single day.
I'm sure Chromatic will probably add this to Modern::Perl. However in meantime its easy to create your own module to invoke your favourite pragmas and other stuff: package Baz; use strict; use warnings; use indirect; sub import { warnings-&gt;import(); strict-&gt;import(); indirect-&gt;unimport(); } 1; Then non trivial programs are just: use Baz; # gosh... I have strict, warnings &amp; no indirect already switched on ;-) 
Ubuntu has recently upgraded the default Perl to 5.10 and provided no clear means to downgrade. This has been causing some people some grief, but the various issues and answers are scattered all over the web. I wrote up a single page containing solutions to all of the downgrade issues I was aware of.
Thanks, I'll definitely add that to the ol' Perl toolkit.
You must not have been here when reddit was doing the same thing...
[search for perlmonks](http://seclists.org/dailydave/2009/q3/0047.html)
A [pdf](http://www.onyxneon.com/books/parrotdev/parrot_dev_guide.pdf) is available from the [publisher's web site](http://www.onyxneon.com/books/parrotdev/)
Due to how the -n switch is implemented, instead of perl -lne 'END { print $. }' one can write perl -lne '}{ print $.' (I don't know if the author reads reddit?)
The author is the submitter, he does
What stops me with a root account on perlmonks.org to install password mailer on every user login? What's the point of encryption then? Don't be such snobs.
Thanks. I have now also added it to the article!
:)
"Can", not "should".
&gt;Can't find string terminator "'" anywhere before EOF at -e line 1. What am I doing wrong?
I never said so. But if the goal is terseness, my solution is the best (of the two).
Thanks for the feedback :).
Is it just me or does the article start out with utter bullshit?
It's just over generalized. Poor Perl coders write poor Perl code.
Which one-liner? You probably forgot the ending ' character when copy/pasting!
What do you mean, the shell type parameter, if I could ask?
I'd like to point out my own project [libperl++](https://github.com/Leont/libperl--/tree). It's a more intuitive and powerful approach.
&gt; The whole incident emphasises the need for robust password security. Using passwords that are resistant to dictionary attack [...] Well, that would have help if the site had stored crypted passwords with a salt.
It's old news by now... but it's a decent enough article and the screenshot of the frontpage (done by Perlmonks admins) is fun. :)
Thank you for your help. The following was the one-liner I tried: &gt;perl -pe '$_ = "$. $_"' I typed it into the command box rather than copy/pasting it. Then I tried copying/pasting it. Then I tried enclosing it in "quotes". Then I wrote it to a *.pl file and called that from the command line. I am using Strawberry Perl on windows. Perhaps this is a problem with windows. It may work perfectly on a Unix like OS.
I can't give enough praise to PPI. It can be a confounding and ugly to use, but when you need it you **absolutely** need it. I'm talking spending 2-3 full days hacking on a PPI script to save you 3 weeks of manual labor. Now its nice to know that I am safe in 5.10! =)
How have you used it in the past?
Wrapping thousands of function calls with an error checking function.
Hey, I'm using SDL_perl right now on my own photo viewer/organizer program. http://github.com/bart9h/bapho
Nice!! Here is another repo for you http://github.com/domm/Game-PerlInvaders Also you can contact us on sdl-devel@perl.org Its heating up! Please let me know if you have issues and/or bug reports for the new SDL_perl 1.2.0 at http://cloud.github.com/downloads/kthakore/SDL_perl/SDL_Perl.tar.bz2 Post your issues at http://github.com/kthakore/SDL_perl/issues
The reasons Perl has ebbed away in mindshare are vast and pretty well known (outside the perl community at least). It has little to do with it being a "glue" language. It has more to do with it just not being powerful compared with more modern languages.
That's not quite right. In terms of ability, Perl still gives many similar-level languages a run for their money. So my take would be it's because other languages are *as* powerful as Perl, but a bit nicer to use.
And my take would be: fashion in programming is much more than anyone would expect.
&gt; It has more to do with it just not being powerful compared with more modern languages. That doesn't explain PHP, for which the main feature is not "power" but "whipupitude".
That would be an interesting reason, if it were, y'know, true or anything. :)
Hey, I didn't expect to see this on Reddit when I came in today! I wrote this code for the most part, although I have to thank mintywalker for writing the first iteration as well as getting me started on the project. I'd be happy to receive comments or suggestions here (reply to this post so I get an envelope please) or @ github.
 Game-PerlInvaders$ PERL5LIB=lib perl bin/perl_invaders.pl YOU WON!! 
True statement, but PHP gained an enormous amount of traction in the web arena (unfortunately). Honestly, even my business sites run PHP at the moment because it was faster to just use something that existed than to try and build it on my schedule.
It "gives them a run for their money" in that it is comparable. But that doesn't make it powerful, that makes it average. So you throw in the maintainability issue and it's a no-brainer. That's what I meant, sorry for not being more clear.
The first part of that rant was silly. When people ask "when is it finished" of course they mean what they meant with Perl5, Python, Ruby and so on. No one expects development to be over forever.
It's prompting me to download the .pl file... server issues?
Actually, no. I think Larry Wall said it best, and I quote: "The very fact that it's possible to write messy programs in Perl is also what makes it possible to write programs that are cleaner in Perl than they could ever be in a language that attempts to enforce cleanliness. The potential for greater good goes right along with the potential for greater evil." Good code comes from good policies, and very little else. Language does play a part, but after a certain point, all high-level languages have their advantages and disadvantages that put them on roughly an equal keel.
Hi Chromatic! Firstly, I love your blog! What exactly do you mean by "whipupitude"? Like how easy it is to whip something together?
Exactly! See Adam Turoff's [Manipulexity and Whipupitude](http://use.perl.org/~ziggy/journal/26131) for more details.
Uh, the sneak peek is not in this blog post, although that was originally the intention.
There is no such thing as a boring number. Proof: --suppose that boring numbers existed --write them down in a list --the first number on the list would be interesting, so it would have to be removed.
Wall said that, but it's not only not true; it's silly. In something that actually *is* flexible one has the possibility to make something that no one could read, but it is easier to write something beautiful and that's what most practitioners of the language do. Perl on the other hand isn't that flexible ("oh look, I can use parens or not! Wow, that's almost as flexible as Ruby!") and makes one put in *extra work* to write something that's not ugly. If all the high level languages are on "roughly an equal keel" (I don't find perl that powerful compared to more advanced/modern languages, especially with meta programming) then why use one that makes it so hard to write readable code?
Ugh. A nine year old tutorial. Really? Here is how you write a daemon in perl: use Proc::Daemon; Proc::Daemon::Init;
The article fails to mention one highly useful pseudo-daemon pattern: using init to keep restarting a script. It's useful when you have a script that can block indefinitely and perform whatever action needs to be performed once after it unblocks. That way you can exit after the action and init will kick it off automatically thus giving you a pseudo-daemon.
You're misrepresenting Perl's flexibility to suit your rhetoric. Losing the parentheses is a very peripheral feature, which I am sure many people don't use because (in my opinion) the visual demarcation the parentheses provides is useful for mental parsing. Good features in Perl are like using foreach() to loop through a hash in sorted order, or being able to find the last index of an array by simply calling $#arrayName. These are flexibilities that can make a Perl program great if you use them right, or rotten if you use them badly. That being said, your premise is also incorrect. Writing readable code doesn't come from the language, it comes from the speaker of the language. Good code comes from good coders, and from nowhere else. What Larry Wall is saying above (and what my argument is) is that the effort you put into making Perl code good, makes it potentially great, because it is flexible, intuitive, and as succinct or verbose as you want/need it to be.
This rings eerily true for me. The company I work at is considering migrating away from Perl, and their main gripe is the difficulty in finding good Perl developers. The industry, however, seems to have Java developers coming out of its ears. They have commissioned a third-party solution provider to come up with a module which is written in Java, and that is now raising questions, and is becoming a trojan horse for wider adoption. A solution to a non-existent problem. The company I work at has chronically abused their Perl system to the point where it has been disfigured beyond recognition. And they are trying to pawn it off as a fault of the language. This also eerily rings true in that the Perl developers at said organization have always been forced to bend over to management's whims, no matter how irrational. It's how the Perl platform (at least within this company) has lost its credibility.
Please don't do this. Your program is buggy, and perl leaks memory sometimes. Some of us use [resource limits](daemontools) and [supervise](http://cr.yp.to/daemontools/supervise.html). Other people use [ulimit](http://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/x4733.html) and either [upstart](http://upstart.ubuntu.com/) or [init](http://en.wikipedia.org/wiki/Init). Someone who can't figure out either of those things can still: `runme &amp;` Using `Proc::Daemon` makes it harder for people to use your program, and harder for you because now you have to track and/or ship some other module. Furthermore, people who might want to use your program have to edit it to remove that stupid daemonization, or hack around it using [fghack](http://cr.yp.to/daemontools/fghack.html) or similarly stupid tricks. This makes it harder to track updates (because everyone has their own private copy) and it increases the amount of pause serious system administrators will give your program. The local solution, whether it be init scripts, or daemontools, or `/etc/ttys` is *always* better than your solution, which either has to contort far further than `Proc::Daemon` does, or make some people unhappy.
I can't make sense at all of your post, sorry. Are you saying you shouldn't daemonize things written in Perl at all? I don't understand any of your reasons. Perl doesn't leak memory, but people can write code that isn't nice on memory usage, and Perl doesn't allow you to deallocate any memory you've previously grabbed. It does free it up for re-use when it does the garbage collection. I can see how that would be interpreted as a memory leak, but it isn't the same thing. I dunno why I'm writing such a long reply to an obviously ill-informed, incoherent rant.
&gt; Perl doesn't leak memory [You're wrong](http://www.bioinformatics.org/pipermail/bioclusters/2004-November/002127.html). You may say it's a platform-specific problem, or perhaps it's difficult to predict because it may be related to fragmentation, but the result is the same: perl leaks memory sometimes. &gt; Are you saying you shouldn't daemonize things written in Perl at all? Specifically, yes. I think you shouldn't write programs that daemonize themselves at all. Using resource limits means the operating system will kill your process if it somehow is convinced to use more memory than is expected (say you used `&lt;SOCKET&gt;` in a network application), and letting init (or supervise or /etc/ttys) run your process means that if this happens it gets restarted.
&gt; You may say it's a platform-specific problem.... As a C programmer who's worked on Perl 1, Perl 5, and multiple implementations of Perl 6, I say that's not a memory leak in any sense that a C programmer would use the phrase.
&gt; As a C programmer who's worked on Perl 1, Perl 5, and multiple implementations of Perl 6, I say that's not a memory leak in any sense that a C programmer would use the phrase. Perhaps no true Scotsman writes in C, either. [Wikipedia](http://en.wikipedia.org/wiki/Memory_leak) defines a memory leak as: "A memory leak in computer science is a particular type of unintentional memory consumption by a computer program where the program fails to release memory when no longer needed. This condition is normally the result of a bug in a program that prevents it from freeing memory that it no longer needs. Some memory is requested by the program and allocated but it fails to return it (deallocate) when no longer needed." That covers my sentiments. In addition, this is a [common use](http://www.google.com/search?hl=en&amp;q=firefox+memory+leak&amp;aq=f&amp;oq=&amp;aqi=g-p2g8) of the term "memory leak", so if you've never *heard* it used this way before, you need to leave your cave. Whether it leaks because of memory fragmentation, or it leaks because of bugs in the operating system, sometimes perl leaks memory. Anyway, please continue to argue semantics, because they're definitely relevant.
&gt; That covers my sentiments. Not the words "unintentional", "needed", "bug", and "fails". None of these apply to the example you provided. The question you *should* have asked is "Why doesn't Perl 5 immediately release this memory back to the operating system? Obviously it can. Was there a deliberate design decision to retain allocated memory? Someone wrote this code on purpose." The answer is "It's a memory use optimization, predicated on the presupposition that most programs tend to stabilize at a memory high water mark. Repeated `malloc`/`free` calls are likely to increase fragmentation and increase running time for little benefit." &gt; Whether it leaks because of memory fragmentation, or it leaks because of bugs in the operating system, sometimes perl leaks memory. Indeed, there *are* bugs in Perl 5 where it *fails* to release memory when it should. The example to which you linked is not one of those cases.
&gt; Not the words "unintentional", "needed", "bug", and "fails". I noted them, is that better? &gt; None of these apply to the example you provided. I disagree. `$dna = 'N' x 100000000;` allocates 192MB. `undef $dna` frees *half that*. If you expected that result you are truly a wizard, especially considering Mac OS X, Solaris and Linux each do something different. &gt; The question you should have asked is "Why doesn't Perl 5 immediately release this memory back to the operating system?" People who write long-running programs in perl have to deal with this problem; in fact, they have to deal with them in any non-compacting memory environment. People who write programs that daemonize themselves are likely idiots, but on the off chance they've gone through the non-portable and byzantine contortions needed to deal with perl and the system's `malloc()`, to have a stable, long-running perl program, then maybe they can help out the `mod_perl` community, because *they* have been struggling at it for years. &gt; Indeed, there are bugs in Perl 5 where it fails to release memory when it should. The example to which you linked is not one of those cases Then if you like, assume that I was referring to one of those [when you read this](http://www.reddit.com/r/perl/comments/998qv/unix_daemons_in_perl_the_easy_way/c0bw1pa), because the exact reasons a process might allocate more memory than the system administrator or programmer expected aren't really all that relevant: Resource limits and init are simply a lot easier.
&gt; ... the exact reasons a process might allocate more memory than the system administrator or programmer expected aren't really all that relevant.... They're incredibly relevant to people like me who fix actual memory leaks. Run your snippet through Valgrind. Do you see 96MB of memory leaks in Perl 5?
&gt; They're incredibly relevant to people like me who fix actual memory leaks. This is about daemons, and practical memory management issues. Perl programs; nay any non-compacting gc'd language when running for a very long time is going to have problems like this. They will be difficult to figure out, and system administrators *should not* be taking any chances. When the program daemonizes itself, it makes the system administrator's job harder, not easier. &gt; Run your snippet through Valgrind. Do you see 96MB of memory leaks in Perl 5? ==5362== definitely lost: 142,834 bytes in 555 blocks. ==5362== possibly lost: 100,000,008 bytes in 1 blocks. Of course, I don't see how this is relevant. The page I linked to indicated it was related to the system `malloc()`/`free()` behavior. `BSD::Resource::getrusage()` is a better test, and it disagrees wildly on different machines.
You're the one who is misrepresenting perl's flexibility. You assign it more (relative) flexibility than it actually has. &gt;Losing the parentheses is a very peripheral feature, which I am sure many people don't use because (in my opinion) the visual demarcation the parentheses provides is useful for mental parsing. I would agree. &gt;Good features in Perl are like using foreach() to loop through a hash in sorted order, Foreach goes through a hash in sorted order now, instead of just hash order like it used to? And what is the ordering used? Anyway, what high level language doesn't have this? &gt;or being able to find the last index of an array by simply calling $#arrayName You mean the size? Most languages just have variable.size or variable.length. That is just as easy and much clearer when scanning the code. Further many high level languages go one step further by having a 'last' method that just gives you the last element, which is probably what you wanted anyway. &gt;These are flexibilities that can make a Perl program great if you use them right, or rotten if you use them badly. Which flexibilities? You haven't shown anything noteworthy so far. &gt;That being said, your premise is also incorrect. Writing readable code doesn't come from the language, it comes from the speaker of the language. True, but only to a point. The language itself either lends itself to elegance (e.g. Smalltalk, Lisp) or unreadability (e.g. Brainfuck). In spoken language; the language defines what you can express and (in the case that you know only one language) even what you can think. It also defines *how* you can express it. This is why some non-native english speakers sound very rude, and it's also why some languages have a reputation for being hard to read. &gt;What Larry Wall is saying above (and what my argument is) is that the effort you put into making Perl code good, makes it potentially great, because it is flexible, intuitive, and as succinct or verbose as you want/need it to be. This kind of propaganda doesn't really forward the conversation any. So what if Larry Wall said something? That doesn't make it true. I have still yet to see a single example of something perl can do that some other high level language can't. And usually the equivalent in another language is much easier to understand (i.e. maintain).
You just found the &lt;=&gt; operator! But you have no idea how to use it. A zombie process eats your liver while you were trying to debug it. Game over.
Nah, you just respawn at your last commit point.
Oh no, the sysadmin installed CVS instead of subversion. It's back to square one!
Oh noes, the sysadmin didn't install the Gates of Github expansion? Well no wonder this game sucks. We can't even play on any of the live Rakudo realms.
This is the nerdiest thing that ever nerded. I don't particularly dislike that.
 - say #( embedded comment ) "hello, world!"; + say #`( embedded comment ) "hello, world!"; Yuk. Try this instead. - say #( embedded comment ) "hello, world!"; + say /* embedded comment */ "hello, world!"; From the Department of Stating the Bleedin' Obvious.
Data structures are not so hard as people might think. [This](http://www.stonehenge.com/merlyn/UnixReview/col68.html) article is all you need to know to grok them correctly. 
And it works great being slightly faster than 5.10.0!
&gt; People who write programs that daemonize themselves are likely idiots Come forth demonized Under the banner of Blashyrkh we ride In the battlesky We lie estranged ([the rest of it](http://www.darklyrics.com/lyrics/immortal/battlesinthenorth.html#1))
You kinda missed the point there. :) This module is not meant to make handling of data structures specifically easier, but to make access on (mostly) read-only data structures like XML hashes much more readable by means of auto-creating accessor functions.
I admit. I haven't read the whole article, just the perl code there :)
People probably think they're so hard because they just aren't in modern languages.
It's easy to roll out changes like that when nobody is using the software yet. I do it every day in development projects. Hooray!!
Good Work. Wouldn't want CPAN to get screwed over due to perlmonks shoddy security.
Very pro.
Glosses very quickly over probably the biggest reason: your app is older than the CPAN module in question. Despite glib assertions that you just "use CPAN modules in new code, and refactor the old code," that's (often) just not very reasonable. If, for example, you've got a million lines of code that use your own (old crappy) date handling library, then simply dropping DateTime into the new code is a terrible idea. It just guarantees that none of your new code will work with your old code.
I'd prefer the symmetry for ease-of-identification, and for not worrying about accidentally ending the comment block, but not sure that this is an improvement: &gt; say #`( embedded comment )`# "hello, world!"; The back-tick isn't very "standout". While I do like the obviousness of C comments, the problem with them is not being able to nest them. Edit: I give up. I don't know how to make Markdown not eat the back-tick after and before the # marks.
&gt; While I do like the obviousness of C comments, the problem with them is not being able to nest them. Fair point. Although I wouldn't ever want to nest comments, or read code using nested comments, it is useful when temporarily disabling (i.e. "commenting out") a block of code that already contains comments. That said, I'd be happy writing all my permanent comments `# like this` and then reserving the use of `/* ... */` for those times when I want to temporarily comment out a block of code. 
See also: http://perlalchemy.blogspot.com/2009/08/dissecting-rails-screencast.html
In other languages, I'm seeing "middleware" (like Rack) becoming more popular than raw CGI for web app development. What about for perl? Is anything like this catching on?
Catalyst and CGI::Application.
There's Mojo. I don't think it's being used for anything other than Mojolicious at the moment though.
&gt; I also hope to continue updating the CGI.pm documentation to promote more modern practices, and de-emphasize other parts of it, like ... the procedural interface It's been a while since I used CGI.pm, but I've often found the procedural interfaces of Perl modules simpler than the OO ones. I hope this won't be a move away from simplicity. 
One of my favorite things about Catalyst is that although its request and response objects provide some similar interfaces, it doesn't actually *use* CGI.pm or maintain compatibility with its 15-year-old mistakes. `HTTP::Engine` is another project which aims to provide just the engine/request/response abstraction that Catalyst does, without the rest of Catalyst. I haven't used it, but it seems pretty good, supports a good variety of environments (in-process HTTP server, CGI, FastCGI, mod_perl, test harness), and is apparently inspired in part by Rack.
Bah, github. Git on Windows is not ready for prime time, so that implies: no help from me.
The really bad thing about having both procedural and OO calling conventions is that *it's using the same subs for both*, directly, and it has to use some weird, yes, buggy, heuristic, to figure out which way it was called. If done properly, it would have used a wrapper sub of one, for the other, for example, the procedural sub would call the OO sub as a method on the default CGI object.
To that general statement, I say: it is. Is there anything specific that bugs you?
It depends on what other technologies do you know. C? Windows programming? Which OS do you use? In general this is the list of most buggy Perl packages/dists: http://ali.as/top100/ , FAIL 100. Top of list is actively maintained, so you should skip it. Patching something in XML-Parser is useless. 2 Alias: Maybe it would be a good idea to add more data to these lists, like popular dists with most open bugs in bug tracker (not only RT, but also Google code), add data about most recent release and availability of repository. 
Well, there's [this](http://perlbuzz.com/2009/08/community-contributions-for-those-who-dont-feel-rockstarry-enough-yet.html). If you can find one anywhere close to your experience or interest, I'd advise you jump in with some of the more actively-maintained projects (Catalyst might be a good place to start if the web is your thing) - they're always looking for people to help out, even if it's with simple tasks like documentation.
For the record, I much prefer darcs, but this was a decision made with Lincoln, and frankly, darcs doesn't anything that matches GitHub yet, and GitHub makes for a nice collaboration experience, even if the user experience for git is often annoying. 
I would also suggest joining the perl beginners mailing list and trying to help others out, this will give you a never ending supply of things to which you can apply your current knowledge, and to keep pushing yourself to learn new things.
Have you asked around on [Perlmonks](http://perlmonks.org)? Or even, just introduced yourself on the Chatterbox? You can easily get a lot of info that way. 
I need lots of help in SDL_perl. Checkout http://sdl.perl.org You can contribute by: * testing the repo: http://github.com/kthakore/SDL_Perl/ * posting the issues * I am also looking for help in fixing windows building for strawberry perl. * More areas is too look at the docs for sdl 1.2.x and see what I am missing in SDL_Perl bindings [EDIT] Answered more of op's questions. 
Go with what you're already using.
I voted this up even though I think I'm too ignorant to fully understand all of it.
Perl is cool because it is.
He can't talk about Perl without taking digs at other languages? Talk about insecurity...
If you read a dig at any other language, you've read way too far between the lines. "Different" is a very different word from "wrong".
Can someone let me know why this is getting down voted? 
Because you made this a self instead of linking to a more appropriate article or changelog or...
I guess [Tregar 2002](http://www.apress.com/book/view/9781590590188) could use an update.
Thank you I will fix this now
I'm disappointed that we've ended up with "parameterized" rather than "parametric" or "parametrized", but otherwise cool ;)
agreed. But name aside, I think this is so full of awesome.
Top comment: Re: Last time I strayed away from proper monk behaviour, I ... by Anonymous Monk on Aug 02, 2009 at 06:58 UTC ... stored plain passwords in a database
&gt; Last time I strayed away from proper monk behaviour, I ... ... had sex? ;)
It would be nice if someone made a nice CPAN package out of this
I honestly don't understand why people keep uploading these next-to-useless things instead of the actual notes used to give the talk. Do they think it's a good idea to taunt people with disjointed incomprehensible snippets of something they missed?
Woohoo! Thank you to Dave and everyone else, because there are many.
Excellent! Thanks!
Well, that's pretty cool!
I really don't understand what are your motivations for keeping puking your Perl hatred on /r/perl. Why don't you just move on?
It's seems the rot is finally taking over google. Who would actually put perl on anything modern? Those guys must be really crazy and it just about time for my little search-engine start-up, right. 
I personally thought google jumped the shark a while ago. They seem to shotgun ideas out there a dime a dozen. By my count they've had about 4 successes. I love a new search engine. I'm kicking around some ideas myself.
Wow. Dammit.
Like the sound of this one! Been fiddling with Rakudo releases for a while, a make install is going to make me more likely to use it for little tasks I'd usually use perl5/ruby/python for!
Obsolete?! Hardly. Perl 5.10 moved the base Perl forwards and CPAN provides the best base of libraries for any comparable language. Even if there were no Perl 6 project I wouldn't describe perl5 as obsolete.
You shouldn't bother make a sensible answer, ytinas has been trolling /r/perl for 6 months.
Strange attitude to Perl you've got there! It's an evolving, and widely used language. Why not be able to use "the glue of the internet" on a scripting platform? Seems like a great idea to me, and I'm a Perl zealot I have to use several of the languages targeted by the ASE, but Perl seems very suitable for the "something you can hack on the device" gap that ASE is aiming for..
You somehow missed the sarcasm there, or I'm no good at it at all :)
That was so unexpected! It made me smile; I'm really happy to see audreyt up and about.
I would hardly call Audrey a newbie.
&gt; By my count they've had about 4 successes. Judging by Google's current place in the world, you pretty much only need one.
This is relevant to my interests. 
"The J.R.R. Tolkien quotes at the head of C source file have been checked and proper citations added, thanks to a patch from Tom Christiansen." ~ from http://search.cpan.org/~dapm/perl-5.10.1/pod/perl5101delta.pod Now I have to upgrade...:)
Wow. Amazingly terrible code all around, with only 1 or 2 (depending on your state of knowledge) novel concepts and it's meant as an advertisement for a consulting company that supposedly teaches perl.
What do you want to use it for? Network administration?
perl 6
Haskell?
http://rakudo.org/
Tcl/Tk. It's like Perl, but better on some part. Integration with C programs is great. It has many libraries. Not as big as CPAN, I suppose, but there's enough of it.
Perl is fine. Ruby is neat though.
This is just plain awesome. I hope this will be included in Portage soon.
Why add the "Avoid" in the submission title?
reddit has less context than an RSS feed or something similar
same people who benefit from the google?
Did you want to say that: i. Google benefits from CPAN and thus everyody that benefits from Google indirectly benefits from CPAN ii. All CPAN users are also Google users 
Neither, my baser instincts got the best of me and I was trying to make a bad "the something" reference. I appreciate chromatic and everyone else's hard work on all aspects of perl.
me
What would the marketing blitz be? "Join us now, so you too can continue to wait for Perl 6!" I don't mean to be a dick -- I've been using Perl since Perl 4 &amp; love it dearly -- but marketing isn't the solution here. My two cents.
How about let's use perl: * here's Mojo * here's Moose * here's padre * .... Perl 6 is not the end all to everything in perl.
hehe, sorry. *polishes anti-sarcasm sunglasses*
Perl 6 is a different language. Perl 5 is developed too - there is no need to wait. And CPAN has more than thousand uploads of modules every month.
Moose seems like a great thing, but until they severely whittle down the dependency tree, it will sadly not be used where I work.
Slow startup is a reasonable objection to Moose, there are situations where it's just not viable, and I can understand (although disagree with) places that won't install anything that isn't in core. But why is "lots of dependencies" a bad thing? Are you manually vetting every bit of external code or something? 
Well, for one, compiled Perl code is much larger than the source, so your memory footprint is much much larger, the more dependencies you have to load up. The main problem, though, is that we use CentOS and our boss will not let us use an external repository that has packages for most Perl modules (the core CentOS repositories are very very barren in that regard). So, we have to create rpms for every one of those dependencies and add them to our internal repo. It's a pain in the ass, and none of us are willing to do it.
It has six non-core dependencies.
Really? http://deps.cpantesters.org/?module=Moose;perl=latest Looks like more than 6. But it does look a lot cleaner than last I looked, so it might be a possibility now.
Moose for heavily OO code. No Moose for lightly OO and procedural code.
It's hard to run cpanflute2? To be fair, I don't know what your internal repositories are like. But creating rpms from CPAN modules is one command.
Ah that does indeed sound like a pain in the arse. I'll admit that's well outside my area of expertise (`make installdeps` ftw). Worth trying PAR or something? Edit: About the increased memory footprint thing. Yes, that's true. But it's not a very good reason to avoid external deps. If you need code to do X, then it's going to take up some memory whether you rewrite it or whether you reuse someone else's code. Admittedly, Moose is a bit different as it will increase memory use over using traditional perl objects simply by virtue of there being more code loaded. That's a reasonable objection if your platform is limited somehow, but if not, then you're into the old developer-time-vs-hardware-cost arguments.
Not familiar with that one. We use cpan2rpm and it does not autobundle dependencies, so it's a pain in the butt. Will look into that one.
True; I didn't count Class::MOP's dependencies.
Our CentOS 5.2 server runs Perl 5.10 via rebuilding Fedora's source RPMs, and a handful from cpanflute2.
That's actually really very cool. Small and simple, straight-forward code (at least, nothing hairy that I can see), no deps. And, most importantly, confers a nice readable syntax on a language construct that can often be kinda nasty. I'm going to start using that in my current projects.
I personally agree with that notion, but if that's the case why call it Perl 6? 
Hmm yes as the consensus on the posts comments said.. Sounds like it's (probably) a job for Mouse !
The long start up time makes it a non starter for CGI scripts. 
&gt;I heard a lot about the DreamWidth development community to be very beginner friendly This made me curious so I went to take a look on DreamWidth's website... I can see no mention about Perl, programming, or their development community, anywhere.
It has 15 non-core dependencies, 2 of which are only for running the test suite, and one of which is not even a module (Task::Weaken) but just a Makefile.PL to detect to see if your perl install supports proper weak refs. So for runtime it really only has 12 deps.
[Mouse is deprecated](http://blog.afoolishmanifesto.com/archives/1124). 
Yes, this is well known, but really, why are you still using CGI scripts? The rest of the internets have moved onto persistent environments. 
I have almost no load. CGIs are deployed easily. When they're done they exit and thus can't hurt the system. In fact the entire setup is engineered around minimizing persistence.
Then it doesn't sound like Moose would really be useful for you anyway. Also, FCGI scripts and Apache::Registry can be deployed pretty easily once you get things set up. As for hurting the system by staying around, that sounds more like a programming issue as your scripts shouldn't ever hurt the system.
I'm pretty sure the scripts would be well behaved and things could be made easy. Moose's start up time though is a lousy reason to make that change, so I get my sugar other ways.
Totally agreed, unless you have a compelling reason to switch then don't bother, and it sounds like you really don't have that reason. When you do though ... ;)
Well, I have to eat some humble pie, because I was a bit mistaken about the dependency tree of Moose when I posted the comment about it before. I think it used to be much longer, but I might be conflating Moose with some other module in my hazy memory. I know I've installed modules that had dependencies on several modules to do the exact same thing. It was probably a case of "if X is installed, use it, otherwise try Y, etc", but the installer just said all of them were required, with no concept of "1 of X,Y,Z is required". Might more be the fault of RPM, to be honest.
I think it may have been longer a while ago, but with anything more recent than Perl 5.8.6 (I believe) the depedency list is very small.
With JRuby, Jython, IronRuby, and IronPython; you can use the libraries of the underlying VM. Because of this, I've been thinking lately that the need for language-specific libraries, like CPAN or RubyGems, may go away in the future. It is a huge duplication of effort. It would be much nicer if we could solve these things once (or twice) for the JVM and the .Net CLR, letting all languages benefit.
[Is it also your best friend, your life?](http://en.wikipedia.org/wiki/Rifleman%27s_Creed)
I prefer the much simpler value = net_benefit = benefit - cost benefit = labor_savings + income_increase Not that I do this math, but it is measurable.
Aside from what's already been mentioned (and Miyagawa's Remedie) I can think of [Zim, the Desktop Wiki](http://zim-wiki.org/).
LOLWHUT? We already have SWIG to easily use C libraries from scripting languages. But if you have ever tried to use the raw interface from your language of choice, you will understand that simply being able to call into Java is just a small part of making its libraries available in a useful way.
I agree, excellent desktop app. I couldn't cope without it!
&gt;has a happy welcoming growing community A little over the top, but still hilarious.
Someone should give OSCON 10 bucks so they can buy at least one microphone that doesn't totally suck balls.
but it's true.
Have you _been_ in #perl on Freenode?
Where's the data showing the Perl community growing? That statement surprises me, because I get the impression that Ruby and Python are eating into Perl's community.
Yup. See also http://www.reddit.com/r/reddit.com/comments/9hdgz/dont_optimize_for_yourself_in_communities/ But for the most part Perl has a swell community.
I'm sorry, I disagree. The only OSS community I'd even call civilized is the Ubuntu forums. Unfortunately, OSS seems to draw a lot of smug, lonely people in need of an ego boost in.
For like five continuous years, yes. (And so has Andy.)
Focusing on CPAN statistics because I happen to have Barbie's slides handy: * [Number of releases to CPAN by month](http://birmingham.pm.org/talks/barbie/stats-of-cpan/slide340.html) * [Number of *new* distributions released to CPAN by month](http://birmingham.pm.org/talks/barbie/stats-of-cpan/slide341.html) * [Number of new authors by month](http://birmingham.pm.org/talks/barbie/stats-of-cpan/slide231.html) If I can find the time I want to make a graph that shows the number of authors *active* in a given month, to account for people who go silent.
Hard to quantify, but as an indicator the CPAN stats look healthy: http://stats.cpantesters.org/graphs6.html I don't think Ruby and Python having awesome communities means they're necessarily stealing Perl's. 
Look at the [screencast](http://blip.tv/file/1150746). (If you're in a hurry, skip to roughly 5 minutes in.)
Graphical representation of the 5 sentences: http://img32.imageshack.us/img32/8715/perl.png
I'm sure they'll appreciate your donation
This is the paragraph that sums it up for me: &gt;Rationalism doesn't enter the picture. Neither does deliberation about personal style and a community that matches their own. Instead, if they see pretty sites done using PHP, they'll assume that somehow, magically, sites they do using PHP will be pretty. And they're probably right. Likewise, they'll learn Ruby if they want a turn-key MVC to start plugging actions into (I don't know wtf actions have to do with MVC, but whatever). They'll pick up Java is they want to do something "Enterprise" and ".NET" if they want to do Microsoft Windows UI stuff or Web stuff that integrates with MS Win. Maybe they'll learn Perl if they want to do some sysadmin-ish stuff or text processing. Even though there's little awareness of it, the whole thing seems to be as simple as "X language is good at Y".
Ah, very interesting. Active authors would probably be the best indicator. Please post if you get that chart created.
Oh, I agree with you. I've seen a lot of statements in the ruby and python worlds along the lines of "I've come to ruby from perl, and I missed module X, so I ported it." Rarely (ever?) do I see statements about people coming to perl from ruby or python. This is why it *seems* like there is a one-way migration. But that's feeling, not data, so I welcome anything quantifiable :-)
Greed is a factor in my language choices, too. I collect languages like some people might collect cars. I never get the chance to drive all of them, but I like having them on my computer because they're pretty and have their own distinctive quirks. It honestly doesn't break down to a rational evaluation of capabilities. At work, I use whatever I'm told is needed. At home I'll break out REBOL or Parrot or whatever because I want to play with the shiny toys.
I didn't tie this into the CPANTesters stats page code, just did it as a standalone thing, but here's the graph: [Distinct active CPAN authors by month](http://cleverdomain.org/active-authors-by-month.png). The trend line isn't a very good fit at all; I didn't bother tuning it to find an especially good function -- I just wanted something in there to say "yes, it's going up". *Edit: I figured out why it sucked: gnuplot thinks 1/1/2000 is date zero. Reuploaded something a tiny bit more reasonable.*
&gt; In short, it's a modern, enlightened Perl 5 distribution. In less short, but more accurate, it's a Perl 5 distribution including some collection of modules you like, and are trying to christen "enlightened" and "modern." &gt; Next, I'd add Padre. Really? Encourage Perl novices to edit their Perl text using a wonky Wx-based editor rather than the text editor they already know? &gt; The goal here is to provide better alternatives to core syntax which is difficult to get right. LOL. Let me know when you do...
|In less short, but more accurate, it's a Perl 5 distribution including some collection of modules you like, and are trying to christen "enlightened" and "modern." Are you suggesting duplicity, incorrectness, or both?
It could be neither, either, or both, because that doesn't matter -- it's politics. "chromatic" wants to win. He probably will, but I reserve the right to point and laugh. P.S. -- To quote me, use "&gt; " rather than "| ".
&gt; It's a [...] distribution incluiding some collection of modules you like. It's not an arbitrary collection of modules that a single person likes. It's a collection of modules that best represent the acquired knowledge and best practices that the active Perl community has tacitly agreed upon having and enforcing. Task::Kensho has an organization behind it (EPO) -- it's hardly some random guy's favorite module list.
&gt; Let me know when you do... I don't have to in this case. Yuval already did.
Thanks, CPAN Testers! There's nothing better than knowing that your code works all over the computing world, and nothing more motivating than knowing it doesn't.
|"chromatic" wants to win. What does he win? "the prize?"
&gt; Task::Kensho has an organization behind it (EPO) Okay, three random guys. Do you want to become the third member of ASSRAPE, the Association for Sexually Satisfying Rational and Awesome Perl in the Enterprise? These things are basically harmless, but not worth taking seriously.
Dude, he wins the internet. Or at least notoriety and a few paid speaking gigs.
What's your point? Regardless of the size of EPO, it proves that it's not just chromatic's personal groceries list.
Which part of [this stuff](http://search.cpan.org/~nuffin/) counts as "already did?"
&gt; ... a few paid speaking gigs. I've never accepted money to speak. I don't expect to. Amazon once paid for a hotel room in Seattle once, but I wasn't there to talk about Perl.
The module he wrote which I mentioned in the linked article.
&gt; I've never accepted money to speak. I don't expect to. IMHO you should ask. I wouldn't pay, and (probably) neither would some ex-pumpkings, but you could make some Benjamins from the fad-followers.
Huh.
Translation any of you linguists?
it isn't worth it
This is great. Frankly if we want software to pass 100% of tests, we should be writing more permissive, shitty tests. 
Thank you for bringing that up actually. I hadn't considered that possibility. :) I'll contact them about making a donation towards mics to be used in perl-related talks.
Man, there's a typo, right there in the code. `$self::SUPER-&gt;DESTROY` should be `$self-&gt;SUPER::DESTROY` ;)
I don't understand a word of Russian, but going from the Google translation it's unbelievably corny.
In Russia, Perl is science fiction.
Hard to beat "Learning Perl"... friend. Wait, that came out creepy...
Don't forget to get a [Perlmonks](http://www.perlmonks.org) account, feel free to ask either there or IRC (#perl at freenode) whenever you have a question.
Automating System Administration with Perl, Second Edition Tools to Make You More Efficient http://oreilly.com/catalog/9780596006396/
Well, there's [this (PDF)](http://refcards.com/docs/forda/catalyst/catalyst-refcard-a4.pdf), but it's kinda old. It doesn't cover chained actions, and probably a coupla other things. (Chained actions are covered nicely [here](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst/DispatchType/Chained.pm)). [Catalyst::Manual::Cookbook](http://search.cpan.org/~hkclark/Catalyst-Manual-5.8000/lib/Catalyst/Manual/Cookbook.pod) is absolutely worth a look, as well, as is the rest of [Catalyst::Manual](http://search.cpan.org/~hkclark/Catalyst-Manual-5.8000/). The [wiki](http://dev.catalyst.perl.org/wiki/) is chock-full of interesting stuff, too. The [Definitive guide](http://www.amazon.com/Definitive-Guide-Catalyst-Maintainable-Applications/dp/1430223650?&amp;camp=2486&amp;linkCode=wey&amp;tag=enligperlorga-21&amp;creative=8882) ([UK](http://www.amazon.co.uk/Definitive-Guide-Catalyst-Maintainable-Applications/dp/1430223650?&amp;camp=2486&amp;linkCode=wey&amp;tag=enligperlorga-21&amp;creative=8882)) (That's an [EPO](http://www.enlightenedperl.org/) affil link, not mine) is actually a very good book, with some great examples for newbies and tons of handy snippets for those with more experience. Day to day, the only references I use a lot are [Catalyst::Request](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst/Request.pm) and [Catalyst::Response](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst/Response.pm). Oh, and, lurking in the IRC channel (irc.perl.org, #catalyst) is very helpful. But, I'm afraid I don't know of any other cheat-sheets. I hope that's helpful anyway, man.
Perl Hacks, Perl Cookbook
I could definitely benefit from something like this as well.
I don't know of one, but if you wanted to draw one up I would go with: 1. forward vs. detach. vs. go vs. visit from [Catalyst](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst.pm) 2. uri_for from [Catalyst](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst.pm) 3. The Action Types section from [Catalyst::Manual::Intro](http://search.cpan.org/~hkclark/Catalyst-Manual-5.8000/lib/Catalyst/Manual/Intro.pod) 4. A quick example of a chain midpoint and a chain endpoint. 5. An example of how `$c-&gt;stash` (and other hashref accessors that behave similarly) work. 6. [Catalyst::Request](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst/Request.pm) quickref: args, cookie, header(s), method, param(s), path, upload, uri, remote\_user. 7. [Catalyst::Response](http://search.cpan.org/~mramberg/Catalyst-Runtime-5.80012/lib/Catalyst/Response.pm) quickref: body, content\_length, content\_type, header(s), redirect, status, write. 8.Authentication quickref: user, user\_exists, user\_in\_realm, authenticate, logout. 9. Hints on what doc pages to look at to find everything else. I'll see if I can make any progress towards starting one of these -- I seem to be a documentation semimaintainer these days :)
[Needs smart matching!](http://gbacon.blogspot.com/2009/09/dont-repeat-yourself.html)
I think he may get to that in the followup; you hate to smash open too many minds too soon.
It's got LOLCODE support! :D
Yes, I will get there, the idea is to go from a very traditional way to do it to a more dynamic and pelish way, that will include using arrays, hashes, eval srings (with the security advice not to use it), eval blocks, Try::Tiny, lots of ways to do it for people to compare techniques and styles available only to perl.
Fantastic, I can now run my legacy LOLCODE on Parrot and it should work like a charm. If you were interested in knowing, this particular script guides missles into terrorist whereabouts. Its ironic seeing code like "ENTERZ ENIMY DOOD BASES AND KILLZ THEM"
A Milton Perl one-liner?
Should be: perl -E 'BEGIN{use charnames(); say "binmode STDOUT, \":utf8\";"} END {say "print \"\\n\""} ($_ = charnames::viacode(ord $_)) =~ s/LATIN (SMALL|CAPITAL) LETTER/MATHEMATICAL BOLD FRAKTUR \1/, say "print \"\\N{$_}\";" for split //, &lt;&gt;' | perl -Mcharnames=:full
The roundaboutness bugs me. What about: perl -Mcharnames=:full -Mencoding=utf8 -E '($_ = charnames::viacode(ord $_)) =~ s/LATIN (SMALL|CAPITAL) LETTER/MATHEMATICAL BOLD FRAKTUR \1/, print eval qq{"\\N{$_}"} for split //, &lt;&gt;' ? Works with -e as well as -E, for that matter.
I tried to avoid eval :)
I can't see the characters so I can tell but this version is missing the eval and has less escaping: perl -CS -Mcharnames='()' -E 'say map { ($_ = charnames::viacode(ord $_)) =~ s/LATIN (SMALL|CAPITAL) LETTER/MATHEMATICAL BOLD FRAKTUR $1/; chr charnames::vianame($_) } split //, &lt;&gt;' 
"But this article is not about C. This article is about perl. But I wish to give C its rightful place. C is the most powerful language that attracts the smartest minds into its fold. As simple as that. " -laughs- That made my day, that did. [I love C, and JavaScript as it's a first order programming language, and is very fun]
Nothing like CPAN? There are maven repositories.
You probably can't see the characters in the console but can copy and paste them in Firefox and see them there :)
cool.
Not even firefox can display this. I tried using gedit and open office too and no success. I must be missing a font.
This is the sort of thing that should go on Proggit.
very.
Any suggestions are welcome. I'd also be interested if anyone else has some Perl shortcut URLs they are fond of which could be added to the list.
Apologies in advance, but... Perl hacks? In my workspace? It's more likely than you think.
The title on that page needs a line-height adjustment: h1 { line-height: 140% } That is all.
CPAN is great but there is a lot of junk there too. 
Thanks for the tip. The title was indeed a little squished. I adjusted the line height. I'll probably revisit the stylesheet later, but that's good enough for now.
That's why it's great. The number of great modules is a function of the number of modules.
Is it? I've always suspected that python's libraries have a higher signal-to-noise ratio because of it's benevolent dictator tradition. Don't get me wrong though, I'm a huge fan of CPAN. It's amazing community accomplishment.
The Ubuntu forums? Really? I would liken them more to a group of toddlers instructing each on how to not pee their pants.
What a lousy video! You can't see him and you can't hear him!
This is as quick as it can be ;-)
Unaligned code? Don't people learn to avoid this in their teens? Standard hygiene people, like washing your teeth! My codes bug driven too. I check for bug conditions and branch on the results.... so don't try to fix my bugs! =) That 8 bit register that holds a 5 bit value just rolled over subtracting 255? Yeah, that was on purpose.... 125,000 lines of code further down the overflow flag's checked, and the 'damage' the value would have done is fixed, and the event triggers another block of code to run. =P
Yeah shame they couldn't have got a tripod, some lights and plugged it in to the sound :| Oh and sat in the middle!
Not having a small child close to the microphone could also have been a good idea.
Aww, I thought we'd get to see a Perl interpreter in Haskell. :-(
I think a re-write of Mason would be very cool.
The mic I used was my own. A Revolabs xTag (http://www.revolabs.com/products_wm/xtag.htm). I probably didn't take enough care setting it up. I probably don't know how to set it up well (position and levels etc). I'd welcome any specific advice.
The video is of my talk in 2008. Slides for my (significantly updated) 2009 talk can be found at http://www.slideshare.net/Tim.Bunce/perl-myths-200909
There seems to be a widely-held view that Perl 5 is the language you learn if you want to be a maintenance programmer; Ruby and Python seem to be the scripting languages the new stuff is written in. Perl 6 may change things if it has compelling advantages over Ruby and Python. We will see. But until Perl 6 is fully ready, I doubt anyone is going to invest the time into writing (or buying) a Perl 5 book. 
What else do you need other than the Camel?
The Camel on the shelves
If you look at Java books, you will see that there are some designed for programming beginners, some for experts, some for web app developers, some for web *service* (XML, SOAP, etc.) developers, some which teach by example, some which try to cover the entire library, some which focus on common tasks, and many which cover domain-specific uses of the language. These different books are useful. They wouldn't be written if there were no demand. A programming book which focuses on web apps, for example, will cover the subtleties of web app security which a general programming book will lack.
A Camel written this millennium? Edit: there have been *thirteen* stable releases of Perl 5 since Camel 3, and Camel 3 predates the Perl 5 testing revolution and everything that helped.
&gt; I doubt anyone is going to invest the time into writing ... a Perl 5 book. Hi there!
Moose book: http://www.lulu.com/content/paperback-book/moose/7406976
That's funny, as I know happen to know a few people who just have : http://www.apress.com/book/view/1430223650 The "widely held view" you describe is mostly just reddit and slashdot, outside of that echo chamber very very few people use python and ruby for *anything*, considerably less than Perl. I believe that Tim Bunce busts the myth about new projects and python in his talk at http://www.slideshare.net/Tim.Bunce/perl-myths-200909 using actual numbers and facts. So wrong on every count, have a nice day :)
Google is 'very few people'? Perl's probably still bigger, but lots of people are using ruby/python
The number of people doing Python is pretty small compared to number using something else, despite the efforts of some noisy python advocates in the company. The number of dynamic language programmers out there is a tiny tiny proportion of programmers - about 5% of jobs, of which about 80 to 90% is Perl. Funnily enough Tim's stats show that the number of jobs and new projects put Perl on top by a long way, this is probably even more skewed in non-open source projects where people are more likely to stay with proven and mature tech like Perl or Java.
Well, I work in a software company which is now using ruby for what was once done in Perl. Another example: Google App Engine, google's cloud computing offering, supports Python and Ruby, but not perl. So I disagree strongly with your claim that "very few people" use those languages.
Google isn't many people neither, compared to the whole IT industry. How many employees do you think they have? And after all, they're 'just' one company.
&gt; So I disagree strongly with your claim that "very few people" use those languages. I'm sure there are plenty of anecdotes both ways. Tim Bunce did a lot of research using verifiable *statistics*; do you have suggestions to make them more accurate?
I'm told Google has 20k employees, so at the extreme high end maybe 2000 of them write Python once a week or more? Probably closer in magnitude to 200 than 2000. Granted, whatever the number, it's probably the most Python people you'll find under one notional roof, but it's nothing compared to the global community for any language -- certainly not Perl's!
&gt;What is difficult, however, is to keep up with the Iron Man blogging challenge. And this was a worthless entry.
Hi guys! If anyone is interested in helping out contact me at kthakore@cpan.org . You can also join us on #sdl on irc.perl.org. Or email the mailing list at sdl-devel@perl.org. 
How about these? http://www.langpop.com/ Looks like perl is only slightly more popular than python and ruby at present.
They don't measure use, but yes -- they're more accurate than any few anecdotes.
So... you admit you're wrong? Or are you going with very large definitions of "very few" for ruby and python, but by a different definition for perl?
I quoted you before, writing: &gt; "very few people" use those languages. My use of the word *use* remains consistent. There may be a correlation between use and search terms, but the presence of sites such as programming.reddit.com and Lambda the Ultimate skews the statistics toward discussion and away from actual use. (That's somewhat debatable, but I'd expect Haskell, ML, Coq, and other languages to receive more discussion than PHP and Perl.)
Well, if you look at the stats I showed (did you really?) you will find that job offerings themselves put ruby, python, and perl in the same neighborhood. I think you live in a bubble. Your reaction to simple facts exhibits a peculiar defensiveness. Of the three major scripting languages, perl is still the most popular in terms of use and interest, but not by an overwhelming margin. Its position is completely understandable considering its history If it will remain most popular going forward, it will have to compete on merit, not history. Ask around the open source club at your local university and see what the next generation of programmers are interested in. I'm aware of what I've seen. Interest in perl is directly proportional to the length of one's beard. You're posting this on a site written in python, by the way. Edit: Here's some more actual data for you: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html Of the three major general-purpose scripting languages, which are gaining and which are shrinking since 2005? I'll help you: python is holding steady, ruby is growing fast, and perl is declining.
I assume you are writing a book on Perl 5, then?
[ A quick note from the author of the site. ] The stats are divided in two separate parts. The first part attempts to gauge 'real world' things: books, jobs, search results, and so on. The second part is the "blah blah" part that looks at discussion of languages. They are independent. [ Carry on flaming :-) ]
Which one? :-)
http://www.apress.com/book/catalog?category=142 There are a couple P5 books coming in 2010 from APRESS. That is only one book publisher.
I always wondered why it's not called "puts".
Irrelevant, but Estonian programmers have [some fun with puts](http://www.urbandictionary.com/define.php?term=puts).
`puts` is 1/3 more typing than `say`.
perl -le'print 235*1.15'
That's true, but writing or importing it into every scope you may want to use it is just tedious enough that it's not worth the minor savings.
It's a shame that you need the 'use 5.010' in each file which wants the 5.10 features. No other way for back-compat though I guess. Default can perhaps change when some proportion of CPAN specifies it.
I'm trying out Padre right now!
yes you should. 
`$ cpan Padre` &gt; Padre requires a perl built using threads :-(
Closures are not objects, full stop. They just happen to syntactically look like them (object 'punctuation' method-call), that's all. CLOS objects are not implemented as closures; it's too limited and costly. 
I don't think that was the point at all. The point is that closures have everything it takes to *act like* objects (modulo changes in syntax) and sometimes that's a nifty thing to do because they're lighter-weight than true objects.
Calling *shift()* is not necessarily the fastest way for accessing the object's reference (*$self*). Using *$_[0]* seems slightly faster than calling *shift()*. The following code: sub inc { ${ shift() }++ } sub inc_0 { ${ $_[0] }++ } sub inc_arg { my ($counter) = @_; ${ $counter }++ } # (...) cmpthese( -5, { closure =&gt; q{$main::inc-&gt;()}, method =&gt; q{$main::counter-&gt;inc()}, method0 =&gt; q{$main::counter-&gt;inc_0()}, method_arg =&gt; q{$main::counter-&gt;inc_arg()}, } ); Gives this results: Rate method_arg method method0 closure method_arg 1463568/s -- -29% -30% -48% method 2069327/s 41% -- -0% -27% method0 2079450/s 42% 0% -- -27% closure 2831802/s 93% 37% 36% -- 
Modern::Perl is the first CPAN module I add for a fresh Perl install these days. That way I can replace use 5.010; use warnings; use strict; with use Modern::Perl; 
 What a waste of a domain name.
as any perl programmer knows, TMTOWTDI
That's incredible. I don't know if they guy is trolling or what.
true, TMTOW, but some of them are stupid.
As not enough Perl programmers know: There Is More Than One Way To Do It But Sometimes Consistency Is Not A Bad Thing. *-and-* There Is More Than One Way To Do It, Which Is Fortunate Because Usually Most Of Them Suck.
Yes, [he is](http://github.com/chromatic/modern_perl_book).
It's worse when social scientists do it. For an example of how to do web scraping one used captured output from wget and regular expressions. Not that LWP doesn't come standard, nor that CPAN has Mech and plenty of mature HTML parsers, no no. PS. As part of the presentation it was advised to NOT use Perl to parse the web.
That statement applies better to semantic equivalences like "scalar @array" or OO.
I think I figured out a solution myself... I do this: #!/usr/bin/env perl .... if (test) { t-&gt;Test; exit; } package t; use Test::Most; sub Test { plan qw/no_plan/; is( 1, 1 ); } 1; Much nicer and you get a "real" .t environment
To remove characters, tr/// is more efficient than s///
What?! I don't understand what the second post is doing!
I personally like to factor away the functionality of the script in a module, add a *run* subroutine, and then do in script.pl: use My::Module; My::Module-&gt;run; This way you can take full advantage of *prove* and have proper tests in a /t directory. Also, if you are already using Moose, you should take a look at [MooseX::Runnable](http://search.cpan.org/~jrockway/MooseX-Runnable-0.00_02/lib/MooseX/Runnable.pm), [MooseX::App::Cmd](http://search.cpan.org/~nuffin/MooseX-App-Cmd-0.06/lib/MooseX/App/Cmd.pm), and [MooseX::Getopt](http://search.cpan.org/search?mode=all&amp;query=moosex%3A%3Agetopt). Together, they make turning a module into a command-line application (with parsing of arguments and options) really straightforward.
Still the use case, and thus the benchmark is flawed. Usually you want to be able to access a counter without incrementing it, or in general you not only want to manipulate state, but also retrieve information about the state. It becomes rather clumsy to do all that in a closure (for example by passing an argument that tells the closure what to do). So the counter might be simplest example where it might make sense to replace an object by a closure, but it's also the most complicated one where you'd want to do that - and thus the only one.
Black magic... in other words - no reg-exes.... =D YAY!
About time. I'd like implicit warnings too. I (and you should, too) *always* start my perl code with `use strict; use warnings;`, this should be default (but for perl -e).
This is how people who don't know regex would do it.
The second one makes more sense to me instead of the regex hieroglyphics. 
Sorry to veer offtopic, but was i the only dirty-minded one that thought the thumbnail was nsfw?
woah, there are people on reddit that use the non-compressed display? mind blown
Uh, wrong. There is a direct correspondence between closures and objects. It maybe is costly on a language that doesn't favour closures, but it's not limited in any way.
I think you might be right! Take a look at this post he did on the same forum couple weeks prior to the on OP linked to. http://www.unix.com/shell-programming-scripting/119176-replace-two-blank-line-single-blank-line-post302352966.html#post302352966 He clearly knows what regexes are and knows it can be used to remove string elements. 
`s/\.//` is heiroglyphics? You really should educate yourself on how to use regex, you're missing out...
Thanks for the suggestion... I usually like to do it that way too (embed in a module), but this was a quick 'n dirty script, so I didn't want the baggage of directories, t/, etc. The "test" mode is basically a sanity check to make sure the functions are working as I want -- I'm addicted to Test::More I'll check out those other dists, they look cool
It's a shortcut, doing exactly what you expect.
I use them all the time in VIM, but I'd rather have readable code.
Nice article, as usual. &gt; alias realias='$EDITOR ~/.aliases; source ~/.aliases' Being just that *little* bit more lazy, I have the following function defined in my ~/.aliases ALIASES=~/.aliases function add_alias { echo "alias $1='$2'" &gt;&gt; $ALIASES; echo Added alias: `tail -1 $ALIASES`; source $ALIASES; } Then I can add an alias from the command line: $ add_alias hi 'echo Hello World' $ hi # Hello World It just occurred to me that it would also be useful to have an 'alias last command' function. $ echo Hello World $ alc hi # alc: alias last command $ hi # Hello World But alas, I couldn't figure out how to access the last command from within the script function. It seems that !! only works from the command line, but not in scripts. 
history
To me, one line with a two character regex is better than 2 lines with multiple function calls. *shrugs*
That's pretty good; I'll have to try that.
I love this. I just did it, also adding 'minicpan' as a daily cron job, and the difference in speed when installing new CPAN modules is amazing. Also, combined with the following command (saved as 'update-cpan'), cpanp o | tail --lines=+3 | awk '{ print $4 }' | xargs cpanp install makes keeping all installed CPAN modules up to date a breeze.
I continued explicitly using `scalar @list` for a couple years after understanding context because I like explicit code, but one day it occurred to me that I was just adding needless work for anyone reading it later. Yes, baby Perl code benefits from `scalar`, but more experienced coders understand what scalar on the left and list on the right means. That's also when I realized that really good Perl code is not necessarily the same for an experienced dev as it would be for the rest of the world. Kind of a frustrating realization, since I like to at least pay lip service to the rest of the world when I write code.
&gt; I was just adding needless work for anyone reading it later. Exactly. When I see `scalar`, I slow down and look for what's complicated because `scalar` is very rare in my code.
Shit. I almost without fail use an explicit `scalar()` when I want to evaluate an array (or a random list-returning-thing) in scalar context. To omit it can often lead to assignments that "look wrong", which (for me at least) is worse than having an unnecessary keyword. This means I write "baby Perl"?
&gt; This means I write "baby Perl"? It's often an indicator of baby Perl. What features of these assignments "look wrong" to you?
Quite simply, `my $bar = @foo;` just looks like a possible error, which means I'm immediately suspicious, and have to work out what `$foo` is being used for to convince myself it's correct. `my $foo_count = @foo;` is better, but not always possible. And still makes me slightly nervous.
Part of Perl's bad reputation stems from the fact that a lot of natural Perl code "looks wrong" compared to other languages. Usually "looks wrong" means it doesn't look like another language might in the same situation. Nothing good or bad about that, it's just a question of what folks are used to. Lack of `my`-style lexical variable declaration in some languages looks wrong for me to this day. I still like explicit code, but nowadays much of the explicitness sits in the variable names. So `my $foo_count = @foo;` looks pretty normal to me. No `scalar` means less parsing time for skilled coders, and the clear scalar name provides the information a novice would need to figure out what's happening on the other side of the equals sign.
&gt; `my $foo_count = @foo;` is better, but not always possible. Like webfiend suggests, the variable name reveals the intent far better than a vestigial `scalar` might. Writing clear code in Perl requires using Perl idioms appropriately as well as naming entities well. Those rules apply to any other language.
Absolutely. But sometimes (often?) what you're getting out isn't (just) a count of the number of elements in an array, and to name it as such may render something else harder to understand. There are also many situations where there is no variable name that can be used to indicate intent. For example: if (@{$foo-&gt;{things}} == 3) { ... } and my $log_line = 'Foos: ' . @foo; For me, both of those would benefit from explicit `scalar()`s (I'm usually happy with `if (@foo == 3)`, though). But I can see why you might disagree. (I actually recall fixing a bug a couple of years back where something along the lines of `print 'Foos: ' . @foo;` was changed to `print 'Foos: ', @foo;` by someone. That's subtle enough for me to be a bit more liberal with the `scalar()`s than maybe I should be.) I'm with you on explicit variable names, though.
As much as I hate to agree with Spolsky, "looking right" and "looking wrong" are really important concepts for me. Being able to quickly scan a bit of code, understand its intent, and be reasonably sure it's not doing something daft is really really helpful. If that means code that's *slightly* harder for the expert to grok in order to avoid (perceived) ambiguity, then so be it. To be clear, I'm putting in the `scalar()`s for *my* benefit, not the compiler's. I'm aware that they're not necessary in most of the places I use them.
I think the most important readability factor is if *you* can comfortably read the code later. Readability for your audience (whether skilled or novice coders) is almost as important to me, but not quite. I say keep using `scalar` if that makes your code more comfortable for you.
&gt; my $count = $#array + 1; &gt; I'm not sure why there's never a scalar there. I'm not sure the author understands scalar context.
Would that aside make more sense to you if I'd written "Given the cargo cult nature of this code, I'm surprised it doesn't have even more vestigial copy-and-paste voodoo thrown in because sometime, somewhere, it may have been necessary in a previous incarnation?"
it sure would.
&gt; Being able to quickly scan a bit of code, understand its intent, and be reasonably sure it's not doing something daft is really really helpful. I don't understand why the sigils aren't sufficient for you when skimming Perl code in this case. I can make the argument for differentiation between the concatenation and list case you mention in another comment -- the difference between the two punctuation character is very subtle -- but I don't understand this argument.
Realise that context was the point of the blog post but focusing on the example used, what about this? printf("Size is %s\n", scalar @list); Or this? sub tell_how_many_bottles { printf("%s bottles of beer on the wall\n", shift); } tell_how_many_bottles($#bottles + 1); ...i.e. the desire to avoid an extra line of code to assign the count leads to these. Wouldn't it just be easier for everyone to have a builtin for counting arrays e.g. update length to support this, or add a sizeof builtin? 
That's a decent suggestion. Another interesting one I stumbled upon the other day: the recent version of [Test::More](http://search.cpan.org/perldoc?Test::More) has a `subtest` function, that lets you group together a block of tests into a single unit, and each subtest has a separate plan (which means you can use the `done_testing`/`no_plan` style for part of the script, and a fixed test plan for other parts). Here's a quick example (straight from the docs): subtest 'An example subtest' =&gt; sub { plan tests =&gt; 2; pass("This is a subtest"); pass("So is this"); }; 
Sigils are *sufficient*, but (for me), an explicit `scalar` often makes stuff more readable. I think it makes my intentions clear and unambiguous, and the code as self-documenting as possible. If Perl had a builtin that was specifically for returning the number of elements in an array, I'd shamelessly use that. But it doesn't, so I use the all-purpose `scalar()` instead. For the same reason, I also use unnecessary parentheses to disambiguate anything where precedence could even *potentially* cause (human) confusion, braces when dereferencing pretty much anything (eg, `@{$foo}` over `@$foo`), and avoid `$_` more or less everywhere apart from `grep`, `map` (and `apply`, etc) blocks. Oh, and I don't think I've ever used `$#array`. Does that really make me bad?
&gt; `printf("Size is %s\n", scalar @list);` I'd write: say 'Size is ' . @list; &gt; `sub tell_how_many_bottles {` &gt; `printf("%s bottles of beer on the wall\n", shift);` &gt; `}` I'd write: sub tell_how_many_bottles { say "$_[0] bottles of beer on the wall"; } tell_how_many_bottles( 0 + @bottles ); &gt; Wouldn't it just be easier for everyone to have a builtin for counting arrays e.g. update length to support this, or add a sizeof builtin? `length` is completely the wrong word. So is `sizeof`. My opinion is "There's already a perfectly good way to get the number of elements in an array", but I'm sure someone will throw TIMTOWTDI back at me. My response to that is "What happens when someone passes a list to this new operator?" Usually the sane people realize that they'll have to answer those bug reports and drop the subject.
Sheer awesomeness.
To me mind blowing is this - http://github.com/miyagawa/Perlbal-Plugin-PSGI - async goodness!
It's called POE. Use it.
Thanks, iÂ´ll have an eye on it.
What do you mean "keep an eye on it"?? POE is *the* way to do event handlers in Perl. It has a robust dev community with hundreds of plugins and modules to work with it. While TMTOWTDI is the Perl motto, you'd be an idiot to roll your own here.
Relax. I'm guessing English is not this person's native language and they meant "I'll take a look at it."
Also look at AnyEvent
doesn't sqlite basically makes all of this obsolete?
My bad. I read "keep an eye on it" (as my reply indicated). Had I actually parsed what the OP said, I would've understood the intention.
I don't know, I enjoyed the discussion on 'seek' and 'tell', Tie::File and its application in, for instance, the rotating log file (for which sqlite would be overkill IMO).
I agree that it makes a lot of it obsolete; the class is 6.5 years old. If I were revising it, I would certainly discuss sqlite in detail. But I don't think it makes it all obsolete.
Can you explain in brief what it does that local::lib doesn't?
use lib 'directory'; ?
He lost me at the point where he asserts greater brevity should mean more lines of code per day for the average programmer ... , what??
I'd imagine the meaning was "get more done as you're typing less" rather than "write more by writing less".
Unfortunately on Windows the code snippet behaves a bit different. When running it locks the script so no other instance can be even started (no STDERR output). For windows I used another method: use Win32::Mutex; my ($name) = ($0 =~ /(.*)\.pl/); ($name) = ($^X =~ /(.*)\.exe/) if ($name eq ''); my $mutex; my $result=Win32::Mutex::Create( $mutex,0, $name); if( Win32::GetLastError) { die "Another instance of this script is running, aborting"; } 
Looks like virtual-python sets up a ~/bin/python which will automatically use the new environment for you. Where as with local::lib you need to modify scripts. Haven't tried either so take it with a grain of salt.
Good catch, time to go look through my code and see if I mucked this up anywhere (doubt it since I don't recall running into any problems)
This is nice.
no real need to modify the scripts just set PERL5LIB or have a shell wrapper that sets it for you. Something like this: PERL5LIB=~/perl/lib perl $@
Upvoted for the description of the pitfall. I knew this module before, but I hadn't reconsidered this problem. I'm sure Damian Conway could easily write a workaround around that. :) (I looked into using `caller` but its return values never includes a list of arguments.) 
Yeah, it looked like virtual-python makes the wrapper for you.
Ultraedit
vim FTW. EDIT: I should add, though, that even after years of using VIM, I still use probably the same basic 10 commands over and over again. I should probably learn more, but I've never had the need, so...
Nano. Most of the code I edit is on a remote server via SSH and I don't have direct file-system access to them from my own computer.
You should think about learning to use emacs under terminal mode(emacs -nw) or vim. You'll probably find your productivity increases from using a more powerful editor. 
Also emacs' tramp mode is useful in the situation of working on remote files.
Komodo, and textpad. Textpad mostly.
cat &gt; file.pl
I should have voted for that too; I do use that more often than you might think.
Anyone care to recommend a good editor for Windows (for a newbie)?
Padre is just too damn hard to install in RHEL which we all use at work. I would think any serious development tool would want to be easy to run on the most popular enterprise linux platform since most of us programmers are actually 'employed' to do our programming. *shrug* Eclipse + EPIC seems to work good to me. 
Eclipse can do this VERY well and almost makes working on files via ssh just like working on a local directory.
&gt; I would think... In my experience, Padre's maintainers are very responsive to bug reports.
The grammar in this post title is not advantageous to the book. 
 my @args = do { package DB; caller(); our @args }; which incidentially is also exposed using Devel::Caller::Perl, but I'm not going to include that in Try::Tiny, if you want an awesome try/catch, use TryCatch which does all that and more, Try::Tiny is the poor man's exception clause ;-)
Padre! http://padre.perlide.org/
Wild: http://rakudo.de/progress.png 
&gt; if no plan is included in a subtest, an implicit done_testing should be there. Thus, you can write subtests without specifying a plan but still have a bit of safety. I thought exactly the same thing when I started using subtests (which are otherwise very cool). [mst is right](http://www.shadowcat.co.uk/blog/matt-s-trout/a-cunning-no_plan/) about plans often being more trouble than they're worth, but subtests actually go some way to making plans more useful and usable, with less scope for accidentally breaking them. But in the general case an implicit done_testing would certainly be very convenient. I'd definitely use it. In fact it'd probably be enough to make me use subtests more frequently. &gt; I think I know how to implement this and it would make test author's lives simpler. Yay Ovid ;)
A virtual server is probably your best bet for Catalyst apps. That way you get full control over the system, can set up CPAN how you like, and you don't have to worry about angering anyone by starting up long-running Catalyst processes. Only downside is that you're generally rather memory restricted with VPSs, and memory restricts the number of server processes you can have running at once - which restricts your throughput. I don't have many useful suggestions, but I've heard [Linode](http://www.linode.com) are good.
I use Padre on Windows and vim on anything else, mainly linux. I only use vim because it's already installed and configured how I like as well as doing a fair bit of perling on remote machines where vim over ssh is easy.
We have [a page with user-contributed reviews of hosting providers](http://dev.catalyst.perl.org/wiki/hosting). I would really recommend going the VPS route if you can afford it; there are really a lot less hassles. But people seem to be fairly positive about those Small Orange folks. It's definitely possible to get running on Dreamhost's shared plans as well; there's a page of instructions for it. Also: come visit on irc.perl.org #catalyst :)
http://www.rootbsd.net
`local::lib` *is* the wrapper. It sets up the directory, it sets up CPAN so that things install into it, *and* it sets up the environment so that applications use the local libraries. A single invocation of `eval $(perl -Mlocal::lib)` in the shell (or a user's profile -- works very well if you deploy an app to its own user), or `perl -Mlocal::lib someapp.pl` is all that's required.
I'm hosting a VPS server with Gandi.net at the moment, and have had a great experience with them so far. I got Movable Type set up off the Debian repository without any problem on their smallest system specification (one share). Haven't tried installing Catalyst yet, though, so I don't know if that'll be a problem.
I got Catalyst working on Dreamhost using local::lib. http://robotsrule.us/local-lib/ 
That's a really nice resource. :)
I use [mediatemple](http://mediatemple.net/) for VPS haven't used catalyst on it though.
What is the point of the posting? Either share the patch or shut up.
Oh, will do. I'll add a comment shortly. I also updated Dreamhost's wiki article on Catalyst.
I'm underwhelmed.. You've used 1 niche website for jobs. I've previously used jobstats.co.uk, which shows Perl to have an order of magnitude more jobs than Python and Ruby combined. itjobswatch.co.uk shows a perl to still have a considerable lead. 
Tiobe? Grasping at straws much? Langpop kicks Tiobe's arse, despite it's flaws. I suggest you take a look at the better sources of information at http://www.perlfoundation.org/perl5/index.cgi?usage_statistics All credible evidence shows that perl usage (jobs, contributed code, conferences, user groups, mailing list and irc activity) is increasing. See Tim Bunce's Perl myth talks for useful figures. The honest truth is that Python and Ruby had some very substantial usage growth and a huge ammount of publicity, but that hasn't resulted in many actual jobs outside of some trendy american companies. They still don't really register in europe (or at least the UK), where they have few user groups, jobs or conferences.
You say that is if Europe matters. ha!
If your perl is less than 10 or 15 years old, the correct way to get a reverse sort in perl is to put the `reverse` operator in front of the `sort` operator. At compile-time, the optimizer will recognize the combination, remove the `reverse` operator from the optree entirely, and add a flag to the `sort` operator telling it to reverse the sense of its comparison function. There's no temporary array and no extra runtime cost of reversing.
&gt; Finally we can write infinitely tail recursive and CPS code with a constant stack space, That took me a minute to understand. You don't need to allocate a new stack frame for a tail-recursive call, because no matter how many times you tail recurse, you always return to whatever called the tail-recursive function in the first place. Thus, only one return address is needed. I'm learnin'...
and only the lexicals or temporary values passed as parameters need to remain live
Can we all brainstorm for more calculations one-liners? I can't think of too many. 
this prime-checking regex is insane(ly simple)
what about this one-liner that calculate an aproximation of pi: perl -le 'print 3'
Better approximation: `perl -Mbignum=PI -le 'print PI'` 
And [Sub::Call::Recur](http://blog.woobling.org/2009/11/subcallrecur.html).
perl -le 'print 22/7' is also simple, but better approximation
There is one? The best editor I've seen so far is Geany. Anyone else? 
&gt;... and now its being rewritten? Parts of it are, as you'd expect from any project in progress.
It would be best to write why you prefer Geany over Padre in you blog (preferably that is shown on ironman or perlsphere) - Padre developers always look for features to implement. P.S. Padre is also based on Scintilla.
Good point. I prefer Geany because it doesn't have any dependencies. Padre requires a specific version of Perl that we're not using here - making development a bit tricky (admittedly not impossible). Also, I had very little time to choose an IDE and Geany 'just worked' right out of the box. Maybe it's due to my lack of Perl experience, but Padre was difficult for me to get up and running and took a lot of time. EDIT: Oh, and Geany has auto-complete, code folding, and a few other things that Gedit didn't have. I think Padre has those features, though. I still would like to give Padre a chance, though, once I'm able to get through it's installation.
The refactor is actually needed to implement and correct many things; it's not like the rakudo hackers do that just for fun. And it's part of the plan for the "Rakudo Star" release, which comes pretty close to what you probably mean by "0.9" Why do you think your uninformed project planning is superior that of people who actually work on Rakudo?
Refactors happen. They eliminate technical debt. They improve overall readability, understandability and maintenance on the code. And in this case, they add features we didn't previoiusly have. I think it's worth the few weeks it's going to take to improve rakudo so that it's poised to go beyond Rakudo* Besides, it's not like Rakudo is "nonexistant" anyway. It's there for you to use now. Go use it! Do you think that Rakudo* will somehow be magical? It will not (not beyond the normal Perl6y magic it already has now). It'll just be more public.
whooosh
&gt; i will give chromatic and patrick a lot of credit for bringing things back on track, and the last year has been a lot better... ... but there's always a *but*, isn't there? &gt; ...but i think its fair to say that input on delivery is not unwarranted. Uninformed input on delivery is. If you can honestly tell me that when you posted that, you knew exactly which bits were up for rewrite and why, then I'll accept your input as valid and useful.
How is PSGI different than FastCGI?
PSGI is a higher level abstraction of web servers &lt;-&gt; perl web applications interface. PSGI is a perl code reference interface, not a wire protocol like FastCGI or raw HTTP. By implementing PSGI interface your application can run on server environments like mod_perl, CGI, FastCGI or even embedded servers like nginx or perlbal, without any code modifications. See http://plackperl.org/ and http://search.cpan.org/~miyagawa/PSGI-1.03/PSGI/FAQ.pod for more.
This is an example of a more general principle, which is that as people read code, they form several mental models of it concurrently. One of those is control flow. Another is data flow. It seems likely that presenting these views clearly and independently makes it easier for a reader to understand the code, in comparison with typical imperative code today that mixes these two aspects. Tools like for-each loops and Perl's `grep` and `map` help with this separation, by abstracting the control flow so we can show the data flow clearly.
By looking at Ohloh stats, it is not "people still", but "more and more people...".
It's pining for the fjords!
There is still a rather annoying problem with map: It is roughly 20% slower than a for loop, which is much more likely to be noticable in the "small processing" cases where it's more likely to be used. I'd be much more happy using it wouldn't automatically incur a performance penalty.
Many of those sites are quite old. Perl is very popular for historical reasons. But is it the language of choice for **new** apps. That is the question.
Fast, stable, ubiquitous, CPAN, great documentation, exciting new modules, and a helpful and experienced community. 
Thanks for the release!
CPAN, CPAN, CPAN. I'm ecstatic right now. I thought I'd write a command line application to deal with my BibTeX database (pdf articles mostly) with ease. I'm almost done now, and the only thing I did was *glue modules together*. The command line interface was done with App::Cmd, the objects built with Moose, BibTeX parsing with BibTeX::Parser, fetching articles online with WWW::Search::PubMed, database logic handled with KiokuDB. I still need to figure out how to extract text from pdfs (to get the doi, title, etc) but, without looking, I *know* there will be several modules to choose from that will do it for me, and it's just a matter of playing with their APIs, and then stick to one. So if Perl 5 as a language lacks any shiny features, I can't tell, because I hardly ever see raw Perl at all. It's like mst says: Perl is the virtual machine, CPAN is the language.
- http://www.takkle.com/college_recruiting/athletes - http://duckduckgo.com/ - http://www.yellowbot.com/ - http://osx.iusethis.com/ - http://www.thumb-rate.com/ - http://hiveminder.com/splash/ many more here: http://www.catalystsites.org/
matlab needs to die, die, die update: this is actually a nice read; matlab still sucks
What's with all the WWW stuff....I use the hell out of Perl for my CS studies, sysadmin tasks, you name it!
Qore (http://www.qore.org) is very interesting, it's main draw being that the syntax is Perlish and it is truly multi-threaded. I can't stand to look at Python, much less try it. Whatever part of me loves Perl, rejects Python with equal intensity.
Of course, that's hardly statistical.
Of course. It does show that there *are* new apps being written in Perl 5 though.
I'm doing so now ;)
Yay! Except... It's November already...
Seems to power my OpenBSD hypercube cluster just fine. What features specifically do you think Perl lacks?
That sounds like such a bunch of weird fun to me! Thanks for describing some of your work. ;-)
ok, *"map is 20% slower than for loop"* is new to me, can you link me to some proof of this or is it a benchmark of your own ? can you post the results to said benchmark ? k thanks
I'm writing a small web app just now. It is quick due to CGI-App, DBIx::Class and TT.
fontsize++ :). 
Comment left on blog (I love meta-sites): &lt;blockquote&gt; I've been long irritated by Test::More's default behaviour, and just last week was writing up a patch to add bail_on_failure() behaviour. Now I don't have to; I can just use Test::Most qw(die). Thank you so much! Tomorrow one company is going to see a revision in all its test suites... :D PS. I recently learned about Devel::BeginLift (thanks jrockway@SO), which allows methods to be marked as running at compile-time.. It would be *really really* valuable to do this for Test::Most::use_ok.&lt;/blockquote&gt;
Well, shit. I spent an hour yesterday trying to work out why my exported function's prototypes weren't being honoured properly in a test script. Makes sense now!
Thanks for idea
Here, just run this: #!/bin/perl use strict; use warnings; use Benchmark qw( cmpthese ); cmpthese(100000, { 'for_loop' =&gt; sub { my @array; push @array, $_ for ( 1..10 ); }, 'map' =&gt; sub { my @array = map { $_ } 1..10; }, }); 1;
Yeah, that's a frustrating problem. use_ok() was one of those test functions that I think was thrown in their without enough thought.
It begins! You're right, eval is bad. If someone put in: `rm -rf ~/*` (with the backticks) or an equivalent, it's all over. ;)
You are not solving equations here, you are evaluating expressions. So it probably should say:'Give me an expression:' and '"The expression \"$eq\" evalualtes to $ans.\n". By the way, you can avoid the ugly \" quotes by using the qq{}-construct. 
That's what I heard when I was reading about the eval command.
Thank you. 
So, eh... what makes this release different from the previous dozens of releases? Is it worth bothering to upgrade every few weeks?
Well, it looks like it's a command line program and not, say, a web app. Presumably an attacker with access to this program has access to the perl executable anyway (they pretty much are guaranteed to). So while eval *can* be a security threat, it doesn't seem to be in this case.
I wrote a similar little program a number of years ago. And... I still use it! I wrote [a blog post about it](http://porkrind.org/missives/pc-perl-calculator) earlier this year. My suggestion to you: get rid of all the superfluous prints (maybe take input from the command line) and see if you can make it into something you'd actually reach for when you need a calculator.
He can do that on the command line too. So, don't just blindly do this for people to whom you don't allow shell access. 
"...and I may be the Mayor of Simpleton, but I know one thing and that's I looooo-ooo-oove you!"
I too started with lots of interaction from STDIN, and after a while I found it quite tiring to enter the same things all over for testing, so instead I switched to using command line parameters (which you can get from @ARGV in Perl). That way I can use the shell history to test my script with unchanged input quite easily.
[Cached version](http://64.233.163.132/search?q=cache:3UYWBZdkINAJ:www.bofh.org.uk/2009/11/08/class-decomposition-and-a-handy-delegation-pattern+Class+decomposition+and+a+handy+delegation+pattern&amp;cd=1&amp;hl=en&amp;ct=clnk), the page seems to be down currently.
There's no vulnerability in `eval`. The vulnerability is when you have a program that allows someone to perform an action that they aren't normally allowed to perform. For example, consider someone posting a web form with their browser. A program runs on the web server machine to process the form submission. The person posting the form does not normally have permission to run programs on the server, but when they post the form, one runs on their behalf. If the program does only what it is intended to do, there is no problem. But if the web user can trick the program into doing something else, that's a security failure. The difficulty with `eval` in this context is that it's very difficult to put any sort of limit on what the web user can do with it. You may expect them to put in something like `3 + 4 * 5`, but they can surprise you by putting in something like `system("rm -rf /")` which erases the whole filesystem. But in the context of a program like yours that someone runs themselves on their own computer, there is no problem at all with `eval`. Someone could type in `system("rm -rf /")` and try to erase the file system, but they could have done that without using your program anyway. 
I tried that and it didn'
Wow, that's really neat that it prints out the answer in 3 different ways.
I'm really liking perl thus far. It's a lot of fun! This is the first language I've tried to learn. Most of the tutorials are for webapps, so it's not too helpful in some respects, but overall there is a lot of help available.
Yawn. No. My programs never do that.
You may want to white-list what input characters you would like your script to process to prevent these kinds of issues. For example, in a simple arithmetic calculator, you may write (before eval'ing) $eq =~ s/[^0-9\+\-\*\/%]//g; To only process digits 0-9 and the +, -, \, and % operators. 
In case you haven't already found it, there's lots of good info on http://perlmonks.org
Seems to me this author sucks at checking return values and should type 'perldoc Getopt::Long' again.
Fixed now. I'd managed to radish my Typo installation rather badly.
I wish the Python guys no ill-will at all, but I do find it rather amusing that one of their problems is a lack of convention for tests and documentation :)
From the SYNOPSIS for [Getopt::Long](http://search.cpan.org/~jv/Getopt-Long-2.38/lib/Getopt/Long.pm): use Getopt::Long; my $data = "file.dat"; my $length = 24; my $verbose; $result = GetOptions ("length=i" =&gt; \$length, # numeric "file=s" =&gt; \$data, # string "verbose" =&gt; \$verbose); # flag It's not a gotchaânone of the example code does any error checkingâso I don't know what you mean. This really bothered me when I was first learning how to use `GetOptions`. I knew from the admonitions in the camel book that I should be checking return values, but the documentation never did, soâmaybe I wasn't supposed to be doing it after all? Maybe there was some behind-the-scenes magic?
From further down: &gt; Configuration errors and errors in the option definitions are signalled using die() and will terminate the calling program unless the call to Getopt::Long::GetOptions() was embedded in eval { ... } , or die() was trapped using $SIG{__DIE__} . &gt; **GetOptions returns true to indicate success**. It returns false when the function detected one or more errors during option parsing. These errors are signalled using warn() and can be trapped with $SIG{__WARN__} .
Yep, I noticed that, but the author explicitly addresses it in his article: Unless you manually elevate the `warn`ing to something more serious, it gives a very confusing output to the user $ perl foo -n Option n requires an argument Processing complete! I know that `GetOptions` returns true to indicate success, and false (together with a warning) to indicate failure. However, to do something about this truth or falsity requires something like `GetOptions(â¦) or barf` in the code, which is precisely what the author is advocating; and the warning, while nice, unless addressed serves only to confuse the end user, rather than doing anything to the program's logic.
Say the person didn't have permission to do `rm -rf ~/*`. Would they still be able to do that through this app?
This is done because honestly, having unparsable options, while bad, is up to the author of the program to handle properly, not some random module on CPAN. In fact, you can set the appropriate %SIG to die if you want. That this programmer didn't read the docs, and has different expectations than the author of Getopt does is not a bug. It's just a failure to read the docs. I'm not arguing merit of the idea, but it is /not/ a bug.
How do I install python modules: * find the TheModuleIWant on google * navigate to its website and download the code * unpack; python setup.py; find deps * repeat for deps How do I install Perl modules: * cpan TheModuleIWant Situation for ruby and tcl/tk is not better either. Ruby gems are ok, but install broken code without deps by default. Not good. Tcl/tk is a special story, but I've managed to handle it. 
I think that you may not have noticed the title: It's âThe horrible bug *your* â¦ program probably hasâ, not âThe horrible bug that Getopt::Long hasâ. The author's not claiming that there's anything wrong with Getopt::Long, just that there's something wrong with the common use GetOptions(â¦); proceed_blithely; Especially since this is the coding style indicated by the Getopt::Long documentation itself, I don't think that this can be put down purely to âBad programmer, no cookieââbut, even if it can, then it's a pervasive coding problem, and should be addressed. That's just what this article does.
easy_install via setuptools?
At first I was like, I never check that and my programs stop on invalid options. Then I remembered I set $SIG{\_\_WARN\_\_} = \&amp;confess . My daddy was a low level C programmer; we don't like warnings.
Only if that package uses easy_install
you could change the last print to this: if ($@) { print "Error in your equation: $@"; } else { print "The solution of \"$eq\" is $ans.\n" } $@ is the variable that catches the eval error, if any.
This actually illustrates an excellent point about Perl versus, say, Python. Perl is meant to be very close to natural language - and for me, this really helps me to "think in Perl" without getting structured too prematurely (or at all!).
Thank you, that really helps! Here's a nice up arrow!
weird, Perl &amp; Python live happily in my head Qore looks awesome, I didn't know it existed, it doesn't seem to have a lot of users though ...
david, you might as well stick that documentation right in your code in pod format. You can then read the documentation via "pod2text /path/to/pc". I formatted for you: #!/usr/local/bin =head1 NAME PC -Perl Calculator =head1 SYNOPSIS pc 11+3 =head1 DESCRIPTION =head1 HOW TO USE PC =head2 The basics $ pc 11+3 14 0xe 016 The first number is the integer result, followed by the hex and octal representations. Simple enough. Order of operations This shows that pc uses Perlâs order of operations (operator precedence if you are in a programming mood): $ pc 1+3*2 7 0x7 07 =head2 ASCII $ pc 1+3*20 61 0x3d 075 '=' Here we see an extra field was printed. In this case pc detected the final integer value was in the ASCII range and printed the character represented by the value 61, an equal sign. =head2 Bitwise Operations We also get Perl (and C) style bitwise operators: $ pc '1+3*20&lt;&lt;2 &amp; 0xff' 244 0xf4 0364 Also notice that we had to quote it since (a) I put a space in the expression and (b) I used the â&lt;â and â&amp;â characters which mean something to the shell. =head2 Floating point Of course itâs not restricted to only integers, it can handle floats too: $ pc 1+3*20/55 2 0x2 02 2.0909090909090 23/11 Youâll notice it shows the result of the floating point math in addition to the integer math. =head2 Human readable You might have noticed a fraction in the output of the previous example. pc uses Perlâs âbigratâ library to do fractions: $ pc 3/4+1/2 0 0x0 01 1.25 5/4 =head2 Human readable $ pc 1000*2000 2,000,000 2000000 0x1e,8480 0x1e8480 07502200 1.90MB Youâll notice that the integer and hex results are printed twiceâone with commas and one without. The one with commas is so that you the human can read the output easily. The one without commas is for copying and pasting. You should also notice that pc helpfully told you the number was 1.90MB. If a number is bigger than 1024 (1KB) it will print it in human readable byte quantity. Power of 2 magnitude suffixes It also accepts magnitude suffixes on the input: $ pc 16m 16,777,216 16777216 0x100,0000 0x1000000 0100000000 16MB The following suffixes are allowed: kmgtpezy (lowercase, no b). Note that the human readable output â16MBâ doesnât have a decimal point. It will remove the decimal point if the number is exactly that value. So: $ pc 16m+1 16,777,217 16777217 0x100,0001 0x1000001 0100000001 16.0MB Since â16.0MBâ has a decimal point, we know the value isnât exactly 16 megabytes. =head2 Large numbers pc uses Perlâs bigint so that it can handle numbers bigger than 32 bits: $ pc '1&lt;&lt;40' 1,099,511,627,776 1099511627776 0x100,0000,0000 0x10000000000 020000000000000 1TB =head2 Random Perl code $ pc 'ord("a")' 0x61 0141 97 'a' Since pc uses Perlâs eval you can do arbitrary perl code too. Though frankly the only thing Iâve ever used is ord(). =head2 Conclusion So there you have it. Itâs designed to give you all the output you ever could want without having to memorize any stupid command line switches. There are none, in fact. It also doesnât overload you with redundant data. If the floating point answer is the same as the integer answer then it doesnât show it to you. Same with the fractions. =head1 AUTHOR David Caldwell (david+spam@porkrind.org) =head1 SEE ALSO L&lt;http://porkrind.org/missives/pc-perl-calculator&gt; =cut use strict; use warnings; etc
Thanks! I don't know why I hadn't thought of that earlier... I've added it in (with some minor tweaks).
We really couldn't just link directly to [perl.org](http://www.perl.org)?
It looks great! Excellent job. Finally Perl sites come back to the future :)
Fun to look at, but note a couple things: * It's looking at raw CLI speed, which for PHP is sort of like testing how fast a fish can jog. * It's from March 2008. There have been significant releases for each of the languages used since this was written (and in some cases, before). I'm not going to insult the post itself. The author was having fun with benchmarks and seems to understand full well the flawed nature of benchmarks. He was just having fun running stuff a lot and comparing simple procedural programs to simple OO programs in different languages.
Great point - he at least admits his tests are flawed. It's kind of upsetting though that he didn't use the most up to date version of Ruby, namely 1.9.1. The speed enhancements are significant in that version.
Whining is an important part of your life, isn't it?
[sIFR](http://www.mikeindustries.com/blog/sifr/).
Using a version of Ruby from years ago? Sorry, but this comparison is meaningless. At least use current versions of software if you want to appear to give an honest comparison. The 1.9 versions of Ruby are fantastically faster than 1.8.
It really is one of the worst logos I've ever seen for a programming language.
It may sound like kind of a snarky answer, but start writing perl. Whatever you can think of. I personally thumbed through Perl Best Practices and wrote some example code every time I saw something interesting. As for a dev environment, I'm a vim guy, but I hear emacs also has a text editor. :) I think jrockway has done lots of perly emacs stuff, maybe you could google around for him.
[Devel::PerlySense](http://search.cpan.org/~johanl/Devel-PerlySense-0.0183/lib/Devel/PerlySense.pm#DESCRIPTION) will give you loads of useful things on top of cperl-mode.
The simplest thing to get right in a large code base is to name unit tests in a structured and consistent way so you can always find them without hesitation. Usually this means naming the files after the classes they test. Non-unity types of tests can be named after web URLs or other things that might make more sense in your domain. Getting this right costs nothing. Getting this wrong is pretty simple. Just don't pay attention to it, and you'll have a mess in no time. Actually, naming things is one of the most important things in programming. Spend some thought and effort on it. Make sure things have names that reflect their essence. And when the essence changes, change the name, even if it feels expensive.
CPerl mode and Sepia, here. The CPAN shell usually works for me, and if it doesn't, sending the relevant module author(s) a bug report will often fix it. As for code organization, how big is "big?" Honestly, for anything you would put together in a 1-2 year postdoc, just dropping common code into packages/modules is probably good enough. Module lookup in Perl works like in Java -- module A::B should be in A/B.pm somewhere in your PERL5LIB path.
Did you use CPAN to install Sepia?
It's been awhile, but now that you remind me, I used CPAN to install the prereqs, then installed the Elisp files by hand ("look Sepia," etc. from the CPAN shell). Emacs doesn't have a package system, unfortunately. If you run Debian, I think you can install it with `apt`.
I just use cperl-mode with emacs, although I've yet to set up a repl-in-emacs that like. I found Sepia and Perlysense to be very heavyweight, but jrockway has a repl that's looking pretty good. For keeping things organized, I'd recommend making very strong use of perltidy and perlcritic, both of which will keep you happy (especially at the beginning). There's a perltidy minor mode for emacs that I use, and I have several variants of its user commands bound to keystrokes so I can just tidy up my buffer or sub quickly and move on. I also have perlcritic run every time I save the buffer, which can be overkill but it ensures you're ok. There's a perlcritic minor mode as well, and you can set the severity within emacs with M-x.
 use strict; use warnings;
If you have any experience with C, you can write Perl in a very C-like manner. Though it's considered the mark of a newbie, it's an easy way to get started. Some idioms that will make your life a little easier from the beginning are the `foreach` loop, using hashes as ways to look up data or de-duplicate data and `while(&lt;INPUTFILE&gt;)` to read though lines of a text file. Coming from Scheme you will probably find that the built in functions `map()` and `grep()` support a style of programming that you are already used to. When writing procedural code, start your functions like this: sub function { my ($arg1, $arg2) = @_; ... } When writing object oriented code, start your functions like this: sub method { my ($s, $arg1, $arg2) = @_; ... } Don't try to use function prototypes, they aren't really analogous to function prototypes in other languages. 
perl with bio informatics flavoring in class is not fun. I'm currently taking a introductory class to perl and because my school consists of mostly students on their way to pre - med, my professor constantly makes references to how your going to have to find the coordinates of certain atoms in a dna strand and some other stuff of the sort. But if you have experience in programming you probably enjoy it from what i seen its one of the easier languages to use.
I use Perl every day for bioinformatics research and I could not live happily without [BioPerl](http://www.bioperl.org/wiki/Main_Page).
I disagree. Perl with bioinformatics is great fun, especially for biological sequence (string) manipulations. The golden era of comparative genomics was built on the back of Perl.
Any one have any suggestions for improvements?
Perl::Critic as well.
I use vim with syntax highlighting turned on and 4 space tabs. Install and use Git. I know that 'use some sort of repository' isn't very Perl specific, but it's essential. Oh, and [PerlMonks](http://www.perlmonks.org)
This, too. While the actual Perl community doesn't care, the Perl "community" insists upon certain mindless rituals. Following them avoids some wasted time.
Not an emacs person, but CPAN does get a little wonky when installing big packages/frameworks rather than simple modules. Most places I've worked, it's been subversion as far as organization goes. Coding style guidelines and project management has been all over the place for me. I've not seen any that I've liked much. &gt; whether I should expect CPAN to work and what to do if it doesn't. Generally, building things from hand won't be that tough. Someone else has had the problem, and can walk you through it... it's probably some odd dependency that needs a specific version. You'll end up liking perl, you can do alot with it. Just take it slowly and have fun.
From what I've seen, Perl6 is most definitely Perl. It's just not Perl5.
Obviously they need a flashblock check! Thanks though, hadn't heard of that before.
Well it seems MST's server is having some troubles. We have made an alternative available at http://gamoscope.com/ 
Jeeezes... Well all I can tell you is to look how those modules do it, and copy it. I think it'll involve reading and parsing the form data (and with www-form-urlencoded form data that is not trivial), read data in from STDIN and write it out to a temporary file. 
http://articles.sitepoint.com/article/uploading-files-cgi-perl or, maybe you meant this: http://www.xav.com/perl/site/lib/LWP.html#ftp%20requests
I can't use CGI.pm :( But I'll take a look into the second link, looks helpful :D
use the source, luke
If your website uses the Common Gateway Interface (CGI) to handle file uploads, and you can't use a library, you're going to have to read the upload directly. Your (CGI-compliant) web server will hand you the file contents on standard input (STDIN in Perl), as described in the CGI specification here: http://hoohoo.ncsa.illinois.edu/cgi/in.html That input's going to come to you in the 'multipart/form-data' input type. The HTML 4.01 specification tells you what to look at: http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.2 All the best!
Modules exist for a reason. Have fun reimplementing Chunked Content-Transfer-Encoding and multipart MIME. Whatever you come up with is going to have more bugs than lines of code.
I actually got it working with about 40 lines of code, I'll test it and tell you how many bugs I find :D Edit: There are less bugs than lines
I got it working, although my code is really messy and shows how new I am to perl. I'll clean it up a little and post it in my original post tomorrow for anyone who is interested. Thanks for the help :D
do not over-reach, you might risk the assignment
My 5 choices ran out halfway down the list ;)
Have you checked out [the Catalyst Cookbook](http://search.cpan.org/~hkclark/Catalyst-Manual-5.8002/lib/Catalyst/Manual/Cookbook.pod#Delivering_a_Custom_Error_Page)?
What course are you taking that uses Perl? It's pretty rare to see a school using it (wish there were more).
A few things I see (you may not want to fix all of them; I just list them for your own edification and because I'm a compulsive code-reviewer): :) - don't call your functions as &amp;functionname. just say functionname(args) - change open FILE, "&gt;/tmp/$head{filename}" to open my $file, '&gt;', "/tmp/$head{filename}" (it's great to see you checking the return value and dying if it fails) -- more information on that here: http://stackoverflow.com/questions/1479741/why-is-three-argument-open-calls-with-lexical-filehandles-a-perl-best-practice - your functions are referencing global data (e.g. writefile() is using $data, which was declared outside the function) -- make the functions independent by passing everything they need as arguments, e.g. sub writefile { my $data = shift; ... } - don't wrap variables in quotes when not necessary: e.g. $head{filename} = $1 rather than $head{filename} = "$1"- @header[2] is incorrect: to get the third element of the array @header, you should use $header[2] (of everything I've listed so far, this is the only actual "error", rather than "not a best practice" 
any /r/perl thoughts on dbuggr.com?
I'll take all your points into consideration. I'm new to perl still and I'm really enjoying working with it, I usually have cleaner code and I'm sure next time I make something like this it'll look a lot nicer. :D
The class I'm taking is mainly about Apache, SSL, and CGI scripting and how they work together. It's at Seneca in Toronto, here's a link to the class outline incase you're interested, [https://scs.senecac.on.ca/course/int420](https://scs.senecac.on.ca/course/int420)
Typical Web 2.0 failure.
Survey says: bleah!
tl;dr. What does it do ?
&gt; Wait a sec, this guy has only been developing software for 5 years? Nope. &gt; And he's trying to position himself as an expert by writing blog postings... Nope.
you mean, it converts an arbitrary image to a square one by removing the most "regular" sides ?
&gt; You said in your blog posting that you have been programming for 5 years. Nonsense. My first patch to Parrot, for example, was over eight years ago. I wrote the heart of the Perl 5 infrastructure at the same time. (I've been writing tests first for almost ten years.) &gt; It was the first sentence. You mean the sentence that starts "In my past five years of experience developing software..."? If I'd written "In my past five years of experience, I've discovered..." would you call me a child prodigy, because I'm obviously only five years old? &gt; And clearly you're working the PR angle so you can sell your books. You changed your argument. First you claimed that I'm "trying to position [my]self as an expert." Now you claim that I'm doing PR. Pray tell, exactly *which* books am I flogging? Can you find a single advertisement on my site? Me, I like to think I'm writing about my experiences of developing software in the past decade in the hope that people who've started recently will learn from some of the mistakes I've made and write better software. Which books am I selling again?
You don't know how many bugs there are until you run it on a public server, or distribute it on cpan, etc. As long as the code is not widely used, the bugs are just potential, however.
&gt; By the way I think your articles are above average. Thank you.
Pungent as always, mst. And, similarly, spot on.
Well, I am starting to understand all of this a little better now. I can safely ignore Perl 6, right? OK. Thanks for the entertaining rant.
I really tried to read this, and language does not offend me, but I couldn't get past every other word being an expletive and quit.
I too quite like test plans, but mst, as often happens, [is right](http://www.shadowcat.co.uk/blog/matt-s-trout/a-cunning-no_plan/). Specifically about them being hard to cope with in anything but the simplest test. Fortunately, [subtests](http://www.shadowcat.co.uk/blog/matt-s-trout/a-cunning-no_plan/) (which get their own plan) are a really good way to use them without fixing your entire test script to a rigid structure and introducing problems if two people are working on a test at the same time.
Can't we all just get along? I love several languages! Why not? Sure, I have a favorite, but if it lacks a library I need, or if there's a good body of existing code in another language, I'll happily use that one. There's room in the world for perl, python, and ruby to all be happy friends and help each other get better. We're all in this together! Be scripting language brothers! But fuck PHP. Fuck it in the vagina with a bent railroad spike.
[This](http://search.cpan.org/~mstrout/) is who MST is and his ranting predates Zed's social experiment.
I have often wondered: To what extent can one really write side-effect-free code in Perl? A lot of a functional programmer's favourite functions (like `map`) are in place, and one can always avoid binding any variables except the parameters to a functionâor, more flexibly, avoid anything but local variablesâbut there are so many Perl operations with implicit global effect (like the match-variable clobbering that Kogman mentions) that it seems to me that writing this kind of code is hard even for a very conscientious programmer.
Okay, this is actually a pretty good rant. Yes, pissing contests are apparently fun. They must be, or they wouldn't be so common. Yes, Perl 5 and Perl 6 are different languages. The problem is that they're both in the same family. When we have Perl 5 v. Perl 6 pissing contests, what others see is Perl people pissing on themselves. I've set my own rule to stop whining so much, because pissing on myself and whining won't impress anybody that I want to impress. 
I've been doing it for years. Perl affords me the freedoms to not do that when it's convenient (JFDI). It might not be the most ergonomic language for purely functional code (no native pattern matching for instance, a strong support for side effects, etc) but there's nothing to prevent writing code that way.
too bad, because he actually had a point.
Didn't he write DBIx::Class, too?
And `Devel::Declare` and....
[This](http://www.flickr.com/photos/mirod/4042453786/) is who mst is
No, that's my point: Even if you are disciplined and write code in such a way that *you* don't introduce side effects, then it's hard to be sure that the *language* doesn't. A program without a regex match in it hardly feels like Perl at all; but every regex match has implicit side effects. (These have been minimised over the yearsâwitness the recent possibility of `my $_`âbut are by no means completely eradicated.)
This is great stuff. We've long needed a modern replacement for use.perl.org. The latter has served us well for a long time, but it's showing its age. People have been wanting something better. There are still kinks to work out, but once done, I expect that most Perl bloggers using use.perl will make the switch.
That's arguably a fixable interpreter bug though, so previously written code can become truly pure eventually. Secondly, approach this pragmatically: how much does lack of reentrancy in ?{ } really get you day to day? I was using it to illustrate a point. If the Int validation routine instead relied on a global $value variable and you would need to do this: $value = $whatever; Int(); Then that would be broken in many additional circumstances. For me writing purely functional code is a way to minimize headaches most of the time, I need to worry far less about combinatorial failures. It's not perfect because Perl isn't perfect, but it does go very far.
Sure, you can safely ignore Perl 6 for now. On the other hand, it's [right there](http://rakudo.org) for you if you ever get curious.
I can't seem to get this to send me a confirmation email ... It says 'Cannot Fork' .... wth? And openID gives me Attempt to reload Net/OpenID/Consumer.pm aborted. Compilation failed in require 
I'm totally willing for perl6 to replace perl5. I prefer the new object model, and want that to be built in rather than using Moose, for example. It's just that it's going to take time. I've finally downloaded and installed Rakudo, and have played around with some examples. I think it's great, but until there are a wide range of modules for parsing HTML and XML, database drivers, etc; it will be hard for me to move new projects to it.
[You wrote](http://blogs.perl.org/users/ovid/2009/11/why-blogsperlorg.html) * OpenID support (for commenting, but not blogging). Why not both?
So, he's been hard at work having other people program, design, and host a site for him? I don't get how that works.
I don't recall, to be honest :)
Capacity issues which didn't show up during testing. Since this was built primarily on volunteer labor, while plenty of bugs were found, a full load test was never done (they're hard to do correctly and we thought it would be better to launch early. Now we're getting slated for it :)
Actually, he installed it, he's done a lot of the admin for it, he worked with several others to coordinate the features we want and he's been working on various issues related to it. It's not like Dave sat back, waggled his fingers at his minions and then imperiously announced that he made something happen :)
Sadly I got this when trying to do a search: Attempt to reload Lucene/QueryParser.pm aborted. Compilation failed in require
It's forked. :(
I get 'Access Denied' errors when trying to download the book.
I'd like someone with a better background than mine comment a little bit about the new [pluggable keywords](http://bit.ly/4CtMjX) feature. Isn't this kind of a huge deal? Will this make Devel::Declare simpler/easier/faster/obsolete?
Hm... A broken attempt to reimagine Haskell with ugly syntax? No, thanks.
How about now? It didn't give me any trouble.
so ... how do I get an account? Send a request at night? 
It works, thanks.
I don't know *much* about it, but the intent seems to be to make Devel::Declare and other modules simpler and easier.
a broken attempt to reimagine Perl 6
This is great! :)
eh, new 404 ?
It seems you can now find it [here](http://rurban.xarch.at/software/perl/illguts/)
It seems to work better now.
I wouldn't call it a broken attempt to reimagine a broken attempt to reimagine Perl 5 -- you're too hard on yourself.
I like the idea of compartmentalizing features so we can figure out what works best together
If you "just" need Linux-only: On your Makefile.PL: use ExtUtils::MakeMaker; die 'OS unsupported' unless $^O =~ /linux/i; # rest of usual Makefile.PL If you need something more specific, you may want to list Sys::Info as prerequisite in META.yaml, use it on Makefile.PL, and do something like: use ExtUtils::MakeMaker; use Sys::Info::OS; my $os = Sys::Info::OS-&gt;new(); die 'OS unsupported' if $os-&gt;is_windows(); # rest of usual Makefile.PL My 2c ;)
Thanks!
Sys::Info::OS would need to be in configure_requires
Reddit is generally not the place to ask coding questions. If Perl Monks didn't help out, then look at stackoverflow.com or ask on the p5p mailing list.
I will do so thank you good sir! 
Done! http://stackoverflow.com/questions/1791114/creating-threaded-callbacks-in-xs
Anyone seen any real life examples of this? Update: Perhaps this is it http://plplot.sourceforge.net/examples.php
Padre is cool, but the name is awful. Too much christianity in that perl community. I've got a better name: NunEditor which means: not an editor. That would be fun.
....it is also mexican slang for "cool, acceptable, easy" http://en.wiktionary.org/wiki/padre#Adjective OTOH a nun is "A member of a Christian religious community of women who live by certain vows and usually wear a habit, in some cases in a cloister." http://en.wiktionary.org/wiki/nun so much about ease of picking a name :-) 
I agree, picking a good name is hard. But 'padre' just seems to be the wrong one to me. I just can't image myself using something called 'padre' :) On the other hand, I took a glance at the source code, and it's pretty good. And the features are good. I like it. I actually hope to port some of the features to vim if find enough free time..
The name has absolutely nothing to do with christianity, I hack on it, and I'm not christian, so I would suggest the problem is with you rather than either the perl community (which has a much larger and noisier atheist minority than the small and barely noticable outwardly christian people, most of whom I could count on one hand, and none of whom have ever bothered me)
Just FYI, many people (including me) will not click on obfuscated URLs as there is no way to tell where it will go or what kind of content lurks there.
I don't get it - is it an open source platform or a public facebook wall?
Yes, Perl is going into oblivion following the tracks of Cobol (yes, I know it's not true). I think it would be best if the "Perl 6 folks" promote "perl 6" as "Rakudo". The new name would have much better impact on the community, than "new, stronger perl". There's a form of psychological pressure when people hear the name 'perl'. I've seen it many times. They just wanna explode if I persist mentioning it. Yes, they all want bad programmers to write good code, but this cannot happen, no matter what.
Considering stats, usage of Perl is raising. So no oblivion.
Hmm, COBOL is a 50 year old language that is still to this day used in some of the most mission critical software on the planet (banks, stock exchanges, etc). And Perl is installed on, and a core part of, just about every *nix system on the planet. That is a pretty strange definition of "oblivion" you have there. The answer here is pretty simple. If you don't like Perl, don't use it, there are plenty of other languages you can use instead. Those of us who like Perl will simply continue on our way, no worse off for not having you along for the ride. 
Although corporate sponsorship and advocacy is an issue, I don't hear enough about the near complete absence of Perl taught in universities - it seems to me this would be a useful statistic to track. It's probably safe to generalize that most introductory CS courses prefer Java and Python to teach core data structure and algorithmic constructs, whereas the Unix toolchain and Perl slide off to elective-land, if they exist at all. At the university I'm in, there's likely not a single undergrad who knows Perl or knows it very well. And since they're learning Python, and grow to love it because it's so much more fun than Java, learning Perl is seen as a redundant and unnecessary skill (I'll also throw in there's a youthful tendency to join bandwagon-bashing, and there's a general sentiment that "Perl is dead"). So I guess another key question should be: how do we get Perl advocacy in teaching CS concepts? It doesn't seem to be a big topic.
&gt; how do we get Perl advocacy in teaching CS concepts? That's a really good question. Some of the discussions surrounding the Google Summer of Code have led to a few Perl Monger groups visiting their local colleges and universities, but that's been sporadic. London.pm sponsored free Perl training a couple of years ago; that seems like a good tactic as well.
I love Perl and I'm using it for the last 6 years or so and will use it in the future. My comment was intentionally provocative and sarcastic.
You've got a good point about university Perl programs - I remember when I was first studying the Slashcode (Slashdot's code base) and hearing about Hope College in Holland, Michigan and their involvement in the project. It made me reconsider my previous biases about institutes of higher learning in general to hear about such a progressive (for the time, as Open Source web application-style projects were few and far between in 1997-1999) attitude from what would have otherwise appeared to be a conservative institution. I attended the University of Minnesota for a few semesters when I was finishing my apprenticeship under an area artist just to see what university was like, and found that most comp-sci programs were either completely useless in modern business (I suspect most of the money from C/C++ was made before I was a proficient enough coder, and Java just seemed soooo cumbersome I just didn't even bother with most post-secondary education in terms of computer science. I was especially intrigued by Perl the more I learned about it. Unlike a lot of the competing languages, Perl's *really* been used (and stress-tested) in almost any area of modern computing that I can think of. Bioinformatics, web apps, neural nets and A.I., database warehousing &amp; mining, and so much more. It was hard to ignore the hype surrounding the other languages, but I'm kind of glad I spent the time looking at their advertised improvements and functionality and promises that coding would be sooooo much more fun than good ol' Perl or whatever, because it taught me to compare my preferred language to other languages in a slightly more informed manner. And let's face it, it's taken a looooong time for Perl to evolve into the smoldering volcano of virility it is today. ;-) Modules like Perl::Critic and many test suites, heck, even a decent MVC framework weren't very widely known back then (if they even existed), so for a while, it was anybody's guess which languages would survive and prosper. It's still open to debate, I guess, but in my opinion, Perl won big over the last decade, and it's still all the rage in my admittedly miniscule social circles. The important thing is that it gets the job done, it's flexible enough for *any* application, it's scalable, fast enough, and has what is probably the most encyclopedic documentation and tutorials of all modern languages. So, Perl wins, for us. The hard part is convincing other people that Perl would be a big win for their projects... but the nice thing is there seems to be a lot of comeraderie between the open source scripting communities, and I regularly bump into Python, Ruby, Lua, and even shell scripters who just think: &gt;"SCRIPTIN' IS FLIPPIN' KEWL." Period. I'd encourage universities to take a closer look at their offerings these days and see if there are approaches they could take to expand their horizons. Nobody wants to sit around benchmarking the various sort::bubble sort::bubble-bobble sort::triple-bubble-bobble algorithms anymore, do they? (Sorry, Don Knuth...) Mostly, young varmints these days seem to want to learn to write programs that are *easy to understand, *maintainable, *extensible, and *sexy. Which is **totally** pretty much everything Perl stands for. The "marketing" people seem to think Perl needs at this point is sort of like marketing the Asteroid Belt. It seems expensive at first, there are some significant barriers to entry, there are vast, vast resources and rewards to consider, and there is (as always) a significant amount of risk, as in any business venture. But, well. Larry Wall wrote Perl while he was working for NASA, so I'm pretty sure we've got some modules in the works that will make mining the flippin' Asteroid Belt a bit easier. (At least, it's my *suspicion* that Larry thinks that far ahead. I'm many layers of onion away from that dude, so I don't really always know what he's thinking, but you catch my drift, right?) 
I think Moose should get hyped a lot more as a modern OO platform that's superior to Java and Python conceptually. You want to discuss marketing: I think it should remove all words like "magic" and "sugar" from its user documentation and leave them in source comments or class documentation and replace them with words like "stable" and "robust." It is downright fun to program with and easy to experiment with. The addition of Roles, a flexible type system and automatic parameter validation are simply primo. It can't hurt Python that it's much easier for faculty to communicate CS concepts than C++ or Java (which require a lot of peripheral language instruction first) and native Perl 5 (same, plus too idiosyncratic). While Moose is of course not first-class like Java and Python, the important thing is it allows you to focus on the design and not the language, which is really what matters in coursework. I haven't mentioned functional programming but I think most students are being taught in the OO paradigm (certainly MIT moving from Scheme to Python contributes to this perception).
Optimization has its limits. There's more to reasoning than proverbs and catch-phrases. The inverse of "if it aint broke..." is "There's always room for improvement. The opposite of "Many hands make light work" is "Too many chefs spoil the broth". Also consider: "Look before you leap." vs. "He who hesitates is lost." "Better safe than sorry." vs. "Nothing ventured, nothing gained." You be the judge.
The Python script is only counting when the rolls are some permutation of [L, R, C]. Your Perl script is counting any set of 3 rolls that doesn't have a D. For example, the Python script wouldn't count LLL or RCC whereas yours would.
Oh thanks. I was stupid last night .... which is no excuse.
I've been working through operator overloading from Programming Perl (3rd Edition) and it seems as though it's changed quite a bit from how I remember it. Does anyone else find it peculiar that they call the hash-&gt;key maps "hoppers" instead of "queues" nowadays? I think I need to apropos hopper or something, but I can't find the man pages on this crappy MRI WindowsEmbedded machine.
[ XPOSTED from blogspam submission for blatant comment karma ] it took me several minutes of reading the article to realize that very few of these are "secret" operators. they are more accurately clever abuses of the parsing patterns, and calling them "operators" because they can be dropped in and we can trust the precedence table to say what we mean for it to. for instance, 0+ isnt an operator. add 0 to an object, and that object will be forced into a numerical context. ~~ isnt truly an operator, its just performing bit-not twice, to force it into a scalar context (flipped), and then flip it back to the intended value. ~- is a joke, since its just abusing the concept of two's complement to perform a very simple operation that could be achieved by subtracting by 1 (very likely, a less costly operation than flipping bits and negating a value) and, my favorite is the }{ operator, since it isnt an operator, but just abusing the -n flag's expansion of the code parameter as a macro expansion, so the }{ gets interpretted as separating the two blocks. this isnt an operator, just an abuse of the interpretter. a clever abuse, mind you, but not an "operator". 
"jokes"? whats that?
he got a little lazy on the last 2 (-+-, 0+), but he pretty much explained all of this in the article
Who calls them hoppers?
there's ${\\()} too which is like @{[]} but it works for scalars like, for instance: ${\\($ref-&gt;{'elem'}-&gt;[$i]-&gt;{$var})}
I'm partial to the reciprocal operator: $ perl -le 'print ///3' 0.333333333333333
Maybe I just hang out with some weird Perl kids, but they don't "pop stuff off the queue any more" when they're using operator overloading. Instead, they just keep throwing hashes into the "hopper" (I think it's named after Grace Hopper but do not know why or if that's true or not), collect all the popped hashcorns into a big bowl, salt &amp; butter liberally, and throw in a DVD. Apparently, random hashcorns, when popped, come in different flavors, such as %hashcorn-&gt;cheesy; %hashcorn-&gt;caramel; %hashcorn-&gt;parmesan; And you can use the use Sneak; pragma to get them into movies under your coat. It helps if you can create a distraction first by scripting up some terrible pun threads to distract the staff if necessary, but if you look around here on Reddit, I'm sure you'll find something.
Well, if you're using 'strict' and 'warnings', you don't have much of a choice to properly define the scope of the variable, do you? That you're NOT using 'strict' and 'warnings' is more worrying.
im using -w, and i hate the warnings, so i fix anything that leads to more "noise". "use strict" is a horrible joke as far as i can tell. youd have to be in the thousands of lines range to forget your variables, and in the thousands of lines range, why are you using perl anyway?
as far as i can see, "my $file" or "my $line" are verbose in a loop.
Turn strict on, you nit. 
read before you pass judgment. and EDIT: this is the torches and pitchforks, then...
I think I hate "you".
First, let me say that I know where you are coming from: There will always be illiterate asshats who define readability as a function of *their* skill level- they'll often refer to things being "too clever", offer to make "aesthetic" changes, and even introduce nonfunctional noise with no justification besides "improving readability". Do *not* let this lead you to believe that readability isn't important or that it is easy: Writing your code for someone else to read it is a difficult skill to master, and it is an *important* skill to master. You should understand that readability is a function of your audience. In a workplace, your management staff cooperates to figure out what skill level of programmer they can find/afford, and *that* defines what will pass for readable. Being able to write readable code means that you can cooperate and function in that workspace. For example: If your organization staffs four programmers, then readable code is whatever these four, and four potential hires could interoperate on, and *writing* readable code is important unless you can do all of the work of those four programmers *and* the company can reasonably expect to hire another person *just like you* to replace you. Too often, emerging programmers discover quickly how effective and capable they are, and note that they *can* do the work of *four* other (particular) programmers. They forget that the company has to be able to replace them, or the company is making a bad decision. Other times, you get a really good group together that works really well together, and they begin to code above the hiring pool. Being able to write readably largely means recognizing and identifying these things. It *doesn'*t have anything to do with "my" or "our" or any other particular bit of syntax.
The apps I work on tend to be in the 100-200kLOC range. Perl is eminently suited for huge apps, more so than Ruby, frankly. I think you're being silly.
Perl true and false - What evaluates to true and false in Perl.
&gt; and in the thousands of lines range, why are you using perl anyway? Because it's a really good choice for programs in the thousands of lines range. The Perl codebase I work on spans a half million lines of code, and the flexibility of scope in Perl is a really nice benefit. I came back from working on similarly large Python (which does not have block scope) programs, and found it to be pretty refreshing.
OK, let me just point out what "my" does for you: Reduces a variables scope. We all (presumably) agree that smaller scope for variables is a good thing in any program more than a few hundred lines. Perl has more fine-grained scope than most mainstream programming languages, including Python and Ruby, last I checked, making it slightly more robust against scope related bugs. It is shorter to type and less characters to read than "local". It is faster to use than "local" because it does not make a copy of the variable; it allocates new memory for the variable. It has none of the side effects of local, for this reason. If your program is very short, and you really don't want any control over scope (e.g. you want all variables to be global), you can define them at the top of your program, as we did in the olden days, or you can turn off warnings for variables (instead of using -w, the ["use warnings" pragma](http://perldoc.perl.org/warnings.html) allows you to specifically control *which* warnings you get). So, if you find it noisy, you might be using too many variables. Try using functional constructs and Perl's powerful expressions to kill variables rather than hating my. When I've refactored large older code in the past, I've often been able to kill 25-50% of the variables, while reducing line count, just by taking advantage of the capabilities of Perl. grep, map, etc. can very easily kill off unnecessary loops and placeholder variables, for example. Side effect is often that the code runs faster and is more memory efficient, to boot!
&gt; The number zero (0) means false. Usually, but "0 but true" is 0, but true. perl -Mstrict -Mwarnings -le 'print "0 but true" + 5; ( "0 but true" ) ? print "true" : print "false"'
I thought this said "Planck Advent Calendar", which would be even more awesome. Sorry, Miyagawa.
Have to plug [Pod::HtmlEasy](http://search.cpan.org/search?query=Pod%3A%3AHtmlEasy&amp;mode=all) which is designed to do exactly what the poster has released. It works just fine from the command-line, so you can plug it in your favorite editor rather easily, so you've got that going for you, which is nice.
&gt; "use strict" is a horrible joke as far as i can tell. Note to self - pass on iamfight for next programmer opening.
That's pretty fucking swish. I wonder what it'll break.
It will break reporting of forgotten semicolon at end of statements which are followed by a block. (Because the new syntax allows two terms in a row). No idea if that's worth it.
DBIx::Class and Catalyst will grab 90% of everything you'll ever want to reach for.
Modern::Perl
You might want to look into Plack, it is a port of Ruby's Rack and Python's WSGI for Perl and is looking really exciting right now. 
Ask yourself this: how often do bare blocks occur? I would say, pretty rarely. Most blocks are subs, if blocks, for loop blocks, etc. When bare blocks do occur, how often do they follow a statement that requires a semicolon? Again, rarely -- the most common place to see a bare block is at file scope, where it's probably after a sub or a BEGIN block, and those aren't statements anyway, and don't get semicolons. :)
Incidentally, just confirming: you're Moritz Lenz, 'moritz' on MAGnet, useperl, etc., right? Or am I wrong? I'm 'hobbs' those places.
More than you might wish: sub slurpish { my $file = do_stuff(@_) { local ($/, *IN); open IN, $file; &lt;IN&gt; } }
I usually write that one with `do BLOCK` so that I can get the value from it directly: open my $fh, 'blah blah' or die 'yadda yadda'; my $data = do { local $/; &lt;$fh&gt; }; so, no bare block there. Yes, I take your point, but I still stand by my assertion that problems would be pretty rare in practice. :)
As was mentioned in another writeup on announces in the Perl community on here, it would be nice if such announces could contain some sort of hook in the title that makes the announce read-worthy. For all i know this could be a pure bug fix release, which would be completely uninteresting to me as a Komodo user. ;)
[Task::Kensho](http://search.cpan.org/perldoc?Task::Kensho) should be enough :) 
I just did that very thing this morning. Aside from the built-ins: * DBI * DBD::Pg * LWP * HTML::Parser * XML::Simple * CGI::Application CGI::Application includes HTML::Temple, and I add the plugins for JSON and DBH. I added Modern::Perl also.
You're right.
Whenever I want to introduce a new scope for a lexical variable, or for local()izing an existing variable. (And no, I don't usually use do {} for slurping files, because that means you have no control of what happens when the implicit close() at scope exit fails).
In the example I pasted I didn't actually declare the lexical inside the do :)
A good alternative to the slow-motion cult of FAIL that is Moose.
Now I can tweet from vim! Next up, getting a life ;-)
Wait, what?
I don't use perl for web development, so my choice of modules is probably quite different: * Date::Calc * File::Basename * File::Find::Rule * Log::Log4perl * AppConfig * DBI
maybe it would be best if you register at and ask [perlmonks](http://www.perlmonks.org/) for helpâ¦
Why have one 'Perl Buddy' when you can have dozens? Get yourself on IRC. There will always be someone around willing to answer questions, critique your code and discuss implementation details. First stop should probably be #perl on irc.freenode.net, but there are a whole load of Perl-related and project-specific channels on irc.perl.org too.
You may want a Perl buddy, but what you really need is a grounding in computer science. Your confusion with the my keyword had nothing to do with Perl and everything to do with writing maintainable code. And, frankly, a lot of that is lack of experience. If you've never had to track down a typo or a name clash in 100,000 lines of code spread out over 200 files, then scoping just doesn't mean that much to you. The very first time you do, you become a "True Believer"â¢.
hence the post...
The jerk-and-jackass fraction on IRC #perl is too high for that to be a useful suggestion, in my opinion. I think the Perlmonks suggestion was probably better.
&gt; And, frankly, a lot of that is lack of experience. There are two ways to get experience. You and I did it by trial and error and fire and blood and sharp, poky things. The second is to learn from someone with that kind of experience.
You're welcome to message me and we can continue our discussion via email.
Mmm .... sharp poky things. The memories are ..... OH GODS MAKE THE PAIN STOP!
I see that you've used `tie` and XS.
tie, yes. I've been smart enough to run screaming from XS, though I keep getting curious to peek around the corner every couple years. Now, I think I'm resigned to just waiting for Perl 6 and sane grammars.
You want to be taught - get a book. The [Llama](http://www.google.com/search?hl=en&amp;client=firefox-a&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;hs=hEE&amp;q=learning+perl+5th+edition&amp;btnG=Search) is a good one. Learn and practice on your own, then ask perlmonks questions whenever you have them. I agree with others about communal mentorship. Edit: Wow, linking to the book's sale page automatically mods the post to 0. Follow Google then...
I'd echo the what the parent comment said, but at the same time, feel free to post of code here for comment. I'd enjoy giving feedback.
NONONONO. i dont want to get taught, cause i already know how to write. i want to get feedback. and im wondering how perlmonks will respond to "so what do you think of my new code? any obvious holes?". it doesnt seem like the place to go with things that already work, but could possibly be better.
ok. heres one that i use to match dates in my data. i wanted to avoid using the bash date or modules. its possibly overkill, but it works. thoughts? my(@range, %year, @months, $mon, @dates, @time, $today); @range = (2008..2010); #runs any range, 3000 years takes 4 seconds %year = qw/Jan 31 Feb 28 Mar 31 Apr 30 May 31 Jun 30 Jul 31 Aug 31 Sep 30 Oct 31 Nov 30 Dec 31/; @months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/; @time = localtime(time); # 3$mday 4$mon 5$year 6$wday 7$yday $today = ($time[5] - ($range[0] - 1900)) * 365 + $time[7]; # (year-range[0])*365+yearday = todays index for(@range) { #fixes + 1 for each leap in range until now if($_ % 4 == 0) { if($_ &lt; $time[5] + 1900) {$today += 1} $year{Feb} = 29; } else {$year{Feb} = 28} for $mon(@months) { for(@_ = ("01".."$year{$mon}")) { push(@dates, "$mon$_"); } } } sub DATES { #feed ($from,$to,"s") # () = todays Mmmdd my($i, @return); #"s" = split (Mmm,dd...) # no "s" = Mmmdd if(!@_) {@_ = (0, 0)} for($i = $_[0]; $i &lt;= $_[1]; $i++) { if($_[2]) { push(@return, substr($dates[$today + $i],0,3),substr($dates[$today + $i],3,2)); } else {push(@return, $dates[$today + $i]);} } return @return; } format of data i would be searching: Dec09 drank beer Dec10 again with the beer Dec11 no beer Dec12 beer again 
re perlmonks - I think it is absolutely *the best* place to ask for coding critique - seriously, try it and see how it goes (be sure to read up on formatting your posts first). Also, from your own admission you need a better grounding in the fundamentals (like scoping with my), and I would still recommend a combination of self-teaching with a good book and targeted help and discussion with others.
Why did you want to avoid using modules? 
I can totally understand the motivation for wanting to get feedback on your code. Perlmonks is great for this. But given you've posted here, I'll try to answer here (don't take from my username that I'm a guru, just that I'm passionate about perl). I really don't understand why using modules is a no-no. I'd trust your instinct that it's overkill. In my experience, 10 out of 10 times I think something is overkill, it is, and probably 10 out of 20 that I don't! Creating a big array to begin with is perhaps not the best approach. There are quite a few problems with this code. It is not very readable. What you're trying to do with the DATES subroutine is obscured by it's generic name. I can't work out why you want offsets from todays date or why you want the alternating monthname, day if called with a third argument. Subroutine and variable names should clearly describe what they do or the data they contain. DATES() doesn't do this; neither does @return. Why have you chosen to call a hash containing the last day in each month %year? Maybe try %last_day_of #, that way you could write $last_day_of{Feb} , which is easier to understand. If you're likely to use this in a keys, each or values call, then these kinds of underscore-of names aren't always best - %last_day_of_month is kind of better in that case. Testing a variable: if ($var==0) is valid but not very perlish. Better to do: unless ($varname), and you don't need the else clause because you have already initialised to the default value of 28. You probably need to think more carefully about scoping. You want a variable to be as locally scoped as possible, so try: for my $mon ( @months ) { etc... and for ( my $i = $_[0] etc. rather than declaring these earlier with broader scoping. Substr and C style for loops are available in perl (tmtowtdi) but aren't always as readable as some of the equivalents.
thanks for your input! this is exactly what im looking for. in my data, sometimes i need the Mmmdd, and sometimes i need the Mmm and the dd later, so i figured offering the option of splitting it in the sub was cheaper than calling a split in the "meat", if you will. i created the big array of dates thinking that it was easier to calculate back and forth if the index was defined from the start... taking into consideration leap years etc, i assumed it would be easier to maintain for the long term, though youre right about it being difficult to read now. readability seems to be a problem... im on it, and thanks again!
half compatibility and half diy
I get the half-diy part. That's reasonable. But you really should consider using them for real projects. IMHO, they're one of Perl greatest strengths. On the DIY side, do you want to share some example data &amp; what the overall problem you're trying to solve is? That might be easier. (You gave an example above, but it doesn't contain a year, which you check for in code.)
CPAN modules are usually seriously tested by cpantesters
i know, it needs notes... the year i checked for was to decide whether it was a leap year or not. like i said, i was starting with an array of the timespan, and then using the index to find what i need relative to today. i would be using it like @dates_i_need = DATES(-7,7); for(@file_i_just_opened) { @split = split(/ /, $_); if($split[0] ~~ @dates_i_need) {print $_} } which would give me a two week span centering on today. id then use that to search for those dates in the data. the overkill part started with making it work over year ends and leap years, and finished with it working for any timespan ever. still, it does the job.
Honestly, date handling is one of the crappiest tasks in programming (not to mention, error prone). I'd really recommend checking out Date::Calc, Date::Manip.
The cult of Moose is failing in slow-motion? The cult of the failing Moose in slow-motion is failing? The slow-motion failure of Moose is a cult? The slow-motion Moose of failure is a cult? The slow-motion cult of Moose is a failure? (I just started using Moose, and yeah, you bet it's slow... if you're doing something stupid like using it as a CGI or something. Oh noes, 300ms startup times, the horror!)
HTML::FormHandler, HTML::FormFu or the upcoming Form::Sensible
What's wrong with the simple life? Must all the languages be multi-paradigm in the same ways?
I don't understand the question.
Le oops: &gt; my $v = $c-&gt;request-&gt;parameters; &gt; my $query = $v-&gt;{query}; &gt; my @names = @{$v-&gt;{name}}; &gt; $query might become ARRAY(0xabcdef) if there are multiple query= parameters in the query. @names line might cause Can't use string as an ARRAY ref error if there's only one (or zero) name parameter. When you have an interface to something that may have zero, one, or many values, having it return a different, incompatible type for "many" and "one" is a really bad idea, even if "one" is the most common case.
Yes, that's my point in the post! :)
Ugh, yeah, I run into this a bit. The individual package channels tend to be much better. The DBIx::Class one is awesome. I really hate being told to RTFM when I am asking because I read the fucking manual, and it isn't covered. And, #perl tends to fail at answering more complex questions. Some people are cool though, it's at least better than #postfix.
That's a far nicer solution than either Catalyst's I-might-get-a-ref method, or the PHP/WebOp.py name-things-in-an-ugly-manner method. Well done ;) One question, though: In the case of multiple parameters when you're only expecting one, why is the **last** value considered to be the one you should be given, rather than the first? Best I can tell, in most cases you're going to have control over the parameter list anyway, so it doesn't really matter whether you get the first or the last (it's either going to break or it's not, depending mostly on luck). But if you're unlucky enough to be in a situation where extra things are being added to your parameter list that you *don't* have control over, isn't it far more likely they'd be added to the *end* of the parameter list? Meaning by taking the last value by default, you're setting yourself up for a fall should something append parameters that happen to clash. And before you say "that'll never happen!", I've encountered this situation myself while trying to build links to sites that send extra data (for the benefit of the site's web analytics system). And had to deal with scripts exploding in interesting ways :) If it helps any, CGI.pm does return the first: &gt; perl -MCGI -e 'my $q = CGI-&gt;new("p=foo&amp;p=bar&amp;p=baz"); print scalar $q-&gt;param("p");' foo
Good stuff. I have been slowly adopting a convention in my code to make this kind of "how many am I expecting?" thing more explicit. I think it's a Good Thing. For example, if many orders can be associated with a user then I'll have methods like this: $user-&gt;all_orders($spec) # list (possibly empty) of all orders $user-&gt;any_order($spec) # one or no orders (returns undef) $user-&gt;one_order($spec) # exactly one order (or throws error) I would usually alias `orders()` to `all_orders()` and `order()` to `one_order()` to save myself a bit of typing. But I like the fact that there's a convention built into the method name (even if it's masked by a bit of sugar on top). It's a bit like Hungarian Notation, but done right (i.e. used sparingly for when it really matters). Apply this to the parameters(), you could have: $hash-&gt;get_one($name); $hash-&gt;get_any($name); $hash-&gt;get_all($name); With `get()` being an alias to `get_any()` which would return a single item or a list. `get_one()` would return a single item (the last if many are defined) and `get_all()` would always return a list. Or if brevity is your thing: $hash-&gt;one($name); $hash-&gt;any($name); $hash-&gt;all($name); You also need to consider what happens if/when you allow a user to set a parameter. They may want to add a new value to an existing parameter (which may currently be undefined, single value or multi value) or replace the existing value or values with either a new single or multiple value. I favour using `set()` to mean "replace existing value(s) with.." and `add()` to mean "add this value to any existing value(s)" $hash-&gt;set($name =&gt; $value); # replace $name with $value $hash-&gt;add($name =&gt; $value); # add $value to $name values [thinking out loud] Another approach that might be worth considering (although I think it's probably not practical in this case) would be to have the hash array return a blessed array of the values defined. This object would then have methods to return either a single value (first, last, nth), a list of all values, a uri-encoded representation of the values, and any other methods that might be appropriate. my $value = $hash-&gt;get($name)-&gt;first; my $value = $hash-&gt;get($name)-&gt;last; my $value = $hash-&gt;get($name)-&gt;n(2); my $values = $hash-&gt;get($name)-&gt;list; my @values = $hash-&gt;get($name)-&gt;list; my @values = $hash-&gt;get($name)-&gt;unique; my $query = $hash-&gt;get($name)-&gt;query_string; And because it's just a blessed array, you can poke straight into it and ignore all the object-ness of it if you prefer. my $value = $hash-&gt;get($name)-&gt;[0]; In effect, this is imposing a policy that every value is returned as a list containing 0 or more items. The fact that it's a blessed list means that we can add some sugar in the form of methods for accessing items in it. But other than the additional `bless`, there's not a lot of difference. The advantage of always returning a list reference (blessed or not) is that it removes any ambiguity. The caller always knows how many values are defined and what they are. The downside is, of course, that it adds the additional complexity of dealing with a list for every parameter. I think that would probably be unworkably annoying in the real world. But it I wonder if a separate method could be set aside for this. Perhaps `one()` and `all()` could return single or list values, respectively, and `any()` could return a collection object? my $value = $hash-&gt;one('foo'); my @values = $hash-&gt;all('foo'); my $value = $hash-&gt;any('foo')-&gt;last; my @values = $hash-&gt;any('foo')-&gt;list; [EDIT: sorry for the wall of text]
Yes, it's worth discussing, or at least having an option or whatever to change the behavior. Currently, i can name two reasons i chose last instead of first: a) it's in sync with what WebOb.py and Rack::Request does. I'll be interested to see if there's CGI-related document that suggests which is better. But more importantly, b) that's in sync with Perl's default behavior when you evaluate a list (not an array!) in a scalar context: &gt; perl -le 'sub x { ("a", "b", "c") } my $x = x; print $x' c
It's also consistent to how Perl merges hash with the duplicate keys. my %foo = ('foo', 'bar', 'foo', 'baz'); # $foo{foo} = 'baz'
Please. God. No.
Be careful with the phrase âlist â¦ in a scalar contextâ. Its legitimacy is [hotly contended](http://perlmonks.org/?node_id=719099), to say the least. I think it's especially important not to think that there's any difference between the list-looking things in perl -e 'my $x = qw/a b c/; print $x' and perl -e 'my $x = sub { qw/a b c/ }-&gt;(); print $x' âthey have exactly the same semantics.
I would be careful about describing / \( (?&gt; [^()]+ | (?R) )* \) /x (my adaptation of the regex in the âYo dawgâ picture, with Perl-5.10-style `(?R)` recursion) as matching exactly the fully parenthesised expressions. I think Perlers especially are liable to think of, say, `(1 + 2) + 3` as fully parenthesised. I would change âexpressionsâ to âs-expressionsâ, or the regex to an âinside-outâ version like /(?&gt; [^()]+ | \((?R)\) )*/x EDIT: Switched to [possessive groups](http://perldoc.perl.org/perlre.html#(%3f%3epattern\)).
It seems like a little backwards-thinking to argue against language improvements because you'll lose syntax highlighting. Of course you can do pretty creepy things with D::D (I, for instance, don't feel comfortable with the bareword URLs). But class keywords and method signatures? I can't wait to have them in core, and I don't care if they break PPI or some crappy syntax highlighter.
YepâI think it's amazing what's been done with `PPI` as a tool, but I think arguing that there's something wrong with somebody *else*'s tool because it doesn't play nice with his heuristic is a bit much. I think that something like "SURGEON GENERAL's WARNING: If you're used to `PPI` goodness, then be warned that other syntactic goodness can break it" might have been more appropriate.
yes, the same semantics, i know! that's why I chose to use the sub x() instead of directly using the list assignment to make it clear :)
What do you get when you cross an elephant and a fish? Swimming trunks! Okay, it's not about pearls, but it's as aquatic as I could get.
&gt;The Poor-Man's Grep (for Winodws): &gt; &gt;perl -nle "BEGIN{@ARGV=map{glob}@ARGV}/PATTERN/&amp;&amp;print &lt;filespec&gt; ... &gt; &gt;Replace PATTERN with the regular expression pattern to search for. Um, isn't [findstr](http://technet.microsoft.com/en-us/library/bb490907.aspx) the poor man's grep for Windows?
Good to see that it's still not ready for actual development use: &gt; The Perl 6 language specification is still in flux. Please take note of the following changes, which might affect your existing programs. In the next release of Rakudo, the deprecated features will likely be gone. &gt; &gt; * The root of the object hierarchy has been changed from Object to Mu. The type Object goes away. &gt; * The term undef is gone. You can replace it with other constructs, depending on context: &gt; &gt; * Nil is undefined in item context, and the empty list in list context &gt; * Mu is the most general undefined value which does not flatten in list context &gt; * as a smart matching target, you can replace $obj ~~ undef by $obj ~~ *.notdef
I can think of several languages, widely deployed, which have deprecated features.
or [ack](http://betterthangrep.com)
I'd rather not write a significant program in a language where, two months from now, a feature as basic as "undef" or the name of the root object type will be deprecated and removed. Even in a relatively active language like Haskell, basic features don't come and go that quickly. I suppose I could keep an old version of Rakudo around from when I started writing each of my programs, but... meh. I've got better things to do with my time, and better tools to do them.
+10 for HTML::FormHandler. I was using CGI::Formbuilder and tried HTML::FormFu but didn't like it at all. HFH is all that and a bag of chips.
Bug report: English in desperate need of a proofreader
Blarg. This is *not* a very nice golfing system. I have a 120-byte solution that passes on the input in the description and fails on the actual input, but the system doesn't give me any clue as to *how* it fails :)
I think it's still under development tbh
&gt; I could maintain a parallel installation myself, but I have better things to do. Does meditating on this statement give you any insight into why most people don't agree with your "fuck back-compat" stance?
Do you find that attacking strawmen arguments gains you enlightenment or respect?
Greetings, I have wanted to get wxWidgets working on ActivePerl for some time now. Nothing wrong with TK, a little on the primitive side. The install went well until; C:\stager\Wx-0.94&gt;nmake I get the error can't find; ExtUtils/XSpp/Cmd.pm which make sense since it doesn't exist. Should I post the entire command here. It's a bit on the long side. Perhaps I blew the command to install it. Which one is it. Thanks for the consideration. Namtog1
You are missing ExtUtils::XSpp. It is available through ppm. The Trouchelle repository definitely has it. I don't know about Activestate. Good luck!
Greetings, I got to this point LINK : fatal error LNK1104: cannot open file 'ut:C:\DOCUME~1\namtog\LOCALS~1\Tem p\compilet.dll' Checking if your kit is complete... Looks good Warning: prerequisite ExtUtils::XSpp 0.05 not found. We have 0.04. No version 0.5 from PPM. I added the Trouchelle repository; http://trouchelle.com/perl/ppmrepview.pl specifically; http://trouchelle.com/ppm10/ for builds 1000 and above (Perl 5.10 with PPM4) So I downloaded it and did a manual install. http://search.cpan.org/dist/ExtUtils-XSpp-0.05/ to C:\Perl\lib\ExtUtils\XSpp. nmake can find it. The process goes along until; mt -manifest ..\..\blib\arch\auto\Wx\RichText\RichText.dll.manifest -out putresource:..\..\blib\arch\auto\Wx\RichText\RichText.dll;2 Microsoft (R) Manifest Tool version 5.2.3790.2076 Copyright (c) Microsoft Corporation 2005. All rights reserved. ..\..\blib\arch\auto\Wx\RichText\RichText.dll.manifest : general error c1010070: Failed to load and parse the manifest. The system cannot find the file specified. NMAKE : fatal error U1077: '"C:\Program Files\Microsoft SDKs\Windows\v6.0A\bin\m t.EXE"' : return code '0x1f' Stop. NMAKE : fatal error U1077: '"C:\Program Files\Microsoft Visual Studio 9.0\VC\BIN \nmake.EXE"' : return code '0x2' Stop. NMAKE : fatal error U1077: '"C:\Program Files\Microsoft Visual Studio 9.0\VC\BIN \nmake.EXE"' : return code '0x2' Stop. C:\stager\Wx-0.94&gt; A Google search for general error c1010070I found this; http://social.msdn.microsoft.com/forums/en-US/vclanguage/thread/4516dd3f-a159-4cd4-9603-54fbeb05c80a seems to be close to my problem. Have no idea how to adapt it for Wx using ActivePerl Hoping I'm going forward, Namtog
(1) Why on earth would anyone think that posting on reddit has anything to do with enlightenment or respect? It's a place for nerds and Paultards to blow off steam. (2) "Fuck back-compat" is shorthand for "regularly-scheduled deprecation and removal," or whatever you call your hobby horse. But hey, this is reddit, so it's more about "winning" than learning. Bring it.
I hope you will find a solution to compiling WxWidgets and Wx::Perl with MSVC. Is the build failing on Alien::WxWidgets or on Wx::Perl? Does the manifest exist where the compiler is looking, or has that not been built? If this does not work out, an alternative is to [ppm install MinGW](http://www.openkomodo.com/blogs/troyt/ppm-install-mingw). This will make Gnu GCC the default compiler for ActivePerl. You will be able to load and build most Perl modules through CPAN, including Alien::WxWidgets and Wx. It also has the advantage that all libraries and executables build will link to the same MSVC runtime DLL as ActivePerl itself, which is build with the ancient VC6 compiler. Less chance of memory leaks and odd behaviour.
It's not at all clear whether or not there is an upper bound on n2 (other than the implied, very large, 65535). If not, then it certainly gives a massive bonus to languages with native arbitrary-precision integers.
Realizing that this is almost certainly the reason why my 109-byte solution is failing... I'm wrestling with the urge to actually implement binary division (well, binary calculation of integer remainder) as a regular expression.
Unless you already considered this: It might be that the reason your solution is failing is that you are converting to integers and trying modulo. Of course, if n is large then you'll get an error when you try to convert the (large!) binary string to an internal representation of an integer.
If it would pass the test suite that is...
If you look on CPAN I fit in the one red box in the test matrix :(
You mean, a live CD just to boot into a perl interpreter?
no. A liveCD to show of perl end user apps, interesting projects and so on.
Not a bad idea. I'm fairly sure there are Live Perl CD projects out there. If you mean boot linux (like a Linux Live CD), that's probably pretty easy. It might be more interesting to create something that could run under windows so a user doesn't have to reboot their computer. One way would be to include a virtual OS app (i.e.: VirtualBox) on the CD. Hmmm... I wonder if it would be possible to create a CD that could do both - boot itself live, or if autorun in windows, could load a virtual OS app then boot itself instead.
A full dev env for perl5 and perl6 + as many cpan modules as you can fit on a livecd would be nice
How much is all of CPAN? Also any choices on particular bundles?
Have you looked at [XAMPP](http://www.apachefriends.org/en/xampp.html)? Includes perl and web server, should be able to run from CD, DVD, thumb drive, etc.
Nice. Thank you for making this available. It is passing every test now except for t42-global.t on win32 Strawberry Perl. t/42-global.t .......... 1/273 # Failed test 'should be 3 subs' # at t/42-global.t line 38. # got: '4' # expected: '3' I think I will force install it anyway. 
On an unrelated note, that's exactly the package I've been looking for. 
Really? When I look at the journal entry, it read that the rationale for changes was 99% because of feedback from actual usage. Maybe he changed the text after you posted.
Perl 6 design rationale: "652 spec changes *that* I can't be arsed to summarize." ftfy
Upvoting for pretty pictures.
Maybe, but probably not. My "feedback from actual usage" is a question: "when will the spec stop changing long enough for someone to implement it, and for me to write my program using that implementation, and for people who may have downloaded a later 'stable monthly release' to use my program?" So far, the answer seems to be either "never" or "shut up."
I upvoted because it's cool.
&gt; my latest project is all Python and I spend at least 90% of my day-job hours on it oh sam.
&gt; "It is sometimes possible to buy the precinct map for a given state, but not always and certainly not in a single standardized format." What sort of third-world country is this?!
&gt; "when will the spec stop changing long enough for someone to implement it" From Carl's post: &gt; But most spec changes nowadays are responses to questions, complaints, comments and points of particular confusion from *implementors*.... Emphasis mine.
So one implementor is confused about the spec, posts about it on the mailing list, and the spec changes. As a potential user, how does this reassure me?
5 minutes trying to find the source yields this [broken link](http://svn.pugscode.org/pugs/misc/elf/). *Plus ca change...*
The best -- the kind with guns, nukes, and trans fats!
Haha! Give it a try sometime, you might like it. One big upside - with nothing close to CPAN you've got all kinds of open territory to populate. And really, we all know it's a blast to reinvent the wheel.
It looks like part of the Pugs subversion repository. You could download this with svn checkout http://svn.pugscode.org/pugs/misc/elf/ There are attempts to implement Perl6 with various backends, including Perl5 and SBCL. I am not sure yet if it is worth it. The project may be stalled or dead.
You seemed to believe that the specification changes in 2009 somehow meant that no one could implement Perl 6. In truth, most of the specification changes come from people implementing Perl 6.
Why bother with the arbitrarily assigned 'precincts', when it is really voters and convenient access you're interested in? Why not just figure contiguous areas of approximately equal population convenient for your canvassers?
Well, so far, no one has finished implementing Perl 6. Discussion with you is mostly a waste of time, or at least mostly about "winning" rather than exchanging information, but here's what I wonder: if I write a Perl 6 program that runs on a recent release of Rakudo, and distribute it, how long will it be before someone running the latest Rakudo (or whatever) won't be able to use it because changes in either (1) the spec or (2) Rakudo's implementation of it break my program? AFAICT the current answer is "2 months," which means that any significant program will be out-of-date by the time it is released.
&gt; Well, so far, no one has finished implementing Perl 6. Nor has anyone finished implementing Perl 5. &gt; Discussion with you is mostly a waste of time.... You'd find it easier if you'd stop changing your arguments and redefining your terms. &gt; AFAICT the current answer is "2 months," The correct answer is "It depends". If you were to ask Mortiz or Carl or Solomon about how much in the test suite (for example) or any of the existing real-world Perl 6 programs had to change due to specification changes, you'd get a much better answer... ... but that depends on which features you use in your program. After April, I suspect the correct answer will include a much longer time period. To my knowledge, no one who's actually written real-world Perl 6 code (or any non-trivial amount of an implementation) has asked for the specification to freeze.
&gt; Nor has anyone finished implementing Perl 5. I tire of your scholastic bullshit. Perl 5 is defined by its implementation (so it's always done!), and its implementors try hard not to break existing Perl code. &gt; You'd find it easier if you'd stop changing your arguments and redefining your terms. Examples? &gt; The correct answer is "It depends". Oh, great... &gt; After April, I suspect the correct answer will include a much longer time period. Color me skeptical, but we'll see. &gt; To my knowledge, no one who's actually written real-world Perl 6 code (or any non-trivial amount of an implementation) has asked for the specification to freeze. "Ask" and "want" are unrelated in this case.
&gt; "Ask" and "want" are unrelated in this case. People who do not contribute to a work are unlikely to effect significant changes to the work.
&gt; People who do not contribute to a work are unlikely to effect significant changes to the work. People who do not see significant potential in a work are unlikely to contribute to said work. Why dive into a clusterfuck?
I want to thank you falettin' me see misc/elf again.
Ah, because come election day you're going to want to turn those voters out to their voting places. And voting places are assigned by precinct! If your plan is just to talk to voters and not bother getting them to actually vote then yes, there's no reason to worry about precincts. You're better off organizing by city in that case, or possibly county depending on the area. As a side note, figuring out contiguous walkable (i.e. not separated by a river or a mega-highway) areas is a tough mapping problem in its own right. I'm still looking for a good way to tackle that one.
If you don't think it's worthwhile, why do you care at all? Can't you at least leave the people who *do* care to work in peace? If the answer is no, you're a troll.
Sorry. Let sleeping pugs lie.
Some folks have resurrected [my old CGI course](http://jdporter.perlmonk.org/cgi_course/) (which got pretty good reviews in its time), but honestly, CGI.pm is archaic. Today you want to look at things like: * [Dancer](http://search.cpan.org/dist/Dancer/) * [Mojo](http://search.cpan.org/~kraih/Mojo-0.999914/) * [Catalyst](http://search.cpan.org/dist/Catalyst-Runtime/) * [Maypole](http://search.cpan.org/dist/Maypole/) (not sure if this one is still active)
As a somewhat beginner, which would be the best to take a look at for ease of use and functionality?
Look into [CGI::Application](http://search.cpan.org/perldoc?CGI::Application) . Plenty of tutorials and a comparison to the other frameworks at [CGI-App.org](http://cgi-app.org/) .
*Note that all links in this post are different from the links above.* That's a tough one. Catalyst is by far the most mature, but it has a steep learning curve for beginners. I expect that Mojo is the easiest to install (it has no dependencies), but it's not yet well documented. I expect that Dancer ([official Web site](http://dancer.sukria.net/)) might be the easiest to get started with as it hits the sweet spot between ease of install/use and documentation. However, I've not worked through it's documentation yet, so it's tough to say. Unfortunately, Dancer has a habit of failing its tests, making it difficult for a new programmer to install. Catalyst, on the other hand, while daunting to learn, [has a decent Web site](http://www.catalystframework.org/), two books for it, an active mailing list [and lots of online documentation](http://search.cpan.org/dist/Catalyst-Manual/). It's the biggest Perl framework of its kind, but it's worth the effort. [Mojolicious looks very interesting to me](http://mojolicious.org/). It's getting better documentation and it does a great job of adhering to Web standards. Because it has no dependencies, it's easy to install. It's *getting* more documentation, but this has long been its Achilles heel. In the end, you'll have to read through and decide for yourself :)
Of Ovid's list, Catalyst. Maypole is dead, Dancer and Mojo are still a bit rough for noobs. Also avoid Gantry and whatever Jesse Vincent has whipped up in the past 48 hours (*uh, that's a joke, son. s'posed to laugh. haw-haw and all that*). [CGI::Application](http://cgi-app.org/) and it's [Titanium](http://search.cpan.org/perldoc?Titanium) bundle variant are somewhat direct upgrades from CGI.pm. For CGI.pm itself, [Lincoln Stein's docs](http://stein.cshl.org/WWW/CGI/) remain the best resource along with "perldoc CGI" I own several books that talk about CGI.pm (including Lincoln's) and there is really nothing novel about any of them that a quick study of HTTP RFC's and how HTML is *really* handled can't displace.
Adding to Ovid's list I would also consider: * [Squatting](http://search.cpan.org/dist/Squatting/) : Bit more mature than Dancer. * [Web::Simple](http://search.cpan.org/dist/Web-Simple/) : Bit less mature than Dancer! * [Continuity](http://search.cpan.org/dist/Continuity/) : And now for something completely different!
Even for a beginner, I second the advice on Catalyst.
I am very familiar with Catalyst. I recommend it. The best tutorial is on CPAN. http://search.cpan.org/~hkclark/Catalyst-Manual-5.8003/ Check it out. As was mentioned earlier, there is a lot to learn.
Don't read the book from Packt publishing. It is out of date and was rushed to market without proper editing. Many of the example code doesn't work and they use deprecated modules. The newer book from Apress is much more complete.
I just had to make the same choice myself (as a beginner). I chose CGI::Application because it did all the grunt work involved with developing web apps for me (plus its many excellent plugins). It was also a great learning experience because it's more low-level than a custom framework and I got to experiment with a lot of concepts. For my next project I feel confident I'll be able to make an educated decision - and it may still be CGI::Application, we'll see.
I'm going to take a look at Catalyst and CGI::Application and see which one works out best. Thanks for the advice! :D
CGI.pm might be archaic, but there was a time or two when it was the only thing I could get by with, hence good coding practiced wrt to it are still relevant. Catalyst, to be honest, seems to be an overhype. Not that I am a pro in either, but I find RoR to be a lot more intuitive, much easier to follow and understand. But that may well be just meâ¦
&gt; If you don't think it's worthwhile, why do you care at all? Because the never-ending Perl 6 clusterfuck harms Perl 5, which I find useful. &gt; Can't you at least leave the people who do care to work in peace? They're free and welcome to keep doing whatever they're doing. And I'm free to encourage people engaged in useful activities not to begin wasting time on Perl 6.
I'm going to add two parts to the series: * 7th on Handy Regular Expressions and * 9th on e-book that captures all these one-liners in a single pdf.
Thanks for clearing that up. You could've made that shorter by just saying "I'm a troll" though.
Hey! Your password generator is very similar to the one I use. print map { pack('c', rand(126-36)+36)} (0..8); Cool. Also I picked up some new perl one liners. Thanks!
Awesome! :)
A really fun matrix effect I do some times it this. perl -e "map { print pack('c', rand(126-36)+36)} (0..9999999);"
Tee, hee... So I could either try to explain my post or, on your Urth, just shout "YES" or "NO," like in those "even Stephen" segments on the Daily Show. Well, you're the autarch...
Does the site not load for anyone else?
http://www.shadowcat.co.uk/blog/matt-s-trout/on-being-a-bastard/
That works, thanks. :)
that's what being a bastard is about
I think we need an A/B test. I propose we revoke all of MiSanThrope's op privileges and see if things get better. I used to like the Perl community. But now it seems like only masochists are allowed in. 
Well written and applicable to many many situations, from social media groups, to reddit, to... hell World of Warcraft guilds if you extend this far enough. Really good read.
Agree entirely, although I'm more often the receiver of help than the giver! If I'm ever looking for help (most often in a Perl IRC channel) I very much appreciate every suggestion and do my best not to come off as ungrateful. I'm more afraid of appearing as stupid when offering what help I can!
Agreed that RoR is more intuitive, but then, RoR is designed to work pretty much out of the box. Catalyst gives you tremendous flexibility, but it deliberately has you assemble the parts yourself. It's better than it was, but there's still some room for improvement.
Fuck you! That's what!
Funny, I think he got it confused with PHP.
&gt; Perl 6 is a wanklage. Perl 5 is not, and neither is Lisp. This. It's always most polite to pretend you didn't see the wanking...
Is it *really* necessary to install the gnuwin32 tools in order to create a symbolic link on windows? Given that it seems to be something built-in to the filesystem (unless his Perl binary and gnuwin32 shares some non-standard definition), I find it hard to believe there's no way to do it with the native OS.
It actually is build in: http://en.wikipedia.org/wiki/NTFS_junction_point I really wish blogs.perl.org woudl get their shit together and actually make registering and/or logging in via OpenID possible again.
You can ask Padre IDE developers on irc://irc.perl.org#Padre what would they choose now over ithreads. http://perlmonks.com is also a good place. As for fork, fork does not launch new process, it clones existing process and does not even copy data until it is necessary. POE would be too slow for you, but there are plenty of faster alternatives on CPAN.
First the nitpick, you don't use apostrophe for plural. Secondly, the actual complaint. On Windows (tested on Windows 7 x64, but no reason why it wouldn't work on other versions), the shebang is simply ignored and the OS just goes by file extension association. #!/usr/bin/perl print "Hello world\n"; runs just fine on Windows.
Entirely unsure about whether this solution will be suitable for you, but this is what i wrote when i needed concurrent downloading on windows: use threads ( stack_size =&gt; 0 );; use Thread::Queue; sub fetch_xml_data { my ($c,$dir,$urls) = @_; my $thread_count = 15; my $Q = new Thread::Queue; $Q-&gt;enqueue( $_ ) for (@{ $urls }); # this is what the threads actually do my $thread_func = sub { require LWP::Simple; while( my $url = $Q-&gt;dequeue ) { my $download = $url-&gt;{url}; my $target_file = $dir.$url-&gt;{file}; say "Downloading XML file from $download.&lt;br&gt;"; LWP::Simple::getstore( $download, $target_file ); } }; # prepare the threads and get them running my @threads; for ( 1 .. $thread_count ) { push @threads, threads-&gt;create( $thread_func ); $Q-&gt;enqueue( undef ); } # wait for all the threads to complete for my $i ( 0..$#threads ) { say ( (@threads - $i)." threads still running.&lt;br&gt;" ); $threads[$i]-&gt;join; } # check the target dir for which files we got and return their names my %results; opendir ( my $DH,$dir); my @files = readdir $DH; for my $file ( @files ) { next if $file =~ m/\D/; $results{$file} = 1; } return %results; }
yep, I was also surprised reading that. only when you run CGI scripts it may matter. i think it depends on web server being used.
It's better to ask code questions like this on either perlmonks.com or stackoverflow.com
You can rely on fork() being an extremely lightweight operation on most systems. At that point the interpreter is already loaded and running, and [only about 4k memory is used](http://tinyurl.com/yj8daud) simply from the fork() alone. That said, since you're apparently familiar with ithreads, have you looked into [forks.pm](http://search.cpan.org/~rybskej/forks/lib/forks.pm) as a workalike?
Hmm, interesting, I didn't know fork() was that lightweight. Also, combining my plans to move all dynamic data to a database back-end (DBI handles [seem](http://www.perlmonks.org/?node_id=594175) to function well when cloned in the fork) with the fact that Linux's fork is implemented using copy-on-write paging, this presents a very viable alternative! For now, forks.pm is the ideal workaround. Thanks for the information! EDIT: of course, UBB code wouldn't work here, now would it
Well, those threads are the default interpreter threads (ithreads) which not only are very memory inefficient on Perl 5.8, but only limited in functionality and quite frequently just left out. Thanks for the suggestion though!
Be sure to note that they set InactiveDestroy on the DBH. Depending on how you're forking and what those children do, you might need to set it too. If you have a connected DBH in the parent, then fork a child that does nothing with the DB at all, it will disconnect the parent's DBH when the child process ends. This is because all memory and filehandles are cloned, so at that point the child still has the DBH in scope and the shared filehandle connected to a DB, and that child can still send a quit/disconnect/bye command to the DB and have its parent disconnected.
Junctions only work for directories. Vista and later supports symbolic links.
I don't understand why people still keep using the shebang line at all. It's not necessary to involve the shell. Just leave it off entirely and invoke the script as: &lt;your perl of choice&gt; &lt;path to script&gt; Easy!
I shouldn't say with too much certainty, but I believe that Apache for instance has a settings to direct it to execute scripts based on their extension rather than on any shebang.
While fork on linux is pretty lightweight, you can still get into trouble if you begin launching a lot of threads. And just to be different: Do you really need threads for concurrent downloads? In most cases with network programming you can handle the processing of data much faster than it is sent, so a single thread should be able to handle multiple downloads with minimal (if any) performance problems. I once wrote a quick little client-server app onces to simulate a certain type of network traffic and decided to fork() a lot. This ended up creating hundreds of threads for simulating certain workloads. This caused havok even on a core2duo with 4 gigs of ram (memory wasn't the problem, but essentially I was fork bombing myself, boom!) The end result was I re-wrote it using IO::Select, which is pretty awesome and keeps resource usage low. You could add all your file handles to IO::Select, and then also use the fh as a key in a hash for storing per download information (check out IO::Select docs for how it does fh stuff). All this could also run in a separate thread from the main thread, with some kind of communication between them for updating status. This way you have a couple long running threads and avoid spawning many short lived ones. Again this is a completely different way of looking at the problem that may not actually work, but I would recommend checking out the IO::Select documentation.
I'm guilty for doing that too :(
It's nice to be able to have the implementation language for a program/script transparent to the user. The shebang enables this.
Have you looked at http://learn.perl.org/ ? It has link to free "Beginning Perl". "Beginning Perl" is also somehow outdated, but due to tight integration with Unix OSes, perl 5.10 only started to be popular enough.
Interesting method to tackle the problem, but I don't think it applies to my situation. Every process/thread not only downloads a file, but needs to go through a whole lot of preliminary actions as well (as in clicking through some forms, waiting a bit, filling in some captcha, ...). I can't think of a way to intelligently timeshare such types of downloads in a single thread, apart from the final filehandle-based download. Either way, the number of threads should remain limited (10, max) and I plan to minimize memory usage by using most data in a read-only fashion (leveraging write instructions through a shared database handle). Thanks for mentioning it though, I hadn't heard of IO::Select.
It might, yet I have been provided with interesting answers here as well! And off-course I refuse to register at sites where they store passwords plain-text.
The past few times I've used Perl in Windows it has just done the right thing with the .pl extension. 
* Eric Wilhelm [has written some nice stuff](http://learnperl.scratchcomputing.com/) for starting perl that may or may not be incorporated into learn.perl.org. It's nice. * Shlomi Fish [also has some nice stuff](http://perl-begin.org/). * [perldoc.perl.org](http://perldoc.perl.org/) remains handy for language reference and a number of faqs. * I can't recommend enough getting the book Learning Perl (5th Ed is the latest) (big but well worth it).
Check out [Strawberry Perl](http://strawberryperl.com/) if you're running on Windows Also (once you get up to speed), use the [CPAN](http://search.cpan.org) For OO in Perl, check out [Moose](http://search.cpan.org/~drolsky/Moose-0.94/lib/Moose.pm) Also, always use strict; use warnings;
There are levels of down to which one should not sink. This is one of them: &gt; Also, always &gt; &gt; use strict; &gt; use warnings; First, understand what you write.
Congratulations to the whole Parrot team on reaching this milestone!
Coro might be an interesting solution for this problem. Have to be careful with it however as it uses a lot of magic. It lets you write code that appears to block at several points in the code but still all runs in one physical process. If you can structure the problem to be 100% event based and not otherwise blocking or computationally intensive then try any of the fine event based distributions on CPAN such as AnyEvent. 
heart warming
Do we have an Obfuscated Perl Contest winner?
more likely pushes the limits of what is a sensible email address. 
brain goes spinny-spinny round and round.
In his Perl library he actually builds it up in parts. 
I'd like to throw random strings at this to see what incredibly curious valid eMail addresses could be produced.
Silly [RFCs](http://www.faqs.org/rfcs/rfc822.html).
Pretty sure you can just look up what the valid e-mail addresses are. It's so complicated because of the sheer variety of things you can throw into an e-mail address. [RFC 822](http://www.faqs.org/rfcs/rfc822.html)
Similar: [MKDoc::XML::Tokenizer](http://search.cpan.org/perldoc/MKDoc::XML::Tokenizer). Part of an XML parser that actually works and everything.
For Postgres, I've been using this: CREATE DOMAIN cdt.email TEXT CONSTRAINT email1 CHECK(VALUE ~ '^[0-9a-zA-Z!#$%&amp;''*+-/=?^_`{|}~.]{1,64}@([0-9a-z-]+\\.)*[0-9a-z-]+$' AND VALUE !~ '(^\\.|\\.\\.|\\.@|@.{256,})'); It's two regexes, true... but it was simpler that way. Everything but comments in a username portion should be valid, I've tested it. Someone's overthinking this.
That's not Perl, that's a regex
Now tha we have i18n domain names, I wonder if it still works?
Generated code is frequently hard to read.
I think that'd be a simple change, if it's not in there already (and I'm not going to try to read that! :). It's just a different character set for some of the very same syntactic elements; that's not where the complexity of RFC822 addresses comes from (I was on the IETF working group that converted 821 &amp; 822 to RFCs 2821 &amp; 2822).
How sure are you that you're *really* validating for the full syntax of RFC822 (2822 and successors) addresses?
Not fully validating. But it will allow any real address you throw at it, and seems to choke on anything that should be invalid.
In addition to (or after you get comfortable with) something like Strawberry Perl, I would consider installing [Cygwin](http://cygwin.com/) with the relevant Perl packages. (During install in the packages list, there is a searchbox just do a search for "perl", you can always add or remove packages later too). You don't need Cygwin or anything, I just always felt that Perl really shines in a Unix like environment....plus you now have Cygwin.
Then you're not doing what that package does. He specifically said it's written to validate for full RFC822 syntax. You've decided you don't care to validate for the full standard, you'll go for a much simpler subset that you think is good enough. Fair enough, if that works for you, but it's not what that package does, and "overthinking" does not apply here.
http://oreilly.com/perl/ Most stuff online is at the Perl 5 level which is not outdated for someone just learning the language.
&gt; You've decided you don't care to validate for the full standard Yes, I only care to validate real email addresses. Please show me even a single instance, anywhere, where an email uses even one of those fucked up features. This is what I do, I write code for the real world.
I've seen plenty, but that's beside the point. The point is that you're doing something other than what this module claims to do, and apparently does. You mischaracterized it as "someone's overthinking this" but what you really meant was "that feature is not one I feel is worth implementing".
circa 2002
If there's something you can't figure out from books and websites, you can find helpful and capable people hanging out in [comp.lang.perl.misc](http://groups.google.com/group/comp.lang.perl.misc/topics). The Google interface sucks though, you may want to check if your provider offers direct nntp access. 
I look forward to buying your book. Really liked *Perl Testing*. Enjoyed this blog, too.
You were at -2, but have a +1. Agree that there's a time and place for `strict` and `warnings`, but you should understand *why* before using them.
WRT "[Protocol Buffers for Perl](http://groups.google.com/group/protobuf-perl)" there's also [Protocol Buffers for Perl/XS](http://code.google.com/p/protobuf-perlxs/) which I have used and is *really* fast. Not sure how well it aligns with the hardened environment requirements however.
This blog post is from July 2008, unfortunately development on perl-appengine stopped a few months later.
Thanks. I currently despise the Perl community slightly less for its emphasis on ritual chants than I admire it for its emphasis on getting the job done. Look, folks: if you want to code and get laid, use Ruby; if you want to code and get tenure, use Haskell; if you want to code and get shit done, use Perl.
I picked up Perl a year ago, and the way I learned it was first with Learning Perl, then with the Camel book and Perldoc. The Camel book sometimes goes way too deep for what I need, but lots of concepts have stuck as I've read it. And it's very well organized; I can flip to a topic I have a question about, read a few paragraphs, and get back to coding.
:(
Threading in Perl 5 and other scripting languages sucks because they are faked - meaning that each thread is its own full blown interpreter. It makes it works when one wishes to share variables, and in particular Perl resorts to using sockets and TCP. The forks::BerkeleyDB module attempts to alleviate this, and it is indeed somewhat faster. Recently, I have discovered a truly threaded scripting language called Qore - http://www.qore.org. It's syntax is Perlish, though the similarities end on the surface. 
It's still app engine...
Check out the Qore Language.
To my knowledge Perl 5 threads do not support SMP. Unless an authoritative source tells me differently, I believe the OP is mistaken. That, or Perl somehow fakes it with fork.
&gt; Perl 5 threads do not support SMP. Perl 5 threads do indeed support SMP. &gt; Perl somehow fakes it with fork. You have that backwards; Perl 5 fakes fork() on Windows.