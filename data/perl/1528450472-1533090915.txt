I generally just use \`perl \-d\`, but I remember [Devel::ebug](https://metacpan.org/pod/Devel::ebug) being rather nice to use.
This is the real answer.
[http://search.cpan.org/\~aepage/Devel\-ptkdb/ptkdb.pm](http://search.cpan.org/~aepage/Devel-ptkdb/ptkdb.pm)
In the world of Docker a change in the cpanfile or [Makefile.PL](https://Makefile.PL) can trigger a build and will download packages to install them. Downloads aren't ratings.
There are others that are mentioned below, but none are official and none seem to be under active development and support. From time to time, out of curiosity i look around to see what is going on all of the debuggers that I can find in CPAN. To me, all fall short of perl -d. Yrs, it is bare bones from an eye candy and clickability perspective, but the base functionality is there. I find the combination of the built in debugger and log4perl work very well for me when trying to debug code.
To follow up on my quick response from last night: IntelliJ (community edition) has decent Perl support one you get some plugins on board. It also has a debugger integration for running code locally under the debugger or attaching to a remote process. I've tried to get this set up for work so I can step through an Apache/mod_perl request. I did manage to get it to connect and step through part of the request, but my mod_perl wasn't built with debugging hooks so it gets to a point and then doesn't stop until it hits a DBI method. Such promise but such miss. 
Speaking of Emacs `perl -d`, there's [realgud](https://melpa.org/#/realgud) that seems an even nicer interface to it than cperl-mode's. Outside of Emacs, there's also [DDD](https://www.gnu.org/software/ddd/) that provides a graphical UI to `perl -d`.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.gnu.org/software/ddd/) - Previous text "DDD" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e0d7ij4) 
You might be interested in Ovid's [using the debugger with Moose](http://blogs.perl.org/users/ovid/2013/10/how-to-use-the-debugger-with-moose.html) as he shows how to extend the debugger via `~/.perldb` for added functionality.
It gets the first element of `@_`, that is, the first argument to this function (I'm guessing some sort of a request object).
Looks like Mojolicious. As anossov mentioned, shift with no arguments removes and returns the first element from @_, the argument array. In Mojolicious, that is the Controller object, whose [param method returns the get/post parameters](https://mojolicious.org/perldoc/Mojolicious/Guides/Tutorial#GET-POST-parameters).
https://metacpan.org/pod/perlfunc#shift You should not use $a and $b as variables outside a sort block. Just declaring `my $a` can screw up sort blocks in that scope. Any other single letter is fine (like $c used for the controller object in Mojolicious and Catalyst).
More than your point, one should never use a single character variable. Period. Always, always, always at least use double characters. In this example, $aa or $bb. "Why?", you ask. Two easy to understand reasons explain my point. 1. Try looking for a single character variable name in code. "$a" for example. I don't care how good your editor is, someday you will have a hard time finding it amidst all the other variables that start "$a. Develop good habits now to save you, or someone else, time and frustration later. 2. Code as though the person who will maintain your code is a homicidal maniac and knows where you live. Give them as few reasons to want to kill you as possible. I don't care how good you are, how careful you are, or where you think your source will wind up, sooner or later someone, somewhere is going to hate you for making your code hard to read. It might, six months later, even be you yourself.
Shift is using an assumed variable. There's many situations where, if you use a function without a variable, perl will assume one. Read here under the section /General Variables/ for more information abut when and why [https://perldoc.perl.org/perlvar.html](https://perldoc.perl.org/perlvar.html) 
Many Perl built\-in functions work on default inputs if they aren't given a specific input. In many cases, that default input is `$_`. Th`eshi`ft function is unusual in a couple of ways. Firstly, it doesn't work o`n`$\_ by default and, secondly, what it does work on depends on where it is called. * If `shift` is called with an argument outside of a subroutine, it works on `@ARGV` (the command line arguments passed to your program). * If `shift` is called with an argument inside of a subroutine, it works on `@_` (the arguments passed to the subroutine). See [`perldoc \-f shift`](https://perldoc.perl.org/functions/shift.html) for more details.
Your second reason is about the same as your first, and your first reason is only a problem is you're not using a decent programming editor. If *that's* the case then you have far bigger problems than comparing between `$a` and `$aa`. E.g. in vim you can find all instances of `$a` by typing `/\&lt;$a\&gt;` for your search (the `\&lt;` and `\&gt;` delimit "word boundaries", and are equivalent to `\b` in grep-like tools).
Your code blocking seems to be a bit off...
&gt; If `shift` is called *without* an argument... If you give `shift` an argument, that is what it will try to operate on. 
`\&lt;` and `\&gt;` are equivalent to `\&lt;` and `\&gt;` in grep...
$aa is just as hard to read as $a for the same reason: it's not descriptive. I don't see a good reason to go for the middle ground of 2 letter names when all it gains is compatibility with Windows Notepad users.
I will use $a and $b.
More than your point - I'll keep using a single character variable.
Enjoy your broken code?
Yeah. Not sure what happened there. Fixed now though. Thanks.
It was late. I was tired. That's no excuse :/
And as long as you are working on your own code that no-one else can see then ,of course, no-one will stop you. But when you want to share your code with other people, or you want to work on other people's code, then code like this will become a problem. Not only are short variable names a disaster for readability, but `$a` and `$b` have specific meanings in Perl code - and that's not how you are using them. Using better variable names is a value tool for making your code as easy to follow as possible. I'd urge you to get into that habit as soon as possible.
um, there is no sort block in that scope.
No. I enjoy your broken code.
I'll create a public repo with $a and $b
You do that. That'll really show us.
I am baffled by the author's charts. Tiny, unlabeled axes, huge wide bars. Combinations of squiggly lines and colored bars. Just to take one example, consider the first bar chart. The author says: &gt; I have closed more than 80 issues during April: After zooming in all the way to read the [tiny y-axis labels](https://jj.github.io/TPF-Grant/illos/closed-issues-may.png), I note that the `JJ` bar is at about 160. So, does the preceding statement have anything to do with the chart? And, in [this chart](https://jj.github.io/TPF-Grant/illos/issues-open-closed-diff.png) using a different color for each bar with red for the supposedly good thing is extremely harmful to the message you are trying to convey. Red is the color of alarm. Instead, the author should just use a single color, use `closed - opened` as the y-axis label so that the numbers are negative until you arrive, and turn positive after you do. Effective use of color can be useful in charts, but, when in doubt, stick with black &amp; white. I haven't really looked at the content of the work, but I have seen some of the questions the author posted on Stackoverflow as part of the effort to carry Perl 6 content from the IRC channel to the Stackoverflow. In most cases, the resultant posts do not have descriptive titles which could help others who might have similar problems in the future. They might make sense if only ever intended to be read by the participants of the related discussion on IRC, but I think that's just a waste of time to move the discussion to Stackoverflow in that case. I haven't reviewed the content of the author's grant work, but the presentation leaves much to be desired.
How can you be sure since incomplete code was posted? Can you say for sure there never will be one? Or a pair function from List::Util? Can you promise nobody will copy-paste the code to somewhere else that has a sort block? Can you promise nobody will try to use $a outside the block it's declared in assuming that strict will catch the typo, but it won't because it's a superglobal? It's easier just to not use them.
Can I be sure? Yes. There is none in this lexical block.
This is not an answer to any of my questions.
It is a requirement but as I understand it's not required to be a part of the up, just that you could contact them and have it done. I also believe that there's a requirement that they have up to 30 days to comply, which means it doesn't have to be instant either.
A miserable pile of secrets (which may be true or false)!
Clearly, only the values (the letter 't', the letter 'r', the letter 'u', and the letter 'e') and (the letter 'f', the letter 'a', the letter 'l', the letter 's', and the letter 'e') ((well actually, the Unicode codepoints for same)) are Boolean values, because a simple 0 or 1 would be 4.5 times smaller and not be English-centric, thank you JSON.
Included now. Thanks for the suggestion!
This depends on how your script is being executed by the web server. Assuming you're using [CGI](https://metacpan.org/pod/release/LDS/CGI.pm-3.43/CGI.pm), it's something like this: use CGI; my $q = CGI-&gt;new; my $company = $q-&gt;param('company')
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://metacpan.org/pod/release/LDS/CGI.pm-3.43/CGI.pm) - Previous text "CGI" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e0h7wjz) 
Don't use CGI, use PSGI or a framework. Minimum version: use warnings; use strict; use Plack::Request; use Plack::Response; my $app = sub { my ($env) = @\_; my $req = Plack::Request\-\&gt;new($env); my $res = Plack::Response\-\&gt;new(200); $res\-\&gt;content($req\-\&gt;body\_parameters\-\&gt;get('company')); $res\-\&gt;content\_type('text/plain'); return $res\-\&gt;finalize; };
What’s wrong with CGI?
Are you really embedding untrusted user-supplied strings directly into a SQL query?
An interesting concept. Though I wonder if any performance gain will make it worth the extra work of populating the database every time it runs. I suppose that depends what you're doing...
It's a monster of a module which seems to be designed on the Swiss Army Knife principle of doing absolutely everything anyone *might just* need to do, however little they actually need. For just reading POST values, 122K is a lot of redundant code to compile every time the script is run. Especially as it's not much more complex than taking \&lt;STDIN\&gt;, splitting it on ampersands then splitting each element into name/value pairs on equals signs.
I've done something similar on a Raspberry Pi by holding a simple DB file on a RAM disk. It's not only fast, but also avoids writing to the SD card and shortening its life.
Please read http://bobby-tables.com/ Also, this is a crosspost: https://stackoverflow.com/questions/50794517/perl-web-development
I work with SQLite all the time at work with the DB being on a RAM disk. For RHEL (Red Hat Enterprise Linux) I can create the DB in /dev/shm which by default is half the size of your total RAM. This has the advantage of being persistent across run times if the host hasn't been rebooted and you can copy the file to disk for more permanent data storage (after a reboot it could be restored for the disk this way). All OS's support RAM disks and you can usually tweat it to use as much memory as you want. Usually not a good idea to let it consume 100% as this will usually end up crashing the OS. 
Any modern framework allows a vast array of deployment strategies (including CGI if you choose) without any code changes, and usually CGI is the least performant option. CGI.pm ties you to deploying with CGI. See also: https://metacpan.org/pod/CGI::Alternatives and https://shadow.cat/blog/matt-s-trout/mstpan-1/ and https://shadow.cat/blog/matt-s-trout/mstpan-2/
With [Mojolicious](https://mojolicious.org): use Mojolicious::Lite; use Mojo::mysql; my $mysql; helper mysql =&gt; sub { Mojo::mysql-&gt;new("mysql://$user:$pass@$host/$db") }; get '/' =&gt; sub { my $c = shift; my $company = $c-&gt;param('company'); my $job = $c-&gt;param('job'); my $salary = $c-&gt;param('salary'); my $eligibility = $c-&gt;param('eligibility'); my $updated_rows = $c-&gt;mysql-&gt;db-&gt;update('company', {post_job =&gt; $job, salary =&gt; $salary, eligibility_criteria =&gt; $eligibility}, {name =&gt; $company})-&gt;rows; $c-&gt;render(text =&gt; "Updated $updated_rows rows"); }; app-&gt;start;
Has anyone in the last three years had a problem at all clicking links on their phone? Even with fat fingers modern capacitive touch encoders do a good job in software of working out what you're clicking on. Plus why are we going out of our way for accessibility of the morbidly obese, over any other demographic? This sort of stuff is actually destructive for blind users wishing to screen read! Look at the down votes, Im not the only one thinking this.
There is a link to delete unhelpful posts.
PHP, since it was envisioned as and historically used as purely a language for handling web requests, internalized the HTTP param handling portion that most languages use a library/module for as core language constructs. That's why there are variables that already exist on every execution that contain the parsed parameters. The way those variables are *actually* gotten by PHP if it's a CGI script (and similarly if it's included as a HTTP module, it's not quite true but it works well enough) is through environment variables which are set by the web server. If your server environment is running linux or some UNIX-alike (FreeBSD, MacOS, etc), you can actually see this very simply by creating a very minimal CGI using bash: cat &gt; mybashvars &lt;&lt;EOBASHVARS echo "Content-type: text/plain" echo "" env EOBASHVARS chmod +x mybashvars # Set it executable You can run it from the shell (./mybashvars) to see the current environment variables, or you can throw it into a cgi folder and access it as a CGI through a browser and the web server to see the environment variables the web server sets. Now, you *could* parse those environment variables manually in Perl, they are accessible through the %ENV hash, which similarly to PHP, Perl sets on start so you can access environment variables easily (PHP as a global environment variables as well, it's just not often needed). I don't recommend that though, since there are *many* modules that will do it for you. The CGI module is one of them, but like others here have noted, it's fairly cumbersome and does much more than you are looking for, complicating it's use and finding features in the documentation. It's a very old module that has acquired a lot of features over time. That said, if your needs are fairly simple, it might be the easiest and most familiar way to existing Perlers to do this simply through actual CGI, so you can find help if needed (as long as you're willing to deal with people telling you to do it a different way. They're *technically* right, but that doesn't always help if your constraints are tight, and knowledge and ability in a target language are constraints). If you want to use CGI, see the top level comment by /u/amdpox. The thing you'll need in addition to that though is to either put `print $q-&gt;header();` on a line or `print "Content-type: text/html\n\n";`, which should be equivalent. CGI allows you to output the headers of your request, and expects those first, and an empty line by itself afterwards, before you output the actual content to display. Lastly, if you have the ability to proxy the connection to another server on a different port,or you can replace the service with something of your own, you might find a Perl framework (instead of CGI) to be easier to deal with. For example, check out [Mojolicious](https://mojolicious.org). It may look like some of the examples include more code, but that's because they are actually including a lot more stuff explicitly (but concisely, it's not that much more code) which helps when you want to change something, and it's all under a good set of documentation and guides. It appears there's also a way to run Mojolicious behind/as a CGI, but I'm not too familiar with that. You can see more info on that in the [deployment guide](https://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook#Apache-CGI) and [CGI submodule of Mojolicious](https://mojolicious.org/perldoc/Mojo/Server/CGI), but depending on your skill level with Perl or other languages, that may be too much to tackle all at once. Finally, as some people have mentioned, you need to be very careful with using user provided data in the SQL queries. I believe modern PHP actually does some automatic variable escaping in the $_POST and $_GET global vars, so you have some automatic protection there, but Perl won't be providing you with that same initial protection just be accessing the variables. Instead, you'll either want to run them through something that escapes the more problematic ways people can abuse them, or preferably you use bound variables (which the mysqli database driver in PHP also supports, IIRC, so you should be able to find similar documentation there of the how and why, if that helps with understanding). Hope that helps!
Another potential problem aside from lack of persistence is if you have to reconnect for whatever reason, you'll also lose the database; for this reason I recommend and default to using a tempfile database instead for such purposes in [Mojo::SQLite](https://metacpan.org/pod/Mojo::SQLite#DESCRIPTION). Personally I only end up using this for testing.
 [[0,1,2,3,4,5],[1],[2],[3],[4],[5]] The easiest way to determine the structure is to use Data::Dumper perl -MData::Dumper -wE"@d = ( [0 .. 5], map { [$_] } 1 .. 5); say Dumper \@d"
Thank you very much!
Can you elaborate? That syntax is 100% valid and correct. Sample: https://perlbot.pl/p/m8ql3e
my $feeling1 = "Good"; my $feeling2 = "Bad"; my $feeling = &lt;STDIN&gt;; if ($feeling eq $feeling2) { print("Thats not so good to hear\n"); } elsif ($feeling eq $feeling1) { print("Thats good to hear\n"); } else { print("Whatever\n"); }
Does that help
Except touch is still quite terrible. NEXT!
You are getting a newline at the end of `$feeling`. To get rid of it you can `chomp` it off. Like so: my $feeling1 = "Good"; my $feeling2 = "Bad"; my $feeling = &lt;STDIN&gt;; chomp($feeling); or if you're feeling up for some new syntax chomp(my $feeling = &lt;STDIN&gt;);
I assume you mean something like this (Reddit screwed up the formatting). https://perlbot.pl/p/2frr5o If you're reading from STDIN you're probably reading in the trailing \n as well, which is breaking the comparison. You probably just need to [chomp()](https://perldoc.perl.org/functions/chomp.html) `$feeling`.
No not exactly if the user enters good the print for good needs to enter so on and so forth 
Might need a `chomp` to remove the newline character at then end of the input. (when you read a line from STDIN, it is submitted with a return, and that is also included). e.g. my $feeling=&lt;STDIN&gt;; chomp $feeling;
Is that all 
https://pastebin.com/Ptf0ze9x This is the full code Would you also have any free perl learning resources 
I recommend [Modern Perl](http://modernperlbooks.com/books/modern_perl_2016/index.html)
[Perl maven](https://perlmaven.com/perl-tutorial) has lots of mini tutorials...and [the perl monks](https://www.perlmonks.org/) seem to know everything. But the best way to learn is to just do it, and when you hit an obstacle then do a quick search for the answer.
Last time I checked the shebang isn’t necessary on Windows. The file extension will cause it to be invoked by the interpreter.
It's unlikely to matter much on Windows, but then I don't use windows. That first "#" makes it a comment as far as perl is concerned, so it isn't going to hurt to have it there. Try writing a simple perl program, like print "Hello World\n"; Can you get it to run, however you like to run things? I'd recommend trying it with the "#!" line, and leave it there if it works. It also might help to use the standard perl script file extension on the name of the file: ".pl". 
Completely unnecessary on Windows, but a good habit to be in. Makes transition to Linux/Unix easier, and makes your scripts shareable. There is also at least one option, -T (taint checking) that can only be done on the shebang. (Well also perl -T on the command line, but it sounds like you're invoking the script by double clicking it)
Not required, but no reason **not** to include it. I'd include it just for consistency.
Can I just use like #!perl 
You don't have to do anything, but `#!perl` is not a bad idea.
Also is there a difference in ACTIVE Perl and Strawberry Perl for Windows 
And now on Mojo 7.83 this has changed to use the `MOJO_CLIENT_DEBUG` variable instead https://github.com/kraih/mojo/blob/75b848466b9f2759f587dcba41e479f56de060e1/Changes#L3
In my experience the main difference I noticed was in module management. Active Perl packages up a lot of modules and required binaries for you. Strawberry Perl provides you with a good mingw environment allowing you to easily build binary components of any modules you need. It isn't flawless but the Strawberry Perl experience is a lot closer to being on a Unix platform, which I've found to be more enjoyable.
This will not work on Unix because the command always must be an absolute path. (The line is actually used by the kernel, for Perl the line is just a comment. You have a similar line for other languages like #!/usr/bin/bash, #!/usr/bin/python, #!/usr/bin/awk, etc.) But that brings us to the next problem, if you specify #!/usr/bin/perl you're going to run the script with your system Perl, which might not be what you want. That's why some people switch to #!/usr/bin/env perl which uses env to find the perl in your path. Again, that breaks if /usr/bin/env does not exist. Most of the time the correct thing is for the installer to adjust the shebang line during the installation. Which is what e.g. [ExtUtils::MakeMaker](https://metacpan.org/pod/ExtUtils::MakeMaker#EXE_FILES) does if the script contains #!perl or #!/usr/bin/perl. I guess #!perl is a good choice for you.
I mean it compiles and runs so that’s all that matters 
`chomp()`. It's always `chomp()`. Without reading any other answers, my guess is that `$feeling` is being read from `&lt;STDIN&gt;`. That variable will come with a newline attached to it that you need to remove using `chomp()`. say 'How are you feeling?'; my $feeling = &lt;STDIN&gt;; chomp($feeling); if ($feeling eq 'Good') { say "That's good to hear"; }
&gt; Would you also have any free perl learning resources See http://perl-tutorial.org/
it's also highly suspect archiecturally. I don't really recommend reading the source to [CGI.pm](https://CGI.pm), it dates back to the days when nobody really knew what they were doing.
I'm a bit afraid that I will have to pay you money to program these projects with you. Will you let me do it for free?
Actually I pay you 
https://metacpan.org/pod/App::cpanminus
I’m kinda confused on the tool used to download is it the Perl command line or CMD because Perl command line is just a CMD that is renamed the Perl command line 
Btw: is PAUSE still the place to upload modules to the CPAN?
On Windows 10 Start Menu &gt; All Apps &gt; Strawberry Perl &gt; CPAN Client This should bring up a console for you to enter the module you want to load, e.g. `install App::cpanminus`
Any cmd shell should ( [I think](https://perlmaven.com/how-to-install-a-perl-module-from-cpan#dwimperl) )) allow you to type something like `cpan App::ModuleName`. If it doesn't then cd to your Starwberry Perl installation folder and its respective bin folder and try again from there. 
Well when I type cpan it does Cpan &gt;&gt;&gt; then I type that it goes through some program then when it seems to be done I type exit on cpan and says something like lockfile blah blah 
Yes. PAUSE and the CPAN mirror infrastructure has not changed.
It's important to note that those statistics were extracted from hits to the [CPAN Meta DB](http://cpanmetadb.plackperl.org/) he runs that cpanm uses to query (but not download) module versions by default, by reading the User-Agent string. In order to track this sort of data you need both a client that will report it and a server that will collect it, and making cpanm explicitly report to a secondary server is unlikely to be appreciated.
For reference, here's the documentation for [Perl's unlink](https://perldoc.perl.org/functions/unlink.html): &gt; On failure, it returns false and sets `$!` (errno) and C's [`unlink`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html): &gt; Upon successful completion, these functions shall return `0`. Otherwise, these functions shall return `-1` and set errno to indicate the error. If `-1` is returned, the named file shall not be changed. Clearly contradicting [this](https://github.com/perl6/doc/issues/2096#issuecomment-396419612): &gt; It copies the way Perl 5 does it and it in turns copies the way it's done in C. 
The fix in the docs got a bit lost in the confusion but the docs are better now.
Good example of the misunderstandings that can occur when either side doesn't read carefully or projects unintended tone. Glad it was resolved in this case.
Did I use this correctly use strict; use warnings; use v5.26; use LWP::UserAgent; If I did how do I know that the module works I ran the program but it worked just fine 
https://stackoverflow.com/questions/6643939/installing-modules-using-strawberry-perl
&gt; how do I know that the module works A module distribution not only contains the library code, but also tests for the code; [for example LWP](https://metacpan.org/source/ETHER/libwww-perl-6.34/t). When you installed the module with a CPAN client, its tests were run. The installation normally only completes when there were no problems during testing. This means, at least for your computer and its configuration, since you were able to install the module, it is quite likely that it works as intended. Caveat: test quality and coverage varies. Tests can only prove the existence of bugs, not the absence.
when you type cpan without any parameters then you enter an interactive mode. (better to enter the lot in one go) cpan is running and the prompt changes to indicate you are a different shell, running in your shell. Once here you can do `install App::cpanminus or whatever. When installing, the screen will show what is happing in the install process, the tests being run and finally whether the install was successful or not.`. Lockfile statement occurs when two files are accessing the same file e.g if you have another cpan install running at the same time. 
Because info is lower than warn, so it's excluded. Either use \`level =\&gt; 'warn'\` or use \`$log\-\&gt;warn("test123")\`.
&gt; Either use level =&gt; 'warn' it's already level =&gt; 'warn'
Well, some tests do test for the absence of known bugs.
I edited it. Pre-fourth cup of coffee titanofold isn't so sharp. 
it's still not writing it 
Try writing to a different location - you may not have full access to /var/log
Ugh, I though Perl conf Is going to be held in Poland. Need to improve my English...
Don't you Haiti when that happens? People should really Czech their titles for ambiguities.
Download and watch at 4× speed to minimise annoyance. The presentation form was chosen poorly, this does not deserve to be a video.
In your code snippet, you set the level (the minimum level required for a message to be logged) to `warn` with `level =&gt; 'warn'`. You then try to log a message at level `info`, which is lower than `warn`. That won't work. You need to either set your minimum log level lower (`debug` or `info` are both lower than `warn`), or log your actual "test123" message at a higher level (`warn`, `error`, or `fatal`), ie `$log-&gt;warn('test123')`. https://mojolicious.org/perldoc/Mojo/Log#SYNOPSIS You allude to trying that in another message... I think. Regardless, you can print some info right before your `$log-&gt;info...` call to make sure your log config looks how you think it should (and nothing else has changed it inadvertently), eg: get '/' =&gt; sub { say 'log level: ', $log-&gt;level; say 'log path: ', $log-&gt;path; $log-&gt;warn('test123'); ... }; https://mojolicious.org/perldoc/Mojo/Log#level /u/dreadpiratemiley's example works perfectly for me as well. 
This is funny. Bolivia not.
Ugh, at least mention Archive::Tar in the subject.
The relevant perl bug report: https://rt.cpan.org/Ticket/Display.html?id=125523
There's no performance gain. SQLite is dog slow whether on disk or in memory. Learned this the hard way.
This is very [cute](http://news.perlfoundation.org/2016/12/grant-proposal-learning-perl-6.html) coming from people who vociferously opposed the grant application for this book and accused the author of various shady things (and later asked their posts to be removed from the site).
*hug*
This is blogspam for [CVE-2018-12015](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12015). ---- [Fixed in Archive-Tar-2.28](https://metacpan.org/changes/distribution/Archive-Tar).
There are those that look at things the way they are, and ask why? I dream of things that never were, and ask why not?
Strange. I've never found that, even on my low-powered home automation server. In fact, comparing a random substring select on a 45000 record table it completes in less than ⅓ of the time that the same query takes using MySQL. It may perhaps not be as efficient on *huge* tables, I don't know, but I've certainly never suffered from it being slow.
&gt; There are those that look at things the way they are, and ask why? I dream of things that never were, and ask why not? That is a very telling quotation and [very apropos](https://www.nu42.com/2018/03/perl-vs-perl6.html) indeed. Here it is, [in context](https://www.gutenberg.org/files/13084/13084-8.txt): THE SERPENT. The serpent never dies. Some day you shall see me come out of this beautiful skin, a new snake with a new and lovelier skin. That is birth. EVE. I have seen that. It is wonderful. THE SERPENT. If I can do that, what can I not do? I tell you I am very subtle. When you and Adam talk, I hear you say 'Why?' Always 'Why?' You see things; and you say 'Why?' **But I dream things that never were; and I say 'Why not?'** I made the word dead to describe my old skin that I cast when I am renewed. I call that renewal being born. ... THE SERPENT. Listen. I will tell you a great secret. I am very subtle; and I have thought and thought and thought. And I am very wilful, and must have what I want; and I have willed and willed and willed. And I have eaten strange things: stones and apples that you are afraid to eat. Just as there was a good reason to avoid taking a bite out of that apple, there are good reasons to avoid being the target of the Perl 6 cabals ire.
Making Perl 6 easier to use is a good idea no matter how we got to where we are today.
&gt;select on a 45000 record table The joins are slow. If you mostly shove data in and out of a few de\-normalized tables I'm sure it's fine. If you actually try to use a non\-trivial relational schema, you are better off just using something like Set::Relation or handwriting data structures. SQLite just does dumb glorified nested for\-loops for joins and it's not very optimized at all.
I think this is great. Nice to be able to manage your modules like a distros package managers.
&gt; there are good reasons to avoid being the target of the Perl 6 cabals ire One of the risks of a policy of "troll hugging" is pre-emptively labeling people trolls when they ask questions you don't like hearing.
*hug*
I'm highly skeptical of anyone writing CPAN clients without having spent time working on the Perl toolchain and its many quirks. There are too many things you can get wrong by misunderstanding backwards compatibility or current practices.
&gt; Coupled with the marketing the author and O'Reilly will be doing for the book, I expect to see an influx of new users. BTW, how much marketing budget is O'Reilly really going to be committing to a Perl (or Perl 6) book these days? I'm thinking nearly non-existent.
a pat on the head then.
I don't have any real knowledge of what O'Reilly spends but my impression has been that there's no particular book that has that much devoted to it. It's not something about ignoring Perl or Perl 6 so much as most of the interest being driven outside of anything a publisher controls. There are sunk costs such as salaries and office space for the people who put together the weekly promotions and whatnot but I don't know how those nonspecific things affect sales. Maybe get on O'Reilly person to do an AMA :) My experience is that people decide on a topic then go looking for a book rather than deciding to buy a book because a publisher drove their interest in the topic. For Perl 5 I've mostly dealt with people who are using it because someone else told them that's the language they were required to use. This gets into a longer discussion of the difference between marketing and advertising. Most people mix up those terms. Marketing is figuring out the audience for the book (size, interest, resources, whatever) and developing something that group wants. Advertising is telling people what's available. O'Reilly has the brand power that mostly takes care of that (although maybe not to the extent it used to). The marketing is done. My book is for people who haven't looked at Perl 6 and maybe haven't programmed in any other language. Various decisions are made around that particular market segment. It necessarily makes decisions that some market segments won't like. However, the books by Moritz, Andrew, and Laurent cater to those segments. They were able to get to the market faster too because they assumed a level of prior proficiency and awareness I had not assumed in my segment. Note that my [Effective Perl Programming](https://www.effectiveperlprogramming.com/) and [Mastering Perl](https://www.masteringperl.org) books are different market segments than [Learning Perl](https://www.learning-perl.com) and [Intermediate Perl](http://www.intermediateperl.com). While those were more fun to write because I could assume different things about the segment, they earn about one tenth of the money of the more beginner books. That's why I'm more interested in the beginner books. One of the biggest drivers of book sales is Amazon reviews. A couple of stellar reviews moves a book. Some middling reviews kills it. The advertising is going to come from the people saying things about Perl 6. If they like my book maybe they recommend it. If they don't like my book they don't or they warn people away from it. I don't know which way that's going to go and there's not much a publisher can do to control that. There's also the issue of my position in the author hierarchy. At best I'm a mid-list long tail author. My books make decent enough money that my publisher will update them but I'm not making enough money off publishing to [buy an island](http://articles.chicagotribune.com/2001-05-20/business/0105200223_1_mansion-stephen-king-sarasota-county). Everyone would probably rush to buy the latest Damian Conway (I hear _[Object Oriented Perl 2: 50 Operators of Hunger Twilight Prisoner of SelfGOL](goo.gl/4eTMDy)_ was just optioned) (and maybe mjd's next book _[Higher Order Shitposting](https://shitpost.plover.com)_ they aren't going to buy a tutorial until they need it. Almost anyone reading this isn't going to need it because it's three years too late for them. This certainly isn't a front list book where everyone is going to buy it the first weekend before the reviews are in (although it is available for [preorder on Amazon](goo.gl/f79Me4)). Publishers advertise the heck out of those sorts of books because they need to make a bunch of money quickly before everyone finds out the book is no good. They don't advertise the slow burn books. A technical book like this is designed for a three year life span. After that people tend to think the book is no good even if it is current (because C has changed _soooo_ much lately!). My books make their money over three years and I think everything in Learning Perl 6 will be good for v6.d (but maybe not v6.e). Many technical authors make their money off the services they offer related to their book's topic and mostly use the book as their advertising. If you're the non-technical person who needs to hire someone how are you going to pick them? The names of authors on books (no matter the publisher) tend to get more traffic. So, finally, yes, I think you're right. 
Perhaps a similar thing could be implemented in App::rs? Debian has a way to do this with apt-mark {auto,manual}. 
I built a boyce-codd normal form schema with some 20 tables and 98&amp;#37; of runtime ended up in SQLite's too-stupid query execution, with DBs under 10MB. Putting the DB entirely in memory or on a ramdisk made absolutely no difference. Huge amounts of time was spent iterating through records and calculating matches. Where modern query planners and caching should obviate the problems I was seeing.
I am just going to plug [an old blog post of mine](https://www.nu42.com/2010/12/economic-perspective-on-marketing-perl.html) on the topic of marketing Perl. It remains to be seen if any of what I said makes sense in the context of Perl 6. I am just not going to contribute to the effort to improve Rakudo on Windows, say, by building it from source etc. I've [been](https://www.nu42.com/2017/02/deception-in-tests-harmful.html) [there](https://www.nu42.com/2017/02/perl6-programmer-frowning.html)
This article makes two references to requisite intellectual capacity — I’m unclear on what is being said here. It kinda sounds like it is saying that Perl is too difficult for some people who would be better off writing code in a different language.
Well, writing a CPAN client **is** a way to spend time on the Perl toolchain, as a direct consumer of the metacpan-api you know much better what it provides, how the CPAN infrastructure works, you're more likely to find bugs and provide valuable suggestions. If you're someone who's actively engaged in the toolchain, I would much appreciate if you could point out the exact quirks that one should be aware, and the exact misunderstandings in App::rs currently; if not, your claim is merely speculation. Regarding to the reference counting objection, why don't you just say what you want explicitly? In App::rs all you need to do is `rs install Module:A`, as demonstrated in the video, nothing will be done if it's already installed, and `rs` would know that this is something you want directly and it would never remove it nor its recursive dependency. Suppose you installed one module which pulled in 99 other modules, your approach would either result in those 99 modules be left there forever when the module installed by you is removed, or you need to individually check whether those 99 modules are eligible for removing and remove them manually, I don't think either is desired.
In my experience, programming is too difficult for most people who successfully pass themselves as programmers.
&gt; If you're someone who's actively engaged in the toolchain, I would much appreciate if you could point out the exact quirks that one should be aware I haven't reviewed the code so I'm not intending a slight here, and my current opinion is indeed speculation, I apologize if it came off as anything else. But a good start is to read the full source code of cpanm (now Menlo) as it deals with many of these quirks, and in fact the Menlo backend may be useful for using directly in a higher-level system such as this. What I'm referring to otherwise is spending time with the people working on the toolchain and the problems that are encountered; just lurking in #toolchain on irc.perl.org can be very enlightening from personal experience. And sure, writing a CPAN client is a good experience for such, but you're not just writing a CPAN client for the experience, you're advertising it for use and applying for a grant, so something like that I will always approach from a position of skepticism. &gt; Suppose you installed one module which pulled in 99 other modules, your approach would either result in those 99 modules be left there forever when the module installed by you is removed, or you need to individually check whether those 99 modules are eligible for removing and remove them manually, I don't think either is desired. That's exactly what I desire.
If they are successful, it sounds like they know how to program.
I don't know about any generalizations, but there are definitely many people who pass themselves off as programmers and are only successful because of the ignorance of the management.
App::rs is originally used for my custom Linux distribution, I've been using it through recent years and it already provides a solid backend for single package management, the CPAN client is built on top of this, and one of its best features is to restore a module from a binary package instantly, and I know it inside out, so it doesn't make sense for me to switch to another backend. What you desire could be done exactly by the more plumbing `remove` command of App::rs, it's what I use to manage my Linux distribution and what's used by the CPAN client internally.
Truer words have never been spoken.
Some examples of what a CPAN client has to deal with (and maybe you are handling these already in which case well done, but these are just the basics): * CPAN clients are expected to first check META.json, or if that doesn't exist META.yml, for configure phase dependencies and install those (and really old distributions of course will have neither). Then if Build.PL exists, run that to generate Build and MYMETA.json/MYMETA.yml. Otherwise run Makefile.PL to generate Makefile and MYMETA.json/MYMETA.yml. Install the build, test (if running tests), and runtime dependencies from MYMETA.json/MYMETA.yml. Then use the Build or make test and install process. * The dynamic_config option can be set to 0 in metadata to indicate that META.json/META.yml contains a static set of dependencies, but CPAN clients can't really rely on this anyway and Makefile.PL/Build.PL needs to be run regardless, so this is mostly useful for static analysis not installers. * There's a new [static install](http://blogs.perl.org/users/shoichi_kaji1/2017/03/make-your-cpan-module-static-installable.html) process that distributions can opt into, it's supported by dev versions of cpanm but is not yet a formal specification. With this indicated in META.json, META.json is exclusively used for all dependency phases and Makefile.PL/Build.PL does not need to be run, the CPAN client is expected to know how to run tests and install the files. Makefile.PL/Build.PL will of course still be required for the forseeable future to support CPAN clients that don't support static install. * [Versions are weird in Perl.](http://blogs.perl.org/users/grinnz/2018/04/a-guide-to-versions-in-perl.html) CPAN clients need to make proper use of version.pm to track upgrades, and account for both styles of versions even within the same distribution. * The metadata and Makefile.PL/Build.PL protocols are constantly evolving in tandem with CPAN clients and distributions that make use of them - almost any major advancement in CPAN packaging requires every part of this chain to be aware and make updates while remaining compatible with old distributions and old CPAN clients (but often without the new benefits in those cases).
Hey, Grinnz, just a quick heads-up: **forseeable** is actually spelled **foreseeable**. You can remember it by **begins with fore-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
That's a good list. I'd encourage this project though: writing new CPAN clients is a good way to shed some light on the darker corners of the toolchain. It'd be nice to make the documentation more explicit for the areas which are currently hidden away in special-case handling in existing CPAN clients. (also, existing CPAN clients have quite a few weak spots, so I don't think OP is the only person who has decided to implement their own to work around those!)
I think the opposite is almost certainly true as well - there are plenty of potentially great programmers out there who never give it a try because of the failings of the education system.
And it's just going to get worse: [https://www.bloomberg.com/news/articles/2018-06-14/citi-wants-analysts-to-add-python-to-list-of-languages-on-resume](https://www.bloomberg.com/news/articles/2018-06-14/citi-wants-analysts-to-add-python-to-list-of-languages-on-resume)
In my experience a select that's slow with sqlite is going to be slow with any rdbms. You need good indexes on your tables, statistics, etc. for anything complicated just like any other SQL engine. Now, if you want to argue that you shouldn't have to manually call `PRAGMA optimize` to improve performance... that I'd agree with.
Absolutely, I'd love to encourage such projects, as long as the author knows what they're getting into and accepts the responsibility of making CPAN work correctly.
Just so you know, Perl doesn't ignore the shebang line at all. It will activate command line switches put in there and it also won't execute the program if there's something other than Perl in there, calling the indicated program instead.
Reminds me why Perl 6 exists.
This just isn't true. SQLite does not have the many optimizations other engines use and just straight up loops through records to compute joins.
Yes. 
Haha, prolog humour!
I suppose declarative programming in Perl is a bit of a stretch? Iirc, declarative Prolog programs can be run forwards or backwards with the same result.
You might like [Logic Programming with Perl and Prolog](https://www.perl.com/pub/2005/12/15/perl_prolog.html/). Ovid has some interesting links in the docs for [AI::Prolog](https://metacpan.org/pod/AI::Prolog) and has written about the sorts of problems Prolog is good at.
Hi again, Bob. I'm a tad late to the discussion. While I'm now spending less time writing on P6 outside the perl subs, this is a topic I've thought about a bit. Plus I wanted to chat about something light. :) &gt;I love how Perl 6 supports just about any programming language paradigm and coding style you can imagine. But one of the features I don't see highlighted in the docs is convenient immutable complex data structures. I'm sure you can build this with the Perl 6 object system. I'm just wondering if it's built in, and I missed it in the documentation. I've thought along similar lines. Plus I agree it can valuably simplify reasoning about code. I see there's been discussion but everyone will have gone by now so I'll just write from scratch. I'll probably cover a lot of stuff you already know but I'll not worry about that because you can skim. Overall I think P6 scores low marks for language support for a 100&amp;#37; immutable programming paradigm. But let me imagine it's nevertheless worth discussing it from a positive perspective. :) Given that P6 syntax and semantics are ultimately completely programmable, so one could in principle, ignoring performance, write clojure in P6, or something hybridish if that's preferred and/or regains performance, I can *imagine* doing 100&amp;#37; immutable programming in P6 at some point in the future. But I have an active imagination that runs far ahead of reality, sometimes infinitely far. :) Anyhoo, it's this possibility that led me to write that P6 scores low marks for language support for 100&amp;#37; immutable programming. Without it I'd have given it an even lower score. :) So, returning to what there is now and could plausibly be in the near term... First, there's `List` which seems like a start. By *default* it is *shallowly* immutable. But `(1,$a) === (1,$a)` will always be `False` for one of two reasons. First, the `$a` is typically a `Scalar` container which is mutable. Secondly, each list behaves like its own object rather than as a type of value so even `(1,2) === (1,2)` will always be `False`! All things considered `List` is a... false start. :) The `say (1,2) === (1,2); # False` example is especially striking though `(1,$a) === (1,$a)` is no less important. Going further, we might consider arbitrarily nested lists and arrays such as `(1,($a,[2,@b])) === (1,($a,[2,@b]))`. There's already been talk of a `Tuple` type that's like a `List` but replaces nested lists and arrays with their immutable `Tuple` equivalent, replaces scalars like `$a` with their value, and acts as a value type so that `(1,($a,[2,@b])).Tuple === (1,($a,[2,@b])).Tuple` is `True`. Perhaps there'd also be some syntax sugar to avoid lots of `.Tuple`s. But imo, while that might work as a step forward, it's only a step. Imo we also need something that covers associative types (`%foo`) and I'd prefer a single solution that covers those too. Perhaps a generic `ro` function/method that "deep freezes" a data structure by replacing all `Scalar` containers with their contents (whether they're on their own, or elements of a list/array, or values of key/value pairs), iterates `Iterable`s, and returns a new object with immutable value semantics. So that `(1,($a,[2,@b,{:c,:d[3,4]}])).ro === (1,($a,[2,@b,{:c,:d[3,4]}])).ro` is `True`. But there are other issues. First, what about objects with mutable object semantics? Do you count objects as complex data structures? While P6's overall architecture is such that you could indeed grow an entirely new immutable object system that sits within the larger system, much of the out-of-the-box functionality, the standard library if you will, is predicated on using built in objects and some of those are mutable and get mutated. Object mutation isn't a problem in the face of concurrency if you use the right features such as [OO::Monitors](https://github.com/jnthn/oo-monitors) that automatically serialize method calls of instances of classes declared with `monitor` rather than `class`. And that's idiomatic. But objects are a form of complex data structure, and a good number of those shipped as part of the out-of-the-box P6 experience are mutable and get mutated, and I suspect it would be a major undertaking to grow a 100&amp;#37; immutable alternative to them. But maybe you don't mean objects in general but just nested arrays and hashes and the like. No matter what approach one comes up with for coding with immutable complex data structures or objects, there'd still be the issue of accidentally/incidentally creating mutable ones when you meant to create immutable ones. I hear clojure makes it hard to do that. I suspect that's a good thing and perhaps critical. And even if you ignore that, you'd still have the problem of accidentally/incidentally calling functions that attempt to mutate and then raise errors when they find they can't *at run-time*. I'm guessing clojure doesn't have that problem. And if you fix that by writing versions of functions that statically match immutable types -- which I think is an unrealistic proposition as a general solution -- you'd now have to make doubly sure you don't accidentally/incidentally create and pass mutable data/objects because that would be statically multiply-dispatched to the original functions that accept mutable data/objects and they'd mutate your supposedly immutable data/object without error. Anyhoo, I'm written out. Thanks to anyone who reads this for listening. :)
Like What?
Is there any way a weekly issue about a computer language could be devoid of a human face image that appears on Reddit next to the post?
I guess you could talk to [Gabor ](https://www.reddit.com/user/szabgab)and suggest fixes to his site's OpenGraph tags.
Thanks for taking the time to write all of that. I learned from it and it's fascinating. I have to admit, I'm disappointed with the situation. To repeat some of the arguments I've made elsewhere, I've found these inadvertent shared references to mutable objects *even within the same thread* to be a source of a significant amount of bugs. I see this as Perl 6's only weakness. It's not a deal-killer, but it harms the argument I've love to be able to make, "P6 is equal or better than your favorite language at *everything*."
Very cool. I am working on a project sizable project now using Moo. I will give this a try. I'm just indoctrinated to use $DB::single = 1 to jump to where I want. So I haven't looked for other options in a while. Ovid's approach looks cool
Here's the [github repo](https://github.com/szabgab/perlweekly) where one could submit a PR for such improvements.
The [-&gt;post](https://metacpan.org/pod/Mojo::UserAgent#post) method appears to expect a hashref for the header, you're passing a hash. Try `$useragent-&gt;post($request{endpoint}, \%header, $request{message})` instead? Alternatively, you should be able to pass `message` as a data structure if you leave out the `Content-Type` header and use `$useragent-&gt;post($request{endpoint}, \%header, ($request{tokena} ? 'json' : 'form'), $request{message})`, let Mojo::UserAgent handle encoding for you.
wow - that's [some release process](https://github.com/szabgab/perlweekly#the-final-touch). If only there was a scripting language that could somehow automate a list of tasks like this...
How much backward incompatibility is there with perl 5? If much, is there a program to convert perl 5 programs to perl 6?
They are different languages, kinda like python 2 vs 3. That said, if I recall correctly, there’s a module that enables inline perl5, so you could maybe start with that until you work out how to properly port it. One of my favorite simple but breaking features is that sigils are simpler now. In perl5, if you’re referring to a list (but not indexing into it), you use @ and if you are indexing into it, you use $. In perl6, you use @ for both because the actual variable you’re using is a list either way. Same goes for % with hashes. I highly recommend perl6intro for getting familiar with the new syntax. 
Since the original idea behind Perl 6 is an update for Perl 5 but breaking backwards compatibility, they went all out with it. Perl 6 can only claim to be a Perl by following the same philosophy, they're completely different languages.
[Kavorka](http://p3rl.org/Kavorka) compares very favourably. I had to change very little to translate the code from Perl 6. Most of the demonstrated features are also available to you in 5. Differences: * signatures have different defaults for traits `alias`, `copy`, `ro`, `rw` * lexical variables in signatures (work-around possible) * nested subs are not private (work-around possible) * named and slurpy in the same definition ---- use 5.026; use Kavorka qw(fun multi); fun a_sub($param1, $param2) { say $param1 + $param2; } a_sub(1, 2); # Output: 3 #### fun b_sub(Int $param1, Int $param2) { say $param1 + $param2; } b_sub(1, 2); # Output: 3 b_sub(1.01, 2); # Throws an error #Value "1.01" did not pass type constraint "Int" at … # Value "1.01" did not pass type constraint "Int" # "Int" is defined as: (defined($_) and !ref($_) and $_ =~ /\A-?[0-9]+\z/) #### fun c_sub(Int $param1 where {$_ &gt; 0}, Int $param2 where {$_ % 2 == 0}) { say $param1 + $param2; } c_sub(1, 2); # Output: 3 c_sub(0, 2); # Throws an error because $param1 has to be &gt; 0 c_sub(1, 3); # Throws an error because $param2 has to be even #### fun d_sub(Int $param1, Int $param2 where {$_ &gt; $param1}) { say $param1 + $param2; } # Global symbol "$param1" requires explicit package name (did you forget to declare "my $param1"?) # see http://p3rl.org/Kavorka::Manual::Signatures # "However, the use of any lexical variables within the term is currently broken." # possible work-around with "our"? d_sub(1, 2); # Output: 3 d_sub(2, 1); # Throws an error #### use PadWalker qw(peek_my); fun d2_sub(Int $param1, Int $param2 where {$_ &gt; peek_my(1)-&gt;{'$param1'}}) { say $param1 + $param2; } d2_sub(1, 2); # Output: 3 d2_sub(2, 1); # Throws an error # $param2 failed value constraint at … #### fun e_sub($param1, $param2) { $param2 *= 2; say $param1 + $param2; } e_sub(1,2); # Output: 5 #### fun f_sub($param1, $param2 is ro) { $param2 *= 2; say $param1 + $param2; } f_sub(1,2); # Throws an error: # # Modification of a read-only value attempted at … #### fun g_sub($param1, $param2 is alias) { $param2 *= 2; say $param1 + $param2; } my $value = 2; g_sub(1, $value); # Output: 5 say $value; # Output: 4 #### fun h_sub($param1, $param2) { fun max_val() { return $param2 &gt; $param1 ? $param2 : $param1; } say "Of these, " . max_val() . " is biggest, and sum is " . ($param1 + $param2); } h_sub(1, 2); # Output: Of these 2 is biggest, and sum is 3 max_val(); # not an error, identifier is package scoped #### fun h2_sub($param1, $param2) { my $max_val = fun() { return $param2 &gt; $param1 ? $param2 : $param1; }; say "Of these, " . $max_val-&gt;() . " is biggest, and sum is " . ($param1 + $param2); } h2_sub(1, 2); # Output: Of these 2 is biggest, and sum is 3 $max_val-&gt;(); # Variable "$max_val" is not imported at … #### fun i_sub(@a) { say join ', ', @a; } i_sub(1, 2, 3, 4, 5); # Output: 1, 2, 3, 4, 5 #### fun i2_sub(slurpy ArrayRef $r) { say join ', ', $r-&gt;@*; } i2_sub(1, 2, 3, 4, 5); # Output: 1, 2, 3, 4, 5 #### fun j_sub($param1, $param2, @a) { say "Sum is " . ($param1 + $param2) . " and rest is " . join ', ', @a; } j_sub(1, 2, 3, 4, 5); # Output: Sum is 3 and rest is 3, 4, 5 #### fun k_sub(:$param1 = 1, :$param2 = 2, @a) { say "Sum is " . ($param1 + $param2) . " and rest is " . join ', ', @a; } # Cannot have a slurpy array for a function with named parameters at … k_sub(param1 =&gt; 1, param2 =&gt; 2, 3, 4, 5); k_sub(3, 4, 5); #### fun l_sub(:$a1, %h) { use Data::Dx; Dx %h; } l_sub(a1 =&gt; 1, a2 =&gt; 2, a3 =&gt; 3, a4 =&gt; 4); # Output: %h = { a2 =&gt; 2, a3 =&gt; 3, a4 =&gt; 4 } #### multi fun n_sub($param1, $param2) { say "Sub 1: " . ($param1 + $param2); } multi fun n_sub($param1, $param2, $param3) { say "Sub 2: " . ($param1 + $param2 + $param3); } multi fun n_sub(@params) { use List::AllUtils qw(reduce); say "Sub 3: " . reduce { $a + $b } @params; } n_sub(1, 2); # Output: Sub 1: 3 n_sub(1, 2, 3); # Output: Sub 2: 6 n_sub(1, 2, 3, 4, 5, 6); # Output: Sub 3: 21 n_sub(1..7); # Output: Sub 3: 28 
* https://modules.perl6.org/dist/Inline::Perl5 * https://docs.perl6.org/language/regexes#Perl_5_compatibility_adverb * https://github.com/drforr/Perl-Mogrify
&gt; Thanks for taking the time to write all of that. Sure. Thanks for writing your post. It prompted me to put my thoughts together on some stuff I've been mulling for a while. &gt; I learned from it and it's fascinating. Me too. The act of writing sometimes forces me to a new level of clarity and this was one such case. &gt; I have to admit, I'm disappointed with the situation. Me too -- when I'd finished writing my previous post. But now past tense as I write this. To repeat, the act of writing sometimes forces me to a new level of clarity and both my prior post and this one are such cases. Time for a tangent: One of the most wonderful (and terrifying) things about Perl 6 in recent years has been the deja vu in regard to the roller coaster of how I felt about Perl throughout the 90s as I let my attention rest for long periods on great aspects or ugly ones. In the original Perl line's case facets like the early community, and the overall practical, deeply non-ideological nature of the language, and the support for communal evolution, won me over for most of the 90s. But by the late 90s I personally couldn't deal with its ugly any more. P6 has sufficiently dealt with the profoundly ugly, and enhanced the beauty, that I'm patient about its practicality (most importantly, performance). It has also significantly extended the deeply non-ideological philosophy and capacity for communal evolution of its convenience, which makes it especially compelling to me. But to be non-ideological it has to include substantial support for the imperative perspective and to be convenient it has to minimize bossing devs around. And there's the rub. My inner community-minded mathematician wants type theoretic types (at least Hindley-Milner but HoTT is even more appealing) and wants maximization of the classes of bugs the language is guaranteed to weed out. Meanwhile my inner community-minded non-mathematician wants abstractions everyone can collectively reason about and to maximize the diversity of the mental capacities and attitudes of the folk who can collaboratively participate. Immutability is one of several elements that sit at the heart of battles that my inner perspectives have been duking out for decades. &gt; inadvertent shared references to mutable objects How does clojure avoid inadvertent sharing of a reference to a mutable object? (I mean an object that is, for good reason, mutable, so I'm not speaking of avoiding this issue by avoiding mutability, which is a different notion.) Presumably, at minimum, the code creating the object has to be explicit that it's creating a mutable object. And I would guess any later mention of the object in code that wanted to make use of its mutability would have to somehow be explicit that it's doing so. I'll return to some other scenarios you mentioned later but an idea for the syntactic sugar for explicitly immutable data just crystallized for me and I want to write about it immediately. If you see a sigilless variable, you already know it's shallowly immutable by convention (and by strong idiomatic default -- you have to know an obscure trick to get around it): my \foo = 99; foo = 42; # error What if the following were introduced: _bar = 99; _bar++; # error The lexically first use of a `_` variable is a deeply immutable variable declarator. Any lexically subsequent use is just a mention, not a declarator. It's shorter than `my`, thus consistent with a broad attempt to introduce a convenient immutability idiom. It binds its symbol to a deeply immutable coercion of the value on the RHS of the `=` (`:=` just does the same thing). It provides the additional benefit of giving P6 auto-declared variables without needing to use `no strict`. It avoids the problem that `my` solves because you won't be able to redeclare or re-assign such a "variable" (it's really a constant). Unfortunately I think there's already been some use of sigilless identifiers that start with `_` without regard for immutability. Fortunately, I think it's mostly been routines. The compiler enforces that routine (identifiers) are immutable. And most if not all of the rest has been constants. The compiler enforces that constants are shallowly immutable and convention almost certainly takes care of the rest. (Would you define a `constant ...` that can and does mutate?) In the meantime, rename the `ro` / `.ro` operator I mentioned in my previous comment to `_` and `._`, so: _a = (1,$z); # _a now contains a deeply immutable coercion of (1,$z) say _a == _(1,$z); # True if $z evaluates to the same value as before _a = (1,_b); # _a now contains a deeply immutable coercion of (1,_b) say _a == _(1,_b); # True If this is introduced, then if you spot a leading `_` then you're dealing with immutable data. Making this work nicely for arbitrary objects will be challenging, to say the least. But I think there might be the seed of a workable idea here. &gt; code that expects the value it had at initialization ... counters, 'Person' objects, output formatters, everything I would have thought that code dealing with a counter would *expect* the value to change. And it would be 50/50 whether a Person object would change. What if the latter had an emotional status? With the approach I've suggested, the identifier name encodes immutability, so I think it resolves the issue of expectation when eye-balling code. Ignoring the scheme I've just dreamt up, P6 tends immutable anyway. I recalled replying to you about this some while back and will summarize it here again, with some corrections: * Scalar and sigilless function parameters are read-only by default. (I don't know why composite parameters are not and why there's no `is ro` trait either. Quite odd.) * Object attributes are publicly read-only by default. * Function return values are shallowly immutable by default. I've written enough to feel like it's time to stop for now. I'm hoping you'll have time and motivation to absorb what I've written and respond. In the meantime, I haven't yet dug into the following but am still pondering them: &gt; some class holds a list of objects and someone absentmindedly makes the class method getList() return a reference to the original instead of a copy. 99.5% of the time... That kind of thing happens periodically with Lists, Maps, and Sets in Java. &gt; it's common practice (syntactically convenient) to build objects with mutable instance fields and a few methods.... periodically some method that assumes all instance fields have been initialized will be run before all initialization happened &gt; some code tries to write to a file handle or query from a database connection that was already closed
Lot's. Especially if you're aiming for wholesome, idiomatic, and performant Perl 6, rather than just changing the bare minimum to make a Perl 5 program run in Perl 6. $ perl6 -e '"0" and say "I am a Perl 6 program" or say "I am a Perl 5 program"' I am a Perl 6 program $ perl -E '"0" and say "I am a Perl 6 program" or say "I am a Perl 5 program"' I am a Perl 5 program 
Thanks for taking the time to read my post and reply. It turns out that 'post' is happy with a hashref or an anonymous hash, but not a named hash - thanks, your first suggestion was on the money.
Interesting! OOC, have you done any speed comparisons?
For the sake of closure: In the end, I used this: `my $response = $useragent-&gt;post( $request{ endpoint } =&gt; \%header =&gt; $request{ message } );` Later I added `-&gt;res-&gt;json` at the end so that I'd get a hash.
This is because a "named hash" as you say is really just placing the hash into the arguments, and when you put a hash or array in a list in Perl, it flattens the contents into that list. In other words, the 'post' method receives a bunch of arguments from the contents of that hash, rather than the hash structure itself. Whereas a ref is a scalar, and an anonymous hash returns a ref, so it's not flattened.
I think some people have gathered together in Utah to celebrate it.
Again, thanks for the discussion. I'm being educated and having fun in the process. &gt; And there's the rub. My inner community-minded mathematician wants type theoretic types (at least Hindley-Milner but HoTT is even more appealing) and wants maximization of the classes of bugs the language is guaranteed to weed out. Meanwhile my inner community-minded non-mathematician wants abstractions everyone can collectively reason about and to maximize the diversity of the mental capacities and attitudes of the folk who can conveniently and cheerfully collaboratively participate. &gt; Immutability is one of several elements that sit at the heart of battles that my inner perspectives have been duking out for decades. That's a great counter-point, and it makes sense. Something like Haskell or those languages that go further than Haskell with complex types like Agda and Igdis. Though to be honest I couldn't tell you anything about the latter two other than the fact that they have dependent types. I tried using Haskell for some toy projects and bogged down on anything past trivialities. So I do see the conflict you laid out there, clearly. Clojure immutability focuses on persistent data structures. When you have a list or a map/hash and add another item, the original object is unchanged and instead you get back a new unchangeable collection with the new item. By convention and convenient syntax users are encouraged to use sets, maps (hashes), and lists for data and discouraged from using custom types - mutable or otherwise. I do remember our previous discussion on this. Thanks for answering my questions then and I hope you'll forgive me for raising the topic again. I'm jumping for any excuse to chat about this language, I really like it. (Now if only I could get a job with P6 that's as cushy as my current Java position...) I like your idea for the _ for immutable, I think it's a clean addition and quite readable. Cool. 
Python 2 and 3 are far closer than Perl 5 and 6 are.
There are two things I miss from prolog when programming in any imperative language: * Structure pattern matching, that's like perl regular expressions but applied to arbitrary data structures. * Being able to backtrack: having points on my program where I can say, I am going to try that strategy now but if it fails come back here and do that instead. On a higher level, those features allow one to implement search algorithms in an easy manner. In Perl, you can always implement the same algorithms but you would have to take care of the low level details. Have you ever tried to implement searching a string for a pattern in a language without regular expression support? It is the same.
I hope I can learn Perl6 a little bit quicker than I learned Perl5. ( hint: still struggling to learn Perl5. )
nope
All this talk of CPAN death and mourning is overly dramatic rubbish...Why can't MetaCPAN be seen as just an evolution of or an alias for CPAN? Then it wouldn't be dead, just reborn, resurrected and redirected.
Bad puns! I knew I loved the P6 community. Thanks for confirming I made the right choice.
On the topic of introducing people to Perl 6, my first look at the language in depth was Andrew Shitov's Perl 6 Deep Dive. I was impressed with the book and the language. But I'm not an expert in the language nor have I read any of the other books, so I can't measure them against each other.
Cpan isn't dying or being replaced. Search.cpan.org is a service that was run by a single individual that never released the source code, and hasn't been truly maintained for some time. Metacpan is much better in a lot of was but there's some nostalgia and sentimentality towards search.cpan.oeg given how long it's been around. Cpan is not, and will not be going away.
From what little I've heard, Perl 6 is an entirely different beast than any previous Perls
Started in late 90s, and I'm still learning! Albeit, I don't use it daily
Calling Perl modules/functions from Kavorka is also trivially easy. You don't even have to install an `Inline::` module to do so. Kavorka is bug-for-bug compatible with Perl, including XS.
&gt; there's some nostalgia and sentimentality towards search.cpan.oeg It's not necessarily nostalgia. Some of us prefer search.cpan.org's navigation.
This link should answer your question: http://jinja.pocoo.org/docs/2.10/templates/#whitespace-control
Include the newlines in the condition so when it's false they aren't output. a [% IF b %] b [% END %]c Or see the [PRE_CHOMP and POST_CHOMP](https://metacpan.org/pod/Template::Manual::Config#PRE_CHOMP,-POST_CHOMP) configuration options.
["You can add - or + to the immediate start or end of a directive tag to control the whitespace chomping options. See the PRE_CHOMP and POST_CHOMP options for further details."](http://www.template-toolkit.org/docs/manual/Syntax.html)
Confusing matters is that search.cpan.org is and was not CPAN despite its "logo". It's just one search engine for it, and metacpan is another one.
All previous Perls are Perl. Perl 6 is not. So, in that way, you are correct.
I would consider myself an expert and I still learn new things about Perl. It's how these things go. Recent thing I learned: the [sort](https://metacpan.org/pod/perlfunc#sort) function has very special-cased parsing that appears to be from Perl 4 days, as it assumes a bareword directly following sort will either be a function name or a string, and strict [doesn't catch it yet](https://rt.perl.org/Public/Bug/Display.html?id=133178).
@briandfoy, thanks, it helped. 
What makes it not a Perl?
It's not [Perl](https://www.perl.org) because it's a different and new language. Whether it's useful to refer to it as a Perl depends on context.
Putting a `-` at the end of your final directive will do that. a [% IF b %] b [% END -%] c
The obscure idiom if anyone reading in the future wants to know: my \foo = $ = 99; foo = 42; #Works; /u/raiph, how to deal with typos if there isn't a explicit declaration? _bar = 99; #bounds a deeply immutable alias _ber++; # typo bounds a new alias 
&gt; Why can't MetaCPAN be seen as just an evolution Please re-read [this subthread](https://www.reddit.com/r/perl/comments/8k1tk0/the_end_of_an_era_saying_goodbye_to_searchcpanorg/dz613yh/?context=3)
Nice.
What parts of Perl are you struggling with? This book might help: http://modernperlbooks.com/books/modern_perl_2016/index.html 
My two main languages are Swift (at home) and perl (at work, along with ruby and Java). Of course, I learned Objective-C first, then perl, then Swift. Perl applications vary greatly depending on what paradigm and modules you're using. Even going from Moose-based CLI apps to Mojolicious-based web apps was practically like learning a new language.
Why the switch?
https://stackoverflow.com/q/50842274 Lose the negative mindset, it's detrimental for getting stuff done. You should know by now that you get help if you ask specific questions.
Sorry to hear you're having problems. Post some specific stuff and I'm sure we'll help you out.
Yay, someone else read my comment! :) &gt; The lexically first use of a `_` variable is a deeply immutable variable declarator. Any lexically subsequent use is just a mention, not a declarator. The idea is more or less to combine: * a `no strict` mode that only relaxes for variables that start with `_`; * the first mention of such a variable is treated as syntax sugar for a `my` declaration of a sigilless variable; * just like a `my` declaration of a sigilless variable, this first mention must be followed by initialization with an `=` (or `:=` which means the same thing) and a RHS. * this declaration coerces the RHS to being deeply immutable. Even if someone makes it be a container, using the trick you've shown, that containership will be stripped as part of the processing of initializing the variable, disabling the trick; * so subsequent mentions of the variable can't modify it. So your `_ber++` is wrong in two ways, first because it isn't initialized, and second because the `++` will fail on an immutable value While I'm here, some updates about the idea: * No point in having a `._` method and lots of reasons not to. So scrap that. * This can presumably be done in module space first. I wonder if it's possible to have a module called `_` so one can write `use _` and have `_::` be the immutable functionality package namespace within the P6 ecosystem. * It would be nice if one could use this approach to create variables that also have a conventional sigil/twigil, i.e. `_@foo`. That would clearly require bending the language, but part of the point of P6 is to enable precisely this sort of language evolution to occur, and to occur in module space.
Thanks for the reply, I get it now.
I just edited my comment, presumably after you read it. Anyhow, I'm super interested in whether you think the idea has some merit. I haven't really thought it through. It just came to me as I was in the middle of writing my reply to Bob and I wrote it out as stream-of-consciousness. I'm about to write another such post in reply to Bob in a few minutes. Hope to see a reply from you there too. :)
I'm a grease bit monkey. I don't see any merit in theory until you show me how it actually works. No language with these properties that I have seen made asynchrony or parallelism any easier. But that's a problem with me, not with your ideas.
Thanks for replying anyway. :) 
Minor detail: [JSON](https://metacpan.org/pod/JSON) is not a "native" Perl package (it has never been core), it's just an unfortunately named module; [JSON::MaybeXS](https://metacpan.org/pod/JSON::MaybeXS) is better (and almost drop-in compatible).
I wanted to learn about the backend as well. And I talked about learning Angular but they pushed me to Perl.
Thanks for the link. I will check out tomorrow. The thing is I am working on an already existing project and it's framework is custom built by our company. So if I am stuck somewhere, I can't find it anywhere on internet. I have to ask everytime and it's embarrassing. 
I am not sure what to do with that stack overflow link? I was kinda seeking advice and experiences rather questions here.
Nice to hear that. I also started with Objective-C and then to Swift. Now to Perl. But Perl Syntax is getting on my nerves. Moreover I am so used to syntax and functions popping up on Xcode, It's very annoying in Sublime not to find anything for Perl. 
Hey thanks. I will post some specific stuff. :) 
10 years ago I needed mock company names for a test database. we think we can come up with names, but it's not that simple. I found a company that sold fake data. Names, contacts, addresses, etc. They sold it as a sqlite db file. 50MB was free. I used that.
Try VS Code with Perl plugin installed.
how about faker? it also play lol pretty well ;-) https://metacpan.org/pod/Faker
If you use $digit = int(rand(9)) Your digit will never be 9. 
Perl is a language that is very easy to write once you get the hang of it... but it can be very hard to read. It is not an especially maintainable language. It is excellent for short scripts that do one thing well. It is considerably harder for driving enterprise software. So if you feel a little lost, know it’s not just you, and it gets easier with practice. Make sure you understand @_ and $_ 
Intellij with the perl plugin will give you the most complete ide experience.
I remember it was more than 10 years ago when I first saw some Perl scripts at work. I was scared! Fast forward to 2018, and I'm a very happy Perl developer. After doing a fair bit of Linux shell programming, Perl suddenly looked elegant. I was no more scared by the $@% sigils. # The scary stuff Sigils. Especially sigil variance: `%h; $h{foo}; @h{'foo','bar'}` when addressing a container, the sigil changes according to what you take out of it. Context. Confusing but extremely powerful. `if (@a)` or `$size = @a` : an array returns its size in scalar context. Lack of strong typing. Many people are afraid of it, but it's a feature. No more `toString` boilerplate. Learn to work with values and nested data structures. Lists. Those temporary, anonymous things that are not arrays, but allow turning a function arguments into a hash: `my %h = @_;` They also allow easy copying of data structures `%h2 = %h1`, which is a complete nightmare in Python. # Useful stuff to learn Get rid of the line noise! We must use sigils, but you can get rid of other noise: quotes and parens. Word characters are auto-quoted in hash-addressing `$h{foo}` and before the fat version of the comma `%h = (one =&gt; 1, two =&gt; 2);` If you want to generate a list without quotes and even commas, use `qw(one 1 two 2 three 3)` Learn the various form of string interpolation. You can place scalars and arrays directly into double quoted strings: `"foo $bar @baz"`. If you must use double quotes inside an interpolating string, use `qq(&lt;node attr="$foo")&gt;`. Stay away from `Moose`. It turns Perl into another language, and managing its dependency list in a production setting is not something for human beings. Perl's native OO `bless` is good enough. Learn Perl's core functional features instead: `grep`, `map`, `List::Util` and closures.
\&gt; I have to ask everytime and it's embarrassing. Others here may disagree with me (let's see what the feedback is) but imo: * **Ask here at /**r/perl **any time you're curious or stuck**. You will almost certainly get several warm, creative, and/or useful responses. We tend to make sure each poster gets enough to make solid progress every time. If you don't feel you've gotten enough, please let us know. (**Apply patience** with both learning Perl and reading apparently "socially inept" responses. Both the language and members of the community tend toward being unusual helpful in reality, once you get to know it/them, but not appearing so at first. Our community leaders remind us to check judgment at the door and try applying insights like [this one](https://www.youtube.com/watch?v=Y24QnadqqJ4&amp;index=104&amp;t=230s&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK) but it's a learning process.) * **Make your** ***title*** **focus entirely on a** ***positive and/or broad goal*** that's driving the activity that led you to post and *leave any negative and/or narrow problem(s) to the body* of your post. In the body of your post, **minimize** [**the XY problem**](http://xyproblem.info/). This is a great habit to get into regardless of tech but Perl is particularly powerful and generalist, and many Perl devs are highly knowledgeable in hundreds of specific domains, so we all gain much greater benefit than usual from avoiding [unnecessarily compounding the problem](https://www.xkcd.com/1171/). (Joking aside, Perl regexes are great imo.) * **Consider cross posting at the monastery,** [**perlmonks.org**](https://perlmonks.org)**.** If you do, make sure to note this in both posts in either the title or the first sentence of the body. Here at /r/perl you get to use a modern UI but responses will typically be short and simple. At perlmonks you'll be using a UI that was cutting edge last century but you'll benefit from typically longer and deeper responses from the many monks there who have built up decades worth of Perl knowledge.
\&gt; I am working on an already existing project and it's framework is custom built by our company. Is this a really big company? Is it a really important backend? Do you think your primary problem is just getting to know Perl or does the framework seem poorly documented so you have two problems? Working with IT systems may be likened to dealing with forests and trees; and the Perl community may be likened to a worldwide association of folk united by respect for the Perl ["swiss army chainsaw"](http://www.catb.org/jargon/html/S/Swiss-Army-chainsaw.html) brand. If you *willfully* maintain a positive mindset in the face of apparent danger, difficulty, noise, and ugliness (compared to using a saw) and *skilfully* ask questions, then you will quickly discover it can be used safely, be a heck of a lot more productive than using a saw, and has its own appealing aesthetic, including its unique worldwide community. Are you trying to *sustain/develop a system* (be a [forester](https://en.wikipedia.org/wiki/Forester)), *exploit it en masse* (be a [logger](https://en.wikipedia.org/wiki/Lumberjack)), or *work surgically with a subset of its API functions* (be an [arborist](https://en.wikipedia.org/wiki/Arborist))? Can you imagine your company/boss bringing in a Perl specialist consulting company like [https://allaroundtheworld.fr/](https://allaroundtheworld.fr/) to help at any or all of these three levels?
Skip the "hard to read" stuff next time. Korean is also hard to read if you're not a korean, but super easy for a korean.
He's saying, and i agree, that your post fails to make it clear what exact question you're asking.
Why not use Data::Fake for simple stuff like e-mail, gender etc?
&gt; Is this a really big company? It isn't exactly a big company. Only 40 employees with 10 Developers out of those only 2 are full time. We had a full time developer who was my main go-to-guy. But he left for some personal reasons. Now the main go-to-guy left is our Co-Founder. &gt; Do you think your primary problem is just getting to know Perl or does the framework seem poorly documented so you have two problems? It's both. I don't know Perl and now the framework and code has no comments in the whole project. And top it off no one really explained the workflow of the project. The documentation is in foreign language which I don't understand. &gt;Can you imagine your company/boss bringing in a Perl specialist consulting company And right now they are I think in process of hiring a Full Stack developer. Your both answers are near to perfect. 
Hi again, &gt;some class holds a list of objects and someone absentmindedly makes the class method getList() return a reference to the original instead of a copy. 99.5&amp;#37; of the time... That kind of thing happens periodically with Lists, Maps, and Sets in Java. Lists, Maps, Sets, Bags, Mixes, ... are (shallowly) immutable by default in P6. The only two composites that are (shallowly) mutable by default are Arrays and Hashes. One could introduce a pragma that makes `@` and `%` variables use their immutable siblings by default and hoist that to the default setting for a particular project or all projects of a given compiler, team or company. &gt;\[in java\] it's common practice (syntactically convenient) to build objects with mutable instance fields and a few methods.... periodically some method that assumes all instance fields have been initialized will be run before all initialization happened In P6: The standard object construction process is blocking/synchronous, with attributes (fields) initialized starting from the root class (`Mu`) , and then walking the inheritance tree up to the leaf class, such that the object is fully initialized by the time \`new\` returns unless a class deliberately wants to delay some of its initialization till after the object is shareable. So the only way that non-construction methods might be called on a not fully initialized object is because the class designer(s) wanted it that way. For the rare classes that deliberately choose to delay some of their initialization until after `.new` has returned, class authors ought to realize they can't just write non-construction methods without paying attention to whether the initialization has been completed. In the ultra rare case that a class's `.new` defers initialization but a non-construction method does not guard against incomplete initialization, the attribute will still have the default initialization that all P6 attributes and variables always have, namely the type object corresponding to the attribute's / variable's type. Any attempt to use that attribute will lead to a good error message and typically graceful failure mode behavior. &gt;some code tries to write to a file handle or query from a database connection that was already closed How on earth does clojure avoid the problem of, say, a socket connection unexpectedly dying? 
If Perl's syntax is getting on your nerves and you like IDE env, why even stay at this job ? Perl is extremely beautiful and powerful language but it's not for everyone. If it frustrates you, just look for another job. It's quite hard to go outside of your comfort zone and actually learn new stuff. As far the most effective way to learn Perl is just do perldoc perl and then traverse the tree of the perldoc pages. 
That sounds rough. Thank you for asking here for help. Does your co-founder definitely like Perl? Do any of the other 10 devs? Did no one want to deal with it and you said "I can do this"? What do you stand to win or lose by staying the course? Same question for going back to Swift? \---- Summoning /u/ovidperl, Hi Ovid. This situation sounds way too unstable for your company but maybe you could provide some guidance for Jon if not the company he's working for, either here on /r/perl or privately?
[removed]
I use perldoc.perl.org frequently. I'll be bookmarking this. How about linkifying functions and keywords in code examples like on perldoc.perl.org? For example, http://perldoc.perl.org/functions/splice.html The code example at the bottom, links "my" and "shift" on line 2, etc.
I thought about this, but this linking is actually broken in some places on that site due to changes in perlfunc between perl versions. I special-cased links on `perldoc perl` so it can act as the "index", but I'm wary of doing more general rewriting across the site, it adds complication and a maintenance burden to all pages where I feel that one could just type a function in the search bar to go directly to it. But it's not off the table, I will continue to consider it if it's highly requested.
Changes: https://perldoc.pl/perldelta
&gt; Lack of strong typing. Many people are afraid of it, but it's a feature. And the magic that makes it work, different operators for string and numeric operations that force interpretation to be what you want. Until you understand this, it just seems like cruft that there's both == and eq, != and ne, etc. Beyond that I think the number one thing that people sometimes never internalize and either muddle along or give up before understanding is context, as you noted. A tutorial that went into a bunch of assignments between hashes and lists, with maps and greps thrown in to show why it's useful, would go a long way towards showing the utility and of how that works, and why I continuously miss it in other languages.
this is not specific to perl, unless you're asking for somebody to do your homework for you.
 $&gt; perlbrew install perl-5.28.0 ... 20 minutes after ... $&gt; perl -E 'say "Hello from Perl $]"' Hello from Perl 5.028000
BTW, is "perlbrew available" working for you guys? It's not returning any result on my laptop here since a few of days ago I tried.
It's just 4.5 minutes over here with `perlbrew install -j4 -n perl-5.28.0`, and almost 1 minute of that is downloading.
Total count of lines of changes: 730000 TL;DR: - Unicode 10 instead of 9 - bitwise operators on integer vs. string no loner experimental (!?) - The experimental subroutine signatures feature has been changed so that subroutine attributes must now come before the signature rather than after. - ... I believe that's it. I'm not impressed. 
I presume in P6 it's possible - though uncommon - to define objects with instance fields and then a constructor that leaves them blank, and a series of accessor methods for initializing the fields. That design approach is shockingly common in Java, and I think it's absurd - any time I'm defining my own class, I set up the constructor to require all of its instance fields and even sometimes do some basic sanity checking on those fields and throw a detailed error if anything is wrong. If construction finishes, the object is good forever. Hopefully the P6 community is too bright to repeat that particular bizarre Java habit. Clojure doesn't have any magic for handling a socket connection unexpected close. That kind of problem is a source of frustration for me, but I was wrong to present Clojure as a solution. In our own code sometimes we have code that passes around a socket object, and every once in a while someone - including me at times - just introduces a logic error in which we close the socket ourselves and then try to send or receive data on it later. My weak understanding is that something like Rust's lifetime monitoring of variables would detect that kind of logic error at compile time.
I like wait for the tests results.
I suspect there are still a lot of perl monolith applications out there that were started more than a decade ago. I suspect there are quite a few python monolith applications out there as well that are hard to maintain. It sounds like they made some good choices in redesigning their infrastructure to be more maintainable and scalable. I just get disappointed that they imply in the title that Perl was part of the problem. Python and Go don't stop you from building a giant monolith, just as Perl doesn't stop you from doing it. 
The fixed version hasn’t been released yet: [https://github.com/gugod/App-perlbrew/issues/617](https://github.com/gugod/App-perlbrew/issues/617) You can edit your local perlbrew (find the path with `which perlbrew`), go to the subroutine `available_perls_with_urls`, and change the regex containing `http://www.cpan.org` to `https?://www.cpan.org`
So one Perl application was doing the equivalent work of 500 Python+Go microservices? nice! (I didn't see a proper breakdown of that list linked from the article)
Interesting, I don't see it in my \`perlbrew available\`.
It's not homework. I work at a company and programming isn't a side task I have to do occasionally, so I'm not strongest at it. I am using perl. 
for some of us, fixing bugs and improving performance is more important than new features
it's odd the fix uses an unecessary group `http(?:s?)` instead of the more natural `https?`.
Agreed. I don't use a bunch of the existing features of perl. Rather than more new features (that only have some percentage chance I'll use) I'd much rather have performance and bit-rot improvements. Maintaining a project sometimes means rewriting old code, in a better way, so that it does the exact same thing it used to. Not new, not faster, not a bug fix ... but very important for maintainability. Its like re-pouring a concrete foundation so that its more stable and can be built upon.
&gt;In addition to scaling issues BuzzFeed were finding it harder and harder to find engineers who both knew Perl and wanted to work with it. Yep. There's the standard reason again :-)
More like: "who were willing to be paid a pittance"
Why in the heck would you ignore this? &gt; delete can now be used on key/value hash slices, returning the keys along with the deleted values.
Also notable: * default hash function changed from siphash to several more performant but still secure options. * in place editing with perl -i now does a tempfile + rename so as not to clobber the file if an error occurs * the [multiconcat op](https://perldoc.pl/perldelta#Performance-Enhancements) speeds up *almost every string assignment and interpolation in Perl*
&gt; bitwise operators on integer vs. string no longer experimental I'm not sure what's confusing about this: the 'bitwise' feature was introduced as an experimental feature in Perl 5.22, and an experimental feature can be promoted to non-experimental after it's been unchanged in two releases of Perl. Since it's no longer experimental, it's also part of the default [feature](https://metacpan.org/pod/feature) bundle for 5.28, which is used by [use](https://perldoc.pl/functions/use) and the [-E](https://perldoc.pl/perlrun#-E) switch to Perl. If you're confused about the feature itself, it fixes the bitwise operators which are currently one of the only remaining sets of operators that (like the smartmatch) depends on the internal state of its operands for what it does. Instead the new operators will coerce to string or number behavior depending which you use.
Alternatively as mentioned at https://rt.cpan.org/Public/Bug/Display.html?id=125553 perlbrew --all still works.
See the other thread by perlancar.
Indeed. It's more about what your available engineers are comfortable with. Personally I would first reach for Mojolicious to write 500 microservices, as many of them would probably make good single-file Mojolicious::Lite applications.
Get the book "Learning Perl" and be sure to do the exercises. A proficient software dev could do it in a weekend. Then check out a perl web application platform like Mojolicious: https://metacpan.org/pod/Mojolicious Hope you stick with perl, in my opinion its the best general development platform available and I've been paid to code for almost 20 years now. 
I know it makes me so sad. This is a perfect example of perl's marketing problem. This should be announced as "Radical new upgrade with tons of new amazing features coming the the CPAN infrastructure!!! Look how we're growing!!!" instead of the "An end of an era." stuff. 
I fixed it in my local version. It still doesn't show me the new one.
This will likely require the use of some basic [trigonometry](https://en.wikipedia.org/wiki/Trigonometry).
**Trigonometry** Trigonometry (from Greek trigōnon, "triangle" and metron, "measure") is a branch of mathematics that studies relationships involving lengths and angles of triangles. The field emerged in the Hellenistic world during the 3rd century BC from applications of geometry to astronomical studies. The 3rd-century astronomers first noted that the lengths of the sides of a right-angle triangle and the angles between those sides have fixed relationships: that is, if at least the length of one side and the value of one angle is known, then all other angles and lengths can be determined algorithmically. These calculations soon came to be defined as the trigonometric functions and today are pervasive in both pure and applied mathematics: fundamental methods of analysis such as the Fourier transform, for example, or the wave equation, use trigonometric functions to understand cyclical phenomena across many applications in fields as diverse as physics, mechanical and electrical engineering, music and acoustics, astronomy, ecology, and biology. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I'd like to see a benchmark of: my $hash = EVAL "{}", :lang&lt;Perl5&gt;; ... though from skimming the bug report, it might be better to abstract that away behind a function.
I think that is because it's not listed yet on the CPAN pages which perlbrew checks for available perls. https://www.cpan.org/src/
Thanks for the tip. The output of "available --all" really needs to be sorted though.
I'm still waiting for your reply...
Well, I'm sure they have engineers at all experience levels. The problem that Perl has currently seems to be that we've all been around so long that we're all "senior developers" or similar. There just aren't enough junior developers who want to write Perl.
I would have used `m{ http s? : // www [.] cpan [.] org }x` ... if I wanted to point out that `https` is optional. Also, escape the dots in patterns.
Assuming that you want to generate a parallel line of the same length as the original but translated in a direction perpendicular to the original line so that connectting corresponding endpoints creates a rectangle, here's what needs to happen. You need to first determine the angle of the original line. Then depending on which direction you intend to translate the new line, you will need to generate new endpoints from each endpoint in a direction of either plus or minus 90 degrees with respect to the original angle.
That doesn't make a `Hash` tho: $ ./perl6 -e '(EVAL ｢{}｣, :lang&lt;Perl5&gt;).^name.say' Inline::Perl5::Hash 
Seems like it [`does Associative`](https://github.com/niner/Inline-Perl5/blob/master/lib/Inline/Perl5/Hash.pm6) though.
It's always important to consider that the technical merit of your argument or advice is not usually as important as how you deliver it.
[annotated slides](https://archive.org/download/yatpc2018-ecosystem/03-yatpc2018-ecosystem-with_speaker_notes.pdf) (PDF, 27 MiB)
Thanks - from a brief skim through, this seems to be "everyone should be nice to each other, and the perl leadership should do more to encourage it"? We can't even manage that on perl5-porters without devolving into metadiscussion about the conduct rules, so I think expecting the "perl leadership" to fix this is somewhat unrealistic.
Since you're using Mojolicious, you should be able to use hooks to achieve what you're looking to do. Particularly, the `after_render` hook. https://mojolicious.org/perldoc/Mojolicious#HOOKS https://mojolicious.org/perldoc/Mojolicious#after_render
* http://p3rl.org/Plack::Middleware::HTMLMinify * http://p3rl.org/Mojolicious::Guides::Cookbook#Plack-middleware
Try [this](http://tpcg.io/uynzFP). The code merely takes your line as a string and the the amount to extend the line by, finds the angle of the line required and simple trigonometry to yield the appropriate new coordinates, which is returned as a string. The result is unrounded...that is left for you to do as needed. # # Extend Line Program # print extendLine("0 0 0 4",1); sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient }; return join (" ", ( $x1-($extension*sin($theta)) , $y1-($extension*cos($theta)) , $x2+($extension*sin($theta)) , $y2+($extension*cos($theta))) ); } 
The -all flag caught it last night. All done. :) 
[relevant xkcd](https://www.xkcd.com/224/)
Taking that middleware as inspiration, you can also use HTML::Packer directly in an after_render hook while still using standard deployment so you get async features.
And here I thought it was THE [SCO](https://en.wikipedia.org/wiki/Santa_Cruz_Operation).
**Santa Cruz Operation** Santa Cruz Operation (SCO) was a software company based in Santa Cruz, California which was best known for selling three Unix variants for Intel x86 processors: Xenix, SCO UNIX (later known as SCO OpenServer), and UnixWare. Eric Raymond, in his book The Art of Unix Programming, calls SCO the "first Unix company". Prior to this, some prominent Unix vendors had been computer hardware manufacturers and telephone companies. In 1993, SCO acquired two smaller companies and developed the Tarantella product line. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Same here, thanks for saving me from going down a [Groklaw](http://groklaw.net) rabbit hole.
This sounds like a classic example of what Perl was made for.
And what about [https://metacpan.org/pod/release/NEVESENIN/HTML-Packer-1.004001/lib/HTML/Packer.pm](https://metacpan.org/pod/release/NEVESENIN/HTML-Packer-1.004001/lib/HTML/Packer.pm) ?
this one [https://metacpan.org/pod/release/NEVESENIN/HTML-Packer-1.004001/lib/HTML/Packer.pm](https://metacpan.org/pod/release/NEVESENIN/HTML-Packer-1.004001/lib/HTML/Packer.pm) you mean?
I object to abbreviating "search.cpan.org" to "SCO". That name is foul, don't use it. Ever.
I'm german and until 1989 was restricted to what technology the east-bloc allowed. SCO means nothing to me other than the original cpan search.
Super depressing talk, talking about extinction of Perl and offering a solution that I don't believe would make a significant difference.
This seems to have gone well. Currently, [a Google search for "perl conference"](https://www.google.co.uk/search?q=perl+conference) returns the Glasgow site as the first result. Now I want to try to get some results snippets on the result page.
https://en.wikipedia.org/wiki/SCO_Group#Legal_battles https://en.wikipedia.org/wiki/SCO%E2%80%93Linux_disputes This was in early 2000s, I'm quite sure this dispute was covered in media all over the world so perhaps you were not involved in open source back then or simply forget? TLDR: SCO was the "enemy" of Linux (and open source in general). Microsoft helped.
German news really didn't care in the early 2000s, but yeah, i was also just going through college. &gt; SCO was the "enemy" of Linux (and open source in general). Microsoft helped. Thanks!
Cross-post: https://stackoverflow.com/q/51045626
I don't think you can expect a great answer with so little information. What are you trying to do? Use the module in your app? Distribute your app? Which system or method of distribution are you using?
so what?
(Dependency management is unrelated to Mojo itself) But a good first step is to use a cpanfile which declares the dependencies and then use cpanminus to install them. https://github.com/kraih/mojo/wiki/Installation-of-cpan-modules-by-cpanm-and-cpanfile This is actually a much larger topic, because at some point you'll want to deal with module versions in various environments (dev/test/prod) to ensure the code you installed and tested is the same as is being deployed. But start with cpanm.
As mentioned it's hard to give advice without knowing what OP is trying to make it a dependency *for*, but cpanfile is a good first step that can be reused by any future process.
http://www.javaprogrammingforums.com/cafe/6776-problems-cross-posting.html
RIP
i won't
Cross posting is rude, disrespectful to the people you're asking to give you free help, and generally frowned upon. If you want to be ignored and/or banned, go right ahead and keep doing it.
be nice open source it now that it's defunct.
No one really cares about that code, metacpan.org is as good or better. All of this "Say Goodbye" stuff has been bugging me for awhile now-- all this means is if you go to search.cpan.org you'll get re-directed to metacpan.org, which a bunch of us have been using already, anyway.
All good points. I don't much care about *perl* in general these days, so I understand your sentiments. That said, it would be cool to see what it looks it. And, PerlMonks. It has historic value. ;)
you idiot? I'll continue cross-posting 
Indeed he likes Perl a lot. I said to them like 15months ago that I want to work on Angular if you guys have some project. Now all of a sudden since they were short on employees. They put me on Perl. Nevermind I am thinking to ask him to switch me back to Swift. We will see what happens. 
I can't find dependency graphs on metacpan.
Right hand side, bottom option.
Please reread [this subthread](https://www.reddit.com/r/perl/comments/8k1tk0/the_end_of_an_era_saying_goodbye_to_searchcpanorg/dz613yh/?context=3)
&gt; metacpan.org is as good or better [No.](https://i.imgur.com/VollUfs.png)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://i.imgur.com/VollUfs.png) - Previous text "No." ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
&gt; All of this "Say Goodbye" stuff has been bugging me for awhile now It's about showing respect to people who wrote and supported code for over a decade that served us all. It's common human decency.
That graph didn't come from metacpan. What is your point?
&gt; Why is it going away? Because its author and owner doesn't want to support it anymore. &gt; Surely, if people are able to look after it, then it should stay. Perhaps, but that's not our call, it's the author's.
&gt; That graph didn't come from metacpan. Technically correct, but irrelevant because Metacpan clearly appropriates the diagram, even more so than s.c.o did with its counterpart. &gt; What is your point? The text is barely readable, the diagram is indecipherable. It is objectively inferior. Does this really need pointing out?
They are still working on it. Perl 6 used it in the past but development on there stalled and was removed at some point. /u/reini_urban can tell you all about it.
thanks. I'm satisfied. Personally I would prefer a tree type diagram but I guess beggars can't be choosers.
The old team rendered it into unusability. Then when Perl 6 took shape I took it over and started fixing most of the destruction. Just the runloop, jit and calling convention reversal was missing, when Perl 6 decided to remove it, because they had a much better VM in the meantime. Parrot advantages were still worth keeping it, esp superior platform and concurrency support. And the removal is still fixable. There's still the middle layer nqp to support multiple backends. Also v8 or tvmjit. They still can add it later, but I stopped working on it and rather came up with my better backend P2, and decided to add most of the perl6 features into perl5 instead, under cperl. This is so far the most promising and realistic prospect for a future Perl.
Contrary to s.c.o., MetaCPAN is open source. Patches are welcome, afaik!
With 8 commits by the same person in the past 2.5 years since the last official release, I don't think you can say that people are still working on it.
Why is that good for Perl 5 or Perl 6?
I'm not sure why you are bringing Perl 5 into this: the PONIE project was already long gone by this time. It was good for Perl 6 because: * there was a lot of PIR code in Rakudo Perl 6 that was needed to get e.g. loops to function with some efficiency. * if you would have a non-ASCII character in your code, parsing would get into some kind of complicated state, that would slow down parsing significantly for "normal" programs. And which would basically make parsing of the setting waiting fo the heat death of the universe (one time I have let it run for several **hours** before giving up: normally the setting would compile in about 5 minutes) * the semantics of Lists needed to be changed before Christmas (aka the Great List Refactor). This would also mean having to refactor the hot PIR code that nobody had touched for years by that time. Since progress on Parrot had basically ground to a halt by that time, it was decided to not invest in one more backend (apart from the JVM and MoarVM backend at that time), but instead use those resources on furthering the JVM and MoarVM backends.
You need to put two spaces at the end of a line, otherwise markdown gets rid of it.
If you think of Perl as a family of languages then Perl 6 is just as much Perl as Perl 5, or Perl 4. If you think of Perl as a language that had several major revisions but maintained backward compatibility, then Perl 6 is not Perl.
Why is rolling perl6 into perl5 in a forked project good? Well, it's probably not good because cperl isn't perl5. But, it's good because it leaves open a path a later point in time for perl5 to suck substantially less and leaves users with an upgrade path, and a huge code base. Perl6 on the other hand is simply *another* language. It's largely a failure by any measure, which is why if you go back 10 years ago to a YAPC conf and find the people talking about Perl6, you'll find a large percentage of them have moved on entirely: the pastures are greener now everywhere. c99 and c11/rust/node/haskell, though Randal jumped ship to Smalltalk.
You need a blank line between a paragraph and a list, e.g. \* bullet 1 \* bullet 2 More text.
Ha!
People stopped working on it [for various reasons](https://www.reddit.com/r/perl6/comments/8p26bb/is_perl6_faster_than_perl_5_on_average/e0df6jq/).
Curious. I slightly see the point, but different forums have different audiences and you will get completely different replies in each. I cannot imagine taking umbrage at a simple cross-posted question; certainly it was common in late 1980s Usenet days. OP did nothing wrong.
Well, Perl was created for religious reasons, but that too.
Contrariwise. Different forums have different audiences and you will get completely different replies in each. I cannot imagine taking umbrage at a simple cross-posted question; certainly it was common in late 1980s Usenet days. OP did nothing wrong. I do resent folks being rude to newcomers here, though. Are we here to attract folks to Perl, or drive them away? On behalf of the Perl community, please accept our apologies, /u/ajmi3388 . 
I'd point out that the initial comment was not rude, it was just providing a link for the missing context I mentioned earlier. The later posts were an explanation of why it mattered, to which the OP was rather rude.
In what world is JavaScript a scripting language? WTF have you been the past 10 years?
You haven't answered OP's question, though. 
What are you identifying as the question?
An argument about a technical resource in the collective good that reduces to authoritarianism oriented around an individual is a pretty shit argument if you ask me, especially when that individual is not being requested to do the work themselves, merely hand the keys to somebody willing to do the work.
Well, why are you mentioning languages that are not scripting ones in order to build an argument opposing OP's. 
You're demanding someone give up their personal property, and you call *them* authoritarian?!
&gt; Does this really need pointing out? I guess so, because I didn't know what you meant, at all. I think the graph comes from Pinto. You should take it up with Jeffery, rather than blaming the metacpan folks.
I replied at https://www.reddit.com/r/perl6/comments/8p26bb/is_perl6_faster_than_perl_5_on_average/e0qdbiz
http://modernperlbooks.com/mt/2013/02/goodnight-parrot.html
Interesting that the new Groovy 3.0- parser is also called Parrot...
cperl is perl5. cperl runs CPAN code and all perl5 code. cperl is the continuation of perl5 maintenance and development, which stalled when Larry left and switched over to perl6. p5p is in happy talk mode, similar to rust, and continues its destruction. They also never ever added any perl6 feature properly. perl6 is another language because it choose to break backwards compat with a few simple concepts. cperl not. Some perl6 terms had to be translated back to perl5 terms. E.g. cperl uses attributes for what perl6 has now special and unnecessary syntax. This is not important. But most perl6 features blend nicely into perl5: types, classes, given/when, special BLOCKS, concurrency. That's why we call it perl11: 5+6. Just some new perl6 designs are so ugly, that I have to think it over more closely: match and macros. This is just insane, and can be done much better. Modern C/C++ is indeed a big step forwards, Rust and node not so. Haskell got much better recently.
Nobody talks about Ponie. I was talking what I did next after Parrot. Which is implementing most of perl6 in perl5. Since perl5 is stalled and going down, and perl6 is also descending into its nice looking but super-slow niche, nobody wants to bother with.
Nope, a conversation more complex than "but I want to kill it, fuck you all, waaah, I'm telling mooom" would be a good starting point.
I should note as you can not see it in the code block, $volume = "\[volume icon\] $volume"; so when the index looks for if 100&amp;#37; exists in the string it looks for "\[icon\] 100&amp;#37;" was having trouble with the click event 5 (mouse scroll down) as when volume at 100 90 80 70......... it wasnt working as finding 0&amp;#37; in the string...... you see what was happening lol. so added the icon to the string and that fixed it. i wanted to use if ($volume eq '100%') but that wasnt working for some reason. didnt spend a lot of time on it so just went with index()
What are some of the things that makes these languages a step forward / not? Especially, what made Haskell better?
&gt; super-slow Why don't you base your opinion on facts instead of just giving opinion as if you knew what you're talking about?
Current Rakudo Perl 6 on the MoarVM backend is at least one magnitude faster than Rakudo Perl 6 based on Parrot. If Parrot was so "fast", how can you now say that Rakudo Perl 6 is in a "super-slow niche"?
I don't get the humour.
See, "our" declares public variables. they're nonprivate and global in scope. Which is why the communism joke is funny here. 
You have Pulseaudio, so use `pactl` instead of ALSA mixer.  is not a volume icon, but [private use](http://enwp.org/Private_Use_Areas). For other people it either just appears as a placeholder or fallback, or all kinds of different glyphs. The speaker characters should work better: * 🔇 `\N{SPEAKER WITH CANCELLATION STROKE}` * 🔈 `\N{SPEAKER}` * 🔉 `\N{SPEAKER WITH ONE SOUND WAVE}` * 🔊 `\N{SPEAKER WITH THREE SOUND WAVES}`
Patches welcome! And I mean that in the nice, "we'd love the help" kind of way. :)
&gt; Patches are welcome, afaik! Can confirm!
Jeffrey was kind enough to provide this graph for us. What we had before this in terms of graphs was... nothing. If there's something that can be done to make it more readable, maybe he has some time to work with us on that. I don't know what the status of his project is, but it's worth mentioning to him if you feel strongly about it.
I guess I expected the happy face in the `my` case, rather than the `our` case.
Communism is evil.
I'm glad I wasn't the only one.
I can't think of anyone who would agree with the statement **cperl is perl5** because agreeing with that means that **forking** and **being** are the same thing; cperl is perl5 only because you decree it. I'm not saying that it's not technically better in every way, but you don't own the term "perl5" (unfortunately). The "Perl" Conference has no talks on cperl in 2017/2018 (that i know of). No distribution ships cperl as perl5. That's not to say you're not backwards compatible, but it's a different thing: "forking" doesn't exclude backwards compatibility. As for me, I can't defend Rust. But, I do like me some Node. For most of my "getting stuff done" problems it's my first-grab. It's ecosystem has surpassed all others, and the rate of language design with ES6,ES201[6789] is by any measure eclipsing most other languages.
Pure and utter idiocy.
They seem to be mixing the Drake meme which normally would have the order you’re suggesting with the space brain meme where the further down the list you go the more inane/crazy/foolish the solution becomes. I think they did this for humorous effect along with the overlay of the hammer and sickle to suggest communal sharing of state was more politik. 
Completely and utterly fucking worthless dipshittery.
Fuck off with this worthless, idiotic bullshit.
Yeah, it was not a good joke. The other way around would have been better. 
Report it, comrade. 
Reini thinks changing language semantics to make implementation easier is the only "technical" solution. Therefore cperl will never be perl5.
definitely - prl is srs business, please to not be joking around
Reini could think the earth was flat and gravity didn't exist and he'd still be more right on language design than perl5. He's got optional types and type inferences. On technical matters, he wins with a grand golden mic drop.
I'd wager much of what they say is based on facts. Now whether or not their combined implications will manifest in what they claim is debatable. I'm not qualified to weigh in on the conversations I've seen of theirs, but I've seen them make sound arguments. I know it takes a fair amount of effort to compose highly technical detailed responses -- I wish they would write up such things more often, but can empathize with not wanting to ( there is very little in it for them to do this vs the time sink involved ). One interesting conversation I remember within the last couple years ( that I cannot find a link to ) was about spillage in the JIT. I'm not sure which side was more technically correct, but it was interesting seeing things being challenged none-the-less.
Gee, if only there were someone who spent time optimizing Rakudo and Parrot who had an informed opinion about why Rakudo ran terribly on Parrot (which ran other languages pretty well) who had written up his findings and a plan for addressing them back in 2010....
Hey, [you also wondered publicly if I wanted to undercut donations to the Perl Foundation to sabotage Rakudo or something](http://colabti.org/irclogger/irclogger_log/perl6-dev?date=2017-10-27#l292), so there's that.
I don't disagree with you at all, but cperl is not perl5 nonetheless.
I was just using his own argumentation techniques to see if I could rile him up.
Usenet, they were marked as cross-posted so you knew to only reply in one place. *That* I don't mind nearly as much. Blind cross-posting that, IME, often results in people giving the same replies in multiple places, thereby causing duplication of effort, OTOH, irritates me no end.
Why does it matter whether something is a "scripting" language? Many people who might have considered Perl6 have found alternatives for the code they wanted to write - seems a simple enough observation.
Xah Lee disapproves.
The joke is that communism is all about shared property and frowns on private property, so our is preferred over my.
I am not going down this path. Have a good weekend, bud.
Have you not read what that donation was about?? (I will donate $100 to the Perl Foundation if this sub goes two weeks (starting tomorrow) with no mention of this renaming garbage)[https://www.reddit.com/r/perl6/comments/78txh8/xpost_perl6_should_be_renamed_perl/doydt90]. Which was a reaction to the incessant discussions about Perl 6 needing to be renamed. Of which you are one of the most prominent proponents. Don't you recognize tongue-in-cheek? I know the Perl Foundation is grateful for every penny they get, and $100 would buy 2 hours of Jonathan. But it would be a small donation still, and not very serious. In any case, you are right, I shouldn't have said that. It was a emotional reaction to emotional reactions. I should have been a better person. I will not refer to you in any online discussion in the future, except in direct reactions.
&gt; Which was a reaction to the incessant discussions about Perl 6 needing to be renamed. Of which you are one of the most prominent proponents. When was the last time I started one of those discussions? People know my opinion. The one person who can do anything knows my opinion, and it hasn't changed his mind. I don't see any value in bringing it up out of the blue. &gt; I will not refer to you in any online discussion in the future, except in direct reactions. Thank you.
&gt; most perl6 features blend nicely into perl5: given/when Are you sure about that? 
As long as jokes aren't actively harmful to someone, they're nice to see here. As such, to the person who reported this submission: Nope, this'll stay.
Who is that?
Keep your right-wing stuff to yourself, bye.
You don't get the meme. 
Bit of Perl ancient history. Xah Lee is a smart guy, but he insisted on everything being completely serious at all times. He criticized The Camel for having jokes in it. His old Usenet and IRC messages are a treat, in the same way as the Mall Ninja, or Enter The Cow-orker. IIRC, he went over to Python and did the same thing. When your language is named after a British comedy troupe, being super serious works even less than it does with Perl.
The only way I can think of, with the current spec (https://metacpan.org/pod/CPAN::Meta::Spec#PREREQUISITES) is to split out the dependency-specific parts into separate distributions, and warn your users to install one, a bit like DBI and the DBD modules are split.
And here's the corresponding code, sample `Build.PL`: use Module::Build qw(); sub probe_runtime_alternatives { # Substitute this with a real check. return rand &gt; .5 ? 'Alternative::A' : 'Alternative::B'; # This code runs at "configure" time. # If you depend on other modules for this # phase, add to "configure_requires" below. } Module::Build-&gt;new( module_name =&gt; 'Foobar', license =&gt; '...', dist_author =&gt; '...', dist_version_from =&gt; 'lib/Foobar.pm', configure_requires =&gt; { 'Module::Build' =&gt; 0.42, }, requires =&gt; { 'Test::More' =&gt; 0, probe_runtime_alternatives() =&gt; 0, }, add_to_cleanup =&gt; [ 'Foobar-*' ], )-&gt;create_build_script; # Run "perl Build.PL ; ./Build distmeta" # to create metafiles. Make sure they have # "dynamic_config: 1" set in it. 
It's actually an irrefutable fact. Hundreds of millions killed by communism. Also, I'm not "right-wing", but you would say that, seeing as you have to vilify everyone who disagrees, thereby making it so you don't have to address anything they say. Bye :)
I do get the meme.
Thanks for the clarification. Let me say that parent commenter overreacted, and my response was, well, a joke too.
Ok, that's an interesting tidbit. :D
You very obviously don't. 
And yet, I do.
Please knock it off, both of you. Humor is subjective. Unless you're actively mocking people, a joke isn't good or bad, it just worked for you or not.
Thanks. I really was curious about how /u/elbitjusticiero thought I didn't get the meme, though. For science.
open an issue here: https://github.com/rizen/Facebook-Graph/issues
This is primarily in reference to https://perldoc.pl/perl5280delta#Mixed-Unicode-scripts-are-now-detectable, a feature [long in the works](https://groups.google.com/d/msg/perl.perl5.porters/5orbYJ4ILlM/qXcpjFwpAgAJ) by Karl Williamson.
Very confusing article. Is it talking about Perl or Perl 6? These are different languages.
Using a search like '&lt;language&gt; tutorial', in the best case, returns you the amount of new users that some language is getting or how difficult it is to find resources for through the canonical web page of the project. If I just look for 'perl' on Google (Italian version) as the second and fourth results I find two introduction tutorials in Italian (one of the two from an university). Just completeness, I do not believe in the TIOBE index either.
Which switch makes it fail? Find that and file a speculative bug.
Am I hallucinating, or are all of those lines trending down?
That's because no popular languages were included in the graph... [https://trends.google.com/trends/explore?date=all&amp;geo=US&amp;q=python&amp;#37;20tutorial](https://trends.google.com/trends/explore?date=all&amp;geo=US&amp;q=python%20tutorial) Plus Google Trends normalises to the max search value period for the 100&amp;#37; which is frequently around when languages first appear.
there are many
I wouldn't know where to start putting that into Catalyst. Somewhere in the view I guess.
Bingo. http://grokbase.com/t/sc/catalyst/1198j9ycqz/compress-html
Is it intentional to use Perl refer to perl6? 
I think the point was that Google apparently doesn't distinguish between "Perl Tutorial", "Perl 5 Tutorial" and "Perl 6 Tutorial" ?
Searching "Perl tutorial" will yield way more results than "Perl 6 tutorial". I've yet to see any demos of Perl 6 out there unless you pointedly look for them, while I do see Perl stuff regularly. Big difference.
I don't think the number of people who want to learn a language, whuch what searching for a language tutorial gets you, is representative of the viability of that language. Instead, you should measure the number of people who keep using a language once they're past the beginner stage.
Apparently, Google uses keywords, not a mind, so there is no intention there.
He talks interchangeably about Perl and Perl 6, but I think the answer to his question depends greatly on which he means. Perl has been an invaluable tool for me for over 20 years. To me, it's "viable" as long as I can expect it to be available as packages or compileable on any systems I'm likely to work on. I'm completely confident that that is the case. Even if development on new features stopped -- even if it had stopped back around 5.8 or 5.10 or so -- I'm confident that there's enough of a userbase to ensure that it continues to be viable for my use. I don't think there's much chance that I will outlive Perl. Perl 6, on the other hand, is a more open question. I've tinkered with it and found it interesting, wrote some blog posts about it, but didn't find it *useful* for me, so I drifted away. I'll probably try it again one of these days, as I've been doing every couple years since I first heard of it. My impression (which could be wrong) is that there's a large overlap between people *using* Perl 6 and those *developing* Perl 6. In other words, I don't know if there are many people who have picked up Perl 6 as a tool, without any investment in the language itself. So if a handful of the main developers drifted away from the project, I don't know what would happen. If I write a program today in Perl 6, I don't know what the odds are that people will be able to use it 5-10 years from now, or what hoops they might have to jump through to get it working. I don't mean that as a slam on Perl 6. They're just two different languages at different stages of development, so I dont think you can lump them together in terms of viability.
&gt; How to fix that? AMP is invalid HTML. [Complain at its vendor](https://github.com/ampproject/amphtml/blob/master/CONTRIBUTING.md#reporting-issues-with-amp) so that they can come into compliance with the existing open, accessible, and universal Web standards.
I'm not saying that AMP is valid HTML 
Perl reddit: 11,296 readers 32 users here now Python reddit: 253,766 readers 1,368 users here now That's how viable is Perl, nobody younger than 40 does not want to touch perl. When we, old school die, so does Perl. 
Hey, in the past 5 hours this subreddit has gained one user! (Okay, Python's subreddit has gained 34.)
Yep, I used perl when I was 13 back in 2004. Was part of a mad-MSN &amp; Habbo bot scene which kind of kicked ass. I'm what, 29 now and only just decided to pick it back-up. It shows it's age. Perl6 is just too immature at this stage imo.
Are you getting an error, unexpected response data, or if not what is going wrong?
Which operating system are you running this on? Does your OpenSSL support TLS 1.2?
Sorry, I should have mentioned that, I receive: 500 SSL negotiation failed
Sorry, I should have mentioned that, it's a windows 2012 r2 server. Not using OpenSSL, I think it's GoDaddy, all other applications (.net) are communicating via TLS 1.2 fine.
You shouldn't need to modify your Perl code at all - no additional parameters for LWP::UserAgent are required. LWP::UserAgent does not implement HTTPS by itself, but relies on IO::Socket::SSL, falling back to Net::SSL. You should try to update these modules. If you let us know where your perl comes from, someone here who knows Windows might be able to help you how to perform that update...
I kind of don't find it amusing. I understand the game may be a bit simple now, but what is the plan for when you go into maintenance mode? How are you enforcing code standards among developers? What is your on-boarding time for new developers? How much of the API code utilizes proper doc headers? How are you testing and verifying the security of your login and payment processes and checking that test coverage? Unifying programmers under one standard is actually a good thing and that's very difficult to do without being naggy on code reviews unless you just make tools that do it for you. I'm not saying VIM is bad for coding or anything like that, it's the staple for managing Linux servers, but those generally run very small cron jobs. Ultimately any editor is fine for small projects (hell even notepad works) and code writing. But not at all for code maintenance, test writing, or editing currently existing code. Always make sure you keep your scalability, maintainability, testability, and project growth in mind. While you may know the in's and outs of all the code right now, one day some scrub programmer is going to have to fix or add something to that code. Often times I've found that when coding with text editors programmers fall into bad habits without an IDE poking them every once in a while to do the correct thing. While VIM is nice for server admins and hipster web/linux developers it's not so pragmatic for complex software that many different people of different skill levels need to maintain.
Try adding this near the top of your script: $ENV{HTTPS_DEBUG} = 1;
I had to add a line to my .net applications forcing it to use tls 1.2 so I assumed the perl was similar. When you say "let us know where your perl comes from" what do you mean? I would definitely appreciate help updating. 
And what does that do?
Are you using Crypt::SSLeay? [See here](https://stackoverflow.com/questions/44055729/why-does-lwp-fail-to-connect-with-500-ssl-negotiation-failed) for potential solution.
It turns on debugging output from LWP.
They are asking which distribution of Perl you are using. On Windows, there are distros like Strawberry Perl and ActivePerl - on *nix systems Perl is generally installed with and depended on by the operating system.
&gt; Crypt I don't seem to be, there is no mention of that in the code.
hmm, that is a good question, if I ~~had~~ to guess I would say ActivePerl as that rings a slight bell. Is there a way to determine that?
(you don't have to add that line to your .NET apps, changing a registry key, or upgrading .NET to 4.6 or higher should also do the trick; but it's good to have options :))
oh? The line I'm referring to is: ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12
I generally use Ghostscript, with code like: my $pdf_data = ... # Get PDF data here open( my $gsfh, '|-', "gs -q -dNOPAUSE -sDEVICE=pdfwrite -dCompatibilityLevel=1.3 -sOUTPUTFILE=$outfile -dBATCH -") or die $!; print $gsfh $pdf_data or die "Unable to push all data through GS for PDF conversion! $!"; close($gsfh); Or just use that command (possibly without piping and batch options) to do it on the command line.
It is sometimes used due to outdated modules or via Net::SSL. The linked post goes into more detail. You want to be using IO::Socket::SSL as the backend ultimately.
&gt; turned away all younglings. [Recent survey](https://docs.google.com/forms/d/e/1FAIpQLSdqrrcxTQWuN1ISAvz3j_XkpCCc2AuQw9uKgAhTivxHBFsweg/viewanalytics) shows a quarter of users are 18-30 and half the users are younger than 40.
perl -V will tell you all about your perl installation. You might want to redirect it through a pager or to a text file.
Try typing perl -MCrypt::SSLeay This attempts to load the module. If you get an error message, it's not installed. If you get a blank line that you have to control-c out of, the module is installed. You can also try this with any of the other modules mentioned here to see if you have them installed.
220 responses. That's pretty much a definition of 'nobody'. 
There's a registry key "UseStrongCrypto" that enables the newer TLS versions and disables SSLv3. The logic is a bit strange in .NET 4.5 but 4.6 and up just default to using the latest TLS versions available. This page has a good in-depth explanation: https://johnlouros.com/blog/enabling-strong-cryptography-for-all-dot-net-applications
For a 2 year old language, 220 community members active enough to notice a survey in a week's time is pretty damn good.
If it's good enough for you, so be it. I still think that perl 6 would be more successful without perl 5 baggage, but this train has left the station for good.
&gt; If you get a blank line that you have to control-c out of, the module is installed. It appears I have this one. Thanks for the instruction!
&gt; perl -V Summary of my perl5 (revision 5 version 10 subversion 1) configuration: Platform: osname=MSWin32, osvers=5.00, archname=MSWin32-x86-multi-thread uname='' config_args='undef' hint=recommended, useposix=true, d_sigaction=undef useithreads=define, usemultiplicity=define useperlio=define, d_sfio=undef, uselargefiles=define, usesocks=undef use64bitint=undef, use64bitall=undef, uselongdouble=undef usemymalloc=n, bincompat5005=undef Compiler: cc='cl', ccflags ='-nologo -GF -W3 -MD -Zi -DNDEBUG -O1 -DWIN32 -D_CONSOLE - DNO_STRICT -DHAVE_DES_FCRYPT -DUSE_SITECUSTOMIZE -DPRIVLIB_LAST_IN_INC -DPERL_IM PLICIT_CONTEXT -DPERL_IMPLICIT_SYS -DUSE_PERLIO -DPERL_MSVCRT_READFIX', optimize='-MD -Zi -DNDEBUG -O1', cppflags='-DWIN32' ccversion='12.00.8804', gccversion='', gccosandvers='' intsize=4, longsize=4, ptrsize=4, doublesize=8, byteorder=1234 d_longlong=undef, longlongsize=8, d_longdbl=define, longdblsize=8 ivtype='long', ivsize=4, nvtype='double', nvsize=8, Off_t='__int64', lseeksi ze=8 alignbytes=8, prototype=define Linker and Libraries: ld='link', ldflags ='-nologo -nodefaultlib -debug -opt:ref,icf -libpath:"C: \Perl\lib\CORE" -machine:x86' libpth=\lib libs= oldnames.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32 .lib advapi32.lib shell32.lib ole32.lib oleaut32.lib netapi32.lib uuid.lib ws2_ 32.lib mpr.lib winmm.lib version.lib odbc32.lib odbccp32.lib comctl32.lib msvcr t.lib perllibs= oldnames.lib kernel32.lib user32.lib gdi32.lib winspool.lib comd lg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib netapi32.lib uuid.lib ws2_32.lib mpr.lib winmm.lib version.lib odbc32.lib odbccp32.lib comctl32.lib m svcrt.lib libc=msvcrt.lib, so=dll, useshrplib=true, libperl=perl510.lib gnulibc_version='' Dynamic Linking: dlsrc=dl_win32.xs, dlext=dll, d_dlsymun=undef, ccdlflags=' ' cccdlflags=' ', lddlflags='-dll -nologo -nodefaultlib -debug -opt:ref,icf - libpath:"C:\Perl\lib\CORE" -machine:x86' Characteristics of this binary (from libperl): Compile-time options: MULTIPLICITY PERL_DONT_CREATE_GVSV PERL_IMPLICIT_CONTEXT PERL_IMPLICIT_SYS PERL_MALLOC_WRAP PL_OP_SLAB_ALLOC USE_ITHREADS USE_LARGE_FILES USE_PERLIO USE_SITECUSTOMIZE Locally applied patches: ActivePerl Build 1007 [291969] 0abd0d disable non-unicode case insensitive trie matching Built under MSWin32 Compiled at Jan 26 2010 23:15:11 @INC: C:/Perl/site/lib C:/Perl/lib .
Thanks for that info!
It'll depend if you have appropriate versions of the modules, but just try this. use IO::Socket::SSL; use LWP; IO::Socket::SSL::set_client_defaults(SSL_version =&gt; 'TLSv12', SSL_verifycn_scheme =&gt; 'none'); my $ua = LWP::UserAgent-&gt;new; 
&gt; ActivePerl Build 1007 [291969] You're using ActivePerl, which uses 'ppm' for Perl package management. Try running ppm from the cmd prompt and seeing if there's some way to determine if any SSL/TLS modules are out of date. If I remembered how to do that, I'd tell you but it's been yeeears since I switched to Strawberry Perl and I've never once looked back.
Thanks for that info, a quick bing says to run "ppm" at the command prompt and I receive this error: "ppm gui failed: Can't locate object method "default_header" via package "ActivePerl::PPM::Web::UA"" The thing is, active perl was never techincally installed on this server, or the last (to my knowledge), it's just been copied over from three servers ago and until now it's been a "ain't broke, don't touch it" type thing... Maybe I need to start with a "fresh install" of Active perl? 
 &gt;Maybe I need to start with a "fresh install" of Active perl? Looking at the version and dates in that -v dump, that would be for the best even if your project *was* working. 
heh, I believe it. I guess I should start there. I'm sure bing can tell me how to do that.
I'd be tempted to switch over to Strawberry Perl. To me, ActiveState Perl always seemed to be the slightly deranged Perl cousin that everybody knew about but avoided talking about.
\&gt; ancient long obsolete version of perl Hehe, CentOS 6 begs to differ
I'm under the assumption that you care about Internet standards because you recognise that by putting effort into making use of them even when they appear esoteric you reap certain benefits. If not, then simply disregard this reply and do what you want. &gt; should wallflower read the X-No-Archive: yes header in a HTTP response as "you can follow the links, but don't save this file as part of your crawling"? No, because [X- prefix is deprecated](https://tools.ietf.org/html/rfc6648). For HTML documents, you can use [`&lt;meta name="robots" content="noindex"&gt;`](http://www.robotstxt.org/meta.html). This doesn't help you with non-HTML resources, and you want an HTTP header. The genericised way to attach meta information there is the [Link header](https://tools.ietf.org/html/rfc8288). It is equivalent to the `&lt;link rel` and `&lt;a rel` elements from HTML2. Unfortunately, there is no way standard way to map the [attributes of `meta`](https://developer.mozilla.org/docs/Web/HTML/Element/meta) into the Link header, so you could instead coin a new [link relation](https://www.iana.org/assignments/link-relations/link-relations.xhtml). Relations that are simple words require registration, either at [Microformats](http://microformats.org/wiki/existing-rel-values#proposals) or IANA: Alternative 1: `noindex` (as an analogue to the existing `nofollow`) Link relations that are URIs are exempt from registration. The idea is that not only serves the URI as an identifier, but when dereferenced in a user agent, it also leads to an human-readable explanation of the semantics of the link relation: Alternative 2: `http://www.robotstxt.org/meta.html#noindex` If you think Web authors could misunderstand or get confused by the (too clever?) re-use of that page for a link relation, then write your own explanation: Alternative 3: `http://philippe.bruhat.net/2018/noindex/` This identifier needs to live forever! If you cannot guarantee that you never lose control of the bruhat.net domain, then solve the problem by introducing a level of indirection: register a [PURL](http://enwp.org/PURL) (e.g. with [purl.org](http://purl.org) or [w3id](https://w3id.org)), use that as an identifier, and in a case of catastrophe you simply redirect somewhere else on the Web. &gt; Can anyone think of other such well-known URL? * https://tools.ietf.org/html/rfc5785 * https://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml 
https://metacpan.org/pod/GraphQL ?
same answer from your previous post: /r/perl/comments/8v207r/can_any_play_with_facebook_graph_v_30/ you're sounding like a millennial that posts to social media: "somebody google this for me". 
I checked out that book the guy said was "brilliant" and all the examples are in cobol. WTF?
Looking forward to this year's!
&gt; I believe I am one of the few people (if not the only person) whose contributions to the project are not acknowledged anywhere It's [just a bug in contributors generating script](https://github.com/rakudo/rakudo/issues/2024), dude. In an alternate Universe where you bothered to tell us that you were missing in 2017.02, we fixed right there and then and now don't have two years of missing MoarVM contributors.
You not only need a developer, you also need at least a sysadmin. This certainly isn't a one-person job.
I'm open to advice. I assumed that once the server was live I could cross bridges as they come.
Can you get an estimate about how large the last team working on it was?
You need the sysadmin team at the same time as the dev team, they will setup a dev environment for the dev team to work. The two teams need to work out the requirements together. I woul recommend starting out with people that want to take administrative roles first, and have enough experience to estimate budgets and schedules. It's not easy to do that and it's only possible with experience.
It was a two man team, one handling 95&amp;#37; of the client to server protocols and the other handling basic graphics and 'concept code'. The server files are completely stable, problem is getting it to communicate with the client once it's running. After that is solved the attention will be directed toward the game mechanics.
You don’t necessarily need a team, just at least one solid dev with sysadmin and other experience. Sent you a DM for more info. 
&gt; I have here the binarys &gt; What I would have you do is take this code, compile it, You want someone to compile binaries? 
Knowing this stuff would be your job, not his.
[He takes the heretical view that the traditional division of labour between the systems analyst and the programmer is absurd](https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380070224)
Would there be any repercussions as far as the code goes? I'd rather not touch the code at all.
Fun! Thanks for the link.
I changed the code given by saiftynet a bit as I believe his code gave incorrect results on non-horizontal non-verticle lines &lt;pre&gt;&lt;code&gt; #!/usr/bin/perl use strict; use warnings; use constant pi =&gt; 4 * atan2(1,1); # # Line extended to rectangle Subroutine # # https://www.reddit.com/r/perl/comments/8t7mt2/how_can_you_expand_a_line_by_x_units_from_both/?st=jj1qcg27&amp;sh=277127b0 for my $line ('0 0 0 4','0 0 4 0', '1 1 4 4', '0 0 4 1') { print $line, "\n"; print extendLine($line,1), "\n\n"; } sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient } return join (" ", map {sprintf "%.1f",$_} ($x1+($extension*cos($theta+pi/2)) , $y1+($extension*sin($theta+pi/2)) , $x2-($extension*cos($theta+pi/2)) , $y2-($extension*sin($theta+pi/2))) ); } __END__ C:\Old_Data\perlp&gt;perl line_extend_my.pl 0 0 0 4 -1.0 0.0 1.0 4.0 0 0 4 0 -0.0 -1.0 4.0 1.0 1 1 4 4 1.7 0.3 3.3 4.7 0 0 4 1 0.2 -1.0 3.8 2.0 &lt;/pre&gt;&lt;/code&gt; Thanks saiftynet who did the heavy lifting. His code (with results after the __END__ token &lt;pre&gt;&lt;code&gt; #!/usr/bin/perl use strict; use warnings; # # Line extended to rectangle Subroutine # # https://www.reddit.com/r/perl/comments/8t7mt2/how_can_you_expand_a_line_by_x_units_from_both/?st=jj1qcg27&amp;sh=277127b0 for my $line ('0 0 0 4','0 0 4 0', '1 1 4 4', '0 0 4 1') { print $line, "\n"; print extendLine($line,1), "\n\n"; } sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient } return join (" ", map {sprintf "%.1f",$_} ($x1-($extension*sin($theta)) , $y1-($extension*cos($theta)) , $x2+($extension*sin($theta)) , $y2+($extension*cos($theta))) ); } __END__ C:\Old_Data\perlp&gt;perl line_extend.pl 0 0 0 4 -1.0 -0.0 1.0 4.0 0 0 4 0 -0.0 1.0 4.0 -1.0 1 1 4 4 1.7 1.7 3.3 3.3 0 0 4 1 0.2 1.0 3.8 0.0 &lt;/pre&gt;&lt;/code&gt;
New perl -v: This is perl 5, version 26, subversion 0 (v5.26.0) built for MSWin32-x86-multi-thread-64int (with 1 registered patch, see perl -V for more detail) Copyright 1987-2017, Larry Wall Binary build 2600 [403866] provided by ActiveState http://www.ActiveState.com Built Aug 30 2017 16:46:44 Perl may be copied only under the terms of either the Artistic License or the GNU General Public License, which may be found in the Perl 5 source kit. Complete documentation for Perl, including FAQ lists, should be found on this system using "man perl" or "perldoc perl". If you have access to the Internet, point your browser at http://www.perl.org/, the Perl Home Page. 
Sure but I'd recommend a more up to date reference. That edition is from 18 years ago.
p.s., not all programmers are guys
Welcome aboard! p.s., not all of us are guys
yeah ik I just found it at school
...and according to the edit on your post, it's working now. Hurrah! 
Moot point as installing ActiveState Perl has got you going again, but... theoretically, there'd be no repercussions. Mind you, it should also be theoretically twice as easy to lick your elbow as your wrist since it's only half the distance. :) 
You don't need all that stuff... You're trying too hard, and it looks way too complex. use strict; use warnings; use feature "say"; use constant WEEKLY_MIN =&gt; 40; say "What is your name?"; my $name = &lt;STDIN&gt;; say "How many hours did you work?"; my $hours = &lt;STDIN&gt;; say "What is your pay?"; my $pay = &lt;STDIN&gt;; my ($basepay, $overtime) = (0,0); if ( $hours &lt;= WEEKLY_MIN ) { $basepay = $hours * $pay; } else { $overtime = ($hours - WEEKLY_MIN) * 2 * $pay; $basepay = $pay * WEEKLY_MIN; } my $total = $basepay + $overtime; printf("\nYou have a credit for %d", $total ); printf("\n\t[Hours (REGULAR)]\t%d", $basepay ); printf("\n\t[Hours (OVERTIME)]\t%d", $overtime );
&gt;use strict; use warnings; use feature "say"; use constant WEEKLY\_MIN =&gt; 40; say "What is your name?"; my $name = &lt;STDIN&gt;; say "How many hours did you work?"; my $hours = &lt;STDIN&gt;; say "What is your pay?"; my $pay = &lt;STDIN&gt;; my ($basepay, $overtime) = (0,0); if ( $hours &gt; WEEKLY\_MIN ) { $overtime = ($hours - WEEKLY\_MIN) \* 2 \* $pay; $basepay = $pay \* WEEKLY\_MIN; } else { $basepay = $hours \* $pay; } my $total = $basepay + $overtime; sub money\_usd { sprintf( "USD &amp;#37;08.2d", $\_\[0\] ) }; printf("\\nYou have a credit for &amp;#37;d", money\_usd($total) ); printf("\\n\\t\[Hours (REGULAR)\]\\t&amp;#37;d", money\_usd($basepay) ); printf("\\n\\t\[Hours (OVERTIME)\]\\t&amp;#37;d\\n", money\_usd($overtime) ); Thank you very much.
TIL of perldoc.pl. Thanks, a very nice resource.
This is really great! For the special variables it might be helpful to just put in the title of the doc pages the names from \`use English\` next to the variable for immediate recognition.
Note that the English variants work as well: https://perldoc.pl/variables/$ERRNO - the title is based on which one is in the URL. But I'll keep this in mind for future refactors.
well, it seems the "internal" (running on the server, posting data to 3rd parties) apps work. This is probably going to sound like the stupidest thing but... there is a site folder, that was empty, and 3rd parties who push to us were getting a 502... so in a hurry, I just copied the site folder from the old installation... but I have a feeling that's not the correct course of action...
Might just be the ones I picked at random didn't have the other entries like that example https://perldoc.pl/variables/$%5B
That one doesn't list the alternate name because it's in the deprecated section: https://perldoc.pl/perlvar#Deprecated-and-removed-variables
You are missing a bunch of `my`s, some quotation marks, and a few semicolons. And I'm not sure what the square brackets on the last line are supposed to be.
The first point is wrong - it's specifically restricting the instance to the requested class, rather than a subclass, so yes, it *is* doing something - and there's no context for this: why was the check added in the first place? What was the original author's intention here? Does the new version of the code preserve that intent?
You seem to be guessing at Perl syntax - which is never a good idea. Perhaps take a little more notice of what's actually being taught in the class :-) But here are the (really quite basic) errors that you're making: * `use strict` means that you need to declare your variables (using `my`). So where you have, for example, `$channel1 &lt;STDIN&gt;;`, you need `my $channel1 &lt;STDIN&gt;;`. * You're trying to assign values to variables. And for that, you need the assignment operator (`=`). So those lines actually need to be `my $channel1 = &lt;STDIN&gt;;` * You've missed the semi-colon off the end of `use feature "switch"` and `use v5.22.1` (and you're not using a switch, so you can remove that line completely). * Your final line is bizarre. You need to quote any strings you want to print and I'm not sure where the whole `$[...]` think comes from. Oh, wait. Yes I do. You're getting confused between Perl and bash. Yeah, different programming languages have different syntax :-) All in all, I think that this is what you were struggling towards: #!/usr/bin/perl use strict; use warnings; use diagnostics; use feature "say"; use v5.22.1; say "What is your name?"; my $channel1 = &lt;STDIN&gt;; say "How many hours did you work?"; my $channel2 = &lt;STDIN&gt;; say "What is your pay?"; my $channel3 = &lt;STDIN&gt;; say $channel1; say 'Check Amount = ', (40*$channel3)+(($channel2-40)*$channel3*2); This still needs some cleaning up (what's with those unhelpful variable names?) but it works.
Results I got running your code: &lt;pre&gt;&lt;code&gt; 0 0 0 4 -1.0 -0.0 1.0 4.0 0 0 4 0 -0.0 1.0 4.0 -1.0 1 1 4 4 1.7 1.7 3.3 3.3 0 0 4 1 0.2 1.0 3.8 0.0 &lt;/code&gt;&lt;/pre&gt;
Picking up on saiftynet's code (which doesn't calculate a diagonal I believe) &lt;pre&gt;&lt;code&gt; #!/usr/bin/perl use strict; use warnings; use constant pi =&gt; 4 * atan2(1,1); # # Line extended to rectangle Subroutine # # https://www.reddit.com/r/perl/comments/8t7mt2/how_can_you_expand_a_line_by_x_units_from_both/?st=jj1qcg27&amp;sh=277127b0 for my $line ('0 0 0 4','0 0 4 0', '1 1 4 4', '0 0 4 1') { print $line, "\n"; print extendLine($line,1), "\n\n"; } sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient } return join (" ", map {sprintf "%.1f",$_} ($x1+($extension*cos($theta+pi/2)) , $y1+($extension*sin($theta+pi/2)) , $x2-($extension*cos($theta+pi/2)) , $y2-($extension*sin($theta+pi/2))) ); } __END__ C:\Old_Data\perlp&gt;perl line_extend_my.pl 0 0 0 4 -1.0 0.0 1.0 4.0 0 0 4 0 -0.0 -1.0 4.0 1.0 1 1 4 4 1.7 0.3 3.3 4.7 0 0 4 1 0.2 -1.0 3.8 2.0 &lt;/code&gt;&lt;/pre&gt;
`#!/usr/bin/perl use strict; use warnings; use constant pi =&gt; 4 * atan2(1,1); # # Line extended to rectangle Subroutine # # https://www.reddit.com/r/perl/comments/8t7mt2/how_can_you_expand_a_line_by_x_units_from_both/?st=jj1qcg27&amp;sh=277127b0 for my $line ('0 0 0 4','0 0 4 0', '1 1 4 4', '0 0 4 1') { print $line, "\n"; print extendLine($line,1), "\n\n"; } sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient } return join (" ", map {sprintf "%.1f",$_} ($x1+($extension*cos($theta+pi/2)) , $y1+($extension*sin($theta+pi/2)) , $x2-($extension*cos($theta+pi/2)) , $y2-($extension*sin($theta+pi/2))) ); } __END__ C:\Old_Data\perlp&gt;perl line_extend_my.pl 0 0 0 4 -1.0 0.0 1.0 4.0 0 0 4 0 -0.0 -1.0 4.0 1.0 1 1 4 4 1.7 0.3 3.3 4.7 0 0 4 1 0.2 -1.0 3.8 2.0 `
Also the point is more "don't do this with an attribute that is already type checked" which isn't clear until halfway into the article. The code is perfectly fine for attributes that aren't already constrained.
&gt; The code is perfectly fine for attributes that aren't already constrained. Except for the other points, especially point #3.
In the case that an attribute is not centrally type checked, the project would have different expectations. See for example Mojolicious which primarily depends on attributes being used only as documented rather than explicit checks. In this case the process of making an attribute more flexible is to check that everywhere that uses it can cope with the new flexibility, then just doing it. Which can be harder or easier depending.
I remember the head of METACPAN made a blog post the other day about the move to a single site and gave an address there to email also
This is about a CPAN mirror, not CPAN searching (so nothing to do with metacpan).
I'm relaying a suggestion from jkeenan to send the same information to webmaster@perl.org.
Right..I was explaining what the article was about but it seemed to have useful info. The IRC info at the bottom of this artical from Olaf may be useful to get you in touch with the correct person(s) https://www.perl.com/article/saying-goodbye-to-search-cpan-org/
I'm not sure what you're referring to. This article and the contact info is about metacpan not CPAN mirrors.
Thanks!
Thanks!
I'm guessing this post was prompted by finding something similar in the wild. Without docs, exactly the kind of thing that would drive me nuts.
I would also add a predicate, so I can see if the value is set(`predicate =&gt; 'has_widget'` and then later on do `$self-&gt;widget-&gt;rotate if $self-&gt;has_widget`. And if you don't want a \`isa =&gt; "Foo::Bar"\`, you could also describe that it must comply with a particular role or use [`duck_type`](https://metacpan.org/pod/Moose::Util::TypeConstraints#duck_type-($name,-%5C@methods)) so you only worry about the particular interface, because you want the thing to support `rotate`
With some minor changes to saiftynet's code (which didn't get the diagonal coordinates). Reversed the `sin` and `cos` functions and changed arguement to the 2 functions to `$theta+ pi/2`. Output from running this program is after the `__END__` token. #!/usr/bin/perl use strict; use warnings; use constant pi =&gt; 4 * atan2(1,1); # # Line extended to rectangle Subroutine # # https://www.reddit.com/r/perl/comments/8t7mt2/how_can_you_expand_a_line_by_x_units_from_both/?st=jj1qcg27&amp;sh=277127b0 for my $line ('0 0 4 0', '0 0 4 4', '0 0 0 4', '0 0 -4 4') { print $line, "\n"; print extendLine($line,1), "\n\n"; } sub extendLine{ my ($lineString, $extension)=@_; my $theta; my ($x1,$y1, $x2, $y2)=split(/ /,$lineString); # extract coordinates if ($x1 == $x2){ $theta=2 * atan2(1, 1); # if vertical then angle is pi/2 } else { $theta=atan2($y1-$y2,$x1-$x2); # else arctan of gradient } return join (" ", map {sprintf "%.1f",$_} ($x1+($extension*cos($theta+pi/2)) , $y1+($extension*sin($theta+pi/2)) , $x2-($extension*cos($theta+pi/2)) , $y2-($extension*sin($theta+pi/2))) ); } __END__ C:\Old_Data\perlp&gt;perl line_extend_my.pl 0 0 4 0 -0.0 -1.0 4.0 1.0 0 0 4 4 0.7 -0.7 3.3 4.7 0 0 0 4 -1.0 0.0 1.0 4.0 0 0 -4 4 0.7 0.7 -4.7 3.3 
Sorry don't follow why that's relevant? If anything surely that's more reason to document how crazy it is?
This is just how perlvar is formatted.
I want to be a programmer that can solve people's problems. Which editor do I need to learn?
Being skilled in an editor software is just a small part; I'm curious why you only ask about that. You don't need to learn one specifically and up-front, it's enough to go along while you work on code. Recommending a single one is pointless, because you can always switch and also *you* change over time in terms of skill and programming language bias. Just pick one that you like on first impression, that's a code editor (rule of thumb: has features like regex replace and syntax highlighting), and you can get help for (e.g. from a local or on-line community).
The answer is vim.
Try a bunch of editors and don't ever rely on one. If you want to solve other people's problems you're going to end up in situations where you don't get to use your favorite editor. My rule for people working for me is that they can use whatever they want as long as it doesn't force anyone else to use the same thing. 
http://tryperl.pl/
Thanks man!
https://learnxinyminutes.com/docs/perl/ http://mvp.kablamo.org
[learn.perl.org](https://learn.perl.org)
&gt; https://learnxinyminutes.com/docs/perl/ There's also a Perl 6 equivalent of that: https://learnxinyminutes.com/docs/perl6/ . I mention this just in case the project at work was not specific about the version of Perl to use.
I thought it was obvious that this is a joke but people are responding seriously.
&gt; learn Perl for an upcoming project at work But let's be clear that if you are a beginnner and have to ask how to learn it for work, the correct answer is not yet Perl 6. 
For a good overview of different learning materials that will help you decide as well, go to: http://perl-tutorial.org
[https://perlmaven.com/perl-tutorial](https://perlmaven.com/perl-tutorial)
[Recent survey](https://docs.google.com/forms/d/e/1FAIpQLSdqrrcxTQWuN1ISAvz3j_XkpCCc2AuQw9uKgAhTivxHBFsweg/viewanalytics#c29) shows 34.7% of Perl 6 users use it at work, with 2.3% selling Perl 6 software.
That's 71 people of the 220 who replied to the survey. I'm not sure you can use that to draw any conclusions about how popular Perl 6 is in the wider software industry.
Well you can given that 220 is basically everyone in the world using Perl 6.
:-)
You can draw enough conclusions for a friendly suggestion of a language tutorial without being scolded with the "correct answer."
If you provide answers to the following basic questions you'll probably get helpful guidance: * Roughly how many coders are there at your workplace? Does anyone else know Perl? * Will you be mainly working on existing Perl code? (If so, share any info you're allowed to share about that code, eg how many files have names ending in .pl and how many ending in .pm, and paste an example of the first 10 lines of code of a random example of each of these two types of file.) * How did tryperl.pl work out for you? * Do you have the rest of July to learn Perl before you start changing or writing real code or just a few hours?
My objection to the comment is simply that the correct answer to "how do I learn Perl" is not related to Perl 6 at all.
Only an Emacs user wouldn't get the joke.
So, is there anything I can do with 5.28, that I can't do with 5.24?
Personally I found the O'Reilly books to be really useful if you can get your hands on them. Programming Perl (for in-depth understanding) Learning Perl (for basics) Perl Cookbook (for good code snippets and examples) I also used these websites Perldocs (Documentation) Perl Maven (Snippets and Examples) Perl Monks (Answers to questions)
Gee, if someone wanted to be productive they could do the work to restore the Parrot backend. It should be easier to port to Parrot than it would have been to fix the existing implementation as we now have a better idea what a VM for Perl 6 needs to implement. (There are now 4 backends being actively worked on) I think the design of Parrot is a very interesting idea and want to see what could come of it. The person(s) who restore Parrot support could probably do whatever changes they wanted to that backend because as far as I can tell there is precisely 2 people who continue to care enough to bring it up. One of which I remember being banned from P5P because he had next to no tact, and pissed everyone off. And yet he still appears to be in the dark about why very few people listen to him. (I distinctly remember skipping every message he wrote, and only reading the responses as he pissed me off too.) Ever hear of the saying “You catch more flies with honey than you do with vinegar”? Apparently the two of you don't realize that you are actively turning people away from your position on the issue who could actually help. Seriously, whenever I see a message from either of you I end up caring less and less about Parrot.
Results of a survey of a set of self-selected respondents cannot be generalized. Plus, given the method by which the survey was implemented, multiple responses per respondent and bogus responses cannot be ruled out. Therefore, it is better to report the results in raw numbers instead of percentages. Regardless of validity, adding numbers past the decimal point implies a precision that is simply not present in such small, discrete sets. The proper way to state those results is to state that there seem to be at most 71 people who use Perl 6 at work, and at most five people selling Perl 6 software. Anyone who spends significant amounts of time on Perl 6 related matters ought to know who those five people are.
A [few](https://perldoc.pl/perl5260delta) [things](https://perldoc.pl/perl5280delta).
There's a series of three O'Reilly books that work together for learning Perl. * *Learning Perl* * *Intermediate Perl* * *Mastering Perl* Then, as you say, *Programming Perl* is the definitive reference. I'm not sure to what extent I'd recommend *The Perl Cookbook*. It's a great book, but it's so old now that the code in it has a good chance of confusing someone who is new to Perl.
1. There are around 4000 people at my workplace many of which are coders. I know there a couple of people within my team who have worked with Perl before. 2. Yes the project is to revamp and update an existing tool that is coded in Perl. We have very tight security so i doubt i would be able to share anything without breaching some sort of security rule. 3. Going to jump on to all suggested sites today but i assume from the vast majority provided that tryperl.pl or any of the others will be sufficient. 4.more than likely have the rest of July, there doesn't appear to be a rush on the project.
That was quick. 
[The Web site is late.](https://github.com/StrawberryPerl/strawberryperl.com/commits/gh-pages) Timestamps indicate the builds were done on the same day when [vanilla Perl](https://metacpan.org/release/XSAWYERX/perl-5.28.0) was released.
&gt; at most five people selling Perl 6 software I assume you mean: "at most five people selling software made with Perl 6" Assuming that people who buy this software will actually use it, would it be safe to say that "Perl 6 is used in production" ?
I wasn't trying to shit on Perl 6. I like what I see in the Perl 6 language. But I live and work in the real world, where if someone has been told to learn Perl for something, the chance of that at all involving Perl 6 is miniscule at best. So it's *not helpful* to confuse the issue for a beginner, however friendly that suggestion is. 
&gt; any of the others will be sufficient. Very wrong. Perl is an old language. A lot has been written about it. A lot of that is hopelessly opinionated and out-of-date and sometimes even asking the community won't help in weeding those out because books with out-of-date concepts still get new revisions but without major update and long-time community members still recommend them based on cachet from 20 years ago. My best recommendation would be to start reading Modern Perl (available free) to get a grounding in what is actually state-of-the-art, then Ovid's Beginning Perl, and after that whatever seems applicable to your problem domain. The Perl Tutorial site has links.
Both Learning Perl and Programming Perl are not good recommendations for complete newbies and first-timers. They're ok for people who need refresher material, but not newbies: http://perl-tutorial.org/rejected/prog_perl_4th/ http://perl-tutorial.org/rejected/learning_perl_6th/
Since you're a long-time community member, i'd like to ask you also to consider this: https://www.reddit.com/r/perl/comments/8xbzok/best_place_to_learn_perl/e24cxgz/
I wouldn't recommend *Programming Perl* to a beginner, but I don't agree with your criticism of *Learning Perl*. It would be great if they spent time updating some of the older code examples but, in general, I think it's still a worthwhile way to learn the language.
Do keep in mind that op said they were asked to learn perl, meaning they didn't know it at all. As for LP, we don't disagree much. I am not saying it's a bad book, just unsuitable for a first-timer. Once they've read e.g. Modern Perl and can tell where LP is out-dated it can serve fine.
I wasn't recommending *Programming Perl* for the OP; just saying that it was the definitive reference. I don't agree that *Learning Perl* is unsuitable for a first-timer. I think that most of it is very good.
You might want to get a job as a business analyst or product manager instead &gt;:3
How do you justify teaching non-strict coding to a first timer?
&gt; you are actively turning people away from your position on the issue My position on the issue is "here's what really happened with Parrot and Rakudo, and for proof, here are links to the mailing list, design summaries, and IRC logs". It's not coming back, and even if were, I wouldn't work on it.
whats perl6 ?
It originally started as the next major version of Perl, but at the end ended up a completely new language. Check it out: https://perl6.org/
I'm going to recommend against this tutorial for a newcomer. In the REPL style it does not even mention that you should be using strict and warnings except as a "suggestion" when you get to the very end. The "quickstart" tutorial here may be a good choice: http://perltuts.com/
You have a point, and "Modern Perl" isn't a bad place to start at all, but I'd argue that a number of the older works remain useful, even if they're slightly dated in some respects. "The Perl Cookbook" is one of the best programming books I've ever seen, and if you're audience is experienced programmers who need to look up perl techniques, it would be tremendously useful to have around. 
Perhaps you should just shut up about it then, as you have just stated that you have nothing productive to add.
&gt; you have just stated that you have nothing productive to add Source? &gt; Perhaps you should just shut up about it then You may be right; it's pretty clear that attempting to correct the record is futile.
If they're experienced, yes. My comments were for the "first timer" context OP is in. :)
As an update, ranguard mentioned on IRC that the CPAN mirrors are organized by [Henk Penning](http://www.staff.science.uu.nl/~penni101/), and that cpan@perl.org is the correct address, he probably just hasn't gotten to it yet.
Thanks 
I disagree that this is a good list. For example you don't recommend Learning Perl, which in my opinion is the best introduction to Perl for complete beginners.
Learning Perl is teaching an understanding of the language to programming beginners. To understand the strict pragma, the reader will need to be aware of concepts like: variables, scoping, barewords and references. Oh and what the hell a "pragma" is too. That's why Learning Perl sixth edition introduces the strict pragma on page 72, once the reader has gotten up to speed with some basic Perl concepts. It spends over 500 words explaining a simplified concept of a pragma and what strict is good for. It ends with this paragraph: &gt; From here on, we’ll write most (but not all) of our examples as if use strict is in effect, &gt; even where we don’t show it. That is, we’ll generally declare variables with my where &gt; it’s appropriate. But, even though we don’t always do so here, we encourage you to &gt; include use strict in your programs as often as possible. You’ll thank us in the long run.
You answered a question i did not ask.
Learning Perl does not conform to the community consensus of what a modern pen tutorial for first timers requires: http://perl-tutorial.org/rejected/learning_perl_6th/
This isn't a community consensus
What are you talking about? My answer does two things: 1) Explains why Learning Perl doesn't immediately teach "use strict" to beginners. That answers your question. 2) Shows that it does teach beginners about the strict pragma. The quoted paragraph in particular addresses your claim that it "teaches a non-strict coding style". Which is really only partially true, and certainly not true with respect to the intentions of the authors. There are hundreds of examples in Learning Perl. If "use strict" was included in all of them, the book would be far longer.
When judging the quality of a Perl tutorial what matters far more than whether it "uses strict" are things like: The quality of the writing: is it intelligible for its target audience? Does it engage them? Does it convey clearly the concepts it wants to teach? Do the code examples work, and are they appropriately explained? I don't know why your list of criteria doesn't include things like that.
This is mostly irrelevant. Things that programmers should always use should be introduced first, and accounted for in all examples, it can be explained later.
These are all important. But not as important as teaching people the easiest ways to write Perl code that doesn't suck.
"All code other than oneliners should use strict and warnings, or the equivalent" is as close to a community consensus the Perl community has ever had.
&gt; &gt; you have just stated that you have nothing productive to add &gt; &gt; Source? I was referring to the message that it was in response to. (operative word being “just”) &gt; &gt; Perhaps you should just shut up about it then &gt; &gt; You may be right; it's pretty clear that attempting to correct the record is futile. Not exactly what I meant, but certainly within the ballpark. It really doesn't matter why Parrot isn't supported, particularly if noone is going to resurrect it. That said, your view of the situation is accurate, but is extremely myopic. Parrot went in the direction of supporting multiple languages, so necessarily lessened the ability to support the only active language. (That isn't meant as a value judgement.) In order to support Rakudo, low-level support for it had to be bolted on. Indeed I'm fairly sure the person who was doing the most work on this shim at the time determined it would be easier to add JVM support to get multithreading rather than try to figure out how to get multithreading to work on Parrot. Now it is likely partly because he already knew Java, and how it's threads worked. I'm sure you will respond with how there wasn't enough information about how 6model works to implement it natively in Parrot. Which is accurate. The thing is, I'm pretty sure this happened at the time when he was in the middle of implementing the third Rakudo backend in secret. (It was in secret so that other backends would continue to progress in the meantime.) Basically his mind was focused on it rather than writing up a document of how 6model works. But none of this matters. The real reason Parrot was dropped as a backend, is it was deemed easier to restart the Parrot port from scratch than continue with what already existed. Part of this may be that the design of Rakudo had changed to be able to support multiple backends. (Indeed why would it need two independent intermediate languages when every other backend uses only one of them.) There were other design changes that I'm sure left a lot of unnecessary cruft. There was/is nothing stopping someone from starting a new Parrot port, it's just that no one ever has. Part of the problem is that this happened in the run-up to the official release, and there were two other backends that were easier to modify. i also remember reading an article where one of the Parrot developers was purposely writing worse code than they would otherwise; to prevent discouraging other contributors. I believe this was a mistake. Perhaps even a fatal mistake. If every contributor did this it would obviously end up with a worse codebase, and then fewer people would want to work on it. You keep looking at the situation from only your vantagepoint. Perhaps you should try to determine why other people have differing views on the situation. I'm sure it would be enlightening. If you do so, feel free to keep me apprised.
Tried it again, slower 10 times than perl5 on average on simple tasks. Solid F. On other hand perl5 28.0 substantially faster than python. Good job, perlporters! 
Could you please elaborate on 1. which version of Rakudo Perl 6 you used, and 2. what the simple task was that you tried?
I agree :-)
\+1 for perltuts tryperl is kind of neat, but its also limited to single line evaluation, its not a true REPL so you can't do \`use strict\` even if it told you to, unless you fancied putting it on every single line. A great idea, but slightly less well executed.
"at most" is also incorrect "at least" is the only logical thing you can say that's true...
I confirm I joked, and after @daxim's spot on response I felt a bit bad that I'm using up goodwill towards newbies asking weird questions.
Not sure why this has the flair "camelia", but I'll take the bait :-). I'm glad to see that syntax wise, all of this is also possible in Perl 6: just replace `-&gt;` with `.` and `new Bicycle` with `Bicycle.new`.
Also, can call `uc` and `print` as methods in Perl 6.
The headline does not fit with the article body. Chaining methods is not what functional programming means! You (= wbazant) should know that because you learned Haskell, which is a functional programming language. The rough equivalent to LWP is &lt;https://hackage.haskell.org/package/HTTP/docs/Network-HTTP.html&gt;, but that code doesn't really tell one anything about the difference between OO and functional.
There is a difference between the traits that good Perl programs exhibit, and the way to teach absolute beginners how to program. This site conflates them.
He says in the article it's not really functional programming. He says he actually doesn't know how to call it, saying it's half way between both styles.
It's hardly irrelevant. I imagine when someone is new to programming, there are all kinds of concepts you'd love to introduce them to, but you have to focus on the important things that elucidate the knowledge you're trying to convey at that moment. It's a trade-off. If we're judging tutorials, we're really asking the question, "what's the best way to teach Perl?" And a simplistic set of rules like "always use strict" is not the best way to judge tutorials. If the text is unclear or the examples too advanced for the reader, but the code is great, that's a bad tutorial.
If the writing is bad but the code uses strict they won't understand what they're doing: that doesn't sound like a recipe for solid code to me.
There's more to it than just strict of course. But the best introduction in the world that doesn't teach them from the very beginning that they should use strict and warnings, and give them examples in each context of how to write good code under those circumstances, is a tutorial that is introducing them to Perl 4.
I would chastise one aspect of the very first example. Although it's Java like, in Perl indirect object notation is a [problematic syntax quirk](https://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/) and it's recommended to always use direct method syntax. The web toolkit and framework [Mojolicious](https://mojolicious.org) is probably the heaviest user of method chaining in Perl. Its object base system Mojo::Base implements chained attribute setters, and provides a method "tap" to allow chaining methods that don't normally return $self.
Not teaching the correct way to write good Perl programs from the start is doing beginners a disservice.
In Perl 6 the problems are solved by requiring a colon after the name of the Class: parse My-Grammar: 'String to parse' calls the parse method in the Class My-Grammar, with the String as the second argument. The only problem with it is that it doesn't compose very well with itself. 
sadly direct object notation is *also* a problematic parser quirk, given that it's quite possible for Perl to decide not to treat the bareword classname as a string and call it as a function instead. of course, `new Whatever::` and `'Whatever'-&gt;new` don't win any style points either. why can't we have nice things...
The Perl parser is quite the quagmire. We just do our best to use what works 90% of the time while not looking terrible. (And of course there are APIs that [leverage](https://metacpan.org/pod/JSON::MaybeXS#JSON) that option for convenience...)
I apologise for the totally off-topic title and introduction if it didn't sit well with you! I'm grateful you've read my post and shared a thought about it and ridiculous introductions don't add to the maybe-educational-or-interesting part. I am trying to contrast two possible styles: the first one emphasises creating an ensemble of useful objects, maybe manipulating state inside them, arriving at a useful object representing the result, and extracting it as desired. The second one doesn't care about the objects, or state, at all - the program declares expressions that are evaluated, and importance is placed on the flow of data. It's not OOP vs FP at all - there aren't even any functions here - but I don't know how to call the difference: procedural vs declarative isn't quite right either.
This discussion might pick your interest: https://www.reddit.com/r/perl/comments/8ojjn4/does_perl_6_have_built_in_support_for_immutable/
` $ perl -v|grep version This is perl 5, version 28, subversion 0 (v5.28.0) built for x86_64-linux-thread-multi $ perl6 -v|grep version This is Rakudo Star version 2018.04.1 built on MoarVM version 2018.04.1 $ python --version|grep version Python 2.7.15rc1 $ cat test.p6 my @array; loop (my $i = 0; $i &lt; 5000000; $i++) { @array.push($i + 1); } $ time perl6 test.p6 real 0m9.502s user 0m6.289s sys 0m0.338s $ time perl -e 'my @array; for (my $i = 0; $i &lt; 5000000; $i++) { push @array, $i + 1 }' real 0m0.368s user 0m0.351s sys 0m0.058s $ cat test.py array = [] i = 0 while i &lt; 5000000: i = i + 1 array.append(i + 1) $ time python test.py real 0m0.642s user 0m0.645s sys 0m0.068s $ `
While it's not an actively terrible way to learn, Ovid's Beginning Perl is much more comprehensive and teaches much better practices. Learning Perl tends to result in people who've learned PERL rather than 2018-style perl, and often programmers who, due to having started with copy pasting the early examples, aren't using 'use strict' (this from bitter experience in freenode #perl, hence why we helped crowdsource content for http://perl-tutorial.org/ to get people started in ways that weren't going to result in them blowing off both feet)
IME if newbies are told 'use strict;' and always introduce a variable with 'my $foo;' they get on with it fine. If they aren't given 'use strict' to start with, they often don't get into the habit of doing it by reflex, and Learning Perl's text only *encourages* it rather than making clear that for anything beyond a one-liner it's practically required. This is replicated regularly on both freenode #perl and irc.perl.org #perl-help and given I and others in this thread all spend multiple hours a week helping people out as they improve from 'newbie' to 'junior' I'd ask that you consider the possibility that we've got a reasonable sample size at this point. This is why learn.perl.org links to perl-tutorial.org and why 'perlbot' provides perl-tutorial.org as the first port of call for people starting using perl. I could've sworn perl-tutorial.org (given its existence as a crowdsourced set of recommendations from the community) was in the sidebar on there for the same "trying to be maximally helpful to newbies" reasons as everywhere else linking it, but I don't seem to be able to spot it now.
&gt; i also remember reading an article where one of the Parrot developers was purposely writing worse code than they would otherwise; to prevent discouraging other contributors [That was Dan Sugalski](http://www.sidhe.org/~dan/blog/archives/000435.html), who stepped away from Parrot in 2005. &gt; You keep looking at the situation from only your vantagepoint. Feel free to read the links I posted. &gt; I'm sure you will respond with how there wasn't enough information about how 6model works to implement it natively in Parrot. Which is accurate. Sure, which is an interesting complaint from the Rakudo side because: * [Jonathan implemented the object system in Parrot](https://github.com/parrot/parrot/commit/f59c670fd772a0da4d013b8cd389113b4fa5e110) * [Whiteknight had volunteered to port 6model to Parrot for months and months](https://whiteknight.github.io/2015/01/15/parrottheend.html) and was repeatedly rebuffed until [he just did it himself](https://groups.google.com/forum/#!searchin/parrot-dev/6model%7Csort:date/parrot-dev/ZFk3Y47Yupw/y1DoNNp4u3AJ) * and... &gt; I'm pretty sure this happened at the time when he was in the middle of implementing the third Rakudo backend in secret. Yep. &gt; The real reason Parrot was dropped as a backend, is it was deemed easier to restart the Parrot port from scratch than continue with what already existed. Nope, it was because Jonathan and Patrick didn't want to work with Parrot anymore, by [pulling the rug out from the compiler toolkit](https://groups.google.com/d/msg/parrot-dev/D2GI0jNSWkg/EGnuuuVwSKgJ) for example.
&gt; revamp and update an existing tool that is coded in Perl Do you know exactly which versions of Perl are used to run that tool and if there's already support for you to move things on to a recent Perl? (A new even numbered version of Perl is released each spring/summer. 5.28 was released a few weeks ago.) If not, I recommend you make it a priority to find out. &gt; ... i doubt i would be able to share anything Do you believe you are allowed to share which versions of Perl are used to run the tool? It can make a significant difference in how you approach learning, debugging and modifying Perl code and soliciting help online. If you don't think you are currently allowed to share that, I recommend you make it a priority to persuade your security conscious folk to find a way for you to be able to share that information, even if you do so under a separate username that you log in to purely to be able to ask a question while naming which Perl version you're using. I also recommend you find out if the first few lines of each source file of the tool includes the [pragmas](https://perldoc.perl.org/index-pragmas.html) `use strict;` and `use warnings;` (or something like `use Modern::Perl;`; [`Modern::Perl`](https://metacpan.org/pod/Modern::Perl) that does `use strict;` and `use warnings;` for you). If it does, consider it a good omen. If it doesn't, consider making your first task be choosing which pragma(s) to insert at the start of each source file. Finally, if you have now tried tryperl.pl or a tutorial etc., how did it go?
&gt; There are hundreds of examples in Learning Perl. If "use strict" was included in all of them, the book would be far longer. I managed to get all of the examples in *Modern Perl* running under strictures. It really didn't pad out the book. (I'm not saying anything about brian's choice to include or elide strictures, merely saying that code length is irrelevant.)
I hate to be like one of those annoying bots but the word you're looking for is [pique](https://en.wiktionary.org/wiki/pique) ;)
To wit: you don't have to include the words 'use strict; use warnings;' in every example, just the first one, and then write the later examples as if they were there. Every other tutorial recommended on perl-tutorial.org manages this.
Thank you for trying Perl 6. However, I think you should give Perl 6 another chance, perhaps after seeing these benchmarks (which were made on HEAD, in a few weeks available as Rakudo Star 2018.07). When doing integer arithmetic, Perl 6 is always using infinitely large integers (aka [bigint](https://metacpan.org/pod/bigint). If you would use bigints in your Perl 5 example, it would be orders of magnitude slower. However, Perl 6 has native integer support, which is very close to how Perl 5 handles integer values (but without auto-conversion to floats if it starts running out of range: but that would not be the case here). So I've taken the liberty of rewriting the example to a more idiomatic Perl way, in fact inspired by the Python example, and run that against Perl 5 and Perl 6. $ time perl6 -e 'my int @a; my int $i; @a.push(++$i) while $i &lt; 5_000_000' real 0m0.298s user 0m0.314s sys 0m0.045s $ time perl -e 'my @a; my $i = 0; push @a, ++$i while $i &lt; 5_000_000' real 0m0.481s user 0m0.408s sys 0m0.070s Not only is Perl 6 faster in this case, it is much faster if you realize that the bare startup of Perl 6 is much larger than Perl 5: $ time perl6 -e '' real 0m0.144s user 0m0.163s sys 0m0.027s $ time perl -e '' real 0m0.007s user 0m0.002s sys 0m0.003s So, if you would deduct startup time from this calculation: perl6 -e 'say (481 - 7) / (298 - 144)' # 3.077922 One can only conclude that, at least in this particular benchmark, Perl 6 is 3x as fast as Perl 5. And apparently also significantly faster than Python. Admittedly, one needs to know where the gears are in Perl 6 to get it really up to speed. But the power is there, and the gears are getting easier to find every day.
Thank you. I stand corrected in this particular case. Explicitly defining @array and $i as int made perl6 a winner. Now please port TensorFlow to perl6 and not in this way https://github.com/drforr/perl6-TensorFlow, please, and we are talking :-)
&gt; "at most" is also incorrect "at least" is the only logical thing you can say that's true... Known fact: There are five recorded responses stating that the respondent is selling software made with Perl 6. * This does not mean that each response was provided by a distinct person. There was no way to control that each respondent only submitted a single filled in survey. All five responses might have come from the same person. * Even if five distinct people said they were selling software made with Perl 6, it is far from obvious that they were being truthful. * Just because one says "I am selling X" does not mean one has sold any X. So, there is no logic that leads to "at least five" because, at this point, we can be almost certain that there is no one who even knows what Perl 6 is outside of the set of people who knew about the survey. If there are five entities who have actually sold software made with Perl 6, they exist independently of the recorded survey respondents. If there were such entities, they would be known to inhabitants of `#perl6` independently of whatever the survey says. If if they know about instances of Perl 6 being used in production, they can publicize those cases. However, all we know is there are at most five people who said they are selling made with Perl 6 (for some definitions of respondent, selling, and "made with"). To credibly claim there **are** at least five entities selling Perl 6 software, you need to **list** them.
&gt; I presume in P6 it's possible - though uncommon - to define objects with instance fields and then a constructor that leaves them blank, and a series of accessor methods for initializing the fields. It's P6 -- even the impossible is supposed to be merely hard. ;) class Period { has $.days is rw } my \obj = Period.new; obj.days = 12; say obj; # Period.new(days =&gt; 12) But P6 makes it easier to write: class Period { has $.days } my \obj = Period.new: :12days; say obj; # Period.new(days =&gt; 12) And it's safer: obj.days = 12; # Cannot modify an immutable Int (12) &gt; I set up the constructor to require all of its instance fields and even sometimes do some basic sanity checking on those fields and throw a detailed error if anything is wrong. If construction finishes, the object is good forever. That's the way to do it. P6 does a great job of making it easy and idiomatic to write this sort of clean validated object construction code. &gt; Hopefully the P6 community is too bright to repeat that particular bizarre Java habit. The P6 *language* makes it easy and natural to do the right thing so the community doesn't have to be bright. &gt; Clojure doesn't have any magic for handling a socket connection unexpected close. OK. That makes sense. &gt; In our own code sometimes we have code that passes around a socket object, and every once in a while someone - including me at times - just introduces a logic error in which we close the socket ourselves and then try to send or receive data on it later. My weak understanding is that something like Rust's lifetime monitoring of variables would detect that kind of logic error at compile time. Well you really need to cover the non-logic case too, eg a socket connection dying. Shit happens. And your code needs to deal with it. And languages ought to make it easy to deal with it correctly. This is why, imo, partially dynamic languages that are carefully designed to help devs deal with whatever happens without boilerplate will always be safer in practice than purely static languages. 
Hi minimim, I've been on vacation for a while and am now picking up some loose threads and noticed this one. Do you recall what reply you're waiting for?
You already answered: https://www.reddit.com/r/perl/comments/8ojjn4/does_perl_6_have_built_in_support_for_immutable/e281hze/
Gotchya. Thanks.
No, thank you.
At some point I have to wonder if Perl's just becoming Ruby with more punctuation. Then again, Ruby's basically just Perl with *less* punctuation, so I suppose what goes around comes around or something.
If you want to design an interface to TensorFlow for Perl 6, we could be doing more than talking!
What to call a programming paradigm that is all about chaining methods? Bound to be some good pun-ishment here somewhere. 
&gt; I don't see a similar option for the default Map There actually is (although for a long time this syntax didn't work): my %map is Map = a =&gt; 42, b =&gt; 666; say %map&lt;c&gt;; # Nil %map&lt;c&gt; = 371; # fails because key doesn't exist %map&lt;a&gt; = 371; # fails because value is immutable The errors given were quite LTA (Less Than Awesome). Since https://github.com/rakudo/rakudo/commit/e2bbe3f0a9 they are much more helpful.
&gt; This does not mean that each response was provided by a distinct person. There was no way to control that each respondent only submitted a single filled in survey. All five responses might have come from the same person. I will keep that in mind the next time I see a Perl 5 survey. &gt; Even if five distinct people said they were selling software made with Perl 6, it is far from obvious that they were being truthful. I will also keep that in mind whenever anybody says anything. &gt; Just because one says "I am selling X" does not mean one has sold any X. So very true. Thank you for explaining this. 
Cool! Thanks for the response.
Thanks for the response. &gt; The P6 language makes it easy and natural to do the right thing so the community doesn't have to be bright. Right. As I'm sure I wrote upthread, an interesting idea I got from the Clojure community is, "The important thing about a programming language is not what it makes possible but what it makes idiomatic." 
There is no such thing as "a version of perl". As made very clear by Jonathan Worthington, the Rakudo pumpking, perl5 and perl6 are considered two separate languages in the same family. This choice of phrasing was also acked by Larry Wall. As such, unless or until Larry puts out a statement to the contrary, please respect his statements as to the nature of the two languages.
Mojolicious is built from the ground up to be asynchronous and works in tandem with the Mojo::IOLoop event loop (which is compatible with all of the other major CPAN event loops). Dancer2's asynchronous support only works when deployed on Twiggy (unfortunately an AnyEvent based server) which is a bit of a hack since asynchronous responses are not originally part of the PSGI protocol. Either of them can work with pretty much any part of the ecosystem, because Mojolicious is compatible with PSGI (though losing async features in that case) and pretty much anything else, and Dancer2 is built on Plack so of course is also PSGI compatible. They also both have substantial communities. My recommendation is just to go with Mojolicious since it was designed for what you're looking for from the start.
That's really cool, but it doesn't justify Liz pretending that Jonathan and Larry's opinions on the "two languages" versus "two versions" question doesn't exist. As ever, I wish perl6 the best of luck and have been enjoying playing with it from time to time.
Despite the Perl slogan TIMTOWTDI, insisting on your API consumers to pass things a certain way simplifies things greatly in the long run, especially when you want to add features or fix bugs later. You don't want to have to deal with maintaining compatibility for 17 ways to specify a parameter.
Thanks! I didn't know those details, and that's helpful. Do you know if the Mojo server is as good as the other PSGI ones, since this will limit my choice down to one? I'm basically making a REST API and what planning to do the database calls in a non-blocking way, just because I figured why not start that way if it's not really any harder. Do you think something like this is worth the effort before you have large amounts of traffic? 
I used to write this way; no longer and for the exact reason you state - I am not taking input from a human, a function is being called from another function. Let the programmer read the docs and get it right.
Hypnotoad is an optimized production web server, it's definitely capable. See the [cookbook](https://metacpan.org/pod/Mojolicious::Guides::Cookbook#DEPLOYMENT) for lots of info about deploying apps in Mojolicious. If your database is Postgres, [Mojo::Pg](https://metacpan.org/pod/Mojo::Pg) makes non-blocking queries much nicer and integrates with the Mojo::IOLoop event loop as well. However to answer your last question, it's not always worth the effort to try to do everything asynchronously until you need it. There is a lot of added complication doing things this way. However if you make use of promises or futures wherever possible, it can still be almost as simple as blocking code. Mojolicious has [Mojo::Promise](https://metacpan.org/pod/Mojo::Promise) as an implementation of this that's used by several components.
&gt; If your database is Postgres, [Mojo::Pg](https://metacpan.org/pod/Mojo::Pg) makes non-blocking queries much nicer and integrates with the Mojo::IOLoop event loop as well. If you want to do this with MySQL, you just have to do it yourself then with a non-blocking? &gt; In addition, non-blocking database queries are not always an improvement because it still adds the same amount, if not more load on the database Is this true even if the database is on another server? &gt; There is a lot of added complication doing things this way. This is why I initially thought maybe I wouldn't do it, be the Mojo example I saw using "render\_later" made it look pretty trivial, although I haven't actually tried it myself yet, so maybe I'm wrong about that.
&gt; If you want to do this with MySQL There is also a [Mojo::mysql](https://metacpan.org/pod/Mojo::mysql). It's a little less clean, but that's MySQL for you; it should be functional. &gt; Is this true even if the database is on another server? Yes, the database has to serve each query the same whether you send them blocking or non-blocking and that's usually the bottleneck. And database asynchronous APIs mostly suck and only allow one query per connection, so Mojo::Pg/mysql end up making a bunch of connections if you do several queries at once. But if you have a lot of slow queries then it's probably still worth to send them asynchronously to free up the worker for other requests. &gt; This is why I initially thought maybe I wouldn't do it It's true that Mojo provides a lot of tools to make it simpler, like promises especially. But there's always the fundamental problem that you have to keep in mind your code will not be running in order or at the point in the code where you write it, and that's tricky for most people.
&gt; Yes, the database has to serve each query the same whether you send them blocking or non-blocking and that's usually the bottleneck. But can't a database like MySQL serve multiple clients at once? And even if the database serves each query the same, aren't you freeing up the event loop on your local server to continue serving more clients? &gt; (This is why Hypnotoad preforks workers - that way different processes can simultaneously handle the blocking parts of request handlers.) Here do you mean so that each process is only responsible for blocking/handling events all on the same process? 
I'd strongly recommend nonblocking DB queries for *any* webapp that you're planning to scale up, since it's not just database load - it's latency as well. If it takes a few milliseconds for each roundtrip, you're going to have an artificial limit on the entire system just due to networking. It's also a lot easier to work on a system that's been designed to be async from the start, rather than having the async features bolted on afterwards (and for this reason I'd avoid Dancer for anything async). Might be worth keeping an eye on https://metacpan.org/pod/Future::AsyncAwait - when it's stable, it'll give you async code that looks almost the same as sync, just with a few `async` or `await` keywords scattered around.
&gt; But can't a database like MySQL serve multiple clients at once? Yes, the load on the database vs the time blocked in workers are both issues that really only show up under heavy usage, so it's at that point where you have to start considering the tradeoffs. &gt; Here do you mean so that each process is only responsible for blocking/handling events all on the same process? While one process is running code to handle a request (any part of the request handling other than waiting for asynchronous results) the other processes can pick up and start handling other requests.
&gt; perl5 and perl6 are considered two separate languages in the same family As I've stated before, I don't agree on the "sister" language meme. If you *really* want to keep it in the "family", I've said it like this: &gt;&gt; I consider Perl 6 more of a genetically engineered daughter language with the best genes from many parents And I still stand by that.
&gt; I'd strongly recommend nonblocking DB queries for any webapp that you're planning to scale up Are you not then turning away from DBI and the entire echosystem around that, like (just as an example) DBIx::Class? That seems like a *huge* downside that needs to be traded off against any benefits of going for Mojo::Pg/mysql (which are the only async db libraries in the Perl space that I know of). Since you seem keen on this, you might know: I'm curious about how to deal with transactions and multiple nonblocking queries on the same db connection. Or does the async db client libraries make additional db connections for each transaction and (in the case of no begun transation) concurrent statement? 
For Mojo you'd use the Hypnotoad app server. It seems very solid. The only annoyance I have experienced is that the zero-downtime code upgrade fails fairly often and therefore isn't really usable (you'll have to manually restart the server anyway to start using the new code). 
&gt; Are you not then turning away from DBI and the entire eco-system around that Yes. It's just not designed for that, so I find anything DBI-based - including DBIx::Class - pretty much unusable in this context. Sure, you can get partway there by using just the query generation parts (or directly through SQL::Abstract and co), but that still doesn't help much with `$obj-&gt;some-&gt;nested-&gt;relationship`-type code. There are also quite a few features that the simpler, sync-based frameworks just don't get involved with: one standard example here would be query consolidation (such as upgrading `select * from users where id = 1` to `select * from users where id in (list, of, pending, ids)`). Personally I use an ORM on top of IO::Async (via Net::Async::PostgreSQL), but I'm sure other people have been able to do something similar with the Mojolicious modules or other CPAN offerings. After all, we do have quite a bit of choice for database stuff, although when I looked a few years ago the async offerings were a bit thin on the ground: https://metacpan.org/pod/EntityModel#SEE-ALSO &gt; I'm curious about how to deal with transactions and multiple nonblocking queries on the same db connection Which database? For most of the common ones (Pg/MySQL/SQL Server) it's a single active query per connection, so you just manage a pool of connections, and definitely don't run unrelated things within the same transaction.
I'm a bit doubtful about the "proven tech" part - DBIx::Class is mired in politics, DBD::mysql has been an ongoing Unicode headache, Pg has had its own UTF-8 issues over the last year (and only gained binary COPY support last year), I see many people stuck trying to get SQL Server working via FreeTDS/ODBC... it's like saying "Perl is good at testing": as a community I think there are a few assumptions that perhaps don't stand the test of time. I don't have much direct experience with Mojolicious, but the Minion job framework seems like a good starting point for people who want to try out Mojo::Pg. The API isn't perfect, but I find it significantly better than DBI (unsurprising, given the 25 years or so between the designs).
Just making an observation: This becomes so simple in Perl 6, by using duck-typing instead... Ask for a Str(Any) and Perl 6 solves it for you. It will call the .Str method on the Object if it's not a Str already. Even then, .Str in an Str object just returns .self. So any Object that can be treated as a Str just needs to implement a Str method and done.
Perl 6 stole everything it could from any interesting language out there, including Ruby. Where Ruby got it right, they shamelessly copied.
Thanks for the correction and the interesting tidbit.
It's called immutable programming. It actually allows for `variables`, but they aren't really variables, they are just constant aliases.
Since I had to look it up (it's been a while..) TIMTOWTDI = There Is More Than One Way To Do It 
I already have my hands tied elsewhere. Tensorflow is just too large to be ported and then supported by one, two persons. It's just a swig glue and unholy amount of dense python written by thousands. Imo P6 needs a killer app on a level of Rails to get it out of it's current obscurity and into wide adoption. What that gonna be ? Hell if I know. One thing is clear, being a 'litle plucky sister' of P5 will not help. P5 is not in the state to help anybody. 
I've just started using Minion in a project and it's indeed quite nice.
FWIW, I think that [Cro](https://cro.services) is in a good position to become the "Rails" of Perl 6. Wrt the "little plucky sister", I consider Perl 6 more of a genetically engineered daughter with the best genes from many parents. A daughter with a difficult childhood, in which she alienated many, who is now getting out of puberty into early adulthood.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://cro.services) - Previous text "Cro" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e2bhbhg) 
&gt;"Are you not then turning away from DBI and the entire eco-system around that" &gt; &gt; Yes. It's just not designed for that, so I find anything DBI-based - including DBIx::Class - pretty much unusable in this context But can't you wrap any DBI statement in a promise/asynch part of the code and now it is async? So you are proposing not to use MySQL at all if I write non-blocking code?
&gt;Yes, but the load on the database vs the time blocked in workers are both issues that really only show up under heavy usage, so it's at that point where you have to start considering the tradeoffs. Okay, so in this instance you're just saying that the trade off is more complicated code? Or is it actually more inefficient to do non-blocking if you don't have high traffic? &gt; (This is why Hypnotoad preforks workers - that way different processes can simultaneously handle the blocking parts of request handlers.) So here a process that handles the blocking part is not the same as the process that was handling the non-blocking part?
Overloading in Perl 5 serves essentially the same purpose. The problem as the post discusses comes when you start trying to account for inputs that don't look close enough to what you asked for, rather than depending on the user to know how to pass you the right part.
Well, if it's the wrong Str, there's nothing the Type system can do about that, the user can just sent a wrong string anyway. So it may be worthy checking the Str you got is actually what you were expecting. And if they don't have a Str method, it's better to let the user have the standard "Use of uninitialized value of type Type in string context. Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful." exception, I think.
No. [It is not possible to magically make Perl code non-blocking](https://metacpan.org/pod/Mojolicious::Guides::Cookbook#Blocking-and-non-blocking-operations).
&gt; The only annoyance I have experienced is that the zero-downtime code upgrade fails fairly often and therefore isn't really usable (you'll have to manually restart the server anyway to start using the new code). I've been using Hypnotoad a long time and never experienced this. Have you raised it as an issue?
I thought that's what render_later or Promises accomplished? Not that the code is now non-blocking, but it's not on the event loop thread. I thought things like Promises were general, so you could put any long-running task in there without the main thread waiting?
Nope. Promises are just a way to write code that is already asynchronous in a more synchronous/organized way. Event loops are not threading (and threads in Perl should be avoided), but one way to run blocking code without blocking the event loop is to run it in [a subprocess](https://metacpan.org/pod/Mojo::IOLoop#subprocess).
Wow, that's really interesting. I'll have to take a look at how classes like Mojo::mysql and Mojo::UserAgent make their subroutines asynchronous, since this was a big appeal to me. Thanks for all of the help!
One more follow up-- hope you don't mind :) So if I created a model to wrap Mojo::mysql, I would lose the asynchronous aspect?
No, as long as your wrappers use the promise API (non-blocking).
I can't wait for Perl6 to ape Erlang and bake in quasi-preemptive multitasking on a VM level, thus creating MoarBEAM.
Erlang multitasking model was analized but it was discarded. Might be implemented as a module, though.
Function::Parameters, look it up.
&gt; I will keep that in mind the next time I see a Perl 5 survey. You should keep that in mind with any survey that can be submitted multiple times anonymously. &gt;&gt; Even if five distinct people said they were selling software made with Perl 6, it is far from obvious that they were being truthful. &gt; I will also keep that in mind whenever anybody says anything. Not equally applicable. For example, if five people responded to a survey, and said lasagna is their favorite food, there is no reason to doubt the veracity of those statement for we run into people like lasagna in the course of our daily lives. However, at this point, I would have to actually see a case of someone selling software made with Perl 6 to believe that person is selling such software. &gt;&gt; Just because one says "I am selling X" does not mean one has sold any X. &gt; So very true. I agree. &gt; Thank you for explaining this. You are welcome.
Quite a shortsighted position, that programmer could be you, and the input verification will save you a lot of pain. But 'don't do it', declare your subs via Function::Parameters instead.
Aaahhh... Thank you for explaining this to me again!
You can hide cgi behind nginx I believe. You don’t have to go the whole framework hog.
Ubuntu. I haven't raised it as an issue. It doesn't "break", there's a "Starting zero downtime upgrade" or whatever the log message is, and then sometimes a "Failed zero downtime upgrade" log message later, so it doesn't look like a bug per se, but as an expected failure. But sure, I should have moaned about it maybe. This might have actually improved recently, I think the log messages are slightly different and it *seems* that it doesn't happen as often, but that may not be true. It definitely still happens though.
EC2 is just a Linux VM, right? You should be able to install Apache httpd with mod_cgi or mod_perl to run the existing CGI programs like in the past. Simple beats modern here, I think. Or is using nginx a hard requirement? Or do you want to rewrite the CGI programs? 
using [fcgiwrap](https://www.nginx.com/resources/wiki/start/topics/examples/fcgiwrap/) will be the most straightforward way to do it
&gt; As I've stated before, I don't agree on the "sister" language meme. You don't have to agree. But it would be preferable were you to make it clear that you're disagreeing with the publically stated positions of both the inventor of both languages and the lead developer of the main perl6 runtime when you give your alternative view.
Hey, matthewt, just a quick heads-up: **publically** is actually spelled **publicly**. You can remember it by **ends with –cly**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey, Mr. Bot! You may be shocked to learn that [very few words](https://www.litscape.com/word_tools_enable_censored/words_ending_with.php) actually end with **-cly**. Over 1000 words should correctly end with **-cally** instead, such as `medically`, `comically`, `mechanically`, `generically` and `biologically`, to name a few. Stop telling people to use **-cly** as a general rule, because while it's correct in this specific case, **-cally** is much, *much* more common, and as a result, telling people to use **-cly** as a general rule does more harm than good. The bot above likes to give structurally useless spelling advice, and it's my job to stop that from happening. [Read more here.](/8y3us6) --- ^^^I ^^^am ^^^a ^^^bot, ^^^and ^^^I ^^^make ^^^mistakes ^^^too. ^^^Please ^^^PM ^^^me ^^^with ^^^feedback! ^^^| ^^^ID: ^^^e2dop51.65ee
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF. Leaving original comment unedited so everybody can laugh at me.
As you may have found, the first way is a syntax error. You might want to use the ternary operator instead: my $my_var = cond1 ? 'a' : cond2 ? 'b' : cond3 ? 'c' : 'd';
Have a look here: https://perldoc.perl.org/perlsyn.html#Basic-BLOCKs
Affidavit: I hereby acknowledge that my standpoint with regards to the status of Perl 6 as a daughter language, is not publicly shared by Larry Wall or Jonathan Worthington.
This does work, with [`do`](https://perldoc.perl.org/functions/do.html) my $my_var = do { if (cond1) { 'a'; } elsif (cond2) { 'b'; } elsif (cond3) { 'c'; } elsif (cond4) { 'd'; }; };
I don't think that's the most straightforward way. Like OP, I just did some significant googling and I still can't figure out precisely what configuration to put in the `server {…}` block of nginx.conf. Assumptions: `cgi-bin` directory resides in `/srv/www` and it has an `index.pl`: #!/usr/bin/env perl use strict; use warnings FATAL =&gt; 'all'; use CGI qw(); my $cgi = CGI-&gt;new; STDOUT-&gt;print($cgi-&gt;header('text/plain; charset=UTF-8')); STDOUT-&gt;print('Hello world!'); I tried a dozen different things and couldn't make it work with FCGI. ---- With reverse proxy, it worked immediately. plackup -l 127.0.0.1:8080 -s Starlet -MPlack::App::CGIBin -e ' Plack::App::CGIBin-&gt;new(root =&gt; "/srv/www")-&gt;to_app ' &amp; `nginx.conf` in a `server {…}` block: location ~ ^/cgi-bin { proxy_pass http://127.0.0.1:8080; } ---- Prove me wrong, show me a simpler solution using fcgiwrap.
You have to be careful with this to have an 'else' case. Otherwise one of the conditions (probably the last one) will end up getting assigned to the variable if all of the conditions are false, it would be undefined behavior.
lol
I believe if that occurs, it means that one or more of the workers did not gracefully exit before the [upgrade timeout](https://metacpan.org/pod/Mojo::Server::Hypnotoad#upgrade_timeout). You could try increasing that timeout in config.
Alternatively, there's also ? : jiust as in C or JavaScript. There's also a bunch of other languages supporting the construct, but they didn't always get the precedence rules right. (for example PHP) my $my_var =(cond1) ? 'a' : (cond2) ? 'b' : (cond3 )? 'c'' : (cond4) ? 'd' : undef; 
I've not done fcgiwrap specifically with nginx, but our perl based app uses fastcgi to talk to nginx. The most minimal nginx config looks like: location ~ ^/cgi-bin { include fastcgi_params; fastcgi_pass unix:/some/path/to/fastcgi/unix.socket; } `fastcgi_params` is a file in /etc/nginx/ that contains a bunch of fastcgi_param directives (basically the translation from fast cgi env vars to nginx vars). It comes with Debian/Ubuntu nginx packages (and probably other distros, too). With fast cgi you might have to play around with `SCRIPT_NAME` and `PATH_INFO` (which are notoriously finicky when talking to different fastcgi implementations): fastcgi_param SCRIPT_NAME &lt;something&gt;; fastcgi_param PATH_INFO $fastcgi_script_name; Incidentally, I just did `man fcgiwrap` and it contains a 3 line nginx snippet as an example. It also documents what it expects `SCRIPT_NAME`, `PATH_INFO`, and `DOCUMENT_ROOT` to be.
From my reading it doesn't look like there are existing CGI programs. In which case I'd suggest to write a Mojolicious or Plack-based (Dancer2, Catalyst, Web::Simple) application so it could be transparently deployed in whatever manner ends up being suitable.
Since you specifically mentioned email scripting, this bit will be separate from however you choose to write and deploy the web application. I recommend [Email::MIME](https://metacpan.org/pod/Email::MIME) and [Email::Sender](https://metacpan.org/pod/Email::Sender), or [Email::Stuffer](https://metacpan.org/pod/Email::Stuffer) for a simple combination of those two.
The boilerplate needed will be right there in `/etc/nginx/fcgiwrap.conf` as mentioned on that page I linked. Within that boilerplate you will find the `fastcgi_pass` directive pointing to a listening *socket* rather than *localhost* as you have configured with the `proxy_pass` directive. I agree that nginx setup can be unnecessarily convoluted, not helped by the fact that Debian maintainers add their own twists to the config files that alter the relevance of answers found through Googling... but fundamentally it's most straightforward to use fcgiwrap to make CGI scripts work with the FCGI boilerplate provided by nginx
Now that sounds like a whole week full of fun debugging to find! (Bring sandwiches.)
&gt; but fundamentally it's most straightforward to use fcgiwrap You keep saying it, but still can't provide a working configuration when the CGI program is `/srv/www/cgi-bin/index.pl`.
OP asked for the simplest approach, frameworks are out. [Plack::Request](http://p3rl.org/Plack::Request)/[Plack::Response](http://p3rl.org/Plack::Response) should feel somewhat familiar to a CGI.pm programmer, yet earn all the advantages.
That entirely depends if you mean "simple" or "simple". Using a framework is by far the simplest modern solution for the author. [Web::Simple](https://metacpan.org/pod/Web::Simple) would be appropriate for the other definition of "simple".
Even if you write it with [CGI.pm](https://CGI.pm), it might be better to run it as a Plack/PSGI app with one of the following: [https://metacpan.org/pod/CGI::Emulate::PSGI](https://metacpan.org/pod/CGI::Emulate::PSGI) [https://metacpan.org/pod/CGI::Compile](https://metacpan.org/pod/CGI::Compile)
perfect analogy timing wise. 
If your server block contains `root /srv/www;`, just adding `include /etc/nginx/fcgiwrap.conf` to the server block will do the job, because the file contains a location block for the cgi-bin directory with the directives needed. If you also have `fastcgi_index index.pl` within the cgi-bin location block it should load the right file, fcgiwrap has to be running as well for the socket to be active, but aside from that it's just that location block with fastcgi directives you need
How about an anonymous subroutine? $x = 1; my $var = &amp;{sub {if($x ==1){return 'foo'}else{return 'bar'}}}; print "var = $var\n";
TMTOWTDI `my $var = ( cond1 &amp;&amp; 'a' ) || ( cond2 &amp;&amp; 'b' ) || ( cond3 &amp;&amp; 'c' ) || 'd'` But just because you can doesn't mean you should. 
If your conditions look like this: my $my_var; if ($foo eq 'abc') { $my_var = 'a'; } elsif ($foo eq 'def') { $my_var = 'b'; } ... you can replace them with this: my $my_var = { abc =&gt; 'a', def =&gt; 'b', ... }-&gt;{$foo}; Of course, it's not a universal solution.
seconding Perl Monks for questions (at the Monestary gates at first. I heavily studied Sam's Learn Perl in 21 days (Not in 21 days) but that book was dogeared and disintegrated when I was done with it (15 years ago - the green one).
what does "do" do?
From its [documentation](https://perldoc.pl/functions/do): &gt;Not really a function. Returns the value of the last command in the sequence of commands indicated by BLOCK. When modified by the while or until loop modifier, executes the BLOCK once before testing the loop condition. (On other statements the loop modifiers test the conditional first.)
https://metacpan.org/pod/release/ETHER/Moose-2.2010/lib/Moose/Util/TypeConstraints.pm#role_type-($role,-?$options) package Foo; use Moose::Util::TypeConstraints; role_type 'This::Is::The::Role::Type';
The error should disappear if you load the role before you write a type check that uses the role. So in your `Foo` package I'd expect a `use This::Is::The::Role`. Unfortunately, module loading has global effects in Perl so this kind of problem can go undetected depending on the order in which a downstream module imports its dependencies. Note that Moose cannot tell in advance whether an `isa =&gt; 'Something'` type constraint is supposed to constrain on a role or class – it needs to inspect the `Something` package for that. It is not possible to load the package implicitly because the package might not be a module (i.e. when you have a single .pm file that declares multiple packages/classes). So by default, Moose seems to assume that unknown type names are class constraints, not role constraints.
For completeness, three ways in P6 that correspond to three of the P5 suggestions in this thread. ---- my $my_var = cond1 ?? 'a' !! cond2 ?? 'b' !! cond3 ?? 'c' !! 'd'; In P6 the ternary operator uses two characters per branch rather than one and uses `!!` for the "not" branch rather than `:`. I've seen a lot of P6 devs use the formatting I show. ---- Insert `do`: my $my_var = do if (cond1) { 'a'; } elsif (cond2) { ... }; So, like the P5 solution, but no need for an extra set of braces. (In fact in P6 you can drop all the parentheses and colons you've included in in your example code.) As grinnz notes, if none of the conditions match then `$my_var` will end up not being explicitly defined. Because P6 gives such undefined values a typed (though "undefined") value anyway, any resulting bug may be less pernicious -- you might get by with just an apple rather than sandwiches -- but perhaps the following would be a good habit: my $my_var = default R// do if cond1 { ... (`R//` evaluates the expression on its right first. If it's undefined it returns its LHS.) ---- Finally: my $my_var = { abc =&gt; 'a', def =&gt; 'b', ... }{$foo}
Regarding the immutability of Lists: I've just uploaded a module to CPAN: [Tuple - provide an immutable List value type](http://modules.perl6.org/dist/Tuple:cpan:ELIZABETH). I think this will provide the immutable `List` features that you were looking for. 
I would recommend using `(sub {...})-&gt;()` to call an anonymous sub. But this isn't much different from using a do block in this case which is a bit clearer.
For completeness, PHP: $my_var = cond1 ? 'a' : (cond2 ? 'b' : (cond3 ? 'c' : (cond4 ? 'd' : null)));
This is really the wrong way to do this. The callee wants the cookie value. Is `Str(whatever)` going to deliver that? Maybe, maybe not. A cookie typically has a name and a value, both of which are strings. Will `Str(cookie)` deliver the value? Or the name? Or will it deliver a string like `name: value`? Or something like `HTTP::Cookie(0x436c1d)`? There's really no telling. No, this fails to solve the problem, in the exact same way that the original code failed. The callee wants a certain string. It should not have to guess how to obtain that string. If the caller happens to know that it is passing a cookie object whose `Str()` will return the correct string, then fine, but it is still the caller's responsibility to ensure that, and there is really no benefit to doing that instead of just passing `Str(cookie)` anyway.
Can anyone produce a working solution according to these instructions? /u/DCLXV: have you actually tested what you were telling?
yes, your hello world script runs fine for me, i'm using the default `/etc/nginx/nginx.conf` that includes `/etc/nginx/sites-available/default` and just added `include /etc/nginx/fcgiwrap.conf` to the server block of `default`. If that config passes parsing but doesn't work then it should at least leave some clue as to why in `/var/log/nginx/error.log`, otherwise the issue could be with fcgiwrap
Yes, if the object doesn't produce the right string through the .Str method, the user has to do it himself.
There is no user. The question that must be answered is: which part of the _program_ should know how recognize this sort of object and extract the desired string from it. If the answer is the callee, you're right back where you started. If the answer is now “the caller, but in this case the caller can pass the entire object, knowing that it will _pretend_ to be the right string”, okay, I guess, but I don't see any benefit to doing it that way over the obvious non-magical way, which is just explicitly passing `cookie.Str`.
Thanks for considering both sides. I meant simple in the sense of relatively straight forward to get something done in a sensible manner avoiding the known likely pitfalls. Rather than simple to understand but also a foundation for bigger things. Thank you to both of you for your considerate responses. I'll research all suggestions along with the rest of the responses in this post. It's so great to get considered, reasonable, non-flaming responses. Thank you again.
Thanks for going to substantial effort to look into this. I can confirm the EC2 instance in question includes ... `/etc/nginx/fastcgi_params` so it appears there are some signs of FastCGI awareness but as yet, I'm unsure how that got there. I've asked my mate who was on holidays until today. I did notice the mapping of those regular, and often helpful, variables in that file. Gave me some hope! Thanks for the tips from your own minimal config along with some gotcha warnings for those variables.
Thanks for the tips! I'll definitely look into those. I agree that getting Perl scripting set up is step one. Installing modules step two. Then finishing up the scripts I guess :) I've used Stratopan with some success before to install modules so I was hoping to leverage that again if needed.
Thanks. I'll check those out. I do want to get my head around at least a PSGI Hello World at some point, if not necessarily the whole concept overall in one shot! :)
I'm reminded of Ruby's [safe navigation`&amp;.`](http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/) operator...
https://stackoverflow.com/a/18390800/46395
that last paragraph is very depressing :'(
Do you think we should tell him the camel book is on its 4th edition?
[https://opensource.com/article/18/7/confessions-recovering-perl-hacker#comment-159016](https://opensource.com/article/18/7/confessions-recovering-perl-hacker#comment-159016)
I tried all of these, Function::Parameters were most efficient of the bunch. Try to benchmark these solutions. The author of Method::Signatures even stopped development of the module when he saw Function:: Parameters, because it was so superior.
You are the best.
I'm two minutes in and this guy is smarmy. I waiting to see some code, but I've been doing code for longer, so we shall see. BASIC/Pascal/Fortran/bit of COBOL.
PDF24 can be used as well here: [https://tools.pdf24.org/en/unprotect-pdf](https://tools.pdf24.org/en/unprotect-pdf)
I know. But I'm not sure I have bookshelves sturdy enough: https://www.programmingperl.org/2012/03/20-years-of-programming-perl/
It says more about my lack of programming over the last few years than about Perl. That's my fault, not the language's!
Did we watch the same video? The presenter gives some tips I think many people would easily agree are almost a minimal set for producing maintainable software. Though likely only useful if you are quite new to producing code with others. 
... I kind of really want to *get* the 4th ed now, I'm not gonna lie.
The examples aren't great - for example, in "write code that expresses intent": `set_numeric_thumbnail_size` talks about numbers right there in the name... but then it takes a string such as `xsmall` as a parameter. Descriptive variable names can be useful sometimes, but `$elapsed_time_in_days` is on the other extreme. I don't think he noticed the disconnect here between the "variables are your nouns" and "here's a phrase that looks fine on its own". Does well-written prose repeat phrases such as "elapsed time in days"? Only when it's trying to make a point, and I suspect the key point in the code that needs this variable is perhaps *not* that the time is elapsed, and measured in days - as such this risks obscuring important semantics. Too much verbiage is not a sign of clean code. "Comments are often lies waiting to happen" - the slide content would typically emphasise "document why, rather than what/how" instead. anyway, I think the original 3-letter summary is actually pretty accurate - there are elements of useful content in here, sure, and it's hard to do an awesome summary of the topic in just 10 minutes. Overall I'd be inclined to point people towards the referenced "clean code" book and other sources rather than this talk: https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ 
Your last point is the most salient.
Are you saying that someone may remove the directory just before you attempt to write the file to that directory?
Did it work?
That's how I read it. If multiple processes write to that directory I wouldn't remove it even on removing the cache.
Well I see from your snippet you are doing a syscall to make the directory before writing. Why not add a syscall to touch the file after that as well?
`IO::All` has a method, `assert` that creates the path in the same operation if it does not exist: https://metacpan.org/pod/IO::All#assert
This topic should be ideally documented with Perl, but I can't find something relevant apart from http://p3rl.org/perl5120delta#@INC-reorganization &gt; is C:\Perl\site a common folder No idea what common folder is. &gt; how do files get in there? By user installation, from CPAN clients and manual installation. When you install a fresh Perl, you will see that `site` is empty. The other two directory trees are `vendor` where OS-provided packages go (or in the case of Strawberry Perl, extra modules that the Strawberry maintainers thought are nice to have), and the prefix-less one where core modules (i.e. the modules that ship with Perl itself) go. › /usr/bin/perl -E'say for @INC' /usr/lib/perl5/site_perl/5.26.2/x86_64-linux-thread-multi /usr/lib/perl5/site_perl/5.26.2 /usr/lib/perl5/vendor_perl/5.26.2/x86_64-linux-thread-multi /usr/lib/perl5/vendor_perl/5.26.2 /usr/lib/perl5/5.26.2/x86_64-linux-thread-multi /usr/lib/perl5/5.26.2 /usr/lib/perl5/site_perl Vendor is optional, e.g. my self-compiled Perl: › perl -E'say for @INC' /home/daxim/local/share/perlbrew/perls/perl-5.26.2/lib/site_perl/5.26.2/x86_64-linux-thread-multi-ld /home/daxim/local/share/perlbrew/perls/perl-5.26.2/lib/site_perl/5.26.2 /home/daxim/local/share/perlbrew/perls/perl-5.26.2/lib/5.26.2/x86_64-linux-thread-multi-ld /home/daxim/local/share/perlbrew/perls/perl-5.26.2/lib/5.26.2 &gt; I just copied the site folder from the old installation... but I have a feeling that's not the correct course of action... Yes, that's not going to work in the general case. Perl is not binary compatible between versions (e.g. 26 → 28), but only between subversions (e.g. 26.1 → 26.2), so all XS modules (those C extensions that compile to DLLs) and similar stuff breaks. Run the [`recompile` command](http://p3rl.org/CPAN#recompile) in the CPAN shell to fix this.
Parrot support wasn't dropped in 2011, so why are you linking that as a reason for Parrot being dropped? Perhaps you should look at http://pmthium.com/2015/02/suspending-rakudo-parrot/ (2015) which says pretty much the same thing I did. (Note that MoarVM which was the main VM at the time was only released the year prior) Parrot was the main VM until mid 2014, more than three years after the messages you linked. (The JVM has never been the main VM, although it was a very close second until MoarVM) Now you could speculate as to why Parrot was so far behind, but it doesn't matter. My speculation is that there was almost no-one who understood all three layers of the Parrot backend. I think the most important point is that the people who were in charge of Parrot didn't understand the upper layer of NQP. Also the Parrot backend was bottom-up, whereas the others are all done top-down. (Features get added, redesigned, or removed as NQP needs them) The bottom-up of Parrot made a lot of sense in the beginning, since that was really the only way to bootstrap the compiler. It doesn't anymore. Honestly without the JVM backend coming along to educate us to how much easier it could be, we would most likely be waiting for another 10 years for the official release. If someone came along and rebuilt the intermediate layers of the Parrot backend so that it was top-down it would probably still be limping along just like the JVM backend is. (The JVM backend is still missing features like proper grapheme based strings.) Yes jnthn implemented the Parrot object system, he also built MoarVM largely himself. MoarVM got to be faster than Parrot within only one year. It is also designed similarly to every other recent JIT capable VM. The idea behind Parrot was that it was similar to machine code so creating a JIT would be easier. It never got a real JIT. Again I think Parrot was a neat idea. But I also now think that it may have been fundamentally flawed from the outset. Do you really care more about your pet Parrot than for the language that was the whole reason it existed in the first place?
It did, however my concern is that the TLS issue that was resolved by updating ActivePerl is not corrected in the site folder. 
Have a look at make\_path from the core File::Path module. It's better than shelling out to mkdir.
yes. how else can it throw the exception I mentioned?
&gt; system("mkdir -p $cacheDir 2&gt; /dev/null"); Don't use shell commands for stuff that Perl already can do. You're also suppressing any error that might occur, that's bad programming, you just run into bugs and don't know what's going on. Instead use the `make_path` function. It will throw an error when something goes wrong. use File::Path qw(make_path); make_path $cacheDir; # program might abort here, e.g. # "mkdir /root/foobar: Permission denied at …" You could catch the error if aborting is not acceptable: use File::Path qw(make_path); use TryCatch; try { make_path $cacheDir; } catch($err) { warn "could not create directory: $err"; # Now what? Try another directory from configuration? # Ask the user for a different one? } 
&gt; No idea what common folder is. I'm a .net dev (and vb before .net existed) so very unfamiliar with Perl. Still have a few legacy apps that have been running with no needed interaction from me. The previous developer sometimes did things in a strange way and since I had a difficult time trying to query this issue, I wasn't sure if "site" was something everyone used, or a folder he created. It might have helped if I said "commonly used directory" but maybe that's still confusing. &gt;Run the recompile command in the CPAN shell to fix this. Thanks! I'll so some research on this (obviously by my question I have no idea how Perl works so my first search parameters will be to figure out how to access CPAN) 
Mojo comes with [Mojo::File](https://metacpan.org/pod/Mojo::File) which wraps several operations like this with proper error checking, a clone of the venerable [Path::Tiny](https://metacpan.org/pod/Path::Tiny) which you could also use instead easily enough.
Yeah I'm not sure there is an easy way of making filesystem operations like this atomic, you could possibly make the directory temporarily undeletable somehow, perhaps if the programs run as different users that would be possible. For a robust solution locking is probably the best option, Fcntl::flock may do the job.
The best documentation for the layout of core lib directories is probably in [EUMM](https://perldoc.pl/ExtUtils::MakeMaker#make-install). Essentially, you have three trees: privlib/archlib (for core modules), sitelib/sitearch (for cpan clients to install to), vendorlib/vendorarch (for package managers to install to). The arch variants are for modules requiring compilation, and come first in lib order. privlib/archlib was loaded first before 5.12. As the section you linked from the perldelta notes, it was reorganized in 5.12 to load site and vendor libs first so that user-installed upgrades to dual-life (core and CPAN) modules will take precedence.
By the way, currently AI::MXNet supports Linux and Mac. MXNet's Python API works on Windows as well. I have no experience with Windows platform. Anybody needs AI::MXNet on Windows to a point of helping to port it ?
Understood. It's just a very unusual situation. 
ok why TryCatch and not TryTiny module?
[Try::Tiny](http://p3rl.org/Try::Tiny) has annoying shortcomings: `return` does not jump out of the subroutine, the error overshadows `$_` except with a lexical topicaliser and that behaviour changed a couple of time. All of this is documented, but an infrequent source of bugs. In [TryCatch](http://p3rl.org/TryCatch) `return` works normally and it does not need to mess with `$_` because you pick the error variable name. It can also [dispatch on error objects](https://stackoverflow.com/a/48985396/46395) which requires an extra statement with Try::Tiny. When I am going to install a module for error handling, I might as well use the better one.
&gt; not found That's not a very good error message. ☹ Do you need a proxy to access hosts outside of your organisation? Is your version of Perl [still recent/supported](https://www.activestate.com/activeperl/downloads)? I know for certain that public PPM repositories for old versions are switched off.
Better is unfortunately a matter of perspective, because TryCatch uses [Devel::Declare](https://metacpan.org/pod/Devel::Declare#WARNING), so I would not put it anywhere near a production codebase. [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) is a real keyword plugin that also avoids many issues with Try::Tiny (performance, sub calls) and thus works similarly to try/catch in other languages, its only shortcoming is the lack of built in exception dispatch.
dupe of https://www.reddit.com/r/perl/comments/8z9kpa/a_salutary_tale_of_language_addiction/ ?
I know too little about Perl to answer that, however, here are the results of perl -v: This is perl 5, version 26, subversion 0 (v5.26.0) built for MSWin32-x86-multi-thread-64int (with 1 registered patch, see perl -V for more detail) Copyright 1987-2017, Larry Wall Binary build 2600 [403866] provided by ActiveState http://www.ActiveState.com Built Aug 30 2017 16:46:44 Perl may be copied only under the terms of either the Artistic License or the GNU General Public License, which may be found in the Perl 5 source kit. Complete documentation for Perl, including FAQ lists, should be found on this system using "man perl" or "perldoc perl". If you have access to the Internet, point your browser at http://www.perl.org/, the Perl Home Page. 
That's recent and supported, so that's not the problem. If it's also not the lack of proxy configuration, then I'm out of ideas. Try: * https://code.activestate.com/lists/group/activestate/ * https://community.activestate.com/forum 
The `merge` doesn't return a URL. That's a [Mojo::Parameters](https://mojolicious.org/perldoc/Mojo/Parameters#merge) object. The URL has already been modified in place so use that same variable: use v5.10; use Mojo::DOM; use Mojo::URL; my $html = '... &lt;a href="http://www.example.com/foo?bar=baz"&gt; ...'; $doc = Mojo::DOM-&gt;new( $html ); $doc -&gt;find('a') -&gt;each( sub { my $url = Mojo::URL-&gt;new( $_-&gt;attr( 'href' ) ); my $new_query = $url-&gt;query -&gt;merge( 'q_key1' =&gt; 'something', 'q_key2' =&gt; 'something2' ); # say "new query is ", ref $new_query; # Mojo::Parameters $_-&gt;attr( 'href', $url ); } ); say $doc; 
thx
I also wonder about the new file getting wiped out right after by another admin calling clear cache. Seems strange.
&gt; Parrot support wasn't dropped in 2011, so why are you linking that as a reason for Parrot being dropped? Now you could speculate as to why Parrot was so far behind, but it doesn't matter. Because: * I was there * I read the mailing list and looked at the contribution graphs on Github, so [I know when people stopped working on Parrot]https://github.com/parrot/parrot/graphs/code-frequency) -- three years before Patrick's post (I do find the comments on Patrick's post amusing. "Parrot doesn't support NFG, but we never filed a ticket about it or told anyone about it until now.") &gt; My speculation is... Read the links I've provided. &gt; Parrot was the main VM until mid 2014 &gt; MoarVM got to be faster than Parrot within only one year. It's easy to be faster when you're not complete. This is a silly argument. &gt; Do you really care more about your pet Parrot than for the language that was the whole reason it existed in the first place? At this point, yes -- but not because I care much about Parrot. I continue to be disappointed that the narrative about Rakudo, Parrot, and Moar is so dishonest. I understand why it is -- "we sabotaged another TPF project to start our own, outside of TPF's control" is not a great story.
What's the proper way to add an anchor to the query string as well? Merely add it as a part of a parameter?
The fragment is separate from the query string. https://metacpan.org/pod/Mojo::URL#fragment
and how can I check whether or not a param "a" exists in the query string?
Sure but its an exaggerated point for illustration, \`$days\` is better than \`$x\_5\` was more the point. In a language with stronger types \`set\_numeric\_thumbnail\_size\` the intent is on the attribute being set. So I would assume from that naming there is a \`$self-&gt;numeric\_thumbnail\_size = &lt;somethng&gt;\` happening somewhere in that method. It says nothing about what the parameter being passed would be, and very common OO practice is you would have a multi method for taking things like \`'xsmall'\` \`250\` \`250.0\` or maybe even some full blown OO enum. \`$requested\_size\` doesn't immediately scream numeric to me other than its about size. If we were in some kind of reasonable language with stronger types or at least type hinting and multi methods (see Perl 6) then I'd maybe expect more than one candidate based on type setting $self-&gt;numeric\_thumbnail\_size
Yes i tried to install AI::MXNet on strawberry perl on windows before month but the install didn't works , i will be glad to use it on windows .
Cool, please go here https://github.com/apache/incubator-mxnet/issues and create a new issue about the matter. Add all errors/system/perl info in here as well. I'll start looking into it after that but can't make any promises, because I literally have exactly zero experience with Windows platform. Shouting again: if anybody with experience wants to help with port, help please.
It shouldn't be proxy. The server is pretty well locked down, but it can access the internet. I tried this for fun: ppm install MinGW And received this result... Downloading ActiveState Package Repository packlist...not found ppm install failed: Can't find any package that provides MinGW 
You might be out of luck installing that on strawberry. Nobody has reported a successful install of that on windows yet: http://matrix.cpantesters.org/?dist=PDL-NetCDF+4.20 That said, Strawberry has a package with PDL preinstalled, maybe if you grab that it might have the dependences for netcdf. Otherwise it might simply be easier to do it on linux.
As a bonus, Syntax::Keyword::Try is by far [the fastest](http://blogs.perl.org/users/diab_jerius/2017/04/how-fast-can-you-try.html) exception handling module.
Get the strawberry with PDL. Go here: [http://strawberryperl.com/releases.html](http://strawberryperl.com/releases.html) CTRLF for PDL.
Is this saying I need to change to a lower version of Perl? http://code.activestate.com/ppm/MinGW/
&gt; I need to change to a lower version of Perl? It's mind-boggling they're not giving you the developer tools/compiler for recent versions. I hope it's a mistake/misconfiguration on their part because that kind of tactics is not the Activeperl I remember. I personally would rather switch to [Strawberry](http://strawberryperl.com/), another Perl distro for Windows, than to downgrade. That one does not keep dependencies hostage at all. &gt; "LWP" package (and maybe it's dependencies if any) http://deps.cpantesters.org/?module=LWP&amp;perl=5.26&amp;os=Windows+%28Win32%29&amp;pureperl=1 You're lucky, all of them except `HTML::HeadParser` are pure-perl, so they are installable with the cpan client without MinGW. [dmake](https://metacpan.org/release/dmake) can be installed manually, see instructions within the zip archive.
Thank you for creating this \o/
 use List::Util 1.33 'none'; sub only_in_first { my ($first, $second) = @_; return [grep { my $x = $_; none { $_ eq $x } @$second } @$first]; } sub only_in_first { my ($first, $second) = @_; my %in_second = map { ($_ =&gt; 1) } @$second; return [grep { !$in_second{$_} } @$first]; }
In Perl 6 I wouldnt bother with a function since there is an operator `@a (-) @b`
very cool, didn't know about that
Is it common to do set arithmetic in Python on lists? › re.pl $ use Set::Scalar qw() $ Set::Scalar-&gt;new(15..50) - Set::Scalar-&gt;new(23..42) (15 16 17 18 19 20 21 22 43 44 45 46 47 48 49 50) An expression isn't worth a function.
I just googled it and yeah, I could've just used a.difference(b) 
If I knew list _b_ was not going to get too large I'd perform an additional step of putting each item from _b_ into a temporary hash for extremely fast look-up which would speed iteration over list _a_: sub only_in_a { my ( $ref_list_a, $ref_list_b ) = @_; my %hash_of_b = map { $_ =&gt; 1 } @$ref_list_b; my @list_result = grep { ! $hash_of_b{$_} } @$ref_list_a; return( @list_result ); } my @list_a = qw( red green blue yellow ); my @list_b = qw( pink blue orange ); print( join( ",", only_in_a( \@list_a, \@list_b ) ) ); Outputs: red,green,yellow
Woosh!
I was going to include a Set::Scalar solution, but it does not retain the order of the original list (as appropriate for set arithmetic, but not lists).
If someone were kind enough to implement a perl6 backend for SWIG, then a TensorFlow interface might magically appear.
Yep, thanks Grinnz. Very nice tool. 
No woosh.
On assumption that the values in list are strings, there exists: my %tmp; @tmp{@a} = (); delete @tmp{@b}; return keys %tmp; This, of course, avoids list scanning so the algorithm is efficient. Unfortunately, Perl hash keys have not been generalized to be arbitrary objects, so there is that significant limitation with this approach.
Does the background process need to be always running? If it's something that just needs to run periodically and update a cache I wouldn't over engineer it and run a cron job at relevant intervals.
P.s. remember that you can create a Mojolicious::Command for your app so it has access to the same helpers and config as your primary app.
I forgot to mention that I'm unable to run cron jobs, because the app is running inside a Docker container, and our current setup doesn't allow for cron jobs. **EDIT:** Also, with 16 workers it would result in having 16 workers running the same cron job, which is exactly the thing I want to avoid. However, I've seen [Mojolicious::Plugin::Cron,](https://metacpan.org/pod/Mojolicious::Plugin::Cron) but the problem would be the same: how can I make sure that only one process is running at all times. Is there a way the 16 workers can communicate with each other? IPC?
You want to end up with (say) 17 workers, 16 of which aren't running sub processes. Could the first one to start, check for a running worker with a particular name, and if not found change its own man's to that? The one with the unique name is the worker entitled to run the sub process. I'm probably displaying my ignorance of Mojo, Docker, and modern Perl in general here, please let me off lightly if so. 
That returns a set, though, not a list. `&gt; say (1..5) (-) (4..8)` `set(1 2 3)` `&gt; say ((1..5) (-) (4..8)).keys` `(1 3 2)`
These will be 16 prefork'ed processes, so I can't really tell which one is first. Also, workers can die (or otherwise quit) and be replaced with a new one. One other option I've thought of, is to use [Proc::ProcessTable](https://metacpan.org/pod/Proc::ProcessTable) in a recurring Mojo::IOLoop, ie. every Xth second list all the processes, choose one of them, and then have that one act as "master worker" at that moment. Pseudo-ish and untested: sub startup { my $self = shift; # Choose a master worker every 15th second Mojo::IOLoop-&gt;recurring( 15 =&gt; sub { my $loop = shift; # Create a list of running workers my $proc = Proc::ProcessTable-&gt;new; my @pids = (); foreach ( @{$proc-&gt;table} ) { next unless ( $_-&gt;cmndline =~ m, prefork , ); push( @pids, $_-&gt;pid ); } @pids = sort { $a &lt;=&gt; $b } @pids; # Choose the last worker as master worker and start # background process if ( $$ == $pids[-1] ) { my $subprocess = Mojo::IOLoop::Subprocess-&gt;new; $subprocess-&gt;run( sub { my $sub = shift; # Do something expensive }, sub { my $sub = shift; # Result/error handling }, ); } } ); } Not sure if this is very pretty, though, plus it's a disaster if the subprocess runs for longer than 15 seconds, meaning that subprocesses will start adding up. This could probably be resolved by creating a "lock file", i.e. if it exists, don't start a subprocess. If it's too old, assume that the subprocess died/quit unexpectedly, delete the lock file. Or something. :-/ **EDIT:** Come to think of it, this method can also fail. Imagine having 16 processes, pid #1 to #16. #16 is chosen as master worker, but it dies. The method above will then choose #15 as master worker, while the newly spawned pid #17 will choose itself as master worker. :-/
Most efficient Perl 5 solution that preserves order is: use Array::Utils qw(array_minus); my @a = 0..10000; my @b = 5000..10000; array_minus(@a, @b); This is how it's defined in the module: sub array_minus(\@\@) { my %e = map{ $_ =&gt; undef } @{$_[1]}; return grep( ! exists( $e{$_} ), @{$_[0]} ); } By the way, never use your original code on large lists, it's orders of magnitude slower than any solution that involves an intermediate hash/set/dict. a.difference(b) does not work on lists, you need to convert them to sets first but is very efficient. It's akin to another solution posted: my %tmp; @tmp{@a} = (); delete @tmp{@b}; return keys %tmp; And for last, a literal translation to perl of your original construct, it's very slow, slower than the python's solution (I guess it is somewhat optimized in python, cause it's an idiom) my @a = 0..10000; my @b = 5000..10000; grep { my $i = $_; !grep { $i eq $_ } @b } @a; 
I agree with all of your points, but just note that the performance difference is not significant when the lists are small, particularly the second list.
Often the best solution to this is to run the code in an unrelated process. Minion is a possible solution as the workers are started separately and the application workers have no bearing on it, and you could use the locking logic to ensure only one job is run at a time. Another solution is to run a separate process either started yourself or forked from application startup (startup is only run once, not per worker), but you cannot use a Mojo subprocess for this because it won't start until the event loop starts in each worker. When not using Minion, you can communicate with the external process via a database or pubsub, and it can manage the timers itself.
In the Perl equivalents, for maximum efficiency, don't use `map` to populate the flag hash. Use an assignment: @foo{@array} = undef; Similarly, don't check the flag as a boolean, check if it exists: grep { exists $foo{_} } @array Here are some timings (on Perl 5.28.0) %foo = map { $_ =&gt; 1 } @array 3690/s @foo{@array} = @array 5236/s @foo{@array} = (1) x @array 7752/s @foo{@array} = undef 8850/s and grep { $_ } @foo{@array} 18939/s grep { exists $foo{_} } @array 25773/s See [this gist](https://gist.github.com/djerius/085fc1dacc14162ad303a5cadc2266a9) for the code
&gt;my ( $ref_list_a, $ref_list_b ) = @_; Since both of the arguments are lists, why isn't it my ( @ref_list_a, @ref_list_b )?
Very informative answer, thanks!
Because Perl 5 flattens lists and if you'd used `my ( @ref_list_a, @ref_list_b )` you'd end up with all the args in the first array. Instead, you have to pass the two arrays by reference (the `\` before the `@` in the call gives that). References are scalar and now we know that we'll only get two arguments (the two references), regardless of the contents of those arrays, and so you use `my ( $reflist_a, $ref_list_b )` to get those two references. That applies only to Perl 5. In Perl 6, there's no autoflattening and the sigils remain the same, to avoid precisely the type of confusion you experienced here :)
Well it also coerces to a set semantics using the operator too, so you lose any dupes in the lists *shrug* I'd leave it as a set myself unless I had a reason to do something else. The real correction is it doesn't do exactly what the OP necessarily wanted anyway.
&gt; @foo{@array} = undef; This assigns undef to the first element then the rest happen to get undef because there's no more elements to assign. `@foo{@array} = ();` might be slightly clearer.
This solution is surprisingly slow compared with hella well optimized python sets. PDL gets a bit close to the optimized sets, but still slower. $ time perl -e 'use PDL; my $a = sequence(1000_000); my $b = pdl(50_000..60_000); setops($a, "XOR", $b)' real 0m0.204s user 0m0.167s sys 0m0.059s $ time perl -e 'my @a = 0..1000_000; my @b = 50000..60000; my %tmp; @tmp{@a} = (); delete @tmp{@b}; keys %tmp' real 0m1.408s user 0m1.471s sys 0m0.093s $ cat list_difference.py a = set(reversed(range(1000000))) b = set(range(50000, 60000)) [a.difference(b)] $ time python list_difference.py real 0m0.137s user 0m0.094s sys 0m0.058s Though one thing is interesting, when I increase size of the @b, pdl gets slower , but the hash/set solution's execution time stays the same. $ time perl -e 'use PDL; my $a = sequence(1000_000); my $b = pdl(500_000..600_000); setops($a, "XOR", $b)' real 0m0.844s user 0m0.888s sys 0m0.049s $ time perl -e 'my @a = 0..1000_000; my @b = 500_000..600_000; my %tmp; @tmp{@a} = (); delete @tmp{@b}; keys %tmp' real 0m1.131s user 0m1.121s sys 0m0.134s $ time python list_difference.py real 0m0.143s user 0m0.099s sys 0m0.059s $ cat list_difference.py a = set(reversed(range(1000000))) b = set(range(500000, 600000)) [a.difference(b)] But all of these beat Array::Utils handily. $ time perl -e 'use Array::Utils qw(array_minus); my @a = 0..1000_0000; my @b = 500_000..600_000; array_minus(@a, @b)' real 0m2.722s user 0m2.592s sys 0m0.421s 
 use Mojo::Base -strict, -signatures; use Set::Light; sub do_the_thing($a, $b) { my $x = Set::Light-&gt;new(@$b); [ grep !$x-&gt;contains($_), @$a ]; } 
Oh wow, I am thrilled you made the effort but sorry I put you through the work. I already love P6 and hope to find a use for it, you didn't have to exert any extra effort on my part.
?
&gt; Often the best solution to this is to run the code in an unrelated process. Unfortunately, I don't have luxury of ripping out the logic involved and create a designated mini-app out of it. :( The application is quite complex, and I don't have time to refactor everything to make that possible. &gt; Minion is a possible solution as the workers are started separately and the application workers have no bearing on it, and you could use the locking logic to ensure only one job is run at a time. I'll look into this today, but I want to emphasize that multiple _jobs_ **can** run at a time. But only one _process_ should be allowed to run the jobs. I'm guessing the locking functionality in Minion can help me with this.
Of COURSE the programer could be me; it usually is. That's why I write docs.
Definitely. Thanks.
You and I also make typos. No docs will save us from that, input verification will, and Function::Parameters make it painless, transparent and automatic.
Going through the same thing right now. The only conclusion I could come to was that I'd have to spin up a separate app server with only a single process and communicate between the two somehow. I don't know anything about communicating between processes so I'm just treating it as a web app and POSTing JSON to it. Thankfully I have the luxury of building this thing from the ground up.
&gt; Unfortunately, I don't have luxury of ripping out the logic involved and create a designated mini-app out of it. Consider using a [command](https://metacpan.org/pod/Mojolicious::Guides::Cookbook#Adding-commands-to-Mojolicious), it can use anything you set up in startup like helpers but can be run externally to the app.
This would return a list in the correct order (well, technically a lazy `Seq`, but I would consider that a feature, as it will allow you to abandon before completion); @a.grep: * (elem) @b This will however do quite a lot of extra work, as it executes `.WHICH` on all the elements in `@b` for each element in `@a` (worst case). So perhaps this idiom is quicker: @a.grep: { $_ (elem) once @b.Set } This converts the `@b` to a `Set` once, which will only execute `.WHICH` once on each element in `@b`. But it does build an actual `Set`, which the first version does not.
More Perl Set class comparisons, using the Python code as a normalizing run $ time python set_difference.py real 0m0.142s user 0m0.105s sys 0m0.037s $ time perl set_object.pl real 0m2.294s user 0m2.175s sys 0m0.119s $ time perl set_scalar.pl real 0m7.132s user 0m6.936s sys 0m0.193s where `set_difference.py` is just a renamed (to reflect that its working on sets) version of `list_difference.py` above: a = set(reversed(range(1000000))) b = set(range(50000, 60000)) [a.difference(b)] and `set_object.pl` is use Set::Object qw[ set ]; my $a = set(); $a-&gt;insert( 0..1000_000 ); my $b = set(); $b-&gt;insert( 50000..60000 ); my $d = $a - $b; and `set_scalar.pl` is use Set::Scalar; my $a = Set::Scalar-&gt;new; $a-&gt;insert( 0..1000_000 ); my $b = Set::Scalar-&gt;new; $b-&gt;insert( 50000..60000 ); my $d = $a-&gt;difference( $b );
Tried Set::Light yesterday and its performance was on par with raw hash.
One of most useless and annoying 'features'. Just kill it with fire.
&gt; see instructions within the zip archive. I'm not sure why I can't seem to grasp the instructions. Perl is a totally different world from what I am used to dealing with for the past 20 years.
If I had to guess, I would say this exists because require is implemented via [do FILE](https://perldoc.pl/functions/do) which returns undef when it fails, which is indistinguishable from a file that returns undef.
An alternative would be a pure Perl implementation, though you wouldn't be able to override `use`. Call it `load($@)`. Have it search through `@INC` as is done in the C implementation (there are a few advanced uses here, like having a subref in `@INC`). Then slurp the file and `eval(STRING)` it, and check `$@` for errors.
What if the module has a syntax error?
You've just reinvented [`Module::Require`](https://metacpan.org/pod/Module::Require). :-)
You've just reinvented [`Module::Runtime`](https://metacpan.org/pod/Module::Runtime). :-)
This article is a start: https://www.activestate.com/blog/2017/05/upgrading-perl-modern-version-activestate-guide
[DBIx::Class](https://metacpan.org/pod/DBIx::Class) is your friend If you are developing your web app with Mojolicious, [this example helps you](https://github.com/tempire/MojoExample) a lot.
https://cpan.metacpan.org/authors/id/S/SH/SHAY/dmake-4.12.2.2.zip `dmake/readme/read1st.txt` &gt; To install dmake, simply copy dmake.exe and the startup/ sub-directory to a directory of your choice. ---- I don't want to help with Activeperl anymore. Ask someone else: * https://code.activestate.com/lists/group/activestate/ * https://community.activestate.com/forum * https://perlmonks.org/?node=Seekers%20of%20Perl%20Wisdom Or [buy a support license from Activestate](https://www.activestate.com/licensing) and ask them. Or switch to Strawberry.
If you want this now, solutions are for years available on CPAN: * http://p3rl.org/true * http://p3rl.org/perl5i#true
They it would raise an exception — you have to trap that with an eval anyway, I think.
I heard rumblings about the latest being a bit flaky. Blame Zefram. I used to be religious about brewing a recent perl, but now distros are relatively recent, I’m not.
I'm not aware of any particular flakiness. Do you have any links?
Sorry. Ask on #perl? Can’t remember if it was #perl, web or a mailing list I heard it. 
&gt; Would there be a good way to maintain good test data that could easily populate either database depending on the setting? My current go-to for database migrations is [App::JESP](https://metacpan.org/pod/App::JESP). It's the least amount of functionality that you actually need. I've used Sqitch a lot, but found it's just trying to do too much. I think it's also a bit too much inspired by Git without taking into account the difference between managing source code (light weight to upgrade/downgrade) and data (very heavy weight to upgrade/downgrade). 
This only covers the changes between 5.14 to 5.24, but might be an easier read than the individual perldeltas: https://www.reddit.com/r/perl/comments/91ghjb/perl_improvements_going_from_514_to_524/ (apologies for the terrible title image, but I really couldn't face yet another camel/onion montage) I'll work on an updated one for 5.24 -&gt; 5.28... it'll be a bit shorter!
The post is more useful as a practical example of patching Perl, IMHO - I'm not even sure if it's a serious suggestion, but it's a good writeup for people wanting to get into the code.
This would be perfect, because this would also solve my concern for testing while using both. However, I'm trying to build this app using the asynchronous model. For this I think I couldn't use DBIx::Class, but instead need to use something like Mojo:: mysql?
Thanks!! That helps a lot :)
That's really helpful!! I look forward to the next one :)
&gt; I don't want to help with Activeperl anymore. heh, completely understandable! While I feel that switching to Strawberry is the route I should take, I worry about what it could break. (My hope is to phase out the perl code completely but I just have to get this one part working for the time being.) I totally appreciate all your help, thanks again for everything and have a great one!
For me the two most useful new features were these: * Perl 5.10: the `//` defined-or operator * Perl 5.20: the `List::Util` core module gains `pairmap` and `pairgrep`, to allow transforming hashes in a functional way. use List::Util qw(pairgrep); my %odd = pairgrep { $b % 2 } qw(one 1 two 2 three 3 four 4 five 5); # (one =&gt; 1, three =&gt; 3, five =&gt; 5)
The Mojo wrappers both provide Migrations which allow seamless schema management. For models, you could get away with using the same query for certain simple queries, especially via the SQL::Abstract helpers, but I would design it from the start to have an abstraction for each backend you want to support because at some point there's going to be differences.
Can you point me to which mojo wrappers allow schema management? And so by two abstractions you mean two models, and I should have tests for each of them, correct?
I saw something on a mailing list a while back but from what I understood some guy was just angry an undocumented private API in the Perl core changed and it broke his code.
Yes, those are the things you need to trade off against each other.
Got it. I was hoping there was something similar, but asynchronous. Thanks!
Also, does SQL::Abstract not write for a particular database?
It's the same API for both wrappers you mentioned. [Mojo::mysql::Migrations](https://metacpan.org/pod/Mojo::mysql#migrations), [Mojo::SQLite::Migrations](https://metacpan.org/pod/Mojo::SQLite#migrations). Two models is the simplest way, but to avoid code duplication you could have a common model role applied to the two model classes. See [Role::Tiny](https://metacpan.org/pod/Role::Tiny) (supported by Mojo::Base -role and with_roles method).
Okay, so I would need two migration files for each schema change then?
It does not - its output is suitable for almost any SQL database, hence why it doesn't have support for many features like offset and limit which aren't fully standard.
Ah, I see. So if I need that I may just have to write it for the different engines. Thanks!
yes, the migrations would almost certainly need to be database specific.
While cute, I wouldn't seriously suggest someone to use these solutions, trading `1;` for a bunch of fragile stack magic.
Before doing that, look at SQL::Abstract::More which supports offset/limit and much... umm... more.
Repost to reddit because the blog software ate my comment. ---- There is nothing wrong with installing things from CPAN. Moops gets you very far to code block №3. # ovid-moops1.pl use Moops qw(class method); class Cache::LRU { use Hash::Ordered qw(); use Types::XSD::Lite qw(PositiveInteger); my $x = Hash::Ordered-&gt;new; # private has max_size =&gt; ( isa =&gt; PositiveInteger, default =&gt; 20, required =&gt; 1, is =&gt; 'rw', ); method set(Str $key, Any $value → Undef) { $x-&gt;shift if $x-&gt;keys &gt; $self-&gt;max_size; $x-&gt;delete($value); $x-&gt;set($key, $value); } method get(Str $key → Any) { $x-&gt;get($key) } } class main { my $cache = Cache::LRU-&gt;new(max_size =&gt; 100); $cache-&gt;set(foo =&gt; 42); say $cache-&gt;get('foo'); use DDP; p $cache; } The "has" above feels verbose compared to your variant reminiscent of &lt;https://github.com/stevan/p5-mop-redux/blob/master/lib/mop.pm#L340&gt;. It is not well specced out, but I can run with it. # ovid-moops2.pl use Moops qw(class method); BEGIN { Keyword::Simple::define 'bikeshed_has', sub { require MooseX::Has::Sugar; my ($code) = @_; # I must be crazy to parse Perl that way. my $semicolon_pos = index $$code, ';'; my @tokens = split ' ', substr $$code, 0, $semicolon_pos; my $type = shift @tokens; my $default_value = pop @tokens; pop @tokens; # '=' my $attr_name = pop @tokens; my $sugar_traits = join ',', map { s/^://r } @tokens; my $macro = "use MooseX::Has::Sugar qw(required rw); has $attr_name =&gt; (isa =&gt; $type, default =&gt; $default_value, $sugar_traits);"; substr $$code, 0, $semicolon_pos, $macro; }; } class Cache::LRU { use Hash::Ordered qw(); use Types::XSD::Lite qw(PositiveInteger); my $x = Hash::Ordered-&gt;new; # private bikeshed_has PositiveInteger :rw :required max_size = 20; method set(Str $key, Any $value → Undef) { $x-&gt;shift if $x-&gt;keys &gt; $self-&gt;max_size; $x-&gt;delete($value); $x-&gt;set($key, $value); } method get(Str $key → Any) { $x-&gt;get($key) } } class main { my $cache = Cache::LRU-&gt;new(max_size =&gt; 100); $cache-&gt;set(foo =&gt; 42); say $cache-&gt;get('foo'); use DDP; p $cache; } I wish I had this kind of power in other popular languages.
Excellent, thank you. I've just recently started using pairmap like so: \`my %hash\_with\_capitalized\_keys = pairmap { uc($a) =&gt; $b } %hash;\`
\&gt; I heard rumblings about the latest being a bit flaky. I'd suggest that it doesn't make sense to turn someone away from the latest Perl release based on: * a single rumbling * of something that you don't remember * from someone or someplace you don't remember.
Thanks!! I'll check it out :)
Does this application currently work via http ? https is usually transparent and handled by the server, switching a tls version should not break anything.
Another option is SQL::Abstract::Pg, while it does have DBD::Pg as a dependency, it does provide extras that are useful for SQLite and MySQL as well.
FWIW, the latest offering from Stevan that has attributes like that is [Moxie](https://metacpan.org/pod/Moxie), built on his UNIVERSAL::Object and MOP base.
Perl CGIs don't normally terminate encryption. What OS, webserver, and openssl versions do you have? If you are running on something like rhel/centos 5 I think they used openssl 0.9.8 which didn't have tls 1.2 support IIRC.
Some people actually consider the goofy clusterfuck Damian invented for a presentation as a serious contender.
If you work with nested lists, experimental `decalred_refs` feature added in 5.26 makes them a lot nicer to iterate over. use v5.26; use warnings; use experimental qw( refaliasing declared_refs ); my @lists = ([1, 2, 3], [4, 5, 6], [7, 8, 9]); for my \@list (@lists) { say join(', ', @list) } If you are moving to 5.28, `refaliasing` is no longer experimental, so you don't need to explicitly enable that, but if you want to play with experimental features, I recommend installing the [`experimental`](https://metacpan.org/pod/experimental) module, which enables the feature and disables the warning. There's also an [`experimentals`](https://metacpan.org/pod/experimentals) module that enables all experimental features for your version of Perl.
&gt;For "is $x in @y"-type queries... Is there any parser ambiguity preventing p5p from implementing an `in` infix op similar to Python? For one, being able to do `if ($x in @xs)` might sate those smartmatch stalwarts who don't want to move away from it because they find `if ($x ~~ @y)` too valuable to give up. Secondly, if it was context aware so it would also work with scalars on the RHS, `if ($substring in $string)` is a helluva lot nicer to write and read than `if (index($string, $substring) &gt;= 0)`.
I liked mop-redux better because attributes access via `$!attr_name` like in Perl6, not `$self-&gt;attr_name` like in Moo/Moose/Moxie. That `$self-&gt;max_size` in method `set` is the last remaining unported difference from Ovid's code proposal, it says just `$max_size` there. I'm sure it can be done, but I don't know enough.
Damian's code is not a "goofy clusterfuck", but he's creating such a robust OO system that it's overwhelming for many Perl 5 developers. At its core, Perl 5's OO is simply `@ISA` and `bless`. Kind of hard to get simpler than that. I was posting an incredibly minimalist version, with *just enough* sugar to simplify Perl 5 OO code tremendously. Consider, here's that LRU cache in core Perl 5 (it's not much shorter in Moose): package Cache::LRU { use Hash::Ordered; use Carp 'croak'; use Regexp::Common; sub new { my ( $class, $max_size ) = @_; $max_size //= 20; unless ( $max_size =~ /^$RE{num}{int}$/ &amp;&amp; $max_size &gt;= 0 ) { croak("max_size must be integer &gt;= 0, not '$max_size'"); } return bless { cache =&gt; Hash::Ordered-&gt;new, max_size =&gt; $max_size } =&gt; $class; } sub max_size { my $self = shift; return $self-&gt;{max_size}; } sub set { my ( $self, $key, $value ) = @_; if ( $self-&gt;{cache}-&gt;exists($key) ) { $self-&gt;{cache}-&gt;delete($key); } elsif ( $self-&gt;{cache}-&gt;keys &gt;= $self-&gt;max_size ) { $self-&gt;{cache}-&gt;shift; } $self-&gt;{cache}-&gt;set( $key, $value ); } sub get { my ( $self, $key ) = @_; $self-&gt;{cache}-&gt;get($key); } } And here's my re-imagined version: class Cache::LRU { use Hash::Ordered; my $x = Hash::Ordered-&gt;new; # private has UInt $max_size = 20; # default method set ( $key, $value ) { if ( $x-&gt;exists($key) ) { $x-&gt;delete($key); # set most recently used } elsif ( $x-&gt;keys &gt; $max_size ) { $x-&gt;shift; # make room for new key } $x-&gt;set( $key, $value ); } method get ($key) { $x-&gt;get($key) } } I'm not trying to pack in everything that Damian offered. My code is much shorter, much more declarative for those things which should be declared, and the actual code part is much easier to read.
Nice! Just be sure to check the original blog post because I correct an off-by-one bug in the LRU cache logic.
I’ve been downvoted to fuck anyhow.
Hello Ovid, What's the point of: if ( $x-&gt;exists($key) ) { $x-&gt;delete($key); # set most recently used } if `$x-&gt;set( $key, $value )` will rewrite the value anyway ? 
According to [the documentation](https://metacpan.org/pod/Hash::Ordered#set): &gt; Associates a value with a key and returns the value. If the key does not already exist in the hash, it will be added at the end. Reading the code verifies this behavior. You must delete the key and set it again to make it fresh.
&gt; Moose? Moops? Moo? Mo? Dios? Something else? You forgot Mu. ;)
Well it looks like this is just a matter of me forgetting how network devices work... I was trying to get the webserver to post to itself. It works just fine when I test posting from my local machine that is not part of the web server's domain.
Well it looks like this is just a matter of me forgetting how network devices work... I was trying to get the webserver to post to itself. It works just fine when I test posting from my local machine that is not part of the web server's domain.
Got it, thanks. 
Good question. There are quite a few variants of `if(in($x, @y))` around, such as the [Data::Munge::elem](https://metacpan.org/pod/Data::Munge) option in the article - extending the construct to cover `index` would be possible, although that'd mean you'd likely need to pass the list as an arrayref instead. For a core operator, I'd expect it to be mired in semantic debate moments after being proposed - should there be separate string/numeric operators? how should refs be treated? etc. - but I think the `$x in @y` is always going to be a syntax error in current Perl, and maybe even `$x in $y` as well, so the concept does seem possible. As an operator, I'd expect a keyword implementation on CPAN would have more success. Non-trivial amount of work though - we're likely doomed to variations on `sub in { !!grep { $_[0] eq $_ } @_[1..$#_] }` for the indefinite future...
Not used the module before but the formula uses semicolons as separators, and my version of LO uses commas. When I enter manually using semicolons, the formulas are autocorrected to commas again...so this may represent why your manual edits corrects the formula. Also after $lookup you have a ".", whereas my version of LO requires a ",". 
I thought we were going to keep [Mu](https://docs.perl6.org/type/Mu) out of this? :-)
I cover in-dpeth most of the interesting user-level additions (and sometimes removals) at the Effective Perler under [new features](https://www.effectiveperlprogramming.com/category/perl/new-features/).
Unfortunately the keyword API cannot be used to build operators.
&gt; Moose? Moops? Moo? Mo? Dios? Something else? There's also [`Mew`](https://metacpan.org/pod/Mew) :)
Two courses I've run at the London Perl Workshop. * [Modern Core Perl](https://www.slideshare.net/davorg/modern-core-perl) covers Perl 5.10 to 5.14 * [Modern Perl Catch-up](https://www.slideshare.net/davorg/modern-perl-catchup) covers Perl 5.16 to 5.24
Awesome, thank you!!
That was filed in 2016...should that not be already patched in the versions on CPAN?
And further down the rabbit hole we go ... :)
For the longest time I always need to look at the documentation whenever I want to use `splice`. Also any function which returns an array of information: `getpw*`, `getgr*`, `localtime`/`gmtime`, `stat`, `caller`. 
The syntax of lookaround assertions (was it `?!=` or `?!&lt;`). Preventing `sort function(@list)` from using `function` as a comparator. Order of arguments for Encode's `encode` and `decode`. Also, "And I ne"...?
pack and unpack for me, definitely. Even after rereading the documentation it takes two or three tries to use it correctly. substr and splice argument order I sometimes have to look up. Various low level functions have odd error checking requirements, particularly do.
Hash slice syntax.
Because one can't code in *anything* without looking stuff up (at least some of the time). Human memory is imperfect, so people forget and misremember things they don't use often (like `tie`). A good IDE with inline hints that can jog the memory goes a long way. `pack`'s excuse is its terse design - it's a language within a language, just like regex, getopt, sprintf, strftime and uniprops. Can we blame C culture for that? I can certainly imagine alternative, more verbose expressions for these features and they would be more memorable, but possibly also more unwieldy; this needs experimental confirmation. Personal "anecdata": I distinctly remember using "jump to context help" in QuickBASIC and Turbo Pascal all the time. I know tie, but not how to use Tie::StdScalar. I don't know * which way int, floor, ceil round * what autodie catches, and what not * the API of especially big libraries like LibXML or DBIC or DateTime (synopses are *great*! why don't docs in other languages have that?) * the name of MHX's hash module * the syntax for named regex backrefs * the posix charclass name for hexdigits * what the name of the dwimmy json module is (not ::DWIM, the other one) * my favourite -D switches for `perlbrew install` * the command-line for Deparse * in which Perl version which `use feature` was added * how the variants of POD =item render as HTML * the name of that email header encoding supported by Encode * how to get perldoc with user contrib * what the magic method for "no" is * zero-padding with sprintf * the module name for undoing PERLQQ or C escapes … and much much more. And some recent non-Perl things: * which the non-characters in Unicode are * how shell quoting for single delimited within single delimited works (is it `'\'''`?) * how to upload files via Web form with curl * `chcp UTF-8` is wrong, what's the magic number? * how to make a throw-away database self-contained in a directory with mysql * CSS3 selectors * preparations for profiling with kcachegrind * additions to a .pro file for Verdigris * the xattr command that's not stupid I only can get things done because I'm good at looking up information (heartfelt thank you, [Fravia](http://enwp.org/Fravia)+ and [Searchlores](http://search.lores.eu/indexo.htm)) and I can remember decently where I was seeing things before on a mailing list or on the Web. I also have many crutches so I don't need to remember things so often; the most productive is [realias](http://www.modernperlbooks.com/mt/2009/10/remove-the-little-pessimizations.html).
This one for me as well, at least on a deeply nested struct that's already within a hash ref. Such a useful thing but I always forget the syntax. For reference: my @sliced_values = @{ $hash_ref-&gt;{top}{middle}{bottom} }{qw/ some list of keys / };
No, the semicolons are definitely correct. If I enter commas or create commas with my script it gets autocorrected to semicolon in LO. In the meantime I updated to the latest 6.0.5.2 and it still occurs. I planted some printf debug statements in the write_formula method of the perl module and I see that the XML output looks good - exactly as it should. So my guess is that it's a problem in LO. The following code at least does not produce Error 508 any longer but the cells are empty: When I open the file in LO all formulas are written in lowercase; as soon as I edit a line it gets canonicalized and starts working. The perl module creates the formula according to the "working" example but it seems LO messes it up while importing. not working: =IFERROR(VLOOKUP(D4;$lookup.$f$2:$F$10000;1;0);"") working: =IFERROR(VLOOKUP(D4;$Lookup.$F$2:$F$10000;1;0);"")
From the SYNOPSIS: &gt; has _cust =&gt; ( is =&gt; 'ro', isa =&gt; sub{ 42 } ); # standard Moo `has` isa sub 42 looks weird?
The order of the match operator =~ or ~= I learn that anew everytime I start a new project. Somehow it doesn't stick.
Yuuup!
This is the best solution, as it preserves both the order and the duplicate elements from list `a`. The other hash based solutions in the comments do not.
A small example program, measuring times for small (100) and large (10000) lists. Two methods, O(n^2) linear search, and a O(n) hash based search. The hash based search could be faster, but the Python example preserves both order and duplicate elements in `a`, same here. use strict; use warnings; use Time::HiRes qw(time); my @a1 = map { int rand 2000 } 1 .. 10000; my @b1 = map { int rand 2000 } 1 .. 10000; my @a = @a1[0 .. 99]; my @b = @b1[0 .. 99]; my $t0 = 1000 * time; my $f = grep { my $a = $_; not grep { $_ == $a } @b } @a; my $t = 1000 * time; my $f1 = grep { my $a = $_; not grep { $_ == $a } @b1 } @a1; my $t1 = 1000 * time; $t1 = 1000 * time; printf "Linear search - %3d/100: %9.3fms, %5d/10000: %9.3fms\n", $f, $t - $t0, $f1, $t1 - $t; $t0 = 1000 * time; my %h; @h{@b} = (); $f = grep { not exists $h{$_} } @a; $t = 1000 * time; my %h1; @h1{@b1} = (); $f1 = grep { not exists $h1{$_} } @a1; $t1 = 1000 * time; printf " Hash search - %3d/100: %9.3fms, %5d/10000: %9.3fms\n", $f, $t - $t0, $f1, $t1 - $t; I print runtimes, plus the size of the filtered lists, just to make sure the two algorithms give the same results. Linear search - 98/100: 0.749ms, 60/10000: 7036.516ms Hash search - 98/100: 0.092ms, 60/10000: 6.896ms 
It's `=~`. You can think of it as "is like". (`=` being "is", `~` being like.)
Problem solved. The syntax for the perl module should look like this: =IFERROR(VLOOKUP(A1,Lookup!$A$1:$B$10000,2,0),"")
I always have to look up the calling conventions for standard modules. Getopt::Long, IO::File, Time::HiRes, B::Deparse, B::Concise, Exporter, overload for example. As for the language core: AUTOLOAD. Every time I need some dynamic method dispatch, I have to look up the boilerplate to do it properly. Also regexp control verbs.
 my $dt = DateTime-&gt;from_day_of_year( year =&gt; 2018, day_of_year =&gt; 31 ); This should work.
Thanks. I am new to perl so I was guessing on the syntax. 
As the story goes, no one is able, even to save their own life, remember how `tar` command line switches work. https://xkcd.com/1168/ It's not Perl specific at all.
Explanation: what happened here DateTime-&gt;from_day_of_year-&gt;( year =&gt; 2018, day_of_year =&gt; 31 ); was that DateTime-&gt;from_day_of_year is the same as DateTime-&gt;from_day_of_year() and so it was called with no arguments, so naturally "day_of_year" was missing. Your arguments was called on something else, which I won't attempt to explain here :) 
It dropped off because it was easier and faster to work around Parrot than to work on Parrot. It wasn't a good target for any language, and that is according to one of the articles you linked to that was written by WhiteKnight. (Technically he only listed a few languages, but they included the most active ones outside of Rakudo) In order to “improve” the situation for other languages, the deprecation cycle increased. Which was exactly the opposite of what should have happened. * Let's say you need a feature changed in Parrot. * You send a pull request, and three months later it might appear, because of the deprecation cycle. * The problem is you need it now, so you write around the feature as well. * If you do that often enough you will realize it is much more productive to just write around the feature from the start. * End result: Everybody stops working on Parrot. (Each person individually.) I don't know how you can say that people stopped writing code for Parrot, and somehow that means that Rakudo (not even a person) stopped supporting Parrot. Obviously I use the word “supported” as short for “supported as a backend”. While you seem to use it to mean “supported by writing code for it”; which I would have shortened to “writing code for it”. (It doesn't even make much sense as Rakudo didn't write any code for Parrot, not being a person and all) Yes the People who were working on Rakudo stopped working on Parrot and instead worked around it, but that is because they each individually probably emotionally felt their contributions were being ignored. (From the huge time disconnect between a contribution and when it would show up.) I mean I even had a pull-request that was ignored for a year well before that time. So rather than asking people why they stopped contributing, you seem to have assumed there was some conspiracy by the people behind Rakudo as to why they individually stopped working on Parrot. In reality the people behind Rakudo were in a holding pattern between 2011 and 2014 when MoarVM was released. The JVM has always been a second backend. Sure it was edging out Parrot, but it didn't eclipse it until MoarVM. At which point Parrot went from the first-class backend to third-class; with JVM staying as second-class. The biggest problem is that there were now so many workarounds for Parrot that had accumulated, that it was slowing all development on Rakudo. In the 2014-2015 timeframe it was decided to try to make a final push to have the official release. Since the Parrot workarounds made everything more difficult, it was decided that support for Parrot as a backend would be removed. I mean are you going to honestly tell me that everyone was stupid enough to effectively kill a backend (2011) before there was a replacement (2014)? So really the people who were managing Parrot done goofed, and they apparently still don't realize the mistakes they made. (Increasing the deprecation cycle, and distancing themselves from the only active language implementation.) What's more, Parrot was always just a means to an end. The end has been met, therefore Parrot was a success. Sure most of us expected Parrot would still be there in the end, but that was not to be. I also have yet to read about anyone complaining that PUGS is now defunct. It was also a success. There's a saying that you should write the first two implementations with the expectation that they will be thrown away. Parrot is either the first or second depending on how you want to count. I'm really not sure why you always have so many negative things to say about Perl 6. Since if it proves to be a failure, then (and only then) will all of the work that went into Parrot have been a complete waste of time. Do you really want all the time and effort you personally went through to be for nought?
You may be interested in [Autoload::AUTOCAN](https://metacpan.org/pod/Autoload::AUTOCAN) which is essentially a wrapper of the necessary boilerplate.
Funny enough I have no problem with tar switches (I guess I use it often enough?) But I can never remember the order of arguments for `ln` and it takes a couple glances through the manpage to figure out which variant is the one I wanted.
The last couple of times I used `ln` I didn't remember if it created hard or symbolic links by default.
The main issue is that interoperability between Moose and Mouse is the deeply flawed [Any::Moose](https://metacpan.org/pod/Any::Moose), whereas interoperability between Moo and Moose is built-in to Moo and just works.
The more I use postfix deref, the less I have to look up the syntax for slicing.
Another tool you might find helpful for this is [Yancy](https://metacpan.org/pod/Yancy): The [Yancy::Backend API](https://metacpan.org/pod/distribution/Yancy/lib/Yancy/Backend.pod) can be used with either Mojo::mysql or Mojo::SQLite, so which database you use becomes configuration. I wrote it for CPAN Testers, which also uses DBIx::Class (which Yancy also supports). I keep thinking I should extract the Yancy::Backend classes to make some kind of model class for Mojolicious, but I've not done so as yet.
Ok thanks. I am new to perl and only use it occasionally 
I use Moo in part because I need to be able to [fatpack](https://metacpan.org/pod/distribution/App-FatPacker/bin/fatpack) executables, so while Moo *can* use XS modules, it doesn't *have* to. Pure Perl still has its place. There was a time early on when Mouse wasn't feature-complete with regards to Moose. I stayed with Moose because of that, and when Moo came out switched to that for its much faster startup time (at $work software is on centralized NFS volumes, and loading modules is sloooooow). I admit that I've never gone back to see if Mouse has achieved parity with Moose features.
The "indirect object" form of the `exec` and `system` functions. (I still can figure out why it's called that. I don't see an object anywhere.) I always forget that its `exec { $cmd } $cmd, @args`, not `exec { $cmd } @args` and wonder why nothing ever works.
Thank you, being able to fatpack is a valid use case, and stripped of its XS Mouse can't compete with Moo adequately. 
Well done, and quite clever stuff. You should do a tutorial in blogs.perl.org.
I agree about Moo being fast enough for an average user, but not so sure about value of Moo becoming Moose under the hood when needed. Moose is just too big and slow to be seriously considered in production code (at least where I work).
A good way to remember it is that it's the same as `cp`: source first, then destination. The thing that trips me up about `ln` is how relative paths work if you aren't in the target directory...
&gt; I'm really not sure why you always have so many negative things to say about Perl 6. I've written copiously about it. You can find several articles by searching for them. &gt; Do you really want all the time and effort you personally went through to be for nought? What I want is irrelevant to whether it was for naught, and it was. &gt; It wasn't a good target for any language... Technically he only listed a few languages You're overgeneralizing what he wrote. &gt; In order to “improve” the situation for other languages, the deprecation cycle increased. You're mischaracterizing the deprecation cycle. It was never about blocking new things. It was about removing old things. If you read the previous links I posted, you'll see that the biggest complain was about removing a feature without providing a replacement. &gt; I don't know how you can say that people stopped writing code for Parrot, and somehow that means that Rakudo (not even a person) stopped supporting Parrot. Because: * I was there * I read the mailing list threads I linked * I read the timeline I linked I don't know how to make it clearer. 2011/2012 came before 2014. &gt; While you seem to use it to mean “supported by writing code for it” You're going to keep confusing yourself if you continue making things up that I didn't say and using the same words of your argument. &gt; Yes the People who were working on Rakudo stopped working on Parrot and instead worked around it, but that is because they each individually probably emotionally felt their contributions were being ignored. Don't speculate. Read the threads. Read the links I posted. &gt; I mean are you going to honestly tell me that everyone was stupid enough to effectively kill a backend (2011) before there was a replacement (2014)? Don't speculate. Read what I wrote. I don't know how to make it any clearer than this: When Rakudo developers announced they were rewriting NQP to support multiple VMs, Parrot developers expressed concerns that (again, read the links I posted; it's very clear): * this was pulling the rug out from under existing languages written on Parrot * this was pulling the rug out from under compiler tools shipped with Parrot * this was a deliberate distancing of Rakudo from Parrot * this provided no technical benefit to Parrot and instead * this would provide a lot of churn especially with regard to the deprecation policy I'll mention this again here: the deprecation policy had its problems, sure, but it protected Rakudo in a lot of ways that Rakudo wanted. The biggest problem I have here is that Rakudo developers continue to tell this story that "Oh, Parrot was supported until 2014/2015 when it just wasn't providing features fast enough" while ignoring that *Parrot developers walked away from the project starting in 2011 after the NQP announcement and the discussion in the PDS*. That exodus was largely complete by 2012. Look at the links I posted and look at the timeline.
My understanding is that this is essentially the main issue: Mouse was accumulating it's own parallel set of CPAN extensions to Moose, and Moo is designed to use the Moose extensions, so there's less duplication. That said, I think the perl insiders really should consider the fact that Mouse is refusing to die for a reason... There might be a need for something like Moo that's precisely backward-compatible with Mouse code. 
I frankly can't understand why we still have no Moose like OOP added into perl executable itself, so we can end this fragmentation and trying to implement sane OOP in outside modules. Perhaps it's too late at this point though.
&gt; Moose is just too big and slow to be seriously considered in production code (at least where I work). This is a massive misunderstanding. Moose is slow for startup. But at runtime it's as fast or faster than Moo.
That's not what I saw in my benchmarks. Now, my benchmarks may have been flawed, do you have any links ? Thanks in advance.
Depends on what exactly your benchmark does, but in this one Moose is 2x the speed as Moo: https://gist.github.com/wchristian/96dba6d6ef3b80161d08be88cb6de2aa
I don't think it's a correct benchmark. The 'Int' check in Types::Standard is not implemented via XS and it disproportionally contributes the perceived Moo slowness. https://metacpan.org/source/TOBYINK/Type-Tiny-1.002002/lib/Types/Standard.pm#L224 I added Mouse to your gist (with Int validation) and the results were: Testing Perl 5.028000, Moo 2.003004, Moose 2.2011 Mouse v2.5.4 Benchmark: running Moo, Moose, Mouse for at least 3 CPU seconds... Moo: 1 wallclock secs ( 3.02 usr + 0.00 sys = 3.02 CPU) @ 817921.85/s (n=2470124) Moose: 7 wallclock secs ( 3.03 usr + 0.00 sys = 3.03 CPU) @ 1362459.74/s (n=4128253) Mouse: 1 wallclock secs ( 3.01 usr + 0.00 sys = 3.01 CPU) @ 5863674.42/s (n=17649660) However when I removed the validation Moo (Class::XSAccessor) and Mouse were similar and Moose was substantially slower. Benchmark: running Moo, Moose, Mouse for at least 3 CPU seconds... Moo: 3 wallclock secs ( 3.00 usr + 0.00 sys = 3.00 CPU) @ 7622339.67/s (n=22867019) Moose: 2 wallclock secs ( 3.10 usr + 0.00 sys = 3.10 CPU) @ 3178300.65/s (n=9852732) Mouse: 7 wallclock secs ( 3.04 usr + 0.00 sys = 3.04 CPU) @ 6482063.82/s (n=19705474) When I uninstalled Class::XSAccessor, Moo and Mouse (pure perl) were identical and Moose a bit slower. Moo: 3 wallclock secs ( 3.13 usr + 0.00 sys = 3.13 CPU) @ 3350927.16/s (n=10488402) Moose: 4 wallclock secs ( 3.16 usr + 0.00 sys = 3.16 CPU) @ 3123869.94/s (n=9871429) Mouse: 6 wallclock secs ( 3.21 usr + 0.00 sys = 3.21 CPU) @ 3376328.66/s (n=10838015) 
Moose is not a perfect fit for the perl core, according to Stevan Little, who initially developed the library. Moxie is his effort to take the lessons learned and create an OO system that is leaner, closer to core, and more perlish. There are others. I don't find it late at all, as perl's present OO abilities, possibly supplemented by CPAN, more than meet my needs. It's rather wait and/help to get something sufficiently flexible, easy to use correctly and with sensible default behaviors.
With a recent perl, you get post-deref syntax by default: $ref = {1..8}; say for $ref-&gt;@{1,3} # 2 4 Of course I had to look this up :-)
Hello, Mr. Kolyshev, I think [Dot](https://metacpan.org/pod/Dot) meets your requirement, it's an object system without code, thus: * the lightest : zero dependency including itself, since there's no code. * the most stable : no code, no bug. * the fastest : since there's no code, you can't spend any time executing it. Maybe it could be added as an option. Regards.
Awesome! Thanks. Is this asynchronous? I can't find anything about that.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://metacpan.org/pod/Dot) - Previous text "Dot" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
The value is simply that it doesn't happen unless you use the metaclass, which comparatively few Moosey projects actually need.
Hello Mr..., I use a lot of Mouse's advanced capabilities in my module, Dot will not suffice. Thanks.
Yep, I think we agree about Moo being most valuable when it's just Moo. If we start using Moose really, why not just s/Moo/Moose/ ? If a module uses Moo and metaclass, does that not force a consumer to install Moose ? 
So, if not Dot, why not Moxie ? https://metacpan.org/release/Moxie
&gt; time perl -e 'use Array::Utils qw(array_minus); my @a = 0..1000_0000; my @b = 500_000..600_000; array_minus(@a, @b)' A bit deceptive, you added an order of magnitude to @a
I happen to like Moose's OOP protocol, I do not mind make a cognitive investment.
This is a waste of time because you're talking about different things. I wasn't comparing against Mouse, because it's all XS. I also don't know what you mean exactly with "I removed the validation Moo (Class::XSAccessor)" because you didn't show the code, but it sounds counter-productive. In any case, we're talking about millions of accesses per second, so this seems like a micro-optimization.
Some very basic sanity checks: Run `pwd` (**p**rint **w**orking **d**irectory) in the terminal. Is this the directory you expect? Use Spotlight or another search tool to locate `moss.pl`. Is it in the directory you think it was?
'I removed the validation': commented out isa parts of accessor definitions. I did that in attempt to show that the slowness you attributed to Moo is coming from Types::Standard. If the fact that Moose is slower than Moo/Mouse by hundreds of percent means nothing to you than I'd like to apologize for wasting your time. 
ran pwd - gives me /user/desktop ran ls - found [moss.pl](https://moss.pl) . also , went to finder and searched [moss.pl](https://moss.pl) . indeed saved on desktop.
&gt; /user/desktop There's your problem. In OS X, the [desktop location](http://lessons.livecode.com/m/4071/l/7536-how-do-i-get-the-path-to-common-folders-on-my-computer) is `/Users/username/Desktop`.
Oh, sorry, my mistake! and thank you for pointing it out! That makes perl and Array::Utils to look so much better :-)
&gt;For a core operator, I'd expect it to be mired in semantic debate moments after being proposed No doubt, which is why it should be as simple as possible. LHS is *always* stringified. A List on the RHS checks for element membership. **ANY** Scalar on the RHS is stringified and `substr` checking is invoked. A possible exception to this is objects, which might be allowed to overload it like other infix ops. One thing that's up for some possible bikeshedding is what does `if ($x in %y)` do? The obvious choice is that it would check if the key exists in the hash... but we already have `if (exists $y{$x})` for that... so I'm sure some might make the case that it should search values instead. While I appreciate the logic, I still think the former makes more sense.
I agree that Moo's compatibility with Moose extensions is something that persuades people to use it. That seems likely.
Yes! This is another nice use of postfix deref. In the example I gave: $hash_ref-&gt;{top}{middle}{bottom}-&gt;@{qw/ some list of keys / } We're on 5.24 and about to be on 5.28 so I should start using postfix deref more...
i mean yeah thats what i got that time ! im so sorry for not writing the whole thing. well, now unfortunately thats not the problem... 
How do you know whether there's a list on the right, or a single scalar? e.g. `$x in function()`
Perhaps it would resist the urge to guess, much like `reverse function()` will treat it's operand as a list regardless of what the function returns. If it returns a string, and you want to reverse it, you have to `scalar reverse function()`. Similarly, maybe `$x in function()` treats the return value as a (potentially single item) list. The user can then force `$x in scalar function()`. Just a thought... I dunno if that could work.
./moss.pl Possibly perl ./moss.pl
&gt;chmod ug+x moss.pl chmod ug+x ./moss.pl -&gt;didnt do anything chmod ug+x ./moss.pl-&gt;chmod: perl: No such file or directory :(
ls -l moss.pl Does moss.pl have a correct hashbang line?
`reverse function()` propagates the surrounding context (e.g. `my @x = reverse function();` vs. `my $x = reverse function()`). I think the "surrounding context" here would typically be a scalar, since it's most likely to be called in `if` or `?:` constructs, but that could lead to some unexpected results if you try to pass as `other_function($x in function())`... I'd suggest posting on perl5-porters, see how much interest there is.
Whatever Mouse does is irrelevant due to its incompatibility. And if the validation has such a huge effect on things, then it makes the point extremely well that you're talking about a micro-optimization that will have little to no effect in real world code and can mainly be measured in synthetic benchmarks.
That appears to be instructions to port CGI::Application things to mojo. I don't know anything about CGI::Application but it appears to use \`?rm=whatever\` for dispatch. In which case it would be a perfectly good way of providing persistence - althought the docs there are a bit light. Note the old CGI protocol support in perl is and evil (it bad things with \`STDIN\` and \`%ENV\`) , so you'd want to do your best to avoid writing new code using that approach.
Yeah, I have an old thing and am moving towards mojo. I want to know if following this guide will provide all that mojo offers as standard
Did you try 6model, available in Perl 6?
I remember it by thinking about the doesn't-match operator !~ This means the ! must go before the ~, which means it must be =~
Here's a somewhat obscure one .. I was opening a bunch of file handles that were being stored in a hash table. However, printing to those filehandles was a problem .. it turned out I needed to do this: print { $hash{$key} } "Line for $key file"; In other words, put the filehandle inside a scope. It's not something you do more than once a year.
Bikeshedding time! my $my_var = cond1 ? 'a' : cond2 ? 'b' : cond3 ? 'c' : 'd';
No, did not try. I am not interested in Perl 6.
If you want this object model with good performance, it's worth a look. But to each their own, I was just after your opinion if you had a look.
Heh, it's not that I don't want, it's just the fact that I make a living by programming. Unfortunately even at our company (that started as a perl shop and still has a *lot* of perl code) things are moving away from Perl 5 and not into Perl 6 direction. Golang, ES7, Python... 
I wasn't suggesting you use it in production. I just wanted to know if you had a look at it.
The fact that Mouse is incompatible with Moose on internal level has a different weight to you and me. Compatibility of the outer sugar is much more important to me personally. When we moved our original classes written in Moose to Mouse at work, the only thing we needed is s/Moose/Mouse/ and things started running three times as fast. I like Moose's OOP protocol and happen to like Mouse's implementation of it. That's it. I feel like our discussion has gotten a bit heated, and don't really like its tone. My benchmark just meant to show that your original assumption that Moo is slower than Moose is not correct and the slowness lies elsewhere. 
Sorry, I missed that part of the thread: No, unfortunately, because as you mention, DBIx::Class isn't. I should add a promises API to the backend, and then async things could be async, and sync things could still return a promise already fulfilled. In fact, it might be better to only use promises for this...
&gt; the old CGI protocol support in perl is and evil (it bad things with `STDIN` and `%ENV`) Pardon my ignorance, but what is so evil about it? Deep underneath all the pretty candy, all web frameworks still use a combination of CGI parameters (be it POST or GET) and cookies, do they not?
No, they are normally deployed as application servers which receive the requests directly. They will only interact with the CGI protocol if deployed as a CGI script.
see the sidebar: "Want coding help? Asking at PerlMonks or Stack Overflow may give faster assistance." irc will also get you faster help.
Dude it's about K3 and K6 looking like kne name with different version numbers -.-
 use Date::Calc qw(Add_Delta_Days); my ($y, $m, $d) = Add_Delta_Days(2012,1,1,186); use POSIX qw(strftime); print strftime("%b%e, %Y\n", 0, 0, 0, $d, $m-1, $y-1900); Jul 5, 2012 
I was referring to the browser to server communication. I don't really see the huge difference between deploying small self contained servers, and the good old Apache/nginx approach.
I'm not sure what you're referring to then. Browser to server communication is HTTP, not CGI.
Consider the sentence, "Give me a cookie." The (implied) subject is "you"; the verb is "give" the object is "a cookie"; and the indirect object is "me". This is equivalent to the sentence, "You give a cookie to me." None of this has anything to do with object-oriented programming.
So, as maybe the last user that uses Date::Calc left on the planet (it seems), I gotta say you should at least be using the object oriented version... $date = Date::Calc-&gt;new($selected_year, 1, 1 ) - [0,0,$day[0]-1]; $date-&gt;date_format(3); # Or a coderef to your custom format "$date"; &gt; Friday, July 27th 2018 You can pass it a custom handler for whatever format you want, though. I don't believe the built in 4-5 formats are exactly the one you're looking for, however.
Well [here's](https://metacpan.org/source/TOKUHIROM/CGI-Emulate-PSGI-0.23/lib/CGI/Emulate/PSGI.pm#L13). How you make an old CGI.pm script work under PSGI. Having to have that go on underneath is really horrible. Woe betide you if your application is architected in an exotic manner cos you'll suddenly find STDIN and/or ENV isn't where you thought it was.
yup, this -&gt; #!/usr/bin/perl
Unless you’ve brewed your own. #/usr/bin/env perl Which is why I suggested perl on the command line initially...
Trying to code **[AI Go FOOM}(http://agi.topicbox.com/groups/agi/T57cced66d45fa115)**. 
I hadn't thought about it in that context. I thought it had something to do with Perl's ["indirect object syntax"](http://perldoc.perl.org/perlobj.html#Indirect-Object-Syntax).
Even Larry Wall says he has to look up things from time to time.
hey , I probably sound stupid for not understanding what you said..but honestly I didn't :p ok see, the first line of my [moss.pl](https://moss.pl) file is #!/usr/bin/perl ; which is what the moss code sent by Stanford is suppose to be .. after executing ls -l [moss.pl](https://moss.pl) I got : \-rwxr-xr-x@ 1 lamyabhasin staff 11117 Jul 29 02:29 [moss.pl](https://moss.pl)
Having Apache or NginX start a Perl process could take 50 milliseconds or more, which doesn't sound like much, but that's only 20 requests a second before your server starts falling further and further behind, eventually crashing. The self-contained server, in contrast, can easily handle thousands of requests per second. CGI just can't cope with what the web has become.
./moss.pl - current directory probably isn't on your path.
Can you run: `ls -l@ moss.pl`? `@` in your output indicates OS X attributes are associated with the file. I wonder if this is preventing the `chomd` (though regardless, seems odd). I have seen OS X ACLs cause stuff like this before but looks like your file has none. They're usually noted by `+` in `ls -l` output. 
&gt; Your arguments was called on something else, which I won't attempt to explain here :) Actually, the arguments were never passed to anything because `from_day_of_year` threw an exception.
Is there any place where we can read what Damian proposed? It's all a bit confusing atm. Thanks!
\-rwxr-xr-x@ 1 username staff 11117 Jul 29 02:29 [moss.pl](https://moss.pl) com.apple.lastuseddate#PS 16 com.apple.metadata:\_kMDItemUserTags 42 
I am new to perl. Alos not my choice of useing Date::Calc I was using datetime (I think that is the module) but I am not the lead and for reasons (unknown to me) they don't want to use that module.
True. What I meant was: your arguments would have been called on something else, and I was trying to avoid talking about subrefs :)
Will keep that in mind. 
I don't know if there is a backup, but you might be able to build a dist of it with this: https://metacpan.org/release/Perl-Dist-Strawberry
https://www.effectiveperlprogramming.com/category/perl/new-features/
There's nothing wrong with it, it's just not in style any more. 
Thanks! That looks great :)
Discussion thread on p5p: https://www.nntp.perl.org/group/perl.perl5.porters/2018/07/msg251647.html And a reply mentioning that there is actually a possibly usable difference in dying and returning false from require: https://www.nntp.perl.org/group/perl.perl5.porters/2018/07/msg251670.html
I'd use the smartmatch operator: #/usr/bin/perl use experimental 'smartmatch'; my @a=qw(1 2 3); my @b=qw(2 4 5); sub diff($$) { my @a=@{@_[0]}; my @b=@{@_[1]};; grep { !($_ ~~ @b) } @a; } print join ',', diff \@a, \@b;
https://www.reddit.com/r/perl/comments/6su5ig/keynote_by_damian_conway_three_little_words/
For me, probably [formats](https://perldoc.pl/perlform), simply because I haven't used them much yet. I suspect a lot do not use it much either.
Why? Just use MySQL for development, too.
Those seem fine. You can try to delete them with `xattr` but I don't think this is the problem. Maybe moss.pl has a space in the name? If you have GNU ls you can run `ls -Q`. Otherwise, maybe `ls -m` will show? 
format was a Perl 1 era (!) attempt at a templating language. We now have [much better options](https://perldoc.pl/perlfaq4#How-can-I-expand-variables-in-text-strings%3F) for templating that don't have to interface directly with global variables and filehandles.
I think you're correct about the need for a lightweight object system that does not have trifling inconsistencies with Moose/Mouse usage. Although MooX::late comes pretty close, and if the Moose usage you care about is MooseX::Declare, Moops looks like it comes pretty close too. With respect, though, I think the *main* issue with Mouse is [exactly what it was said to be in the comment you replied to:](https://shadow.cat/blog/matt-s-trout/moo-versus-any-moose/) Mouse can only play nice with Moose if Moose loads first, and the only control you have over that is by loading Moose first yourself (which kind of defeats the point). Moo does not use MooseX extensions; it has its own extension space, MooX. (But some enlightened modules like Type::Tiny do manage to cooperate with all three.) The parallel Moose/Mouse ecosystems you mentioned might be a symptom of the load-order problem, created on the theory that the more stuff can be done in Mouse, the less chance somebody's going to load Moose late and make Mouse go boom. That's pure speculation on my part, though.
It seems to be up now: [http://strawberryperl.com/releases.html](http://strawberryperl.com/releases.html)
the name doesnt have a space. 
Certainly, though it is still interesting as to why formats remain in the first place. An ode to backwards compat, perhaps? For most templating I usually reach towards Text::Template or Text::Xslate, more more recently Mojo::Template...
The program is designed to break computer arithmetic. This is not a joke. Even perl6 breaks: $ ./breakperl6.pl 00 | 4.0000000000 | 4.0000000000 | 4/1 01 | 4.2500000000 | 4.2500000000 | 17/4 02 | 4.4705882353 | 4.4705882353 | 76/17 03 | 4.6447368421 | 4.6447368421 | 353/76 04 | 4.7705382436 | 4.7705382436 | 1684/353 05 | 4.8557007126 | 4.8557007126 | 8177/1684 06 | 4.9108474991 | 4.9108474991 | 40156/8177 07 | 4.9455374041 | 4.9455374035 | 198593/40156 08 | 4.9669625818 | 4.9669625693 | 986404/198593 09 | 4.9800457014 | 4.9800454510 | 4912337/986404 10 | 4.9879794485 | 4.9879744208 | 24502636/4912337 11 | 4.9927702881 | 4.9926694965 | 122336033/24502636 12 | 4.9956558915 | 4.9936371620 | 611148724/122336033 13 | 4.9973912684 | 4.9569659720 | 3054149297/611148724 14 | 4.9984339439 | 4.1829179009 | 15265963516/3054149297 15 | 4.9990600720 | -14.4971549507 | 76315468673/15265963516 16 | 4.9994359371 | 139.4819461498 | 381534296644/76315468673 17 | 4.9996615241 | 101.4151436597 | 1907542343057/381534296644 18 | 4.9997969007 | 100.0697650170 | 9537324294796/1907542343057 19 | 4.9998781355 | 100.0034856744 | 47685459212513/9537324294796 20 | 4.9999268795 | 100.0001742733 | 238423809278164/47685459212513 21 | 4.9999561271 | 100.0000087135 | 1192108586037617/238423809278164 22 | 4.9999736760 | 100.0000004357 | 5960511549128476/1192108586037617 23 | 4.9999842055 | 100.0000000218 | 29802463602463553/5960511549128476 24 | 4.9999905233 | 100.0000000011 | 149012035582781284/29802463602463553 25 | 4.9999943140 | 100.0000000001 | 745059330625296977/149012035582781284 26 | 4.9999965884 | 100.0000000000 | 3725294111260656556/745059330625296977 27 | 4.9999979530 | 100.0000000000 | 18626462930705797793/3725294111260656556 28 | 4.9999987718 | 100.0000000000 | 4071034/814207 29 | 4.9999992631 | 100.0000000000 | 5/1 30 | 4.9999995579 | 100.0000000000 | 5/1 31 | 4.9999997347 | 100.0000000000 | 5/1 32 | 4.9999998415 | 100.0000000000 | 5/1 33 | 4.9999999178 | 100.0000000000 | 5/1 34 | 5.0000002093 | 100.0000000000 | 5/1 35 | 5.0000052983 | 100.0000000000 | 943696/188739 36 | 5.0001066330 | 100.0000000000 | 46886/9377 37 | 5.0021330151 | 100.0000000000 | 2346/469 38 | 5.0426423508 | 100.0000000000 | 6031/1196 39 | 5.8456351856 | 100.0000000000 | 15602/2669 40 | 19.4660958648 | 100.0000000000 | 27272/1401 41 | 79.3143153484 | 100.0000000000 | 76459/964 42 | 98.6959677737 | 100.0000000000 | 122383/1240 43 | 99.9339369046 | 100.0000000000 | 77149/772 44 | 99.9966946616 | 100.0000000000 | 60498/605 45 | 99.9998347276 | 100.0000000000 | 604999/6050 46 | 99.9999917364 | 100.0000000000 | 12101199/121012 47 | 99.9999995868 | 100.0000000000 | 100/1 48 | 99.9999999793 | 100.0000000000 | 100/1 49 | 99.9999999990 | 100.0000000000 | 100/1 50 | 99.9999999999 | 100.0000000000 | 100/1 51 | 100.0000000000 | 100.0000000000 | 100/1 By iteration 51, perl6's Rat has converged to same answer as floating point.
Could you also show the code that does this?
It's from the article, just change the constant 20 to 50 on the two lines so that it runs for longer.
Rat is a trade-off so that performance doesn't deteriorate; when the denominator overflows 64bit integer, if you want it to keep going, you can use FatRat, which is "infectious", i.e. just putting in one will make everything use maximum precision
True. I guess the Rat type is better than floating point for normal programs people are likely to write, but it is unfortunately not perfect answer and doesn't make computer math always give the right answer, which is how people often write about it. The denominator, however, is quite likely to hit 64 bits after a few dozen operations, just as it happened in here. I think the author of the article just fell for the hype, but I knew immediately from seeing the denominator dump that it must fail for Perl6, too. 
&gt; just putting in one will make everything use maximum precision FWIW, `Num` is more infectious than `FatRat`
&gt; actually have to explicitly ask for troble to get it by converting the Rat to a Num FWIW, Perl 6 *does* have standard floating point literals, you just have to explicitly specify the exponent as part of the literal, e.g. `.123e0` &gt; I have to say that I have had a hard time identifying a Perl6 killer feature [...] But I have to say perhaps some of this can be? I consider it mostly a convenience on the same level as using `/.../` for regexes instead of `Regex.new('...')` that you have to use in some other languages. Nothing revolutionary about rationals. First of all, `Rat` automatically degrades to a `Num` as soon as its denominator hits 64 bits. If you must maintain max precision at all costs, you have to use `FatRat` type, which makes it no different than switching to `Decimal` or whatever library other languages have and doing the same amount of extra writing. But also, all of this extra precision doesn't come free. On latest release, the floating point version of the code below is **21,215,052x faster** than the Rat version. say (1 + .123 /$_) ** $_ with 50_000; say (1 + .123e0/$_) ** $_ with 50_000; 
Yeah, FatRat is slightly amusing. #!/usr/bin/env perl6 sub rec($y, $z) { return 108.FatRat - ((815.FatRat-1500.FatRat/$z.FatRat)/$y.FatRat); } sub default-behavior(Int $N, $default) { my FatRat @x = (4.FatRat, 4.25.FatRat); for (2..$N+1) -&gt; $i { my FatRat $n = rec(@x[$i-1], @x[$i-2]); $n = $n.Num if !$default; @x.append($n); } return @x; } my @y = default-behavior(250, True); for @y.kv -&gt; $i, $p { my ($a, $b) = $p.FatRat.nude; say $i.fmt("%02d") ~ " | " ~ @y[$i].fmt("%3.10f") ~ " | $a/$b"; } 
Thank you to all who allowed, appear in, captured, posted (and spread the word about) the videos. As someone who used to go to these type conferences, but haven't in many years (work doesn't send employees; vacation spoken for), it keeps me connected to the community and I learn useful and cool things.
C'mon everyone, this is perl, and programming. There is more than one way to do it, and just because the way you currently see is ugly and/or yields broken or sub-par results doesn't necessarily mean it has to be that way. Maybe there are language bugs that need to be cleaned up. Or maybe you just need to think about it the right way. In this case you've got three options: * **100% accurate**, but slowest. Use **unlimited precision rational** numerics, aka `FatRat`. Sequence converges on `5` at iteration "75". * Less accuracy, but faster. Use **whatever precision** numerics. Sequence goes haywire at around iteration "35". * Least accuracy still, but fastest. Use **floating point precision** numerics, aka `Num`, double floats. Sequence goes haywire at around iteration "15". &amp;#8203; sub rational { ( 108 - ( 815 - 1500/$^y ) / $^z ) .FatRat } sub whatever { 108 - ( 815 - 1500/$^y ) / $^z } sub floating { ( 108 - ( 815 - 1500/$^y ) / $^z ) .Num } constant iterations-of-interest = &lt;2 3 12 13 14 17 28 34 40 52 53 74 75 1000&gt;; constant numeric-types-of-interest = [&amp;floating, &amp;rational, &amp;whatever]; for iterations-of-interest -&gt; $nth {print "\n$nth"; for numeric-types-of-interest -&gt; &amp;type {print "\n&amp;type.name(): \t"; print .[$nth] given 4, 4.25, &amp;type ... Inf}} displays: 2 rational: 4.470588 whatever: 4.470588 floating: 4.470588235294118 3 rational: 4.644737 whatever: 4.644737 floating: 4.64473684210526 12 rational: 4.9956558915 whatever: 4.9956558915 floating: 4.993637162006792 13 rational: 4.9973912684 whatever: 4.9973912684 floating: 4.956965971956066 14 rational: 4.99843394394 whatever: 4.99843394394 floating: 4.182917900925375 17 rational: 4.9996615241038 whatever: 4.9996615241038 floating: 101.41514365970045 28 rational: 4.999998771812311329999 whatever: 4.999998771812315 floating: 100 34 rational: 4.9999999426976416501660969 whatever: 5.0000002093320575 floating: 100 40 rational: 4.99999999732650109580505138658 whatever: 19.466095864788358 floating: 100 52 rational: 4.99999999999418037480227063278209046744 whatever: 99.99999999999987 floating: 100 53 rational: 4.99999999999650822488135831550476123014 whatever: 100 floating: 100 74 rational: 4.99999999999999992340110157492410507214191742577871705 whatever: 100 floating: 100 75 rational: 5 whatever: 100 floating: 100 1000 rational: 5 whatever: 100 floating: 100 The *rationals* (`FatRat`) sequence is **100% accurate from start to finish**. It converges on exactly `5` at iteration “75” (76th number in sequence starting from `4`) and never moves off of it thereafter. The *whatever* sequence, which shows the default results the language returns if you don’t specify what number types you want, starts out as a `Rat`. A `Rat` is like a `FatRat` except it gives up on 100% accuracy and slims down to a `Num` when the denominator of a user visible stored result would exceeds 64 bits. This yields exactly the same results as the *rational* sequence (`FatRat`) until iteration “28” when it switches to `Num` (float) and the two sequences begin to diverge. Note that it’s still way better than the *floating* sequence that uses `Num` from the start. When the *whatever* sequence first diverges it is actually closer to `5` than the `FatRat` sequence. It soon overshoots `5` at iteration “34”, loses the plot by iteration “40”, hits `100` at iteration “53” and never moves off it thereafter. The *floating* (`Num`) sequence becomes the least accurate from iteration “3”. It begins to noticeably lose the plot around iteration “12” and completely lose it by iteration “15”. It hits `100` at iteration “28” and never moves off it thereafter.