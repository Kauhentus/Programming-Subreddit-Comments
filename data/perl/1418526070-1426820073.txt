But can you give an example that you have run into? I mean, you make it sound like it's a problem you personally run into, often. 
Tl;dr: We're not shipping until next year. Not exactly the first time I have heard this, so why should I believe this time is the last? 
It depends on what you mean by install, I guess. Perlbrew works fine for me. See also: http://stackoverflow.com/questions/2980297/how-can-i-use-cpan-as-a-non-root-user 
* Concurrency * Lack of a built-in, declarative object system * Lack of routine signatures (the ones in 5.20 are a step forward, but they miss validation) * A reputation for lack of readability * Lack of excitement * Inability to correct design errors (let's just mention `reverse` doing two totally different things in scalar vs. list context)
I think perhaps that's one particular group that you're taling about. The London group always has interesting meetings.
Please, link to a non-version specific URL of the module. For example: https://metacpan.org/pod/Parallel::ForkManager
Perl fell off, because other languages came into the light and they just took the share. I'd say the only thing Perl did wrong in the past is not to move away from CGI quickly enough. It was a pain to setup and most users just moved to PHP because of it. Upload a PHP to the server and it "just works", no need to chmod, no funny business. Just works. Then installing packages on shared hosting was a pain. Yes, of course, there is local::lib, but it is still a pain. In PHP, most of the stuff Perl needed backpages for, it was just all built in.
Yeah, I'm game. Looking at it...
&gt; I think the vision is to keep code that's 20+ years old running (backwards compatibility). There's playing to win and there's playing not to lose. Unfortunately, the latter means not winning.
so you're telling me that function parameters kept you from writing the great software that you needed in perl 
I wouldn't know what's the vision, I'm hoping that Ricardo Signes and the likes know it already. Besides that I still think we need a major piece of software that will hold the flag up for perl and bring enough attention to it
No, not at all, I'm saying that that attitude is what killed perl.
I think we as a community have to prioritise what's is more important for the language and eventually us. Is it missing tech from core/CPAN or missing products written in perl that have in enough exposure to bring the language into focus? I'm strongly in for the second...but that's just me
I sincerely doubt that is going to make any difference.
But still in the game ;-)
I *personally* haven't been paid to write a line of Perl in almost a year. Sure, I have some side projects that bring in revenue and they're still built in Perl, but the Perl job prospects I've seen this past year have been laughable. That's not in the game. That's not DNF. That's Did Not Show Up.
You can easily use [Text::CSV](https://metacpan.org/pod/Text::CSV) to parse the CSV file. Of course if your format is this simple, and there are never any other semicolons on a line, you could simply use [split](http://perldoc.perl.org/functions/split.html). You can then use a regular expression or split (or any number of other methods) to get the domain portion of the url and then you can simply have a hash with those domain strings as keys referencing the increasing total. I'm hesitant to write out a code example for you because this feels like it might be a homework assignment or something, but this should get you on the right track.
You may have complications with country codes, e.g. .nz has ones like company.co.nz and someone.geek.nz (i.e. regular 2LDs), and also now allows company.nz. This may not be a problem for you, but keep it in mind.
Do you mean semi colon delimited? If so, just use a hash and += on the key. I.e. read the file with a while loop, use a greedy regex to get the TLD (e.g. google.com) then make this a key, with the value the number of attempts assigned with += so that each time the same TLD is seen it adds the values to the key. Once you are done, sort and print out the top key/value pairs. On a modern computer you should easily be able to parse file up to several gigs in memory this way. 
Likely there are modules on CPAN to extract a TLD from a domain name. It'd be safer to use that instead of just blindly using the last 2 words in the domain name.
&gt; I've no idea why they thought PHP was less powerful / &gt; more secure in a shared hosting environment, but that's &gt; what I heard a few times. It was in practice because PHP has built-in resource limits, and you could run it in "safe" mode. Perl (or most other languages) had no similar built-in support at the time. Nowadays this problem is entirely solved by just giving people a whole VM, and only certain limited platforms (e.g. Google App Engine) try to emulate the old "safe shared hosting" way of doing things. &gt; PHP took over; mostly because of (IMO) the ignorance of hosting providers. I don't think that's a fair claim, you *could* accomplish safe shared hosting with "unsafe" languages back in the day with chroots etc. but it was much more of a hassle, whereas PHP you could just install, configure a bit and be done with it.
Wow, that's really grim. I think that person needs better friends, not more self-censorship.
This isn't really anything to so with signals or trapping them. What it is about is discovering that not everything one thinks is amazing is actually amazing, identifying this as a habit, learning how to change it and, most importantly, that this requires continued concious effort if it is to stick.
&gt; Time to drop the rate? It's not worth it. A client only willing to pay half of my normal rate is very likely to be a high-maintenance client.
As something of a side point, I'm amazed sometimes how programmers get set in their ways (and I'm as guilty as anyone else). People claim they can pick up any language in a day (and the student above seems like they have enough languages under their belt that they'd make that statement), but then complain as soon as you ask them to use a language outside their comfort zone. The reason, I think, is because you can technically learn a language's *syntax* in a day, but you can't learn the whole *ecosystem* in a day, or even a month. I know how to navigate CPAN to find whatever module I need, I know shortcuts for installing modules, and I have my editor setup just so for how I work with Perl. It's all very seamless, and it took me many hours of tweaking to get here. I'm sure there are equivalents to all this in Python or Ruby or whatever, but the seamless quality is impossible to move over without spending an equivalent amount of time. What it comes down to is that programmers should stop claiming they can learn a language in a day.
This example should help you provided I understand you correctly.. use strict; use warnings; use feature 'say'; my @locations = qw&lt;2 4 6&gt;; my $dna = 'ABCDEFGHIJ'; say $dna; my $processed = '-' x length $dna; say $processed; substr ($processed, $_ - 1, 1) = '*' for @locations; say $processed;
Thanks! I will try that. This is what I have so far: my $EcoRI = "GAATTC"; # sequence I am searching for while ($sequence =~ /$EcoRI/gi ) { # $sequence is my input my @EcoRI = pos($sequence)- length($EcoRI); # finds EcoRI locations print OUTPUT "@EcoRI \n"; #don't need to print it, just wanted to see if it worked } If I wasn't too clear, my problem is that I am not sure how to use the locations saved in the array to substitute at those positions in my sequence.
Can you give more details on your code and what you're finding slow? You can call "all" on a MongoDB::Cursor, though that just does the iteration behind the scenes. FWIW, I just opened a ticket, [PERL-475](https://jira.mongodb.org/browse/PERL-475) with a note for how to optimize the 'all' call in the future.
The code actually is calling "all". The problem is that on our system, each call of "next" takes about 20-30 ms, and there are tens of thousands of rows. Now, I am running the code through Devel::NYTProf so the call time is fairly exaggerated, but it still amounts to several minutes even without the profiler. I appreciate you opening that ticket. That's exactly the solution I'm looking for.
What does ecori mean?
EcoRI is a restriction enzyme - the name of the sequence I'm searching for.
Oh, I always love it when people tell me how much time *my job* is going to take. And 10 USD? Wow. Those 100 lines of "basic commands" all need to be thoroughly tested etc. That alone might take way more than 5-10 minutes.
This is a style thing, I would go with $ecori Perl variables are typically lowercase. Also, if space indent your code, reddit will format it nicely.
I studied Java in college and one of the greatest things Perl ever did for me was help me truly understand what "Object Oriented" programming was. Perl always gets bashed for it's primitive OO, but by being primitive it makes learning OO concepts--at least it did for me--that much easier.
Thanks. Didn't have internet access on the box I was running it on but I manged to do a local copy of the .dat file. Now I just need to fiugre out how to print only the top 500 domains descending order by attempts
Do you also walk into a doctor's office telling him you've already done the blood work at home and only need him to write a script. And since that only takes a minute you're happy to pay him 10 bucks...
got the sorting to work now also. Your script works as a charm I just wonder why: d3v1lb83psg9di.cloudfront.net gets printed as that string and not cloudfront.net
Not in an image format it can't. 
Best guess: domain is not in the .dat file. Try adding it to the .dat file, using the same format. 
Yup, that's my experience as well; half the pay and 4 times the work (if you're lucky). Paying late, and trying everything to pay even less (insisting on discounts, fines for missing deadlines, etc.). FWIW my experience for the past year has been the opposite of yours. But (!) I am very aware that this won't last forever. Or better: I have been aware of this for like a decade but each time I thought I could switch to a different language another Perl job came in. And I really do like Perl over e.g. Python. I can't even explain why. Last time I tried, in a Python Usenet group [1], I was told that it was because I knew only one programming language (hah!). [1] Talk about being in the wrong place ...
I can't think of any. I think great efforts have been made to make Perl more accessible (Modern Perl, various OO frameworks, Dancer/Mojolicious). I am afraid that Perl's biggest problem is that it's considered both archaic and unmaintainable (because unreadable / write-once / too many ways to do things). Fixing those things would, IMO, turn Perl into a new language and it's not like we don't have already enough of those. To me it's simple: if you like Perl and can use it in your job or hobby, use it. If you want a much cleaner language check out Python. And if you want something in between, check out Ruby. And if you want something crazier.... Haskell, maybe?
*Always* `use strict; use warnings;`!
Some things I would change * use struct/warnings (as mentioned) * Do not use global filehandles * use the 3-arg version of open * the while loop is much too long for using $_ 
i guess it depends on whether one's focus in more on trying to teach people *programming concepts in general*, or trying to teach people a *specific language for employment reasons*. If you're wanting to increase the likelihood that someone will get Web dev work, sure, teaching them about PHP and its ecosystem makes lots of sense. But in terms of trying to discuss general programming concepts, PHP is a thicket of inconsistency that effortlessly hides such concepts, which probably tends to increase cognitive load on students. So whilst the boilerplate of a Java "Hello World" program might be a relatively high initial hurdle for students, at least they won't have to remember something like "Oh there's both `static` and `staTick`, which are mostly similar but nevertheless have important differences."
A link to the actual files has now been added to the OP.
Thank you for your answer. By "tagged file" I suppose you mean one of the two word lists. In the OP I have added an imgur link to images of them (parts of them, as they are loong), and have also added a link to the actual files. The first two do nothing when I run them, the third one gives me a random number like this: &lt;!--29--&gt;
OK - It looks like you're out of luck, I'm afraid. The first program is supposed to open a file called "tagged", which should look something like (I'm guessing based on the code)... word1/anotherword1 word2/anotherword2 [blank line, or rather one with no "word" characters] word3/anotherword3 word4/anotherword4 [blank line] etc. then process that file and save a bunch of files called "scheme1", "scheme2" etc. up to "scheme48" The second file reads the same file, and writes a bunch of files called "class-something" - but again, this is dependent on the words in "tagged" having a slash in them. The third file then reads a random scheme file (hence the random number) , and uses the class* files to generate the poem. On a second reading, I see all sorts of little bugs that may stop it working, but the main problem appears to be that the "tagged" file isn't the right one. I'm not sure what those two data files are, but neither of them look to be in the right format to generate the scheme files. Sorry. 
An article written in 1996? Really? Like two decades ago.
&gt; Java was supposed to die According to who? Anyway, Java has much more corporate dollars thrown at it. And there are other JVM languages. So it's not going anywhere.
Yes, he is spot on.
I couldn't agree more, and I'm very thankful to have a canned response (in the form of that post's URL) to hand out the next time someone is lamenting to me that they have to abandon Perl because nobody wants to work with Perl anymore. Perl isn't the problem, your company is.
INFO_OUT is a bareword filehandler. It's the older style for opening a filehandler. open(my $fh, "&gt; $info_output") is equivalent. All that's doing is opening a file for output. the '$!' is like strerror() in C. It's the the error message text from a system call.
Awesome! Thank you for the clear answer! Have a coffee on me /u/changetip! Follow up question: If I were to do the same thing in UNIX, would I need the filehandler? I'm not familiar with filehandlers, but later in my perl script, I have print commands such as: &gt; print INFO_OUT "Were done\n"; which I'm guessing adds this text to the filehandler. Is there I can maintain this functionality in UNIX?
/u/cQuaid, Hakuna_Potato wants to send you a Bitcoin tip for 1 answer (1,256 bits/$0.42). Follow me to **[collect it](https://www.changetip.com/collect/264764).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
I'm writing ksh. Awesome! Thanks again!
Following up from cQuaids answer barewords are usually considered bad practice in perl. If you use the same filehandle anywhere else in the same package your open statement will close the existing filehandle and replace it with the new one. If you have a subroutine of the same name in scope the bareword may fail silently. This will probably be bad in most real world programs. Might I suggest adding the [following lines](http://stackoverflow.com/questions/8023959/why-use-strict-and-warnings) to the top of your program: use strict; use warnings; These will cause the compiler to complain when you make errors. I like to use [perlcritic](http://search.cpan.org/dist/Perl-Critic/bin/perlcritic) to check each program as well. [Perl::Critic](http://search.cpan.org/~thaljef/Perl-Critic-1.123/lib/Perl/Critic.pm) is based on Damian Conway's book [Perl Best Practices](http://shop.oreilly.com/product/9780596001735.do).
&gt; d3v1lb83psg9di.cloudfront.net Ah... it appears 'cloudfront.net' is listed in the .dat file as a domain. // Amazon CloudFront : https://aws.amazon.com/cloudfront/ cloudfront.net 
You could filter it out. my @domains = sort { length $b &lt;=&gt; length $a } grep { $_ ne 'cloudfront.net' } split '\n', $data; If there are multiple types of entries like this, you could use a regex to filter them.
Thank you for the tips! I'm trying to convert this script from perl to ksh, so I'll see if I can find an equivalent commands for the compiler in UNIX. If I am ever writing perl, I will be sure to use your suggestions!
Uh...it's about the human genome project. So yes. Like two decades ago...
CGI wasn't the problem, People Love FastCGI.
Perhaps it'd be nice to have more recent success stories.
Considering workarounds... are the documents large/deep/complex? If so, can you do with just a subset of fields that might lower the deserialization overhead?
It was a common prediction about 10 years ago. What seems to have happened instead: the number of languages is growing, fragmenting the marketplace, in smaller and smaller niches (or so it appears to me).
`INFO_OUT` will be the name of the file handle if the open succeeds. You can use it like e.g. print INFO_OUT "some info\n"; close INFO_OUT; `$!` is the error if the open fails (see "`perldoc perlvar`").
&gt; Concurrency Processes are good enough for that. OTOH, the lack of parallelism hurts in the SIMD world. &gt; Lack of a built-in, declarative object system Meh. If you want `Moo.*`, you know where to find it. &gt; Lack of routine signatures (the ones in 5.20 are a step forward, but they miss validation) Writing sub foo($x,$y) { ... } instead of sub foo { my ($x,$y) = @_; ... } saves a few keystrokes, but validation needs a type system, and then you're really down the rabbit hole. &gt; A reputation for lack of readability Can't be helped. &gt; Lack of excitement Same. &gt; Inability to correct design errors (let's just mention reverse doing two totally different things in scalar vs. list context) Inability to break working code is a *feature*. Like C, Perl is a platform: people can build stuff on top of it and expect their stuff to keep working. Backward compatibility is the cost.
&gt; installing packages on shared hosting was a pain. Still is. Perl was king for awhile because it first was better for sysadmins than sh+awk+sed, and then came with CGI. Plus, it bent over backwards to be portable among the many Unices around at the time. It solved real problems. Adding "declarative object systems" or "validated function parameters" doesn't matter. Helping people do their jobs does.
Also recommended, the CPAN 'autodie' module. Compare: $ perl -e 'open my $fh, "&lt;", "no_such_file.txt";' (no output, you need to check the return status of 'open' to check if it worked or not) $ perl -e 'use autodie; open my $fh, "&lt;", "no_such_file.txt";' Can't open 'no_such_file.txt' for reading: 'No such file or directory' at -e line 1 Fatal exception, probably what you wanted anyway. Info: https://metacpan.org/release/autodie 
&gt; It solved real problems. If there's one thing Perl should have learned since mid-2000, it's exactly that. Solve Real Problems.
Ah, too bad. Thanks for your help anyway!
There's quite some oldish [reply on PerlMonks](http://www.perlmonks.org/?node_id=578403) referring to [HTML::FormatText::WithLinks](https://metacpan.org/pod/HTML::FormatText::WithLinks) assuming that `links` and `lynx` produce similar `-dump` output.
The output is a bit different to what `links -dump` produces but I think I can work with that. Thanks a bunch!
No, that's most of the groups. The ones that are successful are the exception, not the rule. Nobody uses mailing lists any more. Hell, I abandoned the idea of trying to start one when I realized that IRC was alive and kicking.
Yeah, there's a lot of unwarranted FUD with the language. The two stupid jokes I heard about Perl are: 1. Perl is ugly (because of sigils, but they don't actually say the word "sigils") 2. When is Perl 6 coming out? I happen to like sigils because it lets you know what kind of variable you're dealing with. And nobody cares about Perl 6 except Perl 6 people.
That and "don't break people's code." Perl 6 broke the world for major changes, and failed as a version of Perl (5). Python 3 broke the world for minor nit-picks, and seems to be a slow-moving train wreck. Ruby 2 broke stuff, but Ruby developers are used to spastic development, so I think it mostly worked. Now Perl (5) is going for the "boil a frog" method. Annual versions break enough code to be annoying, but not enough to take the trouble to maintain an older version. And they provide some minor new features, but none that justify the annoyance.
WWW::Mechanize?
I love the future.
"Not exactly the first time I have heard this"--No kidding, Larry's first announcement in 2000 said "We're not shipping until next year". At least the message is consistent.
Its a good thing there'll be an announcement of a new version of Perl next year (at FOSDEM) so that every company that's been waiting for 15 years to decide what to do with Perl will finally know when they can start thinking about what to do with Perl. Because let's blame the users.
Yeah, the "sigils" thing is just stupid. Perl 6 though, I stopped looking at that a long, long time ago. Personally, I've been using Perl for work since maybe 1996 or so, I can't remember exactly. However, it's been years since I've last worked with someone who had a working knowledge of Perl. I like Perl a lot, and recently used some of the Plack-based stuff. It's very nice for brutal data processing. I never got around to trying something like Dancer or Mojolicious though. Very recently, I've made the jump to Ruby (specifically, Ruby on Rails for getting shit done). It "feels" a lot like Perl, but strangely different, so it was pretty simple to slip into it. The chief reason being because it's more "current", and because I'm seeing less and less support for Perl with APIs for various tools and projects. For example, if I want to use a service of some kind, I'll check the API's and see stuff like Java, Python, Ruby, Lua, etc... but it's getting a lot rarer to see Perl included in that list. For me, Ruby has (or seems to be acquiring) many of the advantages of Perl, and fewer of the drawbacks. Shit, even the Plack thingy was inspired by Rack. Plus, I live and work in Japan, so Ruby has a bit more of a "good rep" here. So all in all, Perl is still very nice, but it simply is not being marketed aggressively enough. 
&gt; I need some assistance. For some reason the scripts will run only if I put my .pl script file on "/home/vli/scripts/logs". But if I put my .pl scripts file in "/home/vli/scripts" no result "somefilename.txt" is found. I would like to run it from "/home/vli/scripts" so I can clear my files on "/home/vli/scripts/logs" the next time I run it. &gt; The scripts I was running is: &gt; !/usr/bin/perl &gt; use strict; use warnings; &gt; my $dir = "/home/vli/scripts/logs"; &gt; opendir my $dh, $dir or die "could not open $dir: $!"; &gt; I am assuming you are trying to only open files &gt; i.e. you were trying to exclude ., .., and any other &gt; directories, -f is a better choice for this &gt; my @files = grep { -f } readdir $dh; &gt; my $outfile = "somefilename.txt"; open my $out, "&gt;", $outfile or die "could not open $outfile: $!"; &gt; for my $file (@files) { open my $fh, "&lt;" , $file or die "Unable to open $file: $!"; while (my $line = &lt;$fh&gt;) { next unless $line =~ /L{6}|L0{5}/; print $out $line; } }
This is related to what johnbokma said. The readdir command returns files without the path information. You need something like my @files = map { -f "$dir/$_" ? "$dir/$_" : () } readdir $dh; The map function is like grep, but it returns the result of the statements in the block. The ?: operator is like an if/else. So this says if the filename appended to the path exists, return it, otherwise return an empty list. The result is the same as the grep, but the files get the path preprended to them.
yeah I attribute a lot of the "decline" of perl to be due to mod_perl. It's an awful environment.
I assume references as in the academic sense? Really we can't help unless we can see a sample input file, the thing that you should parse.
Yup, I think suga_glider has to open the file for reading, and while there are lines check if a line matches author and if so prints the author name(s). And when done close the file.
don't want to be a douche here but it's not in par with html5 &amp; js logos. I bet you can do better.
Assuming you have a file with references per line, with comma separators, then what you have is a CSV. In which case split on commas and print out whatever is the name
print $1 if /author=(\w+\s\w+)/ you didn't provide any text so I'm just guessing it's author=
There are about 20 different ways to do references in academia. We would need to know which one. 
 $ cpanm Biblio::Citation::Parser $ perldoc Biblio::Citation::Parser 
I actually used CAM::PDF at work recently for this exact purpose - pull stuff from the db, fill in a form, append it to an existing title page, then email the files out to be printed. Took a lot more tweaking of the PDF than coding!
tie
Course textbook: Ambiguously Ask The Internet, 19th Edition (requires one-time-use Temporary License Key for access to required quizzes and Enhanced Homework Environment)
Wow. Already downvoted? Why?
Interesting. I searched around too. I found mention of a library for Common Lisp but the link was dead and lots of modules for Python that somewhat seemed to be relevant but I too came up empty with any Perl mods. Sounds like it may be a worthwhile project since it's simply an xml format. Edit: misread. Not an xml format. But xm. My bad. Edit 2: libmikmod seems to be the c library for these files. There is a perl extension here. https://metacpan.org/release/Audio-MikMod
Just ignore down votes, those things happen.
&gt; "Software controlled generation" of music is not like really..... something people need that often ;) even in the old days ;) But can be fun: http://en.wikipedia.org/wiki/Live_coding e.g. https://www.youtube.com/watch?v=nHEA5HXedZ4 Done AFAIK using Tidal, a mini-language embedded in Haskell. In the video you can see the live editing of the code that generates the patterns you hear. A Tidal demo / walk through: http://yaxu.org/demonstrating-tidal/
Maybe OT: how much hassle is it to craft a client which covers the same ground (using OAuth 2.0, Atom and REST)? Here's the docs on the API: http://developers.google.com/google-apps/contacts/v3/ 
Yeah but then in you wouldn't generate MODs still ;) I mean picking some sound effect based on some event is actually called MIDI ;) and thats very old and you find A LOT of libraries for this......
Yikes. Change "perl" to "cobol" and it might as well be 1990. I love perl, and it's my primary language where I work. But we're more interested in migration than hiring more perl programmers. It's too risky.
Oh, just to be clear, I was throwing that question out to anyone who may have done something similar. So I wasn't suggesting that you should undertake that as a big project, rather that someone might chime in and say, "It's easy, here's how..."
This is VERY gentleman
Left. 
So the 21 may reference a dev version or the 1?
might be both, I recall that the even numbers show stable releases e.g. 5.20 and/or 5.20.2 and so on 
5.20.* are stable releases. 5.21.* are unstable/developer releases.
Shit talking perl on perl sub. so brave. 
I've been writing perl and using it for going on 15 years. I use it in my daily work. When people ask me what programming languages they should learn to learn programming, I tell them python.
It might be good to contact merixzon on github or CPAN to see if he has interest in updating the module himself to support OAuth2.0. I halfway thought about doing the work to make it current, but I don't want to take over maintainer because I don't use the code and I'm pretty busy right now so I don't know how much work it would be. Here are the URLs if someone wants to open issues on the current problems and/or ask for maintainership. https://github.com/merixzon/www-google-contacts http://search.cpan.org/~merixzon/WWW-Google-Contacts-0.38/
For your random thing, something like my @array = ("ruby is bad", "something perl"); $randomelement = $array[rand @array]; (I think) for your answer thing, I guess the best way is to catch when a PRIVMSG is sent, and compare it to a few strings you have (use something like if($text =~ 'yuppie what's up') { //} same thing for your bot commands ($text =~ '!wiki ') then split the string to get the value of the argument. There may be a better way, but I remember my IRC bot used something like that (but it was with Perl::IRC)
Let's hope #4 moves to #1
On our hackerspace IRC chan, we have two different bots (a Twitter one and another we use to update agenda and website). The code is published here : * Twitter : https://github.com/haum/TwitterBot * Agenda &amp; Website : https://github.com/haum/combot We use redis as an ACL database. Feel free to ask questions :)
Generally the way to implement commands is via a **Dispatch Table** which is a hash whose keys are the command names and values are coderefs. I've added an example of this to your code. (the use of `-w` should be replaced with `use warnings;`) https://gist.github.com/anonymous/741b24d23b5cb4ee780e Lines 13-25 define the `%commands` hash with a couple of simple examples. Lines 32-48 do the command processing. (You may wish to put this into its own sub.) It checks if the body begins with a '!' and then splits up the line e.g. `!foo bar` produces `$command = 'foo', @args = 'bar'`. It must then check that 'foo' exists inside `%commands`, if so, call the subref with whatever `@args` were given (if any, hence the checks using `length`). So you can test them out using `!echo` or `!greet`. As for your list of responses getting large, you may want to store them in a text file and use https://metacpan.org/pod/Tie::File in combination with `rand` as /u/zapper_the_man showed to get a random response from it. Hope this helps.
As someone who knows SEO &amp; Perl, and got hired in 2014 this makes me happy :)
EDIT: All modules in this post is quite old, somewhere between 2009-2012. I've used a few of them as late as this year which has worked well for my needs but if you run into problems another framework might be an idea. For the purpose of just learning perl I think this is a great way to do so! ----- If you like Bot::BasicBot I suggest you try to use [Bot::BasicBot::Pluggable](https://metacpan.org/pod/Bot::BasicBot::Pluggable) which makes it really easy to add new modules you create but also use existing ones to help you auth as admin, reload your modules, OP yourself and similar stuff. For the question on how to grab who is saying 'perl', it's stored in $message-&gt;{'who'}. So to respond to the person who said it, just do this: if ($message-&gt;{'body'} =~ /\bperl\b/) { $self-&gt;say( channel =&gt; $message-&gt;{'channel'}, body =&gt; sprintf('Silly %s, perl is for kids!', $message-&gt;{'who'}), ); } Regarding the Google question you can find a module (and modify for your liking) [here](https://metacpan.org/pod/Bot::BasicBot::Pluggable::Module::Google). If you want to implement a Wikipedia solution you can use [WWW::Wikipedia](https://metacpan.org/pod/WWW::Wikipedia) or write something yourself. If you wan't an API that returns just the text you can use https://en.wikipedia.org/w/api.php. It returns the DOM from the web page so you'll have to extract it yourself. A short example with Mojo::UserAgent (not tested) below. Note that this will fail a lot with e.g. ambiguous articles, articles starting with a template header etc. if ($message-&gt;{'body'} =~ /^!wiki (.+)/) { (my $title = $1) =~ s/\s/_/g; my $url = 'https://en.wikipedia.org/w/api.php?action=query&amp;prop=extracts&amp;format=json&amp;exintro=&amp;titles=' . $title; my $user_agent = Mojo::UserAgent-&gt;new(); my $content = $user_agent-&gt;get($url)-&gt;res-&gt;json; my $html; foreach my $id (keys %{$content-&gt;{'query'}-&gt;{'pages'}}) { if ($id &lt; 1) { $self-&gt;say( channel =&gt; $message-&gt;{'channel'} body =&gt; 'Nothing found on Wikipedia', ); return; } $html = $content-&gt;{'query'}-&gt;{'pages'}-&gt;{$id}-&gt;{'extract'}; unless ($html) { $self-&gt;say( channel =&gt; $message-&gt;{'channel'} body =&gt; 'No text found on Wikipedia', ); return; } } my $dom = Mojo::DOM-&gt;new($html) my $wiki_text = $dom-&gt;all_text(); # Might be an idea to shorten the result, ex. to get the first sentence something like this: (my $first_sentence = $wiki_text) =~ s/([^\.]\+. )(.*)/$1/g; $self-&gt;say( channel =&gt; $message-&gt;{'channel'}, body =&gt; $first_sentence, ); return 1; } Regarding logging, I wouldn't waste time on that so if you intend to use Bot::BasicBot::Pluggable I suggest you just install and use [Bot::BasicBot::Pluggable::Module::Log](https://metacpan.org/pod/Bot::BasicBot::Pluggable::Module::Log) I don't really have any good advice but if you plan on implementing a lot of 'arguments' to the bot you could go something like this: if ($message-&gt;{'body'} =~ /^!(\w+)(?: (.+))?/) { my ($action, @args) = ($1, split(/\s+/, $2)); unless ($self-&gt;can($action)) { $self-&gt;say( channel =&gt; $message-&gt;{'channel'}, body =&gt; 'Sorry, that is an unknown action...', ); return; } my $message = $self-&gt;$action($message, @args); $self-&gt;say( channel =&gt; $message-&gt;{'channel'}, body =&gt; $message, ); return 1; } sub action1 { my ($self, $message, @args) = @_; # Do something on !action1 return 'The text from action1'; } sub action2 { my ($self, $message, @args) = @_; # Do something on !action2 return 'The text from action2'; } 
 $ perl -e 'my @array = ("ruby is bad", "something perl"); for(1..10) { my $randomelement = $array[rand @array]; print $randomelement, "\n"; }' ruby is bad something perl ruby is bad something perl ruby is bad ruby is bad ruby is bad something perl something perl something perl Looks like you think right.
Missing a quote.. Should be open(my $fh, "&gt;", "$info_output")
Is there a ski module as well? :) (and I can't find anything but App::Skate on cpan)
Thanks for mentioning Crystal :-)
/r/mildlyinteresting
 sub live { }; sub free { }; sub hard { }; live free or die hard
Loved those games.
Or my skate = 1; For the kinds of people who wish to skate to immortality.
This definitely brought a smile to my Tuesday.
Bahahahahaa
No need for a module: $ perl -e 'skate or die'; echo $? 0
This works because, without the strict pragma, barewords that have not been registered as a filehandle, dirhandle, package, or function are treated as strings. This means the statement is actually `"skate" or die`.
&gt;Perl isn't the problem, your company is. Its a bit of both. I know a few shops who use Perl who are some of the best in the world at what they do. They use Perl because the programmers enjoy it and it gets the job done. But, I am familiar with many more companies who use Perl who are not working on interesting topics, employ bottom of the barrel programmers, and simply havent gotten around to changing or dont know how to (government departments, utilities, banks, consulting companies). The Perl community was always the real selling point of Perl. Perl 6 development did irreparable damage to Perl 5 in terms of the way outsiders saw the community. But really, who cares? If you enjoy using Perl and it makes sense for your circumstances then just do it and dont worry about what the world thinks about you. 
That comment wasn't meant for you, but for the people who may be confused as to why that code doesn't throw an error. But thank you for outing yourself as an unpleasant person. It makes it easier to know who to avoid in the future.
I guess I'm not sure exactly what part of my quoted text you're disagreeing with. &gt; I know a few shops who use Perl who are some of the best in the world at what they do. They use Perl because the programmers enjoy it and it gets the job done. i.e. "Perl isn't the problem. &gt; But, I am familiar with many more companies who use Perl who are not working on interesting topics, employ bottom of the barrel programmers, [...] i.e. Your company is. &gt; If you enjoy using Perl and it makes sense for your circumstances then just do it and dont worry about what the world thinks about you. Again, it sounds like you're making the exact same point I was (and that brian d foy was in his article): *Perl* isn't the problem here.
http://en.wikipedia.org/wiki/720%C2%B0#Legacy
Why not: use strict; use IPC::Run qw(run); my $output; if(run ['/usr/bin/links', '-dump', $url], \undef,\$output) { print "Gotit: $output\n"; } links (and elinks, my prefered fork) have options to control the terminal width, so you can stretch it beyond 80 chars.
Yeah, my current version was running links with backticks but I felt it was maybe too expensive for this task. Can you explain what's the difference with running backticks and yours? Thanks for the suggestion. 
Well `-&gt;request()` is listed as an internal routine and doesn't look like it is to be used for such purposes. If you enable debugging you can see what the problem is. perl -MReddit::Client -E '$Reddit::Client::DEBUG = 1; Reddit::Client-&gt;new(user_agent=&gt;"pls no")-&gt;get_comments(permalink =&gt; shift)' http://www.reddit.com/r/perl/comments/2pw2tt [2014-12-25 07:07:50] [ Retrieve comments for http://www.reddit.com/r/perl/comments/2pw2tt ] [2014-12-25 07:07:50] [ GET JSON ] [2014-12-25 07:07:50] [ GET request to http://www.reddit.com/http://www.reddit.com/r/perl/comments/2pw2tt.json ] malformed JSON string, neither array, object, number, string or atom, at character offset 0 (before "&lt;!doctype html&gt;&lt;html...") at Reddit/Client.pm line 183. In particular this line: GET request to http://www.reddit.com/http://www.reddit.com/r/perl/comments/2pw2tt.json So its expects you to pass `-&gt;get_comments(permalink =&gt; 'r/perl/comments/2pw2tt')` as it appends whatever you pass to it onto `http://www.reddit.com/`. 
Does CPAN track when a module is downloaded and show the author this? That would tell the author when it was last downloaded. If it's been a while, then the author might consider retiring the module, especially if the author knows it's been superceded by another module. 
You are sent from God, thanks a ton
&gt; After all these years of refusing to name a date.... Perhaps you meant to write "After all these years of blowing past the artificial 'perhaps this year, perhaps a year and a half' dates." Fibbing on Christmas Day seems like a no-no. See, for example, [Chris Nandor's eyewitness report from the day of the announcement](http://use.perl.org/use.perl.org/articled5d3.html?sid=00/07/19/161217), which gives a prerelease date of OSCON 2001 and final release in late 2001 or 2002. Cross-check that against [the LinuxToday summary of Chris's article](http://www.linuxtoday.com/developer/2000071901704OSSW). Pre-emptive rebuttal: "Sure, those gave rough dates, but *this time we're serious about 'sometime in 2015'". Back in 2000 they were serious about "sometime in 18 months, maybe 24". The "18 months" figure was repeated over and over and over again for the past decade and a half. &gt; It’s beginning to look a lot like Christmas. I know Ruby 2.2.0 doesn't have as many features as RakudoScript will supposedly one day have, but Ruby has a well-understood history of releasing working software on Christmas and it has one thing RakudoScript doesn't have: momentum.
I really hope we see a beta in 2015. That would be cool. 
&gt; what's **is** This may be the greatest truth.. What is.. indeed is, for if it is, it can't not be. &gt; that have **in** enough I see, you're emphasizing on the inner parts.. I strongly agree with you. I think we should prioritise everything with big urgency and make sure things get done, then review our backlog going forward. We should focus on long-term synergies in our assets, especially those that bring added value and increase our ROI(return on investment) so as to make a big impact on our bottom-line. We should have an out-of-the-box mindset but keep our feet on the ground while also having a 30,000-foot view of the big picture to increase participation and engagement into the core while also figuring out the rest. That said we need to invest in long-term and ultra-long-term strategies and leverage employees and people to get traction on products and make sure everyone knows what they need to do. About Perl.. same-old .. same-old.
actually, that means nothing.. increased speed ? .. what are you talking about ..
I said increased dev and release speed cycle, not program execution. And I was talking about this http://www.cpan.org/src/README.html You can notice that there's a yearly release plan of a stable version (with new tests, features (some may be experimental), deprecations and so on)
ups, it's obvious that english isn't my native language ... about your second paragraph..I'm not sure if you're sarcastic or serious about it :) indeed, same-old stories about perl :) 
This would be hard to interpret since at least the CPANTesters network is continually testing the CPAN as do many authors of toolchain modules.
guess i need some help in formatting text on reddit too.
Hint: indent by four columns, or use backticks: \`\`
I pretty much followed this example from the beginning. http://search.cpan.org/~rgiersig/Expect-1.15/Expect.pod The newest version is 1.32 -- check that the examples you are working from haven't changed, and there aren't relevant bug fixes that happened in the meantime. https://metacpan.org/release/Expect
I don't think people are going to make too much effort here if you can't be bothered to fix it.
I strongly suggest https://metacpan.org/pod/Net::Telnet 
Agreed. Why are you reinventing the wheel? Someone else spent a ridiculous amount of time making this work, and it's more recyclable. Don't fall prey to the [classic XY problem](http://my wiki.wooledge.org/XyProblem). Besides if one small behavior changes with your code, you are screwed and you have to rewrite it.
Semi-related: I just today thought about how badly named the XY problem is. Something like the "wrong solution problem" or "inside the box problem" would immediately tell me what I am doing wrong. But the "XY problem"? What is that? Are my equations wrong?
I totally agree, the name is really bad and basically forces people to look it up. However it's a thing, so I referenced it. The concept is useful, but the name is bad. 
unit tests could/should be written for this so expectations can be codified and things. I'm not sure if this would be considered a bug for say in windows. The problem might be that it would break peoples expectations to change it. Windows has always been weird about text output since most people run perl under cygwin which gives enough of a terminal emulator that you can get by with some UNIX things. It seems like say outputting CRLF should be something you should be able to override on a per-program basis with a pragma or something. If you're the original author, try it again with print "$var\n" or print "$var\n\r", just to make sure it's not completely broken. Then.. wait for people who actually know what they're talking about. :) 
Definitely got hired thanks to Perl and #8 :D
Acme::Bleach::Community Next! 
A previous thread on this: http://www.reddit.com/r/perl/comments/2ofixz/31_chaos_communication_congress_the_perl_jam/
I will repeat here what I put on my twitter. "Coding in a language you clearly don't understand is hazardous. Complaining about it makes you look like an idiot." This talk is clearly a straw man, in that, he actually builds a straw man! His slides build to a punchline by putting up an example and stating what he "expects" it to do. Then when it does something clearly different, the audience sees strange behavior. What they may not understand is that he has ABSOLUTELY NO REASON to expect what he says he expects. In truth he seems to expect results based on a comparison to Python (he even calls hashes dictionaries), and a question at the end calls him on exactly that. Hack talk, offered by a hack presenter. Sure it shows a few bits of admittedly bad bugs in some popular software, but the flaws lie there and not in the language. That said, Mojolicious and I believe other frameworks have now made changes, so that those who choose not to learn can continue to do so.
Wait, if we can't blame the programmers, who can we blame? That's like being an architect and having a bridge collapse under normal load and him claiming it's not his fault for design or choice of the material, but the material itself. 
Video available at http://streaming.media.ccc.de/relive/6243/
He insists on writing Perl code expecting it to work like Python does, and then complains about it. WAT.
If you got a nail gun and then immediately proceed to shoot yourself in the foot, it's not a "nail gun vulnerability". You're just an idiot. If you write this: my @arr = ('b'); do_smth('a', @arr); and expect it to be 'a', ['b'] in your following code for some reason, it's not a "list vulnerability", you're an idiot just like with a nail gun. 
I don't understand... Is the purpose of the talk for the speaker to make up arbitrary assumptions of what he'd like a language to do and then act surprised when something other than his arbitrary expectations occur? I'm pretty sure that given enough alcohol and a webcam I could concoct similarly arbitrary (and wholly incorrect) assumptions about *any* programming language and then curse a bit and act surprised that the result is something other than what I dreamed it should be. I'm sorry, I'm just not seeing the point of this talk as anything but a meaningless circlejerk for the presenter and the members of the audience. Is there something here we're supposed to be taking seriously?
Oh gods. I spent days pouring over the source of cgi.pm this year. Props for actually patching it. For $work I'm just trying to make it go away. 
thank you 
I personally liked the contradiction at the end, when during Q&amp;A he said `blame the implementer` when his talks entire point was `blame the language`. With a 20 year old module, that was considered stylistically bad Perl 20 years ago, as example. If we stop using all languages that have been misused by implementers in the last 20 years, and have a talk about every one of them, we need a special congress just for that.
I posted it on the BioPerl mailing list (and PDL, Quantified Onion too)! :-)
His talk exhibits many oversimplifications (blame the language instead of blame to module, and so on) as well es severe misunderstandings of basic language constructs. He made some good points wrt. CGI and DBI, but if you follow recent best practices you wouldn't be harmed by any of these.
HAH!
&gt; For $work I'm just trying to make it go away. Yep, same here. Many of us in the perl community are trying to do the same. Here's a lightning talk on the past/present/future of the module that i gave at APW earlier this year: https://www.youtube.com/watch?v=BBYag43ojjM (first talk)
&gt; Hack talk, offered by a hack presenter. Pretty much this, full of FUD, inaccuracies, and bad code. Legacy code has bugs, who knew? Perhaps we can put some of it down to the inexperience of youth as he mentions he was born in 1994. Thankfully there were a couple of perl programmers in the audience who pretty much deconstructed his arguments in the end Q&amp;A.
I think his point is `blame the implementer of the language`.
I think so, but that would require a certain amount of community effort to happen. More examples to be written, books to be announced, classes to be made. There's lots of exploration to do, and I think it should happen in public, and the Perl Mongers communities out there offer a natural place for this. What do you think?
Geez guys, cargo cult much? The near-equivalance between =&gt; and , is clever. So is using lists to construct hashes. But combined with list flattening, you've got something that violates the principle of least surprise. It's also the exact opposite what you want most of the time when you're constructing a hash. And given that perl doesn't have a hash context, there's no way for a function to figure out how it's being used and do The Right Thing. (I imagine this is why some people say that wantarray() is bad/useless.) For a scripting language that tries harder than most to help you write correct code (strict vars, for example), this behavior is very unfortunate.
Not with that awful design of perl6.org. The thing spells outdated '90s stuff. And then the [author's stance](http://perl6.org/about/) on the logo: &gt; Camelia as the logo for Perl 6 and perl6.org is not negotiable. The logo is a disaster. Perl is in the negative on marketing, it needs to come back out and then some to become popular again. Not saying it's impossible, but it needs real effort and someone with a vision.
[tb;dr](https://en.wikipedia.org/wiki/Betteridge's_law_of_headlines). If Perl 6 is reasonably stable, performant, and non-crashy in 2015, someone may use it to solve some problem of the day by 2020.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Betteridge's law of headlines**](https://en.wikipedia.org/wiki/Betteridge's%20law%20of%20headlines): [](#sfw) --- &gt;__Betteridge's law of headlines__ is an [adage](https://en.wikipedia.org/wiki/Adage) that states: "Any [headline](https://en.wikipedia.org/wiki/Headline) which ends in a [question mark](https://en.wikipedia.org/wiki/Question_mark) can be answered by the word *no*." It is named after Ian Betteridge, a British technology journalist, although the general concept is much older. The observation has also been called "__Davis' law__" or just the "__journalistic principle__". In the field of [particle physics](https://en.wikipedia.org/wiki/Particle_physics), the concept, referring to the titles of research papers, has been referred to as __Hinchliffe's Rule__ since before 1988. &gt; --- ^Interesting: [^Sensationalism](https://en.wikipedia.org/wiki/Sensationalism) ^| [^Rhetorical ^question](https://en.wikipedia.org/wiki/Rhetorical_question) ^| [^List ^of ^eponymous ^laws](https://en.wikipedia.org/wiki/List_of_eponymous_laws) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn9c94g) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn9c94g)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
2004 was the year of Perl 6, and it's over. Please rename it so we can get on with proper Perl.
no
Happy cake day. At every turn for as long as I can remember (since about 2004), perl-6 has had a laissay-fair attitude. "Let them come to us." If this is going to happen, it won't be because anyone in #perl6 says "We need to reach out to our most likely users", it'll be because someone outside of #perl6 gets something done.
As I followed Perl 6 (for years), my Perl 5 improved, and dramatically so. Then I learned several other languages, and my Perl 5 kept getting better. So while I can program in a lot of languages, Perl 5 is the one I use the most. And I will learn and use new languages, Perl 6 included. But there are a lot of languages which are (approximately) as powerful as Perl 6 is meant to be, so there's competition (much more than i ever expected). Every new language tends to be similar to one or two (or more) that came before. So in order to master even just one language, you have to learn a lot of them. Maybe a dozen. And it doesn't put Perl 5 in a bad light to know all sorts of very new languages -- quite the opposite, in fact (at least for me).
He made a comment on the other thread: http://www.reddit.com/r/perl/comments/2ofixz/31_chaos_communication_congress_the_perl_jam/cn9fdur
Thanks, jerk! Now I'll spend the rest of the year washing my eyes with bleach.
Even if I conceded the list expansion inside of a hash constructor is confusing (which I'm not sure I'm willing to do) the idea that you expect foo($scalar, @array) to be called as if @array were an array reference is just nonsense. Perl is pass-by-value and arrays are not objects. There is a fundamental and not-confusing part of the language. The fact that you showed those slides that claimed that that behavior was unexpected is the very definition of a straw man argument. I wasn't as offended by your tone (ok I was) as by your intentional lack of understanding of the language. The language behaves exactly as expected, not as YOU expected. Passing that off to the audience is cheap; done only for laughs.
Hmm, what is your critque of the logo? It might be too complex/colorful but I don't think it's much worse than the Android logo, for example. I don't think I've ever thought too much about a programming language's logo. The venerated camel is distinctive, but not captivating by any means. The onion is a little hokey. I can' think of what php's, java's, or c++'s are logos are like. Edit, actually, I like the logo now that I look at it. 
Are you a Perl 5 user? Assuming you are, is there anything about Perl 5 that "needs fixing," that isn't accomplished via whatever modules?
My whole lab switched to Python at work last year when the last library we wanted to use started working with Pyhon 3. I use Perl for a couple side projects, mostly small stuff with Mojolicious. I really wanted to see a MOP but most of the things wrong with Perl is that its losing popularity, so you see less modules for things like new web sites and services, less bindings to interesting APIs, etcetera.
The "Write Only Language" criticism is the hallmark of a complete novice who never even bothered to learn the language, and is instead relying on popular culture definitions of the language they heard from their equally ignorant peers. In practice, you'll find its not a write only language, some people just can't read it because they never learnt how. ( And thats true of any language, try reading haskell without learning how it works first ) In practice, I often find myself entirely ignoring the documentation and going straight to reading the source code, because it gives a better picture of what it does vs what it was intended to do. Uncommented source code at that. You may as well call Chinese languages "write only" languages simply because you're too ignorant to read it. But Chinese can read them just fine. 
As you clearly stated this was more of a PR stunt to get more attention. This matches with the things Frédéric Buclin complained about, so this is basically your companie's sales department who is behind this. I therefore want to say that I do not blame you personal for this poorly presentation. The Point is that this is not some local Event noone cares about, it's actualy an relatively big international Event. And for such an Event there was very little substantial things in the entire Lecture, in fact it was mostly a poor and rather unprofessional presentation, usind the f-word in every 2nd sentence is in my eyes a no go. If your company wants to be viewed as professionals you must act professional, sadly your company failed here.
I don't see any mention of a company in his video except for the DICE thing. Is that it?
So just to make sure I understand your stance on this correctly: If a C programmer modifies a pointer instead of the value that pointer references, that's the fault of C itself as a language for granting them the ability to make such a mistake in the first place? To take that point further, *anytime* a programmer botches the syntax of a statement through any accidental means or purely out of ignorance of the language, the programmer is not actually at fault for doing so and we should blame the language instead? That makes sense, I totally get it. I'm sure you'd also blame the chocolate manufacturer if you fed your dog a few pounds of the stuff and he keeled over dead, right? I mean, as long as you made the assumption that it should be safe to do, it most certainly *should* be, right? After all, your opinion of how something should work is far more important than bothering to learn how it actually works. Do yourself a favor, and any of the applicable community of buffoons lapping up any of your bullshit, and grow the fuck up.
Everything about your comment at the top I agree with. But your last statement is completely inappropriate and useless. "Grow up" is literally the least helpful advice you can ever give somebody, and its equivalent to "You do not do as I do, thus what you do is inferior, and I shall approximate it with you being a child to further diminish you instead of attempting to objectively correct the problem".
&gt; its equivalent to "You do not do as I do, thus what you do is inferior It actually has *nothing* to do with doing "as I do", what it has to do with is that he is making an argument in an extremely childish manner regarding a topic he has no actual understanding of (or, if he does, he is feigning ignorance for the sake of making it appear more substantial than it is). To be perfectly honest, I absolutely agree that there are aspects of his talk that have very real world relevance, and if approached correctly are things we should all be talking about. His approach along with his absolute unwillingness to see anything from any point of view other than his own personal dreamed-up assumptions, however, is in fact very childish (and demeans any value some of his otherwise worthwhile statements may have carried). A meme-ridden talk filled with ignorantly childish insults is just that: Childish. And in a professional forum such as this it pushes well beyond the barrier of being even slightly humorous and greatly detracts from the value of the content being presented.
http://www.sadtrombone.com/
Define: "extremely childish manner" If I say your style of argument is childish, I give you a criticism that is of no use to you. You have no recourse to correct yourself and give a better argument. If you can't extrapolate the exact behaviour that you perceive to be childish, and criticise on that, then you've failed at being a good critic. You may as well say "your argument is dumb" then give no further justification of how or why. And I say this because I've been told "Grow up" many times, and each and every time, I'm sitting there having no idea what I'm supposed to do, because If I'm doing the best I know how to, and its not good enough, a simple "You suck" won't educate me on how I need to improve. Thus, if I am to "grow up", I need specifics on how I can improve.
Who do we talk to about getting you more work to do during the day? Obviously you have a lot of spare time on your hands.
&gt; Define: "extremely childish manner" I think the presenter did a good enough job of that himself, here's a very quick subset of the slides presented: http://imgur.com/a/SNYVU This comes complete with comments such as the following: _"We know for a fact, lists are just fucked up."_ How constructive! A fact is it? _"We expect [...] because that's exactly what we've coded"_ Except that's *not at all* what the example in question has coded. _"Perl actually says fuck off, because [...]"_ &gt; If I say your style of argument is childish You present an identical opinion to my own, and yet criticize me for having done so? &gt; You may as well say "your argument is dumb" then give no further justification of how or why. I feel as though I've given plenty of justification. You clearly do not agree with me, and that is entirely your opinion, but my justification remains the same: A meme-filled pile of garbage that is full to the brim with ignorance and misuse of the language in question is a sad and childish argument against it. If the best the presenter can come up with is a slew of profanity and a small amount of purposefully poorly written code wrapped in a plethora of silly memes, he hasn't made much of an argument. My 4 year old could craft a more worthy debate. &gt; I say this because I've been told "Grow up" many times, and each and every time, I'm sitting there having no idea what I'm supposed to do You could always ask for clarification (as you've done here).
Well said.
People use such images for comic effect. Comic effect is not "childish". I think the attitude that you're really identifying here is *arrogance*, and arrogance combined with *ignorance* of his subject material. And by that I mean, the arguments you make for his "childish" remarks could be better put in context of "ill-informed". Because he makes remarks about something claiming they are bad, without fully realising the nature of what he discusses. Yes, children make that same mistake, but its because they have not gained awareness of the problem. In short, there are a *lot* of things children do, a *lot* of behaviours they exihibit, and a *lot* of logical mistakes they perform, and simply using "Childish" as a standin here is a a bit careless, because it belies the actual intent, It hides the actual criticism you intended to make with a more general one. The general criticism only serves you to get insult points. ( A thing he does no doubt, but no need to stoop to that level ). That is, Having seen his presentation, I would summarise it as "Guy who doesn't really know anything about Perl, comes to Perl, doesn't really learn it properly, gets confused about parts of the language, categorises the things he doesn't understand as security holes, grand stands like he's some prophet who has discovered security holes nobody has seen before". The reality here is, that he doesn't learn Perl, and doesn't even know how to distinguish between a list and an array, which is a typical novice mistake. Similarly, he'd probably fail to understand how Pointers in C work and then make a slide show about how C is shit and how "Whoops, I added an securirty bugs because I used the wrong symbol". Its completely wrong and completely ignorant, but using "Childish" as the insult here instead just gives an entirely useless criticism. Summary: Please refrain from "Appeal To Age" as a critical technique, when you can be much more effective using a more narrow spectrum criticism that the recipient has the hope of understanding.
FORTRAN never had a logo. Neither did BASIC, C, Pascal, Assembly, or any other serious language. Needing a logo is a sign there's something wrong with the very concept.
Rule #1: Larry is always right.
Sure, nobody technically needs a logo. But if you want to be relevant in the current world, having one is an advantage. People take a product more seriously when it has an identity. A logo is a part of brand identity.
1. Too many colors. Any logo must be reproducible in black and white. 1. It is too complex. A logo must be so simple that it can be reproduced with a pen in a matter of seconds by a person having no artistic skills. 1. It looks like a child's drawing. Especially the eyes and mouth. 1. A logo should have a meaning. Currently, I don't have any positive associations with a butterfly. Is it going to fly away from me? Do I need to chase it? It doesn't have a comforting connotation. Either way, a logo shall be designed by a professional. When a non-designer produces a logo, it's just like when a designer would produce Perl code ;) There is a [method to designing a good logo](https://www.youtube.com/watch?v=zOPA0NaeTBk). It's not just a random picture one thinks up. 
&gt; As a simple example go back to my slides and look at the CGI documentation screen shot. Why would I want to do that? CGI.pm is obsolete and has been for a decade. It's even been removed from perl5 core to discourage its use. You can equally point out that the original PHP 3 mysql() functions were kinda insecure, but trying to tar current PHP with the same brush would be rather unfair (much though I dislike PHP it's the more usual target for the sort of mindless bullshit hate you're spewing here so it makes a good example). Ancient codebases often use ancient practices that don't correlate particularly well with sanity, let alone security. &gt; Now, I'm not saying all of those leads to a vulnerability, but as you can see there's a very visible trend here. Yes. A trend of old projects using old practices and having accrued technical debt that doesn't get fixed because their users are more interested in new features and fixes for visible bugs than refactoring. This sucks, but it's exactly fuck all to do with perl. &gt; Perl was a great language back at the 90's and early 2000 - it doesn't now. No, all of these things were terrible back then, too. However, they've since been replaced with saner and more sensible APIs that the majority of projects started this millenium are using. Fuck it, rails has had vulnerabilities that are pretty similar to this one and nobody's claiming that's a reason why ruby has had its time and should be replaced. Your argument is incoherent, reflects a misunderstanding of the nature of technical debt and the constraints of project maintenance with limited developer time, and is just about valid as an attack on Perl-as-of-2001 but makes no sense as a complaint against Perl-as-of-2014. Criticising the projects for not having prioritised security work over user-facing features and bugfixes would be fair enough. Blaming the language for it is pure theatre, sound and fury, signifying nothing. Also, you can be funny without being a massive dick. I've found that gets easier as you get older, but it was still enough of an uphill struggle that I'd suggest it's well worth starting practising now (note that this can be done *without* "growing up", whatever Kthanid meant my that - exhibit A for this fact being me ;).
That's kd, my co-author for the Cat book. He also released Plack::App::FakeApache to help people trying to do the same :)
Additional comments on HN https://news.ycombinator.com/item?id=8819108
http://blog.kraih.com/post/43193421658/a-logo-for-perl
tl;dr Read [Camelia.txt](https://github.com/perl6/mu/blob/master/misc/camelia.txt) for Larry's overall perspective on Camelia. &gt; Any logo must be reproducible in black and white. https://farm8.staticflickr.com/7518/15967316925_24cae4854a.jpg As per the doc linked above, the Perl 6 Language mascot was designed from the start with various requirements in mind. There being appropriate variants was one of them. &gt; A logo must be so simple that it can be reproduced with a pen in a matter of seconds by a person having no artistic skills. »ö« This is Larry's Unicode / textual version of Camelia. Typing her in this form is pretty simple. Drawing her is perhaps slightly harder than drawing a smiley face. &gt; It looks like a child's drawing. Especially the eyes and mouth. That's exactly what Larry was aiming for. Especially the eyes and mouth. Also, quoting Larry again: "Camelia is intentionally very slightly, er, wall-eyed..." "the bugout eyes and asymmetric smile were added to get away from ☻". &gt; A logo should have a meaning. Currently, I don't have any positive associations with a butterfly. Is it going to fly away from me? Do I need to chase it? It doesn't have a comforting connotation. Do you have positive associations with Tux (the Linux mascot)? 4 of the 5 folk I just asked said they had positive associations with both penguins and butterflies. I'd make a sixth. But this is all anecdata. [The wikipedia page on butterflies](http://en.wikipedia.org/wiki/Butterfly) lists some characteristics of butterflies and the symbolism of butterflies in culture. I'll note: * Polymorphism * Mimicry * rebirth after being inside a cocoon for a period of time * good luck
Nope, pretty sure he was just being sarcastic.
I see people are alluding to how this broken pattern is "legacy" and things have been done and are being done to prevent the next vulnerability of this kind - can anyone please explain a bit more about that? I don't know much about Perl and this mini-debacle caught my interest. If there's a deceptively simple, but wrong, intuition that you can rely on and then your code outputs a horrible vulnerability, by Murphy's law a programmer with this exact intuition will come along every once in a while and (re)produce the vulnerability. Fix dbi-&gt;quote and the next dbi-&gt;quote will come along eventually. Without getting into the question of whose fault it's going to be when that happens, what's being done / been done to stop it? To be completely honest I'm sad to see how all of this went down. It's legitimate to say "hey this system responds to a reasonable-at-first-glance approach by producing code that fails catastrophically; what does this mean, what can we do, how do we stop people from doing the reasonable-at-first-glance-but-catastrophic thing". It's legitimate to say "hey the implementor shoulders plenty of the blame", it's legitimate to say "hey the system that enabled this shoulders plenty of the blame", it's legitimate to debate the veracity of any of those statements. Somehow it ended up devolving into Yet Another Holy War. It's in the nature of those things to, but, still.
&gt; There is; it's "I assume that only the simplest, safest case of user input will ever enter this code path". No language can protect you from that. Are the people responsible for DBI really that obtuse? I want to give them more credit than that. If even *they* weren't sufficiently in touch with the Tao of Perl to be aware of this language feature and/or its implications, what can we expect from Joe programmer? (Or are you saying that the quote function is in fact OK, and people were just using it wrong? I'm not 100% clear on this point). From what I gather so far, this whole thing strikes me as analogous to the strcpy et al. debacle in C. It goes beyond "idiot programmer naively makes assumptions about input"; apparently, and correct me if I'm wrong, programmers were simply *ignorant* of some types of possible input, and the way their code is going to react when it comes across them. It's probably not constructive to say "Well fuck Perl" like it's not constructive to say "Well fuck C". I also think it's not very constructive to say "well fuck Bugzilla". Elsewhere in the thread people are quipping "If you're programming in C and you don't know how pointers can screw you over it's not C's fault" - fair enough, but consider that this knowledge has become deeply ingrained in the C culture, and a lot of effort has been expended to make sure that Joe programmer will be aware of what not to do with a strcpy. People learn C along with "hey careful with the memory management", it comes with the territory. Judging by what's going on here, the same doesn't seem to hold true for Perl and these implicit conversions it seems to be fond of. In case this is really how it is, I think a lot could be gained from raising the bar of awareness regarding these language features. ("If you're going to program in Perl, at least know your language features", says Netanel, and I really don't imagine that anyone is going to argue with *that*). 
&gt; Or are you saying that the quote function is in fact OK, and people were just using it wrong? Yes, that's what I'm saying. &gt; programmers were simply *ignorant* of some types of possible input, and the way their code is going to react when it comes across them. Exactly. You can't write secure code that way. Languages and libraries can only give you tools which *encourage* you to write secure code, but it's up to you to do so. Once, I saw code which wrote to and read from files line by line instead of using arrays because the programmer either didn't know arrays existed or didn't trust using them. There's only so much a programming language designer or library developer can do. &gt; I think a lot could be gained from raising the bar of awareness regarding these language features. This behavior of Perl has been documented for as long as I can remember. (1998? Probably earlier than that.) This specific example--not Bugzilla but similar web code--has been discussed on PerlMonks since 2005, if not earlier. I even wrote a specific example based on this error in one of the editions of the [Modern Perl](http://modernperlbooks.com/books/modern_perl_2014) book which has been online and available for free for the past few years. There's only so much education people can do.
&gt;Yes, that's what I'm saying. In his talk, Netanel seems to claim that it's a function for input sanitization that, for certain clever values of input, fails to sanitize anything. Is that true? If so, I can certainly see a problem there.
&gt; In his talk, Netanel seems to claim that it's a function for input sanitization that, for certain clever values of input, fails to sanitize anything. Is that true? No, in his example he uses the list context version of the CGI-&gt;param method to inject a second argument into the DBI-&gt;quote method to tell that quote method the thing it is quoting is an integer (when it's not). So the return value is not what he expects it should be. As chromatic says, he is passing untrusted user input directly to trusted code. Had he done even this simple validation there would be no problem: my @users = $cgi-&gt;param( 'users' ); foreach my $user ( @users ) { .... $dbi-&gt;quote( $user ); } Besides, the DBI quote method is not really meant to sanitize input for queries, for that you should use prepared statements with bind variables and placeholders; this is explicitly stated in the documentation for the module going back at least 15 years if not longer. The documentation even has the caveat "Quote will probably not be able to deal with all possible input". But guess what? People *have* passed untrusted user input directly to trusted code, or they didn't know that having CGI-&gt;param inside a hash construction or a method call would result in CGI-&gt;param being called in list context. These bugs exist in code going back years, they have lurked there for a long time. Netanel exposed them, which was great, but he's done it in a very immature way. The irony is that in 10, 15, 20 years time Netanel will look back at this talk and probably cringe at just how bad it is.
I see. Thanks for going through all the effort to reply to me.
&gt; So this "list context" means that if an attacker has control of a certain function parameter, they automatically gain control of all the following parameters unless specific boilerplate measures are taken to prevent this? Mostly yes. The important part of the vulnerability is that the attacker only needs control of the query string. You see this in other languages and frameworks, too. Ruby on Rails has mass attribute assignment warnings for very similar reasons (and, to be fair, Rails and ActiveRecord have a much worse security problem here without that warning).
&gt; And given that perl doesn't have a hash context Sure it does - it's list context, because in Perl, a hash is just an even-numbered list of elements that allows for random access. Plus, there's the built-in `scalar()` function for explicitly forcing scalar context in expressions where scalar context is not already forced (for example arithmetic operators, the `?:` conditional, etc).
I use scalar reverse and a substitution regex to format large numbers with comma separators (among other similar uses) without using a loop.
p84-85 of Perl Cookbook 2nd edition sub commify { my $text = reverse $_[0]; $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)$1,/g; return scalar reverse $text; } edit: and of course if reverse $something eq $something we have a palindrome.
Thanks for posting this; the same technique is useful to do any right-to-left processing on a string. Despite the fact that you can also use lookahead to do this without requiring reverse I seem to remember that I benchmarked it and this method was still faster. That was a long time ago though.
I like Amelia (sri's butterfly). Given the strength of your approval of Amelia, I find it notable that she doesn't do well when considering [your own critique of Camelia](http://www.reddit.com/r/perl/comments/2qsrvg/is_2015_going_to_be_the_year_of_perl_6/cnabb0g): &gt; Too many colors. sri's Amelia has 5 colors, the same number as Camelia. (Is it still too many?) &gt; Any logo must be reproducible in black and white. [Camelia's black and white version](https://farm8.staticflickr.com/7518/15967316925_24cae4854a.jpg) works well. In contrast the Amelia design won't work well if it's naively translated to black and white. &gt; It is too complex. A logo must be so simple that it can be reproduced with a pen in a matter of seconds by a person having no artistic skills. Amelia's complexity is reduced somewhat compared to the graphical Camelia's. Even so, it's pretty clear to me that doodles of Amelia without the '6' will look like a generic butterfly; that if the '6' is included by someone with no artistic skills the overall doodle will often look crap; that versions by various non artists will look noticeably stylistically inconsistent; and that fixing these issues will require increasing Amelia's complexity, I suspect to about the level of Camelia's. (In contrast, doodles of »ö« will typically come out cute, instantly recognizable and reasonably consistent even if some doodlers have no artistic skills.) &gt; It looks like a child's drawing. Especially the eyes and mouth. Amelia shows no eyes or mouth. She eschews personality. That sort of design won't ever be friendly in the way, say, Tux is. &gt; A logo should have a meaning. Currently, I don't have any positive associations with a butterfly. Is it going to fly away from me? Do I need to chase it? It doesn't have a comforting connotation. sri's Amelia is also a butterfly. &gt; Either way, a logo shall be designed by a professional. Are you suggesting that sri is a "professional" in a way that Larry isn't? Fwiw Larry wrote, in the context of discussion of Camelia, that he considers himself to be a "professional designer". I'm not sure if he's talking about art design but I do know [Larry's family has the raw art talent](http://www.wall.org/~geneva/). &gt; It's not just a random picture one thinks up. I won't level that insult at sri, but I do suspect that sri's more "realistic" butterfly design was one of the first he thought to try, which seems a far cry from the years Larry says he spent mulling what he would like to see in Perl 6 culture and what sort of mascot and style would work best.
Excuse me mr_chromatic, but where does the name RakudoScript come from? I think I only saw you using it.
Once, I encountered this code, to strip the first char off a string: $_ = "foobar"; reverse chop reverse; 
I'm confused. Sunk cost fallacy is about decision making. If I was claiming that some sunk cost, eg Larry's years of mulling, should be a primary determining factor in some decision about what to do going forward, eg sticking with Camelia, then sure, that'd be sunk cost fallacy. But I wasn't. I was just juxtaposing moltar's characterization of Camelia as "a random picture" with Larry's claim he spent years on it. You sometimes mention your past contributions to Perl 6 and Parrot. You aren't committing a sunk cost fallacy merely by mentioning those sunk costs.
&gt; @days = ('sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'); &gt; print "The last element in \@days array is: ", $days[$#days]; #prints saturday Why not just use $days[-1] ? Probably more efficient as then Perl doesn't have to get the value of $#days first.
&gt; Perl Special variables related to Sorting A good reason not to use $a and $b as "example" variables -- they're treated differently by "use strict".
I cringed because of that CCC talk.. I'm aware of the problem with param() sub in CGI, however author just bashed whole language because of bad programming in the module. very biased presentation.
My god that was truly awful! I had to stop watching half way in, just couldn't take it anymore. "Fuck wut fuck wut fuck wut", from a guy who clearly does not understand the language. Every time time he said "we expect" I wanted to yell at him that no, I *don't* expect that, because I actually know perl.
I watched whole thing and there is some justice in Q&amp;A.
I like the list separator $". It defaults to a space, so many of my scripts contain: $" = "\n"; Here's a good list: http://www.perlmonks.org/?node_id=353259
Not to mention that http://perldoc.perl.org/perlvar.html already exists and does a solid job of describing the vars. Also, `perldoc var`.
I lost my shit at around 6:40 (under the slide "Lists abused") where he demonstrated he hasn't any fucking idea about references, and how to store multidimensional structures. Clueless hipster douchebag.
Dereferencing mostly goes away and ; is used to specify dimension boundaries in literals in Perl6. But flattening is if anything even more insane with you having to know which stuff does and doesn't flatten. There [are planned changes](http://pmthium.com/2014/10/apw2014/) to *maybe* make it less insane.
`&lt;&gt;` is definitely *not* a special variable. It's not even a special operator, as the artiicle suggests. Instead, it is a special use case of the `&lt;`*filehandle*`&gt;` pair of operators, with the filehandle dropped. 
Yes. You can install activestate perl. Then install atom.io, sublime, or notepad++. CMD is still in windows 8, you have to go to run&gt;cmd. Also, install this in windows 8 to make it usable like windows 7: http://www.classicshell.net/ There just, put your path headers for activestate perl in your .pl file and code away. edit: also, you can install cgywin and minitty will give you a terminal and unix paths for your perl installation. But since you are asking this question, you might be intimidated by this.
Out of curiosity, what is your end goal? "Learning modern Perl development" would be very different from "I need to run some old CGI stuff locally for a few days."
I'm interested in learning perl. My end goals will largely deal with editing text in a file.
Alternatively, look into installing Linux using virtual box, and mounting a folder which is visible within the Linux container. You won't run into as many "Windowsisms" then.
&gt; I believe it's fair to describe you as a tireless defender of the P6 status quo. I want change! What status quo do you think I'm defending? &gt; You also mischaracterized moltar's argument, which said nothing about the amount of time spent moltar said "a random picture one thinks up". I think that's inconsistent with Larry's claim "I've been mulling over this particular issue for many years". YMMV. &gt; merely the unobvious connection to the subject. I don't think that that was all moltar was arguing. But let's say it was. I'd love to hear why you or moltar think a cute penguin has a more obvious connection to Linux than Camelia does to P6. Do you think Tux is just "a random picture"?
Console. Sounds wonderful. Thanks
Ok, I'll be honest: Windows is going to actively work against you for learning Perl and editing text. Your original problem hints at why: "I can't find a terminal for starters[...]" Windows isn't built as a development platform, and it shows. Anybody who likes developing on Windows has to install an additional dev environment: Visual Studio, Eclipse, Cygwin, Linux VM, etc. And then you're spending a lot of time learning your dev environment instead of Perl. (Not necessarily bad, but still) Once you have a way to write and run code, Windows' text handling will probably trip you up a fair bit. Windows uses UTF-16 to encode text, which is incompatible with the only sane encoding: UTF-8. You'll run into line ending issues, BOM issues, and file name encoding problems. Perl has excellent ways of dealing with all of these issues, but they still must be dealt with. If your end goal is to learn to program, you may as well bite the bullet and learn how to solve all those issues. (My recommended solution: install Linux or FreeBSD) If you really just want to edit text programmatically, install Vim or Emacs and learn that. (I prefer Vim, but Emacs will let you use a real programming language) If you learn either editor well, then you're over halfway to a solid dev environment anyhow. Final bit of advice: Google is your friend.
Thank you.
A potential alternative is sshing into a different machine and doing the actual testing on that machine, that machine using an OS where Perl is ubiquitous 
I kind of like this idea.
Why did this get downvoted?
This "show" turned actually bad for his reputation. Everyone who is able to understand his strawman clearly sees what idiot he is.
I think we're 99% in agreement (I've heard good things about Strawberry Perl), but that 1% is a very painful 1%. For example, let's say OP gets Perl up and running on Windows, no problem. OP writes some scripts, they run great, etc. A few months later, OP is tired of hearing about Linux and just installs it. Oh, look, there's Perl, preinstalled--awesome! OP whips up some scripts, they run great (just gotta remember to add shebang and do the chmod thing); it's time to break out the classics. Chmod those files and...error. Oops, add the shebang, and...error. OP remembers reading about UTF-16, and sure enough, those old scripts aren't UTF-8. No problem: little bit of iconv, and...error. Crap. Everything should be working, but it's not: there's just a cryptic error. And new scripts run fine. OP is super frustrated, hours have been wasted Googling things--none of this was a problem before--time to uninstall Linux. This hypothetical is brought to you by the Byte Order Marker, which needs to be removed so that exec can see the shebang properly. Forum post with this exact problem: http://www.unix.com/shell-programming-and-scripting/249360-executing-perl-script-linux-gives-exec-format-error-wrong-architecture.html Text on Windows causes problems, full stop.
This is probably good advice, but windows can still be a sane development environment if you take some care. I use a UTF-8 compatible editor and I keep all my code in git. I have never hit the encoding issues mentioned above when switching between OSs. Lack of a decent terminal is a bigger issue, but for simple stuff git-bash (https://msysgit.github.io) is ok. 
Apparently this guy is just finding out about sql injection attacks. You have to parse your form input before you enter it into the database new guy. Dont use a random all purpose function to "fix it" and cry when it fails on specialized input, parse it by hand. Someone tries to put an array or special characters into a text box, catch it as a FORM ERROR, return an error message and let the user correct their input. Dont send it straight to the database. He also wants to pass a combination of arrays and scalars to a function. Combine it into one array first, or maybe play around with references. Tell the function the second parameter is a reference to an array and dereference it properly inside the function. I also suspect he doesnt really get the difference between a list and an array... But thats perls fault.
Apparently this guy is just finding out about sql injection attacks. You have to parse your form input before you enter it into the database new guy. Dont use a random all purpose function to "fix it" and cry when it fails on specialized input, parse it by hand. Someone tries to put an array or special characters into a text box, catch it as a FORM ERROR, return an error message and let the user correct their input. Dont send it straight to the database. He also wants to pass a combination of arrays and scalars to a function. Combine it into one array first, or maybe play around with references. Tell the function the second parameter is a reference to an array and dereference it properly inside the function. I also suspect he doesnt really get the difference between a list and an array... But thats perls fault.
Thanks, do you what it is about these technologies that you do or don't like? Just wondering because superficially the synopsis for Async looks a bit POEish to me
Thanks for sharing, was an interesting read
Nice. There are so many things like this; things that seem really simple on the surface and then end up being much more complex. A nice reminder that we all struggle with those sorts of things.
of course I'm a big fan of Mojo::IOLoop, especially in web contexts. If you need help learning delays I have a blog series starting here: http://blogs.perl.org/users/joel_berger/2013/10/writing-non-blocking-applications-with-mojolicious-part-1.html
The dude criticises the choice of cachegrind yet doesn't even seem to understand it's basic premise and mode of operation. Sigh. Alas, just another piece of Reini propaganda. 
The script can be found [here](https://github.com/Perl/perl5/blob/blead/Porting/bench.pl)
If that's a (very dead) deadpan joke then it deserves to be panned imo. :P Alternatively: * Closed Source: Owner of source code is informed or finds out that there's a bug. Then, when -- and only when -- the owner is ready and willing, the owner does something such as fixing it or informing select customers (beyond the original reporter if any) of the bug's existence. * Open Source model. Maintainer of source code is informed via a public issue tracker and then everyone else can immediately find out about the bug, and what others think about it and the relevant code, regardless of what the maintainer does. Then, when *anyone* creates and posts a bugfix, then *anyone* else can immediately test/use that bugfix, regardless of what the maintainer or anyone else does or doesn't do. In this particular case: * The bugfix was published in the same message as the bug report, so the bugfix was available immediately regardless of what the maintainer did or didn't do. This looks like a good example of a benefit of open source compared to closed. YMMV. * The maintainer responded by taking the time to make the right fundamental improvements (in his opinion) to the testing. And he did so *before* committing the *untested* bugfix to the master codebase. This sounds like good maintenance to me. YMMV.
I liked reading this, esp. because I learned about two modules I'll probably use in the future ([Web::Query](https://metacpan.org/pod/Web::Query), [Lingua::EN::Words2Nums](https://metacpan.org/pod/Lingua::EN::Words2Nums))
www::mechanize is good and easy if there is no java script required. What do you need to use automation for ?
I have found CPAN docs good enough to learn by trying to do what i wanted. Javascript sometimes can be reverse engineered, sometimes you can check what is being send in GET of AJAX call and send prepared data using Mechanize. I still use Mechanize for many websites as it is quick to code and works very fast for me with multithreading. For JS heavy websites i use [Zennoposter](http://www.zennolab.com/en/products/zennoposter/pid/aqq) (affiliate link). Very easy to navigate even most complex websites, you can use own C# code or make call to external script to load/parse content. I have tried various headless solutions, but prefer Mechanize or Zennposter as they are more easy to use with multithreading and proxies. 
But Perl 6 also will have context sensivity. A concept that has little advantage but lets explode the operator amount and offers many pitfalls.
You could try using `Time::Piece` to see if you have the same issues. It has a `strptime()` method. There is also http://metacpan.org/pod/Time::Moment http://blogs.perl.org/users/chansen/2014/08/timemoment-vs-datetime.html 
I would guess it wasn't designed with tens of thousands of instances as an expected use case
Less insane? ((1,2), 3, (4,5)).map({...}) # iterates over three elements map {...}, ((1,2),3,(4,5)) # iterates over five elements Do they want to replace Brainfuck?
Well, operator overloading is a kind of context sensitivity. Anyway, there are plenty of context-free languages. If you don't like contexts I think you'd pretty much be put off of Perl from the start.
But wait, there's more: &gt; method call invocants are *generally* not-flattened, while function call arguments are *more likely to be*. Emphasis mine.
IO::Async has a modern Object Oriented API ( unlike AnyEvent and POE ), and has really nice support for IPC via 'channels' ( sort of like in Go )
MJD, right? It's gotta be MJD. Yup, MJD! YAY MJD Incidentally, part of today was spent adding use experimental 'smartmatch'; to about 60 modules.
Good times. Loved the rant on SPF at the end. Unfortunately, gmail and other large providers are now enforcing it.
I actually did some preliminary work on a [lua library](http://paulbatchelor.github.io/portfolio/xmt_page.html) for XM file generation, but at it's core it is a C library. I've never made a Perl module before, but it may be possible. 
You can write spyware in Perl the same way you do in any other language.
Sort of. sudo su -
I might be way off base but I've simply been calling curl and using Chrome/Firefox developer mode to tease out the calls I need and save them as curl commands with their handy Save As Curl right-click option. I typically try to avoid non-standard modules since my scripts need to be able to run on systems I cannot install modules on.
&gt; I don’t know why this suggestion has been down voted. Agreed, seems like the best way
If they're running on your server or downloaded from there, use normal counters. But - if you "phone home" from them, most people will reject that. I certainly would - enough people spy on me already and I would also not like the extra overhead - not everyone has huge unmetered internet connections. Your reputation would go down and if hosted on some foss sites, this may be against their T&amp;Cs.
The target system always has a base perl install that came with the distro but the server is ultimately maintained by a vendor so I'm loath to install or modify anything at that level. Installing perl or curl on a PC requires navigating a fairly painful IT exception process. Fine for me but a bigger obstacle for those users for whom its targeted, let alone getting ppm or cpan configured to work with our proxy to install modules.
Awesome, thank you! I'll be looking for some noob tutorials.
report bugs to the right place: http://finance-quote.sourceforge.net/developer.html
Please make sure you "use strict;" and "use warnings;" and declare variables with "my %info" etc., and then post some test code and the full output. P.S. If there is some verbose debugging available, please enable it.
 #!/usr/bin/perl use strict; use warnings; my $txt = qq{ paragraph 1 paragraph 1 paragraph 1 paragraph 1 paragraph 1 }; my $int = 1; $txt =~ s/\d+/$int++/eg; print $txt; Do it all in one regex. Slurp it in. What you have is doing the same thing to each line - ie resetting $ii before starting each line. 
&gt; perl -pi -e 's/\d+/++$ii/e;' file2 Ah, thank you!
If you want to do it the way you were trying to originally, use a `BEGIN` block: perl -pi -e 'BEGIN { $foo = 42 } s/.../$foo++/e' input.txt 
+1 for briandfoy's points. I'm a Java developer, but just this past week I had to prepare several PDF's for a Hadoop processing. Quickly fired my IDE, and started writing some Perl code. In the end I'm being paid to work on Perl, and can have fun with Perl, Java, Python and even R. BTW: share your Perl script for the manga site if you find it useful. There's one in my read-list that I'd like to scrap and load into my android.
Back when I had to work in IDL, I used to write code generators in Perl...
The whole expression inside the `-e` argument gets wrapped in the while block. so your assignment gets executed every line. You can either use /u/Rhomboid's suggestion or just use `undef` as a start value: perl -i -pe's/\d+/++$i/e' &lt;file2 
I am also a Perl addict with a non-cs degree. I took my first programming job in Python and used time and experience to land a Perl job. All programming experience is good experience. Like brian says, use/learn Perl when you can, learn what you are paid for too. Contribute to open source too, you'll learn and get your name out there too. When the right Perl job comes along, you can snap it up! (Be sure to learn good testing and source control practices too, all jobs will (should!) want that).
Booking.com is paying for relocation to Amsterdam and even Perl training....
Do you know whether people that join Booking are generally happy working there?
If you're really interested and willing to learn you can get by even without a CS degree. Also try to work on your projects: if you like web stuff do a MVC web app with one of the perl modern frameworks, write tests for it, also work on the html/css/js part and put it on github If you like sys admin stuff, again find a project work on it and as Joel said get your name out there With enough work will end up with a perl job
From what I've heard they are not. Booking.com is all copy and paste and never refactor. But this is third hand information, I've never worked there. 
My understanding is that this is true for a lot of old code, which is bound to happen in any company with their history. Keep in mind, these guys were around since *1996*! Dude, that's almost 20 years! Can't speak for Booking. But I worked at another large company with an old code base. Yes, a lot of the code was ugly. But there was a definite push towards "good practices" for everything new. But this is something you have to deal with if you want to work in large companies like this. Unfortunately, this is going to be the case probably with any language and in almost any company with code base of this magnitude.
I have first hand information (joint attendance at various hackathons and conferences) that smueller and nperez are generally happy. I know a couple more people working there, but don't know about their feelings.
"Perl 6 introduces grapheme-by-default"--you mean, the current unfinished specification puts out the hope that an as-yet-unreleased perl-6 will eventually have "grapheme-by-default." This in a thread called "facing reality." How are those last three great rewrites going?
Keep in mind that people generally complain more loudly than they praise. Also, if you read their [tech blog](http://blog.booking.com/), you'll see that at least some of them are working on interesting new code.
I only have an associate's. I have been working in Perl for over 7 years now. There are plenty of Perl jobs, in fact most Perl places I know have a hard time finding enough people. Location of course can play a role.. But many places are desperate enough for Perl people that they will do remote. 
Maaan... I wrote a Perl book that got pretty good reviews, used Perl to get the first server based video slots/video poker system through the Las Vegas Gaming Labs under their new rules (crazy intense testing and code auditing; server based games allow dynamic updates; saves tons of money on getting new games through the labs) while working for a startup. That was Perl. Three large, extremely well funded companies tried for years and failed to accomplish that. Trade shows taking up half of the Vegas conference center had giant banners hanging from the ceiling that read "SERVER BASED GAMING IS COMING". And a ton of other things. I worked on large US .gov sites, including working on the sortware that powered america.gov. I tried for six months and failed to get a job in Tempe, AZ (in the US). I kindly had an offer if I relocated to Texas and kindly had a lead on telecommute work, but for six months, I had no bites locally or on advertised telecommute gigs (both extremely attractive except another project wound up going and now I'm riding that out). I applied for places sysadminning Apache boxes; I've traced Apache bugs with gdb to diagnose them and backported Linux security fixes, and they wouldn't talk to me. I started taking classes to finish my CS degree and got my Oracle Java certification, and suddenly started hearing from recruiting firms. I put it on my resume and it got vacuumed up by the GOOG and now jobs come to me. (Working on a Kickstarter project now; not sure if I'll just do Java or finish my degree or a bit of both afterwards.) Perl is not marketable. As long as Perl is phased out of places and not used for new projects, the market is shrinking, and if the market is shrinking, then you're facing stiff competition for any and every job posted. If you like Perl, I'd definitely learn something else than PHP. There are a ton of really cool languages that are well designed by smart people that let programmers go crazy in fun ways. Go, Scala, ... too many to list. JavaScript and lots of other popular things are fun languages. And there's something to be said for mastering the un-fun language (whatever it happens to be; used to be COBOL or FORTRAN depending what you were doing; then VB and maybe some other things; now Java and C#) and doing fun stuff on the side. If you're a super hacker like Bunnie or my hero Samy, and you're doing "research", no one questions your choice of tools. If anything, you're setting the trend. Otherwise, you're at the mercy of the ebb and the tide. No language when it starts is hired for. As a sort of terrible accident, I created a programming language once. My boss named it for me: The WebWanker. I had to munge a bunch of HTML, and all of the machines were Windows, and I hadn't yet installed Cywin (then the preferred way to get bash and perl and such on your Windows machine). I was just ftp'ing stuff up to my uni account and using it. Eventually we figured out that I really couldn't do that, and I couldn't put cygwin on the official machines, and we needed to automate it, so I translated the bash script to C, in a configurable way, and the WebWanker was born. It wound up being programmable in an assembly-like string processing language. That's how new things start... except without being so wretchedly awful. And that's how Perl started. Someone wrote something, used it at work, and then shared it, and then other people used it at the jobs they already have. And Perl how now been demoted to that status. So, my advice: Keep learning things. Learn more Perl. Try out some other languages that try to adopt bits of the ideology (expressive, powerful, hackish, introspective, etc) and see if you like them and if so, learn them. Learn completely different languages like OCaml and JavaScript. Know a bit of a bunch of things. Learn some employable things, too. And take Perl off your resume. No one will take you serious as a Java programmer or anything else if you have Perl on there. You have to sneak it in. Or at least that's my experience. By the way, this is nothing new. This has been coming for a long time. I was, at one point, blessed with front page listing on Google for "computer programmer resume" and some similar things. At one point, I put a survey on there ask why I'm not being considered for the job, and put a bunch of things on there, re-adding "Other" as people filled in an other. "Dislike Perl" overwhelmingly won. There's a lot of really badly written Perl in the world, and people hate Perl for it. Part of it is people who didn't know Perl who learned Perl overnight in the dot com boom to make some quick money, and part of it is people who should know better who willingly accepted instructions to skip refactoring code in favor of short term gains. Having "Perl" on your resume at this point in time amounts to saying "I don't believe in refactoring or maintainable code". I know things have changed a lot, at least for a certain conference-going, online-chatting sub-section of Perl programmers, but it's the impression that Perl programmers as a whole have left. Your English is fine. I always cringe a little when I see people write good English then apologize for it. It's good to know that English isn't your first language but if you have to apologize, maybe write "I'm sorry you fat, lazy, stupid Americans that my fifth language isn't as good as your only language; and you Brits can go suck an egg". Or else just add the insults in your native tongue.
Very instructive, thank you.
&gt; Personally, I export the POD of the main module Yeah I do this too (using Dist Zilla). FWIW there was a new module to do this released last month by xdg [Dist::Zilla::Plugin::Pod2Readme](https://metacpan.org/pod/Dist::Zilla::Plugin::Pod2Readme)
That's true Booking.com will pay for your relocation. Also if things go right you will be part of the 30% ruling wich means that you will be having a nice tax cut. If you can assist to a major Perl event or workshop chances are that you will meeting some booking.com devs. We are also recruiting at non Perl events like web conferences and even android events.
I work at Booking.com, and happily so. If anyone has any questions about working at the company, you're welcome to contact me.
&gt; the answer is to write careful documentation showing the user what they can install and why? Yes. If you want to put more code on my machine, explain what it does.
Just a nitpick, technically you don't need Module::Load for that. you can do `eval "use Foo::Bar"` or something like `eval { require "Foo/Bar.pm"; Foo::Bar-&gt;import }` but that requires more typing. The main point of Module::Load is that you can do path-style require: `load "Foo/Bar.pm"` or package-style: `load "Foo::Bar"` using a single interface. It "fixes" the use vs require difference (a perl quirk, so to speak). 
Um, I just used it because of the GUI ppm mananger. Anyway, went back to Strawberry.
Wait... what?
Do you know any Perl? Have you attempted anything yet?
Do it incrementally. FIrst, get one example of the command working, where the host, user and pass are hard-coded. Then step 2, convert the host to a variable, and iterate through all the hosts. Then step 3, do the same for the user-pass. If you post your incremental attempts, no matter how bad, people will help you.
Thanks but I only want to list sites where people can contribute to the source code or at least learn from it.
That's pretty useful I think.
If you are in the experimental stage, the results may not need to be 100% realistic. Fake it until you make it.
Most likely it can do this to reuse part of the tokenizer. From toke.c: case KEY_AUTOLOAD: case KEY_DESTROY: case KEY_BEGIN: case KEY_UNITCHECK: case KEY_CHECK: case KEY_INIT: case KEY_END: if (PL_expect == XSTATE) { s = PL_bufptr; goto really_sub; } goto just_a_word;
Nvm, didn't notice that is a 0.14 branch I should be working off, I'll get back to you in a bit I can provide you an archive you can install with cpanm to try when I'm done?
The author has already made the endpoint changes (and several more) in their development branch [here](https://github.com/leedo/www-discogs/commits/0.14) You can try installing [this](http://uploads.peter-r.co.uk/misc/WWW-Discogs-0.14-devel.tar.gz), built from the latest stuff, and see if it's any better
Thanks this seems reasonable. I wonder if anyone will have another answer. If this is why it seems like me may want to edit the documentation to not even mention it is possible. 
I think it needs to stay unless officially deprecated. If someone comes across weird code doing it we need the documentation to tell them why it works.
Cool idea!
I tried installing version 0.14 on Windows using Strawberry Perl 5.16.4. The test suite fails. It looks unfinished. 
Thanks for testing, yeah the test suite probably would fail given the state of it
I have a little python. Beautifulsoup should do the trick, tho. Thanks!
&gt; Ah, you're on windows with Active Perl then? Yeah, I'm not to familiar with that setup Yes. I could potentially access a Linux machine if need be though, it could be done. &gt; Have you got any scripts using the functionality of the module you want so I can try testing them? I tried but Reddit won't let me post the script!
[script](http://sprunge.us/fObR), [output](http://sprunge.us/PgVK)
Just thought I would add that the [Redirector](https://addons.mozilla.org/en-US/firefox/addon/redirector/) plugin is good for this on Firefox
Where do the Discogs IDs come from originally?
Additionally, I think I've spotted a bug in your script. When it gets the URI for a primary image it essentially only tries the last one, whereas when it tries the secondariness it will stop as soon as it gets any one
I'm not sure if I understand your question properly. I have spreadsheets of discogs IDs I need to look up the genre / style data for on a regular basis, that's why I asked someone to adapt their script for me. What usually happens is I have a spreadsheet on my PC, I run the script using the spreadsheet as an input file, and it spits out a new file with the data appended in an additional column.
Any whole number from 1 to - I think - something like 4000000. Each release that is added to the database gets a successive number, so the first one is 1, the second one is 2, the third one is 3, and so on. So, for example, http://www.discogs.com/release/64 is the 64th release to be added to the database. You can see the genre / style data I am trying to 'mine' through the API, in this case it is Genre: Electronic Style: Deep House 
The two hardest problems in computer science: - Naming things - Cache invalidation - Off-by-one errors
Ah thanks, that's all I need. I'm willing to have a look at reviving this module, especially if there's the possibility of a donation at the end of it (any amount)
Just run pwgen 5 1 till you find something you like.
Hydra is taken. Depending on how your project functions, I'd try to stick to file type based puns. Example: Perl based web retrieval (like wget) could be called grap.pl
I'd say check out http://shadow.cat/blog/matt-s-trout/mstpan-8/ for a decent writeup of the differences, he gives a better summary than I could.. In short, IO::Async looks/feels like a modern library. It has Golang like channels, it uses Futures, and works very nicely with Moo or Moose.
I believe if $string contains regex expression characters, you're going to get unexpected results. You can use quotemeta to make sure string is a literal. Also /g isn't necessary for a match, doesn't make sense. Last, you can use index like this: index(uc $content, uc $string) but I'm not sure if it's faster or not with the uppercase call.
Thanks, going the safer index route. 
It means 'match'. This string matches that pattern.
=~ is Perl's regexp operator
That is far better then php preg_match. Nice!
Thanks! Love reddit.
Vulture
I heard that there was a problem with one of the main machines involved. Apparently databases need to be rebuilt and all that stuff. Been down a few days. The correct people are aware and working on it.
Thanks for the link. But I have to say that I'm not much the wiser after reading it. Matt S. Trout has obviously preferences of his own, but he doesn't explain them in detail. *Kinda weird API* is not a very useful argument. And why did he have to single out the author of `AnyEvent` and `JSON::XS` ("refuses to collaborate ...") ? I'm in no way affiliated with [Marc Lehmann](https://metacpan.org/author/MLEHMANN), nor am I aware about the way he handles his projects, but such things always put me off. Reminds me of the witch hunt with `Class::DBI` a couple of years ago. Do we, the Perl community, really need to do this?
The content is not all well formed on that page, e.g. it's not always `"word" (definition)` ... some examples. "vorübergehen"" (to go by); "auspressen" or "ausquetschen" (to press or squeeze out); "entlanggehen", "entlanglaufen" (to go/walk along) hinarbeiten" (to work towards); ~~The following doesn't handle all the edge-cases, but it may serve useful as an example.~~ **EDIT** Updated to handle all the edge-cases. use strict; use warnings; use feature 'say'; use Mojo::UserAgent; binmode 'STDOUT', ':utf8'; my $url = 'http://www.dartmouth.edu/~german/Grammatik/Wortbildung/Separables.html'; my $ua = Mojo::UserAgent-&gt;new; $ua-&gt;get($url)-&gt;res-&gt;dom-&gt;find('div#main dd')-&gt;each(sub { my $content = $_-&gt;all_text; $content =~ s/""/"/g; $content =~ s/^(?=[^"])/"/; while ($content =~ /"(.+?)"? \(\s*(.+?)\s*\)/g) { my ($word, $description) = ($1, $2); $description =~ s/"//; if ($word =~ /"/) { say "$_: $description" for $word =~ /([^"]+)"(?:,| or) "([^"]+)/g } else { say "$word: $description" } } })
http://en.wikipedia.org/wiki/Perl_control_structures
That's what [`feature`](http://p3rl.org/Module::Build::API#auto_features) in build tools is for. The default feature selection for unattended installations should be sensible, the questions about feature selection terse, and details for when installing a feature is useful should be in the documentation.
Another notable hardware module that landed in 2014 is http://search.cpan.org/~vikas/Device-SaleaeLogic-0.02/lib/Device/SaleaeLogic.pm.
Not to try to discredit your work but this doesn't handle the edge cases mentioned in my post below, and thus misses a few words. ausquetschen: to press or squeeze out dabeistehen: to sit/stand there; to stick with durchschlüpfen: to slip through entlanglaufen: to go/walk along herabmindern: to reduce; to disparage hineinwollen: to want to go in hinarbeiten: to work towards hraufbeschwöre: to cause; to bring about; to evoke There is also a trailing right paren in some of the definitions. (But those are trivial to remove.) Thanks for posting.
Hey if you're still having issues with the matching, throw the code and example files in a pastebin and we can take a look.
&gt; Thanks but I only want to list sites where people can contribute to the source code or at least learn from it. What about the "Second Tier" list? It looks like it contains closed-source websites based on open source projects? If so you *could* add [PerlTricks.com](http://perltricks.com/about) ...
Install 'Coy' and then: $ perl -MCoy -MNo::Such::Module ----- Eshun sits near Mount Fuji. Eleven leaping trouts. No goldfish swimming. ----- Mumon's commentary... Can't locate No/Such/Module.pm in @INC (you may need to install the No::Such::Module module) (@INC contains: /Users/username/perl5/perlbrew/perls/perl-5.20.1/lib/site_perl/5.20.1/darwin-2level /Users/username/perl5/perlbrew/perls/perl5.20.1/lib/site_perl/5.20.1 /Users/username/perl5/perlbrew/perls/perl-5.20.1/lib/5.20.1/darwin-2level /Users/username/perl5/perlbrew/perls/perl-5.20.1/lib/5.20.1 .) Even better: $ export PERL5OPT=-MCoy And enjoy it whenever your perl programs fail!
If you don't understand the module name, it helps to know what `Carp` does, and what you call a fancy Japanese carp. I don't think there's any explanation for the spelling, though.
I want to make a cCoy module so you run perl-McCoy -e error and it says Dammit Jim I'm Just Another Perl Hacker or something silly like that...
But I'm not making a search engine. I'm trying to do statistical samples of search results for different types of searches. I'm trying to test some different algorithms based on domain names and urls...
An additional example: Print the standard read/print-loop code that -p uses: $ perl -MO=Deparse -pe 0 LINE: while (defined($_ = &lt;ARGV&gt;)) { '???'; } continue { die "-p destination: $!\n" unless print $_; } -e syntax OK 
Thank you! Appreciated.
 package cCoy; BEGIN { print "Damnit, Jim, I'm a doctor not a programmer!\n"; exit; } Perl -McCoy &lt;anything&gt;
What do you mean by it gets stuck? Are you sure it isn't still running? Do any tests fail?
At this point the CPAN client doesn't 'move forward' at all. I've left it up for about an hour with no progress... plus, the progress its made doesn't look too successful. I don't know how to 'install' a module without using the CPAN client that comes with Strawberry Perl. I haven't tried installing it on my xubuntu side because I've been doing most of my perl work on the Win side.
I'm sorry if this sounds patronizing, but, did you install PhantomJS first? http://phantomjs.org/download.html
If you get to the point where you'd like to try force installing, open a prompt and try cpanm -f
I had forgotten to add it to my path... The CPAN install still isn't working.... It freezes at a similar spot with the error "selenium server did not return proper status" http://i.imgur.com/3TmdDeJ.png
Trying -f as I type. EDIT: Still getting this http://i.imgur.com/3TmdDeJ.png
Thank you for this, I agree with it entirely. So many naysayers have indeed hidden agendas, or just plain, childish jealousy. Thanks.
The author btw pointed me to this: http://www.reddit.com/r/programming/comments/2suklv/perl_already_won/ where he already posted it on /r/programming... sadly the comments are like slaughtering him :(
&gt; selenium server did not return proper status You can skip tests with `-n` I think but don't expect it to magically work. Chances are it will still fail when you use it somehow
Yes, thank you for writing this Perl do need good stories and brave of you to poste it on r/programming. Though I do not claim to ”love” Perl, I find it to be the most efficient and reliable tool in my toolbox by far ( unless it is statistics where R shines). Unfortunately the uninformed hating is real and telling the good “stories” from the real world is probably the only thing to do about that. 
&gt; The readiness of python types to launch into slap fights about scripting language preference has always seemed really weird to me. [This image](http://www.padhokhelo.com/wp-content/uploads/2014/04/perl-and-python-hackers-compared-300x220.png) pretty much reflects my experiences in this regard ....
&gt; ^(Why do you love Perl?) All the regular reasons, but really it's all about the variables. They're not encapsulated too much, so you can still wire shit up in useful ways without a big hassle, but there's just enough in the way of safety devices to keep you from killing yourself. &gt; ^( How did Perl helped you in your profession? ) Well, Perl is what gives a programmer their power. It's like an energy field created by everything. It surrounds us and penetrates us; it binds the galaxy together. &gt; ^( How did Perl helped your company? ) Makes the hard things easier, and the impossible things doable. &gt; ^( How do you intend to use Perl in the next years? ) I have an app that I deployed under Mojolicious a few years ago, and it's time to clean up and refresh the UI. With that in mind, I've been playing with Docker, since app dependencies, even with perlbrew can still be a pain, and containerization of dependencies is a good thing. So, I've been using Makefiles and shell scripts for developing images and deploying them, and.... Well, I'm doing a Docker API and client so that I can replace a lot of what's in the makefile with a more elegant implementation. Mapping localhost port numbers to container names is trivial with a hash. 
We aren't hip. 
This is a bit of the opposite of the story you are asking for, but I have many years of experience in C, Java, C#, Java and Python. I recently just got a job where 90% of my day is in Perl. So I'm spending most of my time learning perl. So yeah - there are still perl jobs out there. Especially for tech companies that have been around for &gt; 5 years.
sheol black perl cult watch this krypto nyx notelle tubbe nevernoire
Headings are always on their own line? If so then don't worry about splitting but just process line by line A quick search on MetaCPAN for "escape" turns up [this](https://metacpan.org/pod/URI::Escape)
Thank you for the pointer to URI::Escape. I have added the link as a note.
I can think of three ways of doing this * You can go through lines, once you read a header gather text until you get another header, then output that file, and repeat if there are more lines * Take the whole file as a string and split on #, each chunk is now to become a file, either split only one on newlines to give you the header and the rest, then output that file (look up the docs on split for the third argument) * Take the whole file as a string and do a regex match that pulls out each chunk, or even the header and body of the chunk directly rather than splitting once after, then output that file And I'm sure these aren't the only ways :)
Wonderful, thank you.
/u/pwr22 This is wonderful. Thank you so much for taking the trouble. I am hugely impressed with Perl and its community, and grateful for it. I hope I can be more helpful with it in future. Thank you!
Start by breaking out the individual characters from the string. [split](http://perldoc.perl.org/functions/split.html) is a good way to do this (read the part about using an empty string as the pattern).
I believe they have been there since the beginning. Certainly as long as goto has been part of the language (otherwise there wouldn't have been a target for goto to go to).
 They both sorta suck. Hashes are slow, and sorting is slow, but, its a start. 
 So...interestingly for all of us, that perlmonks thread included some timings. The C version was about 50x faster than the Perl versions. The slowest Perl version was 5x slower than the fastest. 
Modern Perl builds might be faster too
Thank you, this is an intriguing alternative. I would still like to learn a Perl-based way, to hone my toolchain, and also because we could happen to have a similar situation, with files that cannot be handled by Pandoc.
Sorry I was not clear, I was trying to think how to trim up to a whole word (ie, avoiding trimming in the middle of a word). That seems to me a pretty complex case, so I was hoping to leverage a word-wrap package, that would keep a certain number of words, up to 100 chars max. But for now I am more than happy to study all the code and links you have sent. Thanks again!
This elision modules all do that for you, look again at my example using one of them
Yeah, I see List::MoreUtils implements "uniq" and offers "distinct" as an alias. This is frankly a misuse of "unique", but it's disappointingly common. In standard SQL, "UNIQUE" is a constraint on a table, forcing uniqueness and "DISTINCT" is a filter on queries that would otherwise result in duplicates. Also sadly common: "more unique" and "most unique". Nothing is "more unique". Something is unique or it isn't. Anything "less unique" is simply not unique. Of course, this is just bad English; it has no programming context. And often flawed language becomes accepted language.
split it, hash it, key it, count it: scalar(keys {map{$_ =&gt; 1} split //, $input}); 
Sounds like a real world programming exercise where you need to go back to your PM and make sure you have accurate requirements and definitions. In this case: ask the prof which version of the answer they're looking for.
Wonderful! Thank you so much.
This is why reddit is better than "just google it." Experienced folks like yourself take the time to thoroughly respond to a post, Even though I'm not the OP, I appreciate your effort. I never realized that there are ambiguities between distinct and unique -- thanks for the explanation! 
&gt; My attitude is the major scripting languages (perl, ruby, python) are so interchangeable Except when they aren't. I've used both perl and python professionally for many years. We had a need for an application that could parse various styles of different logs. It needed network and DB access, needed regexes (no way around that requirement whatsoever), needed XML handling, and a few others. So far, one would think that either would work just as well. The trouble is that they don't work equally well. I wrote a small test parser for a couple simple cases for one particular log style. The pre-compiled regexes in Python were anywhere from 5 to 7 times slower than Perl's -- in our specific case, using logs we knew we were going to use and regexes that were very close to the final things. Honestly, I thought initially I'd be writing in Python (I had just come off using Python every day for three years at a previous job). But the speed difference is a giant win for us when you're going through a few hundred GBs of logs every hour. &gt; I also think perl is still better for shoveling around data and text in hundred liners, and I do that tons. Again, as someone who deals with log files a lot, I agree completely. I use things like Tie::File to look through and arbitrarily alter huge text files fairly often. I also like that the syntax doesn't use white space to denote blocks. On the flip side, I very much do not like OO Perl. Python's OO syntax is far and away superior.
https://metacpan.org/pod/Hash::Ordered#MOTIVATION
Valid point -- I'm an academic :)
&gt; I spend so much time worrying that Perl is hiding things from me that I feel I should hire a hard-drinking detective to keep an eye on me. Are you willing to give an example or two?
You know you can just indent a paragraph to make it source formatted? use strict; Like that.
Thanks for your reply. I did this and here's what I got: This is perl 5, version 18, subversion 2 (v5.18.2) built for darwin-thread-multi-2level (with 2 registered patches, see perl -V for more detail) and more stuff about the copyright and all that. So I guess I have it installed! I know this is a stupid question but what exactly is Perl? I was expecting it to be some kind of program that I can open and type things into, like R or SPSS. Is that not what Perl is? I read about it on the website but it just had a bunch of coding jargon that I don't know anything about yet. 
Great, thanks! What text editor do you recommend? I always just use Microsoft Word and TextEdit.
You need an editor that can edit plain text files and do syntax highlighting. I think TextMate is pretty popular on Macs. I personally use vim but it is a bit unusual for some people.
You've installed the Perl interpreter. It's a command line program, there is no graphical interface. You write your script using whatever kind of text editor you prefer, and then you run it with the `perl` command. This can be automated from the text editor, or you can do it manually from the command line. There is really a spectrum of how much a text editor can do for you. Some are just simple editors, others know things about the language you're writing and can do things like suggest completions or automatically format the code. As you move toward that end of the spectrum, the tools start to be called IDEs (integrated development environments) rather than just text editors. Padre is an example of a Perl IDE, and I'm sure there are lot more. But there are many sophisticated text editors out there that are good enough, and I would wager that that's what most people use. In any case, all of the above is completely separate from Perl, which is just the interpreter for the language. ActiveState is a particular distribution of Perl, i.e. they take the Perl source code and compile it and distribute those compiled binaries, as well as offering pre-compiled binary packages of a number of third party addon modules to avoid the hassle of building them yourself from CPAN. Most Unix systems already have a Perl binary installed, so installing Perl is usually not something that you need to do yourself, although installing a Perl that's different than the one distributed with the operating system is not necessarily a bad idea, as you often can get a more recent version. If you do use the system perl, make sure to install any modules outside of the default system path, e.g. using `local::lib` (usually in conjunction with `cpanm`.) 
You need to save your code into a text file and run it, e.g. `perl filename` or you can specify code using the `-e` or `-E` options. Both options are similar except that `-E` enables features available on newer versions of Perl (such as `say` -- which is the same as `print` except it appends a newline character). perl -E 'say "Hello."; say scalar localtime' You may want to grab a copy of Modern Perl: http://onyxneon.com/books/modern_perl/ Electronic versions of the book are available to download for free, the links are on the page. perl -MJSON::PP=decode_json -MHTTP::Tiny -E 'say decode_json(HTTP::Tiny-&gt;new-&gt;get("http://reddit.com/r/perl.json")-&gt;{content})-&gt;{data}{children}[0]{data}{url}'
This is great, thank you. So Perl doesn't actually have its own dedicated console where you type code, but instead you type your code in a separate text editor and run it via Perl. 
I have not spent much time with walkthroughs but I’ll give it a shot. Apologies up front for any jargon I get incorrect or explanations that are only half dialed in. $input = 'my example'; print scalar(keys {map{$_ =&gt; 1} split //, $input}); Basically the line is processed from right to left, it’s order being the same as description I opened my one line with: split it, hash it, key it, count it SPLIT IT First function will split the input (be sure to chomp the input to remove the new line from the input) and return an array. I create an explicit array object here to make it easier to communicate the next step: @split_array = split //, $input HASH IT This returns the values in an array, which we use in the map function to create a hash: %character_hash = map{$_ =&gt; 1} @split_array (warning: details here regarding 'map' and it’s returned objects and what’s happening internally when I enclose it in brackets might not be completely accurate, but the result and usage is) What the map function does is evaluate the code block for each element in the array, which in the case of $_ =&gt; 1, is creating a list of key value pairs with each letter from the input as a key and a value of 1. The value doesn’t really matter, we just want to exploit the feature of the key in a hash being unique, whenever the map function evaluates with a letter that’s already been created in the hash, it’s simply writing the value for that hashkey again, leaving us, in the end, with a single reference for each letter in the hash. These values are returned by the map function as a list, it ends up looking something like this: (m,1,y,1, ,1,e,1,x,1,a,1,p,1,l,1) which is then typed as a hash when enclosed in brackets (or someone correct me if I’m wrong because I’m not quite confident in my explanation here either): {map{$_ =&gt; 1} split //, $input} note: This list is now a hash, which means the values aren’t necessarily in the order I present them, or how they were input, at this point. They simply exist in the data structure in some non-guaranteed order (and don't let it fool you, it may appear consistent but it won't be for long, so don't depend on the order), which is perfectly suitable for us since the order is not relevant for our solution. KEY IT Now, with this list stored as a hash we can use 'keys' function to get a list of just the keys used in that hash (yup, another list): keys {map{$_ =&gt; 1} split //, $input} COUNT IT Lastly, use the scalar operator to count the items in this final incarnation of the list (i.e. just the keys): scalar(keys {map{$_ =&gt; 1} split //, $input}) I hope that mostly makes sense in it's presentation and that I explained some of those perl internals correctly enough. 
&gt;&gt; The language is unhelpfully helpful in how it deals with uninitialized variables &gt; &gt; You mean the errors that say things like: &gt; &gt; Global symbol "$foo" requires explicit package name at /path/to/program.pl line 127. That's an undeclared variable, not an unitialised variable.
There's also [Devel::REPL](https://metacpan.org/pod/Devel::REPL)
Variables in perl need no initialization. They can be auto-vivified at will. I was merely pointing out how helpfully unhelpful the language was.
Atom still has problems with file sizes over 2MB. ST3 is good.
Ahh. Thanks. Didn't know I could. I should have seen that coming, actually. So, do I understand this correctly? "my" basically let's me take a variable that is probably in use somewhere else and make it apply only to this one piece of code? So my hostname would be different than the hostname variable for my system? 
It is called scoping, yes. You can declare a variable of same name inside and outside a loop and they would be completely unrelated. If you had "use strict;" first in your code perl would require you to declare all variables with my or our. Do not use "our" unless you really know what you are doing - stick to "my". I have never written any perl without strict and warnings on, and I recommend you do the same. The quality of the code will be a lot better. 
+1 for Log::Log4perl. It does have some gotchas, though, once you get past the "easy" interface. It'd be nice if we had a list of recommended modules list with sample usage/config. App::Kensho and others do a pretty good job with the recommendations, but don't provide any examples, and module docs for stuff like Log::Log4perl take quite a long time to wade through and find the important bits.
Also you can grab more than one variable without grabbing all of them like: my ($hour, $mon) = (localtime)[2,4];
Yeah, I think part of the "problem" with log4perl is that logging is something that can be done a hundred ways and that makes writing useful sample configs easy. But I agree that it could have been better, I still get confused sometimes when I need to tinker with something in the log config. 
 use strict; use warnings; use feature 'say'; use Time::Piece; say localtime-&gt;hour https://metacpan.org/pod/Time::Piece
It does however make them available under %ENV which does not need to be declared. 
There's a lot of "magic" in it too. Implicit behavior that's very much not obvious. Makes it hard for beginners. # Warning: bad code sub printStuff { print or die foreach @_; } Is a function that individually prints each argument. It uses a variable you can't see: `$_`. A lot of functions will operate on `$_` if you don't pass them any parameters. Print is one of them. The `or die` is a basic (melodramatic) error handling that halts the program if print ever fails. There's also postfix `foreach` which is just shorthand for `foreach (@_){yourStatement}`; Also, did you notice that we don't have a formal parameter list? Yeah. 
Sigils and punctuation make it look "noisey". "Clever" programmers did idiomatic things, giving it a reputation for being hard to read. There are a lot of idioms in Perl. In Java, most things are library imports, methods, variables, and method calls to get things done. In Perl, it could be a module (built-in or otherwise), a built-in function, an operator, a special variable (this is serious !!! turf if you're not used to it), or some idiomatic combination of multiple things. Perl is usually written less idiomatically these days, but the reputation hangs on. For examples of idioms, poke around in http://perldoc.perl.org/perlfaq.html. Perl programmers also gave Perl a bad reputation by growing projects... er... organically. The C++ guys were studying object oriented design before Perl was created (_Object Oriented Design Heuristics_, by Riel is still one of my favorite books). In the early days of Web development, people didn't consider Web sites to be any sort of software engineering at all. But then things got big. Amazon, BizRate, etc, etc had crazy growth. But Perl programmers elsewhere didn't stop and think that they should take OO architecture and design seriously. Perl programmers clung to the pre-OO days for years after Perl 5 added OO and then when they did OO, they newbed it up like how PHP programmers keep newbing up security. While the rest of the world was studying and discussing _Object Oriented Design Patterns_ as the book that gave names and guidance to things that happen in complex OO systems, the Perl community barely gave it a passing glance. Likewise when _Refactoring, Improving the Design of Existing Software_ hit hard, only a small chunk of the Perl camp gave any notice at all, and generally not the studious attention Java/C++/etc programmers did. Large sites written in Perl are train wrecks. There's a serious apathy about programming as a craft. Like PHP programmers, Perl programmers, by and large, learned Perl to make a quick buck, but then had no basis for knowing when they were in over their head (security, scalability, architecture, etc) so they just kept on trucking and did their best. That's completely not the language's fault... it's purely cultural, but it does answer the question "Why is Perl considered awful?" -- because of the vast majority of code written in it. Perl got formal function parameters, like, yesterday (just in this last year). Virtually every language since the 70's has had this feature. That's things like this: sub some_function(arg1, arg2, ... ) { ... } Perl didn't have that. OO was and still is idiomatic. There's no "class" or "method" keyword unless you import one from some package. Up until fairly recently in the life of Perl 5, people kind of hobbled objects together. This isn't fundamentally bad; Larry Wall famously described Perl as being post-modern and having the duct work exposed, and that's a lot of the reason I like it, but it's also a valid reason for a lot of other people not to like it. This is how you made and used an object: package some_package; sub new { my $package = shift; # 'some_package' unless we get subclassed my $arg1 = shift; # shift function arguments off of the argument stack; there are other ways to do this but they require additional idiom my $arg2 = shift; my $self = { thing_1 =&gt; $arg1, thing_2 =&gt; $arg2, }; bless $self, $package; # magic! makes $self into an object reference associated with this (or the subclassing) package return $self; } package main; my $thing = some_package-&gt;new( 1, 2 ); That's more fuss and boilerplate than most people want. Perl being extremely expressive with text but very not with objects was an impedance mismatch. (I'm writing assuming that you're not seeped in Perl stuff; apologies if I'm wrong and you are.) Perhaps Perl's biggest sin is departing so radically from being C-like. The operators that it shares are the same, and it uses { } for blocks and ( ) for function args, but that's about the end of it. History has shown time and time again that any non-C-like (or not adequately C-like language) gets stuck on a sort of fringe. Prolog, Forth, Lisp, Haskell, etc are awesome, but people can't get over their annoyance at not being able to basically read the code. There's reason for the idiom and non-C-ness. Perl stole a lot from awk, sed, bash, and other languages that are very much not C languages. awk is for writing string scanners. It's basically a parser grammar builder as a language. How rad is that!? Perl extends it and thoroughly integrates it. You can mix sed ideas and OO ideas in crazy but powerful ways... but to someone not familiar with sed, it's just frightening and alien. Similar for other languages Perl stole things from. The "string formats" thing is straight out of COBOL. Any language that a lot of people all learn at once (as happened to Perl during the dot com boom) comes down with newbie disaffectedness disorder. If you learn to program in one language and write really bad code, and then another language comes out that promises clean code, it's an easy psychological trap to fall in to to blame your bad code on the language. And since everyone else was learning at the same time, there's a ton of bad code out there so the language gets the rep for it, and that helps you just blame the language. Then you go learn another language and all of the code is much better... until that language gets massively popular and has a newbie influx. I had one gig where I was interviewing and hiring Indian Java developers. Every tiny code example submitted had serious problems. Something like this was an example: if( obj.everythingOk() &amp;&amp; obj ) { ... } Argh. It short circuits left! The right side will never run when it needs to. And maybe its better to blow up on a null object rather than try to truck on indefinitely. Anyway, Java definitely had a serious code quality plunge in response to its rapid growth. It seems like things have pretty well stabilized more recently, but I think it was enough to kill the myth that "all code written in Java is clean because Java is clean". Point of that being that cultural and market factors have a lot to do with perceptions. Lack of compile time type checking (I wrote a module but it's seriously bitrotted now and, tellingly, no one ever expressed interest in it, only dismay) is an impediment for using Perl on large teams. The fact that the vast majority of Perl programmers don't even comprehend the utility of it is damning. But I guess JavaScript doesn't have this either, but I think people will at least admit that JS on large projects can make life interesting for lack of it. tl;dr http://perldesignpatterns.com/?self
People like me writing code like this, probably: perl -pe 'use utf8;BEGIN{eval pack"n*",unpack"U*","獵戠养⑳嬨⑟嬰崫㴤彛ㅝ 㴲㔶嵽獵戊卻䁳嬤礬⑸⬫崽䁳嬤砬⑹嵽䁫㵰潰㵾⼮ⸯ朻匤礽浡灻匊儤礬⑟⭨數⑫嬤砥䁫嵽䁳㴰⸮㈵㔊"}s/\C/$&amp;^chr Q S Q$y,Q$x/eg' KEY (it's an RC4 implementation that fits in a tweet)
This is so much nicer, thanks for sharing
It's good when you want quick and dirty, and easy to ignore when you don't. 
Lisp is a language inspired by theoretical linguistics. Perl is a language originally implemented by a linguistics graduate with an interest in practical language usage. 
I think the main reason why Lisp people don't like perl much, is that perl code is very hard to manipulate *correctly* from within perl. There are [modules](http://search.cpan.org/dist/PPI/lib/PPI.pm) showing that in pracice, say for 99% of all cases, it can be done, but it's impossible to get it 100% right, as any module can change the syntax of perl. You can check the intro docs for [PPI](http://search.cpan.org/dist/PPI/lib/PPI.pm) which explain what problems they were facing, developing this module.
Having very little exposure to Perl before my gf got a job that relied on it, shit like this was maddening. She often needed help with programs and I wanted to kill whoever decided perl was going to be the default language for bioinformatics. It's just so non-intuitive.
... And now there are 4 glyphs, just added the Raptor :D
Personally, I think it comes down to terse vs. verbose. People who love Perl often know several languages, and they enjoy seeing just the algorithm, without any boilerplate. However, this can be too terse to someone who (a) doesn't know the algorithm, and (b) doesn't know some of the implicit stuff. If you did years of Linux, bash, C, sed, awk, grep etc., chances are that a lot of Perl seems intuitive and sensible. But if you came from Windows, a lot of the "intuitive" stuff probably looks insane. Then if you were forced to maintain somebody else's poorly written code, you're probably angry. However, where I work, people suddenly adore Perl, because I'm replacing poorly written Java and Powershell (and bash) with well-documented production-grade Perl circa 2015. (Which anyone can read and understand). And it runs on Windows (Strawberry Perl) and is now part of our Windows / AD / ERP infrastructure (despite that I don't even use Windows.) What I find hilarious is the Powershell, which looks like the worst bash I've ever seen. So I empathize with those who complain about crappy code, but it's nothing much to do with the language.
Sigils are optional in most languages but are required by the style guidelines of many shops. Only they're called Hungarian notation. It seems a lot of people object to having best practices enforced by a language.
&gt; Clearly they're insecure about their choice of language I'm not sure ascribing motive to a group of people like this does anyone any good.
It is in fact non-intuitive **if you are alread crafted your mind around python or something related**, but than, any and each other tool wil be always unapropriated. If all you have is a hammer, everything looks like a nail. I think that every new language that explore new concepts and new ways to address old problems is a good pick, just because it can teach me new things.
My personal take on the issue, having been a former Perl professional. * **It's not statically typed.** * **Mutable by default.** * **Poor concurrency support.** * **It enables sloppy, non-robust thinking.** * **It attracts poor caliber programmers.** * **It's considered awful.**
&gt; a decent functional programming language I wish Perl had a lower barrier keyword for read only variables.
Oh! Duh, sorry. Literacy failure. my $node = XML::LibXML::CDATASection-&gt;new('Your content here!'); $parent-&gt;addChild($node); gives me a proper &lt;![CDATA[Your content here!]]&gt; You aren't appending the node and *then* creating it as a CDATA section, are you?
So you moved on to Go?
&gt; So you moved on to Go? No, Scala.
May be only duckduckgo
I think your first three points are valid. Points 4 and 5 are however asinine. Poor caliber programers run from Perl like its the plague. Too much syntax, too many strange edge cases. The sloppy, non-robust thinking part has to be a knock on the lack of static typing, but honestly, there is a lot more to coding well than types. 
No, I mean people specifically putting in the least effort to get the most money out of other people despite the harm they know they cause, then completely disclaiming the consequences of their actions.
There are people who are cognitively limited. They tend to try to exalt whatever they are using with respect to what is still, after all these years, a rather important language. This seems to satisfy a desire for self-validation. http://blog.nu42.com/2011/06/is-this-why-perl-sucks.html http://blog.nu42.com/2010/12/dont-blame-perl-for-all-ugly-code.html http://blog.nu42.com/2010/12/why-does-perl-have-to-suck-for-you-to.html 
Enlighten a newbie, please. Why does die() has to die? 
Was this written in Perl? Doesn't [look](http://stackshare.io/gitcolony/gitcolony) like it....
&gt; harder to write bad python. And yet python has no concept of strictures, so I imagine typos in variable names are lots of fun for beginners to debug. 
&gt; A lot of the things you're criticising Perl for just aren't that important. Specifically OO and Design Patterns. Agree. OO (in general) is a fucking disaster, which is why you now see so many people advocating for composition instead of inheritance. There are 25+ years worth of OO textbooks that talk up inheritance....and now people want throw it away because it's too easy to screw up. That's not to say that OO in perl isn't useful--if nothing else, it's a serviceable replacement for a real type system. 
I'm always happy to see new faces in #mojo working on Mojolicious projects and plugins etc, and of course you would [be welcome](http://mojolicio.us/perldoc#SUPPORT). That said, I think you should contribute to something you use/know or else something that you want to use/know. There's nothing better for learning than doing, so pick a project you want to use, then use it, then help to improve it. This may happen quickly, just by reading the documentation to get started you might find errors or things that are confusing which can be improved, or it might take a while until you can start fixing bugs or suggesting features. I hope you find something you will be able to dive in to. Good luck and have fun!
You could join in on the [CPAN Pull Request Challenge](http://blogs.perl.org/users/neilb/2014/12/take-the-2015-cpan-pull-request-challenge.html)
&gt; Actually I think there are very few applications where bitwise operators are needed. It might be interesting to see which CPAN modules use them. Quite a few hardware-related modules need to do low-level bit flippery. So do many that handle binary networking protocols.
There's lots to be done on with hardware. Check out [hardware.pm](http://hardware.pm.org/). There's a new System on a Chip board coming out every week, and I'd like to see a Device::WebIO implementation for all of them. Then there's sensors to implement--temperature, accelerometer, gyro, etc. I recently did Device::PCD8544 (old Nokia LCD screen), and I'd like to see more sophisticated LCD screens implemented. And, of course, projects that actually use all this stuff.
Dare I suggest Perl 6 and Rakudo? ;P Certainly one of the bigger and more interesting projects, vibrant is debatable since most people around here are all doom and gloom. Plenty to do outside of the compiler too like writing tutorials or coming up with nice tools. Given native typed arrays are being worked on ATM Perl 6 integration with Jupyter might be fun, an equally good project to do with Perl 5 + PDL too. http://jupyter.org http://pdl.perl.org
Just pointing out a niche where you do need them, since you seemed to be asking in the article.
Oh right. Thanks.
Good resource, but it needs a section about the challenges of working with Unicode on Windows. This page that I quickly Googled does a decent job explaining what I ran into the other night: http://www.i-programmer.info/programming/other-languages/1973-unicode-issues-in-perl.html
Hi! Thanks everyone! I haven't decided yet, but I wanted to drop by. It would be the first time I work in an open source project, so it will take some time. Cheers! BTW, amazing projects :)
&gt; The README is used to introduce the module and provide instructions on how to install the module Gotta love folks who publish their programs without even bothering to write the first word of documentation. And we wonder why free software has a reputation for opaqueness?
One, thanks for the help. Two, sorry for the delay in replying to your post. I was busy banging my head on the table trying to figure this out. I have it now and figured I'd come back and post so maybe it would help some other unfortunate soul. After I found the nodes I wanted to change, if ($node-&gt;textContent() eq '0') I had to remove the child node, which was actually the text content "0" $node-&gt;removeChildNodes(); then implement the CDATA section my $content = XML::LibXML::CDATASection-&gt;new('New Content Here!'); then append the child back onto the node $node-&gt;appendChild($content); I think what threw me for so long, was the realization that the content of the node I wanted to change was actually a child of said node. I kept trying to use $node-&gt;appendText($content); which would put the content in the node but kept changing my angle brackets back into their ASCII codes. I fixed it when I changed appendText to appendChild. So the whole thing looks like: if ($node-&gt;textContent() eq '0') { $node-&gt;removeChildNodes(); my $content = XML::LibXML::CDATASection-&gt;new('New Content Here!'); node-&gt;appendChild($content); } And it works!
Great to see a new bitcoin library, implemented in XS no less. Can you put it on CPAN?
Nice slides, wonder if the FOSDEM video will be online. Ovid gives great presentations
I give something away for free every morning, into a porcelain bowl. You're welcome.
Let he who is without sin cast the first stone.
Jesus then tells the prostitute, "Go and sin no more." So, stop releasing code without documentation.
The O'Reily books I have always found useffull, starting at Learning Perl or something. There is also this free book, which, I wish I would have known about when I started with perl. Link: http://onyxneon.com/books/modern_perl/modern_perl_a4.pdf
http://perl-tutorial.org/ I really like Beginning Perl by Ovid, this book is IMHO written much better than Learning Perl. 
That sounds great, but I seem not to have cpan: [linuxphoney@linuxphoneyadm perl]$ cpan -l -bash: cpan: command not found I feel like something is broken here. I have several small perl programs that I wrote that run fine, so perl is installed (in some way) but clearly not as completely as most documentation assumed. 
A standard installation of Perl contains just a minimal set of modules that are required for building and getting jumpstarted. The standard installation of Linux distributions add to that list whatever the distributor deems as appropriate. So the philosphy is that users should simply install the modules either from CPAN of from the distribution repository. This is pretty easy when using e.g. the command line tool *cpanm*. With the help of Module::CoreList you can find out which modules are in core. $ corelist Module::CoreList Data for 2014-09-14 Module::CoreList was first released with perl v5.8.9 $ corelist Modern::Perl Data for 2014-09-14 Modern::Perl was not in CORE (or so I think) $ corelist autodie Data for 2014-09-14 autodie was first released with perl v5.10.1 
I mentioned this above, but cpan doesn't seem to be in stalled at all. corelist is also not a command I have. 
Here are a couple of hints: perldoc -f reverse perldoc -f sort perldoc Getopt::Long Instead of prompting for strings, you might want to read them from a file: command line parameters will be found in the @ARGV array (before or after Getopt treatment), so perldoc -f open
Sorry, that was just shorter. The above did not work either. [linuxphoney@linuxphoneyadm perl]$ sudo perl -MCPAN -e shell Can't locate CPAN.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .). BEGIN failed--compilation aborted. 
&gt; still an "unrecognizable switch") I don't think there is an -r switch. Reading `perldoc perlrun` I don't see it.
once you get started, perlmonks.org is a great resource when you run into questions or problems. 
Use cpanm https://metacpan.org/pod/App::cpanminus#INSTALLATION for installing packages. You may also want to set up a local::lib https://metacpan.org/pod/local::lib#The-bootstrapping-technique 
thanks so much, that was actually a big part of the problem. now that i'm doing that, the reverse function works, but it includes "-r" in the sort output. any thoughts on why that might be?
From the pod: &gt; Net::FTP is a class implementing a simple FTP client in Perl as described in RFC959. It provides wrappers for a subset of the RFC959 commands. So internally Net::FTP manages everything, not an external ftp client.
I would suggest using [perlbrew](http://perlbrew.pl) and install Perl into your home directory instead of relying on RedHat systems Perl.
Unfortunately RH intentionally breaks it's system perl. As a result you need to at least install the perl-core package in order for it too be functional. That said, perlbrew is highly recommended (as dj just posted)
Popular frameworks and tools that have been getting recent attention can be good to explore. I recommend Moose, Mojolicious, DBIx::Class, and of course the eternally classic Locale::Maketext::TPJ13.
Hard to know without actually reading your code (which I can't really do and probably shouldn't :-) But if it helps, all the options and arguments passed to perl (everything after your script on the command line) are in the perl variable @ARGV. Your code might be looking at this directly, or via some helper. If you don't somehow process and remove the '-r' option from this array, you'll pass it to the rest of your program as an argument. One way to do this would be to use a module like Getopt::Std or Getopt::Long. But you can also do it "by hand" with an 'if' to recognise hte '-r' and a 'shift' to move it out of the array once you've found it. Good luck.
I'm on a fedora box at the moment, but CPAN.pm is included in the perl-CPAN package. It's probably the same on RHEL. I could vpn into work and check, but I'm 99% sure it's the same.
This is an FTP client. Local machine's ftp service sure sounds like a server to me.
Here is the link to the full cbitcoin library. https://github.com/favioflamingo/cbitcoin. 
Reading the sidebar.
Thanks, this sounds like it will work. I'll give it a go, I'd rather try it myself then use the method. I will be working with non csv files as well.
Great answer!
use 3 argument open (http://modernperlbooks.com/books/modern_perl_2014/09-managing-perl-programs.html#VHdvLWFyZ3VtZW50b3Blbg) close is optional if you use a lexical variable to hold the filehandle, as soon as it goes out of scope it closes the filehandle.
Along with Modern Perl, I think Higher Order Perl is interesting to learn the language flexibility
use the module. don't reinvent a poor imitation of the wheel one of the best things about perl is the CPAN, learn to use it
This! I find it highly annoying. Since CentOS is basically RedHat, it also breaks this behavior. Most of the Perl's core modules are not bundled, and need to be installed separately.
That's too much work for `cpan Modern::Perl`
Thanks guys. That helps the troubleshooting process.
It doesn't mean an anonymous sub but a block Look again at your link
I would follow the policy of always using an explicit return (PBP 197). From my understanding, that should take care of it.
What happened when you tried it? :) Or, read the thread and noticed other people trying it. :)
Man, i wish i'd known that before. That explains so much about the last time I tried to teach myself perl. 
Here is my re.pl session: main(1): [map { my $x = $_; { $x =&gt; 'here' } } (1..5)] $ARRAY1 = [ 1, 'here', 2, 'here', 3, 'here', 4, 'here', 5, 'here' ]; main(2): [map { my $x = $_; +{ $x =&gt; 'here' } } (1..5)] $ARRAY1 = [ { 1 =&gt; 'here' }, { 2 =&gt; 'here' }, { 3 =&gt; 'here' }, { 4 =&gt; 'here' }, { 5 =&gt; 'here' } ]; Interestingly, it does the expected thing if I do not have other statements before the {}: main(3): [map { { $_ =&gt; 'here' } } (1..5)] $ARRAY1 = [ { 1 =&gt; 'here' }, { 2 =&gt; 'here' }, { 3 =&gt; 'here' }, { 4 =&gt; 'here' }, { 5 =&gt; 'here' } ]; 
Something bothers me about this. Why is it possible to parse JSON but not HTML with regex?
You *sort of * answered the question and you also sort of said some profound shit, so maybe copy it somewhere for a good article on why not getting help is sometimes really good. That said, this came about because I cracked open a copy of Modern Perl 2014, which is a guide to getting started and the very first example out the gate was a thing that I could not compile. I'm not suggesting that hand holding is a good thing once you have the basic concepts down, but I think it IS when you're taking your first steps, because those are the least sure steps and they should be. That's sort of what I meant. And to be honest, I didn't know any of the other crap about RH degrading their Perl. That's interesting stuff that I'd never have known (because, of course, I could plot a small bit of Perl code in and run it, so why would I ever think that the language might not be working right?) Also, to be fair, all my other experience programming was with Java and that made me hate the idea so much that it's taken me about eight years to try again. I ask a lot of questions up front, but I hope that means I'll ask less later on. 
Quick question: I need not uninstall anything to install perlbrew, right? I can just put it in there and go? 
That sounds like a good idea, but then i get this: Can't locate Getopt/Long.pm in @INC (@INC contains: FatPacked::38869232=HASH(0x25118f0) /usr/share/perl5 /usr/lib64/perl5 /usr/local/share/perl5 /usr/local/lib64/perl5) at perlbrew line 33. I feel like I'm needing to be a good perl programmer to learn how to be a perl programmer. I'm reminded of java. 
Yup. When I wrote _Perl 6 Now: The Core Concepts Illustrated with Perl 5_, we didn't have perlbrew yet. That was years ago now (the core concepts haven't changed but boy has perl!). One of the first things I did was walk people through building their own copy of perl. And it's obnoxious and seriously weak that you have to. RedHat was, up to very recently, distributing a version of Perl *ten* stable releases behind. Then it split it up into multiple packages and distributed *some* Perl stuff but not even the entire, already very small core. It's expected that when you use Perl that you'll install module as needed, but it's also expected that a small handful have shipped with the thing. They broke that. In my opinion, they couldn't really call what they distributed Perl. So all of that is a huge kick in the nuts. The whole modern Perl movement is a pushback against the catch 22 of only having 15 year old perls available and so writing code for them. As for installing modules, thankfully, it's extremely easy, when it works. Sometimes dependency hell or system package dependencies ruin it, but ideally, this is all you need to go: wget --no-check-certificate http://cpanmin.us -O cpanm; chmod ugo+x cpanm; sudo mv cpanm /usr/local/bin Then once that is done: cpanm Whatever::Module::You::Need Book authors and article authors should definitely repeat that or link to that explanation. I've been learning R recently, and predictably, the situation is similar, with modules. Same for Ruby and Python. The R materials have so far done a good job of telling me what to do if different things don't work (how to install modules, which modules to install, etc). Without that, I'd be very frustrated.
Yeah ... I have no idea what RH did, but it's a mess. I did run that command. cpanm came in fine, but no matter what i try to grab after I get a can't locate (something or other) in @INC error. SO not like. Am I overlooking an easy walkthrough out there for how to do this in RHEL7? 
FYI, the Modern Perl book does discuss cpanm/perlbrew/local::lib in Chapter 2. Perhaps some of that needs to be moved up to the Preface.
This is amazing. But I'm having trouble fully grasping named sub-patterns... As a side note I'm curious - would this be possible in Python Regex? If not, why not?
Sorry, I should have told you to do 'sudo cpanm Whatever::Package'. Otherwise cpanm will install things somewhere in your home directory where perl won't know to look for them (that could be considered a bug; this use case is common enough that the location should be standardized). So, to make that work as a user, look in your home directory, try to figure out where it put stuff, and then add a line like this near the top of your program: use lib '/home/scott/lib/perl5/site_perl/5.12.0/'; That should go before the 'use' line that pulls in the module itself, but generally after 'use strict' and 'use warnings'. The people suggesting you use perlbrew were suggesting that in part because of this problem.
yes problem is there is a space after the dot. i never noticed it, thank you. and this is first time i ever pasted a code in reddit, i will look at it if i post again
I like this. FFI is a really easy way to work with C libs.
This should be on most Perl programmer tests, given how many times I get out of memory running a script on multi gigabyte files in bioinformatics land.
Actually, that is more clear, yes. It read to me like the first was just shorthand for the second. 
Would have been better with examples. Of course people would pick them apart, but examples of how readable it can be with a nod to the unreadable would have improved it IMO.
Note that this line: while (my $row = &lt;$fh&gt;) { needs not be written as: while (defined(my $row = &lt;$fh&gt;)) { because instead of doing the boolean test, as it normally would, while() is automatically testing for defined-ness here. (Reference: perlop, the I/O Operators section.) This is one clear example of the DWIM principle in Perl. I'm not sure I 100% love it though. Maybe 95%.
Are you wiling to provide examples? I learned Perl in the "modern era" and I'm not familiar with this problematic magic (in the recent codebases that I work with).
Just about [anything listed in perlvar](http://perldoc.perl.org/perlvar.html). From `$|` setting autoflush, to `$"` setting your list separator. While it's not due to a variable (well, in a narrow sense, anyway) there's also this nasty bit of code: whatever / 25 ; # / ; die "this dies!"; If `whatever` is defined as a subroutine with a prototype of `($)`, then the `/` starts a regex and the embeded `#` is just a character in that regex. In that case, the `die()` will happen next. If `whatever` is just a bareword or is defined with a prototype of `()`, then the `/` is the division operator and the `#` starts a comment. The `die()` will not happen. In short, prototypes can change the meaning of the program in a way that a compiler alone can't determine. (Also, remember that without `use strict`, a bareword like `whatever` without a subroutine definition will be accepted by perl. I just know that someone would bring this up because they've forgotten how perl behaves without strict.)
Why not just pass "-1" to the limit argument? Then it seems to behave as you want. Edit: Whoops, mastersplat beat me to it :) 
Perl _can_be_ a readable language. But it's really really easy to write unreadable code.
&gt; while() is automatically testing for defined-ness here That's true, I'd never thought about that before. Thanks for sharing.
Kinda related to this is my dislike of how a simple mistake early on in a code file can generate dozens of error messages which are all irrelevant, sometimes going literally to the end of file before Perl is finally forced to give up. Perl parser is just way too flexible and tries too hard to make the code work. And, I guess, the language syntax is itself too ambiguous, having too many parallel interpretations for same symbols. Many simple decisions along the way have resulted in this outcome -- e.g. that functions don't have to be declared before they are used, that parenthesis are optional in function calls, that whitespace is allowed between sigils and the sigils and names, that expressions that return a value in void context are allowed, that Perl has this weird lexer which allows it to parse even spaceless expressions into something, like Perl figures out that ///// can be a valid program // / // in past Perls, or now ////// can be parsed as // // //, apparently meaning regex-match defined-or regex-match. Dreadful.
You could make it a two-step process, using Text::Markdown first, then passing the result through [HTML::Scrubber](http://search.cpan.org/~nigelm/HTML-Scrubber-0.11/lib/HTML/Scrubber.pm) (or similar) to filter out anything that isn't basic HTML.
Does anyone knows when the videos are going up? Did they had video crew at every presentation?
It's generally a very bad idea to uninstall system Perl, though your system would probably indicate that to you ... autarch@houseabsolute:~$ sudo apt-get remove perl Reading package lists... Done Building dependency tree Reading state information... Done The following packages were automatically installed and are no longer required: calligra-data calligra-libs git-man gnucash-common gnucash-docs guile-2.0 [..snip a lot of packages...] mysql-server-core-5.5 w3c-sgml-lib Use 'apt-get autoremove' to remove them. The following packages will be REMOVED: anacron apache2 apache2-bin apache2-dev apache2-mpm-prefork autoconf [..snip way more packages...] texlive-pstricks texlive-pstricks-doc tipa ubuntu-gnome-desktop ubuntu-minimal update-inetd w3c-markup-validator 0 upgraded, 0 newly installed, 200 to remove and 0 not upgraded. 
Slash argument is invalid. As article says, you can write anything you want in any way possible, but if your code includes '//////' without any separation and you can't figure out what it does next day after writing... well, the problem isn't in the language. ;-)
My objection is that Perl allows this. If it was stricter, readability of programs would probably be improved slightly, but more importantly, it would be more likely that parser could early on determine that there is no possible way it can handle a particular expression and it could terminate parsing faster, resulting in fewer and more relevant errors. I find debugging the syntax errors I make from missing a ] or accidentally writing } when I meant ] or something like that to be absolutely horrible.
An interesting hack, but there is always a penalty to using multiple language VMs together in a single process image. At the boundaries, arguments and return values are copied and recreated as destination VMs values, and you can be almost certain that the hosting VM does not observe the changes made in the copies. This, of course, breaks the semantics of language such as Perl, e.g. you can't pass a P6 hash to P5 method, and expect to see any of the changes P5 code may make into the hash.
After enjoying awesome documentaries like "Print the Legend" and "Indie Game: The Movie", I think someone should get a film crew together and record what will be a historic year!
I use perl everyday, but all I keep thinking about perl6 is, if I'm going to learn another language, especially one that has no eco system yet, then why would I learn perl6 over rust? Can anyone answer that question, I can't. The only thing I can think of is perl6 has grsmmers, and they're very cool, but is that enough? I'm thinking not
* You can create Perl6 like grammars in Perl5 using [Pegex](https://metacpan.org/pod/Pegex). * IMHO, you learn a different language to understand the various possibilities of representing an idea in a form that a computer can understand. * Just because a new language is out, doesn't mean you should use it. * Not every new language needs to be used in production. * If an ecosystem doesn't exist, it will be created by early adopters. Look at the language Go. It is, IMHO, a crap language. But it has adopters and has an ecosystem that is coming up. Same with Perl6. There will always be developers who like a language that you/I may think is crap and an ecosystem will evolve. 
&gt; perl6 over rust? Too apple-vs-oranges. Try s/rust/Haskell, OCaml, Python3, Julia, .../.
Is there a specific bullet points of what features to include in "1.0" release (the talk is not online yet)? Because without a specific target, the devs can just as well arbitrarily deem today's (or 6 month later's) HEAD as good enough and label it as 1.0.
Moreover, pandoc can output its parse tree as JSON, meaning you can render the HTML exactly the way you want it, and filter out anything you don't want.
Maybe this technique is apt for the newfangled "microservices" methodology :) Where each microservice are more separated to one another and normally doesn't modify the others' data structures.
Is there a list, or a metacpan query maybe, of every distro with a github repo?
Stefan Seifert's response to your comment was: &gt; that's true. But it's also quite possible to not copy hashes and arrays. Copying was just quicker to implement and there are probably not many useful APIs that need modifications of arguments.
Neilb wrote about that [here](http://perladvent.org/2014/2014-12-15.html)
Thanks
http://www.reddit.com/r/programming/comments/2u6gec/shock_and_terror_perl_is_a_readable_language/#
No, that's the error I got when i tried to install it. it wasn't installed at all. 
This was the droid I was looking for.
That depends on what you mean by "like this". If "Maybe we'll freeze the spec/rename the test suite to the spec by this date", it's unique. If it's "We hope to have something out by Christmas", it's every few months. If it's "We can't predict volunteer resources", it's every week.
I would try: cpan Getopt::Long Then try to install Perlbrew again. I don't have access to a Red Hat Server. Are you running RHEL 7?
Looking at your other comments. I think you need to start with a fresh system since it looks like system perl isn't working at all.
tl;dr: no high likelihood of shipping Perl 6 this year, either. Honestly, I could "attempt" to do all kinds of things, but I wouldn't brag about attempting to do them in most cases, and I *definitely* wouldn't be announcing anything like this if I were they, especially given the objective history here. What, they weren't attempting to release Perl 6 in, oh...let's pick a random year we've had so far this current millennium...2008? Well, I guess no, they weren't. I guess that explains everything. 
God, chromatic, I am hoping that you are basically all over this now.
Doesn't seem to handle time zones very cleanly. Might be fast for systems that are already handling everything in UTC.
Yeah. I'm wondering what the hell could have gone off, because it's a fairly fresh RHEL system and I haven't installed much of anything.
Best perl6 presentation to date
I imagine, in another life, rjbs must be an NPR reporter.
Have you considered returning a reference instead? It's cheaper and might fix your problem.
Whatever you're doing in mySubroutine is causing your breweries array to become a stringified reference before it is stored in the hash. So your problem is in there somewhere.
I *did* try that, but found I was getting even more confused than in the first instance.
That makes sense, as I'm first creating the hash then splitting certain elements and over-writing them with the resultant array (not the best method but it was the best I could come up with at the time). I was thinking that somehow copying the hash may have been de-stringifying it (given that it works when exported) but curiously changing: %myHash = %result; return(%result); to %myHash = %result; return(%myHash); still fails. So it seems as if it's the very fact of being returned from the subroutine that's causing the problem. Odd...
Data::Dumper your hash and you might find the structure is not what you expect.
ARGHHH!!! The answer to my original question "am I being incredibly thick" is a resounding **"YES"**! Because I'm trying to read the breweries array after running: foreach(keys %formdata) { utf8::decode($formdata{$_}); } And surprise surprise, Data::Dumper shows the array intact before this but screwed afterwards. Today, I learned something...
There is something wrong because it should be there by default. I would suggest re-installing Red Hat. Then follow steps I gave you.
I think the refs should remain as refs if you do this, they shouldn't stringify like that.
I would even go still closer to static and say "Missing method != runtime error" until you mark something (e.g. your class) as dynamic. Situations where you don't know what methods are in your class at compile time are extremely seldom. My wish would be that you can make Perl6 as static and type save as any other static language too if you want. The larger your project goes the more you appreciate it. And if it's just valid method proposals in your IDE.
Is it? Apologies. I'd swear I had seen a date of April 2005. Sorry.
Working with decimal system doesn't actually guarantee a "right" answer. Humans are maybe a little bit biased to think that number system where fractions of 10 have exact representation are better than number systems where only exact fractions of 2 have. But our base-10 number system can't represent, say, 1/3 or 1/7 exactly, so we actually suffer from an analogous problem with floating point. However, base-10 can represent more ratios exactly than base 2, so it has got that going for it. That being said, when monetary calculations with base-10 must be made, you tend to reach for BigDecimal in java or decimal in C# or just integers if you are unlucky and have to write exact calculation in JavaScript. In any case, working with floating point boils down to just rounding the result after calculation, if you perform one where the result has been approximated. Integer numbers are always safe in floating point as well, as they have an exact representation, until the value is large enough to round in the mantissa.
Or even the num64 type for a native double.
I'm not sure what you mean with "cleanly". Time::Moment represent an instant with an offset, as required by ISO 8601. If you perform arithmetic or alter the local time or date you may need to account for that using a timezone. [Time::Moment is API compatible with DateTime::TimeZone](https://metacpan.org/pod/Time::Moment#TIME-ZONES). --- chansen (the author of Time::Moment) 
Above happens on both Perl 5.10 and 5.18. With Perl 5.20.0, the same command results in: Unknown regexp modifier "/e" at -e line 1, at end of line Unknown regexp modifier "/n" at -e line 1, at end of line Unknown regexp modifier "/v" at -e line 1, at end of line Execution of -e aborted due to compilation errors. which makes even less sense?
Try escaping $_
But if the API is right there, how much does an SDK really matter? I might end up just using the API anyway. Where I work, we're trying the trendy "microservices" approach, and we're using Perl (and replacing some monolithic Java where appropriate). I'd be fine with including some Go (and others). A multi-lingual future is presumably overall positive for Perl.
Generally you want to single-quote the argument to perl -e instead of double-quoting it, to make your life easier.
You're printing that error message and asking for a new number for *each* element in the original array. If `@number_choices` contains 1, 2, 3, and 4 and you enter 3, the first comparison is `1 == 3` which is false, and then you print the error message. You need to move the block to check against `$found` instead.
^ this The reason for inconsistent results may be clearer if you do: ➜ echo foo bar baz foo bar baz ➜ echo $_ baz
The best advice. And if you really want to use single quotes within single quotes, there are ways....... evil ways. ➜ perl -E 'say "I love '"'"'single'"'"' quotes"' 
Actually, I figured it out. Thank you so much, that was extremely helpful.
Take some code from the module itself: $tm1 = Time::Moment-&gt;from_string('2014-03-29T12:00:00+01:00'); See, that's already in UTC. I want something that is in local time (with a given time zone) either auto-converted to UTC or stored in local time an easy way to get the UTC form.
&gt; But if the API is right there, how much does an SDK really matter? I suppose a little for casual use simply because the AWS API (don't know if you use it much) is pretty sprawling and very finite...most methods involve a pretty decent number of combined calls to achieve even the simplest thing. I certainly wouldn't qualify this as them "adopting" go though, and certainly would agree...if you can't wrap simple HTTP requests in your language of choice you should reconsider your language (or alternately, career :))
I'd comment there, but I don't want to go down that rabbit-hole of pain.
Release early, release often, especially when you develop. Don't be scared about releasing something bad to CPAN, there are no bad releases, there are just uncooperative authors ;). So as long as you are open for the community to interact with you about your code.... everything gonna be cool :-). And yes I really mean that you can release "first crap" if you have at least a bigger picture behind. I have, as example, started this: https://metacpan.org/pod/NCC which is nothing more as a test so far, checking if CPANtesters goes through and all that, I dont followed it up yet, but I am open to follow it up if someone comes to me. :) So.... TL;DR Release NOW!
It gets generated when you dzil release or build ( if I recall correctly ). You can check it out if you run dzil build.
about fetching the images, use Perl and [WWW::Mechanize](https://metacpan.org/pod/WWW::Mechanize) or simply [LWP](https://metacpan.org/pod/LWP) about rejoining the images, [read here](http://www.imagemagick.org/Usage/crop/) convert rose: -crop 20x20 +repage +adjoin rose_tiles_%02d.gif montage -mode concatenate -tile 4x rose_tiles_*.gif rose_rejoined.gif good luck with your project, and always use Perl.
As you many recall, you've previously received [Be civil or be banned](http://www.reddit.com/r/perl/comments/2eqn7d/perl6_20140826_i_can_now_use_perl_5s_dbi_in_perl_6/ckbo6dc?context=3) warnings (though you edited your comment after the fact, something you've done more than once when called out on your behavior). You've also previously been banned for a month for uncivil behavior. You are now banned from /r/perl.
Both of these tasks can be accomplished with Perl, (plus the relevant modules of course) but I just want to point out that they are two distinct problems. You could solve one (scraping) with Perl and the other (stitching images together) with Java or Python or whatever. Or vice-versa. 
&gt; There is a way to filter out plugins from a bundle but it didn't work for me Can you be more specific? Also, if you have an irc client, hop on to the #distzilla channel on irc.perl.org and we can help you out realtime :)
I disagree that there are no "Bad Releases" 1. We have a recurrent problem with people releasing code that is redundant because they didn't look hard enough or didn't ask the right people the right questions to discover how they could achieve the same goal ( and better ) using existing tools. 2. If you have an existing high-visibility module, releasing a new release that breaks existing releases is "Bad", because of the domino of failures that people have to deal with, and not only that, they'll be dealing with that failure for a while ( I keep getting failure reports due to the Moose+Module::Runtime explosion, even though both have been long fixed ) 3. Due to #2, There is indeed a problem with releasing stuff that is not finished in some manner, because you're implicitly bound to support the interface in some way for the foreseeable future. So getting it right the first time reduces this risk. This is not to say it has to be "Perfect", but there are high level abstraction concerns that must be rather solid early on, and that part is more important. Subtle bugs, packaging mistakes and documentation failures are all less significant than the above. Because interface-breaking is the painful technical cost you don't want to pay.
Not sure if Perl's needed. wget should get you the images, if used properly (as wget will get you the content of a webpage). If you can get wget to dump the images properly, you COULD give Perl its output via qx[] and then use regex to name the files if you need to rename them. Honestly, in my Perl scripts, if I need to do something I already know the OS can do, I just wrap it in a qx[] and have the OS tools do it. So, bash may be your friend here. But if you want to challenge yourself and learn some Perl, then by all means, YES, Perl should be able to do this, but you'd need a package that implements "wget" or to use qx[wget ...] at some point.
You could use Perl but it doesn't really make the task any easier and trying to get Image::Magick to install can be painful. http://metacpan.org/pod/Imager is supposed to be better in that regard, I've yet to use it though. As mentioned by others you can use the `montage` command to stitch the images. If you're on OSX you can install imagemagick using `brew install imagemagick`. See http://brew.sh/ if you don't have homebrew set up yet. #!/bin/bash base_url=http://foo.com #for dir in {001..339} for dir in {001..002} do mkdir -p "XX_${dir}r" "XX_${dir}v" for head in {0..9} do for tail in {0..12} do #curl -s "${base_url%/}/XX_${dir}r/${head}_${tail}.jpg" -o "XX_${dir}r/${head}_${tail}.jpg" #curl -s "${base_url%/}/XX_${dir}v/${head}_${tail}.jpg" -o "XX_${dir}v/${head}_${tail}.jpg" touch "XX_${dir}r/${head}_${tail}.jpg" touch "XX_${dir}v/${head}_${tail}.jpg" done done for type in r v do output_dir=XX_$dir$type images=() for tail in {0..12} do images+=("$output_dir/"{0..9}"_${tail}.jpg") done echo montage "${images[@]}" -tile 10x13 "$output_dir/stitched.jpg" done done This just loops through 001 and 002 as an example and creates the output directories and empty files. (You'd replace the touch commands with the commented out curl commands to do the actual fetch). It just echos the generated montage command (You'd remove the leading 'echo' to instead run the command.). You may need to tinker with the montage options depending on the exact output you're trying to achieve. Hope it helps.
What i meant was that i was trying to use the @Basic bundle but remove remove ExtraTests in favor of RunExtraTests. Turns out I was confused about howt to use the filter plugin. This seems to work. The xt tests are being created (I am also using Test::Perl::Critic) The only thing is I don't get a message from dzil saying it is rewiting the xt/* tests like I did with ExtraTests. This is what I am now using. ===== ; [@Basic] ; Filter now adds it so exclude [@Filter] -bundle = @Basic -remove = ExtraTests option = for_basic [RunExtraTests] 
That's very generous of you to work out so much of that, I'll work on it today, I'll let you know if I can make it work out. Thank you again.
There are no bad releases just uncooperative authors, was my sentence, which you totally approved now. Everything on your 1.2.3. list CAN BE FIXED. Thats the point. As long as you are a cooperative author who fixes his stuff, then its no Bad Release...... just a Bug ;) 
There are plenty of jerks on reddit, it's a problem that all publicly accessible sites face. I don't see how banning someone will work when the jerk can just setup another account.
[Markdent](https://metacpan.org/release/Markdent) lets you inject filters into the process, and includes one to strip inline HTML.
I agree that trolls can set up new accounts and I'm sure they will. That being said, are you suggesting that we do nothing and we allow people to attack others, direct profanity at them, and (and in at least one case) make false accusations? You're perfectly correct that we can't stop this problem, but I'm happy to at least mitigate it. PS: I don't know who's downvoting you, but I didn't. Dissenting views are important.
I wasn't suggesting doing nothing, I was just pointing out that doing the only thing you can will do limited good due to the way reddit is built.
When you dont see the false accusation together with the correcting via the comments, then the false accusation can be spread again somewhere else, and noone can point to the disapprove. I mean thats how reddit works, you find most often a very good explaination of something based on a comment that someone said something that was just wrong. If its social, technical or whatever, all topics wander around that way. And if people are jerks, then this is listed via all their comments in the comments, you can see them being a jerk, if you remove that, then the information is lost and they can be a jerk again without the people seeing that they are always a jerk, as.... you know the posts are gone. And .... Profanity is defined by specific words, ban post with those words, nothing subjective here then. But I might be just too liberal here ;)
&gt; Working with decimal system doesn't actually guarantee a "right" answer. Humans are maybe a little bit biased to think that number system where fractions of 10 have exact representation are better than number systems where only exact fractions of 2 have. But that's the beauty of this approach (if I understood correctly): You can choose whatever base you want. You *can* represent 1/3 or 1/7 exactly!
Are those rules just going to apply here or are you going to act like /r/conspiracy moderators and ban people for things they do on other subreddits? For example /r/conspiracy moderators have banned people for just participating in /r/conspiratard.
&gt; Are those rules just going to apply here or are you going to act like /r/conspiracy moderators and ban people for things they do on other subreddits? No. This was discussed and rejected.
That's a really good find, thank you.
 wget --mirror 
Oh, sure. I mean, it's not a bad idea to have a type for rational numbers. I do think it's a bit daring to propose it as the default type for numeric literals, though.
First of all, thank you for taking the time to keep this forum jerk free – it’s appreciated. Feel free to draw a hard line, the Internet is rude enough as it is. One comment on the subreddit description though. As a non-native English speaker, I had to look “Dissent” up, so maybe a more commonly used phrase like “difference of opinion is OK” are better in this context for getting the message across (or maybe it’s just me). Btw while on the subreddit description - shouldn't it be “The Perl Programming Languages…”? 
Ah... my bad, I forgot that was a 4.0+ feature. You can try replacing `for dir in {001..339}` with `printf '%03d\n' {1..339} | while read dir`. $ printf '%03d\n' {1..5} | while read dir; do echo "$dir"; done 001 002 003 004 005 $ bash --version GNU bash, version 3.2.48(1)-release (x86_64-apple-darwin10.0)
umm .... man, i have a hard time getting worked up enough over code to be a dick to someone. I guess it takes all kinds. 
&gt; But if the API is right there, how much does an SDK really matter? Agreed, seems overly pessimistic. The Perl bull market has already turned, some bears just don't know it yet :)
There is a 3 dot range operator but it doesn't do anything different from the 2 dot form in a list context and is generally recommended to avoid because it is confused for the flip-flop operator.
Rationals are NOT the default type for numeric literals. These are the Numeric literals: 1 # Int 2e3 # Num (== 2000, floating point) 3 / 4 # Rational (== 0.75) 5.6 # Rational (== 56/10) 7+8i # Complex Imo, if there's anything daring going on with these it's that P6 is eschewing some forms of backwards compatibility with P5.
Yes, this is my own company's blog, but no, it's not my post. I just think it's a pretty useful thing for doing Perl in production environments.
I'm pretty sure that you end up with rationals in a lot of cases. I think you only have a case when talking about Int, but because even Int / Int ends up as a Rat, it's just going to happen a lot of the time. My point was really that I find it surprising that Perl 6 makes such an effort to avoid floating point values. You will have to actually work at it to generate a floating point number -- you either use them explicitly, or generate rational numbers until their denominator grows very large. It almost won't happen by accident.
Nice, thanks for the great tip!
I don't think you are using the latest cpan module. Just last night I grabbed this module and it wouldn't work until I took 'under_18' out of the qw// in `thing.pm`. Once I removed that, thinks moved along swimmingly though. 
&gt; I don't think you are using the latest cpan module Interesting. The article was written using version 0.8, installed from CPAN. It looks like the latest version to me. What OS and Perl version are you using?
That'd be it. It's broadly similar to how Apache::DBI works.
Interesting. So is this implemented on top of the interactive python notebook?
How negotiable? To be honest I think 45 USD/hr is very low for the skills you're looking for. Especially "analyzing Perl" sounds like "old code base, badly written, no idea how it works if it works". Teleworking possible? edit: you might want to post this to http://jobs.perl.org/ as well.
Interesting article, and I appreciate the desire to have a more active perl sub. However, I effing hate reddit bots. They're often slightly off-topic, way too wordy, and a little smug/know-it-all-ish. I get plenty of that from human redditors. I don't need it from a bot. 
&gt; curl -L http://install.perlbrew.pl | bash Well, it's dumb, and it involves a terminal. People: please don't pipe random HTTP responses into a shell.
[Principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege). Or as i like to describe it, the least moving parts a machine has, the sturdier it is. Having a full environment with a full Perl installation could be used by exploits. Pretty unlikely for a cron job, but look at all those exploits making the news the last few months. I'd rather not create new and exciting opportunities for this.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Principle of least privilege**](https://en.wikipedia.org/wiki/Principle%20of%20least%20privilege): [](#sfw) --- &gt; &gt;In [information security](https://en.wikipedia.org/wiki/Information_security), [computer science](https://en.wikipedia.org/wiki/Computer_science), and other fields, the __principle of least privilege__ (also known as the __principle of minimal privilege__ or the __principle of least authority__) requires that in a particular [abstraction layer](https://en.wikipedia.org/wiki/Abstraction_layer) of a computing environment, every module (such as a [process](https://en.wikipedia.org/wiki/Process_(computing\)), a [user](https://en.wikipedia.org/wiki/User_(computing\)) or a [program](https://en.wikipedia.org/wiki/Computer_program) depending on the subject) must be able to access only the information and [resources](https://en.wikipedia.org/wiki/Resource_(computer_science\)) that are necessary for its legitimate purpose. &gt; --- ^Interesting: [^BSD ^Authentication](https://en.wikipedia.org/wiki/BSD_Authentication) ^| [^Windows ^Installer](https://en.wikipedia.org/wiki/Windows_Installer) ^| [^Rule ^of ^least ^power](https://en.wikipedia.org/wiki/Rule_of_least_power) ^| [^Secure ^by ^design](https://en.wikipedia.org/wiki/Secure_by_design) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cogw6o5) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cogw6o5)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
tl;dr: no
There's also [App::Cronjob](https://metacpan.org/pod/App::Cronjob)
This position has a huge Turnover rate! Seems every few months the person leaves this position and the recruiters go crazy looking for replacements. To prove my point check monster and careerbuilder and you'll see this same position every other month!
I bought a few Packt books during the $5 end-of-year sale, and they've been hit-or-miss. Some were worth $5, and some weren't.
Sure but how does this simple wrapper violate that?
This isn't the only project to do this. Please don't pipe what you don't know.
Cron explicitly sets up a very minimal environment because tasks will run unattended by all system users. This is in order to minimize the chances that a script can be used to compromise the security of the machine. This wrapper undoes that, giving the script a full environment. Therefore subverting security measures of the operating system.
I feel sorry for Mr. Berdeaux, it sounds like he could have used more support from his publisher, especially if English isn't his first language. I also get that bad Perl is annoying, but the tone of this review reads as unnecessarily harsh IMHO.
Have you made any progress?
I like named parameters, especially when there are many optional ones. And even there I tend to split them into mandatory (positional) and optional (named). But if there are only a few and they are mandatory I don't see a big advantage in named arguments. It might be a little faster to read the call but a good IDE will help you there. On the other hand your hybrid function is harder to understand, a call is harder/longer to write and bugs are harder to find. 
Here is an argument in favor, in order to decrease coupling between interfaces and thus increase maintainability. My latest reading into this subject was Sandi Metz's "Practical Object-Oriented Design in Ruby" (http://www.poodr.com). Let's say we write an HTML DSL library. First iteration, I define a function "div": div($content) Over the next few months, several applications are built that make use of divs, but our clients complained about the lack of being able to style their divs via classes. So we support the class tag, and we do it smartly, expecting a list of classes. True to Perl style, this list is at the end of the parameter list, and also conveniently, this parameter has the easy default behavior of not being required: div($content, @class_list) Some of the apps update their code to start using @class_list. A month later, one of our clients says he would really like to violate separation of structure from style and directly specify style tags in his divs. Well, this new optional parameter presents an interesting problem. Where do we stick that new value? # We now have to smartly parse the last entry in order to figure out if it # matches typical style contents, decreasing general performance of div(). div($content, @class_list, $style) # Write and maintain complicated code that tries to allow people to use a # class named "style", check number of parameters, etc. div($content, @class_list, style =&gt; $style) # Users of @class_list must update every use of div() div($content, $style, @class_list) Every other option I can think of involves forcing @class_list users to update every use of div(). Oh! We can define a smarter div function: # Support $attributes{class_list} and $attributes{style} smart_div($content, %attributes) Now we don't break div() compatibility, but on the sad side, I had to define a separate function with a silly name. And we still have not handled the fact that DIVs can include more than one child element, meaning that we all along needed something like @contents instead of $content. Imagine if, from the start, we used named parameters, even for our simple first iteration implementation: # Initial release div(content =&gt; $content) # A few months later div(content =&gt; $content, class_list =&gt; \@classes) # That style request div(content =&gt; $content, class_list =&gt; \@classes, style =&gt; $style) # People are building more sensible web apps div(content =&gt; $content|\@contents, class_list =&gt; \@classes, style =&gt; $style) Named parameters can be optional, we do not break compatibility that requires coordinated rollout, we do not play funky parsing games (except maybe detecting that $content is an array ref), and we can use the same cromulent name for our API. Edit: Looks like the author presents a similar opinion. Hopefully my example here shows the real horror of positional parameters.
Yes, but here you only have optional parameters and, as I said, I like named parameters in this case. But in update_shopping_cart a cart_id does not look optional. And I find a call update_shopping_cart($cart_id, $item, $quantity); quite readable. So if I would extend this function with $apply_discount I would ask myself if I have access to all calls made to the function. If yes: extend all calls with the parameter. After that you can be sure that nowhere a discount gets lost for the user accidentally. If no: add an optional arg update_shopping_cart($cart_id, $item, $quantity, {apply_discount =&gt; xyz}); calls with named parameters everywhere mostly look like name =&gt; $name # just the same with a $ prefix on the right side. If you REALLY have situations where you want to call it with a constant instead of a variable you can create one. update_shopping_cart($cart_id, $item, QUANTITY_ONE); 
Yes, the author noted that adding a parameter might be a good reason for named parameters, and there are certainly multiple approaches for that. But what about changing a parameter? update_shopping_cart($cart_id, $item, $quantity); It's notable to me that the first parameter is $cart_id and not $cart, that the second parameter is $item and not $item_id. Maybe we pass a whole object to one and not the other, and it turns out that there is a performance hit with this because we have to query a database in order to get the object for $item. To fix the performance problem, we want the API to look like this instead: update_shopping_cart($cart_id, $item_id, $quantity); Unfortunately, this function is presented in a package used by a bunch of clients, half of which we are not even aware of (same scenario applies for large legacy codebases); do we break backwards compatibility or present a completely new and performant function instead? Or should we just do the named parameter thing from the start, and you can supply either "item =&gt; $item" or "item_id =&gt; $item_id"? update_shopping_cart(card_id =&gt; $cart_id, item_id =&gt; $item_id, quantity =&gt; $quantity);
TIMTOWTDI: sub update_shopping_cart { my ($cart_id, $item, $quantity, $apply_discount); if ( ref $_[0] eq 'HASH' ) { ($cart_id, $item, $quantity, $apply_discount) = @{$_[0]}{qw(cart_id item quantity apply_discount)}; else { ($cart_id, $item, $quantity) = @_; $apply_discount = 0 } 
Out of curiosity, is there a market for Perl 6? 
I think so. My personal top 4 features (not all of them quite there yet): * grammars * grapheme-based Unicode * parallelization * perl5 interop 
The optional manifest typing is also really nice.
&gt; I'm also pretty excited about the fact that it may one day run in JVM Just to clarify, it already runs on the JVM right now.
Developers and companies invest considerable resources into their chosen platforms, and most platforms have "competing" alternatives, so I think technologies can be usefully viewed as a market. 
nope. There was a market at one point, but it took to long. Now the market is saturated with languages that live in the exact same space. Python - a direct competitor has much better press and has the support of academia - recently surpassing Java as the most popular teaching language. In a few years, most college grads will be comfortable with Python, and they will implement Python on their projects at work. A lot of companies have a Perl5 code base, and they will need to maintain that, but most will use Python for newer projects. The cost of learning Perl6 doesn't make sense when you have legions of college students learning a competing language that is also really good. 
Give yourself a few years. When you have people who write code in such a way that it causes you real problems in employment then you may not be so passive and tolerant.
Brilliant, thanks. For what it's worth, I'm on Linux and installed raduko through that, but haven't had a real play yet.
Thanks for the pointers. Everything is 64 bit because this isn't 2005;-) I am using the apt-get versions, just because I'm dabbling at this stage, but I bet there's an easy way to get updates in Ubuntu through PPAs. When I do something properly serious I'll make sure it's current. I also need to look into building perl6 module packages for Debian, I've done a good few for perl 5. I will like to see how it evolves, even just at the VM level. Good that it's test-case stable.
Until I read this interview, I would have said "no". But something Larry said here changed my mind: &gt;&gt;So early on, our slogan, or at least one of them, was "Second System Syndrome Done Right." And how do you do that? Well, you just have to take long enough. You could say that most languages try to solve the same problem, and they often succeed rather nicely. Take Python for example. But Perl 6 tries to go beyond that. These languages all have problems, most of them even the same problems, and Perl 6 tries to solve those. And, if you may believe what Larry is saying: it succeeded.
Probably. 
your wrong about [Python being taught at Universities](http://www.pcworld.com/article/2451880/python-bumps-off-java-as-top-learning-language.html) Python will grow like Java did in the late 90's. R and Matlab are great at the nich that they fill, but they are not all purpose languages. 
You can [specify a type](http://doc.perl6.org/language/variables#Type_Constraints_and_Initialization) at declaration, if you want to. my Int $x = 42;
On OSX if you user homebrew: $ brew install rakudo-star --with-icu4c It builds the moar backend automagically. Did it last night after reading what Larry says and started going through the little tutorials.
Your speculation lines up pretty well with my speculation. I think Python, Ruby, and Perl are substitutes, with Python having more momentum due to adoption for teaching, a lead among scientists, and perhaps a lead in adoption by large organizations (i.e., Google, NASA). Unlike Python 3, Perl 6 seems non-incremental, so it will be interesting to see what happens. 
 if ($sec &lt; 10) { $sec = "0$sec"; } if ($min &lt; 10) { $min = "0$min"; } if ($hour &lt; 10) { $hour = "0$hour"; } if ($mday &lt; 10) { $mday = "0$mday"; } : : if ($isdst &lt; 10) { $isdst = "0$isdst"; } $DateTime = "$year-$mon-$mday $hour:$min:$sec"; The if statements can be removed, and the following takes care of the desired formatting: $DateTime = sprintf '%04d-%02d-%02d %02d:%02d:%02d', $year, $mon, $mday, $hour, $min, $sec Or better, use Time::Piece. 
But...as minimim said: &gt; Other languages already have it. You don't have to look forward to using it. Only in the context of using Perl.
To let Perl shine to others that do not know Perl I would do some slight changes #!/usr/bin/env perl use warnings; use strict; use English; my %word_in_lines = (); while (my $line = &lt;STDIN&gt;) { for my $word (split(/\s+/, $line)) { push @{$word_in_lines{$word}}, $INPUT_LINE_NUMBER; } } EDIT: Some suggestions by http://de.reddit.com/r/perl/comments/2vr5ka/how_to_write_hashing_in_a_nice_way/conwz5m #!/usr/bin/env perl use warnings; use strict; use English; my $word_in_lines = {}; while (my $line = &lt;STDIN&gt;) { for my $word (split(/\s+/, $line)) { push(@{$word_in_lines-&gt;{$word}}, STDIN-&gt;input_line_number); } }
There's really no sense in doing `= ()` when declaring a hash. That just sets up some kind of misguided expectation that hashes need to be initialized when they don't. It's certainly not idiomatic. 
No it is not necessary. The sense was to clarify that this is not a kind of a scalar but a more complex data type. The goal was "readable for colleagues who do not know Perl" not "write idiomatic Perl" If you never saw Perl but you know { } for a code block you see something like: while (line = STDIN) { for word (split(line)) { push word_in_lines word INPUT_LINE_NUMBER; } } So I think it would all be clear to me except the line with push that is the most complicated. So if you know you put a line number to a kind of complex data type that has to do with word, I think it could help
&gt; Every other option I can think of involves forcing @class_list users to update every use of div(). div($content, @classes) div($content, \%named_params) should work?
&gt; able to maintain software where did you read that? You sometimes have to read code in a language you will never maintain nor learn. 
Not sure if it matters for the OP's example, but &lt;&gt; is not the same thing as &lt;STDIN&gt;. &lt;&gt; first reads contents of any files listed after the command: perl foo.pl foo.txt bar.txt # would read from foo.txt and bar.txt If no files are specified, it reads from STDIN. This provides a really concise way to behave like a lot of unix tools, like cat and grep. In fact, it may be argued that in cases like this where there is not a strong need for interactive input, one should prefer &lt;&gt; over &lt;STDIN&gt; whenever possible in order to keep tools intuitive, to match expected and familiar behavior.
When you say "it" do you just mean "optional manifest typing" without regard to the details of what that means? Dylan is one of the 9 langs currently listed on [the wikipedia page for langs with "gradual typing"](https://en.wikipedia.org/wiki/Gradual_typing). But, as the leading Dylan dev Bruce Michener wrote in January, [Dylan's "optional manifest typing" isn't at all equivalent to the "gradual typing" discussed by Jeremy Siek](http://dylanfoundry.org/2015/01/20/dylan-and-gradual-typing/). So, what lang(s) have you used that have their take on optional manifest typing that you think is equivalent to P6's implementation of its take on gradual typing?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Gradual typing**](https://en.wikipedia.org/wiki/Gradual%20typing): [](#sfw) --- &gt; &gt;__Gradual typing__ is a [type system](https://en.wikipedia.org/wiki/Type_systems) in which [variables](https://en.wikipedia.org/wiki/Variable_(computer_science\)) may be typed either at [compile-time](https://en.wikipedia.org/wiki/Compile-time) (which is [static typing](https://en.wikipedia.org/wiki/Static_typing)) or at [run-time](https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase\)) (which is [dynamic typing](https://en.wikipedia.org/wiki/Dynamic_typing)), allowing software developers to choose either type paradigm as appropriate, from within a single language. &gt;In particular, gradual typing uses a special type named *dynamic* to represent statically-unknown types, and gradual typing replaces the notion of type equality with a new relation called *consistency* that relates the dynamic type to every other type. The consistency relation is symmetric but not transitive. &gt;Prior attempts at integrating static and dynamic typing tried to make the dynamic type be both the top and bottom of the subtype hierarchy. However, because subtyping is transitive, that results in every type becoming related to every other type, and so subtyping would no longer rule out any static type errors. The addition of a second phase of plausibility checking to the type system did not completely solve this problem. &gt; --- ^Interesting: [^Hack ^\(programming ^language)](https://en.wikipedia.org/wiki/Hack_\(programming_language\)) ^| [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Manifest ^typing](https://en.wikipedia.org/wiki/Manifest_typing) ^| [^Nominal ^type ^system](https://en.wikipedia.org/wiki/Nominal_type_system) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cokaxxu) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cokaxxu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Pay your own way and use the networking opportunity to find a better employer. ;)
I neglected to mention that I'm also married. Some employers are stricter than others. 
Yeah, the Perl code needs some modernizing :-). The if ( ... &lt; 10 ) { ... = "0...." } is something that I have seen several times in code written by others. It's like a common idiom to people who don't know (s)printf, I guess. Another horror I saw recently was in a locale where '.' is a thousands separator to divide the result by 1000 and use %.3f... 
In my opinion: don't put in comments what can be gathered from the excellent (!) documentation that comes with Perl. If you have to explain code at that level for your coworkers either you or they are in the wrong job ;-)
The call for talks closes on March 1. After that the submitted talks will be combed through before the list gets posted. HOWEVER, we do know that Larry Wall will be having a Q&amp;A session about Perl 6. You can expect that to be wildly popular.
Thank you so much!
Came here to say that (Data::Dumper), and to learn how to dereference hashrefs and arrayrefs, as well as loop through both. If you can get that down, most things like Reddit::Client and a ton of other perl modules that work with data structures become second nature.
Thank you!
No. That's not a new hack. That's the data dump from last years hack.
Thanks!
&gt; I would like to be able to run the second script that can access the array without having to load the array from the text file each time. What you are asking for is a database. I recommend PostgreSQL. If this is not what you're asking for, you need to specify your problem more exactly. *Why* does this second script need access? What is the main script going to be doing once the data is in memory?
Thanks, I have tried certain implementations with a database too, but the reason for not using one is that I am doing some pretty detailed text similarity analysis, and so far, I have a had to still load the data from the database into a BIG perl array to accomplish this. The module I am using so far is Text::Similarity What I am doing is getting a term from input, seeing if there is an exact match, if so stop, if not break up the term in various ways to see if now there is a match. If not match use text similarity analysis to find the most likely candidates. When I am using a DB, I am using mysql as a database and when I have tried to use Levenstein analysis, for example, it's really slow ... if it doesn't bomb. And the problem is that I need some pretty sophisicated logic for parsing and repeat analysis ... this would be hard if not impractical in SQL. 
Thanks I will check this out. 
Thank you, What I don't understand about the database suggestion is that I would have to parse and/or load everything up every time the program is run. My understanding is that something like DB_File stores things in key values pairs. So in my case I would have a big array where the key is the array index (or line number) and then the value would be the line that was read from the text file when the db was created. However, there are some other fields in the source text file. So I have to parse the value. Does this imply a second array? From the docs, I think i would do something like this use DB_File; tie @array1, 'DB_File', $filename, $flags, $mode, $DB_RECNO ; while &lt;@array1&gt; { push @array2, parse($_); } while &lt;&gt; { $term=$_; foreach(@array2) { say field2 if (complex_conditionsmet_compare_to_field1($term)) } } I had thought that something like "Storable" --- if I retreive from a file --- would have the data already in an array-of-hashes-form once it's stored. So wouldn't something like that allow me to work with just one array? 
&gt; Why does this second script need access? What is the main script going to be doing once the data is in memory? To answer that more specifically, Initially I was wanting a CLI app where the user could do something like this: %&gt; put_big_array_in_memory_once_for_all (what you call the main script, its only function is to keep the array in memory.) %&gt; search_through_big_array &lt;term1&gt; ... output %&gt; search_through_big_array &lt;term2&gt; ... output %&gt; search_through_big_array &lt;term3&gt; ... output 
OK thanks for your explanation. I will read up more. &gt; Anyway, the basic pattern in the code you've shown where you linearly search through an array sets off loud alarm bells. That's going to be a very bad idea if the list gets big. You probably want to formulate a data structure of hashes or sorted lists. Yeah, I hear the bells too. The issue is that the the texts in question are irregular with lots of potential variations or mistakes in spelling. So the matching isn't as straightfoward other projects where I use structured databases. I have experimented with an inverted index of words and other strategies to pair down the number of records that need to be examined. 
OK here's where i'll be looking first. http://www.sai.msu.su/~megera/postgres/fts/doc/ and then more specifically regarding perl functions.
Another idea would be to use [DBM::Deep](http://metacpan.org/pod/DBM::Deep). It is a database for perl data structures. 
Thanks the clustering looks pretty rad. I'll have to look at this in more detail. 
No problem
I have some ideas on how to use this for code completion. I just need to sit down and think about the design.
I do my $config = do "config.pl"; die $@ if $@; I don't save config programmatically though. I'd have to use Data::Dumper or something and that sucks balls.
Why not use one of the standard software packaging systems? For example, RPM.
[my](http://perldoc.perl.org/functions/my.html) short critique.
The Perl is a bit strange but this is the point where I really did a double-take: &gt; A friend of mine asked me if there was a way to send the same 200 tweets over and over again, spaced out every 20 minutes or so. This is where you say "technically yes, but that is a *terrible* idea".
If you used a hashref instead of a hash, more people would likely cotton on to it if they had experience in either any of Ruby,JS or Python. my $x = {}; for my $i ( 0 .. 200 ) { $x-&gt;{$i} = "A Value"; } That code block should intuit to anyone with any experience in the above "There's some kind of data structure, maybe an array, maybe a hash, and they set a key to a value" Its just "Push" syntax that is likely to be confusing, but I don't see how you're going to get around that without something like autoboxing. $array-&gt;push( $item ) Is clearer to many people, so maybe you could just write your push # $lines_for_words-&gt;{$line}-&gt;push( $word, $INPUT_LINE_NUMBER ); push @{$lines_for_words-&gt;{$word}}, $INPUT_LINE_NUMBER; Though I'd be tempted to track the line number manually, because: - `$.` is a bit magical and prone to being wrong if you get IO happening in other scopes - `English` is a wart that should die. - Other languages don't have such a concept of "global line number". At least, you should probably use an IO::Handle method like: STDIN-&gt;input_line_number 
Personally, I use exists instead of relying on auto-vivification, because it makes intent clearer. And it also makes it clearer to the code where the array is **expected** to be created. Because you could very well expect the array to come into existence in some other context, and be only extending it when it already exists. This subtle difference is enough to let subtle bugs creep in. And some of this is why [`no autovivification`](https://metacpan.org/pod/autovivification) exists.
That was one of the basic tricks behind http://search.cpan.org/~swalters/autobox-Bless-0.02/lib/autobox/Bless.pm Edit: Except that the pad entry, which is a reference, is blessed, and I got my hands on it thanks to autobox's magic. So kind of the opposite of going from blessed to unblessed =)
If you're going to share examples of Perl code, then it's probably a good idea to choose ones that actually compile. There's an important difference between "Print" and "print".
If anyone is wondering how this could happen, here is the same thing without bless mixed in (assume strict, warnings, etc): sub foo { $_[0] = 9; } my @arr = (1..5); say join " ", @arr; # 1 2 3 4 5 foo(@arr); say join " ", @arr; # 9 2 3 4 5 We are accessing the place in the array. In the author's code, $f was on the left side of the arrow, making it the first (and in this example, only) element of @_ passed to the me() function. Basic element-in-array assignment changed the value of $f.
I do generally agree with this but use cases matter. Sometimes it takes a long time to generate the files and having quick access to them matters.
Regardless of whether you version control them or not, this is a very helpful article in explaining in one place how all these file types come about.
And having to install a mountain of dependencies to generate the file doesn't help a bunch. Especially if you're optimising for contributors.
I frequently keep generated files as checkpoints in the QA cycle. Previous test results are used as validation of future test results.
Please give me a use-case that can be turned into an article. (e-mail would be fine)
That sounds unrelated to the content of the article. Of course there might be lots of "expected test result files" kept in the repository.
Perhaps in the USA. In the UK and the three universities I've worked at it's certainly not true, at least from my first hand experience. Python is established but not growing fast (i.e. in "decline" like Perl) by most of the "metrics" people use to judge such stuff. It really is being pushed out by languages like JavaScript now that there are trendy server side distributions and most software is written for the web. Python also isn't present on any of the mobile platforms as a core language, so again Java is most definitely still taught at universities even if they also teach Python. With regard to your link I think the distinction between "teaching language" and "teaching a language" should be brought up too. Pascal or Logo are "teaching languages" but students aren't taught Pascal with the expectation they will use it for their job. Java is a horrible teaching language, but a language that is quite necessary to teach if you want your students to have good job prospects. Python already had its decade of growth... So I think you are kind of skipping over the last ten years. I'm doubtful Perl 6 could get to be as successful as Python, not unless a lot of Perl 5 people care about making that happen. http://www.tiobe.com/index.php/paperinfo/tpci/Python.html
For science I think Python is very much a goto language sure. But so is FORTRAN in certain fields. That doesn't really say much about large scale adoption. I think Perl 6 has a good chance of pulling off being the FORTRAN of Bioinformatics, at least that's something I would like to see happen. The "Google use Python" argument is always kind of fun. Obviously Google don't use Python for most of what you actually use every day. The perf is miserable compared to their other official languages and the concurrency model not great. It's officially their scripting language I imagine line for line sysadmin/ops type stuff will be Python. I'd be interested to be proven wrong on that by someone who works there.
explain what you think the market for Perl 6 is.
a better scale then tiobe is [indeed trends](http://www.indeed.com/jobtrends?q=Python%2C+Perl&amp;l=). This reflects the actual job market for programming languages. Python is a "general purpose" language. It can be used for web development or by sysadmins and by everyone in between. Javascript is a one trick pony. It has popularity because of its use in Web Development, but nobody would use it for anything outside of that. Java, I agree is a horrible teaching language, however it became popular/trendy because it was a good OOP language, that had an enormous API, ran on every platform, and was fairly easy to get students writing code quickly. As students graduated, they naturally implemented projects in the language they were most comfortable with .. Java. THAT is why java is everywhere. The same holds true with Python. It is a popular teaching language. It will be as prolific as Java in a few years. Of course, something even better may come along. who knows.
"The release" is about the Rakudo Perl 6 compiler running on MoarVM, and it is about the Perl 6 language test-suite, which a compiler has to pass in order to get called "a Perl 6 compiler". We cannot promise that we can implement the missing bits and fix all important issues by then *and* port all of that over to other backends like the JVM or Parrot. That is the reason why Larry gave us his blessing to focus on one backend to reach our goal.
I dunno even the indeed trends don't look incredible to me.. Also the Python and Ruby trends are incredibly well correlated which suggests it is about the web to me. http://www.indeed.com/jobtrends?q=Python%2C+Ruby%2C+PHP%2C+Perl&amp;l= I'd say the decline in Java is more to do with Go given the Indeed data too! http://www.indeed.com/jobtrends?q=Java%2C+C%2C+Go&amp;l= Though on second look thats probably any word 'Go' rather than the actual language being mentioned :S since the start date is since before Go was released :D So perhaps not the best data ever. How many python zookeeper adverts are there I wonder? lol
maybe he's going for just a short summary, but I think some examples would be very useful for getting the point across. Here is a simplified example where you could use redo: my @methods = qw ( ssh telnet ); my $hostname = 'steve'; my $alt_hostname = 'notsteve'; METHOD: for(@methods) { my $err = $self-&gt;connect($_, $hostname); # if host lookup fails try the alternate hostname if ($err) { if ($alt_hostname) { $hostname = $alt_hostname; $alt_hostname = undef; # retry the same protocol (ssh or whatever) redo METHOD; } else { warn "Unknown host: $hostname"; # no point in trying telnet/next protocol if the host doesn't exist last METHOD; } } }
SublimeText is a good editor -- not quite an IDE, but I think has all the features you really need to code perl when not using vim.
Thanks for the encouragement! I am learning Perl's utility as a compliment to bash scripting for Linux System management. Any links or tips in that direction would be invaluable.
If you are using Linux distribution you can try kate
Higher Order Perl and Perl Best Practices are my must reads. The former is by far the most interesting, but the latter fundamentally changed and the way my team and I write Perl, and dramatically improved quality. But if you're new to the language, those might not be what you're after. Try Chromatic's Modern Perl book. 
oh yeah, 'perl dash pie' was one of the first things I was ever taught about Perl, I think. Super useful.
Not to diminish the OP's enthusiasm, but the code is pretty dangerous. What if `jaas_snippet.xml` contained the text `#; system "rm -rf /"`? Better to store the text into a Perl variable, and use single quotes in the shell, eg: perl -pi -e 'BEGIN { $snippet = shift } s#&lt;!--\sEND\sjaas\s--&gt;#$snippet\n\t\t&lt;!-- END jaas --&gt;#' "$value" jaas.xml
I used the general concept. For my script I am taking user input, stored in a bash variable and added to the xml file with Perl. Thank you for the input. Would you recommend using a Perl variable instead, in the fashion you have shown? 
As mentioned, [chromatic's Modern Perl](http://onyxneon.com/books/modern_perl/) is available for free online (and if you like it, you should really buy it).
+1 for [SublimeText](http://www.sublimetext.com/2). It's the only thing to date that has ever pulled me away from Vim.
With the LICENSE I might agree, because you generate it once and it normally does not change later. OTOH a README that is generated from the POD should not be in the VCS as that will change during the release process. But I am not sure what should be in a README. See http://blogs.perl.org/users/brian_d_foy/2015/01/what-should-be-in-a-cpan-distro-readme.html for further wondering.
whats this
Higher Order Perl is also available online from the author's website http://hop.perl.plover.com/book/
You can also do the catting from within Perl itself using the `e` modifier of the `s` operator. $ cat jaas_snippet.xml &lt;new&gt; XML here &lt;/new&gt; $ echo 'foo &lt;!-- END jaas --&gt;' | perl -pe 's/(&lt;!-- END jaas --&gt;)/`cat jaas_snippet.xml` . "\t\t$1"/e' foo &lt;new&gt; XML here &lt;/new&gt; &lt;!-- END jaas --&gt;
no love for Kate ? I just started using sublime today in windows, it is indeed a very nice editor.
I use perl -E now since optional features include 'say' which is useful for one liners.
Kind of depends what you want Perl for. If you want to be a software engineer in Perl start with ModernPerl. Its likely representative of expectations for your code and knowledge.
Never tried Kate (my primary OS with a GUI is Windows, and tbh Kate for Windows at least looks a little hideous compared to ST). That said, I'm open to anything, can you give me some compelling reasons why Kate would pull me away from ST2 (in the same wrenching manner ST2 was able to do so from Vim)? I'm totally open to giving it a shot, but a Windows distribution of it needs to greatly enhance my ST2 experience if I'm going to consider making the leap.
I will probably go back to that. I was originally working in Sublime/vi. I'm trying to pick up vi at the moment. 
Seconding PBP. If I were to choose a single must-read book, that's the one. It has some dated parts (in particular OOP should be done differently now), but the general attitude is right.
For a gentle introduction to Perl I suggest Learnig Perl 
That book [really isn't very good](http://perlhacks.com/2015/02/penetration-testing-perl/).
Please test if you're a user of CGI.pm, thanks!
I really love your second suggestion, "Beginning Perl" by Curtis Poe. For a beginner, I think it's the best, plus toward the end, it has some introductory coverage of many valuable intermediate topics (Moose, ORM's etc.) I would recommend chromatic's (excellent) "Modern Perl" for anyone who already codes in Perl, or is intermediate and above in another language. "Perl Best Practices" is good for a team to read, to bring up the average level of the group (not too necessary for an individual who already knows how to write maintainably). "Perl Testing" is great. "Advanced Perl" (both editions, different authors) were for me "just okay" (the second edition being vastly improved). Hey brian d foy: "Mastering Perl" is fantastic! Both editions. But tsk-tsk on O'Reilly's lax editing because it's "gerry rigging" rather than "jury-rigging" (how they could miss it in the second edition is hard to understand). It's been a fantastic resource for me, over and over.
Thank you for this; I did not realize there was a second edition (2010) after the excellent 1998 original.
http://i.imgur.com/41MjWaG.jpg ;) Still, good work :D
Perl 6 is a sibling language (think C++ vs C) and not in production yet anyway. For what you want, focus on Perl 5.
This is so exciting! Perl 6 set a very high bar and spend the time and effort to reach it. Every step along the way has been a beautiful adventure!
You might like the book [Data Munging with Perl](http://perlhacks.com/2014/04/data-munging-perl/). It is a free PDF. :-)
I use emacs -nw and tmux. And lots of ack. The occasional dose of PPI
&gt; http://i.imgur.com/41MjWaG.jpg Heh, fortunately i get to work with Mojolicious, DBIx::Class, Moo, et al in my current job so it's not just coding like it's 1995 for me.
Meh I quite like the current Perl6 package management its a lot less fiddly than CPAN and I dont need some Perl specific login or tools. That said work is already underway for Perl6 code to happily reside in CPAN.
You can read the perl521Xdelta for all the details (since perl5220delta hasn't been written yet). My own summary of the stuff that's notable: * Unicode updated to 7.0. * The double-diamond operator. Basically, `while (&lt;&lt;&gt;&gt;) { ... }` is like `while (&lt;&gt;) { ... }` except it opens each item of `@ARGV` with three-arg open instead of two-arg open, which means it doesn't provide a means of command execution through `@ARGV`. * `open my $fh, '-|', @list` and `open my $fh, '|-', @list` are finally available on Windows after 10 years or so, subject to the usual caveat that Windows commandline arguments actually *aren't* a list, they're a string and therefore subject to interpretation. * Experimental aliasing by reference: `\$x = \$y;` makes `$x` and `$y` aliases; `\@x = \@y;` does the same for `@x` and `@y`. You can also write for \my @array (@array_of_arrays) { push @array, 42; } instead of for my $arrayref (@array_of_arrays) { push @$arrayref, 42; } which is pretty cool. See [the bleeding-edge perlref](http://search.cpan.org/~xsawyerx/perl-5.21.9/pod/perlref.pod#Assigning_to_References) for all the details. * `OP_MULTIDEREF` makes constructs like `$foo-&gt;{baz}[$x]{name}` faster (as long as all indices are either constant or simple variables). * Miscellaneous performance and security improvements. * A bunch of things that were deprecated in previous releases are now removed.
&gt; The double-diamond operator. Basically, while (&lt;&lt;&gt;&gt;) { ... } is like while (&lt;&gt;) { ... } except it opens each item of @ARGV with three-arg open instead of two-arg open, which means it doesn't provide a means of command execution through @ARGV. I wonder why this wasn't just a change in the normal &lt;&gt;, unless they were worried it might break a few programs. It would be nice if this was enabled through a pragma "use feature doulblewingwang;" or whatever so it could be enabled for single diamond programs and it's effects tested.
I tend to use readline instead of &lt;&gt;, do you know if there is a more readable way to use the new operator?
&gt; A bunch of things that were deprecated in previous releases are now removed. *"Oh God, what broke this time?"* I'll wait for the full list before deciding whether 5.22 is a step forward, backward, or sideways.
If it hasn't been giving you warnings every time you used it for at least the past 2 years and probably more, it still works. Some of the removals: * `defined(@array)` and `defined(%hash)` (deprecated since 2000) * `@array-&gt;[$idx]` and `%hash-&gt;{$idx}` in place of `$array[$idx]` and `$hash{$idx}` (deprecated in docs since who knows when, gave warnings since 2002) * Some operators let you leave off the sigil for hash and array names, e.g. `push array, $val` and `each hash` instead of `push @array, $val` and `each %hash` (deprecated since 1994!) * `?foo?` match-once regexes (deprecated since 2011; `m?foo?` still works) * importing methods from `UNIVERSAL` into your class (deprecated since 2010) The 2 years thing is official policy; the stuff deprecated in 5.22 won't be removed until at least 5.26.
FWIW there's a [branch of the module installer](https://github.com/tadzik/panda/tree/CPAN) that can install Perl 6 modules from CPAN. PAUSE [processes Perl 6 uploads to CPAN](ftp://ftp.cpan.org/pub/CPAN/authors/p6dists.json.gz). And [Inline::Perl5](https://github.com/niner/Inline-Perl5) makes much of the p5 CPAN available to Perl 6 too.
Good. I get tired of all of the Google search results taking me to the inferior version.
IMO, PHP's class system is better structured than Perl's... and that's pretty much the only thing PHP got right.
Awesome! I knew about Inline::Perl5, but not the CPAN support. One thing I like about putting everything on CPAN is the you get distributed mirrors and the ability to create a minicpan easily. So many other languages can't do that **and** the language developers of those languages can't easily test to see if their latest changes break any packages. Plus, package authors can easily find all their downstream dependencies. *That* is super useful.
Bullshit (from a guy who did 15&lt; years PHP)
So you don't think PHP got its class structure right or are you saying that somehow the massive inconsistency that is its functional library is somehow well designed, despite pretty much everybody saying it's not? And this is of course coming from somebody with a self-proclaimed experience level of somewhere between no experience and just under 15 years of experience. I'm not sure you used your operator in an intended fashion.
From looking at your comment history, it seems as if you suck on half a lemon every single day. You must be a load of fun at parties.
I find Perl much nicer than PHP. But I think a list like that you can create for every language that has its age. Over the years every language has its skeletons in the cupboard
Fumdamentally the interface is terrible. Now that I dont have to care about mod_perl at work any more (thanks to 6 months of high intensity effort) I'm directing all of my hate towards CGI.pm. 
We're just spewing warnings at the moment. All good incentives to maintain the rage. 
Just to explain it for a 5 year old: Rasmus politics underlined: "Bugs has to stay in if fixing would break flows who need that bug"... just to say ONE sentence that leaded to that crap..... The other sentence: "We can't optimize this, else Zend can't sell their products, we can't add this commit"...... THIS IS NOT HAPPENING ON OTHER LANGUAGES..... this is PHP UNIQUE..... no other language is influenced by an egoist retard alone or a huge giant company who influence all decisions..... And that happened FROM START ON...... Just checkup HipHop and you see how fucked up the language is, please INFORM YOURSELF, instead of saying bullshit sentences, this gets really annoying
I am no fundamentalist, i have worked with PHP long enough to know it. We talk about facts here. I have given you a list, you dont have a list. Yes you are for sure not old enough to discuss shit. You are just "believing" you are right, i am KNOWING i am right, cause I can list prove, i have the experiences with all languages in production, i have no idea what the shit you talk about.
Just to point out the little detail: This list i showed you is not listing BUGS, its listing DESIGN FLAWS..... try to setup the same list of DESIGN FLAWS for other languages.... please do so, and when you are back, we talk like adults, ok? Can you do that? &lt;taponhead&gt;
Every language has design flaws but I don't have a design flaw list for every language in my pocket day and night. What I remember for Perl: - Arrays flatten (a point that also admits Larry Wall) - Broken Exception model (at least you can rely on $@ on latest versions, but it's best to install an exception model) - Broken OO-Model (if you want to set up something like an ORM you have to decide what OO-Model you install first) - Manual references (nice blog http://benwingtech.blogspot.de/2010/07/perl-sucks.html) Or the last thing I stumbled in Delphi. (a very conservative language with priority to the language design as a teaching language) When to set a ";" if x &gt; 0 then y := 1 // No, never before else! else y := 2; ... case x of 0: y := 1; // at least most times else y := 2; ... function name (oFeld: TField): String; // Yes, after function declarations begin ... Func := function(oFeld: TField): String // at least most times begin ...
This is what I ment with fundamentalists. This are no design flaws, you are just to stupid to use it correctly. Or as Steve Jobs said about the loss of signal at the iPhone: The phone is fine, the users were just holding it wrong!
I'm not sure if you were around before they invented "late static binding". But nothing about needing it, or the reality of the nature of PHPs OO after adding it, strikes me as "Right" Everything about this page just reeks of failure. http://php.net/manual/en/language.oop5.late-static-bindings.php
Thats a poor equivalence. Removing a feature because users find it confusing simply deprives you of utility. And when the majority of intermediate and advanced users are just fine and dandy with it, and understand how to leverage it to do great things .... its not really a design flaw is it? The opposite hyperbolic argument is to assert that because language A does something different to language B, that one of them has to be wrong. And thats the case with many features. Many are "trade offs", and make novice adoption harder, but allow experts to do more things. Sometimes features exist that frustrate novices and experts alike. _THOSE_ are design flaws. And Perl has some of these which we encounter all the time, and we progressively eliminate them. For instance: `open FH, "$path" ` is a design flaw IMHO. Not because its problematic for usage, but because its a security hole waiting to happen. There's no "right" way to use that safely. ( Unless by "Safely" you mean "Potentially execute arbitrary programs as root if the perl script is setuid" ) And we've countered that with 3 arg open. Global file handles are also a design flaw, and we're countering that with local-variable ones. `while(&lt;&gt;){ }` is a design flaw, because `&lt;&gt;` is implemented in terms of `open FH, $_ for @ARGV` which invokes the problem with executing arbitrary programs. And we're countering that with the introduction of `&lt;&lt;&gt;&gt;` in 5.22. **EDIT**: Hah, I appear to have warned you of `&lt;&gt;` twice now in 2 different threads. I'm not always good at tracking people :p 
Also, author of linked article missed some serious fundamentals. Has obviously never heard of "warnings", despite the fact enabling them has been standard fare for a long time now. Yes, its annoying that we have to turn them on manually, but its a legacy compat problem. Most of his errors show he doesn't understand what he's doing on even a basic level and is simply expecting perl to function like a different language entirely. Doing `+` on strings casts them to numbers and does math on them. He wants `.` for concatenation. That's a very *basic* thing, and arguing otherwise is basically "I didn't learn, and didn't realise it was different" grade problem. That's like bumbling into haskell and wondering why it doesn't work when you type python code into it.
Could any of those %ENV vars also evaluate to false, realistically?
It's a file glob operator, which is implemented using [File::Glob](https://metacpan.org/pod/File::Glob). It's matching filenames in the current working directory. The `{}` would usually be used to match multiple possibilities; `&lt;*.{c,h}&gt;` would match files ending in both `c` and `h`. The `?` matches a single character (not to be confused with its use in regexes). Since it's in scalar context, it will iterate over the list of matched files, which allows `while` to loop over them.
Those are not design flaws, they are design *choices* :)
what answer do you expect? What do you think is wrong with the result? I don't see any entry called "Fluffy", FWIW. Also, you might find it easier to read your hash values if you use the arrow initialization syntax: http://www.tutorialspoint.com/perl/perl_hashes.htm
Sorry, I didn't express it clearly enough. I get Global symbol "$key" requires explicit package name at 4a.pl line 39. That'd be the line "if (exists($pets{$key}))" and syntax error at 4a.pl line 40, near ") {" whitch should be the end of the same line and following line "}" 
&gt; my $key = "Fluffy" Missing semicolon. Other than that, it seems fine, it should print 'NO!' as expected? 
That's it! Thank you! I got totally blind looking at the this code... 
What kind of data?
There are some simple examples of data transformation programs in my book *Data Munging with Perl* (which is [now freely available](http://perlhacks.com/2014/04/data-munging-perl/))
Awesome, I will look into this. Thank you!
A good article overall but "the programming language is a legacy code" sounds a bit odd.
Does anyone have any other recommendations of books on this topic? 
This. I am currently working for 2 start ups as a freelance Perl programmer ;-)
Right, I didn't say that new perl development isn't happening. As you say it is hard to get an objective measure of how widely used different languages are relative to one another. So you have to recognize that a few perl developers saying they have used perl in a start up doesn't mean perl is popular or widely used for start ups. My perspective, albeit as someone who hasn't coded any perl for a year, is that the trending momentum of ruby, go, python and nodejs is much greater than perl. Like [Amazon AWS Elasticbeanstalk](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html) doesnt support perl. Nor does [nitrous.io](https://www.nitrous.io). Perl was one of the last languages to be supported on Heroku. [codewars.com](http://www.codewars.com/) doesn't even have perl as a language they are planning to add. Presumably this means they have little to no demand for it, which would mean that new developers are less interested in learning it. I know all this evidence is anecdotal. It just seems telling to me when PaaS/Development service providers put perl on the back burner in favor of the more popular languages and frameworks. That may speak to the popularity of perl as compared to other languages, at least in start up environments that are the target audience for such services. So all I am saying is that in my opinion, perl is not growing in popularity. If anything, its popularity is declining. It is more of a niche language that is being used when it is the right tool for the job, not as a go to for general projects.
&gt;robust communities behind them rofl. you're seriously trying to compare CPAN to RubyGems? 
If you like Strawberry Perl, you might like [berrybrew](https://github.com/dnmfarrell/berrybrew) a perlbrew-like tool I developed for Windows
No. Thats apples and oranges. I think that the community resources available for someone learning ruby are better than those for learning perl. The ruby community seems faster to adapt to new trends and ideas. Plus you have projects like [jruby](http://jruby.org/). Ruby on the JVM useable in production. Or products like [Ruby Motion](http://www.rubymotion.com/) which converts ruby code into native IOS code allowing you to write native IOS apps in ruby. I'm not trying to start a holy war or say that one language is better than the other. That type of thinking is counter productive. Perl is a great language. This is just my perspective from having spent some time in both communities.
My apologies, its a formatted link via htaccess mod rewrite which then calls invoice.cgi?dispatch=create&amp;key=*customer id* and the semi rest of the program is: 
perl coders have no need to brag. They just get it done. 
&gt; if ($q-&gt;param('dispatch') eq "create") { &gt; &gt; &gt; &gt; &amp;new_invoice; In the last comment I put the beginning part of the script which calls it. I've highlighted it here.. By the way, thanks for the replies!!
The (very successful) startup I work for uses mainly Perl on the back end.
No problem. So I can assume that the function xxx is new invoice. From looking at your code I don't see anything that would cause the insert method to be run multiple times. However, since you are using a modrewrite I would look at your config to see if it the match is too inclusive. If you are making 27 calls that get rewritten to include dispatch="create" then that could cause the problem. 
I take it you've never been in /r/Programming? People talk shit about Perl all the time.
Also, since you have a script called invoice.cgi, have you looked into Shellshock? ^(And maybe Plack...)
So we can expect your Ruby self-promotion attempt (a.k.a. book) in 2015?
mod_perl ... Argh. (The mod_perl to plack adaptor I currently maintain doesn't work if you deploy on mod perl, and despite being a fairly easy fix I've marked it really don't want to fix). 
Could you please elaborate on why it doesn't work if you deploy on mod_perl? That seems confusing to me (because it's a mod_perl to plack adapter). Thank you in advance.
A tiny point of style: it's better to write: new_invoice(); rather than &amp;new_invoice;
Well the script it's self isn't really called invoice.cgi, I more or less named it that for here only. Since on mod rewrite I make use of /invoice/blah blah blah it conflicts if I name it invoice.cgi so it actually have a complete different name. And as far as shellshock, no I really haven't as I typically do these scripts as "hobbies" for my business and really they are only used on the back end requiring some sort of login before anything can be executed. I did just do a quick search since you brought it up and I will look more into it, as these days you can never be secure enough. Once again, Thanks for your help!
I understand the sentiment. It just the phrasing that sounds odd.
&gt; about Perl's successes and shortcomings. Nit: I edited that piece to correct a few technical errors. I *did* write the software that powers the site, though.
Fun fact: my first foray into deploying a node application (etherpad) was full of frustration because the package distribution was broken. Some required package of a package wasn't found. Hours spent trying to figure out wtf was going on. Come back to it a few days later, and it just works. Tables were overturned. If there was, say, a network of mirrors, that wouldn't have happened.
I'm not expecting Perl to run on Arduino. That's just as silly as wanting Python on Arduino. What I do want is for the ecosystem of hardware libraries to be as broad as everything else on CPAN.
Really good news. Congrats.
Just started a job in a biotech startup using Perl exclusively to develop a webapp for genetic diagnostics targetting the NHS in the UK. All "ModerPerl" with Dancer and relatively sane DBIx models, dont really see how it would be more *edgy* in another language. It's not important to advertise that we use Perl other than for getting developers. Even then most longer time experienced bioinformatics people already know Perl it's not really an issue.
The startup I'm in has access to a private data centre. Not all startups are making some trending webapp that needs to scale in the sense of web requests. Plenty of things require a level of secuirty and storage that means it's not suitable for the public cloud without a lot of effort/money, which a startup is unlikely to put in to begin with. Perl is hugely prevalent in biotech/bioinformatics still and those are the sorts of things you wont see pushed to Heroku or even really talked about in a developer centric way. All the code I'm writing isn't generally applicable to other programmers, and adds value to the company so you wont see it being pushed to CPAN for example.
That's why the default CPAN client has to die (or massively modernized, or cpanm becomes the default). The default CPAN client's interface and default settings are the areas that show Perl's age the most. The CPAN architecture itself is great and works relatively well to this day.
shagadelic!
No information there on how to actually sign up? Looks like you just have to [email Neil Bowers](http://blogs.perl.org/users/neilb/2014/12/take-the-2015-cpan-pull-request-challenge.html). Having said that, does it seem somewhat counterintuitive to assign people random modules rather than letting them express some interest in something (or some level of appreciable skill)? Maybe I'm wrong. I'm half tempted to sign up, but I feel like I'd be more inclined, if I had the time, to just find a module or two to actively try to support.
Any idea how the adoption of this challenge looks so far? How many people have signed up? Again, I'm tempted to sign up, but given my present workload I feel like I'd be kidding myself if I thought I was going to be able to make any actual meaningful contribution at this point.
I.. I still didn't do my February assignment. I guess I have to hurry
Between Ruby and Node, Node seems to have more momentum, sure. Will Ruby lose out over the next five years? Maybe. I still see a lot of new code written in Ruby and a lot of people hired to write new code in Ruby on both coasts (though I deliberately don't have any insight into SV any more).
 Anything you can contribute is meaningful, even fixing typos in documentation. I believe it's over 350 devs so far.
Isn't it the author's job to maintain his modules? Do the people that sign up identify issues and submit a bug report?
OK it's not a mod_perl to plack adaptor, it's a [library](https://metacpan.org/pod/Plack::App::FakeApache) that gets you well on the way of getting off the abomination that is mod_perl and on to develping and deploying your mod_perl application via plack. Now in theory you can deploy a plack application on mod_perl, but it seems to me that deploying a former mod_perl application converted to use plack via mod_perl is a particularly silly thing to want to do. In fact I can't see a legitimate reason to deploy anything on mod_perl that doesn't need to, (although there is the occasional use case for mod_perl from time to time, say you want to dynamically alter the apache configuration).
I was wondering about this as well. If you get a module in the challenge and the author is unresponsive, what ends up happening to your pull request? Is there any buy in from the authors whose modules are available to be assigned to help ensure pull requests will actually get seen and reviewed? It would seem detrimental to the cause to have people submitting pull requests that will never be given the proper visibility. [Here's a *great* example](https://github.com/pfig/net-amazon-s3/pull/42) of a pull request that should have been merged nearly a year ago. Not my pull request, but I've hit the same issue and the warnings were driving me bananas. I ended up pulling a local clone of it and fixing it myself in my own repository because the warnings were driving me crazy. No amount of emailing or other forms of communication seem to get the author's attention.
There are apparently schemes to take over modules if the original author isn't active.
It's a PR challenge, not a "get my PR merged" challenge. Sure, it's the goal to get it merged, but if not, it's not really your problem now is it?
Module adoption has been in place for a long time, well before this. Neil hit upon a great way to get others (like me) involved who wanted to contributed, but had no idea about how to start. It's been an incredible ice breaker.
Yeah this is really odd. I actually wanted to participate. But I ran out of patience looking for sign up details. I just looked for the second time, and still did not find his email address.
Cool, thank you for clarifying. My apologies for being obtuse but may I ask why mod_perl is an abomination (of sorts)? I just wrote a simple mod_perl content handler and it seemed straightforward. Is it because mod_perl is Apache-specific (tightly coupled)? Or because Apache is too monolithic? (I checked out your library -- gadzooks, Apache is complicated.)
&gt; it's the goal to get it merged, but if not, it's not really your problem now is it? It's kind of my problem if I'm taking time away from other valuable projects to work on this only to have ultimately squandered that time if an author completely ignores the effort. If the aim of the challenge is to improve CPAN modules, it would seem somewhat unproductive if you're throwing time and effort at something that isn't going to see the light of day.
Tight coupling monolithic, resource hungry. To top it off any of those lovely debug tools you like - they're probably not going to work. Also the documentation is a bad joke. There's no way i could have written FakeApache. 
&gt; Mojoconf 2015 will be held at The Houston Street Center in lower Manhattan. 
Imagine a role that adds a logging object to the consumer and provides methods like `_log_debug`, `_log_info`, etc. These methods shouldn't be public (obviously), but the role itself may not call them.
&gt; Then don't do it, it's not for you. I'm sorry, but I don't see how this a particularly constructive statement to make, nor do I see how you've divined what is or is not "for me" from a couple of seemingly innocuous questions I've asked. A question was posed, which I expanded on a bit as it's something I'm curious about. Rather than an answer, the response given was "it's not really your problem now is it?" Your response, separate from this, then tells me that I might as well go away, because this isn't for me. Well that's fine, point taken, and I will cease inquiring about the nature of the challenge or this discussion in general and forgo the email I was planning to send to Neil tonight to take part in it. If the goal of this kind of collaboration project is to get other stauch Perl supporters (or anyone, really) to become more involved in the community at large, this kind of feels like the wrong sort of attitude to be adopting to further that cause.
There's nothing to stop you picking your own project today and filing pull requests you consider useful. That is the very nature of normal CPAN interaction IMHO. However, that is not "A challenge". Here, the "Challenge" is being assigned a project you're not familiar with, and making you get familiar with it enough to draft useful changes to it. Its also a case of "I don't know how I can help but I want to, send me something" vs your "I want to help and I want to work on X". These are both useful things to say, but their motivations are somewhat on a different axis from each other.
The problem is they have to be a minimum of 2 years deprecated before we can even consider things that consume the space they occupy. And sometimes features exist that need deprecating because they're downright harmful and introduce really odd bugs that are really confusing and unintentional. One such thing I would love to see on the chopping block is `indirect` objects notation, because it flares up often when you least expect it. For instance, accidentally omitting a semicolon before a POD statement as follows is annoyingly hard to debug: my $x =head1 Foo Because that is parsed as my $x = Foo-&gt;head1 And then the rest of that section is treated as normal perl code instead of POD , and that will entirely hide where the real error is in parse. ( Especially if the entire section after the head1 is legal code ). Unfortunately, the best we have for that atm is it is **discouraged** and its culled from being used in core documentation. http://www.nntp.perl.org/group/perl.perl5.porters/2013/08/msg205941.html Hopefully that gives you some context to how much we care about only eliminating things that are completely bonkers. Because indirect methods are actively harmful, and yet, not completely bonkers enough to warrant nuking it yet. 
`while(readline)` and `while( $fh-&gt;readline )` are not equals. I overlooked this because I've never seen `while(readline)` used in practice and didn't realise it was possible. But it appears `while(readline){` is flawed in the same way `while(&lt;&gt;){` is. perl -E 'while(readline){ say $_ }' 'ls|' ^ invokes `ls`. This would be a big issue if the script in question was setuid.
&gt; I would initially think to write a nested for loop for each item I had, but that can't possibly be the best way to do this, right? It's a perfectly fine way to do it. Correctness trumps efficiency.
What does this look like for a list of 10 different things? I get it conceptually sort of, but not in code... Like @items = [14,2,5,63,46,32,64,34,67,907] for(int a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) for(a = 0;a&lt;10&lt;a++) But where does the code that combines every possibility go?
I would use Algorithm::Combinatorics
 for $gender (qw( male female )) { for $height_mm (0..4000) { for $eye_color (qw( blue brown gray green black heterochromatic mysterious not_applicable )) { print "$gender $height_mm $eye_color" } } }
Why not use the traditional if or unless, in that case, since it's generally 'clearer' to begin with? if ($foo == 42) { print "hello\n"; } versus print "hello\n" if ($foo == 42);
I don't agree that the traditional if is generally clearer.
Private methods in roles (as in methods starting with an underscore) should be document and available to consumers. Roles are not classes, and when a class consumes a role all of the role's contents should be considered to be part of the class.
http://mat.gsia.cmu.edu/classes/mstc/heurnote/node3.html#SECTION00021000000000000000 That appears to be the problem they're addressing. 
ImageMagick not helping here?
It did. Thanks.
I think its probably a good idea to ping the author once you have been assigned a challenge. (S)he probably has ideas anyway and it is always polite to ask before sending a pr-out-of-the-blue. Then if you get no response, you can then take appropriate action, which might range from request new challenge to request takeover (clearly depending on the situation).
Your pwd is packrat, not packrat/scripts ;-) edit: while slice and cheese might look funny at first it will wear off very fast.
ARG SO SIMPLE! Thanks. I kept thinking something was getting lost in the outputs! 
You're welcome. I call this "fighting the system". It often helps to make a more simpler version (in this case removing the grep would've made clear what was happening). Another one is to take a break and have a fresh look later. Often when I am stuck I let it rest until the next day. Fresh eyes in the morning solve a lot of bugs (in my experience).
Thanks so much to you. This perl subreddit and perl community in general is so awesome! Yeah!! I'll give Text::Soundex a whirl. 
Thanks, are you specifically recommending "sqlite_create_function" for efficiency? The pod for dbd sqlite uses this format: $dbh-&gt;func( 'soundex', 1, \&amp;Text::Soundex::soundex , 'create_function' ); (or for ex. $dbh-&gt;func( 'now', 0, sub { return time }, 'create_function' ); ) I suppose for portability, but maybe what you have is more direct? 
That's fine too, and it doesn't make any real difference in efficiency since it's only called once. The efficiency bit is to pass `\&amp;Text::Soundex::soundex` directly, vs. something like `sub { return soundex(shift) }` which would jump into a perl optree.
I don't particularly like the way he mocks the integer math in other languages. Programing is a culture different from human culture. A culture is a certain set of conventions or contexts to facilitate routines. Integer math and floating points are simply cultures that gives programmers to render their goals precisely and efficiently, but one need to embrace that culture first. Of course, a culture will look very odd or even ridiculous in the context of different culture. But simply because it is different, you start to mock the other culture to make your own culture look superior is, how should I put it, moronic. It is alright to showcase your culture and illustrate how your culture works how nicely, but please constrain and remove the mocking tone.
if you store the soundex of name instead of (or besides) name and put an index on it your query will be much faster. Now (if I understand things correctly) you're doing a linear scan of all 1,500,000 records.
DBI + DBD::mysql. E.g. http://perl.about.com/od/perltutorials/a/perlmysql.htm
He was obviously having a little fun with it. I think you are taking it way too seriously.
I wonder if the default table collation in SQL Server 95 has the pad space attribute though? 
If you do decided to look at DBIx::Class, which is an Object-Relational Mapper (ORM), you might also look at [Rose::DB::Object](https://metacpan.org/pod/Rose::DB::Object), to see which one you prefer. Different strokes for different folks. There are others too, of course.
Taking (faux?) ignorant numeric pot-shots -- against fixed-width integers, against floating point, against a language's implicit promotion of one type of number to another -- is always a sign to me that a presenter is trying to score cheap points. Tab closed.
&gt; double That doesn't make much sense. Variables in perl are complex objects that will choose to behave in different ways depending on context.
Hmm. It appears I might be wrong. I tested that assumption on an older perl I had access to at the time, not blead. On blead, presently, `readline` behaves the same way as the new "safe" `&lt;&lt;&gt;&gt;` operator. Which means: - perl-5.20.0: `readline` *will* invoke programs - blead: `readline` *wont* invoke programs. But this looks like a potentially unintended side effect (a regression), so I wouldn't rely on it. http://thread.gmane.org/gmane.comp.lang.perl.perl5.porters/148575
Could you please explain how the issues I raised were ignorant? The problems I discussed are well-known problems that routinely confound developer expectations and cause bugs. I don't understand how directly addressing a serious, wide-spread problem is "trying to score cheap points." I want software that is more robust. I want programmers to find it easier to write robust software. I addressed those issues directly in that talk and went on in-depth about how Perl 6 can potentially address some of those issues. Further I did *not* mock other languages. Instead, I pointed out implementation problems. I even did that for Perl 5, a language I'm well-known for enjoying. It's like my daughter: just because I love her doesn't mean that I'm not going to correct her if she does something bad. I will, however, still love her.
Stockholm's syndrome. 
I'm slightly bothered that it doesn't even acknowledge the existence of Test::Fatal, which while being slightly more awkward to use in some cases, is more flexible in others. 
Thanks !!!
&gt; &gt; &gt; &gt; &gt; I mean, I probably will get it if it is a reddit comment, but as a conference talk, having little fun should be less dominant theme than seriousness, right? There is no reason that you cannot do both given the right Presenter. :)
I reflect my reaction was due to an ill history of watching other presentations, so I apologize to you if you were offended. And to my defense, I merely stated that "I do not particularly like ..." and in fact that was the reason I didn't finish your video. To contribute more meaningful (but personal) comments, I do not have history of being bothered by integer division in programming. In fact, I often need remind myself to "use integer" in Perl, sometime after painful debugging (note that I am not complaining about Perl either, it is just different design choice with each pros and cons, and a user can be productive in either once immersed in that culture). As to perl6's implicit rational types, I never had issues of comparing equality in floating numbers. As in my own programming culture, I have learned to avoid floating point equality comparisons, which I think every programmer should do the same rather than learn new particularity in a particular language (and contaminate the habit onto all other programming languages he touches). In the same vein, -7/2 was never an issue in an integer context, when we use such we simply need an approximate integer result (not -3.5). On the other hand, -7%2 is a different story. With such context of mine, I hope you see why I did not have the reception you may have hoped. So for the part I watched, seems perl6 is addressing cosmetic issues that real programmer do not typically care. Sorry that I didn't watch the rest of your presentation. I may resume at some point and give you more comments (if you do not appear to resent them). PS: the reason I perceived a mocking tone was because you present other language's results as if they were errors (except for Perl 5). Quote your text above: "Instead, I pointed out implementation problems.", problem means ill, so I don't think my sensing arbitrary wrong accusing was mistaken. However the perception of mocking is probably my emotional reaction especially when I perceive the other languages are in fact healthy. PS2: Out of curiosity, in Perl6, is 1/3-0.3333333333333333333333333333333 == 0 ? (mathematically, it is &gt;0, right?)
I love it. * A room full of nerds. * $$$'s of dollars worth of recording and presentation equipment. **Can't hear the audio** We really need a Meme for this. 
The LocalHost parameter when you create the listening socket on the server side sets which address it binds to (is available from), in your case you're setting it to the name 'localhost'. 'localhost' traditionally resolves to 127.0.0.1, which is only available on locally (that's what it's for). Looking at your client code it looks like the server's public IP is '129.25.4.146' so if you wanted to bind the server to a specific address you'd want to bind it to that. Alternatively you can use '0.0.0.0' which tells it to use any IPv4 address that it can. You can see what services are listening for network connections and what port and IP they are listening on by running: sudo netstat -ltpn 
It's a joke. I too am attached to old ways of doing things. 
Even if you die with a number, $@ is a string. It includes context of file and line number. (Exception is if you pass a reference to die.) Therefore, you must use eq instead of == when doing the $@ comparison at the bottom.
Replace == with eq
Yes, but it should be possible to add this context information to the "string part" of $@ without destroying dualvar. But maybe the string character of $@ is too fixed in Perl to change this.
Don't use a turd of a software package when you can use perl.
“Meta-design is much more difficult than design; it’s easier to draw something than to explain how to draw it.” — Donald Knuth, The Metafont Book Thanks! This looks like it will help with meta design! 
I still see great benefit from this exercise. I get experience with work flows, meet great new Perl developers, and even if my PR(s) are not merged I still am a better dev and Perl community member for having participated. I don't do it to get PRs merged necessarily. I do it because it makes me better. 
Thank you! that worked!
Yeah I was planning on giving it an infinite loop. basically what it does after it receives the string is it parses it for a username and password then checks if they match up with the database. Then it will print out something in the console or return a value or something to signify it received the message. So I will just put everything in the loop.
I guess the whole point of dualvar was to avoid just that.
I think you may have a slight misunderstanding of the $sock-&gt;accept() function. (although it is possible that it is I who misunderstands) In my experience, it represents a socket itself, and you must read data using it. Here is an example using sysread (built in to perl) $LENGTH=5; $clientsock=$socket-&gt;accept(); $count=sysread($clientsock, $bufferSize, $LENGTH); $count=sysread($clientsock, $dataStoringVariable, $bufferSize); At the end of this, $dataStoringVariable will store what you expect: the data sent over the socket. I'll explain more: the first sysread statement says read from $clientsock exactly 5 characters ($LENGTH) that represent the number of bytes that are about to be sent. (so it would send, say, the number 350, then the 350 bytes of data themselves) But you have to know how many bytes to read before you read them, hence reading the $bufferSize in the first sysread call, then using it in the second to determine the size of information being read and stored in $dataStoringVariable. I am sorry if this wasn't clear, I'm not always great at explaining these things and as 5pm friday approaches my brain is slowly shutting down extraneous processes. I would be happy to explain further if you still need help, but I hope this was helpful a bit! (by the way, for writing data back, try syswrite. same thing!) 
that's just the way I have done it with sysread. I'm a 3rd year college student myself, I've been programming in Perl for about a year now so i am in no way an expert. I also didn't understand it for a while so don't be too hard on yourself. Imagine it like this, you're gonna read some data. how much? How could you know that? Well, because first it says "this is how much data I'm gonna send you." Just remember, $sock-&gt;accept returns another socket object that you can use. Think of $clientsocket as a tunnel to the socket on the user machine, whereas $sock is the socket directly on your machine. I hope that is helpful too, I kinda just tried to rephrase what I said earlier lol. Good luck and just PM me if you run into any more roadblocks or really can't figure out what I meant with that. Perl is love, Perl is life. 
In case you weren't familiar with it, this site will be your best friend. http://perldoc.perl.org/functions/sysread.html
Try the following: my $result = $telnet-&gt;expect(30,"$device_prompt"); unless ($result) { print $telnet-&gt;exp_before(); die; } Same with the other unless. I've seen 5.8 do funky things in conditionals. I distinctly remember an issue with ||= in conditionals as well.
Are you using the perl Expect module? If so, then set $Expect::Debug at line 190. You'll get more output from the Expect module and may show you what is going on. Also set $|++ so no buffering is going on with your output. Expect, or die, or something could be outputing to standard error output and writing in the order you would expect.
Two videos are labeled as having bad sound. Rjbs's sound also cuts out a few minutes in. Very disappointing. 
Maybe it's time to separate Test::Simple from the rest. It would probably be less than 100 LOC with no dependencies.
Yeah, I knew it had to be a recursive issue if not a memory leak (where the leaked reference's DESTROY was getting called). But also, Net::Telnet, man. 
Why are you not just using RANCID instead of some home cooked stuff?
The variable will not care about the captilization. Its the function that is doing the move that will and even then that depends on the OS being used windows is case insensitive, Linux/UNIX is, for Mac it depends on the filesystem settigns A little more detail would help is this a CGI file upload program? Could you post the relevant bit of code . 
I though about suggesting lc() but it case shouldn't matter as long as its consistent. I wonder if its a secondary process that's the problem And WRT input sanitation everyone should have this on their wall :-) http://xkcd.com/327/
[Image](http://imgs.xkcd.com/comics/exploits_of_a_mom.png) **Title:** Exploits of a Mom **Title-text:** Her daughter is named Help I'm trapped in a driver's license factory. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/327#Explanation) **Stats:** This comic has been referenced 581 times, representing 1.0628% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cp7gify)
XML? http://i.imgur.com/YYJQd6f.jpg
Mark Jason Dominus's book is still one that I consider to be one of the top three Perl books in the history of the universe. And, he gives it away for free. However, consider buying it to encourage and reward publishers and authors.
It feels like yesterday ;-) MJD gives a better explanation of functional programming concepts than any other functional programming related books I have had a chance to look at. +1
A wonderful book.
Thanks, I've added a reference to Test::Fatal.
This book taught me a million little things you could do with sub {}.
I wonder what a Perl 6 version of this book would look like! You could get rid of the `sub`s most of the time, and some constructs could be transformed to something more concise/idiomatic.
Changed the way I think about programming. Not many books I can say that about...
Thanks to everyone in this thread for your kind words and your support! 
[This might help.](http://www.perlmonks.org/bare/?node_id=900350) 
I had not seen this book before, and it does look like a good read following a quick skim of the PDF. Thank you for the link, I will add it to my Amazon list. You have however piqued my interest. May I ask what the other two books in your top three Perl books are?
A higher order thank you to MJD: sub give_thanks { my $thanks = shift; return sub { print $thanks } } 
It was a joke, I realize XML has a lot of legacy use still.
Follow-up at http://blog.wlindley.com/2015/03/zero-to-mojolicious-part-3-wp-api/ ... using the WP-API to extract rendered HTML from a running instance of WordPress and display it in a Mojo system.
He means literally stuffing it with binary data, no encoding. The article had hex encoding, but Number::Phone::UK::Data is straight binary (warning: big file in link): https://api.metacpan.org/source/DCANTRELL/Number-Phone-3.0006/lib/Number/Phone/UK/Data.pm I don't really like mixing content types like that. For CPAN modules, this particular problem is better solved with [File::ShareDir](https://metacpan.org/pod/File::ShareDir).
Number::Phone works on Windows. At least, I don't get oodles of failure reports from the CPAN-testers or from users, so I assume it works. Of course, if you try to treat your binary as text then you'll need to be careful, because of `binmode` and other weird character encoding stuff, but weird character encoding stuff afflicts all platforms. As for not seeing it in the editor, that's why the big ol' blob of binary in Number::Phone::UK::Data is auto-generated. If I ever need to change what's in that file, I fiddle with the build script.
Wouldn't it make more sense to bundle the database file using `File::ShareDir`?
Can someone explain to me like I'm 5 why this is at all useful and give me an example of a real world application.
I rolled my own at some point, it managed to lock up all my VTY's (requiring a reboot)... so be careful. 
There's really only one UART on the Pi? That's a pity.
You can always use a converter on the USB ports.
That book was mind blowing for me. Thanks!
Sometimes, it's handy to keep everything in one big file. 
[Do you uuencode? pack 'u' does!](http://www.nu42.com/2015/03/do-you-uuencode.html).
No, because IIRC that would mean that I'd have to use Module::Install.
Number::Phone's use of a DBM::Deep database in `__DATA__` pre-dates that by about four years.
That's a 'regular expression', not exclusive to perl, but certainly used heavily in perl. http://www.regular-expressions.info/ should help you with some / most of that.
That's less than 1/3 of the 31,471 distributions on CPAN. What do the majority do?
Just wanted to say "thank you." I work hard on those talks and it's great to hear that people appreciate them :)
&gt; I reflect my reaction was due to an ill history of watching other presentations, so I apologize to you if you were offended. Thank you, and I'm not offended :) More than once I've had an initial reaction that on reflection, could have been different. That being said, even if you stood by your initial reaction, that's OK. It's important that people have different opinions!
Try rubular regular expressions to help you figure it out. I know its not perl but is still pretty useful.
Hehe, this one is like level 25 I think.
Probably about 1/2 way there.
Possibly related: [The Old New Thing: Why Daylight Savings Time is nonintuitive](http://blogs.msdn.com/b/oldnewthing/archive/2003/10/24/55413.aspx)
That is good, but it doesn't explain how `stat` is consistent with Strawberry Perl, and inconsistent with my `perl` built with Visual Studio. For reference, here is what I get: perl -E "say scalar gmtime( (stat 'test-file.txt')[9] )" Sat Feb 21 06:08:00 2015 versus perl -E "open my $fh, 'test-file.txt'; say scalar gmtime( (stat $fh)[9])" Sat Feb 21 07:08:00 2015 versus c:\opt\strawberry\perl\bin\perl -E "say scalar gmtime((stat 'test-file.txt')[9])" Sat Feb 21 07:08:00 2015
You might also want to mention the difference between `-M` and `-m`.
You can also check if an XML file is well-formed using `XML::Parser`: `perl -mXML::Parser -e 'XML::Parser-&gt;new-&gt;parsefile("afile.xml")'`
For posterity, a fix was applied in [Mojolicious](https://github.com/kraih/mojo/issues/761), though we could probably argue that it is a Windows bug :-)
The fix avoided a spurious test failure. It is either a Windows bug, or a bug in the way I build my `perl`. Strawberry's `stat` gives the same result whether it is given a filename or filehandle. Mine, built with Visual Studio, causes the problem.
Fascinating article, Ovid. I love and recommend your book. It may be unique in having such clear Moose and DBIx::Class coverage. P.S. Any thoughts on why blogs.perl.org seems to be so bogged down?
I'm shocked that Ovid can still post at all. I've been locked out for months -- https://github.com/blogs-perl-org/blogs.perl.org/issues/291
Cpanminus is so awesome.
Top of mind: * [rex](http://www.rexify.org/howtos/perl.html) is cool and hasn't got the recognition it deserves yet. * Could say the same about [Argon](https://metacpan.org/pod/distribution/Argon/README.pod).
Very cool!
barbarian 
I have not used that cpan client for ages and it was not even configured in my perl, but thanks for the suggestion. I've tried it now and got all kinds of errors. cpan -g WWW::Mechanize ... Bizarre copy of ARRAY in list assignment at then I tried cpan -g WWW-Mechanize to which I got Can't call method "cpan_file" on an undefined value at and then I tried cpan -g WWW::Mechanize again and this time it worked. I guess I should send some bugreport somewhere... Maybe here: https://rt.cpan.org/Ticket/Display.html?id=102778 I've also added this to the article. 
It would probably be worth somebodies while to introduce some consistency so that stat works the same on every platform, even if it meant that on windows it used it's own extra ifdef, or even an extra bit of XS C magic to always do the right thing. Time is so important that getting it wrong leads to subtle bugs in other layers nobody thinks of, so making sure cygwin, strawberry and peoples compiled versions (under whichever compiler they choose) give the same answer. You might file a bug under the cygwin or base perl versions, but it might be looked at as [SEP](http://en.wikipedia.org/wiki/Somebody_Else%27s_Problem) since it's caused by windows itself.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Somebody Else's Problem**](https://en.wikipedia.org/wiki/Somebody%20Else%27s%20Problem): [](#sfw) --- &gt;__Somebody Else's Problem__ (also known as __Someone Else's Problem__ or __SEP__) is a psychological effect where people choose to dissociate themselves from an issue that may be in critical need of recognition. Such issues may be of large concern to the population as a whole but can easily be a choice of ignorance by an individual. Author [Douglas Adams](https://en.wikipedia.org/wiki/Douglas_Adams)' comedic description of the condition, which he ascribes to a physical "SEP field", has helped make it a generally recognized phenomenon. Somebody Else's Problem used to capture public attention on matters that may have been overlooked and has less commonly been used to identify concerns that an individual suffering symptoms of depression should ignore. This condition has also been employed as trivial shorthand to describe factors that are "out of scope" in the current context. &gt; --- ^Interesting: [^The ^Resurrection ^of ^Mars](https://en.wikipedia.org/wiki/The_Resurrection_of_Mars) ^| [^Buck ^passing](https://en.wikipedia.org/wiki/Buck_passing) ^| [^Reality ^distortion ^field](https://en.wikipedia.org/wiki/Reality_distortion_field) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpf3pm7) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpf3pm7)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You should log some values for the various API calls and Perl's functions, as well as the properties in Windows explorer, both for FAT* and NTFS. Then, do it again for the same files after daylight saving tames goes into effect, which is pretty soon, so this is a good time for this test. (Or you could cheat and change the date in the system clock...) You'll probably see that some of these values change by 1 hour, and that while the files themselves were not touched. That's how big of a problem Windows under Perl has. 
You can combine debug and execute to get an interactive Perl shell unix&gt; perl -d -e 0 Loading DB routines from perl5db.pl version 1.39_10 Editor support available. Enter h or 'h h' for help, or 'man perldebug' for more help. main::(-e:1): 0 DB&lt;1&gt; $x = 20 DB&lt;2&gt; print $x 20 DB&lt;3&gt; 
Oh, damn. Here, the switch will probably be by the end of March, IIRC. But, file time also change in results from Windows API calls, yes, even `FindFirstFile`. So changing `stat`to use this function instead, as asked in the last paragraph of the post, would actually not solve the problem. And, anyway: Perl should return the same result as the file properties in Windows Explorer, even if that value is wrong.
I think this is of general Perl interest (vs. /r/perl6 interest).
Hi, You can use rand() to take a random element from the array: # Make an array of words. my @items = qw/I need to select 10 print them into an output \ file as the first line. Then select 20 print them into the same \ output file as the second line and so on and so forth Pretty \ new with Perl and could really use some help/; # $num_items has how much words we have in the array. my $num_items = scalar @items; print "There are $num_items items in the array\n"; # Print 10 random words to stdout print $items[ rand($num_items) ] . " " foreach (1..10); This prints: There are 45 items in the array could line output the need file Pretty the the second Of course, the last ten words are picked randomly. Hope it helps,
That's fantastic thank you ever so much for taking the time to help me. First post to get a swift reply in a polite manner with comments, i hope the rest of the community is half as good as you :)
I don't know too much about perl on Windows, but is there any way to do a quick and dirty fix at least for now? I'm getting super worried about a piece of software I'm working on that I'm going to run on both *nix and Windows.
Hi tarje, &gt; GitHub uses Textmate's syntax highlighter for Perl source are you sure about that? I always assumed that it uses the language grammar from [TextMate's Perl bundle](https://github.com/textmate/perl.tmbundle), but not the actual code from TextMate to do the highlighting. &gt; This explains why viewing perl source on github is frequently messed up. Michael (infininight) pointed out that he is happy to accept pull requests [here](https://github.com/textmate/perl.tmbundle/issues/1#issuecomment-81294570). John Harrison for example, added basic support for [Perl 6 syntax highlighting](https://github.com/textmate/perl.tmbundle/pull/13) recently. So for everyone interested I would recommend to clone the Perl bundle and start to fix the grammar issues. Your work could help a lot of GitHub, TextMate and Sublime Text users.
They're using the Textmate syntax *bundle* but not the Textmate syntax highlighter *code*. Textmate's tmbundle format has become something of a de-facto standard. Textmate, Sublime Text and Atom all use it. Github developed the Atom editor, so I assume they'll be using the Atom syntax highlighter. https://github.com/atom/highlights 
(R)?ex is one of the reasons I turned to Perl. Puppet, Chef, Ansible, Fabric and others would just not "click". When I saw (R)?ex it felt perfect. Another Perl wonder.
I just had two tabs open side by side. One was "My Bad Communication Skills" which I read and decided it wasn't addressed to me. The next was "Fix Those Legacy Subroutines or Methods" which I read several weeks ago and was thinking about, then forgot the link for and had resolved to track down. When I clicked that I saw that both were written by you. So first I guess I'll say it depends on the utility of what you're blogging about. Some perl topics can reach multiple audiences so you might be able to cross post it to /r/sysadmin or /r/networking depending on how it's used. I wouldn't try to spam, but be thoughtful about who is going to use it and post accordingly. As an example, the Accelerometer post today mentions arduino and raspberry pi, so if the module is applicable to either platform then he might post to those subreddits. Otherwise twitter, facebook, linkedin, google+ and any other social service you can paste a blurb to. There are also mailing lists for some audiences, but usually if the mailing list is big it's better to be a part of that community before you join/spam a link. I know this may not be helpful, but when I code things or figure out sysadmin solutions I sometimes put them on github gists or post them somewhere with little to no blogging. I do it because it took me 5 hours to solve it and I hope the solution helps others, but in that particular case I don't have time to tend to it. The appeal of that is that I know it's out there and with a good google search people will find it, even if they don't talk with me about it. Finally, thanks for the articles. :)
&gt; Puppet, Chef, Ansible, Fabric and others would just not "click". I'm really glad you said this. From the title, I assumed it was just some sort of a regexp enhancement for Perl, and probably wouldn't have bothered to click through to the site if this hadn't caught my eye and made me realize this was a deployment/configuration management tool.
glad you found them helpful! Your reply is very much appreciated and is helpful to me as well. Thanks!
I think you can just do if($json_text) { $c-&gt;render(data =&gt; $json_text); } You're basically just treating your pre-encoded JSON as a bag-of-bytes at this point, you just need to make sure Mojolicious knows that's how to handle it.
Install a version of Perl in /opt and let the she-bang of each script point to it? #!/opt/bin/perl See: http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/opt.html
Here some information about what I do: https://gist.github.com/Getty/afa507175721e731dde8 If you have any questions, feel free to ask.
using perlbrew - install from your package manager or from the website if need be something like this should work export PERLBREW_ROOT=/opt/perl5 perlbrew init #do what it said about adding the source to the bash_profile perlbrew available perlbrew install perl-5.20.2 perlbrew install-cpanm and that will work, although the other users will need to run the `source /perl/path` thing, or add it to their bash_profile, or i guess you could put it in /etc/profile or /etc/profile.d/perlbrew.sh https://metacpan.org/pod/distribution/App-perlbrew/bin/perlbrew#CONFIGURATION
this approach has worked well for me also
I really try to avoid mixing system-perl with custom-perl. Who knows what might happen to system services that are tested with the system-perl I do not use cpanm on the system-perl unless I absolutely have to. For everything that needs a custom-perl I think I'd go with the solution mrbig4545 posted.
i don't know lmod, but I use carton for this https://metacpan.org/pod/Carton
I like plenv + perl-build combo.
I put perl on an NFS server. Then I only have to add modules to one place, and users can switch from box to box and still get the exact same Perl version with all the modules wherever they log in
You got it. $mech-&gt;find_link( url =&gt; 'foo' ) $mech-&gt;find_link( text =&gt; 'bar' ) will both find &lt;a href="foo"&gt;bar&lt;/a&gt; The text_regex and url_regex options work the same way, except they take a regex reference ( qr/.../ ) instead of a string.
Nah, didn't bother learning this, so gave up =(
Bingo. Thank you sir.
His environment, his rules. Some of us, for example, may want to optimize for ease of use so that coworkers who don't know/care about a custom perl install can just run a script, no matter what they've done (or haven't done) to their PATH.
Can you please not write like a 4 year old in need of a bathroom break, thanks. From the question it's clear that this is a single box, so in my opinion there is no need for portability. Moreover, since env can pose a slight security risk and users might break PATH in various very creative ways my advice is far from what you call "worst hint ever".
My recommendation (for a large and/or firewalled environment): Use perlbrew + cpanm (and optionally, Carton) to automate building a monolithic package containing your preferred perl version + extra modules from cpan. Install it in your preferred location (e.g., /usr/local). Do not touch the system perl. Do use native packages (e.g., rpm or deb) because then you can easily manage your deployment with puppet/chef/whatever. Do not try to build your own packages for individual modules (at least, not 3rd party ones), because package management is time-consuming and the extra work of maintaining multiple packages will yield nearly zero value. (However, if you expect to change/update your modules frequently, you might benefit from building two packages instead of one: one for perl core and one for your additional modules.) Why not just use perlbrew + cpanm on each system? Predictability. Package installs are atomic and rarely fail, so you can spend less time verifying that your perl + modules actually got installed and are functional.
Then you make a bash script that calls the perl script, and dont waste the Perl script to the one and only use case. Hardcoded paths make all steps around harder, and the gain is literally zero. Also your sysadmins are probably super happy about all those paths on movement then.
Well, we talk about professional software development here, and this kind of workaround are the worst for any team environment. Whatever you think, i dont care, ask some sysadmins what they think if they have to change hosting environment and encounter a lot of hardcoded paths, totally fun for them. It should not be habbit to do it that way. Period. If you don't want to work professional, then it's ok, but don't inject that to others. This is a root of the problem on our market, that people just think "doesn't care how its solved, as long as it is solved", but only making something work is not the job of a programmer, actually every monkey can make software run, you just hack till it works.
perlbrew is made for developers and it is really sad that people just use it in the thought that this is a good way to manage their Perl on the system, while it is not designed for this use case. Standard Perl Installation is even less work and can be integrated as easy. But hey, what to do against the hype, right? ;)
I know your question is answered, however I would like to present ultimate module for web data extraction: http://mojolicio.us/perldoc/Mojo/UserAgent#SYNOPSIS What normally takes ages to achieve using WWW::Mechanize is doable in minutes with Mojo::UserAgent.
What do you get with `perl6 --version` ? Works locally for me through copy paste, but I built my Rakudo five mins before posting &gt;:3 If you put `.first-index` instead should work too. Though that might screw up if you have a parcel. This sort of problem is what is being addressed in the ongoing list refactor. Parcel is going away and everything will be a list. Try some `[]` instead of `()` wrapping the hex numbers and it will likely work for you on an older Rakudo.
I can't check right now, but I think it's whatever is in Ubuntu. So you're probably right that it's just a bit old. 
The `^` is the [*upto* operator](http://doc.perl6.org/language/operators#prefix_%5E). It generates a range from 0 *upto* (but not including) its argument. Note that the range is lazy, so `^1000000` isn't expensive (unless you use all of the elements. So in a REPL, if you typed `say ^6`, you'll just see `0..^6' To see the full range without directly operating on it, you can use the [flattening operator](http://doc.perl6.org/language/operators#prefix_%7C): $ perl6 &gt; say ^6 0..^6 &gt; say |^6 012345
"Up to 6" &gt; say ^6 0..^6 &gt; say (^6).flat 0 1 2 3 4 5
This is a real shortcut for 0..5? The manual range would also be lazy?
Where does that 'roll' come from? Is that really a perl6 keyword? Also, stuff like this is why I have little respect for the Unicode consortium. Dice, and playing cards, and snowmen, and eleventy different smiley faces, shouldn't be in a character set.
["roll" is a method on the List class](http://doc.perl6.org/type/List#routine_roll). It randomly selects a number of items from a list, allowing duplicates. It returns a lazy list. And yeah, I think the Unicode consortium should focus on character sets before toys, but presumably that's not as fun.
Right, if you're building a perl for production use, one can simply use Perl::Build, which provides wrappers around the compile/install scripts (although reading the documentation and doing it manually is not hard at all).
Well, 2013 is not long ago and it's ok with me. Still, I will argue that modules that weren't updated really long are probably abandoned and have unfixed bugs with better probability than they have zero bugs and have no problems at all. But when it wasn't updated in 2014 and it's homepage is down — it feels like if it was last updated in 2005. I tried it already, it seems that it does the job, but I don't know how well (it's property based testing with randomized input after all). Maybe I would be safer if I wrote my own implementation. So, my questions are still not answered.
That is not necessarily true. I have 2 modules on CPAN that I've last updated in 2011. But they are not abandoned. If you were to file a bug today, I'd fix it very quickly. But I just don't want to add any new features, because I like to keep modules small (SRP).
It's your module, right? If I will find a bug I will report at once. I didn't mean your module is bad, I was asking how good is it, no offence given.
Ahh that said, I do enjoy Python!
I feel sorry for Python because its being taught to school children and will become "that crappy language I had to learn at school".
I have such a dislike that it borders on hatred for Java, but at least it can be used to do things. Unfortunately, it _is_ used to do things, too. I learned the basics in college, I think the guy I was responding to was talking about middle/high school, which is when I learned BASIC and Pascal.
No, sorry for confusion, the module in question is not mine. All I was saying is that the last release date is not indicative of abandonment. Some of my modules have not seen new releases in a long time, but I do not consider them abandoned. I just don't want to add anything to them, and nobody has filed any bugs. So they just sit there. However, if there are several RT tickets or GitHub bug reports, and no action, then maybe.
Python is an industry used language being taught by teachers who have never been near industry and in extreme cases, programming. From what I hear from my son, the emphasis is on 'documenting' the code as its written, which appears to mean writing down every bug encountered down to and including 'I typoed the variable'. The experience has put him off tech qualifications :-} 
No answers? I can't test this on my phone
Is there any reason to use one approach over the other?
We don't do it. Our motto is "There's more than one way to do it" and we really mean it. Inclusive in language choice. 
Readability has to do with the communication skills of the author. I can write garbage code in Python and nothing that it does will stop me. The biggest readability issue I run into in any language is run-on functions. The only rule to create and enforce that will resolve that is limiting lines per function or indentation levels as a function of the language.
They still need two passes in the program to run it. If it's a big one, it can take a while. And it can slurp a lot of unnecessary things into memory. They didn't do it because they aren't good enough. Sun wasn't the brightest cookie.
I think something like the following would work. Of course you have to write the process_block sub, and this assumes you're using the default variable. s/(&lt;blockquote&gt;)(.*?)(&lt;\/blockquote&gt;)/$1 . process_block($2) . $3/ge;
But what if there are html tags between the blockquote tags? If you really wanted to do it right, I would use a negative lookahead assertion that said basically "Find everything between the tags, not including another set of blockquote tags", so that you could have blockquotes within blockquotes and still have the regex work. The way I wrote it above, the regex would fail on nested blockquotes, but I was assuming it wouldn't be an issue.
I can see the 'value' in that; learning from mistakes and everything. But not in code-comments. If absolutely necessary, a better place for that would be a journal or something, detailing the things you learn as you go.
I really hate oddities like this. It basically boils down to "who cares" as this is nothing that would ever be used in production code. If you're really using **Modern::Perl**, strict and warnings are enabled by default, so this quiz is pretty much a moot point.
Pascal and Delphi were a reasonably big deal for commercial software in the 80s and 90s, and Visual Basic was considered a serious development tool by many companies. Fashions come and go. And management has a tendency to think "these turbonerds are making programming harder than it really is; we need to switch to a more friendly language to make it easier!"
&gt; many perl projects have made some really unreadable and unclear decisions Oh my god. It seems like every snippet of perl I've ever seen at work has fit this description exactly.
Test::LectroTest has one open "bug" report. It's for a one character typo in the documentation. Compare it to my module Params::Validate::Dependencies, which I know is used in software that has tens of millions of users, and in software that makes millions of pounds. It has two open issues that are about as old, one of which is an actual bug, the other a reasonable feature request. I've not done anything about them because I'm lazy. So much for the time since the last release meaning anything whatsoever about anything!
&gt; But how would Perl6 recognize a range? Extra data type and not a "real" list? A [Range](http://doc.perl6.org/type/Range) is an [Iterable](http://doc.perl6.org/type/Iterable) object that also does the [Positional](http://doc.perl6.org/type/Positional) role. The same is true for a [List](http://doc.perl6.org/type/List). A Range is not a List nor vice-versa, but both of them are both iterable (reading sequentially, one element at a time) and positionally accessible (random read access by numeric index). (An [Array](http://doc.perl6.org/type/Array), which is a List of writable elements, is also always positionally writable, whereas a List is only writable into the individual elements that are individually writable.)
I would be screaming at the wrong person :-( The exam board seems to want to show their working (fortunately its in a separate document)
Are you, perhaps referring to IEEE-754 floating point? I used the accepted answer [here](https://stackoverflow.com/questions/770342/how-can-i-convert-four-characters-into-a-32-bit-ieee-754-float-in-perl) when playing around with the network traffic for WoW. Unpack it with "L" and run it through that function. As I look at it now, my sent data was put through `pack("L", htonl(pack("f", $float)));`so I'm not sure why that couldn't just be inverted for received data: `unpack("f", ntohl(unpack("L", $received_data)));`... there was a lot of blind guesses and trial and error with that project, so I wouldn't be surprised if it's nowhere near optimal. 
Wow. All this hatred for a language that has great uses. A language isn't useless when its being used globally to do lots of things. You know, Perl has a hell of a lot of drawbacks too...
If the author of that site reads this: it's not allowed to use a Catalonian domain if you're not also hosting content in Catalonian Spanish.
3, 4, and 5 all print -foo. As for production code, yes one of these exact incantations is used in the documentation for [HTML::TreeBuilder](http://search.cpan.org/~cjm/HTML-Tree-5.03/lib/HTML/TreeBuilder.pm) − use HTML::TreeBuilder 5 -weak; # Ensure weak references in use which creates the literal string "-weak" as an extra argument passed to the Tree::Builder code.