Maybe give Mojolicious a try. I'm actively working with it and my experience is overwhelmingly positive. Included standalone webserver, websockets, everything. And more lightweight than Catalyst/Dancer. The main advantage of anything non-CGI is that your requests are served by long-running processes, instead of starting up a new process on each request.
simplified highlighting
Make it simple! Now it's totally inconsistent anyway.
Now it's even more inconsistent than your pictures. Look at the constructor call! https://cloud.subogero.com/s/BqV3NN3JjVnfSXI
The nice thing is either Mojolicious or any Plack-based framework (Dancer2 and Web::Simple are two such frameworks with different kinds of "simple") gives you a multitude of options for deployment without changing your code like /u/davorg mentioned. The main benefit of Mojolicious is that it runs its own event loop, giving it the ability to seamlessly execute non-blocking operations while serving requests, particularly useful for Websockets, but not necessary for beginners. The main benefit of Dancer2 is its approachability and simplicity for newcomers; you don't need to learn a vast network of object classes or dive into object-oriented programming, it is all declarative. Mojolicious::Lite presents a similar experience wrapping the full Mojolicious functionality in declarative sugar, but still requires some use of objects. Either of those gets unwieldy for larger applications, so you may want to leverage the full Mojolicious setup for such an application. Web::Simple and Catalyst and other Plack/PSGI based frameworks each have their own niches as well, but they aren't really optimized for newcomers. Here is mst's comparison of the options: http://shadow.cat/blog/matt-s-trout/mstpan-1/
I commented in a recent thread on the same topic: https://www.reddit.com/r/perl/comments/70btyx/how_do_we_prevent_similar_malicious_modules_in/
The sigil states the type of the resulting expression. `%foo` refers to the hash as a whole, so it uses the hash sigil `%`. `$foo{"Me"}` is a single (scalar) value extracted from the hash so it has the sigil for a scalar. If you were to write `$foo` that would be referring to a completely separate and unrelated variable. Nothing in this example involves references. 
Thank you. That may have been the source of my confusion. What if I have an array as a hash value?
%{$arr[0]} 
Hash values are always scalars. The value could be a reference to an array or hash, though, in which case you need to dereference that to refer to its values. my %foo = (a =&gt; [2,3]); my $last = ${$foo{a}}[1]; # or $foo{a}-&gt;[1]; # simplified with arrow-dereference syntax, or $foo{a}[1]; # arrows between two element accesses can be omitted The `@` sigil, on the other hand, can be used on a hash to get a slice, or in other words, a list of values from the hash corresponding to a list of keys. my %foo = (a =&gt; 1, b =&gt; 2, c =&gt; 3); my @values = @foo{'a','c'}; # @values now contains 1 and 3 There are lots of perldocs on each aspect of this: * https://metacpan.org/pod/perldata * https://metacpan.org/pod/perlreftut * https://metacpan.org/pod/perlref * https://metacpan.org/pod/perllol
&gt; Consumer-class microcomputers tended to have memory-mapped character displays For example, on a [Commodore PET](https://en.wikipedia.org/wiki/Commodore_PET), you drawed a character on the screen (40x25 characters monochrome) by `POKE`ing to a certain memory address range. `PEEK` and `POKE` were BASIC commands for reading from / writing to memory. Characters could also be graphical symbols. 
**Commodore PET** The Commodore PET (Personal Electronic Transactor) is a line of home/personal computers produced starting in 1977 by Commodore International. A top-seller in the Canadian and United States educational markets, it was Commodore's first full-featured computer, and formed the basis for their entire 8-bit product line, including the Commodore 64. The first model, which was named the PET 2001, was the third personal computer ever made available to retail consumers, after the Apple II and TRS-80. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
And in [5.20+](https://metacpan.org/pod/perl5200delta#New-slice-syntax), you can even use %new_hash = %old_hash{ 'key1', 'key2' };
There are no references in your example code. (Hint: lack of `-&gt;`.) The sigil refers to the **mode of access** to the data structure. my %foo = ( Me =&gt; "person", You =&gt; "beloved one", Them =&gt; "space aliens", ); `%foo` is the whole hash. `$foo{"Me"}` accesses a single value, hence the `$`. `@foo{qw(You Me)}` accesses multiple values, hence the `@`. Similar for an array: my @bar = qw(Me You Them); `@bar` is the whole array. `$bar[0]` accesses a single value, hence the `$`. `@bar[2, 1]` accesses multiple values, hence the `@`. ---- That I needed to explain this to you means your source of information for learning Perl is really shoddy. Get rid of the (person|book|tutorial) and replace it with a good one: http://perl-tutorial.org/
[Kate](http://enwp.org/Kate_%28text_editor%29#Features) shows a similar defect: https://jsfiddle.net/0j0734u8/ I would like, if possible, you to co√∂rdinate your change with other major syntax highlighters.
I remember a loong time ago, someone uploaded a distro that did something naughty, think it was deleting something. This was "to prove a point" that you shouldn't just install things without looking at it, and the distro was taken down by the same person quite quickly when people were upset.
I use Dancer, it's pretty easy to grasp, especially with the [cheat sheet](http://perldancer.org/resources/dancer-cheat-sheet.pdf)
I'll provide a slightly different tack to the others' answers... **The sigil specifies what type of result you're dealing with: `%` for key/value pair(s), `@` for a list of values, and `$` for a single value.** Thus you have: use feature qw/say/; my %h = (foo =&gt; 42, bar =&gt; 70, ber =&gt; 100); # key/value pair(s) say join ', ', $h{foo}; # output 42 # a single value say join ', ', %h{foo}; # output foo, 42 # key/value pair(s) say join ', ', @h{qw/foo bar/}; # output 42, 70 # a list of values my @a = qw/foo bar ber/; # a list of values say join ', ', $a[1]; # output bar # a single value say join ', ', @a[1, 2]; # output bar, ber # a list of valeus my $s = 42; # a single value say $s; # output 42 # a single value ----- Arrays and Hashes can only contain scalar (single) values, so you can't store other arrays and hashes in them directly, but it can be done with references that take a hash/array and return a scalar "reference" to the original entity (or the anonymous one). The same pattern for sigils follows with references, just with the addition that you use the reference variable (including its scalar sigil) where you'd normally use a hash or array my $h = {foo =&gt; 42, bar =&gt; 70, ber =&gt; 100}; # a single value (scalar ref to anon hash) say join ', ', $$h{foo}; # output 42 # a single value say join ', ', %$h{foo}; # output foo, 42 # key/value pair(s) say join ', ', @$h{qw/foo bar/}; # output 42, 70 # a list of values my $l = [qw/foo bar ber/]; # a single value (scalar ref to anon array) say join ', ', $$l[1]; # output bar # a single value say join ', ', @$l[1, 2]; # output bar, ber # a list of valeus my $s = \42; # a single value (scalar ref to a scalar) say $$s; # output 42 # a single value Sometimes you'll have more complex expressions where you get your references from, and to disambiguate, you simply wrap them up into { }: my $refs = { # a single value (scalar ref to anon hash that has our other refs) h =&gt; {foo =&gt; 42, bar =&gt; 70, ber =&gt; 100}, # a single value (scalar ref to anon hash) a =&gt; [qw/foo bar ber/], # a single value (scalar ref to anon array) s =&gt; \42, # a single value (scalar ref to a scalar) }; say join ', ', ${$$refs{h}}{foo}; # output 42 # a single value say join ', ', %{$$refs{h}}{foo}; # output foo, 42 # key/value pair(s) say join ', ', @{$$refs{h}}{qw/foo bar/}; # output 42, 70 # a list of values say join ', ', ${$$refs{a}}[1]; # output bar # a single value say join ', ', @{$$refs{a}}[1, 2]; # output bar, ber # a list of valeus say ${$$refs{s}}; # output 42 # a single value As you can notice, this quickly becomes a royal mess, so alternative syntax exists, to dereference another scalar, the `-&gt;` arrow. You can put it after each step in the chain of dereference, but because it's known the contents can only be scalars, only one arrow at the start of the chain is required; the rest are implied. And if you want to access data in pairs or list of values view, simply use the appropriate sigil, wrapping stuff in { }, as before: my $refs = { # a single value (scalar ref to anon hash that has our other refs) h =&gt; {foo =&gt; 42, bar =&gt; 70, ber =&gt; 100}, # a single value (scalar ref to anon hash) a =&gt; [qw/foo bar ber/], # a single value (scalar ref to anon array) s =&gt; \42, # a single value (scalar ref to a scalar) }; say join ', ', $refs-&gt;{h} {foo}; # output 42 # a single value say join ', ', %{$refs-&gt;{h}}{foo}; # output foo, 42 # key/value pair(s) say join ', ', @{$refs-&gt;{h}}{qw/foo bar/}; # output 42, 70 # a list of values say join ', ', $refs-&gt;{a} [1]; # output bar # a single value say join ', ', @{$refs-&gt;{a}}[1, 2]; # output bar, ber # a list of valeus say ${$refs-&gt;{s}}; # output 42 # a single value Now, even this syntax is kinda gross, so newer perls have somewhat more awesome syntax where you just follow the dereference chain (instead of going back and wrapping stuff in {}). It uses the `-&gt;` arrow, followed by the sigil showing what sort of values you want my $refs = { # a single value (scalar ref to anon hash that has our other refs) h =&gt; {foo =&gt; 42, bar =&gt; 70, ber =&gt; 100}, # a single value (scalar ref to anon hash) a =&gt; [qw/foo bar ber/], # a single value (scalar ref to anon array) s =&gt; \42, # a single value (scalar ref to a scalar) }; say join ', ', $refs-&gt;{h} {foo}; # output 42 # a single value say join ', ', $refs-&gt;{h}-&gt;%{foo}; # output foo, 42 # key/value pair(s) say join ', ', $refs-&gt;{h}-&gt;@{qw/foo bar/}; # output 42, 70 # a list of values say join ', ', $refs-&gt;{a} [1]; # output bar # a single value say join ', ', $refs-&gt;{a}-&gt;@[1, 2]; # output bar, ber # a list of values say $refs-&gt;{s}-&gt;$*; # output 42 # a single value As you can see in the last example, simply use an asterisk at the end, if you don't have any more things to refine your statement further. That about sums it up. And to put the cherry on top: the most basic examples with just the sigils on variable name indicate what type of stuff the variable got inside. To ensure variable names do not clash, if you don't specify anything (like keys, indices), it's assumed you're just refering to that variable, so `@h` means variable `@h`, not "list of values view of variable `h`" my %v = (0 =&gt; 70, 1 =&gt; 13); my @v = (22, 33); my $v = 42; say %v; # output 070113 # just the contents of the %h variable say @v; # output 2233 # just the contents of the @h variable say $v; # output 42 # just the contents of the $v variable Hope that helps \o 
That would be ideal, but AFAIK Kate uses a completely different way of specifying how a language is highlighted. At best we could settle on a common corpus of code to highlight and make sure all editors highlight that corpus consistently.
I've been writing perl for nearly 20 years and you taught me some new things with this fantastic post. Thanks.
&gt; it seems that Perl 6 is a whole new language with new runtimes Yes, it's a completely separate language, with some people even refusing to call it `Perl 6` at all, to avoid confusion (I call it "Rakudo" at the moment). The good ol' Perl still continues its life, though, with major versions offering new features, now being a subversion of 5 (e.g. latest major release is 5.26, released 3 months ago). &gt; Is it compatible with CPAN? You can upload Rakudo modules to CPAN and the module installer will install them. If you're asking whether Perl modules can be used with Rakudo, there exist [Inline::Perl5](https://modules.perl6.org/dist/Inline::Perl5) module that promises to make the process of using Perl modules painless and I heard some people swear by it, but personally I had troubled experiences with it (maybe I'm just Doing It Wrong‚Ñ¢). &gt; Frameworks like Catalyst? The major kids on the block are [Cro](http://mi.cro.services/) and [Bailador](http://bailador.net/). Both are relatively new, needing polish. &gt; Has it seen any adoption? Yes, some. We have [website visitor stats](http://www.p6c.org/stats/) available if there's any direction can be gleaned from them. Once in a blue moon someone says they're using Rakudo for work; once in a while someone says they're using it in production; I had one or two people say they're using it to teach a class; and on occasion people drop links to things written in Rakudo, which seem to work OK: e.g. https://utiaji.org/ The adoption is (was?) hindered by [poor performance](http://news.perlfoundation.org/2017/07/grant-extension-approved-perl-.html), [small ecosystem](http://modules.perl6.org/search/?q=), and (IMO) confusion over the naming: people who don't like Perl think it's just the next major version and never bother trying the nice new language. Though, yesterday I had [an argument](https://irclog.perlgeek.de/perl6/2017-09-18#i_15182392) with someone saying performance is good enough, so perhaps all the [recent work on improving the optimizer](https://6guts.wordpress.com/) is paying off. Over the past year we saw [a whole ton of books](https://perl6book.com/) spring to life, so I'd expect growth to continue. ------ And to answer the titular question: *Relevance of Perl 5?* It depends on whom you ask. Some stats show it dropping, others growing. Personally, I use it for its polished tools like [Mojolicious](http://mojolicious.org/), but I prefer Rakudo whenever I can use it, because it's [concise](https://raw.githubusercontent.com/perl6/marketing/master/TablePosters/Rakudo-Concise/Rakudo-Concise-300ppi.png) and fun to write. Your implied question is whether people are abandoning Perl into irrelevance in favour of Rakudo; not really, as they're separate languages [with different strengths](https://rakudo.party/post/The-Hot-New-Language-Named-Rakudo#fo6.dforthought). Some use one or the other. Some use both. Just like some folks use Ruby instead of Perl.
I love Perl 5 and will keep writing in it for my existing, unfinished hobby projects. I'd love to try Perl 6, but I promised to myself to finish all my Perl 5 projects first. 
Today, September 19th 2017 : NET::ERR_CERT_AUTHORITY_INVALID
Down again ! NET::ERR_CERT_AUTHORITY_INVALID
I wandered through and this answer solved a problem I just happened to be working on. Cheers to you. 
So I've kind of gotten a handle on this, I think. my $user = { name =&gt; "Tom", email =&gt; 'tom@example.com' }; # scalar ref to anon hash my %params = ( whatever =&gt; "Don't care", user =&gt; $user ); # regular hash with a scalar ref to a hash #printing out pairs for the user hash: for my $key (keys %{ $params{user} }) { say "$key: $params{user}{$key}"; } This gives the output I expect. Is there a more idiomatic way to go about something like this? Or is this a valid and clear implementation of this process according to average Perl standards? Thank you for your very thoughtful response by the way. 
This all looks quite standard, and is the usual way you'd see these things done. If you're on perl 5.24+, you can use the slightly less ugly [postfix dereference](https://metacpan.org/pod/perlref#Postfix-Dereference-Syntax) (which is mostly nice for its [slice syntax](https://metacpan.org/pod/perlref#Postfix-Reference-Slicing)): for my $key (keys $params{user}-&gt;%*) {
Great walkthrough but there's one more option here since 5.20 (when key-value slices for hashes were added): [index-value slices](https://metacpan.org/pod/perldata#Index/Value-Array-Slices) for arrays, also using the `%` sigil. my @a = qw/foo bar ber/; say join ', ', %a[0,2]; # 0, foo, 2, ber (Also, try not to use `$a` even in examples, it's a global for sort() and using it as a lexical leads to tricky problems. `@a` and `%a` don't have this problem.)
A distro can do anything in its Makefile.PL or Build.PL, as it's just perl code which the cpan installer will dutifully execute. This is a good argument for not installing modules as root (except via distro packages), and using local::lib or a local perl install/perlbrew/plenv instead. That won't help if the module decides to delete the contents of your home directory of course. Here's a particularly nasty example which isn't even intentionally malicious - this has caused issues on cpantesters thus the giant monologue the author added at the beginning: https://metacpan.org/source/REEDFISH/Net-FullAuto-1.0000394/Makefile.PL
I went through the courses a couple of years ago, and I had a great experience with it! https://geekuni.com/certification/validate/DE8580A https://geekuni.com/certification/validate/AD95D3BF I used to be a QA tester before having the opportunity to move into development. Most of my work involved writing/modifying bespoke templates with some Perl subroutines thrown in, and to start off with a lot of the Perl code just went over my head. I started the course after Andrew Solomon began doing some contract work for my previous employer. It was quite challenging at first (given I didn't come from a development background), but I found the course engaging and Andrew was happy to help when things didn't quite make sense. A few months after completing the course I went looking for a job elsewhere to put my newly acquired knowledge to work, and ended up taking a junior Perl dev role which was ¬£5k higher than my previous salary. I'm now working as a full-fledged developer, and as well as writing Perl for work I also maintain the Perl 5 and 6 exercism.io tracks. I would personally highly recommend the course. It had a significant impact on my coding skills and career path, and I don't think I'd be in the same position as I am now without it!
Perl 5 is everywhere and runs on almost anything. It has an exceptionally quick start-up time which makes it ideal for quick-and-dirty CGI scripts or maintenance tasks which can be launched from `xargs` or `find`. Perl 5 does struggle on the multi-process and multi-thread front. Well, I lie, multi-process is handled pretty well, actually. But multi-threading really is awful. Perl 6 is exciting. It offers longer-running processes JIT hotspot performance improvement, and superior multi-threading/parallelism support. The language itself has strong typing and many features from language development over the last twenty odd years. But Perl 6 start up is still very slow compared to Perl 5 today. So a quick-and-dirty Perl 6 script is just not going to cut it today - particularly if that script needs to be called thousands of time. So how relevant is Perl 5 today? Pretty relevant if you have some sysadmin tasks to make your life easier or faster. Pretty relevant if you need to automate something (plenty of libraries available that support practically every popular network protocol - even unpopular protocols). Pretty relevant if you need a CGI script in a hurry that still performs reasonably well. Oh, and Perl 5 has something very few languages have, even today. [**Taint mode**](http://perldoc.perl.org/perlsec.html). Can you *believe* that even after all this time that other scripting languages haven't adopted such an utterly mind-blowingly fantastic idea? How has the world of "technology security" evolved and yet Taint mode isn't *everywhere*!? Seriously - if you did any kind of human interface development - and were serious about not getting hacked - Taint mode should be top of your list. It doesn't fix everything but it sure makes you remember to at least sanitise your inputs.
Wait people still need CGI scripts?
Why not? On a cheap $2.50 or $5/month virtual server with limited memory there is something reassuring about the web application (process) being completely unloaded from memory when unused.
Yes. Still the fastest and easiest way to knock together a userspace interface to something. 
Are you serious?!
Yep. Still use perl daily. It's a multi platform tool that does what a lot of Unix tools do. It's great for scripting, because whilst bash is slowly growing features, it's still lagging. And python suffers from trying to be too serious. I find it's lack of precompilation quite irksome too - strict and warnings are valuable to me in perl.(And syntactically significant whitespace does my head in) But perl has some truly excellent XML parsers for example. I disagree with you in threading. I have used perl threads quite frequently, and they work fine. The biggest gotcha is assuming they are lightweight, like they are in some other languages, when they aren't. And for all it starts as a simple one liner, perl can do object oriented, parallel code quite readily, and with perltidy, strict and warnings you get some very readable code. I mean, the biggest criticism I have heard is that perl is "write only", but I contend you can write bad code in any language. (In perl, it's often regex that's at fault anyway)
Thank you. 
I started my course 3 or 4 years ago at the London Perl Workshop. We had some hours in a lecture room together with Andrew, and doing the rest from home. The course was good prepared and Andrew is very quick if you have a problem. What i also like, is the fact that you do not need your own developing environment. All programming tasks run in an browser environment =&gt; you can do your coding on your cellphone.
&gt; Down again ! NET::ERR_CERT_AUTHORITY_INVALID http is fine, https is now 404ing for me. I will prod my contacts to get this fixed.
Server side JPList UI Demo using JPList module https://jplistdemo-catalyst-perl.herokuapp.com/datasources
Yes, we just call them "Serverless" nowadays :P
&gt; Perl 5 has something very few languages have, even today. Let me add the glorious but unsexy killer feature: Perl 5 is well-maintained and *stable*. I can run all the code that I've written over *decades* on current Perl 5. I value Perl's remarkable stability. Consider the continuing cluster fuck of C++. Plain old C is a better bet. Python v2 to v3 is a complete break; v3 is better than v2, but v3.4 to v3.6 is full of headaches. Python's readability means little to me without stability. And the cost of Python's readability is that folks may avoid awk and sed; I don't care what glib *pythonistas* say, *that* in itself would be a sad failure to use great tooling. Learn to write clean Perl 5. And if Perl 6 avoids the mess of Python v2-v3 and can emulate Perl 5's stability, I will be using it. 
https://i.imgur.com/IHcMYJj.png Use [font-relative units](https://www.w3.org/TR/css3-values/#font-relative-lengths), not absolute.
Perl 6 is not Perl. I don't think posts about it should even be considered on-topic here. I tried it, and both the performance and the syntax was awful. As in, around 0.5 seconds just to start execution, and as far as syntax, capital letters just everywhere. Sometimes entire words capitalized. I use Perl in my dev environment, which I SSH into, and it is a nightmare to try to type Perl 6 code. People defend this by saying I should be using a modern development, but seriously, for a scripting language, just fuck off, that's ridiculous. So a better title would be "relevance of Perl 6", and the answer is it isn't.
I guess the terminology caught me. FCGI is still big in PHP, but when I think perl and CGI, I think the CGI module and the perf issue that come after a certain number of connections
&gt; for a scripting language, just fuck off, that's ridiculous. Maybe don't think of Perl 6 as a "scripting language".
Typing capital lEtTeRs is a struggle for you over SSH? Also if you are typing all caps words in Perl 6 its by definition a code smell, or shout in this case. You're meant to want to minimise how often you type them.... that was literally the point. I'd also like to point to [this specific bit of the Perl 5 docs](https://perldoc.perl.org/perlmod.html#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END).
The CGI module is pretty obsolete, but CGI itself is still useful in cases where you don't need to scale so the inherent performance issue of restarting the code on each request isn't a problem. You can write scripts for CGI using any of the modern web frameworks (and as a bonus they can then seamlessly be deployed in other ways).
I was a beta tester when Andrew set up various test modules. The test environment is one that is realistic allowing you to experience real life scenarios. I had struggled with the perl tutorials offered on perldoc.perl.org; especially with the more advanced hash/array references. Geekuni gives you real life use case scenarios where you get more than your share of opportunities to learn this concept. Hats off to Geekuni
&gt; there's one more option here since 5.20 Oh, cool. TIL! &gt; Also, try not to use $a even in examples Oh, yeah. Totally forgot about that one :) I edited my OP, changing `$a` to `$l` 
strawberryperl.com is currently an http-only site. port 443 happens to be open on the shared hosting box it's running on, but should not be expected to work.
Would you be willing to paste a couple examples of the code that you tried to type?
Sorry you had a negative experience with the language. Hope you'll try it out again in a couple of years. *hugs*
&gt; and can emulate Perl 5's stability, I will be using it. Great :) We actually hope to do good on stability. Design-wise at least, it's yet to start being applied in a strict fashion. We'll start using multi-version compilers in 2018 and see how it goes. Basically changes to language are implemented additively and you can specify with a pragma which language version you want to use in a single comp unit (e.g. a module). So if you write a module for `6.c` language, just put `use v6.c` at the top of the file and even a compiler that offers new features in, say, `6.d` language would still run that particular module under 6.c language, and if some other module wants 6.d language in *the same program*, it can have it. So you get the ability to implement new features and behaviours without breaking old code that relies on earlier language versions.
I don't know what all caps words your talking about, but I'm going to presume you mean things like `CATCH`, which is called a "phaser". Perl 5 has them too, eg. `BEGIN`, or `CHECK`. These are made to stand out because when these blocks run is outside the standard flow control. Also, every single line of perl (5 &amp; 6) I've ever written is done via SSH, so I don't get this complaint.
The Perl Essentials course gives you a good explanation of all key elements of Perl. Additionally you get to use the Perl tools by building (and at same time testing) a fairly complex application. I still refer to the code of this application for problems I need to solve nowadays. By participating in the course you‚Äôre forced to use your knowledge actively (as opposed to browsing code online or from a book) and your code answers are reviewed by the tutor-bot. Additionally Andrew is always helpful in providing additional explanation if needed! Definitely worthwhile. Same counts for the Web Development course where you get to use the Perl Dancer framework. 
Jesus. How many times a week are we going to see this kind of posts? **Yes**, Perl is not the hotness it used to be a few years ago. I don't care. I still love the language and will continue to use it until the day I die. Let the cool kids use whatever tool is hot today, and deal with all its instabilities, dependency hell, version breakage, etc. Give me good ol' stable Perl any day. Edit: As the matter of fact, I think OP is a bot given its comment history and age. Mods, please take a look at it? Thanks.
lol no im not a bot. I like analysing trends using traffic data. its my hobby! edit: its pretty accurate actually most of the time
in this particular case perl.org is loosing visitors. they recently major redesign. I wonder if they set up proper 303 redirects for search engines to correctly keeps the old pages' ranks.
Stats that go back two months aren't exactly compelling. Show us something that goes back twenty years and we can talk.
BSD is dying. Netcraft confirms it.
good ol' stable Perl (except for the massive major version breakages) :P
Haha, I see what you're saying! But still. I only use the modules I truly, _truly_ need (so, no left-pad nonsense), and I rarely have issues when upgrading. I think the only major one came up when they changed the syntax of their string packing function, but that was like, 10 years ago. Edit: Oh, you're referring the Perl 5 --&gt; 6 shenanigan. Hehe, I see it now.
Perl 5 to 6 is not a major version difference. It's a different language.
Yes. I know that. And I know /u/i_love_limes was joking.
In the comments, you claim you like analyzing data, yet you link to a site that uses poorly constructed charts that don't have axis starting at zero. Even if you zoom out to 1 year of data and take the highest peak measured against the lowest trough, the change is **-1%**. That's also just visitors to perl.org. In my ~15 years of using Perl, I've visited that site twice at most. Claiming a piece of software is slowly losing users because one of its less-used sites had 1% of users fewer last month than a year ago is a bit of a stretch, wouldn't you say? In fact, [metacpan.org's stats](https://www.trafiklite.com/metacpan.org) show an entirely different picture. 
Hot grits are in decline and Natalie Portman is starving.
 Still can't find anything better for system admin task such as processing various logs, dealing with mysql databases and simple web crawling. 
usually there is a strong correlation between visits to the main website and users. this study finds the same thing: [20 most used languages](http://www.business2community.com/tech-gadgets/top-20-popular-programming-languages-2017-01791470#4Cqc7zTaXoMYBfPp.97) 
Yeah, but with something like perl, I think you'd be hard-pressed to find a "main site." Sorry, bub, but this is not a good indicator.
So's COBOL. Apparently. 
But 1% change is statistically insignificant. Yes, you can find *some* stats showing Perl's decline, but OP was making the conclusion using data from this specific website that doesn't actually show any real decline. 
Maybe not a bot, but useless troll, definitely.
Another reason it shouldn't be called "Perl 6". Not only is it a different language (which should be enough to change the name), but it serves a different purpose as well. As a counter example: Python 3 was an incremental change to Python 2, but v3 is extremely close to v2 (almost identical), and v3 has the same goals as v2 (general purpose scripting, glue). And even at *that* the transition took quite a while. The Perl 6 team has even said that Perl 6 is a "sister language" to Perl 5. So, it makes even less sense that they're hanging onto to the Perl name. I realize Perl 6 / Rakudo is perlish, that it has many similarities to Perl 5, but that's not enough of a reason to give it the same name as an existing language.
Beside the fact, that Perl 5 (and 6) is powerfull, the community is very friendly and helpfull it's not just a fact of those ponints, money is also relevant. If you have to eran money for living, you should concider "stackexchanges Developer Survey Results 2017" https://insights.stackoverflow.com/survey/2017#technology-top-paying-technologies-us Here you can see that Perl (5 I guess) is worldwide no 6 in the ranking with $63068 in front of many other languages most of us guess better. In US Perl is 5th with $105000.
It's a bug in one of the dependencies. Specifically, this line in Text::Reform - https://metacpan.org/source/CHORNY/Text-Reform-1.20/lib/Text/Reform.pm#L350 causes a reference cycle: my $tmp = $config-&gt;{header}; $config-&gt;{header} = sub { my $header = &amp;$tmp; return (ref $header eq 'HASH') ? lcr($header,$config-&gt;{pagewidth},'header')-&gt;() : $header; } due to the usage of $config inside that coderef. Reported as https://rt.cpan.org/Ticket/Display.html?id=123105 If you're looking to build up some skills, tracking this sort of issue is much easier with 3 tools: * Devel::MAT (and the GTK interface https://metacpan.org/pod/App::Devel::MAT::Explorer::GTK) * Devel::Cycle * Test::RefCount with that first one, it took about two minutes to run your test script with a smaller number of iterations, sort by counts in pmat-explore-gtk, then look at the line of code that it referred to: https://prnt.sc/gobfjm 
We are all aware of the general preference younger users have for other languages. You chose a really crappy measurement and illustration, with a bad sample size, to what? Troll us? I don't write in perl because I think it makes me cool. Declining usage numbers, whether they're genuine or not, won't dissuade me. I write in perl because it's brilliant.
Yeah, I tried to use Devel::Cycle (and a few other Devel modules) before chopping it down to this example, and it was pretty hard for me on a much larger piece of code. But now that I have a small piece it should be good to learn to use it, see how it works, so I know how to apply it in the future. Thanks! And thank you for logging the bug.
The current working directory is a per-process value. When you use `system()` you're creating a child process. Running `cd` in that child process changes the current working directory for that process, not the parent process. If `cd` was the only thing run in that process, as in your example, then it has no effect at all, because the child process terminates after running the specified command. You either need to change the current working directory of the perl process (using [`chdir()`](https://perldoc.perl.org/perlfunc.html#chdir-EXPR), not `system()`) or you need to change the current working directory in the same child process that is going to execute the script, e.g. `system("cd /foo/bar &amp;&amp; baz")`. You could also avoid the shell by doing a `fork()`, then in the child process do a `chdir()`, and then `exec()` the script. That way is also much safer in that it eliminates shell injection vulnerabilities. There is probably a CPAN module that will do that in a safe and cross-platform manner, for platforms that don't use fork. 
Can you clarify the "CD /Foo/bar &amp;&amp; baz"? What's the &amp;&amp; baz?
`system()` runs the given string using the system's default shell, which I'm assuming on your particular platform is a Bourne-like shell since your example uses `mkdir`. (Edit: also, it's not a good idea to shell out for these kinds of things. Use the functions perl provides.) Read up on Bourne shell syntax. The `&amp;&amp;` is used for running a second command if the first succeeded.
Each system() call is an independent shell env. You want to change the working dir of the environment of the script running to have it last between calls: https://perldoc.perl.org/functions/chdir.html
This is the key point really. 
Doesn't that lead to the same problem I encountered at first? E.g. my $a = "caaamel"; print "matched $1" if $a =~ /[^c](a+mel)/; Output is: matched aamel
Oh OK...that won't work :(
As others have explained, system creates a child process and the 'cd' runs in the child process so does not affect the parent. But if you do the 'cd' in the Perl script, then that will affect child processes run via system. Perl has built-in functions for making a directory and for changing into a directory: #!/usr/bin/perl use 5.012; use strict; use warnings; use autodie; mkdir('dir1'); chdir('dir1'); system("/home/script2"); Check the documentation for more info about [Perl's built-in functions](http://perldoc.perl.org/perlfunc.html).
The basic problem is that regexes are always evaluated left-to-right, and only go back to the left (backtrack) to parts that already successfully matched. So the `a+` will match as many a's as it can starting at the first `a` that's not preceded by `c`. There's no way to tell it to match as *early* as it can, because it already decided the first `a` after a `c` won't match. Instead you want an `a+` following a `c` to not be able to succesfully match at all. It turns out this logic is much simpler in reverse, but doesn't need variable lookaheads: if (reverse($str) =~ m/(lema++)(?!c)/) { my $match = reverse $1; } The extra `+` attached to `a+` is a modifier that prevents backtracking and can also be written `(?&gt;a+)`. So it will match as many `a`s as possible and if a `c` is found afterward, it won't backtrack to try that part of the string anymore. See https://metacpan.org/pod/perlre#(?%3Epattern) and https://metacpan.org/pod/perlretut#Using-independent-subexpressions-to-prevent-backtracking (Your positive/negative lookbehind combination will fail when the `a+` is at the start of the string.)
I also recommend using either https://metacpan.org/pod/File::chdir or https://metacpan.org/pod/File::pushd so the directory is only changed in that scope.
Thanks for your input. &gt; Your positive/negative lookbehind combination will fail when the a+ is at the start of the string. I realize that, but for my particular purposes I happen to know that the expression cannot possibly be at the start of my string. I suppose I could address that issue with a well-placed \b but in my situation it doesn't matter.
And they wonder why people shop Amazon and not brick and mortar book stores
I did think the book looked interesting.
Outdated version not withstanding
You may have just been unlucky, I got the perl one liners book at B and N recently.
Wow and my work is still running perl 5.14
You can't expect a brick and motor store to have all books about niche subjects. 
I was going to say the same. It's sad but physical stores just can't compete with amazon. Having instant access to thousands of reviews from real customers is a game changer. Being able to buy products from home any time day or night is a game changer. Instant book downloads to a kindle is also a game changer. I can literally sit on a beach with nothing but a kindle and a wifi or phone signal and buy any of a massive selection of perl books and get them cheaper than the dead-tree versions.
"Outdated"? From [what I can see](http://modernperlbooks.com/) 4th edition is the latest.
Modern Perl is an excellent choice when you are only exhibiting a single Perl book. 
And yet so much PHP. Ugh.
My bad, I took the 4 to be Perl 4, not the edition #. Still why would I drive to a physical store when they have 1 book on a topic when I can find a dozen or more choices online
For context that was released 6 years ago, equivalent versions of other languages at the time: PHP 5.3, Python 3.2/2.7(v2 is frozen in time), and Ruby at 1.9. Languages like Swift and Julia didn't even vaguely exist, and Go, Rust and node.js had just been released. Six years is a long time in the world of programming languages.
You‚Äôre telling me
I typically haunt B&amp;N a few times a month as I love bookstores...practically was raised in one. I check the programming section regularly and most of what you see is Python, JavaScript, Java, C, C++, &amp; PHP. I have been lucky enough in the past (only 1 Perl book now) to buy Programming Perl (Camel book), Learning Perl (Llama book), Beginning Perl (Lee, not Ovid's book...had to buy his online), and Perl one-liners. All my other Perl books have come from Amazon and were dirt cheap as they were old. I'd love to see a new Perl5 book that isn't focused on learning the language. I'd like to see 15 projects in Perl...kind of like "Python Playground" (also sold at B&amp;N). It's cool that your store has Modern Perl. I'd buy a paper copy in that case (only do online shopping rarely).
Yes, I am glad it's this book and not one of the many vastly outdated ones, as is the usual problem with a language this old.
And yet, it's still worlds better than the [large number](http://cpanmetadb.plackperl.org/versions/) of perl users still stuck with 5.10.1 because it's the version used by RHEL/CentOS 6. Perl 5.14 lets you use keyword modules, exceptions no longer disappear in object destruction, global destruction can be reliably detected with `${^GLOBAL_PHASE}`, and [all of these regex features](https://metacpan.org/pod/perl5140delta#Regular-Expressions) are available.
I see what you did there.
I feel sorry for anyone "stuck" using CentOS 6 :( My last experience of CentOS was the libc was too out of date to compile a really simple piece of academic software. So its not just perl. Though I've personally never relied on the system perl wherever I am whatever I'm doing.
I can think of worse things.
Hi, perhaps you could also look at one of dependency injection modules on CPAN. Based on personal experience, I would recommend you to look at Beam::Wire module. Regards, Jan
Also the version on AIX 7. Don't ask, I cry inside every time I think of supporting AIX.
I started the course at a London Perl Workshop. As an experienced developer, I particularly liked the 'hands-on, learning by doing' aspect of the course. Andrew was always very responsive to any queries I had and would carefully 'nudge' me in the right direction. I found the certification option useful as it allowed me to 'benchmark' my Perl expertise.
Runing the editor with 0 == system 'editor', $filename or die $?; should wait until you close the editor. What have you tried?
It's not working, still continues running next subroutines. My code is: subroutine1 0 == system 'gvim', "$WORKDIR/$FILE_TEST" or die $?; subroutine2 once the file opens, the subroutine2 goes on to run like usual
generally, when i open a file with my editor, it doesnt take overmy terminal. How can i force it to take over the terminal so that when i open it from the perl script, it will take over the terminal and not continue until its closed?
use File::Temp;
Don't use a GUI editor? 
Lol, right?
Remove the g from gvim:P
Run `gvim` with the `-f` or `--nofork` option. As an aside, also consider checking for $VISUAL then $EDITOR before using a hard-coded editor. Note that $VISUAL or $EDITOR may contain spaces and command-line options. use Text::ParseWords qw(shellwords); my $filename = ...; my $editor = $ENV{VISUAL} || $ENV{EDITOR} || "gvim -f"; sub1; 0 == system shellwords($editor), $filename or die $?; sub2;
The OP's issue is that `gvim` forks. Being a GUI has nothing to do with the problem. `emacs`, for example, doesn't fork when invoked in GUI mode.
You can't fire up an editor and save things in your SSH mode?
CGI::Application is a completely separate module and should be installed independently of CGI.
In addition, if you want your snippet to work, you have to delete the `-M` switch.
Thanks, I didn't realize that
Thanks, I removed the -M and just did perl CGI::Application -e'print $_ . " =&gt; " . $INC{$_} . "\n" for keys %INC' and got 'Can't open perl script "CGI::Application": No such file or directory' So it looks like I need to install CGI::Application
Savior!
&gt; if you want your snippet to work, you have to delete the `-M` switch That's wrong. `-M` is the command line option to pre-load a module. It is required here. Not sure why you think it needs to be removed.
You're right that it looks like the CGI::Application module needs to be installed. You're wrong that this module has any connection to the CGI module. In Perl, modules with similar names need not have any connection with each other.
Thanks, I guess I was misunderstanding what the :: meant
Maybe this will help clarify: http://cpanmeta.grinnz.com/#~CGI:: Some modules, like CGI::Carp and CGI::Cookie, are contained in the CGI distribution (which you can preview [here](https://metacpan.org/release/CGI)), but many are just CGI (the protocol)-related modules in separate distributions.
Generally a decent recommendation, but the OP may have specific reasons to have $WORKDIR and/or $FILE_TEST pointing to specific locations.
void-context `split` only dumped its results into `@_` in versions of perl from before the year 2010. For compatibility (not to mention readability), use an explicit variable. while (&lt;&gt;) { my @fields = split; splice @fields, 1, 1; print "@fields\n"; }
Thank you so much. That works perfectly.
The `::` just means "replace this with a directory separator when working out the name of the file which contains this module". It's purely about naming. Obviously, you would hope that packages with names starting with "CGI" have some connection to the CGI protocol. But they don't necessarily have any connection with each other.
Here is what I have so far and it doesn't work. Oy. #!/usr/bin/perl my $test = @ARGV[1]; my $string = @ARGV[2]; if ($test =~ $string) { print "Match: $test matches $string"\n"; } 
`a2p` (and several related tools) was removed from the core in 5.22.0, have a look at [`perldoc perl5220delta`](https://perldoc.perl.org/perl5220delta.html#_find2perl_%2c-_s2p_-and-_a2p_-removal). It now lives on CPAN as [`App::a2p`](https://metacpan.org/pod/App::a2p). 
Log::Journald looks like it uses an XS backend so it should be fast. There is also Log::Log4perl::Appender::Journald which appears to be by the same author. 
Simply next the lines you're not interested in, like: while(&lt;textfile&gt;) { next if $_ =~ /Content\s+=\s+Delivery_Report/g; # adding up any further code you need... } 
Do they mean the same thing as grep -v? Or it's totally different?
grep -v is just inverting the pattern you give in and removing all lines that match that certain criteria. So, considering that it's pretty much the same result. 
 @a = grep (!/pattern to remove/ ) @a; @c = grep (!/pattern to remove/ ) @b; 
You'll want to place these lines before your code. use strict; use warnings; `warnings` will give you information as to why your code is not working. Firstly `@ARGV` contains only the arguments meaning the first arg is indexed at `[0]` and not `[1]` Secondly you use `$ARGV[0]` and not `@ARGV[0]` when indexing a single item. print "Match: $test matches $string"\n"; You have an extra `"` quote here. Also, `/MA/` does not match `Mars` 
Agree. I believe that even with the new web development frameworks out there, the decision to remove CGI from the base modules is wrong. There's a lot of CGI applications out there in the industry where you need the functionality but you don't care about millions of users accessing your application because it's sheltered within a corporate network. 
This sounds like conflicting wishes to me. My guess is that porting Perl 5 to the JVM would cause problems for many more users than removing CGI.pm.
What is meant with 'porting': give it an additional platform (JVM, node) to the existing one. The important this: the work of arbitrary Perl developer does not in any way conflict with this effort. Speaking of CGI.pm. If people are so eager to save some Megabytes or have some security concerns, why not working on the codebase of this module? Nobody is against nonbreaking rewrites. Btw. CGI.pm is not just some module, it was an a essential one. It was an important part of Perls history and still is for some people. You (Perl core devs) either respect that fact and take care to backward compatibility or people will eventually move to other platforms. It is not 1990 anymore, people have a lot of shiny new platforms and attractive languages at their disposal. For a lot of today developers Perl strengths is its "proliferation" and the stable core language and library. If Perl does not deliver in this area, they drop it in a heartbeat. This not a critique its just like it works
Thanks. I was able to install a2p and run it. Sadly the script doesn't seem to work. Here is what it converted to. #!/usr/bin/perl eval 'exec /usr/bin/perl -S $0 ${1+"$@"}' if $running_under_some_shell; # this emulates #! processing on NIH machines. # (remove #! line above if indigestible) eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_0-9]+=)(.*)/ &amp;&amp; shift; # process any FOO=bar switches #determines if string matches regular expression. $, = ' '; # set output field separator $\ = "\n"; # set output record separator $ARGV1)-1] =~=~ s/^\//$//g;#remove the / from before and after if f ($ARGV[(2)-1] =~ $ARGV[(1)-1] ? scalar($RLENGTH = length($&amp;), $RSTART = length($`)+1) : 0) { print 'Match: /' . $ARGV[(1)-1] . "/ matches \"" . $ARGV[(2)-1] . "\""; } 
thank you for your help. This is my code that worked. #!/usr/bin/perl use strict; use warnings; my $test = $ARGV[0]; my $string = $ARGV[1]; $test =~ s/[^a-zA-Z0-9]*//g; if ($ARGV[1] = $test) { print "Match: $test matches $string\n"; } 
&gt; OOP support How is OOP support a bad decision? I'm curious, since you mentioned it twice in your rant. &gt; Yes Perl has its weaknesses, but you learn to work around and to accept its boundaries. This is true for any language. &gt; And inside this boundaries there is a really nice and really practical programming language especially when it comes to text processing. I mean, that's Perl's acronym... &gt; Then they removed CGI. etc. Huh? Edit: Oh, from core. I see what you're saying. &gt; I think Perl is on the verge of becoming irrelevant. Aw, man, you got me. So, this is simply yet another annoying post about predicting Perl's doom. Just **stop** with this tiring trend already. Perl is doing just fine. Who the hell cares if it's not the shiniest toy in town anymore. 
&gt; yet another annoying post about predicting Perl's doom You find it annoying - then why bother replying? &gt; Perl is doing just fine. No - unfortunately it is not. Personally I invested a lot in Perl in terms of writing code, learning, building tools. Perl doesn't owe me anything - so no I don't think there is any ranthing here. You can do what you want. If you really try to play with Perls future, you might be surprised how quick that can go wrong. But since I feel somehow connected with Perls future, I cannot see anything wrong in raising my sincere concerns. Building is a lot harder then destructing.
&gt; You find it annoying - then why bother replying? Because I want to let newcomers know that yours is not a shared sentiment among all Perl coders. Look, Perl is doing just fine. Perl 5, the implementation, is robust, and it's still in active development. A lot of Perl code is still being run and maintained. Let others be lured by the omg-a-new-package-manager-must-install crowd while you and me keep using Perl. 
CGI is still on CPAN. Not everything needs to be in core.
I agree with you in that Perl doesn't have to win a popularity test. My concern is that Perl falls under a certain threshold, then it looses its seat in /usr/bin/ and when that happens it's over. 
Just like sed and awk before it? ;)
That does not do what you said you are trying to do. Not even slightly. First you strip non alphanumeric characters from $test ($ARGV[0]), then you assign $test to $ARGV[1]. As long as test isn't a [false value](https://perlmaven.com/boolean-values-in-perl) your message will be printed out. Edit: you don't get a warning from that?
&gt; Give it an AST based compiler, port it to Java. This is the problem with Perl. Everyone has his own idea and everyone want to change it in a particular way. In the effort of *saving* Perl, we together bury Perl. Now here is my idea of saving Perl -- instead of chasing *modern* idea, focus on the core of Perl, make Perl better by shedding *features* rather than adding to it. In the effort to do everything, it loses its identity. For example, (which I agree with the OP), OOP is not what attracts people to Perl. In the effort of chasing OOP, it makes users question their reason for using Perl. 
&gt; Because I want to let newcomers know that yours is not a shared sentiment among all Perl coders. It **is** shared among many though, so it is important to voice opinions like theirs, and let discourse take its course. Upvoting parent and downvoting your "rants"
&gt; Please be and stay focused on Perl and it's original strengths. That's probably the right thing for Perl. Keep making it the best \*nix shell scripting tool for sysadmins. Many systems will continue to depend upon Perl for some time to come. Perlito seems to be about using Perl as a general purpose programming language, which is a different goal. [Rakudo](https://perl6.org/) (Perl 6) is about being a general-purpose (all-purpose?) language. Not the same goal (or language) as Perl.
There is no need to be condescending. And if this is a "trend", it must mean that *some* people do care. 
I'm not being condescending. &gt; And if this is a "trend", it must mean that some people do care. Correct, and it's been discussed ad nauseum elsewhere. 
Just upvote/downvote without announcing it. This is like "no digg!" from the old days. Fine, let discourse take its course. Many say "Perl will be irrelevant!", I say "no, it won't" for the 100th time. 
&gt; Please treat Perl 6 for what it is: an experimental platform I rather treat Rakudo as a nice new language :)
You know you can do the sorting and uniqueing directly in perl without resorting to system?
The removal of CGI.pm from core served to remove the assumption that it was a preferred implementation for creating CGI scripts. It is one of the worst choices, and https://metacpan.org/pod/CGI::Alternatives (written by the current maintainer of CGI.pm) lists alternatives *that all work seamlessly as CGI scripts*, but also can be deployed in more scalable manners with no code changes, can be tested effortlessly without starting a web server process, and are in general going to be much more agreeable to whoever needs to maintain/extend it later (which could be you in six months).
&gt; Speaking of CGI.pm. ... Nobody is against nonbreaking rewrites. The problem with CGI.pm is that it can't be fixed without breaking it.
Yes, it's not 1990 any more. If CGI.pm were a selling point of Perl 5 than I would be very wary of that language.
Those two where just meant as examples for topics where ambitious developers could pour there efforts in. But I also would be fine with no new efforts at all as you seem to suggest. &gt; focus on the core of Perl thank you, this is exactly my point
&gt; Look, Perl is doing just fine. No, it's not. Whenever a shiny new toolkit comes out with interfaces for other languages, Perl used to be in the front row. Not any more. Most such tools don't bother with support for Perl any more. And that, more than anything else, proves that Perl is in decline.
&gt; Make it faster, make it stabler That is exactly what the perl5-porters team is doing. &gt; But please stop to implement breaking new stuff. Could you clarify what things have broken? 
And I think journald also supports Ye Old Syslogd Sockets, and there are a bunch of modules for that too.
Yes, you are being condescending. This is the place to discuss such things, regardless of what happens "elsewhere". And it's *ad nauseam*. 
Ok. Let's assume this is 100% true, then. What will the community do about it, then? Port it to the JVM like OP suggested?
A lot of things. For example everything around smartmatch. Buggy and sloppy implementation. Then act if the introduction of a 'experimental' pragma is an excuse for every bad or postponed decision.
welcome in my world
That's not being condescending. Plus, elsewhere as in, this subreddit every two weeks.
I wrote my first perl script over 20 years ago. For many years that was 3/4 of what I did on any given day. Over the past few years, I've found it necessary to use other languages to write software if I expect anyone else to ever touch it. If I write something in perl, it's pretty much a guarantee I'm the only one who is ever going to be comfortable using it. Feels weird, but honestly, I agree with the advice from that perspective. I continue to use perl for things for myself like quick data processing scripts and the like, but the rest of the time I'll take a different route happy knowing someone else can read and understand the code and maintain it when I stop working on it. Perl just isn't in widespread use outside of crusty old folks anymore. ;(
Don't you guys have anything fun to post? Awesome new projects? Cool code? Fun challenges to solve? Some gatherings on- or off-line? Anything, really! Lately on r/perl I see a lot of depressing posts about fewer visitors on websites, too few Perl books in a book store, or books not recommending Perl. Why is this stuff even relevant? This miserable, desperate tone is really off-putting, so you're empowering a self-fulfilling prophecy that no one wants to use Perl.
The writing's on the wall and has been for some time. The Perl 5 community is still interesting, but marginalized. It's rapidly becoming sort of what Lisp was in the 1980s/1990s: avidly used by a radical fringe; capable of great things; utterly incomprehensible to the masses. Perl is now the butt of the same kind of widespread jokes that Lisp was, back when I was a student lo these 30 years ago. For data analysis (my main schtick), I evangelized and developed [PDL](http://pdl.perl.org) for many years, and still do bread-and-butter work in it. But I'm working on my exit plan to numeric Python. In my field, 90% of the people work in IDL (*spit*), 9.5% work in Python, and 0.5% work in PDL. The Python number is growing. The PDL number is not. It's unfortunate, because to my mind Perl is head and shoulders above Python in terms of expressiveness, power, and general awesomeness. But (as /u/trackpete pointed out) it's also marginalized in the extreme. It turns out that the things I really like about Perl are things that the vast majority of programmers loathe about it. 
I use Perl because of its OOP support, and have for roughly 20 years.
Kinda like recommending that admins not learn and use grep, sed or awk.
"Perl 6" (the name, not necessarily the project) is an ongoing disaster, as the quoted paragraph amply illustrates. The sooner it can be renamed, the better for all of us.
&gt; Aw, man, you got me. So, this is simply yet another annoying post about predicting Perl's doom. This is a textbook example of condescension. &gt; elsewhere as in, this subreddit every two weeks. ... and yet, this post has 27 comments now, more than any other in a month. A clear sign that people *still* want to talk about it, despite you personally finding it annoying.
I'm half-way tempted to lock such topics as not constructive.
That's pretty sad
There is another side of the story: the price of those crusty old Perl folks in going up all the time. Stackoverflow survey 2 years ago: Perl, 10th best paying job in IT. One year ago: 6th best paying job. I wouldn't worry too much.
I never really learned sed or awk *because* of perl.
I feel your pain, fellow piddler. Not sure what to move to. I need to move towards web oriented stuff, so it's looking like ruby on rails for now.
Yet, if I go looking for Perl jobs, I find nothing. :( That's the #1 reason even I'm looking elsewhere at new languages right now.
Curious. Why not python?
Currently, 15 of these comments by 9 different people are disagreement with the premise of the OP in some form, and 5 comments are from the OP. Not exactly a good indicator that people want to talk about how perl is dying.
A couple recent projects of mine, both leveraging Mojolicious and Vue.js: * https://github.com/Grinnz/cpan-meta-browser - A visualizer/search of the publicly available CPAN metadata files, using a Mojolicious command to periodically cache the metadata in a sqlite database, and a Vue frontend to search the database via Mojolicious endpoints and display the results in a table with formatting methods. * https://github.com/Grinnz/song-request-queue - A song-request queue for streaming music games. Stores songs in a postgresql database to make use of its fulltext searching ability, so that songs can be queued by a search query. Also has an user account system to manage who can modify the song database and the queue.
jobs.perl.org has jobs available. Also, if you are willing to move to Columbus, OH the place I work is hiring several Perl people including two for previous job, with good pay for the location. I would be the trainer, and be a part of the hiring process. If interested send me a private message for details.
Not a good move. Node.js is where web is going (currently) if anything.
I would support that move. 
Looking at react or vue on top of rails.
Short answer specifically nobody has paid me to learn Python and there are more interesting things to spend my free time on. 20 years ago (circa 1997) when I was trying to figure out what skills I'd need to be a web developer, Perl was the choice. When I was trying to figure out what skills I needed to be a programmer, Object Orientation was the new hotness. The flexibility of Perl 5's native system (Damian's Object Oriented Perl book is a great reference here) really helped me understand OO in a way that even my CS professors at the time didn't appreciate (CS was still mainly taught in Pascal at my school back then). When 2007 rolled around and Moose was starting to catch on, the consistency it brought basically shored up all the issues I'd had with Perl5. I haven't yet found another system that works as well _for me_ in any other language. Now that's not to say there aren't interesting things in other languages, Erlang's Actors when viewed through an OO lense are a fascinating way to do parallelization. Javascript's Prototypal inheritance helped me understand some of the edges of Perl5's model that I didn't get early on. Java was a neat little language with a huge standard library. But when it comes to straight flexibility to write the object model I have in my head quickly, Perl5 + Moose wins _for me_ every time right now.
Disagreement is part of the discussion. We're not here to just agree with each other, don't you think? As much as it may bother you, the "Perl is dying" posts tend to be the ones with the most comments in this subreddit. This is very easy to check. People want to talk about it.
&gt; Make it faster, make it stabler &gt; &gt; That is exactly what the perl5-porters team is doing. Huh? What? Every major release comes with a "list of things we broke on purpose". Some of them get presented as "Security fixes", but don't really achieve anything other than cause ecosystem damage. 5.26 alone broke: - Anything that relied on '.' in @INC ( and you can pretend it didn't due to that badly named ENV var, but that's going to be a shit-show when that gets removed in 5.30 ) - Anything that relied on old understanding of what "{" means in regex has a class of breakages, which affected things like autoconf and automake. - OP_SIBLING/OP_PARENT changes broke whole swathes of XS code - Removal of `tmpname` from `POSIX` broke a whole bunch of things - Deprecating `encoding` breaks a whole bunch of things. And lets not forget the recurring "oh, we broke this certain programmers XS code, instead of admitting we actually broke their stuff, we pretend like they were doing something wrong, and we were right to break it". Whether or not you were "right to break it", perl5-porters *still broke it* 
No, sorry. I meant `-M` and its argument entirely.
No, it is not required. The snippet is for writing the contents of `%INC` of OP's system. Trying to load the module from the beginning with `-M` only makes it fail to run, which is the original problem.
I've not had a problem finding remote contract work at all. 
I have a few blog posts about using some of the non-blocking/concurrent/async Perl modules, if people would find those interesting?
&gt; This is a textbook example of condescension. No, it isn't. &gt; ... and yet, this post has 27 comments now Of which 17 are about this thread, where I'm pointing out that OP's kind of rant is redundant and you trying to dismiss it as condescending.
Or the more likely conclusion: It's easy clickbait.
+1
Certainly!
I don't think that's the case, since clickbait doesn't lead to much discussion. In fact it would be more like the opposite: an abundance of comments indicates that it's *not* just clickbait. 
You could be right and still be condescending, too. One thing doesn't preclude the other. I'm officially tired of you. Welcome to my ignorelist. 
Happy to be here.
That would be great! I beg you. And thanks.
I'll keep writing new stuff in Perl for as long as I feel it's fun - which I hope it will be 'til my end of days.
Why move at all, though?
Perhaps a more precise term would be 'commentbait'. This entire thread, for example, is a discussion about whether this post should exist.
&gt; Could you clarify what things have broken? Could we have a bloody working `switch`, for fuck's sake? And a bloody working smartmatch, at least for arrays? In a couple of weeks, it will be **10 years** the thing has been introduced. In a few months, it will be **5 years** it was ~~removed~~ sorry: *experimentalised*. I read new versions release notes on occasion, and nothing happens on that front. So I start every program with re-enabling the thing and silencing warnings. 5 years for a simple bloody `switch`... and still no sign of it.
Yeah, just keep the blog spamming that nobody reads or comments on...
OK. How should these work? Hint: "that's obviously a number" and "that's obviously a string" are both wrong. switch ('5.0') { case '5': } if ('5.0' ~~ [3,4,5]) Here is the most recent thread about the attempt at fixing smartmatch (which is the main issue with fixing given/when): https://www.nntp.perl.org/group/perl.perl5.porters/2017/08/msg245769.html The current conclusion is generally "smartmatch will always treat non-refs as strings, with undef handling", which avoids the whole number/string problem. I'm not sure if there has been any progress in implementation.
I've been working a couple of modulesfor the networking field. One is a module to be able to perform unit tests on Palo Alto firewalls. Another is a set of RecDescent parsers to parse network device configs - e.g Checkpoint Gaia, Cisco ASA, etc
At work, at the moment I'm adding some hooks into an existing Plack/PSGI app to mimic higher latency scenarios to see how the various client applications (across many servers) react when things go bad.
If by "thread" you mean the post, it's actually not. If by "thread" you mean the comments following a single top-level comment, then *that top-level comment* should be considered commentbait, not the post. There is actual discussion about Perl, its present and its future here, and about things like whether keeping CGI.pm in core would have been better or not. EDIT: Also, if I was harsh to you in my previous comment, it's because I mistook you for the other guy, who was already becoming tiresome. Now that I set RES to ignore him, I can see you're a different person. My bad.
Sounds like a plan
Yup, I'd like to read
Sorry I don't have any published source at the moment. I'm planning to do so soon. But in the spirit of answering this question, here's a few: * [This is an unpublished site](https://www.rppalencia.com/) (well, not anymore, I guess!) which I'm planning to use to offer my tech services locally. I started writing the backend in Perl from scratch about three months ago. * [This is a quite dated site](http://pachesoft.com/rockerferbasic/index.html) I wrote to teach programming in Spanish, and I translated it to English for the sake of it. The language engine is written in a compiled language, and the interface between the site and the engine was done entirely in Perl. I'm planning to come back to it as soon as I complete other projects. * I also have a game whose backend is written in Perl, and the next thing I want to add is a video rendering scheme to produce replays that you can publish to youtube and the like. I want to publish all my Perl code as open source. I just need to better organize it when I have time (hopefully by the end of the year). 
elbitjusticiero will be missing out ;-)
Just finished up a mojo api using openapi and beamwire for $work. Wondering if anyone else has examples of beam wire or bread board apps. Interested to see how other people incorporate dependency injection frameworks 
https://i.imgur.com/c4jt321.png https://wonderopolis.org/wp-content/uploads//2015/03/1425_3.jpg But honestly if we have to suppress these posts then there is something wrong. Instead of censorship, sarcasm and deflection, it might be better to address the problems and have discourse. If we dont learn from the mistakes and improve, whether that is Perl 5 or Perl 6, its too late. People often complain about the same big problems and their problems are never really addressed. Write only, I fee like Perl6 has already gone past the point of return on this. It has a million operators and variables. TIMTOWDI is great and all, but there needs to be balance and moderation. It is ridiculed in other subreddits, and all ever see is ‚Äúits easy once you learn it‚Äù or ‚Äújust look at the documentation‚Äù in response. I love Perl but I would never recommend it to anyone new. Its lost its critical mass. API support is nothing compared to Python. The biggest adversary Perl faces is its own community Maybe if we see something over and over again there is some validity. These are the only posts on this subreddit that get more than 20 comments. If these posts are removed, it will just be bots telling us what the new versions of the CPAN modules there are.
I'm not really sure what you think /r/perl can do about those complaints. If you want to have a constructive discussion, you might want to think more in terms of solutions. Bringing up the same complaints in more threads just makes the complaints self-realizing.
Alot of people who frequent /r/perl are perl6 developers. So by users voicing their complaints, it lets them know of possible issues to avoid, fix etc. It is up to them of course whether to implement those changes. There are of course a dozen other reasons to provide discussion. Documentation, etiquette, coding style and culture can also be affected. I really do/did want Perl6 to succeed. I have voiced things I think are needed. But I got some responses that are unique to the Perl community. In another post, someone has already mentioned what they think is great about Perl, what their concerns are and what they think Perl needs to do to remain relevant. Bad analogy time. Its like voting. Several people have aired their concerns. They may not directly implement the change, but maybe the people listening can. If the people listening disagree, then at some point you switch parties. edit: One effect this thread has is that someone has created a new thread showcasing Perl projects. I never see those posts unless theyre in response to these posts.
I'm sure they'll recommend PowerShell before the decade is up.
That's too bad. My employer has a HUGE Perl codebase, but even they are retiring it and moving to Go for new work. It's too hard to find Perlers. I think Perl knowledge will still be useful for another 5-10 years as it's retired, though.
Working on internal employee web app for $work. Using [Mojolicious](https://metacpan.org/pod/Mojolicious) and [Mojo::Pg](https://metacpan.org/pod/Mojo::Pg) and just loving every minute working with these tools. They're so nicely polished and fit my brain well. Also working on [modules.perl6.org](https://github.com/perl6/modules.perl6.org) powered with Mojolicous and [Mojo::SQLite](https://metacpan.org/pod/Mojo::SQLite). Soon gonna add support so 6lang's modules on CPAN are shown on that site \o/
Perl5-porters team is the dominant force that will ensure the slow demise of perl5 -- by continuing maintaining Perl while its captain had long abandoned ship. 15 years ago when the captain jumps ship, there is no danger of Perl dying. Plenty of people are using Perl and are willing to work on Perl. But since there is this perl5-porters team taking control, the Perl ship is being preserved into a zombie state. While not dying -- in fact, one can claim it is opposite of dying -- no interesting things can happen either. As a result, Perl slowly withers. Real useful things can't really die. Vi, for example, numerous people have tried recreating it, and some of these efforts eventually give it a much more vibrant new life. If vi is being officially maintained with the yearly release, I think it will go the same way of Perl. Perl is really unique in the programming landscape. It ignores the gospels of the academy and went its way of practicality. There is more than one way to do it. The fact is the language didn't start with a clear destined way, so it simply developed many ways ad-hoc and let the natural evolution take control. That is beautiful. Since I believe perl is unique and beautiful, I am quite confident that if the captain officially annouce his abandonship, many more new lives of Perl would sprout -- except, this is never the case. As a disclaimer, I am in no way diminishing perl5-porters team's effort nor good intentions. But the way of history is often ironic.
&gt; Short answer specifically nobody has paid me to learn Python and there are more interesting things to spend my free time on. I am not sure what to get from your long answer so I'll just respond to your short answer. You said you use Perl because of its OOP, how does it relate to your answer of "being paid to learn"? Does your long answer simply spell "invested"?
&gt; These are the only posts on this subreddit that get more than 20 comments. I pointed this out in another thread earlier and the reactions were: 1. It's because of the clickbaity title. 2. Who cares? 
yes I'm aware of that, and I'm still in learrning process so I have a very limited knowledge in perl
At $work I'm refactoring and consolidating a legacy test framework and particular large scale tests that have grown out of it. Using [Moose](https://metacpan.org/pod/Moose) in new code as much as possible with [Kavorka](https://metacpan.org/pod/Kavorka). Hoping to soon replace the custom logging with something stock from CPAN, there are so many choices! I'd appreciate any recommendations on which one I might like to pick
I'm a writer by trade, not a programmer. I wrote a tiny script for my own use which grew and grew over the years until it became a pretty sizable project. It's a system for text processing that takes a text file with some minimal markup (of my invention) and generates an EPUB, MOBI, PDF, DOC, TXT, or HTML file. It features user-generated variables for generating different content for different formats, counters, automated TOCs, and the like. I'm pretty happy with it but it will always be a WIP. ;) (EDIT: that script leverages some cool external tools to do its magic. I'm not writing a PDF by hand!) Also, I had written my contactbook in php, but I'm sick of its issues so I'm porting it to Perl. The distinguishing feature is that contacts can be dependent on other contacts so you can store data for a company and an employee of that company as separate entities but have them linked and displayed together, and this can go on indefinitely (dependencies of dependencies of dependencies). This project is still in the initial stage because I spent too much time fighting with the different GUI interfaces, only to fall back to the core one, sparsely "documented" Tkx.
Actually, fresh new projects may be where Perl is most useful, We.
&gt; That's probably the right thing for Perl. Keep making it the best *nix shell scripting tool for sysadmins. Oh man, you will love that other thread. 
Rewriting parts of [flexget](http://flexget.com/) in perl. The original program is designed poorly and it is unnecessarily cpu and memory intensive.
Wow! That sounds pretty cool. Props.
A few things... Using Perl to automate the process of decoding DLT files into csv to be indexed into Splunk. Automating image synthesis from single images using Perlmagick. Automating user input on HMI via GUI test32. 
Lemme turn this back on you. Why would Python be the only obvious choice in 1997 when I decided to learn programming? What makes Python significantly different from Javascript, Erlang, Java, Io, Go, Scala, or any of the thousands of other languages out there that I should have spent time on it in the last 20 years? The long version does kinda shorten up into "investment" but specifically ... Perl's OO system is the best I've used for my needs ... what makes Python so special that I should spend my time learning it rather than Erlang, Java, Go, Scala, Io, or any of the thousands of other languages out there?
I work on my personal projects on a home Fedora server, with many perl versions for dev managed by [plenv](https://github.com/tokuhirom/plenv), of course with git, and nano because I am too lazy to set it up to use a GUI editor. At work I use [vscode](https://code.visualstudio.com/) in both Windows and Fedora.
I recently found out my hometown publishes a list of towed cars (as required by regional law). But they made it simple for themselves, and just save it to a shared excel file stored in a cloud. So it's basically useless if you want to quickly look up where your car is. I threw together a small site that monitors and parses the file, and publishes last three days of data in mobile friendly format: [GdeTachka](http://gdetachka.ru) (means "Where's the car?" :-)) The major Perl parts are: `Spreadsheet::ParseXLSX` for parsing, `DateTime` and it's few "plugins" for date parsing, formatting, and timezone manipulation, and `Mojolicious` (lite) for the website stuff. I'm thinking of adding SMS gateway, to push text message as soon as a car get's towed. At first for myself, friends, and family, and if that works well for anyone else who registers. And we'll see there that goes :)
It was an attempt to find the module, which wouldn't be in `%INC` unless it was loaded first, and died because it wasn't installed at all. Another "trick" to find where a module is physically installed is a switch for the `perldoc` program: perldoc -l CGI::Application
Posting this in the spirit of sharing stuff. I don't write for other people a great deal, so I make no guarantees as to the quality!
Uplink/Downlink ground station for the upcoming COSMIC2 satellite constellation. Launches on a Falcon Heavy next year, and this station will make the first contacts after release from the rocket. Failure is not an option TM. Boss had wanted to move away from perl to C/C++ for that project, and that was a massive failure (you can't replicate a 10yr code base in 6 months, esp not with C and be reliable!) so it's all perl now. Literally, had to replace 6 months of the C/C++ guys code... and it took 3 days in perl... and isn't buggy now. Lots of satcom equipment drivers, etc, and evaluating web frameworks to move away from an old Java webstart app. I need websockets for this badly, but I'm not seeing any modules for that in perl right now. Also, this needs lots of server asynchrony, which is like the only thing that's easier in Java. Looking to "generalize" our mostly weather satellite focused stuff to better match the growing small sat market. 
Hey! I am also developing for5 COSMIC2! Payload handling as well as software to control the antenna and the modem. All Perl and Mojolicious. The antenna driver is in production and do more than 10000 passes each month. Edit: looking at your profile I realize that the antennas I control all comes from your company. We should talk. 
Great, so its gone full Cobol.
Mojolicious and Mojo::UserAgent natively do websockets as a server and client respectively. See https://metacpan.org/pod/Mojolicious::Guides::Cookbook#WebSocket-web-service and https://metacpan.org/pod/Mojolicious::Guides::Cookbook#WebSockets. It works via the event loop built into Mojolicious (also useful for async stuff, or IO::Async is another good choice). Of course with critical software, I hope you are pinning your module versions!
Yes, what site are you working on? Mauritius?
Indeed.
There are like 10 users on /r/perl, and we happen to be working on the same constellation. What are the odds?
We switched from a poorly maintained Vagrant setup to Docker + docker-compose (for dev)/kubernetes (production) in the last year. It's so great. The local system stays as clean as you want it to, you can easily try new versions of Perl (by changing base images), and to get up and running with development, all you only need to install are git and Docker. $ git glone $ docker-compose build # only the first time, or when dependencies change $ docker-compose up $ # You can now browse to the dev environment New Docker container images are built automatically on push/merge to one of the release branches (thanks to gitlab's built-in CI/CD tools) using the same Dockerfiles as used for development.
You started out with sarcasm. Please don't. I'm not culturally equipped to handle it in any meaningful manner and it makes it hard to consider anything following as not written in bad faith. You entirely overlooked my mention of "constructive". Please try and rethink what i said in the context of permitting such posts with constructive components.
At work, we make a process/case management system for local governments (in the Netherlands): zaaksysteem.nl I also recently wrote [Document::OOXML](https://metacpan.org/pod/Document::OOXML) to read/write docx (and in the future: xlsx, pptx, etc.) files, so we can use them for templating (besides ODT which we've supported since forever)
I need to learn how to do this!
I disagree. The post highlights a very real problem facing the Perl community. 
Have a look at the official Perl docker images on Docker Hub: https://hub.docker.com/_/perl/ There are lots of tutorials for writing Dockerfiles around the web. If you want more inspiration, you can look at some of our code at https://gitlab.com/zaaksysteem
Thanks, kind coder!
Big fan of Mojolicious.
The last I wrote was a small script which converts documentation from a webpage to respective manpages: https://github.com/andlrc/rpgleman I use it for pretty much everything like the above.
We would have been much better off it wasn't added in such a half-broken state, and would be much better off if we hadn't discovered afterwards that smart-match is a nightmare. If you want an example of something that looks as horrible as "smart" match does in javascript, consider: [` null &gt;= 0`](https://blog.campvanilla.com/javascript-the-curious-case-of-null-0-7b131644e274) in JavaScript
Excellent, very in depth walkthrough.
[removed]
My experience is the opposite. They are looking for me.
I'm doing but waiting for Tau Station launch: https://taustation.space (Written in Perl and Javascript I suppose)
I don't disagree, but do they help anyone? What exact good is the post at the top here? Did it give you an actionable? I've had people tell me they looked at perl reddit today, saw two such posts, concluded they won't be learning anything useful or new here today and closed it again.
MIFID 2. It's a new financial regulation, which will go live on January 3 in Europe, that requires a slate of changes in the banking and investment industry. One of the provisions is that all companies involved in a trade must identified uniquely using an unique ID, called a LEI. All the LEI are centrally managed and published *a single 1.2GB XML file* ! I just wrote a procedure to manage this big blob of data, using Perl and teaching me some XML::Twig, a very useful tool of which I was already aware but that I did never use before. XML::Twig strength is that you can parse an XML file serially, reading and processing a node at the time and then discarding it, so keeping memory usage way down. This way my script that parsed the whole 1.2 GB file and extracted the information useful to my $work only ever occupied around 30MB of memory.
[removed]
If your goal is to increase the size of your team, as it is from every low-level manager and upwards, Perl is a bad choice. It's just too easy to solve technical problems with it. The code size will be 5% of the same project in Java and 20% of the Python version. Only Clojure comes close in terms of expressiveness. And I'm talking about fully readable Perl, not obfuscated or Golf style. Moose tried to solve this problem, by adding all the type-safety and OO dogma, so popular due to their job-generating potential, but it was too late. Python has already disappeared on the horizon.
My company has many thousands of cellular lines of service and I've written some utilities to help with provisioning and troubleshooting, such as getting a device's status or connection history etc. After copying and pasting chunks of XML between programs for a couple of years, I'm finally doing what I should've done from the start: Writing a module that accepts some named parameters and returns the chunk of XML necessary to perform the desired task. Hoping that I can give it to the carriers and they can add it to their existing Python/C#/Java examples.
I do all my stuff on my Linux laptop, using kakoune for code editing, carton for dependency management if I can be bothered. Perl installed with plenv.
We've just improved and relaunched our ValueMyCV tool at work (http://www.adzuna.co.uk/jobs/value-my-cv). ValueMyCV takes a CV, transforms it into structured data, parses the data, hands it over to our data-science team's (Python) APIs and returns an estimated valuation for that user in the job market based on the skills and experience in their CV. So it's a mixture of Perl, ReactJS and Python/TensorFlow. We're a UK based startup in the jobs space where the majority of our codebase is still written in Perl. We have no plans to move away from it and are enjoying growing our business using Perl as our core technology. We use a mixture of all the usual suspects: Moose, Plack, DBIC, Test::* etc.
* The CGI module didn't go away. It's still on CPAN and it's still being maintained. * It's perfectly possible to write web applications using more modern tools and deploy them in a CGI environment if that's what you want. * Writing a web application using the newer tools and deploying it as a CGI program is easier than writing a program using CGI.pm (and you get all the great development, debugging and testing tools that come with PSGI/Plack).
CGI.pm is not and has never been an essential module. It's not an essential module for the large number of people who use Perl for non-web work. And it's not an essential module for web work as there are far better alternatives.
I have two whole subreddits which are automated with Perl: * /r/fiveyearsagoonreddit * /r/tenyearsagoonreddit And I'm working on a whole other sub, but it's secret. just this week * I wrote a perl script to quickly get the last five errors from an oracle database via somewhat hack-y means * I wrote a utility to decode Base64 documents in bulk * I graphed data on a running event into an animated GIF using ImageMagick and Perl * I wrote a script to generate 5 HTML and XML documents and zip them up for a co-worker who regularly needs those five files customised when they install new users into a system.
&gt; 15 years ago when the captain jumps ship, there is no danger of Perl dying I'm really not sure that's true. There's a reason why Jon Orwant threw those coffee mugs in 2000.
I think we're both in agreement here. I would much rather see positive posts about Perl, both here and on the web as a whole. But I really don't want to get into the murky waters of "censorship" (using the term loosely) by trying to define what is/isn't appropriate content for the sub. My attitude has always been that if a post is about Perl and not obviously flame bait then I think it has a place here, even if it makes for uncomfortable reading. 
I don't really code in my day job but I use Perl for all personal projects: * coding challenges (Euler, Advent of Code) * website stuff (blog, scraping) * any random data analysis that's a bit too tough for Excel 
git with github/gitlab on a [Bodhi Linux](http://www.bodhilinux.com/) VirtualBox VM running inside a Windows 10 host. With Sublime Text 2 on a 1440p monitor for [3-column editing](https://i.imgur.com/ydLQxiS.png) üòãüòãüòã. I'm yet to have something better for syncing dev environments between other boxes I work on than copying the relevant files to my [Linode](https://www.linode.com/) server :)
At work, maintaining huge Perl libs for a Wall Street bank. Removing Moose everywhere I can. At home: * remotepi: web UI for my own RPi media centre (SPA, REST, websockets) * u2b, Web::U2B: Youtube streamer/downloader for same * rpi.fm: Internet radio search for same * Net::ZooIt: high level recipe library for ZooKeeper, also used at work * muttrulez: email rule engine for Mutt users * homelb: a home load balancer * tempolate: pure-Perl template engine for above (see interpolate)
What you want is probably Mojolicious. Async, websockets, out of the box.
&gt; Btw. CGI.pm is not just some module, it was an a essential one. It was an important part of Perls history and still is for some people. You (Perl core devs) either respect that fact and take care to backward compatibility or people will eventually move to other platforms. I wrote about this [last year](https://leejo.github.io/2016/02/22/all_software_is_legacy/). Please stop playing the CGI.pm card, it's tiring.
Preping some Marc record extraction and manipulation scripts in preparation for a project to change our library's ils. Before that, some scripts to extract Marc records and crosswalk them to Dublin core for use in a new system. Perl does seem to be used a lot in library world.
This appears to be part of the "Python Everywhere" movement. (Which is really a "Python Is All I Want To Understand" movement.) Pythonistas may be having fun but their thinking is narrow and the authors claim some authority. Their opinionating does a disservice to the audience of the book (sysadmins). The age of a language has no bearing on the language, else C and C++ should be dead and the book should recommend Swift instead. I was going to say Haskell, but Haskell is as old as Java. Off with their grey heads! Does the chapter in the fifth edition continue to discuss *bash* as though bash does not "show its age"? If anything is a source of pain, it's bash. Have you tried to write object-oriented bash? It's tough. To write bash, awk, and sed, you need to understand the same stuff that makes Pythonistas hate Perl. Is the sixth version of this book going to recommend that Python replace bash, awk, and sed? I don't see many jobs for bash, awk, and sed these days! My start-up doesn't even *know* what these ancient bits of tooling are. OMG LOL. I only used Python in school, and we all know that school teaches best practices for the real world... A competent sysadmin needs skill in reading and using code that isn't Python. Python's instability (2.x -&gt; 3.x, 3.4 -&gt; 3.6) is a strong argument *against* Python for system administration. A sysadmin will be working on systems of various birthdates. Python has strengths, but stability is not one of them. 
**[AI Mind Maintainers](http://ai.neocities.org/maintainer.html)** need to learn **[Perl](http://strawberryperl.com)** to grow and expand my **[ghost.pl](http://ai.neocities.org/perlmind.txt)** with the following Perl Mind-Modules: * [MainLoop](http://ai.neocities.org/MainLoop.html) of AI living potentially forever * --TabulaRasa -- wipe memory clean * --[MindBoot](http://ai.neocities.org/MindBoot.html) of English and **[Russian](http://github.com/kernc/mindforth/blob/master/wiki/RuBoot.wiki)** vocabulary * ----KbLoad -- load the Knowledge Base * --[ReJuvenate](http://ai.neocities.org/ReJuvenate.html) -- recycle memory space * --[Sensorium](http://ai.neocities.org/Sensorium.html) -- Sensory Input * ----[AudInput](http://ai.neocities.org/AudInput.html) -- auditory input * ------[AudListen](http://ai.neocities.org/AudListen.html) -- listen for input * --------[AudMem](http://ai.neocities.org/AudMem.html) -- English auditory memory * ----------[AudRecog](http://ai.neocities.org/AudRecog.html) -- auditory recognition * --------RuAudMem -- Russian auditory memory * ----------RuAudRecog -- Russian auditory recognition * ------[OldConcept](http://ai.neocities.org/OldConcept.html) -- recognize a known old concept * --------[EnParser](http://ai.neocities.org/EnParser.html) -- preposition? (in)direct object? * ----------[InStantiate](http://ai.neocities.org/InStantiate.html) -- create conceptual engram * --------[RuParser](http://ai.neocities.org/RuParser.html) -- expect first a noun, then verb * ----------[InStantiate](http://ai.neocities.org/InStantiate.html) -- create conceptual engram * ------[NewConcept](http://ai.neocities.org/NewConcept.html) -- create new concept * ----FileInput -- read files on a server * --[Volition](http://ai.neocities.org/Volition.html) -- Emotion + Thought = Motor Action * ----[Emotion](http://ai.neocities.org/Emotion.html) as influence on thought and free will * ----[EnThink](http://ai.neocities.org/EnThink.html) -- think in English * ------[InFerence](http://ai.neocities.org/InFerence.html) -- automated reasoning * --------[AskUser](http://ai.neocities.org/AskUser.html) -- validate an inference * ------[EnNounPhrase](http://ai.neocities.org/EnNounPhrase.html) -- English noun phrase * --------[EnPrep](http://ai.neocities.org/EnPrep.html) -- insert English preposition * --------[EnArticle](http://ai.neocities.org/EnArticle.html) -- insert English article * --------[EnPronoun](http://ai.neocities.org/EnPronoun.html) -- substitute a pronoun for a noun * --------[ConJoin](http://ai.neocities.org/ConJoin.html) -- insert conjunction * ------[EnVerbPhrase](http://ai.neocities.org/EnVerbPhrase.html) -- English verb phrase * --------[EnAuxverb](http://ai.neocities.org/EnAuxverb.html) -- insert auxiliary verb * --------[EnAdverb](http://ai.neocities.org/EnAdverb.html) -- modifies a verb * ----------EnAdverb -- modifies another adverb * ------[ConJoin](http://ai.neocities.org/ConJoin.html) -- insert conjunction * ----[RuThink](http://ai.neocities.org/RuThink.html) -- think in Russian * ------RuNounPhrase -- think with a Russian noun * --------RuPrep -- insert a Russian preposition * --------RuPronoun -- substitute a Russian pronoun * ------RuVerbPhrase - think with a Russian verb * --------RuAdverb -- insert a Russian adverb * --------[RuVerbGen](http://ai.neocities.org/RuVerbGen.html) generates a Russian verb-form * ----------[AudBuffer](http://ai.neocities.org/AudBuffer.html) stores Russian phonemes * ----------[OutBuffer](http://ai.neocities.org/OutBuffer.html) manipulates phonemes * ------[Speech](http://ai.neocities.org/Speech.html) -- output to screen or loudspeaker * ----[PsiDecay](http://ai.neocities.org/PsiDecay.html) -- lowers conceptual activation * ----[SpreadAct](http://ai.neocities.org/SpreadAct.html) -- spreading activation * ----[MetEmPsychosis](http://ai.neocities.org/MetEmPsychosis.html) -- AI soul travel * ----MindMeld -- merge two AI Minds * ----[Motorium](http://ai.neocities.org/Motorium.html) -- for autonomous humanoid robots 
Which one?
debian mostly, usually system perl; many VMs for testing; cygwin on m-windows geany for editing, with [snippets for perl](https://www.reddit.com/r/perl/comments/5tdz5r/geany_users_customise_the_snippetsconf_file_for/) git and mercurial running on an ARM plug 
I code for myself, on Windows, so I'm just fine with using a main directory for my scripts outside of C: for easy backup. I have reason to complain about the archaic rules to find modules though -- it's just too hard to casually tell Perl "oh, this module I wrote myself is not on the CPAN so look for it here instead". Or rather, it's easy, but not as straightforward as it should be and more like an afterhought. (See the recent `@INC` silliness.)
I disagree with the above. Ruby is awesome and you'll love it coming from Perl. Node is hell
BTW, is the book very influential or authoritative? As unfortunate to Perl as it is, I can understand the reasoning and think the recommendation is rather sensible. An admin can still be advised to learn sed or awk because they are significantly simpler than Perl. But if an admin decides to learn a full-fledged scripting language besides bash, he/she might be advised to learn, let's say, Python instead. Perl might be recommended if he/she wants to learn a third or fourth language, for example. But still, it's just a recommendation and someone else, like me, would still encourage admins to learn Perl.
We use Perl at work, for a lot of things. But for academics purposes (actually it was more for fun) I participated at the IberEVAL 2017 workshop: http://ceur-ws.org/Vol-1881/ and submitted a solution just using Perl ( http://ceur-ws.org/Vol-1881/BARR2017_paper_3.pdf ), it was a script with a few CPAN Modules and some regexps. It was the simplest solutions proposed, but we get good numbers, and it was really fast compared with the other systems.
My experience isn't identical, but it shares a theme. Started perl around 2000 using it as glue for what was mostly a sysadmin job. Got a new boss a few years in who was a huge perl guy so it kicked into overdrive. The actual job responsibilities morphed over the years as the industry changed. Syadmin, network admin, dba, but no matter what perl was the glue that held everything together. Basically, my job was never "perl programmer" but regardless of what I was actually doing, by 2012, it was about half my workday. Got absorbed into another department. Virtualization had been primetime for a few years and true cloud stuff was starting to be taken seriously. I don't know if devops was a word yet, but it was gestating at least. Each new thing I had to work with either didn't have native perl support, or if it did the libraries/docs would constantly be scant/feature limited compared python/ruby/powershell. Couldn't really afford to be constantly telling a new department that the language I was using would take days or weeks to build up and test a full package to manage whatever it was in perl when python, powershell and sometimes ruby just had it all out of the box on day one, so while I was still using it for a lot for older stuff, I was learning the others just to keep my head above water. When I decided it was time to move to a new company, the writing was on the wall. There were a fair number of full time senior++ perl jobs out there for grizzled wizards, but it had never been a full time job for me and though I felt like I was above average, I didn't feel like I was at the level that I could stake my whole career on it or sell my house and do a national search. Nobody in my area was looking for an intermediate or entry level perl programmer, they all wanted someone who could decipher and take over primary responsibility for whatever ancient perl beast that was critical to their company that they didn't understand but couldn't just replace. For jobs more like what I had been doing, all that deep experience using *insert well known scripting language* to glue things together got me a leg up in interviews, but they made it very clear they were an *insert newer well known scripting language* shop and I'd have to come up to speed quick. 
Personally, I was never into OOP, so I can't really testify between Perl's OOP or Python's OOP, and it was never my question. What I know is back 15-20 years ago when I and a couple friends all picked up Perl, and then a couple years later, all the rest of them were all switched to Python one after another, for the reason of OOP. It is you mentioned you "chose and stick to Perl because of its OOP". It implies you had objective reasons beyond personal history and bias, doesn't it? And I always had the curiosity, so ... Anyway, it was not an accusation, and you don't need to defend. I think you already clarified, so it is well.
are you moving to a new ils or writing a new one? if moving to a new, which one? we use koha right now but its heavily modified and on a 10 yr old version because of all the modifications.
Why removing Moose? Replacing with...?. Just curious.
why remove moose?
Why not use: use lib "c:\path\to\directory";
Among my lengthy (in the comment world) thesis, you picked up the minor point... I was not criticizing the captain in any way. The captain was and is entitled to move on and pursue his vision/goal. What ever happened does not change the value of what ever he created before. I admit I do not know the details of history, so if you care to elaborate, you are welcome. But my point is, right now, the captain -- who feels himself owning the project, responsible for the project, and feel comfortable in making a drastic/directional change of the ship and not overly concerned about its immediate superficial consequence -- has moved on. Right now, I don't think the perl5-porters team owns Perl, are thinking about future of Perl as a captain does, and are diligently only doing a caretaker's job. In the open source world, that makes Perl5 into a zombie states -- it is undying, full of activities, yet missing the brain. And my main (implied) point is, it may be better to dismiss the maintainance of Perl. It is better to let Perl die than to sustain it as a zombie. If perl is useful and unique, as I believe so, effort will sprout in fixing or reborn. If perl is truly useful and unique, new lives will sprout on top of Perl's corpse, and each new lives will have a brain, puny or big. The true perl (as vi) will never die. Personally, I will be fine if Perl stays at version 5.8, and secretly I even wish it did. 
Have you ever seen a Moose stack trace? Have you ever compared the performance of Moose / no Moose versions of the same program? You even have to type more to define the same constructor! Which runs 6 times slower. I think type/OO centric Moose goes against Perl's data/text centric core philosophy. It's a bit like using Roman numerals. Perl's functional aspects appeal to me more and more. I'm using more and more grep/map/reduce/closure stuff every day. Have you seen the new Perl 5.20+ List::Util? pairgrep, pairmap? They are awesome. Not that I get monads, BTW. Apart from the obvious fact that they are monoids in the category of endofunctors. :D
Moving from voyager to alma. So from a system where we can do a fair amount of scripting to a cloud based, api only system :(
&gt; I think we're both in agreement here. I would much rather see positive posts about Perl Not entirely. There's a distinct difference between positive and constructive. What a positive post is is clear. What a constructive post is can also be something like "this aspect sucks, let's work out how to improve it, here's my ideas". I've done this in the past and it resulted in http://perl-tutorial.org The problem is that posts like the one above *are* effectively flamebait, even if not intentionally so. They result in a lot of discussion, with heated heads and result in bad moods and little else. Does any of that change your perspective?
Ah. I saw that thread yesterday but can no longer find it. **Edit:** [here it is](https://www.reddit.com/r/perl/comments/72u6g5/we_suggest_avoiding_perl_for_new_work_at_this/)
If you call it "6lang", I think it will end up very often typed sixlang, or else just "six". 
It was just a comment to correct the history. It was at OSCON in 2000. Larry Wall was due to give a keynote on the future of Perl on the first day of the conference. In the evening of the previous day, there was a Perl 5 Porters meeting. [This account](https://www.nntp.perl.org/group/perl.packrats/2002/07/msg3.html) (written two years later) comes from someone who was at that meeting. Larry worked through the night to rewrite his keynote as an announcement of the Perl 6 project. So it's incorrect to say that there was no danger of Perl dying before Larry started devoting most of his time to Perl 6. In 2000, there was a real worry that the language was in trouble. **Update:** And I don't agree that p5p is doing a caretaker's job. I think they're adding useful features to the language. Not everything works, but I find it painful if I have to use anything as old as 5.8.8.
Ruby: if (0) puts "0 is true" end prints **0 is true**. Game over, I can't use a language where zero is true.
that's in development for a long while. is it going to be relevant by the time they launch? I wish they started public beta testing already, got some feedback...
Nice writeup! Shared it with my team. 
So do I :) previously I played Lacuna Expanse, it was great game! :)
That's fine :)
I would second this that Moose is a great thing. I actually wish Moose, or something at a similar level (as I know the author of Moose is starting something new), would be shipped with Perl core. 
As a Perl (and programming) novice, thanks for the writeup. 
I agree that Perl shall definitely not go back to 5.8. I actually hope p5p and the community to move even faster than now to bring more into the language core, like * make function signature non-experimental * fix smartmatch please! it's been so many years. * get Moose (or something alike if Stevan would still want to develop something new to avoid Moose's drawbacks) into core * Python''s cool features like yield/continuation and async. (I know there are some CPAN modules can more or less do similar things, but it's better to have them in core. )
It is a good comment. Fair enough. &gt; but I find it painful if I have to use anything as old as 5.8.8. Painful is not necessarily bad. When smart and devoted programmers find it painful enough (yet love it still enough) they'll work on it -- not under caretaker's role but an ownership role -- like elvis and vim or neovim. To be honest, it is not that can't happen with perl5-porters in position, but I am making this hypothesis that it will happen more easily if Perl5 maintenance is officially abandoned. PS: it is very interesting to read of "that account". EDIT: Imagine if p5p were never in place, no matter what dramatic changes people do -- like those in elvis or vim -- people who love the old will not contest. It is not like the old vi will go anywhere. But there is a real danger for those who loved the old Perl (for whatever reason) that the old Perl is going to disappear (or rather slowly degrade/morph) at some point (yet the whatever in place is not really new enough to compensate the regret). Another EDIT: &gt; So it's incorrect to say that there was no danger of Perl dying before Larry started devoting most of his time to Perl 6. In 2000, there was a real worry that the language was in trouble. The people who live in the history don't necessarily see the real picture. If some people think Perl in 2000 is dying, what should they think of today, now putting the larger picture side by side? It is ironic maybe a portion of the same people today actually think Perl is very alive. I picked up Perl in 2000 and I remember how that I appreciated the stability of Perl. In fact, I would suggest there is significant programmer growth in the 2000s. A poll here would be interesting.
Good name: * 6lang, sixlang, six, 6 : timtowtdi, and to spell it. * "six" is only 3 letters, and only one syllable. And sexy. And Cylon, for that matter. * "six lang" sounds a _little_ like "slang", which may be somewhat apropos here. * filename extension could remain and solidify on ".p6" ("programming language 6"). * Name for 6lang devs: "sixers", which is conveniently already in use. * __Edit/Addition:__ Calling it 6lang lets you still keep separate names for the language and implementation.
It may be hard to find Perlers. But it's not hard to train other programmers into Perl, given that Perl/Python/Ruby are so much alike, (unfortunately many people just don't understand this though...)
Why not use Mojolicious?
I tried this, but had network connection issues when I tried to run code on one container and a MySQL DB on another container. Have you done anything like that (communication between multiple containers) on your setup?
I was a user of numeric Python before I landed onto a Perl-only job. But I've not yet any experience with PDL. I am curious to know to know if you see any weakness in PDL, and how you compare PDL to its counterparts in Python. So people can see this and might finally improve it (in Perl5/PDL or in Perl 6)?
Yeah we use it all the time. That's what docker-compose is *for* :) You can declare dependencies between containers, and connect to them using the short name you give them (or an alias you can also specify). The format description of docker-compose.yml files has a bunch of examples: https://docs.docker.com/compose/compose-file/
For a full example check out our code at https://gitlab.com/zaaksysteem/zaaksysteem It has separate containers for postgresql, redis, and IMAP server, an smtp server, a small daemon for document conversion, etc. And it all talks to each other.
PDL has an extremely elegant and awesome way of interacting with array data. Its "threading engine" allows you to do some really powerful things in really small spaces. It predates NumPy and SciPy by many years -- I've been using it since 2001. It has a smaller development community (especially these days) but was originally implemented more elegantly, so it was preferable for a long time and (for some uses) remains so. The PDL reference book is on Sourceforge -- you can get to it from the [PDL web page](http://pdl.perl.org) or [here](https://downloads.sourceforge.net/project/pdl/PDL-2.008/PDL-Book-2.008.pdf?r=http%3A%2F%2Fpdl.perl.org%2F%3Fpage%3DFirstSteps&amp;ts=1506616417&amp;use_mirror=cytranet). The main remaining differences between NumPy and PDL (aside from stylistic ones due to the host language itself) are: * PDL separates the concept of "computed/element" assignment from the concept of "total" assignment. The former modifies elements in a pre-existing array; the latter generates a completely new array. * Selection operators maintain a "dataflow" connection unless the connection is explicitly broken. So if you select a portion of an array and put it in a daughter, modifying elements in either array modifies the corresponding element in the other. This is very handy for multiple representations of data (e.g. separate R,G,B planes in an image vs. (RGB) triplets), and its implementation speeds the selection operators a lot: an array slice doesn't use additional primary memory. * Each PDL object has a means to carry metadata around: both internal flags that you can manipulate, and an attached Perl hash that you can populate with your own fields. There are some standard fields based on the FITS WCS standard that you can use to describe, e.g., world coordinate systems to which your pixel grid corresponds. * PDL includes a metalanguage (PDLPP) that you can use to define new vector operators in a very concise way. Together with Perl's Inline language-switching apparatus, this means you can include snippets of terse C-like code directly into your Perl scripts and create machine-speed operators on the fly. The last time I looked, Python's tools for this kind of work were much more cumbersome. Sorry for the multiple levels of bullet nesting: it appears to be a markdown bug in reddit.
Maybe https://metacpan.org/pod/lib::relative could be helpful? (I'd be interested in testing if it works properly on a windows platform)
I use Linux, perlbrew and phpstorm + perl plugin (very nice). Depending on the project I sometimes setup a vm and use the sync feature in phpstorm to push changes. I do a little PHP and I am pretty happy with my IDE.
My day is spent in iTerm2 on my iMac ssh'd into 3 or 4 Ubuntu server vms. On each vm, I keep multiple tmux sessions stored so I can quickly jump back into different task environments. I use neovim exclusively to edit my code. My navigation is to swap iTerm2 windows between portrait and landscape monitors, or switching tabs within each of them (different hosts for each tab in iTerm2), or connecting to different tmux sessions on the servers. That gives me the perfect flexibility to keep very quick access to several bash prompts and split screen vim sessions. EDIT: the storage is via a git repo and a shared NFS mount on each of the vms. 
[removed]
Have you tried Moo? Most of the features of Moose without the frontloaded setup time of the metaprotocol. Though if you are set on using perl's raw OO it won't help you there. (And I agree that OO isn't needed for everything to begin with, but it depends on the use case.) Class::Tiny and Mojo::Base are some other options that just do the bare minimum (and fast) so you don't have to write boilerplate constructors and accessors.
[removed]
This is what I've been trying to say. The discussion might have been useful, if the posts presented their case constructively, but that's not the case.
[removed]
Not that I prefer one or the other, but javascript has plenty of warts itself. It's just where the wind is blowing now, which seems to be the primary motivation of who I was responding to.
&gt; The age of a language has no bearing on the language, else C and C++ should be dead and the book should recommend Swift instead. I'll also note that Python is nearly as old as Perl. 
I wish Perl stayed at version 5.8. That is not the same as wish Perl to go back to 5.8. Nevertheless, I like to add my comment regarding those features: * function signature is emulated by my ($p1, $p2, ...) = @_. Perl functions are very dynamic and offers flexibility. Enforcing a function signature in any way will hurt this characteristic. * I have to look up what is smart match now -- so obviously I never find its need). There is no way I can comfortably use an operator unless I fully understand what it does -- "smart" is a word that often turn me off. Even Perl5.8 contains much "magic" that I probably never touched. * I probably won't object, nor I would care. * yield/continuation and async are simply context management. I guess I am so used to manage my own contexts that I don't really have need to off-load to language support.
[removed]
Stevan's new object system is on CPAN (in several independent pieces) and functional now, though the interface at the top level is a little odd in my opinion: https://metacpan.org/pod/Moxie Personally, I would vote for https://metacpan.org/pod/Class::Tiny and https://metacpan.org/pod/Role::Tiny to be cored, but as always the hardest part is politics.
The biggest takeaway here is that Larry Wall has stated that he is ok with an alternative name for marketing. Now the hard part is agreeing on and coordinating such a name.
How about Rakudo. That's a much better name. 
Just about everyone where I work uses Perl at work for... just about everything. As for me personally, lots of data extraction from financial reports (10s of thousands of reports), dropping that data into mySQL tables, then taking the data out of those tables, normalizing it all, and formatting it all into reports for our clients. 
I'm using Sublime Text 3 for Perl development, but I'm not very impressed with the auto completion support for Perl. I'm open to suggestions on how to improve my writing experience
It *is* a terrific name, however it's already used by *an* implementation of the language. While Perl's language/implementation are tightly bound, in 6lang they're much more distant; e.g. what Rakudo does does not define the language, the 6lang's spec does.
&gt; "six lang" sounds a little like "slang", which may be somewhat apropos here. Indeed, and 6lang has "slangs" as a(n experimental) feature, where you can lexically(?) mutate the language. So it all works out nicely :D
"Rakudo" is a good name, but the problem is that if it's just for marketing, then it will still really mean "Rakudo Perl 6" (as well as being the name of the main Rakudo Perl 6 compiler), which doesn't solve the issues at hand: * it's still got "Perl" in the name, and all the confusion that that entails for new sixers. * The Perl 5 folks are still stuck explaining to everyone that "Perl 5 is still the classic Perl you're thinking of, and yes it's confusing that Rakudo Perl 6 is using the name 'Perl' as well." 
I recently threw together a script to clean out old packages from netbsd pkgsrc installations that I should probably publish.
Didn't it also get faster? FWIW, porters did ensure my totally useless code on CPAN got the `{` regex thing fixed, so I'd say they went far and beyond in reducing the fallout. There's also [perlbrew](https://perlbrew.pl/) you can use to brew for a specific user a specific version of perl the code was design to work with.
&gt; Didn't it also get faster? I don't know, its kinda fallen beneath the noise floor in the thousands upon thousands of cycles wasted isolating and fixing all the things that got broken. &gt; FWIW, porters did ensure my totally useless code on CPAN got the { regex thing fixed, so I'd say they went far and beyond in reducing the fallout. If they submitted fixes for stuff on CPAN and 'fixed' it, that doesn't mean "they didn't break it". It means they still broke the code, and then gave people a workaround for the breakage, which was then dependent on somebody publishing the workaround, and that making its way to end users. Which is still "broke it", no matter how you say it. And this doesn't even begin to factor for the screeds of modules that haven't seen a maintainer activity since 2003. And every time this sort of shit breaks mainstream code like **autoconf** ( see OP ), people say things like "well, if perl is going to keep breaking this, maybe we should just rewrite it in python" ( Also said in OP ) &gt; There's also perlbrew you can use to brew for a specific user a specific version of perl the code was design to work with. That's just an admission that newer versions of Perl break existing software, and that's "OK, just dont upgrade, problem solved!" But the constant chatter you get when you are using an old version of perl is "Why are you using that old shit, upgrade! GET THESE SHINY NEW FEATURES". ( And people have the balls to do this via adding dependencies on newer perls ) Well, duh, There's a reason people don't upgrade. Because it breaks the shit they're using. 
What's a good way to do stuff like this? For example the @INC thing you mentioned fixed a major security bug. What would be a good way to implement fixes similar to that, where people think it just gottta be changed for whatever reason?
&gt; If they submitted fixes for stuff on CPAN and 'fixed' it, that doesn't mean "they didn't break it". The contemporary Perl community mindset is that if `$upstream` breaks `$downstream`, that means `$downstream` needs to be fixed ‚Äì rather than that `$upstream` needs to be fixed. Carpet-bombing RT with patches is seen as ‚Äústability‚Äù when it‚Äôs the very essence of the precisely opposite.
Hi - nubish programmer/Linux user here. You mean lock from commenting, not banish to the shadows or prohibit voting, right? My gut overreacted until I gave you a re-read. For my part, don't fret. My next two priorities are awk and Perl because I want to do more powerful text processing. Negative look-behind and conditional regex are sexy as hell to me. Perl 5's lauded `taint` feature has my curiosity, too. I care that posts like this get you and others down, and I personally couldn't care less about locking comments, so long as I can still see the post. When I recommend Perl to others, I want to be able to qualify that recommendation with contrary opinions they could run across, because nobody likes an evangelical fanboy. Seeing those contrary, disparaging ~~comments~~ posts here is convenient and awesome. Thank you! 
I will check it out. I now `use lib` but it took months for me to find it. It's like this simple feature is an outrageous luxury in the Perl world. ;)
Yes, but what's the point of having accessors at all? What's wrong with plain data? Actually, if anything is wrong, is that they're mutable. And many Perl functions change data in place instead of returning a modified version: `chomp`, `s///`, you name it. And all the array functions, `shift`, `unshift`, `push`, `pop`. I'd appreciate having immutable versions of these, much more than all those OO frameworks.
It's what I'm doing now, but if you google the issue,`use lib` is given as a last resort for when you can't set environment variables or such. I mean it should be backwards. It took months for me to realize this simple command was available. 
On the other hand, if you want to _limit_ your program's audience to just (actual|honorary|aspiring) greybeards, there are much worse choices than Perl. Not to mention ones that've got less turn of the century cool.
How would you suggest fixing the code? I'm not sure I exactly understand how to overcome the problem.
Just saw your blog post and read TimToady's comment more closely: &gt; I could go for something more like psix, "where the p is silent if you want it to be" :) P6 Oh, wow. That's really the name of the language. P6. It's what everyone has been calling it all along. It's already the filename extension. It's brief. Instantly pronounceable and recognizable. It's original. And as the commenter (BWVA) on your blog mentions, it carries no connotations/baggage for those not familiar with its history. It has all the benefits I mentioned previously, except for sounding like "slang". Some may prefer it not sounding like "slang". 6lang is a good name, but odd in that it starts with a digit. And, looking more at it, the 6 actually looks strangely somewhat like an upside down g to me (so, "glang"). **Edit:** Or a 'b', so at a glance it looks like ... "blang". Neither of those sound good. "P6" is better: * "p6" can be used as an identifier, * it's probably the best compromise with people who don't want to let go of the name "Perl 6" * it's the easiest one to transition to. That's the one. P6, a sister language to Perl. The P6 website can still mention "Perl" all over the site, and users won't be confused about which is which: Perl is Perl, P6 is a next-gen sister language to Perl. Go with that, and the Perl 5 folks can finally go back to calling their language "Perl" (without the 5). All complains stop, and the sixers just made a good friend of the Perl (5) community. 
TBH neither is ideal to my eyes: "P6" is a random combination of a letter and a number. What was it "Q5"? "N8"? The acronym [is already in use](https://en.wikipedia.org/wiki/P6_%28microarchitecture%29) in computing and isn't immediately obvious it refers to a programming language. "psix" looks like a typo, has "pee" in its name, and someone already made a "pee sex" joke about it. 
Fixing that problem right, is so hard, that we still haven't actually done it, and nobody has presented a good way to do so. What was done instead was an attempt to fix a specific incarnation of an entire *class* of issues, and the class is still there. But what I can tell you, is the number of packages that were broken because of this, were far greater than the number of packages that had a real security concern. Lets take another long standing Perl feature that provides improvements to security, which, while not being any absolute measure, does help in some minor way ( which makes it a good analogy ): Taint mode. Its a very good thing P5P didn't decide to make taint mode the default mode. It would be obviously entirely irresponsible to blanket-enable it because the amount of code it would break would be astronomical. And ... ironically, taint-mode has omitted `.` from `@INC` since forever!. But "well, its too hard to do right, so we'll just do it wrong instead, because it helps a little bit, and that makes it ok right?" is still a "we like to have weak justifications for breaking software", and is still an admission that "yes, we break things by choice". 
So how to do it the hard way?
It's sad to see another instance where AnyEvent is mentioned as the go-to "event loop/async" paradigm for Perl, when its abstract is but misleading propaganda; it's not the DBI of event loop programming, it's the least compatible and least supported of the top four pluggable event loop ecosystems on CPAN. [POE](https://metacpan.org/pod/POE), the old man on the mountain, had pluggable event reactors years before AnyEvent was even a concept. [IO::Async](https://metacpan.org/pod/IO::Async) and the newest contender [Mojo::IOLoop](https://metacpan.org/pod/Mojo::IOLoop) have interfaces that may be more agreeable with the Javascript generation (which includes myself), and also have pluggable reactors. All three have the ability to interoperate, maintainers that idle in the same IRC channels, and extensive ecosystems with strengths in different areas. Meanwhile AnyEvent [still has a hard-coded die](https://metacpan.org/source/MLEHMANN/AnyEvent-7.14/lib/AnyEvent.pm#L1439) when IO::Async tries to interoperate with it, which the maintainer somehow [considers FUD](https://metacpan.org/pod/AnyEvent::Impl::POE#Questionable-maintainer-behaviour). I'm not saying you should not use AnyEvent if you've considered all this and considered it acceptable, perhaps if the AnyEvent ecosystem scratches an itch not solved sufficiently in the others, or if you have existing code already using it, but please don't present it as the first choice. (edit: And sorry for latching onto one tiny link in the whole blog post. This is sort of a continuously appearing pet peeve of mine.)
Rex is pretty nice https://www.rexify.org 
The number of packages that had a security concern is kind of dwarfed by the fact that the distribution package installer for one of the most well known linux distributions had a security concern, which actually was exploitable in practice.
Well, you might need a user loaded plugin that employs discretionary access controls on a path-by-path basis. Because the real vulnerability path is "loading executable code from untrusted paths", where "untrusted paths" are "paths that anyone can write to, or at least, historically, could write to". If you made "." and everything in it, then you're not in a vulnerable state. And that's exactly the situation when you're doing CPAN module installation: - `.` and its contents you just rolled out from a tar.gz - `inc/` is expected to be loadable and executable - `t/` is expected to be loadable and executable Because the path of trust is "I untarred this archive and I am executing its contents". And subsequently, the original risk path, where executable code could live in `/tmp` and be loaded by accident, can still occur: You just need to load [some CPAN module](https://grep.metacpan.org/search?q=use\\s*lib.*tmp&amp;qd=&amp;qft=) that adds `/tmp` to `@INC`, and you no longer even have to chdir to execute vulnerable code. Because the CPAN module and `/tmp` are not governed by the same authors, and `/tmp` being world writeable is also not governed by you, or the CPAN module. But as you can imagine, doing that sort of thing is really messy, at least, without having hooks in Perl itself to make it possible, and needs platform-specific help.
Sorry, I meant the more general problem that to progress the language must some times make breaking changes. From your description of how @INC issue should've been handled, it sounds like any change should provide a hook that end user must subscribe to on an opt-in basis, but wouldn't that be even more annoying? I don't want to try to remember to update every single script I wrote to add an opt-in for security fixes. I think that'd be impossible actually, with my shitty memory :)
I tried this before and managing dependencies within the perl files was not fun.
I code on my work laptop (ubuntu) with vim and a bunch of plugins. Testing occurs on a vagrant machine, I have a few set up to mimic our server archetypes, and use the system's environment variables to determine which databases and job queues I connect to. 
Novice perl programmer but I'm creating an auto-extractor for torrents.
&gt; "P6" is a random combination of a letter and a number. But no! In fact, it's already hewn right into the [Perl 6 logo itself](https://perl6.org/camelia-logo.png)! &gt; The acronym is already in use in computing and isn't immediately obvious it refers to a programming language. That just goes to show that it works fine as a name. And it doesn't need to be immediately obvious that it refers to a programming language --- hardly any programming language names do. You find them by searching "C programming language" or "java programming language", etc. &gt; "psix" looks like a typo, has "pee" in its name, "psix" does look a bit odd. Maybe a typo of "posix"? Regardless, I think "P6" is much better than "psix". A letter and number works. Like the [BMW i8](https://www.bmwusa.com/vehicles/bmwi/i8.html), [Audi A4](https://www.audiusa.com/models/audi-a4) (and A4 paper), vitamin B6, fireworks M80, Cray X1 supercomputer, V8 JavaScript engine (and vegetable juice!). As for the letter P, in physics it's used for momentum (lowercase), and power (uppercase). In math it's the peta- prefix (as in \*10^15). It's the chemical symbol for phosphorus. P3 was an airplane. P4 is a CPU. [P10](https://en.wikipedia.org/wiki/IRCd#P10) is some IRC extension protocol. P6 man! Search your feelings, you know it to be true! &lt;/vader&gt;
6lang though. That isn't even something that makes me go "Huh, what is that?". Might be just me though.
&gt; But no! In fact, it's already hewn right into the Perl 6 logo itself! Only because it's an acronym for "Perl 6". If I'm writing an article about about async features, the title `P6 Async` is rather meaningless. &gt; A letter and number works. Like the BMW i8, Audi A4 (and A4 paper), vitamin B6, fireworks M80, Cray X1 supercomputer, V8 JavaScript engine (and vegetable juice!). The list you provided to me shows that "P6" is a terrible name. You had to add clarifiers to the letter+digit combinations for them to make sense any sense at all. You even had to clarify the ambiguous ones (same as P6 is ambiguous with the architecture). The more fair comparison is: i8, A4, B6, M80, X1, V8. The "P6" looks like an acronym that begs an explanation of what it stands for to understand even its basic meaning that it's a language name. I don't see it standing on its own without "Perl 6" to prop it up, and the whole point of this exercise is to find a suitable alternative for those who consider "Perl" part to be a misnomer.
This is kinda where we need a secondary stream or something for deploying security solutions that break backcompat independently. For instance, many Linux vendors have their own security systems where they deliver advisories about security issues, and deploy with those advisories how to get fixes ( most of the time these are just "Install version &gt;= foo" ), describing the scope of the problem so that users who are affected can self-identify. We really don't have such an equivalent mechanism that I'm aware of with Perl, the only way you find out about security issues is they're stated in the release notes of the perl versions with the fixes. This is pretty much not helpful for anyone who is stuck on older perls for whatever reason and *cant* upgrade to get the fixes for *other* reasons. Maybe there's scope here for a dedicated library that exists simply to deliver language-wide security fixes to older perls, but even that seems like it would re-create the same problem, one step removed. Ideally, the nature of any such dangerous change is you need to be aware its happening when it happens, you need a clear picture of what is affected, and you need the tools to make the right choices. We just don't have any of those things, we just make the choice for the user, we make it the default, and then 2 cycles later, we remove the ability for them to opt out! In practice, we're maximising for breaking downstream code, because upstream is maximising for their own convenience. 
&gt; that the distribution package installer for one of the most well known linux distributions had a security concern A concern that could be fixed by either of 2 ways: * Patching the starting point of various programs not to have '.' in @INC ( as was done in 5.24.1 , and did not require breaking CPAN ) * Patching their sitecustomize.pl not to have '.' in @INC, which breaks CPAN only for the debian toolchain. If we escalated every programs misuse of Perl features to core changes, instead of changing the misuse, then what would we do. Would we remove the ability for `rm -rf ` to nuke directory trees because somebody somewhere invoked it wrong and deleted directories they didn't intend to? You can *still* get `/tmp/` into @INC and load vulnerable code from `/tmp`, its just less likely. And there is code on CPAN that puts `/tmp` into `@INC` https://metacpan.org/source/GEOFF/Devel-Profiler-Plugins-Template-0.01/t/02context/10process.t#L57 https://metacpan.org/source/ALAMBIKE/Eixo-Docker-1.211/examples/basic_containers_examples.pl#L1 If you find yourself running any of this code, you are just as vulnerable. Debians amplification of scale only makes it seem significant because their weak entry point has a large volume of users. But no matter how big your audience, if you fix the entry point of the problem, well, you fix the problem. And Debian already have fixed this problem on their own without CPANs help. Don't blame them for this. Linux vendors are allowed to do what they want with their Perl distributions, because they're responsible for what they break, and they're responsible for whatever security issues they do and don't care about. However, none of the above changes the fact that: 1. P5P Does actually break things by choice. The debate subsequent is a goalpost shift to a secondary discussion about how justifiable it is that they break things by choice.
&gt; The list you provided to me shows that "P6" is a terrible name. You had to add clarifiers to the letter+digit combinations for them to make sense any sense at all. Any tech with names like V8, nginx, MoarVM, JVM, etc. is going to need a little explanation and getting used to. In ancient times there was even a language called [PL/I](https://en.wikipedia.org/wiki/PL/I). There was an OS called Plan 9. That said, I'm not arguing that "P6" sounds *awesome*. The "pee" sound isn't the *best*, but I do think it's great. And an excellent compromise with sixers and fit for Perl 6. &gt; The "P6" looks like an acronym that begs an explanation of what it stands for ... Meh. Again, lots of software has weird names that don't stand for anything (or else have some backronym for them) that take some getting used to. LLVM, Perl POD, GNU GCC, etc. &gt; I don't see it standing on its own without "Perl 6" to prop it up, and the whole point of this exercise is to find a suitable alternative for those who consider "Perl" part to be a misnomer. If you're not happy with it standing on its own (and note, most users will just take it in stride and go, "Ok, it's called 'P6', tell me about it"), then if you like, P6 = "Perl 6" for sixers, and "Programming Language 6" for everyone else. &gt; and the whole point of this exercise is to find a suitable alternative for those who consider "Perl" part to be a misnomer. Yes. "P6" does that. It removes "Perl", but sixers still have the satisfaction of squinting at it and knowing where the "P" came from. Everyone else just says, "oh, P6 is Perlish, got it". I kinda' like the idea of Perl 6 / Rakudo / P6 / 6lang owning the "P". Perl 5 owned it back in the LAMP days. 
**Plan 9 from Bell Labs** Plan 9 from Bell Labs is a distributed operating system, originally developed by the Computing Sciences Research Center at Bell Labs between the mid-1980s and 2002. It takes some of the principles of Unix, developed in the same research group, but extends these to a networked environment with graphical terminals. In Plan 9, virtually all computing resources, including files, network connections, and peripheral devices, are represented through the file system rather than specialized interfaces. A unified network protocol called 9P ties a network of computers running Plan 9 together, allowing them to share all resources so represented. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Kind of an aside, but LAMP refers to PHP, not Perl, though both Perl and Python could be conveniently substituted.
Blasphemer! ;) 
I berate PHP enough, I figure it gets one free.
Right, but you're perfectly ok with these? [] + []; // =&gt; "" {} + []; // =&gt; 0 {} + {}; // =&gt; NaN [0] == false; // =&gt; true {} == {}; // =&gt; false [0] == "0"; // =&gt; true NaN == NaN; // =&gt; false Every language has its quirks.
AnyEvent *is* the go-to "event loop/async" paradigm for Perl. (I'm not happy about that but it's true) POE seems unmaintained. Mojo::IOLoop is great but the documentation is nowhere as good as AnyEvent and to use it you have to be familiar with Mojolicious conventions. Also, most event loop abstractions are only fast when used with libev, which was written by the author of AnyEvent (Marc Lehmann) so it makes no sense to stop using AnyEvent because of Marc's hostility but then use Mojo::IOLoop with Mojo::Reactor::EV. I am not too familiar with IO::Async but the ecosystem is not as big as AnyEvent's. I feel that the only way to break free from EV and AnyEvent is to write proper perl bindings for libuv (the current perl UV module is incomplete)
We created our own base layer, based on the Perl base layer, that has all our dependencies already installed (using cpanfile/cpanm) When dependencies change you need to rebuild that base layer, and off you go again. This happens every few weeks, and most of it's automated/scripted.
[removed]
EV's merits stand on their own. I am only arguing against promoting AnyEvent, and my reasons for avoiding it mostly don't apply to EV (though I am loath to include any of his modules in my dependency chain, that's primarily based on past experience). Like you mentioned, EV can easily be used with the other event loops, so that's a non-factor; and there aren't any real alternatives. (Though I find the built-in Poll loops for both Mojo and IO::Async are fast enough for the majority of my needs; they've both been optimized quite well in the past couple years by bypassing IO::Poll's API, funny enough.) It widely depends on what you need from an event loop of course (and there are specific things I know of that only have decent bindings for AnyEvent), but I've found everything I have needed between the IO::Async and Mojo ecosystems, and I'd be curious to know if you have a requirement that you feel is missing from them. I also use POE as I have experience with it and in particular POE::Wheel::Run; it is not unmaintained (indeed the author is quite happy to politely discuss or help with it in #poe on irc.perl.org), but rather (like many old projects) is focused on backcompat and doesn't particularly need new features. But it wouldn't be my first recommendation to others as IO::Async tends to fill its shoes well and fits better in most people's "modern perl" and "async" mindsets. And if a program works best with parts from different ecosystems, it's easy to glue them together, as long as one of them isn't AnyEvent. By the way there is a [project underway](https://metacpan.org/release/CAPOEIRAB/UV-1.000002-TRIAL) to bring UV up to usefulness, but the brave soul working on it requires more of the limited XS arcane knowledge that exists.
[removed]
[removed]
[removed]
In my case, and back when I was learning, the whole array slicing syntax deal was just a delight to learn and use. But an actual tip would be using -e to check for file existence. if -e './whatevs.txt' ...;
Using `my` in a for^list loop doesn't actually declare a new variable - it just renames `$_` - which means if you alter it you actually alter the value in the list itself. Try this: use strict; my @cars = qw( BMW Audi Volvo ); for my $car ( @cars ) { $car .= " drivers suck"; } print( join( ", ", @cars ) ); This outputs: BMW drivers suck, Audi drivers suck, Volvo drivers suck Which is not what you'd expect. This bit me several times until I learned about this quirk.
I've learned some of the coolest Perl stuff by reading the "perldelta" manpages. They contain all the new features, and a list of things that will be obsoleted in the new version of Perl.
Got to be hash slices. my @cols = qw[col1 col1 col3]; my @data; while (&lt;$some_file_handle&gt;) { chomp; my %row; @row{@cols} = split /\t/; push @data, \%row; } I use this all the time. And it's always a big "wow" moment when I introduce it on my intermediate level course.
I will second /u/davorg about Hash slicing. Particulalry nice when you have a function that takes a lot of arguments, so you use named args... but you also use them a lot so you want to assign them to scalars up front. This is a trivially short example of a higher-order function, but you get the idea sub process( %args ) { my ( $data, $pred, $proc ) = @args{qw( data pred proc )}; return map { $proc-&gt;($_) } grep { $pred-&gt;($_) } $data-&gt;@* } I'm also loving using signatures and post-deref as you can see. But for more classic fave tip, I can't go past `split(' ')`. The `split` function typically takes a regex. Even if you give it a "string" it's treated as a regex pattern. The exception to this is the ~~single-quoted~~ single space `' '`. This is special syntax that splits a string by any arbitrary whitespace, ingnoring leading and trailing whitespace. my $line = " oddly spaced words "; my @words = split( ' ', $line ); # @words = ('oddly', 'spaced', 'words') I do a lot of text processing and I use this almost every time. Note that `/ /` does not do the same thing, only `' '`. Also, a word of warning... If you like your regex patterns with insignificant whitespace so much you `use re '/x'`, then this trick doesn't work. The most obvious solution is to do it inside a function that lexically disables the `re` pragma use re '/x'; sub words( $str, $n = 0 ) { no re; return split( ' ', $str, $n ); } my $line = " oddly spaced words "; $line =~ / s p a c e d / &amp;&amp; say join( ', ', words($line) ); The `$n` retains the ability to control the number of times to split. Edit: Updated to reflect whitespace split works with `split(" ")`
Agreed on these, just one very minor point: " " or a scalar variable containing a single space will have the same effect - i.e. perl -e'split " "' works the same way as your split ' ' example.
Unlike Python, we don't need a (named) function to make a lexical scope. Any block will do. $line =~ / s p a c e d / &amp;&amp; do { no re; say join ', ', split ' ', $line; } if ($line =~ / s p a c e d /) { no re; say join ', ', split ' ', $line; } 
Would @rows = ('a','b','c'); @hash{@rows} = (1, 2, 3); Make $hash{a} == 1 ?
And to be sure its a file -f
No Perl here
True, but I've used my `words()` sub about 8 times in my current project. I don't wanna repeat myself, and creating lexical block everywhere is not always convenient. For example, I'm using inside a conditional which makes for some nicely readable code. if ( words($input) == 1 ) { ... } 
Ahh, you are correct, sir. I could have sworn that double-quoted string behaved differently. Damn false memories.
[removed]
Exactly.
I really like the App::Cmd (https://metacpan.org/pod/App::Cmd) module in order to build my CLI apps.
`map` is an awesome function, and you can do a lot of cool things with it. A pretty standard: my @things = qw ( fish carrot banana potato ); my %is_thing = map { $_ =&gt; 1 } @things; print "'fish' is a thing\n" if $is_thing{'fish'}; You can select 'paired' values straight into a hash. So given some text like: test=woilla test2=gronk fleeg=flirble You can hashify this: my %value_of = $str =~ m/(\w+)=(\w+)/g; 
What about hashref slices? my $hr = { qw(one 1 two 2 three 3 four 4) }; my @odd = @{$hr}{qw(one three)}; Interpolating *anything* into strings, not only scalars and arrays: "localtime @{[ join '-', localtime ]}" "2 + 2 = @{[ 2 + 2 ]}" Writing `sort` like functions with `$a` `$b`: sub pairgrep(&amp;@) { my $func = shift; my $caller = caller; my @res; while (@_) { my $key = shift; my $val = shift; no strict 'refs'; local *{"$caller\::a"} = \$key; local *{"$caller\::b"} = \$val; push @res, $key, $val if $func-&gt;(); } @res; } And then my %h = qw(one 1 two 2 three 3 four 4); my %even = pairgrep { $a ~~ [qw(two four)] } %h; I know I know, it's core in `List::Util` from Perl 5.20, but I badly wanted it in older versions. And something I learned yesterday. What happens with a hash in scalar context? %h = qw(one 1 two 2 three 3 four 4); print scalar %h, "\n"; print %h . "\n"; 3/8 3/8 WAT? Number of used/all hash buckets!
Works especially well IMO for stuff like CSV with header rows. #!/usr/bin/env perl use strict; use warnings; use Data::Dumper; #read header row. chomp ( my @header = split /,/, &lt;DATA&gt; ); my @rows; #iterate other rows while ( &lt;DATA&gt; ) { chomp; my %row; #use hash slice to insert into named values. @row{@header} = split /,/; #push this row into the larger data structure. push @rows, \%row; } print Dumper \@rows; __DATA__ field1,field2,field3 value,anothervalue,someothervalues fish,bird,carrot 
I find `//` to be particularly useful. It's not comment, it's a 'defined' test, that works like `||`. So you can do: print $value // 'default',"\n"; And if `$value` is undefined, then you get a default. But _unlike_ `||` it handles empty string and zero differently (which are boolean false, but defined). You can also use it for setting defaults with `//=`: my $thing //= 'default value here'; 
[s/script/program/](http://web.archive.org/web/20120211064443/http://xoa.petdance.com:80/Stop_saying_script) Where did you get "solution" from? No one says that. Is anyone else using %appstrs meta information? I use [Module::Starter::PBP](http://p3rl.org/Module::Starter::PBP) as template (about ten to twenty times more useful than yours), and [PCP::Documentation::RequirePodSections](http://p3rl.org/Perl::Critic::Policy::Documentation::RequirePodSections) to test it. Single file is a tempting siren call, but does not and cannot work out in reality. For starters, how do you want to record dependencies? You need to give in to the notion that a software source package consists of more than one file, yes even if you are "just" a sysadmin, and then you can leverage the ecosystem around the conventions we have agreed on. "CPAN readiness" is a huge time and work saver.
`say $x` is prettier than `print $x . "\n"` Embrace post-dereferencing. $a = { a =&gt; 1 } ; $b = $a ; $b-&gt;{ a } = 2 ; say $a-&gt;{a} ; # 2, because references my $c = { $a-&gt;%* } ; $c-&gt;{ a } = 4 ; say $a-&gt;{a} ; # 2, because values say $c-&gt;{a} ; # 4, because values Plus, the Schwartzian Transform is a bit mindbending, but once you understand it, it's **very** powerful.
I wanted to start keeping an electronic journal, but don't trust any existing app or system to keep my personal thoughts secure. I'm most of the way through developing a Catalyst app using end to end encryption using Crypt::CBC and AES-256. It uses DBIx and has full-text search capability.
"Rakudo" is the best sounding name. "P6" is the easiest to use (already have .p6 files, people already informally refer to it or type it as P6). I don't think "6lang" will catch on. Just my 2 cents. In the end, if you wait much longer, if the Perl6-ers do nothing, and Perl 6 doesn't replace Perl 5, then I think people outside of Perl 6 will just start calling it Rakudo to avoid confusion. You already see posts on r/perl about Rakudo releases, and newcomers probably just assume that's another name for Perl 6. 
Yeah, and here's the thing. I know that Rakudo is an implementation of Perl 6 or however you want to say that. I don't care. At this point in time, Rakudo is the best name period. It's unique. It sounds good. Enables good marketing. I could go on but you get it I am sure.
Alright I took another crack at it. This appears to work. /MA/ and test - do not test positive /MA/ and Mars - does test positive. #!/usr/bin/perl use strict; use warnings; my $test = $ARGV[0]; my $string = $ARGV[1]; $test =~ s/[^a-zA-Z0-9]*//g; if ($string =~ m/$test/ ) { print "Match: $ARGV[0] matches $string\n"; } 
&gt; What about hashref slices? &gt; &gt; my $hr = { qw(one 1 two 2 three 3 four 4) }; &gt; my @odd = @{$hr}{qw(one three)}; And now with postfix dereferencing: my @odd = $hr-&gt;@{qw(one three)}; 
dispatch tables my $dtable = { something =&gt; \&amp;BLA::Today::do_something, something_else =&gt; \&amp;BLA::Today::do_something_else, }; symbol table manipulation : read the source for Class::Data::Inheritable, saw the light 
It *is* the best name, though I don't know if Perl 6 people will accept it. That's why I suggested P6 -- I thought it would be more palatable for them. I think it's nonsense to try and call the language "Rakudo Perl 6". Another nice thing about the name "Rakudo": they already own [the domain](http://rakudo.org/). 
My tip is use [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) for HTML parsing. In the past, I used to use `HTML::TokeParser` then `HTML::TokeParser::Simple` and people recommended all sorts of XLTS and Tree parsers and they all were awkward to use. So as far as blowing minds goes, `Mojo::DOM` did that when I first found it. I already knew CSS well at the time, so perhaps that helped the ease of use, but compared to `HTML::TokeParser`, `Mojo::DOM` plays in a whole 'nother league. ----- But if you meant core-Perl tip, then I'd say it's that the `/.../` in list context returns the captures and `/.../g` returns the matched substrings if there are no captures in the regex: say join ", ", "foo bar ber" =~ /\w+ (\w+) (\w+)/; # OUTPUT: bar, ber say join ", ", "foo bar ber" =~ /\w+/g; # OUTPUT: foo, bar, ber Nice and concise and no `$1, $2` to deal with. 
&gt; And now From Perl 5.20 upwards, with use feature qw(postderef); and it's experimental up to 5.22.
Not trick per se, but the first time I ran into lexical post-if: my $var = some_stuff() if whatever_expression(); If you don't know it: it's a horrible bug waiting to happen, because the lexical is only created if the condition is true, but in the scope of the surrounding code, because post-if doesn't create its own scope. So if you have a variable with the same name further up the calling chain, that value will end up being used. My tip: Use a linter or a PPI based test to catch them in your code.
I think that looks good too.
The [Schwartzian transform](https://en.wikipedia.org/wiki/Schwartzian_transform). I don't often have a need for it, but it's a very cool way to sort an array by an additional attribute. There's no need for a secondary data structure that keeps using memory after the sort is done, and the attribute is only found/computed once for each element. 
I've been using Perl for 3 years and you opened my sir!) Thank you.
Ah, let me mull it over. It's not a showcase of best Perl coding by any means so it might be kind of embarrassing. ;) Just to be clear, this is for fiction and poetry books, not documentation. I guess it could work for docs too, but there are no fancy layouts like text frames and side-by-side figures. EDIT: Englische. 
Yeah, 'my' is scope. Same as 'our'.
Sorry, I can't see why that is surprising. That's what I thought would happen.
[P](https://stackoverflow.com/a/6163129/1039320)[e](http://world.std.com/~swmcd/steven/perl/pm/xs/intro/index.html)[r](http://www.masteringperl.org/2015/05/computing-excellent-numbers/)[l](http://www.linuxcareer.com/perl-as-a-career-option) [c](http://irclog.perlgeek.de/perl6/2013-10-17#i_7723873)[o](http://www.perl.com/pub/2005/07/14/bestpractices.html)[m](http://www.wall.org/~larry/pm.html)[m](http://interviews.slashdot.org/story/02/09/06/1343222/larry-wall-on-perl-religion-and)[u](http://www.perlmonks.org/bare/?node=Erudil)[n](http://rjbs.manxome.org/rubric/entry/1959)[i](http://blogs.perl.org/users/damian_conway/2012/03/why-i-love-my-job.html)[t](http://perlbuzz.com/2010/11/29/think_for_perls_sake/)[y](http://www.perlmonks.org/?node_id=1180698)... ^ generated via this script: #!/usr/bin/perl use strict; use warnings; chomp( my @links = reverse &lt;DATA&gt; ); print map /\s+/ # don't turn whitespace into a link ? $_ : "[$_](" . pop(@links) . ")", split //, 'Perl community'; print "...\n\n^ generated via this script:\n\n"; open my $script, "&lt;", $0 or die "Can't open $0: $!"; print " $_" while &lt;$script&gt;; __DATA__ https://stackoverflow.com/a/6163129/1039320 http://world.std.com/~swmcd/steven/perl/pm/xs/intro/index.html http://www.masteringperl.org/2015/05/computing-excellent-numbers/ http://www.linuxcareer.com/perl-as-a-career-option http://irclog.perlgeek.de/perl6/2013-10-17#i_7723873 http://www.perl.com/pub/2005/07/14/bestpractices.html http://www.wall.org/~larry/pm.html http://interviews.slashdot.org/story/02/09/06/1343222/larry-wall-on-perl-religion-and http://www.perlmonks.org/bare/?node=Erudil http://rjbs.manxome.org/rubric/entry/1959 http://blogs.perl.org/users/damian_conway/2012/03/why-i-love-my-job.html http://perlbuzz.com/2010/11/29/think_for_perls_sake/ http://www.perlmonks.org/?node_id=1180698 
 like the acceptable : my $var = 32 if 0; 
But why not just use a for loop and make it easier for whomever is coming behind you to read. I have been writing perl since perl v2 and I can't find a really good reason to use map other than to be perish. I love perl, probably too much, but I hate perl code that is hard to read just because someone wanted to be perlish. I am sure that I have never done that üòú ... Err not that I would admit to in Reddit 
references - before their existence, I used any number of old, lame methods to encode some form of data structure into a string, list or associative array. references have me freedom to go wild and shape the structure on the fly the way that I wanted. Wow!!!! While I am not a computer scientist and am ignorant in many if not most languages, I don't know of any language with similar capability. - edited to correct typos
Using map for this *is* the easy, idiomatic way. It's perlish? This **is** Perl. That's like complaining something written in Java is javaish.
This has nothing to do with `$_`. This is because `for/foreach` aliases each value, rather than copying it, like subroutines alias their arguments to the elements of `@_`. In fact, this is one reason why using `$_` in a for loop can be dangerous even though it localizes the variable; if you call code inside your for loop that modifies `$_` for its own purposes, that will modify whatever the for loop is iterating through!
FWIW there is a [core perlcritic policy](https://metacpan.org/pod/Perl::Critic::Policy::Variables::ProhibitConditionalDeclarations) for this, and I've subclassed it into the [freenode theme](https://metacpan.org/pod/Perl::Critic::Policy::Freenode::ConditionalDeclarations).
Hashes in scalar context now (since 5.26) returns the number of keys, since the hash bucket details are slower to calculate, implementation dependent, and really not relevant to the programmer. If you really needed the implementation details for some reason, you can use [Hash::Util](https://metacpan.org/pod/Hash::Util).
feature.pm isn't needed to enable it once it became no longer experimental (5.24+), since it doesn't conflict with existing syntax.
Most scripting languages have this capability, or the capability of multi-dimensional data structures, in some form; it would be very difficult to do anything complex without it. Fun fact: since perl 4 didn't have references, it had a shortcut to generate fake multidimensional arrays, which still exists in perl 5 today, but you should probably never use it, and it looks confusingly like a hash slice: https://metacpan.org/pod/perldata#Multi-dimensional-array-emulation
At work: our team currently implements a "replica" system that should create and manage replicas to the customer databases so they can easily switch to them in case of a failure of the primary one, but also if they e.g. want to change the database engine without waiting for the dump of the original database, translation between the SQL dialects, and load. At home: currently busy improving [pm-cb-g](https://github.com/choroba/pm-cb), a GUI client for the PerlMonks' Chatter Box.
I use emacs to write code. I run Linux on my home and work computers, but at $job - 1, we used MSWin desktops - a cygwin window was my lifesaver. Other than that, the usual stuff: git, makefiles, perlbrew for testing, blead perl for checking fixed bugs.
I didn't grok `map` until I realised it's a list comprehension in the functional programming sense. Being able to manipulate whole lists is surprisingly useful. 
do you know what the logic is for /g having that functionality, as opposed to, say, /r ? Otherwise, wow, TIL. I ask because /g with capture groups 'carries on going for the whole string' my $x = "cat dog house"; while ($x =~ /(\w+)/g) { print "Word is $1, ends at position ", pos $x, "\n"; } prints Word is cat, ends at position 3 Word is dog, ends at position 7 Word is house, ends at position 13 and /r is the "return the result of the match". 
`+` forces scalar context on its arguments, @_ is an array, and arrays in scalar context return their size. Array that contains only 5 has size 1, 1+1 is 2. In case of 1), though, the sub is called in list context as an argument of `print`, and nothing changes the context, so it returns all the members of the array, in particular 5. Use sub { 1 + shift } or sub { $_[0] + 1 } instead.
Autovivification, which is such a cool Perl trick that [the wikipedia page](https://en.wikipedia.org/wiki/Autovivification) starts out "In the Perl programming language..." Given a bunch of lines that have devices and genres (this was from an iTunes example that I just tried -- full example further down)... my ($device, $genre) = split(/\t/, $_); $index-&gt;{$device}-&gt;{$genre}++; We get so used to this, that it's easy to take for granted. But in most languages you can't do this sort of thing so easily. You can go as many levels deep as you want, and you can change up the grouping by just moving around where your variables are in the hash. It's very powerful and is a handy party trick (well okay, a work trick). Here's the full example, which assumes you have `curl` and `jq`: curl -s "https://itunes.apple.com/search?term=football&amp;country=us&amp;entity=software" | jq -r '.results[] | .genres as $genres | .supportedDevices as $devices | $genres[] | . as $genre | $devices[] | [.,$genre] | join("\t")' | perl -MData::Dumper -lne '($device, $genre) = split(/\t/); $index-&gt;{$device}-&gt;{$genre}++; print Dumper($index) if eof' And, if you don't have `jq` or prefer the pure-Perl version... curl -s "https://itunes.apple.com/search?term=football&amp;country=us&amp;entity=software" | perl -MJSON -MData::Dumper -lne 'push(@out, $_); if (eof) { my $index = {}; my $data = from_json(join("", @out)); for my $result(@{$data-&gt;{results}}) { my $genres = $result-&gt;{genres}; my $devices = $result-&gt;{supportedDevices}; for my $genre(@{$genres}) { for my $device(@{$devices}) { $index-&gt;{$device}-&gt;{$genre}++ } } } print Dumper($index) } '
**Autovivification** In the Perl programming language, autovivification is the automatic creation of new arrays and hashes as required every time an undefined value is dereferenced. Perl autovivification allows a programmer to refer to a structured variable, and arbitrary sub-elements of that structured variable, without expressly declaring the existence of the variable and its complete structure beforehand. In contrast, other programming languages either: 1) require a programmer to expressly declare an entire variable structure before using or referring to any part of it; or 2) require a programmer to declare a part of a variable structure before referring to any part of it; or 3) create an assignment to a part of a variable before referring, assigning to or composing an expression that refers to any part of it. Perl autovivification can be contrasted against languages such as Python, PHP, Ruby, and many of the C style languages, where dereferencing null or undefined values is not generally permitted. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
What if I tried something like: `sub { $_[0] % 3 == 0; }` Would this return a Boolean as long as I passed a numeral?
&gt; do you know what the logic is for /g having that functionality, as opposed to, say, /r ? Nope, don't know. I don't think `/r` existed that far back yet.
There aren't any Booleans in Perl. What's returned depends on the context in which you call the sub. It's easy to try: $ perl -wE 'say sub { $_[0] % 3 == 0 }-&gt;($_) for 1 .. 3' 1
`/r` applies to `s///`, not `m//`, which has different return values to begin with. There's no `/r` modifier for `m//`. Your example is running `m//g` in scalar context (whereas Zoffix's example is in list context), which changes both its behavior and return value, something that can be surprising to newcomers but was probably intended to be "intuitive".
The `dbmopen` command which ties a hash to a local on-disk database. Years before sqlite, I believe, and doesn't require a module. It's deprecated and there are much better ways to do it, but sooner or later you need some kind of simple, *ad hoc* database and `dbmopen` is the quickest way to do it.
FWIW, this was superceded aaages ago by the core module [DB_File](https://metacpan.org/pod/DB_File). Another one for similar usecases is [DBM::Deep](https://metacpan.org/pod/DBM::Deep). But I tend to prefer SQLite anyway, though I might be [biased](https://metacpan.org/pod/Mojo::SQLite); it's generally going to be much more efficient in the long run if you're doing anything other than reading and writing the entire structure at once.
One of my favourite uses of this is trimming leading and trailing whitespace: my @foo = (' foo ', ' bar '); s/^ +//, s/ +$// for @foo;
It's very useful in general for quickly making the same modification to every element of an array.
What does the following code do? use strict; my @cars = qw( BMW Audi Volvo ); for ( my $i = 0; $i &lt; scalar @cars; $i++ ) { my $car = $cars[ $i ]; $car .= " drivers rule"; } print( join( ", ", @cars ) ); 
I do not recommend using Perl::Version for bumping perl module versions. It only supports dotted-decimal versions (i.e. `v1.2.3`). For example, it will bump the version `1.9` to `1.10`, which is a smaller version in perl version numbers. I wrote [perl-bump-version](https://metacpan.org/pod/perl-bump-version) (actually [App::RewriteVersion](https://metacpan.org/pod/App::RewriteVersion) is what does all the work) to bump perl module versions (both decimal and dotted-decimal) correctly, using [Version::Next](https://metacpan.org/pod/Version::Next).
I argued against smartmatch as much as I could back when it was getting added because it was obvious from the start that the idea was fundamentally broken in the context of Perl&amp;#160;5. But people wanted so badly to believe, and were so intent on copy-pasting design choices from Perl&amp;#160;6, that it got added anyhow. 5.10 was a catastrophe we never really lived down. It‚Äôs been a decade and we‚Äôre still dealing with the aftermath. (Subsequent releases have been better overall, but the amount of intentional breakage has been ratcheting up inexorably. It‚Äôs a pity since there are plenty of worthwhile improvements‚Ä¶ so neither sticking with an old perl nor upgrading to a newer one is a viable choice by default. Sigh.)
well that is a massive time saver, thanks for that gem
Structure with no problem in sight yet, great!
I'm totally aware it's been superseded, but it's been superseded by more complex things. the dbm thing is instant, and there's practically no syntax to remember. You use one command, and now you have a hash which is saved to disk.
Awesome. Always felt kind of vexed by there not being a good PP YAML parser. I do a lot of 'fatpacking' and relying on YAML::XS is difficult. Also drives me a little nuts that they're not interoperable.
 eval { may_die(); 1 } or print "boom"; Instead of eval { may_die() }; print "boom" if $@; 
People deliberately use this to give them persistent variables in subroutines; #!/usr/bin/perl use strict; use warnings; sub foo { my $foo if 0; return ++$foo; } print foo(), "\n" for 1 .. 4; This now gives a deprecation warning and can be replaced by `state`. #!/usr/bin/perl use strict; use warnings; use feature 'state'; sub foo { state $foo; return ++$foo; } print foo(), "\n" for 1 .. 4; 
 use strict; my @cars = qw( BMW Audi Volvo ); for ( my $i = 0; $i &lt; scalar @cars; $i++ ) { my $car = $cars[ $i ]; $car .= " drivers rule"; } print( join( ", ", @cars ) ); but that is completely different. Without trying it I would say that it prints out "BMW, Audi, Volvo" Now, I tried it, and that's what it prints. There is no aliasing of the member of @cars, it is copied out in a sub-scope, and nothing changes at the outer scope. 
Yet in both cases you use `my` to declare a new variable and you only alter this new variable. But in the first case even altering this new variable actually changes the list.
yes, yes, you're right on. 
Well, one thing is completely clear: you *definitely* know what you're talking about. 
Excepting very rare circumstances, you should probably use some sort of templating engine instead of a bunch of "print" statements. The generally-accepted one is Template Toolkit. The Perl module is here: https://metacpan.org/pod/Template Documentation for the template syntax itself is here: http://www.template-toolkit.org/ Good luck!
Thanks.. will surely go through it
Stylistically, this IMHO abuse of hash. I recommend not putting user data into its keys, but rather as the values, e.g. something like this: my @tests = ( { description =&gt; "1) Why does this print 5", func =&gt; sub { @_ }, }, .... ); Then iterate over the array with something like: for my $test (@tests) { print $test-&gt;{description}, ": ", $test-&gt;{func}-&gt;(5); } etc. You can then translate this to object oriented modeling by declaring a Test class or some kind, and then you have $test-&gt;description and $test-&gt;execute(5) or some such thing that calls the underlying function. Code could ultimately look something like this: my @tests = ( Test-&gt;new("Some description", sub { ... }), Test-&gt;new("Some other description", sub { ... }), );
Yes it is idiomatic and there are a lot of Perl idioms that I do like; however, I do not believe in sacrificing readability solely for the sake of being perlish. 
Yep, used or in the olden days
Depending upon your specific needs, you may want to consider HTML::Element. I use this when I have the exact opposite use case for templates, when I want everything to be in the perl source code. In my case, this when I want formatted output from a program that will exist on a file system and is not likely to be maintained on a web server. The MetaCPAN link is https://metacpan.org/pod/HTML::Element 
Thanks.. will look into it..
Along with being [deprecated](https://metacpan.org/pod/perldeprecation#Using-my(\)-in-false-conditional.) for a while now as you said, this functionality seems to have been accidental due to how `my` was implemented with both compile-time and run-time behavior. It's certainly not documented or tested anywhere.
To give some more context, this is an important construct for anyone using plain eval instead of Try::Tiny or Syntax::Keyword::Try. Never rely on the value of `$@` to determine if an error occurred; but if an error occurred, eval will always return undef, and you can rely on that.
Another option is https://metacpan.org/pod/Text::Xslate which has the benefit of escaping output for HTML by default (in Template::Toolkit you need to remember to use the | html filter on unescaped output).
This is a much better execution of my idea, thank you!
What I forget again and again and am amazed when seeing in a code is using `values` where keys aren't important, especially as lvalues. E.g. $_++ for values %count; or say sum(map $hash{$_}{count}, keys %hash); # versus say sum(map $_-&gt;{count}, values %hash); 
https://www.reddit.com/r/AssHatHackers/comments/1v90gh/swedish_chef/?st=J87PEXQ4&amp;sh=d8fdfbdb
Most of the modules in the Acme:: namespace count üòÅ
"0e0": used as a number, its value is 0, but used as a condition, its value is true.
Used as a condition how?
Perl one-liner to replace [text in a file](https://www.perturb.org/display/557_Perl_Replace_text_in_a_file.html): perl -pi -e "s/search/replace/g" /tmp/foo.txt
 if ("0e0") { # code that will run }
That's really weird... are there any real world use cases for this? Seems like odd behavior to me.
Something something [semipredicate problem](https://en.wikipedia.org/wiki/Semipredicate_problem).
**Semipredicate problem** In computer programming, a semipredicate problem occurs when a subroutine intended to return a useful value can fail, but the signalling of failure uses an otherwise valid return value. The problem is that the caller of the subroutine cannot tell what the result means in this case. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Really useful when using DBD to check for the existence of a record in a database. It returns 0E0 when zero records are returned, which it TRUE that the statement returned 0 results. 
If you are writing HTML files, presumably they are being served up through a web server to an internet audience. While Text::Xslate and others are good templating systems, the modern solution to serving web pages is to use a framework like Catalyst, Dancer or Mojolicious, or some others, rather than individual CGI scripts.
For efficient autoloaded functions, sometimes I will do things like sub AUTOLOAD { no strict 'refs'; my ($method) = $AUTOLOAD =~ /.*::(\w+)/; my $sub = sub { # do whatever }; *$AUTOLOAD = $sub; goto &amp;$AUTOLOAD; } AUTOLOAD only gets called the first time, after that it goes right to the anonymous function. It can save a huge amount of time on things that are frequently called, like autoloaded database accessor methods.
http://mojolicious.org/ http://mojolicious.org/perldoc/Mojolicious/Guides/Tutorial use Mojolicious::Lite; # Route leading to an action that renders a template get '/foo' =&gt; sub { my $c = shift; $c-&gt;stash(one =&gt; 23); $c-&gt;render(template =&gt; 'magic', two =&gt; 24); }; app-&gt;start; __DATA__ @@ magic.html.ep The magic numbers are &lt;%= $one %&gt; and &lt;%= $two %&gt;.
Wow! I'll be using this.
Using perl instead of sed is obscure?
I've always liked "0 but true" for its self-documenting nature. This one works too
Hard to know, because * that sentence makes no sense * it's easy to make a program do nothing
And remembering it is easy. I‚Äôll get pie while this file is substituting 
Random string my @chars = ('a'..'z', 'A'..'Z'); my $string; my $length = 25; $string .= $chars[rand @chars] for (1..$length); 
Probably just `exit;` after you've finished the output.
Thats probably it since there isn't an example in the pdf of what that would look like otherwise. I emailed the prof about the requirement but he hasn't responded since i sent it (thursday). I just want to make sure I completed it so I can work on the extra credit project.
Goatse operator
use either https://metacpan.org/pod/Acme::Bleach or if you dont want to install a module http://perlobfuscator.com/po.cgi 
Maybe ask for user input, the old press enter to continue prompt after the call to the editor line? They can just hit enter when you exit the editor? 
Interesting idea, but that's a lot of lines for something that doesn't do anything useful. * there's no checking on the %appstrs keys - easy to miss a typo, you already have one in the content for example * why create a main sub? if scope is a concern, just use a bare { ... } block * how do you test the content of this script? * how do you handle commandline parameters? Seems odd to leave those out but include the looks_like_number function * do you really copy and paste that logging code to every script? The Python and Java comments seem like strawman arguments - there are plenty of concise Python scripts out there, and I love the optimism of a sysadmin who chooses Java as a primary tool! Maybe a real script that uses this approach would be a better example than this template?
At work, a colleague promotes my $obj = Some::Moose::Class-&gt;new( user =&gt; $user_id, ( groups =&gt; $groups ) x !! @$groups, ) instead of @$groups ? ( groups =&gt; $groups ) : (), The problem is that unlike the ternary operator, it evaluates the "then" part even if the condition is false, so you shouldn't put there anything involving side effects.
For TT2, https://metacpan.org/pod/Template::AutoFilter provides automatic escaping. Worth understanding the limitations, though - cases like [% text | truncate(16) %] aren't filtered, IIRC.
I thought this was a fairly typical usage. 
 use warnings; use strict; Judging by the times I've been asked for perl help, those are the clever, mind-blowing tricks people aren't using to figure out where their coding errors are.
I like to use "map" to make a MDR (magic decoder ring). Comes in very handy when reading CSV. Use the map to build a lookup index for the header row. This way you can refer to everything after that by it's name instead of just an index number. Code: #!/bin/perl use Data::Dumper; my @data = qw(red blue green cake pie candy); my %mdr = (); my $i = 0; %{$mdr{'Name_to_Num'}} = map {$_, $i++} @data; # Creats a lookup index using the name to get the array position $i = 0; %{$mdr{'Num_to_Nama'}} = map {$i++, $_} @data; # Creats a lookup index using the array position to get the name print Dumper(\%mdr); __END__ Output Results: $VAR1 = { 'Name_to_Num' =&gt; { 'blue' =&gt; 1, 'cake' =&gt; 3, 'candy' =&gt; 5, 'green' =&gt; 2, 'pie' =&gt; 4, 'red' =&gt; 0 }, 'Num_to_Nama' =&gt; { '0' =&gt; 'red', '1' =&gt; 'blue', '2' =&gt; 'green', '3' =&gt; 'cake', '4' =&gt; 'pie', '5' =&gt; 'candy' } }; 
What black magic is that?! Amazing. 
I'd suggest contacting the authors to see if they want the help. If the author's in no hurry to make a new release, your time might be better spent elsewhere.
I see. So an unintuitive solution was chosen instead of the original unintuitive solution. I expected it to be the number of keys plus values, due to the analogy below: %h = qw(one 1 two 2); @a = %h; $s = @a; #4
Also reasonable, but another perspective is that the logical "size" of a hash is the number of keys it stores. I am just glad it's something useful (and faster) now.
Good point -- I'll update my post.
Of course, the usual disclaimer applies; if you hand-roll your CSV parsing, one day you'll choke on something you didn't expect, e.g. quoted values or multi-line rows - for instance: foo,"Hi, this is one field",42 If you use Text::CSV, (or Text::CSV::XS) then it's a battle-tested solution that won't fall over little gotchas like that, like your code would have. (If you control the generation as well as the consumer of the CSV then you can be more confident hand-rolling if you really need to, but even then I'd still tend to just use Text::CSV personally.) It can also handle the "give me the data as a hashref" cleanly for you, e.g. : open my $fh, "&lt;", $filename or die "Failed to open $filename - $!"; my $csv = Text::CSV-&gt;new; $csv-&gt;column_names($csv-&gt;getline($fh)); while (my $row = $csv-&gt;getline_hr($fh)) { # $row is a hashref whose keys are the column names } 
Granted. But most of the time, I find Text::CSV to be altogether too heavyweight for _most_ usage scenarios - sure, when you're handling quotes and whatnot it's absolutely my go-to. (Although sometimes that's `Text::Parsewords`). But _most_ times CSV is not that complicated. 
["A slightly more elegant solution is the `maybe` function."](http://p3rl.org/PerlX::Maybe)
The task was writing HTML files, not serving HTML resources.
&gt; rand $#chars should be: &gt; rand @chars Otherwise, you'll never get `Z`.
[removed]
Tip for people who own Github repos - if you add a "hacktoberfest" label to issues in your Github issue tracker, then they will appear on [the search list](https://github.com/search?q=label:hacktoberfest+state:open+type:issue). (Here's the [search list filtered for Perl projects](https://github.com/search?utf8=%E2%9C%93&amp;q=label%3Ahacktoberfest+state%3Aopen+type%3Aissue+%3Aperl&amp;type=).)
Even if you're using a framework, you'll still be using one of the templating engines to create the HTML pages.
Use *perltidy* to quickly solve the "missing right curly or square bracket, syntax error at EOF, execution aborted due to compilation errors". apt-get install perltidy
I like your constructive manner of suggesting your alternative. Cheers! 
agreed.
 my @foo = (' foo ', ' bar '); $_ = join(' ', split(' ', $_)) for @foo; Although it's kind of convoluted, this can be a faster way if you can tolerate (or actually want to) knock all whitespace down to a single space. The ' ' argument to split is a special case condition which automatically trims and flattens whitespace.
Fixed, thanks!
Same, for repos in **perl6** GitHub org: https://github.com/issues?utf8=%E2%9C%93&amp;q=is%3Aopen+is%3Aissue+user%3Aperl6+label%3AHacktoberfest
Amazing, I didn't understand that at all on first reading. Is that what it's like for "normal" people to talk to developers :)?
You can use EPL to create ordinary strings with [render_to_string](https://metacpan.org/pod/Mojolicious::Controller#render_to_string)
Every field has it's jargon. :) The real trick is seeing when your audience is getting confused, and to start translating the jargon into layman's terms. Basic translation of the above, MARC records are a format for storing bibliographic information on items (books, URLs, DVDs, anything really). Dublin Core is another standard for encoding bibliographic metadata. Cross-walking is translating from one format to the other. 
And we also own https://6lang.org, so what?
So people don't accidentally google this: https://metacpan.org/pod/perlsecret#Goatse
If you are not serving them, you would probably be better off using Mojo::Template directly, which is quite simple. use Mojo::Template; use File::Slurper 'write_text'; my $t = Mojo::Template-&gt;new(auto_escape =&gt; 1, vars =&gt; 1); my $rendered = $t-&gt;render(&lt;&lt;'EOT', {one =&gt; 23, two =&gt; 24}); The magic numbers are &lt;%= $one %&gt; and &lt;%= $two %&gt;. EOT # or my $rendered = $t-&gt;render_file($template_filename, {one =&gt; 23, two =&gt; 24}); write_text $filename, $rendered;
IMO, I think that you say that because you're more use to for loops. I prefer map personally.
Spoilsport.
You expect someone to know what sed is, eh? 
Is this true for all DBD drivers? Is there an advantage to using this over any of the other obvious checks?
A good reason not to buy that book!
It is insightful that you talk about GNU autotools. Because I personally consider both Perl and GNU autotools excellent pieces of software, which rarely break and often do the work they are supposed to do. I dont really know how come, in the end, the academia choose python and other fancy build tools which performs vary badly. I have a suspect, which is that those people have not time for their students, they secretly program Perl but teach python because it is easy, also there are those big corporation eager to redistribute their income among their Python employer. In any case, the mission critical part is written by real programmers, neither in Perl nor Python.
&gt; I think we can now safely say that Rakudo Perl 6 has the most complete Unicode support of any programming language in the world. You wish, but it isn't. Customised collation is easily possible in Perl 5, here I'm matching inter alia `∆è` as `E`. Despite all the effort put into the grant, you can't do that in Perl 6. use utf8; use Unicode::Collate qw(); my $az = '∆èski d√∂vr adlandƒ±rƒ±lan birinci d√∂vr XIII …ôsrd…ôn XVIII …ôsr…ô q…ôd…ôr '. 'olan d√∂vr√º, yeni adlandƒ±rƒ±la bil…ôn ikinci d√∂vr is…ô XVIII …ôsrd…ôn ya≈üadƒ±ƒüƒ±mƒ±z '. 'g√ºnl…ôr…ô q…ôd…ôr olan bir d√∂vr√º …ôhat…ô edir. ∆èski Az…ôrbaycan dilind…ô s√∂z '. 'birl…ô≈üm…ôl…ôrinin qurulu≈üu daha √ßox …ôr…ôb v…ô fars dill…ôrinin sintaktik '. 'modelind…ô olmu≈üdur: f…ôsli-g√ºl (g√ºl f…ôsli), t…ôrki-t…ôriqi-e≈üq (e≈üq t…ôriqinin '. '(yolunun) t…ôrki), daxili-…ôhli-kamal (kamal …ôhlin…ô daxil)‚Ä¶'; my $c = Unicode::Collate-&gt;new(normalization =&gt; undef, level =&gt; 1, entry =&gt; &lt;&lt;'ENTRY'); 0131;[.1CAD.0020.0002.0069] 0259;[.1C25.0020.0002.0065] 018F;[.1C25.0020.0008.0045] ENTRY for my $user_input (qw(adlandirilan Azerbaycan cox dovru ehate Eski gul qurulusu teriqinin yasadigimiz)) { if (my ($pos, $len) = $c-&gt;index($az, $user_input)) { printf "Found %s at position %d, length %d as %s\n", $user_input, $pos, $len, substr($az, $pos, $len); } else { print "Could not find $user_input.\n"; } } __END__ Found adlandirilan at position 10, length 12 as adlandƒ±rƒ±lan Found Azerbaycan at position 187, length 10 as Az…ôrbaycan Found cox at position 240, length 3 as √ßox Found dovru at position 70, length 5 as d√∂vr√º Found ehate at position 170, length 5 as …ôhat…ô Found Eski at position 0, length 4 as ∆èski Found gul at position 304, length 3 as g√ºl Found qurulusu at position 226, length 8 as qurulu≈üu Found teriqinin at position 343, length 9 as t…ôriqinin Found yasadigimiz at position 129, length 11 as ya≈üadƒ±ƒüƒ±mƒ±z 
Surely you'd never type `print $x . "\n"` rather than `print "$x\n"`?
Well, if you gonna use a module for this... üòùüòùüòù use Unicode::Collate:from&lt;Perl5&gt;; my $az = '∆èski d√∂vr adlandƒ±rƒ±lan birinci d√∂vr XIII …ôsrd…ôn XVIII …ôsr…ô q…ôd…ôr ' ~ 'olan d√∂vr√º, yeni adlandƒ±rƒ±la bil…ôn ikinci d√∂vr is…ô XVIII …ôsrd…ôn ya≈üadƒ±ƒüƒ±mƒ±z ' ~ 'g√ºnl…ôr…ô q…ôd…ôr olan bir d√∂vr√º …ôhat…ô edir. ∆èski Az…ôrbaycan dilind…ô s√∂z ' ~ 'birl…ô≈üm…ôl…ôrinin qurulu≈üu daha √ßox …ôr…ôb v…ô fars dill…ôrinin sintaktik ' ~ 'modelind…ô olmu≈üdur: f…ôsli-g√ºl (g√ºl f…ôsli), t…ôrki-t…ôriqi-e≈üq (e≈üq t…ôriqinin ' ~ '(yolunun) t…ôrki), daxili-…ôhli-kamal (kamal …ôhlin…ô daxil)‚Ä¶'; my $c = Unicode::Collate.new: :normalization(Str), :1level, :entry(q:to/üòù/); 0131;[.1CAD.0020.0002.0069] 0259;[.1C25.0020.0002.0065] 018F;[.1C25.0020.0008.0045] üòù for &lt;adlandirilan Azerbaycan cox dovru ehate Eski gul qurulusu teriqinin yasadigimiz&gt; { if $c.index($az, $^input).List -&gt; ($pos, $len) { printf "Found %s at position %d, length %d as %s\n", $input, $pos, $len, substr $az, $pos, $len } else { say "Could not find $input." } } =finish Found adlandirilan at position 10, length 12 as adlandƒ±rƒ±lan Found Azerbaycan at position 187, length 10 as Az…ôrbaycan Found cox at position 240, length 3 as √ßox Found dovru at position 70, length 5 as d√∂vr√º Found ehate at position 170, length 5 as …ôhat…ô Found Eski at position 0, length 4 as ∆èski Found gul at position 304, length 3 as g√ºl Found qurulusu at position 226, length 8 as qurulu≈üu Found teriqinin at position 343, length 9 as t…ôriqinin Found yasadigimiz at position 129, length 11 as ya≈üadƒ±ƒüƒ±mƒ±z 
A cyber security incident response and threat intelligence tracking system. https://github.com/sandialabs/scot . Mojolicious based.
*bleep, bloop, I am a bot.* You linked to a GitHub repository, here are some of my favourite commits: - [body size limiter for Vince Urias fuck ups](https://github.com/sandialabs/scot/commit/db1c93ca74401bf1d4d33903aa92d5077b6ff161) ***** ^[Source](https://github.com/mike-eason/angry-commits-reddit-bot) ^| ^[Issues](https://github.com/mike-eason/angry-commits-reddit-bot/issues)
When was the last time you upgraded sed or awk and one your scripts broke? Never, you say? Well that‚Äôs why they stick around in `/usr/bin`.
&gt; has never been an essential module You‚Äôre making an ahistorical statement with a straight face. How? &gt; It's not an essential module for the large number of people who use Perl for non-web work. And never has been ‚Äì true. &gt; And it's not an essential module for web work as there are far better alternatives. But it *used* to be ‚Äì a long time ago, but you are old enough to have seen it and well young enough to remember. [For everyone else reading this: I know, because we‚Äôve met. üòä] So I am baffled how you can make this claim. The one Perl talk I‚Äôve ever given, some 15 years and change ago at the local Uni, was‚Ä¶ a tutorial for making dynamic websites using CGI.pm, for people who know a little bit of programming but not Perl. It was very well attended. There was a window of time around the turn of the century when this was a quintessential marketable skill. You know that.
I'm assuming the opened file is delimited by tabs? 
So this tool is used to create 2D indexing of text files or CSV files? 
Good bot
Yes, it's not really useful for select statements but when executing statements that update/insert/delete it will tell you how many rows were affected or matched (details of this number may vary between drivers/databases). So it will still return true when no rows are affected, but it's numerically 0.
You are basically describing an event loop. Take a look at [IO::Async](https://metacpan.org/pod/IO::Async) (particularly the section on Timers).
 while ($whatever) { ... last; } is always going to be at most one iteration so the same as if ($whatever) { ... } That observation aside I'm not terribly sure what you're trying to do. You allusion to timers and such is making me think of co-operative multitasking / asynchrononous stuff Is that the sort of thing you're interested in here?
That's considerably more sophisticated than what I wrote. This seems very useful for network operations which are very asynchronous. I am honestly having a hard time understanding it.
I promise you that the nested "thread" loop runs more than once. :) I have working code that I can share that was a demonstration of threads turning on other threads. If you care to try it out I will post. To answer your question, I was trying to use perl to keep track of a particularly addictive game that was solely based on multiple timers. I have since dropped the game because it was a time sink, but I am still proud of all the basic scripts I wrote for it. 
Event loops take a bit of trial to understand, and I've found it helps to read the source code (such as for [IO::Async::Loop::Poll](https://metacpan.org/pod/IO::Async::Loop::Poll) or for [Mojo::Reactor::Poll](https://metacpan.org/pod/Mojo::Reactor::Poll) which is one backend for the similar event loop [Mojo::IOLoop](https://metacpan.org/pod/Mojo::IOLoop); you would not use these backends directly but it helps to get an idea of what event loops do). But it is very useful for anything where most of your program's time is spent waiting for timers or handles, even if only one or the other. The documentation for the individual timer notifier types may be helpful; I'm not entirely sure what you're going for here to suggest something more specific.
I debated not replying to this at all because I can‚Äôt think of how to do so without it sounding snarky, but it‚Äôs nevertheless a real answer that I don‚Äôt wish to leave entirely unsaid. With that disclaimer, the least snarky way I can think of putting it is this: It‚Äôs easy to be baffled about other people‚Äôs anxiety over losing relevance when you‚Äôre an advocate for a language that has none yet. Consider that that‚Äôs a form of insensitivity, though.
I can handle the snark :) I wasn't baffled. I was pointing out the obvious. The easiest way to lose relevance is to be miserable whiners who fret about losing relevance instead of posting something actually interesting.
I'm not going for anything anymore, I was interested in the concept. You definitely shared something very similar which is what I was looking for. Thanks. 
Thanks again for the recommendation. It took a while to test because I wanted to package the module up in an RPM, and that sent me down dependency hell as we have to have all dependencies in our repo to build modules we use. The log performance went from ~33 seconds to run down to 1 second. So I am quite happy! In case it helps (or helps anyone else), here is [our repo](https://www.alteeve.com/an-repo/el7/). The SRPM is [here](https://www.alteeve.com/an-repo/el7/SRPMS/perl-Log-Journald-0.20-1.el7.src.rpm). Here's [the code](https://github.com/digimer/anvil/blob/fa1145954327b5860a344995b27acbf9de9793ef/AN/Tools/Log.pm#L303) on how we used it. Thanks again!
Speaking of that: I never understood why you aren't allowed to combine the command line switches to `-pie`, whereas `-lane` is perfectly OK.
In this example, yes. But the concept is easy to use for other file types.
I think we're just talking semantics here. I don't believe that CGI.pm has ever been an essential module - because there have always been alternatives. Matt Wright, for example, never saw the need for it :-) I agree that for a long time i was a highly recommended module. But never essential.
Only because the main loop comes around again. The inner `while`s do nothing.
Then the ‚Äúinstead of‚Äù part makes no sense to me. Did the rest of the sub disappear? This was two threads about losing relevance, in amongst all the usual blog posts and articles and threads.
there are so many I doubt anyone has used them all :) these I used and they work: - HTML::Mason https://metacpan.org/release/HTML-Mason - probably the most powerful of them all but also the most complex - HTML::Template https://metacpan.org/pod/HTML::Template - simpler to understand and use but not as flexible - Text::XsLate https://metacpan.org/pod/Text::Xslate - probably the fastest if you want to generate a huge amount of text/html - Template Toolkit https://metacpan.org/pod/Template - the most hyped/popular and most likely to land you a job there is also Mason 2 ( https://metacpan.org/pod/Mason ), which is the second iteration of HTML::Mason, it works fine, I used it for personal stuff but not for commercial work
The Black Magic of Damian Conway.
I think it's because -i takes an optional argument which is the extension to use for a backup of the original before performing operations on the file. -ie says to make a backup of the file with an 'e' extension, swallowing the '-e' you meant to throw. 
Well that does get us into the semantic weeds‚Ä¶ by that definition, what module *is* essential? You can always do the job some other way. That definition basically leaves only Scalar::Util as essential‚Ä¶ plus I guess DBI as far as CPAN goes.
I really use this one in production everyday. Thank you very much.
Agreed, that's probably the reason.
Yeah, in general you cannot combine more than one switch that takes an argument and that one switch (and its argument) has to be at the end of the combination. However, you can have more than one combination, as in the pathological perl -pie -de "s/search/replace/g" /tmp/foo.txt
How are you doing the unit tests for PA? I help manage about 6 of them for different school districts and would really like something like this.
&gt; Only because the main loop comes around again. Yes, this is true. &gt; The inner whiles do nothing. No, this is not true. "Last" just exits the loop. It doesn't make the loop condition false. On the next pass, the inner while thread loop's condition is true, so the loop runs one iteration. 
I'm not sure exactly what you are looking for but here is a simple while loop that sleeps until an alarm expires: #!/usr/bin/env perl use Modern::Perl; use autodie; # sorted list of alarms my @alarm = sort {$a &lt;=&gt; $b} map { time() + int(rand(30))} 0..4; while(@alarm) { my $now = time(); my $when = $alarm[0]; if ($when &gt; $now) { say "sleeping ". ($when - $now). " till $when"; sleep $when - $now; } else { say "alarm expired \$now = $now \$when = $when"; shift @alarm; } } 
Right, which means that you could change "while" to "if", remove the "last", and have something far less absurd that does exactly the same thing.
Aside from the question of using threads or not, and whether there's an existing module that does what you're looking for (let's assume that you do need to write this), the code just got to the point at which procedural code will start to confuse me enough that I would create some sort of Timer object class, in order to keep from repeating myself and confusing myself. Basically, my rational for that is: I'm going to have multiple occurences (the objects) that need to do the same thing (the class). And speaking of keeping myself from getting confused, I tend to use Moose for this sort of thing now (yes, there are other Moose-derived classes that act the same way, but I've stuck with Moose the whole time). Class: package Timer; use Time::HiRes qw( gettimeofday ); use Moose; has start_time =&gt; (is =&gt; 'rw'); has end_time =&gt; (is =&gt; 'rw', lazy =&gt; 1, builder =&gt; '_build_end_time'); has elapsed_time =&gt; (is =&gt; 'rw', lazy =&gt; 1, builder =&gt; '_build_elapsed_time'); has precision =&gt; (is =&gt; 'rw', isa =&gt; 'Num', default =&gt; sub { 6 }); sub BUILD { my $this = shift; $this-&gt;start; } sub start { my $this = shift; $this-&gt;start_time( gettimeofday ); } sub _build_elapsed_time { my $this = shift; my $format = '%.' . $this-&gt;precision . 'f'; return sprintf($format, $this-&gt;end_time); } sub _build_end_time { my $this = shift; return gettimeofday - $this-&gt;start_time; } 1; Code that uses this class: #!/usr/bin/perl -w use strict; use Timer; use Getopt::Long; # this defaults the precision, but allows for # a command-line argument (--precision) to override it # Two command-line arguments are supported, with these defaults: # --precision 6 # --timers 10 my $precision = 6; my $timers = 10; GetOptions( "precision=i" =&gt; \$precision, "timers=i" =&gt; \$timers, ); # just a place to store my timers, so I can stop them all later... my @timers; # For every timer we need, start them up # (the BUILD method in the Timer class starts the timer automatically) foreach(1..$timers) { my $timer = Timer-&gt;new( precision =&gt; $precision ); push(@timers, $timer); } # for each timer in the array, stop it and deliver the elapsed time for my $timer(@timers) { print $timer-&gt;elapsed_time . "\n"; } Note that this is an _extremely simple_ implementation of asynchronous timers. It occurs to me now that my `elapsed_time` method should be able to give you the time that has elapsed _without stopping_ the timer, optionally. As is usually the case, there are lots of improvements that could be made. But my reason for posting this was to demonstrate that you don't necessarily have to use threads to be able to do something asynchronously. In this case, you just need a convenient place to store your start time for each time, and "a convenient place to store stuff" is one of my two favorite things about objects (the other one being "a place to put all your abstraction code").
I'm not an expert on unicode or collation by any stretch. I live in a wonderland of ASCII only, so I never really deal with unicode, except when playing around. For this reason, I thought about how I would solve this using my limited knowledge and came up with some possible solutions. Most likely there are cases where customising collation is probably better, but I'm not even going to talk about collation, because I know little-to-nothing about it. This is Perl, so Regex can probably help here. Regexes can already be asked to ignore marks... &gt; so 'd√∂vr√º' ~~ m:m/dovru/ True So now I just have to deal with your custom substitutions. The simplest way I thought of is to translate the search string. my $as = $az.trans(&lt;∆è …ô ƒ±&gt; =&gt; &lt;E e i&gt;); for &lt;adlandirilan Azerbaycan cox dovru ehate Eski gul qurulusu teriqinin yasadigimiz&gt; -&gt; $query { if $as ~~ m:m/$query/ { say "Found %s at position %d, length %d as %s".sprintf( $query, $/.from, $/.chars, $az.substr($/.from, $/.chars) ) } else { say "Could not find $query"; } } This is a kind of bait and switch. I _bait_ my search with the translated string, but when printing the result I _switch_ in the original string. A little dishonest, but it works. My second solution is a little more honest. For each search query, create a Regex pattern where the customised letter is a character class, ie. `ehate` becomes `&lt;[e…ô]&gt;hat&lt;[e…ô]&gt;`. Then I can search the original `$az` string and it works. my %trans = ( 'E' =&gt; '∆è', 'e' =&gt; '…ô', 'i' =&gt; 'ƒ±', ); for &lt;adlandirilan Azerbaycan cox dovru ehate Eski gul qurulusu teriqinin yasadigimiz&gt; -&gt; $query { my $pattern = $query.subst(/&lt;[Eei]&gt;/, { '&lt;[%s%s]&gt;'.sprintf( $/, %trans{$/} ) }, :g); if $az ~~ m:m/&lt;$pattern&gt;/ { say "Found %s at position %d, length %d as %s".sprintf( $query, $/.from, $/.chars, $/ ) } # else { ... } } This technique could also be expanded to allow multiple possible substitutions for each character. I realise that I'm using a Regex match instead of an `index` op, so there's probably some performance considerations. Under the NQP hood there is an `indexim` (index-ignoremark) op that hopefully gets exposed directly in Perl6, but for now I can pull in some NQP and use it in my bait and switch example for a speed boost use nqp; for &lt;adlandirilan Azerbaycan cox dovru ehate Eski gul qurulusu teriqinin yasadigimiz&gt; -&gt; $query { if ( my $pos = nqp::indexim($as, $query, 0) ) &gt;= 0 { say "Found %s at position %d, length %d as %s".sprintf( $query, $pos, $query.chars, $az.substr($pos, $query.chars) ) } # else { ... } } I'm not claiming any of these is a better solution that yours... I'm just playing around here. Sorry for blog posting in the comments. Have a nice day, everyone.
Use -p instead of -n
It's now just outputting empty lines
 cat report.txt | perl -ne "print if s/(.+)n\/a.+/\1/;" although in my computer using -w suggests that \1 is better written as $1, that probably does not apply to command line where $ means something else. without -w you just don't get that warning 
Sure - the modules I‚Äôve written are Device::PaloAlto::Firewall and Device::PaloAlto::Firewall::Test These are used by a test template (that you run with ‚Äòprove‚Äô) https://github.com/gregfoletta/network-test-templates
Use single quotes around your perl expression. Otherwise the shell will interpret the `$1` itself, probably replacing it with the empty string. Also switch to either `-p` (as /u/ltriant said) or use `print if` as /u/saiftynet suggested. perl -wpe 's/(.+)n\/a.+/$1/' &lt; report.txt Using a backslash instead of dollar sign will work instead in this particular case, but not everywhere, since in some circumstances the shell will also eat backslashes if they're not single-quoted (and sometimes you might need a Perl variable that isn't $1 $2 etc). 
 &lt;report.txt perl -ne 'if (/(.+)n\/a.+/) { print $1 . "\n" }' may also work. Got this from [StackExchange](https://stackoverflow.com/questions/5098884/only-print-matching-lines-in-perl-from-the-command-line) 
You should be able to do `coll` to do the comparison with collation, setting that you don't mind if diacritics are there or not. I think there is currently a Rakudo bug preventing this. At least [the documented behavior](https://docs.perl6.org/language/experimental#index-entry-%24%2ACOLLATION-%24%2ACOLLATION) doesn't work for me locally: use experimental :collation; $*COLLATION.set(:quaternary(False), :tertiary(False)); say 'a' coll 'A'; # Same I don't get the Same coming out of that, I get More.
Ahh, ok... Bisectable says [this commit](https://github.com/rakudo/rakudo/commit/9b42484a5d0ca6b5d340620cc5d8dd88e2eb331f) broke it.
try cat report.txt | perl -pe 's\#\^\(.\*\)n/a.\*\#$1\#'
`\1` should definitely be replaced by `$1`. Removing `-w` is not a good strategy for getting rid of warnings :-) You eliminate the warning by either escaping the `$` so the shell doesn't see it. cat report.txt | perl -ne "print if s/(.+)n\/a.+/\$1/;" Or, more simply, by using single quotes to hide the variable from the shell. cat report.txt | perl -ne 'print if s/(.+)n\/a.+/$1/;'
Unicode::Collate ships with Perl5. Let me know when something ships with Perl6 that does this, something that *isnt* "Wrap Perl5 which obviously can do this, to paper over Perl6 not being able to"
I think Zoffix was being fairly tongue in cheek there given the literal tongue in cheek emoji. Plus that would be the current version of Perl 6, see my post above. You have to enable it with an experimental pragma. The issue is it's not working as expected at the moment from what I can tell. Id register you're interest if you want it fixed/implemented though. It's obviously super close to anyones expectations of this functionality. Quite possibly with better perf too given the way unicode strings are dealt with inside MoarVM. I think "paper over" is a bit of a limited view of what Perl 6 is about, one of the major features is representational polymorphism so that things can easily be borrowed from other languages and sources. Being able to use existing stuff from C/CPP, Perl 5 and Python all in a single Perl 6 program where everything looks like a single language feels like a good thing, rather than a quick fix. I agree unicode shouldn't be something that Perl 6 needs to lean on 5 for.
Thank you for the feedback , Damyan Ivanov is the hero for this release 
In case it isn't clear.... &gt; &lt;TimToady&gt; I could go for something more like psix, "where the p is silent if you want it to be" :) Larry Wall was doing a P.G. Wodehouse reference: https://en.wikipedia.org/wiki/Psmith, http://www.gutenberg.org/ebooks/10586 
**Psmith** Rupert Psmith (or Ronald Eustace Psmith, as he is called in the last of the four books in which he appears) is a recurring fictional character in several novels by British comic writer P. G. Wodehouse, being one of Wodehouse's best-loved characters. The P in his surname is silent ("as in pshrimp" in his own words) and was added by himself, in order to distinguish him from other Smiths. A member of the Drones Club, this monocle-sporting Old Etonian is something of a dandy, a fluent and witty speaker, and has a remarkable ability to pass through the most amazing adventures unruffled. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
I was just thinking recently that if I did a talk comparing perl5 and perl6 I'd end up talking about "six" as opposed to "five". I think some variation of "six" is going to be the winner, with the lead going to "p6" with the silent "p", because it's got Larry behind it. Admittedly "SixLang" seems more trendy, and is likely to make some people wonder if it's something like "GoLang". Unfortunately, seizing the attention of the "low-information" technical expert is what this game is all about. (I keep having to explain "perl6 is really a new language" to bright people who you'd think would know better.)
Thanks. Didn't even realize that :)
You may need to backslash the `$` character in *double* quotes as the BASH shell itself could be substituting that variable. Try: cat report.txt | perl -w -pe "s/(.+)n\/a.+/\$1/" OR single quotes without escaping the `$` character: cat report.txt | perl -w -pe 's/(.+)n\/a.+/$1/'
`$1` doesn't mean something else on the command line; it means something to the shell itself, because the argument is double-quoted rather than single-quoted. It has already been interpreted before perl can read it in this case. `\1` is still wrong; that's for use within the same regex, not in the replacement string. It only works at all because that's how it works in sed. See https://metacpan.org/pod/perlre#Warning-on-%5C1-Instead-of-$1
Out of those I'd just recommend staying away from HTML::Template. As you mentioned it's not very flexible, and it has fundamental design issues. Another option (as I demonstrated in another comment) is [Mojo::Template](https://metacpan.org/pod/Mojo::Template). There are of course many more but this covers most of the ones designed for HTML.
Perl is great for parsing network configs and logs. It‚Äôs saved me on many projects as a network engineer. I just recently used a combo of batch and perl to pull performance data out of 100‚Äôs of wireshark traces (116 x 20MByte pcap files). I basically took the text out from tshark and capinfos and parsed it into CSV or HTML.
Could this be modified to act upon the expiration of any one of the alarms? There is a lot of notation in here that I'm not familiar with. I need to start using map more often. What does the "&lt;=&gt;" operator do? Ok, actually not a lot of strange code here. I thought \$...=... was some kind of deferencing thing at first....duh.
I've never heard of moose before. what's the difference between package and use? In the class, you're using shift not in the array operation sense...what is it doing? &gt; has end_time =&gt; (is =&gt; 'rw', lazy =&gt; 1, builder =&gt; '_build_end_time'); Is this specific to moose? this is defining parameters I'm guessing. For some reason I thought perl didn't allow variables to start with underscores but I may be mixing languages. &gt; default =&gt; sub { 6 }); What is this doing? &gt; GetOptions( &gt; "precision=i" =&gt; \$precision, &gt; "timers=i" =&gt; \$timers, &gt; ); GetOptions is part of "use Getopt::Long;" right? Why didn't you use @ARGV? &gt; extremely simple implementation of asynchronous timers. bro dont even start. This is level 10+ stuff and I'm still on level 3.
have a nice day
Moose is the big daddy of object systems in perl. Start here: https://metacpan.org/pod/Moose::Manual 'package' is declaring what namespace the following code is under. So basically you're creating the 'Timer' package in this case, which you can 'use' from elsewhere. 'has' is what you use to define attributes for a class in Moose (as well as similar object systems like Moo and Mojo::Base). Underscores are generally fine in variables, but in this case `_build_end_time` is the name of a subroutine which that attribute will use if the attribute is accessed but doesn't have a value yet. `default` is another way of specifying this subroutine but inline. GetOptions is indeed a function from Getopt::Long. It uses `@ARGV` automatically. If you want to use it on a different array, you'd use GetOptionsFromArray.
Thanks for the explanation. Every day's a learning day :)
Suggest reverse chronological order so that most recent are at the top. At first glance it looks like you're not maintaining it. Also suggest three pages - in progress, succeeded and failed.
Well, by "extremely simple" I didn't mean that it's beginner stuff. I meant that it's just at the point where you get it working, and then there's always more stuff that can be added :) Anyway, to answer your questions: Those `has` declarations at the beginning are from Moose, you're right. [Moose](https://metacpan.org/pod/distribution/Moose/lib/Moose/Manual.pod) is an object framework for Perl. You can do object-oriented Perl without it, but Moose makes a lot of things easier, and it's all I ever use for objects anymore, unless I need something brutally fast. You asked about my usage of [shift](https://perldoc.perl.org/functions/shift.html) without an argument. It defaults to `@_`, which is an array that is very often present, and which contains the variables passed into (in this case) the subroutine (which, in an [object-oriented](https://perldoc.perl.org/perlootut.html) context, I'll usually call "the method"). When you call a method on an object, the first item in `@_`, which will always be the object itself, so it's very common to see `my $this = shift` at top top of a method. You asked about the difference between `use` and `package`. You use `package` to create a module or a class, and you use `use` to use that module or class in some other code. [More info](https://perldoc.perl.org/functions/package.html). The question about starting variables with underscores. That `_build_end_time` thing you noticed is the name of a subroutine, not a variable. That line says that `end_time` is a property of the object, which will not be built until you call it (`lazy =&gt; 1`), but when it's called, it will be built by calling the `_build_end_time` -- which you will notice returns a value suitable for `end_time`. You asked about the `default` parameter. That's a Moose thing. You can specify a default value for attribute, by giving it an anonymous subroutine (in this case) or a code reference. Yes, I use Getopt::Long for argument processing, even though a lot of the Perl world has probably moved on to something better (I saw mention of something with "App" in its name recently, which looked like it might be useful). I definitely don't bother dealing with arguments at the @ARGV level. Getopt::Long provides a lot more flexibility. You can have arguments that take a string or a number, the user doesn't always have to spell the argument out completely, you can have boolean arguments, the argument syntax is what unix people are used to, etc.
Good answers. I didn't see this before writing my reply.
The example sleeps until the next alarm expires by waiting for them in time order. If you need to add new alarms in the middle of the run then you can append them and re-sort. The line commented "# sorted list of alarms" is a bit dense. It generates an array of five random "alarms" within the next 30 seconds. The alarms expiration time is represented in "unix seconds". Then it sorts them in numerical order. It is easiest to understand that line by taking it from the right. Sort takes an optional comparison routine as its first argument. "&lt;=&gt;" is the numerical comparison operator. It returns -1, 0, +1 based on the left and right arguments. Read about it here: http://perldoc.perl.org/perlop.html#Equality-Operators When things get more complex than this then it is worth considering one of the event loop modules.
There are [tutorials](http://perl-tutorial.org/) in the sidebar. All I can suggest without a more specific question is to start writing code and running it until it does what you want. That's what perl does best.
Gracias.
just discovered the MXNet api for Perl, amazing, a great job for the perl community.
damn, that‚Äôs making me sad :(
Dealing with alarms and timers is a difficult task. Even one timer has hidden facets that can mess you up quickly. That's because they use [`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html). If you use [`perldoc -f sleep`](http://perldoc.perl.org/functions/sleep.html) for your timer, `sleep` will be interrupted by any signal, not just the timer. I recommend you search [CPAN](https://metacpan.org/) for a module. Since I don't suggest modules that I don't use, you have to search on your own. Try "alarm" or "timer" in your search.
Yes, I'm a fan of Mason myself-- I can see why someone who doesn't like perl would prefer Template::Toolkit, but Mason lets you flex your perl-muscles much more easily. (There's a apparently a problem with programmers that put stuff in their Mason templates that really should be in a module of it's own. My solution to that is to say "don't do that".) 
Using DateTime / DateTime::Duration, once you get a duration, you can get the number of months out of it: my $months = ($duration-&gt;in_units( 'months' ))[0]; 
Here is what I coded: &gt;print "You have $days_until_retirement days until retirement.\n"; &gt;my $months_remaining = DateTime::Duration-&gt;new(days =&gt; $days_until_retirement ); &gt; &gt;my @mon_day = $months_remaining-&gt;in_units( 'months', 'days' ); &gt; &gt;print "$mon_day[0] months, $mon_day[1] days\n"; Here is the result. &gt;You have 5641 days until retirement. &gt;0 months, 5641 days
Kinda brute force, but sometimes you need a hammer. ($thisday, $thismonth ) = ( $2, $1 ) if $today =~ /\d\d\d\d-(\d\d)-(\d\d)/; ($thatday, $thatmonth ) = ( $2, $1 ) if $retire =~ /\d\d\d\d-(\d\d)-(\d\d)/; $fullmonths = $thatmonth - $thismonth -2; $payperiods = $fullmonths * 2; $payperiods += 2; # we're past the first of this month, and we'll be past the first of that month when we retire $payperiods++ if $retireday &gt; 14; $payperiods++ if $today &gt; 14 
The number of months depends on the actual calendar dates, since a "calendar month" isn't a specific number of days. So first get DateTime objects for now and the future date: my $now = DateTime-&gt;now; my $retirement = $now-&gt;clone-&gt;add(days =&gt; $days); Then you can get a DateTime::Duration object with a number of calendar months between the two dates: my $diff = $retirement-&gt;subtract_datetime($now); my @mon_day = $duration-&gt;in_units( 'months', 'days' );
Ha, was experimenting with DBD and DBI last week that's why this caught my attention
 use 5.024; use strictures; use DateTime qw(); my $current = DateTime-&gt;new(year =&gt; 2017, month =&gt; 10, day =&gt; 9); # https://en.wikiquote.org/wiki/Sid_Meier's_Alpha_Centauri#Even_five_hundred_would_be_pretty_nice. my $retirement = DateTime-&gt;new(year =&gt; 2517, month =&gt; 10, day =&gt; 9); my $paydays = 0; while ($current &lt; $retirement) { $paydays++ if 1 == $current-&gt;day or 15 == $current-&gt;day; $current-&gt;add(days =&gt; 1); } say $paydays; The amount of pay periods is the amount of pay days, possibly off by one or two, depending how your system deals with partial periods.
[Crossposted to PerlMonks](http://www.perlmonks.org/?node_id=1200953).
 &gt; if ($yn == "y"){ I haven't had time to study this in detail, but this is wrong. You want a string comparison here. if ($yn eq "y"){
You're right, it should be eq, but for whatever reason it works like it is. But I'll edit to eq. Thanks. 
I would normally suggest just leave the `use` statements, and let the script bomb out. It's a bad habit to 'teach' users to automatically download code of the internet to run. I mean, you know and I know that CPAN is _generally_ ok, but I'm not really sure it's a good idea to assume that, and auto-install. 
When you ask Perl to compare strings numerically, it will try to convert the strings to numbers. If your strings begin with numbers, that works fine: $ perl -E'say "1 foo" == "2 bar"' $ perl -E'say "1 foo" == "1 bar"' 1 But any string that doesn't start with a number will be converted to zero. And that will give some surprising results. $ perl -E'say "y" == "y"' 1 $ perl -E'say "n" == "y"' 1 So when you say "it works like it is", I suspect you haven't tested it very thoroughly :-)
&gt;&gt;I suspect you haven't tested it very thoroughly Yep, that would be the reason it "works every time." Thanks so much for the insight and clear explanation. I'm always amazed when I find neato new way to screw up my code. 
&gt; Because I wanted to avoid the hassle of having to remember which packages I had installed on each of my machines, and to avoid the hassle of having to explain to these other people how CPAN works You know the one about good intentions and the path to hell‚Ä¶ As a Perl developer with my OS packager hat and my sysadmin hat on, I want to dissuade you from your idea. It's already broken for people who don't have libxml headers installed, and they shouldn't have to, because they're not developers. It's broken for people with old versions of CPAN.pm because those do not offer to install into a user-writable directory. It's conceptually broken for users who want to deploy your script as a system service: very often these run under accounts which lack the permission to install stuff. It does not save any hassle if the CPAN client errors out for some reason and the end user has no idea how to fix it. Essentially, you distribute software, but do it the wrong way: 1. CPAN and CPAN clients target developers, not end users 2. your script is potentially incomplete software and not ready to use. You need to learn about packaging for your end users' platforms, and then distribute your software as a package. That's the teflon-tape correct solution to the problems above. Tell me the platforms/Perl distros of your users and I can amend the list of links and perhaps go into further detail. * https://pkg-perl.alioth.debian.org/ * https://en.opensuse.org/openSUSE:Packaging_Perl * http://p3rl.org/make_ppm * https://chocolatey.org/docs/create-packages Packaging is an order of magnitude less difficult than programming, semi-automatic most of the time and on popular platforms your dependencies are already packaged.
I knew intuitively that there was something wrong with this, turns out there were many things wrong. I'm always trying to learn, so thanks for pointing out some of the many problems. To be honest, I've never considered packaging, and don't really know much about it--like I said, I wouldn't really consider myself a "programmer". I'm on Mint 18.1 and most of my users will be on either an Ubuntu derivative as well, or possibly OSX. 
First convert your scripts into a CPAN-ready tarballs with a main .pm file and record your direct depencies in the meta file. You are not required to actually upload those tarballs to CPAN, just conform to the format. Help: https://lists.perl.org/list/module-authors.html http://perlmonks.org/?node=Seekers%20of%20Perl%20Wisdom https://stackoverflow.com/questions/tagged/perl+packaging Also see [examples in the App::*](http://search.cpan.org/search?mode=module;query=App%3A%3A) namespace. For Ubuntu: install `pkg-perl-tools` and use `dh-make-perl` to create .deb packages out of tarballs. For Mint, ask the Mint developers where all that software is, because I can't see it. I suspect it isn't necessary and Ubuntu .deb packages can be used as is. OS X: I know nearly nothing, go find an expert. Starting points: https://brew.sh/ http://finkproject.org/ http://zero-install.sf.net/packagers.html 
The for loop itself looks correct, though very C-like. However, you are never actually reading from the file. This line looks like it's supposed to: chomp( my @lines = $fhin ); But that makes `@lines` an array holding a single element, the file handle for the input file. You want the `&lt;&gt;` operator, like `&lt;$fhin&gt;`, to actual reading the lines from the file. Once you get that fixed, you can improve that loop. Instead of iterating over the indices, you can iterate over the elements directly: for my $line (@lines) { if ($line &gt; 0) { ... } # and so on }
How is this? #!/usr/bin/perl use strict; use warnings; print "Enter a file name: "; chomp( my $infile = &lt;STDIN&gt; ); open( my $fhin, "&lt;", $infile ) or die "Can't open input file '$infile':$!\n"; chomp( my @lines = &lt;$fhin&gt; ); close( $fhin ); my $ctr_pos = 62; my $ctr_neg = 42; my $ctr_zero = 32; for my $lines (@lines) { if ($lines &gt; 0 ) { $ctr_pos++ ; } elsif ($lines &lt; 0 ) { $ctr_neg++ ; } else { $ctr_zero++ ; } } printf ( "Freq(Z+):%7d \n", $ctr_pos ); printf ( "Freq(Z-):%7d \n", $ctr_neg ); printf ( "Freq(0):%8d \n", $ctr_zero ); printf ( "Total:%10d ", $ctr_pos + $ctr_neg + $ctr_zero ); exit;
That was a pretty damn good discussion!
I haven't run your program. I see some minor problems. Take the file name as a command-line argument rather than reading from stdin. This makes it much easier to automate your program. `chomp` does not work with files with DOS/Windows line endings. Remove [`\R`](http://p3rl.org/perlrebackslash#%5CR) instead. Do not slurp the whole file into an array if don't need it all at once. You will run into trouble if the file is larger than the computer's memory. You can iterate over the file line-by-line instead, that always works and is memory-efficient. [`autodie`](http://p3rl.org/autodie) makes it easier to check your system calls. You don't need to write a check manually and you can't forget to check. ‚Ä¶ use autodie qw(:all); use Getopt::Long qw(GetOptions); ‚Ä¶ my %opt; GetOptions(\%opt, 'infile=s'); my $ctr ‚Ä¶ open my $fhin, '&lt;', $opt{infile}; while (my $line = readline $fhin) { $line =~ s/\R$//; if ‚Ä¶ } printf ‚Ä¶ Next, add some [documentation](http://p3rl.org/Pod::Usage#Recommended-Use) and [on-line help](http://p3rl.org/Pod::Usage::CommandLine).
One other minor point: the `use` lines will happen before the package installation block. You'd need to wrap that initial code in a `BEGIN { ... }` block for that to work as intended. In addition to the other comments, one other link that might be of use: https://metacpan.org/pod/distribution/Module-CPANfile/lib/cpanfile.pod if you happen to have `cpanm` or `cpm` around, those can install dependencies through a single `cpanm --installdeps .` command. I find cpanfile is much easier to work with than META files, your mileage may vary! 
I don't understand what this means: is it that now Perl6 modules can be hosted on the same place as traditional CPAN and than `cpan` &amp; friends will continue to get Perl5 packages while zef will get Perl6 ones? or maybe both? In other words: are they sharing the same data mirrors?
&gt; In other words: are they sharing the same data mirrors? Yes, they share mirrors. Perl6 dists live in `Perl6/` directory of PAUSE users and Perl 5 tooling was trained to ignore it, while Perl 6 tooling ignores Perl 5 dists. 
Oh, that's great! Yesterday I was browsing a CPAN mirror but I only found files more than one year old, hence my confusion. I guess that in a few moths the number of distributions there will grow much more.
I've used ripgrep, and it's pretty great.
Your attachment filename is deemed "evil" because it has round brackets in it. So it will create its own filename for you, by trimming the filename to 14 characters long and determining the file extension in its own way, as you have observed. There's more to it than that, but that's the path your MIME part is taking. You can find all this code in [MIME::Parser::Filer](https://metacpan.org/pod/MIME%3A%3AParser%3A%3AFiler), and is documented for the evil_filename function. A couple of solutions might be: * Subclass MIME::Parser::Filer and write your own evil_filename() function. * Find the actual MIME::Entity belonging to your MIME part, get the filename from the Content-Disposition header and output the file yourself.
AAAAAaaaaaahhhh perfect. I know how to proceed now. Brilliant.
&gt; chomp does not work with files with DOS/Windows line endings. This isn't entirely true. chomp removes `\n`, but `\n` isn't a specific character. The `:clrf:` layer, default on Windows platforms, translates the windows `\r\n` into `\n` when reading. The only issue occurs when you try to use a windows-created file on a non-windows platform, which is something you should probably fix separately. 
Honestly I just use 'git grep' and 'grep -r PATTERN .' most times. Before I discovered git grep I used ack a lot more. It has sensible defaults and works. I honestly don't spend a whole lot of time worrying about how fast my file searches are.
Ack just works, great for searching large code bases.
Crossposted to [PerlMonk](http://www.perlmonks.org/?node_id=1201120).
&gt; The only issue occurs when you try to use a windows-created file on a non-windows platform That's still a huge "only". &gt; you should probably fix in the file itself That's inconvenient if the file is under version control. Just accept that a number of Perl built-ins suck balls‚Ä° and use the work-around available within the language instead of external tooling. `s/\R$//` works always and unlike chomp requires exactly no deliberation or extra work. &gt; it's simpler just to read it from the first element of @ARGV That's bad advice. * You can't reorder positional arguments. * You get no synergy with Pod::Usage * GetOptions has some rudimentary type checking ‚Ä° One day I am going to write a Perl-Critic policy against chomp, unlink, rename, open, flock, sprintf, chown and all that rubbish that only works sometimes or as a user expects but the caveats are completely solved by modules.
I had a twitchy knee when I read the part about ripgrep being the "most Unicode-compliant", but surprisingly it turns out he's right. The surprise is that I didn't notice until know that ack is really bad at Unicode grepping. ‚Ä∫ # testing character properties ‚Ä∫ echo ‚Ç¨ | ack '\p{Sc}' ; echo $? 1 ‚Ä∫ echo ‚Ç¨ | rg '\p{Sc}' ; echo $? ‚Ç¨ 0 ‚Ä∫ # testing Perl named characters ‚Ä∫ echo üçª | ack '\N{CLINKING BEER MUGS}' ; echo $? 1 
I would love to see this as an enhancement to [App::HTTPThis](https://metacpan.org/release/App-HTTPThis).
Thanks for this.
I would use a while loop rather than load the entire file into an array... use strict; use warnings; my $ctr_pos = 62; my $ctr_neg = 42; my $ctr_zero = 32; print "Enter a file name: "; chomp( my $infile = &lt;STDIN&gt; ); if (open(my $fh, '&lt;:encoding(UTF-8)', $infile)) { while (my $line = &lt;$fh&gt;) { chomp $line; if ($line &gt; 0) {$ctr_pos++ ; } elsif ($line &lt; 0 ) { $ctr_neg++ ;} else {$ctr_zero++ ;} } } else { warn "Could not open file '$infile' $!"; } printf ( "Freq(Z+):%7d \n", $ctr_pos ); printf ( "Freq(Z-):%7d \n", $ctr_neg ); printf ( "Freq(0):%8d \n", $ctr_zero ); printf ( "Total:%10d ", $ctr_pos + $ctr_neg + $ctr_zero ); exit; 
It's only hard if you need local employees, as (understandably) people are rather reluctant to uproot their lives and those of their families to move to a new city. If you can handle remote workers, there are lots of Perl programmers available (including yours truly).
Not builtin, but there is a [SimpleHTTPServer](https://metacpan.org/pod/App::SimpleHTTPServer) on CPAN, leveraging Mojolicious. It currently only supports serving on HTTP, but it would be simple to enhance to have the ability to pass a custom listen option to the daemon. Any Mojolicious daemon can serve HTTPS by passing the appropriate [listen option](https://metacpan.org/pod/Mojolicious::Command::daemon#SYNOPSIS) with https, a cert, and a key, as long as IO::Socket::SSL is installed.
My assumption would be that ack does not decode its input from UTF-8, and then encode the output back to UTF-8; this would be required for them to be matchable as unicode characters. This gets tricky once you think about the possibility of searching files that aren't UTF-8 encoded.
&gt; You can't reorder positional arguments. Doesn't matter in this simple case with one required argument. In my opinion, this is a case of optimizing for possible future requirements that makes the user experience more complicated unnecessarily. &gt; You get no synergy with Pod::Usage I don't see how this is relevant. Pod::Usage just prints out whole sections of pod when invoked. &gt; GetOptions has some rudimentary type checking Since this is a string, that doesn't really matter here either. 
Subs can modify variables as well.
&gt; My assumption would be that ack does not decode its input from UTF-8, and then encode the output back to UTF-8; this would be required for the contents to be matchable as unicode characters. Indeed, this is not necessary! ripgrep's regex engine is based on finite automata, and it actually embeds UTF-8 decoding into the regex matcher itself. That means it doesn't need an explicit UTF-8 decode/encode step, which in turn means that it gets non-UTF-8 matching for free. That is, you can run ripgrep on latin1 text and it will still work fine, insomuch as it will only match the ASCII subset of latin1. You can see this using the regex-debug tool to compile regexes. Compiling the regex `.` into a Unicode codepoint machine works similarly to your assumption: $ regex-debug compile '.' 0000 Save(0) (start) 0001 '\u{0}'-'\t', '\u{b}'-'\u{10ffff}' 0002 Save(1) 0003 Match(0) But when you compile it as a DFA (pattern edited slightly to make example more concise), then you get a FSM with UTF-8 decoding built-in: $ regex-debug compile '^.$' --dfa 0000 StartText (start) 0001 Split(2, 3) 0002 Bytes(\x00, \t) (goto: 27) 0003 Split(4, 5) 0004 Bytes(\x0b, \x7f) (goto: 27) 0005 Split(7, 8) 0006 Bytes(\x80, \xbf) (goto: 27) 0007 Bytes(\xc2, \xdf) (goto: 6) 0008 Split(10, 11) 0009 Bytes(\xa0, \xbf) (goto: 6) 0010 Bytes(\xe0, \xe0) (goto: 9) 0011 Split(13, 14) 0012 Bytes(\x80, \xbf) (goto: 6) 0013 Bytes(\xe1, \xec) (goto: 12) 0014 Split(16, 17) 0015 Bytes(\x80, \x9f) (goto: 6) 0016 Bytes(\xed, \xed) (goto: 15) 0017 Split(18, 19) 0018 Bytes(\xee, \xef) (goto: 12) 0019 Split(21, 22) 0020 Bytes(\x90, \xbf) (goto: 12) 0021 Bytes(\xf0, \xf0) (goto: 20) 0022 Split(24, 26) 0023 Bytes(\x80, \xbf) (goto: 12) 0024 Bytes(\xf1, \xf3) (goto: 23) 0025 Bytes(\x80, \x8f) (goto: 12) 0026 Bytes(\xf4, \xf4) (goto: 25) 0027 EndText 0028 Match(0) This works similarly for regexes like `\w`, `\d` and `\s`, which are all Unicode aware by default in ripgrep. Similarly for character classes and more exotic things like `\p{Sc}`. It is also possible to disable Unicode awareness and search by raw bytes as well. For example: $ regex-debug compile '(?-u).' 0000 Save(0) (start) 0001 Split(2, 3) 0002 Bytes(\x00, \t) (goto: 4) 0003 Bytes(\x0b, \xff) 0004 Save(1) 0005 Match(0)
I've heard of things like this, but isn't it correct that it still needs to assume *some* particular encoding? And there's no way to 100% tell apart a latin1 document from a utf-8 document; non-ascii latin1 characters could be valid utf-8 but will be incorrectly interpreted if so.
The contents of `@_` are aliased, so if you modify it directly, it can modify the variables that were passed. Example: sub increment { $_[0]++ } my $x = 1; increment($x); say $x; # 2
Yes? It assumes UTF-8, but can feasibly work on any ASCII compatible encoding, which includes latin1 and cp1252. If you get garbled output, then disable Unicode awareness and everything gets restricted to ASCII. Either way, this is orthogonal to my prior point. I was trying to point out that you don't need an explicit decode/encode step.
Sure. My point was just that ack could be similarly useful, if it had an option to decode files and parameters from UTF-8 (or another encoding) and then encode the output. But I've found no such option.
Yes you can, they're called [function references](http://modernperlbooks.com/books/modern_perl_2016/03-perl-language.html#RnVuY3Rpb25SZWZlcmVuY2Vz) 
This isn't because it's a function reference, this is because it's a closure. You can do that with standard named subroutines just as easily. my $var = 0; sub foo { $var++ } foo(); # $var is now 1
If you indent your code by 4 spaces it will show up as a code block which would be much easier to read. That warning occurs because `$lines[$i]` isn't a number when you compare it numerically with 0. Try printing out `$lines[$i]` before the if/elsif chain, inside the for loop, to see what the values are.
sorry about that! When printing out $lines[$i] it says: 112-10568-1-8-3-700-76Freq(Z+): 5 Freq(0) : 7 Freq(Z-): 4 Total: 16 Which is the correct total of numbers in the file that it is reading.. not sure what to do in order to fix this warning :/
Print a newline after $lines[$i] so you can tell each value apart. `print "$lines[$i]\n";`
Okay, so it does have the correct number file, when it prints out it is : 1 [the error code in the title] 12 -1 0 56 8 -4 55 -1 -8 -3 -7 0 0 -7 6
I got it, my number file had a space between 1 and 12 which apparently gives that error, TIL
üéâüéÅüéâüéÅ
Perl does have its tricks to let you do that, but what is described is simply a macro replacement -- "use the keyword, the code runs in that location as if it was hard coded there". 
Thanks for the job larry. 
Thanks for my job Larry. 
Fantastic! Perl was the only (useful) training course my employer ever sent me on and I've helped grown the company with Perl for 20 years. I'm still in awe at what it can do.
You picked the wrong data type. Use a [hash](http://www.modernperlbooks.com/books/modern_perl_2016/03-perl-language.html#SGFzaGVz). my %dict; @dict{@dictionary} = (); unless (exists $dict{$uniqueword}) { # not expensive any more 
Thank you. That's a simple yet very effective fix. Runtime is down for 41 seconds to 15 seconds.
There is also Perl's keyword API, which lets you hook into the parser and define how perl interprets the rest of the code once a keyword is reached, of which the simplest interface is [Keyword::Simple](https://metacpan.org/pod/Keyword::Simple); but even the simplest use of it is far beyond what the OP actually needs here.
Hashes are a far better solution to this problem, but for the initially proposed code, it's best to avoid raw usage of the [smartmatch operator](https://metacpan.org/pod/perlop#Smartmatch-Operator) as it's experimental due to having ambiguous behavior. Alternatives would be [any from List::Util](https://metacpan.org/pod/List::Util#any), a core module, or [Smart::Match](https://metacpan.org/pod/Smart::Match), which allows you to make the smartmatch operator explicit and makes the syntax nicer in some opinions. use List::Util 'any'; unless (any { $uniqueword eq $_ } @dictionary) { ... use Smart::Match; unless ($uniqueword ~~ any(stringwise(@dictionary))) { ...
It just make things more complicated than it begins with. The OP just need a macro or preprocessor. A preprocessor is a meta-layer that is orthogonal to the language syntax that does not require language to be more complex. 
Yes, but it's a different kind of complicated, it requires you to run the preprocessing in your build or deployment.
Preprocess is easily integrated. Most people don't even realize C's preprocessing step. For build and deployment? Would you really care about one more dependency in your makefile? It solves the complexity in an orthogonal direction. Do you notice how much of the hypes on new languages are merely syntax issues? A capable meta layer obviates most of them.
Thanks I'll bear that in mind
People have already suggested using a hash. But if you wanted to be able to cheaply suggest possible corrections a Trie might also be a good data structure. I have no idea how optimal the CPAN implementation is http://search.cpan.org/~avif/Tree-Trie-1.5/Trie.pm
The -r flag means that the file is readable.
I see, thanks !
Here are a few suggestions. * What makes the Perl languages (5 and 6) different from all the other programming languages you've encountered? * One of the feature the Perl 6 community is touting is the Perl 6's grammars &amp; actions. What makes them worth bragging about, and in which situations might a developer want to reach for this particular tool in their toolbox? * One of Perl 6's foundational inspirations is Paul Graham's article about [The Hundred Year Language](http://www.paulgraham.com/hundred.html). It's now almost 15 years later. Has the Perl 6 community made any progress with this ambition, and if so ‚Äì how?
Do you have more examples of MyDef usage? The script in https://huizhou.gitbooks.io/programming-with-mydef/gallery_perl.html seems like a complicated way to write perl -lne'print "$1: $2" if /^(.* Zhou)\b\s*(.*)/' &lt; directory.txt and it's not too clear how it'd be useful in a larger application. Does it handle multi-line expressions, for example? Why would you use this with Perl rather than just starting with a different language altogether, such as Python for example? Also, some parts of the default behaviour look like odd choices, or even potentially dangerous - https://github.com/hzhou/MyDef/blob/master/output_perl.def#L156 for example. Much of the rest of the logic in that file looks like it'd work better as a DSL implemented as a standard Perl module... ... which leaves the semicolons and {} blocks, I guess? I understand that some people prefer languages such as coffeescript or python which forgo those, but I just don't see how removing those from Perl is going to work without spending more time debugging problems caused by the preprocessor changing the code. See http://shadow.cat/blog/matt-s-trout/show-us-the-whole-code/ for example. Sounds like it works for you, which is great - but I'd be interested in hearing more about what you use it for, and the problems it solves.
&gt; seems like a complicated way to write ... One-liner is not particularly readable and it does not leave a record for review. The point is not simply to write short programs. The point is to write the *same* code but in a more readable way. Of course what is readable is to some extent a personal taste and MyDef provides a layer that you can customize. &gt; Why would you use this with Perl rather than just starting with a different language altogether, such as Python for example? Because I like Perl. I do have Python examples, and many recent developments, but that document hasn't been updated for a while due to lack of audience. &gt; Also, some parts of the default behaviour look like odd choices, or even potentially dangerous - https://github.com/hzhou/MyDef/blob/master/output_perl.def#L156 for example. Much of the rest of the logic in that file looks like it'd work better as a DSL implemented as a standard Perl module... I am impressed that you dig so deep. I write a lot of perl snippets with that each pattern in perl, that is why I put it in the code as default. If you have preferred other ways, you should have no problem change it into your way, right? Again the point of MyDef is really just a meta layer. You still think and work in the language underneath (e.g. Perl) and MyDef let's you write the *same* code more easily and readable. A DSL in a perl module, or in any other library form pose restriction. With DSL, one inevitably will be forced to think and write in the narrowed realm of particular DSL implementation. MyDef simply gives you DSL like syntax, while you still think and write in the full capability of your language. The worst case, you simply write your original perl, or original whatever. &gt; ut I just don't see how removing those from Perl is going to work without spending more time debugging problems caused by the preprocessor changing the code. They are not removed. You can still put in semicolons or braces if you prefer. I indent my code block strictly anyway so it appears to me a huge hassle and ugly to deal with them. When there is MyDef error, I simply look at the perl code MyDef generates, which is what Perl sees and the code is what I would normally write in perl directly anyway, so I don't see any increased debug burden than straight Perl. Of course, I can insist to use my fancy MyDef syntax, then I do end up spend time on figure out the best way to write it, but you don't have to (you could simply write straight perl instead when the MyDef macros get into the way). The philosophy of MyDef is not to hide the whole code. I often have split windows that on one side is def code that I edit, and on the other side is the code that compiler sees, and I think in that code, nothing is hidden. &gt; but I'd be interested in hearing more about what you use it for, and the problems it solves. Every kind of text I deal with. It only solves the problems that you perceive. For example, I don't want to remember and type boilerplate code, so I put them into a macro file and call them instead. I don't like brackets and semicolons, so I avoid them. I like indented block, so I enforce them. I find macros come in handy, so I use them. Etc.
* How much time do you spend sleeping? * Will Perl 6 replace perl 5 or will they continue to be two members of the family of perl languages?
Does he have to be crazy to write a Parser for Perl in regexes or does it just help?
When is the Perligata slang for Perl 6 coming out?
You could also (doing this from mobile) `my $hash = eval { retrieve($hashfile) } || {};` 
* I'd actually like to know about his exercise regimen. He always looks really fit for a coder. Not even joking. * Does being Australian give you a different outlook on the world? Again, sounds like a joke but isn't. I'm Australian. * Considering how truly *out there* some of the things he's done are ‚Ä¶ what are some ideas he's had and thought ‚Ä¶ nah, that's just too weird. * If he got to choose, would Perl 6 be called Perl 6 or something completely different? * Is there any market for Perl books any more, or even coding books in general, now that everything's online and every relies on Stackoverflow? * What was the first computer he got to work on, and what kind of things did he code? What were his first experiences of coding like, and how did he get into it as a full-time thing? * Is Perl a good first language to learn, if you're new to coding? * What does he think about Java? * Is Adam Kennedy the only person he's afraid of? Who is Adam Kennedy afraid of?
&gt; I'd actually like to know about his exercise regimen. He always looks really fit for a coder. Not even joking. It's probably fighting off all those drop bears.
If it's just because you need to provide a web interface for your apps, dancer is nice...
Dancer is nice, too
Around April 2016, at the Toronto Perl Mongers meeting, he mentioned he might make a Perl 6 book "in a year". Did that plan change or something actually in the works? If yes, what's it gonna be like?
A trick that helps me tremendously is that while developing, use Data::Dumper. That way at any point in yourncode you can quickly dump your variables to STDOUT or STDERR for inspection.
Where does he see Perl6 fitting into the overall programming language ecosystem? We have a lot of powerful &amp; fast languages coming out like Julia, Nim, Crystal, &amp; Clojure to name a few. Perl6 would be great for scripting, but that is a very competitive landscape. If we could get it to run on LLVM, then I see some staying power. Also, Perl6 is lacking some simple things like Python's basic IDLE IDE which comes with a simple text editor &amp; REPL. How do you recommend using Perl6? Vim and another terminal REPL session? Also, would he be agreeable to posting a video of a livecoding session online or do a presentation that way at a YAPC?
Yes, this. I want to see transparadigm coding in a book!
1) Perl (5) appears to be a survivor in programming languages despite a decline. Is there the prospect of a game changer that is required to reverse this decline, back to being the go-to universal programming language? 2) Can Perl 6 be considered the cause of Perl 5's decline (and its own)....a sort of accidental murder-suicide 3) Saw the DIOS video...clearly Perl is a gift to geniuses and insane master-obfuscators, as Damien, and vice-versa. ...does he agree?
It's probably been 15 years since I was at a talk he gave, and it's still the best PowerPoint assisted presentation I've seen.
no, it's even worse than the original
Morbo is a server for development of web apps. It's specifically designed to restart whenever files it's watching change. There's no reason to use it for this Mojo::ACME application. You can start a simple daemon with: `/path/to/cert.pl daemon -l http://[::]:3001` It wasn't really explained what the goal of using Plack here was. Mojolicious apps can also serve https without using Plack; the daemon and prefork commands, as well as morbo and hypnotoad, take a cert and key in their 'listen' option: https://metacpan.org/pod/Mojolicious::Command::daemon#SYNOPSIS. Conversely, you could also serve the Mojo::ACME app via plack, but there's no need to. Mojolicious apps told to listen on https will reflect this in url_for; I'm not sure why that wouldn't occur for plack apps under Starman.
Why version 7.0 for 6lang? :) It's already versioned using letters: 6.c for the current one, next one is 6.d, 6.e afterwards, etc. There's currently not a lot of support for "6lang" as an alias to the language name and not enough support for complete rename away from "Perl 6". As for "Perl 7.0", doing that right now is somewhat pointless. Without a solid rename of "Perl 6" done first, it's basically equivalent writing off "Perl 6" as a dud. But even if we assume such damage is irrelevant, "Perl 7.0" will be what exactly? Just a "Perl 5" under a different label that implies backwards incompatibility but with no new features to justify a major version bump? Feels a bit dangerous: sawing confusion among current users who don't want breakage due to major upgrade; without gaining any new users due to modernized features. Such versioning scheme also will see another family member to jump over eventually: Perl 11. I think someone proposed "Pumpkin Perl" in the past as a walk-away from just-Perl name, just as "Perl 6" is trying to do so. Perhaps that's a safer path.
I think his code is not loading posix anyways (autoload, and he didn't use it) which is why he doesn't see it shrink later. Needs more testing. 
You should never load POSIX.pm without an import list. See https://metacpan.org/pod/POSIX#CAVEATS
Perl v5.26 could become Perl5 v26 :) for some reason this article reminded me of http://grammar.ccc.commnet.edu/grammar/twain.htm 
Not a fan, after reading the post and then a link that goes to the naming discussion update, all I can see now is "slang". Once you see it, it cant be unseen. What happened with Rakudo becoming the new name?
&gt; What happened with Rakudo becoming the new name The naming discussion update blog post explains that point:https://6lang.party/post/6lang-The-Naming-Discussion-Update#therakudolanguage In short, progress happened. 
And to clarify: no official decisions have been made. That will be done during 6.d language release. Both Rakudo as language name and 6lang are just trials and experiments. The latest mood appears to favour TimToady's proposal: * "Psix" where 'p' is silent if you want it to be*
That's a good theory. Try tweaking `_zip_file_member` (the method in ParseXLSX that's responsible for looking up subfiles, and the one that throws that error) and see if you can get your file to load somehow. If you can, try telling doy about it (or rather, try filing an issue [here](https://github.com/doy/spreadsheet-parsexlsx/issues).) Being able to supply an example file would help, of course.
Inspect `perl -v` for a surprise.
"This is perl 5, version 20, subversion 3 :) " already done :) thank you that was very fast response :))
I don't know the internals of ParseXLSX, but I do know a but about the internals of the OOXML formats (having written [Document::OOXML](https://metacpan.org/pod/Document::OOXML)) I can think of several potential problems: The location of the "parts" of an OOXML (xlsx, docx, etc.) file are recorded in ".rels" files. The main one is in "_rels/.rels", and every part can have its own "rels" file listing its relations in &lt;directory the part is in&gt;/_rels/&lt;partname&gt;.rels. If ParseXLSX has a hard-coded path for stylesheet.xml ("Excel always puts it here"), it may be looking in the wrong place if the XLSX file was written by something other than Microsoft Excel. If it actually reads/parses the "rels" files, those may have wrong info in them (or it may be interpreting them the wrong way). 
The problem is that backslash sequences are interpreted before variables are pasted in‚Äîotherwise you wouldn't be able to write `"\$foo"` for a literal dollar sign. Instead you can use a combination of `hex` (to convert your hexadecimal string to a number) and `sprintf "%c"` (to convert a number to the corresponding Unicode character): s/¬∫([0-9A-Fa-f]+)¬∫/sprintf "%c", hex $1/ge Besides `use utf8` (because your regexp contains a Unicode character and your script is in UTF-8), you probably also need to `binmode STDIN, "utf8"` and `binmode STDOUT, "utf8"` to say that your input/output streams are UTF-8 encoded. Alternatively, you can use the `-CS` or `-C7` command-line option to do the same thing (which also affects STDERR: see `perldoc perlrun` for more information).
The problem is that backslash sequences are interpreted before variables are pasted in‚Äîotherwise you wouldn't be able to write `"\$foo"` for a literal dollar sign. Instead you can use a combination of `hex` (to convert your hexadecimal string to a number) and `sprintf "%c"` (to convert a number to the corresponding Unicode character): s/¬∫([0-9A-Fa-f]+)¬∫/sprintf "%c", hex $1/ge Besides `use utf8` (because your regexp contains a Unicode character and your script is in UTF-8), you probably also need to `binmode STDIN, "utf8"` and `binmode STDOUT, "utf8"` to say that your input/output streams are UTF-8 encoded. Alternatively, you can use the `-CS` or `-C7` command-line option to do the same thing (which also affects STDERR: see `perldoc perlrun` for more information).
[local::lib](https://metacpan.org/pod/local::lib) is designed to set the env vars you mention so that modules can be seamlessly installed to and used from your home directory. But you shouldn't use that manually either if you are using plenv (or similarly perlbrew), you will overwrite plenv/perlbrew's configuration and a local::lib must be made specific to one perl installation. Use plenv's local::lib support which is available from [plenv-contrib](https://github.com/miyagawa/plenv-contrib). Menlo and Carmel are still in the development phase. plenv and cpanm are perfectly capable tools already though. There is also [Carton](https://metacpan.org/pod/Carton) which is the existing bundler similar to Carmel. Not needed for maintaining your own development environments but useful for pinning dependencies specific to a project in a way that can be easily reproduced and deployed. It uses local::lib internally to accomplish this as well.
`chr hex $1` works as well as `sprintf "%c", hex $1`.
`//` is not a comment in perl, `#` is. Make sure you are using strict and warnings, it will help you find issues. There's really no need to shell out for these operations, indeed you will have lots of problems when the `$rawRptOut` variable contains shell metacharacters and escapes your quotes. Here's some equivalent code. use List::Util 'uniqstr'; my @rawRptOut2 = sort uniqstr split /\n/, $rawRptOut; my $rawRptOut2LineCount = @rawRptOut2;
You shouldn't have to set any of that stuff. `plenv install-cpanm` will give you a `cpanm` that, when run, automatically installs modules into the same plenv. Likewise, if you use that to install cpm, cpm will work the same way.
&gt; use List::Util 'uniqstr'; &gt; I get error ""uniqstr" is not exported by the List::Util module". What does that mean?
Indeed, thanks!
I needed this the other day but came up with a workaround instead. Going to try this tomorrow, thanks! 
You need List::Util version 1.45 or higher to get uniqstr. It's not difficult to write this functionality without using a function like uniqstr, but it's less pretty. my %lines_uniq = map { ($_ =&gt; 1) } split /^/, $rawRptOut; my @rawRptOut2 = sort keys %lines_uniq;
Ah, makes total sense! Thanks for the explanation. (Also, it works.) :) 
Thank you! It works perfectly. 
If you have not defined $rawRptOut, or $rawRptOut is empty you will get an nothing printing out. e.g. $rawRptOut="Test\ninput\nstring\nfor\nscript"; my @rawRptOut2 = `echo \"$rawRptOut\" | sort -u`; my $rawRptOut2LineCount = `echo \"$rawRptOut\" | wc -l`; print $rawRptOut2LineCount; print @rawRptOut2; works fine for me.
If anyone wants to check out the file, I've uploaded a version here http://www.cdezign.co.nz/downloads/test_sheet_new.xlsx If there's a better place for files, let me know. 
Try **List::MoreUtils** and **"uniq"** According to CPAN List::Util does not export anything by default....
This is irrelevant. The presented code imports uniqstr. List::Util 1.45 also provides uniq and uniqnum, so there's no reason to install List::MoreUtils instead of upgrading List::Util.
&gt; [that‚Äôs beside the point](https://i.imgur.com/QBWu3Mf.png)
Bad bot 
Can you update your post to show these expressions in context? The only strange place I can remember seeing `'` used in old Perl code is as the package separator. In Perl 4, you wrote `$package'variable` instead of `$package::variable`.
If you just want to remove spaces, try `perl -pe 's/ //' file.sp &gt; file.fasta`.
You're missing something. Hex literals have been `0x` since perl 1; binary literals have been `0b` since perl 5.6, and didn't exist before that. Single quotes have always started single-quoted strings, so they're not really available for anything else (except the perl 4 package separator, as davorg mentions). I think you're looking at something that's not exactly what you think it is.
You can still do this in Perl 5... but don't. üòù
Ah, yeah. Meant to mention that. See, for example [Acme::Don't](https://metacpan.org/pod/Acme::Don::t).
Well, that was painful to look at.
Some examples. `NTF::DATACHAIN-&gt;fdop_clk = ‚Äòb1101;` `my $ctrl_reg = 8‚Äôb10010001;` `$shift-&gt;ring = ‚Äòh2a;` I am wondering if they are using a custom compiler or a preprocessor. 
Here's a nice [overview of Perl 6 books](https://perl6book.com/).
Goto https://perl6book.com. Sign up for the emails. Has links to many perl6 books as the come to availability. 
First link: What is the purpose to used the operator? And people pay for this? SMH
Yep - some part of the chain is reading the hex and converting to a unicode character I bet. 
Best to stick those in your original post. Some people might not find them all the way down here.
I have been pondering this question as well and from my personal pov I find the following points: 1. Direct string composition. print "Hello $name\n"; 2. Direct regex. if ($line=~/^(\w+)\s+(.+)/){ $hash{$1} = $2; } 3. Scoped variable declaration with "my" and "our" as well as implicit namespace via "package". When reading code, you see "my", you don't need to refer further. { my $a = 3.14; $l = $a * $r * $r; } 4. Sigils for arrays and hash, as well as scalars. my ($S, @L, %H); 5. Support and adopts most sensible defaults utilize context. my @A; ... if(!@A){ print "empty\n"; } else{ print "A: @A\n"; }
Perl likes to absorb ideas from other languages and make them its own. If you want to program in a functional, object oriented, or imperative style, Perl will happily provide the tools to do so. It's also flexible enough that the community can often implement new ideas without needing core changes. For instance, when roles/traits/mixins became all the rage, we didn't have to wait years for a committee to work it all out like Java did. Modules simply started to appear on CPAN that implemented the idea.
What is your purpose in learning P6?
Hmm, imagine the following assignment designed to let Perl shine: You're given a weird device with chip and *nix derivate you've never heard of. On that system you are to implement some wall-mounted device to be used in a factory hall as a terminal for some weird logistics crap. The device will have network access to a larger server with a database where you can retrieve and store data. Oh and because the factory is dirty and movable parts tend to collect dirt, the device will use some RFID or optic code or something other that's not haptic to interact with the user. The data you get is produced by some old proprietary machine in a weird 7-bit format (see attached 100 page pdf). You'll need to do some transforms on the data (see the other 100 page attachment, there's also an external binary that does some of that) and need to run the data against existing databases. Those are all in Unicode now btw. Please pay attention to the collations. So. Why does Perl win for me? * It runs basically everywhere that can run a *nix and you don't need to worry about most of the machine details. * You don't need to cross compile, you don't need to compile in the first place. * You'll need libraries for network, database, that RFID/QRcode/whatever thingy. CPAN has them. I've found very few formats where there isn't already a CPAN module for it. If there's a C library, there's a Perl wrapper for it. There's a module for Wiimote. You'll need to compile some, but it's still way easier than getting python2 packages to run on python3. * You also need to do some non-trivial data processing that's not hardware hungry but incredibly prone to implementation errors? Screw bit fiddling in C state engines. Regexes, dispatch tables, closures, hashes, currying, objects, exceptions - use whatever you think will get the job done ^(not Lisp macros though). * That proprietary machine lasts for a decade? Whatever you're building will still work in a decade too. Perl doesn't break your existing code without very good reasons. * Unicode. That example may be a tad over the top, but astonishingly large subsets of it have popped up in the past.
Perl and cpan and the community form one of the best programming by research stacks.
There is no "Programming Perl 6" book. (Yet; Larry wants to write it eventually). &gt; Absent that, I'd hoped to find a book on Perl 6 aimed at Perl 5 programmers. [Migrating to Perl 6](https://deeptext.media/migrating-to-perl6) by Andrew Shitov targets exactly this audience. Enjoy!
Here's some counterpoints. 1. String concatenation is often a little too primitive to actually work properly for a given purpose, e.g. think of HTML or SQL injections, where syntactic metacharacters must be escaped. 2. On the other hand, while regexes may be nice, datastructures are less so. Perl's $foo{$a} = $b stuff can hardly be called syntactically elegant. Even foo.put(a, b) in style of Java is nicer. 3. On this, I agree, mostly, although I wish Perl had some form of "const" modifier for once-assigned variables. Your example redefines variable $a, though, so that's weird/bad. 4. This ranks among my least loved features. I have grown to hate $, @ and % because these characters require effort to type, and combined with {} result in absolutely dreadful expressions. push @{$foo{$bar}}, $baz etc., to say nothing of how you use $ to reference both @ and % typed variables in some cases. Yuck. 5. I don't understand what this is about. I imagine you like the rich operators Perl provides, or whatever. I'll synthesize a random counterexample. While talking about testing if array is empty, remember the fun times you had when you did the same thing everyone else does, and tried length(@a) and it doesn't work as expected? Or the weird operators like m?? or split //, or the fact that split "" actually splits by regex and that's why split "." doesn't work to break IPv4 address to parts? 6. Eh, Perl almost certainly advocates you to imperative style, and probably to procedural programs too, it's just the kind of work it's well suited to, I guess. It is not a functional language by any stretch, and not a very good object oriented one either.
&gt; Here's some counterpoints. Love them, bring them on. &gt; String concatenation, and syntax that supports it, is often a little too primitive to actually work properly for a given purpose, e.g. think of HTML or SQL injections, where syntactic metacharacters must be escaped. You can't work with many systems using that, though it can be fine in a lot of cases. Still, I mostly write "foo" . $bar myself partly because you can't e.g. call methods from within the string interpolation context. Did I emphasize I use print for debuging? Most people see programming as a final product. I see programming as a developing process, during which understanding and refactoring is the dominant activity. When direct string expansion fall short, there is '.', join, and s?printf, and I use them often. But missing the quick print is what I miss most uppon switching languages. &gt; On the other hand, while regexes may be nice, datastructures are less so. Perl's $foo{$a} = $b stuff can hardly be called syntactically elegant. Even foo.put(a, b) in style of Java is nicer. Data structure introduces a layer of complexity on its own. `$foo{$a}` is a straight hash or dictionary. `foo.put(a, b)` is an abstract object that requires extra context for comprehension. That latter has its importance, but not always. &gt; On this, I agree, mostly, although I wish Perl had some form of "const" modifier for once-assigned variables. Your example redefines variable $a, though, so that's weird/bad. "const" is a value, I hate it when we are forced to use a variable in stead. A variable is supposed to vary. In practice, I use an additional meta-layer that gives me macros so constant is not an issue for me. There are another situation that you want to protect certain variables/object from changing values -- that is semantic issue that is best solved with program design. Are you so against using convenient/temp variables for readability? `my` and scope allows that. Otherwise, I quickly run out of good temp names. Long range variables are necessary, but they require better planning to avoid readability issues and they better be minimized. &gt; This ranks among my least loved features. I have grown to hate $, @ and % because these characters require effort to type, and combined with {} result in absolutely dreadful expressions. push @{$foo{$bar}}, $baz etc., to say nothing of how you use $ to reference both @ and % typed variables in some cases. Yuck. Sigils separates words between variables (scalar, array and hash for that), function names and syntactic keywords. The effort of typing them in exchange of easier readability is no-brainer for me. @{$foo{$bar}} is no longer a simple variable, it is rather an expression. Treating it as expression, it is on the same level of all other operators. I think what you are arguing may be the merit of availability of explicit references (as between Java and C). Explicit references does make the language more complex, but it offers a level of fine control that I find very important. Dealing with refereces, `@{...}` is rather concise expressions. Reference is a scalar, just as pointer holds an address. The illusion of otherwise is harmful (unless the language do not give you that control from beginning). &gt; I don't understand what this is about. I imagine you like the rich operators Perl provides, or whatever. I'll synthesize a random counterexample. While talking about testing if array is empty, remember the fun times you had when you did the same thing everyone else does, and tried length(@a) and it doesn't work as expected? Or the weird operators like m?? or split //, or the fact that split "" actually splits by regex and that's why split "." doesn't work to break IPv4 address to parts? My point is, those are suprising gifts from Perl. You could always use `if(scalar(@a)==0){...}` and you are missing nothing. But when you learned you can simply type `if(!@a){...}` and find it more readable, that is a nice gift. &gt; Eh, Perl almost certainly advocates you to imperative style, and probably to procedural programs too, it's just the kind of work it's well suited to, I guess. It is not a functional language by any stretch, and not a very good object oriented one either. Well, I just recently had so many conversation that only talks about OOP in perl. As for functional, have you read the book "Higher-order perl"? Perl does not advocate it. It advocates "There is more than one way to do it". People do advocate their cup of tea. 
I‚Äôve gathered from the comments here that this is not, nor ever has been valid perl syntax. So I suspect there is some sort of hack or extension here. 
`tie` is incredibly powerful. Taint checking is too. Perl runs everywhere. It does regex inline, which makes it really good for text processing (this is also the reason perl has a reputation for being inscrutable. I still call that more regex's fault than perl. But `use re 'debug';` is incredibly powerful. Functional programming ( callbacks ) are easy. So is threading and forking. I know people will say use of threads is discouraged, but that's only really because Perl is a heavyweight thread implementation. You can most just poke native C calls when you need to knock together a test case. (Had one recently where I needed to debug an NFS locking problem, and whilst I could have done it in C perl was less painful) `map` is a list comprehension (another functional programming thing) and it's really cool. (So is grep). Perl does both lightweight OO that lets you evolve a script. But it also let's you do "full" oo, when appropriate using things like Moose. You can write bad code in perl. It will let you get away with it. But with use strict and warnings and decent coding standards you don't have to at all. Perl can do all the standard Unix tool stuff as one liners. So can awk, sed, grep, tr, cut etc. But lends itself to easily building a one line hack into a proper program as a result. Perl is context sensitive. It can behave appropriately in a scalar/list/void context. This can be used to trap errors and `die` if an inappropriate void context is used. 
&gt; And people pay for this? What ?! 
I agree, but that's not the problem. =)
It's certainly loading /something/ because the RSS goes up 2MB and never drops.
^\d+$ -- starts with a digit, followed by more digits /^\d-$/ -- starts with a digit, followed by "-" try again 
My colleague suggested that Perl 6 be renamed Python 4. I'm unsure the suggestion is totally without merit. /me ducks.
``` /^\d+$/ /^\d-$/ ``` How ingenious! Unfortunately, no.
In case anyone's lurking, looks like it's not as simple as I thought. I can't see that ParseXLSX is hardwired to look in xl/ for the files. Following /u/treenaks suggestion I've looked at the _rels/ folder. There's a file there called workbook.xml.rels. It alludes to a Target="stylesheet.xml" which lives a folder higher in the hierarchy. If I edit it and then reassemble the xlsx, it parses.
There's no one reason and everyone's going to have different reasons, but here's what stands out for me. The language, and most things written in it, are written from the perspective of practicality and necessity. The majority of perl code out there has been written to accomplish a task or meet a requirement in the real world. The language was designed to facilitate this. It has edge cases that seem odd at first, unless you are the target audience of them, where they become conveniences; someone familiar with other tools like sed or awk, or anyone doing a common operation of iterating through the lines of each filename passed on the command line and printing output. The CPAN ecosystem revolves around providing a standardized set of documentation (based on the pervasive standards of man pages) which makes it more likely to find a well-documented reusable module. It also has a rich culture of testing, with CPAN distributions all running tests upon installation as well as continually on volunteered smoke-testing machines and infrastructure at http://cpantesters.org/. This makes it easier to find modules that actually work, and to see at a glance what versions of perl and architectures a module is compatible with in practice. The syntax is as readable or as concise (or both) as you make it. TIMTOWTDI means that newcomers can write ugly perl that makes sense to them and still works, and as they learn the ins and outs of the language they can tidy it up to their liking. Overall, it's not that it has any one "killer feature" that makes it better to use than python, ruby, or javascript/node. It's up to you what language will best suit your expectations or your needs, and it may be more than one of them. For me, it's been Perl.
I agree. Also, some of your examples are using the regular apostrophe, and some are using smart-quotes; these are different characters, so the difference will be important to Perl or whatever is parsing these.
You can write `use List::Util 1.45 'uniqstr';` to get a clearer error message when your List::Util is out of date.
(Sorry for beating the drum again, but the names still don't make this clear, so in case OP is unaware...) Perl 6/Rakudo/P6 is a separate language designed from the ground up with only syntactical similarities and shared infrastructure, and its own identity otherwise. Perl 5 is still as it was, and is actively developed.
so what would be a properly designed regex? even if it‚Äôs not for specifically what i‚Äôm asking for 
Thanks for all of the useful comments guys. It's been interesting. I guess like any other language, it can't really be appreciated without actually using it to solve real problems. I hope to spend more time with it one day. Thanks again
You might also have a look at another related language if you plan to learn it for fun: Perl6. Perl6 has most of what people pointed her as being likable about Perl but adds a lot of other things that are very interesting. It's common for people to feel like they're fighting every other language after they learn Perl6. It also have many features that aren't available anywhere else.
1. It isn't the most graceful construct, but you can insert complex expressions including function calls inside double-quoted strings using @{[ ... ]}. $ perl -E 'sub foo { "foo"}; say "this is a @{[foo()]} string."' this is a foo string. 2. If you want nice objectsm use Mo, Moo, Moos, or Moose, or Moxie, or rperl, or Class::Std or ... too many alternatives. 3. Lots of solutions for constants. Perl core comes with constant.pm, but it provides functions which you can use without the parentheses, which means it doesn't work the way you want it to in strings or hash keys. Readonly.pm is popular, but not the fastest. Const:;Fast is my preference nowadays. 4. 5. 6. You can't please everyone. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/upwork] [Questions from the Upwork Perl test. ‚Ä¢ r\/perl](https://np.reddit.com/r/Upwork/comments/77b5bq/questions_from_the_upwork_perl_test_rperl/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It's easier to do useful, moderately complicated things in perl than in many other languages.
I get the same results as you on Linux. What are the different results you're getting on a Mac?
https://imgur.com/a/ZJMEg
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/oTFBu6D.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dokj81p) 
Maybe try capturing the negative numbers first and see if that gives the same results on a Mac (I don't have one handy): if ( $num =~ /^[0].{0}/ ) { $ctrZ++; } elsif ( $num =~ /^-\d+$/ ) { $ctrN++; } else { $ctrP++; }
Unfortunately I can't change the code at all, only the regex or I fail the assignment.
Or you could replace that whole if/elsif/else structure with this: $num &lt; 0 ? $ctrN++ : $num == 0 ? $ctrZ++ : $ctrP++;
Oh, in that case I don't know what to tell you. I'm not familiar with macs enough to know why it's behaving that way.
Surely you can change the code while you're testing? It'd be helpful to know exactly which of the numbers are causing problems.
yea, i misread what he meant. I meant that for another post.
My guess would be some how that `__DATA__` isn't being read correctly on your MAC? Maybe it's a line endings thing? I'd start by just printing out that data structure and see if it's being read-in correctly.
What is your regexp `/^[0].{0}/` doing? Start of the string followed by a literal zero, followed by any char repeated zero times? 
Yea, i managed to figure it out, you were right about the line endings. The "$" was messing it up.
Thanks for the advice
It‚Äôs always the carriage return 
^ matches the start of the string \d is the same as [0-9], matches digit + means 1 or more, so \d+ means one or more digits \d+ does not mean poisitve integers -- regex is not designed to tell integers or not, it is only designed to match character patterns. So \d- does not mean negative integers, it simply means one digit followed by "-", which of course did not match anything in your case. You want to match a "-" sign before the digits, so /^-\d+$/ shall do it.
If all you data are numbers, you're better off using cmp() to compare against zero. cmp() will return -1 if the first argument is less than the second; zero if they are equal, and +1 if the first arg is grater than the second. regexen are powerful, but sometimes you're taking a bulldozer to a popsicle stick fight.
I think it gets a bit easier if you re-order your checks to check for the easiest stuff first. I've also switched to using `$_` to store the number. #!/usr/bin/perl use strict; use warnings; my ( $ctrP, $ctrN, $ctrZ ) = ( 0, 0, 0 ); while( &lt;DATA&gt; ) { chomp; ## print "num=[$_]\n"; if ( $_ eq '0' ) { $ctrZ++; } elsif ( /^-\d+/ ) { $ctrN++; } else { $ctrP++; } } printf("freq(Z+):%8s\n", $ctrP ); printf("freq(Z-):%8s\n", $ctrN ); printf("freq(0):%9s\n", $ctrZ ); printf("Total:%11s\n", ($ctrP+$ctrN+$ctrZ) ); exit; __DATA__ 19 -22 498 512 15 -932 0 22 808 17 -32 
If you're reaching for something like `/^0$/` then it's time to put the regex engine down and use `$num eq '0'` instead :-)
some things that are great in perl, IMO: 1) regex (syntax, features, speed, integration with main language). 2) variable scope (lexical, local, state, package global). ruby and python pale in comparison. 3) unicode support. 4) interpreter startup speed. 5) module repository (CPAN) namespace organization. the module names tend to be hierarchical, more organized, more meaningful compared to the other languages'. 
&gt; I'd actually like to know about his exercise regimen. He always looks really fit for a coder. Not even joking. i think damian circa 2011-2012 was rather... plump :) https://www.youtube.com/watch?v=ORjyXcLDd9M
Video linked by /u/perlancar: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [YOW! 2011 Damian Conway - Temporally Quaquaversal Virtual Nanomachine](https://youtube.com/watch?v=ORjyXcLDd9M)|YOW! Conferences|2017-07-04|0:57:48|5+ (100%)|125 $quote Watch in horror as Damian writes a Perl program to extract... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/perlancar ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
[Perl as functional programming on stack overflow](https://stackoverflow.com/q/31046327/2566198)
Ya... but I got the impression from his post that he has to use a regexp for this homework.
Re-reading it, you're probably right. I'm not sure what's worse - Perl not being taught in colleges or Perl being taught in colleges by teachers who have no idea about the language :-/
Looks like we have [two people](https://www.reddit.com/r/perl/comments/779bdg/question_about_regex_for_and_integers/) trying to solve the same problem simultaneously. Can I suggest that you try working together?
But be prepared to explain that it's a poor quality assignment. Regular expressions are a text and pattern processing tool. They aren't numerically aware. For a numeric comparison it's like using a hammer as a screwdriver. It will work, but it will be harder and messier than using the correct tool.
Think `&lt;=&gt;` will do the trick. $count_of{$num &lt;=&gt; 0}++;
I hear good things about that name, do you think they'd mind if we borrowed it for a version or two?
https://hop.perl.plover.com/
Perhaps we should leap frog version numbers? odd_perl =&gt; 'perl5', even-perl =&gt; 'perl6', # Not a serious suggestion.
I'm both intrigued by and somewhat skeptical about what I've heard about Perl 6. So at this point, my motivation is mostly curiosity, but that could easily change. Currently, about 5-10% of the (file-based) code I write is in Perl 5, and almost all of it is sysadmin-y type stuff: git extensions, logs parsing, etc. Plus I use Perl 5 "one-liners" on the command line all the time. It would not be farfetched to think that I would switch to Perl 6 for the code I currently write in Perl 5.
Thank you: that was a very worthwhile reminder.
Good Bot.
Thank you minimim for voting on imguralbumbot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
^(thank you) ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
*Migrating to Perl 6* does sound just like what I'm looking for, but AFAICT it won't be available until 2018. (At least this is the case for the printed version, and I was not able to find an electronic version.)
That looks more like Verilog instead of Perl. In Verilog constants to be put into registers are written like that. The apostroph denotes quoting and the number before that the bit width.
I'm aware of the `"@{[whatever]}"` stuff but at this point I rather type `". whatever ."` because it's fewer, more easily accessible characters to type. There's one exception, I guess: when your result is actually a list and you also want spaces between elements and `"@{[whatever]}"` works the same as `" . join(" ", whatever) . "`. But that's very marginal, I guess. 2. Perl's large littany of competing OO schemes is not actually a point in its favor, I think. It sounds like you have to learn like 10 different class based OO conventions, depending on whichever koolaid that particular library's author chose to drink. I'm sticking with`fields::new($p)` for now. 3. I really just would like to have the concept of "variable that is assigned to exactly once". This can be a constant, but it's more like "here's N different code paths through this function. Before the point where some variable $x is used, all code paths reaching here must have passed a point where they set $x, but none must have set it more than once". Trivially, this is a constant value that is immediately assigned on definition, but it can be a safeguard that checks that you didn't forget to handle some specific case in your if-else branches.
Just join back the lines in @y: my $y = join "\n", @y;
&gt; Did I emphasize I use print for debuging? Yeah, I guess that helps, and it might even be the best way to debug perl programs. On the other hand, in other languages you can set breakpoints at code lines that drop you into debugger when execution reaches them or when uncaught exceptions happen, and you can investigate all variable values in all the stack frames that lead to this point. I'm not sure if perl debugger would do me any good, as I've never learnt how to use it. &gt; Data structure introduces a layer of complexity on its own. $foo{$a} is a straight hash or dictionary. foo.put(a, b) is an abstract object that requires extra context for comprehension. That latter has its importance, but not always. It could be a TIEHASH, in fairness, which can do arbitrary garbage at least in principle. Method called "put" is a very strong hint to a Java programmer that foo is something that implements the Map API, just as you assume when you see `\\$\\w+\\{` that you're working with a hash. &gt; Are you so against using convenient/temp variables for readability? My point was, you did { my $a; my $a } in the same scope, which obviously will produce a warning from Perl. I wasn't too clear about that. I use anonymous scopes a lot in all my programs to limit bleed of temporary variables to surrounding scopes. &gt; Well, I just recently had so many conversations that only talks about OOP in Perl. It is a fact of life that Perl5's performance is quite low, and perl's scalars are rather fat. In practice, this limits the degree of abstraction that you can attain in Perl programs without hitting memory and CPU unnecessarily hard. I've tried OO modeling of problems in Perl, and I've tried things like the overload module to define own datatypes. It is a pleasant surprise when something works, but a lot of the time it's just a slow descent to madness. I've had to throw away working OO designs for performance reasons and just write the simplest possible for loops that straight up manipulate the data using fewest perl ops possible to reach acceptable performance levels. As to functional programming, I guess I was thinking about something like Haskell or whatever other languages the cool kids rave about these days. I think you'll strain yourself to push Perl for that, and in any event the more function calls you use, the worse performance you'll enjoy, as Perl5 does a lot of work to set up and tear down every function call and can't inline anything as far as I know. It could be that Perl6 can find ways to optimize all this properly, which will make it more likely I know that going into performance issues is a bit of a lowly punch to the balls in programming language discussions, but it is a concern when the language is on the slower end of the spectrum. If there is one thing I'd wish for Perl5, it would be the focus on consistent deprecation and removal of features that add memory cost to scalars, or force the interpreter to handle special cases that rarely matter, or force programmers to be aware of strange behavior in expressions such m??. I've heard that Perl5 has made impressive gains in some (micro?)benchmarks, but these gains do not seem to be apparent in the programs I actually write and run, for whatever reason.
intern position? How do you spell "perl"? :) I wouldn't expect that you would know much, but would suggest that you look at: - What are the perl basic data types. How do you use them? (arrays/hashes/scalars). - When we talk about 'context' in perl, what does that mean? (E.g. scalar/list/void context, `wantarray()`) - Can you give an example of how you'd use `map`? - What does `&lt;&gt;` mean and why would you use it? - Can you give an example of a command line flag to perl and an example of it's use? (E.g. `perl -pe 's/search/replace/' somefile`) - How would you display the contents of a hash for debugging? (Data::Dumper) - `use strict;` `use warnings;` - why should you always use them? Would probably steer away from threads vs. forks because they're advanced topics. Also: [Seven stages of a perl programmers](http://blogs.perl.org/users/mark_leighton_fisher/2015/07/the-seven-steps-to-perl-mastery-by-tom-christiansen.html)
Yep: #!/usr/bin/env perl use strict; use warnings; use Data::Dumper; my %count_of; while ( &lt;DATA&gt; ) { $count_of{$_ &lt;=&gt; 0}++; } print Dumper \%count_of; __DATA__ 19 -22 498 512 15 -932 0 22 808 17 -32 
Some things I like about perl: * Perl has one of the best lexical scoping implementations I've ever seen. * Tests are more ingrained in to the culture than most other platforms I've seen. * Perl is generally faster than other interpreted languages. * In my opinion, explicit referencing and dereferencing is a feature. * operator type coercion. 1 + "1" always DWIM. In javascript and many other languages this has to be 1 + parseInt( "1" ).
&gt; On the other hand, in other languages you can set breakpoints at code lines that drop you into debugger when ... You can do that in perl with `perl -d`. Putting print/log is more of an active approach than using a debugger. I assume people who are brought up with IDE are more used to debugger. For me, waiting for debugger bring out context or trying to figure out the context is counter intuitive especially when you are trying to understand your program. Contexts is nested from top-down, so depositing print from top down makes more sense to me. &gt; Method called "put" is a very strong hint to a Java programmer that foo is something that implements the Map API ... Are you sure? It is that unsure part that pushes into the abyss of the abstraction layer. &gt; It is a fact of life that Perl5's performance is quite low, and perl's scalars are rather fat. In practice, this limits the degree of abstraction that you can attain in Perl programs without hitting memory and CPU unnecessarily hard. Are you comparing Perl against Java or against Python? Perl is more of a performant member among dynamic languages. If your code is dominant by io and string processing, then Perl is even on par with compiled languages. But abstraction is the true root of evil. Java nowadays with JIT is not really much slower than C. But a typical Java program will be much slower than typical C program and the average programmer has no idea why it is so slow. It is not because Java is intrinsically slow, it is the abstraction layers. On one side, the abstraction adds in the infrastructure cost. On the other hand, the abstraction shields away from programmers most insights on where the resource went. You sacrifice performance and understanding for abstractions, so arguing for performance under the context of abstraction seems ill-dressed. &gt; I know that going into performance issues is a bit of a lowly punch to the balls in programming language discussions, but it is a concern when the language is on the slower end of the spectrum. I use both Perl and C depending on the nature of problems and the objectives. It is weird to see people arguing for performance on the perl side and arguing for abstraction and ease on the C side. Pick your problem and fix your objective, then we can have a better conversation. &gt; If there is one thing I'd wish for Perl5, ... Obviously one wish is not going to change your mind about Perl :) Understand oneself is the most difficult tasks...
Questions I have asked when a candidate claimed familiarity with Perl: * what is the difference between require and use? * name one or more modules that you have used and why you used it? * in plain Perl OO, what is the name of the constructor? In a face to face, I would ask two programming questions: * write a program that outputs the nth term in the Fibonacci sequence (starting with 1,1) * write the fizzbuzz program
&gt; in plain Perl OO, what is the name of the constructor? If people just said "new", would you ding them? This seems like one of those questions where the simple answer will give you a passing grade, but there's a more correct answer that will get you bonus points.
Usually, my follow up question was "why?" or "how do you know?" If you don't know why it is "new", then I just know that you are likely a beginner Perl user.
&gt; How would you display the contents of a hash for debugging? x %var in the perl debugger 
Funny, I've done this before but didn't know that it's called a function decorator. I just called it a wrapper, but in retrospect there's definitely a difference in intent between the two terms.
For an intern, I would consider practically any answer acceptable :)
relevant: http://blogs.perl.org/users/piotr_roszatycki/2014/03/pythons-decorators.html
I'd put the Camel book in front of them - tell them they've got fifteen minutes - and when you come back you'd like them to explain Taint Mode to you as best as they can. That should give you insight as to: * whether they can research and learn on their own * whether they can understand what they read * whether they can communicate what they know with you 
I would say new, but anything could work if it blesses a ref. But that I use "new" by convention because I'm not an evil bastard that wants to confuse people.
Crossposted to [PerlMonks](http://www.perlmonks.org/?node_id=1201647).
and that is where you move to at least medium level of knowing how Perl works
You can use backticks to capture the output of a command. However, shelling out should generally be a last resort, in this case you probably want to use something like the Net::Ping module. 
I've already tried the backticks Would it look like: my @a = exec "ping -c3 $host";
Use open.
Take a look at ‚Äúqx‚Äù in the ‚Äúperlop‚Äù man page for some examples. qx/backticks have some serious shortcomings though which is why I suggested Net::Ping. That said, it might be good enough for your purposes. 
I've been writing perl for 20 years. It's been so long since I've used anything but use I had to think about the first one a bit. 
What position does the on/off switch have to be in for the computer to be usable as a computer?
Try capturex from [IPC::System::Simple](https://metacpan.org/pod/IPC::System::Simple) which will let you capture the output into a variable like backticks do, but without passing its arguments through the shell. use IPC::System::Simple 'capturex'; my @lines = capturex 'ping', '-c3', $host;
&gt; It would not be farfetched to think that I would switch to Perl 6 for the code I currently write in Perl 5. This is why I responded with my comment above; this seems like a thought spurred only by the similarity in name. There is no more practical reason to switch Perl 5 code to Perl 6 than to Javascript/Node, or to not switch it at all. Perl 5 still does what Perl 5 does best, and Perl 6 was not designed as a "better Perl 5" (at least, not anymore), but has its own strengths due to being free from that constraint. So, you should learn Perl 6 if you want to learn a new language that looks a little like Perl 5 and is better at threading and unicode and grammars; not just to "keep up" with Perl.
Fairly recently I played around the idea of programmatically crafting classes at runtime This was a question that would tell me if I had an advanced user on front of me
[Class::Method::Modifiers](https://metacpan.org/pod/Class::Method::Modifiers) (or [Moose's version](https://metacpan.org/pod/Moose::Manual::MethodModifiers)) is a nice way to achieve this with less room for error and no ugly manual symbol table manipulation. They also interoperate nicely with Moo/Moose inheritance and roles.
Data::Dumper boiiiii
backtick, not doublequotes. my @a = \`ping -c3 $host\`;
I feel the perl debugger is underutilized. This was my attempt to promote the debugger ;-) 
For the lurkers, I've now discovered that editing the workbook.xml/rels file as above actually fixed the shit. So I'm suggesting an approach to @doy to validate the location of each Target xml file before attempting to open.
Interviews themselves are a mixed bag. You never know if you're getting somebody who just wants to throw you off by asking you as question they know you can't answer, or if they just want to have a conversation about Perl. If I was interviewing a Perl developer, I would ask ask them about some of the newer stuff. Their take on Perl 6 ("Objection! Relevance!"), whether they're using Moose or some Moose variant, what kind of ORM they use, what kind of Perl web frameworks they use, their approach to things like services, how they deal with dependency management (cpanm, which has a different purpose than carton, which has a different purpose than Docker, etc)... I would ask them about their thoughts on using Perl in a world that is increasingly hostile to Perl, and what their thoughts are about other languages, and how those languages compare to Perl for various things. You know, an actual conversation. I would love it if they could tell me about a great CPAN project that I don't know about, and I would also love it if they could tell me about _any_ great project that I don't know about.
`open` is going to be the simplest solution.
I was thinking think the actual answer is "bless" as that's what turns a hash into an object and returns a reference. "new" is pretty much the convention, but there's quite a few places where object construction is implicit, like `Time:: Piece -&gt; strptime` or `XML::Twig - &gt; parse` My standards for an intern wouldn't be particularly high on that front though :)
I don't use require often - usually it's just a friendlier sanity check for modules than just bombing out. My major scenario is when threading, because there are an embarrassing number of modules that aren't thread safe. So doing a require/important within a subthread defends against most namespace pollution nastiness.
[How to Identify a Good Perl Programmer](http://www.modernperlbooks.com/mt/2011/01/how-to-identify-a-good-perl-programmer.html) I think the questions are relevant even just for a scripting job.
You definitely don't want `exec()`. From [the documentation](https://perldoc.perl.org/functions/exec.html): &gt; The exec function executes a system command and *never returns* You want backticks (```ping ...` ``), also spelt `qx[...]`. But I'd really recommend [Net::Ping](https://metacpan.org/pod/Net::Ping). 
Perl 6 is superior to write concurrent software. Will eventually be better in regarding performance and distributed environments, but at this pace it is going to take decades
I run my mojo app on DreamHost ‚Äòs shared hosting. The app runs as a fcgi or cgi script within apache. I‚Äôd say that it is not a good choice, it‚Äôs too slow. Any VPS would be better than a shared hosting.
Yeah, when you can get a decent VPS for $5 a month, shared hosting doesn't make much sense. 
It does, when you have many small traffic sites/apps on different domains. It's a lot easier to set up and maintain.
I have a small-traffic Mojolicious-based app (speed comparable to WordPress side on the same account; I don't use caching on either), and a veeeery old CGI script which runs fast.
Books? That's so 20th century :)
Worth mentioning we have [five 5-to-6 guides](https://docs.perl6.org/language.html) in the `Language` section of docs.
&gt; Plus I use Perl 5 "one-liners" on the command line all the time. I use Perl 6 for this all the time now. Its `lines`/`words`/`slurp`, the Lists/Hashes actually having tons of methods to call, and the core Dateish objects make it very handy in many situations.
My company has a business line and we host websites local. We also have a VPS at a cloud company called Involta (vmware based). Both run fine. I run uwsgi with straight plack (no mojo or dancer) and it works great. I really like emperor mode cuz I can start/stop apps by dropping an .ini file into /etc/uwsgi. Restart by touching the .ini file or the main .pl script. Which means I can update live sites just by "svn up". For funzies I rewrote a tiny perl plack script in C (both used uwsgi), and while performance was about the same (both just do a quick image resize using GD) the memory usage was much smaller in C. uwsgi is a wonderful container, tons of options, fast, small. I very much enjoy it. I have both nginx and apache forwarding calls to uwsgi, and both work great.
I don't doubt what you write, but then, IMO, to call this brand new language "Perl 6" was a serious blunder, to put it politely.
DreamHost. I have a shared hosting account and host there many sites with Perl or php based websites. Works great.
Do you use any web framework in perl? And how do you deploy the app? My mojo app is too slow, either run as fcgi or as cgi...
You could easily host them all on a single VPS, too. Use nginx as a reverse proxy and route traffic internally based on the ports you've got each Apache instance listening on.
I'm sure you can totally do it... if you know how to. I'm guessing it's more hassle to configure too. In cPanel you type domain name, click create and you're done.
VPS (with Apache).
Automating your deployment can certainly make it easier for ongoing usage (still have to do the up front work, of course). I use Opscode Chef (free for up to 5 nodes, iirc, which more than covers this use case) but there are other great alternatives as well. Configuration then becomes a breeze and adding new sites is just a few bits of metadata in a JSON file (e.g. domain, port).
Back in the early 2000s I wrote a framework for a nonprofit in HTML::Mason that got moved to DreamHost, so i wrote a fcgi handler for it as well. I know almost a decade ago someone made an attempt to replace it with WordPress, which got rolled back when the torches and pitchforks came out. Apparently it's still running that code (just checked). At $work I'm still using that but with fcgi configured nginx Docker containers in Rancher.
Or,putting it all together: my $y = join "\n", (uniq split /^/, $x); The parens are PROBABLY not needed - but I like them for clarity.
To be fair, it made a lot of sense at the time. To be very fair, it has made less and less sense as time went on.
is it dead? all links to search.cpan.org from Google work for me, site is operational. but metacpan is so much cooler, I wish all links were just permanently redirecting to metacpan.
https://chrome.google.com/webstore/detail/meta-cpan-redirect/blakeebdldmplhhegjofiaidnijmiphj?hl=en
cool, thanks!
http://search.cpan.org still works, you are probably trying to access https://search.cpan.org accidentally or via some browser weirdness, which doesn't work. There still need to be some improvements to the s.c.o-&gt;metacpan redirect proxy (as the "View on Metacpan" link on any s.c.o page, or replacing search.cpan.org with search.mcpan.org in the url) but it may be getting close to possible functionally to allow metacpan to handle all the traffic. Politically is a separate issue.
I'm sorry to have to remove this, but your assertion that SCO is "dead" is a case of "downformeoreveryoneelse" and i don't want to see rumours like that spread pointlessly. If you want to reopen the discussion with that, go ahead. But do make sure you got your facts straight.
Hmmm, that's interesting. Thanks for the clarification, and if it's up for most people, then that's fine. I do think you're being a little harsh, on the "get your facts straight" front. Perhaps you check downforeveryoneorjustme.com every time you see that a site is down, but considering SCO has been bashed for years, it was not a surprise to me _at all_ that somebody had just given up on it. In addition, it's not just down for me from home. It's down for from elsewhere also. So it's not _acting_ like a that sort of an issue, from my perspective. When a single site seems to be down, even if it's just for you, for a long period of time, and from different IP addresses, assuming the site is really down is a reasonable assumption. I just tried it from my cell phone (which I guess is something I never do), and it works. I'll see if I can figure out why it's down for me on my computer. Anyway, I'm not "spreading rumours," pointless or otherwise. Here's an example of how you might get the same message across without sounding like an ass: &gt; I'm confused. SCO is not down. I wonder why it's not working for you. Sorry for removing this post, but I think the premise of your question might be confusing to others, so that's probably best. Having said that, I'll go ahead and give you some measure of benefit of doubt, that maybe you're completely blindsided that you sounded like an ass to me, and you didn't mean it that way at all. If so, then I'm sorry that was how it sounded to me.
hetzner.de
It seems I have a stage VI infection. I may not have much longer. It‚Äôs been great, guys and gals. 
Yeah, sorry if that came across badly. English isn't my first language and my native one is quite blunt, plus i was a little strapped for time. Someone else suggested it is a http vs https issue, so maybe you found a bug?
Currently reading "Learning Perl," and this looks like a good guide to make sure I'm on track.
[removed]
Thanks for clarifying. Yeah, I saw that response as well, about http-vs-https. That sounded like a good one, but it works for me neither way. It turns out that it doesn't work _in Chrome_. In Firefox, it works fine. I happen to be in a hotel room at the moment, so obviously on a completely different IP address, and it still behaves the same way. I am being redirected every time to the https version of the site, even when I request the http version. My assumption is that it behaved this way at once time (forced redirect to https -- even though /u/grinnz says it never has), and my Chrome has initial http request cached, so it can't "forget" about the redirect. If I really wanted to go nuclear on the thing (I don't), I would just clear all of my browser cache and see if that clears it up. shift-reload won't work in this situation, so I'm kind of stuck. However, I just installed that Chrome plugin recommended by /u/workrestplay, so it wouldn't surprise me if I never have to think about it again. I was still never able to hate search.cpan.org as much as most people seem to. I guess I was just used to it. Like a lot of things, I still remember what life was like before it existed, so I never really got over the goodness of having it. I'm more used to metacpan now than I used to be -- obviously, because I've been having to use it, but there's just something about the older site that I like. Just resistance to change, I assume.
Might actually be your browser. My Chrome in Germany can load it just fine. :) And yeah, i don't hate the old one either and i still use it sometimes because its search works differently.
Hi, I am a total amateur at Perl web development, forced by necessity to make a web site for a fledgling community, being completely unused to other party's utilities, or any knowledge of how to use CPAN etc. Used shared hosting provided by Freeola, using one of their free domain names, and pay as you go FTP access. My apps tend to not depend on external modules, (I do use CGI.pm...which I am told is old hat, and some Device modules), are a simple home-brew CMS, a Raspberry pi controller/monitor, and a custom mini database engine. My experiences so far have been good. My bandwidth is always low, and I have near zero downtime, apart from the odd occasion that the service provider updates their software, and I find some settings have been altered.
Yeah, it's definitely my browser in particular. My theory that clearing _all_ of my cache would fix it turned out to be correct. I'm not sure you can easily clear the cache of a particular site. I was reluctant to do that, because I forgot that you can clear _just_ the cache without also clearing cookies (there thereby logging you out of pretty much everything). But I just went to the cache settings again, realized that it would be _just_ the cached files, and went ahead and bit the bullet and cleared my all-time cache. search.cpan.org was restored immediately.
Oh, I knew there was a reason I was reluctant to clear all that cache. Now none of my address bar autocompletes work, so it will take me a few days to retrain Chrome :(
Sometimes browser have bugs too. :)
Here is a script that will take any swiss protein format file as descrbed in [this location](http://arep.med.harvard.edu/labgc/jong/Fetch/SwissProtAll.html) and extract the sequence from it in fasta format. my $fasta=$swiss; #swiss cotains swiss formatted data #Extract the sequence which starts after line starting with SQ SEQUENCE if( $fasta=~m/SQ SEQUENCE[^\n]*\n(.*)/s){ $seq=$1}; #Remove unwanted whitespace (anything that is not A-Z) $seq=~s/[^A-Z]//g; print $seq
AH! This is perfect, thank you!!!
Well I think you are full of bullshit: until is a very nice and perfectly understandable english word, no ambiguity ever
To be fair, the absence of -i and -a command line options as well as the .1 seconds startup time and slow regexes make perl 6 suboptimal for common one-liner scripting
Never I expected to see Darkthrone here.
I would recommend avoiding `uwsgi`, just use HTTP with reverse-proxy settings instead: simpler and more reliable, plus you get more features. We used `uwsgi` in a deployment where each worker had to handle about 10k connections with long-polling - stability was poor and it lacked client-disconnect detection. Switching to plain HTTP improved things significantly.
 $ perl -e 'print "yes\n" if "file.pl -p 4" =~ /-p\s(\d)/' yes Works for me. What error are you getting?
Are you looking to parse options passed to your program? Are you looking at @ARGV? [Getopt::Long](https://perldoc.perl.org/Getopt/Long.html) is a nice module for option parsing... If I'm misinterpreting what you're really after, the following worked for me. my $var = 'file.pl -p 4 var'; print "match!" if ($var =~ /-p\s\d/);
That worked. I just had to see someone else code it haha. I'm using $ARGV[] in place of quoting -p and the number and was only entering the $ARGV[0]. Not the whole line... Thank you!
Well, you really should look into using Getopt instead, much easier.
&gt; We will not delete things from BackPAN if your reason is something like "oh that's embarrassing, please delete it for me". Suggestion: add something here about release of sensitive information (accidentally-included personal information, secret keys, etc.). Either "we will make reasonable efforts to remove it, but cannot guarantee removal from BackPANs" or "that ship has sailed, once it's out there, you can delete and reupload, but you will have to assume it's been mirrored and act accordingly." Either way an explicit statement would be good IMO. &gt; admin Good idea. &gt; If you upload something to PAUSE with a license specified, that license must give permission for the file to be copied to all CPAN mirrors (crossreference 2.2) &gt; If an upload does not include or specify any license, the act of uploading it does not imply any particular license. Suggest clarifying to avoid an apparent contradiction with 2.2. I interpret it as: the act of uploading does not imply any license besides the implicit license for PAUSE and CPAN to process and redistribute; i.e. uploading doesn't imply any grant of license to anyone receiving the file *from* CPAN, and doesn't imply that the contents are open-source software.
Nice list! Here's a few more, some of them strictly speaking not run by people in the Perl community, but still useful: - https://grep.cpan.me/ (and https://grep.metacpan.org/ when the former doesn't work) - http://irc.perl.org as an introduction to the Perl community on IRC - http://perl6intro.com/ as a place to dip one's toes into the Perl 6 pool - https://perl.meetup.com/ 
The `&gt;` character is due to your shell, (probably `bash`) interpreting your statement as "run `perl program.pl -qualifier inputFile.csv` and take `stdout` and redirect it to `outputFile.html`. You can read more about direction [here](https://en.wikipedia.org/wiki/Redirection_(computing)).
thanks. I've added them to the article.
With a &gt; in your command line, that character and anything after it gets interpreted by the shell, not by your Perl script. 
&gt; Suggestion: add something here about release of sensitive information (accidentally-included personal information, secret keys, etc.). Agreed. Mistakes happen (talking from experience here).
 my $argv = $#ARGV + 1; that's a rather roundaobout way of saying: my $argv = @ARGV; 
I see. I thought maybe that was the case, but wasn't able to find an answer online. Thank you.
Ah ok so stddout gets redirected to the file. I think I see. Thank you.
I'm new and trying to learn so I wasn't aware of that. Apparently there are many different ways to do the same thing in perl, so thank you for showing me a different way of accomplishing that.
you're welcome. this is the first time I saw someone using `#$ary + 1` btw :)
BTW, it makes no sense to assign the same values to variables twice: `($var1, $var2) = @array;` is the same as `$var1 = @array[0]; $var2 = @array[1];`.
Thanks -- all good suggestions!
You're very welcome. My comment is more than a bit simplified - shell redirection etc is quite powerful, I think you'll like it. 
Quite so, as is 'unless'. 
thanks a lot for this feedback
very interesting, thanks a lot. Below there is a comment from /u/tm604 that raises some concerns. What in your opinion on this?
Perl, of course. Why else would I be here in /r/perl - sure isn't for the jokes!
Oh yeah. I forgot to delete that before posting. It was just an attempt to debug because I wasn't sure if the previous assignment statement was working. Thanks for the tip though.
Indeed it is. After waking up I can't believe I didn't realize io redirection was going on here, and I was trying to open a file manually. Guess that happens when you try to code while tired. Again, thanks for the help.
I am working for a hardware company, so that is probably where they got the inspiration. 
here i cleaned it up for you. you had a couple problems A. the &gt; makes the output go to file outputFile.html. i do not think that's what you wanted B. you used the old file call, the new one includes the garbage collector. #!/usr/bin/perl use strict; use warnings; print "ARGV = ".@ARGV."\n"; #ignore, only to see what is read from ARGV print "Arg # $_ : $ARGV[$_]\n" foreach (0..$#ARGV); die "Incorrect Number of Command Line Arguments.\n" unless @ARGV == 3; my ($qual, $inputFile ,$outputFile) = @ARGV; print "$qual, $inputFile, $outputFile\n"; open(my $infile, "&lt;", $inputFile) or die "Input File cannot be opened.\n"; open(my $outfile,"&gt;" ,$outputFile) or die "Output File cannot be opened.\n"; 
I dont have 10K connections at once or need long-polling or client-disconnect notifications. I just have regular web traffic. I'd agree uwsgi is a little more complicated. Their documentation isn't the best and there are a million options. Each option is documented, but its hard to get big picture concepts. Reliability is fine for me ... just doing normal web stuff.
I am very glad about the clarifications to licensing for code uploaded to PAUSE. This recently came up as a possible issue on a distribution where the author decided his license was "the laws of physics".
Any opinions, anyone use it or play with it?
Perl is already too kludgey and really near its limits and they want to take it to 11.
&gt; I am very glad about the clarifications to licensing for code uploaded to PAUSE. This recently came up as a possible issue on a distribution where the author decided his license was "the laws of physics". Your statement is a bit ambiguous. Just want to check that we are on the same page - you do agree that the dist/license in question is perfectly reasonable as far as the document we are discussing is concerned. Yes?
I'm not sure whether the author's choice of non-license (he was progressively less specific) satisfies the needs of CPAN to be able to mirror the code, but this document at least lays out what is required or will be assumed for code uploaded to PAUSE.
Title seems a bit confused; perl11 is the 'project' that contains several perl offshoots including this (cperl), rperl, and others. http://perl11.org/
I have used cperl before and is really fast. It is a shame p5p do not accept cperl patches.
It is a solid, and in places really exciting, piece of work. Author goes out of their way to provide compat-patches to make CPAN work to a large degree within the interpreter: https://twitter.com/ribasushi/status/719793279655669760 It makes tradeoffs which are completely opposed to what I am personally seeking from the language, so myself have no use for it, and stopped tracking its development about a year ago. But if you are into native types and strict(er) compiletime checks - I definitely recommend taking a look.
Follow-up to my grammars talk linked in the videos section of TFA: * [slides](https://github.com/daxim/talks) * you can install [Grammar::ErrorReporting](http://modules.perl6.org/dist/Grammar::ErrorReporting) so that the parser returns something more useful than `Nil` (most other parsing libraries have built-in error reporting) * Perl6 bug report [grammar cannot parse from Blob/Buf](https://rt.perl.org/Ticket/Display.html?id=132003) * Perl6 bug report [infinite loop with grammar](https://rt.perl.org/Public/Bug/Display.html?id=132004) When I can set aside a large enough block of time, I want to revisit Pegex (Lichtkind told me I used it the wrong way) and add some more parsers from CPAN into the comparison.
Why is that? you have a link to info?
This seems misrepresentative. p5p has banned Reini from participating on the list due to his refusal to refrain from personal attacks after many, many warnings (for instance, https://code.activestate.com/lists/perl5-porters/221747/). Many CPAN modules may not take his patches that serve no purpose other than "supporting cperl". But otherwise I don't know of any particular refusal to review helpful patches that originated from cperl.
Perl 6 is still a thing?
Yup :)
Bad bot.
The thing is that '++', while a valid Perl operator, originated from C (or maybe BCPL?). Naming C++ as such made sense since '++' was quite an idiosyncrasy of C. Visual Basic became Visual Basic.Net What's something that is inherently Perlish that would denote increment or upgrade?
Python 3 is a new version of Python 2. It's not a close example at all.
It's _exactly_ a close example. Perl 6 started off as a new version of Perl. Only recently people started claiming "oh Perl 6? Oh, it's totally a different language." Plus there is a lot of people out there who'd rather stick with Python 2. How is it "not a close example at all" again?
Perl 5 and Perl 6 are developed by unrelated teams and will continue to be for the forseeable future. Python 2 and Python 3 only have one BDFL, the only way Python 2 development will continue is if it's forked, as is made clear [here](https://wiki.python.org/moin/Python2orPython3). How Perl 6 was intended 15 years ago doesn't matter much now, and keeping the name as if it did only serves to confuse people and damage the reputation of both languages.
Perl++ would do the job nicely; it would be completely obvious what was meant. A new language: with good, deep, roots - but a new language. 
Perl Linear A.
If it was my choice I'd call it "viper". The "vi" is 6 in roman numerals and the "per" is "not quite perl". 
Yes, it should.
"viper" reminds people of "python", and it's smaller in size than python. 
As are your programs if you write them in viperl6lang rather than python. ;)
the Perl version should be bumped to 26, replacing the major version number with the minor version number ... others did it too, Java for example
&gt; Only recently people started claiming "oh Perl 6? Oh, it's totally a different language." It's not just an arbitrary claim. IMO there're very few similarities between the two languages. I'm yet to hear anything other than arbitrary and vague "they're the same in spirit" when I ask what's so similar between Perl and Perl 6. Sigils. Types. Operators. Core features number. All different. Even this basic one liner produces different results depending on whether it's run with Perl or Perl 6 compilers: "0" and print "I am a Perl 6 program\n" or print "I am a Perl program\n"
That still has "Perl" in its name, which is detrimental to the language IMO. Renaming from "Perl 6" to "Perl++" is a pointless exercise IMO.
Perl++ has been proposed years ago, didn't seem to catch on.
This has been done. But didn't seem to catch on. Everybody's still saying "perl 5.26" or "I have perl version 5.26 on my system". % perl -v This is perl 5, version 26, subversion 0 (v5.26.0) built for x86_64-linux ... 
Dimond?
... I'll start calling Perl 5 using "Perl " . $version_number then ... for example "Perl 18 has improved the memory management, it will return more memory to the system when strings go out of scope" 
I was thinking about learning Perl 2-3 years ago. Without knowing much about Perl6 and how it pertained to Perl5, I thought I was making a natural jump by putting my attention on P6, considering the former near obsolete. What kept me waiting was the fact that there didn't seem to be a lot of resources to make Perl6 useful, so I pretty much held back from learning Perl. Only did I look back to find that it was essentially a new language did I come back and really tried to learn Perl (P5). Naming Perl6 does give the wrong impression. Should have just stuck with Rakudo from the beginning.
Increasingly a thing.
Like C++ still had C in the name and which stopped it from being such a big success? 
No, like "Perl is an archaic, unreadable thing no one uses" that's in common circulation among modern-day programmers, so it isn't a useful term to label a new language that's nothing like Perl. The two blog posts OP linked to expound the reasons for renaming and "Perl++" as a name solves none of the listed problems.
Your troll is showing... 
I was watching Reini‚Äôs video about cperl on YouTube. An Amsterdam 2017 YAPC. He showed many speed improvements and also complained that his patches has not been accepted on Perl 5. On this video he has also mentioned that the @INC bug/fix was found by him but no one listen (kind of). I was not aware of his personal behavior. 
I found this information on this video: https://youtu.be/60gkNmDWyes 
I stand corrected.
Thanks. OP's article should be linked to /r/perl6, then.
Because I disagreed with you? OK then.
It should be named anything but Perl.
No, it isn't, and spamming it where it doesn't belong, in a sub for Perl, is fucking obnoxious, and the mods need to fix it.
Perl 6 is not Perl. Stop spamming this bullshit.
Perl 6 is not Perl. Stop spamming this bullshit.
It's not Perl and it shouldn't have Perl in the name.
Perl 5 is used by millions of people; Perl 6 is garbage that will never be used by anyone, because it's garbage. That's why it shouldn't have Perl in the name.
The current description for this sub reads: `The Perl Programming Language, including both Perl 5 and Perl 6.`
&gt; Perl 6 is garbage that will never be used by anyone, because it's garbage Seems like an easy solution is to fix whatever it is that makes it garbage :) What is it?
Rakudo came much later. Perl6 was being laid out in the early 2000s.
I read around something Lang 6. 
It's not trolling, it's an unfortunate example of the attitude many people outside of the Perl echo chamber have, as you can see whenever Perl is brought up in a thread on /r/programming for instance. Which is why the association damages the reputation of Perl 6 before people even try it.
In the early 2000s, it was intended to be the next version of Perl.
&gt; it isn't a useful term to label a new language that's nothing like Perl Do you think naming it Rakudo, or Camelia - or literally anything else - will make people forget it started out life as the next version of Perl? We need to own it. Own it or forget it and walk away, which I don't want to do thanks. 
&gt; Do you think naming it Rakudo, or Camelia - or literally anything else - will make people forget it started out life as the next version of Perl? No, it'll make them look at it for more than 5 seconds, without instantly rejecting it just because someone made a "line noise" joke at some conference. The renaming undertaking isn't about erasing history. It's about removing barriers that prevent people trying the language in the first place.
I haven't used Perl since the early 2000s. Are they still making it some weird VM thing? I loved Perl5 and these days saying "Perl" out loud makes my coworkers look at me like I was a dog who'd just had an accident on the rug. https://en.wikipedia.org/wiki/Perl_6#Major_changes_from_Perl_5 https://www.quora.com/Why-is-Perl-6-considered-to-be-a-disaster I'll leave further googling as an exercise for the reader. 
You're ignoring what I said about owning it then. 
What do you mean by owning it?
The links say it took too long, which is true, but it has been "finished" 2 years ago in a sense that there's a stable spec now. The other critique as I understand is it's different from Perl 5... but if your coworkers look at you that way about Perl, surely both being different from Perl 5 and‚Äîthe subject of this thread‚Äîrenaming away from "Perl 6" to be more accurate about it being a new language is a good thing? Perl 6's development process did cause damage, but I'm failing to see why it makes *the current* product *"garbage that will never be used by anyone"*
&gt; it has been "finished" 2 years ago in a sense that there's a stable spec now I'm not sure this is helping in the way I think you intended.
No, it's pretty accurate. I have no illusions that the spec was sparkling 2 years ago, while at the same time I don't think the "it still isn't finished" claim from second link applies today.
I mean that trying to remove those barriers *looks* like pretending Rakueelia++ doesn't come from Perl. We need to be proud of it, and not apologise for the idiots who wrote line noise and called it programming. 
@myArray is an array, not a hash
ok, so I have an array of hashes but still without iterating over the array of hashes, how can I check if a value with $word exists in the {member} property of the array of hashes?? 
Using the data structure you have currently, there's no way to avoid iteration. That information just isn't available. If you want to be able to efficiently check for records containing a word, then you need to create a data structure that allows that. An example might be a separate hash that works as an index, and which has every word as keys and a list of references to the corresponding records.
understood. thanks
You can be as proud of it as you want, but changing the public perception of Perl is easier said than done. Harder still is doing it with a language that's very different from Perl.
you want to add your \%ArchiveKey hashes into an hash. my %myBigHash; for () { #... my %ArchiveKey = ( .... ); $myBigHash{lc $member } = \%ArchiveKey; } # .... if (exists $myBigHash{$word}) { } 
Ok, I can see I'm not going to convince you, thanks for listening anyway. 
&gt; at the same time I don't think the "it still isn't finished" claim from second link applies today Everybody else: P6 still isn't finished. Rakudo developers: It is! Here's the spec! Everybody else: I don't care about the spec. It isn't finished! Rakudo developers: Pay no attention to the bait and switch game we're attempting to play with pronouns! It is stable! We're still polishing it! An implementation mostly implements the stable spec! The next version of the spec is coming! Everybody else: Our eyes have already rolled away again.
üòÅ
let's say ArchiveKey has three pairs index member count for item $word how can I then get the index of that item? doing this just gives me garbage: print $myBigHash{$word}{index}; 
So I've been away from the Perl 6 scene partly because y'all can't stop fighting about it. One thing I've noticed after reading through these comments: there seems to be more optimism about Perl 6 (yes, name and all) *outside* the Perl community than what y'all got going on. So smarten up, call it Whatever, something marketable, don't listen to you-know-who and press on. PLEASE.
you mean rakudo6viper?
Hate to jump on the bandwagon but rakudo belongs here as much as lisp posts
 $str =~ tr/a-z A-Z'-//dc; should do it.
I like viper, but it's a bit close to python, and would have a logo confusable with python. How about ratel (aka the honey badger)? It ain't beautiful, but it's a mean bastard: https://www.youtube.com/watch?v=4r7wHMg5Yjg It eats snakes! 
What do you mean? The subreddit description reads: `The Perl Programming Language, including both Perl 5 and Perl 6.`
What would you call perl 5.6 then? :) 