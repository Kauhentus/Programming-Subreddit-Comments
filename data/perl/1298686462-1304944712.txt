I first used Schema::Loader when I was learning DBIC / Catalyst, but have since forgone it for the simplicity of not having to care about SQL.
That works as long as you don't have to do 'interesting' things in your database. DH handles schema versioning, it's more like deploy than loader.
This coincides with the [7DRL challenge](http://groups.google.com/group/rec.games.roguelike.development/browse_thread/thread/924204b3b910be48?pli=1) (Seven Day Roguelike), so two birds can be shot with one implementation. 
you started her well. modern perl + catalyst ;) good job.
Looks interesting. I have a project due soon that involves web crawling, so this will be fun to try.
I agree with the first comment there, this is something any good package manager should have built in. It drives me crazy that *no* programming-language-specific module installer seems to do this.
I saw "Object Relational Wrapper" and thought "hmm, that's a weird way to write 'DBIx::Class'..."
So, Perl5 is a dinosaur? :)
But, unlike the actual dinosaurs, it's still around and in great use. Perl is old as dirt though.
an agile dinosaur.. but apparently still a dinosaur. 
A pretty damn badass dinosaur that survived to dominate the food chain!
Have you tried email? Last I knew the author was incrediably responsive to communication from users (you know--- us!) and given the on going nature of the problem and the (just guessing here) simple nature of your request, this should be the simplest way to get from a to b...
Extinct but re-born. Can't be contained by mere fences. P E R L 
"Look ma, no SQL!" I get the need for DBIx::Class, but I never got this approach. For what it's doing SQL, is a fine language. In fact, I still don't use DBIx::Class because I tend to find writing my own api relevant to the application can work just as well with the complex cases.
**JURASSIC PERL** Badass
The question remains, can Perl be used to determine if your neighbors are velociraptors? I say, yes.
I love the riff on dinosaur.
[i thought Perl 5 already had a logo?](http://www.perlfoundation.org/static/images/foundation/tpf_logo_150x79.png)
That's a funky looking camel, son.
http://oreilly.com/pub/a/oreilly/perl/usage/ &gt; We've also trademarked the association between particular animals and the subject of their books. After all, the only reason that people think of camels in association with Perl is because we used a camel on the cover of Programming Perl. 
You can't trademark a camel. Only particular likenesses. 
So, a retarded dinosaur. Sounds about right.
A dinosaur seems a fairly arbitrary choice, what was the reasoning here? Also CPAN doesn't always find away, otherwise I wouldn't be adding my own modules to CPAN - so this tagline feels a bit misguided.
Sounds like you're suggesting that you know more than O'Reilly's trademark lawyers.
Perhaps Perl should consider potentially litigious private corporations as damage and route around them.
You are CPAN!
Disney can't trademark all cartoon depictions of a mouse. Only a particular likeness.
They didn't trademark camels. They trademarked "&lt;animal x&gt; on cover of book about &lt;language y&gt;", with the possible combinations of x and y probably being strictly defined.
IIRC, O'Reilly have sued people in the past for using the term "Web 2.0"(™) without permission. That's the sort of people being dealt with here.
 use Regex::Dromaeosauridae; for ( @neighbours ) { if ( $_ ~~ velociraptor ) { warn; die unless house_secured; } }
In the case you're thinking, they issued a cease and desist to the organizers of a conference who used Web 2.0 in the name of a conference. Given a trademark on the use of the term to describe a technical conference and the unfortunate "defend it or lose it" nature of trademarks, their actions were understandable... ... not that I defend using a trademark owned and enforced by a privately held corporation as a logo for a community produced project. (For example, my company publishes books about Perl. Why should a company which no longer publishes books about Perl have any greater say over a Perl logo than my company does?)
Can you post an example of what you mean?
Can you post an example of what you mean?
Clever girl.
This is how I would format this: func valid_calculation_type ( $type ) { my @valid = qw/concatenation lookup date_formatter substitution/; return ( $type ~~ @valid ); } This is how perltidy tidies it func valid_calculation_type($type) { my @valid = qw/concatenation lookup date_formatter substitution/; return ( $type ~~ @valid ); }
Oh, dear. I read that as "Can't be contained by feces".
Clever Perl....
To me it looks like a pretty damn badass dinosaur that scares potential new students of Perl. 
It quite saddens me to see that Perl is slowly "dropping out of favor". I've been programming Perl far longer than any other language, and it's by far my favorite. Maybe this is just one more thing to add to my resume to make me awesome.
[This](http://radar.oreilly.com/upload/2011/02/AllYearsT20Langs.jpg) seems to bear out the author's fears, too.
The "debate" linked to seems a fairly friendly discussion with most people in agreement that the docs need updating. I'm confused where the hostility is; maybe I missed something.
I would say the post by Abigail was the only one that approached the line. The documentation should explain the usage of OO in core Perl and point to better ways with explanations of why the others are "better".
&gt; I'm confused where the hostility is.... Read the existing documentation while pretending you've never written OO Perl 5 before, or any OO code. After you've done so, how confident are you that you can write good code?
Plain old, ancient CGI? There is no setup. Write your script, `chmod +x` it, then tell the webserver to execute it when an URL gets hit.
I don't take that chart seriously for Perl for one simple reason: it demonstrates only that the market leader for Perl books stopped producing new Perl books. Any other conclusion you draw from that needs better support from the facts. (Note how carefully every "State of the Computer Book Market" report fails to discuss the ratio of frontlist versus backlist titles, the change in title efficiency per topic between years, and the standard deviation in revenue between titles of the same topic. You'd almost think the lack of *meaningful* data and analysis were intentional.)
For which web server? Apache? As flussence says, just chmod +x and then (lazy way) stick it in the pre-existing cgi-bin directory (which most Apache installs have by default). It should be at http://localhost/cgi-bin/myscript.cgi unless Apache is not vanilla configuration. Be sure you know where Apache's "logs" folder is, and tail -f error_log (or whatever the error log is called on your system).
I actually wrote up a howto on this awhile ago... Here ya go. http://serveradmins.net/howto-enable-cgi-in-the-builtin-osx-webserver/ 
AddHandler and ExecCGI statements aren't enabled by default. 
Do you already have Apache running? EdIt: Depending on what you're using the CGI for (ie running a prepackaged cgi, or rolling your own for something) you might want to check out [Dancer](http://perldancer.org) which can run stand alone, through Apache, or anything else that supports [Plack](http://plackperl.org/). Dancer, imho, makes perl web development so much easier.
Please ask questions in a more appropriate venue like StackOverflow or PerlMonks. Reddit just isn't a good Q&amp;A forum.
They aren't enabled by default in lighttpd or nginx either, and the OP never specified what webserver he was using so being specific is kind of hard.
Neither of those ship with OSX and the chances are that if he source built/installed them, this thread wouldn't be here. 
&gt; While I like Cameila It is an awful logo. I thought it was a joke the first time I saw it... The Camelia done by the same guy who did the dino logo for perl5 is really nice and likeable: http://blog.kraih.com/a-logo-for-perl 
I guess I just don't equate antiquated or poorly written with hostile. And the "debate" about updating them seemed to mostly be about the confusion between tutorials and documentation. FWIW, I don't think core docs or tutorials should be about Moose. They should mention Moose as a semi-popular option and probably link to the moose docs for more details. Most of the Perl world doesn't use Moose, despite the beliefs of some of the high-profile community members, so making it front and center for tutorials seems a bit premature, especially given that it's not included in core.
I agree. It looks ugly and cartoonish. The one you link to is a step up but it has gradients that don't look quite right when printed in black and white. Perl needs a logo that everyone can use and that people will recognize. Unfortunately the camel logo is copyrighted to O'Reilly and the onion logo belongs to The Perl Foundation. Any idea if it would be legal to remake the camel logo so that it no longer falls under TPFs copyright? Seems to me like that would be a good direction if it's legal; people already mentally associate perl with the camel.
&gt; I guess I just don't equate antiquated or poorly written with hostile. Try my experiment. &gt; Most of the Perl world doesn't use Moose... ... which is fine, but remember that most of the Perl world probably doesn't use CPAN either, which gets to the heart of the problem. (If it's okay to *keep* clunky, outdated, user-hostile features in the core and outdated documentation demonstrating the clever abuse of those features as if they were best practices or even representative of what really good Perl 5 programmers do regularly because the CPAN exists, there's a huge problem.)
&gt; Any idea if it would be legal to remake the camel logo so that it no longer falls under TPFs copyright? You mean trademark and O'Reilly and the answer is most likely "no". Why would you want to prop up the branding of a privately held corporation anyway?
Odd. Every Perl programmer I've ever met uses CPAN, and precisely one of them has ever used Moose. Small sample set and all that, but I'd be surprised if more than 20% of Perl users have never used CPAN. It's one of the major features of Perl.
At my current company exactly none of 5 perl programmers use(d) CPAN and Perl is one of the core technologies responsible for earning money.
Because the association is already there. I don't care about sending people to them, I care about promoting Perl. Getting people to mentally associate a new logo with anything is hard and takes time. If we are going to have a new logo for Perl then it would take less for people to switch to another camel than to something completely new. I would be in favor of a raptor logo, sans the butterfly wings.
Chromatic, I have the Slash book, the hacks book and the testing notebook. I think you're a great hacker and writer. And I look forward to getting your Modern Perl book 2nd Edition - Perl 6 ;)
The second edition of the Modern Perl (5) book will cover Perl 5.14 or 5.16. Perl 6 by definition is far more than modern!
Hashes aren't light on memory comparatively but generally you won't notice a problem. If your sets are massive (enough to run out of memory) then you may need to play tricks to reduce hash levels but I've only heard of that single digit times.
It's hashes and turtles all the way down. As far as I know, Perl doesn't impose limitations of the complexity of a data structure. The only real limitation you will run into is space in memory or hdd. In my limited experience, I have found it best to use whatever data structure is the most intuitive and/or easiest to maintain.
&gt; book will cover Perl 5.14 or 5.16 Sounds Modern enough for me. 90% of the code I manage daily is still on servers running 5.8.8 &gt; Perl 6 by definition is far more than modern! Whatever you do, please don't name the book *Post-Modern Perl*
&gt; 90% of the code I manage daily is still on servers running 5.8.8 ditto. Basically, up to know, new releases did not offer THE update that would have pushed people(hear firms) to update. They would update if it would offer a better oo system, mainly,I think(new,method,super keywords for example would be THE features). Everything else is a nice have,it comes in handy once in a while for some scripts but not must have imo.They need an update that would help envision new horizons of development. 
Problem is, I can't see Perl5 changing very much. Significant changes (even ones proven to break only the craziest of code) often get so bogged down in arguments about backwards compatibility and the "DarkPAN" that they never happen. And because the changes that do happen are carefully designed to be backwards compatible, upgrades can be avoided for a very long time. (Of course the obvious answer of incrementing the major version number in order to make changes that break backwards-compatibility is unfortunately not an option available to Perl5 ;))
That'll not tell you what core modules are included with your Perl installation. It'll tell you what core modules *should* be included. It doesn't account for the fact that vendors remove core modules for arbitary reasons, leaving the user with a more or less broken Perl installation. [See brian d foy's post on this very issue](http://blogs.perl.org/users/brian_d_foy/2011/03/a-modulecorelist-for-vendor-distributions.html). 
many applause Moose because thanks to this module, perl has a "proper" oop mechanism available. I will also point out that because Moose is being used widely that perl core may not be able to take the risk to upgrade it to keep backward compatibility with such code base. But as for all the new elements up to now, making them a feature you use would make sense and should certainly avoid breaking things(?). 
&gt; But as for all the new elements up to now, making them a feature you use would make sense and should certainly avoid breaking things(?). You'd think that, but even if you can prove that no existing code could ever break--accidentally or otherwise--it's still difficult to add new features to Perl 5.
&gt;but even if you can prove that no existing code could ever break--accidentally or otherwise--it's still difficult to add new features to Perl 5. I can understand that adding new features, with such a code base, is something that merits consideration but it can feel discouraging sometimes. Thanks to CPAN testers, shouldn't we be able to have a very good overview of what could break by simply adding a new feature that is not even used? 
I think you should focus on writing your app first and only think about memory optimization later if the program has to start hitting swap to finish. You can use things like [Devel::Size](http://search.cpan.org/perldoc?Devel::Size) or [Devel::Size::Report](http://search.cpan.org/perldoc?Devel::Size::Report) to see how much overhead your structures have if you really want to know. &gt; Do the length of the values matter in the hash? I don't understand this part of the question. Of course the length of values matters to how much memory your script will require. For example, using strings instead of integers: $fruits-&gt;[10]-&gt;{type} = "apple"; $fruits-&gt;[11]-&gt;{type} = "orange"; $fruits-&gt;[12]-&gt;{type} = "banana"; vs my %types = ( 'apple' =&gt; 1, 'orange' =&gt; 2, 'banana' =&gt; 3 }; # you would generate this automatically instead of typing it out by hand like this, but this is just to show you what the variable would hold ... $fruits-&gt;[10]-&gt;{type} = $types{apple}; $fruits-&gt;[11]-&gt;{type} = $types{orange}; $fruits-&gt;[12]-&gt;{type} = $types{banana}; Of course this only make sense if you have a lot of repeated values, e.g. there are 12 different fruit types but 1000 total records. But this has nothing to do with hashes themselves, it's just that storing a bunch of copies of strings when they are from a small pool of values is quite redundant. You would have the same problem regardless of whether you used hashes or not. (Generalize fruit names to any repeated string value that could be stored more readily as an enumeration, for example "Connection refused" or "Successful transfer.") 
Update: found out that just cpan bla::bla from the command line also works, but this makes my bat hang with no output. I wait forever and it doesn't seem to do anything.
Update 2: perl -MCPAN -e "install Package::Module" Exits out of the CPAN shell back to DOS after completing. Once again though, no use in the .bat. It just prints the command over and over again.
Update 3: Found the solution!
Start off assuming it won't be a problem. It probably won't. Perl hashes are pretty fast (with any number of keys), there's no limit on depth except memory, and common keys are shared -- so if you have a million hashes all with the same ten keys, those ten key strings are only stored in one place, meaning most of the memory is spent on your *data*.
psst, don't capitalize his name or he'll get mad ;)
After 16 years of working in Perl nearly daily and on some rather massive systems for several Fortune 500 companies, I have only once ran into a situation where a naive solution for building hashes didn't work. Now, if you're thinking about storing statistics on daily events, you might want to look at DBM::Deep for your storage solution instead of Storable or the like.
Web::Scraper is so effin awesome. You just yank up some LWP from disk, add some scraper to it and whambo!! Youse gots urself some local data that the web universe used to call it's own. Follow that author on CPAN... he's a genius.
miyagawa is an institution
I'd guess Rakudo Star was released at the same time as GHC 7.0. And, Haskell won.
I've run out of memory several times attempting to do huge in-memory sorts in Perl (with hashes, natch). It's not really odd that this could happen, but I was surprised to see Perl's memory use spike up to over 6 times the size of the on-disk data set.
You have what, a couple gigs of ram? They can go pretty deep. Long running scripts may leak memory if you're not diligent in how you maintain the longterm hash. This would cause the script to be killed by oom eventually. Past that, actually testing is the only way to give you a definitive answer.
All it takes to scuttle a new feature is someone suggesting that the DarkPAN may somehow contain even the most egregious abuse of syntax and common sense in, of course, a critical business application that must obviously migrate to the latest stable release of Perl 5 under the guidance of people who know nothing about Perl, have no tests, couldn't possibly audit their system, and have a staggeringly irresponsible inability to read the changelogs. Strangely the people concerned about p5p performing system adminstration for these nebulous hypothetical systems never seem to volunteer when *I* need work done on my machines.
Are you saying GHC and Rakudo have a lot of devs in common?
If that graph measures commits to trunk, it doesn't reflect the prototyping work Jonathan has been doing for several months for a new metaobject system.
Look into Devel::Leak::Object and Devel::FindRef to see if you can narrow down where you're actually leaking. I've never run into this particular issue myself, but I did use those tools to figure out that HTML::Mason leaks component objects that have %shared sections just today.
We use postgres exclusively, and we have never run into this issue. Perhaps if you give more specific details, it would help -- perl version, DBI/DBD versions, DBIx version (if used), etc. Can you reproduce this issue outside of your application? That is, does it present itself with a simple connect, prepare, execute loop?
Agreed, that logo is a design abortion.
I'm disappointed this article did not have hand formations for Butterfly and Velociraptor for use in RPS-5.
For the past six years, my job has been loading huge quantities of data into databases. When I left my last team, it was 2, 500, 000, 000 records a day, in duplicate ... a side and b side. Never had memory leak problems.
I'm only doing about 40,000 a day, at most. I'll go back over it tonight (personal project) when I get home, but I don't see where there's any other opportunity. But you can sit there and watch it gobble 100k every minute or two. I still have a few scalars in the loop that get the value reassigned, but no hashes of my own. 
I'm actually experiencing these problems right now as well. Instead of spending any more time tracing the leak, I just stop the process after processing n records and start back up again where I left off. I'd love to hear about how people have tracked down these leaks though. Maybe in some spare time I can fix it up right and end the hackyness.
Wow...that's an incredible amount of data.
Please ask Perl questions on a more appropriate forum (like Stack Overflow or Perlmonks). Reddit isn't a good QA forum.
Mind... Boggled. How can a Perl programmer *NOT* use CPAN?
Thanks for the info. Very much appreciated. I guess the thing I was thinking about in terms of length was whether having longer keys would decrease the speed of the hash retrieval. It is probably negligible unless the key was enormous, and I won't be running into that. 
I just came across DBM::Deep today, so I will take a closer look at it. I was starting to use Storable, but I hadn't really determined my storage mechanism. Thanks
You can call 'has' from within a method as long as you haven't already called 'make_immutable'. Does that help?
Oh that's interresting, thank you. But I was more looking for something like $self-&gt;errors-&gt;feature1, a bit like associative arrays ($errors{$device}{'feature1'}++), this is how I usually code.
why not `$self-&gt;errors-&gt;{feature1}` ? That doesn't take any special doing, just has 'errors' =&gt; ( isa =&gt; 'HashRef', is =&gt; 'rw', default =&gt; sub { +{} }, ); 
That was exactly what I was looking for, thank you. It's special for me, I'm a noob, sorry if it sounds stupid.
Listen man, I don't want to be a bringdown from your Moose parade, but aren't you stepping out of your promotion schtick and into dissing others' shit?
Have you run valgrind on it?
I must've missed it, what did he diss? Also: He didn't explain the why in the first draft of the article, but he's right. Sub-classing non-moose classes with Moose will leave you unable to do certain things with your new class that you could do with a full moose class, like method modifiers. So it's better to have a new class wrap around the one you want to modify.
By writing in a C-like style and CONSTANTLY reinventing the wheel. (Example: They rebuilt database indexing mechanisms in perl using 8-deep hashes to avoid having to use a real database.)
We had a similar problem with a long-running backend script. After much research and raging, we came to the conclusion that we would have to do some defensive programming to manage memory leaks and other excessive memory usage scenarios. So what we did was have our backend scripts load all their required modules and configuration, and then fork to create a connection to the database and do work. This forked process would run until it reached a certain memory size, and then exit, and it would be restarted again. The cool thing about forking this way is that copy-on-write features on modern OS's cause the forked process to only require additional memory equal to what it actually needs on top of the parent process (plus a little overhead). Since the parent process isn't doing anything except forking new child processes occasionally, its memory usage won't increase significantly over time. Child processes will free their memory each time they exit. Here's some example code: package My::Process; use Moose; use My::Schema; use Carp qw( croak carp ); has memory_limit =&gt; ( is =&gt; 'ro', isa =&gt; 'Int', default =&gt; 256, # Megabytes RSS (Resident Set Size) ); has _schema =&gt; ( is =&gt; 'ro', isa =&gt; 'My::Schema', lazy =&gt; 1, builder =&gt; '_build_schema', ); sub _build_schema { my ($self) = @_; return My::Schema-&gt;connect(...); } sub _memory_usage { my ($self) = @_; # Parses the RSS (Resident Set Size) from ps. my ($KB) = qx{ ps -p $$ -o rss= } =~ m{ (\d+) }xms; return int( $KB / 1024 ); } sub run { my ($self) = @_; while (1) { my $pid = fork(); croak "Failed to fork: $!" if !defined $pid; if ($pid == 0) { # Child process does the work. $self-&gt;_run(); exit 0; } else { # Parent process waits on child process. waitpid $pid, 0; } } } sub _run { my ($self) = @_; RUN: while (1) { # Do something useful with $self-&gt;_schema # Since it's a lazy attribute it won't initialize # and connect until its first use here. ... # Finally, after every batch of work, check our # memory usage and exit if we are over the limit. last RUN if $self-&gt;_memory_usage &gt; $self-&gt;memory_limit; } } 1; 
Hey, *I am* the official troll of Perl 6. Find your own turf. And even I have to admit that you'd be quite a fool to make conclusions based on a single graph. But it's a good *trolly* thing to do.
Yes, but I'm not sure I understand the output enough. 
Wow, and people say I'm a troll.
treenaks, why did you delete your post?
This is the great thing about the perl community -- there really aren't any stupid questions. (Without turning this into a flamewar...) this is what makes perl insanely great: the community. It's the community that's created CPAN, the support (via perlmonks, irc, and here among other places), and the general atmosphere of helping those that are less experienced than you -- without condescension.
I have no use for Perl Tidy or other source code style hammers except for maybe cleaning up a large amount of old code that someone else wrote. Coding is an art, and I feel like it's my responsibility to know how to format code for readability and maintainability. It's also satisfying to write code that performs well *and* looks clean and readable. In my experience, developers who want Perl Tidy are the ones who not only lack the skills necessary to style code for readability, but may lack skills in other areas and do things like: * endlessly chain if-else-elsif blocks together that compare a string instead of using a switch statement * give their variables names like $data, $segment, or $security_controller_default_action_hook_sub * still use indirect object notation It takes some upfront investment learning style guidelines and seeing what looks good, but after that it doesn't take any longer to write beautiful, readable code than to mash out the minimum that works and let Perl Tidy try to clean up the mess. I wouldn't want to read a book where the author pounded out the entire story in all lower case in one paragraph and then ran it through Novel Tidy. It might look good superficially, but just like Perl Tidy, it can't replace the styling skills of a human.
ಠ_ಠ
The joke was so bad it was funny.
neodon: redefining the one-liner.
I lol'd! :D
LOL! I wish I could say it was auto-capitalization from an iphone or something. It's not. I committed the blasphemy myself.
&gt; All it takes to scuttle a new feature is someone suggesting that the DarkPAN may somehow contain even the most egregious abuse of syntax and common sense in, of course, a critical business application that must obviously migrate to the latest stable release of Perl 5 They just,don't migrate right? &gt; Thanks to CPAN testers, shouldn't we be able to have a very good overview of what could break by simply adding a new feature that is not even used? 
&gt; They just,don't migrate right? That seems like an obvious solution, but apparently there are a lot of people who have vast amounts of Perl 5 code that absolutely must never stop running but no tests or other change management processes.
OK, several reasons: * one of the core committers has a rough time in real life. And that is a bit of an understatement. * as chromatic points out, the graph only measures commits in the master branch * lots of work happens in the [nqp](https://github.com/perl6/nqp/) repository (also in branches), in preparation of moving to a new meta object model, which is based in nqp (nqp is used to build rakudo, so it makes a lot of sense to stuff it there, and later import it in rakudo. That way it is also available for other nqp based projects) 
Can you elaborate on what you mean? I will happily revise the tutorial when I receive some constructive feedback. My goal is simply to help people learn how to accomplish /their/ goals.
This proved very true in my case.
thank you xkcd.
Well, the problem I see is probably fairly specific to my work environment, but I doubt it's uncommon. We use the perl RPM from CentOS (which is sadly still 5.8.8), and all CPAN modules have to be installed via RPMs as well (per my boss, but it does make managing things easier). Many times we need to upgrade a specific module for a specific bug fix, but when that module is included in the core perl RPM, then we have to jump through more hoops than you'd imagine to make sure all the generated files end up in the right locations (you can tell RPM to overwrite them, but then you lose the ability to rollback, so it is forbidden). So, in that regard, I'd rather that absolutely nothing beyond the very basics is included in core. If we rolled our own perl RPM, then the situation would be a little different, but even then we'd be more likely to upgrade a module than our version of Perl itself. Decoupling is a good practice for system administration as well.
Moose
What if there were an perl-extended-core RPM or DEB?
Same here, they should teach perl in high school, as a secondary language.
about 30 packages were listed... I listed them up in a poll: http://poll.pollcode.com/uMt I would go for: LWP DateTime(+ formatters) Try::Tiny JSON::XS perl5i List::MoreUtils
Socket6! WHY THE SHIT ISN'T IPv6 SUPPORT CORE YET?!
Speaking of Task::BeLike:: someone should write a tutorial for whipping one of these up. I've never actually uploaded anything to CPAN, and this is probably the best thing to start with. =D
one vote for DBI and one for LWP! Although I use DBI all the time, I don't really see it ship with perl core. 
I had some very large, fixed format input files to bash into a database at work. There was a some garbage in them: carriage returns, private accounts that needed deleting, wrong line lengths. I was in a state of despair because they needed to be done soon. A friend was good at perl and wrote a few scripts that cleaned them right up. Most were one or 2 lines and magically filtered out the crap. Lets just say that I read a certain chapter of a certain book titled "The gory details" and it has been a life saver ever since. I don't program perl all the time but once a year or so, I pull out the camel book and browse that big chapter for when I need the skill.
For a quick and dirty program, nothing beats perl. Stream files in? No problem. Filter text into a string variable? Done. Chop out the data you need? Done. Even if you program some other language for a living, UNIX and perl are a must.
Moose is winning: http://poll.pollcode.com/uMt Well, including Moose would mean including quite a few other modules in the core. I am not sure this would happen tomorrow. 
They'd get it wrong.
perl 5.14 will have IPv6 support in Socket.pm :-)
Moose shouldn't even be on there. I get that it is the "right way" to do OO in Perl. Including it in the core would be a disaster. You would have to pull in way too many other modules.
I have been hacking out small Perl scripts for about two years now. I mostly work with Perl 5, so I don't really know if things *really* change with Perl 6. So, take what I am about to say with a grain of salt. &gt;“Every developer with whom I have discussed this issue says roughly the same thing: It’s very difficult to pick up a piece of Perl code, even when it’s your own, and be able to quickly understand the gist of it.” Generally, I find this to be true. I only know a few guys (approximately two) that are all-around hardcore enough to know everything all the time. These guys can look at a Regular Expression and tell me in a matter of seconds what it is doing and how it is doing it. Aside from those two guys, I rely on people commenting their code to explain something that is really complicated. In a dream world everyone would comment their code, but alas I/we are not so fortunate. As is the usual case, there are either no comments whatsoever, or they are few and far between. Perl is not all that complicated, but because its syntax does (for me at least) tend to obscure what is really going on. When I read Perl code, as apposed to C/C++, it is not immediately apparent to me what is going on, so it might take me five or ten minutes to *really* understand what is going on. I don't know that it really bothers anyone that I am slow. That having been said, is this a problem with other developers out there?
[Rob Pike wrote][1] &gt; If your code needs a comment to be understood, it would be better to rewrite it so it's easier to understand. Before anyone makes the usual lame crack, yes, it's possible to write clear Perl. [1]: http://www.lysator.liu.se/c/pikestyle.html
Sure, I totally understand that. However, if you need to write something like: `if($email_address =~ /^(\w|\-|\_|\.)+\@((\w|\-|\_)+\.)+[A-Za-z]{2}$/)` I am not sure that there is another way to write that more clearly. It is apparent from the name that this has something to do with and email address. Someone with even a superficial knowledge of Regular Expressions and Perl would know what is being done here. Wouldn't it be better written as: `# $email_address is being compared against a regular expression that validates email addresses.` `if($email_address =~ /^(\w|\-|\_|\.)+\@((\w|\-|\_)+\.)+[A-Za-z]{2}$/)` If try hard to comment all of my code, in any language. I don't comment things that are obvious such as ` i += 20`, but I do comment things that have more than one level of complexity. 
&gt; I am not sure that there is another way to write that more clearly. Use Email::Valid, Regexp::Common, or some combination of the `/x` flag, named captures, and regexp fragments. (The former is the most correct.)
All true but at the very least, use character classes when that's what you mean and don't escape things that don't need to be escaped. All the backslashes make it noisy. On just the regular expression level, this is much clearer: /^[-\w.]+\@([-\w.]+\.)+[A-Za-z]{2}$/
&gt; Wouldn't it be better written as No, it absolutely wouldn't be better. Your comment explains *what* the code does, not *why* it's doing it. Also, that is an awful email validation regex that you should be ashamed of using in production.
That would probably be somewhat useful, but again it would be difficult to upgrade individual modules that way. If all that RPM or DEB did was require all of the various RPMS for the individual packages, then we're talking. Even the core perl rpm could do that, so I could get a newer version of an individual package as a new RPM and YUM wouldn't complain about it, but if you installed perl, it would pull in all of the other RPMS automatically.
Even better: # We require this limited, rigid format due to breakage # in the legacy Veeblefetzer. Yes, we'd like full RFC5322 # compatibility, but that would mean rearchitecting the # whole Potrzebie. my $Special_Email_Address = qr/ ^ (?&lt;local&gt;(?&amp;LOCAL)) (?&amp;AT_SIGN) (?&lt;domain&gt;(?&amp;DOMAIN)) $ (?(DEFINE) (?&lt;LOCAL&gt; (?&amp;DASH_DOT_ALNUM)+) (?&lt;DOMAIN&gt; ( (?&amp;DASH_ALNUM)+ \. )+ (?&amp;TWO_LETTER_TLD)) (?&lt;DASH_DOT_ALNUM&gt; [-\w.]) (?&lt;DASH_ALNUM&gt; [-\w]) (?&lt;TWO_LETTER_TLD&gt; [A-Za-z]{2}) (?&lt;AT_SIGN&gt; \@) ) /x; if ($email_address =~ /$Special_Email_Address/) { ... } Note that unlike your comment, which mostly translates the Perl code to English but with the valuable bit that it's looking for a certain sliver of email addresses, the comment addresses the *why*—information the poor reader can't readily deduce even when she understands *what* the code is doing.
Yeah, I like your solution better.
Sorry.
Ok, I see what you are saying. That looks much cleaner.
You're one of those hardcore guys... I like this solution though. I haven't written any Perl for about three months. I've been in Java and C++ land, I think this is a good example of why it is important to stay in contact with languages that you might not use a lot. I'm out of practice, not that being in-practice would have helped me here. Thanks for this! 
So long as its less wrong, im ok with that.
Hey everybody is on a learning curve. Don't feel bad. 
So long as its less wrong, im ok with that.
Hey everybody is on a learning curve. Don't feel bad. 
So long as its less wrong, im ok with that.
I have in mind the RPM/deb equivalent of Task::Kensho--merely a bundle which depends on other packages.
Whoa, when did perl5 get grammars?
You should be. YOU SHOULD BE. ([Email::Address](http://search.cpan.org/~rjbs/Email-Address-1.892/) contains an adequate validation routine, though it fails on a few edge cases.)
Yes. You want WWW::Mechanize and HTML::Parser.
This. +1 Also... HTML::Parser comes with two additional interfaces for working with it. HTML::PullParser - http://search.cpan.org/~gaas/HTML-Parser/lib/HTML/PullParser.pm and (the one I use most) HTML::TokeParser -http://search.cpan.org/~gaas/HTML-Parser/lib/HTML/TokeParser.pm They're worth looking at because they're slightly easier, imo, to use than directly with HTML::Parser.
There are even more specialized modules for parsing table data, such as [HTML::TableContentParser](http://search.cpan.org/perldoc?HTML::TableContentParser) and [HTML::TableParser](http://search.cpan.org/perldoc?HTML::TableParser).
Sounds super easy. Another +1 for Mechanize.
Being that what you are scraping is totally static, I would make a local mirror as one step, and parse out the needed data as a second. It will make the problem simpler and less error prone.
From the comments: &gt;No one goes on and on about how unreadable Python, Java, C#, etc. are. Uh, what? I do. Java is, most of all, *bulky*. A little program to post a form to a website takes 2 pages of code (100+ lines). When I try to read that, I give up trying to understand it after only 10 lines... and there's still 10 times more left to go. Now *that*'s what I call "unreadable".
Unrelated! * Stop trying to validate email addresses. You are almost guaranteed to be doing it wrong. If you must ensure an email is valid, send a link to the user to click on. * You missed a case like `boobs4life+boobs@example.com` ;)
Please note that you'll be violating their terms of service. http://www.sports-reference.com/data_use.shtml &gt; Sports Reference frequently receives requests for data. We make every effort to simplify the manual retrieval of small amounts of data from our web sites (e.g., most of our tables can be converted to CSV format). However, our company spends a lot of time, effort, and money producing and checking the data we publish, and as such we can not freely give away large amounts of data that we produce. If you are interested in obtaining a large amount of data, please contact us for pricing information. Please do not attempt to spider data from our web sites, as spidering violates the terms and conditions that govern your use of our web sites: Site Terms of Use There are other baseball sites out there that give you free downloads of huge amounts of stats in both CSV and MySQL table form.
I'm not sure I understand everything you're saying. but you don't really need to assign values from @\_ to local variables -- you can use $\_[0], $\_[1], ... don't modify them, though, that will get original values modified.
There's no easy way in Perl 5 (unless someone's written a very clever module to do so), but that's a core feature of Perl 6: my $lambda = { say $^a; say $^b }; In Perl 5 you could emulate this with Devel::Declare and a little bit of extra syntax. Alternately, get used to: my $lambda = sub { say $_[0]; say $_[1] };
What? That's just a plain old regex.
I've seen `?&lt;&gt;` before but not the `DEFINE` or `?&amp;` thing. How long have those been there?
http://perldoc.perl.org/perlre.html Seems like it was introduced sometime around 5.10
Hm... I was just assigning them to local variables for readability. $foobar is better than $_[2]. What I'm hearing, though, is that this isn't quite doable. Too bad. Thanks!
Bah. Thanks anyway. One day I will migrate to Perl 6...
You mean you have something like... %jumptbl = ( plus =&gt; sub { return $a + $b; }, minus =&gt; sub { return $a - $b; } ); And you don't want to have it be this? %jumptbl = ( plus =&gt; sub { my ($a,$b)=@_; return $a + $b; }, minus =&gt; sub { my ($a,$b)=@_; return $a - $b; } ); If you really want, you can use something like.... my ($f1,$f2); { local ($a, $b); sub join_vars { *a = \ $_[0]; *b = \ $_[1]; } $f1 = sub { print "$a + $b = ", $a + $b, "\n"; }; $f2 = sub { print "$a - $b = ", $a - $b, "\n"; }; } foreach my $pair ( [ 1, 2 ], [ 7, 3 ], [ 5, 5 ] ) { join_vars( @$pair ); $f1-&gt;(); $f2-&gt;(); } But regardless, you need to set those vars at some point (thus the call to `join_vars` in the example). Perhaps if you posted some of your code, we could be of more help.
That sort of general rule irks me. Sure, if a piece of code is wacky, and could be simply rewritten to be easier to understand, then yes, that is better. But sometimes code is necessarily complicated and could use some comments to explain what's going on. Also, sometimes it's just not worth it to go around rewriting stuff constantly. People can get obsessed with some code and sit there tweaking and tweaking it endlessly.
Also have a look at http://search.cpan.org/dist/Web-Scraper/lib/Web/Scraper.pm , it's really nice
Take a look at the pure-perl implementation of pairwise() from List::MoreUtils: sub pairwise(&amp;\@\@) { my $op = shift; use vars qw/@A @B/; local (*A, *B) = @_; # syms for caller's input arrays # Localise $a, $b my ($caller_a, $caller_b) = do { my $pkg = caller(); no strict 'refs'; \*{$pkg.'::a'}, \*{$pkg.'::b'}; }; my $limit = $#A &gt; $#B? $#A : $#B; # loop iteration limit local(*$caller_a, *$caller_b); map # This map expression is also the return value. { # assign to $a, $b as refs to caller's array elements (*$caller_a, *$caller_b) = \($A[$_], $B[$_]); $op-&gt;(); # perform the transformation } 0 .. $limit; } This works by first getting references to $a and $b in the caller's package, localizing them, and then assigning to them references to each element in the arrays. 
&gt; These guys can look at a Regular Expression and tell me in a matter of seconds what it is doing and how it is doing it. Aside from those two guys, I rely on people commenting their code to explain something that is really complicated. I'm not excusing badly commented (or uncommented) code. Those people should be shot. But what this says to me is that you have a hard time understanding regular expressions, not necessarily Perl. I see this alot, people blaming regular expressions for Perl unreadability when in truth regular expressions are ugly in any language (except Perl 6 which makes them as readable as they could be).
If you really want to dig into it, you can figure out how Method::Signatures uses Devel::Declare to do basically the same thing. (Method::Signatures (among other things) basically puts "my $self = shift;" at the top of subroutines declared with the method keyword (rather than sub)).
I know but it was listed many times so I think it expresses a real need. If Moose might not be the solution (dependency hell, mechanism itself), I think that viewing all the votes for Moose means at least that there is a real need from perl programmers to have a better OOP mechanism than the actual default one. In that sense, voting for Moose is a good way to express this needs even if in the end, it results in having some keywords added to the core instead.
For now, the ranking is: Moose LWP DBI with DBD::SQLite 14 votes so it's not enough to make it relevant data though...
I regularly program in Java, Perl, Python and Ruby. Regular past experience in PHP, C, C++. Perl is the first language that i really understood. Regex's can be in any language, they're a 'normal' part of most unix tools. If you equate reading a regex with reading perl you're missing the point anyway.
So true! People need to realize we write code for the human, not for the computer.
http://perldoc.perl.org/5.10.1/perlretut.html This explanation is way much easier to grasp
What's the bit about with the weird kid?
What's the bit about with the weird kid?
With perl 5.12 it became easy to upgrade core modules even in case of vendor distributions. They just should go into 'site' directory. But as you are using CentOS, you will get perl 5.12+ after ~5 years.
CPANPLUS has uninstalling.
What's the big picture of what you're doing? Sometimes you have a family of functions that want to share state, but you don't want to expose truly global variables for any putz to stomp. This is where [lexical closures][1] are especially handy. For the sake of concreteness, [HTML::Parser][2] seems to push my code in this direction so the different handlers can know where they are in the document. Say you want the equivalent of CSS selector `div.foo a` (that is, a elements inside any div whose class is foo): sub parser { my @div; my $start_h = sub { my($tagname,$attr) = @_; if ($tagname eq "div") { push @div, $attr-&gt;class; } else { if (@div &amp;&amp; $div[-1] eq "foo" &amp;&amp; $tagname eq "a") { ...; } } }; my $end_h = sub { my($tagname) = @_; pop @div if $tagname eq "div"; }; HTML::Parser-&gt;new( api_version =&gt; 3, start_h =&gt; [ $start_h, "tagname, attr" ], end_h =&gt; [ $end_h, "tagname" ], ); } Yes, `$start_h` and `$end_h` had to unpack their parameters, but notice how they're implicitly sharing `@div`. If you call `parser` again, you'll get another HTML::Parser instance whose handlers communicate via a different private `@div`. Maybe an adaptation of this technique will work for you. What's the broader context of what you want to do? [1]: http://perldoc.perl.org/perlfaq7.html#What's-a-closure%3f [2]: http://search.cpan.org/perldoc?HTML::Parser
Building rpms of perl modules to install in the site directory is much more time-consuming and annoying than you'd think. There's all of the documentation files that have to go somewhere else so they don't overwrite files generated by another rpm. I forget what else. I usually just give up and hack around the bug.
Surely the most logical thing to do would be to switch to InnoDB instead of MyISAM? That way, along with row level locking, they'd get transactions and full ACID compliance to boot.
another hilarious joke i will never be able to explain to anyone irl!
This is how I usually install the odd Perl module (`dh-make-perl` that is), in order to keep my system tidy. I don't like putting things in my system outside of the package manager. 
18 votes, the same result: http://poll.pollcode.com/uMt Moose LWP other modules are at 2 votes all almost. 
I started playing with self-declared formal positional parameter (e.g. `$^a`) and they only really work for simple expressions. Every block structure creates new variables. Compare &gt; { if $^a { $^b + 5 } else { $^b - 5 } }(1, 5) Too many positional parameters passed; got 2 but expected 1 &gt; { $^a ?? $^b + 5 !! $b - 5 }(1, 5) 10 Although, in playing with them I found something cool I did not expect: &gt; sub foo { return "foo" } foo &gt; if (foo()) { "$^a was in the if" } foo was in the if Pointy blocks are probably better complex lambdas: &gt; my $lambda = -&gt; $a, $b { if $a { $b + 5 } else { $b - 5 } } _block647 &gt; $lambda(1, 5) 10
I thought about mentioning pointy blocks, but wasn't sure it's what the OP wanted. Every block in Perl 6 is a first-class function, in one sense.
perl5i can help you do this. You need pretty recent version of perl, and it has a lot of dependencies, but it has a lot of other cool things: use perl5i::2; my $sum = func($a,$b) { $a + $b }; say $sum-&gt;(1,2); # prints 3 
The new META features seem to be explained here... [CPAN::Meta::Spec](http://search.cpan.org/dist/CPAN-Meta/lib/CPAN/Meta/Spec.pm)
The quick answer: Sort of. The longer answer: * Install [Strawberry Perl](http://strawberryperl.com/). ActivePerl is what you install when you want to pay for support. * You can use Perl for "windows scripting" the same way you can use C# for "windows scripting", as in, you can sort of do it, but in the end, it's so not worth it.
Yeah I'd never really heard of it. I run linux and mac systems and don't really use Windows systems mostly because of automation problems I've had. So it's not really fair to say that a particular script would be portable?
Sure! [I carry around Strawberry Perl on a thumb drive](http://oylenshpeegul.typepad.com/blog/2009/07/perl-on-a-stick.html), in case I encounter a Windows machine that doesn't already have Perl installed.
I was the lead programmer at a medium-sized Windows Web Hosting company. We used ActiveState Perl for most of our internals and never needed support of any kind. I can't speak to Strawberry's qualities, but I can attest to that. You'll want the Win32 CPAN module for automation. Pick up the latest O'Reilly book on it. OLE is invaluable. There's nothing I came across in 7 years that I couldn't do in Perl for Windows except make ISAPI filters for IIS. I started barely down the C-library-in-Perl rabbit hole, but backed out. At that time I was convinced I'd be able to do just about anything in Perl if I cared to learn how. I think we used FastCGI for high-demand front-end apps but it's been a while. Consider this my vote that you shouldn't have any problems. All you haters can come at me. EDIT: I'd like to mention that our in-house-developed Control Panel, service deployment, server maintenance, and practically everything we did was entirely Perl on Windows, if that clarifies just how good ActiveState Perl was to us.
Sweet deal!! I'll have to check it out.
&gt;I carry around Strawberry Perl on a thumb drive, in case I encounter a Windows machine I like the short version ;) I'll defiantly check out Strawberry Perl tomorrow.
Apparently Strawberry Perl is good; it was recommended to me by a friend.
I just remembered we used PerlEx, not FastCGI, for multi-threaded, persistent Perl CGI apps. I will say that there might be some initial config pains. I only have pre-6 instructions for my configurations, and they were pretty specialized to our needs, but configuration is the hardest part; just log what you learn as you go and you'll know forever. There's a big world of Windows Perl people out there that will help you if you have troubles, but we're mostly quiet because Linux people laugh at us :(. I'm sure your questions will get answers if you come around here again.
I tend to pick Strawberry for the reasons explained on [their website](http://strawberryperl.com/support.html). Most notably: &gt; **Throwing Money at Your Problem** &gt; In situations where you simply MUST have commercial support for operations or policy reasons (you know who you are) Strawberry may not be your best option. While their ActivePerl distribution may not have CPAN support out the box, ActiveState does offers support on commercial terms and can be modified to do most things that Strawberry can, albeit sometimes with some effort. &gt; This may change in future, but remains true for the present. &gt; If the fact that Strawberry isn't released by a company worries you, remember that 100,000+ people and companies trust our releases, including Larry Wall and most of the top CPAN authors.
I don't doubt Strawberry is good, but as someone who's never needed any support, I'd want to know what's *wrong* with ActiveState Perl to switch. What can't it do without modification that Strawberry can? That first statement is definitely true in business. While some don't mind the hacker's approach, and trust communities entirely, often in business you can afford to and prefer to pay someone just for the peace of mind that they're responsible for helping you. MySQL is no different than ActiveState in that regard, which I guess is one reason Postgre is growing in popularity, and for the same reason we went with Dell, Cisco, Microsoft, and other businesses--they stood by their products with warranty and support contracts. We always approached the community/documentation/references first, and never needed MySQL/ActiveState support. We often proved Microsoft at fault for our cases which resulted in no payment, and Dell was pre-paid for hardware failures, which are inevitable. It's useful to have such services available. That's not to say a huge community-supported platform couldn't sustain itself. I'm still wondering just what sort of problems people encounter, though, because there's never been a thing I couldn't figure out with a little bean-power.
I agree that ActivePerl is a perfectly good solution for people who want to use Perl on Windows. [PPM](http://en.wikipedia.org/wiki/Perl_package_manager) works well and ActiveState does a good job keeping things up to date (*e.g.*, I think ActivePerl 5.12 was available before Strawberry 5.12 was). There is nothing *wrong* with ActivePerl. I think what's compelling about Strawberry Perl is that it works the same way as Perl on other platforms. You no longer have one set of things to do on Windows and another set of things to do on all of your other computers. 
That's outdated and wrong. ActivePerl has offered CPAN support out of the box, complete with a MinGW compiler for a LONG time now.
I earn my daily bread writing Perl on Windows with ActivePerl and Komodo IDE and it is really a pleasure to do so. (Except for the relatively few times you encounter someone who writes perl as if there's only one OS on the planet. (And this goes towards all the OS types out there.))
What set of things? ActivePerl works the same on windows as it does on Linux (aside from obvious OS differences like slashes). CPAN works fine and PPM is mostly there only as a backup for things that are a bit harder to compiler (even on linux), like DBD::mysql.
Just remember perl doesn't fork right under windows.
Can you elaborate? How would it be different? What consequences would that have?
Under Windows forking in Perl is emulated by using threads instead of starting new processes. This has the side effect that children can't wait for their parent process to exit and vice versa, because they're effectively the same process. You can read more here: http://perldoc.perl.org/perlfork.html
It's not that Perl doesn't fork right under windows, it's that windows doesn't actually have fork. So Perl fakes it the best that it can, but it's not exactly the same.
Oh of course. Thanks for sharing!
It might be a bit overkill, but I have had much better luck with automating things in Windows by installing [Cygwin](http://www.cygwin.com), and using its native Perl package. Some other neat things like the [SSH service](http://chinese-watercolor.com/LRP/printsrv/cygwin-sshd.html), and [PuTTYCyg](http://code.google.com/p/puttycyg/) have been very helpful for scripting and automation that goes beyond things running on the local machine.
I use both activestate and strawberry pretty interchangeably. I have my site\lib directory net mounted. Seems to work fine from both.
I have never used ActivePerl on Linux (and I don't know anyone who has), so I'll have to take your word for it. But perhaps this points out an important difference between the two projects: while ActivePerl aims to make *ActivePerl* work the same everywhere as it does on Windows, Strawberry Perl aims to make *Perl* on Windows work the same as Perl everywhere. Perhaps this difference is more philosophical than practical, as I don't know anyone who is unhappy with either ActivePerl or Strawberry Perl.
I'd advise against using a moose to teach. Once a moose bit my sister.
Perl used to have a great, if not so frequently updated news site at http://use.perl.org but it's shut down. I guess this is the replacement.
no, the real replacement is http://blogs.perl.org/ which is a community blogging site just like use.perl.org (the front page was really just a minor feature of use.perl.org)
There's also http://perlisalive.com/
Seems to me kind of silly to use while (s/$pat/-/o) { because that will unnecessarily include all that time spent doing string replacement to be included in the benchmark. Why not just focus on the matching instead -- there's no reason to modify the string if you're going to throw away the result: while (/$pat/g) { Also /o is superfluous since your pattern contains no variables to interpolate and using qr() explicitly means that it's only compiled once.
I would do it this way: my $new = ( grep { $_ ne $old } ($him, $her) )[0] if $old; Also, what if they're both ne to $old?
Maybe? $new = $him eq $old ? $her : $him; Or more verbose, if( $him eq $old ) { $new = $her; } else { $new = $him; } 
It seems very, very heavy-handed to be using grep when you're just choosing between two items - ew73's code is shorter, faster and easier to read. 
If you want to be annoyingly clever without the grep: my $new = ($him, $her)[int($her == $old)] if $old; But this is one of those times it's probably better to use a few lines for clarity's sake.
I wonder how the interviewer would have taken "I'd use Regexp::Common" as an answer :)
You may have missed it, but the article itself includes a link to a reddit submission with a discussion about the article. http://www.reddit.com/r/programming/comments/g6srh/perl_complex_regexp_and_a_programmers_job/ 
I think it's usually considered a good practice to produce a value using a ternary table. Covering each value without being clever helps with clarity and maintainability. Making each condition positive instead of negative helps a bit as well. I think this might work: { # Avoid warnings about comparing a string to an undefined value. no warnings 'uninitialized'; my $new = !defined $old ? undef : $him eq $old ? $her : $her eq $old ? $him : undef ; } Edit: Thank you autarch for pointing out my mistake. I updated the code with your correction. 
While this is not an ideal solution, it is quite clever and cute. I like it!
Would earn a left hook from me.
My goal was to make it fairly realistic; match and replace, match and print, whatever. The test suite uses the same structure for all regular expressions - same input, same functional spec - so in theory there's a uniform baseline and the only thing we vary is how the pattern is matched, so this gives us a basis for comparison. _update_ ps: i do want to manually check the results of each. This isn't just a timetrial, it's an accuracy-trial too.
Me too, but then I just showed that Regexp::Common is slower than brute force...
Over the years I've come to recognise the benefit of the more verbose version. Assuming that the code is correct, the next most important thing is readability, or *skimability* if you prefer. I can see at a glance that the verbose version is an `if` test with some assignments - it's a familiar "shape" of code. Whereas the "clever" examples require me to mentally parse the code to intuit the meaning. That said, a ternary expression laid out like so is almost as good: $new = $him eq $old ? $her : $him; If would definitely avoid `grep`, though. Too clever by half. Remember that debugging code is harder than writing code. So if you write to the best of your ability then you won't be smart enough to debug it.
I like using map and grep to process sets of data, rather than slogging through data elements one by one, but you do have to be careful about layering set operators and suffix operators until you have total incomprehensability. The good news is you're making things unnecessarily complicated. If you're only going to have two things to compare, the ternary condition is good, Neodon has it right. As far as what you're trying to do with grep, grep starts with an array or list on the right, which is compared within the block. Any values which evaluate to true in the block get passed out the left hand side. Also, while referencing undef variables leads to warnings ( you do have warnings and strict turned on, don't you? ), but using an undef variable in a boolean comparison is ok. If $him matches, $her will not match, and vice versa, so you know you'll have at most one value coming out into the assignment. my $new = grep { $_ eq $old } ( $him, $her ); If there's a possibiity of more than one value matching, you need to wrap the expression in parentheses so you can apply de-referencing square brackets to the whole thing. my $new = ( grep { $_ eq $old } ( @them, @those, @others ) )[0] But it is becoming more complicated.
/o has been 99.9% pointless for a long, long time, because even when a regex has an interpolation, it saves enough information (basically the stringification of the regex with variables interpolated) so that the next time it's run, it's able to tell whether any of those variables have changed. If it's not, then it skips recompiling the regex and just runs the stored compiled regex, the same as if there had been no interpolation and the regex was compiled at compile-time. This adds a small overhead (a memcmp and a memcpy, basically) but it's thousands of times less than recompiling the regex. So `/o` gives only a tiny, tiny savings (skipping a string interpolation and a memcmp) when it's used properly, and it causes your code to be completely incorrect if you slip up and use it where the pattern might actually change, so why run the risk of using it at all? Oh, and the best bit? I had thought that the optimization I mentioned above was added in 5.6 or 5.8, near `qr//`­— but I took the time to hunt down exactly when. Turns out it was added in *5.002*. In *1996*. Which makes use of `/o` purely a legacy of perl4.
So you've got me - yes, I've been coding perl since '89. I'd have gotten away with "/o" too, if it hadn't have been for you pesky kids!
Thanks, ew79! Yeah, my only problem with your top solution is that occasionally $old is undef, I don't want $new to be defined either, however your top solution would give $new the value of $him. But I guess in that case I could just amend your code by: my $new = $old ? $him eq $old ? $her : $him : undef; At the end of the day, though, what's the point of avoiding verbosity? Like I said above, for some reason I have this fetish for getting stuff done in one line. I should probably cool off with it a little bit!
That's cool! Man after my own heart. Totally incomprehensible but said with as few words as possible!
Since people have solved it the more readable (ternary) way, here's if you really want to use grep: my ($new) = defined $old ? grep { $_ ne $old } $him, $her : undef; This of course assumes that they're not both different than $old, otherwise you'll end up with the first one. Edit: Sadly "defined $old &amp;&amp; grep" makes $new be "" when $old is undefined.
Ugh. You're already using an if statement modifier in your original, so why not continue that my $new = $him eq $old ? $her : $him if $old; Also I really think this one-line obsession needs to die. The above statement is much readable even by simply putting the modifier on a new line: my $new = $him eq $old ? $her : $him if $old; 
Yeah. I keyed in the version you said right after I posted my comment. At the end of the day, I may just go the more verbose way. The one-line thing probably comes from me being a beginner, but also I remember reading that if you find yourself repeating terms a lot in your code then it could be a sign of inefficiency. So that's probably also why I get the heebie jeebies when I have to say the same thing more than once.
"Don't repeat yourself" is a good thing to keep in mind, however another sign of inefficiency is creating a temporary list to hold two values, then creating another temporary list to hold the result of applying grep, and then shifting a value out of that second list, and then freeing those two lists whenever the garbage collector runs. That's a lot of housekeeping work managing data structures behind the scenes in the name of cuteness compared to just comparing the values of three existing scalars, which requires no temporary variables be created and destroyed. 
If I was interviewing someone, I'd be even more impressed by Regexp::Common, turning to the CPAN to solve this problem that's already been well-solved a million times over.
Then try something like: if( defined $old ) { if( $him eq $old ) { $new = $her; } else { $new = $him; } } I'd suggest avoiding the ternary operator unless it's a _very_ simple one-line version of an if-then. Otherwise, it's better to write the whole thing out. Ignoring some very unique edge cases, it's no faster, and a hell of a lot harder to read. Also -- don't forget that Perl also has `unless( $foo )` as a handy way to write `if( ! $foo )`. A good rule of thumb for when to pick verbosity over one-liners is to pretend that you're encountering the code you just wrote for the first time. If you've an urge to find the original author and hit them, you've made it too complex.
Version 0.102 with some sugar for the capture file options should hit CPAN as soon as PAUSE processes it.
And is now up on CPAN. Also, to the downvoter: I'd *really* like to know what mistake i did. Care to tell me?
Or, you could just use PAR and PAR::Packer. Creates self-executable zip files that (optionally, but almost necessary for "deploying to Windows") contains a Perl interpreter and everything the program needs to run.
Turning a list into an array reference, that into an array, and then shifting the first value off that array is definitely not a good thing, when you could just unpack the first of element off the original list, i.e. my ($new) = grep ...
Yeah, I saw that in another comment and slapped my forehead as I didn't even think of that. I was sitting here trying to grep into a scalar and of course that only gives you true or false, so I thought of using shift and before you know it you're traveling way down a dead end road. Thanks for your input.
It's very common for *any* given comment to get about 20-30% downvotes, don't sweat it.
It's very important that code be *readable* by everyone (assuming that the problem is such that readable code is possible). So I would write it like this: my $new; if ( defined $old ) { no warnings 'uninitialized'; if ( $him eq $old ) { $new = $her; } elsif ( $her eq $old ) { $new = $him; } else { # do something here? } } That seems to satisfy your requirements, but there's an curious edge case: what if *both* $him and $her don't match? What should the default to $new be? In the above code, $new will remain undefined and I don't think you want that. *Edit*: Accidentally hit "save" too soon.
Yeah, i know. :) I'm just wondering if there are, well, real complaints that would be addressable. I like making people happy.
That is not the right way to test if a variable is defined. In the code above, `$old eq undef` will be true when $old is an empty string. If you want to check defined-ness, use the `defined` operator! 
Site down for maintenance...? [Here is a description of the search engine on searchtools](http://www.searchtools.com/tools/namazu.html): * Japanese search engine as a CGI using Perl * command-line driven, you have to do a "make install" * indexes local files only (no robot), requires wget or another package to index remote files 
Thanks. Yeah, one of them will match, always. There are some boundary cases where $him and $her do not apply but $old will always be one of the two if they are defined. The thing I'm trying to do is leave $new and $old undefined if $him and $her are undefined. But from a coding perspective, I am assuming it's just as if not more efficient to leave $new and $old undefined, rather than populating them with a blank value. Is this a mistake?
&gt; The thing I'm trying to do is leave $new and $old undefined if $him and $her are undefined. Ah, if you also want $old to be undefined, that changes things yet again: my $new; if ( defined $old ) { no warnings 'uninitialized'; if ( !defined $him &amp;&amp; !defined $her ) { undef $old; } elsif ( $him eq $old ) { $new = $her; } elsif ( $her eq $old ) { $new = $him; } else { # do something here? } } &gt; I am assuming it's just as if not more efficient to leave $new and $old undefined, rather than populating them with a blank value. Is this a mistake? It's probably a mistake, but for reasons different from what many expect. When we talk about "efficiency" in code, we often mean "I want my code to run as fast as possible" or "I want my code to use the least memory possible". When *I* talk about "efficiency" of code, I often mean "I want my code as easy to read and change as possible". It's long been demonstrated that programmers will usually guess wrong about what is fast or slow in their code. That's why we use tools like [Devel::NYTProf](http://search.cpan.org/dist/Devel-NYTProf/) to find out where the bottlenecks really are rather than guess. And we only do that when we know we have performance issues. The problem with trying to make this code more "efficient" in terms of speed or memory consumption is that this often results in code which is no faster, but is harder to read and change. Even if the code *is* faster, is it worth making the code harder to read? I tell people that as a good rule of thumb, "expert" code should look very close to "newbie" code in terms of simplicity. Writing really clever code can be fun, but when that hides the intent of the code, it's hard to find and correct bugs and hurts us in the long run.
That sucks!
Heh, I've been bitten by this quite a few times; which is partly the reason why I've subconsciously conditioned myself to detect and recode around it.
Best bet is probably to fire up Wireshark and compare the actual headers sent from both FF and Mech.
Firstly, setting the Host: header manually is not necessary. LWP takes care of that for you. Also, setting the Connection: header manually will not do what you want. Running your script as-is results in headers like this: GET /eram/getMaintFeesInfo.do;jsessionid=0000SbX-LOY9XE3fLubkkIs_858:11g10965f?patentNum=6507351&amp;applicationNum=09457139&amp;signature=aff9bff8f034a6ff7585bcf2beebb5ad&amp;loadTime=1300885785478&amp;sessionId=SbX-LOY9XE3fLubkkIs_858&amp;maintFeeAction=Get+Bibliographic+Data&amp;maintFeeYear=04 HTTP/1.1 TE: deflate,gzip;q=0.3 Connection: keep-alive, TE, close Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Accept-Encoding: gzip,deflate Accept-Language: en-us,en;q=0.5 Host: ramps.uspto.gov User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15 (.NET CLR 3.5.30729) Keep-Alive: 115 Note that the Connection header now has three values. That's because LWP (or more precisely, under the hood Net::HTTP) wants to add "Connection: close" unless it's been told to use a persistent connection (which you haven't done; you've only set a header.) It also wants to add the TE (transfer encoding) option if it's been told to, which LWP::UserAgent does. This results in three values for Connection. If you want to enable persistent connections, do so explicitly: my $m = WWW::Mechanize-&gt;new (keep_alive =&gt; 1); And then don't go mucking with setting 'Connection' manually. You can modify LWP::Protocol::http to not request the TE header (search for `SendTE =&gt; 1`). Making those two changes you get a request that looks more like your specification: GET /eram/getMaintFeesInfo.do;jsessionid=0000J2u30YKSEN1cax2cJrOYzey:11g0uepfb?patentNum=6507351&amp;applicationNum=09457139&amp;signature=3cc1e13ca9c8db528757294e7b0c9f00&amp;loadTime=1300885369024&amp;sessionId=J2u30YKSEN1cax2cJrOYzey&amp;maintFeeAction=Get+Bibliographic+Data&amp;maintFeeYear=04 HTTP/1.1 Keep-Alive: 300 Connection: Keep-Alive Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Accept-Encoding: gzip,deflate Accept-Language: en-us,en;q=0.5 Host: ramps.uspto.gov User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.15) Gecko/20110303 Firefox/3.6.15 (.NET CLR 3.5.30729) However, this still doesn't work. (Thinking that case might matter I tried editing Net::HTTP::Methods to use lower case 'keep-alive' instead of 'Keep-Alive' but this makes no difference.) Since it does work in the browser I suspect that the site might be checking the order of the headers to detect LWP. In Firefox, the order of headers is Host, User-Agent, Accept, Accept-Language, Accept-Encoding, Accept-Charset, Keep-Alive, Connection. If you want to try changing the order, edit HTTP::Headers, specifically the `@header_order` at the top which controls how they are ordered in the request. 
This type of question is better on a Q/A forum like stackoverflowcom or perlmonks.org. Reddit just isn't very good for question/answer stuff
See if spoofing your user agent will make it work. my $mech = WWW::Mechanize-&gt;new; $mech-&gt;agent_alias('Windows IE 6'); $mech-&gt;get("https://ramps.uspto.gov/eram/patentMaintFees.do"); ... Also, some issues with your code: $html =~ m/\"hidden\" name=\"signature\" value=\"([A-Z,a-z,0-9]+)\"/; You dont put commas in character classes unless you want it to match a comma. Youre trying to match a word char so use `\w` or `[A-Za-z0-9]`, but in that case youre actually trying to match a hex digit, so use `\p{Hex}` or `[A-Fa-f0-9]`. Also make use of URI's query_form method: my $url1 = URI-&gt;new('https://ramps.uspto.gov/eram/getMaintFeesInfo.do;jsessionid=' . $jsessionid . '?patentNum=' . $patent_number . '&amp;applicationNum=' . $application_number . '&amp;signature=' . $signature . '&amp;loadTime=' . $loadtime . '&amp;sessionId=' . $sessionId . '&amp;maintFeeAction=Get+Bibliographic+Data&amp;maintFeeYear=04'); Is better written like: my $url1 = URI-&gt;new("https://ramps.uspto.gov/eram/getMaintFeesInfo.do"); $url1-&gt;query_form(jsessionid =&gt; $jsessionid, patentNum =&gt; $patent_number, applicationNum =&gt; $application_number, signature =&gt; $signature, loadTime =&gt; $load_time, sessionId =&gt; $session_id, maintFeeAction =&gt; "Get Bibliographic Data", maintFeeYear =&gt; "04"); Otherwise, why use URI at all?
Cool initiative, but why aren't you on irc.perl.org with the rest of the Perl world?
Catalyst Apps have a section of their makefile that makes a dist tarball suitable for distribution. &gt; First, Java wants to own the world And that's why Perl doesn't have a similar tool. With perl, "webapps" typically don't rely on a single httpd or DB backend: they use FastCGI and DBI to interface with whatever flavor of those you choose. The Perl community strongly believes in TMTOWTDI and for good reason. What if that new app your business wanted to use only worked with lighttpd, but your business uses all nginx httpds? Or it only supports MySQL and you're an Oracle or Pg house? You'd be screwed if it weren't for the abstraction layers that FastCGI and DBI provide. Also, something like this is certainly already possible. PAR allows you to bundle everything into a single file package (it's actually a ZIP file). Combine that with a server component that can recognize when a new .par is dropped somewhere, unpacks it, kills the old app if there was one, starts the new one, etc. And you've basically got the same thing.
Well you are quite right with the JDBC example (I forgot Java finally got a database-neutral interface), but the WAR example requires an already-configured "app server", of which I believe there is only a single implementation. I'm probably wrong in this respect, but I still think that my original point still stands: there are so many ways to connect your users to the applications (apache, lighttpd, nginx - cgi, fastcgi, mod_perl - catalyst, plack, and so on) that there hasn't really been work on making anything as automated at WARs.
Sadly, no .pars are not widely accepted. Most Perl applications come bundled as regular tarballs with some kind of configure/make script (either MakeMaker, Module::Install, or Module::Build).
Exactly what I thought when reading the TFA. I think this does it for apache/mod_perl: http://search.cpan.org/~nbyrd/Apache-PAR-0.30/PAR/tutorial.pod Not sure how well it works. Interesting the make dist option of Catalyst. Rails 3.0 has bundler built in so you add your gems to a Gemfile do a 'bundle install' and gems and their dependancies are installed. I think the install is local to the app (and only done if not already provided by the hosting system). Not saying it's any better, just saying. 
I still like to see the test results :)
Argh! I thought this was a self post and wrote out some advice -_-
I thought about saying "fuck it and use some formatter to parse it into a DateTime, then print it out in whatever format you want", but I like the linked solution.
Wow! This page is golden!
Right? The answer is to `use DateTime;`, of course.
I must be some sort of ass, because before I even clicked on the link I had started thinking something like: s/09:23:53 08- OCT-98/Thu Oct 8 09:23:53 1998/; =/
I came here to say that I would use DateTime to parse the timestamp and then write it out in the desired format.
That is of course very much the preferred option. :)
Caution: Do not install this EUMM when your Scalar::Util is v1.22 or older; as it will break your CPAN (due to breaking Compress::Zlib). Details here: https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker/issues/4 
The "Camel Book" is the standard - http://oreilly.com/catalog/9780596000271/ My favorite, though, is Perl: Best Practices - http://oreilly.com/catalog/9780596001735 It may be more intermediate, but ultimately more useful in learning to get the most from the idiosyncracies of Perl. 
If you are not a beginning programmer then I _highly_ recommend that you read "Modern Perl" http://www.onyxneon.com/books/modern_perl/
[LearnPerl.org](http://learn.perl.org/) is a good place to start. I learned from the O'Reilly book ages ago, although honestly I'd take a look at the documentation that perl includes (it's linked on the site). It's absurdly good.
I've found the process of learning perl is obstruct with outdated sources that only teach bad practices. As a basic introduction, O'Reilly's *Learning Perl, Fifth Edition* and *Programming Perl, 3rd Edition*. Get those editions since they cover Perl 5.10 But from that you might want to review with modern perl books; for instance, *Modern Perl*, *Effective Perl Programming 2nd Edition*, and O'Reilly's *Perl Best Practices*. Those recent books will guide you through the recent features, idioms, styles and syntax. Also the OOP with Perl, and how is used in the present. There are tons of tutorials and guides, but most are outdated. There is always irc.perl.org and #perl at irc.freenode.net; Perl mongers ready to answer any query. And by 'any', I mean anything. 
Thanks a lot for the replies everyone, will look into the books:-)
"Learning Perl: and "Modern Perl" to get the basics, the mechanics. "Effective Perl", "Perl Cookbook", "Perl Best Practices" to get a feel for idioms. Note that Modern Perl and Effective Perl are current, the others have some elements which are becoming dated. 
I couldn't agree more! Truly. I strongly recommend Modern Perl be the first book you read on Perl. Then as you read anything else following this, keep the frame of mind you learned in Modern Perl. Ask yourself "did Modern Perl say something different about this?" and if so, default to what Modern Perl recommended.
There's no need to SHOUT.
Modern Perl is pretty good, and mentioned somewhere else. I personally learned perl with the built in docs. "man perlintro" if you're on Linux or Mac OS X. Not sure about Windows, but [it's online](http://search.cpan.org/~rjbs/perl-5.12.3/pod/perlintro.pod) at least. "[perlfunc](http://search.cpan.org/~rjbs/perl-5.12.3/pod/perlfunc.pod)", "[perlre](http://search.cpan.org/~rjbs/perl-5.12.3/pod/perlre.pod)" are great references that I use constantly. [You can see it all online here](http://search.cpan.org/~rjbs/perl-5.12.3/pod/perl.pod). Check out all the tutorials. My personal advice is to always put: use strict; use warnings; at the top of every perl source file you write. I went way too long without doing that...
Elements of Programming with Perl [Paperback] Andrew L Johnson 
I concur with this. 
That was my favorite book for novice programmers for a long time, but it's difficult to find (and it covers an older version of Perl). I wish there were an update for Perl 5.12; I would recommend that book wholeheartedly.
Yes I like it too and still refer to it. Amazon has 17 used from $4.18 !! 
Have you noticed that they took out any socket development information in the later editions?
Just in case the OP missed what he was saying, It's "Perl" (the language) or "perl" (the interpreter) but never "PERL".
For beginners, try [Beginning Perl](http://www.perl.org/books/beginning-perl/), a free, online, tutorial-style book. Also, as others have mentioned, Modern Perl. O'Reilly books are decent reference, but are aging rapidly.
I guess someone should point out that there are free PDF versions of the book available from [that page](http://www.onyxneon.com/books/modern_perl/).
I'd suggest reading the above, following up with [Higher Order Perl](http://hop.perl.plover.com/). I think they make a great combination. Also read the perlre manpage. It's the single best regex reference out there for all languages using Perl-style regex.
I'm sorry, but I disagree. I bought and read "Modern Perl". I found a lot of it to be basic perl mechanics - things that are covered well in perldocs, the camel book, random google search, etc. Past that, it was just a lot of preaching about certain modules to use. I appreciate that this book can provide a model for an advanced perl environment, but I don't see it as essential or even especially worth recommending. Again, this is not meant to be any sort of flamebait, just my opinion on this book. For the record, the perl books that I've read are the camel book, Modern Perl, Perl Best Practices, and Higher Order Perl. I recommend the camel book highly to a beginner. I highly recommend Perl Best Practices to an intermediate (someone who can write a perl program, but it is butt-ugly). Higher Order Perl is a book I recommend to a perl hacker who wants to learn about functional programming. I think it is a good book to cover functional programming and how to accomplish it in perl, but it has a limited scope.
&gt; I found a lot of it to be basic perl mechanics - things that are covered well in ... the camel book.... I find that surprising.
Or ActiveState's Perl Dev Kit. Pricey, but it works well.
I have never dealt with Manning. Do you think they would be up for updating it?
&gt; I recommend the camel book highly to a beginner. Are you serious? It's my impression that the Camel book would drown a beginner in irrelevant details. The Llama book would be a better recommendation IMHO.
It's difficult to imagine a traditional publisher publishing a new Perl 5 book, given the damage a certain animal book publisher did to the market.
I asked them anyway. Got an interesting answer and it wasn't a definite "no". 
i went to my college library, checked out all the Perl books they had, only about 4-5. They had the Sams teach yourself in 24 hrs and some other ones. The Sams one showed me the way and how Perl modules work and the basics of using cpan etc...it was the best out of the books i got. I then went online and found the Perl website to be of great help. I found that the Modern Perl is a good pdf / book for a programmer that knows how to program and needs a 'best practice' approach to Perl and how to use some of the new modules. Its good. Perl rocks, good choice on starting this awesome language.
I haven't read the llama book, so I can't say which one I think is better. I think the camel book does a very good job teaching a beginner about e.g. how to use hashes, references in perl.
Frankly, I think it's very cool that I can criticize a book on reddit, and the book's author will offer a response. I thought that the OP should see a counter-argument to the highest rated post on this thread. I think s/he would be better served by books other than "Modern Perl", but this is just one man's opinion. I have nothing but love for you mr_chromatic, and the whole perl community. xoxo, NJalien
I think HoP only shows what you can't do properly with Perl, and the message I get from that book, is that beautiful ideas exist, but they can hardly be expressed through Perl and need some other language that can do it properly(I'm only reffering to HOP ideas here). Also, HoP is not something you recommend to someone who wants to do professional Perl development, because the things describe in it you will **never** use in practice, at least as a web developer, and to be honest all other areas that you would use Perl for. 
Huh? You're saying the author wrote the book in order to show that Perl can't cut it with the subject matter -- seriously? Perhaps you also have a low opinion of web development, i.e. that they don't need higher order functions? I guess if you don't know about them, you might not miss them, but if you do know about them...
_I_ certainly use higher order functions in webdev a lot, for sure. Even small things like map and grep are HOFs. Who doesn't use those all the time?
&gt; I think s/he would be better served by books other than "Modern Perl", but this is just one man's opinion. That's a fine opinion. Given, though, that the point of *Modern Perl* is to explain things that the Camel is way too old to explain, I find the idea that the Camel covers them better surprising.
&gt; I now use web servers to manage my processes. &amp;#3232;\_&amp;#3232; 
The failraptor itself is nice (and I think would make an interesting error page), but the flow of multiple colors is, IMHO, a wrong UI decision. When a user reaches a failure page, they should immediately feel it, which can come from a lack of color and utter simplicity in the page. So, the raptor alone with the words above would make a good error page, the colors won't. 
I agree with your reasoning, but disagree with your conclusion. I think the jarring colours are precisely what make the page stand out so that the user "feels it". Of course these are entirely subjective opinions, so we can both be right :-)
Good
All of this is easy enough to test empirically: script.pl #!/usr/bin/perl use strict; use warnings; use X; use Y; use Z; X.pm package X; use strict; use warnings; use Y; use Z; BEGIN { print "compiling X\n" } print "running X code outside of functions\n"; sub import { print "running X import\n" }; 1; Y.pm package Y; use strict; use warnings; use X; use Z; BEGIN { print "compiling Y\n" } print "running Y code outside of functions\n"; sub import { print "running Y import\n" }; 1; Z.pm package Z; use strict; use warnings; use X; use Y; BEGIN { print "compiling Z\n" } print "running Z code outside of functions\n"; sub import { print "running Z import\n" }; 1; Running that shows that the code only gets compiled once, but the import function gets called multiple times. This makes sense since the import function's purpose is import stuff into the package that called it. So, the performance impact is dependent on how complex the import function is. As for determining dependencies, take a look at [Module::ScanDeps](http://search.cpan.org/dist/Module-ScanDeps/lib/Module/ScanDeps.pm).
[stackoverflow.com](http://stackoverflow.com) or [perlmonks.com](http://perlmonks.com) are better places for Question/Answer posts. Reddit is about sharing links and opinions, not getting good technical answers.
If you are use **require** or **use** to incorporate code from other files perl should automatically track what has already been loaded and avoid loading it again.
Look at [perldoc perlvar](http://perldoc.perl.org/perlvar.html), specifically at `%INC`. In short, when you load a module with `use` or `require`, its path relative to `@INC` is automatically stored as a key in that hash (and the full path as the value), and loading it again is avoided if the same key exists (assuming you don't dingle with `@INC`, but then if you are, and there's a conflict, you probably really do want to load a different file.) To verify this empirically, you can run an `strace perl yourprog.pl` and check the system calls made, and see that it only opens and loads each module once.
The real cost in use/require, btw, is ironically if you have a huge @INC and most of your modules tend to be in the later directories vs. the earlier ones. Then, there's a system call to see if the file exists in every directory in order. That can add up.
The hell it is. You can ask questions and get good answers on reddit. 
And wasting phenomenal amounts of time. Kudos. 
And import only gets called on modules that are exporters, so if your modules are all OO and don't export anything then the overhead of repeated `use` is almost nil (about two hash lookups, one to determine that there's already an entry in `%INC` and one to determine that there's no import method)
When Perl loads a module, it adds an entry to `%INC` where the key is the module name as a relative filesystem path (e.g. `Your::Module1` becomes `Your/Module1.pm`) and the value is the full path to the file (e.g. `/usr/lib/perl/site_perl/5.10.0/Your/Module.pm`). Both `use` and `require` will avoid loading a module if it's already been loaded. If you ever want to force a module to be reloaded, you can delete the relevant entry from `%INC` and call `require` to load it anew.
import only gets called if the import subroutine exists. packages don't have to subclass or otherwise use Exporter.pm inorder to use this "magic".
There is absolutely no reason to ever be worried about the performance impact of C&lt; use &gt;. Period. ... Unless you intentionally abuse it, though I can't imagine how or why. C&lt; use &gt; is compile time.
If you think you want to improve performance, don't guess at what the problem is. Measure. Use a tool to find out where your code is taking a long time. The tool you're looking for is called a "profiler" and the state-of-the-art in Perl profiling is Devel::NYTProf. Start there, rather than guessing that repeated use calls might make things slower.
I said "modules that are exporters", not "modules that inherit Exporter" :)
Right, sometimes that distinction isn't as clear to some people. Thought I'd clarify the distinction.
Short answer: Yes. Longer answer: No, use Moose and Roles, where roles behave somewhat like but entirely differently than mixins in other languages. Even longer answer: Yes. Roles just moosh everything into the same package in the end. It may help to realize that, in Perl, `$obj-&gt;method( $param )` (where `$obj` is an object of say, `Person` type) is a handy way of writing `Person::method( $obj, $param )`.
Any method you call on an object has to be in the namespace of the class of that object or one of its accessors. Within `Manipulation`, you can export any necessary methods into the `Person` namespace manually, reopen the `Person` namespace with a `package` statement, or declare your methods with `sub Person::walk { ... }`. These all seem like hacks around a design problem, however.
I agree it seems like a design problem. Person is doing too much, i.e. OP is putting all the code into Person instead of having enough distinct classes to model the problem. If this was a game of chess, it seems like we'd need a Board class. Then $board-&gt;move($which_piece, $direction, $spaces); Or more abstractly, Board has Movements, each Movement has Piece etc. Putting nearly everything into Piece would be a bad move, which is what OP seems to be doing by putting so much into Person.
Isn't the import() call made by the use statement called at runtime?
Not to quibble and not to answer the OP's question, but that would be $board-&gt;move($which_piece,$square); Direction and space(s) is inherent in destination.
Probably what you should do is to have Manipulation.pm start with "package Person"; then the subroutines it defines will be methods in the Person package. 
&gt; It may help to realize that.... That's where most of the Perl 5 core documentation of OO goes wrong. The differences are very important.
`use` runs at compilation time in an implicit `BEGIN` block. This is how importing symbols can satisfy the compile-time mandates of `strict`, for example.
I got the same flak when I asked a question here many moons ago. Dunno what it is about r/perl, but a lot of people here have a bug up their ass...
Yours is a most excellent quibble, sir. And you are right, yours is better. And I am a terrible chess player :)
/nod Seems like OP is trying to implement Moose's mixin Roles.
If mkdir randomly stopped working, I'd look into that first. I bet it's related.
&gt;(variable holding the path for it to check is definitely initialized): Can you prove (beyond a doubt) that it's initialized? Seems like you're merely confident. &gt; A) could including File::Path have some weird effect on the -d check? Unlikely. &gt; C) Is there a better alternative all together for checking if a directory exists? It sounds like you just have a bug in your code, perhaps a regression from a seemingly unrelated code change (another reason to have classes and tests, maybe you are doing that already). I would suggest posting a runnable example, probably at Perlmonks.org (for the best, fastest responses).
Another thought: Can you make your script output extremely verbose information each step of the way, to a log file that grows over time?
http://stackoverflow.com is a better place for Q/A
print out your pathname before checking with -d. It sounds to me that something is wrong with your pathname.
Isn't this a situation where you could use [use base](http://perldoc.perl.org/base.html)?
It's beautifully ugly.
Methods on a class can either be in its package or in a package in its @ISA hierarchy. Think of Manipulation as a role and use multiple inheritance. You dont have to immediately go to Moose to do this, although depending on what youre doing, you may want to consider it. sub Manipulation::walk {say "walking"} @Person::ISA = "Manipulation"; sub Person::new {bless {}, shift} sub Person::set_hair_color {say "setting hair color to $_[0]"} sub Person::get_current_location {say "getting current location"} my $person = Person-&gt;new; $person-&gt;get_current_location; $person-&gt;walk; 
Please don't be a troll. I've been looking for an alternative to WP4 that doesn't require either PHP or MySQL.
There is always [MovableType](http://www.movabletype.com/) ; this is of course, if you're in the line of Perl. 
What is this nonsense. We know how to use libraries. 
Derp, I meant MT4.
I just ordered your book. I have been programming in Perl for 5 years. I have been reading your book to get "modern". I won a 50 dollar b&amp;n card at work. I decided it was time to pay you for helping me be a better Perl hacker. Thanks dude.
Agreed. I thought they were going to describe how to *implement* the filter, not how to use a CPAN module. What self respecting Perl hacker doesn't know how to use CPAN?!
Check out [Harmony](http://get.harmonyapp.com/)
My guess is that 80% of people who use Perl never use the CPAN. Hopefully we can improve those numbers.
Wow, Bricolage has really had a graphic makeover, hasn't it?
&gt;Get the job done with powerful templating (Mason, Template Toolkit, or **PHP**) Uh, what??
http://en.wikipedia.org/wiki/Bricolage_(software)#Design Paragraph 3
There are a [few blockers](http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2011-03/msg00593.html), but i don't think they'll be that bad. :) A bit of a brainbending read though, that thread. :D
I'm in favor of [this one](http://www.perlmonks.org/?node_id=404804), particularly with the ending. ;)
It would help to have the whole program instead of a snippet. We can't tell how `$i` is being set so we don't know if it's pointing to a valid index. If you haven't turned on `use strict` and `use warnings` do that first. Also, it's wasteful and pointless to write `"$var"`. There's no reason to create a new string to interpolate a single value like that. Just write `$var`. Also, this: if (j == 0 &amp;&amp; i != 0) { does not look valid. Also, instead of while (&lt;input&gt;) { $line = $_; Just write while (my $line = &lt;input&gt;) { as that avoids clobbering the global `$_`.
Sorry, I just updated the the program.
1. Do not use indirect object method calls. Use `Class-&gt;new( $params )`, not `new Class $params`. It will save you headaches, is more explicit, and works. 2. `@list = new Class;` is calling `Class-&gt;new()` and assigning the result to `@list`, probably not what you want. I suggest reading [Beginning Perl](http://www.perl.org/books/beginning-perl/) before going any further. 
I was not speculating about anything, simply asking a question to better understand something. I was not having a real world performance issue, nor was I "guessing" that a problem was caused by repeated use calls. I was asking what the performance implication (if any) of repeated use calls is. Thanks for your "help" though.
I have been playing around with Module::ScanDeps, very cool. Thanks for the tip!
Thanks, exactly the answer I was looking for. 
tl;dr: use mouse
all joking aside, i'm getting pessimistic again about p6. i subscribe to the lists...and i never see anything. thinking that maybe my subscriptions were somehow broken, i decided to read the web archives. crickets what happened??? there seemed to be some momentum for a while...
Maybe everything is going on in IRC. #perl6 was quite active last time I looked (admittedly, some time ago).
I see what you're trying to do, and my advice is to simply have a class that represents an interface ("network" as you call them), with accessors for each of those instance variables (ESSID, Quality, Encryption). You can achieve these accessors with Class::Accessor, Moose, et al. Then, instantiate an object of that class for each of the interfaces, assign them to an array, and iterate over them as needed. I think that, in addition to reading, getting some hands-on experience is great practice and a necessity; and, that this is a great task to start with. You have a long, fulfilling journey ahead of you.
&gt;php is a turd Have an upvote for making me laugh, with the poop joke aspect of your very apt observation. And yes I don't care how damn old this post is.
Yeah, there's activity on irc. Would be nice to see more of it show up on planetsix. 
... irrelevant given that until your profile your application, you don't know what the slow parts are. But I'd be willing to bet that in most apps, the slow parts are I/O and algorithms, not accessors. 
Yes, that's exactly what I'm saying, HoP is showing that Perl can't handle HOFs and HOP in general, Perl is a toy which is not conceived for such things, it's conceived for other stuff which it does pretty well but not HOF/HOP.
I don't think HOF/HOP means map/grep... that's like saying "maths is all about plus,minus,divides and multiply and some numbers".
Okay, I'll bite. Example(s)?
Why not link to the project page instead? http://code.google.com/p/get-flash-videos/
you're not biting silly, it's true. take [this article](http://bit.ly/fV3cxC), it contains hardcore Haskell. reading that article might lead you to understand that HOP/HOF is not just about map/grep, can you write it in Perl ? no. why ? 'cause Perl is a toy when it comes to HOF/HoP, and it's not made for hardcore HOP. I can write a book like mjd did about some stuff like that and then say "wow, Perl kicks ass" but in reality I think mjd struggled a lot to get those examples, you can see from his code. so is Higher Order Perl teaching you functional programming ? some very small part of it, and the language is not the proper language to teach yourself functional programming, Perl can do many things but not always in a proper way, sometimes they just work. can you write abstract algebra in Perl ? no. is functional programming linked to abstract algebra ? yes. why ? 'cause Perl is not conceived to do that. another argument: most functional programming languages need type-inference, which of course is possible if you got a type-safe language, is Perl type-safe ? not it sure isn't, so can you do proper FP in it ? no you can't. so that's why I would advise not learning FP through higher-order-perl because it's a mistake. now you understand I hope..
Afraid of re-posts? http://www.reddit.com/r/linux/comments/93r4f/if_you_need_a_script_to_download_a_flash_video/
Huh, the amount of blockers seems to be rising: http://bit.ly/blocks-514 Maybe the vision may be right after all! :byodood:
Yet another reason I prefer Dancer to Mojolicious.
Why the hell are they in there in the first place?
Now here's something you could: plough through the IRC logs and blog about things you find worthwhile.
is there performance difference between: sub bar { my $self = shift; return $self-&gt;{bar} unless @_; $self-&gt;{bar} = shift; } sub bar { my $self = shift; return $self-&gt;{bar}= shift || $self-&gt;{bar}; } sub bar { return $_[0]-&gt;{bar}//= $_[1]; }
Bricolage would likely be a bit of overkill for a simple blog site (common MT4 scenario), but would be ideal for a network of blogs. 
Probably, but since I'm more of a programmer than blogger, it might be more "helpful" to me than MT4. Going to check it out next week.
Haven't played with Moose or Chloro (urth.org is tossing security exceptions, btw), but this looks a lot like a piece of Django forms. While I get the small, specialized software tools for specific purposes philosophy I do think that some looking for form processing/handling will be expecting something a bit more turn-key. Any plans for Chloro add-ons to accommodate this?
That's just plain wrong, all code is very well commented. We've even had complaints about too many comments! ;)
Why does the Perl source code itself contain LotR quotes?
Haters gonna hate.
That security exception is cause hg.urth.org uses a certificate from CACert. Sorry, I don't want to pay for a cert for this. I haven't looked at Django forms at all. Specific feature suggestions are welcome.
Actually they have not changed at all, comments have always been good, here's a link to the very first commit. https://github.com/kraih/mojo/commit/090a56da9d3c3ddf904f22ab1fc1bf8fa13654e9
Reddit's bugginess has decided to swallow my other post, so here's the short version: Your comments are a severe indicator of not understanding the purpose of comments in code. They are not there to describe **what** is happening. That's what the code is supposed to do. Comments should explain **why** it is happening, when that is not entirely obvious. Most of your comments don't even try to do that.
Short version here again, because the former one got swallowed: I don't like those either, but they are acceptable for these reasons: There is one(1) of them per file, max. The content of it relates to the content of the file. They are immediately followed by actual documentation. My question above was serious: I do not understand why they are there. They are a detriment to the code, as they distract while reading due to the promise of actual information, which is ultimately broken. In fact, they don't even seem to relate to the code they precede. I am curious as to what kind of value you think they add.
Comments are simply there to make code easier to understand, no more, no less. There are many strategies, if you were a good troll i'd argue a bit about it now, but instead i'll just forward you to Wikipedia. http://en.wikipedia.org/wiki/Comment_(computer_programming)
Fun.
You specifically mentioned that you were upset because those quotes were the only comments in some files. That statement is clearly false as i've proven above.
&gt;if you were a good troll I do not need to be a good troll, since i am being completely sincere. I think one can disagree with another without being a troll. &gt;Wikipedia Would you be so kind as to point out where on that page your strategy is described?
A straight-forward and useful answer, thank you.
I guess my professors read perltoot. Don't tell The Rock I asked this, but I should be using Moose, right?
If your professors want you to learn that way, learn that way. But ask them. I'd be very interested to see what they say.
Excellent!
YES!
I remember having had similar problems in a project where we built a large scaled management infrastructure where also SSH was used. We finally switched to [Net::OpenSSH](http://search.cpan.org/dist/Net-OpenSSH/) which worked really fine.
Did you try turning on the debug option (in the constructor) for verbose output? 
unfortunately the person who assigned this project to me requires net::ssh::perl
I have, it is less than helpful. it ends at... ....:Trying empty user-authentication request. At first I thought it was implying that it wasn't passing the userid, but that's not the case. 
This is quite funny, but in all fairness... use the right tool for the job. Sometimes a bless hash is more then enough for the job. I haven't used moose (my employer has their own relational-object mapping system that has been in place and extended for many years before moose) but I hear it's nice.
Not ideal but you could create a new dsa public/private key without a password. put the public dsa key in the authorized_keys(2) file on the remote server. Otherwise I would switch to the Net::OpenSSH package.
I attempted this as well for awhile, and never really came to a good conclusion that would result in a workable solution. Net::OpenSSH saved the day there.
Tell them that Net::SSH::perl sucks. Seriously, we had the same issues with it and opted for a mix of Net::OpenSSH and IPC::Session/ssh.
&gt; I should be using Moose, right? In the vast majority of cases, yes. 
Net::SSH::Perl does not support passwords for RSA/DSA keys ("identity files"). It only supports passwords for remote logins. You can do passworded logins, passwordless keys, or use a key agent for password-protected keys. 
Learning Perl, page 44. It's an assignment. The population of @other is going to be copied verbatim to @copy. To assign a reference you would write: @copy = \@other; # assign a reference of @other to the first element of @copy and clobber anything else there. #!perl my @other = qw( foo bar baz quux); print "assign like a boss!\n"; my @copy = @other; foreach (@copy); print $_ . "\n"; } print "reference like a bad mutha fu-WATCH YOUR MOUTH!\n"; @copy = \@other; foreach (@copy) { print $_ . "\n"; } #### $perl foo assign like a boss! foo bar baz quux reference like a bad mutha fu-WATCH YOUR MOUTH! ARRAY(0x826140) 
Thanks!
`@b = @a` is a straight copy of each array element. Any `{}[]` refs in the original will point to the same (shared) thing in the new one. It's worth mentioning that a line like `sub { my ($x, @y) = @_ }` also does a copy, so if you have to pass huge arrays around a lot it can be faster to keep them as references.
It's also worth noting that even when copying an array reference as above, this is only a shallow copy, i.e. an alias. If the data structure is more complex, say hashes of hashes of hashes, you will need to be careful what your intentions are. If you want to make a deep copy, i.e. a full new copy of the entire data structure, I would suggest the Clone module.
Moose is definitely one of the most popular frameworks for OO Perl, especially in the realm of web development or other arenas where program start-up cost is negligible. (and if you like Moose, but need less start-up cost, check out Mouse). But **nobody is** (or should be) **saying you should use Moose in particular**. Here are three very popular frameworks/classes that give you at least constructors and accessors: * Mouse (though this provides a lot more, such as roles) * Class::Accessor (and C:A:Fast and C:A:Faster) * Object::Tiny And these are but a few. There are *loads* of other tools, including tons of distributions for more specific OO problems (e.g. roles). The unstated moral of my short, illustrated story is simply: There are few good reasons to bless a hash these days. **Use a tested, tried-and-true starting point for creating Perl classes unless you have a compelling reason not to**. It makes your code easier to write, easier to read, easier to maintain, and less prone to bugs.
By the way, here is a lot more information indirectly answering your question: http://blog.moose.perl.org/2011/01/the-moose-ecosystem.html
There's a serious message there too. Regarding your situation... Nobody in their right mind would suggest rewriting loads of already-working code without another compelling reason. And of course you should use the right tool for the job. :) But this was more a commentary on how we, as a community, introduce Perl newcomers to OO Perl. In short: We're f$%@ing sadists, handing a loaded gun with a hair-trigger to an infant. On closely related subjects (and much more eloquently and diplomatically), chromatic has written a number of posts that are worth reading if you haven't already. Two in particular: http://www.modernperlbooks.com/mt/2010/09/what-you-can-and-cannot-teach-about-encapsulation.html http://www.modernperlbooks.com/mt/2011/01/the-minimalist-object-system-and-your-lousy-axioms.html 
Entering a state / city without a job category dumps you back to the main page. In a similar vein, there's no information on how many jobs per profession/location exist. If there are no jobs, it would allow the person to change their criteria before waiting to get no results. Seems you grabbed the city / location information from craigslist, and I'm not sure why you didn't correct the capitalization. $city = join(" ", map { ucfirst } split(/\s+/, $city)); Also, there don't seem to be any job listings. 
Looks rather late-1990ish Looks aren't everything, but at minimum you have to be current
Right. The key I am using is passwordless and it still is borked. 
Yeah, that would be good for my career :) However I'll look at OpenSSH as a work around. 
`@copy = @other` does a shallow copy. If you want a deep copy, use [Clone](http://search.cpan.org/~rdf/Clone/Clone.pm) or [Storable::dclone](http://search.cpan.org/~ams/Storable/Storable.pm).
What's a shallow copy? EDIT: Nevermind. [kc_underwhelemed answered it.](http://www.reddit.com/r/perl/comments/gkbms/newbie_question_about_array_assignment_lmgtfycom/c1o6bw0)
A shallow copy of some array @a is when only the things at the top (indexed like $a[1], $a[2], etc.) get copied, but nothing deeper than that (for example, if your array @a has nested data structures (like an arrayref as one of its elements), then $a[1]-&gt;[2] wouldn't get copied in a shallow copy). Just experiment and see for yourself: #!/usr/bin/perl use strict; use warnings; use Data::Dumper; my @a = ('foo', ['yo', 'yo', 'ma'], 'bar', 'baz'); my @b = @a; # @b is a shallow copy of @a. $b[0] = 'X'; # Only changes @b, not @a. $b[1]-&gt;[1] = 'Y'; # Changes for both @a and @b. print '@a: ', Dumper(\@a); print '-' x 10, "\n"; print '@b: ', Dumper(\@b); 
ಠ_ಠ 
Have you used this book, and would you recommend it?
I wouldn't disrecommend it, but I would recommend [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) to let you in on some of the recent best practices.
Yes but only as a teaching aid. And yes, I think it's fine choice if you're a novice programmer and Perl 5 is one of your first programming languages. It can be a bit too slow-paced if you are an experienced programmer.
It's a short, hand holding introduction through the cat-walking-across-keyboard syntax that makes perl your lifelong friend. If you're already a good developer, you can probably just move on to its most excellent [big brother](http://oreilly.com/catalog/9780596000271/). Then, you can move on to the [master](http://oreilly.com/catalog/9780596528126/) [classes](http://hop.perl.plover.com/).
I was very happy with Sams [Teach Yourself Perl in 21 Days](http://books.perl.org/book/98). It took me from zero to a good overview of Perl in about 10 days…
Related: [Beginning Perl](http://www.perl.org/books/beginning-perl/), a free and not rapidly outdated book.
There's nothing wrong with using a blessed hash. Its a valid and simple way to create objects!
You want this book, and the camel book as a companion text. Modern Perl will teach you how to write good, post-5.8, clean perl. You want this. I've seen no other perl book that does this as well. It's also free online (but you should buy it anyway to support chromatic).
Don't forget *Modern Perl* and perhaps *Higher Order Perl*. *Learning Perl* is a darn good place to start TBH, just don't stop there.
I used Llama (Learning Perl) when I was starting out for a little while, but have since spent nearly all my time in Camel (Programming Perl). If you have some programming experience under your belt, the Camel book should be sufficient for a learning / reference book. So yes, I agree with the above.
A wild stab may be to skip the keyfiles and use the Net::SSH::Perl default: .ssh/id_dsa. According to the docs, it defaults to $ENV{HOME}/.ssh/id_dsa Make sure $ENV{HOME} is /home/testid and copy .ssh2/tesdid_dsa to .ssh/id_dsa and see if that makes it happy.
cookbook FTW!
If you haven't done much programming (and if you read the most recent edition), it's a good way to start learning Perl.
This is 3rd edition, from 2001. Better read 5th edition - it describes perl 5.10.
Agreed. *Learning Perl* was a bit too simple for me when I was, uh, learning Perl. What worked for me was a combination of *Programming Perl* and the most excellent [Perl Cookbook](http://oreilly.com/catalog/9780596003135/).
Modern Perl is great but it glosses over certain basics that Learning Perl covers in depth. I think both together though would be a excellent learning combination though.
Yeah that's exactly what I did. I already knew how to program and Learning Perl did a good job of introducing me to the intricacies of Perl. And now I have a well worn copy of Programming Perl 2nd Edition on my desk.
Thanks yall i'm the guy who built it. I know my design stinks, lol lol. That wasn't the point though. I just wanted to learn how to use perl better when working with databases. The goal is just to make job posting completely free... $400 is just too much to charge plain and simple. If it's successful I'll just hire someone with a good eye for design. Thanks yall. I will implement scriptsvcs suggestions, they were helpful thank you. 
Sixth edition is coming soon.
I gotta go with Modern Perl as well.
I would also recommend Perl Best Practices
Elements of Programming with Perl [Paperback] Andrew L Johnson
Perl Black Book [Paperback] Steve Holzner
I actually discovered higher order perl recently. Excellent advanced topics. It came recommended along side learning other (perhaps more pure) functional languages.
HAHAHA RESUMESTACKER.COM WHAT A JOKE RIGHT YALL??? COME ON LAUGH IT UP LOL LOL. AFTER ALL WHERE IN THIS COOL FORUM.... WOOOOOO HOOOOOO RESUMESTACKER.COM SUCKS!!!!! CALL UP MONSTER.COM AND TELL EM TO PUT AN END TO THIS HAHAHA!
Well, making all those resumes readable by anyone via http://resumestacker.com/class/db/ is a bit regrettable, as is embedding passwords within perl scripts that are readable in http://resumestacker.com/class/scripts/
If you know C, java, or python, and consider yourself a programmer, get the latest Camel book. Otherwise, the Llama book (the one in your link) is the better book for you. 
&gt; ... get the latest Camel book. Why? It's almost 11 years old and is 18 stable releases out of date.
Just want to preface by saying this is not a snark. Back in college (early 'oughts), I learned everything I ever needed to know to get started with Perl from [Network Programming with Perl](http://www.amazon.com/Network-Programming-Perl-Lincoln-Stein/dp/0201615711). It's sort of an incredible book. Sure it's "network oriented" but instead of glossing over the fundamentals, it takes time to also explain the Perl concepts needed to write networking code. 
Because: * it is still a good book * most of the changes since 5.6 don't impact beginners * the Llama book can be tedious if you already know how a for loop works * a lot of people are still on 5.6
I highly recommend the Learning Perl book that you linked to. It helped me learn Perl without any programming background ~ 10 years ago
I would have thought Ruby since almost every post about it has "Ruby is fun!" somewhere.
I really like this one too. I actually email Manning to see if they would update it and they said they would think about it.
Fun fun fun! Where should I sit?
Ruby has a lot of haters too. Make a positive post about ruby in /r/programming to see what I mean.
Heh, I will *not* take that challenge. lol
I'd be interested in seeing if those stats have changed since that was originally posted.
After reading your comments about handing a loaded gun to newbs... oh yeah, I hear ya. We are all crazy bastards! I learned about tie-ing hashes with mldbm long before DBI (I blame the 'man' because I can)
You drunk ol boy? looks locked down to me.... Unless your workin for monster and you know my cheat codes lol lol
&gt; most of the changes since 5.6 don't impact beginners See the top of page 874 for one dramatic example. &gt; a lot of people are still on 5.6 I have trouble believing that a substantial proportion of novices new to Perl 5 would start with a version of Perl almost a decade out of date.
If they are using a shared system at school or work, I wouldn't be surprised to see 5.004. If you are an experienced programmer trying to pick up Perl, Camel is going to get you there faster than Llama, even if there are a few hiccups along the way. 
hoho, is locked down now. ResumeStacker's clearly seen the earlier posting.
The guy who posted it has outlined pretty well how he got the results, shouldn't be too much work to remake it. You should make a Perl script...
I love programming languages and have been in contact with the community of alot of those I have experimented and tested, and I can assurely say that the reason I continue to use and promote Perl is not just because of the language, modules or guides/tutorials. The community plays a big part of it.
I would recommend this book to people who never have tried out Perl and have generally little knowledge of programming beforehand. Most of the stuff in there is pretty basic and imho, you can learn most of it from official Perl documentation. Randall Schwartz rocks.
Isn't the Camel book extremely outdated?
Personally I usually find books like that more valuable to learn that "Learning..." books because they actually cover a topic you can make something of. Something interesting, compared to calculators and the usual gang learning programming books tend to use as examples.
Exactly. For me its up there with The C Programming Language by Kernighan and Ritchie in terms of complete and annotated code examples. 
Good idea. I have too much work to do at present but I put it on my long-term to-do list. If it still sounds fun after this semester of school is over, then I'll share results.
Wait, it's not assembly?
[langpop](http://www.langpop.com)
Blows!!!!
discussed here: http://curiousprogrammer.wordpress.com/2011/04/11/parallel-tasks-using-fork/
There is always Blosxom :)
Trying to read that huge slab of spaghetti code in tiny text with no syntax highlighting and umpteen levels of indentation made my brain hurt and my eyes bleed.
Besides the fact that this is spam.. There are three Perl jobs in NYC. This one sounds like Shutterstock. Apply directly if you don't think this guy should get a fee for spamming Reddit. 
AFAIK, yaml error is spurious. It says it didn't find the .tar.gz file. Did you check in ~/.cpan/? Maybe try downloading the file manually or go through the cpan config wizard again and pick some new mirrors?
You might want to install YAML and PadWalker yourself on the command line. The easiest way of doing this would be (assuming you have curl on your Mac): curl -L http://cpanmin.us | perl - --sudo YAML PadWalker
i went ahead with the command line style above. it had no problem downloading the files and appeared to have no problem until when it started installing i got ! Can't configure the distribution. You probably need to have 'make'. See /Users/JD/.cpanm/build.log for details. i checked the log and it didn't say much other than the same thing. is this related to the sudo (it didnt ask for my password)? i google searched and unfortunately that is not an easy thing to google.
The Swartzian is an example of the decorate, sort undecorate pattern which is a form of memoization applied to sorting. Once you grok the swartzian move on to the GRT http://www.sysarch.com/Perl/sort_paper.html
You probably need a development environment. Its been a while since Ive done this but you should be able to get a package called Xcode from Apple that contains basic tools like make. http://developer.apple.com/xcode/ You also might want to try: curl -L http://cpanmin.us | perl - --look YAML This will open a shell in the YAML distribution. Then you can read the INSTALL file and do what it says there. Usually its like: perl Makefile.PL make sudo make install Then do the same with PadWalker.
Does anyone want to buy some indoor rhino repellent? Give me your money and I promise you won't be charged by angry rhinos in your living room.
I love how they try to gloss over the fact that in each case (Google being debatable), it was the programmer at fault for willfully violating the license.
you might want to install some core modules from MacPorts from that you can try with sudo cpan Module::Foo For example, YAML, can be found [here](https://trac.macports.org/browser/trunk/dports/perl/p5-yaml/Portfile) and [PadWalker](https://trac.macports.org/browser/trunk/dports/perl/p5-padwalker/Portfile) 
Neat, but hardly seems like a huge deal. Having a sort function that does any significant computation is a giant warning flag to anyone with half and ounce of sense.
Or, what I think is more likely, the large company said "fuck it, we don't need to follow the GPL - they're just some small time company and won't be able to sue us". &gt; Does using Perl/Python/TCL licensing put your IP at risk? Yes, **WHEN YOU EVEN GLANCE AT THE FUCKING LICENSES**.
Q. What kind of company redistributes software without understanding its rights and requirements to do so? A. One that responds positively to marketing such as this.
I have only one thing that comes to mind when reading crap like that PDF: Please don't paint the developers of the company or their products with the same brush that applies to their marketing. At my own company i see the quality in perl development increasing leaps and bounds since i arrived and taught people how to use CPAN and modern perl (thanks for the book, chromatic). Meanwhile we all watch in dismay as management puts out press announcement of fake studies proclaiming their software as better than the rest of the competition. I wouldn't be surprised if jdb was groaning at this too.
Use Moose. Conway would have used it in his book if it'd been invented in 2000, I think. That doesn't mean don't read the book - I'm sure you'll learn a lot from it. [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) has a chapter on OOP that should get you going on the syntax, and Damian's book should still be good for concepts (although I haven't read it in a long time).
Read it anyway, then read about Moose. There's a chapter in PBP about 'inside-out objects' that Conway suggested as an OO framework long before Moose was conceived, but it's not been taken up by the community and you'd probably find it a lot easier to use Moose instead.
Both have their advantages, the "modern perl" way is Moose. Moose is also expensive if you're running in restrictive environments. 
Use Moose. Here's a recent analysis of how the chapter on objects has held up over time: http://blog.urth.org/2011/03/reviewing-perl-best-practices-chapter-15-objects.html 
Having done OOP both ways, the learning curve for Moose is quite steep. Doing objects 'right' is problematic regardless of approach. Moose is 'in' at the moment so why not? Modern Perl is good for reasons other than Moose so it is a good acquisition no matter what your final approach winds up being. I.e. get both...
I was going to answer this. Then I realized the link does that. I think they should remove this warning. my only takes one item.
&gt; my only takes one item ?? If I understand you correctly then you are incorrect; my instantiates as many items as you list. e.g. `my ($var1, var2, var3)`.
What I meant was that it either takes one item or one parenthesized list of items. Its not a list operator, so it doesnt take my $a, $b, $c; # NO
According to the [Parentheses missing around "%s" list][1] explanation in perldiag &gt; Remember that `my`, `our`, `local` and `state` bind tighter than comma. Consider: $ perl -le '($a,$b,$c) = 1..3; print my $a, $b, $c' 23 Enable warnings to see that the lexical `$a` contains the undefined value, *i.e.*, it parses as `print(my($a), $b, $c)`. Before you object, at least fifty examples in Perl's standard documentation use the form `open my $fh, $path` with no parentheses. [1]: http://perldoc.perl.org/perldiag.html#Parentheses-missing-around-%22%25s%22-list
The warning [appears][1] to be intended for code that fails to compile. An unchecked call to `open` is severely bad form, and this particular warning's heuristic failure has gotten little attention because I suppose code that does it likely doesn't enable warnings and uses bareword filehandles. [1]: http://stackoverflow.com/questions/5596874/why-does-perl-warn-that-open-my-fh-file-is-missing-parentheses/5597468#5597468
The simple answer, use inheritence: package Person; use base 'Manipulation'; # this is almost like copy/pasting everything in.. # the problems here will soon arise when you need to inherit from multiple classes like Manipulation... The better way is to use Moose and Moose roles: package Manipulation; use Moose::Role; sub walk { # do the walking } ..... package Person use Moose; with 'Manipulation'; .... 
What version of perl?
If you're not familiar with OOP at all, go with Moose... if there is one thing that's VERY clear, it's that you absolutely should NOT learn OOP by learning how to manipulate the inner workings of an interpreter, which is exactly what you're doing when using *bless* and manipulating @ISA. If you are familiar with OOP... actually still go with Moose, unless you really, REALLY have a burning desire to get into some black magic that won't be in any way applicable in another language. Better yet, skip Perl's OOP altogether and use Ruby or Java or something... don't get me wrong, I love Perl, but man, the Perl Way of doing OOP is absolutely horrible.
that makes more sense, apologies for my misconstrual.
&gt; I love Perl, but man, the Perl Way of doing OOP is absolutely horrible. Moose is pretty fucking easy to pick up. I feel you, but Perl still has signifiant advantages over pretty much every scripting language.
5.10
Yeah, I suppose if you're limiting your scope to scripting languages then Perl's OO syntax isn't any more horrible than any other scripting language. Compared to strongly-typed OO languages, though, it's an awful way to learn object-oriented programming, which was my point... if you know OOP already then go for it, if you're learning OOP, pick it up in Java first so you develop good OOP coding habits, *then* go learn how to do it in Perl. Otherwise you end up like one of my contractors who can write decent Perl but writes absolutely horrible Java code.
&gt; Compared to strongly-typed OO languages, though, it's an awful way to learn object-oriented programming, which was my point... Absolutely. Moose makes object orientation easy for Perl programmers who can't step out of their domain. I would not advocate anyone learn OOP via Perl.
I don't quite understand perl's internals, but I hear it's all one giant symbol table. If you learned this today, you probably also heard about File::Handle and Symbol, which provides the ability to generate (randomly named) symbols and anonymous handles. Knowing this can eliminate some superfluous code, leaving the remaining code more concise. Edit: found this while googling for the module containing gensym() : http://www252.pair.com/comdog/mastering_perl/Chapters/08.symbol_tables.html
&gt; Compared to strongly-typed OO languages, though, it's an awful way to learn object-oriented programming, which was my point... Which popular programming language with static typing has decent OO?
[Don't use bareword filehandles](http://books.google.fr/books?id=gJf9tI2mytIC&amp;lpg=PT226&amp;ots=HlZcmJrwlu&amp;dq=bare%20filehandle&amp;pg=PT224#v=onepage&amp;q&amp;f=false)
&gt; I hear it's all one giant symbol table It's not. Lexical storage is different from package symbol storage. Package symbol storage is typed (typeglobs have typed slots for the various package-level items). The problem is the use of barewords. Given a package name of `JSON` and a glob name of `JSON`, can the parser disambiguate between a method call on the glob and a class method call with the package? Avoiding barewords is important. That's why lexical filehandles have existed since Perl 5.6.0. There's no excuse not to use lexical filehandles 11 years later.
Stop using barewords as filehandles and the problem magically goes away.
It's extremely popular to hate on Java for any number of hypothetical reasons, but those of us who actually *use* it on a regular basis instead of bitching about it like it a lot. It sucks for scripting, and if you're using *vi* instead of a proper IDE it seems awfully verbose, but Java + the Eclipse IDE is a dream for large-scale projects.
Interesting you mention Java, as I have Eclipse editing a modest Java project on another desktop. Eclipse's refactoring (and what it can do for finding integration errors if you use the type system at all sanely) is the only thing redeeming Java's OO from being almost unusably clunky to something in which you can get things done without writing too much code and making too much of a mess, if you're careful. A *decent* OO implementation wouldn't make developers rely on the presence of an IDE to generate accessors and mutators for private attributes. A *decent* OO implementation wouldn't encourage the use of bean-style getters and setters for object attributes which a decent polymorphic constructor could exist. (A good OO implementation would make the construction and use of immutable objects easy.) A *decent* OO implementation could provide polymorphic and generic containers without type erasure. I could get rid of `instanceof` checks with a *decent* OO implementation. A *really good* OO implementation wouldn't need external frameworks to provide inversion of control. Finally, the less said about the problems of Java interfaces the better (especially when compared to traits and roles). *Edit:* Any worthwhile OO implementation doesn't need its own version of Spring to make unit testing tractable.
I think best practices these days is to use a lexical variable as your filehandle: open my $fd, "&lt;", "stuff"; my $file = join("", &lt;$fd&gt;); close $fd; [Also three-argument open().]
I note a surprising lack of *any* suggestion of alternative, better languages on your part. It's just a laundry list of bitching about Java that reads like someone who is working on a master's in CompSci but spent little to no time working in the real world... ...and in the real world, Java is still one of the best OOP languages we have to work with.
*I note a surprising lack of any suggestion of alternative, better languages on your part.* Let me correct that for you: * Smalltalk * CLOS * Perl 6 * Perl 5 with Moose &gt; ... in the real world, Java is still one of the best OOP languages we have to work with. Close your IDE and say that. (My guess? It's not Java or its OOP that you like. It's Ctrl+1 and Shift+Alt+S and Shift+Alt+T, none of which is a property of Java.)
Yes, I do like my IDE... you know why? I don't have the time or the inclination to repeatedly sift through documentation to find the name of some esoteric method I only use once in a blue moon, nor do I have the time to deal with tracking down a crash at runtime due to a misspelling or mistakenly thinking I'm getting back a class further down the inheritance chain or something. Too bad you can't even do something as simple as "autocomplete" in Perl even WITH an IDE, thanks to loose typing, the ability to add and remove functions at runtime, and it's bullshit inheritence rules. And refactoring? Forget it, there is absolutely NO way to automatically determine dependencies in Perl well enough to allow for automatic refactoring. As for Smalltalk and CLOS... not exactly widely used, now are they? My guess? You think you're several of orders of magnitude better at programming than you actually are. You know how I know that? Because *real* programmers don't sneer at any tool that can help them get their job done better and faster any more than a construction worker sneers a power saw. We have a job to do, and we're happy to let the computer help us out as much as it can... we leave the arrogance to the guys who don't have lives.
&gt; I wouldn't be surprised if jdb was groaning at this too. Actually, he kind of smiled and shook his head. There were a few people here who felt the title was a bit... alarmist. Apologies for hitting developers with a message that is really better suited to corporate legal departments. But... &gt; Q. What kind of company redistributes software without understanding its rights and requirements to do so? &gt; A. One that responds positively to marketing such as this. What chromatic mentions is true, but it's not because those companies are dumb or negligent. There are lots of companies using Perl or Python (sometimes in legacy applications where the original developers are long gone) who do not have a deep technical understanding of the language or full knowledge of the licensing that applies to the language or modules (many of which use a different license than the core language). One of the things these companies come to us for is indemnification. IOW: "You deal with this. You're our vendor, so you take the heat if we get hit with an IP lawsuit for anything in your Perl/Python stack." So it's not "indoor rhino repellent". It's lawsuit repellent/insurance, and some folks actually need that. 
Don't see how that makes a difference. The company is on the hook for the actions of the developer whether the infringement was accidental or intentional.
*Because* real *programmers don't sneer at any tool that can help them get their job done better and faster any more than a construction worker sneers a power saw.* *As for Smalltalk and CLOS... not exactly widely used, now are they?* When even James Gosling says he'd rather use Scala than Java, maybe Java's not the be-all, end-all of programming. (Without Smalltalk, you don't get VisualAge. Without VisualAge, you don't get Eclipse.)
If you *really* need your perl script to run in Debian Woody, you can always do this: local *JSON; open(JSON, "&gt; file.json") or die;
I know, I'm just commenting on the fact that the piece of marketing makes it sound like it's the *license's* fault. Like an innocent developer was going along one day, and all of a sudden **boom** the GPL strikes.
&gt; It's lawsuit repellent/insurance, and some folks actually need that. This is true. However, the whitepaper contains outright falsehoods. For example, the third paragraph alone is full of nonsense. If ActiveState's marketing department cannot (or *will not*) get its facts right, why should anyone believe their indemnification insurance is effective, or even necessary? I certainly think much less of a company that lies out of ignorance or malice to uninformed potential customers.
I didn't claim it was the be-all, end-all of programming... I said it has a decent OOP implementation and it's widely used. "Decent" means "not horrible", not *totally without flaws.* Kind of how Perl is a *decent* language... there are many other languages that do specific things better, but at the end of the day Perl is a fantastic all-around scripting language and you don't have to worry about finding a replacement Perl programmer when the old one leaves to "find himself" or something. As for James Gosling - he hasn't had to do any *real* programming (you know, the kind with deadlines and people screaming at you if you don't make them) for a very, very long time, so he can use whatever he wants. The rest of us have real work to get done, and Java is fantastic at that.
Afraid I don't have much background in graphics programming, but CPAN is usually quite a boon for something like this. Would any of these be helpful? I don't see anything that looks as simple as "here are two polygons, figure it out". http://search.cpan.org/~markov/Math-Polygon-1.01/ http://search.cpan.org/~ewilhelm/CAD-Calc-0.27/ http://search.cpan.org/~dvdpol/Math-Geometry-Planar-1.18-withoutworldwriteables/ http://search.cpan.org/~sifukurt/Math-NumberCruncher-5.00/
If the edges intersect, then one or more vertices of one polygon will be inside the other polygon. You can find whether points are "inside" a convex polygon by using determinants. When you know the edges that cross, you can solve for the intersection(s). If the two polygons merely touch, then they should have one or more vertices in common, and/or one or two vertices that are colinear to two vertices of the other. Again, you can use the determinant to tell of the points are colinear. 
I don't think that wouldn't solve the problem in the link. Either way, Woody had 5.6.1, so lexical open is just fine. Actually, older versions of perl supported lexical handles too, they just didn't autovivify them, making them cumbersome to use.
and then you can... hmm... for the case where the edges intersect, find the intersection points and make note of what edge they occur on (and what vertices are on each end of that edge, for each polygon). Then, start at an intersection point, and move to whichever neighboring vertex of polygon A is inside polygon B. Then keep chasing vertices around polygon A until you reach another vertex with an intersection on the far edge. When you do, move to the intersection point, and then start chasing vertices around polygon B, in whichever direction lies inside of polygon A. Keep going until once again you reach an intersection, which should be the point you started with, because unless I'm delirious at 2:30am, the intersection of two convex polygons is connected and they will only cross in two places :)
Came here to say this. You could definitely do it with Math::Polygon.
I'd recommend [Modern Perl](http://www.onyxneon.com/books/modern_perl/), if you want to write good programs. Don't get me wrong, there are lots of good Perl books, but Modern Perl is very up to date, puts Perl into a nut shell and what even better it's completely free.
No, not specifically, but he could've gone: my $json = JSON-&gt;new.... do { local *JSON; ... And fuck this. Woody's bad enough (I thought it was older because utf8 support sucked). No excuse; etch is too old.
Write it in C/C++ then translate into Perl.
You have C/C++ code? Post it here and I'll translate it for you. (Probably some other people here will gladly do the same.)
&gt;If the edges intersect, then one or more vertices of one polygon will be inside the other polygon. Wrong. Take a [Star of David](http://en.wikipedia.org/wiki/Star_of_David), for example: 2 triangles that clearly intersect, but neither of them have even one vertex inside the other one. But the rest of your whole approach does make sense. If the polygons intersect, you will have intersections, and you can test for them all (N x M), for each side of each polygon. I don't think you can take shortcuts. 
Do your own homework kid.
&gt; I certainly think much less of a company that lies out of ignorance or malice to uninformed potential customers. So what do you think about Strawberry Perl, given that they outright lie on their support page? (Marketing is Marketing, and everyone plays the game eventually and it has little to do with what is delivered.)
Dude, the algorithm is the hard part. It sounds like you've got that part down cold. So if you want this to be an exercise in Perl, rather than on who remembers their geometry, what you do is start out with some pseudocode, and then turn it into real Perl step by step. As others have said, I'm dubious that you are being genuine here, as if you've already been through graduate school and have done some C++, you *know* that these are the steps to tackling the problem. The fact that you have posted no information suggests that you know none. Sorry for the cynicism; a few years on Stack Overflow will do that to you.
I'm happy to publish an article on Perl.com about how to use the CPAN from ActivePerl, rendering the sentence in question moot.
Somebody buy this man a copy of PBP, stat! And a bareword file handle is just the start. Two argument open, not checking for success in the opens, useless interpolations. Someone has learned some really had habits and needs to have them adjusted. I used to be this bad, but now we have adopted a standard company wide perlcritic, and I have that run every time I save a script or module. Instant feedback has gotten me to the point where I can write a decent sized script and have it pass on the first save. But damn if that doesn't help correct problems before they become bigger problems.
Ooh, Star of David... excellent example of an test case I hadn't thought of.
I would actually like that a lot! (Though, what more is there to write than: Start -&gt; Run -&gt; cmd -&gt; cpan ?) During two training days at my company a highly-respected member of the german perl community also mentioned the same thing and i keep seeing it pop up again and again in many place; despite not actually being able to remember a time when CPAN wasn't included and usable. (Though there was an early time when there was no MinGW bundled, that time sucked.) The more people learn that ppm is merely an emergency fall-back, the better. :)
There's obvious utility for such an article. Do you have any recommendations for authors?
Except for `STDIN`, `STDOUT`, and `STDERR`. No way around using those.
A while ago jdb had written a longish article on the matter here: http://www.activestate.com/blog/2010/10/how-install-cpan-modules-activeperl We talked about it and thought it'd be best if i condensed it down to what'd be necessary to get ActivePerl cpan going on all three major platform types. If you have any input, please feel free to remark, otherwise, how can i reach you when i have a draft of an article?
And `ARGV` and `DATA`, but the odds of collisions there are lower.
s/tricky problem at work/college assignment by cheating/;
You probably want to run a network facing server under tainting mode. It can catch a lot of possible issues, at a relatively low cost (though this means giving up env, not that env gives you much). Also, check out perlbal for a high performance Perl based proxy server.
Thank you for both suggestions -- I'll look into them.
You're building a single gigantic data structure. You might want to use object orientation to compose the world of separate little objects. For example, even if you only had a single World class, it gets easier: my $world = My::World-&gt;new; my $city = $world-&gt;get_city('Willow Lawn'); print $city-&gt;list_buildings; Presumably you would also want other classes, ideally one class per "noun" like City, Building, Connection. Perhaps classes for Player and Movement. It will definitely make your code more readable and easier to type. Best advice might be to get a similar game already written in Perl with OO and see how they did it. Reading other people's [excellent] Perl code is a great way to learn.
&gt; So, with this structure, I have to use things like $world{'Willow Lawn'}{'Markel Building'}{'description'} just to get at simple data. Is this totally insane? Would throwing it all in a database where I can just reference key numbers and field names make a lot more sense? Well first off, the connections are likely coming up undef (I checked, they did for me). This is because Perl is going to evaluate those references before the outer structures have been created. Perl will create such inline structures from the inside out. So, the connections would come before the hashes containing them, before the location hashes containing them, and so on. As for how to reference them, how would you have expected to reference them otherwise to get at the deep connections? Which languages were you previous exposed to that exposed deep constructs this a different way? There are many ways to do what it looks like you are wanting. A database can certainly help and is definitely a very good choice if you expect to have evolving data over time. However, if the data is completely static you could: 1) Specify your references in some encoded string and then dereference them using a function when needed. (e.g., find_location $str). 2) Use Moose or other OOP to create an object oriented interface to create your regions and locales and then either have some lazy-object-creation function make the bits on demand or use more string referencing. 3) Create the locations first and then insert the connections later: $world{'Willow Lawn'}-&gt;{'Merkel Building'}-&gt;{'connections'} = [ ... ]. 4) Dissociate the connections from the rest of the locations and turn it into a pure hash by itself (whose keys are locations and values are arrayrefs of locations). When looking for connections, use that hash instead of membership relationships. There are likely many other strategies but those are the four off the top of my head that would seem to work. [Ignore this: One other thing, you need to use '-&gt;' on the hash references. Instead of $world{'Willow Lawn'}{'Faison School'} you need $world{'Willow Lawn'}-&gt;{'Faison School'}.] Best of luck on your project! [Edit 2: Fixed typo on #3
&gt; One other thing, you need to use '-&gt;' on the hash references. Instead of $world{'Willow Lawn'}{'Faison School'} you need $world{'Willow Lawn'}-&gt;{'Faison School'}. Perl doesn't require the '-&gt;' in this case. As long as it's been pairs of adjacent brackets (whether square or curly), you can omit the dereference arrow. Details are near the beginning of [perllol](http://perldoc.perl.org/perllol.html).
If you will not be moving to an object oriented interface, using 3) along with adding -&gt; as needed would be my choice if you want to continue down the data structure route you have begun.
Well, I'll be. Learn something new everyday.
about the connections coming up undef, one alternative would be to store just the strings, like: %world = ( 'Willow Lawn' =&gt; { 'Markel Building' =&gt; { description =&gt; "A small cylindrical building made of wrinkled aluminum.", connections =&gt; [['Willow Lawn','Faison School'], ['Willow Lawn','CVS']], }, 'Faison School' =&gt; { description =&gt; "A school for children with special needs.", connections =&gt; [['Willow Lawn','Markel Building']], }, 'CVS' =&gt; { description =&gt; "Everyone's favorite neighborhood pharmacy.", connections =&gt; [['Willow Lawn','Markel Building']], }, }, ); and use it like: foreach my $a (keys %world) { foreach my $b (keys %{$world{$a}}) { print "From $a/$b you can go to:\n"; foreach (@{$world{$a}{$b}{connections}}) { print "\t".(join '/', @$_)." ($world{$_-&gt;[0]}{$_-&gt;[1]}-&gt;{description})\n"; } } } 
Here's the p5p thread to go along with it: http://www.nntp.perl.org/group/perl.perl5.porters/2011/02/msg169627.html If you haven't been following this issue, make yourself some popcorn, sit back, and prepare for the drama. What I figured should be a welcomed, positive step in the right direction turned into a mine field.
My recent meme post reveals which side of the debate I'm on, by the way :) http://i.imgur.com/AKUiT.jpg (and comments here: http://www.reddit.com/r/perl/comments/gjld2/the_rock_on_perltoot/ )
use Moose; and create classes for every noun like mentioned by rjbond3rd, and: use Moose::Role to create roles for the shared functionality of all the other classes it's really the only way to go....
I use the Data::Dumper to see the datastructure, the result is below. Can anyone tell me why the order of Markel Building, 'Faison School',and 'csv ' are changed? Thank you in advance. print Dumper %world; $VAR1 = 'Willow Lawn'; $VAR2 = { 'CVS' =&gt; { 'connections' =&gt; [ undef ], 'description' =&gt; 'Everyone\'s favorite neighborhood pharmacy.' }, 'Markel Building' =&gt; { 'connections' =&gt; [ undef, undef ], 'description' =&gt; 'A small cylindrical building made of wrinkled aluminum.' }, 'Faison School' =&gt; { 'connections' =&gt; [ undef ], 'description' =&gt; 'A school for children with special needs.' }
How can this be *core* Perl documentation on OO programming if it doesn't contain a single example of using `bless`? As it is, it basically says "Use Moose, unless it's too slow and bloaty for you, in which case maybe use something else, but they're not as good as Moose anyway, so you're screwed". As much as I love Moose, it's just a module. Perl is a language and There's More Than One Way To Do it. It's not sufficient to say "we think X is better than doing it yourself" if you never actually explain how to do it yourself.
That's all still ther, from that very document: &gt; If you want to know how Perl OO works under the hood, the perlobj document explains the nitty gritty details. Keep in mind this is only meant to be the tutorial.
Ah, beg pardon. This is *pertoot*, not *perlobj*. Makes sense, then.
A hash is never guaranteed to keep it's keys in original order. It's why you see the "sort keys %hash" idiom often.
Happens to the best. :)
They are correct, it does end there. If you disagree, you should quote it on a HTML/XML level (for example with a CDATA block).
They don't understand string quotes inside &lt;script&gt; tags. If a string contains the '&lt;/script&gt;' character sequence, the available Perl modules mistake that for a real &lt;/script&gt; tag, as far as I know. No disrespect intended towards Perl. I think it would be better if they parsed JavaScript too, and interpret strings with their known escape sequences. My question was about this.
Just for grins and the outside chance of a better answer, take this question to PerlMonks and let them tear it (and possibly each other) apart...
&gt;In this case they believe the &lt;script&gt; block ends inside the str initialization. And they're right. Javascript code *may not contain* closing script tags. That's why you often see such a tag as string split into concatenated parts. For example: var a='&lt;/'+'script&gt;'; Your problem is not in Perl. Your problem is in your misunderstanding of how HTML should be parsed.
&gt; They don't understand string quotes inside &lt;script&gt; tags. Neither does [the HTML standard parsing algorithm implemented by every current browser](http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#script-data-state). Try following it instead of making things up.
Anyone know under what circumstances this is exploitable?
A carefully crafted URL could have caused the static file server to serve files from outside your expected web root.
Thank you. That settles it
It also seemed to depend on the built in web server being used without a reverse proxy, which is a rather uncommon production setup. The worker processes would also need read permission on sensitive information, which is even more rare. But there are far too many possible setups for us to test out there, so everybody should just upgrade and take no risk.
Uh, use lib?
Suggestion, try perl -MCPAN -e shell to manage your CPAN modules.
&gt;I tend to forget which cpan module is installed in which local::lib directory That's a bit silly. @INC is supposed to contain library *root* directories, so it's perfectly safe to put all your modules in the same one. So I recommend you to hunt down all your custom installed .pm files, and put them under one and the same root dir (taking the inbetween folders for the namespaces in to account, of course; a file Bar.pm for a module Foo::Bar should be in a folder "Foo", in the root dir.) 
&gt;I tend to forget which cpan module is installed in which local::lib directory That's a bit silly. @INC is supposed to contain library *root* directories, so it's perfectly safe to put all your modules in the same one. So I recommend you to hunt down all your custom installed .pm files, and put them under one and the same root dir (taking the inbetween folders for the namespaces in to account, of course; a file Bar.pm for a module Foo::Bar should be in a folder "Foo", in the root dir.) And: you can modify @INC safely, per script, using the environment variable [PERL5LIB](http://perldoc.perl.org/perlrun.html) (except when under taint), the command line parameter [-I](http://perldoc.perl.org/perlrun.html#*-I*_directory_), and the module [lib](http://search.cpan.org/perldoc?lib).
Blogspammer.
You can compile to C code and then native code. http://code.google.com/p/perl-compiler/
Has anyone here even used Perl 6?
I haven't used Perl 6 beyond a simple "hello world" CGI script (partly to test how easy it is to get the "AddHandler cgi-script" directive in Apache to work with other script interpreters than `/usr/bin/perl`).
HIB0U?
i think its a mistake to write-off the python effort. by end-of-life'ing python2, they've essentially forced an upgrade path on to users. in 2011 they're going to whine about it...by 2013 they'll be glad they forced most of the community to move forward without a clear motivation to push perl5 coders forward, i wonder how many will ever bother with perl6. perl6 needs them...the equivalent of cpan for perl6 will never emerge from the current small community of perl6 coders 
yes, but mostly for the sake of learning perl6
Perl6 is already starting on its own CPAN: http://modules.perl6.org/ And the motivation for Perl5 coders will be that it offers many features Perl5 doesn't. I know i'd love to start using it in production today.
&gt; by 2013 they'll be glad they forced most of the community to move forward Meh. The Python upgrade from 2 to 3 is not a huge one. They've cleaned some things up, removed a few warts, etc. Once everyone has upgraded to Python 3, things will not be too terribly different from the way they are now in Pythonland. As far as Perl 6 getting more users, they don't need to do that by converting Perl 5ers. People coming from other languages (ex. C++, Java, Python, Ruby, PHP) are potential new Perl 6 users. 
&gt; People coming from other language... ... as well as people who've never programmed before.
perl 6?! im still mastering Perl 5
*As far as Perl 6 getting more users, they don't need to do that by converting Perl 5ers* i think this is naive. in my opinion, the core of perl6 coders will indeed emerge from perl5. c++ coders are likely in the market for a systems language, they're likely looking at go or rust. java coders will want to retain jvm portability, they're likely looking at scala or clojure. python and ruby people already think they have something superior to any version of perl, and i'm not sure i would want php coders even if they were interested. come back in eighteen months and i am convinced i will be proven right as it will become obvious that there needs to be a concerted effort to bring forward the mass of perl5 coders
just because perl 6 is a different language doesn't mean it won't interoperate. A lot of the perl 5 CPAN will run on perl 6. a lot of it already does. That ability to mix and match will be a great kickstart for the 6pan.
Well, you could do precisely what you propose. my @lines = (); my $cur; while (&lt;&gt;) { my $day = (split /\t/)[0]; if (not defined $cur or $day == $cur) { push @lines, $_; } else { process(@lines); @lines = ($_); $cur = $day; } } process(@lines) if @lines &gt; 0; EDIT: this has a bug!, see kahirsch's solution in his reply
This is the right idea, but you have a bug. Variable `$cur` will never be assigned a value. use strict; my @lines = (); my $cur; while (&lt;&gt;) { chomp; my $day = (split /\t/)[0]; if (!defined($cur) || $day != $cur) { if (@lines) { process(@lines); @lines = (); } $cur = $day; } push @lines, $_; } process(@lines) if @lines &gt; 0; I've probably written hundreds of programs like this over the decades, using either `awk` or `Perl`.
Hooray!
This is fantastic.
Now, if I am pushing the rest of the input from &lt;&gt; into an array and holding onto it if I need it later, might I not as well open the whole file into an array and do my sorting and selecting from there? My problem is, I don't feel I can store these millions of lines into an array, so I wanted to use while &lt;&gt; to process them one by one. But if I could somehow manage the "bundles" of lines that come through and execute code between them then I won't have to store anything in an array but the bundle. EDIT: Nevermind... this is brilliant, mates. Thanks! I love this subreddit!
yes i'm aware of that page...i'd love to contrib more but i can't even get Pie (installer) configured on arch linux. 
Why would you insist on using mod_perl. Why not use Plack. It can do most things mod_perl can but allows you to switch to other environments easily. Unless you want deep integration with Apache, it doesn't really make much sense to use mod_perl IMHO. YMMV.
Spoiler: module authors weigh in.
He's right. For all the stuff people rag on Gentoo for, CPAN's often worse. Last time I installed Catalyst it pretty much consumed an entire day.
From the comments: &gt; I know it wasn't the point of the rant, but would you mind (if you still have the 10403 lines of output) posting (or mailing jesse@perl.org) the failure. I'd like to make sure that it doesn't happen for anyone else. Jesse++
tl;dr: 1. Moose is big. 2. Net::Twitter uses Moose. 3. jwz didn't have Moose installed.
_4. Net::Twitter original author explains the situation. _5. jwz didn't check out other lighter-weight modules like Net::Twitter::Lite.
Often worse, based on Catalyst? Wouldn't you agree that Catalyst is the extreme case?
&gt;The dependency hell that follows results in 49 tar files downloaded, 91 packages installed, and 10,403 lines of compiler and installer output. And the problem is ... what exactly? Run it in a screen or other terminal and go back to doing whatever else you had going on at the time. &gt; *Boxcat's comment about the database drivers* I've installed the MySQL and Pg DBI drivers quite a few times, and i've never had problems with them not working after a simple `cpanp -i DBD::mysql DBD::Pg` I've personally yum upgraded a Fedora linode from Fedora 8 through Fedora 13 (major version upgrade via yum rather than reinstalling) and each time it took a day at the most - AND THAT is supposed to be even more painful than CPAN dependancies. Maybe I'm not trying the right modules (fires up a shell) but I think all these dependancy-hell blogs are just full of shit.
Oh look, Net::Twitter is installed already... in &lt;3 minutes (Granted I had most of Moose already installed, but that didn't require any babysitting either).
Agreed with this. I would suggest either Plack or Catalyst for new projects. DON'T starta a new project with mod_perl unless you want to be the guy supporting existing mod_perl apps for the rest of your life.
Why would you use Plack? Mod_perl has been exhaustively tested under high loads. It just works. Plack is great for hobbyists but does not have the production chops for high traffic sites. My company's site runs under mod_perl because if it does not run (and run well) we have potentially 60 people out of work. Plack, while fun to play with, just does not inspire the degree of confidence needed. Just because it is new and the latest fad does not make it better
&gt; jwz didn't check out other lighter-weight modules like Net::Twitter::Lite. Nor should he be expected to.
Also: the standard cpan client doesn't know how to handle conflicts yet. Moose dependencies change, and new versions are sometimes incompatible with older support modules (e.g. namespace::clean, Package::Stash).
Really? "I don't like how big this package is" naturally leads me to "I wonder if there's another package that does this and is smaller". I mean, it's even listed on the twitter [dev page](http://dev.twitter.com/pages/libraries#perl). I guess when I have a problem I tend to look for a solution instead of whining about it on my blog. Ninja edit: It's even in the pod for net::twitter http://search.cpan.org/dist/Net-Twitter/lib/Net/Twitter.pod#OMG!_THE_MOOSE!
Things _should_ just work. But a search on CPAN for "twitter" brings up both Net::Twitter and Net::Twitter::Lite (as the two top results). Still, I enjoyed his rant but moreso, the responses. 
Should've just used cURL.
Hi aggrolite, mod_perl is tons of fun. 1. Write a simple "Hello World" handler that generates content. Then go from there. 2. Write handlers for other request phases. You could write a custom authentication handler, or something to ban IP's, or throttle bandwidth hogs. Hundreds if not thousands of very useful possibilities. 3. Get one of the several excellent mod_perl books. "Mod Perl Developer's Cookbook" is an easy read. 4. Find a project which uses mod_perl, and then read through the source code.
Other stuff is pretty bad too. An average module pulls in about a dozen deps, and often there's not much overlap.
Oops, thank you very much :). The thing is, so have I, yet I still manage to write them with bugs :).
Turning the prereqs policy to follow makes much of the pain go away
Are you installing it on a 386 or something? :-p I did a clean perlbrew install just a couple days ago, and installed Catalyst, DBIx::Class, TT2, and a bunch of MooseX and Catalyst::x stuff, and all their dependencies (including DBD::Pg, Moose, and all the Test::x and Module::x and build libs, etc) and it took about **15 minutes, unattended**. Try cpanminus, or configure your preferred cpan installer to work unattended.
&gt; Are you installing it on a 386 or something? Celeron actually, my work won't give me anything better.
your employer won't give you anything better than an $89 computer???? seriously, go collect some aluminum cans out of the garbage, cash them in, and buy yourself a better system. 
really, it took me on a fresh debian install about 20 minutes...
celerons should be outlawed.
I'm kinda surprised noone ragged on OP for not using strict or for not using warnings - both of which would have told him outright where the error was.
TILA [cpandeps](http://deps.cpantesters.org/) and [ttytter](http://www.floodgap.com/software/ttytter/)
Or telnet. That's standard way.
Isn't that merely the price of reusable, well-developed, well-tested code?
Plack is an abstraction layer around webservers, nothing more, nothing less. You can still use it with mod_perl, and in fact plenty of people do exactly this. I don't know where you get the idea that Plack is for hobbyists. It's very solid, and the latest version of frameworks like Catalyst and Dancer actually rely on it instead of their custom abstraction layers.
totally (prefix) agree: ++jesse; This has been on my mind of late and I'm pleased that a notable perl hacker stepped up in the gale of a rant and asked the critical question: do you happen to have that error message? Some quotes that I hope lead to food for thought: [Why not be honest and resign yourself to the fact that version 0.8 is followed by version 0.8, which is then followed by version 0.8?](http://www.jwz.org/doc/cadt.html) -- Jamie Zawinski (vs:) [I think making the right choices when you face them is the best way to say how things should be done](http://notes.torrez.org/2011/04/an-empathetic-plan.html) -- Andre Torrez (via:) [ Most developers aren’t doing things that seem stupid or wrong because they themselves are stupid, but rather because decisions previously made reduce the options that are available to them.](http://rc3.org/2011/04/12/against-carping/) -- Rafe Colburn 
I love Perl because it is so relaxed... you don't need to formalize unnecessarily. Just dive into it. I have used chronologically Basic, Pascal, Assembler and C before, and none gave me this positive feeling. Maybe it's the easiness of using hashes, maybe it's because unlike C and Pascal, strings can grow arbitrarily large and I don't have to worry about them, maybe it's because Perl rarely throws error messages for trivial things... I just feel pampered with Perl... 
Can you be more specific? A 500 error code usually means the server responded but doesn't know what to do with your request. Simply writing a "use CGI::Session" won't do anything in your script. What are you using in that module. An example snippet of your script would be helpful. Also, i doubt you have to upgrade anything on the server side.
I take my script that works just fine, then add the following line to the top: use CGI::Session; And suddenly my script stops working! It's very frustrating. When I have this line: use CGI; it works just fine. Any ideas? Thanks btw!
Just to make sure, both of these lines are in the top of the script, right? If so, and *all* you're doing is adding 'use CGI::Session;', then it may just be that the module doesn't exist on the server. Fwiw, "use warnings;" will give you a better idea of what's up if you exec it via commandline, or have the access to view the error log for your account. If you have SSH, you should be able to just run the command by hand 'perl blah.cgi', and get the appropriate error.
To find out more about the error, you need to take a peek inside the server error log. If this is Apache, it would typically be called "error_log". For CentOS, it's usually in /var/log/httpd. But why not try this: at the command line, run: perl -e 'use CGI::Session' and see if it's even installed in a default location. Also, for development, try putting this line at the top of your script (but only for development, not production): use CGI::Carp qw(fatalsToBrowser); It will stick the error in the 500 error for convenience.
I would have thought that the module would exist on the server, since it's Yahoo. It's not exactly their first rodeo... But then, it appears that they were kicked in the head in one of their earlier rodeos, so who knows! The error log has been pretty much useless, a lot of incomprehensible stuff. Looks like a compiler having a nervous breakdown. Running any command-line items on Yahoo seems to be out of the question, they don't seem to support ssh, telnet or rlogin. (You get the feeling that Yahoo sucks, right? Me too.)
Excellent! This did the trick, and sure enough it can't find session.pm in the INC. (Hmmm, maybe this IS Yahoo's first rodeo!) How do they host perl sites when they don't have sessions? 
Solution: I don't know if this will work in the long run, but since Yahoo doesn't seem to want to answer my email &amp; trouble-calls I've decided to put a copy of Session.pm and ErrorHandler.pm in the directory that I'm using. To do that of course I've had to modify my code to use Session instead of CGI::Session, and I've modified Session to use ErrorHandler instead of CGI::Session::ErrorHandler. Thanks to all who replied, I couldn't have fixed it without your help! 
The right thing to do would be use lib 'whatever' and then you can put all the modules in the right directories, as in, you can have CGI::Session at whatever/CGI/Session.pm and so on.
afaik, CGI::Session isn't a standard Perl module that's likely to ship with a standard installation of Perl. And, despite its name, it has no direct relation to the "CGI" module; it just uses the same namespace.
Just to be clear, I'm not writing it off. I'm using Python as a jumping off point to write about Perl, and my blog post should not be read as really saying anything about Python.
Interesting side note here, the reply to my request for support by Yahoo resulted in a canned response. In that response it said "Currently, Yahoo! Web Hosting does not support member-uploaded programs such as CGI Scripts." A little later, it had this gem: "For a full list of the file types that we do support, please go to: http://webhosting.yahoo.com/v/filetypes.html " When I looked at that site, it very clearly lists Perl as well as Java, pascal and PHP. Is it any wonder that Yahoo's market share is tanking?
I really hope this isn't a final farewell; I use his modules pretty much whenever I'm writing in Perl.
Thanks for the kind words. It's not a farewell. Just a note of what I notice about my involvement.
it seems like someone has ticked you off i've been in this boat before...it seems i have had the misfortune of working with some very abusive individuals over the years...my strategy for dealing with them is this: *i'm doing something i like and you don't get to take it away from me* because i have found that ultimately that is what the abusive personality likes, to get you to quit. they thrive on negative outcomes so don't give it to them. just tune people out. the internet is full of assholes, you can't re-educate or moderate all of them, so just let them go about their business and make sure they don't mess with yours. you clearly like or have liked hacking perl, and you must know we use and download and run your code all the time too...so keep doing it if you like it. only stop if you have found something you like more 
Thankfully, I'm not seeing in the Perl 6 community the issues you mention. 
Does anyone know what's caused him to write this?
There might be some truth in that, but I guess that nobody has hard numbers on that. 'The perception of language communities of each other' could make a nice sociology paper.
I am amazed at how eclectic and tolerant and curious Perl hackers are. The attitude toward languages seems to be: why not learn as many as you can, and take the best from each?
I am sorry to read this. I'm not wired into that inner part of the community. I only see the cordial and collegial interactions. But I can certainly understand why you would feel exhausted from that.
I haven't, either, which is why I hang out in Parrot and Perl 6 much more.
Years of bad behavior tolerated by far too many other members of the Perl community, I assume.
I take it you're asking for a specific problem that broke the camel's back. The specifics don't matter.
This is not as nicely put, but i think it represents what you're saying: http://programming-motherfucker.com/ It's what i do whenever i get annoyed with stuff, be it at work or in the community. Just sit back and get some programming done so the day ends up being useful.
While this may be, in some respects, an accurate observation; i cannot condone it. This is simply because it in itself represents an attack of the sorts that it sets out to deride.
While watching the video, my 7-year-old just walked by and asked me, "Is that the actor for Han Solo?" :) 
I think a Perl hacker's attitude towards Python is more like "I could never get past that whole whitespace thing, but some people like it a lot." Spot on about the Python hackers, though.
Funny, I thought I would have heard of a language that was as influential as he seems to think Cobalt has been.
Do you mean COBOL?
Hah, I read the transcript first too!
Moaning about Python whitespace is on the same level as complaining about Perl line noise. It's not even remotely getting the point.
I would guess that that was temporary. 
Whoever transcribed that conversation must have had no idea what Larry was talking about. 
Well a post like that is going to make people wonder, so you can't blame us for being curious! Personally the only perl community I really see is PerlMonks, which seems polite enough when I dip into it. Very sorry to hear you feel that way anyway. I have a huge amount of respect for you, and if the community might lose your contribution as a result of this, it really ought to prompt some self-examination. 
Do you think she got permission from [O'Reilly](http://onlamp.com/pub/a/oreilly/perl/usage/)?
nailed it
Translation: I laughed my ass off.
tl;dr JavaScript, Java, Haskell, C, and Perl
&gt; Java is sort of the COBOL of the 21st century.
are Perl and her the same age ?
Is it just me or is Larry always a pure joy to listen to or read?
I believe it was O'Reilly who had the temporary tattoos printed for one (or more) of the Perl conferences. Brent Michalski has a [real Perl camel tattoo](http://www.spidereyeballs.com/os5/set1/small_sm_os5_r18_0805.html).
Hell yes. I had the opportunity to have lunch with him and many other Perl big-guys at YAPC::NA 2007 in Houston, and that was an absolute blast.
No, most decidedly not the case. I am being entirely sincere in what i said.
Personally, I thought the cartoon was saying that a malleable approach can incorporate a rigid one, but not vice versa. Of course opinions will vary and I appreciate what you're saying.
Now that you called for it, I might ask one of my sociology major friends, and see what she says. According to one of them, there is more accurate data that can be recollected from digital builder "tribes". Term she uses for the sub-populations of prog.lang. communities.
Thanks for understanding. :)
The only one I never looked into was Haskell.
What do you mean by "OO structure"?
Haskell is very much worth your time. [Real World Haskell](http://www.realworldhaskell.org/) is a useful resource.
Perl itself doesn't have an OO structure. Instead, it allows you to tag a reference with a string. Then, if you attempt to call a method using that reference as an invocant, the Perl interpreter will attempt to find that method in a package named that string, or a package in that package's magical @ISA global variable. That said, it's pretty easy to build OO frameworks on top of that. [Moose](http://search.cpan.org/~doy/Moose-2.0001/lib/Moose.pm) is driving a lot of practical OO research and is pretty darn useful in production, too.
For `POE` (event-driven stuff) users, I wrote a `Capture::Tiny` equivalent recently called [`POE::Quickie`](http://search.cpan.org/perldoc?POE::Quickie).
&gt;http://poll.pollcode.com/uMt `autodie`? Seriously? It's been in core since 5.12.
The thing to do is, replace your mod_perl things with fastcgi things.
 alias j2y="ruby -rubygems -e 'require \"json\";y JSON.load(STDIN.read)'" alias y2j="ruby -rubygems -e 'require \"json\";j YAML.load(STDIN.read)'" Convert between YAML and JSON. Often I'll use it to read/write JSON in a more human-parsable format. As a side-effect, it will check for well-formed syntax.
Actually this isn't entirely true... You can still build the modules, you just have to edit the Makefile and remove the -arch ppp portions and then do your make. Pain in the ass, yes. Full blocker? Nope. 
I agree with this post and personally I would kick guys like mst in the teeth until their teeth would fall off. I believe mst and his gang is basically responsible for most of the bad stuff described in petdance and chromatic's posts. Someone would need to raise awareness about this and tell those guys that they need to calm down with the aggressive attitude they're throwing around. Again, I'm not saying any names, I mean basically people like mst or apeiron and some other guys, but I'm not saying any names if you know what I mean. The channel perl on Freenode needs to be taken over by someone who is calm and neutral and knows how to do things right. irc.perl.org needs to be decentralized completely as it's basically a gang-controlled IRC network, some sort of monopoly if you will, and that's not good, that thing needs to be discouraged, completely, in order to kick mst in the teeth and his gang.
You ARE saying names, and I don't think it helps. It degenerates into he-said/she-said. 
It might turn out to be a good thing.
I take that pledge as well.
It could but I doubt it. What needs to happen is the community needs to stand up and start challenging when it happens. If that happens, the problem probably goes mostly away.
I don't want to be in the same club (or room) with anybody who wants to "kick guys in the teeth." Why would you think that it's acceptable to say, "So and so is such a jerk that it's okay to threaten to kick somebody in the teeth"? The first thing to do to promote civility is to be civil.
Upvoted for truth. I'd like to spend more time on Perl related IRC channels, but I can't handle the attitude of people like mst.
I agree completely. It's possible to encourage people behaving badly to change their behavior in a civil fashion (or to remove them from the list, channel, or project for a time) in a civil fashion. When civility becomes a game of upsmanship, it ceases to be civil and starts to become its own problem.
I hope this movement takes hold. I too have been driven away from the Perl community by the baseless hostility and hair trigger kick/bans. This comment from the other thread rings true to me. But since a certain someone's name didn't come up over there, I'm bringing it here... &gt; Saving this to rub in the face of "I'm talented so I can be as rude as I want" divas. Uhh, no, you can't, that makes you a sociopath. If/when a call to action is taken up, I will gladly stand in your corner. I doubt it's possible at this point but if I were king I would revoke op privileges from the individuals causing this toxic environment. Regardless of how helpful they think they're being and how many projects they contribute to. They're doing far more harm than good and it's going to start adding up... 
I agree with rjbs on this one. The post called for civility, and your answer is completely the inverse. But one must remember that #perl@freenode and irc.perl.org are for helping, and mostly to give feedback. For more than 2 years, I've seen people not asking, but expecting other people to do their work. I've thrown more links and documentation sites than any actual comment or saying to a supposed question. So what really happens here is a misunderstanding about what is a real-question, a quick query, and an unworked issue. For an unworked issue, I'm referring to all the RTFM questions or all the ones that feel like replying back with a "Google is your friend". There are several texts like ESR [How To Ask Questions The Smart Way](http://www.catb.org/~esr/faqs/smart-questions.html) that prove to be the solid first guide for any one in doubt. So what should be speculated in the future, is the need for a balance; without balance the community will be totally shut closed to any newcomer, or on the other hand, an utterly mess without any critics and guidelines on what is correct and modern. Note that is not what is expected in Perl, remember Tim Toady, but there are certain criteria made by the community and the foundation which lead to a quality that everybody is entail to. &gt;In short, the Perl community needs far more people like Karen Pauley, Ask Bjørn Hansen, Jess Robinson, Tim Bunce, and, yes, Larry and Gloria Wall. If you agree, please, please speak up. Yes, we need them, but as much as we need the last mentioned, we need a mst in each community, and also a grumpy person like Linus Torvalds [that rejects patches for quality purposes](https://lkml.org/lkml/2010/10/13/333). High expectations are not exclusive to the Perl community, it can be found in every other community, and still is thought as a normal thing. Not that it is, but sometimes there is a purpose for it. For example, Gentoo forums ,Debian packaging rules and bugs, and the Linux Kernel mailing list. Balance is the key. 
A prominent perl figure writes that impoliteness in the perl community is to be the expected norm and acceptable because that's how the internet works and that one should go offline to interact with polite perl people. I'd like to tell him just why this kind of view is straight-out damaging to perl in his blog, but since he disabled comments i can only write about it here and hope he sees it: While he may be right about the internet leading to easier slips, they are still completely unacceptable. In short: Ignoring the online and retreating to the offline would make Perl an echo chamber. Not only that, it would make it a shrinking echo chamber, because newbies rarely enter the world of perl by saying to themselves "hey let's visit a perl con". They enter it by reading and posting online and learning about Perl there and if the thing they are greeted with is insults and abuse and a stance that such behavior is acceptable, since it is, after all, online; then they'll just be pushed away. I hope he'll reconsider his stance.
Offense is not in the intent but in the reception. The thing that bothers me most about this most recent round of "Perlers be nice!" rants is that those crying into the bucket this time are among those who have at different times managed to offend and curtail contribution through rude and dismissive comments of their own over the years.
I haven't been too active in the Perl community but I have always had a good experience with the community when I really needed the help. The Perl community has been the best when compared to some of the other language communities. One of the great things about Perl is posts like this and how a post such as this happens, it gets spread throughout Perl community and we all know about it. Ill pledge to it and to be more active.
"He who is innocent, cast the first stone." Right? But i think it's also noteworthy that they kept from naming names. They're not looking to lambast others for mistakes they may have made themselves in the past. They wish to improve the situation as it is now. It is possible for people to learn new things and better oneself.
&gt; Offense is not in the intent but in the reception. That's one of the stupidest things I've ever heard. While it's true that people may be offended where no offense was intended, in most cases it's *very much intended* and everyone knows it. It's pretty hard to say that when someone tells you to fuck off, it's *your* problem if you're offended.
&gt; are among those who have at different times managed to offend and curtail contribution Doesn't make the goals any less worthwhile.
Plus, 99% of the community do not attend offline meetings. Even if everyone could go to YAPC or OSCON, what about the other 51 weeks of the year?
&gt; Balance is the key. As long as that balance doesn't include abuse, insults and disrespect of others. No newbie question warrants it. &gt; For more than 2 years, I've seen people not asking, but expecting other people to do their work. Me, too. Doesn't excuse insulting people.
Yeah, i think that part went without saying really. Heck, i do have a local perl community, but i never bother to attend PM meetings, because they sit in bars that are too loud to have a civilized conversation and never actually talk about Perl.
&gt; The thing that bothers me most.... I know I've done that. I was in the wrong then. You have my permission to tell me I'm in the wrong if it happens again.
Thanks. If we ever meet in real life I'll buy you a beer or other libation of your choice and we can continue exploring your estimation of my opinions.
I think setting the environment variable "ARCHFLAGS='-arch x86_64'" will get you around even this.
I'm definitely interested to see where this heads.
*That's one of the stupidest things I've ever heard.* I don't think that's really helping.
Thanks for that. I see that Moose is modeled after Perl 6, so I assume it is meant to fill the gap until Perl 6 is released and widely adopted.
Personally, I use Perl 50% for web programming, and 50% for sysadmin tasks related to VM's, monitoring, provisioning, syncing, failover etc. We also use it to manage a huge Java enterprise app (strange but true). When to use Perl vs. another choice? For many folks, it comes down to the CPAN (http://search.cpan.org) which is a vast repository of re-usable code. Spend some time searching and you'll get a feel for it.
That was actually deliberate, and I was wondering when someone was going to notice. Basically, the OC (original commentor?) is saying that, hey, it's just words, and so they shouldn't find any offense in what I said, right? After all, offense is in the *reception*, isn't it? :-)
You'd more than likely use it over ruby when it seems like a better fit, which is a crappy answer when you're looking for certainty but really highlights the important thing: get skills with the tools you choose to use. I used to write Python exclusively for sys admin work, then switched to Ruby because I had taken twenty minutes writing a program in python that I thought should have taken sixty seconds, so I pulled up an online ruby reference and wrote the program in sixty seconds the first time I tried. I wrote Ruby for a year and a half, two years, then switched to perl because I switched jobs and there was one person who knew ruby (me) and two people who knew perl (me and someone else) and I wanted to give the company a more maintainable codebase. By all this, I mean that there's no right language, just go with the flow. FOr build environments, make is probably the language you're looking for. Or shell script. Or Perl, or Ruby and rake, or whatever. Ruby's pretty popular right now, Perl will be a workhorse for years to come. For what it's worth, I see ruby and perl as being two very commonly offered languages when someone is offering a high level API to a service.
If you need a program to have very fast run time, and can afford a long development cycle, go for C, C++, Java. If you can be satisfied with tolerably fast run time, but need the program soon, go for Perl ( or Python or Ruby, depending on your taste.)
Perl is good for: programming. Perl is not good for: floor wax, desert topping.
&gt; the most toxic things man has ever created: the mailing list thread and website comments It takes some amount of guts, maturity, and tact to moderate website comments ("hey! why did you delete my comment you jerk!"), and likewise (plus sometimes humor) to send useful replies to rude comments made on mailing lists (replies that diffuse potential public blowouts rather than having the opposite effect). Hopefully the Perl community has enough people with those qualities willing to take a moment or two out of each day to do their ... "civic duty". **edit:** "community service" :) 
Do you see how your interpretation differs from my intent? Do you see how my interpretation might differ from your intent? Do you see how another reader might take what you say in a way different than what you expected? Does that make them wrong? Does that make you wrong? I think this thread and the meta thread around it comprises a fantastic illustration of some of the dimensions of the sociological experiment that contains the Perl community.
I'm having a terminology impedance problem. I think of tests written to illustrate bugs discovered after deployment as 'regression' tests. Integration tests are those that are written to illustrate problems that might arise when modules are combined. And unit tests are those that are written to convince ourselves that new code works well enough to commit for release. I'll site Wikipedia as corroboration for this usage. Still the point is well taken. Taking the time write automated tests for failures that have been seen in the wild is more valuable to code quality than the ones we write to convince ourselves that our code works in the first place. In all cases though, an automated testing framework must be used to run all available and valid tests. Applying and revetting the complete test suite on regular intervals is a critical part of insuring confidence in the application. BTW, Commenting directly on the blog failed for me. I suspect pilot error.
I think that saying "Offense is not in the intent but in the reception" *as a blanket statement* is blaming the victim in the worst sort of way. It is typically uttered as a defense by those who are called out for offending. In general, it is very clear where the offense lies, and while there are exceptions—there are those sorts of people who will take offense at almost anything—it is not with the person being offended. Take that as you will. (And no, I am not surprised that someone took what I said as autarch did, for example; I rather expected it, in fact, because I was, after all, being deliberately offensive. In this case, however, I do think autarch is wrong—I think you were being deliberately provocative, and I think your replies confirm that.)
I think we will never come to an agreement on this point. It seems that you continue to presume that my initial comment was intended as an excuse for the offender. Rather my intent was to emphasize the frequency that what we say in jest or in passing or as a dismissal has more hurtful impact than expected. I suppose I could have been clearer. I'm sorry if I confused you. Of course your response to autarch and this response indicates that you did intend your comment to be offensive. So at least I did not mistake your intent.
For me at least computer problem solving works kinda like this: * Do I know a solution that already exists? Use that. * Can I find a solution via my module search or google? Try that. If it works great! * Can I put a small number of things together that solve the problem? Use perl as duct tape. * Is the performance of the solution not good enough? Benchmark, tune and rewrite using perl, other tools or C. It is rare when I end up at the last step. Most of the time someone has solved the problem already in some other way or a simple command line adaptation will do.
Ahhhh. Yes, I would say that we have here a fine example of how miscommunication occurs! I'm afraid that I frequently see that phrase, or variations of it, as an excuse for the offender, rather than as what you, I now see, intended. Please forgive my misreading, in that case! Language is always fraught with peril, even in direct, person-to-person communication, and the medium of the Internet—with no facial expressions, delays in response, and so on—is so very much worse. Of course, my "that's a really stupid thing to say" remark was based on the interpretation that you meant to blame the offended rather than what you have just made much more clear, and was intended somewhat wryly, as I hope my comment to autarch indicated. (I believe the correct Internet meme would have been, "I see what you did there...") Personally, I *loathe* behavior of the sort that chromatic and others are rightfully decrying, and I am very pleased to see them standing up against it. (And I think the perl community is actually *better* than some other communities I could, but won't, name—at least, I don't see the rampant misogyny in the perl community that I see in some others.) That's a long-winded way to say, wow, way to prove both of our points, I think. :-|
Just for that I want to go to OSCON :]
 perl -pi'.bak' -e 's/this/that/' file1 file2 The above is one of the handier ones to learn. It does an in-place S&amp;R and takes a backup of the file ("file1.bak" ...) as it does it.
 perl -ne 'print if $. &gt;= 17 &amp;&amp; $. &lt;= 30' The author seems to know about the `..` operator but doesn't know that it matches `$.` by default when used with a constant expression, so the above can be better written as perl -ne 'print if 17..30' There is no need for nonsense like `int($.) ~~ (17..30)` or `grep { $_ == $. } 17..30`. perl -ne 'print if /^[[:alpha:]]$/' Surely there is a missing + or \* there, because otherwise that only matches lines that contain exactly one alphabetic character, not lines that contain only alphabetic characters. 
I've listed the one that were requested in the original blog post but I should have checked on that though, my bad! ----- side node: I have to say I am only using 5.8.8 as it's all there is available on all the projects i work on so i am not up to date with every new modules added, perl5.12 dates from last year, did not touch it yet. perhaps when companies will upgrade to it, in say, 4 or 5 years.
What's the output above that? A problem installing GD is frequently due to a missing library or development package for an image format (libjpeg, libungif, etc.), but I can't see where the problem is based on what you've posted.
Unless you really need GD as a dependency, you might try a more modern package, such as [Imager](http://search.cpan.org/~tonyc/Imager/Imager.pm). It installs real good, and I find it's generally more pleasant to work with.
This is great! I'm going to experiment with this ASAP. 
pleasant in what way ? 
The name and value attributes of the button get sent to the server just like other form pairs. Can you show some example code?
Believe it or not, that was the clue I was looking for! It never occurred to me (DUH!) to look at the name/value pair. Thanks!
Java's run times are faster than Perl?
Perl can be used for just about anything. You can solve simple problems at the command line with one liners or you could write a [video game](http://www.frozen-bubble.org/) with it. I've written a point of sale system in Perl, along with all the web and system administration stuff it's good for. I guess it just matters if you like using the language or not. It's more of a personal preference than a right or wrong thing. In my experience it works well in Unix/Linux shops for just about any business oriented task.
In the Llama book they talk about it being good at dealing with text, and less so with "everything else". Do you find that to be true, and what is "everything else"?
I think Perl is perfectly suited for text handling. It's the swiss army chainsaw of the Web. And there are libraries on CPAN that do just about anything else you would ever need to do with a programming language. Perl uses a native implementation of the standard Tk library so you can easily make a GUI and have it look like anything you want. A lot of people feel that Perl isn't good for larger projects because the code can be hard to read, therefore hard to debug and troubleshoot for other people down the line. If you comment your code and follow the best practices for coding in Perl, your code should be no more difficult to read than the same logic in another language. Perltidy helps, too.
Take a look at [Finance::Bank::HSBC](http://search.cpan.org/~mwilson/Finance-Bank-HSBC-1.06/lib/Finance/Bank/HSBC.pm) as it seems that many of the Finance::Bank::... modules have used that as a template for adding new banks. Be careful... it is your money.
What are some of the dangers of using a perl script to check your account balance?
some of the dangers of automating the stuff an online banking system does. it has nothing to do with the language you choose to write it in.
Tried to comment on the article, wasn't able to, so I'm writing it here. Moose needs to be in core. Moose needs to be viewed as the "de jure" object system for Perl and not the "de facto" one(as it is now). There should be one object system and the old one should remain there but just for compatibility reasons. Insist on better exception handling to be part of the language. As of now, I do not know any exception handling module that is considered a de-facto standard. If one existed, that'd still be wrong since it should be part of core. 
There is nothing inherently dangerous about using perl vs. any other programmed method. That said... * Do **not** store your account, user, password, etc in your script -- unless you store them in-the-clear in a file on your disk already (which I hope you don't). * If you're going to call this script in any automated fashion, step through the paces a few times to make sure you don't slam the bank -- you don't want to get your account flagged for unusual activity (e.g. 1000's of account balance checks per minute). * Think about what you're doing before you do it. You don't want to accidentally transfer all your funds away or take out a payday loan by accident. This is hyperbole obviously, but just a simple warning to remember that whatever you can do online manually, you can probably get your script to do for you as well. * Don't save any information on disk that you wouldn't do so normally (no account numbers, etc). * Validate your inputs, run with `use strict` and `use warnings`. * Have fun 
What a coincidence. I'm trying to create a script to log in to your bank account too.
Basically, [perl5i](http://search.cpan.org/perldoc?perl5i) with '.' instead of '-&gt;'.
Moose is too big to be in the core.
can you argument your claim please ? thanks.
Are you talking about a subset of Moose or the whole shebang? Moose requires the following as of v1.00: Class::MOP: 0.98 Data::OptList: 0 List::MoreUtils: 0.12 Scalar::Util: 1.19 Sub::Exporter: 0.980 Sub::Name: 0 Task::Weaken: 0 Try::Tiny: 0.02 And those are just top level requirements. Class::MOP requries: "Algorithm::C3" : 0, "DBM::Deep" : 0, "DateTime" : 0, "DateTime::Calendar::Mayan" : 0, "DateTime::Format::MySQL" : 0, "Declare::Constraints::Simple" : 0, "File::Find::Rule" : 0, "HTTP::Headers" : 0, "IO::File" : 0, "IO::String" : 0, "Locale::US" : 0, "Module::Info" : 0, "Module::Refresh" : 0, "Params::Coerce" : 0, "Regexp::Common" : 0, "Test::Deep" : 0, "Test::DependentModules" : "0.09", "Test::Inline" : 0, "Test::LeakTrace" : 0, "Test::Output" : 0, "URI" : 0 And so on and so on. I would be all for a sane subset of Moose that allows larger more sane OO to built upon it.
What is the blog trying to tell me when it says: Your comment submission failed for the following reasons: Text entered was wrong. Try again. 
Wow, that's a pretty negative way to look at things. 
I use the mechanize console to step through the interactions I need with a site, then spit out the relevant code. Check out WWW::Mechanize::Shell
how do we tell truths that might hurt?
I disagree on point 2, Perl tastes delicious.
As a Unix System Admin, 98% of what I need scripts for is manipulating text, therefore for &gt;10 years I've used Perl 98% of the time. I do use Python sometimes, but only because I "wanted to learn it". For things I need scripts/programs for, Perl has been 100% sufficient and there has never been a time where I thought "wow, I could do this so much faster/better in another language". Not that that means that would never happen, it has just never happened to me in ~11 years. FWIW, I have written Perl programs with &gt;15,000 lines of code across dozens of files/modules. I think there is some truth to "code being hard to read for other people" *depending on how you write your code*. This can be true for any language really, the difference with Perl is that you have more freedom to write your code poorly or at least in a poorly formatted fashion, so if you aren't disciplined you could really screw over people that might have to fix/update your code later.
Ha. You guys are a riot.
&gt; Class::MOP requires: where did you get this list from? Class::MOP is now part of Moose as of Moose 2, and even for the last standalone version of Class-MOP i.e. 1.12, the dependency is so different from what you specified. http://cpansearch.perl.org/src/FLORA/Class-MOP-1.12/META.yml 
I cannot get past her voice. I... I... I cannot finish this video. 
Good talk. Covered most of the modules that have been recommended to me, though I haven't yet used Method::Signatures. Probably time to start. :) One thing that was a bit distracting though was that the person hosting asked that questioners please use a microphone -- however, the person giving the talk kept on responding to un-amplified questioners anyway. 
"or I will stop it." Them's pretty big words pardner as the Duke might have said. I wish you luck--- this problem is as they say, non-trivial. How do you stop it when the offender is a recognized expert having a bad day, month, year etc. Or is just not a particularly nice person. Even a community as laid back as PerlMonks has a bit of a problem when it comes to things like 'Homework' or 'solve my problem for me' or other things typical of new posters. We even have decent postings from people who admittedly don't like Perl! Are they going to be on your hit list (if that is what you mean) Like I said, this is not an easy problem with no fast and dirty solution--- you are hardly the first and sadly probably won't be the last to not like the more obnoxious things that you can run into on the internet. Might be fun to try and track down the first DARPA flame war just to see how long the problem has existed.
This is great! And highly accurate from what I can tell. I wish I had this a while ago...
It's not really her voice but the recording. A better microphone and a low-pass filter would not have gone amiss.... Her voice is not this piercing IRL. 
perltidy and perlcritic will help you out with this.
Meanwhile at the same [conference](http://www.itwire.com/opinion-and-analysis/open-sauce/44707-lca-2011-keynote-speaker-censured-over-sexual-images)...
For anyone else who can't use flash without their CPU burning up: http://blip.tv/file/get/Osdc-Perl6Update920.flv 
Thanks for pointing out #perl-cats You may want to lay back on the trolling though when you have a serious message to get across.
msthrope++
Probably related to the flash player available on his OS/arch, not the hardware. I feel his pain :)
tl;dw: its coming along nicely
http://leasticoulddo.com/comic/20110430
Thank you sir for your valuable comments, I will take them into consideration for updating the diagram. I'm just trying to make a map of the community so people who don't have time for conflicts or newbies will not get into problems. Acting like a cartographer. I'm also trying to describe which questions should go where. If you want, you can take the diagram and edit it, and add your stuff to it. 
:) no problem. I have a serious message to get across, I'm not trolling, the Perl community has a problem and I'm making a diagram to show that it's serious.
I don't understand that, and I'm not planning to understand it :) And most of all, I don't care. 
very interesting, I'm watching that, but why posted so late (in 2011) ? anyway ++
&gt;I want first-class classes that I can store in a variable. Doesn't Moose do this? I thought that was a fundamental part of the MOP. 
I don't know what this "after" directory signifies, but if there are improvements to the Perl syntax highlighting, it would be good to get them into the official Perl vim files: https://github.com/petdance/vim-perl
Good to see things getting kept in check.
I don't see the need to name names.
Thanks! It was bugging me that I knew there was another "better" Perl Vim mode...but couldn't for the life of me remember how did it. Do you still update it or is it pretty baked at this point?
No, it's still updated. When it's time for a vim release, Bram Moolenaar mails me and says "Give me the latest", so any improvements in vim-perl make it in to core vim.
im not sure how i feel about this
is it just me or is too much syntax highlighting terribly distracting? i've used this scheme for perl/c/whatever for years now and haven't ever seen something i'd prefer more: http://lamentation.net/dump/cgoldev-compressed.png just stock vim highlighting with tweaked color scheme
great tutorial, anyone know what the pricing will be?
I think this is a nice example of using unicode characters as operators which look exactly like what they do. Preferable, IMO, to something like `vec.dot(@a, @b)` and `vec.cross(@a, @b)` if you're using those operations more than a few times. 
I don't think it'll get many users, if any at all, if it stays off CPAN. Still neat to see.
I'll chime in with others and summarize: the resources you listed and the flow chart of how to seek answers is valuable. If you'd like it to be useful, or widely distributed, *just remove the bile*. Asterisk the forums you've found unhelpful, and add a footnote, "I've personally found the replies to (newbie?) questions I've posted in this forum to be more caustic than helpful."
May 1st 1945: Hitler announced dead. May 1st 2011: PureMVC announces Perl 5 support.
Why should I remove from it ? I see no reason to do that. Everything in the diagram is true, so removing one part would mean concealing truth, and that would defy the purpose of the diagram. About distribution, you have the .dia file, do whatever you want with it, modify it, add to it, delete from it. It's under [WTFPL license](http://sam.zoy.org/wtfpl/)
Ladies and Gentlemen, they've done it! We have classes!
Looking at the docs, that doesn't seem very perlish at all. Yes, you can write Java-like code in Perl, but then you could have written it in Java in the first place. The point of Perl is that you don't have to.
This announcement is a perfect example of how to get it backwards. The most important part of the announcement, "Fredric Sullet has ported PureMVC to Perl 5!", is buried in the middle of the final paragraph. Software authors would do well to learn about the inverted pyramid. http://en.wikipedia.org/wiki/Inverted_pyramid
Why remove it? Well, you saw others' reactions. Whatever the various reasons, they reacted to your being personal, to your saying "these people are a problem." Not the response *I* would want, which is "hey, this is great! Let's put this in the PerlMonks tutorial section and add it to the perlfaq documents." There's a theory that the meaning of a communication is the response it evokes. Not sure 100%, tho I wonder if this is the response you want. Speaking for myself personally, it will help to know where to look for info, and where I'm likely to be dismissed. I already post my few questions to perlmonks, which is one of the helpful forums. Cheers.
Classes are just strings that map to packages. You can store them in variables no problem. my $class = "Skeet::Skert"; $class-&gt;new("erp"); no strict "refs"; ${"$class::var"} = "no prob"; 
1. Id like to have catch blocks within any other block (enter and leave blocks would be nice too). As Perl6 has it. 2. regex library should be made reentrant and possible to run on streaming filehandles. 3. subroutine signatures
meh.
Perl 5.8.9 reached the end of its life years ago. Perl 5.10 will reach the end of its life very soon. This means no new minor versions, no bug fixes, and no support. This also means that CPAN distributions have free rein to use features from modern versions of Perl 5, such that they won't run on older versions of Perl 5. It's nice, I suppose, that Red Hat (and by extension CentOS) like Perl 5.8 so much that they're willing to "support" it for the next several years, but don't confuse their support with anything other than making sure that it compiles even when Perl 5.22 is the current version. (Also `for` does not do smart matching, for example.)
[Much faster](https://secure.wikimedia.org/wikipedia/en/wiki/Java_performance). For more than ten years now, the JVM compiles bytecode on the fly into machine code. This can be even faster than C++ on occasion because of context sensitive optimization. Like Perl, Java suffers unjustly from a bad reputation gained early on.
Flip the question on its head--- any compelling reason not to use current software? You don't use a kernel based on; oh say 1.4 do you? I'm sure you could if you try hard, surely someone has a copy of Sackware laying around somewhere? Snark aside, you already use the current (sort-of) 5.12 so I'm not really sure where the problem is. You don't have to rush out and install 5.14 when it releases shortly (for some definition of shortly--- I believe it actually has a schedule) Without regard to whether any of us like 'progress', it happens! Best I can recommend is some very good whitewater advice I got a long time ago; 'Don't push the river.'
In this talk, Jacinta gives a number of very good reasons to be using 5.10.1 or newer. http://ontwik.com/perl/perl-programming-best-practices/ Those features aren't just sugar, but invaluable tools to make your code more bug-free, robust, scalable, and maintainable.
I don't have experience with actually converting it, but I have been told that [packing](http://search.cpan.org/~rschupp/PAR-Packer-1.009/lib/pp.pm) is the best way to go.
The reason to not stick with 5.8 is that you are part of a community, you're not alone on an island. Before too long, CPAN authors will stop testing their modules against 5.8 (if they haven't already) which means you'll get all sorts of weird bugs and inconsistencies and their response will be 'tough shit.' Eventually they will flat out fail to work with 5.8 altogether, so you're going to have to deal with this one way or another. Perhaps if you're entirely reliant on your distro's packages for modules you will just continue using ancient versions of modules to go with your ancient version of perl and be oblivious. Frankly I am totally baffled why anyone would consider "having to build them myself" to be an issue. Maybe you haven't learned about `o conf prerequisites_policy follow` or cpanminus, but in my world installing a module is the most hassle free part of my day -- to install Foo::Bar I just run `cpanm Foo::Bar` and all the rest is taken care of automatically without me having to do anything. If I were shackled to the CPAN packages that my distro had available I would tear my hair out, as there are at least a dozen that I use that are not packaged. CPAN is the best thing about perl and artificially limiting yourself to only those few popular ones that have packages seems like pure 180 proof insanity. By the way, I happen to like 5.10's `state` keyword and `\K` regex escape. Yes, you can replicate the effect of both with more verbiage, but readability is important.
Is `cpanm` different than `cpan`? Perhaps I should start a different post, but `cpan` almost never works for me. One example in particular when `cpan` had no reason to fail me was when I wanted to `cpan Tk`. It would keep failing with `Won't install without force`. I had all the prereqs installed already (libX11-devel, gcc, make), and when I downloaded the tarball and ran `perl Makefile.PL; make; make test; make install` it all went by without a hitch. Not sure what CPAN's problem was. The only modules the `cpan` command could ever install for me are super simple, pure perl modules that have no dependencies besides built-in pragmas (strict and warnings). I like when I can `yum install` things for this reason. Last time I tried to install SDL-Perl "by hand", half the time was spent trying to Makefile.PL various modules and going back to CPAN to download the next dependency on the list and so-on.
I did come across this when I was originally Google'ing. I got it to run, but again the output file didn't do anything when I ran it.
&gt; the exe that it made didn't do anything *Literally* didn't do anything? Or just didn't do what you expected? It didn't even pop up a command-line window then disappear again? Some obvious things: 1. Tell us what it's supposed to do. 2. Put some print statements into it to tell you what's happening at any stage. 3. Put a &lt;STDIN&gt; at the end so it doesn't quit until you hit Enter 4. Make sure all the things which could cause it to fail have a die() with some useful output.
cpanm is [cpanminus](http://search.cpan.org/perldoc?App::cpanminus) which is a play on [CPANPLUS](http://search.cpan.org/perldoc?CPANPLUS). But regardless of which of the CPAN interfaces used, module dependencies should be taken care of. CPAN.pm by default asks you if you want to do this for each module, which you can disable by setting `prerequisites_policy` to `follow`, but otherwise it's just a matter of hitting enter each time. If module installation is failing it sounds like something is wonky on your system. Maybe if you post the entire output when it fails someone will be able to tell you what's wrong. "Won't install without force" just means that `make test` exited with non-zero status, and the default policy is not to continue unless tests pass. So the real issue is whatever happened before that message. I just tried both of your examples (`cpanm Tk` and `cpanm SDL`) and both worked fine, installing a bunch of stuff without any further action on my part.
Great talk. :) I'm building perl-5.12.3 now on my CentOS server.
Ok, I guess I misspoke. It DID open a command prompt for a second before closing. 1. The script takes in a list of computer names and then goes through each profile on the computer deleting the temp files. It is pretty much a simple version of CCleaner but for mass profiles/computers. 2. There are various print statements at each stage of the script as well as a summary at the end of everything that was done. Also it creates a logfile of all STDOUT. 3. This is a good idea, something I didn't do and that I WILL do to test further. 4. Anything that could cause the script to exit have statements to output the error.
Well I would guess that 1. is the problem. What's a "computer name"? Something which identifies a computer on your network? That will almost certainly be very different between Linux and Windows. Also your script sounds like a truly scary idea. 
Yea, I just thought it would be really cool to be able to turn a working Perl script into a Windows exe, but honestly I don't understand how that even works. How does Perl code automatically get transformed into something Windows can understand and execute? I'm thinking I might either just keep using and running it from a Linux box or re-script it in something Windows CAN understand. As far as scary goes, you're right haha. Changing 1-2 lines of code I could have it delete everything off the root folder of a machine, for EVERY machine on the network. Luckily it's only cleaning the Temp, Temporary Internet Files and Windows Temp files. ^_^
The script was ran, tested and working on my LINUX machine. I ran pp on the Linux machine and tried transferring it to a Windows machine, nothing. I transferred the "script.pl" to a Windows machine and installed Per2Exe, nothing. I don't have paths to direct files but I do have paths to machine names and I never changed any of the code when transferring from the Linux to Windows machine. Maybe that is one of my problems? I wasn't aware that I had to change ANY of the code, I kind of didn't/don't understand how it even works, making a exe out of Perl code.
[PerlBin](http://sourceforge.net/projects/perlbin/) might work for you. Despite being an old project, it still works on modern perls, AFAIK. At least it did last time I tried (about a year ago). Note that the executable is big, though, as it contains all of perl.
Short answer to how it works is, it brings a windows version of perl with it. So, it'll be slow and unnecessarily large as well as difficult to code. Hope this helps. 
[Smart matching](http://perltraining.com.au/tips/2008-04-18.html).
Wait, you transferred the script and installed perl2exe ... that's all? You didn't convert script.pl to script.pl.exe or whatever? You may be missing a whole stage. 
Now that's how you demo! (Although the physics seem a tad wonky.)
All I did was just run the pp command on the script.pl file, it converted it but not to anything that could run in Windows. I probably did miss a step or two, I've never used the pp command and had no idea what to do/expect.
The new stuff I use most: smart matches and given when, named captures, say.
Just like trying to find the love of your life -- it only happens when you're not looking for it. I really like this article. Coding for reuse distracts from making a module as concise and as clean as possible. Trying to compose each module to handle all cases in all possible ways diverts the effort of making it do only what it is supposed to do. If it turns out that this is a module should be reused/published, that will be evident after the fact when other projects begin using it. Code cleanly and with purpose, and reuse will take care of itself.
Personally I'd upgrade purely for 'say'. That and // so that jerks (hopefully not me) stop misusing ||=. Oh, and getting the name of that damn undefined variable in an interpolated string in an the error message is nice too.
I use smart matching and named regex variables.
There is an angle on the boxes that don't get rendered. I should do that. 
What perl is installed on the Windows box you ported to? Are you running perl2exe on the windows box or the Linux box?
Install strawberry perl on a windows machine. Install PAR::Packer. Use the pp command to create an executable. Works well.
You accidentally the whole thing. pp *when run in Linux* will create a *linux* executable pp *when run in Windows* will create a *windows* executable. If you've never used pp, then *read the freaking manpage!!!*
Umm, because 5.10 *FINALLY* has a CASE statement, even though its called "given". 
There's lots of talk about compelling features in 5.10+ here already but I'd like to add that 5.10+ have lots of performance improvements and memory improvements. Your code will run faster and use less memory even if you don't use any of the new features.
Some syntactic sugar is nice: like `say`. New features like `switch`, and even better: `state`. Named captures in regular expressions, eg `$string =~ m/(?&lt;lastname&gt;[^,]+),\s(&lt;firstname&gt;.*)$/`. Now if you need to update it to add middle initial you don't have to go about mucking with `$1`,`$2`, etc to fix the rest of your code. Smart matching: `~~`. It does a lot of brilliant "do what I mean" matching. Updated regexps. Not only faster but there's new charachter classes, like `\R` for matching a newline (even if it's not `\n`), recursive patterns, and much. much more. `DOES` augments `ISA` to allow for roles in modules without having to needlessly subclass another module. Sorting lists in place now uses constant memory. Many new core modules, you can use these modules and know that they will be on any other machine running 5.10+ ... And that's just for 5.10.x. I haven't done the required reading for 5.12 yet.
The first thing you want to do is install Perl on a Windows box and get it working there on the Windows command line. Once you've done that, the final translation step should be the easy part.
&gt;It just seems to me that a lot of the new features are "nice-to-have" but not "must-have"; You could say the same thing about most language features. The flexibility of a for loop is a "nice-to-have", not a "must-have"; a while loop could be jury-rigged to provide the same functionality, though not as efficiently. A hash is a "nice-to-have" variable type, not a "must-have"; you can use a array to store the same data, with only a loss of comprehensibility. The real question is, why settle for "must-have" when there are so many new features that make Perl 5 a better language?
http://www.reddit.com/r/perl/comments/fa8x3/is_there_an_alternative_of_indigos_perl2exe_for/
Take a look http://strawberryperl.com/, have used it before and it worked well. Just make sure any modules you use are compatible with windows :)
What's a man page??? JUST KIDDING. Yeah I should have probably read the man page for pp before proceeding. I was following some tutorial I found that didn't say a thing about how pp worked. Thanks for the advice I'll retry using pp but on my Windows machine.
Thanks for the response, this seems to be the consensus. I'll test this out today =]
One word: Moose
It just packs the perl interpreter right in with the script into an exe file (simplified explanation but this is basically what happens).
PAR::Packer is the way to go. Done it many times.
Moose has no problems with perl 5.8 from my experience. Disclaimer: This is not an endorsement for 5.8.
Uhh, no, the Perl community is not great offline. Sure, there are some nice guys (there are nice guys everywhere) but there are more than a handful who have an image, dare I say hygiene, problem which should definitely be addressed. The whole neckbeard, gross, basement-dwelling nerd stereotype is alive and well in the Perl community. And yeah, I could do without the ego and the drama queens. And the cursing. I say this out of love, as a career-long Perl advocate.
I'm a big fan of him and his work... But it's so stupid that he even had to ask. There's no reasoning with crazy. How could you possibly ask civility out of people who are already busy not being civil? It's just like politics... Civility is such a fundamental part of a successful community. The fact that we're even having to talk about this shows how far behind the community is. It's so sad!
I hate that guy... Get a hair cut or something. And an attitude adjustment.
You'll need to setup a perl dev environment on a windows machine and for the most part you'll want to develop your windows perl scripts on a windows box. When the script works then you can make it an exe.
Btw, that's overriding the X built-in operator: snoopy@deb6:~/git/rakudo$ ./perl6 &gt; &lt;a b&gt; X &lt;1 2&gt; a 1 a 2 b 1 b 2 
The x they use is a separate Unicode character from ASCII letter x.
I honestly have no idea what that article was about.
I don't get why they had to invent another layer (PSGI) on top of an already fast and portable layer (FastCGI). I get the interoperability between FCGI, CGI, mod_perl, and standalone but why not just focus on FastCGI?
Maybe check out: http://search.cpan.org/~miyagawa/PSGI-1.03/PSGI/FAQ.pod#Why_do_we_need_this?
NB: not acting like a dick makes most of these resources more hospitable and less angry
When developing web-apps i often find it useful to be able to switch out various interfaces. CGI mode for rapid debugging, FastCGI for deployment. Previously i had to figure out how each framework i poked at did those, and often, if the one the framework did wasn't to my liking, had to rewrite it. With PSGI these things are implemented in one single place and i can switch them out easily no matter how my stack above looks. Also, it saves the framework developer some time an work. They don't need to implement all interfaces on their own, but just a single one which does the rest of the work.
Another alternative here which I keep thinking about doing, but never have the time to, is to log into your account via your web browser (Firefox) and use a few browser plugins and greasemonkey to grab your data. For example, using ReloadEvery to keep the session alive, and general javascript to grab the information you want and save it to a JSON formatted file which perl can read and do with as necessary. The benefit here is that your browser handles the security/SSL component, and also deals with any JS trickery that the banks web interface may impose (which may prove difficult with perl/WWW::Mechanize). It does mean that you have to keep a browser open somewhere to run this thing, but these days that isn't too difficult, especially with virtualization. I think the security aspects of this approach out-weighs the overhead of requiring a desktop/browser. (Still interested in hearing other thoughts/ideas on how to do this!)
This post is just content free rubbish.
Nice, more choice is always good, phenoma, doctcloud, and now stackato
Seems pretty simple to fix: use a single disk writer process and write to it via socket.
Read the comments. He does not want any daemon, external process or server. He wants to solve it with a module loaded by the scripts doing the logging. In other words: He's approaching it in entirely the wrong way and is unwilling to change his concept even though it is fundamentally flawed.
"If only we could somehow make leaded gasoline work **better**!"
Another one! Yay!
I do want to change my concept if it doesn't work out. I'm sorry if my answers sounded arrogant. Still, I like the idea of using plaintext (\n-separated) logs as queues, because they are: 1) local 2) easy to grep and generally unixway-ish We are considering logging daemon option. BTW, do you know any existing lightweight solutions? (not syslog-ng, though, we don't want to write separate config for every new file).
Not arrogant, just set in your ways and misguided. If you are really against setting up a database server and absolutely must roll everything yourself, do this: Take Net::Server, write a small script that listens on a port and dumps into a file, then make sure it stays running with monit or supervise. Be warned though that you will most inevitably end up duplicating half or more of the functionality of a modern database. You'll have to set up one for each machine, but them's the breaks if you really need to log everything into a single file from multiple processes. I honestly hope you'll find a way to do what you want and maybe blog about it. :)
Another (possibly easier) option might be to make every process write to a different log file (maybe as simple as "log.$$") and then collate them together later.
We have many database servers. We also have several hundreds of servers in several dedicated datacenters. We also have the sysadmin policy that every host can go down on Friday night, and we should be ready that it won't be up until Monday. So, there should be no single points of failure (at least we are trying to achieve that). So, when I read your advice about database server, I read it as "setup the cluster of database servers, and make sure that writing/reading code doesn't hang and switch to the different DB when one server goes down and begins to reject TCP packets, and make sure that there are enough of them in every datacenter, since entire datacenter can go down as well". (No, I'm not working at Google. I'm working at russian search engine Yandex, and it's pretty damn close.) Thank you for your comments. I'll try to write more about the solution we come up with in the future. PS: I feel like you don't remember me, or you wouldn't advice to use monit/supervise ;)
&gt; BTW, do you know any existing lightweight solutions? Call `select()` in a loop, write each input received to the file with a trailing newline? It really doesn't have to be complicated. (and the less it is, the less ways there are for it to break)
Yeah, you are probably right... I always avoided socket programming and tend to overestimate its complexity :)
&gt; Every now and then I get really envious of Ruby's marketing What do you see as "Ruby's marketing"? Can you give an example?
Indeed, it could have just been a reddit self post. Free link karma though?
think the same... 
&gt;With PSGI these things are implemented in one single place and i can switch them out easily no matter how my stack above looks. CGI was already doing that... before frameworks reinvented the wheel... and obviously, this happened because of: &gt; if the one the framework did wasn't to my liking, had to rewrite it and therefore, will come one day an other "protocol" layer... I really feel it's just trying to re-brand HTTP::Engine framework as a "protocol" and try to sell the thing with new protocol aware servers and confusing/poorly written explanations that are very bad at being to the point... 
Mithaldu != Ovid. I just happen to agree with the sentiment and think it's at the very least worth pondering.
Exactly how you setup your database is up to you. You can externalize it or of course also just give each server a lightweight postgres installation. In fact, with your use case i'd suggest the latter: Set up a postgres instance on a dev server configured to do your logging (since you're only catching data that would normally go into simple files you don't even need passwords), then bundle that up in whatever package system your os uses and deploy everywhere needed. Also, your name rang a bell, but my memory is terribly bad, so i couldn't connect it. Now i did. :) Sorry for dropping out on Ubic. New job here in berlin sucked up any time i had and put way more important problems on my plate.
chromatic, can you give us an update on your plans to publish a Moose book? (And anything else in the pipeline?) I will happily pre-order if that's an option. I suspect many people would.
metacpan is pretty cool, good use of jquery ui.
I really think that installing postgres, especially on every host, is an overkill for this task and it will create more problems than it will solve. Sorry, it's almost as if you'd tell me to put my data in table and select it with "order by" if I asked "how can I sort a set of lines". Re ubic: don't worry, at least you inspired me to work on cross-platform features, and Windows port is still going to happen one day :)
&gt; CGI was already doing that.... See the Plack::Middleware::* namespace for a list of many, many things that CGI could never do. &gt; I really feel it's just trying to re-brand HTTP::Engine framework as a "protocol" If Plack offered no benefits, why would the authors of dozens of servers, server adapters, and frameworks all agree that Plack is worth supporting? That's kind of like saying "HTTP is just an attempt to rebrand a specific Telnet application." Sometimes a little bit of protocol in between discrete layers of an application solves a lot of problems. In this case, the ability for a framework to support multiple competing backends by conforming to a single protocol (and letting someone else worry about writing and debugging and maintaining that backend adaptor) is a huge benefit, as is the ability to share middleware components between frameworks and to (almost transparently) change deployment mechanisms between testing and development and production.
What about SQLite, then?
I would absolutely buy that. And a Little Book of Moose would be cool, too. Also, a Big Book of Moose.
&gt; overkill You need to examine how something is overkill. Is it overkill when you spent two weeks implementing it? (And untold more while it sits there and you find all the edge cases.) Is Postgres overkill because it uses a lot of memory (though i'm fairly sure it can be configured). I think just saying "it's overkill" in this case is a dead-beat argument without any actual meat attached and wouldn't let myself be convinced by it if i were in your situation. ;) Good to hear work on Ubic is continuing. :)
SQLite doesn't do concurrency well at all. The best thing it manages to do is tell you that the database is locked at the moment, which is an error you'll have to catch and which will slow you down.
&gt; See the Plack::Middleware::* namespace for a list of many, many things that CGI could never do. Obviously, is not the role of CGI to add such things. You already have many of these elements on CPAN, some of them unrelated to the CGI context at all, some of them HTTP aware. you could add a CGI::MiddleWare namespace if you want... would be the same. &gt;If Plack offered no benefits, why would the authors of dozens of servers, server adapters, and frameworks all agree that Plack is worth supporting? That's absolutely not an answer, nor a valid argument and you know that right? it's not because "everyone" is doing something that it's good for your health or it s the good way of doing it (Perl would not exist then!) The protocol they had to support was CGI and de facto CGI.pm. but some people thought CGI.pm sucked so they rewrote their own crap. why not... the PSGI is no better than that. and most of the middleware is based on Catalyst modules... you can handle CGI and FastCGI and you're good to go. I am trying to convince myself of the usefulness of this layer but can not see any valuable reason as to its existence. 
&gt; Obviously, is not the role of CGI to add such things. Then perhaps "CGI [wasn't] already doing that...". &gt; ... you could add a CGI::MiddleWare namespace if you want... would be the same. You'd have to add an adaptor for how CGI provides request data, how mod_perl provides request data, how FastCGI provides request data. At that point, you're reinventing an important part of PSGI. &gt; it's not because "everyone" is doing something that it's good for your health.... It's not an argument solely from popularity. It's an acknowledgement that multiple authors of multiple competing projects have recognized that collaboration on this part of the stack makes their work easier. (When CGI::App, Catalyst, Dancer, and Mojolicious all agree on something, *pay attention*.)
I'm on board with this idea. When I write `use v5.12` I like to not need to also write `use strict;`, but then `use warnings;` without strict next to it feels weird.
&gt; Then perhaps "CGI [wasn't] already doing that...". it was about working in CGI/FastCGI and even mod_perl context, not the middleware stack. &gt; You'd have to add an adaptor for how CGI provides request data, how mod_perl provides request data, how FastCGI provides request data. Not really true as CGI.pm does handle them for you in quite transparent manner. well, I have to say that mod_perl has never been in my list of things I want to support so it gives me just CGI/FastCGI and it just happened to be already handled by CGI module... The fact that frameworks switch over it is only giving me the impression that CGI.pm, who did not make consensus upon such frameworks-Catalyst,Mojolicious - but same guy started them right?, needed to be reborn under a new protocol completed with Plack, new coding styles that are perhaps more to the likings of these authors as representative of actual standards. All in all, PSGI per se does not seem to bring that much. (I mean, we have CPAN right? creating a thin layer around all the actual existing modules with ::PSGI at the end is it really helping?) Don't know. Don't see the reason of its existence. Even though I am not really convinced by Moose way, I still think however that it did answer a real problem and that it really brings something (let apart personal liking). PSGI? Nope, don't see it this way. yet. 
CGI.pm is fine, yes. Then take this fine CGI script: use CGI; my $cgi = CGI-&gt;new; print $cgi-&gt;header, "Hello World"; and do the following things: * Run this script as a standalone web server * Add a basic authentication to this application * Write a unit test to see if this application really outputs text/html header and "Hello World" in the body. You can do all of them with CGI or FastCGI, but you need a web server and configure them to do so. If your application follows PSGI, whether it was using Plack or PSGI supported frameworks or not, they are all obvious and easy and *absolutely no changes* are required. (plackup, Plack::Middleware::Auth::Basic, Plack::Test, Test::WWW::Mechanize::PSGI) - and of course if you really want to do the basic authentication in the web server, you still can. &gt; needed to be reborn under a new protocol completed with Plack, PSGI doesn't enforce you to use Plack, either in the server side or in the application side. Plack is a toolset to share the implementation (because, like you say, we have CPAN) but you're absolutely free to not depend on Plack, like Mojolicous, and yet users can benefit from the power of Plack middleware. See also this thread, since I don't want to repeat the same argument http://news.ycombinator.com/item?id=2498692 After all, if you don't see the benefit of PSGI and are perfectly fine with CGI.pm and FastCGI, then that's totally fine. There are many people who do and contribute to the project, and it's not my job to convert you. I'm sorry.
I hate it. But Tom Christiansen is on board, so I guess it's going to happen. I hope they will at least include a command line option to disable warnings. 
I guess you didn't read too well. He's saying that: use v5.16; Would be the same as: use strict; use warnings; Also keep in mind that these pragmas are lexical so they only apply to the lexical scope of the file they're in.
Yes, I didn't. If they do it that way, I don't mind. Thanks for the clarification. 
&gt; but in my world installing a module is the most hassle free part of my day -- to install Foo::Bar I just run cpanm Foo::Bar and all the rest is taken care of automatically without me having to do anything. In your world, your scripts apparently are only meant to be run on systems you control. Many people's worlds don't resemble that one.
&gt;You can do all of them with CGI or FastCGI, but you need a web server like anything else. &gt;If your application follows PSGI, whether it was using Plack or PSGI supported frameworks or not, they are all obvious and easy and absolutely no changes are required. "obvious and easy" is a rather subjective opinion,especially when you look at the doc. but i'll wait for a "idiot-proof" tutorial as you wrote on mr_chromatic blog last entry about Plack(which does contain comments about the doc being rather abstruse. that's funny for something that is supposed to be that easy) &gt;you're absolutely free to not depend on Plack, like Mojolicous, and yet users can benefit from the power of Plack middleware. if i look at their changelog, a lot of bug fixes are dedicated to PSGI support. Do they really benefit from such extra work? (they also have bug fixes for other context but hey, that's what you get when you reinvent the wheel. and that's true for Catalyst on that end.) &gt;I'm sorry. Don't feel sorry, it may feel condescending to say so. I am just a conservative guy i guess. 
&gt; that's funny for something that is supposed to be that easy I can only speak for myself, but I only really understood PSGI when I realized how simple it really is. I overthought it for a long, long time.
&gt; like anything else. No, in PSGI/Plack it's just a perl code reference, so you don't need a web server, to say, test your application. &gt; if i look at their changelog, a lot of bug fixes are dedicated to PSGI support. Just two commits recently we whipped up on irc to improve the support. Will never call that "a lot". &gt; Do they really benefit from such extra work? Clearly. http://blog.kraih.com/mojolicious-and-plack http://blog.kraih.com/mojolicious-in-the-cloud-hello-dotcloud &gt; which does contain comments about the doc being rather abstruse. No, the comments about the lacking doc was more about the deployments. As claimed in another comment, we're working on it. &gt; Don't feel sorry, it may feel condescending to say so. I wasn't apologizing. I just felt sorry for you that you decided to trash something without even trying it. 
&gt; Just two commits if you look at the changelog it's more than 2 and you know that. &gt; Clearly. well, you're working for dotcloud... it's not really an argument that has a real value. &gt;I wasn't apologizing. I just felt sorry for you that you decided to trash something without even trying it. I've never said you were apologizing. That's exactly why I said it was condescending. And you re wrong to decide that i did not try it. I've read the 2009 plack blog stuff, try it. not convinced it was worth the effort. 
here again, it simply shows that the doc is really poorly written then. I guess you overthought it because explanations are not clear enough on what it intends to solve, how it solves the "problem" and why it is a good way to solve it. 
&gt; here again, it simply shows that the doc is really poorly written then. Long before Plack or PSGI existed, I misunderstood and overthought WSGI too.
http://www.python.org/dev/peps/pep-0333/ Rationale and Goals made perhaps sense at the time, for Python devs,environment. I'll wait for your book to enlighten me then. 
I've no idea of what it might be useful for, but it's a hell-of-a nice hack!
It's no longer happening, deprecation has been reverted, the Perl community is sadly not ready for it. http://mojolicio.us/perldoc?Mojolicious/Guides/FAQ#Why_is_using_Perl_52E82Ex_such_a_bad_idea3F
Because FCGI requires a socket and both sides of a binary protocol implementation. PSGI is just a code ref that gets passed a hash ref and returns an array.
It would be nice if he employed more links in that article. Like: Where did miyagawa link? Or: That url to the nginx suggestion should be a link. His Atom feed also seems kinda broken.
http://news.ycombinator.com/item?id=2498692 http://www.reddit.com/r/perl/comments/h46mr/plackpsgi_ecosystem/c1sv16a Are what he posted on the TWWWWWWITer
Reading these may make you rage.
Tell the CPAN testers that 5.8 is no longer supported--- I spend a fair amount of time making them happy for a version that is at best historical. Somebody needs to get their facts straight here...
I did link to the three links Miyagawa posted (two from a tweet he sent out, one from #plack on irc.perl.org). They're linked from the words "bunch" "of" "forums". I also just fixed the link link the footnote. That said, I wrote this in about 20 minutes. It really takes time to heavily link an article. My typical posts took an hour or more to write because of all the linking and cross-referencing I would do. It got so I didn't want to write anymore. Which is sad because I do like writing.
You can configure your distribution to not install/test on a 5.8 system. Regexp::Grammars for example has done this in the Build.PL.
so what? they discovered FastCGI and got better performances? that's not surprising. They could see even more improvement if they forgot about Apache and switch everything back to Nginx. It is not PSGI related... I've decided to work with FastCGI because it would not bind my application to Apache. Where I work we have a pretty close architecture as to this article (Nginx does it all though). No need for PSGI at all to get good perf... And yeah, Catalyst dropped all their so called engines to use PSGI ones because it is their engines, almost, it is just bundled outside of the Catalyst namespace. If you tell me that switching to Plack (it is the only available PSGI implementation I am aware of) will bring me an increase in performance that could outcome FastCGI then we're talking. I relate to all the people that are just fine with FastCGI and don't see PSGI as a plus and they are many, i am sure but you get minused each time you say so without getting back valid arguments so that must stop many to comment and go against the propaganda of those days. that's not exactly a fair way of proving that what you plaid for is good. 
I think the plus is this: when you write your web app, if you base it off of FastCGI, then you're stuck with that for deployment. If you base it off of PSGI, then you can run the app (with *zero* changes) as CGI, FastCGI, mod_perl, or even standalone. The very first use case is probably for developers: while they're certainly able to setup a lighttpd or nginx frontend to interface with the app they're developing (against FastCGI, not PSGI mind you) - wouldn't it be much easier if they just develop against PSGI and then run it as standalone for development, then as FastCGI in staging/production? This is definitely not a giant performance increase, but it greatly simplifies the code and interfaces that link all the parts of a webapp together. By having just the PSGI interface and the engines that interface with CGI/FastCGI/mod_perl/HTTP::Server, you greatly reduce the amount of code reuse and therefore amount of time spent writing, testing and debugging said code. That probably doesn't apply to most houses, but it's still not a reason to completely throw the idea away. -- Also, as for "why should I rewrite my perfectly fine app just to use PSGI?" the answer is a resounding "DONT!" If it works, and it's good enough: LEAVE IT ALONE. However, if you're starting a project from scratch anyway, why not build on top of a pretty darn good deployment system?
Thank you for your insight. The main selling point is that you don't have to support CGI/FastCGI/mod_perl and that you do not bind your app to one server but with CGI/FastCGI it runned on the most common ones (Apache,IIS,Nginx) without hassle at all. But my equation is different: FastCGI = CGI.pm because it already handles it. and if it cannot run under FastCGI revert to plain old CGI. mod_perl = JUST DONT EVER USE IT. most of the time I can access FastCGI deployment without pain so it's all good. So, we add a thin layer on top of everything that allows to "abstract away" the "vendors", the ORM of the webservers if i dare say. well, why not... Was it really necessary to get all the so called deployment facilities on top of yet an other protocol? Frameworks have been doing that before without any of this so... As a side note, I was excited about this project at first, the mysterious and so powerful PSGI/Plack stack. Then all the readings, all the learning, all the "trying" did not give me the magic, power I was expecting. I'll wait for more insights on this topic or that the project matures enough to be of value to me. 
I'm not sure you really understood what I was saying. The performance you seem to be focusing on has absolutely nothing to do with PSGI. We were in fact using Catalyst::Engine which predates PSGI. The point was (as imMute apparently understands) that we had to make zero changes to the application for the operations team to try an alternative deployment. This has nothing to do with performance, and everything to do with making it cheap and easy to try alternatives. Plack is hardly the only PSGI implementation. Mojolicious has written their own because they have a zero non-core dependency policy. There is also uwsgi (http://projects.unbit.it/uwsgi/) which supports PSGI, WSGI, and Rack. There may be more but those are the two I know of off hand. 
Yes exactly. 
&gt; The point was (as imMute apparently understands) that we had to make zero changes to the application for the operations team to try an alternative deployment. Yes, that's right, I've read your article too quickly, sorry! That's nice to be able to switch of environment so quickly but they were doing this in Catalyst without having to create yet an other protocol. And Catalyst decided at first to create different engines for different environment (CGI/FastCGI,mod_perl and else) but this was their first error imo. CGI::App for example made a way much better sane choice by depending on CGI.pm instead of reinventing the wheel. All I see is that a rock has been torn apart into sand and that now we try to put it back into a flooded bucket. 
The magic only manifests itself when there's a competent programmer around.
haha, yeah you are right. such a good argument! If your programming is at the level of your argumentation I hope i'll never have to look into your mess either.
yes, and I like to stay polite. That's who I am.
As I said I like to stay polite, you should learn from that at least! and sorry, I edited before i've seen your last comment... But I did not loose much... There must be a lot of magic going around you too... 
 haha, I thought that the most impolite person I've ever met on reddit was you but yes, Dishonesty is not very nice either. kind of trolly. Hope you get the meaning... I wish you can,,, and if you can not...well, just forget about that and continue programming like you write... 
oh, you erase the sentence where you wrote some nice words... Fair player that we have... Happy to have met you anyhow!
Hey, you're quite able to have a very unpleasant conversation with me! You take quite a lot of time to answer somebody like me,,, I have to say... You are my hero. I am very happy to know that they are such pleasant person in the world. It gives me hope in humanity. Thx! 
&gt; Plack (it is the only available PSGI implementation I am aware of) Your application (or framework) does NOT need to switch to Plack. You can implement PSGI without using Plack *at all*. [CGI::Application::PSGI](http://search.cpan.org/~markstos/CGI-Application-PSGI-1.00/), [Mojo::Server::PSGI](http://search.cpan.org/~kraih/Mojolicious-1.31/lib/Mojo/Server/PSGI.pm), to name a few. And there's quite a few PSGI server implementations that are not (and do not depend on) Plack as well - [uWSGI](http://projects.unbit.it/uwsgi/), [HTTP::Server::Simple::PSGI](http://search.cpan.org/~miyagawa/HTTP-Server-Simple-PSGI-0.14/), [fastpass](https://github.com/miyagawa/fastpass), [mod_psgi](https://github.com/spiritloose/mod_psgi) etc. &gt; If you tell me that switching to Plack (...) will bring me an increase in performance that could outcome FastCGI then we're talking. Well, let's see. Nginx + fastcgi + CGI::Fast: # hello.fcgi use strict; use CGI::Fast; while (my $q = CGI::Fast-&gt;new) { print $q-&gt;header, "Hello FCGI"; } # nginx.conf http { server { listen 3001; location / { include /usr/local/etc/nginx/fastcgi.conf; fastcgi_pass unix:/tmp/fcgi.sock; } } } Benchmark: # run FastCGI external server env FCGI_SOCK_PATH=/tmp/fcgi.sock ./hello.fcgi &gt; ab -c 8 -n 5000 -k http://127.0.0.1:3001/ Requests per second: 2581.90 [#/sec] (mean) PSGI: # app.psgi my $app = sub { return [ 200, [ "Content-Type", "text/html", "Content-Length", 10 ], [ "Hello PSGI" ] ]; }; Benchmarks: Run it with Feersum: &gt; plackup -s Feersum -E deployment app.psgi &gt; ab -c 8 -n 5000 http://127.0.0.1:5000/ Requests per second: 6598.65 [#/sec] (mean) Run it with Starlet, with 1 worker: &gt; plackup -s Starlet --workers 1 -E deployment app.psgi &gt; ab -c 8 -n 5000 http://127.0.0.1:5000/ Requests per second: 2694.35 [#/sec] (mean) more workers: &gt; plackup -s Starlet --workers 10 -E deployment app.psgi &gt; ab -c 8 -n 5000 http://127.0.0.1:5000/ Requests per second: 3259.24 [#/sec] (mean) Run it with Starman with 10 workers and keep-alive on: &gt; starman --workers 10 app.psgi &gt; ab -c 10 -n 5000 -k http://127.0.0.1:5000/ Requests per second: 6101.47 [#/sec] (mean) Also with Plack's own FCGI handler behind nginx (same nginx.conf): &gt; nginx -c nginx.conf &gt; plackup -s FCGI -E deployment --listen /tmp/fcgi.sock &gt; ab -c 8 -n 5000 http://127.0.0.1:3001/ Requests per second: 2747.92 [#/sec] (mean) Let's add more workers (8) for FCGI : &gt; plackup -s FCGI -E deployment --nproc 8 --listen /tmp/fcgi.sock &gt; ab -c 8 -n 5000 http://127.0.0.1:3001/ Requests per second: 3700.93 [#/sec] (mean) I'll admit this is not a realistic benchmark, but may not be a bad starting point either. And I'm sure this is not a completely fair benchmark since the FCGI script is coded to run a single process. Of course you might be able to use FCGI::ProcManager or FCGI::Engine to make it preforking, but you still need to modify the script - with PSGI and Plack, you don't. At last but not least, the performance is *not* the only benefit of PSGI and Plack. If this tiny benchmark doesn't convince you that's entirely fine, but I hope this is good enough to prove that there's no downside either, with the benefit of being able to use ton of middleware with no additional cost. Hope this helps.
Please do keep in mind that not every programmer is a native English speaker.
And that was the *second* part of my article. I personally think that the state of the art of Web Application deployment has improved since 1993. I think we've learned things in the last 18 years, and that having to fake a shell environment so we can call CGI-&gt;new() is perhaps a mistake when writing a new application stack. As for your other point. Catalyst had something similar to PSGI yes. Mojolicious didn't. Dancer didn't. Jackalope, OX, Web::Simple ... and countless other web frameworks didn't. So, if you believe that 1993 wasn't pinnacle of web stack integration, what do you do? You abstract what Catalyst (and others) were doing. You look around to see what other languages are doing. You steal the best bits from all of them and release that. That is what Miyagawa did.
Yeah, i understand those issues. Writing something well is a major task. And thanks for explaining. I wasn't missing what miyagawa linked **to**, just where he did the linking, as i don't follow twitter-ongoings.
&gt; CGI::App for example made a way much better sane choice by depending on CGI.pm instead of reinventing the wheel. You might be interested that Mark Stosberg, the current maintainer of CGI.pm and CGI::Application, [is thrilled about adding PSGI native support to CGI::Application](http://permalink.gmane.org/gmane.comp.lang.perl.modules.cgi-appplication/8268). 
It has worked great for me. I used it along with psexec to quickly build and update a distributed processing system.
Thank you for the benchmarks! That seems a bit faster so it's always a plus but I would rather see a Plack::Response/Plack::Request vs CGI::Fast as you are using raw output vs module loading,instantiation, method calls which is certainly heavier ($q-&gt;header outputs by default a bit more than the headers you've put in your app.psgi version). # run FastCGI external server env FCGI_SOCK_PATH=/tmp/fcgi.sock ./hello.fcgi &gt; ab -c 8 -n 5000 -k http://127.0.0.1:3001/ Requests per second: 2581.90 [#/sec] (mean) &gt; nginx -c nginx.conf &gt; plackup -s FCGI -E deployment --listen /tmp/fcgi.sock &gt; ab -c 8 -n 5000 http://127.0.0.1:3001/ Requests per second: 2747.92 [#/sec] (mean) I can see some of the benefits though (write one program and then you can switch to any environment without having to change anything- when i said it was the ORM of the webservers that's what I meant or an Interface). 
&gt; You abstract what Catalyst (and others) were doing. I can get that but why they did not use CGI.pm. I know there's been a lot of depreciation for this module but I really feel none of the other modules have built such an easy, well documented tool. Obviously it's not perfect but why not improve it and work together? (this is off topic though!) 
&gt; most of the time I can access FastCGI deployment without pain so it's all good. "most of the time" *is* the problem. Let's say you want to run your Perl web application on an Android phone via [SL4A](http://code.google.com/p/android-scripting/). Android has no Apache, nginx or IIS. So there's no FastCGI nor CGI. If your application is compatible to PSGI, you can run it with HTTP::Server::Simple::PSGI, since it is written in pure perl and has no non-core dependencies and supports perl back to 5.6. You can just copy over the .pm files over the USB cable and [your web application just works on an Android phone](http://d.hatena.ne.jp/naoya/20100930/1285868397) (the post is in Japanese but the perl/shell bit should be still readable). Lastly, the interesting thing about your "CGI.pm is just fine" is that CGI.pm based application could still just work fine in PSGI *without Plack*, since we wrote [CGI::PSGI](http://search.cpan.org/dist/CGI-PSGI), [CGI::Emulate::PSGI](http://search.cpan.org/dist/CGI-Emulate-PSGI) and [CGI::Compile](http://search.cpan.org/dist/CGI-Compile). Take your CGI.pm based application (whether it's a plain CGI script or based on frameworks such as CGI::App) and bootstrap script in myapp.cgi, use CGI::Emulate::PSGI; use CGI::Compile; my $sub = CGI::Compile-&gt;compile("/path/to/myapp.cgi"); my $app = CGI::Emulate::PSGI-&gt;handler($sub); Save this file as `app.psgi`, and now you get a PSGI application - you don't need any changes to your application, and just works with any PSGI-based web servers and can use any Plack middleware. (Of course, because this runs through CGI emulation using STDIN/STDOUT/%ENV magic, there's a performance drawback - if you want to avoid that, you might have to modify the framework to natively support PSGI, but that should not be that hard) I hope that this can be the proof that PSGI's goal is *NOT* to replace CGI nor CGI.pm - it's just a tiny/thin layer between web server and applications - a subroutine reference that takes a hash reference and returns an array reference, and Plack is a toolkit that flourish around the tiny interface.
&gt;I would rather see a Plack::Response/Plack::Request vs CGI::Fast That's not fair, since Plack::Request/Response *is not* mandatory when you support PSGI, while using CGI.pm interface *is* mandatory when you want to run it through CGI/FastCGI. &gt; as you are using raw output vs module loading,instantiation, method calls which is certainly heavier Yes, that is *exactly* why PSGI is a dumb Perl interface that is a subroutine reference that takes an hash ref and returns an array ref. It doesn't enforce you to implement any methods, APIs, using specific modules (such as CGI.pm!) AT ALL. &gt; I can see some of the benefits though I'm glad that now you can see them.
It's a related topic. I can't speak for the first issue. I'm not a Catalyst developer and I wasn't involved with Catalyst at all when the decision to write Catalyst::Engine was made. I know the answer to the second question. You can't just improve CGI.pm because it has legacy support issues that new code doesn't have. Case in point it's only been recently that CGI.pm dropped support for Perl's older than 5.8.1. Version 3.53, Apr 25, 2011 -- "Update minimum required Perl version to be Perl 5.8.1, which has been out since 2003. This allows us to drop some hacks and exceptions" Combine that with CGI.pm being dual-life so you even if you "fix" a bug you can't guarantee that it won't keep cropping up because of people's fear of CPAN. A problem which is solved by Catalyst::Engine because if you have a zero-non-core-dep policy, you wouldn't have installed Catalyst::Engine to begin with. Core modules have to be *very* conservative. Dual life modules only have to be *mostly* conservative. CPAN-only modules are allowed to be as liberal or conservative as they need. [edit: capitalization] [edit: dual-life not dual-core *sigh*]
&gt; using CGI.pm interface is mandatory when you want to run it through CGI/FastCGI. You can print a simple content-type in CGI and it will work too right? 
Sure, but with the change (print "Content-Type: text/html\n\n" instead of header()), I get: Requests per second: 2663.55 [#/sec] (mean) 
And you are still loading the CGI.pm module (which contains also methods to deal with uploading files,cookies,etc) so it's far to be a bad result imo. It is still faster though so that might be interesting on that side. 
&gt; And you are still loading the CGI.pm module (which contains also methods to deal with uploading files,cookies,etc) If you stop loading CGI.pm, your application stops working under FastCGI.
&gt; if you have a zero-non-core-dep policy, you wouldn't have installed Catalyst::Engine to begin with. yes,indeed... But I see your point regarding improving CGI.pm even though that's a bit sad somehow... 
&gt; HTTP::Server::Simple::PSGI You could also use HTTP::Server::Simple::CGI... but I see what you intend to explain.
yes,yes. That's why I said that with all the extra you still get from CGI.pm, the result were not bad at all (compared to app.psgi version with which you will have a hard time building something interesting starting from such a low-level entry point) 
So basically with only *loading* CGI.pm but not actually using any of it except the CGI::Fast hookups. You're nearly as fast as the fourth fastest PSGI benchmark shown? Where do I sign up!
That's logic though. The app.psgi can do nothing per se... print a hello world and that's it... In real life application, you do way much more. You can try to build a web app with the nude app.psgi and no module but I guess you will appreciate the amount of work you will need. That's why I said that to get a better picture it would be nice to add some modules that can actually DO something... The other benchmarks run on other servers and are not relevant at all. 
Given many, many frameworks supporting PSGI today, we don't hardly have any hard time building something interesting. And that is why many frameworks stop worrying about web servers support and just implement PSGI.
I was talking about your app.psgi file in your benchmark, not PSGI in general. You are benchmarking 2 very different beast imo but tell me if I am wrong: CGI.pm that can handle many many things for us, cookies, printing headers,handling post data and uploads,etc against a raw app that can print hello world. I am not saying you can not build something interesting with PSGI but you can not do so with your benchmark base file and that's why I think the comparison is not very fair (but you think the strict opposite so...) 
&gt; that's why I think the comparison is not very fair (but you think the strict opposite so...) I just showed how bare and yet powerful the PSGI interface is, mostly because you initially stated Plack is the only implementation of PSGI and that you *have to* use Plack to implement PSGI, which is not correct. Just for the sake of your argument: # hello.psgi use Plack::Request; my $app = sub { my $req = Plack::Request-&gt;new(shift); return [ 200, [ "Content-Type", "text/html", "Content-Length", 10 ], [ "Hello PSGI" ] ]; }; Now $req can do many many things for us, cookies, handling post data and uploads :) &gt; plackup -s Feersum -E deployment hello.psgi &gt; ab ... Requests per second: 6625.08 [#/sec] (mean) [edit] you can also say: # hello.psgi use CGI::PSGI; my $app = sub { my $q = CGI::PSGI-&gt;new(shift); ... }; and $q can do anything CGI.pm can do.
How are they not relevant though? One of the points to using PSGI is that you can switch between the backends without changing your application and find the best fit for your distribution. Limiting to *only* FastCGI is like saying that you want to compare a bicycle and a motorcycle, but the motorcycle can't use it's engine.
&gt; plackup -s Feersum -E deployment hello.psgi Requests per second: 6625.08 [#/sec] (mean) on Nginx and it will be even nicer! 
&gt; How are they not relevant though? Because miyagawa was trying to do a speed comparison in that case. 
&gt; untold more while it sits there and you find all the edge cases This is exactly what I'm talking about. As a matter of fact, we already use remote mysql tables for *some* queues. And there were problems, indeed. I believe we solved most of them, but I'm also pretty sure that there would be the new ones if we try to use a hundred mysql installations (one per host) instead of one. BTW, you are still answering the wrong question. Even if I give up \n-separated log format (which I really don't want to do for the reasons I already mentioned), postgres is not an answer to the question "how can I write the code which stores lots of data concurrently". You are just saying "Take this black box, it'll do everything for you". And you know what, this black box does tons of other stuff as well, and it definitely doesn't solve my task in the simplest way, so I won't be able to look at its code and learn. Also (surprise!) it relies on files, too.
I'm in the same boat with [CentOS](http://centos.org/), which as a distro, I am *very* happy with, thank you very much. I just wish those distros made it a lot easier to install several versions of Perl side by side. Having to compile from source, just because I don't want to replace the system perl?? No thanks. You're not being helpful. I don't understand that this is the standard way that distros handle things.
I think the Perl community would be fine with it as long as their favorite distro/environment/web hosting moved to a newer version.