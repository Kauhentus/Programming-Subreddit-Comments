What kind of file is it? What is the output? Are you using open(FH, &gt;$file); What errors do you get? 
Any reason you need to do this in Perl? Using a shell can get this done easily with xmlint: xmllint --format xml_file.xml Redirect the output to a new file, then move it to the original location.
totally fair question. This was more or less a challenge issued from the bossman. Just trying to give it the old college try.
Thanks! I figured it had to be that simple. I'm getting hung up on scale. It makes sense in my case when the amount of stuff in the file isn't great. Is this still the way to go if I had a ginormous text file?
the source is a text file, the output would still be text, just a prettied up xml version. so say source file looks like: &lt;a&gt;&lt;b&gt;&lt;c&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; we'd be expecting: &lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;/c&gt; &lt;/b&gt; &lt;/a&gt; The idea would be to overwrite the one-liner with the prettied up version. I was getting an error after I had assigned $newVar = &lt;$file&gt; and subsiquently done some find/replace operations on it with a $newVar =~ /regexWizardry/. The error said I was working with unassigned variables at the $newVar =~ line#
You really don't want to overwrite the output file like that. The usual idiom is to write the output to a new file (with a name chosen to be guaranteed unique) and then once that is done, rename (move) the new file to the old file. This has several benefits: - If your program encounters a problem while writing the output (e.g. it's interrupted, or there's some input it wasn't expecting and it bails due to an exception) the original file is untouched and remains intact instead of being in some indeterminate state, having potentially lost important data. - The filesystem rename operation is atomic, so if other processes are trying to read the file, they either see the original file in its complete form or they see the new file in its complete form. They never see the file in a partial state while it's being written to, which could cause problems since it's likely in an invalid format during that period. Here's an example of how you might pretty-print an XML file in-place using the rename technique: #!/usr/bin/env perl use warnings; use strict; use XML::LibXML; use XML::LibXML::PrettyPrint; use File::Basename; use File::Temp; die "Usage: $0 filename\n" unless @ARGV == 1; my $filename = $ARGV[0]; die "$filename: $!\n" unless -f $filename; my $tmp = File::Temp-&gt;new(DIR =&gt; dirname($filename), UNLINK =&gt; 0); my $document = XML::LibXML-&gt;new-&gt;parse_file($filename); print $tmp XML::LibXML::PrettyPrint-&gt;new(indent_string =&gt; " ")-&gt;pretty_print($document)-&gt;toString; rename $tmp-&gt;filename, $filename or die "Unable to rename: $!\n"; Note that a rename can't work across filesystem boundaries, which is why this is careful to create the temp file in the same directory as the input file. Another thing to consider is that you might want to ensure that the new file has the same mode as the old file. I'm sure there's a CPAN module somewhere that does this for you.
No. You are able to share bytecode and src code within linux and windows hosts, but for bytecode it must have the same version and threading model.
No, because of protected memory space required to do virtualization properly. The closest you can get is something network based.
EPIC Eclipse. Requires a Perl runtime. Thought I'd try something creative. Not happening.
DateTime like others have suggested. Makes working with dates etc very smooth.
Thank you. The files are accessible. Perl runtime environment needed for EPIC debug isn't. The best solution so far is to download activestate perl or something similar. Oh well.
Do you really need context sensitivity? Especially when there is a case where a "no content" is returned undef makes it very clear whereas an empty array can have different meanings.
&gt; The usual idiom is to write the output to a new file (with a name chosen to be guaranteed unique) yep, this is what I do: $infile="input.txt"; $basefn=substr($infile,0,index($infile,".")); $outfile = "&gt;" . $basefn . 'o.txt'; # outfile="inputo.txt" This guarantees the output filename is unique in relation to the input file. In the OS file list this also sorts similar files together. I also can put Perl errors into "inputerr.txt" because in my job 95% of the errors are a problem with the customer's data and the project manager needs to contact the customer about each error and resolve it. input.txt inputerr.txt inputo.txt 
+1 for the example showing OP how to use Getopt::Long and fitting OP's use-case. BTW, OP already is using references in his code. Nothing wrong with someone writing their own option parser. Close to 100% of experienced programers have done that. But if there's a core module which already does exactly what you want, then it's good to know how to use it.
Off the top of my head, but haven't tested it. All "carton exec" does is prepend your local/ dir to @INC and remove some parts from @INC. You can do the same in your Ubic script I guess. See what "carton exec" does and replicate the behaviour inside Ubic script.
Thanks, this put me on the right track. Turns out Ubic::Service::Plack has an undocumented environmental variable UBIC_SERVICE_PLACKUP_BIN that let me change it to "carton exec plackup" and solved the problem. Need to figure out why it's ignoring it for the ENVIRONMENT inside the ubic service, but otherwise, it's working as intended. Thanks!
And woe be to the poor user who happens to have both `input.txt` and `inputo.txt` as input files, because you've just scrambled their data. That's not what I mean by "guaranteed unique". You can give a template to `File::Temp` so that the temporary file name starts with `input` and ends with `.txt`, but in this case it will actually be unique. Also, you shouldn't be using the 2-argument `open`. 
Any particular reason for this? carton exec works for me when I remember to do it.
This was an informative ppt on a confusing topic. Thanks for sharing!
Mr. Show was done in perl?
Readonly::XS and Data::Lock are both essentially no penalty and probably fast enough. If you want compiler optimizations, you can still "use constant".
This is my favorite perl book of all time.
https://metacpan.org/pod/Const::Fast is much nicer than Readonly.
Would love to see some sort of corrigendum that lists what the author thinks is now unsightly and deprecated.
I'm considering options here. I'd like to see something like that myself, but I'm not sure how much time I can devote to it.
Thank you, everybody. I will be reading this later.
I'm afraid that your code doesn't make much sense. if (exists($data{$number})) { But $number doesn't currently have a value. %data = split(/: /, $msg); But $msg doesn't currently have a value. And you are now overwriting your tied hash with new values. &lt;p&gt;$msg&lt;/p&gt; You haven't put any value into $msg. It isn't really clear what you're trying to do here. What data is in your SDBM file? What data are you trying to display? And one important tip. Always start your Perl programs with "use strict" and "use warnings". 
Right, sorry, I should have probably posted my code in hastebin. I'm feeling flustered right now so I'm probably going to go to sleep soon. Here is my instructions. &gt; Create a script that will process the form data. Name the script c09ex4.cgi and save it in the cgi-bin/chap09 directory. If the user clicked the Enter Data button on the form, the script should store the form data in a DBM database named c09ex4, and then display a Web page that advises the user that the information has been entered in the database. Remove any leading and trailing spaces from the data before saving it to the database, and save the credit card name using uppercase letters.Verify that none of the input data is blank before saving the data to the database. If the user clicked the Display Data button on the form, the script should display the contents of the c09ex4 database on a Web page. Here is my [code](http://hastebin.com/qikedatoyu.xml).
Where is $number coming from? Are you using strict and warnings?
The $number is coming from a param and yes, no warnings since we haven't learned about it yet.
use warnings; and use CGI::Carp qw(fatalsToBrowser warningsToBrowser); might tell you something. Good luck. 
 if (exists($data{$number})) { %data = split(/: /, $msg); } untie(%data); WTF? Shouldn't this be $msg = $data{$number}; 
&gt; Finally, SecApp stores the passwords in an encrypted format You want to hash the passwords, not encrypt them. Keeping them encrypted on the server is bad. Additional reading: https://crackstation.net/hashing-security.htm
Terminology gets a bit confusing when encryption algorithms are used as part of a hashing function. In this case bcrypt.
Thanks both. I've updated the article.
I'm not too familiar with WWW::Mechanize, but what do you get as an output. I would think you would have more luck with actually submitting the form and not clicking the button. Take a look at this method: $mech-&gt;submit_form(); http://search.cpan.org/~ether/WWW-Mechanize-1.73/lib/WWW/Mechanize.pm#$mech-&gt;submit_form(_..._) 
The output is supposed to be the HTML content of the second page i request after login. When I do this with Facebook it works, but can't get to work with 23 and me. It doesn't login.
I mean what does WWW::Mechanize give you as output? There has to be some way to view the headers of the request you are sending so you can see what is going on. Also, just becuase that snippet works for Facebook, does not mean it will work for other websites. It's possible they have other actions or JS that may govern the logic. Your best bet would be to submit the form properly using the method listed below. $mech-&gt;submit_form
I tired submitting the form using submit_form(), but I got the same result. Thanks for the suggestion though.
See http://blogs.perl.org/users/rurban/2012/09/my-perl5-todo-list.html Most constant foldings optimizations are currently not possible, because there is no type support. Hashes need a major cleanup before they can be studied. (i.e. read-optimized) But immutability is more needed for OO optimizations, const package and @ISA. Technically trivial but there are strong forces against any kind of optimizations into this direction. perl6 also does not have it yet, so forget about it.
Well, without the request/response header information, I won't be able to assist you further. If you have that information, I'm sure your issue will be quite obvious. 
That's sad to hear, as it can only bring gains.
I'd note that a WWW::Mechanize instance returns a [HTTP::Response](https://metacpan.org/pod/HTTP::Response) instance from a call to get, so you can inspect that.
 s/^\s+//; s/\s+$//; is all you need.
I think you're looking for r/php.
Real Perl programmers are never nudes.
Thank you for releasing it, though I own a copy it's great that others may be able to enjoy it.
Linked code breaks if passed `0`
Because core functions are indistinguishable from user-defined functions, there is a reluctance to add new core functions. There needs to be a really good reason to break backwards compatibility. The alternative is the 'use feature' mumbo-jumbo which nobody really likes.
I'm curious historically if there was a reason this was never added. There are loads of other string functions, seems weird this one got skipped. I'm sure there was a reason.
substr works just fine thanks. So does regex search replace.
 sub trim { local $_ = shift(); local $/ = shift() || "\n"; chomp; return $_ }
`Modern::Perl` does this. Take a look at how chromatic does it: https://github.com/chromatic/Modern-Perl/blob/master/lib/Modern/Perl.pm
Doing two substitutions actually ends up being faster than doing the OR substitution like this. Granted, in small doses it doesn't make a practical difference, but it can add up if you do a lot of trimming.
Note that you can *only* do that trick for pragma modules. For "regular" modules that actually export symbols, you need to use Exporter's `export_to_level` or something like that; just calling the module's `import` will import the symbols to *your* module, not your caller.
Why not `s/^\s+|\s+$//g`? ~~seems faster to me~~ ^(is actually slower). 
I don't think this will work as expected.
Because if you don't satisfy the \S+ it fails. For instance, a line that is a single space will fail.
&gt; I'm tired of writing use strict at the top of EVERY script I write. Sorry, I think you should suck it up, or write a template starter module that you can copy into place as you need it. If you get used to not seeing that boilerplate, at some point you'll forget it, and then it will bite you on the ass. With Murphy's luck, it will be at 4am on a production machine.
Import::Into is a good reimporter that works with both regular (symbol-exporting) modules and also pragmas.
This. If you're not using Moose/MooseX::Declare/other modern Perl techniques you should look into it
This is a good point. I use text expansion to put a chunk of junk at the top of every new script by typing: `headr` Simple and effective.
 s/^\s*(.*?)\s*$/\1/s;
Benchmarked it, and this seems to be the fastest way: s/^\s+//o; $_ = reverse; s/^\s+//o; $_ = reverse; Seems like if you don't loop over the String within the regex engine, your're faster (seems odd to me though).
`\1 better written as $1 at …`
the only thing i would guess is that internationalization wasn't really sorted out till 5.8 and by then, new core functions rarely were introduced.
Has been done before. &lt;http://illusori.co.uk/blog/2010/03/05/advanced_benchmark_analysis_1.html&gt;
I've been out of the perl game for a while, but shouldn't there be a CPAN Lib for sanitizing inputs? Why whip a dead camel?
I use this: sub trim {my($uul)=@_; if (defined($uul)) { $uul=~s/^\s+//; $uul=~s/\s+$//; } return $uul; } # trim Are you using this in a loop over a million times per run? If not, don't worry about it. I sometimes process 500k lines with no problems. Takes about 10 seconds. 
 $str=~s/^\s+|\s+$//g; Not sure how it compares with time trials but it's relatively straightforward. 
&gt; When your input receives "\x{11}" is it actually receiving those 6 ascii characters, or one character? One would assume these end users would notice if they were entering long strings of literal Perl-specific escape character syntax before submitting it. &gt; And why are you stripping the printable characters? The OP isn't doing that. &gt; Why not strip the non-printable ctrs? That's what that line does. &gt; Not sure if \w includes punctuation. A little fact-checking goes a long way.
um… thanks.
Unfortunately using just :ascii: will remove unicode characters, which I'm fine with, and not remove the non-printable chars I want to rid. $ perl -CA -e 'my $str = "\x{11}\x{2}\x{f}\x{4}last 6 mos ☃"; $str =~ s/[^[:ascii:]]//g; print $str' | xxd 0000000: 1102 0f04 6c61 7374 2036 206d 6f73 20 ....last 6 mos
tl;dr: [String::Strip](http://search.cpan.org/~phred/String-Strip-1.02/Strip.pm) is the fastest implementation.
Hmm, but now I realize my method also rids the unicode snowman :\
There is a reason it has only 1.5 stars on cpanratings.
The better resource is https://github.com/melo/perl-benchmarks
My tests show that it's also faster, especially with a longer text to trim, though that seems likely to be Perl version dependent. I tested with 5.16.2. 
http://cpanratings.perl.org/dist/String-Strip Here's the ratings page you referred to. Total of 4 reviews, only 2 of which have stars to calculate an average. And they're all reviewing version 1.01, while the current version is 1.02, addressing the bug called out in the review: https://rt.cpan.org/Public/Bug/Display.html?id=70028 
I really hope reddit ate your formatting. Otherwise I would rather kill myself than read anything of yours more complicated than this.
I'm aware of that. Since you bring it up, the fact that the module went twelve years with that bug not being fixed is probably also relevant.
there is String::Trim if you like
&gt;`sysread(COM,my $buf,500000000);` It's going to block until it reads 500000000 bytes (477MB) from the serial port.
Oh man I read that wrong I thought that was buffer size. Is there a way of having it read and display the output constantly?
:print: is any printable character. [Link](http://search.cpan.org/~rjbs/perl-5.18.2/pod/perlrecharclass.pod#POSIX_Character_Classes). OP is removing from the front of each line, a printable character followed by a space. OP may want to remove all control characters anywhere in the line. $str=$input; $str=~s/[:cntrl:]//g; &gt; Control characters don't produce output as such, but instead usually control the terminal somehow: for example, newline and backspace are control characters. In the ASCII range, characters whose code points are between 0 and 31 inclusive, plus 127 (DEL) are control characters. 
My formatting works fine on Firefox on Win 7. The Perl code is indented 4 spaces and is a fixed width font. Are you on a mobile device? What device and browser are you browsing with? 
You can also open the filehandle in non-blocking mode with different arguments to sysopen, in that case the sysread will return undef and you can check $! to see why. That gives you the opportunity to do other things instead of just waiting for data.
Yeah, but he only checks for short texts, I did my own benchmarks based on this and came to a [different result when the text gets longer](http://pastebin.com/S1UY6wsq). 
Oh god yes that's what I need. Thanks.
Something like this? sysopen(MODEM, "/dev/cua0", O_NONBLOCK|O_RDWR) or die "Can't open modem: $!\n";
This is what I see in Chrome (on Mac). I don't think reddit formatting really has a lot of variance between browsers.
Why wouldn't you use `find` for this, is perl a hard requirement?
[File::Find](http://perldoc.perl.org/File/Find.html) You can easily write something that iterates through directories recursively... but there are edge cases and what not... File::Find has done that work for you. my $ffr_obj = File::Find::Rule-&gt;file() -&gt;name( "*.txt" ) -&gt;maxdepth( $level ) -&gt;start ( $dir ); while (my $file = $ffr_obj-&gt;match() ) { print "$file\n" }
find2perl /somedir -type f -iname '*string*' #! /usr/bin/perl -w eval 'exec /usr/bin/perl -S $0 ${1+"$@"}' if 0; #$running_under_some_shell use strict; use File::Find (); # Set the variable $File::Find::dont_use_nlink if you're using AFS, # since AFS cheats. # for the convenience of &amp;wanted calls, including -eval statements: use vars qw/*name *dir *prune/; *name = *File::Find::name; *dir = *File::Find::dir; *prune = *File::Find::prune; sub wanted; # Traverse desired filesystems File::Find::find({wanted =&gt; \&amp;wanted}, '/somedir'); exit; sub wanted { my ($dev,$ino,$mode,$nlink,$uid,$gid); (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &amp;&amp; -f _ &amp;&amp; /^.*string.*\z/si &amp;&amp; print("$name\n"); } 
I recommend File::Find::Rule instead: https://metacpan.org/pod/File::Find::Rule The syntax is straight forward and its OOP.
That is a killer trick, thanks for sharing. Never knew about `find2perl`.
Yep I think so. Then I believe you can either do the sys read with the check for undef and $!, or use 'select' to see if there is data waiting on the handle for reading.
[Link to said page](https://metacpan.org/news) for the lazy
Ah, thanks for explaining. I never use negation in sets, and when I think of negation, I think of the bang (!). I need to brush up on Perl sets. 
&gt; I installed file::find This worries me. File::Find has been a standard part of the Perl distribution since Perl 5.0 was released almost 20 years ago. Why did you need to install it? Are you using a really old Perl installation, or a really crippled one? Either is a really bad idea :-)
File::Find and File::Find::Rule are two completely different modules.
This works fine, as does the top rated comment. Remember though, to use prepare() as a general best practices method so you're not opening yourself up to SQL injection. Even for queries that don't use parameters I utilize prepare() simply to get into the habit.
The key to actually using the Perlbrew modules is to actually run your Perlbrew copy of Perl instead of the system one. i.e. on my web server I installed Perlbrew as the user "bob" (the builder ;) ), so it was like this: [bob]$ sudo mkdir /opt/perl5 &amp;&amp; chown bob:bob /opt/perl5 [bob]$ export PERLBREW_ROOT="/opt/perl5" [bob]$ wget -O - http://install.perlbrew.pl | bash [bob]$ perlbrew init [bob]$ perlbrew install perl-5.18.0 [bob]$ perlbrew switch perl-5.18.0 Perlbrew was installed under /opt/perl5, and then I made a symlink so that /opt/perl always points to the current Perl, like ln -s /opt/perl5/perls/perl-5.18.0 /opt/perl so that /opt/perl/bin/perl is my new Perl interpreter. Then you just make sure you use *that* Perl, and other binaries inside *that* path, instead of your /usr/bin one. Want to install a CPAN module in Perlbrew? /opt/perl/bin/cpan &lt;module&gt;, instead of /usr/bin/cpan. Want to use that module? /opt/perl/bin/perl -MMy::Module etc. If you edit your `.bashrc` to include your custom Perl path in your $PATH variable, then just typing "perl" or "cpan" etc. will use your versions, i.e. export PATH="/opt/perl/bin:$PATH" In your CGI or shell scripts written in Perl, just make the shebang line point to the right Perl too: #!/opt/perl/bin/perl
I think click uses the name rather than the value, so give `click('button')` a try as well.
 user@host:~$ \curl -sL http://install.perlbrew.pl | bash ## Download the latest perlbrew ## Installing perlbrew perlbrew is installed: ~/perl5/perlbrew/bin/perlbrew perlbrew root (~/perl5/perlbrew) is initialized. Append the following piece of code to the end of your ~/.bash_profile and start a new shell, perlbrew should be up and fully functional from there: source ~/perl5/perlbrew/etc/bashrc Simply run `perlbrew` for usage details. Happy brewing! ## Installing patchperl ERROR: Failed to retrieve patchperl executable. user@host:~$ source ~/perl5/perlbrew/etc/bashrc user@host:~$ perlbrew install perl-5.19.11 # or whatever version you want user@host:~$ perlbrew install-patchperl user@host:~$ perlbrew install-cpanm user@host:~$ perlbrew switch perl-5.19.11 user@host:~$ perl -v | sed 2q This is perl 5, version 19, subversion 11 (v5.19.11) built for x86_64-linux # Now let's install something using cpanm! user@host:~$ cpanm Mojolicious user@host:~$ perl -Mojo -E 'say g("reddit.com/r/perl")-&gt;dom-&gt;at("a.title")-&gt;text' complete dummies guide to install perl modules using perlbrew? *newbie* user@host:~$ # Now add to to my bashrc so it's sourced for each new shell user@host:~$ echo 'source ~/perl5/perlbrew/etc/bashrc' &gt;&gt; ~/.bashrc You can list what versions are available to install using perlbrew available I just then call my scripts like so perl /path/to/script Or you can do the shebang thing like /u/CodeBlooded described.
According to Unicode::Map8’s CPAN [documentation](http://search.cpan.org/~gaas/Unicode-Map8-0.12/Map8.pm), tou returns a Unicode::String representation of "$currentpass", presumably in order to get byte-swapped before being converted to utf16. I’m not sure what the rationale for using byteswap here is; possibly that the place that this data is coming from is differently-endian from the device doing the processing. In any case, the business with tou is only there to get your string into an intermediate representation so byteswap can be run before conversion to utf16. If the swap step weren’t required, you could presumably just use Unicode::Map8’s to16.
Thanks for that link! I was having issues finding anything while searching with search engines, and in retrospect really should have gone straight for the source. 
This is a good topic. I would recommend reading the modern perl letter (just google it) and it will give you some tips, also its just a great reference in general. The other thing I struggled with getting started was linux/unix environment basics. For instance I didnt' know that after I installed perlbrew I needed to add this to my bashrc: source ~/perl5/perlbrew/etc/bashrc The above runs the perlbrew env settings. By adding it to your .bashrc (or whatever shell manager you have) you will invoke the perlbrew env variables. Getting the env variables correct are crucial to your set up. env | grep perl PATH=/Users/firegiver/perl5/perlbrew/bin:/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11/bin:/usr/local/sbin:/Users/firegiver PERLBREW_ROOT=/Users/firegiver/perl5/perlbrew PERLBREW_HOME=/Users/firegiver/.perlbrew PERLBREW_MANPATH=/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/man PERLBREW_PATH=/Users/firegiver/perl5/perlbrew/bin:/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/bin PERLBREW_PERL=perl-5.18.2 MANPATH=/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/man:/usr/share/man:/usr/local/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man PERL5LIB=/Users/firegiver/perl5/lib/perl5 PERL_LOCAL_LIB_ROOT=/Users/firegiver/perl5 PERL_MB_OPT=--install_base "/Users/firegiver/perl5" PERL_MM_OPT=INSTALL_BASE=/Users/firegiver/perl5 perlbrew info Current perl: Name: perl-5.18.2 Path: /Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/bin/perl Config: -de -Dprefix=/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2 -Aeval:scriptdir=/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/bin Compiled at: Apr 9 2014 13:24:02 perlbrew: version: 0.67 ENV: PERLBREW_ROOT: /Users/firegiver/perl5/perlbrew PERLBREW_HOME: /Users/firegiver/.perlbrew PERLBREW_PATH: /Users/firegiver/perl5/perlbrew/bin:/Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/bin PERLBREW_MANPATH: /Users/firegiver/perl5/perlbrew/perls/perl-5.18.2/man *Oh also: I'd recommend installing cpanm. Do it using perlbrew : perlbrew install-cpanm
Do you set cookies in the right way ?
Sounds good - can't wait to test this out at work. 
Read the data into an array of arrays, or better yet, an array of hashes. Then use the sort function to sort the whole array by the wins.
Hard for me to say for certain without seeing the script, but you might try adding a perl sort call inside of your split call. http://perldoc.perl.org/functions/sort.html
That is pretty awesome.
Hopefully, it can detect those cases where 5.16 allows for interacting with refs as if they were actual hashes/arrays.
First, if you're going to post code, put 4 spaces at the start of each line of code, and Reddit will format it correctly. Like this: sub write { open(DATA, "&gt;&gt; $datafile"); print DATA "$player|$wins|$losses|\n"; close(DATA); while(&lt;TEXT&gt;){ chomp; ($d1,$d2,$d3,$d4)=split(/\|/); print "&lt;tr&gt; &lt;td class='player'&gt;$d1&lt;/td&gt; &lt;td class='player'&gt;$d2&lt;/td&gt; &lt;td class='player'&gt;$d3&lt;/td&gt; Notice how it looks better, and the `\` in the split isn't missing. And also please post complete snippets of code - that way people can easily copy &amp; paste it into a script to test it out. Now, before I tell you how to do the sorting, some constructive criticism on the code you posted, if you don't mind. - don't use "write" as a sub name - it's already a built-in function in Perl. Use something more descriptive, like "save_score". - don't use globals to pass info into a sub - pass paramaters. This makes your sub more re-usable, and reduces the number of globals (globals are bad in programming!) - don't use the bareword form of file handles - use lexical file handles, and check the result of the open in case it fails (and include $! in the error message because it will tell you *why* it failed) e.g. `open my $data, '&lt;', $filename || die "Couldn't open '$filename' because $!";` - use meaningful variable names - why use $d1, $d2, $d3, $d4 instead of $player, $wins and $losses ?(and you don't need the 4th one!). That said, here's how I'd re-write your code above (still no sorting, and HTML tags removed for clarity) into a stand-alone script that anyone can run: #!perl use warnings; use strict; my $datafile = "scores.txt"; sub save_score { my ($player, $wins, $losses) = @_; open my $data, '&gt;&gt;', $datafile || die "Can't open '$datafile' for appending because $!"; print $data "$player|$wins|$losses|\n"; close $data; } sub output_scores { print "Scores:\n------\n"; open my $text, '&lt;', $datafile || die "Can't open '$datafile' for reading because $!"; while(&lt;$text&gt;) { chomp; my ($player,$wins,$losses)=split(/\|/); print "$player : $wins $losses\n"; } close $text; } save_score("Player1", 5, 7); save_score("Player2", 2, 2); save_score("Player3", 3, 0); save_score("Player4", 0, 0); output_scores(); Now, in order to sort the data, you need all the data in memory, so you need to break down the output into 2 stages: 1) read the data from the file into a suitable structure that you can sort, 2) sort it, 3) output it. (You could combine sorting and output into one step, but for clarity I'll leave them as separate steps). I'll assume you know about hashes and references to hashes. If you don't, this might be too advanced for you, but I'll explain anyway. Here's my take on how I'd do it. I'll break down the steps further below: sub output_scores { print "Scores:\n------\n"; open(my $text, "&lt; $datafile") || die "Can't open '$datafile' for reading because $!"; my %scores; while(&lt;$text&gt;) { chomp; my ($player,$wins,$losses)=split(/\|/); $scores{$player} = { wins =&gt; $wins, losses =&gt; $losses }; } close $text; my @player_names_sorted_by_wins = sort { $scores{$a}{wins} &lt;=&gt; $scores{$b}{wins} } keys %scores; foreach my $player (@player_names_sorted_by_wins) { print "$player : $scores{$player}{wins} $scores{$player}{losses}\n"; } } So, how does it work? The data from the score file is read into the hash %scores - the player name is used for the key, and the value is an anonymouse hashref with the wins &amp; losses as key/value pairs. So after reading the scores, you end up with a hash like this: %scores = ( 'Player1' =&gt; { 'wins' =&gt; 5, 'losses' =&gt; 7 }, 'Player2' =&gt; { 'wins' =&gt; 2, 'losses' =&gt; 2 }, 'Player3' =&gt; { 'wins' =&gt; 3, 'losses' =&gt; 0 }, 'Player4' =&gt; { 'wins' =&gt; 0, 'losses' =&gt; 0 }, ); Next, is this line which is where the magic happens: my @player_names_sorted_by_wins = sort { $scores{$a}{wins} &lt;=&gt; $scores{$b}{wins} } keys %scores; To break it down easily, read it from right to left, as follows: keys %scores - this is the list of player names sort { ... } - this sorts the list of player names using the code in the braces (see below) my @player_names_sorted_by_wins = - and assigns the sorted player names to this array Now, the code in the braces defines *how* the player names are sorted. It is executed automatically by the sort function for each pair of items it needs to compare. In this case we compare the wins of one player (`$scores{$player_name}{wins}` is the number of wins for $player_name) with the wins of the other, thus giving us player names sorted in win order. Once we have the player names sorted in the right order, outputting the scores in the right order is simple - we just iterate over the sorted player names, and output the scores for each player as we go. Hope that helps. 
Consider also asking for feedback on [codereview.stackexchange.com](https://codereview.stackexchange.com/help/on-topic). Here are a few quick observations: * It's a top-level module. Don't pollute the namespace this way. The module hierarchy serves also as a classification. You have provided a cryptographic module, so consider moving your dist into the `Crypt::` namespace. But don't you dare using `Simple` in the package name ;-) * You export symbols by default. Please don't, and let the user import symbols explicitly. For that, change the `@EXPORT` to `@EXPORT_OK` and adjust the naming of your functions to not be overly verbose. This could be achieved by an OOP interface: my $passwords = Crypt::PasswordVerification-&gt;new(algorithm =&gt; 'BCrypt', cost =&gt; 14); my $hash = $passwords-&gt;hash($plaintext, cost =&gt; 16); if ($passwords-&gt;verify($plaintext, $hash)) { ... } * You depend on various modules, but don't specify their minimum version. Change the imports to `use Foo 0.42` instead. Prepare for failing tests otherwise :) * The password information returned by `passwords_get_info` has a different format than the `%options` named arguments for `passwords_hash`. Fix this, so that we can simply do: my $info = $passwords-&gt;get_info($hash); my $other_hash = $passwords-&gt;hash($plaintext, %$info);
Hey /u/amon-pl, thanks for the feedback! Some counter thoughts though: &gt; It's a top-level module. This is by intention. As written above putting it in a sub namespace like Crypt:: Authen:: (and I am pretty sure there are more were it would "fit") - it would complicate it for no reason. "Don't pollute namespace" is something I agree with, e.g. I placed another module I have written under "WWW" as thats where most of API-Clients are in, but I'd not want to see "Dancer" for example in some subnamespace like "HTML::Frameworks::MVC::Dancer" - it does not make sense. The "Passwords" is as is and will also never have sub-namespaces. KISS. &gt; You export symbols by default. That is by intention. I do not export everything by default, but those 4 subroutines and constants. It does not make sense (with this package) to let users import functions explicitly except to make the call more complicated. But if someone can give me a detailed view on why it is bad practice to export symbols by default (though many other packages are doing so as well) I will re-think my strategy ;) Also, I did not want to make it OOP as stated above, if you need OOP for whatever reasons you can have it with Authen::Passphrase::BlowfishCrypt. &gt; You depend on various modules, but don't specify their minimum version. I do specify them in the Makefile.PL (and respectively included in the META.json/META.yml), so if you install the module it will take that already in consideration. [Tests won't fail](http://static.cpantesters.org/distro/P/Passwords.html). If you simply copy the Passwords.pm you might have problems (and you don't at least look into Makefile.PL), why I will add explicit versions number in the *import* in the next release. &gt; The password information returned by passwords_get_info has a different format Thats true, I never thought of that function being used in that manner. I might change that in the next version (while keeping it backward compatible). 
This is a problem where there are a million ways to do it wrong, and basically one way to do it right. I have my own pet issues with Authen::Passphrase ([covered in detail here](http://www.wumpus-cave.net/2014/03/31/perl-encryption-primer-passwords/)), but it gets it mostly right. Where it could improve is: 1) A proper plugin system so individual enciphering types can be split into different distributions 2) Protection against timing attacks Frankly, the API and namespace issues are bike shedding.
Thanks for the Feedback! I knew using a top namespace would give me a lot of frowners ;) Just to be clear though: * I did not "take" anything away. The "Passwords" namespace was not taken (how long does CPAN exist?). Also in what way do you mean "large namespace"? In terms of "it was already used by many other modules" - as I said the namespace was not taken. In terms of "significance" ? - ok but why was it then still available? * putting it into "Crypt" is most probably just another way of doing it wrong. Crypt includes (currently and should in the future) modules that actually implement/port algorithms into Perl. So putting it into "Crypt::Passwords" is like "wait, what? Passwords is a new algorithm?". So IF ever Authen would be *more* appropriate. * &gt; What about people who want to interact with a LDAP database, or do some other authentication method that involves passwords - but not hashing using bcrypt? Simple: don't use it! You don't have to ;) - Passwords is not meant to be an API that can interact with X-Algos. If you want that, you can either build your own or use Authen::Passphrase. If you have to work with LDAP (or any other system that does not support bcrypt) - chances are high you already know what algo that system supports and what not - if you are building your own application and you don't know it - well thats when Passwords comes in.
&gt; 2) Protection against timing attacks Yes I'll definitely implement something to avoid timeattacks still this week.
Mojolicious is conspicuously absent from these statistics.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 450 time(s), representing 2.3687% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
Thank you very much! This is all very useful and I will take your advice on all the points mentioned. I am getting wrapped up with my intro to web programming class. We just touched on perl the last few classes and got a pretty rough primmer on the use of it so I am a bit rough around the finer points and usage. I am hoping to to improve my knowledge and skills in programming skills. Do you have any suggestions on where I can look to be a better coder/programmer? I feel pretty comfortable with most HTML and CSS would you have any suggestions on what I should consider as the next logical step in learning more complex and capable languages? Thanks! 
They're both around 100 deps. Who cares which is more morbidly obese?
I don't know of any specific resources to help you improve - I think a lot of programmer skill comes with practice/time, but one great way to improve your code is to get it reviewed by someone with experience. Let them tear it apart and tell you what's wrong with it (don't let it upset you - we all write bad code, even the me of last year, who has 30 years of programming experience, and he's way better than the me of 5 years ago! (and don't get me started on the me of 25 years ago - that guy used to write really dodgy code!)), and get them to explain **why** something is bad/good/right/wrong (e.g. global variables are bad because they promote [action at a distance](http://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)) As for languages, it really all depends on what you want to do. Perl is a great language for many things, but if you wanted to, for example, write iPad apps, then you'd find Perl wasn't particularly useful and you'd need to learn Objective C. Many programming concepts transcend languages (most have variables, subroutines, globals, locals, data structures, parameter passing, etc.) so once you understand the concepts, picking up a new language isn't too hard. But if you want a good all-round language with plenty of scope, I'd suggest something like Java (or maybe C++ or C#). That'll introduce you to the concept of Object Oriented programming, which is a pretty fundamental thing to know about. And Java programs run pretty much everywhere. (although I have to say it's not one of my favourites - those would be Perl &amp; C#, with perhaps Objective C sneaking in there a little). If I had to give you some general programming tips, they'd be: - Comment your code well - even if nobody but you will ever read your code, you'll be doing you-in-the-future a big favour if you add in comments summarising blocks of code, explaining **why** code is written as it is, documenting data structures, etc. Well written code and well named variables, methods and subroutines can reduce the amount of comments required, but they will rarely remove the need for comments altogether, in my opinion. This is a big bug-bear of mine in my job, where I often have to fix bugs in other people's code - it often takes me as long to understand what code's doing as it does to find and fix the problem. - Use meaningful variable/method/subroutine names in your code. The occasional i/j/k/etc is fine for a quick loop index, but don't use cryptic abbreviations like 'bsts' when you mean 'button_status', for example - it may make sense to you now, but when you come back to your code months or years later, you'll wonder what the hell 'bsts' means. In general, make your code beautiful to look at, easy to read, and simple to understand. e.g.: if (bsts) { ... } vs use constant LIGHT_ON =&gt; 1; # button status when the light is on. if (button_status == LIGHT_ON) { ... } both the above snippets do the same, but which is easier to understand? - Don't use "magic numbers" in your code. Use constants/defines or whatever feature the language you're using has to give meaningful names to these magic numbers. e.g.: wht += 45; # wtf does this line of code do?? vs use constant STATUS_ICON_HEIGHT =&gt; 40; use constant STATUS_ICON_TEXT_HEIGHT =&gt; 5; # Expand window to allow room for the status icon plus its label. window_height += STATUS_ICON_HEIGHT + STATUS_ICON_TEXT_HEIGHT; - Global variables are bad, mmkay? They're occasionally useful, but they make for [tightly coupled](http://en.wikipedia.org/wiki/Coupling_(computer_programming)) code which makes things harder to test in isolation and, due to the aforementioned action-at-a-distance, they make for hard-to-find bugs and hard-to-debug code, so avoid when at all possible. - Don't copy-and-paste blocks of code; if you want to do the same thing (or almost the same thing) more than once, make it into a subroutine. Always think about code re-use and modularity. And of course making self-contained little subroutines which encapsulate some simple operation are easy to test on their own. Which reminds me - learn about [unit testing](http://en.wikipedia.org/wiki/Unit_test) and write tests for your code. Some languages make it easier than others, but it's really useful to be able to run isolated chunks of code in a test environment to make sure they're good or figure out why they're wrong. Hope that helps! 
using cpan makes sense, it means you're reinventing the wheel less, and there's less to maintain
&gt;But if someone can give me a detailed view on why it is bad practice to export symbols by default (though many other packages are doing so as well) I will re-think my strategy ;) It helps in code reading. Consider: use Foo; use Bar; frob(); # Where the hell did that come from? Versus: use Foo qw/frob/; use Bar qw/baz/; frob(); # Oh, I'll just go to Foo.pm 
I would say that the reputation of Catalyst being a 'heavyweight' choice stems not as much from dependency count but the fact that it uses Moose which can run slower and take more memory and the fact that its interpretation of MVC requires more thought and study. As a result this 'conceptual weight' is more than a lot of people want to deal with, and for that group Dancer1/2 has a lower barrier to entry. I think also that typically when using Catalyst you are also encouraged to use an ORM like DBIC (its all over the tutorial) and again that involves some learning and buy in which not everyone is willing to accept. As a result the typical Catalyst setup involves more installation and conceptual weight than some programmers are willing to accept. Sadly I find there's a lot of Perl programmers that would rather write there own everything rather than spend a few minutes reading docs and reviewing source code. Although the overall dependency count between the two is similar you should likely look deeper. Its possible that some of the dependencies of Catalyst might be 'bigger' and take longer to install and/or have a worse track record installing. Personally I find with a modern setup (perlbrew or perlenv + local lib/carton) that I never have trouble installing Catalyst but I know other people have reported struggles. My guess is if you are stuck on some old Perl and can't use modern tools that Catalyst may not be easy to install (I can't quantify that myself, but I do recall when I started with Catalyst a number of years ago that I had trouble installing until I learned how to set up Perl in a modern fashion). BTW, the 'time to run tests' is a bit of an odd approach to measure complexity, but I'd add that the longer running time is also impacted by Moose versus Moo startup (Moo starts very fast). Personally when I run test cases on Catalyst as I am hacking on it I use 'prove -lvr t -j9' and that typicality finishes all tests in under a minute so you want want to consider running tests in parallel if Catalyst installation time is bumming you out. One other thought comes to mind regarding conceptual weight and ease of doing what programmer wants. Dancer does come out of the box with some tools to process common contemporary web development tasks like processing JSON input/output while Catalyst for a long time relied on external tools like Catalyst::Action::REST for this. Modern releases of Catalyst do come out of the box with basic support for JSON and improved REST endpoint modeling but its possible that not everyone knows that. So this is not conceptual weight but perhaps if there's some mismatch between what programmers are doing today versus when the bulk of the Catalyst docs where written, people might struggle a bit and find that Dancer is easier to start. Personally I think that down the road Catalyst leads to a better application but I would agree that day one its not as easy to learn and use. For the longer term I am hoping to see as we start planning Catalyst6 that we can think of it as two projects, a Catalyst6 'Core' that is basically what Catalyst is now, a minimal MVC framework with service discovery and a Catalyst6'Stack which would build on that and add more bells and features (as well as turn on all the modern config settings we leave off for backward compatibility). That would then try to cover more of the spread between Dancer and Mojolicious but still stick to Catalyst core principle where we want to be using the best of CPAN and how we want to say that Catalyst programming should be as much as possible just plain Perl programming (no DSL or fancy language enhancements). If that sounds like fun to you, please chill out on #catalyst-dev over on irc.perl.org! 
Does Catalyst make extensive use of Moose's meta features or would it theoretically work just as well with Moo?
Catalyst uses the meta object to inject some methods but the biggest use of meta is to read the method attributes (Path, Local, Args, etc). It does that via a MooseX extension (unfortunately nobody was interested in migrating that extension back to Moose core.) Since we expose action attributes via Catalyst API there is no reason for someone to use the Moose meta object for that purpose, thus its only used internally. It is possible that new stuff written for Catalyst6 could use Moo, but I've not felt very strongly yet. It would open the door to a 'pure perl' Catalyst deployment but I am not sure that is a compelling thing for the Catalyst use case. Feel free to come to #catalyst-dev to discuss!
I don't think the number of `META.yml` files processed is a meaningful metric at all. The interesting stats are actual code size (not mentioned in this comparison) and the test-running numbers (i.e. how well it performs in practice).
 sub mywriteln { open(DATA, "&gt;&gt; $datafile"); print DATA "$wins|$player|$losses|\n"; close(DATA); } The simple way is to store the $wins in the first column when you write the file. And this is how I read a file and process it. open(TEXT, "&lt; $datafile"); @file=&lt;TEXT&gt;; # Now whole file is in array chomp(@file); # At this point I could sort @file in Perl if I wanted, or # shell out to awk and sort by a different column. $i=0; while($i&lt;=$#file) {($d1,$d2,$d3,$d4)=split(/|/,$file[$i]); print "&lt;tr&gt; &lt;td class='player'&gt;$d1&lt;/td&gt; &lt;td class='player'&gt;$d2&lt;/td&gt; &lt;td class='player'&gt;$d3&lt;/td&gt;"; $i++; } # while 
There's a bunch of things I'd like to see in UAV::Pilot. Some of these might be set by the time YAPC rolls around (I've been working on object detection with OpenCV of late), but there's still tons of awesome stuff to do. I'd also like to setup an opportunity to play around for people who are interested but don't currently own an AR.Drone or other UAV. If you're one of those, feel free to come check things out. Would be very helpful for other people with AR.Drones to bring theirs along.
Yes! All version 2 AR.Drones will work. Version 1 should mostly work, but the video stream definitely won't.
Do you need a full drone to work with UAV::Pilot or can you get by with just the [Parrot Main Board for AR.Drone 2.0](http://www.parrotshopping.com/us/p_parrot_product.aspx?i=230894) and a battery? 
Can't say I've tried it. I *think* it would work since the firmware and WiFi and such all seem to be on that mainboard. Wouldn't be terribly interesting by itself, but you could use it to build a quadcopter with better motors and props and such. One thing I'd really like to see is a USB dongle [based on Arduino and a cheap 2.4GHz transceiver](http://dzlsevilgeniuslair.blogspot.dk/2013/11/more-toy-quadcopter-hacking.html). The dongle could probably be done for ~$20, and would be compatible with a bunch of sub-$50 quadcopters.
Very cool, thanks for posting
My first project was to capture syslog information from my firewall router ( mainly which ports were being scanned etc.), parse that, and insert into SQL Server or MySQL (both easily done with Perl and DBI), and to setup a webpage to graphically display activity on the top ten most active ports. Using this years ago I saw early indications of the SQL Slammer virus which attacks ports 1433 and 1434.
Can a "robot" start and sustain ongoing human community/activity? Create a twitter bot that evals P5 code on twitter and tweets the result with some suitable hashtags (and a link to instructions). Ask a few folk to try it out and see if self-sustaining tweeting occurs.
There are quite a few Perl programmer scientists who may have better suggestions. but what about these: -developing a hypothesis and testing it with a questionnaire, and visualizing the results? CGI.pm could do that. -create a password generator program (for passwords like this [xkcd](http://xkcd.com/936/) comic. You could test that the passwords are more memorable than random letters or something. CGI.pm could do that too. 
[Image](http://imgs.xkcd.com/comics/password_strength.png) **Title:** Password Strength **Title-text:** To anyone who understands information theory and security and is in an infuriating argument with someone who does not (possibly involving mixed case), I sincerely apologize. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=936#Explanation) **Stats:** This comic has been referenced 447 time(s), representing 2.3280% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
It's done. BOOM!
I was just considering getting one off ebay. I am wondering if it would be easy to make a Drone testing fixture using it so you could hack on the API do testing etc. Think hacking in a coffee shop where the other patrons may not enjoy a hovering drone.
Thanks for the considered reply. I hadn't thought about the "conceptual weight" - that an interesting observation and I agree it probably contributes to the overall impression too. I'll be sure to visit #catalyst-dev also.
Some last minute issues have caused the schedule to be delayed. Training will go up as soon as we finish the call we just announced but it will be intro on sat/sun - advanced on thurs/fri. Hope that helps. If you have specific needs admin@yapcna.org is always open.
Hm...that *specific* one won't work because it cant involve Humans. But I like the generator idea, even if it seems daunting. 
I don't use twitter so I'm a bit confused on this one. Is this supposed to add hashtags to the post, in a new tweet? 
Awesome! May I ask what is the "call [we] just announced"? I'm not seeing that. Thank you very much -- I really appreciate it. This will be my first YAPC.
It might have its uses, but I've come up with a bunch of different ways to handle testing without connecting to the UAV. Other than the flying issue, it also won't connect itself to a secure WiFi AP, so there tends to be a lot of switching your WiFi settings around while testing on an actual UAV. A plain mainboard wouldn't really help there. I have a bunch of dumps of raw data off the AR.Drone that I use for testing. Like in the UAV::Pilot::ARDrone distro, t_data/ardrone_video_stream_dump.bin is a dump of an h.264 video taken right off the AR.Drone, including the PaVE encapsulation headers. Then I have a bunch of scripts that can split that into individual h.264 frames, or rip off the PaVE data and write the video stream to a file, and so on. Then there's some navdata packets that are hex-encoded into the tests, such as in t/020_nav_packet.t. The file script/nav_data_dump.js lets me compare my code's output against NodeCopter. So I get what you're saying, but there's a bunch of ways to do that. If you do need to test against the actual machine, you can just leave the drone on the floor in many cases.
Hmm. Don't worry about the bot writing additional hashtags for now, they are not essential. Assume something like: 1. Person tweets "say 'hello' #eval #p5 #demo @friend1 @friend2" 2. Your bot searches twitter once per N minutes for "#eval #p5". 3. If it sees new matching tweets, evals the tweets and tweets results, appending the original 'comment' part of the line, replacing '#eval #p5' with a link to an explanation of your bot. 4. So the result is a tweet response like "hello t.co/123 #demo @friend1 @friend2". If what folk tweet is interesting (due to the code, the results, or the existence of the bot, or whatever) others may retweet or use the bot for another one liner which others may retweet or... And if the whole thing is in a github repo, so it's easy to contribute to the bot then other folk could improve the bot , making it more likely to gain traction... Folk (doesn't have to be you) could make the bot fancier in terms of what info it takes as input and what it decides to output. For example, on output it could add the compiler version/build id, the time it took to eval, a link to a gist containing results if they don't fit in a tweet, a hashtag or two, and so on. On input it could look for a #play:XXX hashtag where XXX is arbitrary and take that to mean that this eval should be compared input-length-wise, execution-time-wise, and output-match-wise with other tweets using the same #play hashtag.
Common sense is: don't use top-level namespace, unless it's some state-of-the-art project like Catalyst or Moose. Had he used Company::Project::Config instead, it wouldn't be a problem. 
sorry. this doesn't really make sense to me. Do you mind elaborating further. 
Is this the only way to do this? I was hoping I wouldn't have to use rand. I wanted to make make my own generator based on my numbers.. Thanks for the explanation. 
This is more or less what I meant. I'm going to try this in perl. http://codetheory.in/weighted-biased-random-number-generation-with-javascript-based-on-probability/
You can use Perl 5.18 via perlbrew, using a custom cartridge. There are a couple of problems (you should configure it to a dir other than home because the home dir isn't writable; and you should install CPAN deps without tests because, e.g., Mojolicious tests open net connections which are disabled on OpenShift; and you should muck with action hooks to run your server correctly; and of course, the setup of perlbrew+perl+cpan can take 30-60 min), but it's workable.
Grab a module from [CPAN](http://search.cpan.org/). Profile the module using [Devel::NYTProf](http://search.cpan.org/dist/Devel-NYTProf/lib/Devel/NYTProf.pm). Form a hypothesis about what can be done to speed the module up (hint: look for the code that is run the most). Make the change. Profile the module again. Rinse and repeat until you have enough data to fill your tri-fold display (I can't remember what they are called). One of the nice things about Devel::NYTProf is that it creates nice graphs for you that will look cool in your display. And remember, successfully speeding up the module is not required for a good science fair project. Accurately documenting a failure is just as important. But if you do manage to get an increase, submit the change back to the author. 
it's fine if it uses rand, I just don't like 0-150 interpreted as 1 kind of thing. It's very close to what he suggested I just like the way they implemented it better. Thanks.
It is the exact same thing /u/olleg suggested but normalized to [0,1) instead of [0,208)
yes, it makes more sense to me in my mine when it's normalized to [0,1).
Sorry, I was writing my reply from a tablet, so using integers was just a convenience to me. Using [0,1) is a more canonical way for sure.
http://prepan.org is also a good place for getting feedback on new module ideas/code.
You could use Math::Random::Discrete from CPAN use Math::Random::Discrete; my $rnd = Math::Random::Discrete-&gt;new([150,40,15,3], [1,2,3,4]); foreach (1..10) { say($rnd-&gt;rand); }
Thanks!
Seems like a good way to find perl quines that fit into 131 characters or less. ;-)
Here's my (also subjective) measure: can I get paid a living wage to write Perl in 2014? How difficult is it to find such a job?
ack
Really confused here... what does this do that vanilla grep doesn't?? $ grep . -HErne "pass" ./data/__init__.py:32: pass ./space/sol.py:16: pass And `-P` if you want perl pattern matching $ grep -Po "(case|alias) .*" .bashrc ... case "$TERM" in case would tend to support setf rather than setaf.) alias ls='ls --color=auto' alias dir='dir --color=auto' ...
You should cross-post that to /r/programming!
Seems like it would be biased towards old languages, but not reflective of what people are actually using in the present.
My team at Ariba has three open Perl slots; we've had a damn hard time filling them. 
And I believe there's a number of Perl positions open at my last company, Liveops. 
Sure. To even try to do what I suggested you'd have to deal with this problem. Hand waves ... https://metacpan.org/pod/Safe ... :base_core ... vm clouds ... mumble, mumble. This aspect is by far the gnarliest part of what I suggested and she'd have to get help to get going but I think the community would come through for her and I didn't want to scare StarRice (or others) off before she/they even began to consider it...
CPAN was moved en masse to GitHub so "a number of projects" is hardly accurate, same for SO questions. Here's an idea for another measure: number of LOC contributed to GitHub over the last 12 months vs number of SO questions over the same period. 
It's not that confusing, portfolio inflation is a thing... http://artificer.io/#/project-srcgrep Also the value is that find is also used inside the script to limit what files to grep. So it adds as much value as using find and -exec grep'ing the files that match.
I usually reference Catalyst::Manual::Tutorial on the CPAN. The model is really an interface to some kind of data. For example if you want to use a database to store information, you would create the database and use a model as the interface to that database. You can see how that is done with Sqlite here: http://search.cpan.org/~ether/Catalyst-Manual-5.9007/lib/Catalyst/Manual/Tutorial/03_MoreCatalystBasics.pod#CREATE_A_SQLITE_DATABASE You don't have to use a model for database storage only. Catalyst::Model::File for example is an interface to the filesystem. As for whether or not a model is necessary. If all of your content is static, no model is necessary. However, if you need to save any information longer than the session; An address or a phone number for example, you probably want to put it in a database and use a model class to interact with it. 
Is it safe to say that being below the line and to the right is generally better? The interpretation being that one can get more done without asking as many questions. 
That is the best measure IMO. Why are people concerned about a language's popularity? Usually because they've invested time in learning it and want to remain relevant to employers.
An alternative interpretation would be that only experienced programmers who already learned the basics with some other language turn to those languages, i.e. who writes Vim plugins except for people who are already quite knowledgeable?
TMTOWTDI is taken as a challenge by some people, resulting in widely different coding styles and a resulting difficulty in maintaining legacy code.
It can also mean there are other places where users of that particular language go to ask questions.
Every language goes through the same phases of life. Once something has been really popular, all that's left is the inevitable "decline." Whether the decline is real or not, it takes a certain toll. But for me, Perl is as durable as Javascript. It's going to be there until after you retire. It may morph into something else, but it will be there, in some form. It's best to learn multiple languages, and work somewhere that lets you choose what you want to use. We switched our big flagship over from Java to Groovy, and use Perl for pretty much everything else. Is that changing? Not for us. It's not so much the language as what you're doing with it (the project). The language is a detail. But I would prefer to use Perl because it's fun and powerful. P.S. Linux is also "old".
My previous employer was extremely picky about what we could use on our production Windows servers. The application consisted of C++ code built into executables so their thought process was "you don't need anything else installed on our servers besides Oracle client for the database connection." The Oracle database client has a Perl install with it by default, so I wrote administrative scripts and jobs with that at hand, since I couldn't use Powershell for everything. I loved using Perl and will continue to use it, despite the fact that I was "forced" into using it in the first place. If I still worked there I would be nervous too - administrative and O&amp;M tasks are critical and depending on another software's library for access to Perl is a terrible idea.
I love Perl, but it isn't going anywhere. The developers could have given it sensible method signatures a decade ago, but half of the features added (like smart match and auto deref) have been removed because they were poorly designed. The language survives mainly because of innovations in CPAN. On the other hand, there is no reason to worry. If you succeed with Perl (and can deal with its obscure shorthand and innumerable gotchas) then no other dynamic language will pose a problem for you. You can get comfortable in Ruby or Python in a matter of days.
&gt;I love Perl, but it isn't going anywhere. ... The language survives mainly because of innovations in CPAN. Er, how is that different from *any* other mature language? (substitute "user community" for CPAN) 
If they can't compete with you, they insult you. Perl being old as an argument to not use perl is one of my favorites. My response generally, is "and?" C is old. Perl is old. Shit ton of reliable systems still run because of the simple fact that it works, works well with limited resources, and consistently performs. That to me is the argument end all... what will work the best, using the least resources, and provide the longest usage. If they want python because it's newer... then ask if that's the only reason. .Net was newer and got a ton of people using it when it came out.
And the more you say Perl is unpopular, the more unpopular it becomes.
Ruby and Python aren't actually that much newer than Perl. Perl was invented in 1987, reached 5 in 2000; Ruby appeared in 1995; Python in 1991. The difference is that Perl *feels* old. Partly this is due to the huge existing codebase of 'crufty' code that could be written better, partly lack of effective advertising/'branding' (e.g. Catalyst vs. Rails) and partly because the core language itself is outdated in many respects compared to Ruby and Python, with no sign of that changing anytime soon. I think a comparison to C is disingeneous because that language is inherently resistant to changing over time. Its entire focus is to be basic, close to the metal and portable. Perl is a dynamic language which could easily have, say, function signatures or a sensible object system by now, but it does not. People are switching to Python because of that, not simply because it's newer.
I am new to perl (about two months worth of coding, ~1 hour daily on average) but I am not new to programming in general. From my current perspective decline in Perl coders is quite baffling. I'll try to explain. Before that, bare in mind that my programs are not intended for wide use. I have about eight years of background in scientific computing, first as mathematics/physics student and later for various institutes. I have started with C, then Fortran and only two years ago I started getting out of these two if you don't count Bash scripting and self-taught Assembly. I have added Python, found out that nympy/scipy is not always sufficient, similar case with Sage. Then came Common Lisp, Mathematica, Haskell and Scheme (I got fascinated by syntax and natural for me way of functional thinking). I'm still mostly work with C and Fortran, but making one monolithic program is usually counter-productive. So I started making smaller programs in different languages and tried to 'glue' them together. Bash was too slow, same with Python (unless you want to point out Cython to me. But with amount of optimization needed I would rather make it in C). Some people recommended Lua, but it resulted in multitude of minor problems. Discouraging to the point that I had to forsake it and looked for replacement. Again. One post-doc student I worked with overheard me discussing this problem and introduced me with Perl. And... it worked amazingly. Just as advertised, perfect fill in the gap between C and Bash. I started propagating Perl among my peers, now more and more of them are replacing Python/Ruby/Bash scripts with it. Just like that. My friend even commented on it as 'Yeah, syntax is weird at first, But after benchmarking some of my Python scripts and their Perl remakes there is at worst only 5% difference in speed'. This is not exactly what he said, but I want to be PG13 about it :P. I can't believe that I did not get interested in Perl earlier and I am quite surprised that it is not more popular then other languages in that category. While it might seem old, I see far more potential in Perl then in Python. 
What's the rough salary range?
Thanks a lot. I think I'll have a better idea of how to decide whether or not I need a model now.
Thanks! That blog looks like an interesting resource to keep up with!
From what I understand, Perl will not go away anytime soon, as there are so many scripts running on so many vital servers. It's a great language for scripting a system, and I see no reason that it will ever change. Until, of course, some AI takes over the world.
Perl was a victim of its own success. It is such a "hacker's delight" that many, many people discovered they could solve pretty hard problems without any background, just by teaching themselves Perl syntax. The problems came because Perl, more than any other language I've encountered, lets you write horrifically ugly code if you choose. Bad Perl code is worse than bad assembler code, it's worse than bad C, it's worse than INTERCAL. Good Perl code can indeed be a thing of beauty. Python seems to be surging primarily because it does enforce some basic style and design rules -- so it's an easy language to teach. Pascal had a similar run in the 1980s, for similar reasons (compared to C). For scientific computing: try [Perl/PDL](http://pdl.perl.org). It doesn't have as many specialized niche applications as Python, but it's far more general and powerful than Scipy/Numpy. Among other things, you can use *Inline* to write hotspots in other languages, right there in the middle of your Perl script. There's also a "Perldlpp" metalanguage that lets you write vector operators very concisely, and that compiles to C. 
That's the P6 argument: the reason it's not usable is because so many people complain it's not usable (and, by implication, not because the people who've worked on it over the years, *including me*, made poor decisions).
Bad Perl is not worse than bad C from a security perspective. Poorly written C can be very dangerous. If you don't know how to work properly with buffers and memory, it's very easy to inject malicious things via your bad C program. Not so easy to exploit via Perl. I'll also argue that Python is surging because it's what all intro CS courses are using now (instead of Java), so it's just what people know -- not because of its syntax. Its syntax has become such an issue that pep8 needs to exist so you don't fuck it up and have to deal with huge bugs because you missed an indent. 
Yep. Python is surging because it's what all intro CS courses are using -- and that is because it is a B&amp;D language that enforces a particular style. Pascal had exactly the same process: it enforced "structured programming" (what everybody does now) rigidly, and as a result was an ideal teaching language -- so for a "generation" (5-10 years), everyone who studied CS ended up knowing Pascal. Of course, Pascal totally sucks for anything that's not a toy problem -- but that didn't stop Apple from writing a whole operating system in it.
I know C and Python, and a little bit of Perl (I came to this subreddit very recently to learn more about it). Recently, I've been trying to put myself out there as a Python/C developer to find work, only to find that nobody really cares about C any more. What I've discovered is that a lot of businesses have decided that compiled languages are simply too inefficient to program in using rolling release/Agile-type development cycles, and that it's much easier to keep everyone on the same page as an interpretive language. Most jobs I've applied for ask for Python, Perl, and Ruby, in that order - but no C, or even C++. Some interviewers have outright told me C/C++ "isn't really a consideration," aside from the generalized programming experience that entails. So, is C/C++ dead? Probably not. There's just not much of a use for it except for specific applications, now that easier tools have come around. Perl is still used heavily in the sysadmin field, I've found - "Perl experience necessary" is present in almost all sysadmin-oriented job postings I've seen - but for generalized development, Python/Ruby are the talk of the day. tl;dr: Perl is used as sysadmin duct tape more often, whereas many core applications are programmed in Python/Ruby these days. That's just the trend. Perl isn't dead - it's just found another role.
I've been learning Perl off and on for the past two months. My biggest problem with Perl is that there appear to be really low standards for what is considered acceptable commenting and reliability. For example, my latest Perl project involved downloading e-mail attachments from a gmail account. Searching for 'Perl gmail download attachment' yields links to code which uses some combination of MIME::Parser, Email::Simple (which is a complete red herring; it won't help at all), and Email::MIME::Attachment::Stripper. Some other folks also have their own, less popular modules which they may even link to. These smaller modules don't work. Then I look at the documentation for the major modules. I can either get good textual descriptions of the supported methods for an object/module, or I can see example code that's somewhat related to what I need. I never see both together. In addition, it seems like every example either describes using Email::Simple to get a message index into the $message variable, or describes how to parse a $message using MIME::Parser. Bridging that gap is apparently up to the programmer. And you'd think these two modules would work together. They don't. I have significant experience with C++, Python, and MATLAB. I thought Perl was supposed to be superior to Python, which is why I was trying to learn it, but I know the solution is easy in Python so I'm going to implement it in Python in maybe 30 minutes. Sure, the code will be simplistic and inelegant. But working inelegant code is better than elegant code that takes 20 hours to write/debug.
The sysadmin role isn't anything new, though--most serious uses of one-liners fall into that category. This role will continue to exist as long as there are Unixy servers around.
Yeah, for sure - I'm just saying that Perl isn't dead and wont be dead any time soon, because many tech jobs still require strong Perl knowledge, which will always keep people learning it. It's just not used that often for mainline development any more - but neither is C/C++.
Perl does have a sensible object system. It has several, in fact :-) Seriously, the wide-open structure of the language's built-in system may encourage bad practice, but it does offer a very minimalist approach with little cognitive overhead. More modern add-ons like Moose are simply awesome. 
&gt; Perl needs a new killer app. People have been saying that for years now. Doesn't seem to be happening though. 
**Marketing**. Perl just has a very unsexy image. Some better visually designed downstream products would help. And to anyone who wants to jump in with "what do pretty pictures have to do with a programming language", it's not about you. **Quality**. I agree with /u/metagamex. The quality of Perl code out there in the wild is bad. And people also let it continue to be bad. Like there should be a movement to improve the adoption of Perl's best practices. Yes, I know Modern Perl exists. But something more definitive. Draw a line in the sand and say "no, this is bad, stop writing code this way". **Killer app.** I don't know why /u/frezik was downvoted. It is true that one way of spurring adoption is the existence of a killer product that happens to be implemented in Perl. See Rails or Google's initial use of Python.
I wrote about this at length on my AtariAge blog at http://atariage.com/forums/blog/561/entry-10780-perl-is-irrelavent-and-the-atari-2600-isnt/, but: We've been behind the ease-of-adoption curve for a long time. mod_perl was a major headache to set up and install, and a major headache to use. Its API exposed all of the Apache request processing cycle internals, which are complicated and scary. mod_php on the other hand was self contained and presented a simplified API. PHP popularized Web programming. It took it to the masses by virtue of making it easy. Ruby popularized Web frameworks. Perl hoped on that bandwagon late. By the time Perl was on the Web framework bandwagon, almost all new development was being done on top of CMSes such as WordPress. Most people learning PHP now days learn it so they can modify or create extensions to WordPress. When someone wants to put up a site and they aren't using tumblr or the like, for most people, the first thing they do is go WordPress plugin shopping. Perl programmers have, for the 15 years or so I've been using Perl, concerned about other programmers. PHP has been interested in end users: empowering them, creating apps for them, supporting them, teaching them. Perl never had much of a chance of taking on C++, C#, or Java without a strong typing implementation because "enterprise" shops using those that employ 20+ programmers are just too attached to compile time type checking. It keeps new programmers in line, catches mistakes, and clearly deliminators responsibilities between programmers building different parts of the system. You can tell them that they really don't need that feature and that there other ways to do it, but 1. they *like* that feature 2. it's probably *you* who doesn't get it so really you're wasting your breath. 
You might try http://jobs.perl.org/ if you've not already.
In summer 2000, Larry announced that Perl 5's end of life would occur toward the end of 2001 or start of 2002. Almost everyone reading this knows that the story has a *lot* more nuance than that, but Perl as a language *did* suffer from a holding pattern until about 2010, and by then a decade of damage had been done. If Python 3 is having adoption problems five years after release, think how much worse a P6 would be if it were ever released--and P6 isn't nominally a replacement for Perl anymore.
That's an absurd argument. Whoever came up with that has a seriously twisted imagination. :) Got a link? Of course *I* have engaged with you three times over the last couple years about my hunch that *your* hostility toward P6 has negatively affected *contribution* to P6. Is that what you're talking about? I regularly see P6ers claiming that users who conclude it's not usable for them (yet) identify lack of speed as the deal breaker more than any other problem. No one is making the absurd argument you suggested.
CPAN is like a non-default subreddit really, if it's not core then a huge percentage of people aren't going to use Moose. I've had to actively convince people to use it at work. Instead people write all this boilerplate (and wrong) `ref($class)||$class` stuff and write constructors that can't be overridden or make typos when accessing attributes in `$self`. It *is* minimalist, but perhaps a little too minimalist for me :P
And Python 2 is getting a lot of Python improvements backported, right? Further dampening the impetus to upgrade. Perl 5 is slowly going in that direction and Perl 6 is for all intents and purposes a completely different language, I think!
Not so much a challenge as an inevitable consequence of having a language that's awesomely expressive. It makes coding more fun and more personal, but self-control and diligence is required to restrict yourself to the Perl Best Practices subset. It's simply easier to get into this situation with Perl than with Python.
I think P6 is not usable yet because the scope of the language is just ridiculously huge. The architectural decisions required to get the language functional, complete *and* fast seem extremely hard and that's evidenced by how many backend rewrites have occured with Rakudo.
I thought Mojolicious would be it, ah well...
I mainly mean that the language is open and hackable enough that you can implement all kinds of crazy stuff in CPAN. No doubt the community is hugely responsible for Perl's continued (relative) popularity.
&gt; I regularly see *P6ers* claiming I emphasized the problem in that statement for you. You would do better getting feedback from people who don't hang out in #perl6 all day about why they don't bother. &gt; I have engaged with you three times over the last couple years about my hunch that your hostility toward P6 has negatively affected contribution to P6. You're severely overestimating the amount of influence I have, had, or care to wield. I stopped working on P6 *because* I felt that I no longer had any influence on the project. It was pretty clear that Rakudo developers were going to do what they wanted to do and didn't want my contributions. (It's darkly amusing you make that accusation, because I can point you to the moment pretty much everyone left Parrot for good--due to the latent hostility *from* Rakudo *toward* Parrot becoming explicit. However, the last time I pointed you to IRC logs where Rakudo developers admitted that, for example, they directly told me *not* to work on things that would benefit Rakudo, you didn't bother to read them.)
I wouldn't concern yourself with it. Knowing a language in depth and having logical reasons for why it's such a great language is always a trap and disappointment. 
&gt; Python 2 is getting a lot of Python improvements backported, right? Not really. 2.7 lets you use some 3 features, but they're always going to be separate and there'll never be a 2.8 that gets 2.x closer to 3.x. The big concern is that there's a lot of 2.x code that may not be worth updating to 3.x. That includes free/libre libraries (which are slowly getting updated or replaced) but lots of internal code.
Good call. I'll post it over there. Wanted to give redditors a chance at it first. If you're cruising /r/perl, you're probably smarter than the average bear when it comes to camels.
&gt; that's evidenced by how many backend rewrites have occured with Rakudo. Another interpretation is that the people working on Rakudo are more motivated by fun than they are by the desire to produce a single, polished product for end-users who aren't also Rakudo developers.
In principle, with suitable teaching materials, P6 could excel as a multi-paradigm language for expressing a very wide range of language concepts. Hence Damian's interesting [single-training-lang-for-CS](http://www.meetup.com/Oslo-pm/events/172566472/) concept.
If p6 ever gets off the skids and into the ocean, that would indeed be a very nice thing.
&gt; Programming Language &gt; &gt; ... &gt; &gt; XML &gt; &gt; TeX :(
SoCal as in greater LA area or San Diego area? The two are very different.
The way I see Perl, it's going to be the new Cobol, and my retirement strategy is 3 months of [hardcore fixes in 2038](http://www.perlfoundation.org/make_localtime_and_gmtime_work_past_2038) ;-)
Yow. I didn't realize the release schedule was *that* bad. Duke Nukem Forever of the programming world...
I'd [try CPAN](http://search.cpan.org/search?q=gmail;s=1) before Google. Looks like the first result might do what you need.
We are in Laguna Beach, which is almost exactly in between the two. Lot's of restaurants, art galleries, stuff to do, very beachy.
Thanks! I will try it out when I'll get a bit more confident with Perl. But I think I might have worded my use of Perl badly: I am not using it for calculations, I am using Perl to maintain queue and redirect some I/O between few small programs that run particular parts of very complex computation. I know that it is really bad practice, but my 'user base' consists of me and three people at the institute :P. I would never attempt something like that in any other circumstances.
I had written something here, but decided to erase it. In short, these discussions come and go, we vent but nothing happens. As if we look at the car being about to crash, scream, but none takes -or is able to take- the wheel to avoid it.
Are you talking about the *lack* of a move to perl 6?
&gt; Not so easy to exploit via Perl. You've probably never seen "eval"-ed strings received from CGI parameters. But I've seen such and similar code several times. And, because the Perl is higher-level language, it could lead to severe consequences. 
I remember when perl was new and shiny, there was no bash, and sh/awk/sed/csh scripting was old and unpopular. I suspect in 20 years pythin &amp; ruby will be old &amp; unpopular....
The way I see it, the competitors are easier to learn and that's very hard to fight. Perl was popular because it made things easier, not because it was pretty or expressive or whatever other thing you want to think about. And now the competitors are easier to use, and specially ruby and python, embracing object orientation ( which sadly won the "paradigm wars" ) , that of which in perl is just a feature. I don't think that being "mature" is an excuse for not improving the language, at first it was reactionary, it did things differently, now it lacks that, it just does less because "think of the legacy code!". That thinking takes you nowhere.
It was great but never evolved. No subroutine parameters, objects painful after twenty years. Both were obviously bad from day one. I still love it for what it is capable of.
TIL: FORTRAN is still killing it. In your face Boo.
Try Mail::Box. It isn't as simple as some other modules out there, but it does almost everything you'd need to do with retrieving messages out of mailboxes. And I agree with the sibling commenter. Go directly to CPAN. If you don't find anything there, ask. One trick I use when I don't see enough docs is go into the test directory and see how the tests use the module.
Mojolicious is a tool to make the killer apps. Perl has great tools. It's time to focus on things non-developer end-users want.
As a sysadmin who has written quite a bit of Perl over the past two decades, I think the reasons are generally: 1) PHP. Almost full stop. Perl was not a great "web" language back when it was king - PHP was much easier to learn, and allowed for lesser skilled folks to quickly get webapps up and going. Perl/CGI was comparatively harder to write, and generally slower. I won't talk about mod_perl because it was and is atrocious for the small self-taught web developer. Heck, it's atrocious even for larger apps. I still have extreme disgust towards PHP based on the early days of every idiot and their mother coding "applications" I had to support and try to scale as a higher-end web hosting shop. I imagine other folks feel the same about Perl. 2) The neckbeard Perl hacker types - I may be a bit guilty here. I have an ex co-worker who wrote nearly exclusively in Perl (more programmer than sys-admin) and he found it a personal challenge to make everything as complex and clever as possible. Too many people writing code like this as a point of pride turned off new users to the language. If I have to debug another 90 character regex I might scream, although you certainly feel some sense of accomplishment after doing so (note: this is not a good thing). 3) Perl6 never actually becoming anything. 4) Lack of a good consistent object system - I'm not a programmer so I can't really comment a lot here (all my stuff is generally functional in nature) but I have to say Perl's OO still confuses the crap out of me to this day sometimes. That all said, I still love Perl. I prefer Perl over shell programming, and CPAN still is unsurpassed in the world of languages for it's sheer coverage of just about anything you could possibly think of in a sysadmin role. These days, I think a lot of the problems have been solved. Mojo is up there with the best of the web frameworks I can see, and you can start off with a really simple script and easily expand it through CPAN and make it extremely robust with little effort. The "perl code is ugly" seems to be getting quite a bit better, as less extreme hacker types have gotten into the language. Reasons I love Perl... 1) Perl5 is stable. It just fucking works. Anywhere. I can write a script to base Perl5 (e.g. no CPAN - just base modules) and I can expect it to work out of box on any Unix OS ever released in the past 15 years, and likely any to be released in the next 15. PHP/Ruby/Etc. is hell in comparison. If I get asked to install version 99.3.4.5 vs. 99.3.4.3 of some new trend language I might go on a rampage. I can update the OS, and pretty much guarantee the Perl stuff will work fine. The Ruby stuff is guaranteed to break every single time, and the PHP stuff is still a bit iffy but getting leaps and bounds better than it was just 5 years ago. Python is in the middle, but generally Python devs are using some framework that breaks horribly if you change anything. Don't get me started on Node. 2) It works great for small one-liners, all the way up in to major web applications. Yes, you have to be smart to scale Perl, but that's true for any language. I find it hides developer stupidity a lot less than the latest "in" language (guaranteed to use the newest trendy "framework"), so there are fewer nasty scaling surprises. Less is hidden from the developer, and for me it's much easier to eyeball some Perl code to know where the scaling issues will lie vs. Django or Rails or whatever you cool kids are using these days. A lot of this likely is simply due to new kids with no experience are not using Perl to begin with though, and those that do have been around the block a few times and know you shouldn't be doing SELECT * or passing HTTP parameters to the shell, or relying on some shitty framework to "optimize" your SQL for a webapp that gets 10,000 hits/second. Most web scaling issues I get paid to fix generally are some framework abstracting the database layer so much a single simple page render is making 280 queries when 2 or 3 would suffice if hand-crafted. tldr; Perl coders tend to rely less on frameworks and abstraction. This can be a good or bad thing, depending on what you're doing. 3) CPAN. Enough said. 4) If you're going to know one language as a sys-admin, I'm going to say Perl is your best bet. If you're a developer by trade, then knowing one language is just being stupid. For me, I just have no interest in spending a few weeks/months becoming proficient at another language, when I know I can solve pretty much anything I need to with Perl. I'm not coding the next Facebook here, I'm largely solving infrastructure automation problems. Using the right tool for the job matters, and for SA work - Perl generally is the right tool should the job call for more than a 50 line bash script. See #1 for why. 5) I just enjoy it. I find some Perl to be absolutely gorgeous. The same can be said for any language of course, but Perl is my first love. Things that concern me... 1) The general attitude from "real" developers that Perl is old and shitty, and only idiots use it. I've become less concerned over the past few years of this, because from experience developers with that attitude tend to be pretty bad anyways. Still a concern though. 2) Somewhat related, but the deeply concerning lack of API modules being released on CPAN for some things. Infrastructure related APIs generally are still fine, but the trend is there. This is the one thing about Perl that I feel is a major concern to be watched, and it saddens me. Sorry for the wall of text. I get annoyed at the folks I work with now dumping on it so much, mostly for invalid reasons. I don't think Perl is the right choice for most "major" projects, but it still functions much better than languages meant to replace it in most of it's traditional roles. Mojo is extremely interesting, and I love being able to apply my SA-level Perl knowledge into coding some quick webapp in my spare time, or a quick web portal to interface into a CLI tool I wrote that needs to grow to be more user friendly. In the end, I love it because I know it, I don't need to waste time learning another tool to solve problems well matched for what Perl already has done for decades. Perl largely just works without a lot of prerequisite fussing the other languages tend to need. It's the old reliable friend.
If you can write a vi style text editor in Perl, that would be your chance to sneak important Perl modules in the core GNU/Linux OS. I can't do It myself because I am too busy writing database applications and card games to write it myself.
TeX is a full-blown programming language for type setting. LaTeX is a markup language implemented as a TeX library.
Oh, my "of course" wasn't meant to say it's a reasonable thing to do. I only meant that everybody knows P6 is now his pet project, and so it's predictable that he would focus his energies on it. 
&gt; the last time I pointed you to IRC logs ... you didn't bother to read them. [Sure I did](http://irclog.perlgeek.de/parrotsketch/2011-09-06#i_4382859). For anyone reading along, chromatic pointed me to this link last year to back up a claim he made that he was "told not to change Parrot" and that this had led him to conclude "there was no reason to continue working on {Parrot}". I'll let you read the exchange yourself so you can draw your own conclusions.
I know what TeX is (and LaTeX too, for that matter), but I wouldn't call it a programming language just because you *can* program with it, at least not in the context of comparing programming languages. I sure hope people don't use it for other things than typesetting.
I'm curious what "off the skids and into the ocean" means. Also, what do you think remains to be done, if anything, for Rakudo to be ready for Damian's concept?
I can't speak for drzowie, but for me it is the moment when Perl 6 becomes comparable in speed of execution, usefulness and ease of learning and writing with Perl 5, Python or Ruby.
&gt;Seems like you already have to know ahead of time the way the XML is nested in order to create a profile, is that right? That's right, XML::Dataset wouldn't work where the xml structure is unknown ahead of time. It sounds like you've got it covered already, but for those situations I like to use straight XML::LibXML or XML::Rabbit.
I overstated things with "end of life"; that's a technical term of art. What I *meant* (and should have written) was "release date for P6, at which point P5 goes mostly into maintenance mode". With that said, that 18-24 month figure was *always* the plan back then. Larry didn't mention it in SOTO 4, but you can see it in the RFCs: "Finally, we've got about 18 months before Perl 6 is expected to ship." -- [RFC 260](http://www.perl6.org/archive/rfc/260.html), published September 2000 "Perl 6.0.0 (Octoberish 2002)" -- [Perl 6 Prospective](http://blob.perl.org/perlweb/dev/perl6/talks/2001/Perl6-Notes-200108.v2.pdf), Damian Conway 2001 I believe Larry gave a rough date along those lines at his ALS talk in September (?) 2000, but the transcript has disappeared from the net.
&gt; chromatic pointed me to this link last year to back up a claim he made that he was "told not to change Parrot" Partially true. You're overstating things; I posted that link to demonstrate that even Rakudo developers agree that they told me not to make certain changes to Parrot, even though they'd be beneficial for Rakudo. That's a long way from me claiming I was told not to change Parrot, but at least it's in the same time zone as the truth. &gt; and that this had led him to conclude Nonsense. I've never made that the consequent of the former statement. You're putting words in my mouth and arguing against a position I've neither held nor expressed. Why does it seem like every discussion you try to hold with me devolves into you making bizarre strawman arguments?
&gt; And, because the Perl is higher-level language, it could lead to severe consequences. Can you explain this a little? Not quite following. I would replace "because" with "despite" myself. Not a lot you can do if you have an epic moron writing code. Look at PHP with the ever-so-common directly passing HTTP_* variables into exec() calls or a file handle opens, or other stuff I'm forgetting before my morning caffeine. And yes, I have seen the same thing you're describing and I still facepalm every time. That said.. There was this one looking glass script I wrote that did system("$ping $host") instead of system($ping, $host) I'm still kicking myself for 11 years later :)
The next release of perl will have subroutine signatures.
Maybe I was not so clear about what I wanted to say. I'll try to re-phrase. Perl, being a higher-level language, makes it easier to exploit a vulnerability. Exploiting code execution vulnerabilities in C-written code is quite difficult. You need to carefully craft the malicious code because it's not very easy to translate your intent into bytes and be 100% sure it will work on particular system. With Perl, you just pass Perl code and it works just fine everywhere. Data::Dumper or Storable serialization was a norm before YAML and JSON came into game, so old code may have a lot of such problems. 
Seconding jobs.perl.org - I've found both some quality freelancers there, as well as one guy I hired full time (who turned out great, but moved on to a more senior role elsewhere after a couple years). The only difficulty you're likely to have is finding someone either local, or willing to relocate :)
This seems to get the job done to me, were you having problems? It's a "weak" form of tracking in that it's based on that specific browser, folks not clearing cookies, etc. But you likely already knew this. Nothing wrong with using CGI for tiny little scripts like this - I think Mojo and the like would be overkill if it's a one-off standalone thing. Not quite understanding the question, I guess. 
&gt; 18-24 month figure was always the plan back then. Michael Schwern spoke of an expectation. Damian's date was explicitly a "Forecast". Both are well known for being very enthusiastic. Conflating an enthusiastic expectation or forecast with "a plan" is often a basic mistake. Perhaps you just didn't find the quote to prove your point. I'd still like to see the ALS talk transcript. I'll predict that, if Larry talked of "the plan" or even just "a plan", his words would have been consistent with the wisdom apparent in his original P6 announcement and he was not talking of his own expectations or plans.
In this day in age why don't you use google analytics? It is free to use and for most sites will be enough.
&gt; Perhaps, when you say "always the plan back then" you mean "the expectation" or "forecast" of some community leaders.... Conflating an enthusiastic expectation or forecast with "a plan" is a fundamental mistake. I was *there*. From the beginning, there was no explicit release date set, but the expectation was always to have a beta by OSCON 2001 and a stable release around the start of 2002. For example, on the bootstrap list: &gt; The final release will be on (he picks a date approx. 18 months from the start of the project) 1 January 2002. -- [Nat Torkington on P6 release planning, August 18, 2000](http://www.nntp.perl.org/group/perl.bootstrap/2000/08/msg1185.html) Nat, of course, was the first project manager of the project. Note that this email updates the timeline that Nat and Skud put together--see the [Archive.org copy of the HTML P6 project timeline] (https://web.archive.org/web/20010214041533/http://infotrope.net/opensource/software/perl6/plan/x96.html). That timeline comes from the [original p6-bootstrap list project plan from August 4, 2000](http://grokbase.com/t/perl/bootstrap/0084nbcq2v/perl-6-project-plan-roadmap). Note Skud's words: &gt; This is intended to be *the master plan* that guides the development of Perl 6. Emphasis mine.
How about Marpa? But then, it's also a tool to make apps, not the app itself.
Thanks for the links. So the 2002 release date Nat declared was made up on the spot and all he had to go on was Skud's skeletal timeline which Skud charitably called "vaguely defined" for the "later stages of the project" (ie no dates, which is pretty vague for a timeline). If *anyone* took Nat's release date seriously they needed their head examined. If large chunks of the Perl community did, well, what on earth happened? Now I *really* want to see what Larry said about this plan and especially about P5 in light of this plan. If he formally set in stone the release date that Nat arbitrarily picked then Larry really needed to very loudly and completely reverse himself once he became seriously late delivering the "Preliminary design and specification". And if he also EOL'd P5, or anything like that, based on Nat's release date, well, for once, words fail me.
&gt; Nonsense. I've never made that ("there was no reason to continue working on {Parrot}") the consequent of the former statement ("told not to change Parrot"). You're putting words in my mouth and arguing against a position I've neither held nor expressed. chromatic: ["After being told not to improve Parrot (being told not to change Parrot), there was no reason to continue working on it. That's why you can see commits and participation drop off a cliff"](http://perlmonks.org/?node_id=1053960) How am I misinterpreting that? ---- &gt;&gt; chromatic pointed me to this link last year to back up a claim he made that he was "told not to change Parrot" &gt; You're overstating things; I posted that link to demonstrate that even Rakudo developers agree that they told me not to make certain changes to Parrot, even though they'd be beneficial for Rakudo. The precise quotes: chromatic: "After being told not to improve Parrot (being told not to change Parrot)" me: ["No way am I going to believe that that is a balanced characterization of what went down."](http://perlmonks.org/?node_id=1054051) chromatic: ["With all due respect, that's because you have no intent of reading the IRC logs or the mailing list archives of that time period. If you cared to do any research at all, you would have no trouble confirming my characterization of the event."](http://perlmonks.org/?node_id=1054132) And then, a week or so later: chromatic: ["Found it."](http://perlmonks.org/?node_id=1055549) with the IRC log link. How am I overstating things? Also, fwiw, the Rakudo developers wanted stuff that was *definitely going to be* beneficial to Rakudo, but there were lists of things that were only *theoretically going to be* beneficial to Rakudo, and they had reason to defer you from the latter. Again, for those interested, reading this [exchange about Parrot and Rakudo from the #parrotsketch IRC log of Sep 6 2011](http://irclog.perlgeek.de/parrotsketch/2011-09-06#i_4382859) is instructive. ---- &gt; Why does it seem like every discussion you try to hold with me devolves into you making bizarre strawman arguments? Not sure. Your perception perhaps? It certainly doesn't surprise me that our dialogs devolve into something unproductive if the truth seems to you to be a bizarre strawman.
Somme active Perl defenders are working on marketing, but I believe Perl has nothing to prove.
Even more important than a 5% speed difference, you can also feel a 50% satisfaction difference when the Perl is greatly written in *natural language*, that your modules are tested and packaged in the perlish way... It **really** makes the difference. Good code is not necessarily about great performance. 
Go is better than Perl/Python/Ruby. Perl/Ruby were sidegrades to Perl. Go is an upgrade. Perl is going to become more and more marginal, sorry to say. (If you need something more "dynamic" than Go, then JavaScript will fit the bill [not Perl]).
[Unicode Utility](http://www.reddit.com/r/perl/comments/254g8m/concerned_about_perl_unpopularity/chf15ov)?
**Edited** This is solid info yet it got downvotes. Maybe this version will do better. I think you've misunderstood the P6-is-a-spec notion and its outcome. P6 has an informal written spec. Surely you can't think that is a bad thing per se? We have, for all practical purposes, like P5, just one reference implementation -- Rakudo. So you should like that. We also have a bunch of "spec" tests (30K+). These serve as regression tests for Rakudo, just as P5 has regression tests, but they match the spec, so they also serve as acceptance tests. This is a solid technical way to determine whether a compiler is or isn't a compatible P6 compiler. Larry's words on this topic from [his 2000 SOTO](http://www.perl.com/pub/2000/10/23/soto2000.html) established this approach: &gt; there is some value to using the reference implementation approach and what we currently have [P5] is a reference implementation... but, obviously there are benefits to having things justified well enough that you could implement another one even if you didn't want to ... what we particularly want to stress ... is not perhaps so much the spec as developing our current regression test. Well, we call them regression tests, but they're almost more acceptance tests ... of what the language actually means ... and then we actually have a machine-readable spec.
Said *I*, not most of the people. Indeed it's sad how people that don't know very well the actual Perl ecosystem can react when you mention that you are motivated by it, arguing that Perl is *for system administration only* or that it produce *strong spaghetti code* as if you can't produce spaghetti code with Java or Python.
&gt; You've plucked a single sentence out of its context and made a fallacious inference Thanks. Fwiw I understood Patrick made the list you're talking about. If you avoid making [inflammatory/absurd/false statements about P6](http://www.reddit.com/r/perl/comments/254g8m/concerned_about_perl_unpopularity/chdpcfd) or me ("I pointed you to IRC logs ... you didn't bother to read them") I'll happily leave you out of it.
How about: use sqlite instead of a text file, then use SQL to sort the results! 
I think Perl does produce strong spaghetti code. Without going too deeply into it my thesis is that good Perl requires more discipline per unit of work than other languages making for relatively sloppy code for any constant value of discipline.
This kind of discipline is a value. Maybe some might say that this value is too expensive.
**Edited** This is solid info yet it got downvotes. Maybe this version will do better. As to portability: Rakudo runs on MoarVM and Parrot, both of which are portable across platforms that can be programmed in C, ie the same range in principle as Perl 5. For example Nicholas Clark is doing [ongoing work to get MoarVM to run well on more architectures](http://irclog.perlgeek.de/moarvm/2014-05-11#i_8708087). Rakudo also runs well on the JVM. In this sense P6 is already more portable than P5. (And to complete this roundup: a substantial chunk of the work to port to JS, and eventually to run in a browser, has been done; and Rakudo is known to be readily portable to .NET because jnthn prototyped 6model on .NET.) So, in general, P6 can run on a broader range of platforms than Perl 5. This all accords with Larry's guidance on portability from [Apocalypse 1](http://www.perl6.org/archive/doc/design/apo/A01.html): &gt; Perl 6 must not be limited to running only on platforms that can be programmed in C. It must be able to run in other kinds of virtual machines, such as those supported by Java and C#.
I noticed I cannot get it to print the variable in the html page. It's suppose to display a page that says how many times you visited it.
In my case, performance is the most important thing. At least when it comes to coding at work. This little improvement, even by 5% can mean shortening computation time by tens of hours. 
TAP is sexy. Yeah, baby,
This is cheating. Get off Reddit and study like an adult.
&gt; I fully admit I know nearly nothing about P6. I've followed it on and off since 2000. I've read [the #perl6 log](http://irclog.perlgeek.de/perl6/) daily since mid 2011. I contribute around the edges, eg this [bugfix](https://github.com/jnthn/rakudo-debugger/pull/20) and [speedup](https://github.com/jnthn/rakudo-debugger/pull/22) for the debugger or this [draft grammar for http://cpan.org/MIRRORED.BY](https://gist.githubusercontent.com/raiph/63508a5f4ade000acc7f/raw/08dd25bda87096a8fd2d2f155000137d864f87b1/gistfile1.txt). &gt; Thanks for the info! I have some reading to do. Most of the content on the net about P6 is bogus. Incorrect or worse. Even the good content is patchy. I'd be happy to be your guide. What do you want to read about? Alternatively, set aside a half hour to [visit #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) (peak activity is something like 6am - 6pm EST) and ask questions. &gt; Perl6 is trying to be everything for everybody running everywhere. No. I'd say it's aiming roughly at what P5 would aim for if it weren't as hard to evolve the core (for social and technical reasons) as it is. (Though I'm very pleased that things like signatures and Stevan's mop look likely to land in the near term.) &gt; I'd rather have Perl5's very well implemented interpreter that only runs on C platforms, vs. P6's idealistic halfway-implementations that run everywhere. Good news. You *have* Perl 5's very well implemented interpreter and there's no reason to let it go unless you choose to. The P6 design and Rakudo architecture assume an embeded libperl, and use of CPAN, including XS-using modules, as first class citizens. It's hard to say when this P5 interop will finally get implemented (I suspect diakopter isn't going to do it after all), but provided the trajectory of the last 3 years is sustained I'd be really surprised if P5 interop weren't a fairly mature part of P6 by 2017. Also, Rakudo is not an idealistic halfway implementation. I know you may have heard otherwise. But it isn't. &gt; One implementation means you can realistically code towards it - and know that if you're running Perl 5.10 and write code to Perl 5.10 it will run wherever Perl 5.10 is installed. You seemed to have missed the point I made in my earlier comment above. There is, in practice, just one P6 implementation that matters: Rakudo. (Just as there are arguably multiple implementations of perl 5, but again, just one that matters in practice.) &gt; When someone comes to me and says "I have a Perl app!" I want to know exactly what that means from that simple statement. Perl6 makes that nearly impossible - I will have to ask which interpreter, versions, etc. With P5 you generally ought to concern yourself with which version of P5, just in case it makes a difference. Is it 5.10 or 5.14? And what if you want to use modules A and B that both depend on module C -- but in practice need different versions of module C? What if there are competing implementations of the exact same API? The way P6 has addressed repo, module, version, author, and other such issues has been driven by capable P5 hackers (Larry, FROGGS, and lizmat) and it's an emerging strength compared to P5, not a weakness. &gt; The biggest reason I like Perl is that perl is perl, and it just works. No futzing around like there is with Java, Node, Ruby, etc. P5 is great in that way. P6 is still immature. I'm not going to predict here how the story of P5 and P6 reunification will unfold, and the timing of major steps over the next decade, but imo it's all but inevitable.
Not sure if you're perhaps in the same class as me...but I'll PM you what I came up with. 
I wrote (am writing) a photo management application in Perl. It's for my own use, but to me it's a killer app.
I wonder if we could not find a way to optimize for what I think is going to be a common case, where there's only one arg: $self I also wonder if there is some downside here with the 'adding a slurpy makes it faster."? Because I am certain this is something everyone will suddenly start doing since "its faster". I am guessing the upside here to naming the correct number of params will show up with MOP and the ability to properly introspect your code. I can see the value of that for things like code completion tools and interface enforcement. I would imagine that Method::Signatures is just doing some code replacement with Devel::Declare so if you have a simple signature its probably very runtime fast. I wonder how the new native signatures would compare to some of the existing stuff on CPAN that uses the native function API code? I guess the current native code needs to do the count to proper matching. The only way around that I can see is to have a compile time option that validated for a given codebase if all the calls were correct up front (this would only work if the call was introspect able as well). Probably not possible without adding a lot more compile time type checking as well.
Your code works as expected for me. I mean, sure, there are tweaks and improvements that I'd make - but this is a good start and does what you want.
Gosh darn it you are right. I'll re-run the benchmarks.
You're talking up the city, but doesn't your company have any good points? How many employees? How long in business? 
not opening for me either. but metacpan.org is up and seems to be working.
Apparently it's been down for about 6 hours at this point. [Link](http://www.isitdownrightnow.com/cpan.org.html) *Edit:* It's back up.
I thought something was wrong as on the server we're suppose to upload it too gave me a 500 error message when the conversion was set to UNIX and the permissions were set to 755. In the console, it displays the line right and inserts the number one. Am I suppose to just assume it'll work or is there a way to see if it'll say two?
That jive turkey don't fly! I don't know how you can delude yourself into thinking that padre is vi like. It looks like the missing link between emacs and eclipse.
You know what a hassa is? It's a pig. That don't fly straight.
Metacpan has a hosts file hack to auto redirect to metacpan from search.cpan.org. Don't have a link, I'm on the phone, but just google it. 
Oh God I need a Perl job that lets me write C code too. My last role had so much OO code that really stretched the boundaries of OO that it almost put me right off Perl altogether. And no C allowed. Needless to say, I quit. But fortunately for you I'm not in the USA as I charge like a wounded bull.
We're down in Southern Cali, we charge like happy dolphins ;)
Various future optimizations are still on the table for the native signatures. Basically right now, they are compiled to almost exactly the same chain of operations as a manually written equivalent that checks argument counts and assigns copies of @_. So it was very much a case of "lets get it right first while not burning any bridges in terms of leaking implementation details, then get it fast later."
That does look really cool. Probably won't be out until Christmas, though. They have a few other smaller products for the &lt;$100 space, though I don't think any of them are going to be controllable over WiFi. I just bought an Estees X-Proto ($40 off the shelf) and some 2.4GHz transceiver modules off eBay (~$2.50 each). We'll see if I can get that working before YAPC::NA.
Square brackets create an array reference. As there's nothing in the brackets in this case, it's creating and assigning to `$sum` a reference to an empty array. See [`perldoc perlref`](http://perldoc.perl.org/perlref.html) for details. 
Thanks. Makes sense now.
Wow, that's totally hideous. I mean really totally unbearably hideous. It's a nice idea, but what you want to do is show only 2-4 people: the 2-4 most relevant people for whoever is looking at the page. For anons, maybe you pick the most prolific `++`ers, or the most prolific CPAN releasers or something. For logged-in users, maybe you pick people based on the accounts their profile has attached: - github: people you collaborate with, or people who have repos you've starred - pause: people you share co-maint with - twitter: people you follow Right now this is just an unbearable mess. It isn't easily scannable because there are too many people listed, and the thumbs are too small to see clearly. Unfortunately, UX fails are a common anti-pattern in open-source software `:(`
Love libxml, so easy and great for unknown structures.
Also, the way the [icons wrap](http://i.imgur.com/JuFwTN4.png) is not well implemented. The icons take up half the page for Moose on my screen! Edit: Also, the `and X non-PAUSE user(s) ++ed this.` overlaps `Source (raw)`.
Let's rephrase these comments: Oh this is awesome! It is great the MetaCPAN developers have added this feature. Let me add a few suggestions for improvement and personalization: [then here come your points] 
This is what we need.
Wow! This is really great. The mouse-over thing, the ability to rotate the whole thing. It's neat. The only thing that's needed there is a close button (because interface :), and the ability to resize the whole layer. For example deps on [Chart::Clicker](https://metacpan.org/pod/Chart::Clicker) are huge, so there's no reason for window to be so small. Also, I haven't checked the source code, but could this be used outside metacpan? For personal projects for example, etc.. Edit: I just noticed [full-screen version](https://widgets.stratopan.com/wheel?q=Chart-Clicker-2.88&amp;fs=1) so the resize thing is out..
I'm as far as I can go (1280 x 800). Probably doesn't help that my laptop has a 13" display.
Woohoo this is great!
Very interesting - thanks for sharing.
Instead of shifting, why not iterate over the original array with a foreach loop?
Sounds like you might want some form of lazy evaluation. Perhaps with a sub that returns a subref that returns your data. Something like this: while( my $data_sub = build_next_data_sub() ) { while( my $result = $data_sub-&gt;() ) { # Do something with $result } } So `build_next_data_sub()` would get the next batch of results, and then lets you iterate through them using the sub it returns. That's one approach, anyway. I'm not sure how much help we can be without seeing the larger context, though.
[The Perl Foundation](http://www.perlfoundation.org/) is probably the best place for donations though I don't know if they accept bitcoins. [Gittip](https://www.gittip.com/for/perl/) is an option for donating to individual developers.
The best way to support is to help others, and share code. At least that's my theory.
&gt; polite, and patient. Ahh, I see you haven't been hanging out with us for long. ;) All jokes aside, it's always nice to see conversation in the perl channels, and it always makes me happy to see shadowpaste relay some code for me to take a look at!
I'm still not clear of what you're doing. It sounds like you keep all the data but just shift it back and forth between these arrays in different orders? If that is the case, you could instead use references to the data itself and create temp arrays holding the references in the order you need. It would save a lot on resources with all the shifting and array manipulation you're doing. Or if I'm totally not getting what you're trying to do just ignore my answer. =)
These [circle graphs](https://widgets.stratopan.com/wheel?q=Catalyst-Runtime-5.90064&amp;runtime=1&amp;fs=1) aren't that informative. Graphviz does a better job showing who is to blame for dependency hell.
Seconded. Although the size of the circle can give a quick clue on how large the size of the dependency tree is.
Cool! I'd add a tooltip for mouseovering, instead of having to look at the URL in the status bar.
Glad to have you in Perl, and its awesome you've chosen Catalyst! You might have already seen this, but the yearly December Advent Calendars (http://www.catalystframework.org/calendar/) is a resource worth glancing through. jnap
Been doing perl for 14 years now (sigh I feel old) and I find irc to be a wild card. Sometimes u strike a guru or helpful coder and others can be outright hostile. Glad u got a good experience and dont let the odd troll (if u even strike on) put u off.
Yes, the close button is needed. I submitted a [pull request](https://github.com/CPAN-API/metacpan-web/pull/1177) for "Exit on ESC button" though. Edit: [Close button also added](https://github.com/CPAN-API/metacpan-web/pull/1182). 
Show me an example or tell me questions that you want the graph to answer. I'll see what I can do.
Would a tree view like [this](http://bl.ocks.org/mbostock/1062288) be more helpful?
Its no wild card if you know how to ask questions and how to work with the answers, if you dont like an answer, then its not hostile ;).
Which IRC channel did you join? I went to the freenode one and encountered a few very hostile people, and it turned me off the channel entirely.
It's not a bad piece, but there are times when just using the standard tools makes more sense. (e.g. monit, daemontools, etc.)
the official channels are on [irc.perl.org](http://www.irc.perl.org/)
IRC: * Has [constantly growing traffic, at least on freenode](http://freenode.net/history.shtml). * Has a "culture" per channel; eg some tech channels are routinely friendly towards newbies that clearly haven't done much research prior to speaking up, others routinely unfriendly; * Has activity cycles per channel that reflect the habits and worldwide spread of that channel's participants. For many channels it's easy to visit when almost no one is active on it, in which case your experience might be total disappointment because no one responds to you or rapture because someone nice happens to focus a lot of friendly energy on whatever you just said; **Edit** Removed the thing I imagine caused me to get negative votes for this comment. Let's see what happens. **Edit 2** Votes went up... then down again. Removed a bunch more things. Prolly no one reading this now but whatevs...
Ah, thanks. I think this is a good approach. Shows the intent well while still being able to bury the logic where it doesn't get in the way of actually processing the results.
Also the powers that be behind irc.perl.org are interested in making sure it stays/becomes as friendly as possible.
I and the people I have spoken to about it are well compensated, but as you probably know, cost of living as well as wages are really spiraling up here in the bay area, and these positions are on-site only.
Some dick in here does not like differing opinions. Irc is awesome or u asked wrong.
I love how the author talks about what a "good" system administrator should be without ever mentioning not reinventing the wheel with home-rolled Perl process monitoring. 
As a (mostly) back-end agnostic front end developer, I see almost no jobs come up on my radar with a Perl backend. I can recall maybe 3 in the past 13 years. Possibly irrelevant: I accepted one of them in the past and just accepted another.
The question is "how many modules are required only because of module X?"
Just using regex against the process labels is fragile, and will result in false positives (think 'ps ax | grep some-daemon-keyword', zombie processes, etc). You should use other methods of determining whether a service is active, e.g. checking PID file's existence and content, checking whether service is listening on a TCP port, actually sending requests to check whether service is responding, and so on. 
Very cool. It would be very useful for de obfuscation
If you read the other OP's question, the group he will be working with is already using perl. It would be harmful for him to learn python in lieu of perl. If he moves to another group that uses python in the future, he can learn it then.
A hard road ... but we're lucky we have someone like Stevan to persevere delivering it.
Mebbe true on all counts. Looks like I've fixed the "wrong" aspect of my comment because it's gone from -2 to +1. :)
If you want to start learning how to use Perl to test external programs, start with learning to use Perl to test Perl bits. The Test::More module is a good place to start. Once you understand that, look at all of the other Test::* modules on CPAN to see if one of those modules does the sort of thing you need to do. Also see: [C++ unit testing using a scripting language](http://stackoverflow.com/questions/5354427/c-unit-testing-using-a-scripting-language)
In this case, I think the size of the node would represent the number of dependent CPAN distributions (recursively). The length of the connector would not have any meaning.
What a classic, unexperienced "programmers" shitting on perl and promoting python. Another case of "your question is wrong!".
The OP didn't ask for recommendations. He/she requested resources. This redirection is an extremely frustrating tendency to come up against when asking for advice online. 
Thanks I will...
[exercism.io](http://exercism.io/) has Perl programming exercises which can teach you about Perl and testing
if you want to write perl modules with unit tests you may have a look at h2xs. the program h2xs builds a Perl extension from C header files. But let us ignore that Instead let us use h2xs to build a module skeleton. This skeleton creates a makefile for your environment, provides a "fill in the blanks" module and a test module. So lets start: we don't need the glue code and don't need c code so we will call h2xs with parameters that create only perl code. Lets create a module named Foo::Bar $&gt;h2xs -X -A Foo::Bar Defaulting to backwards compatibility with perl 5.18.1 If you intend this module to be compatible with earlier perl versions, please specify a minimum perl version with the -b option. Writing Foo-Bar/lib/Foo/Bar.pm Writing Foo-Bar/Makefile.PL Writing Foo-Bar/README Writing Foo-Bar/t/Foo-Bar.t Writing Foo-Bar/Changes Writing Foo-Bar/MANIFEST Lets have a look into the directory Foo-Bar * Foo-Bar/lib/Foo/Bar.pm contains a module skeleton with lots of useful defaults. If you are a beginner many things will be a little disturbing here. but if you try to understand them it will really help you to write good perl modules. * Foo-Bar/t/Foo-Bar.t Tests go here. man Test::More for help. * how to use it. first we want to create a makefile. $&gt; cd Foo-Bar perl Makefile.PL Now you have a makefile make generates a manpage make test executes the tests in Foo-Bar/t/Foo-Bar.t make dist packs the stuff into a tar.gz make install installs the package for more information type make help I know it's quite a bit information for a beginner. But I think it's worth trying it. 
Reddit kind of is Python territory. Python is what Reddit is written in. I still can't believe how threatened the Python enthusiasts seemed to be.
1) I really like, this is awesome 2) How do I change the highlight color that it uses? 3) Since the syntax is so close would you consider making it work for PHP also?
That was an enjoyable and thought provoking read. My favorite part was actually the comments. It was great to hear from a variety of people about how they code and why. 
If you read TFA, the variable highlighting for Perl *is* based on the one for PHP. 
Be honest and also explain that you made a post where you admitted to having merely passing knowledge of perl, yet felt the need to espouse your opinions as facts and as a result got your post downvoted to hell.
"oh but Perl is dying" /s Very happy with this as this is my exact skillset. Also the rise of DevOps is a plus. Now to update my LinkdIn profile.
Mine too!
Historical note: the original reddit was launched in about June of 2005 as one of the original [Y Combinator](http://ycombinator.com/) projects. It was written in Lisp. It was rewritten in Python in about December of that year, as described in this this blog: [rewriting reddit](http://www.aaronsw.com/weblog/rewritingreddit). 
What scenario are you envisioning for someone to use this over letting Apache or nginx handle the virtual hosting? I guess a test environment, possibly. 
True, but I have a patch from someone to help with different *inflexions* of variables. Since [Paul Johnson is now maintaining this](https://github.com/pjcj/vim-hl-var/blob/master/plugin/hl-var.vim), I'll drop him a line and try to get this sorted. After all, this was just a quick hack.
A test environment would be one possible scenario. Also, if you're limited with memory you might not want to run each app as a separate Catalyst instance, and it might be easier to just maintain one Catalyst instance and not have a different port open for each app. Here are a couple people on perl monks who desired this feature: http://www.perlmonks.org/?node_id=964958 http://www.perlmonks.org/?node_id=954591 Is your concern that it would be bad for performance to use instead of Apache or nginx, or do you just think it would be bad practice to let a Plack App handle the virtual hosting?
My concern is mostly with putting a PSGI server directly on the internet like that. I'm also a big fan of not reinventing the wheel. I've just always put mine behind an Apache mod_proxy -- it made it easy to load up 3 or 4 apps when needed, allowed me to keep different apps completely separate even if they were on the same server, and let me put everything behind Apache for things like HTTPS handling and access_logs being handled in a standardized way.
What do you mean by putting a PSGI server directly on the internet? Do you mean directly on port 80 and letting it take requests? The way that I have my setup is I'm actually still using nginx on port 80 to handle things like access logs and serve out static content, but if it's not static then I pass it to my Plack App running on port xxx and let that determine which app specifically the request needs.
and back down :(
The coolest cat by a long shot!
s/cat/hat/;
[Slides of tadzik's PLPW talk "Steroids"](http://feather.perl6.nl/~tjs/talks/plpw14) which summarizes it as a "game development framework modelled after phaser.js (sort of), SDL2 under the hood"
 Usage: mteval-v13a.pl -r &lt;ref_file&gt; -s &lt;src_file&gt; -t &lt;tst_file&gt; Description: This Perl script evaluates MT system performance. Required arguments: -r &lt;ref_file&gt; is a file containing the reference translations for the documents to be evaluated. -s &lt;src_file&gt; is a file containing the source documents for which translations are to be evaluated -t &lt;tst_file&gt; is a file containing the translations to be evaluated So you would run it on the command line like so: perl mteval-v13a.pl -r ref.txt -s src.txt -t test.txt To get the full help output run: perl mteval-v13a.pl -h If you try to execute multi-blue.pl with no arguments it will print out its usage: $ perl multi-bleu.pl usage: multi-bleu.pl reference &lt; hypothesis Reads the references from reference or reference0, reference1, ... 
Thanks a lot! However I'm a complete layman when it comes to programming\scripts etc, it's my first encounter with that stuff. Trying to run perl mteval-v13a.pl -h I get this error: &gt; Can't locate XML/Twig.pm in @INC (@INC contains: C:/Strawberry/perl/site/lib C: Strawberry/perl/vendor/lib C:/Strawberry/perl/lib .) at c:\m\mteval-v13a.pl lin 7. BEGIN failed--compilation aborted at c:\m\mteval-v13a.pl line 7. Edit: I also have no idea how to format the txt files, in the example there are large blocks of text, I just need single sentences, optimally with multiple reference and candidate versions. Moreover, can I run the commands in Padre editor? Seems more efficient as you can just ctrl+c ctrl+v them there.
In Padre do Tools =&gt; Module Tools =&gt; "Install CPAN modules" then install XML::Twig. Repeat for whatever modules you get similar errors for.
Edit: never mind, managed to run the full command and got evaluation based on example files. Now only figuring out how to make it work for my own sets of single sentences is left. Thanks a lot!
For a computer applications class in my high school, an assignment required of us to mail a letter to a celebrity of our choice to practice writing formal letters or something. I chose Larry Wall and wrote him a short letter, nothing special, I just professed my undying love for him :-)
Signed up... there was only three others doing Perl5 :S They also instantaneously muted their code after I commented which was the first and assumedly only comment. No reciprocation so far. So not sure this is /that/ worthwhile. The command line interface is fairly clunky too. You could easily just do all of this through a Gist with friends. Pretty much any Perl6 Gist I have ever written gets comments from #perl6 on style and idiom. Putting up a Gist on this sub reddit is almost certainly a more effective way of getting nitpickers too :D Plus there is no facility to nitpick the exercises themselves! I'd nitpick on the parameter ordering of the accumulate() exercise itself being the wrong way around.
I think orthogonal is pretty strong. They're both, powerful, high level languages with strong text processing features. On the skills front, Perl is increasingly being seen as dated by the business community, and Python is gaining traction. I imagine it's a way they hope to future-proof their hires
I wonder if it's a subtle form of ageism.
&gt; I wonder if it's a subtle form of ageism. I think that is way too strong a statement. Perl has been around a long time, and there are a lot of competitors in that space. I wouldn't hire somebody who knew only Perl and had no interest in learning anything else. There seems to me to be more active, interesting things going on in Python today than in Perl. It wasn't ageism that killed COBOL, it was just age.
&gt; I see lots of stories about how the best part was the hallway, and talking to all the people, and the amazing things you’ll talk about and the connections you’ll make. If I were the kind of person who actually talked to people like that, maybe it would be. Maybe it even will, if I don’t go hide instead. I don't consider myself an outgoing person, either, but I easily find people to talk to at YAPC. It's a very friendly group, and yes, Hallway++ is often the best part of the conference. That said, the lack of updates and sponsors with a month to go is concerning. I realize that real life gets in the way sometimes, but this is a conference where 400-500 people show up, and costs go into the tens of thousands of dollars. It's important!
* perl and python live on similar environments and solve similar problems...you are likely to see both * there aren't a lot of "pure" perl jobs...people mostly use perl to help with their real job, which makes the choice of language somewhat arbitrary * python and perl both get embedded into other apps, so if you job is to support those kinds of apps, you take what you get
If you are on the fence about coming to YAPC::NA I started adding [details](http://www.yapcna.org/yn2014/wiki?node=Hackathons) for the Hardware Hackathon. I hope it gets you to attend. 
&gt; I wouldn't hire somebody who knew only Perl and had no interest in learning anything else. Would you also say "you wouldn't hire somebody who knew only Python and had no interest in learning anything else"? &gt; It wasn't ageism that killed COBOL, it was just age. Your answer seems to imply that age, per se, is a weakness, not a strength, for a programming language. Will age eventually kill Lisp? After all, it's over 50 years old. Python? After all, it's almost as old as Perl.
Perl6 will probably kill perl before any perceived advantage of python, or the age of perl5.
It should also be noted that Schwern [isn't someone we can feel safe citing on this issue anymore](https://adainitiative.org/2013/09/the-ada-initiative-does-not-support-michael-schwerns-ally-work/). And I say that as someone who gave his 2012 keynote a standing-O. He still said some important things, but the community needs a different champion on this subject.
Hi parfittaRole, Your OP title says "most" Perl jobs "require" Python as well. Presumably that's just very sloppy language -- you don't actually mean what the words literally mean, right? I'm curious about things such as what job listings you (or anyone else) are looking at, how best to measure "Perl jobs that require Python", and what numbers you found.
I do think there hasn't been much said about the conference but there are things in the works and it is shaping up to be one of the more entertaining YAPC's there has been. Real life has caught up to the organizers pretty hard over the past few months and following the blitz of information that set the bar at Madison it's been overwhelming to try to get anything out. Talks are coming in and the guy who's organizing times is getting that together soon. The hotel is situated pretty nicely downtown so there won't be to much outside walking if you don't want there to be. The hallway talks should be great and the emphasis on this year is more about community than it is severely technical things as I've noticed. If you really have any questions about anything PM me here or email the YAPC staff they usually get back to people pretty easily. Full disclosure I'm one of the leaders of Orlando.pm who's helping organize this thing. I do not however have all the facts but I can get you to who does. I hope you all come out. I hope to meet you all there. 
I feel slightly obligated to point out that I wrote a Standards of Conduct for 2011 at the request of the commuity. That Standard of Conduct is remarkably similar to the one we have now for YAPC::NA. We had an incident reported in 2011, it was dealt with to the satisfaction of everyone concerned. The fact that you never heard about it is because the system, although not perfect, worked. I was a participant in the precipitating events that caused the issues Schwern complained about, and had I then had the powers responsiblities that I have now results would have been different. (I am now an IRC Operator on irc.perl.org, I was not then. I am also being specifically tasked to lead up the community team that is responsible for dealing with these incidents.) I firmly believe that *everyone* should feel welcomed and invited to any aspect fo the community I particpate in. I work to the best of my ability to ensure that is true.
I think the Perl ones mirror the other languages though so you'd want to change all of them :S
The charges are directly applicable to exactly the things Schwern was talking about, so it's not a run-of-the-mill ad hominem. There are other people we can cite on this matter, though perhaps none quite as visible within the Perl community.
Ruby is closer in spirit to scheme than it is perl, I think. Ruby is on the surface, similar to perl, meaning syntatically, but there is a lot of difference between the two 
Just some advice: I used to dislike Python too, but when I was hired for a Python job in an image/video processing consultancy firm, I found that it was in general a sensible language, that I can be productive in it, and that I could tolerate it, and even like it a bit. I wrote some good code there. While I still prefer Perl, I realise that “Reality to be conquered, must be obeyed” and I cannot get exactly what I want every time. Also see what I wrote about [“The Stoic Road to Peace of Mind”](http://unarmed.shlomifish.org/1747.html). A summary is that you can say to yourself that “This situation is not ideal, but hopefully I can cope with it and tolerate it, and don't forcibly try to hate it, and then maybe I can even like it”, and then you would likely lead a happier life.
I agree, no reason to complain about such a thing when there are far worse things a company can do, like make you work weekends or evenings, or put you on 24/7 SMS on-call, or not provide free food at lunch. (I'm not so serious about the last one, but it's definitely something I'll miss when I change jobs...)
Good comment, I agree. Also see the [“Why Chrunch Mode Doesn’t Work”](http://developers-beta.slashdot.org/story/05/06/08/1646234/why-crunch-mode-doesnt-work) in reference to the [EA_spouse blog post](https://en.wikipedia.org/wiki/EA_Spouse) . Right now, I've been trying to get rid of a sort-of-phobia I've had from writing PHP code, so I can work at jobs that involve that. While I think PHP is a very bad language, many companies use that, and it can pay well and/or allow you to contribute to the common good. Many software developers can be quite-a-bit opinionated and picky, and that's not good. I also wrote an essay titled [“Your programming language must suck.”](http://shlomif-tech.livejournal.com/57811.html) That put aside, a young programmer I met on Freenode, who had to learn and use Perl for a job he found at his university, initially reported some problems with Perl, which I wasn't fully aware of at the time, and didn't find show-stoppers. I agreed they were real problems. However, after a while he testified that he has grown to like Perl and found it useful and powerful, and that he was productive in. So it can work for Perl as well.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**EA Spouse**](https://en.wikipedia.org/wiki/EA%20Spouse): [](#sfw) --- &gt; &gt;__Erin Hoffman__ is an American game developer, blogger and fantasy writer. &gt; --- ^Interesting: [^Erin ^Hoffman](https://en.wikipedia.org/wiki/Erin_Hoffman) ^| [^Electronic ^Arts](https://en.wikipedia.org/wiki/Electronic_Arts) ^| [^Criticism ^of ^Electronic ^Arts](https://en.wikipedia.org/wiki/Criticism_of_Electronic_Arts) ^| [^Video ^game ^developer](https://en.wikipedia.org/wiki/Video_game_developer) ^| [^Team ^Bondi](https://en.wikipedia.org/wiki/Team_Bondi) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chmvfp9) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chmvfp9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Perl 6 has been in development for 14 years, and there's nothing even close to a complete implementation with practical performance yet :/
What problems did he report? I'm sure anyone who's used the language for a while can think of several :P I work in a Perl shop and a lot of programmers start off disliking the language, and many continue to, but a large number eventually grow to like it and use it in personal projects. (Stockholm syndrome?) I think PHP is a good comparison because just like Perl, it has some innate flaws, and it's easy to write bad code if you don't follow best practices. I enjoyed your essay and I think that's why Perl is so polarising. It fits my brain perfectly, I memorised the special variables and the gotchas easily, and I can kind of ignore the ugliness. But those same properties are an absolute no-go for other people it seems. Either way a job's a job. For my job I've had to write Visual Basic for Excel and maintain C++ code too :P
&gt; there aren't a lot of "pure" perl jobs...people mostly use perl to help with their real job, which makes the choice of language somewhat arbitrary &gt; I hear this often - I always feel like I'm lucky for being in a pure perl job.
Thanks for your comment. I believe you are right. I cannot remember what he said, but I may be able to dig it in my Instant Messaging client logs. I don't think it matters too much, though. I'm glad you enjoyed my essay. Thanks for telling from your experience. At my various workplaces, I wrote in C, C++, C/C++ (C++ with many Cish paradigms) , MS DOS Batch, Access Basic, Word Basic, Visual Basic for Apps (Excel Basic), Perl (naturally), Python, Bash/sh, csh, PHP, Python, Java, JavaScript, and maybe some other stuff. And I worked with more languages in the open source world and for experimentation and enlightenment. Anyway, some people (including me) like to say “There is more than one way to do it. One of them is to use Python.”. One shouldn't succumb too much to tribalism and territoriality. 
If someone said the Rakudo P6 compiler was already complete in the ways they care about, what missing stuff would you be most incredulous about? And the same for practical performance? (If someone said Rakudo P6 on MoarVM already had practical performance for their needs, what performance aspects would you be most incredulous about?)
I upvoted because I assumed (from Larry's original plan for P6) that the written spec would be the official representation of the language. Having the regression tests serve as spec makes a lot more sense to me.
You're right, I'm selling Perl 6 a bit short. MoarVM is a massive improvement and very exciting. Still, I don't want to get anyone's hopes up because there's still a long road ahead. First Rakudo Star release with MoarVM was two months ago and plenty of stuff is still experimental (like threads, and the JIT). I'd also personally appreciate Unicode support at the same level as Perl 5 at least. Even after all that stabilises they'll be a ton of bug fixing, optimising and testing to do, right?
Because the legacy stuff they have to maintain is written in perl but the new stuff is written in python?
Perl6 isn't Perl. Calling it Perl6 was a bad move, and made things confusing for the laymans, but Larry isn't going to budge on that one.
&gt; I wouldn't hire somebody who knew only Perl and had no interest in learning anything else. That depends on what kind of shop you are. You can either get my 15 years of Perl experience, or a few months of C#, or VB experience that has atrophied for at least a decade. People don't hire C++ programmers to code in Java. You shouldn't hire Perl programmers to code in some other language.
I don't think there's any place here for repeating unsubstantiated allegations, and it only serves to undermine the original point that it's important to care about diversity.
I'm not a fan of python. I tend to agree with you on the reasons why. It kind of reminds me of COBOL without the uppercase. I think the thing I love most about perl is it's regex as an operation thing. I guess that's a gimmicky feature, but I came from ancient C where parsing text was tedious and dangerous. Perl was a welcome relief for me. That said, there have been many times when people just won't give me a perl or REST API. Instead they hand me python things. Sometimes even perl wouldn't have helped because I'm interfacing it with a webpage coded in PHP. I usually will write python glue that outputs JSON which everything else can handle. You're best bet is to ask them what they're up to in the interview. If it's a 90% python job with a bit of perl then maybe it's not up your alley. If it's 90% perl with a little python, or whatever then that may be what you want. It also may depend on what they're doing with the language. Maybe it won't be your favorite language but if the project sounds cool you might be excited enough to take it on those merits. 
Because they're written by recruiters and/or HR.
Have you tried $ARGV[0] =~ s/[^\d]//g; print $ARGV[0]; That should replace any non-digits in the argument with nothing and print what's left. (Then again I haven't had my morning tea yet so that could be the combination on my luggage for all I know.)
 #!/usr/bin/perl -w use strict; # if we accedently misstyped @ARGV to @ARGS (or any other variable), give us an error, instead of creating that variable on the fly use warnings; # instead of using the -w switch, i.e: #!/usr/bin/perl -w my $digits = ''; for my $argument (@ARGS) { # loop through all the passed arguments $argument =~ s/[^\d]//g; # deleting all non-digits $digits .= $argument; } print "$digits\n" if $digits; 
To put some context to this: a colleague learning Perl just searched how to read line-by-line rather than ask me and found this.
I think you should laugh hard. Just for comparison, is there anything similar in the python community?
There's also the fainting __END__ off screen which makes you worry about the unlink $HOME; :)
Nope mostly just helpful comments in the equivalent posts: http://stackoverflow.com/questions/3277503/python-read-file-line-by-line-into-array http://stackoverflow.com/questions/8009882/how-to-read-large-file-line-by-line-in-python Though the latter link has some oddball posts that aren't helpful. But they aren't pure trolling.
h2xs is very outdated. Current best practice is to either use Module::Starter (that I wrote and no longer maintain), which was the successor to h2xs, or Dist::Zilla, which is the successor to Module::Starter.
This has been answered well, but I'll just add a one liner: print $a if $a = join('', @ARGV) and $a =~ s/\D//g;
If you're doing one liners, golf it down a bit :) s/\D//g,print for@ARGV
Wait, that's no ordinary troll. It's Tom Christiansen. :(
 tr/0-9//cd foreach @ARGV; print @ARGV; 
Beautiful.
Good grief they have formatted Perl like Cobol. Yes I do get shat on sometimes because I don't know absolutely everything about Perl. Yes, I'm not perfect. 
Hah. I've heard the Python community are a little snooty / aloof, and the Ruby community were a little in love with their own brilliance *cough*. It's good to know we are, at our very core, assholes. 
You can use \\ to escape the underbars like this \\\_\\\_END\\\_\\\_ to get \_\_END\_\_.
The utf8 pragama lets you use UTF-8 characters in your source code. the q// quote-like operator can use most characters as delimiters and in this case, it is using ╬. Running the whole program through B::Deparse gives us use utf8; sub BEGIN { require 5.10.1; } use autodie; BEGIN {${^WARNING_BITS} = "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\003"} use strict; no feature; use feature ':5.10'; BEGIN { $^H{'autodie'} = 'Fatal :lexical'; $^H{'guard Fatal'} = 'ARRAY(0x9054fdc)'; } &amp;binmode('STDOUT', ':utf8'); sub END { &amp;close('STDOUT'); } our $FOLIO = ' SnPmaster.txt '; &amp;open('FOLIO'); sub END { &amp;close('FOLIO'); } &amp;binmode('FOLIO', " :crlf\n :encoding(CP-1252) "); while (defined($_ = &lt;FOLIO&gt;)) { print $_; } continue { exit unless $. ^ 13 ^ '15'; } __DATA__ unlink $FOLIO ; unlink ~$HOME || clri ~$HOME ; reboot ; which cleans it up a little. There are still some oddities like the one argument version of `open` and the use of the bitwise xors and the `exit` to escape out of the loop (and the whole program). The single argument version of `open` looks for a package variable whose name is the same as the file handle and uses the contents of that variable for the file name. The line \_\_LINE\_\_ is one is 15, so it is replaced with the value "15". The number 015 is octal for 13. The reason he chose 13 and 15 is that their bit patterns are 1101 and 1111 respectively. Xoring with these two bit patterns flips the value of the second bit ensuring that when the current line number ($.) is 2 it will become 0 and the program will exit. I have no idea why he chose to use the Windows-1252 codepage for the encoding.
http://hop.perl.plover.com/
To put some more context to it, tomc is a Perl OG, hailing from a time when you could assume that people asking for help were capable of independent thought and had senses of humor.
 my $digits = join '', map { /(\d+)/ } @ARGV; print "$digits\n";
&gt; chomp(@owners = &lt;FILE&gt;); Thank you. This works very well. I thought that's what was happening, but I didn't know how to read it all in at once. I bought you gold because this was bothering me all day and you solved it on the first reply. Thanks again.
Yup. All due respect to Tom but I'm not sure Stack Overflow is an appropriate place for that sort of humor. 
This is great, thanks for sharing EDIT: I was so inspired I [ported](https://github.com/sillymoose/xperl6) 4 exercism programming exercises.
What's the deal with the `__DATA__` section?
Have to say though, that the top comments on SO were helpful for the OP and instructive. Then there were the slightly more obscure, yet none-the-less instructive as in the one-liner &lt;perl -MO=Deparse -pe'exit if $.&gt;2'&gt;. And then the absurd, but technically true answers that will confound even some perl mavens. TC = Loki?
One thing you might want to do is find an abandoned perl module that does something you enjoy and adopt it. If you can't adopt a project because it's still maintained, then lots of times there will be test coverage missing, or unhandled bugs in the ticket logs on CPAN. Fork it on github and start patching things. That gets your name in public so people know what your skills are like, and it lets you interact with the community. Join PAUSE so you can publish to CPAN and use RT there. The patches I submitted to people were always tiny until I took over a module. Github (or just modern version control) makes a bunch of this easier, but it used to be a huge pain to contribute code because of having to ship patches around and worry about integrating them when the main branch had moved while you worked. It sounds like since you've written some Mojolicious stuff you've been exposed to Moose based perl code. You might try converting modules to or from Moose where needed. I think reading and writing tests is very important and overlooked in most cases. It's a chore nobody wants, but if you setup the base for it you can end up in an environment where the test is written first and the code is written to fulfill the test. Bugs that come up are generally something that nobody thought to test, so writing a test that shows the failure allows you to continue to test it for years to come. Meaning if someone removes the fix because they don't understand it, the test fails again and hopefully the clue has been documented in detail somewhere. Finally, it might be important to study why you failed the interviews. Were they test based? If so, the companies were probably writing hard interviews that were too specific to their requirements (asking someone to design a rocket engine on a whiteboard.. you get no notes). In some cases maybe the tests were fair and you weren't up to the challenge, but in that case you hopefully realize from the direction of questions where you might want to focus. In general, if a test is asking about weird/obscure language idioms, how to do something algorithmic that isn't often used and is easily looked up, but not in an interview setting, or giving examples that are written around a hack feature, then the interview wasn't designed to test the candidate, but to show how smart their senior developer thinks he is. You can't win in those cases, you can just try to be the best of the failures. You might seriously ask yourself if you want the job once you've figured this out though. If you failed on a general technical one-on-one setting or something like it, usually one of the developers interviewing you will give a business card. Write them a polite email saying you are very interested in the work they're doing but you know you're skills weren't where they need to be for their requirements. Ask them about some things you might focus on to train for that type of position and if they might consider you if another spot opens up. Also, if you have insights after the interview, like say they're designing a talking Doll and they describe the general framework of their design. Maybe something they say inspired a thought after the interview. You can always ask followup questions or explore other directions afterwords. Writing to them and saying "hey, does the doll deal with failure when a child pees on it?" might be something they hadn't considered and your insights make you a better candidate (don't overdo this though, you don't want to annoy them)
I do not envy the task of porting the HTTP::* stuff. Good luck!!! I spent a good chunk of this week staring at this craziness: https://metacpan.org/source/GAAS/HTTP-Message-6.06/lib/HTTP/Request/Common.pm#L125
Sorry, somehow I missed you reply (I blame the iOS reddit client!). http://yapcna.tumblr.com/post/84910428739/its-time-to-choose-the-train 
There's a `__END__` way off to the right of the original code. It keeps the program from executing what appears to be "delete my file, my home directory, and reboot"
Very cool. A benchmark comparison at the end would be nice. I think a big thing making people reluctant about perl 6 has been finding rakudo slower than molasses.
Well independent thought of asking for help given you have some code and you are working in isolation isn't awful. Stack Overflow would have no value for helping yourself if others hadn't asked for help. Due to Google its also the first ranked piece of self research anyone capable of independent thought will find. Its only funny if you already know perl and its history. Someone completely new might imagine that's what perl can and does look like. Just because the author is someone idolised doesn't make it any better. My aim was certainly not to call out an individual. I personally had no idea who TomC was until it was pointed out. Im not sure its important this stuff is so common amongst people who know perl pointing a finger would involve a lot of hands.
Aye, we're working on the speed issues and MoarVM is proving to be very valuable in this regard. Sadly, we're missing a good profiling tool for MoarVM, so at the moment we're relying on C level profiling information to guide our optimization efforts. Rakudo has been developed with the "make it work" mentality for a very big portion of its life. Now we're looking at all the "slow paths" that have been put in to make the semantics right and put in fast paths and general optimizations to make sure unused semantics don't make execution suffer the costs. Finally, we're sadly not equipped with a very good benchmark suite; our benchmarks are quite "microbenchmark"-heavy. Therefor putting out benchmarks of perl5 vs Rakudo (and NQP) regularly has only very minimal value :(
http://neilb.org/adoption/
What Benabik said. It is just there to scare the reader. I had to look up clri though. It writes zeros on the inode handed to it (if you weren't aware, files are really pointed to by inodes, names are just for us humans). The manual says &gt; The primary purpose of this routine is to remove a file that for some reason appears in no directory. 
So what happens if the file exists and you write zeros to the inode. (I had to lookup `clri` too) And this is exactly why I love these things, I originally missed the __END__ and ended up learning a bit. (Also the original troll post was interesting to read through and learn about an interesting way to exit with xors... hehe) Thanks for the reply!
I prefer perl -le 'print"@ARGV"=~/(\d)/g' plal1 pdse2d 30eeee and 5 It is one character shorter and allows us to use the -l option to get a newline on the end. Yours would put newlines in the middle of the numbers. However, both of our solutions are wrong as they use `\d`. It matches more than just `[0-9]`. For instance, it will match ٠ (U+0660 ARABIC-INDIC DIGIT ZERO): perl -CA -le 'print"@ARGV"=~/\d/?t:f' ٠ 
Think about it in terms of conditions. If some condition, do this. Else, do that.
From the man page I found: &gt; If it is used to zap an inode that does appear in a directory, care should be taken to track down the entry and remove it. Otherwise, when the inode is reallocated to some new file, the old entry will still point to that file. At that point, removing the old entry will destroy the new file. The new entry will again point to an unallocated inode, so the whole cycle is likely to be repeated again and again. 
Well, I got that part yes. Its just hard knowing the order, and what exactly I do if/else for...
One could argue that your unicode example is a digit and thus valid :P That or use /\d/a, so \d only takes ascii digits. But nice solution, you win.
Have the script output every form. So the URL never changes. Then detect what (if anything) has been submitted. If nothing has been submitted, show the first form with the checkboxes. Else, if any value from the first form has been submitted, show the second form. To store the previously submitted values, use HTML hidden fields like this: &lt;input type="hidden" name="customer" value="StarRice"&gt; P.S. Of course in real life, you can't be this trusting!
So? Bad answers are downvoted, the crappiest answers are at the bottom. Stack Overflow works.
The problem with `/\d/a` is that it only works in Perl 5.14+.
Wow, that's terrible.
Thank you for the lengthy reply I'll start with an adoption of a module I frequently use, I hope it is available for adoption or for making it pass the tests Thanks again 
Thanks for the list. I've already found something that I use and see if I can take it over. By the way, is there someone that can look over my code and provide a review (better implementation or optimisations)? Thank you
Yes, I have it downloaded for some time now. I'd better start working on it. Thanks
I don't understand what this means: return not $logger-&gt;warn("Bad stuff") You might be trying to cram too much into a single line, for my eyes. Check out the book Perl Best Practices.
Personally, I'm not a fan of starting with 'unless', it's just slower to read for me. If it's something short, I'll put it at the end, otherwise I'd use an if. However, in this case you perhaps could do: "good" ne $stuff and return not $logger-&gt;warn("Bad stuff"); (I haven't tested it, but I think it'll do the same thing.) However, for anything more complex than this, I'll do the full if (something) { ... } thing, as later I'll probably have to put debug code in or modify it to do something in addition, and that's easier with a proper if. One thing I find good to learn in Perl is the functional operators, like map and grep and such. They can allow you to have some nice simple code (once you've learnt to read it), e.g: grep { $_-&gt;{field} } map { { field =&gt; $index_field_convert{$_}, } } @indexes; which is processing a list with the map, and checking the results with a grep to throw any away that didn't convert.
Well it performs the log which returns a truth itself, so not $logger-&gt;warn("...") Does the log and evaluates as false, strictly tying writing the log to returning a false in the parent subroutine.
I've been bested! That a gorgeous line you got there. I'll remember that; there are many single Boolean checks in my subroutine and they all need custom logs, so I figured this would be best (it's just so... pretty) But as I say, I'm teh noob! 
Wouldn't this: return not $logger-&gt;warn('Bad stuff') if $stuff ne 'good'; Accomplish the intended oneliner? Not sure on the precedence now that I think about it actually.
Thanks! Sorry that should actually be $stuff-&gt;content #Always true # Should be $json-&gt;decode( $stuff-&gt;content ) #Sometimes false
Your second example isn't valid -- you can't begin a statement with `unless` like that without using parentheses. There are two versions of each of these: [statement modifiers](http://perldoc.perl.org/perlsyn.html#Statement-Modifiers) which modify a preceding statement, and [compound statements](http://perldoc.perl.org/perlsyn.html#Compound-Statements) which are themselves statements. The latter always require parentheses around the condition, whereas it's optional with the former. I find both versions relatively abhorrent. This `not $logger` stuff is just the pits. Is the goal to return a false-like value? Then just use `return;`. It returns `undef` in scalar context and an empty list in list context, both of which evaluate to false. if("good" ne $stuff) { $logger-&gt;warn("Bad stuff"); return; } if(!$source-&gt;content) { $logger-&gt;warn("Worse stuff"); return; } return $source-&gt;content; Don't try to get too pithy with one-liners for everything. It will eventually bite you in the ass when you have to come back to read the code. I can look at the above and instantly know what it does without having to go look up what `$logger-&gt;warn(...)` returns, for example. 
Fair enough! It does stretch quite the width of the editor as a single liner, which I've learned is universally considered annoying.
Yes. Please take this advice. The above code is infinitely more readable and maintainable than any one-liners in the thread! *Edit - the only change(s) I would consider:* if ( "good" ne $stuff ) { $logger-&gt;warn("Bad stuff"); return; } elsif ( !$source-&gt;content ) { $logger-&gt;warn("Worse stuff"); return; } else { return $source-&gt;content; } That way all of your `return` calls are in a single logic block.
I'd go that direction too; I wonder why all these languages have to have different else-if's! 
I don't like cramming a combination of nots and ors and if/unless into the same line most of the time, but in general I think the judgement of how to order your if/unless clauses or statements should be based on what meaning you want to focus on. What will read most clearly, in English, to convey what is actually important about the line of code you're writing. Therefore, I don't think there's a good general rule about which order to do things in; I think it depends on the meaning of the statement. In my view, "beautiful" perl is perl that reads more like English in a way that conveys what the code is really doing and why. For example, &gt; dosomething() or warn "failed to do something: $!\n"; vs. &gt; warn "unable to do something\n" unless checksomething(); I'd use the first form if dosomething() is expected to usually succeed, and you're adding a warning as a special case for those exceptions when it fails. I'd use the second form if you're expecting to give a warning at this point in the code, but the warning may be suppressed sometimes and checksomething() is what checks whether it should be suppressed this time. Subtle distinction, perhaps, because technically they're the same, but do you see what I mean about conveying meaning and intent?
Mhm, it did read weird with the **unless** in the middle, though I heard that it was conventionally there (probably for other uses). I'll probably end up doing multiline blocks like others have urged me, my main language is javascript which isn't *terribly* different; I've developed a writing style there that I much enjoy so I'll use those principles.
Being able to understand and appreciate your own code is the most important thing.
Because they can.
In both cases, you seem to be wanting to return false along with reporting an error message as to why. Possibly using `die`, with your caller code wrapping the function in [eval](http://perldoc.perl.org/functions/eval.html) would be a good approach? i.e. sub attempt_stuff { ... die "Bad stuff" if $stuff ne "good"; die "Worse stuff" unless $source-&gt;content; return $source-&gt;content; } ... eval { my $content = attempt_stuff(); do_things_with($content); ... }; $logger-&gt;warn("attempted stuff but couldn't: $@") if $@; 
First: unless "good" eq $stuff return not $logger-&gt;warn("Bad stuff"); will never work. You need parens and braces. unless("good" eq $stuff) { return not $logger-&gt;warn("Bad stuff"); } which looks a lot more noise than return not $logger-&gt;warn("Bad stuff") unless "good" eq $stuff; as in your first snippet. For some people this is enough reason to flip it around this way, although I feel that the code order should reflect the intended execution order, and flipping it around makes it more awkward. In that case, the short-circuit or makes more sense: "good" eq $stuff or return not $logger-&gt;warn("Bad stuff"); Second, your `return not $logger-&gt;warn("Bad stuff")` looks terribly confusing to me. You know, you can use the comma operator to achieve the same (?) a bit more more transparently: $logger-&gt;warn("Bad stuff"), return 0 which I like a lot. Alternatively, when called in scalar context, you can do this: return $logger-&gt;warn("Bad stuff"), 0; Otherwise you must do return scalar($logger-&gt;warn("Bad stuff"), 0); which is missing the point. TL;DR: I prefer "good" eq $stuff or $logger-&gt;warn("Bad stuff"), return 0; 
I'm getting: Too many positional parameters passed; got 1 but expected 0 
Agreed. Most of the perception of perl as an ugly, hard to read language comes from constructs like this. There is no reason you can't write easily readable code in perl by avoiding ugly compound statements. Typically, I only use them in a very idiomatic and rote way where the intention is clear and nobody (including me) is going to be spending a lot of time examining it to fix bugs or trace the flow. Opening files with "open (my $fh, "&lt;", $filename) or die $!;", for example.
Feel free to ask on irc, I'm on my phone at the moment
I want one! how, where?!
You got a plus there where it doesn't belong, for starters.
Yes. All a matter of preference. I don't generally use "unless" but sometimes it does read better. If I see an 'unless' with a negated test then I immediately want to flip it back to an 'if' though.
Pretty nice. Does it have any music? At least it's one of these silly haikus. Touting my own horn, I should note that [my own computer geeky songs and stories](http://www.shlomifish.org/humour/) (about Perl and other stuff). Some of them are long, but others are much shorter. One of my favourites is [“I'm the Real Tim Toady”](http://www.shlomifish.org/humour/bits/Im-The-Real-Tim-Toady/) but it's incredibly incomplete and I lack inspiration to complete it.
Paste error. Fixed.
Wow, will the conference videos be available after the fact? Also, I hope there's a Mojo conference coming to North America. Also, when possible, can someone post about today's Mystery Talk?
Awesome :-) 
&gt; Wow, will the conference videos be available after the fact? That's my understanding, I'll see if I can get one of the organizers here to give more details about that! &gt; Also, I hope there's a Mojo conference coming to North America. https://twitter.com/sjoshuan/status/470242489698619392 Mojoconf2014 donates 2000 EUR to whoever organizes Mojoconf2015. We'll see if somebody picks up the ball. :)
Talk videos will be published in 1-2 weeks when we are done with editing and approvals from the speakers. 
I would have preferred evidence or a theory -- light rather than heat. (Plus, my mom told me not to analyze assholes.)
Sorry , I meant that it was ***not*** one of these silly haikus.
would need to see why get_profile_handle is not returning anything; sounds like a possible configuration issue but this is purely speculatory 
Where do I start? - You're running a program you don't understand, inputting whatever data it asks, and trusting it. It *says* it's doing an IP flood, but what is it really doing? It could have done anything up to and including installing a rootkit. - You're trying to do something that may get your household's Internet connection suspended if you succeed. Will that be your problem, or everyone in the house's problem? - You're doing something that is actually illegal. Federal illegal. "I was just messing around" is not a defense. Can I suggest that you find some better way to mess with your friends? If you want to learn to program we heartily support you and will be happy to help you learn to do something useful. We will not teach you to be a script kiddie nor we fix haxx0r scripts for you. Oh, and you'd better run your anti-malware stuff, assuming the script didn't delete or disable it.
fyi: other talks from NLPW 2014 can be found on [their youtube channel](https://www.youtube.com/channel/UCAsxQEJp-ov1qEDNjvLfjCA/videos).
You never actually answered my question. There is nothing wrong with the script because I have seen it work. I just don't know why it crashes my internet no matter what IP i enter.
I spent a few minutes searching for "cobbler" and "satellite" (about neither of which I know anything), and I couldn't figure out what Perl module(s) you might be using. That would be useful information. You said that die was invoked, but you didn't say what the message was. It would have included the value of $!--again useful information, assuming that's how the module in question reports errors.
I missed the subtlety sorry. Maybe I won't be able to recognise a Haiku even if it hit me in the face at 100 m/s. Anyway, nice one. I can be quite dense some time.
Please don't. Rakudo has far too many already. Surprisingly none of them are capable of releasing anything.
This sounds delightful. And your talk sounds like just the thing. Alas, as of this writing, I have not made hotel arrangements because the schedule has not been posted. So airfare could become prohibitive, but I remain cautiously optimistic that the schedule will appear this week, and that airfare will be affordable.
it was alleged in irc that the schedule would appear over the weekend (or on monday since it's a long weekend in the US). So hopefully it will appear tonight. regardless, the talks are all posted already.
Do you really intend to be there for less than the three days of talks? If not, how does it matter which days which talks will be on?
[Room sharing and hotel options page on the YAPC wiki](http://www.yapcna.org/yn2014/wiki?node=WhoIsStayingWhere)
You are trying to run a "hacking program" without knowing how it works. Besides the fact that you're running a program of dubious provenance - which is about as smart as running random programs attached to your spam mail to see what they do, and *any* such program as this is dubious - you're 32 years old (so your posting history tells me), which means you're old enough to know better, and, should you get caught, eligible to be prosecuted under the Computer Fraud and Abuse Act. Even if you're not really *guilty* guilty, the prosecutor might be in the mood to become famous for prosecuting computer crimes, and proving that you aren't will cost you terribly. Yes, the CFAA is completely idiotic, but it's the law, and you're busy trying to put your foot in it with this. "Helping" make this program work would effectively make any of us who did so a conspirator under the CFAA as well. I and everyone else here are *totally* uninterested in going to jail because you want to mess with your LoL buddies (also in your posting history). Send them a dozen pizzas from a throwaway number or subscribe them to embarrassing porn or something. We are not going to help.
Heh. Did you look at that page before you showed me that link? Or alternatively: Way ahead of ya.
It was more for other people's benefit.
&gt; Can someone tell me what I'm doing wrong? Yes, you skipped some essential steps http://www.zdnet.com/blog/security/how-to-become-a-hacker/9501 Then, in a few years you should be able to understand and debug a network flooding script.
this is cool!
I have family and work obligations so 1.5 days plus travel time is my maximum. So the question is which 1.5 days. I envy you, being able to attend the whole event. Not knowing what's on what day is just crazy-making.
Thank you so much. I appreciate it.
So I take it you guys just don't know. That is fine.
So I take it you guys just don't know. That is fine.
Ah. Well then, sorry about that :) Doctor John should have the schedule posted today.
&gt; Perl 5.20 compiles on Android! The current documentation is online, and will be accessible via "perldoc android". WOW!!
&gt; Setting a non-integer value to the input record separator variable ("$/") will throw a fatal exception Wait, what?
Are the HTML hidden fields the same as cookies? Thanks, the sort of got me on the right track. I'm not sure how to do if/each for checkboxes though, only radio buttons or text boxes. 
It was only released yesterday and it still has more users than perl-6 has ever had.
Splendid, thank you so much!
Well, what else should *$/ = 3.14;* do? Readline reads integer data (ie. characters/codepoints) so only integer separators make sense.
With the postfix dereferencing do you need the arrow? $nested_array_ref-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;@* can this be the slightly nicer: $nested_array_ref-&gt;[0][0][0][0]@*
`"\n"` is a non-integer value that makes perfect sense to assign to `$/`--in fact, it's the default. Presumably both you and the author of the referenced article meant to talk about assigning a *reference* to a non-integer to `$/`.
FUNCTIONAL SIGNATURES, AT LAST!!! 
You still need the last arrow: $nested_array_ref-&gt;[0][0][0][0]-&gt;@* 
Functional function signatures, too?
Yeah! ;)
Subroutine signatures without an external module? *oh baby*.
When will they do something about the multidimensional array declaration kludge?
This is pretty cool. I tried once to write something similar but ended up with ridiculous names like "PascalCaseTolc_", "lc_toCamelCase", etc. and apparently I didn't figure out the $WORD_SEPARATOR_PATTERN so I ended up with a lot of functions "PascalCaseTolc_" and the opposite "lc_ToPascalCase". Also the implementation of [String::CamelSnakeKebab](https://metacpan.org/source/KABLAMO/String-CamelSnakeKebab-0.03/lib/String/CamelSnakeKebab.pm) is really concise!
What's the kludge?
what channel were you on?
Nice! Adding to my toolkit.
I'm a bit embarrassed about how simple this code is. But then I realised that I've seen even simpler code posted on /r/programming. ;-)
It's helpful. Thanks for sharing. 
Perl, not unlike some other languages, doesn't have native multidimensional arrays nor does one declare their size often (though you can).
Now that perl compiles on Android, what can we do with it though? Use it as a command-line program on an Android terminal? We certainly can't develop an Android app or access Android-specific API or anything like that yet, right? 
i would suggest to use PDL: my $v = zeroes(5, 10 ,4); but, in perl it isn't so hard: my @v = map [map [map undef, 1..4], 1..10], 1..5; or here is a function to create "undef"-filled N-dimensional arrays: sub ndim { return undef unless @_; my $v = []; map { $v-&gt;[$_-1] = ndim(@_) } 1..shift@_; $v } usage: my $v = ndim(5, 10, 4)
Well it's beyond me. Looks.. good? 
I once tried downloading Comedy Central videos, without any luck.
get_flash_videos had support for that at one point, but something changed and now it is broken. I want to fix it, but I'm afraid that because they use RTMP, I'd do all the work and it still won't download properly.
So on Tuesday, it looks like I'll be going to Augustina Ragwitz's beer talk, followed immediately by Jake Goldsborough's coffee talk, followed shortly by mst's SotV talk. In other words, my afternoon will be beer, coffee, and trout.
Thank you very much!
Since you said random tips welcome, I [wrote this up](http://pastebin.com/vTJkTzsq) about an hour ago to try and wrap my head around dereferencing an array of arrays (AoA aka 2D array) and using push, pop, shift, and unshift on them. I don't exactly understand the map part that does the copying of the array [but it appears to work fwiw](http://i.imgur.com/F5Mzg8t.png).
Also, pimping my own work here plus a few of our social channels: both our IRC (irc.perl.org #yapc) and our twitter [@YAPCNA](https://twitter.com/yapcna) will post the schedule "live", letting you know what talks are coming up and what rooms they're in, 10 minutes before they happen. It's the most convenient way I know of to stay on top of what's going on.
and the schedule is up at http://www.yapcna.org/yn2014/schedule
One Wednesday keynote has been added. 
Likely an issue with token authentication and such on their CDN preventing you from scraping the RTMP stream.
Perl is an interesting choice here. Net::SNMP is used internally by the AirWave team at Aruba for monitoring and managing wifi networks. But Ruby also has decent SNMP bindings, which makes the Perl programming language an interesting choice.
Perl isn't losing popularity. Far more activity in the Perl community than ever, including regular Perl5 releases, Perl6 is coming along, and more uploads to the CPAN by far. I dare say more people are actively employed doing Perl as a significant part of their job today than during the first dot-com boom. The problem is that the whole problem space is much much larger than during Perl's "heyday". Perl was a big fish in a small pond in 1998. Now it's a small fish in a big pond. This makes people confused about Perl's relevance. Perl is absolutely still relevant. 
What'd PerlMonks/Stack Overflow say?
I've been googling and nothing from Stack has come up that answers my question. So I'm going to say "nothing".
Sounds like the repo is installing an old version. You can check what is installed with: perl -MHTML::TreeBuilder -le 'print $HTML::TreeBuilder::VERSION' If the version is 4.2 as it says, try installing the module with CPAN and see if that is more recent.
Actually, I just realised: to save time, you might want to install the `cpanminus` package from the [Ubuntu package repo](http://packages.ubuntu.com/eo/precise/cpanminus).
Why does the script require version 5 of `HTML::TreeBuilder`, could it be modified to work with 4.2? Otherwise, you'll need to install v5+ of `HTML::TreeBuilder` outside of your distribution's packages, using `cpanminus` or `cpan` (if you're a masochist.)
Mojo has the best API, whenever I can do something in mojo, I won't use other modules. One thing is mojo utility API seems too simplistic , e.g. Json pointer only supports very basic extraction, I hope these utilities can be more complete and powerful. 
Awesome as usual! Thanks for the good work Sebastian.
Ah, fresh Mojolicious release! A moment to ponder whate a neat compact toolchest for everything this is become. I can't start a bew perl project without it, even when it has nothing to do with the web.
shagadelic!
Thanks for upvote. Note that it's been that way (tests are the real spec) since day 1 -- quite literally: the quote from above is from Larry's 2000 SOTO speech which was when P6 was announced. Also, the latest version of the S01 specification document says: "Perl 6 is anything that passes the official test suite.". It's been that exact sentence since at least 2006 (earliest version I've found). Comments such as angrydude42's aren't factual. My take on them is they are individual's rationalizations of their disappointment with, distaste for, or disgust at, the outcome thus far.
Out of interest what Unicode features are you waiting for in Rakudo? I recently used Rakudo to uppercase some accented characters Perl 5.18.2 couldn't handle :S
I'm not sure JSON pointers can be extended. They follow [rfc6901](http://tools.ietf.org/html/rfc6901) so it's not our call. 
Agreed, I use Mojo outside of web contexts all the time now too! 
Perl can handle that, e.g. [rjh@rjh-x220 ~]$ perl -Mutf8 -CS -E ' say uc("éléphant");' ÉLÉPHANT If it isn't working for you, you probably need 'use utf8;' (tells Perl that strings in the source code are UTF-8 encoded) and/or -CAS (tells Perl that stdin, stdout and stderr are UTF-8). 
Most of the content on the net about perl-6 is bogus. First time you've admitted it, Ralphie-boy. By 2017 you might even write something honest about it. IMO it's all but inevitable even you will have trouble flogging this dead butterfly.
The outcome this far? You mean destroying Perl? Yeah, people might be upset about that. But it's their fault for being so mean and pointing out that after thirteen years, Perl was so successful that everybody thought they could spend the next fourteen years producing absolutely nothing usable and still have users. IMO it's all but inevitable that the people who haven't ever released anything worth using will continue to be absolutely rubbish developers.
the blog post omits a very important word here: reference. Setting $/ to a reference to an integer previously set the input into "record mode" setting it to an non-integer reference was not defined and would probably have resulted in trying to read until the string `SCALAR(0xNNNNNN)` occurs in the file (whis is silly at best).
Looks like the only way Slashdot comments have changed in the last 10 years is that now half of them are spambots.
Sounds reasonable to me. You might start building against the .0 to find bugs though. 
It's not their fault, not entirely. * Blame the whole notion of perl6 as a spec, and not an implementation. * Blame the implementation as being (obviously) too challenging to implement. * Blame the lack of incentive to complete an implementation. * Blame the high number of assholes in technical communities that drive away talent. Perl6 probably should have been perl 5.12'ish, and the crap that is perl6 spec should be more like perl8.... but whatever... without a future it should be no surprise the ranks and file of perl mongers is thinning out, which is a shame because it is a very pragmatic way of coding.
Ah, thanks. Now I feel kind of lazy. :)
Just deop mst and flush that social turd. He banned me from irc.perl.org because aperion, his little sycophant, banned me from irc.freenode.net/#perl. And, I dare anyone to tell me the reason. I remember the reason: it was actually because another op (mauke) banned me for [this post](http://www.perlmonks.org/?node_id=763565). I was unbanned by simcop but mst took it upon himself to impose a policy against reversing bans, and banned me for ban evasion. Now just joining irc.perl.org to be a productive member in any channel results in a ban, always by mst. There is no reason to have irc.perl.org to begin with. Just create a group namespace on freenode and let the module creators decide who gets banned from their chans.
The SoC if people are interested / need a reminder: http://www.irc.perl.org/rules.html
What? Only one person wants me banned: MST/aperion -- aperion isn't an independent agent. He's an employee of mst. The other is a wash, mauke was for banning me (not because of my actions on irc), simcop was against it (because of my actions on irc). Quoting someone from IRC on perlmonks, is not a bannable offense if you're sane. And, to have that roll over to irc.perl.org by proxy of mst-hate is laughable. I don't even think mauke cares anymore. I'm banned now only by mst and only because of *ban evasion*. The original issue isn't even something I can contest; and, yes, fuck everything about mst. The unchecked power of that one opper is a far greater threat to the perl community than little old me. I'm just glad he has drama with sri too so I can use Mojo in peace. Now I just fork everything into `::ButMaintained`. Communication with the community is too difficult thanks to mst's monopoly on irc.perl.org. Go back and look and your years of logs in `irc.perl.org/#Moose`. `mcoleman` is my usual sockpuppet. Read the ban reasons there and the conversations that were happening before mst found out who it was. He's just a shit with a grudge.
Is there a Perl runtime app in the app store yet?
Note to people who aren't Evan: if you want a #perl-* channel on freenode, it's already registered as a group; I (mst) am the group contact and am happy to assist people in setting things up. So far the vast majority of projects seem to prefer having their home on irc.perl.org though.
1. without going into detail: mst might be a perl god but he is a bad oper with weak social competence. 2. #perl has really skilled perl people but they are stuck in their #perl world. I wish someone took them out and put them to another channel which is more open minded so we all can have fun. 3. I don't join #perl anymore because it's always the same. same people, doing the same smalltalk, little minded thoughts (mostly non technical). and if you bring some technical stuff and it might be wrong in some people's eyes then you can prepare to get either banned or bashed by (often the last word takes mst). I saw many people getting banned by mst. and several people said it was unfair to ban. but actually I don't care.
Why go out of my way to shit on it? Reciprocity. Guess which one of these bans wasn't imposed by mst, or was approved by the appropriate registrar of the channel? 23:26 [perl] -!- Cannot join to channel #perl (You are banned) 23:27 [perl] -!- Cannot join to channel #moose (You are banned) 23:27 [perl] -!- Cannot join to channel #poe (You are banned) 23:27 [perl] -!- Cannot join to channel #moose-dev (You are banned) 23:27 [perl] -!- Cannot join to channel #catalyst (You are banned) 23:27 [perl] -!- Cannot join to channel #mojo (You are banned) If you answered **NONE OF THEM**, you're right! This is another attempt to legitimize irc.perl.org which will never happen so long as it's run by shadowcat. Seriously, I was banned from #mojo when Sri, for good reason, would certainly rather hell freeze over than have mst run any project or admin any channel of his. And, I was trying to create a CPAN-published view for Mojo so I could get a [jade](http://jade-lang.com) to run. &gt; Community opers will not have the ability to issue klines or glines, as these are a function of network operations. If the SRB determines that a kline or gline is necessary as part of SoC enforcment, they will bring this recommendation to the network opers via Chris Prather (perigrin), sungo or **Matt Trout (mst).** It is expected that the network opers will act on the recommendation of the community opers but they **may challenge the decision if they wish.** The matter will then be discussed openly in #magnet-srb. Oh good, he's still special classed and above everyone else. It's news as usual. Does sungo even give a shit about magnet? His last [CPAN contribution was five years ago.](https://metacpan.org/author/SUNGO?sort=[[2,1]]) Is he in the game at all or just token seniority?
This sounds highly hipocrytical and bureaucratic. It is exactly what IRC networks should not be. They are a place for informal communication, help and support for small issues. The other things go to mailing lists. Instead of bashing and banning people all the time, which is what's happening all over the main IRC perl-related channels, you should find an intelligent way to deal with this. Right now, the main Perl channels on IRC do not have intelligent opers, they have non-intelligent ones who are infuriated and enraged beyond natural limits. They should take a break from all of their activity and go through an introspection of their own mentality which is completely derailed. 
I don't feel particularly infuriated or enraged. I am also not sure how suggesting that I am willing to revisit the decisions made by previous admins is hypocritical. I wasn't in a position of responsibility when those decisions were made, and while it would be easier to say "that's the way it is" I am instead trying to work with the task I have been given which is to make Irc.perl.org a welcome and safe place for anyone who wishes to participate. Sometimes we need a little beuracracy in order to protect people who might not otherwise have a voice.
Sungo is the main network admin. The post above is on his personal site. He is also the one who established your original Kline specifically so it was clear it wasn't a personal vendetta from mst. He made this clear to me when I asked about your situation. Matt has special access because he runs several of the IRC nodes. He falls into the Network Oper category listed in the rules. I fully understand you have a personal beef with him, and hey that's fine. My job is to make sure things like that don't affect the IRC.Perl.org community anymore. 
It certainly isn't for everyone, and if PerlMonks suits you better by all means try there. The horrible people who run irc.perl.org are trying a new process to enfranchise more people and have a better process to manage the few thousand people who do in fact find irc.perl.org useful.
Or, even this subreddit or StackOverflow.com. I second this. Magnet is a shadowcat cesspool.
so much drama 
Here's the thing, Evan. This is ancient history. I understand that you have issues with mst. Clearly, you're not alone. But going through every detail of a situation that happened many years ago isn't terribly productive. The point is that I'm creating the SRB to take personalities out of the situation. The new community opers are reasonable people with the respect of the community. I'm sure, once they're up and running, the SRB will be willing to discuss your situation if you can approach the conversation in a less emotional way than this. Regarding mst's special status. perigrin's right. mst is a network oper. He's called out in that section of the proposal because he's the only other not-sungo oper that is actively involved in the day to day operations of the community. Those three names, myself included, are called out because we are the only ones who can implement the global changes. Yes, we can challenge the decisions but the very next sentence says those challenges will be discussed openly in #magnet-srb. Those discussions will therefore be public and logged.
&gt; The horrible people who run irc.perl.org are trying a new process That does not make them less horrible. It is purely unsound, there is no process that achieves the betterment of horrible human beings which the operators of irc.perl.org are. The real solution here is to give up the monolithical hierarchical structure that is seemingly making its way in this bureaucratic document with a "written-in-stone" feel. The word 'drama' was mentioned by someone else in this thread. All the drama is created by the opers themselves because they have no idea how to run a network, and they are co-ordinated by a man with delusions of grandeur. This policy means nothing to me. As a member of the Perl community I am ashamed to see this sort of hipocrisy perpetuated over-and-over-again by the attention-hungry irc.perl.org who once again seems to not have the best "policy. I reject your policy. **grabs-policy-from-your-hand** **rips-policy-into-small-bits** **throws-bits-of-paper-in-your-face** Everyone should know irc.perl.org is the most horrible place to talk about Perl. This policy will not change that. C'mon everyone, it's time to move on to Perl communities that know how to treat users as irc.perl.org is bullshit.
I'd love some detail on how we're horrible (hell, how *I'm* terrible since you seem to have a specific axe to grind). I'd also like to here your thoughts about what the right policy should be.
"hipocracy" ... you keep using that word, I wonder if it means what you think it means. Ultimately people will have to evaluate that for themselves I suppose. As a member of the Perl community I'm just here to represent the people who are trying to fix the issues you've raised via your vivacious choice of pseudonyms. I personally find irc.perl.org to be a useful place to associate with reasonable people. I'm happy to be given the opportunity and responsibility to share that with other reasonable people. As I've said, it's not for everyone, if you have something that better fits your ideal utopia ... good on you.
&gt; irc.perl.org is a very good example of how not to run an IRC network. the people who run it are horrible, and they have a track record for that. @jackballfufu, this is an unfair statement. The people who run i.p.o are the ones who: 1) Recognized that it was becoming an unhealthy community 2) Are taking these steps to improve the situation 3) Are now being unjustly raked over the coals for doing so You are both complaining about the state of i.p.o AND complaining about the effort to improve it. This is illogical. While I respect that your statement is born out of the flames of the past i.p.o, it does not help the improvement effort if those who are fighting the good fight are being attacked by those they are trying to protect and serve. sungo, perigrin, and the others are trying very hard to turn i.p.o around and once again make it a helpful and welcoming environment for Perl practitioners of all levels and backgrounds. If you have productive suggestions for how they might better direct those efforts then, by all means, let us all know how your recommendations on to approach the problem. We're all in this together, after all. But if all you have are personal attacks, then please sit down, be quiet, and let the adults continue the hard work of reshaping a community for the better. Thank you, irc.perl.org opers and others for everything you're doing to heal and improve this valuable Perl resource. And thank you to everyone else for your patience and forbearance during this transition. 
&gt; But if all you have are personal attacks No, they are not personal attacks, they are conclusions. I'm a very rational person and I gather conclusions based on facts. &gt; Thank you, irc.perl.org opers and others for everything you're doing to heal and improve this valuable Perl resource. And thank you to everyone else for your patience and forbearance during this transition. irc.perl.org has tested the patience of possibly hundreds of people who went there expecting a normal interaction with a community. All they got were bans and kicks and all the nasty stuff. &gt; 2) Are taking these steps to improve the situation A 100 page policy fixes nothing. &gt; Are now being unjustly raked over the coals for doing so No they're not being unjustly raked dude! They're horrible people who upset hundreds or thousands of (potential) Perl community members by being rude and banning and bashing left and right. I am not going to be kind to rude people, because they're mean and horrible. I'm a Perl community member, I teach Perl to a friend of mine, I try to show that person what Perl is good at and what it should be used for, I do my best to encourage other people to learn Perl. I warn everyone who wants to join irc.perl.org about the problems that are present there and recommend them not to join it and for very good reason. The existence of this 100 page policy that you're building is the sign of a problem, it's not the solution.
As I commented below, I'd love some additional details. If the detail is "mst is the source of all our problems", I understand that folks have some issues there. I am also aware that other opers exist and these issues could and should have been brought to us. And you're right. The policy is the sign of a problem. A problem we're fixing with the policy. As I commented below, I'd appreciate any thoughts on a proper solution. I've been soliciting opinions for the last month and have gotten mostly silence.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/274nx7/perl_520_released_and_mojolicious_50_the_very/
&gt; But if all you have are personal attacks, then please sit down, be quiet, and let the adults continue the hard work of reshaping a community for the better I don't follow. I'm not an adult because I disapprove of your ideas? I'm a critical thinker that disagrees with everything you say. Again, I will tell you straight up: A policy that enforces bans and creates an even more strict and bureaucratic situation is by no means a solution. If you want solutions, study other communities and see why they're thriving and welcome users and enjoy success. If you don't, then you get stuck in this policy-loop where you collect all sorts of rules. This is not a firewall dude.. This is not a networking problem where you try to make rules for packets to go in or out. 
&gt; If the detail is "mst is the source of all our problems" Let's not go that far. His attitude is the problem, not himself. But he comes across as being horrible because of his attitude. People do not change their attitudes over night, and while mst is an extremely well-versed in writing code and being quite well-educated in software, I cannot offer the same compliment about his social skills which are probably in top #10 worst ever. Perhaps he thinks too highly of himself and tries to mimic a well-known Kernel author, and then again, maybe he should re-think and be more humble as he's not near said kernel author in terms of importance. &gt; I'd appreciate any thoughts on a proper solution Study succesful communities. See why they thrive and prosper. Read their IRC logs. Study how opers behave there. And most importantly, do they have 10000 pages policies too? For example, study the Ruby or Rails community, or even better, the Python community. Everybody knows they're popular. One component of their popularity must be linked to their IRC communication. If they'd be bashing people left and right on IRC and mailing lists, I don't imagine anyone would want to deal with them (I'm refering mostly to beginners).
&gt; I actually did study other communities. They all have SoCs and governance policies that are typically more stringent than ours. Oh so you did study them. Ok, let's study them together because it seems my findings are different than yours. I [can't find any Ruby Code of Conduct for IRC](https://www.google.com/search?q=ruby+code+of+conduct+irc). Can you please share your research with me on this topic ? And the [Python Community Code of Conduct is quite short](https://www.python.org/psf/codeofconduct/), way way smaller and more reasonable than the one for irc.perl.org
I've approached this from a network perspective. Frankly, irc.perl.org is irc.perl.org because someone at TPF pointed it our way 10+ years ago without asking us. I talked about that here: https://sungo.im/2014/04/14/the-irc-dot-perl-dot-org-changes.html Regardless, here are two of the examples I looked at: Ubuntu's guidlines https://wiki.ubuntu.com/IRC/Guidelines and freenode's https://www.freenode.net/policy.shtml Remember also that your links are also Codes of Conduct not network policies. Our Standard of Conduct is over at http://www.irc.perl.org/rules.html and is pretty tight. The governance policy is how do we as a network support the community and enforce the SoC in the hopefully few times it's violated.
&gt; Regardless, here are two of the examples I looked at: Ubuntu's guidlines https://wiki.ubuntu.com/IRC/Guidelines and freenode's https://www.freenode.net/policy.shtml Thanks for giving some examples of policies you have studied. Now, these are big communities you mention, Freenode is huge, and Ubuntu is huge, and that's because one is an IRC hosting **a lot** of opensource projects. The other one is **an entire** Linux distribution. While Perl is just a programming language, and yes, I agree it does have an eco-system, but still.. the comparison you make is kind of stretched to the limit. I would prefer a one-on-one comparison with Python/Ruby/Javascript/Java. And since I disagree with your comparison on the basis of size mismatch, I will [add that neither Ruby](https://www.ruby-lang.org/en/community/) , [nor](https://www.python.org/community/irc/) [Python](https://www.python.org/psf/records/board/minutes/2011-08-15/) have dedicated IRC networks. We seem to be experiencing a bit of fragmentation here don't you think ? Let's analyze: * [cpan.org](http://search.cpan.org/) - hosted by YellowBot (weird..) * irc.perl.org - basically shadowcat property, let's be honest * blogs.perl.org - [property of develooper.com](http://www.whois.com/whois/perl.org) * perl.com - property of tom christiansen Why aren't all these things under perl.org ? What's the deal here? So you basically take a piece of it, namely irc.perl.org and you take ownership of that and isolate it from the rest. Hmm, this seems artificial and weird. Is irc.perl.org so **big** (in comparison to the amount of communication channels other programming languages have) that it deserves to exist. Why not just go with Freenode ? Ah, but then you would not have the pleasure of writing such a well-detailed-look-at-us-how-important-we-are-code-of-conduct-because-were-so-independent-from-everything-else-and-we-dont-give-a-fuck. Yeah.. there are multiple weird things here. 
&gt; If you notice, mst is not a community oper, much like I'm not. We're involved in the process at this point mostly because there are no other network opers who can be. Oh, just the two of you? I was under the impression that there are too many of you(you know what they say, two is company, but three's a crowd). I must have been very confused. And mst is not a community oper ? [But look at him how he pumps his chest](http://www.reddit.com/r/perl/comments/26z8ku/the_final_version_of_the_ircperlorg_governance/chwskhx) about other priviledges that he enjoys..
I'm not going to discuss whether the network should exist. If folks don't want to use it, they can go elsewhere. As I discussed in the post I linked to, the network was initially created as a refuge for friends. If the perl community abandons it, the network will revert to being a refuge for friends. irc.perl.org is not a shadowcat property. They do own several of our nodes, yes, but they do not own all our nodes. If SC went away, the network would survive. The network's been around for 14ish years and has seen plenty of sponsors come and go. Regarding size, we're (as of right now), 1331 users and 463 channels. Not huge but not tiny. I decided what to study based on type, not size, as I said. I am also extremely disappointed that you've taken what could have been a useful discussion about the governance policy and dropped back into invective. I would have liked useful feedback.
He's discussing his privileges on freenode and I have no control over that.
&gt; refuge for friends That is the exact problem, you said it Sungo, you said it. You put the finger on it like an artist. If you can somehow make irc.perl.org not seem like an exclusivistic network, you get your problem solved and everyone, I mean everyone will be happy again, and then we can have nice things. &gt; I am also extremely disappointed that you've taken what could have been a useful discussion about the governance policy and dropped back into invective. I would have liked useful feedback. I'm sorry you feel that way. But I have also given you feedback that can guide you in improving things. So, my apologies for the parts that have not fondled you, but I am not here for that. Reality is hard.
Since there seems to be [some confusion](http://www.reddit.com/r/perl/comments/26z8ku/the_final_version_of_the_ircperlorg_governance/chxerv2), it may be worth pointing out that [the list of network and community opers](https://sungo.im/2014/05/31/irc-dot-perl-dot-org-first-community-opers.html) was published not long after the governance policy. 
&gt; I decided what to study based on type, not size, as I said. Well, my objection was on both of those, type and size. There is a type mismatch, namely Perl is a programming language, while Freenode and Ubuntu are not. There is also a size mismatch, Perl has a much smaller community than the entire Freenode, and all the users of Ubuntu. If by type you mean that it's an IRC network, ok, we have 3 IRC networks * irc.perl.org * irc.ubuntu.org * irc.freenode.org Do we compare these just because they're IRC networks ? This somehow eludes the nature of each which is an important thing that should be preserved in order to make the comparison meaningful in my opinion.
My point about this being a network of friends is that the network was never intended to be about *just* perl. Hell, #perl is rarely about perl and it's been that way since the beginning. I have two separate FAQs on the irc.perl.org site to cover that. I choose to operate like an independant network because I want the network to be friendly to non-perl people too. A DNS entry is no reason to make it unfriendly to python channels or linux channels or whatever. If the channel list is any demonstration, we have tons of non-perl activity. If TPF wants to create a Standards of Conduct for all of perl-dom, they are welcome to. That's not my responsibility.
You can't complain about a huge policy and still expect us to go and smash channels like this. And that's what you're suggesting, that we go roust 244 people and install a dictator on the channel to make sure the channel conforms to the notions of the network operators. #perl has changed a lot in the last few years. Perl vs non-perl talk is about 50/50 and newbs are directed to #perl-help or wherever without much nastiness. But if you'd like that to change, please feel free to join the channel and *constructively* help to change that. "constructively" does not include exploding in channel and generally being nasty. As they say, be the change you want to see. Regarding beginners, I have a ticket open for the irc.perl.org site to draft a page on how to use IRC. If you'd be willing to draft a PR-appropriate section detailing the pitfalls you see for newbs, we'd happily consider it for inclusion. The ticket is https://github.com/perl-irc/perl-irc.github.io/issues/1
Learning perl book is very good if you have no experience. Also the perl programming is great if you're previously exposed to programming. Make sure to get the right edition depending on your organization's version of perl.
We have 463 channels. The site lists those who have asked to be. That site is also available on github where folks can and have sent requests or PRs to have their channel added. There's a section in the FAQ about whether or not we're the official network. I'll let that speak for itself. End of the day, if you have a problem with irc.perl.org existing as a DNS entry, take it up with TPF. They control perl.org DNS and, just like when they added the entry, only they can remove the entry. We have no control over that.
What is the thing you find yourself doing most often? Optimally something for which you already wrote a module? Package it up, and publish it. Alternatively find a bug that bothers you the most in someone else's module, fix it, and send them the patch. Alternatively, find a module which is lacking tests, and write tests for it.
&gt; You can't complain about a huge policy Actually, I'll complain all I want. I also don't expect anything to change. &gt; and still expect us to go and smash channels like this. And that's what you're suggesting, that we go roust 244 people and install a dictator on the channel to make sure the channel conforms to the notions of the network operators. That is exactly what the present looks like. And the policy enforces it. Sorry, that is exactly what's happening. &gt; perl has changed a lot in the last few years yes it has &gt; Perl vs non-perl talk is about 50/50 and newbs are directed to #perl-help or wherever without much nastiness. It's still weird that #perl is not the channel for Perl support and people have to jump through another hoop to get where they need to be. &gt; But if you'd like that to change, please feel free to join the channel and constructively help to change that. No, I will politely refuse that. And to what end should I do that? To enter a debate of whether #perl should become #perl-help or not ? No thanks, that is so basic and so obvious that there need be no debate about it. &gt; "constructively" does not include exploding in channel and generally being nasty. That's what operators are like all the time. &gt; As they say, be the change you want to see. I am the change I want to see. I am not using irc.perl.org and I recommend all my friends not to use it. &gt; Regarding beginners, I have a ticket open for the irc.perl.org site to draft a page on how to use IRC. If you'd be willing to draft a PR-appropriate section detailing the pitfalls you see for newbs, we'd happily consider it for inclusion. The ticket is https://github.com/perl-irc/perl-irc.github.io/issues/1 I will again politely refuse as my time is limited. You should value the time I have spent to provide you with directions and incorporate these as you see fit in the repository you have mentioned. Thank you very much for taking the time to read and I wish you the best of luck with your IRC network. 
Another great resource is [this](http://modernperlbooks.com/books/modern_perl_2014) book. It has practical examples of how perl is (or in most cases, should be) written today. *Edited for mr_chromatic's link correction.
I'd suggest Modern Perl, most other perl books still use style that has been obsolete since the early 2000's.
I really found Beginning Perl to be much easier to follow and learn over Learning Perl. Another suggestion is the http://perlmaven.com/perl-tutorial site. There is a video series as well that helped me get started with Perl. 
Thank you guys so much!
I also found that "Beginning Perl" by Curtis Poe is easier, friendlier and far more comprehensive than "Learning Perl" (which was not useful for me).
A better link might be [Modern Perl 2014 book](http://modernperlbooks.com/books/modern_perl_2014).
What edition should i get? This is my first programming language ever. After Perl i plan on doing bash or python. 
I second that! Especially in bioinformatics, the tide seems to have turned sharply toward Python. Would be great to hear more Bio-related PERL
Oops! I meant 'Perl' ;-)
It's a shame that a major component of the Perl community needs to be duct taped at the seams with a lengthy legalese document, but I suppose with an inclusive open space like IRC such things are inevitable. By contrast `#perl6` has gotten along fine for years with only one rule — ["Be nice to all kinds of people"](http://perl6.org/#welcome-header) — but that only works because it has ≈200 users; orders of magnitude less than irc.perl.org.
Well there is also the rule "Don't ask Perl5 questions in #perl6" ( http://perl6.org/community/irc ) but yeah. It is also a single channel on a network that has a much more comprehensive document which umbrellas it. A more direct comparison would be http://freenode.net/policy.shtml to http://www.irc.perl.org/rules.html 
If you're on Mac/Linux, it's already built in. On Windows, Strawberry Perl is nice; as a developer, it's useful because I can install CPAN modules that require C compilation with less messing around.
Python is popular in science in general.
Something else to add, the Beginning Perl book starts off with CPAN whereas other books don't touch this until much later or not at all. I personally felt this really brought up how powerful Perl really is. Also the examples given in the book are much more real world where you can piece together something handy just from the chapter questions. Learning Perl is a good book as well but didn't feel it was as quick to get you started on real work. 
Evan is one of the last great internet performance artists. Jeff Atwood actually made him phone him before he believed Evan was a real person. Personally, I'm finding this entire thread hilarious.
&gt; You put the finger on it like an artist. If you can somehow make irc.perl.org not seem like an exclusivistic network, you get your problem solved and everyone, I mean everyone will be happy again, and then we can have nice things. I appreciate that one anecdote is not data, but: I joined irc.perl.org about 18 months ago, and I have felt suitably welcome in every channel I've chosen to join. Perhaps I'm looking in the wrong places to find the exclusivity and drama.
I't's a shame that you feel that way. Every day I see people get help in #perl-help on irc.perl.org, but also in #perl on freenode, and while regulars do get exasperated with the particularly clue-resistant and those who won't read the damn documentation when pointed at it, by and large they also tend to go away with their answer, or the tools to obtain it. I've only been hanging around there for months, not years, though -- maybe it was worse, once upon a time? Edit: word order
Try reading up on the excellent Mojo::UserAgent module within Mojolicious - very easy to use if you've scraped content before. Also reddit has an api I believe :)
Isn't the API a better plan than scraping? http://www.reddit.com/dev/api
That seems like a really good idea. Yeah, I'm pretty new to all this :D
I'll take your "I had a bad experience" and counter it with "the irc.perl.org community is really awesome and amazing". The only people I've seen have a bad time are the idiot troll types who ask for people to do their job for them, or who are incapable of distilling a technical problem down to its salient points.
Will do, thanks for the etiquette lesson, I'm definitely not trying to make their lives worse! 
Here you go - had this code lying around; haven't tested it but should work with a little customization on the reddit API for your use case: https://gist.github.com/robhammond/bcfb61eadac4a88d2923
someone might have done alot of work for you already: https://metacpan.org/search?q=reddit
&gt; blogs.perl.org - property of develooper.com Not really. We get a subdomain from them, but it's not hosted on any of their hardware and isn't managed by any of the usual perl.org team.
It happens to me today, I was wondering how could I write an array of array into cvs using one liner . Very useful and practical , thanks for sharing.
According to SO, it's because by default Python generates technically-illegal JSON: http://stackoverflow.com/a/6602204. &gt;NaN, Infinity and -Infinity are not part of JSON, but they are standard in Javascript, so they're commonly used extensions. If the recipient can't handle them, set allow_nan=False. But then you'll get ValueError when you try to serialise NaN. So I think instead of blaming Python for generating invalid JSON, you should ask yourself why you are giving it values that will not be valid JSON to begin with. Well, make that "in addition to" rather than "instead of".
"Get a life": the soft, sad cry of protest from someone who has nothing constructive to contribute to a discussion. Why am I not surprised that a perl-6 fan can produce nothing actionable?
&gt; perl.com - property of tom christiansen Tom owns the domain name, but TPF runs the site. It's run by the usual perl.org team.
"Belated Perl 6", talk about an understatement.
Perhaps if you cared less about the far future of the Perl community, the present of Perl would matter more. Why do you have to elbow your way in to perfectly reasonable pragmatic discussions to push your pet research project?
Oh is that snake oil you're selling? I'd like to buy some of that. Whatever Python is responsible for making the broken JSON, is responsible for making the broken JSON, and since it's responsible for making the broken JSON, it ought to be blamed for making the broken JSON, and it ought to stop creating the broken JSON. The spec is super-clear here: "Numeric values that cannot be represented as sequences of digits (such as Infinity and NaN) are not permitted" http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf https://tools.ietf.org/html/rfc4627 Whatever Python produced this crap is broken. 
**This output is not JSON**. It is broken garbage output from a broken Python program. 
Not really. Perl exhibits the same behavior, except you can't turn it off in Perl. See my other comment. Garbage in, garbage out.
I wonder about the rationale behind this. If floats can be represented in JSON, then NaN, Infinity, and -Infinity ought to be valid values. Python is still wrong to do this when the spec so clearly says you're not allowed. But ECMA seems wrong to disallow it.
Mind you, JSON::XS has the same problem: $ perl -MJSON::XS -E 'say encode_json({ foo =&gt; 1 + NaN})' {"foo":nan} JSON::XS can't read its own output here: $ perl -MJSON::XS -E '$out = encode_json({ foo =&gt; 1 + NaN}); $in = decode_json( $out );' 'null' expected, at character offset 7 (before "nan}") at -e line 1.
Python is a red herring in this context. Perl has so many module to handle poorly formatted HTML, why not JSON?
Which appears to be [against its own docs](https://metacpan.org/pod/JSON::XS#PERL---JSON). Also, I didn't know you could reference NaN like that. Thought you need special tools like Data::Float.
Thanks! I'll look into it when I'm not dead tired from the trip 
Oh, interesting! 
Robustness principle: &gt;[Be conservative in what you do, be liberal in what you accept from others](https://en.wikipedia.org/wiki/Robustness_principle). If you buy this, Perl's JSON should by default: * not emit `nan`. * accept `nan` and `NaN`. 
"Poorly formatted JSON" is the red herring here. There is no such thing as "poorly formatted JSON". Either it is JSON or it isn't. Also JSON is designed so that only one byte needs to be looked at to parse it correctly. Once you start accepting "poorly formatted JSON", you lose one of the big benefits of JSON's simple design. 
&gt; Also JSON is designed so that only one byte needs to be looked at to parse it correctly. Really? "null" is more than one byte.
It's not Python, it's a Python module. Don't blame the language, blame the module author.
Yes, really. You can unambiguously work out the current parsing state from just the next byte. You could try writing a toy JSON parser if you doubt it. 
By definition, the spec is 'correct'.
It isn't Perl or Python. It is the data correct? If invalid JSON is passed in, the both the Perl and Python modules are going to try and deal with it. Fix the data.
With all due respect (to others it may concern, since an anonymous fly-by-night troll like you deserves none), if you're in any way representative of the present of the community then *it has no future*.
The correct answer here would be to use YAML where ±Infinity is a valid data type.
This is great and should be more common!
Well, sure, as far as implementations are concerned, the spec is correct. I'm just wondering why ECMA choose to do this.
No, the docs just say "it is an error", i.e. "don't do that". It doesn't specify what the consequences are.
Is it valid JSON5 though?
With all due respect, do you really think that the best way to contribute to the Perl community is to get sucked in to the never ending black hole of despair decade-plus research project that is perl-6? Because Perl has users actually doing bioinformatics and perl-6 doesn't have users. Disclaimer: I used to have a job doing bioinformatics with Perl. Except now the lab switched to Python, because the black hole of despair that is the decade-plus research project called perl-6 made Perl unappealing for people who make decisions about which programming languages to use based on their viability. That's right, even the clownshoes fiasco of Python 2/3 is more appealing than waiting for perl-6 to find its arse with a map and a flashlight.
And what **is** the correct way to represent those values in an implementation-agnostic way? XML?
&gt; sucked in to the never ending black hole of despair Sounds scary. I suggested a chat session. Are you fearful that P6 will appear attractive? &gt; I used to have a job doing bioinformatics with Perl. So why don't *you* chat with Larry and friends? (Well, I can think of a reason. If you use the style you're using here you'll be wasting everyone's time and you'll get kicked off the channel. But if you can raise your game a chat ought to be worthwhile.) &gt; Except now the lab switched to Python, because ... perl-6 made Perl unappealing for people who make decisions about which programming languages to use based on their viability. Please, please, find a way to prove this. Ask the folk who made that decision to sign a letter saying something to the effect that they switched from Perl to Python because of something to do with Perl 6, not to do with Perl 5 or Python. It would be very useful to be having debates about this sort of thing based on hard evidence. Were you involved in the process that led to the switch decision? &gt; even the clownshoes fiasco of Python 2/3 Did those who made the decision to switch to Python see Python 2/3 as a fiasco? Do you think Python 3 should have been a lesser upgrade with less breakage in back compat? Or do you think they didn't do enough?
The director of my lab used to be a contributor on the perl-6 language list. I know he had some patches to the spec. His quote was something like "F*** perl-6, it's a decade late. Why should we be stuck with a technology that doesn't have a future?" I decided not to ask him for a letter. Sorry. (I'm not sorry. I don't want you knowing where I work or where I live.)
&gt; Why should we be stuck with a technology that doesn't have a future? Sounds like he thought Perl 5 didn't have a future.
Reading comprehension isn't your specialty, is it? We're actively switching away from Perl for new development because the lab now believes that Perl doesn't have a future thanks to perl-6 being "a decade late." Because I know your kool-aid stained fingers are already banging on the keys to find the bon mot to refute everything I just wrote, let me get one more point in. You don't work here, so every point you try to make about how I'm wrong, about how that isn't what he could possibly have meant, I am going to read out loud to my coworkers and we're going to laugh at how wrong and stubborn and deluded you are. Because that's all perl-6 is good for anymore. It's already done the damage and ruined a the job prospects of perfectly good language. All that we can do is laugh at your weird cult marketing and wonder if you really believe all the shite you spew.
You're right that, even though I can not *know* one way or the other, I don't believe your director arrived at his switch decision based *purely* on "Perl has no future because Perl 6 is a decade late". Maybe he thought there were already major technical problems with Perl 5 (eg weakness when dealing with concurrency, making it harder to partition large problems). Perhaps he felt there was a perception problem ("Perl is write-only and too old") and this made it unduly hard to attract staff and/or otherwise reflected poorly on the lab. Maybe there were things he really liked about Python, or at least Python in the context of bioinformatics. Perhaps he was influenced by what other labs are saying and *they* are in to Python. If he really did make his decision based purely on what he knows (or doesn't) about the status of Perl 6 in 2014 and what he predicts about its future, without taking in to account that he might be wrong, and without taking in to account what he knows (or doesn't) about the future of Perl 5 and of Python, and how all of that relates to his lab, well, imo that's a pretty terrible decision process. Was your director once strongly pro P6? Several ex-contributors have flipped from strongly pro to strongly anti. That could explain his stated rationale (even if his decision was really much more nuanced). Regardless, I'd really like him and/or some of your coworkers to [visit #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) between 9am and 9pm GMT and chat with Larry Wall (nick: TimToady) about the respective merits of using Perl and Python in a bioinformatics context now and in the future. Here's hoping.
I heard some guy talking about that. He seemed awfully excited. I should get my wife to commit on hardware so I can add things.
Cool, so were you worried the timing would be too inconsistent if you just wired up the ADC to the RPi?
Not my project, sorry. There is a commenter on [hackaday](http://hackaday.com/2014/06/06/a-tweeting-litter-box/) saying that the whole thing could be done on the Arduino.
I have to say that is quite awesome.
well, you should start by reading perlguts documentation. and then take a peak at perlapi. supplement it with PerlGuts Illustrated, and hack away. If you are interested in C++, I'd recommend ExtUtils::XSpp / Module::Build::WithXSpp. 
Adding to this, a good book, the only good book, is "Advanced Perl Programming". Read a lot of existing XS code also.
Prototyping stuff with Inline::C can be a good idea; no Makefile nonsense to set up, no extra files to edit, and no compile phase between edit and run. And then you can transplant your code into a proper XS file pretty easily once it's working.
Next in this series: "why French didn't win" !
that's a http 503 if I'm not mistaken. Service temporarily unavailable. Someone took down your mirror for maintenance. Give it a bit and see ifit clears up when they bring it back online. If it is continuously appearing, check your repo mirrors and try using a different one.
It didn't? I was unaware that there was a competition.
I tried two vpn servers, different countries , all the same. 
uhh... vpn won't solve the problem. VPN just changes where you come from, not where you are going. if cpan is trying to get to uk.mirror.org then it'll still be trying and failing whether you're on a vpn or not. http://stackoverflow.com/questions/18389824/how-to-change-the-perl-cpan-repository-location The answer on that question gives you the right commands to use. go through the mirror set up until you find one that you can connect to.
http://www.forbes.com/sites/pascalemmanuelgobry/2014/03/21/want-to-know-the-language-of-the-future-the-data-suggests-it-could-be-french/ On a more serious note - i wonder what percentage of professional perl developers started their career pre perl6 announcement and what percentage post? I'm very much in the latter (2003 onwards) and many i have worked with are the same. Surely this is the greatest measure to the oft begged question that perl6 somehow killed perl. Anyway, this concept of "winning" in programming language terms is silly. To borrow an analogy from the article: Usain Bolt wasn't always the fastest and he won't always be the fastest. Swift maybe the shiny new, but in a decade or more it will be just another legacy language.
This script is pretty rudimentary, what types of IRC alerts are you using?
Best not to click on the link, this appears to be some sort of crappy advert site, that just posts what seem to be topical articles on the hope of getting traffic they can serve ads on. Its just the same of junk that's bee recycled a million times. Since there's no response link there's just no point to doing much.
I down voted this since as I said we only help these chumps drive up there SEO value by giving them links. I hope more of you follow up and help down vote this link into oblivion.
&gt; Someone who has at most 1 year of perl-on-the-job experience Hm, I doubt that.
The only other explanation for all the half-truths and implications would be malice and i feel like being nice today.
chromatic, as much respect i have for you, i have no idea why i seemingly need to explain to you what half-truth² and implication³ mean, and why they are orthogonal to opinion and why they, in this article, are either ignorance or malicious guidance of other's opinions. ² Presentation of a fact that appears negative due to leaving out closely related other facts. Example: "It's 2009. Maybe they'll fix some of the bugs in 5.10 this year.It's 2014. Are you still paying attention?" - Left out: The fact that since 2010 Perl's only a regular release schedule. ³ Presenting a fact that causes the reader's imagination to imagine an implied reality, regardless of its factuality. Example: "It's less useful to have a module which understands the Gopher or Archie protocols in 2014 than it was 15 years ago" - Implied: Most of CPAN is useless, outdated and unmaintained stuff.
Sorry, but I gotta go with chromatic on this one. Yes, we can pick apart any writing line by line and make claims that the author is being deliberately duplicitous, but barring some glaring factual inaccuracy of the article and some evidence that the inaccuracy was deliberate, asserting that there this would must be the result of either an inexperienced developer or a malicious one implies that you know either their ability or their *intent*. If you can reliably do that from reading an article on the Web, [James Randi has $1,000,000 for you](http://www.randi.org/site/index.php/1m-challenge.html) :) You may not agree with the article, but sincere, intelligent people can come to differing conclusions about something without incompetence or bad intent.
&gt; It's 2009. Maybe they'll fix some of the bugs in 5.10 this year. I remember writing angry blog posts on mpb.com arguing that very point! 5.10 had a glaring performance problem that was discovered a few weeks (a month or so?) after release and fixed on trunk, and 5.10.1 was continually delayed. &gt; since 2010 Perl's only a regular release schedule. Thank goodness for that, but it was not an easy road to get to that point.
1. I never claimed an ability to detect this in the general case, only in this article. 2. I actually agree with many points in this article. I take offense to the copious omissions, which manage to paint a much darker picture if you read this article in the mindset of someone who is not familiar with Perl. Do you agree that the omissions exist, and do you agree with my view on their consequences? If not, why not; if so, what would be your explanation for these omissions?
I like the reference to [Why Lisp Will Never Win](http://perl.plover.com/yak/12views/samples/notes.html#sl-39): &gt; They're always complaining that not enough people are using Lisp, and that Lisp isn't popular. But they humiliate and insult newcomers whenever they appear in the group. (The group regulars would no doubt respond to this that the newcomers deserve this, because they're so stupid and argumentative.) See also [Matt S. Trout's comment on Hacker News](https://news.ycombinator.com/item?id=7867424): &gt; I don't want the popularity we once had. &gt; The same people who wrote unreadable, unmaintainable perl went on to do the same sort of damage in PHP, then python, then ruby/rails, and now node.js/go. They were never a net positive to the community, and I'm not sorry to see them causing problems for somebody else.
"Winners compare their achievements to their goals. Losers compare their achievements to those of others." I have to wonder which Losing language this anonymous wang-waving opinionista is backing.
Either I totally misunderstand your comment, or you might have not noticed that this site links to a book written by chromatic. (and the domain is owned by his company) So I think it is clear that this article was also written by him.
I would love to read an article on how Perl *can* win
Again, i actually agree with the overall statement. That said: There are multiple omissions in that vein in that article. It is not the simple existence of one, it's that the pattern of these omissions draws itself through the entire thing, drawing every negative point much bigger than it is in reality. "The omission of the Modern Perl movement" - I never lamented that, i specifically lamented the lack of mention of regular releases in a section that makes Perl look as it it has received all of 2 updates between 2000 and 2014.
That is why i originally went with ignorance, even though in a hyperbolic manner. That said, i do see that the main difference in perspective here is that you believe it is possible the author wasn't just another one in a long line of people trolling Perl, for which i applaud you; but which i cannot accept as a possibility since i recognize a much too large number of trolling tactics in the article.
Oh, interesting. I didn't get that interpretation from mst's post. Perhaps that's because I lump "newcomers" and "people who aren't writing idiomatic code" into the same bucket of "people who aren't using Perl's strengths".
It's all a matter of perspective i guess. I've worked with people who wrote Perl on the side and genuinely didn't care and factually had no need to improve their Perl. But i've also worked under and received money from a CTO whose primary job description was writing the code for their company's main product, who had been working on that product for 15 years, still wrote Perl exactly as in their first year, actively opposed any programming style even slightly diverging from his (by, say, using subroutines), and as a result struggled to hire Perl developers. There is everything inbetween that and the complete newbie. :)
http://www.lemoda.net/xs/xs-intro/
OK. Did you write the article?
If you're planning to attend YAPC in Orlando I'll be giving a talk, [The Perl API for the Mortally Terrified](http://www.yapcna.org/yn2014/talk/5302), which will cover the basics. But until then I highly recommend Inline::C, man perlapi, man perlguts, and Perlguts Illustrated. 
I need a similar script for weechat. Only problem is I run it in tmux on a remote VPS so I can use the same session at work. Haven't looked into how to get remote notifications working yet.
&gt; still wrote Perl exactly as in their first year It's these people the community doesn't need. Although, technically, they weren't ever part of the community to begin with; they just added a data point to demographic calculations.
I feel that board shorts shouldn't be just given out to everyone. They should be earned. Also there are situations where they might be dangerous. You would do well to table that discussion until an investigative committee can ascertain the full facts.
Considering I spend most days sitting outside working, I feel they have been earned. The question really is do I violate basic human civil rights and/or cause an aviation hazard exposing my pasty white legs to the world?
I don't think it can, honestly. Too much legacy crap. I know mst shits on some Go users, but the language/ecosystem itself is actually maturing at a good pace, and it can do things out of the box that Perl will never be able to do without hacks upon hacks (speed &amp; clarity from static-compilation/type-checking, cross-compilation, binary distribution). You just can't compare their starting points. Go was *designed*. Perl has *evolved*. And, honestly, you don't lose terribly much going from Perl (or Python, etc.) to Go.
Well we should discuss who's to be on this committee and maybe talk about flight patterns and how you're bright white legs will affect landing planes. 
Haha. MJD and MST are total polar opposites. It's like you just quoted Piers Morgan and Jeremy Clarkson side by side. 
&gt; "The other day I was at a client where I had to read in large JSON files." Does he go back to the client and tell him to give him properly formatted JSON, or does he work around the problem?
Which host + port are you trying to reach, specifically? have you tried other mirrors?
I don't think anyone benefits from, say, someone churning out lots of Baby Perl modules on the CPAN, or being a help vampire on support channels. We all wrote Baby Perl at the beginning. But, we grew beyond it and were able to contribute to the community as a result.
That's a wall of bitching about something that isn't real. Perl is still used all the time in certain instances. My girlfriend had no other option when she joined her biophysics lab because everything they do is in perl.
Yes I'll be attending YAPC and this topic interests me greatly, so I'll plan on coming to your talk thank you for the recommendation. In the meantime I'll check out all the things people here touted, thank you all for those recommendations as well.
I moved to Jacksonville last year and haven't been able to get in contact with anyone from the onetime Jacksonville.pm -- anyone have a suggestion how to get things restarted here? 
Easy answer, come to YAPC and find people! Aftet that is their mailing list still active? If bit drop a line to support@pm.org asking someone to ping them and maybe volunteer to take over ... Then post like mad on reddit and wherever else!
Hehe, maybe you can use [bcvi](https://metacpan.org/release/App-BCVI) to proxy the commands back? I haven't tried it, but it already has a [`bnotify` script](https://metacpan.org/pod/App::BCVI::NotifyClient). I love how the environment *I* want is built using lots of tiny Perl scripts working in unison ;-)
&gt; I don't think it can, honestly. Too much legacy crap. A few things could probably elevate its current position: * significantly faster compilation and execution (it would beat the alternatives), * also: JIT, * better OO (like MOP) in the core, instead of blessing stuff and modifying @ISA, * less hackerish approach to syntax: better reference syntax (even without sigils in some cases), * new features like smartmatch done right, * somewhat obsoleting XS - I know it's used a lot, but platform independent stuff like FFI is probably a better way, * new killer app :) Given that, we could probably hope to have Perl in better situation than these days. 
Ruby \**ducks*\*
If this is your plan to prepare Perl for the future it is a very poor one.
&gt; neither an attractive object system Let's pretend Moose was core. Would that be sufficient? &gt; nor a good concurrency story How does one fix this?
Check the values of $1 and $2, first? if ($1 and $2 and $1 ne '' and $2 ne '') { } or something slightly less ridiculous...
Have a default value for $2? $2 ||= 'default value';
You can use named grouping, which is something like: if ($s=~m/(?&lt;num&gt;\d+)? (?&lt;frac&gt;\d+\/\d+)/) { $mfrac = $+{num}.' '.$+{frac}; } If that isn't right there is some way to do it, but my memory might have failed me.
Try this: @mfrac = $s=~m/(\d+)? (\d+\/\d+)&lt;stuff&gt;/; if (@mfrac) { $mfrac = join(' ', @mfrac) ; # whatever else you want to do with it }
5.8? My condolences to you. Try this: if (my @m = ($s=~m/(\d+)? (\d+\/\d+)&lt;stuff&gt;/)) {$mfrac="@m"; }
How about: if ( my @values = ($s =~ m/(\d+)? (\d\/\d+)&lt;stuff&gt;/) ) { $mfrac = join ' ', grep { $_ } @values; }
You just need ? quantifiers for the second capture class. You could also write multiple match patterns with |. It would helpful to know if you're reading each input as a string ( as in "11" is one string, "3/4" is another ) or you are reading them in as one string ( "11, 3/4, 2 1/8" ) is one string. Edit: I don't why I'm downvoted. None of the answers are correct unless we know context.
This will only suppress the warning.
Not on Perl 5.8.
You can check them with `defined`.
Cool. I'm a bit rusty with Perl, but I'm pleased to have come up with the same solution (more or less) before I peeked at the comments. use strict; use warnings; while (my $s = &lt;DATA&gt;) { chomp $s; if ($s =~ m/( (\d+)\s(\d+\/\d+) | \d+ | (\d+\/\d+) )&lt;stuff&gt;/x ) { print "$s: $1\n"; } } __DATA__ 11&lt;stuff&gt; 3/4&lt;stuff&gt; 2 1/8&lt;stuff&gt; 
I don't think the takeaway here is hating on unit testing, just hating on over-mocking. Same thing that happens when anybody gets all starry-eyed about the latest methodology/language/library/shiny-thing. You forget about using the right tool for the job. Instead, you have a hammer and try really hard to make everything look like a nail.
Yes.
Perlbrew might be a good thing for OP to look into. It sets you free from the system perl.
&gt; Hopefully someone will come along in a minute and show me up by pointing out a way to match "this thing, or that thing, or both with this thing in the middle ... both are optional but at least one is required" without enumerating all three patterns I came up with this, but to be honest, I think the way you did it is much easier to read: if ( $s =~ m!(^(?:\d* ?\d+\/)?\d+)! ) { $mfrac = $1; } and adding in the &lt;stuff&gt; if ( $s =~ m!(^(?:\d* ?\d+\/)?\d+)&lt;stuff&gt;! ) { $mfrac = $1; } Test data I used: 11&lt;stuff&gt; 3/4&lt;stuff&gt; 2 1/8&lt;stuff&gt; 1&lt;stuff&gt; 3 /4&lt;stuff&gt; 2 1/&lt;stuff&gt; Matches the first 4, not the last 2.
His problem is with (over)mocking, not with TDD per se. Personally, TDD has saved my bacon any number of times, improving the design of the APIs for my functions (because I was writing tests first, I designed the interfaces based on ease of use instead of based on purity of design). I tend to only use very, very few mocks in my tests. If I need mocks, either the function is tightly coupled to outside things (in which I should also be testing outside things), or it is too big and complex. For instance, I never mock my database. I have an environment variable (DEVEL), and if it is set, all the database functions connect to a devel database which I can trash with my tests to my heart's content. That means everything that deals with the database gets extensively tested, but on a real database, not on mock objects pretending to be a database, and probably failing to detect the exact failure mode the tests are there to uncover.
&gt; Perl has neither an attractive object system It would probably be more correct to say that Perl doesn't have *familiar object system*. Kids get out of college where they've learned Java and C# and Perl with it's global @ISA hacks and similar stuff is obviously totally alien to them. They don't start with or need Moose. They want something sensible and familiar in the first place. &gt; nor a good concurrency story. Well, fork() should be good enough for start. At least on *nix it's pretty standard.
short (since Perl 5.10 afair): $mfrac=$1.' '.($2 // ''); edit: Oh, Perl 5.8. Irgnore this solution
Writing unit tests is hard. These guys had barely written them before and didn't even try to write integration tests until much later (you need both) so it's not surprising that there were problems!
Don't you need a "g" at the end of your regex? @mfrac= $s=~m/(\d+)? (\d+\/\d+)&lt;stuff&gt;/g; 
Well, to the OP's defense, here's a quote from the blog: &gt;This is the story of how I learned to loathe unit tests. Check it, that is the whole second paragraph. So you can't accuse the OP of putting words in Ovid's mouth.
Interesting. But if the number of possible matches can be anything from 0..N then, on average, the number of iterations drops substantially to below half the set. Quite useful if the matching condition is complex. I think, intuitively, most programmers know this - and you will often find a pattern: for ( @array ) { next if ( ! match ); # handle match last; } instead of if ( grep { match } @array ) So have the `any` function to simply this manual idiom is quite useful.
People mock whole classes? Why on earth would you do that? His proposed solution of only mocking the method that does the actual remote communication was my understanding of what mocking meant. If you mock whole classes, you're really just testing that your programming language can call functions (surprise, it can!), which is pretty useless as a test.
Right, it's the people who seem to never be inclined or capable of growing beyond Baby Perl that are no help whatsoever to the community. And, by contrast, beginners who are eager to learn are actively embraced by the community nearly universally (e.g. see the success with the last few years' of GSOC and OPW students).
&gt; better OO (like MOP) in the core, instead of blessing stuff and modifying @ISA, The fact that we're halfway through 2014 and this is still just a wish should show you why Perl has been on such a big decline for the last decade. It took a fucking decade just to add subroutine argument unpacking ffs! It's still experimental though, so who knows maybe we'll have a smart match fiasco again. 
Sorry, 2014 is not NumberWang. [^Brought ^to ^you ^by ^the ^NumberWang ^Show!!](http://www.youtube.com/watch?v=qjOZtWZ56lc) 
Thanks I'll check that out
When I was taught how to mock, I was taught to over-mock everything. Yep, basically they were just unit tests that made sure the right functions were being called in the right order. Very ridiculous now that I think about it. I haven't written many unit tests lately, and used mocking even less, but I will consider mocking again but differently. oh i thought this was /r/python ... I've never written a unit test in perl.
What does the cli client say?
I still write a lot of unit tests and mock where required, but yeah, the whole dogmatic "mock everything" approach is rather silly. Mock what you have to to avoid dependence on external systems, but actually test how your code interacts with your other code. I don't consider the database an external system in that regard, since you can control it and every database system is now extremely reliable.
Fixing concurrency is very hard it would seem. I personally feel like it may not even be worth it. Languages like Clojure, Erlang and the like make it so natural that trying to wedge it into a fairly standard procedural language like Perl might be an exercise in futility.
&gt; Threaded programming in a language with a baked in concurrency paradigm is far easier to wrap one's head around Maybe. But that's also the reason we have tonnes of books explaining threads, but a few pages of how to do fork properly. You can't miss with fork. You don't get much for it obviously, but it can be good enough for a bunch of cases. Not every web service has millions of visitors. 
Install Strawberry Perl. Then at the command line type: cpan Module::Name Where Module::Name is the name of the Perl module you want to install. Once I switched to Strawberry Perl, I never looked back.
Tons of books explaining threads in languages like Java or C++ - you don't *need* thick books to explain threading in a language like Clojure or Erlang, it's as natural as linear programming in a traditional programming language.
Hey I just starred this on github. I'm going to choose to believe that I was the straw that broke this camel's (hehe) back! Seriously though, good work!
I gave a talk at YAPC::NA a couple years back which is a very basic introduction, called Baby XS: [Video](https://www.youtube.com/watch?v=EPZHXVZwsY4) [Slides](http://www.slideshare.net/joelberger/baby-xs) It wont get you very far, but it should get you started.
[Saleae Logic](https://www.saleae.com/logic)
I am happy to see this land. This will help the work that is going on to create [Firmata Test Programs](http://www.firmata.org/wiki/Main_Page#Firmata_Test_Program) in Dancer and Mojo. (If anyone wants to help let me know and I will get you connected.)
I'm glad he got funded. I cannot understand his cost breakdown though.. $260 for 6 nights stay? He must be crashing on a couch and just giving his host the money.
Changing the Perl concurrency story might be very hard, but solvable and worth it. Though maybe not by wedging stuff in -- maybe the lang's design will have to be completely rethought. I'm in [the complete-rethink camp](http://jnthn.net/papers/2014-nlpw-reactive.pdf).
OK. How's that complete rethink working out for Perl so far?
I shall call him Bob.
I was calling perf incorrectly. Because of something i don't understand about how perl backticks and/or perf filedescripters work. i needed to do: system("sleep 0.35 &amp;&amp; client-bin 2&gt;&amp;1 &gt; /dev/null &amp;"); my $perfoutput = \`perf stat -B -e cache-references,cache-misses --log-fd 1 server-bin `; 
system(@array); http://perldoc.perl.org/functions/system.html
You might like to use Padre -- but I don't know if that has an emacs interface. I generally write perl/PDL code in emacs, and use PDL's REPL and autoloader. Works for me...
[Devel::PerlySense](http://search.cpan.org/~johanl/Devel-PerlySense-0.0207/lib/Devel/PerlySense.pm#From_Emacs) is a good one to use too. Adds a ton of useful things like jumping to POD for an object, viewing inheritance, etc. If using autocomplete use the source `ac-source-perl-completion`. Or try out [perl-completion](http://www.emacswiki.org/emacs/PerlCompletion). `perl-tidy` [integration](http://www.emacswiki.org/emacs/perltidy.el) is good, and [`perl critic`](http://search.cpan.org/dist/Perl-Critic/bin/perlcritic#EMACS) should be in there as well. 
Sometimes, switching to another language is better. Consider using Python. I did something similar to what you're trying to do, but in Python (with psycopg2, since my database was PostgreSQL) and it worked very well for me. Like you, I wrote to a CSV file. **edit**: Yeah, or just downvote me. Do you not agree that switching between languages for different kinds of tasks is a useful thing to do? I thought most programmers had realized that it was.
Q: Having a bad language day with any of *U, V, W, X* or *Y*? A: Start coding madly in language *Z*. There's plenty of [places like that](http://jobsearch.monster.com/search/?q=perl-and-python-and-php-and-ruby-and-.c__23-and--java).
It's true that different languages have different strengths. It's also true that Perl is pretty much perfect for this application.
There is absolutely no reason to switch to Python for a simple problem like this. What utterly useless advice.
You should check the result of connect_db, in case it fails. And, as pjfl says, add `use strict` and `use warnings` to your code to point out some coding issues. &gt; the spreadsheet has a different schema than the database. So what is the database schema? From your queries you at least seem to be missing the `gecos` column that you want in the output. And how does "`server0, server1, server2....`" in your desired output relate to the single column `hostname` in the database table? It would be easiest if you could give some examples (made up if you like) of the database data and the desired output. 
This was pseudo code, I will have the real code in 1.5 hours. I will post it under the pseudocode. strict, warnings, Text::CSV, and DBI modules are already imported.
The way you explained your problem is really bad. Also no sign of the place you're having problem in your code. Anyway, try this: my @row = (move this line above foreach) foreach my $j (0..$#hosts) { if ({$report_data[$i]{'hostname'}} eq $hosts[$j]) { push @row, $hosts[$j]; } else { push @row, undef; } 
Yes, that is what I want.
I am having one more problem. I am getting an `Odd number of elements in anonymous hash` error at the line where ` if ({$report_data[$i]{'hostname'}} eq $hosts[$j])`
 my $format = $cell-&gt;get_format(); my $backgroundcolor = $format-&gt;{Fill}[2]; my $font= $format-&gt;{Font}; I don't have the ability to test the above code, but I think this may get you pointed in the right direction. It looks like Spreadsheet::ParseExcel::Cell is the module documentation that contains all the bits you are missing.
The fine manual tells us that the Fill property returns "an array ref of fill pattern and color indexes as follows:" [ $pattern, $front_color, $back_color ] You want the background color, so you ask for array index 2.
That would be a fascinating effort. One wonders how could one rethink the language in such a way as to solve the natural concurrency problem, and still be left with something that is recognizably Perl?
Wow nice.
So you want the same X value in all serverX fields? If this is matched: $report_data[$i]{'hostname'} eq $hosts[$j] You want all the serverX fields to be filled with the same hostname ? 
When the server name matches, mark an x there, indicating that the user has an account on the server labeled in the field.
What if uid,gid,gecos,shell differ from server to server for particular user?
&gt; how could one rethink the language That partly depends on the ones doing the rethinking. In this case, the main one is Larry. But there's also feedback over 14 years from many other folk: those already in the Perl community (eg TheDamian and other CS teachers); and those outside the Perl community (eg Audrey Tang from the Haskell community and other lambdacamels). &gt; in such a way Well, it's Perl, and Larry, so a good first thing to note is that TIMTOWTDI (there is more than one way to do it). Perl 6 compilers, or rather their middle- and back- ends, support features such as low level threads, locks, and continuations. However, the focus for the support at the full Perl 6 language level is clean concurrent combinators consistent with models such as CSP, CCS, and Actors, and the implicit parallelism that's been carefully designed in to Perl 6 junctions, hyperops and so on. &gt; to solve the natural concurrency problem The [CAP theorem](http://en.wikipedia.org/wiki/Cap_theorem) suggests there is no practical general "solution" to the underlying natural concurrency problem; it's all about [the tradeoffs relevant to a particular scenario](http://www.infoq.com/presentations/CAP-DDD). &gt; and still be left with something that is recognizably Perl? Well, that's subjective. Would you call the following working code recognizably Perl? use GTK::Simple; my $app = GTK::Simple::App.new(title =&gt; 'Code Golf Assistant!'); $app.set_content(GTK::Simple::VBox.new( my $source = GTK::Simple::TextView.new(), my $chars = GTK::Simple::Label.new(text =&gt; 'Characters: 0'), my $elapsed = GTK::Simple::Label.new(), my $results = GTK::Simple::TextView.new(), )); $source.changed.tap({ $chars.text = "Characters: $source.text.chars()"; }); Supply.interval(1).schedule_on( GTK::Simple::Scheduler ).tap(-&gt; $secs { $elapsed.text = "Elapsed: $secs seconds"; }); $source.changed.stable(1).start({ (try EVAL .text) // $!.message }).migrate.schedule_on(GTK::Simple::Scheduler).tap( { $results.text = $_ } ); $app.run(); (These are the 29 lines of code mentioned at http://jnthn.net/papers/2014-nlpw-reactive.pdf#page=38) 
Yes that definitely feels like Perl to me. As to natural solutions to the concurrency problem, I suspect I was misusing terminology here. What I meant is, if you look at a language like Clojure where data structures are inherently thread safe so reasoning about concurrent applications becomes MUCH easier, that's what I was going for.
Sorry It took so long to get back to you. What is suppose to happen when the data is in conflict, another record is suppose to be produced in the spreadsheet. I can already tell that there is going to be so many conflicts in gecos and shell that it may be easier to fix after the fact If I don't find a good algorithm for performing the desired behavior. 
What, no. It's not the peak tourist season in Florida. High season ends in April there. Right now, Florida is too hot and too humid. And Days Inn costs exactly [$36 per night](http://www.daysinn.com/hotels/florida/orlando/days-inn-orlando-international-drive/hotel-overview) starting June 22. 
The presentation isn't just about the client, but some of the underlying things they wrote to make it work, like Mojo::IRC. I'm not sure why the entire dependence on redis. There are some advantages to having a db backend, like being able to sort, search and filter views on channels. There are limitations with redis and I think elasticsearch might be a better fit, but ultimately that might be too heavyweight for what they're doing. Late in the talk they talk about future elasticsearch support for searching.. I don't know if they would need a redis backend then or not. I don't know why it couldn't support straight text logs but... I really like this. I don't know why because it's not a new concept, but this time I actually want to use it. I'm currently using irssi and screen over mosh to keep my connection steady between my home and work. Being able to keep a window open in 4 places, one of which is a tablet, and chat in any of them, seems neat. I intend to check it out when I get around to it.
&gt; There are some advantages to having a db backend, like being able to sort, search and filter views on channels. Right, and perhaps I don't fully understand Redis, but I don't think a key-value store is going to provide much in the way of sorting, searching, and filtering. If a database had to be used, I would think a traditional SQL database would work better. Basically, it seems like an excuse to use Redis, not because it's the right tool, but because it's shiny and new. &gt; I'm currently using irssi and screen over mosh to keep my connection steady between my home and work. Being able to keep a window open in 4 places, one of which is a tablet, and chat in any of them, seems neat. If you're using irssi + screen, you could chat from 4 different places, one of which is a tablet, using any sort of ssh client. I prefer the security of ssh over some novel and new web-app that may have gigantic flaws that allow someone to chat as me, or read my logs.
&gt; my $backgroundcolor = $format-&gt;{Fill}[2]; Looking through the documenation it looks like array position {Fill}[2] returns an index into the workbook's color pallette, not the actual color. &gt; $font-&gt;{Color} &gt; Returns the color index for the font. The mapping to an RGB color is defined by each workbook. &gt; The index can be converted to a RGB string using the $workbook-&gt;ColorIdxToRGB() Parser method. [Docs here](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.65/lib/Spreadsheet/ParseExcel.pm#$font-%3E{Color}) say to use the workbook method $workbook-&gt;ColorIdxToRGB() but I get an error when calling it. Docs for the [workbook](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.65/lib/Spreadsheet/ParseExcel/Workbook.pm) and [worksheet](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.65/lib/Spreadsheet/ParseExcel/Worksheet.pm) do not mention ColorIdxToRBG() at all. Have any ideas how I can find the actual color, in RBG format or any other format? 
 #!/usr/bin/env perl use strict; use warnings; # Your SDH sql query creates this kind of data structure; my @report_data = ( { hostname =&gt; 'host1', username =&gt; 'aaa', uid =&gt; 1, gid =&gt; 100, shell =&gt; 'sh', gecos =&gt; 'gecoaaa1' }, { hostname =&gt; 'host2', username =&gt; 'bbb', uid =&gt; 2, gid =&gt; 200, shell =&gt; 'sh', gecos =&gt; 'gecobbb1' }, { hostname =&gt; 'host5', username =&gt; 'aaa', uid =&gt; 1, gid =&gt; 100, shell =&gt; 'sh', gecos =&gt; 'gecoaaa1' }, { hostname =&gt; 'host3', username =&gt; 'ccc', uid =&gt; 3, gid =&gt; 300, shell =&gt; 'sh', gecos =&gt; 'gecoccc1' }, { hostname =&gt; 'host4', username =&gt; 'ccc', uid =&gt; 3, gid =&gt; 300, shell =&gt; 'sh', gecos =&gt; 'gecoccc1' }, { hostname =&gt; 'host2', username =&gt; 'aaa', uid =&gt; 5, gid =&gt; 500, shell =&gt; 'sh', gecos =&gt; 'gecoaaa2' }, ); # You want this kind of output #username, uid, gid, shell, gecos, host1, host2, host3, host4, host5, host6, host7, host8 #bbb, 2, 200, sh, gecobbb1, , x, , , , , , #aaa, 5, 500, sh, gecoaaa2, , x, , , , , , #ccc, 3, 300, sh, gecoccc1, , , x, x, , , , #aaa, 1, 100, sh, gecoaaa1, x, , , , x, , , my %records; # For every SDH record foreach my $i (0 .. $#report_data) { # This was the tricky part - to use all values as a hash key - it took me some time to get this idea ;) # It's kind of a hack but helps a lot in solving your problem. my $key = $report_data[$i]{'username'} . ":" . $report_data[$i]{'uid'} . ":" . $report_data[$i]{'gid'} . ":" . $report_data[$i]{'shell'} . ":" . $report_data[$i]{'gecos'}; push @{ $records{$key} }, $report_data[$i]{'hostname'}; # The above will generate something like this # $records{"aaa:1:100:sh:gecoaaa1"} = [ host1, host5 ] # $records{"aaa:1:100:sh:gecoaaa2"} = [ host2 ] # $records{"bbb:2:200:sh:gecobbb1"} = [ host2 ] # $records{"ccc:3:300:sh:gecoccc1"} = [ host3, host4 ] } # Your SDH2 sql query my @hosts = qw( host1 host2 host3 host4 host5 host6 host7 host8 ); # Print the header print "username, uid, gid, shell, gecos, "; print join( ', ', @hosts ); print "\n"; # Print the values foreach my $key (keys %records){ my ($user, $uid, $gid, $shell, $gecos) = split /:/, $key; print "$user, $uid, $gid, $shell, $gecos"; for my $host (@hosts){ if (grep {/$host/} @{$records{$key}}){ print ", x"; } else { print ", "}; } print "\n"; } # Enjoy ! :)
that's an ugly printf (imo) I prefer (and this is convention where I work): printf( "%12s %d:%d %s\n", $match-&gt;{home_team}{country}, $match-&gt;{home_team}{goals}, $match-&gt;{away_team}{goals}, $match-&gt;{away_team}{country}, ); I would almost consider putting the 'or die...' on a new line as well
I don't disagree. Should have done it like that. Edited. 
That's okay. I didn't want to post the code publicly to avoid confusion. I had someone PM me and help resolve the issue.
i really like it! It would be cool to add colours to it. (check out Term::ANSIColor or even Term::ExtendedColor) You can quickly remove uncompleted matches with next if $match-&gt;{status} ne 'completed'; or next unless $match-&gt;{status} eq 'completed'; which removes a level of indentation and makes the code easier to read. You can also just grep them out: my @matches = grep { $_-&gt;{status} ne 'completed' } @$decoded; --- You can also use hash slices to pull out multiple keys at once. This is overkill for this particular example (your code is easier to read) but you may find it useful in other code: printf( "%12s %d:%d %s\n", @{$match-&gt;{home_team}}{qw(country goals)}, @{$match-&gt;{away_team}}{qw(goals country)}, ); For example if you have a big hash with lots of keys and you want to pull out a,b,c,d you can do my @vals = @{$hashref}{qw(a b c d)}; This syntax is also supported (or anything yielding a list): my @vals = @{$hashref}{'a', 'b', 'c', 'd'}; You may know this already but I thought it might be helpful for anyone reading.
I'll check this out. This is my first time using the JSON module so any tips are welcome.
I'm not sure if this can help you. Sorry upfront. The manual pages for perl seemed to be really extraordinary. Try doing man perl. When I saw it for the first time, I was pretty amazed. It's all divided into subsections like perltoc, perlintro, perlfaq (there are 10 faq pages... perlfaq, perlfaq1, perlfaq2, ..., perlfaq9), and so forth. This isn't a RTFM kind of answer. It really seemed to be that the perl man pages were really good. Good luck.
"Automating System Administration with Perl" by David Blank-Edelman is what you're seeking. 
Nice, I'll check that one out. Sounds like it's right up my alley. 
Perhaps you might find the [Category:Perl](http://rosettacode.org/wiki/Category:Perl) page on Rosetta Code useful?
One liner! perl -Mojo -E 'c(@{g(q(http://worldcup.sfg.io/matches))-&gt;json})-&gt;grep(sub{$_-&gt;{status} eq q[completed]})-&gt;map(sub{qq[@{$_-&gt;{home_team}}{qw(country goals)}:@{$_-&gt;{away_team}}{qw(goals country)}]})-&gt;join(qq[\n])-&gt;say' Or with [5.20's postfix dereference](http://perltricks.com/article/68/2014/2/13/Cool-new-Perl-feature-postfix-dereferencing) perl -Mexperimental=postderef -Mojo -E 'c(g(q(http://worldcup.sfg.io/matches))-&gt;json-&gt;@*)-&gt;grep(sub{$_-&gt;{status} eq q[completed]})-&gt;map(sub{qq[$_-&gt;{home_team}-&gt;@{qw(country goals)}:$_-&gt;{away_team}-&gt;@{qw(goals country)}]})-&gt;join(qq[\n])-&gt;say'
This modern perl site looks pretty good!
start with perldoc perlintro. As a bash/shell user lots of perl will seem familiar.
 Post a ~20 line bash script that you think is complicated. We'll show you how to turn it into Perl and why Perl is better. 
Google for 'perl &lt;what you did in your bash script&gt;' and re-write your scripts.
&gt;I want to write a perl script that can login to a ton of Linux boxes, change a bunch of stuff, write logs, report errors, send me this information in readable format and do it all quickly. Puppet. I know this doesn't answer the perl thing. But for that: puppet. Everyone else here has answers for perl. And that's fine. But puppet.
Came here to say this. Puppet will do a lot of the hard work for you. You don't have to be a perl programmer to do great stuff with puppet. And you will pick up the fundamentals of perl while messing around with puppet. 
&gt; And you will pick up the fundamentals of perl while messing around with puppet. Puppet is Ruby, maybe you mean Chef (iirc that uses Perl for recipes, but it's been a while)?
Thanks for the link. I added it to the page hosting the video.
I find the only way to learn to write something is when a need arises. With Perl, you can talk to a database. Instead of writing logs to the screen - have it write to rows in a database table that you can later write a web front-end for that can read from those same log entries you've stored in a table.
I've never heard of this before, thanks! As someone who is getting somewhat frustrated with the "heaviness" of Puppet, Rex looks refreshingly simple. And Perl certainly doesn't hurt.
Chef is also Ruby. Puppet actually has a [DSL]( http://puppetlabs.com/blog/why-puppet-has-its-own-configuration-language) which is specific to it, although when you dig into extending it you'll find it's all written in Ruby.
&gt; the function should just croak if you try to do this This is how Digest::MD5 works, so I expected Digest::SHA to do the same. Surprising.
1. Think of a useful building block, a small starting point. For example (randomly), authenticating with a remote machine via SSH or LDAP. 2. Visit CPAN. Discover the Net::SSH module, or the Net::LDAP module. 3. Maybe it's installed (to check: perl -e "use Net::SSH"). If not, for RHEL, rpm's typically exist already (or install another way). 4. Build a small script to perform (test) the success or failure. 5. Repeat, eventually combining these "Lego's" into multiple useful things. 6. Stuck? Visit Perlmonks.org for -incredible- assistance from generous pro's. Keep things modular, and compose from small parts, i.e., avoid writing big, monolithic scripts (because they are harder to debug, test and maintain). You may find you already know more Perl than you realize, because there are a lot of similarities. Perl is a natural Unix-y evolution of bash / grep / sed / awk etc. Enjoy and have fun!
If he is using RHEL (as he stated) he might have a fairly old version of perl and the docs got some important overhauls in the last few versions (the object orientation tutorials being removed, for example). I'd stick to the perldoc homepage.
I like that Perl is trying to get unicode string semantics to be "standard". I have not used Perl for long enough that I'm behind the curve, but this just strikes me as asinine: &gt;If strings are equal (perl "eq" operator), Digest::SHA will return same digest. That's it. &gt;Strings "\xE9" (without utf-8 flag), and "\xC3\xA9" (with utf8 flag) are equal. The first part (strings being equal even though the byte sequences are not) is not the asinine part. The fact that those two values *must have the same digest* is. As far as I understand them, Digest algorithms do not give a flying fuck about "strings", they operate on byte sequences. Why does Perl insist on being different? 
Thanks for the idea, sakodak. I have heard of puppet many times but I've never taken the time to investigate. I do have ambitions to learn a programming language, so perl is still on my list because it's prevalent in my environment. Though, I should also look into puppet. 
romerom - That is a good point. I've only ever gotten better at bash because I had to solve problems and bash was the best way to automate stuff I already knew how to do. I've taken a shot or two at building perl scripts, but get stuck pretty quickly. I'd like to invest more time into it. 
DrStephenTyler - This brings up a really good point: one thing I always get stuck on with bash vs. another language is that I know what I want to do and how to do it with bash. What I want to do with perl can't be translated to bash or shell scripts (AFAIK). So I get confused by the fact that I have to (apparently) learn a bunch of perl through and through before I can do anything at all. And I'm just not sure if I have to do that. 
generally the convention in perl land is you let it all hang out and you get help for free. Or you keep it private and pay. Speaking as someone who makes a living with perl, where feasable the former is always better.
More info on [the Gimp front page](http://www.gimp.org/). It supports GIMP 2.8 and provides the following features: * An autosave script (not installed by default, examples/autosave2) will save in its own directory files that were opened and changed, then reopen them on GIMP startup; if installed, will start along with GIMP. * A plugin registry viewer, installed by default to Filters/Browse Plug-in Registry. * A Perl console, installed by default to Filters/Perl/Console. The way to install the release candidate on Linux is: perl -MCPAN -e "install 'ETJ/Gimp-2.30_05.tar.gz'"
As a snr sysadmin myself who has no certs but 15 years logged for fairly big contracts ive personally found the perl cookbook to be invaluable. It might be a little dated now but it doesnt teach you to code so much as how to create solutions.
Take a look at Rex (rexify.org)
So, mostly a matter of opinion, but one thing I don't like about Perl is the density of symbols, especially interpolating nested object dereferencing. Like I would have written for my $match ( @$decoded ) { if ( $status eq "completed" ) { printf( "%12s %d:%d %s\n", $home_team_country, $home_team_goals, $away_team_goals, $away_team_country ); } } Obviously I'm skating over the part where you have to do extra scalar assignments and the vertical size of your code grows. However I've developed this style in reaction to some really unfortunate code bases where people try to be too clever about jamming inline syntaxes into small spaces. Code should be about legibility, not saving space*.
I run the Perl Maven site and the Perl Maven Pro subscribers have access to these videos as well: http://perlmaven.com/beginner-perl-maven-video-course I also run the Perl TV site: http://perltv.org/ where you can find more than 300 free videos.
I am loving perltv.com! Thank you for making such a great site. (I will check out perlmaven.com.)
YAPC::NA is going on currently and they've done a pretty good job streaming all the talks to YouTube this year. You can find them [here](https://www.youtube.com/user/yapcna). Mojolicious has a nice series of webcasts [here](http://mojocasts.com/e1)
Follow the #yapcna tag on Twitter.
No language can guarantee that all data structures are inherently thread safe, avoid race conditions, etc. To quote clojure's own doc "some languages make it significantly easier to write correct, safe concurrent programs, but none are completely immune to concurrency hazards ... languages just encourage or discourage certain practices and techniques.". The code I included above is thread safe and easy to reason about. It takes just 4 statements to: coordinate asynchronous input, asynchronous output, and a timer; avoid concurrency hazards; and distribute automatically across available threads. The Perl 6 language design, by encouraging certain practices and techniques and discouraging others, makes it surprisingly easy to write correct, safe concurrent programs.
Not sure why the question was asked, but me, leont and garu are sharing a single 3-bed room at roughly $120/night plus random taxes. Cheers ;)
&gt;WordPress is hard to extend and has a history of security problems. Eeeehhhh. I've never had problems creating plugins, themes, etc. in WordPress. I can't wait until it moves to a templating system and more MVC patterened, but I love WordPress. Fite me. Anyway, in re article: Perl is still used, but not on the front-end. PHP took off because you could mix PHP with HTML, and didn't need to do things like print "&lt;h1&gt;" . $title . "&lt;/h1&gt;"; Instead, you can do &lt;h1&gt;&lt;?=$title;?&gt;&lt;/h1&gt; Since PHP is more or less moving towards MVC, ORM, million-dollar-design-pattern'd architecture, you're going to see Perl doing the same thing. Catalyst, Mojolicious, etc. allow you to just as easily make a site in Perl than in PHP. But, consumers love easy stuff. Your average business owner doesn't care what PHP or Perl or anything is. FFS Drupal is still widely used. Web hosts provide PHP applications that can be installed from the dashboard. No one is going to move to CMS-X just because it's written in Perl. People who care whether something is in Perl already have something written in Perl. They want it done, and they want it fast. Not to mention the ten million plugins and modules for Drupal and WordPress. ThinkGeek uses Perl, you know. I interviewed with them a few months ago. Nice people. Management prefers plugins and modules to doing things right, of course. Sadly. Fuck Drupal. I have no real point, just coffee. Oh, kind of a point: do I welcome something like Wordpress written in Perl? Of course. I love Perl, I love software that provides a solid foundation for writing less code and therefore costing less time, and I love the esprit de corps of Wordpress. Am I going to watch in excitement as Perl developers suddenly become desired times 10 because of a few well done open source projects? No. Sorry to say, but it isn't likely.
Wasn't PHP originally designed as a templating markup syntax for Perl? (That's the story I've always heard but never been able to backup, [this site](https://line.do/history-of-php/r5q4x1/vertical) disagrees, and I'm not really up on my PHP lore) I mean, I wouldn't reasonably write CGI scripts in Perl if I was starting a new project, making this obsolete anyway: print "&lt;h1&gt;" . $title . "&lt;/h1&gt;"; I'd use Template Toolkit and do something like: &lt;h1&gt;[% title %]&lt;/h1&gt; or if I were using Dancer maybe something like &lt;h1&gt;&lt;% title %&gt;&lt;/h1&gt; (Personally, I like the square brackets as they help differentiate from the html tags, but the Dancer (or is it Mojo) tutorial makes use of the angle brackets). 
&gt;Wasn't PHP originally designed as a templating markup syntax for Perl? Nope, that site is correct. I had just started doing webdev in '95 and remember "Personal Home Page" tools. The extension was also .phtml when they started. At the time I was reverse engineering perl CGI scripts to learn (anyone remember Matt Wright and Selena Sol's archives?) and I remember giving php a look and staying the course.
The OP is correct. It started out as perl and then shifted to C. See this bit in their manual from 1998. &gt; PHP began life as a simple little cgi wrapper written in Perl. I wrote it in an afternoon during a period between contracts when I needed a quick tool to get an idea of who was reading my online resume. It was never intended to go beyond my own private use. The web server where I had my resume was extremely overloaded and had constant problems forking processes. I rewrote the Perl wrapper in C to get rid of the considerable overhead of having to fork Perl each time my resume was accessed. [source](https://web.archive.org/web/19980701122601/http://www.php.net/manual/phpfi2.html#history)
I think this is only good news. As /u/ExParteVis states: &gt; Am I going to watch in excitement as Perl developers suddenly become desired times 10 because of a few well done open source projects? No. Sorry to say, but it isn't likely However, I do believe it's a step in the right direction. I have been saying that what Perl is lacking is a big, ubiquitous, project that everyone has adopted. Look at the other big and/or fad languages at the moment. Ruby has Chef and Rails (also Puppet but that also has its own DSL), PHP has WordPress, Python has... white space sensitivity? (django... but it's not nearly as ubiquitous as WordPress in my experience) I mean, everyone copied wsgi from Python (rack, plack/psgi, etc). While this may not end up being an end-all solution, perhaps it can be a vehicle to making further progress in getting "back in the spotlight" so to speak. The big problem I see with existing Perl solutions to the WordPress problem is things like Movable Type and WebGUI are designed by Perl programmers for Perl programmers, whereas WordPress was written for the average Joe to write his next "Cooking Blog" and not have to worry about the "programming" of his website. WordPress "Just Works"^TM and at the push of a button. It would be a huge step for the Perl community if we could just upload a directory and run a script to have a working Blog. The author seems to echo this thinking: &gt; The best way to create demand for Perl is to have desirable, plug-in extensible applications out there written in Perl. (I really like WebGUI but the install process was such a pain in the backside I've never attempted to deploy it in production)
It was written in perl, but it wasn't a templating mechanism. Edit: written in perl, not *for* perl.
This is a worthy goal but to me, WebGUI is very gnarly and complicated. Shouldn't a project like this start out with a simpler foundation? WebGUI has a lot of "legacy" decisions built in, it seems to me.
&gt; (I really like WebGUI but the install process was such a pain in the backside I've never attempted to deploy it in production) Making that easier is exactly what /u/scrottie is planning to do. He talked about it in a YAPC lightning talk yesterday.
Perl has MREs -- militarized regular expressions.
I wasn't expecting him to be a 92A.
Can I chime in with some lame PTSD joke?
I'd rather comb thru the jungles of 'Nam than a regular expression for emails.
&gt; In the example code, the operands are in the wrong order. Very good. But the problem is why there is no warning produced at compile time or run time? I know the answer to this - but I think it is a good exercise left to the reader as to why Perl doesn't consider this faulty code.
Were warnings enabled?
I only return `$number` if the number is narrower than the desired width. Here I tell the function to give me a number 4 digits wise - and provide "34" which is 2 digits wide. In this case I return `$answer`.
Yes.
Yes, this is the right answer.
"Hmm, that domain sounds familiar..." \*quick search\* [Yep, i knew i had seen this person before](http://vivin.net/projects/cherryblossom/)
This might look like a good candidate for a warning, but strictly speaking, it isn't actually faulty code. Remember that there is no practical difference in perl between `0` and `"0"`, it all depends on the context they are used in. the `x` operator treats the LHS as a string to be repeated, in the example code `"34"` and the RHS as an integer for number of repetitions, in this case `0`. So what should perl warn about? The fact that the LHS is a scalar int? Nothing wrong with that, perfectly allowable code. The fact that the RHS is a string? Again, nothing wrong with that, it's a common perl idiom (for instance, suppose the value had been read from an ASCII stream, like a CSV file.) That just leaves the fact that the RHS evaluates to zero, making `x` a no-op (well, an empty string). But again, that's valid, and a not uncommon idiom. I'll grant, it would make sense for `'foo' x 0` to raise a warning, since using a literal zero there is basically pointless, but it could be a way of temporarily "remarking out" a string or part of a string, without actually removing it from the code, for instance: $sql = "SELECT * FROM TABLE" . (" WHERE foo = 'bar'" x 0) . " ORDER BY qux"; 
I completely agree. Perl is doing everything right in this example. It is a weakness inherent of a weakly typed system. There are times I wish I could tell Perl "this is a strict type, don't interpret it any other way". But I can't fault Perl for doing what it was designed to do. Obviously if you replace "0" with a non-number such as "-" you'll get an error.
&gt; You want to pad a number with leading zeros. Better question: why didn't the original author just use sprintf?
&gt; Obviously if you replace "0" with a non-number such as "-" you'll get an error. Will you, though? A string like `"-"` evaluated in numeric context is `0`. On my machine: $ perl -e 'print "-" x "-";' exits silently EDIT: Also: $ perl -e 'print int("-");' 0 EDIT2: Since someone is bound to correct me, yes, I know that strictly there is no such thing as "numeric context", but you know what I mean. EDIT3: DEEEERRRRRRP
Insufficiently enterprisey?
Oh yeah. Good spot.
If it's `require`d, sure.
Also I think multiplying a string by zero should never be a warning - because as an algebraic expression it is quite useful. In fact I've relied on this myself when calculating how wide a string should be on a display - and sometimes it should be zero width (too far to the right).
MIME::Lite or Mail::Sender or open(SENDMAIL,"|/usr/lib/sendmail -t -O DeliveryMode=i ")
The perl-6 language design, by being an endless slog through a bog, makes it easy not to bother writing code in perl-6.
I've had good luck with MIME::Lite . my $msg = MIME::Lite-&gt;new( From =&gt; $from, To =&gt; $to, 'Reply-To' =&gt; "nobody\@domain.com", Subject =&gt; $subject, Data =&gt; $host_text, ); $msg-&gt;send;
Writing handy scripts with Perl is pretty easy IMHO to get started with some examples, and then adjusting them to you needs. This book, which I think is geared much better towards SA experienced than CS experienced people is great and pretty much clicked the "Ohh! I get it" light with Perl. http://smile.amazon.com/Beginning-Perl-Curtis-Poe/dp/1118013840 Also check into the cpan modules. https://metacpan.org/ There are lots of handy tools like Net::SSH which allow you to create tools and everything else in Perl. 
That's the simplicity I need. No muss no fuss. Thanks!
 * It cannot use any unix system command like sendmail, because there is no mail system setup on this machine. 
If your system can't send mail, take a look at configuring 'ssmtp' in the OS. It's basically a sendmail replacement that simply proxies the mail to a willing remote mail server. Most hosting companies have a server that will accept these kinds of connections.
https://metacpan.org/pod/Email::Sender
Believe it or not, I'm going to recommend looking into sending email using a web service. There are some great services that make sending email as simple as sending an HTTP request. I've been using mailgun.com for several months now. There are others, like SendGrid. Under a certain threshold, the service is free.
It took many years to come around, but this is also now the solution I recommend. I like Mandrill and found it was easily to use with perl, though many others are also great. 
What's *your* point? I found this code in an enterprise. **Re-read the original post**: &gt; True story: I found this bug in a firm processing financial records. The bug had been there for years before I discovered it. So, yes, I'm aware that `printf` exists. I'm aware that `sprintf` exists. Again - how does *my* awareness of these functions magically make this problem disappear from an existing code-base? "More to the point," to steal an overloaded expression from you, what does your comment add to a discussion about the `x` string operator and trying to multiply by the string `"0"`?
Ah yes, another good recommendation from the fine folks at MailChimp.
Is anyone in perl working on a bitcoin module that calls a C library like cbitcoin?
Not sure what this provides versus the existing info on TPF site: * http://www.perlfoundation.org/running_grants * http://www.perlfoundation.org/completed_grants (other than being one page versus two.)
Well, 'large' can mean a lot of things. From my work experience, I've worked on applications that ran the full company business and I don't think it was harder because Perl is dynamic. Some frameworks I think are better for managing larger applications, like I find that Catalyst starts to shine when the team i more than 10 people and you have dozens of controllers and hundred of actions. Same thing with DBIx::Class, you start to really get the benefits when you have scores of database objects and the codebase is a year or two down the road from startup. So I think you can make some smart tech choices off the top to improve things down the road. 
why not vim? why not vimdiff? It is the one true editor, after all! You can use it on any OS and it's always there when you need to log on to a server...
Use http://search.cpan.org instead of cpan.org. You can also file a feature request here https://github.com/CPAN-API/metacpan-web/issues to ask metacpan to accommodate your use case.
Try printing from http://perlybook.org/ and ask the MetaCPAN developers to provide integration.
Printing support is better in Internet Explorer than other browsers. I don't usually use Internet Explorer, but when I want to print web pages I use it. 
Get [perlbrew](http://perlbrew.pl/) to manage your Perl installations. Don't mess with the system Perl on OS X; you might break stuff. Get [cpanminus](https://raw.githubusercontent.com/miyagawa/cpanminus/master/cpanm) for installing modules. Much nicer and easier than CPAN.pm. If you don't like Vim, there's a good port of Emacs called [Aquamacs](http://aquamacs.org/). Recently I've been experimenting with the [Atom editor](https://atom.io/) from GitHub which I'm enjoying a lot.
Sublime is awesome. All my colleagues use it. I am sticking with Textmate that is pretty freaking great too. 
Meld is a really nice GUI diff viewer. I occasionally use Geany as an editor (although I'm happier in emacs, most of the time), and that does nice version control / meld integration. For testing web applications: take a look at Selenium
PerlyBook integration for metacpan would be awesome 
I came here to say this. Vim is the only editor I'll ever need on a *nix or Mac OS system.
Selenium's ok but if you're willing to use a bit of JavaScript I'd go for CasperJS - very fast, flexible, installable via homebrew, &amp; easy to drive using perl via backticks and Casper's CLI options
There's a fantastic built in tool called Visual Merge. Use Homebrew. Strongly suggest Vim, but you've got a million other options. Use iTerm and not the built in Terminal. What else are you looking for?
Or Windows! ftp://ftp.vim.org/pub/vim/pc/gvim74.exe
+1 for iTerm2. Excellent Terminal Emulator.
Is there another c library with which to port to perl? I tried sx tools, but that is difficult to compile on my set up, ( armhf architecture).
FileMerge (comes with XCode), Sublime Text 3, Perlbrew, and MacPorts. You're in business.
I would not create the tables where you are creating them. I would move that to the top of your code, as it adds noise to the rest of your code and unnecessarily nests it. You also have a `for` loop before your conditionals, that seems to be setting `$innerLength` in a loop, but will only ever have 1 value.
you missed $sth2-&gt;execute
That was it. Now I'm embarrassed :$ .
Just signed up and set up a feed, looks great so far.
Good to see improvements that aren't a complete rewrite (how many of those do we see succeed - TT3, Perl 6, ...) Upgrading will be tricky since so much code relies on Test::Builder, there are bound to be breakages. But at least the breakages will occur in test scripts and probably not in deployed code!
 my $innerlength; for my $i (0..$#data) { $innerlength = scalar @{ $data[$i] }; } if ($innerlength &gt; 6) { The code is iterating over the array, extracting the length of each array ref, but it is only checking the length of the last element?... 
Yes, that is enough to tell the difference between an array storing a password file and one storing a group file. Yeah, I should make another arr ray the save the results of every check into, or do something funky with map, or more explicitly check the one element I am looking for, but I at least got the code to work. Of course I need to clean it up.
Isn't that the whole reason you use wildcards?
Do you mean placeholders? In the case of this exploit it's not really the same thing; it's "data structure injection" rather than SQL injection. The point is if you're using something like SQL::Abstract, don't blindly assume that user inputs are ~~scalars~~ non-references.
I guess I come from the perspective that I don't use orms as they inherently slow down one of the most critical parts of your system and one that you have to get right. They also make it very easy for idiots to create race conditions.
&gt; But, to many of us, Perl looks like a regular expression. It really sucks that people still think Perl is unreadable.
What sucks worse, however, is that fewer and fewer people ever bother to find out that isn't true. So I read the target article hoping for some glimmer, really any glimmer of hope that Perl had a future. But there goes Damian, a guy whose salary I was paying some sliver of in the early 2000s, admitting that Perl is not a good choice for a first language and thereby tacitly admitting the situation is unlikely to improve. I admire his honesty, as ever, but this has all gotten really depressng. 
Look what he thinks IS a good choice for a first language: lisp! Not because it is useful for production work, but because he can explain it's syntax in 30 seconds, and then spend the rest of the time teaching how to solve problems by programming. Once you know how to program, though, you can choose a language that matches your style, and perl packs a lot of information into a small space, which is why people who are good at it love it, and people who are just starting with it are sometimes overwhelmed.
I think you may be underestimating Perl's long term prospects and misunderstanding Damian's position on Perl 6. He thinks "Perl 6 doesn’t need as much syntax to get the basic stuff done. There’s acres of syntax in the background but you don’t need it early on." He's recently said he thinks P6 would make an ideal CS teaching language, better than lisp or Python.
All I can say is that Perl 6 certainly had better have long term prospects given its incredibly long term gestation period. I'm all for expressive, so long as it compiles. I do respect Damian's opinion on teaching in a CS environment, but I do wonder how many people learn to program in the CS environment vs. just trying to pick it up from stuff you find sloshing around the web. (There could never have been a better time than now to be a young coder except tomorrow.)
Inside the []s, it means a literal '+' character. Outside of []s, it means 'one or more of the preceding sub-pattern' - it's equivalent to {1,}. 
Which plus? But seriously, it means "one or more (of the preceding thing)". So [a-z]+ only matches if there is at least one a-z character. Contrast with [a-z]* which matches zero or more (it would match an empty string). Two quick things: * That regex is a bit confused * There are modules for explaining regexes. 
So does the + after 'Z.+]+@[' link the two patterns together? What would happen if I remove the +s outside the []? Edit: 1 more question kind sir m/\-d(.*)/ $example = $1; Could you kindly tell me what does the .* mean? 
The dot matches any one character. The asterisk means the dot matches zero or more characters. Check out http://regex101.com/ While it doesn't have a specific option for perl, you can still plug most regexs into it and it will give you exacting details on what each part of the regex is doing. For example, on your last expression, it tells you the following: /-d(.*)/ -d matches the characters -d literally (case sensitive) 1st Capturing group (.*) .* matches any character (except newline) Quantifier: Between zero and unlimited times, as many times as possible, giving back as needed [greedy] 
Thank you!
'+' is not a link/concatenation operator inside a pattern. If you give the [-0-9a-zA-Z.+] grouping the name "address chars", you could read the pattern as "one or more address chars, then an '@', then one or more address chars, then a '.', then two, three, or four alphabetic chars. .* outside of a [] generally matches zero or more of any character apart from newline. So $1 in this case will be any characters which come after a '-' then a 'd'. -dabc123 would give $1 = 'abc123' There is a good regex overview in the standard perl documentation. $ perldoc perlre 
Don't reinvent the wheel, badly. Use something like http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html
The . isn't escaped though, so won't it match any character?
I recommend using something like Regexp::Common
It also expects no unicode in the part to the left of the @, which will break with a lot of foreign users. 
Its inside a character class, so no
Do not recommend modules from 12 years ago. That regex is awfully outdated. Use http://p3rl.org/Email::Valid instead.
The [YAPE::Regex::Explain](https://metacpan.org/pod/YAPE::Regex::Explain) module can be used to get an explanation for a given regex. Entering this at the command-line, perl -MYAPE::Regex::Explain -e 'print YAPE::Regex::Explain-&gt;new(qr/[-0-9a-zA-Z.+]+@[-0-9a-zA-Z.+]+.[a-zA-Z]{2,4}/)-&gt;explain();' gives, The regular expression: (?-imsx:[-0-9a-zA-Z.+]+@[-0-9a-zA-Z.+]+.[a-zA-Z]{2,4}) matches as follows: NODE EXPLANATION ---------------------------------------------------------------------- (?-imsx: group, but do not capture (case-sensitive) (with ^ and $ matching normally) (with . not matching \n) (matching whitespace and # normally): ---------------------------------------------------------------------- [-0-9a-zA-Z.+]+ any character of: '-', '0' to '9', 'a' to 'z', 'A' to 'Z', '.', '+' (1 or more times (matching the most amount possible)) ---------------------------------------------------------------------- @ '@' ---------------------------------------------------------------------- [-0-9a-zA-Z.+]+ any character of: '-', '0' to '9', 'a' to 'z', 'A' to 'Z', '.', '+' (1 or more times (matching the most amount possible)) ---------------------------------------------------------------------- . any character except \n ---------------------------------------------------------------------- [a-zA-Z]{2,4} any character of: 'a' to 'z', 'A' to 'Z' (between 2 and 4 times (matching the most amount possible)) ---------------------------------------------------------------------- ) end of grouping ---------------------------------------------------------------------- 
The + outside the character class (the stuff in square brackets) says "match one or more of these characters". The character class, despite its having many characters inside it, only matches one character itself: any one of the characters inside the brackets. Adding the + says "match at least one of these, and keep matching until you reach the next thing in the pattern not in the class" - in this case, the @.
You are correct, the third one is unescaped when it probably should be. As someone else mentioned, though, there are other issues with this regex - the new TLDs coming online will fail to match, for instance. The OP or author should probably just use Email::Valid or similar, [just like the good book says](http://perldoc.perl.org/perlfaq9.html#How-do-I-check-a-valid-mail-address?).
* first '+' is just a '+' * second '+" is a quantifier meaning match one or more of the preceding character class * third '+' is just a '+ * fourth '+" is a quantifier meaning match one or more of the preceding character class * the {2,4} at the end is another quantifier meaning match two to four characters from preceding character class.
That's the postincrement operator. See [`perldoc perlop`](http://perldoc.perl.org/perlop.html#Auto-increment-and-Auto-decrement) for details. The expression evaluates to the value of `$hash{$_}`, and then increments it. Basically, this is storing a count of the number of times that the value `$_` has been seen. If the count was incremented from 0 to 1 (which includes `undef` to 1, since `undef` acts like zero in a numerical context), then run the following code because it's the first time that value has been seen. If the count was incremented from 1 to 2 (or any other value), then skip the code that follows and go to the next iteration of the enclosing loop. 
It's not the same thing as that, because it evaluates to the value before the increment. That value is the predicate of the `if` statement modifier, so it matters that it returns the previous value. It would not not work if it was written with the pre-increment operator. 
Thank you for the detailed explanation!
To be clear, what that line of code is equivalent to is: my $val = $hash{$_}; $hash{$_} = $hash{$_} + 1; if ($val) { next; } 
&gt; (which includes undef to 1, since undef acts like zero in a numerical context), And (as the result of Perls Autovivification) also includes a not yet existing key. (as addition because this behaviour is mostly used in these duplicate situations)
Not what OP is asking for, but here's a fun way to get uniques, given a @list of items: my %set; @set{@list} = (1) x @list; @list = keys %set;
I would do something like: if (opendir my $dir, "/some/directory") { my @files = grep { /\.xls$/i } readdir $dir; closedir $dir; }
OR: @files=`ls *.xls`; simple.
Platform specific
In that case is $dir scoped inside or outside the if?
Its base64, G‑CADLP‑00001439.xlsx. Try this: use MIME::Base64; my $str = 'R+KAkUNBRExQ4oCRMDAwMDE0MzkueGxzeA=='; print decode_base64($str); 
I'll be darn. That's the right filename on the email, but that's not what is getting saved to disk via $entity-&gt;parse_data($msg). I thought I had a variable that wasn't initialized but that's not it either. I'm still pondering this. 
Inside.
I don't know that a variable falling out of scope closes resources, and it's just 'good practice' to close your files when you're done with them.
In the unlikely event that there's a file in that directory with a name ending in ".xls" plus a newline character, that pattern will match it. If you really mean "end of string," use the regex pattern that means exactly that: `\z` grep { /\.xls\z/i } readdir $dir; 
TIL. Thank you.
\``ls -1 *.xls`\` is actually better, without need of more parsing, however I find this very shell-ish thing to do. readdir() is always better option.
Indeed, but that is open to opinion and circumstance. My point was that in this case it is no more clear, semantically identical and saved a line :P.
I like autodie for things like this. Lets you better seperate the functional code from the error handling.
Does autodie work without an explicit close? 
rjbs++
Wasn't a requirement to make it platform independent :)
your whole community is falling apart via language specific problems and popularity... and all you could think of as an improvement is creating a standards of conduct mailing list. good job... 
Which operating systems, under which conditions, allow a newline in a filename? Perhaps when Perl actually creates a new file? 
Yes, I've been reading and writing XLS files for months now. See [Spreadsheet::ParseExcel](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.65/lib/Spreadsheet/ParseExcel.pm) for reading, and [Spreadsheet::WriteExcel](http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel-2.40/lib/Spreadsheet/WriteExcel.pm) for writing. I didn't use the XLSX modules because they are poorly documented for beginners to OO Perl, and i don't do much Object Oriented Perl programming, and the low version number for the XLSX module makes me suspect it's still alpha. Also I couldn't get them to work. &gt; I'd like to feed the excel file in and the have it exported back out and saved with updated statuses, roughly weekly. What statuses are you updating? Are you simply putting the current date in a specific column in the spreadsheet? For which records/rows? Or is the text different in the status column for every row/record? &gt; Also, there would be login information to enter on the online system for a smart card. I have no idea what you want here. Do you want Perl to connect to a database and update a field for a given record key? 
A pragmatic solution: you can execute one command "cat $path1 $path2" and use the fact that your two files in question have different format to separate the rows returned. upd: but it certainly depends on what you need this data for. because if you expect files to be formatted improperly or if you care about the exact file contents, then you would need smth else
Er, use scp? (pscp on Windows) Or, based on olleg's idea: create a tar file with both files and transfer that instead.
that would put the value at each index into $i rather than the index itself. no? EDIT: It looks like he never uses the index independently so (in addition to your suggested change) he can do: $serverlist[$i]{'port'} becomes $i-&gt;{port}
I do need the exact contents, but the parser I written isn't smart enough to tell the files apart when streamed tougher. If both files are combined into one file, the parser won't parse it properly. I could make it parse by the line, but I will probably run into some other issue I don't foresee.
And just call it $server :D
I never figured out how to interpolate a file from an scp command into a Perl data structure. 
 use strict; use warnings; use autodie; use Net::SSH2; sub get_remote_files { my ($serverlist_ref, $options_href) = @_; my $ssh2 = Net::SSH2-&gt;new(); for my $server (@{ $serverlist_ref }) { $ssh2-&gt;connect($server-&gt;{hostname}, $server-&gt;{port}); $ssh2-&gt;auth_password($options_href-&gt;{username}); my $sftp = $ssh2-&gt;sftp(); my $passwd_file = $sftp-&gt;open($options_href-&gt;{passwd_path}); my $group_file = $sftp-&gt;open($options_href-&gt;{group_path}); $ssh2-&gt;disconnect; my @passwd = &lt;$passwd_file&gt;; my @group = &lt;$group_file&gt;; push @{$server-&gt;{passwd}}, \@passwd; push @{$server-&gt;{group}}, \@group; } return @serverlist; }
Does it work with both passwords and ssh keys. Does it mask the password when used interactively?
Hi komodo, you are right.
But the [margin of the reddit comment is too small to fit it](http://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Fermat's Last Theorem**](https://en.wikipedia.org/wiki/Fermat%27s%20Last%20Theorem): [](#sfw) --- &gt; &gt;In [number theory](https://en.wikipedia.org/wiki/Number_theory), __Fermat's Last Theorem__ (sometimes called __Fermat's conjecture__, especially in older texts) states that no three [positive](https://en.wikipedia.org/wiki/Positive_number) [integers](https://en.wikipedia.org/wiki/Integer) *a*, *b*, and *c* can satisfy the equation *a*^*n* + *b*^*n* = *c*^*n* for any integer value of *n* greater than two. &gt;This theorem was first [conjectured](https://en.wikipedia.org/wiki/Conjectured) by [Pierre de Fermat](https://en.wikipedia.org/wiki/Pierre_de_Fermat) in 1637, famously in the margin of a copy of *[Arithmetica](https://en.wikipedia.org/wiki/Arithmetica)* where he claimed he had a proof that was too large to fit in the margin. [The first successful proof](https://en.wikipedia.org/wiki/Wiles%27_proof_of_Fermat%27s_Last_Theorem) was released in 1994 by [Andrew Wiles](https://en.wikipedia.org/wiki/Andrew_Wiles), and formally published in 1995, after 358 years of effort by mathematicians. The unsolved problem stimulated the development of [algebraic number theory](https://en.wikipedia.org/wiki/Algebraic_number_theory) in the 19th century and the proof of the [modularity theorem](https://en.wikipedia.org/wiki/Modularity_theorem) in the 20th century. It is among the most famous theorems in the [history of mathematics](https://en.wikipedia.org/wiki/History_of_mathematics) and prior to its proof it was in the *[Guinness Book of World Records](https://en.wikipedia.org/wiki/Guinness_Book_of_World_Records)* for "most difficult mathematical problems". &gt;==== &gt;[**Image from article**](https://i.imgur.com/x03HV2V.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Andrew_wiles1-3.jpg) --- ^Interesting: [^Wieferich ^prime](https://en.wikipedia.org/wiki/Wieferich_prime) ^| [^Fermat's ^Last ^Theorem ^\(book)](https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem_\(book\)) ^| [^Wiles' ^proof ^of ^Fermat's ^Last ^Theorem](https://en.wikipedia.org/wiki/Wiles%27_proof_of_Fermat%27s_Last_Theorem) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciscy1b) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciscy1b)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; where I can just search for statuses in the database and get the report, but it sounds like this is a little different? * Do you Perl? * Do you know SQL? * Then use Perl to execute an SQL query on your database for each document # you want to look up, and have the SQL return the data (status or color code) for column O. 
Nyt::prof
Software updates should always be done through the OS package manager - everything else will just mess with your system's consistency and maintainability. 
Which OS package manager should I use for RHEL 5.5.56? [This site](http://learn.perl.org/installing/unix_linux.html) says to use the `curl` command to install Perl, but it wasn't clear if it was installing a binary package or source package. 
i haven't used RH distros in years, but i presume you could use the [`yum`](https://en.wikipedia.org/wiki/Yellow_dog_Updater,_Modified) or [`up2date`](https://en.wikipedia.org/wiki/Up2date) front-ends to the RPM package manager. Having said that, i second u/Rhomboid's comments. 
Is there a particular reason you need the newer version, and how new a version do you need?
use perlbrew to install a self contained copy of a newer perl, and leave the system perl alone. then when you install packages from the cpan they will also be installed alongside the self contained perl http://perlbrew.pl/ as for a list of changes, you'll want to read the perldetas https://metacpan.org/search?q=distribution:perl+perl%20delta
&gt; assuming you have a basic working C toolchain. I can't assume that as I've never used the C compiler before. Nor has anyone else. Thus my preference for a binary distro. 
**Final goal**: Send occasional SMTP email from Perl without installing a full MTA on my linux system. [This is the reason](http://perlguru.com/gforum.cgi?post=79091;sb=post_latest_reply;so=ASC;forum_view=forum_view_collapsed;;page=unread#unread) I am considering a newer version. Mail::Sender throws an error in debug mode, but not in regular run mode. Hope you can read that. Mail::Sender was updated in 2014 and I needed something to send SMTP email because I don't have an MTA, like sendmail, on my system. I'd rather use Perl, instead of installing and configuring a whole new MTA, which I don't really need. The debugger is an essential part of a programmer's tools, so I want to fix this, and am considering putting the latest release of Perl (not an alpha or beta or nightly) in a new directory. 
Thank you. Maybe I'll use curl or wget to grab the ones I want so I can read them offline later. 
If you don't have a working C compiler, then vast portions of CPAN will be off limits to you as well, and if that's the case then why even bother? Besides, getting a working C compiler shouldn't be any more than `yum install gcc`, but I'd be surprised if those packages weren't already installed. 
Depending on what you're allowed to change, this could be as easy as just using perlbrew, and changing which perl your app uses. or it could be a complicated nightmare if you have an extensive codebase that requires particular module versions to work, some of which don't work on 5.20. I did the later project a bit ago, so if it seems pertinent, lemme know and I'll give you some pointers. Protip: hash randomization fucks everything from 5.8.8.
What do you mean by "hash randomization"? Right now, in Perl 5.8.8, I'm using these modules, so they have to work in the latest version of Perl: * Spreadsheet::ParseExcel * Spreadsheet::WriteExcel * Net::POP3 * MIME::Parser * Mail::Sender I [see here](http://www.activestate.com/activeperl/downloads) there are ActivePerl versions for Linux for versions 5.16.3 and 5.18.2. I could install one of those also. But it's critical the above modules work. Right now Mail::Sender won't work in the debugger. It throws an error and my program quits. 
The `cpanm` utility works and I've successfully installed and used modules. So does that mean I have a working C compiler? Also, doing `which cc` and `which gcc` gave me some paths. At least those are on my path. 
Many common Unix filesystems famously (infamously?) allow any characters in filenames other than slashes and null characters.
Sounds like you should contribute to the project.
 $entity-&gt;parts(0) That should be `$entity-&gt;parts[0]` surely? Is that your actual code?
The use of parens comes from the examples in the documentation. 
Are you perhaps saying that the OP is over-optimizing?
You should easily be able to install an MTA, which you shouldn't really need to configure to send mail, like Postfix. This also doesn't seem like a Perl problem but a module problem. I'm assuming you've installed Mail::Sender via yum and have checked and there are no updates available? If not then maybe you can use local::lib just for this program.
So you're mixing modules manually using CPAN and also those provided by the system? This is not a good idea.
Worth mentioning that the logistical issues behind this help inspire P6 to be defined before an implementation.
Where did you hear that you cannot? Besides the 3 perlcc compilers (2 native, one bytecode) there exist several packagers also. http://search.cpan.org/dist/B-C/perlcompile.pod#Other_perl_to_exe_compilers (Edit) And several other research projects, see eg: http://perl11.org/ (11 = 5 + 6) for an overview on p2, rperl, gperl, perlito, perl5 on perl6.
Sure he is missing the obvious: The existing perl5 compilers. B::C natively compiled perl5 is used in production for more than a decade, and is running on ~70% of all the hosting providers (ie. the "Internet"). Re perl6: The native code backend for parrot was removed several years ago, but there's still the simple approach you described with pbc_to_exe.
No, perl cannot upgrade itself. EPEL does not have a newer perl, but you can simply compile your own (default: /usr/local/bin/perl) wget http://www.cpan.org/src/5.0/perl-5.18.2.tar.gz tar -xzf perl-5.18.2.tar.gz cd perl-5.18.2 ./Configure.sh -de &amp;&amp; make -s -j4 test &amp;&amp; sudo make install And then re-compile all your XS extensions. E.g. with perl -MExtUtils::Installed \ -e'print join("\n", new ExtUtils::Installed-&gt;modules)' &gt; module.list cpan `cat module.list` I would not recommend perlbrew as it makes it very hard to deal with the needed local env and local lib settings. You can try perlall which does compile multiple perl's globally, but you only need one. BTW: Never install a .0 release to be used in production. (5.20)
Can you elaborate the p5 compiled code in production? Is it part of Apache? Now I feel silly for not having tracked with Parrot development over the last few years.
That compiled code would be cPanel.
 use strict; use warnings; my ($x, $y) = ('$y = $x', 'x'); eval "$x"; print $y; (it prints "$y = $x") Code, similar to this, is almost impossible to compile into bytecode, yet it's still valid Perl code. You still need Perl interpreter during run-time stage. Technically, it's possible to include Perl interpreter to do it for you (I think Cava Packager does this), but it's different from real compiling. 
Apart from using local temp files... Me neither. Instead of a tar file you could create your own, very basic, file format: first print out the length of the file, followed by a newline, followed by the contents of that file, and do the same for the other file. That way you can *safely* split up the stream into parts, each with the original file contents. With a bit of coding on the other side you can even format this so that you can split up the data in a single [unpack](http://perldoc.perl.org/functions/unpack.html) statement (look at the paragraphs starting with "The / template character" under [pack](http://perldoc.perl.org/functions/pack.html)).
I've used Perl a little bit. I don't know SQL. I was planning on farming this out to someone who knows how to do it, since it's easier to justify spending money than hours learning programming. I just didn't want to be going in the wrong direction before doing that. 
Link please? I can't see it in the CPAN pages you linked to. 
Nope. It's under MIME::Entity. [Here's the link to the subsection with the example code using parens.](http://search.cpan.org/~dskoll/MIME-tools-5.505/lib/MIME/Entity.pm#Access_examples) 
&gt; I have this statement, where I first check to see if $t1 is defined: `if ($t1)`. That isn't how you check whether a variable is defined. That tests whether `$t1` has a true value. If you want to test whether `$t1` is defined, you should write if (defined $t1) { ... } &gt; However, even though $t1 is undefined, it still checks the last part `($t1=~m/^[\d\, ]+$/)`. How do you know this? What behavior are you seeing that is causing you to conclude that this expression is being evaluated?
&gt; So you're mixing modules manually using CPAN and also those provided by the system? No, I said I did the 'which' command and do have C and GCC, but I'm not sure if they work. Doing 'which' is not a good test to see if the compilers work and are configured properly. I do know how to use them, I just haven't used them on this system. I thought `cpanm` just downloaded and installed text files (the modules) but didn't need to compile anything. I install all modules via cpanm, and currently point to one version of Perl. I simply have never used a C compiler. But someone else said, if I've installed modules, then the C compiler works. 
That does not affect anything.
Because I get an uninitialized variable in pattern match error in that line, probably from ~~(len($t1)&gt;0)~~ `($t1=~m/^[\d\, ]+$/)`. But Perl will still stop checking after the first check is false? like `if ((defined $t1) and (len($t1)&gt;0) and ())` 
No, `undef` is false in boolean context and doesn't produce a warning. In fact, I don't get a warning with the code posted above. And yes, Perl has short-circuiting: if the first condition is false, the second doesn't get evaluated. Other issues I have found: Perl doesn't have a `len` function. Is that user-defined? And this check is not strictly necessary, because the regex will take care of this. if ((defined $t1) &amp;&amp; ($t1 =~ /^[\d, ]+$/)) { blah(); } Works as expected: for `undef`, empty string and `"4"`. Is `strict` mode enabled?
I still get "uninitialized value in pattern match" in the `if` statement. if ( (defined $t1) &amp;&amp; (len($t1)&gt;0) &amp;&amp; ($t1=~m/^[\d\, ]+$/)) { storeinclude($t1,$lin); } If $t1 is defined, why the "uninit variable in pattern match" error? 
Yes, len() is user-defined. It simply calls length().In len() I also check for an undefined value, hence the new subroutine len(). Yes strict mode is enabled. I use `use strict` so it stricts everything. 
OK, can you show me your `len()` subroutine? How do you check for `defined`ness there?
Limitations on complexity: none. It passes the perl5 core testsuite (after fixing the wrong parts of the testsuite which do not know about proper phases and external compilation) Just a few caveats: https://code.google.com/p/perl-compiler/source/browse/STATUS Bigger applications will need a good C compiler as you will run out of memory with an older gcc and -O2 on Moose or dzil. See http://blogs.perl.org/users/rurban/2012/04/big-module-sizes.html Execution time: B::Bytecode and B::C have similar run-times, B::C only does memory optimizations on the data structures. Which provides parts of the 10x faster startup-time and destruction-time. You just map the data and code in, do some dynamic adjustments on the symbols, and run it through the normal libperl runloop. However with rperl and/or B::CC programs are optimized to vastly better run-time performance. I wrote a series of blog posts on one array benchmark with B::CC, which went from 22m14s with pure perl to 3m30s with B::CC compiled perl. * http://blogs.perl.org/users/rurban/2012/09/optimizing-compiler-benchmarks-part-1.html * http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-2.html * http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-3.html * http://blogs.perl.org/users/rurban/2012/10/optimizing-compiler-benchmarks-part-4.html With rperl certain micro benchmarks are up to 200x faster. But rperl and B:CC are not stable yet, you cannot run everything, and it is not yet used in production. 