thelandofnarnia, mr\_chromatic is a leading Perl dev: http://en.wikipedia.org/wiki/Chromatic_(programmer) From that page: "While he may be most currently known for the module Modern::Perl, chromatic originally wrote Test::Builder, which is the foundation of most testing in the Perl world." If I were you I would hire scrottie tonight and donate something at http://www.onyxneon.com/books/modern_perl/
How many instances do you have? What exactly is the result of the memory leak? Are you sure that that is the problem?
Our last live stream didn't work well. But onward and upward! We're trying again! A few days after the event, the recording will be available on Internet Archive.
This isn't really Perl's fault. It's a product of the kernel for any process that asks for memory. The solution for that would be to use forks for short, temporary bursts of memory usage.
I use two general approaches to dynamic data types with Moo(se)-ish perl. One is to go all MOP on the thing and dynamically add real attributes as data is loaded. Exploit lazy =&gt; 1 where it is valuable. The other is to go indirect and have one attribute that stores a representation of the raw data element and a general purpose accessor or two. A variation on this is to exploit sub AUTOLOAD to give you the appearance of real accessors.
Indeed. Hiring scrottie yesterday is your best move here.
Dude, ditch the shared hosting. Get a real server. They're cheap, check out http://www.kimsufi.co.uk Your tech guy says the RAM usage is normal. Believe it. Your hosting company does not want you to use the RAM because you're not paying them enough money. Get real hosting.
Unused pages will still be swapped out, though. So other processes will get the freed up memory, even if the pages are not actually marked as free.
It's funny you should say that, I spent some time last night trying to get DBIx::Class to work and it does to appear to be what I was looking for. It was just aggravating not having a name for it! Another user, /u/crashorbit mentions a 'lazy' way of doing that might be suitable as I learn more about DBIx::Class. &gt;The other is to go indirect and have one attribute that stores a representation of the raw data element and a general purpose accessor or two. A variation on this is to exploit sub AUTOLOAD to give you the appearance of real accessors. The only reason why I would think about doing this first is that I kind of understand what's going and it will help me learn a bit more about Moose!
damn I completely missed this...will there be a vod up anytime soon?
We're on a managed dedicated server. This wasn't an issue of that, but thanks for the thought there. 
We're on a dedicated managed server, and I actually stepped in on a call where for several hours the tech co-founder and server admin were working on the problem. The good news was that we've placed a bunch of stop gap measures to keep it from happening again. The bad news is that the glitch was unable to be recreated as they worked on it, and they said as anomalous as it was, it would take a very experienced programmer weeks or even months to really figure out what the issue is which goes beyond our scope. Seriously though, I really appreciate these answers. They are certainly helping me understand a bit more of my partner's position here. 
Hopefully today or tomorrow. I'll post once it's up. Not only was the talk itself great, Larry was at the meeting and was kind enough to go on camera at the end and tell us more about his new gig at craigslist. :)
^ This. Your existing tech can't solve it so you need to look outside. This won't be fixed by us randomly guessing. Also consider the possibility of malicious action, DOS or competitor interference. Or something else on the system, or upstream systems, or - dammit Jim - it could be anything, based on your description! 
&gt; It's a product of the kernel for any process that asks for memory. Perl *could* release memory to the kernel, but there's a lot of overhead required to keep track of how much and when you can release it, and it's optimized for the possibility that you'll use that much memory again (so why do something slow like request the same memory over and over again)?
But the whole page would have to be unused and there's no way to predict which Perl variables would be in what memory pages. If just 1 part (or some internal bookkeeping stuff from Perl itself) of your program is on a page then the whole page will stick around. And relying on things to eventually be swapped out is just waiting for a disaster. Swap is a nice saftey net, but not something you want to use often.
The github-sync feature will automatically create Github tickets for you. What happens when you close the ticket on Github though? Will it sync the other way, and delete the line from your source file?
No. It doesn't do that. Messing with somebody's code is too sacred I'd say. 
Excalibear is right, if you close the ticket on GitHub it will let you know (Resolved on GitHub) when you run the report. I decided against deleting the line from source; it didn't seem like a good idea to let the tool touch the users code.
I'm sure this is homework, but what the hell, I guess you just got dumped. /[aeiou]{4}/g
http://www.wordnik.com/lists/words-with-four-consecutive-vowels
williadc's answer will match, but it won't match correctly. If you want the while word you need to use word boundaries: /\b\B*[aeiou]{4}\B*\b/g Finding words that start with capitals would be basically the same ideas (word boundaries, ranges and wild cards): /\b[A-Z]\B*\b/g \b = word boundary [A-Z] = all letters between A and Z (all capitals) \B = anything but a word boundary (i.e. a character in a word) \* = repeat 0 or more times You really should be able to learn this yourself if you want to be a decent programmer, especially if you want to do perl. [learn to fish instead of asking for a fish]( http://www.regular-expressions.info/wordboundaries.html)
I'd do something like this (the \s at the front is assuming you're getting these words in a long string. If you're getting them one word at a time, get rid of that and use ^ ) /\s[A-Z][^A-Z]/g or for your specific example (again, \s assumes you're getting this in a long string. Use $ instead if you're getting them one word at a time): /L\S*n\S*m\s/g
I honestly hope you have no plans of becoming a programmer... I don't think I've ever seen a complete and useful program that doesn't use regexes at some point.
Please don't try to become a software engineer.
Thanks for sharing this. I've never used \b before, and I can think of a few places where my code was complex because of it.
His blog entries about Perl one-liners were regularly posted on proggit. Here's the first part, with links to the other parts: [Famous Perl One-Liners Explained, Part I: File Spacing](http://www.catonmat.net/blog/perl-one-liners-explained-part-one/)
OR... Just write an AUTOLOADER routine to dynamically create your setters and getters
You still have to define methods your object supports. Otherwise you autoload anything - which is a bad thing. It's much nicer to use simple modules to do this and forget about the whole thing.
You could use a helper to determine which methods you support and which you don't, and then you can share that between `AUTOLOAD` and `can` so that you don't break the latter. Or you could do the simple thing and use a module, just as you say.
This looks pretty impressive. Rewriting my multi-threaded programs from perl5 to perl6 is going to be interesting. Big thanks to jnthn!
Interesting, the later ideas are closely related to Flow Based Programming, in which components push and pull data from streams to achieve asynchronous and concurrent execution. 
It is, but it would be even nicer if the terminology wasn't reinvented in such a cute way. Streams, promises, futures, channels are all very familiar in other languages, so why not at least borrow the existing names? Keep and break is almost too cute. 
Have a look at [`perldoc perlop`](http://perldoc.perl.org/perlop.html#s/PATTERN/REPLACEMENT/msixpodualgcer) if you need a refresher. The `/e` flag means to treat the REPLACEMENT part as a Perl expression to be evaluated. We can infer that prior to this statement, `$pool_oid` contained a raw encoding of the OID, and this translates it into a textual representation. The regular expression `(.)` matches each byte, and `sprintf('.%u', ord($1))` translates the byte into a decimal ASCII representation with the delimiting period. Presumably this wouldn't work with your example since "3375" is too big to fit in a byte, but if the string was a utf-8 string then it presumably could be encoded character-wise instead of byte-wise. 
Awesome thanks!
##AUTOLOADER is one of those tools that for every problem you solve, you create more problems. Generating the accessors as static methods at compile time is far more useful, and far more resilient. For instance, how does one wrap an AUTLOAD method ala `around`, `before`, `after` ? And how does one programmatically list all the methods a class provides if the methods are AUTLOADed when invoked? Now, if you wanted to have an object respond to *any* method name at all with a resulting action, for instance, a wrapper around a hash with on-demand per-instance methods, then maybe AUTOLOAD would be useful. However, to just define methods that are essentially static as soon as the file is sourced, AUTOLOAD is more cancer than cure. ## Alternative Solution If a single dependency is acceptable, and you're doing nothing more than the limited accessors described in this document, I highly recommend `Class::Tiny`, which for lightweight things, especially cases where you want lazy-loaded values, is ideal. package Point; use Class::Tiny qw( x y ); If you wanted some defaults that were lazy-set if not passed at construction: package Point; use Class::Tiny { x =&gt; sub { return 0 }, y =&gt; sub { return 0 }, }; Which I'm sure you'll find much simpler than the applicable `Moo` or `Moose` code to do the same. package Point; use Moo; has x =&gt; ( is =&gt; 'rw', lazy =&gt; 1, builder =&gt; sub { return 0 }); has y =&gt; ( is =&gt; 'rw', lazy =&gt; 1, builder =&gt; sub { return 0 }); And even more code do to that in Moose ☺ 
Off-topic: the front image is that of Dubrovnik, Croatia in case anyone is interested. (I have to promote my country :)). 
Fortunately, several P6ers claim to be generally averse to [too cute](https://www.google.com/search?q=site%3Airclog.perlgeek.de+inurl%3Aperl6#q=site:irclog.perlgeek.de+inurl%3Aperl6+%22cute+today%22). Why not [join #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) (busiest between around 3-4am and 6-7pm EST) and make your case? That said, I'd say the most urgent thing right now is to specify the *semantics* of P6's high level concurrency constructs, implement them in Rakudo (just Rakudo/JVM at the moment), and then try them out in a variety of scenarios. Edited to fix some sloppy writing.
`.` matches a character not just a byte, so it would DWIM on a utf8 string actually
wow, what? is this even possible?
Well, on the semantics at least, I'd say jnthn's instincts are great. 
I didn't know that cpanel was compiled perl, are there any tools available? Also i wonder why so little support to the project of this guy.
&gt; Also i wonder why so little support to the project of this guy. [The project seems a little heavy on the promises and light on the deliveries](http://perlmonks.org/?node_id=1061711), to me.
If it is so easy to speed up any random Perl script, why wasn't there any discussion about it earlier, even as just an idea? And by THIS Christmas, too? Where's the catch? Convince me and I'll pledge something.
Very interesting. But why does it need a kickstarter?
https://metacpan.org/pod/B::C
In 1996, Malcolm Beattie (now retired) created the perlcc compiler suite made of the B::C and B::CC compilers for Perl 5, using the B compiler backed directly into Perl 5 core. The B backed is still part of Perl 5 core. B::C hides source code, optimizes startup time, and does not optimize runtime; B::C was broken for a long time, but in 2008 Reini Urban fixed it, and now cPanel compiles their high-magic Perl 5 code with it. B::CC does the same as B::C and also does optimize runtime. I went to Houston and worked with Reini in 2012 to see if B::CC is salvageable, unfortunately it is not. Neither B::C nor B::CC is currently part of Perl 5 core, so you have to install them after you have main Perl installed. In many ways, RPerl is like B::CC, it creates optimized C/C++ code that is compiled to binary and is 100% equivalent to and compatible with the non-compiled normal Perl 5 code. The difference is that RPerl is (initially) restricted (R!) to low-magic Perl 5 code, and also RPerl uses Ingy dotNet's awesome Inline modules which did not exist in 1996.
Funny that chromatic should give a link to my recent "Perl 5 Optimizing Compiler, Part 9" post on Perl Monks, considering he doesn't actually post or reply of the points therein.
srynearson1 is correct, new projects will benefit by using RPerl from the get-go, and "key parts of legacy code" can be upgraded to RPerl for an overall performance increase. Our minimum $100 Kickstarter goal was quickly met, thanks to friends of Perl on Facebook. Hopefully some friends of Perl on reddit will also step up and back RPerl on Kickstarter!
Not my kind of Perl. For your code to get into the "fast" section of this interpreter, it needs to follow a huge list of don'ts, including: * no coderefs * no undef * no taint mode * no BEGIN/INIT/END etc. * no utf8 Nothing I write would be out of magic mode long enough to get enough benefit from the optimisation. And even if it did, given that computing power is cheap, and wetware remains expensive, I'll stick with the full-powered version backed by p5p over this kickstarter. Paraphrasing Henry Spencer, "Those who don't understand Perl are condemned to reinvent it, poorly" 
It is not easy to speed up any random Perl script. RPerl requires the use of low-magic Perl 5 and an advanced compiler toolchain to achieve the significant runtime performance benefits. Also, it has been discussed many many times before, and as you can see from my comments above there was the old B::CC compiler in addition to other attempts to speed up Perl 5 over the years, ultimately none successful. There is no catch to the inevitable release of RPerl on Christmas day, it is a Perl holiday tradition which we should proudly uphold. Please check out the Kickstarter page and http://rperl.org for more info, then let me know if you have any questions. Did I convince you to pledge something? :-)
We need a Kickstarter campaign because RPerl is Free &amp; Open Source software, and we are not getting paid by any corporation to do the actual programming to create RPerl.
I've spent enough time responding to the previous editions.
mp_at_work, you may be right, if you only ever write high-magic Perl and refuse/cannot write low-magic Perl, then RPerl isn't for you. For those of us who want our Perl to run super fast, RPerl is the only option. Remember, you can put your low-magic Perl into one single subroutine and then only compile that subroutine with RPerl.
Well if you keep on hatin' then I'm gonna keep on debunkin'
That … doesn't answer my question. There are gigabytes of Perl code out there which match the same criteria. Nobody asked for funding. Is there something about the project which requires you to buy hardware or pay staff, etc. so that it requires funding upfront before you can begin? Most kickstarter projects involve the manufacturing of physical objects, or financially demanding activities like making a movie. Also isn't there a Perl Foundation which gives grants for this kind of thing?
I've been working on RPerl since January 1st, 2013 and have not received any income so far; the time has come that I've got to pay myself to continue working on the project, like I said we don't have a corporation or other outside entity funding development. There is an entire section called "Open Software" on Kickstarter, you should look it up. The Perl Foundation does give grants and I'm working on that in addition to the Kickstarter campaign. Does that answer your questions?
srynearson1, I believe RPerl could provide you with major speed benefits, please consider making a generous pledge on Kickstarter!
When was the last time you worked for 11 months (on-and-off!) with no pay on a free and open source software project? Tell me why it doesn't feel right.
I've never done that, but that's not really an argument. Are you saying you've worked on this full time since January?
My post says "on-and-off", so it has been at least part-time since January, and full-time for probably half that.
Also, "it still doesn't feel right" isn't really an argument either. Again, tell me why it doesn't feel right?
This is a free and open source software project that will benefit the entire Perl community. Projects like RPerl are why there is an "Open Software" section at Kickstarter.
http://www.kickstarter.com/discover/categories/open%20software
It is crazy to write C (and make it properly interface with Perl) when you can have RPerl do it for you. Just as crazy as writing assembly when you can have a C compiler do it for you.
Jive turkey? How so?
Hey knock yourself out. That's what open source is all about. Personally, I don't get why you would invent a new dialect for what is essentially embedded C, a problem already solved twice with XS and Inline::C 
There are a number of placeholder files, I think these are the ones you are looking for: https://github.com/wbraswell/rperl/blob/master/lib/RPerl/DataStructure/Array.cpp https://github.com/wbraswell/rperl/blob/master/lib/RPerl/DataStructure/Hash.cpp https://github.com/wbraswell/rperl/blob/master/lib/RPerl/Algorithm/Sort/Bubble.cpp 
Please remember RPerl is still alpha software. Here's a link to installation instructions so you can at least get the tests to run: http://rperl.org/use_rperl.html
Sometimes vanilla Perl is not fast enough for me. And sometimes it eats too much memory. I wonder if RPerl can help in the memory usage aspect.
And many other supporting files to make them work. Now go get it to run and then come back and tell me what happened. http://rperl.org/use_rperl.html
mp_at_work, RPerl converts low-magic Perl 5 code into Inline::C and Inline::CPP code. The reason to do so is that Perl programmers want to program in Perl, not C or C++, and certainly not XS!
RPerl can compile into C/C++ operations that use either Perl data structures (Perl-data mode) or C/C++ data structures (C-data mode). When using RPerl in the C-data mode, then you will have significant memory savings, and you may also have lesser memory savings in Perl-data mode.
In the video you mention that rperl will be released under the same license as perl, but perl is free-of-charge for any use. What gives?
Every kickstarter falls on that criteria.
Perl cannot be re-sold without source like BSD licenses allow. That is the kind of commercial use I'm referring to.
So I can use rperl for enterprise work? You might want to clarify your FAQ, as it makes it sounds like a CC non-commercial license. Those are a clusterfuck.
Fixed! http://rperl.org/faq.html#faq_how
Cool, thanks.
Oh, he's *that guy*. Yeah, I'm going to pass on this one.
HATERS GONNA HATE potatoes gonna potate
So you're saying you'd rather write Inline::C than Perl? NOT ME!
Lots of people work for free on open source stuff, and thats our choice. If someone wants to have a kickstarted around it, I'm cool with it. I've considered something similar for Catalyst at times, although it was more about writing docs than code, but still the same thing.
This is absolutely not true. As I said, the majority of kickstarter projects involve things which are financially demanding, like making a movie or manufacturing a physical object. Creating software, which involves only time, is the exception, not the rule. 
You think programming computers requires only time? No specialized equipment?
We will start by compiling low-magic Perl 5 into Inline::C and Inline::CPP, I've already got the basic data types and hand-compiled operations working with the benchmark code, so I'm afraid your assessment is invalid. We are not setting the bar too high, but JUST high enough.
Well, no. Honestly not sure what your point is. Programming computers normally just requires … computers. Which presumably you already own or you couldn't be posting on reddit. Recording music, assuming it's not wholly instrumental doof-doof music, is quite a complex undertaking. 
I contend that low-magic RPerl is so different to Perl that the mental context switch between them is as big as if you had switched languages. If it is not so for you then you are likely not using much of Perl's expressive power. &gt; Perl programmers want to program in Perl Indeed they do, and RPerl does not support that because low-magic RPerl is nothing like Perl. Again, I'm not concerned that you are doing this. My problem is mostly about your assertion that not following your low magic commandments leads to buggy Perl. 
I would most definitely write Inline::C than low magic RPerl
CGI, my friend.
Well I suggest you speak to a couple of professional musicians some time.
Aw, that's not a modern scientific graph library for Perl. It's a cloud graphing service with social aspects, that happens also to have a Perl API. [These](https://github.com/run4flat/PDL-Graphics-Prima) [are](http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;ved=0CEMQtwIwAw&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DWILd2XTz3F4&amp;ei=GsaWUteOHs_joASutoDwBQ&amp;usg=AFQjCNF-U4ddfXcb0d1VOPCXHiTyVoGssg&amp;bvm=bv.57155469,d.cGU) [modern](http://www.github.com/drzowie/PDL-Graphics-Gnuplot) [scientific](http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0CDwQtwIwAg&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhUXDQL3rZ_0&amp;ei=d8eWUq62MYbXoAT0roKwCA&amp;usg=AFQjCNEH4ZxTfGSQp-ByKRloYKXAE9zh4Q&amp;bvm=bv.57155469,d.cGU) [plotting libraries](http://pdl.perl.org/?docs=Graphics/PLplot&amp;title=PDL::Graphics::PLplot) for Perl (well, for [Perl Data Language](http://pdl.perl.org) -- but then, that's the best scientific analysis package available for Perl). (Speaking of which, if you want to write a plot.ly interface for plotting Real Data, you should ping the good folks at the PDL mailing list -- perldl@jach.hawaii.edu. There are many helpful people there who can get you going.)
The context switching issue is addressed by RPerl's 2 very different compile modes: Perl-data mode and C-data mode. In both modes, RPerl uses C/C++ operations wherever possible. In Perl-data mode, RPerl uses Perl data types when possible. In C-data mode, RPerl uses C/C++ data types when possible. If the low-magic code to be compiled is relatively segregated from the other high-magic code (or if there is no high-magic code), then you would want to use the C-data mode, because it will spend most of it's time in C-world and will invoke the RPerl typemaps when performing the less-often context-switching back to high-magic Perl-land. If the low-magic code to be compiled is relatively interleaved with the high-magic code, then you would use the Perl-data mode, so the data structures always stay in Perl format and there is pretty much no context switching at that point.
You say low-magic Perl is nothing like Perl. This is crazy talk. Low-magic Perl is a subset of Perl, and is by definition a "small" Perl. Also, nowhere do I say that you will have buggy code if you do not follow the low-magic commandments, so you're wrong again.
That is so very, very silly of you. But okay, good luck with choosing the harder path for no reason!
You're not making yourself look better by posting like this. 
Oops I missed the word "mental" in your "mental context switch". Low-magic Perl starts to feel natural once you do it for a little while. Just try. Don't be resistant to change that can help you.
For anybody who has read "Higher Order Perl", no coderefs is a killer. Perl without coderefs and closures is basically Java. No utf8 kills anybody dealing with text that the user might enter, and no undef kills any remaining chances of backwards compatibility.
"bet bits of magic"? unicode and closures are some of the most basic and important features of perl...
why would i pledge to your project? your terminology is insane (closures are high magic? even fucking c++ has closures), you talk in biblical language (always a huge red flag in technical matters) and i dont see the point of making a bad c out of perl with none of the advantages of c.
FTP essentially has two operations... put and get. You'll have to just upload a new version of the file.
Just over-write the existing file. Editing would -probably- take more resources than simply over-writing. I'm not sure how you'd -edit- a file via ftp (which is basically just for transferring files). But maybe I've misunderstood. Everything has pitfalls and trade-offs of course but that's my simplistic take. P.S. there are better ways than ftp to transfer a file (e.g., sftp, https post etc.)
thanks. 
I got the overwriting working. I started with ftp "just because" what is a better method of transfer and why? I am hosting the file on a shared host.
Cool, keep rocking with your app. At some point, you can switch to an encrypted method of uploading (e.g., sftp) so that your login information is not visible on the network.
huf, I'm sorry you don't agree with my terminology, I spent a few weeks at least working with members of the Perl 11 team and then Perl Monks to figure out what should be considered "high magic". We can address the need to compile high-magic Perl 5 once we have the low-magic compiler working. I'm sorry if you don't like my tongue-in-cheek old English ("Biblical") writings, this is a well-known tradition among the Perl community. Heck, we call Larry a Saint, we have Popes and Monks and Wizards, etc. The point of RPerl is to help Perl 5 run fast, if you "don't see the point" then maybe you don't mind if your code is slow, and RPerl isn't for you.
Mount your ftp destination via ftpfs and then just work with it like you would with a local directory.
On CPAN, it says that the 'new' constructor for SFTP makes a call to Net::SSH::Perl. Looks like that one has an arguement to pass a port. I'd type it out for you, but I have enough problems typing normal sentences on my phone. Let alone Perl. Tl;dr: CPAN and other docs are your friend. Link: http://search.cpan.org/~dbrobins/Net-SFTP-0.10/lib/Net/SFTP.pm#Net::SFTP-&gt;new($host,_%args)
Thanks.
Thanks, I am trying to pass the port like this: my %args = (port =&gt; '21098'); my $sftp = Net::SFTP-&gt;new($host, %args) or die "Can't open $host\n"; $sftp-&gt;login($user, $password) or die "Can't log $user in\n"; But, I continue to get an error along the lines of "Can't connect to (yourHost), port 22. So, it is still trying to use port 22, not 21098 from %args. 
It passes ssh_args (as a hash) to the Perl SSH module. Meaning that you need to put the ssh_args hash in your args hash. So something like: %args = (ssh_args =&gt; [port =&gt; 21098]) There. Now I've gone and typed perl on my phone (it wasn't pretty). No idea how it will work, but this is what I have picked up from using the docs. Honest, the docs are your friends. They don't bite. Usually. Except for that one that we hide in the back corner. But nobody uses that module anyway. 
Thanks, I think I understand now. Unfortunately, I am getting some permission denied errors, so Ill try to sort that out. 
&gt;On one hand, The Architects *may* have a point. You may be right to ask them *why* they feel Perl is not right for production usage. When I have these conversations, unfortunately, some of our leaders simply don’t like a language, or they had a bad experience with it previously, or they don’t like it because it isn’t their preferred stack; this is worse when they are zealous in favor of ruby or java- this is effectively a religious war, and you were better off Doing Good Work by yourself. Sometimes, they have a legitimate gripe or concern, like long-term supportability (from a pure languages perspective). &gt; &gt;At the same time, you need to have data-in-hand to back up your arguments as to why it’s appropriate. These are the discussions that need basis in fact, not feelings. Some arguments you may run up against are “It uses too much memory.” or “It runs too slowly.” – make sure you have performance use cases IN HAND, BEFORE these questions are asked. This data can go a long way with Architecty-type folks. &gt; &gt;In my org, we use perl in both our front-end and our back-end. Perl does customer-facing or front-line work like managing customer support functions, or order processing (in production). Perl does operations work, like providing monitoring and log file analysis (in production). Perl does security work, like orchestrating other tools to scan our networks, and ensure compliance with key systems (in production). Like any language, whatever you’re implementing needs to be done sanely and efficiently- the language is not largely relevant if your code is garbage. This is all being done at the level of a Very Big Company. &gt; &gt;Keep your code clean, be able to explain what it does, how to rebuild the environment from scratch (if necessary), and provide use-case based factual analysis defending your performance. &gt; &gt;The key is to use the right tool for the job. If perl happens to be the right tool for your use case, then that is fantastic. Be open to what Archie has to say- sometimes they have good ideas and points(‘There’s More Than One Way To Do It’). But stand by your guns.
[Here we go - github search.](https://github.com/search?l=Perl&amp;q=overload&amp;ref=cmdform&amp;type=Code) I recently saw some interesting overloading in some module on CPAN, but can't remember which one.. 
This is a weird bug in Net::SFTP (actually Net::SSH::Perl) and is the reason I stopped using both. I recommend [Net::SFTP::Foreign](https://metacpan.org/pod/Net::SFTP::Foreign) instead. The author [compares his against other SFTP modules](https://metacpan.org/pod/Net::SFTP::Foreign#Net::SFTP::Foreign-Vs.-Net::SFTP-Vs.-Net::SSH2::SFTP).
_Most_ of the time, using overloaded operators is frowned on for the same reasons it's frowned on in other languages -- it's unexpected behaviour. I wouldn't think to try to add to objects together, even if they were the same type. I would expect a class method that can handle that (probably named `add`). That said, [DateTime](http://search.cpan.org/~drolsky/DateTime-1.03/lib/DateTime.pm#Overloading) overloads some of the basic operators, but stops there. 
I've worked at lots of banks and I know others that work at lots of banks too. EVERYONE uses Perl. 
Not something I would consider for real code, but [Quantum::Superpositions](https://metacpan.org/pod/Quantum::Superpositions) uses it extensively (and so does it's slightly less magical cousin, [Perl6::Junction](https://metacpan.org/pod/Perl6::Junction)). I remember seeing [this monstronsity](http://www.perl.com/pub/2006/06/01/fear-api.html) many years ago. It seems to have disappeared from CPAN, but you can get the idea from the article.
You haven't missed much. It has absolutely sucked since belg4mit gave up the role as editor. There has been nothing amusing, clever, insightful, illuminating, or even merely interesting since rjbs took over. It'd probably be best if he resigned. He really has no talent for this at all.
For what type of applications? This would be useful to know to break down the perception that Perl is only useful for sys admin or small, once-off uses.
Thanks!
[Reply by tchrist copied below.](http://mortoray.com/2013/11/27/the-string-type-is-broken/#comment-5923) &gt; Don’t see any major problem with Perl: remember that `\X` represents a grapheme cluster: &gt; $ echo noël | perl -CS -nle 'print reverse /\X/g' &gt; lëon &gt; Which works no matter the normalization: &gt; $ echo noël | nfd | perl -CS -nle 'print reverse /\X/g' &gt; lëon &gt; $ echo noël | nfc | perl -CS -nle 'print reverse /\X/g' &gt; lëon &gt; There does exist a [Unicode::GCString](http://search.cpan.org/perldoc?Unicode%3A%3AGCString) module that allows you to do `substr`, `index`, `length`, etc. operations on grapheme clusters instead of on individual code points. Basically, it turns a string into a sequence of grapheme clusters instead of a sequence of code points. But for simple enough stuff, you can just use `\X`. &gt; $ echo ñôël | nfc | perl -CS -nle 'print scalar( () = /\X/g)' &gt; 4 &gt; $ echo ñôël | nfd | perl -CS -nle 'print scalar( () = /\X/g)' &gt; 4 &gt; $ echo ñôël | nfc | perl -CS -nle 'print length' &gt; 4 &gt; $ echo ñôël | nfd | perl -CS -nle 'print length' &gt; 7 &gt; So don’t do this: &gt; $ echo ñôël | nfd | perl -CS -nle 'print scalar reverse' &gt; l̈êõn &gt; Do this: &gt; $ echo ñôël | nfd | perl -CS -nle 'print reverse /\X/g' &gt; lëôñ &gt; It’s up to you whether you want to deal with code points or which grapheme clusters. Once you learn the difference, it’s pretty easy.
😸😾
*If you don't like or are not interested in P6, please ignore this comment beyond the first two links.* ----------- First, a couple rosettacode tasks. The first task is [Matrix exponentiation](http://rosettacode.org/wiki/Matrix-exponentiation_operator#Perl). The link is to a P5 solution. The overloading is introduced by the `use overload ( ... ) ` statement. The P5 solution to this first task is followed by a P6 solution for the same task. In P6 overloading of this sort is introduced by the `multi infix:&lt;*&gt;` statement. The P5 and P6 solutions to [Formal power series](http://rosettacode.org/wiki/Formal_power_series#Perl) also both involve overloading. ------------- Here's my favorite Perl 6 advent calendar entry that touches on operator overloading: [4.7kΩ ± 5%](http://perl6advent.wordpress.com/2012/12/18/day-18-formulas-resistance-is-futile/) ----------- For more general info on overloading in P6: * [The Overloading Synopsis](http://perlcabal.org/syn/S13.html). * "we don't really talk about "operator overloading", because it falls out from multiple dispatch and the fact that operators are just funny names for functions" ~~ [Larry Wall on IRC early this year](http://irclog.perlgeek.de/perl6/2013-02-18#i_6466463). * "Perl 6 explicitly anticipates and supports modules and applications changing the language’s syntax for their specific needs. Defining custom operators is just one example of a place where we change the language syntax itself, but Perl 6 also allows the dynamic addition of macros, new statement types, new sigils, and the like." ~~ Patrick Michaud in the 2009 advent entry ["The Perl 6 standard grammar"](http://perl6advent.wordpress.com/2009/12/24/day-24-the-perl-6-standard-grammar/)). ----- Finally, nothing to do with operator overloading, but possibly of interest given your original example: [How Perl6 treating decimals as rationals helped me solve a problem](http://www.perlmonks.org/?node_id=1004081)
Thats fine as long as the defaults for x and y is the same, but it gets rather messy as soon as you have a **lot** off accessors, so you end up writing a wrapper of some description to make it easier. For instance, doing what I'm doing here, with any other OO Framework, is rather hectic: https://metacpan.org/source/KENTNL/GraphViz2-Abstract-Node-0.001001/lib/GraphViz2/Abstract/Node.pm#L23 To even come close to that sort of ease of use with `Moo`, I'd need something like sub _attr { my ( %accessors ) = @_; for my $key ( keys %accessors ) { has $key, ( 'is' =&gt; 'rw', 'lazy' =&gt; 1, builder =&gt; sub { $accessors{$key} } ); } } Just to save typing. ( And I've done this in the past, though now I just use Class::Tiny because its more reliable and less magical )
&gt; Interactive, publication-quality plots in your web browser "Just what I've been waiting for" said no one, ever.
Constants: [Acme::Roman](http://search.cpan.org/~ferreira/Acme-Roman-0.0.2.12/lib/Acme/Roman.pm). Operators: [Acme::Dot](http://search.cpan.org/~ovid/Acme-Dot-1.10/lib/Acme/Dot.pm).
Thank you
About halfway through this article I realised that I was thinking very seriously about the question "how long is a piece of string?" 
&gt; It’s up to you whether you want to deal with code points or which grapheme clusters. Once you learn the difference, it’s pretty easy. Is it sensible for (for instance) `reverse` to operate on codepoints by default? I'm having trouble thinking of a situation where that's the Right Thing.
Or when "yellow smiley-ball with ears in profile" was not considered text. Or when `\d` didn't match counting rod numerals.
So now Perl6 is just another JVM language...why would anyone use it over Scala?
Because it's not just a JVM language. The JVM is just one of the VMs it is designed to run on. Scala (to my knowledge) can *only* run on the JVM. Anyway, by your logic (to the extent that you have explained it): "Scala is just another JVM language. Why would anyone use it over Java?"
Just that it's been around for a long time, and there is a ton of legacy code floating around. It also still does what everyone wants it to do. It's a fast, reliable language that is extremely effective.
Where are you running this? Some shared hosting environments have time limits and kill any script which runs over X minutes. 
Yup and it gets better every day. One of the more mature implementations Rakudo now targets the JVM too.
Show us the source!
I think your solution has problems that are unrelated to compression. I can't imagine what I might use a 400 GB file for. Yes, I'm sure there are legitimate uses of a file that large. At Pixar, for example. Maybe I'm just a simple country boy, but I'd like to believe that I would find a way to make that data manageable. I realize this is off-topic and not helpful, but I'm uncomfortable viewing this as either Perl problem or a compression problem. This is an analysis problem.
Perl6 is a specification designed to run on multiple backends (there are several worked on, JVM, and .Net runtime, plus native C as well, and possible javascript). Scala is a nice language, I've enjoyed playing with it a lot. Why use P6 over Scala, well its going to be about what you enjoy and what you get paid to do. I like Perl5, and get paid to use it, so I am naturally interested in P6 since even though Perl5 and Perl6 are independent projects (Perl6 is no longer seen as the replacement for Perl5, and Perl5 will continue to see new features and development for as long as people are still getting jobs for it) both P5 and P6 share many common philosophies. If it doesn't seem like fun to you, give Scala a try, since that might be more to your liking.
&gt; As a customer of *(something)* I receive an affiliate payment for the successful referrals from the links on this page. Maybe you should be more explicit that you're just spamming.
tar cvf - mystuff | gzip | ssh myserver 'cd /my/work/dir; gzip -d | tar xvf -'
Is that similar to what Cython is doing to Python? (if you are familiar with it)
Yes RPerl is similar to both Cython and RPython.
I overloaded this in my ORMResult.pm use overload '&lt;&gt;' =&gt; \&amp;iterator, fallback =&gt; 1; so I can use it like this while (my $obj = &lt;$result&gt;) edit: sadly I found no Syntax to write it in one line. Something like: while (my $obj = &lt;Class-&gt;find()&gt;) Perl gets confused by the -&gt;
&gt; 400GB is not even worth a double take in this day and age. Bullshit. A 500 GB hard drive is $50. 400 GB of RAM is probably a few thousand. Do the math.
I can understand the need to use 400 GB of data. I was saying that you generally don't need it in single files of that size. But maybe I'm just old fashioned... or just wrong :)
Let's see if I get this right - you have an Excel file that has a list of IP addresses. Next, you have a router config template and you need one config file created from that template for each IP address in the Excel file? If this is what you need done, start looking into how to open and read files from Perl. Its fairly easy and should take you all of 2 mins to figure out. By doing this you can now read the Excel file. Note: If the file is pure Excel, you might need an Excel-reader module installed in Perl. I am currently on mobile so can't search/link the module but Google is your friend. This should get you started in the general direction. I am currently on mobile so I can't link the relevant tutorials,etc. Sorry. I should be home in about 5 hours and if you are still struggling at that point, shoot me a message and I will show you in code how to do it. :) PS. I wish I was a Cisco Engineer. Its been my dream since 8 years now (since I was in uni) but they always shoot me down :(
* [Excel 95-2003](https://metacpan.org/pod/Spreadsheet::ParseExcel) * [Excel 2007 Open XML](https://metacpan.org/pod/Spreadsheet::XLSX) * [Template::Toolkit](https://metacpan.org/pod/Template)
Another Advent calendar, this one by Paul Evans, dedicated to Futures. This is not a dedicated site like the other advent calendars, but is part of Paul's blog. I have put together all the calendars together in a [single feed](http://xrl.us/perladvents), in case anyone's interested.
Or simply [Spreadsheet::Read](https://metacpan.org/pod/Spreadsheet::Read) for whatever spreadsheet data you have.
So I had to do something similar in a project at work. You can have two text files, 1 for the template, and 1 for list of key/value pairs. In the text file call each variable something with special character that won't occur anywhere else like %VARIABLE_NAME% Then use your perl script to find/replace on that value... reading variables from the text file. Very simple solution that should work, although there may be much more elegant solutions out there :) If you have specific question on how to achieve the above, shoot!
Would love to see more with asynchronous futures using his io::async::loop. All the examples I have seen use "-&gt;get" which is synchronous... Will continue reading posts, keep up the good work
i always use %%TAG%% or &amp;&amp;TAG to avoid confusing my editor when it's highlighting my syntax
Well, you can use the Net::FTP module to write a Perl script to grab/upload the json file. As for generating a JSON from a CSV, trying using [this](http://search.cpan.org/~makamaka/JSON-2.90/lib/JSON.pm) module. If you still can't figure it out, post your question to [perlmonks](http://perlmonks.org)
Thanks, I was able to write the json in perl and ftp it with Net::FTP. I wrote an iOS app to grab the json and parse it with AFNetworking into an NSDictionary and display the text fields. It's pretty cool really, I am reading temperature, humidity, pressure, and light sensors I have setup in the back yard on my iPhone from anywhere I have an internet connection. It does not sound so spectacular when I write it down, but to realize it first hand is quite remarkable. 
You've just unknowingly asked one of the most "everyone has a different answer" questions in Perl: "which template system should I use?". For your needs, I'd recommend [Template::Tiny](https://metacpan.org/pod/Template::Tiny) for being pretty lightweight in terms of API and dependencies. If you want a more exhaustive list of template engines to do your own research, my [Task::Template::Benchmark META.yml](https://github.com/illusori/Perl-Task-Template-Benchmark/blob/master/META.yml) dependencies file has a list of 30-40 different Perl template engines to use as a jumping-off point. Really though, save yourself the time and just use Template::Tiny for this use case. :) For file reading and saving, your jumping-off point should be the docs for [IO::File](https://metacpan.org/pod/IO::File). For spreadsheets, I'll defer to everyone else's suggestion of Spreadsheet::Read.
Got a good intro as to why I would want to use Futures and when?
Futures are asynchronous programming constructs. [Wikipedia's page on them](http://en.wikipedia.org/wiki/Promise_%28programming%29) can serve well as an overview. ----- For those interested in Perl 6, note that futures (called Promises) are a standard part of P6. This [example: asking for the Nth prime but not waiting for the result](http://jnthn.net/papers/2013-npw-conc.pdf#page=10) is from a recent talk given by jnthn.
&gt;Too much, how to pick? &gt; &gt;The biggest problem is probably that there are so many different technologies. Which one to learn? &gt; &gt;First of all you need to decide which fields might interest you, but you should also check companies that are hiring in your area (or wherever you'd like to work) and see what are their requirements. Based on the ads you can have a direction. Good advice. It's great having a favorite programming language, but you have to be willing to take the "boring" language jobs (i.e. Java) to land a job in a lot of areas. Sadly, most Perl shops I've applied to in the past few months are looking for people with 5+ years of Perl dev. experience, which kind of sucks for people just out of college. 
We've got several Perl job openings where I work. It requires relocation though.
_Mmm, relocation_. Link?
I am a perl developer primarily (though I have also worked doing ruby, python, javascript, and *sigh* even php.). I have never had a hard time finding open perl positions locally (portland, oregon), or remote. Typically when I decide to move on I end up with multiple offers and get to pick.
Yeah my company would hire people because they know perl. Lately we've been hiring good people and training them in perl because it's so hard to find people who know it. 
Where do you work? Feel free to PM me.
Where do you look when you're ready to move?
Jobs.perl.org, dice.com, jobdango. At this point I also get emails from recruiters every 2 weeks or so.
Do you happen to work at rentrak?
Template::Tiny is a module name, modules (aka libraries) in Perl use :: to delimit the name into namespaces. There's no real hard and fast rules on how this is done, but people tend to stick to a few conventions. A ::Tiny module is one of those conventions, they generally have no dependencies other than core modules (ones that come with Perl itself) or other Tiny modules; and they generally follow the principle of "simplicity is more important than feature-bloat or extreme optimization". That makes them pretty good if you want to get something simple done without fuss or a steep learning curve.
So you're saying that perl.org would let me host my own, competing, advent calendar? In what sense are you using the word "fork" here? Not in any meaningful technical sense, it seems. rjbs has been dumb and blind to all constructive criticisms and ran the advent calendar into the ground. See his above flippant dismissal of my previous comments for an example. Your suggestion of creating a new one has merit. I suppose I was holding out hope for him to resign sooner rather than later but unless that situation changes than next year you may see an advent calendar with some content that is as not as dull and humourless as the current dreck. Now, proceed with your downvotes!
The articles are written by multiple people. In fact, so far as I'm aware, everybody who offered to submit one was given the chance to have a slot. So, y'know, either contribute something, or expect us to ignore your entitled whining. Your choice.
Okay perhaps it's because I have a background in technical writing but I think your use of the term "constructive criticism" may need some expansion or a definition. If for example you said "It would be nice if he picked more articles about X" or "I would love more articles with a tone like Y" *that* would be constructive in that he could use it to build a change to the current advent calendar. "[He should resign]. He really has no talent for this." doesn't seem in any way "constructive" at all.
Perhaps such a lack of selectivity is the issue. belg4mit clearly favored quality over quantity and meticulously edited each article. I had written some many years ago, I should know. Truly he considered himself an editor and had a sense of style and flair which is missing. I am not sure how many other ways I can say that. Advent articles used to be so lively and entertaining! Perhaps the soi-disant writer above can give the current editor and authors some writing tips.
http://job.listings.cpanel.net/ Edit: direct link to job postings. 
In my experience I never got as far as the writing on the old calendars because the code was almost invariably terrible; the current style may be less playful but at least now the advice is actually reasonable. Of course, if you wanted articles that were lively and entertaining, you could simply submit them with the writing already done like that and allow the editing process to focus on ensuring the technical quality was up to scratch.
I'm guessing you mean me. Considering I'm one of the authors you're decrying for a lack of lively entertaining style, I doubt I'd be of much use. Perhaps you can help me pick out which of 2009's articles best represents the style that you're suggesting is lacking now? That is the year quality was obviously favored over quantity because only 11 articles were published. 
Nope.
thanks prakashk!
Your last self-submit was affiliate spam. Is this one different?
And all the unicode support won't help you if you think it's ok to reverse string by reversing codepoints/graphemes/whatever. (Want examples? Think about RTL for example) 
From your description, it sounds like you've got a directory full of tar files which you'd like to move into their appropriate directory and then un-tar. This is the sort of thing Perl does in its sleep. :) Maybe try this: #!/usr/bin/env perl use Modern::Perl; use autodie qw/:all/; use File::Copy; my @tar_files = glob '*.tar'; # All the tar files in the curr dir. unless (@tar_files) { die "No tar files here. Exiting!\n"; } for my $tar_file (@tar_files) { my ($path, $row) = $tar_file =~ m/^LC8(\d{3})(\d{3})\d+LGN\.tar$/xms; say "Found $tar_file, with path $path, and row $row"; my $dir = "p${path}_r${row}"; say " so, dir is $dir"; if (! -e $dir) { say "$dir dir not found. Creating it..."; mkdir $dir; } move $tar_file, $dir; chdir $dir; system "tar", "xf", $tar_file; # If you also want to delete the tar file, uncomment next line. #unlink $tar_file; chdir ".."; } If you don't have that Modern::Perl module installed, you can install it by grabbing `cpanm` and installing it, or you can delete that line and replace it with: use strict; use warnings; **Edit:** Oh my, I don't think reddit does syntax highlighting. If you want that with some color, look [here](https://gist.github.com/uvtc/7837784).
&gt; Thanks for your time, monks. Where dya come up with "monks"?!? ---- If you don't get all the help you need here, you might want to post at [PerlMonks](http://perlmonks.org) too...
Boom, nailed it
Damn, you guys really are monks, thank you **SO** much!! Will report back with results!
Without posting an actual script to solve your problem for you, you would want to look into regular expressions.... which the solutions posted make use of. Yeah, I ended that with a preposition.
At this year's YAPC::EU (Yet Another Perl Conference Europe) about half of the talks contained a "we're hiring" statement. http://jobs.perl.org/ has 6 new openings added this month alone. When I was looking for a Perl position about 1.5 years ago, I had the feeling it was easy to get job offers. Edit: I recently heard that the OTRS AG employs quite a few perl programmers, and most of their developers work from home. I have no idea if they have open positions right now, but might be worth investigating.
I think the greybeards would frown on that. Pick up a copy of learning perl and modern perl.
Or....I could just watch a few videos and see what I think.
Perl is like voodoo. Better off reading the books: http://scienceblogs.com/stoat/2008/12/17/perl-would-be-voodoo/
thanks
Lots of fun to be had in Markov Chaining. And nice to see Charlie going back to his roots.
His [Perl tutorial](http://www.antipope.org/charlie/old/perl/perltut/) is a useful antidote to the "capital-M-modern" BS that is currently popular. I'm not saying you should follow it religiously, but it is the perspective of a smart person using Perl to make his life easier.
Perl comes with documentation available via the `perldoc` command (for example, `perldoc perlretut`). This documentation is also available online, rendered as html at http://perldoc.perl.org/ . If you look at `perldoc perlre` (the reference docs for Perl regular expressions), it directs newcomers to these two tutorial docs: * http://perldoc.perl.org/perlrequick.html * http://perldoc.perl.org/perlretut.html If you just want a general "intro to Perl 5" type tutorial, you might start with [perldoc perlintro](http://perldoc.perl.org/perlintro.html). Two recent general Perl 5 books which I'd recommend are [Modern Perl](http://modernperlbooks.com/books/modern_perl/chapter_00.html) and Ovid's [Beginning Perl](http://www.wrox.com/WileyCDA/WroxTitle/Beginning-Perl.productCd-1118013840.html). 
Do people use videos to learn other languages? I didn't know that was a thing but maybe I'm just getting old. When I bought a copy of Turbo Pascal it came with about 25 pounds of reference manuals. That's how I learned to code. (Presentation videos can be great for getting an overview on a new topic but learning a language from scratch seems very different.)
That's why I said 'to get a sense of it' 
I stand corrected. It IS voodoo.
Any time.
I learned Perl without continuous access to the internet, so I read the documentation instead of watching videos (which I find quite inefficient, with some exceptions like SICP). There are some free Perl resources that should be pointed out here: * [Perl Maven](http://perlmaven.com/) includes a free beginner tutorial. It isn't finished yet, but those parts that are available have very high quality. The site also offers paid content (incl. videos) which I do not know. * The [Modern Perl](http://modernperlbooks.com/mt/index.html) Book can be read online. It is a good summary of the language, and showcases idioms and best practices. It isn't a tutorial, but it is a good read wherever you are on the Perl learning curve. * If you see a tutorial in the wild, check it on [perl-tutorial.org](http://perl-tutorial.org/) first – too much stuff out there is outdated crap from the 90s. I just looked what YT offers in terms of tutorials. * I cannot recommend the “ScriptSocket Video” channel: CGI-centric, outdated technology, ignores modern best practices, not very good didactics. Doesn't indent code. Explains "lexical variables" in video 92 (too late). Many other playlists copy these videos. * The “PerlTutorials” channel has a very dated Perl tutorial. It is excruciatingly slow, but tends to explain in much detail. Even more outdated than ScriptSocket, and ignores modern best practices. Would not recommend, unless you want to unlearn some things later. * The “codewithjosh” channel has a couple of videos. Uses notepad.exe to write code (not very professional). Bad audio. Ignores modern best practices. Seems confused at times. Explains "lexical variables" in video 23 (too late). * “Gabor Szabo” has a couple of [introductory videos](https://www.youtube.com/playlist?list=PL1D7FB1B066E46746). He is the author of “Perl Maven”. Teaches modern best practices from the start. Some videos have poor resolution. Good subtitles. Youtube also contains many videos of talks from Perl conferences, but that isn't exactly beginner-friendly material. Should you be running Windows, you'll want to install [Strawberry Perl](http://strawberryperl.com/).
Wow, thank you so much! 
I might make some beginner videos, what topics are you interested in?
I think the "Learn Python the Hard Way" series would be a good template to follow.
Programming in Perl is about typing characters into a file, then running them through `perl` to see what they do. Videos are useless. Find the oldest version of the Perl documentation that you can ([5.8.8 is not bad](http://perldoc.perl.org/5.8.8/perl.html), but earlier would be better), pick out a problem you want to solve, and have at it.
The [Modern Perl Book online](http://modernperlbooks.com/books/modern_perl/) link may be a better starting point than the blog.
&gt; when they could be using something like MegaHAL instead [Or it's more modern incarnations](http://blogs.perl.org/users/aevar_arnfjor_bjarmason/2010/01/hailo-a-perl-rewrite-of-megahal.html) Edit: I'm gonna do that but not today, i should be working :P
There's also one [in Python](https://github.com/pteichman/cobe) if you feel polyglot today too, doing very similar things.
[Presenting Perl](http://www.presentingperl.org/) [1] has "[v]ideos and audio from conferences and workshops around the world." Some of those may be beginner oriented. [1] I am not exactly a fan of the site's color scheme, though it's something that could be easily fixed with Stylish/Greasemonkey.
If someone could develop a similar system to the Learn Python by Zed Shaw, I imagine there would be some good money to make. 
Looks doable, but isn't it too tedious?
It is. It seems to cover the bases though. Gives structure to the learning process. 
Interesting, I will look into it. Thank you!
Perl just isn't cool anymore. It's seen as old and archaic even though it's not really a fair view. I don't really know what we can do to improve the perception either. Perl 6 is still forever away for 'normal' use, the internal architecture improvements are taking time and even getting Moose/Moo/etc working and used can be challenging to people at times.
I think the pereption of Perl is starting to change again. I'm starting to see a bit more chatter about the active community, modern Perl, etc. The perception for a while was quite bad, but it looks like the community in general is fighting back against that perception 
What about P6? I'm probably the most willing of all folk to post about P6. (See [this PM comment](http://www.perlmonks.org/?node_id=1041369) for a sense of why.) Yet I'm deliberately keeping the flow of posts about P6 artificially low. I do that because the negativity toward P6 is sufficient that I fear the negativity will hurt P5, Perl, and P6. So I'm posting just enough to ensure folk who are paying attention realize it's alive and well. I could easily post one or more high quality P6 posts a day so this sub much better reflects the exciting stuff we see on #perl6 every day. So now let's see what the voting is like on this comment. :) **Edited** s/reddit/sub/
I hope so. I've written some Python and Ruby recently, and all I think is 'this is Perl but with some syntax sugar and the rest is more annoying'.
Yes, do that.
Perl already has some great communities. I'd go to [perlmonks](http://www.perlmonks.org) before posting here unless it's something particularly newsworthy. Also, Perl is just not trendy. I've been able to make a pretty good niche for myself because of its stigma. Most Python-espousers loathe Perl because it gives them too much rope and they end up hanging themselves. They cobble together some terrible code and then walk away thinking that Perl is "ugly" and "hacky". Perl users typically don't have any problem working in Python but not the other way around.
"old perl" can adapt a version system just like Java, where ver. 1.7 is called Java 7 - Nobody complains that Java is still at version 1 do they? Perl 5.20 should be called Perl 20. By all accounts, Perl 6 is a different language. It should be called something different so we can get rid of the confusion once and for all.
**Edited** to try distinguish between concerns over naming and support for P6. Would you support me and others posting about P6, if it has a name you support, in this sub?
That history is wrong, as it turns out.
Of course. But, the real bad thing is lack of optimism in the Perl community about p6 (or so I see it). I don't remember when was the last time we had some discussion about perl6 on perlmonks for example. All the new happenings in p6 world are mostly hidden in IRC/github logs. 
Sorry, I mostly do 6502 assembly and SNOBOL these days. Slightly more seriously... I've been doing apps in Perl that the community would not care about, such as a bike count management system, and a daemon to keep MailChimp lists and interests areas sycn'd with Workflowy (though I did release the Workflowy API). Even stuff they might care about, they don't, such as Continuity being a way better node.js before node.js was created. It took an epic amount of hype to get people interested in and caring about and learning Moose. Maybe if people don't feel like they're on the cutting edge, then no develop is that interesting.
Fwiw I post something P6ish about once a month at PM (mostly in either the news or meditation sections). (Even more so than here in this sub, many of the *comments* in the follow up threads at PM are negative, typically from the same half dozen or so posters, even though almost all "significant" *votes* are positive.)
Perl is awesome, but people are certainly leaning towards viable alternatives now like Ruby or Python. I love Python and use it frequently, but I find perl more useful for things I used to do with Bash. I actually learned perl this year too. I just feel like you have mostly the same use cases, and honestly I'm just much more familiar with Python, but I still see that the same problem can be solved sometimes more concisely in Perl than Python. Plus perl is Always on the distribution, and embedded devices.
Hey, I keep trying to get someone to write about Continuity for Perl.com.
After thirteen and a half years, you're blaming the Perl community for a lack of optimism? I cannot understand that.
Hi singe, Let's imagine that P6 one day offers a big enough advantage that you end up using it. Let's say it takes 6 years to get to that point. Would you be willing to just ignore daily posts about P6 here and at other Perl haunts for the intervening 6 years?
&gt; If reading any of the 2013 Perl Catalyst Advent articles has inspired you Frankly, I skipped all that advent-related stuff. Advent is, I suppose, something related to christianity which I tend to avoid a lot :) 
Have an upvote, 0 points for a reasonable question seems silly. I'm probably not going to play with P6 much until perl6 packages hit Debian. It is still useful to see what is going to be available in P6 even if I'm not actually using it yet. I can easily skim titles with P6 in to see if they are interesting.
It's not a utf8 string. Numbers &gt; 127 are encoded with [a flag and some bit shifting](http://msdn.microsoft.com/en-us/library/bb540809%28v=vs.85%29.aspx), so 0x962F.
Please post. Because of an upcoming change in day job, I'm finally going to have a combination of time and inclination to look at Perl6. I haven't really looked at it since the RFCs and Apocalypses, so a bridging guide of some kind would be awesome. 
You need two key ids for your code. The key id used to sign should be your key, the key id encrypted to should be recipient's key. Your signature command is failing if you're trying to sign with the recipient's key id because signing requires the private key. 
But I feel like in practice you would only do this with large datasets (I'm a bioinformatician) and would end up having to use something like c++ ... I'm curious as to how this scales... Any knowledge?
I'll add to that with a "and if that version is running on the JVM, I still don't care"
Makes sense. I'm trying the following but still now luck. my $file = $thisFile; my $key_id = 'myKey'; my $pass = 'pass'; my $signature = $pgp-&gt;sign( Filename =&gt; $file, KeyID =&gt; $key_id, Passphrase =&gt; $pass, Detach =&gt; 1, Armour =&gt; 1, ); my $is_valid = $pgp-&gt;verify( Signature =&gt; $signature, Files =&gt; [ $file ], ); my $key_id2 = 'theirKey'; my $plaintext = $pgp-&gt;encrypt( Filename =&gt; $file, Recipients =&gt; $key_id2, );
Why, when I go to the bar, do I see so many people order Bud Light when they've got Glenmorangie?
Rakudo P6 runs on the Parrot VM (and MoarVM). Would a stable and supported Rakudo be of interest?
Perlmonks? You mean the site that always has answers from 2007 or earlier? The dated information ends up being bad advice. Stack Overflow has largely replaced that site.
as a 43 year old, I know that the future of the language very much depends on developers under the age of 40
Why not start r/perl6 and post as much as you like?
But to answer your question, P6 posts wouldn't bother me too much so long as they are easy to spot.
The disadvantage of this approach is that you have to make sure the node names are unique. Plus, there's also a [Graph](http://search.cpan.org/perldoc?Graph) module on CPAN, complete with [Directed](http://search.cpan.org/perldoc?Graph::Directed) and [Undirected](http://search.cpan.org/perldoc?Graph::Undirected) subclasses.
`Graph` is one of the most useful modules in CPAN. Sadly, it is in dire need of a new maintainer. Whatever approach you'll use to model a graph, the node IDs will have to unique. This isn't a problem, as any collection can be enumerated and the index be used as ID.
I'd guess the grouping makes the . literal.
After some testing it seems that way. Also from the documentation: &gt; The \d\s\w\D\S\W abbreviations can be used both inside and outside of character classes. I assume that means that the other groups can't be used. Never knew :)
Because the answer to every question is always RTFM? 
If you want to read more blogs about Perl, consider * http://ironman.enlightenedperl.org/ (aggegator) * http://perlsphere.net/ (another aggregator; those two have lots of overlap) * http://blogs.perl.org/ (shared blogging site) * http://planetsix.perl.org/ (Perl 6 aggregator) ... and feel free to share the more interesting posts here :-)
SO is great for finding answers, perlmonks is great for having discussions (and yes, you can also find good answers there).
Because you use the 's' modifier, which means "Treat string as single line." So '.' will now also match the newline. See: [http://perldoc.perl.org/perlre.html#Modifiers](http://perldoc.perl.org/perlre.html#Modifiers) 
In PAUSE's [Edit Account Info](https://pause.perl.org/pause/authenquery?ACTION=edit_cred), at the bottom, is the 'forward mail to...' option set correctly?
$ perldoc perlrecharclass &gt; Bracketed Character Classes &gt; Special Characters Inside a Bracketed Character Class : Most characters that are meta characters in regular expressions (that is, characters that carry a special meaning like ".", "*", or "(") lose their special meaning and can be used inside a character class without the need to escape them. For instance, "[()]" matches either an opening
I knew about the modifier. However I thought that a dot in brackets would match everything as well. Kinda like [\s] and \s would match the same thing.
Does computer code wear out in only six years?!
Long story short: SPF is an anti-forgery tool; SRS is the accepted way for mail forwarders (eg pobox.com) to continue working; cpan.org does not seem to be using SRS. So cpan.org connects to gmail.com, tells it "I am sending from gravatar.com", gmail checks the incoming IP address and says "pffft, no you're not, get lost hoser". I can't guarantee that this is what's happening, but it seems likely. Do you have a non-gmail account you can use? Like an ISP? If so it's _possible_ that they have less aggressive SPF-rejecting measures. Try changing your CPAN forward there, test it, then send your gravatar confirmation.
Right on! I was agreeing with your comment, by noting that there's a generational divide on the version question.
I would say Catalyst Advent is about as Christian as Santa Claus... However for the part of Christianity that is about sharing what you have to help out those that don't, I have no issue with honoring the tradition of naming December Perl articles in this manner. Larry Wall is Christian and he gave us Perl FOR FREE, instead of trying to cash out. My guess is his religion inspired that in some part. I also know that religion inspires people to do all sorts of other things that are significantly less wonderful... The world is funny that way, I just try to be cool and go with the flow. If you are a Perl programmer, you'd benefit from all the 2013 Advent articles. If you use Catalyst I think this year we covered a lot of what is new for 2013. So its your call... :)
We've been through this argument before. For better or worse we are stuck with the versioning as it stands. We just have to cope with any confusion that might result. Lots of people have tossed out good ideas about how to reduce the confusion, be we end up endlessly bike shedding. Lets start solving the problem by agreeing to not keep saying "perl 6 should rename itself".
... I thought I was pretty smart but nothing you said here makes sense to me, no matter how many angles I look at it...
This has been suggested, that we just use the existing branding Perl5 version 20 it's the most sane idea in my mind but for some reason we can't move it forward.
If the fields come dependably in order (status, name, state) without missing any, then you can cheat a little and it's much simpler. Just grab most-recently-seen fields until you get to the last field in the group, then print the whole row when you see it. #!/usr/bin/perl -n chomp; if (/^Status : (.*)$/) { $status = $1; } elsif (/^Name : (.*)$/) { $name = $1; } elsif (/^State : (.*)$/) { print "${status}::${name}::$1\n"; } 
Thanks for the encouragement! I admit, I was a bit unfair in criticising totally irrelevant part of the whole thing. I have never used Catalyst seriously, so I'll read the articles carefully to see what's new. 
No, because Perl 6 SHOULD rename itself. It's confusing, and it's keeping new people from learning Perl. Why in the world would anyone want to learn the OLD version of a programming language? You need to put yourself into the shoes of all those people that start off a post saying: "I'm thinking of learning how to program, should I start with Perl or Python" So, here they are - revved up to hopefully start learning them some Perl, and they find out that there is a version 5 and a version 6. Well Boy Howdy, they'll want to learn the latest version. But then they are going to find out that the latest version isn't really complete yet, and no point in learning the old version because the new version and the old version are very different. So .. instead of learning Perl, they start learning Python instead because that's what all the kids in school are telling them they should learn anyway .. because .. well .. Perl 6
I subscribe to the notion that "shoulding" leads to arguments. Fwiw I use the name p6 instead of perl6 or perl 6 (for the compiler, and uppercase equivalents to name the project/language). Fwiw I love the idea of a switch to Perl 2014 for the brand name for the package that includes the 5.20 compiler (or Perl 2015 for the 5.22 compiler if it takes that long to get ducks in a row to make the switch). Then, say, Perl 2018 can bundle p6 tech as an experimental addition. But it's just fwiw, which may well be zero, and I accept that and move on.
Awesome. I shall give this a try.
I'll look into those as well. Thanks.
Is it just emails from you@gmail -&gt; you@cpan that you're not seeing in your gmail? I think gmail is probably trying to be clever and hiding those from you as duplicates. The "conversations" will exist in your sent items folder, but you won't see the received copies.
* Moose was beta six years ago. * Moo didn't exist six years ago. * Plack didn't exist six years ago. * Dancer didn't exist six years ago. * DBIx::Class was alpha six years ago. * Try::Tiny didn't exist six years ago. * GitHub didn't exist six years ago. * Travis CI didn't exist six years ago. * Perl 5.10 was *just* released six year ago. So, very yes, computer code is obsolete in six years, especially in the fast-growing field of Perl modules.
This trick is actually a neat way to escape most characters in a more legible format. /Question\?|\(Q\/A\)/ /Question[?]|[(]Q[/]A[)]/
[I'll just leave this here](http://arstechnica.com/security/2013/12/crypto-weakness-in-web-comment-system-exposes-hate-mongering-politicians/). Remember to use a disposable address.
I like the idea, but could you go ahead and break down the feature set on this?
There's more info about the feature set on https://github.com/Nordaaker/convos
Is "Reddit" in the title of this post a typo? Did you mean "Redis"?
Oops yes. 
funny you mention it since I actually used this for making debruijn graphs in the "Bioinformatics Algorithms" class on Coursera. the code worked fine on their sample sets of about 1MB but i haven't tried larger!
I definitely think its super to teach about such algorithms using some things as accessible as this. That's cool that you did that! 
I'd do it like that: sub new{ croak "singelton pattern, use get_instance instead" unless __PACKAGE__ eq (caller)[0]; return bless {},shift; } sub get_instance{state $self //= PackageName-&gt;new(); $self} that way you tell the user of your API a little what he shouldn't do. Edit: Formatting.
Isn't that a bit overdone for perl? Perhaps I didn't understand the Problem right, but for Perl &gt;= 5.10 there was ment a solution and below (or even for every Version): package Foo; our $obj = bless {}, __PACKAGE__; Your "shift" in the bless is a bit dangerous by the way. I think you don't want it to be an other package than Singleton. edit: I'm not a great fan of Patterns as they are mainly written for Java-like languages.
There is an important difference: *when* the object is instantiated. Usual singleton implementations only create an instance when it is first requested. Using a package variable does not make sense here, as it breaks encapsulation: Anyone would be able to change `$Foo::obj` (unless you make it `Readonly`). An accessor method is much better. It is true that *some* design patterns are just there to work around language limitations. You will only see *RAII* in C++ and similar languages without garbage collection. You will mostly see the *Command Pattern* in languages without higher-order functions or without closures. It was painful to learn about such patterns just after having looked through *Higher-Order-Perl*. Other patterns are pretty much universal, e.g. the *Strategy Pattern* or the *Visitor*, and I use them quite frequently in Perl as well.
Ah, the time of instantiation, you're right. Concerning encapsulation: Perl is very weak in encapsulation and most of it is convention. Not Long ago I had the Standard example for singleton: A DB-Connection. But in my case I needed a second one to a different database. So either see a Chance to connect to a second DB or fall back to native handmade DBI. package SQL looked like this (shortened): our $dbh; sub connect { $dbh //= DBI-&gt;connect(...) || die $DBI::errstr; } so: local $SQL::dbh = DBI-&gt;connect(...) did the Job and I was glad that the one who wrote SQL did not use a singleton pattern.
there are too many logs to import into SQL.... These are all logs from the DHCP server for a Large network. The logs are in zipped up for each day, so i do a zcat [logfilename] | grep or something to 
[DateTime](https://metacpan.org/release/DateTime) is a fine module, although a bit heavy. When I need only a few date calculations, I tend to use [Time::Piece](https://metacpan.org/release/Time-Piece) and its companion module `Time::Seconds`, which are part of Perl core. Here's a way to get the previous month: #!/usr/bin/env perl use feature 'say'; use strict; use warnings; use Time::Piece; use Time::Seconds; # create Time::Piece object from date string in YYYYMMDD format sub from_ymd { Time::Piece-&gt;strptime(shift, "%Y%m%d") } # convert Time::Piece object to string in YYYYMM format (no day) sub to_ym { shift-&gt;strftime("%Y%m") } my $today = localtime; my $first_day_of_this_month = from_ymd( sprintf "%04d%02d01", $today-&gt;year, $today-&gt;mon ); my $last_day_of_previous_month = $first_day_of_this_month - ONE_DAY; my $previous_month = to_ym( $last_day_of_previous_month ); say "First day of this month = ", $first_day_of_this_month; say "Last day of previous month = ", $last_day_of_previous_month; say "Previous month (YYYYMM) = ", $previous_month; Using $previous_month you can create the path to the previous month's logs.
I'm not on site with the SQL server. These are all pushed to my system nightly for our use. I don't think it'd need an array or anything for that matter. IF they enter 3, 2, or 1, i'd just know i'd need to subtract one from month, and search backwards once, twice, or thrice... If month = 1, subtract from year, and start with 12.... i think the datetime or others might be a better tree to bark up... 
I would go further than this and suggest logstash. It's more a pain to setup, but once you have it you can let anyone lookup the data rather than it being a CLI script you have to run. If you're forced down this route for administrative or political reasons, or you just really really want to avoid databases, then I think Aethy has what you need.
There needs to be a "ultimate guide" for this?
Not at all. David Farrell has at least one advertiser, and is trying to drive traffic to his site.
Interesting article, but on Linux I'd use dos2unix or unix2dos, wouldn't those do the same thing with less typing?
I used to be excited about Continuity, and it still has its high points, but its paradigm is too different for wide adoption. In the meantime, [Mojolicious](http://mojolicio.us) is really the best node.js competitor on CPAN as far as non-blocking frameworks.
This gets rid of some of the macro obfuscation so that you can see what's really going on, but it certainly doesn't make anything *easier*. There are two pretty big problems with XS in my mind. The first one is that Perl doesn't *really* have an extension API; it just has a bunch of bits of its internals that have been declared public and stable(ish) for modules and embedders to work with. The second is that we use the same system (XS) for extending perl (which is scary wizard stuff) and for calling functions in native libraries (which doesn't need to be). If we could agree on a good FFI, I think it would be a genuine contender for coring even in these "small core" days, as it would make a lot of things possible without getting a C compiler involved anytime after the building of perl itself :)
no it does not gets rid of some of the macro obfuscation. Every line there has multiple macros hiding. it just look more C then before.
Heh, true I guess. All of the `PL_stack`blah things, `SvNV`, `newSvNV`, and `sv_2mortal` are all macros. It's stuff like `ST` and `EXTEND` that the article is de-obfuscating a little.
Unlike 'mr' (which I just learned of via your comment), GitGot can work on any arbitrary subset of managed repos (selected by name, index, or tags). GitGot has hooks in place to support other VCSen, but only supports git at this point in time. (Thanks for pointing out 'mr', I'll see if there's anything there to steal now... 8^&gt;)
To be honest, I don't entirely agree with an FFI being a good solution for exposing most system libraries. Mostly, I see FFIs being successful in the cases where wrapping the function with XS is as trivial. Whenever things get hairy, FFI-using examples start getting rare and ultimately break down. IMO C isn't that hard and neither is XS.
I thought [Alien::Base](http://metacpan.org/pod/Alien::Base) was the new way to talk to libraries. Looks like it's in use as of end of 2013.
Alien doesn't do anything about interfacing. Alien is about *installing* non-Perl libraries. For example, you can use Alien::SDL to build and install the SDL library on your system if you don't have it, but you use the SDL module (which is XS) to actually talk to it.
Oh - I assumed it was a wrapper layer around C libraries too. Never picked up on the still-needs-xs factor when it was blogged about some time ago. Less interesting from a debian point of view then.
I am. I'm getting no output, and the only error I'm seeing is the one written to the error logs. It just says there's an error when I try to print the value of $plaintext because it doesn't have value.
GitGot looks like an improvement over `mr`. at the very least, it looks equivalent without almost typo-ing `rm` constantly! I'm building a package with `fpm` right now to experiment :D
This is a fairly random P6 post! Why those IRC logs specifically?? That's certainly not the most interesting advent calendar post imho either :S Give some added value or occasionally remind people of the P6 blog aggregator. Otherwise this is just making P6 look a bit dull, disorganised and needlessly noisy. The advent on P5 slang status or concurrency is certainly more interesting than numerical types/literals. 
Oh goodie, more whinging from username223.
Turns out there wasn't anything wrong with my code. I'm stuck with a server at Godaddy and they've been arguing with me for about a week about this. They convinced me it must be my code, and I just received an email that they admitted it was something on their end. Everything is working perfectly now.
Yeah. I was trying something deliberately mundane. And the votes are in! :) Fwiw the IRC selections were from sunday. 
DBI is threadsafe so you can share one DBI handle cross-threads. I've never tried it cross-process however. Probably possible with some hackery (Perl is quite good with these types of things) but I really think this sounds like an opportunity to rework some of these distinct applications together.
[DBD::Gofer](https://metacpan.org/pod/DBD::Gofer) is written for just this purpose. [Slides 23 and 24 here](http://www.slideshare.net/Tim.Bunce/dbdgofer-200809/23) are pretty cool. :) You have to avoid any per-connection state though. (transactions, temporary tables, locks, etc) 
I would, as others have mentioned, take a moment to look at a more fundamental issue with your system and find a "real" solution to the problem, instead of going down the threading / IPC rabbit hole. I'd look at something like [pgpool](http://www.pgpool.net/mediawiki/index.php/Main_Page) (if postgres) or [mysql proxy](http://dev.mysql.com/doc/refman/5.1/en/mysql-proxy-configuration.html) (if mysql). I don't know or care to find out what other DBs use for the same task. The point being, the above stuff reuses connections that have the same fingerprint (db/credentials/protocol version/etc.) in a transparent way. I'd go this route long, long before I started trying to pass a connected DBI handle around. 
You pass the handle around somehow. For myself, I had a central dispatcher that would use Thread::Queue::Any to pass an object to worker threads. These worker threads would use the method _retrieveDbh on the object, which first check itself for a handle in one of the properties and return that if it existed, or would generate one and store it in the property and then return it. You can accomplish the same idea with global variables if you mark them as Shared. This was all still in the Proof of Concept phase (before I decided to move to a JVM language for jdbc thread pooling and a few other options) so it's possible there are flaws here.
Some cherry pickin' you got going on there. That's not at all what the article says. 
&gt; DBI is threadsafe Since when? As far as I can remember, when installing DBI, it *always* warned against using it with a threaded perl. Maybe that has changed though [judging by the docs](http://search.cpan.org/perldoc?DBI#Threads_and_Thread_Safety) that is unlikely.
ralph thinks he is being funny. ralph is tired of getting ignored in /r/perl6 and is whoring for attention here.
If everything gets done within a year? That's been the perl-6 motto since 2001! I like your kool-aid mustache. It makes you look sophisticated.
Too bad perl-6 can't keep them passing!
Step one, invent a time machine. Step two, travel forward in time to when perl-6 is usable. Step three, avoid the zombie apocalypse. Step four, profit!!
You most definitely cannot share database handles across processes. You'll need a proxy (like DBD::Gofer).
My working assumption as a 55 year old who codes Perl for money and personal things is that I'll be using Perl 5 for the rest of my life.
Well, the article's opening paragraph reads "When is Perl 6 going to be Ready? We get this question a lot in the Perl 6 community, and the answer is never as simple as we or the inquirers would like." with a line break (deliberately) left immediately following the word "never". It was the obvious quote. I think "Monitoring P6 progress and regressions against test suites" is a better summary than "Roasting Rakudo Star" which requires that someone knows what roasting, rakudo, and star are.
Now if only someone involved with perl-6 knew what progress is.
Connections in MySQL are really cheap and if your server's load isn't bad then there's almost no reason to keep it lower than you need.
Maybe those old tests are just "technical debt."
Everything about a project that has more years than it does users screams "technical debt".
not lots left rope you end so old man C see sea
for teh has INLiNE::C case when wants having dem SNIFF SNIFF crackles
"and the answer is never" The best word wrap I've seen for a Long time.
I am 35 and I fear the same. But what I fear, and already watch, more is to be forced to switch to other languages more and more.
There are quite a few ways to get traditional OS elements like dialog boxes with Perl. The problem is they mostly suck, particularly on Mac. And installing them isn't going to be fun for a beginner. What are you trying to achieve and why does it need a pop up? Maybe we can help you do the whole thing another way. 
Well I, a couple years ago, took a CS course and was trying to duplicate many of the things I did in this class. But this class used NetBeans and Java. I have no idea why I'm even trying to re-learn these things. How would one go about learning the basics (and I mean basics) to coding an app?
Maybe try [Citrus Perl](http://www.citrusperl.com/)?
You can install Tk (`cpan Tk` in your shell), but your GUI will not act like other Mac programs (if that matters). Honestly, if you want to write a good Mac GUI, you should just download XCode and write it in Objective C, maybe calling out to a Perl program to do some of the processing.
I've already had to grit my teeth and dive into Java for Android app development. And a better reminder of how Perl makes it **so** easy to get things done would be hard to find.
I don't even know what **language** that was written in!
http://jobs.perl.org/ 
Yeah. I was glad that P6ers wanted to keep it. (It's unclear to me if it was initially an accident but almost everyone on #perl6 who saw it and expressed an opinion as we reviewed the draft thought it was funny and liked the idea of keeping it *even though it was obvious we'd get some trollish responses such as educated_poo's*.) (Edit. Added what seemed obvious to us in case it wasn't to everyone else.)
Only in #perl6 can you find people who think it's hilarious that they can't deliver working software.
I can't comment on Mac programming (unless you want to use OSX's XWindows server and target that) but wanted to say hi, good luck, and have fun! Also, if there is a PerlMongers organization near you, catch up with them for a meeting. A lot of times, figuring stuff out in real life is easier than on the Internet, the Internet tends to overload the few people doing help at any moment, and you're going to have a lot of questions, so real life code buddies are golden.
Funny, thought the title gave it away. 
My snickering is about your decade-plus delusion of releasing a working perl-6, not a linebreak!
Right that's the problem. Your title implies that the comic is related to Perl when it is not.
Indeed. Your title or the comic's title, the content has little to do with Perl.
[Plug for dancer](http://www.perldancer.org/) unless you need to do some configuration, then I would use an ncurses wrapper module. Otherwise us C++ and QT, but who does that? 
https://metacpan.org/pod/Wx
@retrec may not have populated as a simple array. Use Dumper to check the contents. It may be the case that the array contains hashes so you will need to have a look at the contents before determining how to access them. Edit: Just adding- you have determined that connectivity with the DB isn't an issue, right?
Can you post everything including the dbi connect?
You got ODBC/Sybase working? You're a God among men in my book.
Already checked all that. As I stated, if I do just: use Base; our @ISA = qw(Base); Everything works just fine. Note that I also tried using 'use parent' as well, which again didn't fix the issue.
hmm. If you have this directory structure: |-- My | |-- Package | | `-- Base.pm | `-- Package.pm `-- perlscript.pl Your Base.pm must start with `package My::Package::Base;` and in `Package.pm` you refer to it as `use parent 'My::Package::Base;` Works for me... could you show your directory structure? (maybe rename the directories into A, B etc.) **Edit**: Which other packages are you using? There are plenty that do nifty stuff. Maybe there's an incompatibility thing. **Edit2**: Do you have an `import` routine in your Base.pm or are you using `Exporter`? Or some other module that implements an `import` sub?
&gt; Basic objects means no Moo* packages I guess? God no. &gt; I, and I think nobody, can help you if you don't show an minimal case where you Error occurs. Yeah, that's the problem... You do anything to try to break it into a simple test case and it works.
no, I meant you should do it the other way around and delete as much code as possible for the error to occur, then obscure some variable names that your company policies don't get hurt and post that. Nobody can help you with just the error message.
I would start by not calling my class "Base". Especially if I am on an operating system (Windows, OSX) that is case insensitive. Maybe Product::Base or Company::Base. If you don't know how to deal with those, call it CompanyBase.
http://pastebin.com/Q66AfrFP
Yes - I've got the connection and I use this type of code on a daily basis. Problem is, that sometimes a stored procedure fails and the try catch code rolls the transaction back and I don't get a record created. I'm trying to figure out how to make perl aware that a problem happened with the SQL Server stored procedure.
Thanks! I've never used this - see output here: http://pastebin.com/4qQS2Gb4
To expand on this explanation, Perl 5 comes with a file base.pm, and a `use Base;` or `use base 'Base'` will find the core base.pm, load it, and then find that no package `Base` (just `base`) was declared in there, and whine.
wow, example code in that article is an image so you cannot copy&amp;paste. sucks
Some. 
Figured out the issue. It was a problem where subversion merged back in some files that had been deleted.
Cool story.
Very Cool story, hopefully you did not start writing in some shitty language like R or Scala, god that would suck. 
From your comment history you seem to be very angry about Perl. Can you show me on the doll where it touched you?
Did you stop using English when you had to rewrite a colleague's poorly written documentation? 
I started writing OO Perl after 3 years for the purpose of [Bio::Taxonomy::GlobalNames](https://metacpan.org/pod/Bio::Taxonomy::GlobalNames), all thanks to Moo.
Well English wasn't their first language ;-)
Well R is something you simply can't get around in my field and Scala is a beautiful language. I actually still had my undergraduates start with Perl even when I no longer used it. I think it can teach students important principles that are best learned through experience.
I wrote a module to use the Tumblr API. [Here it is!](https://github.com/cedriczirtacic/tumbperl)
Yes yes I agree. Hence my edit. And in practice, the 'best' programming language is the one you know how to use :D.. even if it's *shudder* Java. Merry Christmas to you.
My favorite thing from this year was writing a script to filter out certain lines from various files that was generic in function but specific in the filter based on products. It was able to read a separate file to load up a set of regex commands into an array(different for each product) and then execute the in an eval loop at run time. I know it's nothing all that fancy, but it sure worked well for what we were working on.
&gt; it's been gratifying to see https://metacpan.org/ continue to improve and rise in acceptance. Maybe some day it will be as usable as http://search.cpan.org/ ...
I use Perl for scientific computing, so these may be a little out of the Perl mainstream - but: I used Perl to process a terabyte (two years' worth) of starfield images from the twin STEREO spacecraft, removing the 99.99% of the signal that is noise, stars, and dust to reveal giant clouds of free electrons zooming across the inner solar system. I used [PDL::Graphics::Gnuplot](http://www.youtube.com/watch?v=hUXDQL3rZ_0) to implement, in two afternoons, a complete graphical markup tool to track small comet-tail features through the data and reveal interesting things about the solar wind (I'd tell you more here but the results need to undergo peer review first). It wasn't brand-new - but I revisited and augmented some Perl code I wrote in 2010 to control a sounding rocket as it flies into space. (First flight worked flawlessly -- Perl coordinated and synchronized activity across four in-flight computers. We're getting ready to fly again in the spring). 
In bioinformatics I'm often forced to suffer through R as well, but that does not make it any less of a crappy nightmare. And as far as Scala is concerned, I do everything in my power to stay away from anything Java like.
All you trade for a large number of connections is some RAM. I don't remember the rule of thumb, but the MySQL docs should be pretty clear about it. At work, our typical MySQL instances have connections in the thousands, and we have thousands of those MySQL instances. Just requires configuring the server correctly. :)
What do you find worse about metacpan? Have you submitted feedback?
&gt; Have you submitted feedback? Yes, and it got the expected "not a bug / wontfix" response.
I hadn't even realized state variables existed until I saw this topic. But as far as I can see, I think they're a useful feature and I don't understand the reasoning of this article. Of course you can find I simple example that doesn't really need state variables, but You don't need a much more complex example to see their benefits - imho.
Ah, now, having to rewrite horrific unreadable code with tentacles... that I can sympathise with! But really, people write unmaintainable spaghetti in any and every language. I'll concede Perl makes it easier to get away with.
Nice! I do like Prolog. Have you seen [Language::Prolog::Yaswi](https://metacpan.org/release/Language-Prolog-Yaswi)?
Not particularly epic, but something that was fun and rewarding for me was working on bringing [SPDY](http://dev.chromium.org/spdy) to Perl/PSGI - namely, the development of [Arriba](https://metacpan.org/pod/Arriba) and [HTTP::Tiny::SPDY](https://metacpan.org/pod/HTTP::Tiny::SPDY). Also fully embracing [Dist::Zilla](http://dzil.org/) (finally) and creating my own plugin bundle ([Dist::Zilla::PluginBundle::ODYNIEC](https://metacpan.org/pod/Dist::Zilla::PluginBundle::ODYNIEC)), which made my development process so much easier and more effective.
Nothing sexy. Just drawing on CPAN and retrofitting a test suite to a legacy app. The beauty of Test::WWW::Mechanize (and friends) is that they're less invasive and offer a way into otherwise impenetrable web apps. &lt;p&gt; I was faced with a series of about 20 user registration processes from a federated web-site. Each had been cut and paste from common ancestor and is used by a different business unit, with a customized rules and look and feel. Very little use of OO or library code. I took a'black-box' approach going through the web pages and building up spreadsheets of inputs ans outputs. With a little Perl I churned out some basic data structures that described all the variants and expected inputs and outputs. From there, it was a matter of building up a test suite from scratch that drove the application from the data-structures via Test::WWW::Mechanize. After building up the tests and fixing bugs I was finally in a position to implement that changes using a TDD approach. So I was able to deliver largish changes, keep my sanity, and build a test suite along the way. Thanks CPAN. 
Taking advantage of mod perl's shared memory to reduce the resource requirement of our telemetry server by 75%. 4 VMs can now do what we needed 16 VMs before. Also they don't collapse under heavy load.
This may be the best reply I've seen to a language hater in a forum dedicated to that language. I hate PHP, but I channel that into /r/programming and /r/lolphp, not /r/php.
implementing live coding using perl+emacs: https://github.com/vividsnow/perl-live
You need to interface with the web and you don't like Perl. Something is lost here. 
JavaScript and Scala. :-)
Completely agree with you here. Metacpan is great, far better looking and more usable than search.cpan.org.
So many things! Finally getting into [publishing modules on CPAN](https://metacpan.org/author/SILLYMOOS) and launching [Perltricks.com](http://perltricks.com), which runs on Catalyst.
fake.. code doesn't work.
Android Firefox is what I use to test it on my phone, so I was not aware of any problem. I would be grateful if you could send a more complete bug report to me at `mjd@plover.com`. Thanks. Edit: I see now that it is unreadable under the default android browser, but I don't know why or how to fix it. It behaves properly in desktop Chrome and Firefox at many different font sizes and widths, and I don't know why the Android default browser is choosing an absurdly large viewport size. If you have any constructive suggestions, I will be very glad to hear them. 
I've been trying to get the time to pick up Ruby. From what I've seen so far, Perl is definitely its Spiritual Liege, but with some new bits thrown in. Not sure if the infrastructure and stuff is as nice as CPAN etc yet though. Ruby's getting the "it's dying" news recently, which means it must be fairly mature now ;-)
Are you calling the perl from the command line or a shortcut? What thrashing around did you do?
Maybe adding something like this helps? &lt;meta name="viewport" content="width=device-width" /&gt; 
GetOpt::Long is pretty good, I recommend.
This is an interesting point - if a shortcut is used, and the command line is quoted, then that could explain the single effective argument.
If it's intentional then it's not a bug. 
I would agree that the "floating" time zone issue could be considered a bug. But there's a slight difference between the two situations. On your blog you *intend* for the menu to not display on mobile devices. You've made the decision to sacrifice some ease of navigation to make the page more readable. With the time zone issue the *intention* is that you not mix "floating" and "real" time zones, but the overloaded comparison and math operators don't enforce this rule, although they should.
That's weird, and it's not what I see. Are you sure the command syntax is correct in the Registry? Although, that's likely just for doubleclicking and dropping files onto the script's icon. Just how are you calling the script? 
I have used Language::Prolog::Yaswi, but I also needed a way to just generate fact files in perl that a prolog program could utilize. 
From the command line: prog.pl arg1 arg2 ditto from a batch file.
The thrashing was to try to fix the registry. Win7 stopped associating perl with the .pl extension, and when I got that fixed, it wouldn't pass the arguments. Whoa! When I fixed the registry call syntax for perl, I'll bet I added just one argument! Maybe that's why it's jamming all the arguments into one. Now if I can just remember where in the registry I made the change. :-(
Just as a test, what does perl prog.pl arg1 arg2 do? You might have to add the -S command line switch before the script name if the script isn't in the current directory. perl -S prog.pl arg1 arg2 This does sound like a problem with how *.pl files are set up to use arguments when running as a script, as opposed to as an argument to perl.exe.
I haven't done any IPv6 programming, but the Socket core module in 5.14 had a lot of IPv6 work done. You might not need Socket6 at all.
Look [here](http://www.perl.org/about/whitepapers/perl-ipv6.html) for most of the answers to your questions. For reference, Perl 5.14.0 was released in May, 2011.
&gt; You know very well why you're getting that output, so don't be stupid. No I don't know, and there is no need to insult me. &gt; Just comment out "`use warnings;`" and move on. The problem isn't that I get the warnings: it's that the warnings are the sign that something is wrong.
&gt; You might not need Socket6 at all. At the very least, I need `inet_ntop` and `inet_pton` from `Socket6` which don't seem to be in the core `Socket` module. **Edit**: Sorry, they are, they're just not exported by default (contrary to `Socket6`). I also need the `IPV6_V6ONLY` constant and that doesn't seem to be anywhere. I don't even see a way to work around this in a portable manner (I don't know its value on any system other than Linux). :-(
So should I copy my bug report against `Socket6` to the Perl core?
Actually, no. I'd read the documentation for a modern version of [Socket](https://metacpan.org/pod/Socket#IPV6_ADD_MEMBERSHIP-IPV6_MTU-IPV6_V6ONLY): use Socket qw(IPV6_V6ONLY); .. should work, assuming your OS has such a thing, and whenever Socket was compiled, it was detected.
Great! Thanks for pointing this out.
Well, honestly, I'd say that it's a reasonable assertion. It's not going away, but it's tiring. Less people are picking it up, it's losing ground to Ruby/Python, I'd probably not even advise people to learn it unless they had to (and I've been using it loads for the last 10 years). It's probably boring, and annoying to hear it, but I'd say it's on a downward slope now. I don't care all that much either way, I know it well, and it's done me no end of good (and some harm) but there is no room for emotion. A release a year doesn't really define it as healthy per se. It's the number of new coders that are picking it up. 
It's suffering from a degree of neglect due to the amount of attention to the mythical Perl 6, but certainly not dying. For me, Perl 5 is still the most productive and enjoyable language to work with. Very much highlighted by recent work developing Android apps. Even accounting for my lack of familiarity with Java (which is a *horrible* language to code in) it's reminding me just how great Perl is as a language to get things done quickly. Something that could be done in minutes in Perl takes **hours** to do in Java because of the convoluted and strictured way the language works.
Fair enough. Upvoted. I mean, what I am seeing is anecdotal, but it is what I am seeing. I'm not seeing people younger than me picking up Perl 5. There's no other way to say it. The people that are coding that sort of stuff are (again, solely from my vantage point, in and around NYC) not getting into Perl5, they are using other things to get that job done. And asking me for Perl ;)
Much as I'd like the contrary, I'm pretty sure my death will inconvenience fewer people than Perl's. :-/
Who is working on Perl6 who'd otherwise be driving loads of P5 stuff forward? Its not mythical either Rakudo is right there to try.
The programming community is fragmented in general right now. Trying to get things done is what people claim to be about, but then they go invent new languages to satisfy some need. To name a few commonly used languages now (that aren't C) perl, PHP, ruby, python, java, javascript, rust, go, haskell, scala, lua All of these are viable languages to write your program in. With limited exceptions they're mostly the same difficulty level. So people just pick the one that suits them. They write a bunch of code and other people contribute to the code. The problem is if you want to use that code from another language you're stuck either doing something mega hacky or rewriting the module in your favorite language. The reason python is very popular is because people ported or rewrote from scratch hundreds of modules from perl. All this is a bad thing because in an enterprise sometimes you already have a hundred thousand lines of code and can't accept "rewrite the program" so you're forced to rewrite a module. And you might be doing that without being an expert in that modules scope (that's why you were trying to use the module..) which means the new code is probably going to be crappy. In an ideal situation there would be an object compatibility layer that lets people use objects from any language in another language. Then it's completely up to programmers preference what they want to write in. Right now there is a bunch of shit like REST/SOAP/CORBA to proxy stuff through. Sure, json is pretty clean for moving data between languages but it still sucks compared to just "use PyModule;" Perl6 with it's VMs was looking at doing this. JVM being a backend for scala, JRuby, jython, and java opens up the possibility of modules working between languages (but forces you to use a JVM, which I dislike for mostly historical reasons) 
Larry could. And Rakudo is there to try if your time has no value.
As an aside, that warning is generated because you used the "-w" switch – this is [not recommended][-w] , as you should "use warnings" only. The "warnings" pragma only affects the lexical scope (here: the current file), while "-w" has a global effect and doesn't offer the same fine-grained control. Recommended version of that code: #!/usr/bin/perl use strict; use warnings; use Socket; use Socket6; (note also the absence of a space in the shebang). This comment is a code review, not a suggested way to do IPv6 programming – other comments have given better solutions. [-w]: http://perldoc.perl.org/perlrun.html#*-w*
&gt; Rakudo is right there to try Which is not the same as saying "worth bothering with yet". Why would I waste my time *trying* something that's not ready to put into any production systems and won't be for decades? Especially as if it ever *does* become ready for production there's a good chance it'll have changed so much that whatever I've already tried will no longer be of any use.
Unauthorized release?
I've always been confused about the relation between `-w` and `use warnings`, which is why I normally use both: the man page (you cite) says that "normally, the lexically scoped `use warnings` pragma is preferred", which doesn't exactly mean that one shouldn't use `-w`, more that `use warnings` is generally better (but doesn't argue against using both). Concerning the space in the shebang, I took the habit of using one when I learned that there was some version of Unix (I can't even remember which) which took `#! /` (with space) as a four-byte magic number to decide when to pass a script to an interpreter, so the space was mandatory on that version. But it's true that said Unix is probably completely dead by now, so this practice is no longer useful (I can't see a reason why it would be harmful, though).
&gt; P5-mop for example strongly resembles P6 syntax but is a P5 people project. If you'd already learnt P6 you would be slightly more prepared come the production release of the new object model. Alternately, you could have used Moose, which has been suitable for deployment for several years even if you have never touched P6.
I didn't know that Perl even *had* and IDE. But if we are on the level of Notepad and such, I can come out and say that I use vi or vim, in both linux and Windows environments. In Windows I can use vim under cygwin.
It is an IDE in a "silk-purse-out-of-a-sow's-ear" kind of way. I say in [my blog](http://pjk.scripts.mit.edu/pkj/2013/09/14/being-a-vivim-purist/) how I am able to get a nice interface from vim. The command lines are used starting in your home directory. And yes, it understands Perl, and does the right syntax highlighting. I have had mixed results from system to system. In Linux it works perfectly, in Cygwin, I say in my blog that things went haywire, until I found that the default vim that comes with Cygwin is vim-tiny, and you need to have the normal version of vim installed.
O'Reilly has largely stopped printing Perl books. Other than the Camel Book, most books from O'Reilly still in print haven't been updated in 10 years or so. But there has been an up-surge in the newer languages such as Ruby and Python. My local bookstore no longer sells Perl books, but sells titles from other programming languages. The Human Genome Project, a big Perl scripting project if there ever was one, is now showing signs of moving away from Perl. [Rosalind](http://rosalind.info) now tells its new students to learn Python for its bioinformatics projects. This is essentially an abandonment of the hundreds of libraries used to mine the data of the genome of various species.
You're quite welcome. I've wanted to make parallel testing easier for years, but never quite seemed to have the time. It's good to hear that some appreciate it. I've feared that, despite how *relatively* easy it is to use, that it's still too advanced for people.
Or Moo or Mouse. Or even Mo. All of which are perfectly viable, production-ready OMs.
Sure, all of those are viable alternative object systems. Moose is probably the best fit for that example, however, because it has such a strong MOP. If and when p5-mop is in the core, it's likely that some or all of Moose, Moo, Mouse, Mo, M, Squirrel, Badger, whatever will be implemented atop p5-mop. Most people won't use the MOP directly.
Found via brian d foy's via [Twitter feed](https://twitter.com/briandfoy_perl)
make it a bash variable and use the variable in the script?
Interesting idea. DO you have an example?
Set the following bash variables For the webhost: PATH=$PATH:/usr/bin/perl PERL_LIB_PATH=/home1/$webhostUsername/perl For your machine: PATH=$PATH:/usr/local/ActivePerl-5.16/bin/perl PERL_LIB_PATH=/Users/$username/Library/ActivePerl-5.16/lib Set both of those globally, or before you call the script. Then, run the scripts with: #!/usr/bin/env perl use lib $ENV{'PERL_LIB_PATH'} I'm not positive that this will work, and it's not quite elegant, but it's not terrible either. 
Used your advice and tested on both dev and prod environments. Worked perfectly. Thanks for the advice. I thought that the interpreter would barf if I included library paths that do not exist. Glad to see that it does not.
I am currently perusing a career as a Linux and Unix Admin. Not only is Perl stimulating to solve problems in, and has many libraries to draw from in the domain I am working with but it is pretty much every Linux and Unix system either has Perl installed on it or requires if as pat of the build process. 
check out local::lib http://search.cpan.org/~haarg/local-lib-2.000003/lib/local/lib.pm 
'best' as in most popular on metacpan. 
I got to meet Larry Wall at OSCON. Does that count?
&gt;Is this because the script is calling the 'last' command on my current system to parse an output file from the Solaris system? I don't know enough about SunOS to know whether or not that would cause this issue, but that is what you're doing and that is something that is very likely to break, so I would try running that same command(last -f /home/justin/billing/wtmp |) on both machines and comparing their outputs -- is it any different? Another thing you can do is instead of opening the command, just pipe that command in to your script and read stdin directly. That way you can replace the command with ssh sunos last -f whatever | perl localparser.pl last -f /localfile/wtmp | perl localparser.pl or whatever you want as needed. And lastly, I doubt this will help anything, but rather than using a giant regular expression you could try using split() and splitting for the \t tab characters that should be between each field. Again, no experience with solaris, cant promise that will change much of anything, but in my experience it always sucks to go back and figure out why a regexp broke.
It sounds like you added one argument and Perl is reading your $ARGV[0] and $ARGV[1] as @ARGV
I can't recommend `Getopt::Long` enough. It's **that** good.
Too bad Image::Magick can't easily be installed with cpanm/cpan tools without manual intervention. Others have suggested how to easily do it like many other modules do, but it looks like the interface is not actively maintained. All bug reports regarding cpan are completely ignored.
Use [`Text::Tabs`](https://metacpan.org/pod/Text::Tabs): my $foo = expand $str; 
If you insist on a regex .. ```s/^\t+/" " x (length $&amp;)/e```. The part between " " is what each tab gets translated to, so put a few spaces in. Backwards is a bit more complicated if you don't know how many spaces, but if you do, you can probably use the same approach .. ```s/^\s+/"\t" x (length($&amp;) / 2)/e```. (/2 if you have 2 spaces per indent)
 s/^(\t+)/" " x ($tabsize * length $1)/emg;
&gt; Backwards is a bit more complicated if you don't know how many spaces He's working with code so backwards is waaaay more complicated, since it's harder to differentiate between indent vs. formatting spaces. Come to think of it, looking at the code base of my day job, everyone screws up the formatting by frequently using tabs to indent *and* format. So if the op's standards are low it's not so hard after all.
Identify any cases where this is true. There should be few or none. Deal with fixing them In a second step.
Still pretty beta but should work. Also has a plugin engine. Constructive criticism is always welcome.
 curl "http://www.reddit.com/user/$USER/saved" | perl -lne 'print "$1 -- $2" while /class="title .*?href="(.*?)".*?&gt;([^&lt;]+?)&lt;/g'
The question wasn't clear, and it doesn't hurt either way :)
That won't handle multiple pages.
Booking.com threatens hotels and charges commission even when guests do not show up, bookings booked through there website often are cancelled, declined credit cards are used making it very hard for the hotel to provide accomodation to their guests. If you do not follow the exact procedure to report declined cards or guests no show then it results in commissions being charged and if you query it they advise you to pay up or they will suspend your account - this has happened to many smaller hotels - the staff that you try to talk to are overseas and have little english skills and just come accross as bullies. I would never go back to booking.com there are other more professional companies without all the issues eg Agoda, Wotif, Check-in.com
Use Text::Tabs. Not everything needs to be done with a regex. The best code is working code that you don't have to write.
Downloads Reddit saved links via your saved links feed.
I went ahead and automated the process with a [script](https://gist.github.com/zmughal/8264712). There are some caveats with how the Perl binary is built, so I mentioned them at the top. I'm not sure if that is the best process, but I'd love to get feedback and learn of better solutions.
If your concern is the formating of Perl source code, then you might also want to take a look at [Perl::Tidy](https://metacpan.org/pod/Perl::Tidy)
I'm not sure I follow you, but I think it may be a simple matter of wrapping a "while(1) { .... }" around your code. https://gist.github.com/scrottie/8278414 ... how is this different from what you have now? By the way, perlmonks.org was created just for getting Perl help. I'm sure you're welcome to try your luck here too, but I thought I'd mention that.
 /M | [TN]|B/ Is there a joke there I'm not getting? Did I misread it? Is this really a regex that matches every line of Star Wars subtitles but not Star Trek? Or is it just a nonsense regex (which doesn't seem likely)?
In all seriousness, can such regexes be used for efficient string matching? Such as searching for an exact substring match with a list of strings? 
I expect that it might be a joke.
"[Subtitle](http://www.merriam-webster.com/dictionary/subtitle)" has two meanings. This comic is referring to things like "A New Hope" or "The Wrath of Khan," not captions. 
What is your list of strings? Which of these do you mean? * `0 &lt; grep {/$substr/} @strings` * `$regex = join '|', map(quotemeta,@strings); $string =~ /$regex/`? The first one is faster with `index` the latter is better with a regex.
I presume he means this: use warnings; use strict; my @star_wars = ("A New Hope", "The Empire Strikes Back", "Return of the Jedi", "The Phantom Menace", "Attack of the Clones", "Revenge of the Sith"); my @star_trek = ("The Motion Picture", "The Wrath of Khan", "The Search for Spock", "The Voyage Home", "The Final Frontier", "The Undiscovered Country", "Generations", "First Contact", "Insurrection", "Nemesis", "Into Darkness"); for my $title (@star_wars, @star_trek) { my $result = $title =~ /M | [TN]|B/i ? "matches" : "doesn't match"; printf "%-40s %s\n", $title, $result; } which prints: A New Hope matches The Empire Strikes Back matches Return of the Jedi matches The Phantom Menace matches Attack of the Clones matches Revenge of the Sith matches The Motion Picture doesn't match The Wrath of Khan doesn't match The Search for Spock doesn't match The Voyage Home doesn't match The Final Frontier doesn't match The Undiscovered Country doesn't match Generations doesn't match First Contact doesn't match Insurrection doesn't match Nemesis doesn't match Into Darkness doesn't match Curiously, the `/i` flag is necessary but wasn't included in the comic.
Yes, the second one.
Awesome example, thanks!
Yeah is more efficient, because you have some variant of a trie built into the regex engine.
I think the following works (using a simple prefix tree): #! /usr/local/bin/perl -w use strict; use warnings; use Getopt::Long qw(:config no_ignore_case); my (@poslist, @neglist, @posfilelist, @negfilelist); GetOptions("p|pos=s" =&gt; \@poslist, "n|neg=s" =&gt; \@neglist, "P|posfile=s" =&gt; \@posfilelist, "N|negfile=s" =&gt; \@negfilelist); sub readfiles { my $flst = shift; my $lst = shift; foreach my $fname ( @$flst ) { open my $f, "&lt;", $fname or die "Can't open $fname: $!"; while ( &lt;$f&gt; ) { chomp; push @$lst, $_; } close $f; } } readfiles \@posfilelist, \@poslist; readfiles \@negfilelist, \@neglist; my %conts; foreach my $s ( @poslist ) { for ( my $i=0 ; $i&lt;=length($s) ; $i++ ) { $conts{substr($s, 0, $i)}{substr($s, $i, 1)} |= 1; } } foreach my $s ( @neglist ) { for ( my $i=0 ; $i&lt;=length($s) ; $i++ ) { $conts{substr($s, 0, $i)}{substr($s, $i, 1)} |= 2; } } my $regexp = "\^"; sub doprefix { my $pfx = shift; my @end = (); my @lst = (undef, [], [], []); foreach my $c ( keys(%{$conts{$pfx}}) ) { if ( $c eq "" ) { $end[$conts{$pfx}{$c}] = 1; } else { push @{$lst[$conts{$pfx}{$c}]}, $c; } } die "Lists are not disjoint: $pfx is in both" if $end[3]; my $chars1 = "\[" . join("", map(quotemeta,@{$lst[1]})) . "\]"; $chars1 = quotemeta($lst[1][0]) if scalar(@{$lst[1]}) == 1; if ( scalar(@{$lst[3]}) + ( !! scalar(@{$lst[1]}) ) + ( !! $end[1] ) &lt;= 1 ) { if ( $end[1] ) { $regexp .= "\$"; } elsif ( scalar(@{$lst[1]}) ) { $regexp .= $chars1; } elsif ( scalar(@{$lst[3]}) ) { $regexp .= quotemeta($lst[3][0]); doprefix ($pfx . $lst[3][0]); } return; } $regexp .= "("; my $first = 1; if ( $end[1] ) { $regexp .= "\$"; $first = 0; } if ( scalar(@{$lst[1]}) ) { $regexp .= ($first?"":"\|") . $chars1; $first = 0; } for ( my $i=0 ; $i&lt;scalar(@{$lst[3]}) ; $i++ ) { $regexp .= ($first?"":"\|") . quotemeta($lst[3][$i]); doprefix ($pfx . $lst[3][$i]); $first = 0; } $regexp .= ")"; } doprefix ""; print "$regexp\n"; Examples: ~ $ perl/regexp-golf.pl -p foo -n foobar ^foo$ ~ $ perl/regexp-golf.pl -p foobar -n foo ^foob ~ $ perl/regexp-golf.pl -p foo -n foobar -p foobarify ^foo($|bari) ~ $ perl/regexp-golf.pl -p foo -n foobar -p foobarify -p foobug ^foo($|b(u|ari)) ~ $ cat /tmp/star_wars.txt A New Hope The Empire Strikes Back Return of the Jedi The Phantom Menace Attack of the Clones Revenge of the Sith ~ $ cat /tmp/star_trek.txt The Motion Picture The Wrath of Khan The Search for Spock The Voyage Home The Final Frontier The Undiscovered Country Generations First Contact Insurrection Nemesis Into Darkness ~ $ perl/regexp-golf.pl -P /tmp/star_wars.txt -N /tmp/star_trek.txt ^([AR]|The\ [PE]) ~ $ perl/regexp-golf.pl -P &lt;(seq 0 3 99) -N &lt;(seq 1 3 99) -N &lt;(seq 2 3 99) ^(0|6($|[6390])|3($|[6390])|7[285]|9($|[6390])|2[714]|8[714]|1[285]|4[285]|5[714]) (Actually, it doesn't work when the positive list is empty, but then there's no obvious way to make a match-nothing regexp. I might have made mistakes, of course.)
Only on Linux! edit: *x!
Unix actually...it works on OSX.
That's pretty cool.
backticks: the last refuge of the scoundrel.
Yeah, big time. *Fuck it, I'll just stick it in this once. There... it works*. I mean, from what I understand, Larry Wall wanted to make something that gave his shell scripting more... oomph, thus Perl. So, it's ground up designed to be easy to get into that interface. I dunno, there is an awful lot of things you can do between system(), exec() and backticks (ahem) plugging crap into Perl to do with what you will. Every now and again I feel like I should be using shell to do something. Invariably the specs get extended, and I end up getting tied in knots, and switching over to Perl again. In fact, pardon my ignorance, but would someone mind explaining why I should not just use Perl for pretty much everything above very simple / couple of lines long shell scripts? 
You can do string and file manipulation in the same script, with the right libs. I use backticks somewhat less than I used to, since I see that Perl supports a ton of UNIX commands inside the script.
&gt; which features of Perl continue to make it great for Unix? Perl is not expecially "Unixy" in the sense of conforming to Unix's design philosophy: it's not a bunch of simple things spitting line-oriented text at each other. Perl is "Unixy" in the sense that it makes it easy for you interact with the Unix platform. It hooks into both the C/POSIX level and the shell level, while providing its own programming language that will be familiar to anyone already familiar with Unix. It's also "Unixy" in the sense that it was written to accomplish a specific task: Larry Wall need to munge text in complex ways and create reports. IIRC the guys at Bell Labs needed to control a printer and share a PDP-10.
Backticks are a good one, but for my money it is syntax like this: while(&lt;&gt;) { } The entire idea that with two characters "&lt;&gt;" I can write *Take input from a file (or list of files) listed on the command line, or alternatively read from STDIN.* is just a brilliant example of Perl functionality that allows you to build chains of simple tools that work together. I also think Perl's ability to do in place edits of files is very Unixy, e.g. perl -pi.bak -e's/foo/bar/g' file.c I might have missed it, but that is the kind of functionality that I would have loved to have back in the Applesoft BASIC days.
&gt; there's no obvious way to make a match-nothing regexp `(?!)`
I had a devil of a time getting it to work many years ago--does it work better now?
To me it's the syscall bindings. I know exactly what to expect when I do strace perl -e 'rename "/tmp/x", "/tmp/y"' Which is this: rename("/tmp/x", "/tmp/y") = -1 ENOENT (No such file or directory) Perl doesn't screw around. unlink, chmod, read, write, select are all right to the metal, which makes doing POSIX stuff very nice. I found it very good at prototyping C programs where you want to figure out how to get your algorithm written to POSIX without worrying about memory or types or speed.
This is Perl's serial-killer app. Edit: a serial-killer with a swiss army chainsaw. Edit: and a bazooka. Edit: with chrome plate, and blinkin' lights.
I was trying to output a regexp that doesn't rely on Perlisms (although that isn't really possible because of the way escaping works differently in different regexp engines). Even then, it's possible to hack something like `$foo^` but I didn't want to use incomprehensible hacks either.
I have noticed that there was no Perl Module for Csound. People in the Perl IRC channel on freenode pointed out to me that The Template Toolkit, could be used to help generate the score files.
%conts is an hash of hashes. That is, every value of %conts is a reference to another anonymous hash. So $conts{$pfx}{$c} (which is syntatic sugar for $conts{$pfx}-&gt;{$c}) is the value with key $c in an anonymous hash, whose reference is the value with key $pfx in the hash %conts. I suggest a reading of the perldsc manpage (try "perldoc perldsc" on a terminal). 
[Link to delta](https://metacpan.org/pod/release/RJBS/perl-5.18.2/pod/perldelta.pod)
I can't answer all your questions, because I don't really understand the code fully either at the moment, but it looks to me like $conts{X}{Y} (where X is a prefix string and Y is the character that appears after that prefix in one of the input lists) contains a bitmask where a value of 1 indicates that the seqeuence XY appears in the positive list, a value of 2 indicates it appears in the negative list, and therefore a value of 3 indicates it's in both lists. So in the code if ($c eq "") { $end[$conts{$pfx}{$c}] = 1; if $c is an empty string, then we're looking at the end part of a word. $conts{$pfx}{$c} looks at which list the string "$pfx$c" was seen (and of course $c is blank so we're really just looking at where $pfx was seen) and gives a value of 0-3. If it's 3, then it's in both lists which is an error condition (since the program prints a regexp that matches words in the positive list but not in the negative list a single word can't be in both lists). So if $end[3] is set, it's an error. Or something like that. I think the code could do with some comments, tbh. EDIT: push @{$lst[$conts{$pfx}{$c}]}, $c Break it down: push @{ ... }, $c # puts $c into an array. $lst[ ... ] # @lst is an array of list references, so each element in @lst is one array ref # $lst[0] - unused # $lst[1] - positive list # $lst[2] - negative list # $lst[3] - both lists $conts{$pfx}{$c} # a value, 0/1/2/3, indicating which list the sequence "$pfx$c" was seen in So it adds $c to one of 3 arrays, depending on which list that character was seen after $pfx. &gt; is this really badly written or am I stupid? I wouldn't say it's badly written by many standards, but it's uncommented (a big bugbear of mine), not easily understandable, and I'm not a fan of the variable/sub naming conventions or some of the more cryptic lines. If a programmer on my team handed me that for review he'd get some constructive criticism. 
Great thread. Saving for later. Thank you.
Can you explain? I'm not sure whether I agree or disagree with you here. Interface-wise, even the better and/or more popular CPAN modules seem like a grab-bag of simple and not-so-simple tools.
Not to side-track this thread, but curious: Does Perl 6 retain Perl 5's "unixiness"? 
removing `use warnings` broad spectrum is incredibly bad advice. Warnings are things that indicate there is something in your code that is likely wrong, and you should either: * Find a way to resolve the problem so the warning does not occur * Lexically inform Perl that for a given context, the warning it provides is nothing to worry about. By "Lexically", I mean: { use warnings; &lt;warnings trigger here&gt; { no warnings 'redefine'; # Tell perl that redefining a sub is not an accident &lt;code that would trigger a redefinition warning here&gt; } &lt;redefinition warning will still work here&gt; } This is all very clearly explained in `perldoc perllexwarn`. Broad spectrum warnings disabling will just make bad things happen, and perl will not tell you those bad things are happening. **Analogy**: Your house is on fire, the recommended action is not to disable alarms in the house and hope that fixes the problem, but to respond to the problem. If the alarm telling you the house is on fire is wrong, you fix the alarm. You don't go and turn off all the alarms of all kinds in all parts of the house just because one alarm is erroneous. :)
I'd say the P6 design does. That's why, for example, the [default command line processing features of MAIN subs assume unix shell processing and unix utility argument conventions](http://perlcabal.org/syn/S06.html#Declaring_a_MAIN_subroutine). For more, maybe browse [#perl6 mentions of "unix" by Larry Wall](http://irclog.perlgeek.de/perl6/search/?nick=timtoady&amp;q=unix).
That analysis is so, so wrong, I wouldn't even know where to start to criticize it. Let's just say that "fastest growing" means what it means, not what Brian thinks it means. And that percentages of the kind he's talking about are the best way to evaluate that.
Back during the Haskell craze on /r/programming in 2007 or so, someone joked that Haskell was the fastest growing language that everyone should learn because a second company besides Galois was hiring. "Fastest growing" might be mathematically precise, but in this context it's not interesting.
It's not interesting *to me*. If there were one Haskell job last year and now there are two, I'm not getting that second job. If there were a million Perl jobs last year and now there are 1.1 million, I'm learning Perl even if Haskell's growing a lot faster by percentage. Maybe it's interesting *to you* which languages grows faster by percentage, but it's innumerate to publish that statistic without providing raw numbers, if only so everyone else can evaluate whether they want to compete for that one new Haskell job. As I see it, if you compare only percentages to determine what you're going to do for a job, you might as well go out for a professional sport because the salaries of the highest paid athletes are astronomic (sure, there are only ~500 NBA players in the world every year, but you have a 0.2% chance of making the most money in the league in any given year, if you play with statistics that way).
&gt; Maybe it's interesting to you which languages grows faster by percentage, but it's innumerate to publish that statistic without providing raw numbers &gt; if you compare only percentages That's the caveat. I'm not advocating for the use of *just* percentages for comparisons. Neither does anyone. You see, there are two kinds of percentages involved in the kind of analysis Brian tries to perform: one is individual growth (the percentage resulting from dividing the current share of something over the previous share) and the other is the share itself at one point in time. "Fastest growing" can mean that something had a certain share in the total and now it has a much bigger share, *or* it can mean that it was at a certain absolute number and now that number has multiplied. To evaluate what it really means, you need to know both things --but the point is, *both of those things are percentages*. The fact that you need to know both percentages is not what Brian is criticizing. He is saying that you should focus on the absolute numbers. He is very wrong.
tl;dr Not done yet, probably six months away from abandonment in favor of something more fun and less practical.
And thus the cycle of perl6 continues...
This should only be a problem if you're responsible for his work on this or you're paying for it.
Who knew that even /u/educated_poo's weird vendetta could have some value? I hadn't listened to [Circles and circles and circles again](http://www.youtube.com/watch?v=Tf8oNq9uTPU) in years.
MoarVM has moved very fast since it's inception, as has Rakudo JVM. The Parrot mess is behind us now, and we should start seeing a lot more progress soon :)
Just in case anyone is misinterpreting Qinsd: The only reason it's currently worth posting updates like this and talking about P6 at places like /r/perl and PerlMonks is to attract Perlers interested in **contributing**. For contributors there is indeed the excitement of rapid progress at the moment in relation to the JVM and MoarVM backends as well as of P6 more generally. But if your only interest is as a user of a polished product I strongly doubt 2014 (and maybe even 2015) is your year.
Well, I feel ambivalent. On the one hand, the decline is "real" because there's stiffer competition for general-purpose scripting these days (and nothing wrong with that). But on the other hand, Perl still has many advantages and I still default to it for server-side stuff, so raw measures of popularity are not relevant. I hear complaints from Python and Ruby programmers that their fave languages are in decline, if not in raw terms, at least subjectively and everyone knows that massive popularity (the kind all three have enjoyed) just doesn't last forever.
I think it's important to paint an accurate picture of what's going on in the p5/p6 community. Yes, perl6 has been a long time coming, but then it's a very ambitious language. Without a doubt there's been a marked acceleration in the pace of perl6 development as of late, having to do, if nothing else, with the abandonment of parrot and the advent of moarvm/rakudo jvm. perl6 suffers from a perception problem due to the lengthy and highly public language design process (which started in 2001 I think?) This is vastly different from most of the trendy languages these days. IMO this is because TimToady et al were more focused on perl6 being an answer to java rather than banging something out, like the inception of ruby/python. There remains a need for cautious optimism and carefully measured words in order to achieve that.
I'm surprised that any Python folks would be complaining. I tip my cap to them because really, this was their year, at least in my field. They seemed to have made a lot of progress not only in traditional scripting language tasks, but also in scientific computing. In the halls around my office the only question is whether people are using Python or R. For the past 20 years I've gotten together with a college buddy on New Year's Eve and one of his traditional questions has always been, "So, what is new in the world of perl?" and I've usually had something clever to report, or at least something that I could spin in a positive direction to justify my undying love for this language. This year? Nada. I expect I'll still be writing perl code in 15 more years when they drag me away from the keyboard, hand me a gold-plated watch, and throw me into the snow. I will keep loving perl because it has always been good to me; but I fear new programmers will soon look at perl and see it the same way they do line-numbered BASIC on spools of green and white fan-fold paper.
Ohloh is probably not the best measure of Perl projects. My guess is that a lot of Perl projects where not in github or in a place easy to find. That might be changing as more Perl projects use github at least as an external mirror.
It is certainly encouraging to hear the Perl6 development is ongoing and that headway is being made. Part of the *problem* (if we can call it that), is the changing context of the news though. I still remember using perl for the first time and wanting to immediately throw all my sed and awk books into the shredder because I had found absolute nirvana. But now? There are more new languages and packages being announced every day then I will ever have the chance to use, and steady progress does not really compete with all of that news and energy.
&gt; That didn't cover somethings of interest to me (Catalyst and DBIx::Class). There were a couple of DBIC and Catalyst mentions (one Catalyst major release and the Advent calendar), but I'm happy to update the post with anything else you find appropriate.
Every year there is significant perl-6 discussion. Maybe some year there will be significant perl-6 worth using.
&gt; Without a doubt there's been a marked acceleration in the pace of perl6 development as of late I too have seen continuing acceleration since the low point in 2011, but I'm concerned lest folk get the wrong impression; the low point was low, there's plenty more still to do, and what P6 needs is patience and, preferably, more contributors. &gt; having to do, if nothing else, with the abandonment of parrot and the advent of moarvm/rakudo jvm. Fwiw P6 still hasn't officially abandoned Parrot as a backend. What happened is that the Parrot project, which never went well, lost most of whatever dev momentum it did have in 2011 and now appears to be at a dev standstill. I think that switching attention to the JVM and MoarVM has been a (necessary) net drain in apparent progress so far. That said, it paid off a little last year on the JVM/concurrency front, and looks set to pay off nicely in terms of real progress this year and next. I think the dev acceleration is due to 1) the natural acceleration that happens as an ambitious project matures and 2) increased contribution. In 2013 the continuing contributions of about a dozen long term major P6ers (coke, colomon, japhb, jnthn, masak, moritz, timtoady, etc.) was coupled with a few new major contributors (most notably froggs, lizmat, and timotimo). Given how good the #perl6 vibe remains I'm hopeful that these existing contributors will keep going and another half dozen new contributors, or perhaps past contributors, will appear or return in 2014.
Parrot abandoned? More like Osborned. An official announcement would mean that someone on #perl6 would have to admit a mistake, but in for one Osborne in for them all, eh ralphie-boy?
Are you seriously suggesting that that (or indeed anything) is justification for trolling?
Do you really want to go through a list of all of the promises perl-6 has made in the past decade and change and mark all of the broken ones? Do you know why people think that Perl is dying? Partly because in over a decade perl-6 has made a lot of noise and released nothing worth using. That hurts everyone who wants to work with Perl. If saying that is trolling then I'm a troll.
Is Unixness the Bell Labs New Jersey "get something simple working, then let it evolve" approach of Perl or is it the MIT "it must be perfect so keep revising the specs and throw away many prototypes and rewrite everything" approach of perl-6? Or did I answer my question?
Tried to find work in Perl lately? perl-6 was supposed to replace Perl 5 by 2003 or 2004. Ten years later people see Perl 5 on your CV and think you're a COBOL dinosaur. Thanks for nothing, perl-6.
Everything I mentioned. Work on optimisation, modules and ultimately a compelling use case for people to want will take many more years. In bioinformatics just grammars and auto threading is enough to interest me. When did a single random person on the internet become the official line for a project anyway? I like your troll mask it makes you look like a jerk.
It sounds as if you are/were quite heavily invested in the success of perl6. I'm sorry that hasn't borne fruit, and can understand why the slow progress would frustrate you.
Insert the following on line 5: use strict; use warnings; Run it again. Until you have a very good reason not to, always use strict and warnings (hint: you're not likely to have such an occurrence, and even if you were you are a very long way off from that). Edit - I should add that you have a number of other issues as well, but you're not going to identify any of them fumbling around in the dark.
&gt; [–]educated_poo 1 point 8 hours ago &gt; &gt; I was on a working committee, helped with two RFCs, chatted on IRC for years, answered questions on p6l, and donated to TPF for perl-6 development. So yes it's a problem. chromatic? Is that you there?
Usually when reading from `STDIN` you assign it to a *scalar* and not to an *array*. So the first thing I'd do is change `@input` to `$input`. Secondly since you're trying to remove the newline it's probably a better idea to use `chomp` instead of `chop`. Nit-picky, but thought I'd point it out. Then since `$input` is now a scalar all you need to do is to run that split and store it as an array of words! So that'd look something like `@words = split(/ /,$input)`. Then we want to loop over all the words that we have: `for my $word (@words) { ... }` You can do your compare inside of there. Finally it's a really good idea to get in to the habit of using: `use warnings` and `use strict` on all your perl. It really helps you avoid lots of problems. So taking all of this together I'd end up with something like: #!/usr/bin/perl #Name: 1.pl #Desc: Program to count the instances of the word 'the' in STDIN use strict; use warnings; print "type a sentence with the words 'the' in it\n"; my $input = &lt;STDIN&gt;; chomp($input); my $wordcount = 0; my @words = split(/ /,$input); for my $word (@words) { if ($word eq "the") { $wordcount++; } } print $wordcount; There's other ways to go about counting up words, but this is a good start.
you're a genius. Is it possible to take it as an array and then parse though it? if not I can live with that. I have just started learning perl, mostly for work, but sounds like it's going to be an adventure :) I may call on you guys for help in the coming weeks 
 C at #1? What a joke. But, Perl is dying guys. Failure to get basic features in for many years killed it. 
So first off: **Always use `strict` and `warnings`** Second: in line 8 you're useing `chop` use `chomp` instead and forget that `chop` even exists, you'll never need it. If want to use an `while`-loop for reading in: `while (&lt;STDIN&gt;){chomp; my $line = $_; …` If you really want that Array (note that you're filling unneeded memory that way) try an `foreach` loop. Like `foreach my $line (@input)` Next your counting: this is perl there are thousand ways to do that. So I'm guessing you want to split the line at spaces, right? `my @words = split (" ", $line)`; you don't need your $count variable here. Next you want the number of all that words that are "the". Now I personally would use the `grep` function for that, but that seems a bit to much for an beginner, I'm just mentioning it here. You'll need a variable that resides outside the loop that keeps track of all the "the"s you already have found, I go along with you and call it `$count`. now iterate over the Array of `@words` and increment the variable: foreach my $word (@words){ $count++ if $word eq 'the' } and now exit all the loops. Sorry your program was far from the solution so i just wrote up what came to my mind, hope that helps obligatory one-line solution (for other redditors, because there is one funny operator in it, and it's so rare to see it): `my $count =()= map{/\b(the)\b/} &lt;STDIN&gt;;` **Edit:** formatting
This way you only get the numbers of the in the first line of `&lt;STDIN&gt;`.
In addition to the other advice here, my tip is to name variables a little better. Not only will it make your code easier for others to understand, but it will make your bugs easier to find (or more likely you won't create the same bugs to begin with). For example, instead of @input I'd have used @lines (it is, after all, an array of lines of text), or maybe @input_lines or @lines_input. Your worst offender (and the source of your problem) is $count - what is it counting? The while loop condition ($count &lt;= @input) suggests it's counting lines, but the word test (@words[$count-1] eq "the") suggests it's counting words. Had you named your variables more appropriately, you'd see code like this: if (@words[$line_count-1] eq "the") { which, mixing words &amp; lines in one expression, should start alarm bells ringing immediately. Also (and I know it's already been said, but it's so important it's worth repeating), put these 2 lines at the start of every perl program you write: use strict; use warnings; They will find problems in your code, and force you to declare your variables before using them (which might seem like a pain in the behind at first, but is a really good thing). 
Do what it suggests. Your code should say: `$words[$count-1]` and not `@words[$count-1]` If `@words` is an array, then one item in that array is `$words[$i]` - note how the `@` sigil at the start changed to a `$` - that's because each item inside the array is a scalar (Perl5 arrays can *only* hold scalars). You only use the `@` when referring to the whole array (or slices, which are a more advanced topic), not for accessing individual items within the array. 
&gt; would someone mind explaining why I should not just use Perl for pretty much everything above very simple / couple of lines long shell scripts Can't explain it, because you probably should. ;) I write Perl code for a living for everything from tiny scripts to large enterprise web applications, so obviously I'm biased, but I'm in the same boat you are: There are a lot of ways to get things done, but a lot of the easiest and most efficient ones for most tasks I run into are in Perl.
Good start, but can be written more elegantly: map { cond($_) ? $_ : () } is the same as grep { cond($_) } even in scalar context (which doesn't have to be made explicit here). Then, we can do this for any number of lines by either setting `$/`: print "type a sentence with the word 'the' in it\n"; print "Finish with an empty line\n"; local $/ = "\n\n"; ... or by terminating at EOF/\^D and using all input: ... = grep { $_ eq 'the' } map { split } &lt;STDIN&gt;;
Indeed, yours is superior. ;) To be fair, wasn't necessarily shooting for the most condensed version but was hoping to give exposure to a few other concepts (scalar/map/split) the new dev might have gained some benefit from and threw it together quickly. That said, I appreciate the input, and learned a little something in the process. Thanks!
Retrain in bioinformatics and you will have a job for life in Perl hacking...
I agree with the others posts that explain how the script should be rewritten for clarity and to use idiomatic perl. I just want to point out what your *actual* error is; here: @words = split(/ /, $input[$count-1]); if (@words[$count-1] eq "the") { you are using the same counter to check over all the lines in your input **and** over the words in your lines. The problem is, you are using a single loop for them. So at every loop you are only checking if in the Nth line there is "the" as the Nth word. This is logically wrong. Here how it should be rewritten in the same style as the rest of your original script, using two nested loops: while ($count &lt;= @input) { @words = split(/ /, $input[$count-1]); $count2 = 1; while ($count2 &lt;= @words) { if (@words[$count2-1] eq "the") { $wordcount = $wordcount++; } $count2++; } $count++; } Anyway, you *should* use idiomatic Perl; in this case is much better to use "for" loops without an explicit index, like this: for my $line (@input) { chomp $line; # chomp only delete the last character of a string if it is a newline my @words = split / /, $line; for my $word (@words) { if ($word eq "the") { # when you do an increment the variable is modified in place, no need to assign it to itself $wordcount++; } }
Fair enough. I was thinking I'm missing some trick by giving up and resorting to perl. 
Could you give us ([PerlTricks.com](http://perltricks.com)) a mention please? We launched in March 2013.
Looks very similar to DateTime. Without timezones that is.
Good article. While DateTime has more features than Time::Piece, it is also much slower and memory hungry (http://howcaniexplainthis.blogspot.fr/2009/06/datetime-performance-hit.html). So yeah, you should only use DateTime if you really need it.
Time::Piece::MySQL has nice shortcuts. $date = Time::Piece-&gt;from_mysql_date("2014-01-01"); $datetime = Time::Piece-&gt;from_mysql_date("2014-01-01 00:00:00"); 
I was able to get my Perl Certification while having only having gone through Learning Perl and browsing some articles on it and writing some. I think mastery comes from practice, so just write something you want to see to consolidate your knowledge. 
There's a cert for perl? Is it widely recognized? When did you get it? How much did it cost to get? Did your job prospects improve?
&gt; CIW Web Design Specialist That's not *technically* a _Perl_ cert but a more generic certification that I suppose happened to include Perl in your course work. The CIW [page](http://www.ciwcertified.com/Certifications/Web_Design_Series/design.php) describing that cert doesn't actually mention Perl at all. I'm happy you feel the certification has improved your job prospects, never underestimate the value of self-confidence, but I'm not aware of a single widely recognized Perl specific certification. A quick search shows there are several out there, however I have yet to see a reputable Perl company request or require one as part of the hiring process.
The best way is the one that makes you productive. Intermediate and Mastering Perl didn't exist when I was learning Perl, but I did read both of them as well as Programming Perl, Effective Perl Programming, Object Oriented Perl, Minimal Perl, The Mythical Man Month, Extreme Programming Explained, The Diamond Age, The Elements of Style by Strunk and White, and just about any other book on programming I could easily get my hands on. The single best thing I found for mastering Perl was contributing code to a community and getting feedback from other people.
I would say option 2 is going to be the easiest way to not only to get started, but to understand. I would also add: * Perl Best Practices * Perl Cookbook As for Modern Perl, you can read it later, but then you will know most of what it says, except for Moose, but the [metacpan](https://metacpan.org/release/Moose) module explains it quite well. Also it's better to understand Perl's standard OOP, as Moose is heavy, and will never become apart of the core. :( 
Reading the documentation as if it was a book is my suggestion. At least you'll know what's in there.
Yes, I do.
I've used Perl since 1998 and still don't know all of it. I can do anything in Perl but I don't know all the syntactic sugar yet.
Then "Learning Perl" will bore you, and "Programming Perl" is the better approach, IMHO.
I wish. Python's taking over in my department.
I'm all for making any/all parts of Moose into the core. I do like working with it, and I agree it has gained quite a large following in the Perl community, I just feel it's just too big a dependency. **[EDIT]** And thanks for the Object::Tiny link, I think I just found out where my weekend is going. 
Thank you!
On this very Reddit page you can scroll down and see that the post at the bottom of the page was made 16 days ago. In other words this is a very low-traffic subreddit. That tells you everything you need to know about Perl. The Perl powers that be announced Perl6 in 2002, never delivered it, and in that decade PHP ate Perl's lunch; and now Ruby and Python have finished the job. Neg away. You know I'm right.
tail recursion optimization can help memory usage (here using the new __SUB__ token): sub { ... goto __SUB__ }
re: multidimensional data structures. I feel strongly that the standard document [perldoc perldsc](http://p3rl.org/dsc) should be discouraged, it's a crutch that hurts the user in the long run. Better to read the overlooked and underrated [perldoc perlreftut](http://p3rl.org/reftut) which teaches you everything you need to know in 5 simple rules. It's my favorite perldoc!
You should point out that there is an error in the library with the highlighting of `length`. or change that in your example code (it's not a good idea anyway to use built-in function names for object attributes).
Is it a bug or a feature that reserved words used out of context are given the 'kwd' class?
Running the commands in parallel could be an obvious way to speed things up. And there's a script, written in Perl, just for that: https://www.gnu.org/software/parallel/
You might also want to look into curl multi http://search.cpan.org/~crisb/WWW-Curl-3.02/lib/WWW/Curl/Multi.pm I am not sure there will be a huge difference but it might be a little more efficient
I'd suggest [Parallel::ForkManager](https://metacpan.org/pod/Parallel::ForkManager) pretty simple to use. You'll need to do some file locking to not clutter your output.
So much yes
Cool. I've just been running everything through `highlight --fragment --include-style --enclose-pre --inline-css` ; this does look prettier.
Nice! Personally, I'd like the job title "Software Artisan" to catch on. Or at least something that hints at the creative process behind it all. Good programming is a lot closer to architecture than bricklaying.
There are plenty of Perl modules that can do the network stuff for you. Mojolicious, for instance, supports web sockets so you don't have to open and close connections for every request. Other than that, the network time is something you can't easily control. You might investigate other ways to get the data. Maybe they have a data dump or they'll be able to make an easier way for you to get chunks of data in a single request.
So it is a scanner! Well, learn to use IO:Socket or File:Fetch, n00basaurus. Spawning a new curl process for each get is insane.
you said "efficiently", so this: http://act.yapc.eu/ye2013/talk/4977
Done now. Thanks for letting me know.
I'm curious, what do you need node for? Updating the version of angular?
"Perl in a Nutshell" was a great reference when it was published. But it was last updated in 2002. Perl has changed a lot in the last twelve years, so anyone reading that book will be getting some great but rather out of date knowledge :-/
Whoa, I came back to this because I wanted to do precisely this with Windows and the comment I came back to check has been deleted! Dammit! I guess pp is indeed dead.
That's the PPI libray having a problem. In what cases would that be a feature?
I use bower to install front end packages like angular, yes. I also use grunt for deployment to min/uglify jss and css assets. You can easily clone this project and use it without node. But you will have to manually install your front end packages and make your own tools for deployment. But thanks for the question, I will update the doc to remove the dependency on node and put it as an add on.
[This search](https://metacpan.org/search?q=exchange) on [MetaCPAN](https://metacpan.org) produces as its top results: * [Mail::Exchange::Message](https://metacpan.org/pod/Mail::Exchange::Message) * [Email::Folder::Exchange](https://metacpan.org/pod/Email::Folder::Exchange) The latter is only specified to work up to Exchange 2010, but maybe there have been no significant changes between 2010 and 2013 that would prevent it from working?
Why does it have to be either or? Why can't it be both?
Oh, oops, I didn't realize rjbs wrote it. I retract all objections. More seriously, the process of installing dzil modules could use some polish. Someone had to tell me about the 'dzil' command line and 'authordeps' and how to feed the output of that to cpanm if I didn't want to iteratively install a module, try again, fail, install a module, etc. automake, another miserable beast of a build tool, comes with some boilerplate text about how to use the bloody thing. That could be a positive step for dzil dists. A stub Makefile.PL that invokes dzil wouldn't be bad either. I have enormous respect for rjbs, but less in-the-loop Perl programmers are going to be frustrated when something that used to work stops working without warning. Let's focus on constructive solutions that involve neither the abolition of dzil nor telling Perl programmers to essentially deal with it. Remember that googling Perl related things is often not productive. tl;dr what wdr1 said
A stub `Makefile.PL` is all well and good, but if you're going to complain that it's not obvious to use `dzil --authordeps` (and it isn't) then I'm going to complain that it's not obvious that you need to install `make`. Then again, I could be biased.
Me too. Thanksfully only new-school super modern bobos do without EUMM, and rather seldom need to use their modules.
The OP claims that Dist::Zilla is not required for his own repos, but is that strictly true? With some plugins it's possible for the code is not compile until D::Z has been run over it, right? Aside from that, I appreciate that it's best for the authors, but my singular experience with dzil involved a single dep a ridiculously large depchain for some plugin failing to build. dzil could take a leaf from cpanm's book and make it easy to run out of the box, even if that does mean flatpacking stuff.
It is not required to contribute, meaning you can check out my repo, install prereqs, write a patch, test with prove, and send me a pull request without ever installing Dist::Zilla. I do most of my development testing with prove and usually only run dzil at release time.
Boilerplate like this? http://screencast.com/t/5BurI5BTEXFu
Agreed that it isn't obvious to use 'make', but knowledge about how to do it that way fanned out to the point where even Google knows about it now, and Google does know about it. If we can't have in situ docs and Google doesn't easily dig up how to do it and the knowledge hasn't spread out through word of mouth, then that's a roadblock to adoption.
I do not see a lot of huge issues here. You have the regular expression backward on line #62, it should be something like: if($type =~ m/SSD/) { Try and simplify your %box code to be something like this: my %box = ( 'ssd' =&gt; \@ssd, 'hdd' =&gt; \@hdd ); I have not run it to see how it all works, but hopefully this is a step closer.
Thanks! I didn't realize the backwards reg ex on line 62. Fixing that fixed the syntax for me! I must of mixed it up earlier when I had other problems I was fixing, tried matching "SSD" =~ m/$type/. Now I have to wait until tmr to go to work and see if it works!
Great! Good luck!
Call it a pet peeve, it irritates me when people use regular expressions to match short strings exactly. Consider it the equivalent of taking a supersonic plane to go to the other end of the runway ... Considering the half hour warmup and prep time, not to mention getting permission from the tower, it might be faster to run, bicycle, take a motorcycle or car ... Why not just use: if ( $type eq 'SSD' ) { if you expect an exact match, or if you simply expect the characters to appear somewhere within a string, use: if ( -1 &lt; index( $type, 'SSD' ) ) { 
Well the actually line will be Disk Hardware type : SAS-SSD Hard Disk I wasn't aware of any other way to match it, mainly because it can change but will always have SSD in it somewhere. I wasn't aware of index, still fairly new to perl. Though personally I think with the =~ it's a bit easier to read, especially for people who don't use perl much. Thanks for the tip though!
I'm with you on this - for matching an exact string eq is more appropriate, but using index like this just decreases readability. Perl's regex engine is super fast, so odds are it's never going to be a performance issue that using index but sticking with pure perl is ever going to fix.
If what you have works, why not stick with it? Is there some particular deficiency that you think might be solved with a CPAN module?
The main causes of my dissatisfaction with the script so far are the speed of CVS command execution (directories of files need to be looped through and CVS commands with unique parameters need to be applied to them) and the clunkiness of authentification (can't check if there is RSA, the whole thing breaks down if user login or password is incorrect). I want to know if any of the CPAN modules might improve this.
Important to note: this is just for Perl **E**books: &gt;For one day only, SAVE 50% on Perl **ebooks** and videos from shop.oreilly.com and watch your productivity soar. The headline got my hopes up for hard copies.
Thank you! I got my hopes up, too. Poor choice of words in the title.
Ricardo's code can fairly be called a lot of things, but I don't think spaghetti is one of them. He does use a lot of abstraction (sometimes maybe too much) but I haven't found it especially difficult to use his code. And I've written both PodWeaver and dzil plugins, so I'm somewhat familiar with their internals.
What do you mean by "Ebooks are better off free"? There's a lot of work that goes into creating an ebook.
I'm a fan of free access to knowledge.
Were you compensated for your work at least as well as if you had if you had pursued those business opportunities?
No "use strict", no "use warnings"... what's wrong with Net::NTP? http://search.cpan.org/~abh/Net-NTP-1.3/lib/Net/NTP.pm
That's very hard to say. As a general rule, tech book authors are given very small advances because most tech books sell maybe 5,000 copies. You have to sell enough copies for your royalties to out-earn your advances and that usually doesn't happen in our industry. That being said, I can out-earn the advance pretty quickly in consulting or training fees. But would I have gotten those opportunities if I didn't have this book under my belt? I have one contract that I'm negotiating in part because I have that book and that's because the company has legacy Perl code and doesn't know anything about the Perl community. It all depends on the author and I'm admittedly an outlier because I'm one of the better known people in the Perl community. Other authors have made it clear that publishing a book is what gives them their credibility and they accept the sacrifice of temporarily [making less money than panhandlers](http://www.komonews.com/news/local/15157611.html) in hopes of the long-term reward of more business opportunities. So for the tech author, the money from the book is almost irrelevant (this may be why [chromatic gives away Modern Perl](http://onyxneon.com/books/modern_perl/index.html), but would like you to pay for it if you wish). However, to publish a book and get it widely distributed and recognized, many authors feel that having a well-known publisher (particularly if it's O'Reilly) backing them gives them more credibility than a self-published book. As a result, the publisher needs to earn back their money and it's only fair if I, as an author, agree to let the publisher charge for the book.
If the exchange server offers POP3 or IMAP access, you can use any of the standard modules. Then yes, shouldn't be too much work.
Someone needs to be ***that*** guy. This method is fine as a first approximation, if you don't mind +/- a second or two. Just ask for an reply and grab the time out of it, okay. But if you want accuracy well under a second, you need to look closer. Asking a remote host what time it is overlooks the whole point of NTP, which is how to deal with network latency, jitter (how much a remote clock wanders), and offset (how different is the remote clock's time from your time), in addition to assessing remote hosts overall quality of timekeeping and throwing away outliers. I encourage anyone interested to look at the Mills algorithm and read a little further; it's a fascinating topic of getting the most accuracy possible out of a messy situation. To sum that up, you need a "real" ntp client to do the math. It could well be written in pure perl.
You don't need strict and warnings if you know what you're doing :)
Ovid, I know you from Perlmonks. Do you have a full time job? Do you consult? What's your hourly rate?
Just take a look at http://perldoc.perl.org/perlfunc.html#Perl-Functions-by-Category Input and output functions "binmode", "close", "closedir", "dbmclose", "dbmopen", "die", "eof", "fileno", "flock", "format", "getc", "print", "printf", "read", "readdir", "readline" "rewinddir", "say", "seek", "seekdir", "select", "syscall", "sysread", "sysseek", "syswrite", "tell", "telldir", "truncate", "warn", "write" With the exception of maybe 5 of them, you all know these as POSIX syscalls, right? Or another section: Functions for filehandles, files, or directories "-X", "chdir", "chmod", "chown", "chroot", "fcntl", "glob", "ioctl", "link", "lstat", "mkdir", "open", "opendir", "readlink", "rename", "rmdir", "stat", "symlink", "sysopen", "umask", "unlink", "utime" 'nough said.
I'm a full-time consultant and trainer: [allaroundtheworld.fr](http://www.allaroundtheworld.fr/). My hourly rate depends on what I'm doing and what gets negotiated. My wife handles that side of the company, so if anyone wants to retain my services, I cover the technical side and she covers the business side.
&gt; The majority of my team would not understand "if (20 .. 40) { ... }" So, they're not in position to read a lot of valid Perl code then? Flip-flop op is used since always in Perl, your team should be familiar with it. Also, goto &amp;sub. It's standard. And these are pretty well documented features of the language, hardly corner cases.
I have only programmed Perl for 6 years or so, but I have never seen the flip-flop operator in the wild and only seen 'goto &amp;sub' once. And yes, I wtfed when I saw it. I have read Programming Perl from end to end, but Perl is a frickin' big language and you can't remember everything. Most of my team learned the language on the job, few people know the language nowadays. If you can read and remember the whole of the perldocs, great, but most people pick it up as they go along. I don't expect people to know about formats either.
Sorry, I always panic when someone declares parts of Perl unusable :) I wanted to say that these features are pretty well documented and known, so they can be understood and used without much problem on programmer's side. Flip-flop is used a lot in one-liners and parsing simple stuff, I've mostly seen in on perlmonks as far as I can remember. I'm actually not sure if I've ever used it myself. I've seen goto &amp;sub in a lot of code from CPAN (edit: [for example](https://metacpan.org/source/ASG/List-Gen-0.974/lib/List/Gen.pm)).
These corner cases of the language are like using big words — they exist for a good reason, and if you avoid them just for the sake of the idiot in the room, you'll come off as a bit stupid yourself.
I think you can look Perls Age combined with its backward compatibility. From design failures (Array params as a list) to things script languages handle for their own nowadays (care of references) or things that were insertert afterwards (like minimalistic OO) . Not minimalistic because you can't achieve everything, but you have to do a lot of hand work to get a comfortable Version or install one of dozens modules (which all are different in usage). I miss data types and the ability to easily create new ones. Imagine a hash that is defined like a struct/record, you could use auto-complete, error checkings, ... Real named params, not this hash emulation. ... I like Perl, but i think it's not state of the art anymore.
Are you sure you want multiple databases? Without thinking about it for longer than two seconds it might be easier with one DB with a city table, a neighbourhood table, a street table and so on. Or an address/location tree-based table. Depending on what the settings are, you may be fine storing them as configuration. If you have a separate city per DB you're going to have to maintain a connection to a lot of different databases, which sounds like quite a lot of trouble to go to...
Unfortunately the DBs are already made, and working. I have to make it work based on them, because other (independent) systems rely on them. I know it's a lot of trouble to do it. Indeed connection parameters will be set in config files. What I don't know how to do is how I can structure controllers, something like inheritance, so that each will make available what they have. I mean: Cities.pm will have common attributes for 'cities' and when a city :id is accessed it will pull from the config file it's parameters, but those parameters names will be held in Cities.pm...Am I making myself clear about this? Does it sound complicated? Thank you :) 
This is pretty much my view as well. For most purposes (even if you aren't a new programmer) it just isn't clear why someone would choose Perl over Python. What does it really offer at this point? Your post points out that Python looks simple, but in my experience it also remains reasonably simple even when used for more serious projects.
Since Perl 6 is going to change everything, they keep having to refactor for everything having changed.
Perl 6 solves many of these complaints and is one of the reasons I'm considering learning it (specifically the currently dominant implementation, [Rakudo Perl](http://rakudo.org/)). Edit: ok, one downvote. Why? Do you think Perl 6 is a waste of time?
`goto &amp;sub` has a very specific use for tail recursion and keeping stack traces clear of cruft. Neither should be used very often, and it should always come with a comment justifying and explaining its use. But when you need it, nothing else will do.
Well it doesn't handle lexical scoping as you might expect, and the 2.7 vs 3 debacle are non obvious problems with it. edit: but python's problems are non existent to most people who doesn't have experience with something else. Meanwhile we care about each little thing and each little operator and any other kind of bike shedding thing.
perl paid the bills for a long time for me and I still have a few apps written in perl that are in the wild. However, whenever I mention perl as a tool for e.g. systems work or even full-on applications, I feel like a dinosaur. Most people look at me the way I used to look at a ksh hacker who hadn't discovered perl yet. I got in right when perl5 was released so I didn't have to deal with the transition from perl4. Every perl4 hacker I know did make the transition and moved on to perl5 very quickly and kept the momentum going. I feel the prolonged development of perl6 has irrevocably hurt perl for new users and established users alike. As much as I continue to love perl, I find more and more that ruby feels like the spiritual successor to it both in terms of how it's used and how widely it's used.
You said it well 'Hopefully'. Unfortunately they are all on different servers :( Do I have any hope to make a restful URL with classes that inherit from one another?
As an "experienced" Python dev, I started learning Perl last year and really fell in love with it, as a replacement for more complicated bash scripts. With the built-in regex, the succinctness of the language, and shelling out with backticks, it really makes sense to code some command line tools and log parsers in it. I would always use Python for a larger project, but perl is definitely a useful tool for smaller scripts that I need to parse a log and give me some data. I know it can do plenty more, but I feel that i have a much easier time writing maintainable projects in Python.
XML response? Why not use something more standard to REST like JSON instead? I recently wrote a perl module for work (REST::USPS, not yet open source) that required this to be used, but the [JSON module](https://metacpan.org/pod/JSON) made it really easy to encode/decode JSON. Give it a consideration.
I know what you're saying, but XML response was a requirement. I proposed JSON of course, but the data won't be so big so it won't make much of a difference. Also I'll be using Mojolicious and it has a render method that works like this: $self-&gt;render( json =&gt; $hash_ref); or $self-&gt;respond_to( json =&gt; {json =&gt; {hello =&gt; 'world'}}, xml =&gt; {text =&gt; '&lt;hello&gt;world&lt;/hello&gt;'} ); this is the least of my concerns. The biggest issue is how to create controller inheritance for the given URL :| Thanks for response :)
As a hobbyist programmer, I've dabbled with both python and perl. My two cents: I found perl much easier to start with than python. One reason is TIMTOWTDI. I could hack together code however I could make it work pretty quickly. The code was abysmal, but with a bit of Googling and trial and error, I could get it to do what I wanted. Another reason is CPAN. First, there is an extensive library of packages, and second, it is *incredibly* easy to manage these packages. I rarely have issues installing new packages thanks to CPAN. As time goes on, I learn more and more about the *right* (or at least *better*) ways to program in perl. One of the early challenges was learning how perl deals with objects, though. I think python actually has a steeper learning curve. Some reasons: It wasn't as intuitive to figure out how to structure a basic script. It's less obvious how to do basic operations (e.g., if I want to add elements to a list, I need to know about 'extend', and I need to make sure I don't incorrectly 'append' to the list). I started with Python3, and you have to be careful about which version documentation and examples are written for. Package management is poor compared to perl, in my opinion. I use helper tools like easy_install, and I still run into issues. Package management in python probably isn't that bad; rather, I think it's so good in perl that many other languages can't compete. So that's my subjective experience as a novice programmer. They're both nice languages. I just found perl easier (and more fun) to dive into. Oh, someone else in this thread reminded me of this one: I really like perl's regex, too. 
Unfortunately I don't feel very qualified to answer this as its pretty far from my area of expertise. My only suggestion would be to look into [bridges](http://mojolicio.us/perldoc/Mojolicious/Guides/Routing#Bridges) which may help. Otherwise I would just suggest writing a method which inspects the stash and provides the correct db handle.
perl-6 is a fun toy if you want to solve math puzzles. http://rosettacode.org/wiki/Perl_6 but if you want to use any of those features in production you're going to have to babysit it for several years until perl-6 becomes a serious project.
Indeed bridges might be a solution and maybe combined with stash values. Thank you :)
Perl 6 has been right around the corner for well over a decade now. 
Which corner? I want to surprise it.
What are some inherent things that would make Python more maintainable in your opinion? I see that all the time but if you could shed some light into it it would be great.
2026
**Perl 2026** sounds awesome.
Thank you for this post. I thought I am the only one who feels uncomfortable with Perl6. It's simply too much for me. 
I don't enough about Perl to claim it's not maintainable... I do see things about it and I have a way of coding in it that makes it hard to understand what's going on at first glance. Overuse of implicit $_ for example. It's just not nearly as obvious to me how to work on a script in Perl, especially if I overuse regex, which is fun and easy in Perl. I've spent a lot more time working and collaborating in Python than all other languages, and I have a better understanding of longer term projects, and how they should look and be structured. I can't claim that Perl isn't as maintainable with experience.
&gt; I can't claim that Perl isn't as maintainable with experience. Familiarity is a substantial (and underrated) aspect of maintainability. It's good to hear that other people recognize it.
Perl is definetely not trendy. It's not the easiest language for newcomers to pick up and looks "messy" (to those who haven't even completed a Perl hello world, but think they know enough to pass judgment). However, as a Perl developer I have learned not to get tied up with the language debates. Skilled Perl developers get stuff done as well if not better than Python developers and our community is amazing.
&gt; Why not use something more standard to REST like JSON instead? Data::HAL author here. Plain JSON cannot be used in REST because the format does not have hyperlinks, it's not standard. XML does (via XLink). Please submit your module on http://lists.perl.org/list/module-authors.html for review.
Use bash instead: ls *.txt | while read; do mv $REPLY new_$REPLY; done
That's a terrible idea. For one thing, as written it will fail with filenames that contain whitespace or backslashes. That can be corrected by [not trying to parse the output of `ls`](http://mywiki.wooledge.org/ParsingLs) and instead using a glob and proper quoting, but then you run into the second problem which is that it forks and execs a whole `mv` process for every file, which is extremely inefficient if you have a lot of files to rename. Not only is the perl version shorter, it suffers from none of the above problems: $ perl -e 'rename $_, "new_$_" for &lt;*.txt&gt;' 
This looks amazing.
i started using Perl within the last 4 years out of necessity at work. we run Oracle client on application machines so the app can interact with and Oracle server. Oracle client comes with Perl out of the box, and our client is finicky about what we install on the machines. i say that to preface that i was forced into using Perl, but i have grown to love it. it's great for sysadmin tasks, file i/o, database interaction, etc. sure you can get the same functionality in [X] popular language, but at the end of the day isn't it more about getting your programming tasks finished?
On my tablet right now... Otherwise I'd try it myself... Can you use this with fork? Fork workers out? And can you communicate via pipe?
*Lobs a [v5](http://perlmonks.org/?node_id=1041925) into the discussion and hopes it doesn't cause too many explosions.*
Your answer to "what features should be excluded" is "anything worth using"? Stay helpful, ralph.
I'm having trouble with this perl-6 program, ralphie boy: constant parrot = %*ENV&lt;HALFARSED&gt;; constant moar = %*ENV&lt;HALFARSED&gt;; constant jvm = %*ENV&lt;HALFARSED&gt;; constant rakudo = $parrot + $moar + $jvm; say rakudo; It keeps giving me "HALF-ARSED". From what you say you are CONFIDENT ABOUT, three half-arsed backends should eventually equal one full arse. Is this an optimizer bug or does camelia have a special form of math?
It's not a year. It's the number of times they rewrote it before it was usable.
Anyone knows if this would play well with mod_perl?
username223 has a strange fascination with my arse and likes to discuss it in public. username223 is strangely not so fascinated by ralph, who seems to be a throwaway account determined to convince the world that perl-6 isn't an arse.
It would probably work, but it's not a given that it will improve a busy web server. There you already have a bunch of processes running that should more or less fill up all your cores.
Why can't you be civil? You can be nicer than this.
&gt; performance and authentication I think you're stuck with what you have. I don't know any CVS module that isn't a wrapper around a CVS binary. e.g. * http://cpansearch.perl.org/src/RSOLIV/Cvs-0.07/lib/Cvs/Command/Base.pm * http://cpansearch.perl.org/src/STEPHENCA/Cvs-Simple-0.06/lib/Cvs/Simple.pm * http://cpansearch.perl.org/src/MKANAT/VCI-0.7.1/lib/VCI/VCS/Cvs.pm (scan for 'cmd' in each) There are probably others but those are the ones I recall offhand and have used at least once. CVS (RCS) is inherently slow. All data and metadata is stored in the repo files themselves. So diffs and deltas invariably involve full file seeks. You can't avoid it in CVS. Authentication is similar. If you're using pserver, you're stuck. With ssh you may be able to shave a few seconds (minutes?) from multiple sequential commands by [reusing the ssh connection](http://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing). If, at this late date in CVS's lifecycle, you are stuck with CVS (as I suspect - my condolences): I think best you can hope for is to put it on low latency media like SSD's so the reads are faster (if as expensive). You can't really get away from the lock speed since lock files have to be acquired in each directory.
What's the line? "It's Exchange's world and we just live in it" or [something like that?](http://itre.cis.upenn.edu/~myl/languagelog/archives/002947.html) More seriously, I'd suggest taking a serious look at [davmail](http://davmail.sourceforge.net/). It's a Proxy/Broker/Gateway that translates Exchange's [peculiar interpretation](http://www.unixwiz.net/techtips/sbs-remote-access.html) of POP3/IMAP/LDAP and turns them into actual POP3, IMAP, and LDAP responses. From there you can use less... suborned modules such as: * [Net::POP3](https://metacpan.org/pod/Net::POP3) * [Mail::IMAPClient](https://metacpan.org/pod/Mail::IMAPClient) 
So I read this when it showed up this morning, and this afternoon had to write a script to do thousands of network requests. Rolling this in to do it two at a time to speed things up was very straightforward. I expect I'll use it again in the future when converting large batches of data (which I do a fair bit.) Might see about converting my main workhorse conversion script to use a few more CPU cores. 
my %box = ( 'ssd', 'hdd' ); Is a bug since it creates the hash {'ssd' =&gt; 'hdd'} so regardless of simplification its currently wrong.
I wouldn't start with parceling Perl - what to learn and what not. Start with a good recent book (for example: http://modernperlbooks.com/books/modern_perl/) and you're learning good subset of Perl from the start.
What is your problem? There's already plenty in v5 that's worth using in the OP's context: * v5 started with [STD_P5](https://github.com/perl6/std/blob/master/STD_P5.pm6), the **Perl 5 parser written mostly by Larry Wall** in Perl 6. This became [v5's Grammar.nqp](https://github.com/rakudo-p5/v5/blob/master/lib/Perl5/Grammar.nqp). The v5 parser already covers a large subset of Perl 5 syntax, more than enough to make it relevant to the OP, and can be technically easily extended to 100% coverage. The parsing aspect of v5 presumably isn't your problem. * [v5's Actions.nqp](https://github.com/rakudo-p5/v5/blob/master/lib/Perl5/Actions.nqp) generates an AST corresponding to a parse by Grammar.nqp. This AST generation **already implements perl 5 features relevant to the OP** such as pragmas (use vars, use strict, use warnings), control flow (loops, conditions), builtin functions (shift, pop, chop, ord, require, etc.) and math ops. This clearly isn't *everthing* relevant to the OP but clearly isn't nothing either, so presumably the AST generation part of v5 isn't your problem. * **v5 is tested against the test suite used to test the P5P perl5 binary** (or rather a slightly modified version thereof). So presumably the testing aspect of v5 isn't your problem. * The AST generated by v5 targets NQP, the compiler toolchain built for the P6 compiler Rakudo. While it isn't faster than P5 yet, it continues to close the gap (eg **in the past week Rakudo/MoarVM got about 5 times faster at running the Rakudo spec test suite**). It makes no sense for the NQP compiler toolchain to be your problem. So I'm out of guesses. Apart from an apparent burning need to troll, what specific problems do you have with v5 in the context of the OP? **Edit:** Fixed bit about Larry Wall's STD_P5. (Dev actually happened over many years with some contributions by others.)
Like everything else in perl-6, it is an unfinished project with an uncertain future which has no business being used in any serious situation unless you are willing to babysit it when it falls over. That is what you want to teach new Perl users? Why use a half-arsed hobbyist project when you could use the real thing? One which works with CPAN, installs everywhere if it isn't already, has documentation, has test cases that all pass, many real developers, even support from companies? Your constant suckup desire to con some punter into treating perl-6 with relevance it's YEARS away from is quite tiresome, ralph.
That's too bad... I'd be very curious to see a rundown of how they hacked in. Would be good to learn what to avoid in my own work.
I don't think the language should be changed just to teach new people. They can learn the tiny subset they choose to start with and grow from there. As well as *Modern Perl* mentioned already, Ovid's *Beginning Perl*, and *Learning Perl* are all good places to start learning. I think it is probably better to put forth some collective effort to help everyone see what is and can be built with Perl ( E.g. [Built In Perl](http://www.builtinperl.com/) ) as well as working to get in more places such as [repl.it](http://repl.it/). I think showing new people something like: perlcritic -theme pbp --stern from the beginning would probably be pretty useful in the long run.
Maybe i worded it wrong, i'm not talking about forking perl, just collecting a small subset of features to teach perl, baby perl like larry would call it, but somehow structured. perlcritic could help to keep the newbie from tripping on the wrong hood, in a caring and friendly way, not in the UNIVERSE WILL EXPLODE ABORT PROGRAM way.
I think I'm misunderstanding, then. What do you mean by "collecting" and "make a subset" ?
Listing language features by difficulty maybe? Which things that are confusing or hard to use should be left out? Which things are easy to do with perl that are also easy to understand? Is that clearer?
The passwords were hashed with crypt(3). They may as well have been plain text.
I too think the P6 project will remain far from relevance to *most* programmers this year, including you. But not all. v5 is already parsing and executing a significant subset of P5; the OP's context seemed to me to be right up v5's alley; and it seemed (and still seems) plausible that the OP or others reading this might be interested in v5. v5 successfully parsed and executed its first (tiny) CPAN module a month ago. v5's author is also one of the main folk driving P6's approach to CPAN. v5 is one of the two primary approaches being taken toward CPAN by the P6 project. (The other is embedding libperl.) v5 already installs broadly, including places beyond the current p5 binary such as the JVM. The underlying toolchain (NQP) will likely be much easier to port to newer platforms (eg a port of NQP to JS/V8 is nearing completion) than the existing p5 binary. v5 is passing about 5K odd of the 43K p5 tests at the moment. The passing 5K is focused on basic features -- which matches the OP's interests.
Do you really think that giving a newbie some half-arsed software that can't even pass all of the basic language tests is going to make them say "Oh wow, this is so much better than Python! It has no documentation, it is slow, it is buggy, it is incomplete, but Ralph on the internet is confident that one day it will be relevant, so I had best learn it!" I am confident that the OP is not interested in teaching newbies the subset of Perl that v5 supports because it seems plausible that whatever FROGGS has implemented is not according to a philosophy of teaching newbies or removing things that are confusing but only about what he thinks will be fun to implement. Did you read "perl critic" in the OP? Do you know what that is? Do you know why the OP wrote that?
Worse -- Movable Type. At least it motivated my lazy self to generate a couple new random passwords.
Unfortunately, we use MT4 - for the "professional" features. And that seems to be in a cul-de-sac with no upgrade route to MT5.
How can I reverse my password? I had forgotten I even had a blogs.perl.org account and have no idea what the password is. I *usually* don't use the same password on different accounts, but I'd like to be certain... As I understand it, `crypt` "hashes" can't be reversed so I'd need to hash several password attempts and match the hash listed in the leaked passwords. But I don't see the salt in the leaked passwords so I'm not sure what I would need to hash my password attempts. EDIT: [Soulution on Perlmonks](http://www.perlmonks.org/?node_id=1071729) (you'll have to infer how to check your own passwords based on the response, but it's fairly straightforward once you understand how `crypt` works (I'd hate to give the solution to the evil people and most of the people on /r/perlmonks are far more experienced than I))
In the comments section, he mentions they uploaded a php file that they then executed to gain access. PHPs killer feature is also what makes it such a great attack vector; you can just upload a plain text file and execute it server-side.
When I worked for the "Webhosting" company (long story), I used to always joke that WordPress was a "remote shell with a neat blogging feature". This is exactly why.
I said that they uploaded a PHP file. I didn't say that PHP was used to upload the file.
Good thing I used open ID :)
Yay I have an account in that list. Unfortunately I don't remember my password.
We are! Business &amp; Technology Applications Analyst I - The Genome Institute - 26988 The Genome Institute at Washington University has an opening for a talented software engineer in the Bioinformatics group. The position will work with an experienced group of software engineers to develop software supporting the tracking of laboratory data and analysis processes to support large scale genomic research projects. The ideal candidate has a talent and love for writing software, is interested in developing that skill, and applying it in a production environment. The candidate will be expected to learn new things on a regular basis, think critically, and collaborate with other developers across groups. The environment is fast-paced and a person who likes to get things done will find a lot of opportunity. The Genome Institute has been at the forefront of genome research since its inception in 1993 and has been a part of major scientific projects such as the Human Genome, 1000 Genomes and TCGA (The Cancer Genome Atlas) Projects. The Genome Institute is a world-leader in the generation and analysis of genomic sequence data and uses this data to extend biological knowledge of the human genome and provide clinically relevant sequence analysis aimed at understanding human diseases (such as cancer and Alzheimer's disease). In addition, the Institute fosters public understanding of genomic science through various educational and outreach efforts. Washington University in St. Louis is an equal opportunity, affirmative action employer and encourages applications from women, ethnic minorities, veterans, and individuals with disabilities. Degree or certification from a technical school or college in computer programming required; experience in computer programming and/or relevant DBA experience may be substituted on a year-for-year basis for required education. Design, testing, debugging, and problem analysis are a regular part of the work. Skills in abstract software design, object-oriented architecture, relational data modeling, and web interface design will be used frequently, which will require thorough knowledge of each concept. The applicant will use these skills to develop software that will: interface with people and/or laboratory equipment, process and analyze large data sets on a compute cluster, and provide intuitive web based interfaces to the specifications of the laboratory managers and technicians. Proficiency in dynamically typed languages (Perl, Ruby, Python, Lisp, etc.) is a plus, but not required. Understanding of relational databases and SQL will be helpful. Experience with web technologies such as HTML, CSS, Javascript and approaches such as REST and AJAX is an asset. Regular work will be done in GNU/Linux and other UNIX-like development environments. Familiarity with open source technologies, version control software such as git, and programming in a network environment are also assets. This position is full-time and works approximately 40 hours per week. The salary will be commensurate with experience. Benefits: * Retirement Savings Plan * 22 vacation days * 8 Paid Holidays * Sick Time * Tuition benefits for employee, spouse and dependent children * Free Metro Link / Bus pass * Free Life Insurance * Health, Dental, Vision * Health Savings Accounts (HSA) * Long Term Disability Insurance * Flex Spending Plan * Other Benefits - Med School HR website (medschoolhr.wustl.edu) Please email your resume and a code sample to me, William Schroeder (wschroed), at genome.wustl.edu. You may also apply through the official channel (you can do a basic search for job number 26988): https://jobs.wustl.edu/ 
Hey guys, No Starch Press published my Perl One-Liners book a month ago but I hadn't announced it here on /r/perl, so I'm doing that right now! I decided to do another 10 free review copy give away here as well. Let me know if you're interested in reviewing my book and I'd appreciate if you posted an amazon review (or a blog post). Just respond to this comment and I'll send you a free review copy! (Print books+ebooks within the US, ebooks anywhere else.) **Update: all review copies have been given away** Alternatively you can use discount code **REDDITPERL** to get 40% off the book (till Feb 1).
Great! Email me peter@catonmat.net and I'll have the book sent to you. Include your mailing address if you're in the US, and also add your nickname so I know who got their copies.
sent an email
That looks like enough evidence.
Thanks! 
I would also be interested in doing a review.
Hi, I would be interested in a copy to review! Thanks!
Great! I already got your email so I'll have the book sent to you soon.
Great! Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you.
Done! Though it'll be an ebook only for me as I'm not in the US. Thanks!
I'd like to do a review.
Thank you! Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you.
I would love to write a review!
That's great! Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you.
Sent! Thank you!
I would love to give a review!
That's great! Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you.
perlmonks still doesn't encrypt user passwords.
Email sent, thank you!
I got a blog, I'd do a review. Hopefully I'm not too late.
Cool! I think you're the 9th person. So there is one more book to give away. :) Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you. Looking forward to reading your review!
Are you quitting or just moving to a different team? Or is this just another position like your?
I'm not quitting - you'll have to still put up with me. :) But my responsibilities are evolving and I'll have less time for driver stuff.
Hi, are there any remaining review copies of your book? Thanks. 
Would you consider an intern?
Interesting. I'd like to see the comparison with Scala traits, case classes/objects and mixins
This is for a full-time position, but we do have a very good summer internship program for undergrads and you could propose some Perl stuff as an internship project. Feel free to drop me a line if you're interested in applying for that.
IMO, at least in his example he's coming from a bad design. 'Go' is a function of something that can move. 'Hitch' is a function of something with a hitch. Plowing is an action of something that can move and has a hitch -- a superclass. If OP is getting that wrong, he's probably getting other scenarios wrong.
I am very interested. Is it paid?
If the last review copy is still available, I'd like to give it a go.
I agree, that Vehicle is definitely not a Role/Trait. An easy signal is, that is not named in a gerund, "*able", ...-form So it IS a vehicle ad it DOES not vehicle. And if you want to make "go" a Role it would be as you mentioned Movable. [edit]or even better the gerund Moving[/edit] But I thing it's all right to add Plowing by applying Hitchable. ~~The Thing the author forgot is to check if the object is compatible. You can do this with "requires 'go'" in the Hitchable Role.~~ *I see there is a requires-check, so it is ok for me*
*Here is the text of the [answer](http://www.stackoverflow.com/a/1626689/1106405) linked above, by user [daotoad](http://stackoverflow.com/users/59135):* --- &gt;While I like the idea of reducing boiler-plate code, I am deeply suspicious of &gt; tools like Modern::Perl and common::sense. &gt; &gt; The problem I have with modules like this is that they bundle up a group of &gt; behaviors and hide behid glib names with changeable meanings. &gt; &gt; For example, `Modern::Perl` today consists of enabling some perl 5.10 features &gt; and using strict and warnings. But what happens when Perl 5.12 or 5.14 or 5.24 &gt; come out with great new goodies, and the community discovers that we need to &gt; use the `frobnitz` pragma everywhere? Will Modern::Perl provide a consistent &gt; set of behaviors or will it remain "Modern". If MP keeps with the times, it &gt; will break existing systems that don't keep lock-step with its compiler &gt; requirements. It adds extra compatibility testing to upgrade. At least that's &gt; my reaction to MP. I'll be the first to admit that chromatic is about 10 times &gt; smarter than me and a better programmer as well--but I still disagree with his &gt; judgment on this issue. &gt; &gt; `common::sense` has a name problem, too. Whose idea of common sense is &gt; involved? Will it change over time? &gt; &gt; My preference would be for a module that makes it easy for me to create my own &gt; set of standard modules, and even create groups of related modules/pragmas for &gt; specific tasks (like date time manipulation, database interaction, html &gt; parsing, etc). &gt; &gt; I like the idea of [Toolkit](http://search.cpan.org/perldoc/Toolkit), but it &gt; sucks for several reasons: it uses source filters, and the macro system is &gt; overly complex and fragile. I have the utmost respect for Damian Conway, and &gt; he produces brilliant code, but sometimes he goes a bit too far (at least for &gt; production use, experimentation is good). &gt; &gt; I haven't lost enough time typing `use strict; use warnings;` to feel the need &gt; to create my own standard import module. If I felt a strong need for &gt; automatically loading a set of modules/pragmas, something similar to Toolkit &gt; that allows one to create standard feature groups would be ideal: &gt; &gt; &gt; &gt; use My::Tools qw( standard datetime SQLite ); &gt; &gt; &gt; or &gt; &gt; &gt; &gt; use My::Tools; &gt; use My::Tools::DateTime; &gt; use My::Tools::SQLite; &gt; &gt; &gt; Toolkit comes very close to my ideal. Its fatal defects are a bummer. &gt; &gt; As for whether the choice of pragmas makes sense, that's a matter of taste. &gt; I'd rather use the occasional `no strict 'foo'` or `no warnings 'bar'` in a &gt; block where I need the ability to do something that requires it, than disable &gt; the checks over my entire file. Plus, IMO, memory consumption is a red &gt; herring. YMMV. &gt; &gt; **update** &gt; &gt; It seems that there are many (how many?) different modules of this type &gt; floating around CPAN. &gt; &gt; * There is [latest](http://search.cpan.org/perldoc/latest), which is no longer the latest. Demonstrates part of the naming problem. &gt; * Also, [uni::perl](http://search.cpan.org/perldoc/uni%3A%3Aperl) which adds enabling unicode part of the mix. &gt; * [ToolSet](http://search.cpan.org/perldoc/ToolSet) offers a subset of `Toolkit`'s abilities, but without source filters. &gt; * I'll include [Moose](http://search.cpan.org/perldoc/Moose) here, since it automatically adds `strict` and `warnings` to the calling package. &gt; * And finally [Acme::Very::Modern::Perl](http://search.cpan.org/perldoc/Acme%3A%3AVery%3A%3AModern%3A%3APerl) &gt; &gt; The proliferation of these modules and the potential for overlapping &gt; requirements, adds another issue. &gt; &gt; What happens if you write code like: &gt; &gt; &gt; &gt; use Moose; &gt; use common::sense; &gt; &gt; &gt; What pragmas are enabled with what options? &gt; &gt; --- ^[about.StackBot](http://www.github.com/gabrieldain/StackBot) ^| ^(downvote to remove)
Do you hire people from outside US? Specifically I'm from an EU country :)
I mean Modern Perl the book not Modern::Perl the module. (The stack exchange answer I liked also doesn't like Modern::Perl the module for similar reasons). And actually, what I *really* mean is Perl Best Practices (the book) not Modern Perl (the book). (though I'm having trouble trying to google the chapter... I may have to resort to analogue help docs...) Also see this thread: http://www.perlmonks.org/?node_id=670524
It's available. You got the last copy. :) Email me peter@catonmat.net and include your mailing address and nickname (so I knew who got their copies), and I'll have the book sent to you.
Sorry, I ran out of review copies. 
&gt; really need to lay off the appeals to authority. "You really need to stop linking to documents that already explain what you are trying to communicate and should instead rewrite others ideas and claim them as your own". Fixed that for ya. All my point is is that "common::sense" is anything but. If it works for you and your team, great. But others coming on to the scene deserve to understand both points of view. Your opinion is "you should check out common::sense", my opinion is "you should know what you are getting into before blindly adding dependency requirements; common::sense is no substitute for actual common sense". Heck, I used to use common::sense religiously, but then I ran into an issue with one script which cascaded into a good majority of my library so I had to go through and write out common::sense (hooray for the corporate world! even though the people making the rules never use my scripts/applications/etc). Hell, for quick one offs, I still use common::sense so I don't have to type out `use 5.10`, `use strict`, `use warnings`, etc. I'll agree with you on the "Know what you're getting into" bit.
yes. stop using it until smartmatch is fixed (if it ever will be). since when() uses smartmatch and smartmatch is fundamentally weird and unperlish and almost impossible to remember, just... just dont. Switch::Plain instead, if you want a switch/case construct.
Fantastic progress on Moar! Curious: what is hindering Panda from working on Rakudo/Moar? 
Effectively it was, but it was introduced in 5.10 before the current "experimental" state actually existed. When "experimental" was created, smartmatch was immediately added to the list.
A lot of IO stuff is NYI/buggy in the Moar version of Rakudo, and NativeCall hasn't been properly started on yet too afaik... Things are so rapid with the MoarVM support though that this comment is probably already out of date. The Rakudo JVM backend has just had the NativeCall bumped to the point that it can probably support Panda and be part of the Rakudo* release soonish... If interested here is the right sort of area in the backlog http://irclog.perlgeek.de/perl6/2014-01-23#i_8164298
I didn't say anything different; I think you misread my comment. The fact that the uploaded file was then executable is a feature unique to PHP, as far as I know, and was the biggest reason it became so widespread as it made running it on shared hosts a lot easier to manage. That was my point.
A tradition of quality!
We do have some dev staff in the EU. If you're interested, send me an email with your details and I can ask the right people.
I agree, the example is a unfortunate choice.
(Author of Moose here) … Scala traits were an early source of interest, but roles ultimately are more heavily based on the Smalltalk "traits" paper. Having spent a good amount of time writing code in Moose and in Scala, I can say a couple things: * Traits in scala are not as strict compositionally as Moose roles, but Scala's type checking pretty much makes that a moot point. * Case classes/objects are awesome and have no corresponding feature in Moose/Perl * Mixins are a horrible idea in any language (mostly because they are basically an abuse of multiple inheritance masquerading as a "feature"). 
Contrived examples are contrived. This is the curse of all technical book/blog writers. 
Wow. That was an unexpectedly informative. Thank you. I pretty much never use mixins but I do love case classes/objects and traits. Thanks again!
I want a "click here to download Perl6 for the JVM" so bad.
It was just an expression of desire, a differently worded " i wish perl6 was finished and ready for the general population". But thanks for the guide anyway, i'll try it.
For JVM vs Parrot Timothy King has an analysis you can take a look at. http://sd.jtimothyking.com/wp-content/uploads/2013/12/Benchmarking-Perl-6-How-Ready-for-Prime-Time-Is-It-revised.pdf I think MoarVM is going to be included once it's a bit more mature. In general each backend has it's strengths and weaknesses. It's kind of neat that for whichever task you have you can choose which to use. So if on the command line doing one liners use Moar or Parrot, for something long running doing numerical stuff on big lists use JVM. Though it's not really clear yet what Rakudo on Moar can and can't do.
A big advantage of the json format is that it is human readable. One can always inspect its value.
http://irclog.perlgeek.de/perl6/2014-01-25#i_8175511 and in some cases wait for the JVM to out perform Perl 5. Choice is never bad, and yeah I'd choose to use Perl 5 for anything serious. Playing around I choose Perl 6 because its enjoyable to use as a language. Im still hopeful the implementations will catch up with what I want to do day to day. I find it odd you keep making the choice to be so negative bordering on outright angry though. Most of your posts on here are just rage aimed at Rakudo devs it's one of the reasons I've posted anything on Reddit... Unless you're someone who's been burnt and chewed out by the project directly I don't get it? 
I asked on #moarvm and timotimo generated [a set of micro benchmarks for Perl 5, the three NQPs and the three Rakudos](http://feather.perl6.nl/~raiph/25jan2014-benchmark-p5-nqps-rakudos.html) using japhb's perl6-bench. * Patience! It takes about 30 seconds for the results to appear... * **The above benchmarks are really intended for internal purposes -- they are micro benchmarks -- but hopefully they answer some of your questions** without causing too much trolling. * [On #perl6 today](http://irclog.perlgeek.de/perl6/2014-01-25#i_8175379) japhb said "_sri: **rakudo-moar has had about half a week of actual optimization work on it total, so don't get your hopes up too high yet. :-)**" * [On #moarvm today](http://irclog.perlgeek.de/moarvm/2014-01-25#i_8175662) jnthn said "**For those benchmarking or discussing performance, it might be worthwhile remembering that Moar doesn't do a shred of optimization of the bytecode its fed yet, let alone any kind of JIT compilation.**" * These benchmarks subtract out startup and compile time * NQP/MoarVM starts and compiles faster than NQP/Parrot and NQP/JVM * (Afaik P5 starts and compiles a lot faster than NQP/MoarVM) * MoarVM is compiled with -O1 -g3; Parrot with -O3 * Relative speeds vary tremendously depending on op and iterations * Most NQP/MoarVM results are between about 100x slower and 10x faster than P5 * Rakudo/MoarVM is generally 10x to 100x slower than NQP/MoarVM * NQP and Rakudo string ops are especially weak * NQP and Rakudo are generally a lot faster than they were a year ago * P6ers expect NQP, Rakudo, and MoarVM to get a lot faster this year too Hth
When it first came out I downloaded Rakudo Star like a good little boy and tried to use it and reported a few bugs and they never got fixed. There was no documentation, you just got dumped in an irc channel full of in jokes and drinking contests, so that's as seriously as they want you to take them and so I do. I would like perl-6 to change it's name so it stops making Perl look bad. No one would care if it were a little playtime language but if it's supposed to replace Perl then it's done a piss-poor job.
Almost exactly what I am looking at; I need high performance except I need to be cross-platform - I will be de-serializing in Java. Have you looked at Google Protocol Buffers? https://developers.google.com/protocol-buffers/docs/overview http://search.cpan.org/~saxjazman/Google-ProtocolBuffers-0.11/lib/Google/ProtocolBuffers.pm 
If you meant what you wrote, we'd be golden. Of course P6ers would care. I've read #perl6 daily for about 30 months and P6ers consistently quickly and helpfully address problems brought to their attention. If someone encounters a bug which manifests on Rakudo/JVM, but not on other backends, then it typically turns out to be an issue with NQP/JVM and someone who knows both (NQP and JVM) fixes the problem. If it's a problem with a JVM itself, P6ers try to come up with a workaround. (Because, if there's no workaround, and it's a bug in a JVM, you'd need to deal with the JVM's developer, eg Oracle or the OpenJDK project). The situation with the Parrot VM is both better and worse. It's better because there is only an open source version -- there are no proprietary versions of the Parrot VM. So any user could, in theory, fix things themselves. It's worse because the Parrot VM is very complex, and much buggier than the JVM, and the Parrot project is resource starved, so in practice bugs in the Parrot VM are a very thorny problem indeed. With MoarVM the situation is ideal. MoarVM is an open source project, like Parrot, but it's also much simpler than Parrot, is much less buggy, is being very actively developed, and its devs know NQP inside and out (MoarVM is specifically designed to run NQP).
Yes. That's my understanding as well.
Protobufs require a schema, which isn't always possible or desirable. The protobuf implementations vary in quality. I've heard the Perl ones are particularly slow. Do your own benchmarking.
JSON doesn't handle binary data at all though.
Offer rejected because I find your weird stalking creepy. I am confident that in the next 18 months that blaming anyone and everyone except for the drunk jokers who haven't made anything worth using will convince people that you were right and everyone who tried perl-6 and found it... lacking... were wrong about their own personal experiences.
If that's a requirement, why didn't you include Storable? That's a core module. I ran a test and it turns out to be a lot slower: json decode: 8 wallclock secs ( 7.66 usr + 0.00 sys = 7.66 CPU) @ 130548.30/s (n=1000000) json encode: 7 wallclock secs ( 7.48 usr + 0.00 sys = 7.48 CPU) @ 133689.84/s (n=1000000) mp decode: 9 wallclock secs ( 9.62 usr + 0.00 sys = 9.62 CPU) @ 103950.10/s (n=1000000) mp encode: 5 wallclock secs ( 5.22 usr + -0.01 sys = 5.21 CPU) @ 191938.58/s (n=1000000) sereal decode: 10 wallclock secs ( 9.98 usr + 0.00 sys = 9.98 CPU) @ 100200.40/s (n=1000000) sereal encode: 10 wallclock secs ( 8.63 usr + 0.00 sys = 8.63 CPU) @ 115874.86/s (n=1000000) storable decode: 18 wallclock secs (18.26 usr + 0.00 sys = 18.26 CPU) @ 54764.51/s (n=1000000) storable encode: 31 wallclock secs (32.00 usr + 0.00 sys = 32.00 CPU) @ 31250.00/s (n=1000000) 
Four legs good, two legs baaaaaaaaad... bleat bleat, Ralphie boy. No-one cares who's to blame. Sure you've crawled so far up perl-6's arse that of course you're going to blame everything on everything that didn't originate in #perl6 but face it... you can blame Oracle or Parrot or Pugs or sunspots until you're blue in the face and no one cares because the simple fact of the matter is perl-6 hasn't delivered anything in 14 years. Even if they completely started over from scratch AGAIN that wouldn't erase any of the failure up to this point. If you want to brag about what you think are successes by the people you absolutely ADORE then you ought to pretend to be objective and admit that they've made some pretty obvious cockups too. And the bugs I reported still didn't get fixed, so suck on that.
educated_poo: I don't care much about the past as for the present. How much is between you and trying it again some day (in near future)? I am a MoarVM/NQP/Rakudo dev and I can't share the experience you had. So, maybe it is a bit different today? I can't tell if your tickets are solved or not, since I can't find them.
(Not my benchmarks, but I did help design and implement Sereal) Storable (in addition to being slow) also has problems between different Perl versions. One of the reasons we wrote sereal was to facilitate an upgrade from Perl 5.8.5 to 5.14.2. 
We have enough machines and systems that were genering Storable blobs that we couldn't stop-the-world, upgrade everybody, and then bring everything back up. Which meant that we were going to have some places that were 5.14.2 generating Storable blobs that were not readable by 5.8.5. Our solution was to build a storable replacement that also solved some of Storable's issues. You can read more about this at our blog: http://blog.booking.com/sereal-a-binary-data-serialization-format.html
Any guesses on what to replace Movable Type with? I'm looking to replace my own WordPress blog with something Perl-based, but it seems like there aren't many Perl alternatives with a good base of plugins.
For the record, the benchmarks use Sereal in a significantly suboptimal way: If they used the OO interface (and possibly added the no_shared_hashkeys option to the encoder), it would beat the MessagePack implementation. https://gist.github.com/tsee/8634922
Why would I try it again instead of some other language? You've had fourteen years to compete and you've failed. Why should I trust you again?
Because Perl 6 is an awesome language. And that is really the only reason why to try a language at all.
What a hater. Why don't you patiently sit and wait for Christmas like the rest of us?
In my sixth form applications I talked about a bootloader I'd written in assembly. That was awesome at the time but no one has used it since including me. You know why? Because it was buggy, incomplete, slow, undocumented, and you couldn't trust me to maintain it. Besides that there are many many credible alternatives that may not be as awesome personally to me but they work and you can rely on them.
Have they delivered what they promised? Are they immune from criticism? Maybe if they explained why they've messed up so many times and showed how they'll do things differently this time they might be believable. But Ralph is still mixing the kool-aid.
https://github.com/openmelody/melody? I know nothing about melody other than that a couple days ago jay allen, responding to b.p.o's security breach, said melody is an MT 5.2 fork that retains the open source license and he'd be delighted to help reactivate it as a project.
They've taken so long because they needed to redesign it from scratch a few times. You know, to make it even more awesome, you ingrate. This python and ruby thing is just a fad that will go away once Perl 6 is released.
I'm happy to follow your guidance on how I publicly follow up or not on these bugs you speak of. But I still want to know what your bugs were.
You mean something like `rvm install jruby`?
Stupidly it seems only be possible to mark the whole Operator as experimental. Only because of weird combinations I never woule have used. All I need is scalar ~~ array of scalars regex ~~ array of scalars I read the rest of the Operator and thought OMG.
 for i in *.txt ; do mv "$i" "new_$i" done is the good shell solution 
That book you're learning from is ancient. "Learning Perl" is probably your best bet. I suggest a trip to your local public library and seeing what they have there.
If it requires you to load a module, it takes more than one line.
Great talk with a lot of new modules (well... new to me) and techniques. Would watch again anytime! A++++++
Also, it probably requires installed and running OS, so it's not a one-minute job.
"OMG" is a pretty good description of smart match. Maybe we should just call it the God Operator (since it does everything). ;-)
By the time it's released, even Javascript will have been a fad!
Has it been six months already?
[Java Rakudo Installation Instructions](http://www.youtube.com/watch?v=HYsGtYMOaBg)
Note that WWW::YouTube::Download already comes with a command-line interface called `youtube-download`, so no need to recreate (a lesser version of) that.
*hah* - I had no idea. Thanks for the pointer, am updating the article now.
I was there and really enjoyed the Ric's presentation: enthusiastic, informative and entertaining. Recommended!
Hipster download/install from source, here you go: curl -L http://git.io/build-jvm-rakudo | bash Such hip, very modern, wow... Seriously checking out some repos and doing a make is too difficult for the majority of developers? I have no idea if the above will actually work ok, let me know ;P You'll need JVM (v7+), Git, Perl and I think that's it.
Only in the Perl 6 community you will find sneering at easy installation procedures =) No wonder you neanderthals still have a language with more developers than actual users after more than a decade. Not sure why I even bother at this point. I suppose it's clear now that the only purpose of P6 is to amuse its developers. To be frank, it's hard to think of something more hipster than that.
"Elements of Programming with Perl" was a great book when it was published. But that was over ten years ago now. I really wouldn't recommend anyone learns Perl from a book that old.
*The Perl Cookbook* could really use an update. It's full of great advice, but it's all looking a bit out of date now.
I thought the 'when' part was useful, but the construct is not so game changing and crazy useful that its worth breaking code backcompat, in my mind. Generally I think when faced with a decision tree that could be solved with this, or with nested if/elsif/else its probably better to step back and look harder at the code and at how to refactor it since I tend to think this is a code smell over the long term. I've been using Perl since 1995 and never felt I really needed this. I'd just not use it myself.
`Dist::Zilla` and `Module::Build` are orthogonal. `Dist::Zilla` is concerned with automating building a distribution to ship to CPAN. `Module::Build` is concerned with building and installing the distribution at the other end of the chain. You're basically asking "which do you prefer General Mills or Whole Foods?" Some form of both are required to get a module from say my box to CPAN to your box. So which one are you really interested in feedback for? `Module::Build`'s main competitors are `ExtUtils::MakeMaker`, `Module::Build::Tiny`, and `Module::Install`. There may be others, but I haven't really run into them yet. I personally use `ExtUtils::MakeMaker` or `Module::Install`. I've been tempted to look at `Module::Build::Tiny` since nothing I'm doing is that complicated, and chromatic keeps pointing out that relying on a Perl script that generates a Perl script that generates a shell script to generate a makefile ... is silly. I use `ExtUtils::MakeMaker` though because I use `Dist::Zilla` and I haven't bothered to change the default. `Dist::Zilla`'s main competitors are ... too numerous to really count: `h2xs`, `Module::Starter`, `Module::Start`, `Module::Make`, copying an existing dist and removing all the guts. I'm lazy and for the longest time I chose "copy some existing dist and get everything mostly correct". This meant I ended up gravitating to `Module::Install` for my choice above because it was the least amount of pain for me and my users. Now I find Dist::Zilla is even easier because starting a new distribution is copying a dist.ini, modifying it to have the new dist's metadata, and running dzil build. This is not a suggestion that `Dist::Zilla` is the obvious choice. It has some known issues. For example, It's a bit heavy to install (I think someone clocked it as taking ~10 minutes to install in an empty `local::lib` today). Some people take exception to spending 10 extra minutes installing author tools that have saved me countless hours of pain. They're free to be offended at my choice of tools, just as I'm free to use whatever tools I find useful. Isn't freedom grand? That said I have started including `cpanfile`s into my dists so that you don't need `Dist::Zilla` to install deps and run tests. 
&gt; relying on a Perl script that generates a Perl script that generates a shell script to generate a makefile ... ... a makefile which may or may not launch several Perl one-liners to get behavior portable across shells and operating systems....
Thanks very much for the info. I am more in the "getting it ready for cpan" I think.
Do you mean the text is plain text on html? Then: use strict; use warnings; use URI; use Web::Scraper; my $scraper = scraper {process "*/text()", text =&gt; 'TEXT'}; $scraper-&gt;user_agent-&gt;env_proxy; my $res = $scraper-&gt;scrape(URI-&gt;new("http://www.google.com")); binmode STDOUT, 'encoding(utf8)'; print $res-&gt;{text}; 
It's absolutely shit code that shouldn't be shared and it's not a repository. It's just a collection of crap. This isn't [even a subroutine](https://github.com/bmrobin/perl_repo/blob/master/pangram.pl). It's a random perl script. The subroutines you do have don't export... They're not module-ified, and the god-aweful. Take for [example this](https://github.com/bmrobin/perl_repo/blob/master/db_select1.pl). sub db_select1($@) { my $ssql=shift(@_); my $db = shift(@_); @results = $db-&gt;selectrow_array($ssql); my $answer = $results[0]; # NOTE - remove this line if you want your program to check for NULL $answer=-100 if $answer eq ''; return $answer; } What is that? lol You only use one column from the result. Just use [`$dbh-&gt;selectcol_arrayref('YOUR SQL')-&gt;[0]`](https://metacpan.org/pod/DBI#selectcol_arrayref). And, put the little `-100` in the calling code if your app requires that.
Meaning no offense but when you have reimplemented builtins with a million nested loops or remade DBI helpers that exist in the standard module it's kind of hard to take seriously. It's eerie enough that I'm thinking the joke's on me. I should use these when I give interviews and hire anyone who has the chutzpah to call me out.
I think you deserve some credit for putting yourself out there and sharing this with an audience; it took me a while to do the same when I was starting out! A few comments on your code: - Your code is organized into a bunch of .pl files; .pm is the standard module extension if you want to use `use` or `require`. - Each file loads subroutines into the `main` package; they should be organized into packages with the `package` keyword. The name of the package should reflect the location of the file on disk; ie. `package List::Util` is in `List/Util.pm`. - Make sure that you use `Exporter` to export your subroutines into the importing package. My personal rule-of-thumb (which others may disagree with) is to put nothing in `@EXPORT` so that users must explicitly declare what they want from your module. You might want to consider looking at some more tutorials, such as http://perl-begin.org/. Reading more seasoned authors' work can also provide some insight. I hear that Paul Evans (https://metacpan.org/author/PEVANS) writes some great code.
This code may be of debatable quality, but we all started as shitty coders and only become better with time. It's good that you asked for feedback from others, as tapping into the knowledge of more experienced programmers can accelerate your learning process. I suggest you use [`perlcritic`](https://metacpan.org/pod/release/THALJEF/Perl-Critic-1.121/bin/perlcritic) with increasing harshness to point out issues with your code – although I disagree with some of the policies. You could also post parts of your code on [codereview.stackexchange.com](https://codereview.stackexchange.com/questions/tagged/perl) (e.g. one file at a time), which is a site dedicated to pointing out how your code could be improved. One thing that I consistently found is that you have a good code layout and possibly prior experience with programming, but unfamiliarity with Perl. The [Perl Tutorial Site](http://perl-tutorial.org/) lists good tutorials, and some tutorials to avoid. I see that your style is very dated which could mean that you're using completely outdated tutorials. Stop using them, and read something like [Modern Perl](http://modernperlbooks.com/books/modern_perl/) instead.
BMrobin, Glad you are choosing to stop lurking and start participating! As has been pointed out, some of your Util subs do replicate either Perl built ins or widely used modules on CPAN, but often people start by coding what makes sense to them I did my share of database helpers and templating systems before I got serious and started working with the fine offerings on CPAN. I don't know what you do, web development, sysadmin, etc., but if you are doing webdev I am always looking for people that want to help me improve Catalyst, one of the more popular web development frameworks. There's tons to do, even for people that are unfamiliar and I am willing to mentor. See my blog: "http://jjnapiorkowski.typepad.com" for more. One hopefully useful specific comment, I notice you use the old form of open: open (CONFIGFILE, "&lt;$file") || die ...; Today it is preferable to use a lexical and the three arg version, since CONFIGFILE is an evil global (amongst other problems) open (my $conf, '&lt;', $file) || die .... Best of luck, Jnap
For code in config_file.pl, you can try using the CPAN module Config::IniFiles. Or perhaps Config::Any.
As for pangram.pl, just a reminder that in Perl you can be very succinct yet expressive. My take (I cheat a bit by using `uniq` from a non-core module): use 5.010; use List::MoreUtils qw(uniq); sub pangram { join("", grep {/[a-z]/} uniq(sort(split //, lc $_[0]))) eq join("", "a".."z"); } Example: pangram("abc"); # false pangram(The quick brown fox jumps over the lazy dog""); # true 
I ended up using this solution -- did exactly what I needed! Thanks so much!
Tried this, and it works. LWP::Simple makes it a little more... simple.
Sorry I was unclear. I didn't have access to system commands, so I wasn't able to use commands like wget/cat ect.
thanks this is helpful!
Sweet
thanks, i will look into doing it this way!
Evan, While you may be an expert programmer, not all of us are. I commend bmrobin for putting himself out there and asking for help. It is not an easy thing to do and you're just being a jerk. Help the community by giving useful criticism, not deterring others from seeking help. -laj5026
Of course, TIMTOWTDI. File::Find has the advantage of being core but if you want a simpler interface, check out: https://metacpan.org/pod/Path::Iterator::Rule
I think one big hit to improve your code would be to really read and read again the CPAN docs for any given module you use. A lot of the code you have for DBI is superfluous. For example https://github.com/bmrobin/perl_repo/blob/master/db_select_all_ar_ref.pl what was wrong with the built in: $dbh-&gt;selectall_arrayref("SELECT foo FROM table WHERE bar = ?",undef,$placeholder_value) or in the parlance of your module: $db-&gt;selectall_arrayref($ssql) Notice that your function doesn't allow the passing of values to fill placeholders in the $ssql query, which in of itself is a bit of a red flag. This PerlMonks post covers why you might want placeholders http://www.perlmonks.org/?node_id=7548
I'm not sure of the difference. If I were you I wouldn't buy anything and just try to use the free online resources. For example the Modern Perl book is also free online: http://modernperlbooks.com/books/modern_perl/chapter_00.html#toc_UHJlZmFjZQ
What wanker would down-vote this announcement... You are really harshing my high dude(tte).
I'll see if I can get one of the designers at my company to do it. Thanks!
Fashion is a fickle mistress. Once upon a time, requiring a library would give you some helpful functions in your package. Then it was hip to "export nothing by default" and make everything object-y. Then it was back to giving you some functions by default, but calling them a "DSL." Then shoving various lexical pragmas into your package became de rigeur. The next logical step was pragmas that made life worse for everyone everywhere, whose behavior depends on whether or not they think you're running in a version control directory. I can only assume that Facebook logins and pop-ups encouraging users to "like my app on MetaCPAN" are not far off.
Other than leaving off "crawl back into your mother and die," you scored full douche points.
This time: with audio!
And, naturally, when we finally get audio &amp; video down we get hit with network woes. Apologies to all watching the live stream. Hopefully we don't have any snags with the recording so you can watch it in its entirety later on our Internet Archive collection.
We've confirmed it's recorded (albeit in two pieces). It was a great talk and we're looking forward to sharing it w/everyone.
Perl was my first paid-as-professional language, and I'm very comfortable with design and Reddit's styles and markup, so if I can help in any way let me know. 
I'm not sure I would send a complete beginner to a book. The best thing is to try some code straight away imho http://perltuts.com has some nice interactive tutorials and points people to decent books too.
Not really. Altough you can do dozen needless things with it, it's not possible to do an easy duty as Array ~~ scalar
i see both sides of the argument. and it is handy when a warning kills your module and you have to fix it, especially if it is actually broken. although it shouldn't affect code outside of the library, this is true
It *is* handy … during *development*. Not during *deployment*. Of course we all do a round of QA when upgrading to another perl or library version … right? Anyway, I find it nice that *something* good (this blog post) came from something so incredibly misguided like the RT #121085 issue.
&gt; Not during deployment. YMMV. But, I've done this at my previous job. We ran few of our Perl web servers always in fatal mode (set up via signal handler so to dump stack trace and stuff before child exits). This way it forces you to fix bugs and undef warnings ASAP (like those found in production). Of course Moo with it's fatal warnings could make your life miserable, but I've used Moose under these conditions and everything worked perfectly more or less. A few times thing would explode (like a fork bomb) but it was manageable. I've always installed new Perl releases on test servers to see if everything was still in fit condition, if there were new errors, warnings etc, before updating production servers (which were mostly few Perl releases behind). This code is still running stable since 2005. 
Actionscripted, Hey awesome, I think we'd not do wrong to take the original and just change "#!/usr/bin/perl" to "#!/usr/bin/env perl" and replace the camel with an onion from TPF (I think http://www.perlfoundation.org/perl_trademark) but I'll send email to them to verify and get back to you. thanks! Jnap
Great, I look forward to seeing the recording.
It is indeed your choice to use something other-than-Perl6, if you find that other-than-Perl6 superior. But, I do have one question: why are you spending so much of your time talking about something you don't like? You could instead be talking about that other superior language, and who knows, it might even benefit others.
&gt; I've always installed new Perl releases on test servers to see if everything was still in fit condition.... That helps, but the worst part of `strictures` is that it's vulnerable to *any* CPAN module upgrade.
I don't think #!/usr/bin/env perl is better. It's suitable for some usages (e.g. random scripts in your ~/bin) but not for others (e.g. CPAN distributions).
I emailed TPF about it, lets see what they say. Thanks! -jnap
That's surprisingly obnoxious. Maybe "#!perl" with a tiny crossed-out camel and onion (or the phrase "talk to your lawyer") beneath would be best.
Yeah, me either. That message came from the build log. Here it is directly: Entering Moose-2.1202 Checking configure dependencies from META.json Checking if you have ExtUtils::MakeMaker 6.30 ... Yes (6.57_05) Checking if you have File::Spec 0 ... Yes (3.33) Checking if you have Dist::CheckConflicts 0.02 ... Yes (0.10) Checking if you have ExtUtils::CBuilder 0.27 ... Yes (0.280212) Configuring Moose-2.1202 Running Makefile.PL This distribution requires a working compiler at Makefile.PL line 52. -&gt; N/A -&gt; FAIL Configure failed for Moose-2.1202. See /home/pge8877/.cpanm/work/1391134665.3228/build.log for details. 
And this is the Makefile.PL in question: http://cpansearch.perl.org/src/ETHER/Moose-2.1202/Makefile.PL This may be a recent change. I'll check the change log and maybe try installing an older version. Or it may truly be an environmental thing. I suppose I could also crank up a brand new Linux server on EC2 and see if it's different than on Cygwin
I found the entry in the change log: 2.1107 2013-11-29 (TRIAL RELEASE) ... - now failing early at build time, with a useful error message, if a compiler is not available That's funny: "a useful error message." I mean yeah, it would be useful if I truly didn't have a working compiler. But I do. I'm just gonna go back to an older version for right now, I think. Everything started to work right with the older version, but then I ran into an ever better message from another distribution. This one rang a bell. It was looking for a command called gcc-4, and then later a command called g++-4. The version of GCC that I have is 4, but those symlinks didn't exist. Creating them solved that problem. So then I decided to go back to the latest version of Moose, assuming it's griping about the same thing. Then I started running into those lame Cygwin "address space already occupied" messages. I read online that this can happen with your virus scanning software, particularly if you're running 32-bit cygwin on 64-bit Windows. Which I am, for an entirely separate reason. This is a brand new box I'm setting up, and I would actually prefer to be on 64-bit Cygwin, so I went back to that and worked through the obstacle that I ran into earlier today that made me run back to the relative comfort of x86 :) TL;DR: Got through that problem. Thanks :)
Run `perl -V`. You should see lines like this: Compiler: cc='gcc-4', ccflags ='-DPERL_USE_SAFE_PUTENV -U__STRICT_ANSI__ -g -fno-strict-aliasing -pipe -fstack-protector', and Linker and Libraries: ld='g++-4', ldflags =' -Wl,--enable-auto-import -Wl,--export-all-symbols -Wl,--enable-auto-image-base -fstack-protector -L/usr/local/lib' The interesting bits are `cc='gcc-4'` and `ld='g++-4'`. Go to `/usr/bin/` and run `ln -s gcc.exe gcc-4`, `ln -s gcc.exe gcc-4.exe`, `ln -s g++ g++-4` and `ln -s g++ g++-4.exe` (or equivalent, depending on the output from `perl -V`). Then try building Moose again. 
I like all of these!
My little project was not on your list. It doesn't really fall into any of the categories in your post at perlmaven. [Demeter](http://bruceravel.github.io/demeter) is scientific software with a userbase in the many hundreds, possibly as many as a couple thousand ... hard to say exactly. I recently did a write up at government.github.com : http://government.github.com/stories/xas-software/
Why should someone protest that Tory twit David Cameron when he might talk up Labour instead? Because too many twits make a... well, you know.
&gt; Well, there are practical reasons for that. True, but the period also spawned deeply clueless things like File::Spec. EDIT: as for name collisions, it's a shame that { package M; use Math::Package::That::Exports } M::something(...) didn't catch on as a way to deal with name conflicts. &gt; Which module are you referring to? That would be (at least) "strictures," which behaves differently depending on whether it thinks you're in a VC checkout. 
I was thinking of doing a Kickstarter to finish WebGUI8. It never got past alpha before development on it effectively suspended. I spent a couple of months rolling up an installer (lack of an installer and difficult install process was a major hurdle for potential users) and fixing the worst of the admin bugs. The core is solid and is heavily unit-tested. We used to have conferences with hundreds of people to them and users swear that it's the least insane CMS they've worked on and I really do feel joy in coding on something people actually use to get things done rather than just entertaining programmers with hackery (though that's fun too). Being employed for a few years to work on and support open source/Free software (WebGUI) was certainly a highlight of my career. I've emailed several people asking if they'd help promote the Kickstarter and no one so far has responded. It created jobs for several small companies and dozens of consultants. There's no way that would get funded unless the community was telling the community to get behind it. I think there's a lot more potential for transitioning wG to a community developed model if I can get 8 out of alpha. 7 is painfully out of date. Thoughts welcome.
You got your own category now. Please send me a mail when you have another article so I can include it in the Perl Weekly.
I am surprised. Has Plainbalck stopped supporting and developing WebGUI? I think your approach of contacting companies that *depend* on WebGUI is the right way to get the funds to work on it. That's your community. Not the general Perl "community".
I quite agree with you, but if there are no companies (or people) who are heavily invested in WebGUI than I don't see how you could get money for working on it and as I can see the "Perl community" is quite satisfied with the state of the things or they think they are powerless to make changes.
&gt; for Normal People &gt; Examples in Perl Jokes are coming in 3.. 2.. 1..
+1 for *not* exporting the subroutines by default. I recently did it with my Hijk module and actually found it manageable -- but having the module name itself is pretty short helps a lot. However this opens some thought on using the namespace itself as part of hint for readers. For example, the indexof.pl provides `indexOf` function implementing the "match" part with regexp matching, this might be wrong or intentional, and/or can be considered as a *flavour* I guess. Since the comparison between 2 things generally has different flavours of what are considered equal, maybe the indexOf subroutine can be organized like this: - List::Ref::indexOf - List::Str::indexOf - List::Num::indexOf - List::Regexp::indexOf While having 4 implementations around will definitely have some redundant code, but each sub should have much shorter code and less code branch and might be a bit easier to maintain. 
There are dozens of us!
Actually, it's more like "dozens and dozens" :)
This is fantastic. I love seeing these sorts of edited lists of stuff to help people through the firehose of CPAN.
I'm considered a newbie to Perl, I've been using it at work mostly for personal scripts but also to help decode current working scripts from previous engineers. Part of the pain I never really got into Perl before was the language felt very confusing and saw code written differently from other languages. Looking at Perl vs C# or something, felt like it was missing indents and other standards, almost like it encourages the author to make the code more confusing for fun. Now that I know more about Perl I can read it much better but that was my first take looking at it. Another issue I have with Perl is the road map going beyond Perl 5. Since it appears Perl 6 is not moving anytime soon, it feels like a bit of a gamble to heavily invest time and money into a language that may or may not exist in the next few years. I know that Perl 5 will be around for a long time, but I'm sure it's a major selling point for end users and companies to back Ruby or Python. (Sounds like a great Dilbert cartoon) As for technical learning, I also felt like the community of Ruby and Python had better resources and welcomed the totally new users. Look at the amount of Codecademy clones out there for Ruby and Python, compare that with Perl. Searching for "beginner Perl" on Amazon will result in less than 5 books, one of them being the highly suggested "Learning Perl" which I felt was highly over rated. Thanks to Ovid for writing his "Beginning Perl" book which gave this field a breath of fresh air and really helped me so much in Perl. Finally, if you look at the question from a reverse perspective, what types of skills employers are looking for, it's a hard sell to ask people to code in Perl where jobs are hiring for Ruby or Python users. I tend to look for "one rock two kills" type of skills to build, something that helps my current role but also in my future role at another job. If I invest my time in Perl would it pay off as much as investing that same time in Python? For now, since the place I work at has a heavy investment in Perl it does, but I am trying to keep up to date with Python as it's asked for much more than Perl is. 
I'd like to try it. Can we get some instruction on how to get it up and running on shared hosting?
Just came across [Warrick](http://warrick.cs.odu.edu/), a web page recovery tool written in Perl.
A generic flash video retriever would be more useful for me. I would use it to feed videos into mplayer so I can avoid using Adobe Flash. I would consider converting the video before I with avconv before I even watch it.
Why isn't it on cpan?
Will you be doing another hardware hacking session? 
The README on github seems like a pretty good start - https://github.com/Perl-Evozon/PearlBee
If I understand it correctly you cannot just run commands on most shared hosts.
Some certainly. I wouldn't think most. If your shared doesn't doesn't give you a shell, you should probably find a new host. However, even with a shell this will probably be challenging to get working on a shared host. A VPS would be more appropriate.
I mean something like dataflow or node based programming in general.
I have seen this project called [PNI](https://github.com/fibo/pni-pm) before, but haven't tried it. Side note: a tool that does visual ETL / data acquisition would be a really nice showcase of Perl.
I'm kinda tempted since i've been working on a framework for Java, but a simple visual tool for perl could be nice. Something that invokes scripts concurrently and routes results visually.
Yes! It is confirmed. 
A direct link to the mailing list is here. http://mail.pm.org/mailman/listinfo/hardware-pm
Sounds great!
How will you know when you get to the end? Do all methods have parameters?
Of course you can do that. Just be sure that the AUTOLOAD subroutine returns a properly blessed reference so that the chaining works.
You can use the autoload stuff, assuming, as others have mentioned, you properly bless your return values. Myself, I would look at Moose, specifically, the metaclass stuff, and using add_method or some such at runtime, so autoload isn't hit every time you make a method call.
You can do that, but it would be my last choice. What ist this JSON-Obj? Is the package written by you? What's its Intention? Just store JSON-data? At first sight I think you should inherit from your JSON-package to add your RPC logic.
syntax_parse looks ugly. But I agree with your second example. Why inject AUTOLOAD magic, fake your functionality, internally guess when you have to flush your call (DESTROY? Operator overload? Guess on Parameters?) and get confusing error messages, just to have different Syntax?
In his specification it is not clear if you know the methods in advance or if it is just a function name to string mapper.
And, it's slower and more difficult to error-check.
[This](http://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234582#answer-4234491) is the single best thing online about parsing HTML with Perl.
I was doing this exact thing yesterday. I ended up using HTML::Manipulator, it's great for pulling information out of specific tags, or editing HTML. 
The `Devel::Local` module looks really useful! I usually do that by hand in a file I call `ENV.sh` right above each project directory. Looks like I'll be able to cut down the work there.
Module::Build is absolutely not necessary to use a sharedir -- it only takes a few lines added to Makefile.PL!! And this is by far preferable over using FindBin to bring in another file in @INC.
Untested, but probably works: foreach my $alignI (keys %charHash) { foreach my $key (keys %{$charHash{$alignI}}) { print "\$align = $alignI, \$key = $key\n"; } } 
 foreach my $alignI (sort keys %charHash) { print join(", ", map { "\$align = $alignI, \$key = $charHash{$alignI}{$_}" } sort keys %{$charHash{$alignI}}) . "\n"; } 
Yep, that works. Source: I use HsoH much too much. 
DDG and Google do not give anything helpful for HsoH. What is it?
Sorry; Hashes of hashes. HoH is a pretty normal abbreviation for 'hash of hashes', and pretentiousness and anal retention overcame me when I pluralised it. 
HoH I would have recognized. I thought maybe I was missing out on a better way to extract data from them.
That's great to know - have you got a link to where this is documented, or maybe just post a code example? Thanks
Are there other editors? ;)
My benchmarking shows the xs implementation of Protocol Buffers will kick any ass. YMMV.
Before running cpan you can seed the values the config would normally ask for into /etc/perl/CPAN/Config.pm at least that is the location I have in Ubuntu.
Use 'cpanm' instead, maybe?
I do love being able to just do cpanm Moose But I am gaining much love for puppet apply -e 'package { "perl-Moose": ensure =&gt; "installed" }'
Thanks for the tips! The Puppet module [example42/perl](https://forge.puppetlabs.com/example42/perl) works well enough.
You could just use cpanm (App::cpanminus), which is entirely command-line driven, has no config files, and knows where to download things from automatically.
huh? the graph is not "based on" number of modules added per day. the graph is number of total modules that existed there on each day. The far right column of the table below the graph shows the first derivative, which is number of modules added per day.
Yeah, but most of those Ruby "gems" are probably like this: http://rubygems.org/gems/a
cpan can load any configuration file you like with it's -j switch. If you have a setup you like: % cpan -j MyConfig.pm -i Some::Module
And the whole thing ignores the fact that CPAN already has a very mature and stable set of modules, something that a number of the other languages lack.
Ignore the cpanm spam on this sub. Configure CPAN once by hand, then copy ~/.cpan/CPAN/MyConfig.pm to whatever other machines you need.
Looks cool but doesn't work for me (nothing is printed). Any particular version required?
Quantity != Quality across any of these, it's always about the right tool for the job. I'm ignorant to a lot of these other language module repos, but i'm curious if all these other languages have the emphasis on testing similar to that of cpantesters. 
Why is "Perl versus Python" such a huge pissing contest? Perl is popular. Python is popular. There are a ton of languages more popular than either, but they're total divas and pretty ugly on the inside. They're both pretty, okay? It's just that I happen to like Perl better. I know her better, and I've known her for longer. In a way, we grew up together. My younger bother likes Python, because *they* grew up together. I still think Python's cute, and I like hanging out with her sometimes, but I'm not going to risk everything I have built with Perl for some younger...indentations. I like having a diverse group of friends, but it's Perl that I love. 
CPAN.pm is using ExtUtil::MakeMaker::prompt, so it can be forced to autoselect by closing STDIN or using PERL_MM_USE_DEFAULT environment variable, in Unix-like shell: PERL_MM_USE_DEFAULT=1 cpan -i CPAN
I wonder if their "modules on the CPAN" number is taken from 00modulelist, or 02packages -- as the registered module list is deprecated and not really used anymore. 
In other news, J.Bieber is more popular than J.S.Bach. 
Not a bad idea! I just worry that the config file will have some machine-specific details that will create trouble for other machines... I'd like to be able to install cpan packages no matter the hardware, network, or OS. ... and so I use [example42/perl](http://forge.puppetlabs.com/example42/perl).
Not sure what a second edition review should be all about, but a whole paragraph about the new cover that's almost as long as the summary of the book? Coverage of `taint` as a highlight? 
It's a **big** change :)
Sorry, but I'm having trouble figuring out whether or not this is a serious post (formatting + "old" style + past trolling here = my suspicious nature). In case it is, I've formatted it a bit if anybody wants to take a stab at it: *edit: s/cleaned/formatted/* ------------------------------------------------------------------ sub UtilDisplay() { my $conn = shift; my $query = "SELECT ID,BLOCK,BITS FROM IPDB WHERE PARENT = 0"; my @result = &amp;QueryDB($conn,$query,"Pull parent list"); my $total = Math::BigInt-&gt;new("0"); my $inuse = Math::BigInt-&gt;new("0"); my $tnum = Math::BigInt-&gt;new("0"); my $tinuse = Math::BigInt-&gt;new("0"); my $i = 0; my @out; while (@out = $result[0]-&gt;fetchrow) { $id = $out[0]; $block = $out[1]; $bits = $out[2]; $ver = &amp;Version($conn,$id); if($ver == 4){ $total = &amp;Addresses($bits,$ver); $tnum += $total; $blk = &amp;deci2ip($block,$ver); $inuse = &amp;GetInUse($conn,$id); $tinuse += $inuse; $pcnt = ($inuse/$total)100; printf("%40s/%3d | %.2f %% in-use\t%10d / %d\n",$blk,$bits,$pcnt,$inuse,$total); } undef $ver; undef $bits; undef $block; undef $id; undef $total; undef $inuse; undef $blk; undef $pcnt; } $tinuse =~ s/+//g; $tnum =~ s/+//g; $pcnt = ($tinuse/$tnum)100; print " "; printf("Total | %.2f %% in-use ",$pcnt); printf("\t%10d / %d in-use/total\n",$tinuse,$tnum); print " "; printf("Class C's | ",$pcnt); $tinuse = $tinuse / 255; $tnum = $tnum / 255; printf("\t%10d / %d in-use/total\n",$tinuse,$tnum); print " "; printf("Class B's | ",$pcnt); $tinuse = $tinuse / 255; $tnum = $tnum / 255; printf("\t%10d / %d in-use/total\n",$tinuse,$tnum); print " "; printf("Class A's | ",$pcnt); $tinuse = $tinuse / 255; $tnum = $tnum / 255; printf("\t%10d / %d in-use/total\n",$tinuse,$tnum); &amp;FinishDB(@result);
Sorry I'm not great at formatting in reddit.
&gt; $pcnt = ($inuse/$total)100; Don't you want: `$pcnt = ($inuse/$total) * 100;` 
That is in there. It must have been lost when he formatted it for me.
I like that new cover format FWIW.
 $pcnt = ($inuse/$total) *100; You're using (big)ints to do a floating point calculation (~~I'm assuming the formatting also missed off a multiply~~ [Edit]I see from below that's the case). Try this... $pcnt = 100 * $inuse / $total; 
For code, just indent everything by at least 4 spaces.
Thanks I see where I went wrong there.
congrats to all involved, great to see another book published!
Hmmm, maybe it's the thrift ones that suck then..
for all you down voters, is there any constructive criticism here? Don't like the direction of the Catalyst project, feel this is not the correct channel for announcing it? If I don't hear anything I'll assume its just a petty power trip from social misfits, thanks ;) -jnap
DWIM == "Do What I Mean" for those of us that spaced that.
Here's my quick rambling about that "article": * Broad explanation of protoypes, but typeglobs are too old? * Forgot to mention that hash keys in @_ are read-only. (Which he should if he goes that deep into details). * Failed to mention slices for references (`@{$hash_ref}{qw|two keys}`) * ¿¿¿¿GOTO???? * Array Context? That thing is called List context. * `qq` even does dereferencing. /thought filter on slightly finer threshold That article from the looks and from the content seems to be written sometimes 1999 but the mentioning of `state` and the new edition of "Mastering Perl" suggest otherwise. I really can't imagine no target group for these words, It just reads as if someone has programmed some time in perl and pulled excerpts of documentation he found useful together.
Do you have an example of the file? While you can't adjust $. there's a number of methods to pull additional lines but just using extra &lt;&gt; operations usually works for me.
With respect, that doesn't describe the file at all. You can do this as simply as a loop looking for the record header, followed by assigning each following line to a new variable with &lt;$fh&gt; You need to show either code or data, you can't give us neither. If you don't have a real example, please construct one (including headers, line returns etc)
You can add targets to the Makefile by defining particular subroutines in the MY:: namespace. See, for instance, the MY::postamble example in the ExtUtils::MakeMaker documentation. However, I'd just define those as shell aliases instead of adding them to every Makefile.PL. 
You need to buffer the lines yourself then use them however you like.
It sounds like you have a file with multiline records. If you set `$/` variable into your record separator, you'll be able to take record by record. 
There's an example in the ExtUtils::MakeMaker documentation. If you have a bigger question, I suggest StackOverflow, which is a bit better for this sort of thing. Remember to show what you did.
Updated my description with the `Makefile.PL` I've go so far.
There isn't really any magic happening. With the default value of `$/`, each time you invoke `&lt;&gt;` one line is read and assigned to `$_`. That's it. If you want the next line, you have to call `&lt;&gt;` again yourself to get it. Perl isn't going to do any IO that you don't explicitly ask for. Lines have variable length, which means they are not random access -- perl can't know where any given line number starts in the file. The only way to get that information is to start at the beginning and read lines and count them until you reach the desired line number. If perl were to speculatively do that behind the scenes in order to support the kind of random access that you're talking about, it would potentially involve a great deal of IO and memory, which would be very unwelcome to people that didn't use the feature (i.e. everyone.) However, if you know the file you're dealing with is reasonably small, you can go ahead and read it yourself: my @lines = &lt;&gt;; # or &lt;$fh&gt; if you're not reading from stdin/argv This reads all of the lines from the file and puts them in an array, so that you now have random access. Line number 5 is `$lines[4]`, line number 100 is `$lines[99]`, and so on. Whatever you were hoping to do by setting `$.` can be done by indexing into `@lines`. 
You have to use the subroutine name "postamble".
In that case, you might want to try out [`File::Tie`](https://metacpan.org/pod/Tie::File) which gives the illusion of random access without having to read the entire file into memory. If your usage pattern is of reading lines in mostly sequential, increasing order, it should be very efficient. The other way to do this is to write what amounts to a simple state machine that reads each line and recognizes when it's reached the beginning of a new record: my @current_record; while(my $line = &lt;$fh&gt;) { if(is_record_header($line) &amp;&amp; @current_record) { process_record(\@current_record); @current_record = ($line) } else { push @current_record, $line; } } This assumes that you've written `is_record_header()` and `process_record()` that do the obvious things. 
 $ cat file.txt Author: Bill Gates Comment: good book! Public: y ==== Author: Katy Perry Comment: I want 2 hrs of my life back. Public: n ==== $ perl -e '$/ = "===="; while(&lt;&gt;) {m#^Author: (.*)$#m &amp;&amp; print "Author is $1\n";} ' file.txt Author is Bill Gates Author is Katy Perry
If you pass `-q` to perlcritic, it will not print the "source OK" lines and only give you errors, so you don't have to do your `grep -v "source OK"`.
Meh, Ruby? I think Go is gonna be where it's at soon (if not already).
Cool new feature. I don't like it. I see more usability in fixed given-when and smartmatch operator, than new syntax for something that not so hard to do already. 
I'm not in love with the syntax. The old way of dereferencing has a logical feel that is near intuitive. If anything I would prefer a function like syntax that was more wordy but easier to understand, something like: deref($my_reference)-&gt;to_array which still gives you the postfix operation, with a prefix hint of what's to come. Well, I really can't complain too much since I don't participate in the perl core community. I figure we had a chance to voice any objections and we didn't, so we get the new feature. :) 
Thanks!
Looks awesome. Can't wait for it to move out of experemental so that i can feel safe using it.
while you can say today: Everything that starts with a $ is a scalar ... I hope it's worth another exceptional case in the syntax
A few questions: * Perl version, * which database is this?, * does your query works and hangs when entered directly in the database client?, * how did you detect that the last item is the problem?, * do you have enough memory on your machine? (kind of unnecessary question, I know), * do you have some pretty big rows in these resultsets? (like title field the size of few KB and more). Maybe it's Perl memory allocation issue. Try to run your loop without assigning to hash, but do some calculations of the fields so it doesn't get optimized (like total length of all author fields).
I'm sort of on the fence. I'm a huge fan of "the outermost sigal is what sort of thingy we're dealing with" mindset, but the new syntax makes deeply-nested structures a _lot_ cleaner looking. 
I wish you could say that today! perl -E '$scalar = sub { say q(Im no scalar!) }; $scalar-&gt;()'
&gt; Maybe it's Perl memory allocation issue. I've definitely seen this with large amounts of data in a hash. When the process ends, it takes an extra bit of time (could be 30 seconds or more) to do something with releasing the memory.
Sub refs are indeed scalars. &gt; All data in Perl is a scalar, an array of scalars, or a hash of scalars. A scalar may contain one single value in any of three different flavors: a number, a string, or a reference.
Oh, I see what you mean. Good point. That's actually a really good precedent for this new syntax.
Yea. The SQL statement was just an example. Can you elaborate on the bind on execute? Thanks!
Data binding works like this: my $sth = $dbh-&gt;prepare("SELECT isdn, author, title, publishdate FROM books WHERE publishdate &gt; ?"); $sth-&gt;execute('2012-01-01'); You can read more in: https://metacpan.org/pod/DBI#Placeholders-and-Bind-Values
Do you mean like this? my $sth = $dbh-&gt;prepare("SELECT isdn,author,title,publishdate from BOOKS where publishdate &gt; ?"); $sth-&gt;execute('2012-01-01') or die "Cannot perform query\n"; Thanks!
It's not memory. See my other response. I apparently don't understand something about how perl is executing code internally I think. Thanks!
Yea. I got what you were referring to after I posted my first reply but thank you. My actual query is more general than my example and so I didn't do it originally. But after I get my hash keys I am using binding in all of my select statements further down the line. I was thinking the binding was for security to prevent SQL injection type of attacks. Is that right or is there more to it? This particular query is just running on my machine but I do try to practice it when I can though. I will check out the link.
&gt; So postfix dereferencing is not setting a precedent here. I wonder if people avoid `&amp;$coderef` because it's a) ugly b) too similar to `&amp;function()` c) too similar to `\&amp;coderef` or d) not that popular in example code.
Even more i like the slicing syntax: $hashref-&gt;@{qw|one two three} = 1..3; 
&gt; What about some perl functions that already "experimentally" deference automagically, like push, ( v5.14+ in this example ) ? Thanks to the array-keys mistake, they're a mistake waiting to be removed.
So see the new syntax as a magic method injected to refs? I think it mainly tries to fix symptoms of the problem that Perl cannot handle refs for its own.
&gt; This is cleaner than circumfix as there are no extra curly braces I don't understand how replacing three chars with different three chars is "cleaner", especially when everyone is accustomed to old style. &gt; nested references are easier to read as we don't have to track back to the beginning of the reference to locate the sigil. WAT? You don't "track back to the beginning" if you're reading code left-to-right. You know it's @{ } from the start. &gt; Stylistically the circumfix operation is ugly &gt; push @{$deep_array_ref-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]}, 4; &gt; push $deep_array_ref-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;@*, 4; Yeah, well, you know, that's just, like, your opinion, man.
Console output is buffered. You need to add $|=1; to make your "print" function actually print to console. That's also why you need to provide actual code that causes problems, because it seems it has nothing to do with the DBI calls. The problem is most likely with "print/say" and you didn't even include them in your post. 
Well it's a work project and that makes me a little squeamish about posting my actual code. My code is like this: my $count =0; my $sth = $dbh-&gt;prepare("isdn,author,title,publishdate from BOOKS where publishdate &gt; '2012-01-01'"); $sth-&gt;execute(); while (my @subscription = $sth-&gt;fetchrow_array) { $count += 1; $randomhash{$array[0]}{'author'} = $array[1]; $randomhash{$array[0]}{'title'} = $array[2]; print "$count\n"; } #closes while @subscription $sth-&gt;finish(); print "Done.\n"; print scalar keys %randomhash; print "\n"; So, the lack of the last digit of the counter and the two other print statements were what was making me believe that it was stuck in the while loop. I'm unclear on where I should place the $|=1 in that process to keep the print statements from being buffered. Would you show me? Thanks.
$| can be localized. If you don't need non-buffered output anywhere but in your "while" loop, place it in there and make it local: while (my @subscription = $sth-&gt;fetchrow_array) { local $| = 1; $count += 1; ...; If you don't really care about buffering, just place it in the beginning of your script as $| = 1; It's described in http://perldoc.perl.org/perlvar.html#%24%7c
Sounds to me like what you really need is a config file instead of command line options.
I dunno, reading a YAML config file is much easier in my opinion than getopt.
I like to use commas to divide multi-part arguments. It's obvious to use and obvious to read. --headers=location,color,stuff my $headersarg; GetOptions( "headers=s", \$headersarg, ....); my @headers = split(/,/, $headersarg); 
Nope, but that's cool!
I don't completely understand your requirements, so I could easily be wrong, but the config file seems less complex to me than long, confusing sets of command line options.
I prefer to use a single %options hash, rather than individual variables. my %options = ( ... initialize with default values ... ); GetOptions( \%options, 'column_headers=s@', ... ) ... If you read your Getopt::Long Perldoc.... "Options with multiple values Options sometimes take several values. For example, a program could use multiple directories to search for library files: --library lib/stdlib --library lib/extlib To accomplish this behaviour, simply specify an array reference as the destination for the option: GetOptions ("library=s" =&gt; \@libfiles); Alternatively, you can specify that the option can have multiple values by adding a "@", and pass a scalar reference as the destination: GetOptions ("library=s@" =&gt; \$libfiles); Used with the example above, @libfiles (or @$libfiles) would contain two strings upon completion: "lib/stdlib" and "lib/extlib", in that order. It is also possible to specify that only integer or floating point numbers are acceptable values. Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators: GetOptions ("library=s" =&gt; \@libfiles); @libfiles = split(/,/,join(',',@libfiles)); Of course, it is important to choose the right separator string for each purpose. Warning: What follows is an experimental feature. Options can take multiple values at once, for example --coordinates 52.2 16.4 --rgbcolor 255 255 149 This can be accomplished by adding a repeat specifier to the option specification. Repeat specifiers are very similar to the {...} repeat specifiers that can be used with regular expression patterns. For example, the above command line would be handled as follows: GetOptions('coordinates=f{2}' =&gt; \@coor, 'rgbcolor=i{3}' =&gt; \@color); The destination for the option must be an array or array reference. It is also possible to specify the minimal and maximal number of arguments an option takes. foo=s{2,4} indicates an option that takes at least two and at most 4 arguments. foo=s{1,} indicates one or more values; foo:s{,} indicates zero or more option values. "
One thing I tend to do for config files for quick-and-dirty scripts is build the config as a hashref in Perl, and use a module like YAML to dump out the config file itself. Works for me.
Just use the array solution as shown elsewhere in the thread, and parse "OR" from the array.
I don't think the former can work in Getopt::Long. And the latter looks way too verbose to me.
I think I'd bypass Getopt::Long and parse @ARGV directly. It's not rocket science. You can then use custom delimiters, a bit like [find](http://unixhelp.ed.ac.uk/CGI/man-cgi?find) uses a quoted `;` as a delimiter for `-exec`. Or, you can continue parsing arguments *until you get to the next option*, and `--` if it's the last option on the command line. If you insist on pairs of data, then, by all means, *use* pairs of data. --pairs a=one b=two c=three --end 
The former works if you use the experimental --opt=s{1,} format. But it doesn't interact well with some other options (bundling I think).
This syntax is neat, but it doesn't work with bundling, which sucks because bundling is really nice. The CSV thing is suggested in the Getopt::Long docs and I think people find it more intuitive, too.
This is insane. Your CLI will parse options differently to every other script (users hate this) and you have to write a bunch of probably-buggy code that someone will have to maintain. For the sake of allowing array arguments? I would stick with split(/,/)