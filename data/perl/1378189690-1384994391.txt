that's exactly what you're doing...joining and printing the "one big list" returned by map.
Cool. I suggest to show the full chain of links on the "VICTORY!!!" page, not just the count. It should also have a more prominent link to play again. Also, the page with the "start" button should explain how the game works. Especially, it should explain how the temporary hint is coming.
The only time I've done this is when using a singleton pattern: my $thing = Foo-&gt;new; becomes: my $thing = Foo-&gt;instance; Maybe this is dumb, but it works for me. 
I will add this tonight :)
I have not decided how I want to simplify it yet... Thinking of making a set of "known" pages based off modern(ish) culture.
PPW is a good time
I'm reading Higher Order Perl right now and it's been a revelation. Thanks for another example of how this is useful.
Programs that write programs are the programs I like most.
Higher order programming is an important skill to cultivate. I've been doing this a long time, so it was interesting to step back and attempt to explain what I'd written and how it worked to an audience with less experience. (It felt really natural to write, which is a nice sign.)
Neat! One bug I encountered regarded disambiguation pages: Goal was "Grigory Rasputin", and 'Rasputin' is a synonym for 'Grigory Rasputin', page-wise. However I had to go to the disambiguation page and click on 'Grigory Rasputin' to trigger the end of the race. Here's the chain: London-&gt;Metropolitan area-&gt;Moscow-&gt;Tsardom of Russia-&gt;House of Romanov-&gt;Rasputin-&gt;Rasputin (disambiguation)
Hurm... let me check on this the log shows you made it legit... [Wed Sep 4 23:01:15 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : London [Wed Sep 4 23:01:27 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Metropolitan_area [Wed Sep 4 23:01:42 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Moscow [Wed Sep 4 23:02:00 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Tsardom_of_Russia [Wed Sep 4 23:02:34 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : House_of_Romanov [Wed Sep 4 23:02:40 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Rasputin [Wed Sep 4 23:03:07 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Rasputin_(disambiguation) [Wed Sep 4 23:03:16 2013] [info] Start : London - Fin : Grigori_Rasputin - Current : Grigori_Rasputin 
&gt; use 5.010; &gt; use feature 'say'; Clueless...
That seems an awful lot more like an insult than a critique.
"perldoc feature" may clue you in.
Point taken. Thanks. Some of us have been away from Perl for a while and only recently came back, so maybe you could be a bit more up-front with your point and a little less abrasive? 
As a wee admin I once remarked to a senior that I thought I was "cheating" by writing code that writes code. He told me that if you're not doing that then you're doing it wrong. Now I abstract up as far as I can so I can reuse the code writing code for many different tasks.
&gt; you could be a bit more up-front with your point and a little less abrasive? Fair enough. I'd appreciate it if you would, in turn, consider how much of how many others' time you're consuming by self-promoting on Reddit.
Yes, I wrote an entire article - which took about two hours between editing, coding, etc - and put it on my blog with zero ads openly seeking peer review because I'm promoting myself. Exactly as you are certainly not trolling by dismissing my entire article because of one redundant line of code.
IOW, "chicks dig minus-less-than," so include "-&gt;" in your code as much as you can.
I've recently been using Inline::CPP at work. Not something I'd want to have to use often, my C++ is poor at best but it's certainly a useful tool to be aware of. There are some nice quotes in the rational section of the Inline::CPP docs https://metacpan.org/module/Inline::CPP#RATIONALE
I tried it yesterday but this morning I faced a Server Error just after starting a game... EDIT: Seems OK now.
Depending on the time of day it could have been a few things * Had a bug in the page load that broke on wiki pages that had "/" in them * I could have been doing a deploy * Aliens.... Aliens.
Some OK advice but I'm not sure he understands what script-kiddie means.
The general rule of thumb on reddit is up to 10% self-promotion is acceptable. This user is closer to 50% and the rest of their "contributions" only appear to dilute the spamminess in a numerical sense.
&gt; you can set up a VCS on any server you choose, or even just on your desktop machine. Or use the fucking DVCS, it's 2013, you don't have to set up anything
Perhaps it's possible to identify a point in Perl 5's history at which the language or its culture or its idioms changed sufficiently that Before is one thing and After is another.
It's not dead...
Not only have I never heard of it, no search engines can find evidence of its existence.
&gt; s/Linl/NQP/g 
Where this line appears: my $album_playlist = $iTunes-&gt;CreatePlaylist("$album"); Change "$album" to "$artist - $album". That should work. Also there's a lot of cruft in this script which could be removed. Don't know if these are the parts you've edited or just the script in the original form. Just makes me not put a lot of trust in the code.
Quick fix. Change my $album_playlist = $iTunes-&gt;CreatePlaylist("$album"); To be my $album_playlist = $iTunes-&gt;CreatePlaylist("$artist - $album"); 
When I try that, the playlists comes out " - 20/20 Experience", etc. The artist doesn't show up.
The script I linked is the original source. I haven't modified it. I tried that change, but the $artist tag makes it blank: " - 20/20 Experience", etc. It seems like there's a disconnect between the first and second functions. The scope of the first function's "$artist" doesn't carry over to the second, so it's not actually using the same variable (scalar?). (To test, I changed the variable to $number in the second function, and it worked just fine.) The problem I'm having is pulling the artist title out of the array or hash or whatever that's called. I mean, what does "push (@{$seen{$artist}{$album}}, $track);" do? I tried reading about it, but couldn't figure it out.
Do all the playlists come out that way or just some? Double-check that the song does in-fact have artist information entered and also double-check your spelling of $artist as well. The line: print OUT "$artist\n---------------\n"; Should print out the artist names as the script runs. Are you seeing this output at all when you run the script? 
https://github.com/perl6/nqp Runs on top of JVM or [Parrot](http://parrot.org)
In what universe it's ok to change language name to another *existing* language's name (even if Perl 6 is now Perl 42 or whatever)
Hey Rob, great article. I have one comment though, when you say &gt; The recommended technique in this case is to copy the list of scalars you intend to print and throw it away after you're done. Couldn't you simply not interpolate the value, and instead use print as a list operator: my $value = 10; print "Next year, I will be ", $value, " years old.";
Note the s/Linl/NQP/g at the end. I realized it might be irritating to some that I invented a word ("Linl"), but this seemed to me an appropriate device to make a point. The technical merit and relevance of the NQP and Rakudo approaches to reinvigorating Perl 5 are getting lost due to emotional misinterpretations of what has actually happened and is happening. I agree with the sentiment that the NQP and Rakudo devs pretty much need to deliver a polished product before further addressing regular, non-contributing P5ers, but I also think that the main thing slowing their dev efforts down is limited contribution, and that the main thing constraining contribution is awareness of the technical merit, progress, and relevance of their efforts.
Afaict devs seem to be thinking they'll also soon* have NQP self-hosted on: * [MoarVM](https://github.com/moarvm/moarvm). This is the target of [the $10k grant to embed libperl](http://news.perlfoundation.org/2013/07/hague-grant-application.html) that I mentioned above. * [A node.js/V8 backend](https://github.com/pmurias/rakudo-js). This is the target of [a GSOC project to get NQP to self host on node.js/V8](http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/pmurias/9002). \* I'm liable to get in to hot water for using the word "soon" but I think it's apt. From what I've heard, I think the MoarVM devs anticipate NQP being self-hosting on MoarVM this month and the V8 dev (pmurias) is over half way through his inchstones to completion. Update: [NQP is now self-hosting on MoarVM.](http://6guts.wordpress.com/2013/09/08/a-moarvm-progress-update/)
I don't see how Parrot has come close to trying to address the concerns in my original post. It's a mess of old school C, and by the mid aughts C stopped making sense for these things. As far as I can tell it never made clean and easy embedability in a C++ project a priority. It has also been obscenely slow for over five years.
Who mentioned Parrot? Ignore Parrot. Evaluate NQP (NQP/JVM, NQP/MoarVM, NQP/V8, etc.) on its own merits.
Whoa, awesome! Is it realistic to just run with NPQ, and live with whatever subset?
actually, I believe map creates a copy of the whole modified array, so it uses more memory. 
Thanks for testing it. I read over the code a few times and I was baffled why it wasn't working.
Super cool! Thanks for the walkthrough.
Turns out, I'm an idiot. I'd modified the "my $artist = $track-&gt;Artist();" line to say "AlbumArtist", which made all of the albums with no AlbumArtist info show up blank and first. I fixed the problem by modifying all of my tracks using foobar's "Automatically fill value" and the source $if2(%album artist%, %artist%) to assign an album artist tag to every song. Running the perl script again then made it work. Thanks for your help. (Oddly, the line "print OUT" doesn't show up on my screen. If I remove the "OUT", it shows up. Am I looking in the wrong place?)
I feel really dumb right now. When I'd first run it, it worked but gave me distinct playlists for the same album per artists with "feat. X". So I figured out that the "my $artist = $track-&gt;Artist();" line could be changed to say "AlbumArtist", and changed it. For whatever reason, I didn't realize that albums with no "Album Artist" data wouldn't work, even though it's obvious in retrospect. So, I used foobar to modify all of the albums with no "album artist" to have their artist data entered, and tried the script again. It works. Thanks for your trying it out. Sorry to have bothered over something like this.
You don't need the braces around the join... and the expression form (no braces need a comma) of map is perhaps a little cleaner too: print join ' ', map @$_ , values %hash; That way the comma is read as a nice statement separator, and it's not as noisy with braces. Functional style FTW!
Oh yeah, I didn't even catch the OUT there. That is for outputting to a file which I don't see opened anywhere. The original developer was probably using that for debugging and then accidentally left it in. Glad you got it working.
I like your style :)
This does however maybe help me with something I need help in doing that isn't quite as complicated on the proxy side but I need to add in a specific curl commands or some other use to say for every new msg that is in inbox find these things, put into MySQL db, then move msg to folder X. Does anyone already have this script written?
Original post on /r/pics: http://www.reddit.com/r/pics/comments/1lz8mq/things_fitting_perfectly_into_other_things/
Yep, they're easy to get at most Perl conferences. Liz and Wendy distribute them. (Source: I got one too :))
Yeah, I picked up a few at LPW last year -- as /u/tsjr says, they're around at most big Perl events :-) The other side reads "TUIT", making it a [round tuit](https://en.wiktionary.org/wiki/round_tuit)
That's timotimo's tuit. lizmat (and Wendy) designed and distribute them. timotimo spent many years focused on python. He did not find Perl 5 attractive but he "drooled over a couple of examples from perl6advent" during December 2011 and wanted to take a closer look. In early 2012 he got around to it -- he joined [the IRC channel #perl6 on freenode](https://kiwiirc.com/client/irc.freenode.net/perl6) and asked some questions (including "what's a tuit?"). He's now a well loved contributor to Perl 6 and [NQP](http://www.reddit.com/r/perl/comments/1lumnn/in_a_parallel_universe_what_would_have_happened/cc3gpkl). lizmat had been a Perl hacker for a couple decades. In 2012 she hosted a ["Perl Reunification Summit"](http://blogs.perl.org/users/liz/2012/08/as-some-of-you-may.html) bringing together Perl 5 and Perl 6 contributors. She really wanted to find time to contribute to Perl 6. In 2013 she has gotten around to it in a big way, landing loads of commits most days for 3 months and counting. \o/ When are you, dear readers, going to get around to it? :)
The bold is highly disturbing.
I got one at YAPC::Europe last month. They say 'Tuit' on the other side of them. The (rather lame) joke is that when you ask someone to do something you can give it to them and say "now you get a round 'tuit'".
NQP is designed to be "a high-level way to create compilers and libraries for virtual machines". It assumes/provides some stuff that helps (most notably 6model and a grammar engine) -- and not a lot else. It probably won't be suitable outside its domain. NQP documentation is a weak spot at the moment but apparently this is being addressed for the NQP workshop this month. So maybe play with it when the new doc gets published, presumably in the last couple weeks of September. **Update:** [Rakudo and NQP Internals Workshop Slides](http://www.reddit.com/r/perl/comments/1mlaqi/rakudo_and_nqp_internals_2_day_workshop/)
Technically Liz buys them. She got to visit the factory that makes them when she came to Austin for YAPC::NA 2013.
Well, does all discussion need to have a value? But actually, I think this does have a value. There are people saying variations of "Perl 6 is stopping Perl 5 from changing its version number" and this makes them consider whether or not this would have happened in the last thirteen years.
&gt; this makes them consider whether or not this would have happened in the last thirteen years. But it doesn't matter either way. If the answer is "yes", then what? If the answer is "no", then what?
Thank you. I've edited my comment.
And I meant to say that Wendy buys them. It was Wendy organizing the trip to the wooden nickel factory at YAPC::NA
I hear you. I'd have chosen "fun" to keep it three letters like "sub", or "defun" like LISP, or as you said, "function" like Javascript. But as you said, a little nitpick. "method" is gorgeous and I can't wait to use it.
I think [Carl Mäsak's point is well taken](http://www.youtube.com/watch?v=E_8bjsimLsk&amp;t=29m53s). As a Python 3 enthusiast, I'm frustrated by the staying power of Python 2. Here we are at the advent of Python 3.4 and when the average person on the internet says "Python", they still mean "Python 2 only". Conversely, whenever I post something that only works in Python 3, I'm generally met with, "oh, I forgot to mention...we're using Python 2." Whenever I find myself lamenting the length of time it's taking them to create Perl 6, I remind myself of the situation with Python. The Perl situation could be much worse...*they could actually finish Perl 6!*
The `new` wouldn't be written with a `func`: That is what the invocant parameter is for. We can use an alternate name like method new($class: $log_line) { ... }
I think on one-line return methods you're better off not assigning $self at all due to the overhead of copying variables during function calls (subject to code clarity, but it's good to be in the habit of knowing this when you're making getters for public modules, since you might not know how many times it will be called by a program) Stuff that just does a lookup or calculation should: return $_[0]-&gt;{value} * 5; You could do shift-&gt;{value} but that calls another function, which may or may not be optimized away.
With Perl 6 being effectively a new language, it's going to take a lot to get me to even *consider* using it. What are the chances that the time and effort involved in becoming as proficient and **efficient** using Perl 6 as I am with Perl 5 will pay off in terms of the speed with which I can create working code and the efficiency with which that code will run? And that ignores the likelihood of Perl 6 matching Perl 5's ubiquity, particularly where it's likely to matter to me; on commercial webservers where I'm going to want to implement CGIs.
&gt; What are the chances that the time and effort involved in becoming as proficient and efficient using Perl 6 as I am with Perl 5 will pay off in terms of the speed with which I can create working code and the efficiency with which that code will run? You're probably years away from that being a practical problem.
One important difference: the intent is and always has been for Python 3 to replace Python 2. Even though that was true for P6 for many years (it's in the *name*, after all), pragmatism dictated a few years ago that that's no longer the case. In one sense, P6's interminable gestation solved the problem of a period of uncertainty in which P6 gradually replaced Perl 5. Unfortunately, it did so only after failing to produce a credible replacement for Perl 5 and making all of Perl look like a project wandering in the wilderness without a map.
say()? Versus...print()?
This gave me a little laugh recently while skimming 'perlsub'. &gt; Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. http://perldoc.perl.org/perlsub.html#Prototypes
 $_ =~ /(?:[[:alpha:]]{2}|[[:alpha:]]{6}):\d{4}[ ]\d+/ ...is what I could come up with, based on what you say. Note that "\D" (with a capital D) matches *any* non-digit character, probably not what you want. Breaking it down using the '/x' switch: $_ =~ /(?: # non-capturing parens, marked by the '?:' [ # start of a character class [:alpha:] # like [a-zA-Z], but potentially locale-aware ] # close character class {2} # exactly twice | # OR [[:alpha:]]{6} # the same, except exactly six times ) # end non-capturing parens : # a literal colon \d # any digit {4} # exactly four times [ ] # you have to put a space in a character class # when using the '/x' switch, because it # ignores spaces normally \d # any digit + # one or more times /x; # see perldoc perlre for more on '/x' 
So, to start with, rather then using the "NOT numerics" character class (\D) to match alpha chars, instead using something like \pL (which matches all unicode letters) or if this is known to be ASCII, [A-Za-z]. I don't get what you mean by "But there has to be a way to tell Perl, that 2 alpha's is different than 6." can you rephrase that? If you wanted to match both in a single regexp then you could use: my( $prefix, $num, $final ) = $_ =~ /([A-Za-z]{2}|[A-Za-z]{6}):(\d{4})\s(\d+)/; You can tell which kind it is with length($prefix)==2 and length($prefix)==6 If you wanted to put the 2 char and 6 char prefixes in different buckets: my( $prefix2, $prefix6, $num, $final ) = $_ =~ /(?:([A-Za-z]{2})|([A-Za-z]{6})):(\d{4})\s(\d+)/; In which case you can use defined($prefix2) and defined($prefix6). Does that help?
Thanks. However, this is a little off the mark for what I need. I am using this is an If, elsif statement. If the pattern is [:alpha:]{2} it needs to do one thing, if it's [:alpha:]{6}, it needs to do another. right now, the pattern, when it's 6 alphas is returning true for \D{2}. I'll update to use :alpha:, but I don't think that will solve the problem. Thanks for the help.
Personally, I find \s a lot easier to read then [ ], but I'll grant that they don't actually mean the same thing, as \s can match all vertical and horizontal whitespace, rather then exclusively a space character. That said, that difference usually that doesn't matter.
say() has been in perl since 5.10, released in 2007.
Ah-hah! Ok that helps us understand what your problem is. Neither of our solutions would fix things for you. What you need to do is bind the match to the start of the string. Currently the 2 char versions will always match 'cause they just skip the first four chars of the 6 char versions. What you need to do is add a ^ to the start of your regexps. ^ asserts that your at the start of the string you're matching against. So you can say: my $suffix = qr/:(\d{4})\s(\d+)/; if ( $_ =~ /^([A-Za-z]{2})$suffix/ ) { my( $prefix, $num, $final ) = ($1,$2,$3); ... } elsif ( $_ =~ /^([A-Za-z]{6})$suffix/ ) { my( $prefix, $num, $final ) = ($1,$2,$3); ... } While I'm here, you can actually skip the $_ =~ part, as that's the default action: my $suffix = qr/:(\d{4})\s(\d+)/; if ( /^([A-Za-z]{2})$suffix/ ) { my( $prefix, $num, $final ) = ($1,$2,$3); ... } elsif ( /^([A-Za-z]{6})$suffix/ ) { my( $prefix, $num, $final ) = ($1,$2,$3); ... } 
I always forget about ^ meaning the beginning of a string - I always think of it as a negator. However, this is pretty brilliant. I just want to make sure I am understanding the code here. You create a variable $suffix and pass it everything from the literal colon and right along with the pattern grouping. Then use an if statement to check the beginning (left of colon) for length, then assign it to named variables, using the $1, $2, &amp; $3, where the $2 &amp; $3 are still part of the $suffix variable? 
Exactly right.
Under appreciated text styling; lime green on black. 
&gt; You're probably years away from that being a practical problem. Indeed. I'm 55 years old now and have every intention of carrying on coding until the day I die. I may never have to even *think* about the problem.
We're currently not planning to upload them to YouTube (where it's a PITA to jump through hoops to upload videos greater than 15min in length). They will be available on Internet Archive soon, where they can be streamed in a browser and on a variety of smart devices. Also: free and limitless storage in perpetuity, free transcoding to multiple formats, open source, etc.
Nice, I will also be tuning in.
Great move on streaming and archiving. Thanks! Not sure how long the movie would be, but eliminating 15 min limit on youtube can be done just once using SMS, and you don't need to repeat that many times. Youtube makes it so much easier to watch on many platforms with the streaming capabilities, so consider uploading to youtube as well :)
What about vimeo or some other site?
If anyone is watching the live stream, I'd love some feedback on sound and quality. (apologies: I know it's difficult to read the text on the slides with white background. We're getting a lot of glare from the windows to Adam's left. He'll be sharing the slides afterward.)
The closest I've come is C#, and just based on that you're in a whole different world. You've got some dynamics you have to solve before you even get to perl: * Unix/Linux. You're going to need to know the basics as well as how to edit files without the assistance of a GUI editor. You won't always have to go into this world, but it helps a lot. * Apache. You'll need to at least know how to start and stop Apache and eventually you'll need to know how to edit the configuration file, which, btw, requires that you know how to use 'vi' or in some cases 'emacs'. * Editing. There are Windows editors that will edit perl code. In fact, there are extensions to Visual Studio that will allow you to use it for your perl projects. The challenge you have, at least with Visual Studio, is getting a unix-based file system to show up on Windows. An ssh filesystem extension will solve this problem. Other editors have built-in FTP/SFTP access. Eclipse, as much as I loathe it, comes to mind. Perhaps others can recommend a good Windows-based editor. Once you get into the perl world, basic semantics are quite similar to other C-like languages (including C#). You'll find that braces replace the control statements that you find in VB. In all honesty, though, I wouldn't be as concerned with the language. If you're any kind of programmer, you can pick up the basics of any language in no time as so many of the concepts carry over from language to language.
I guess I am wondering if there is a vb.net type graphical tool for perl. 
I believe say() automatically adds a newline. and it's shorter to type!
Forgive me if I'm misunderstanding - the only graphical programming tools I've played with are UML-type things or "toy" plug-together-the-animated-components jobbies, but what exactly are you wanting a graphical tool to do? Presumably, the website you're working on has some kind of CGI interface to a DB-based back-end, and spits out HTML or similar? It *may* be possible to load that code into something that provides a graphical representation, then allows you to add components or something, but it's a different paradigm really, and probably would involve a lot more work than simply rolling up your sleeves, getting hold of the [Camel Book](http://shop.oreilly.com/product/9780596000271.do) and learning some command-line basics.
Be careful, you might break the internet!
To me it is harder to read the masked version... It's an interesting feature and I'm sure there are people out there that will find a great way to use it.
I don't use them, but ActiveState's commercial tools might be worth looking at if you're on Windows. However, if you're going to be doing a lot of Perl in the future, learning some Unix and a decent text editor is the way to go.
Are you asking for a graphical editor? If so, I'd recommend that you honestly try to branch out and use a standard unix editor like vim. It's a pretty steep learning curve at first, but then when you're good at it you're much faster than using something graphical. But if you can't seem to find the courage to get over that learning curve, you could look at something like Padre or Eclipse with a Perl plugin. But believe me, you'll look back at this decision years down the line and will be thankful you learned a real editor :)
Some benchmarks wold make it easier to think about if/when I want to use the module.
Long-term, that is probably pretty good advice. But short term, for a person who also doesn't know any Unix or Perl at all, telling him to go learn Vim is *phenomenally poor advice*. There are plenty of new things to get stuck on without having to *also* learn another, quite different, editor. For familiarity and support, I'd try either **Komodo** (from ActiveState, I think there's a free download), or **Padre**. 
Replacing `"\n"` with ␤ would make more sense.
&gt; You're probably years away from that being a practical problem. What's the cause of this sudden outbreak of optimism?
 use strict; use warnings; Just do it. ;)
1. Use the built-in documentation. 2. Focus on solving your particular problem. 3. Ignore online style wars.
Took a perl class, special topic at my CC. The teacher was terrible and monotone, his only answers to questions were quotes from the book. Only 3 of the ~20 people passed the class (I was one of them). At that point I was largely teaching myself from the book with a goal to write a program to sort and tag my music collection. From then on whenever I had a programming itch I would scratch it with perl. Eventually I got a job working on a perl application, my first month on the job taught me more than 4 years of programming classes combined. Been about 6-7 years since that first job, now I make a good living off my perl skills. https://github.com/exodist https://metacpan.org/author/EXODIST
Come lurk on irc.perl.org - it's amazing how much you can pick up just from other people talking about the problems they're facing and how to solve them.
If you're asking the question, then I'd say no.
Even I have to admit that the possibility exists that someone with the desire to produce a working product will eventually start a new P6 implementation or take over an existing P6 implementation.
Why are we still recommending the use of modules that use Devel::Declare, which was only a hack to bridge the gap until perl 5.14 added interfaces to extend the language syntax properly? This warning applies to all downstream users of Devel::Declare, including Method::Signatures: https://metacpan.org/module/MooseX::Declare#WARNING The best signatures module out there is signatures.pm, and its syntax is due to be cored in the next year, thanks to the hard work of Peter Martini. 
I am a biologist. I learned Perl from an optional course at my University, called "Advanced Topics of Bioinformatics". In fact, it was a course about Perl, although a rather outdated version of Perl with optional use of strict/warnings, global filehandles etc. It still did the job and now my language of choice is Perl, even though I occasionally use R or Common Lisp.
If you're talking about the architect tools included staring with VS 2010 (IIRC), the answer is not. There's nothing quite like that out there.
[Do you understand what that does?](http://perl.plover.com/yak/12views/samples/notes.html#sl-31)
At the risk of appearing stupid, what the hell is that all about? Without any context, I haven't a clue what it all means or indeed whether or not I ought to be interested.
I think I was really lucky to get into Perl. We were implementing a massive (also very expensive and ultimately crap) system which required a lot of Perl to glue it together. As none of the team knew Perl and I was the team's software utility writing bloke, I took a couple of weeks out of the office with a copy of *Learning Perl* and winged it from then on. I'm sure I'd've done better with some proper training (after all, the business was spending £18M[1] on the new system, so that shouldn't have been too much to ask). What I learned of Perl then helped me move my career on quite nicely. [1] Fortunately we didn't spend all that money. After £9M had been spent I managed to get senior management to realise that the system was never going to work on the scale we needed and that we could actually write an in-house web application (we're talking mid-1990s here, so rather advanced) to do the job... In Perl...
You may want to check [this]( https://www.youtube.com/watch?v=YvnIcLc2Nrs) out :)
Reini's working on an alternate VM and implementation for Perl 5 and P6, based on something called Potion.
make stuff.
I hope it goes well and more "ground shaking" additions get in too.
Read a lot, code stuff, and talk to people (related to this). Do everything at the same time. Knowing how the perl docs are laid out helps too. The first thing i'd do if i were completely new would be practicing regular expressions and using them in scripts. It's a skill that will help you forever inside and outside of perl. For example count the ammount of swear words in a chat log or a website, expand abreviations in a text, etc. And since you want to see what's up, check out this nice site : [map of cpan](http://www.mapofcpan.org)
I learned via brute forced and the need for something a little more stronk than bash. (do most everything said in these comments... all solid)
Have a goal, a specific task you're trying to accomplish. The hardest part of any development is laying out your process. After that, it's just processing data. Use strict, use warnings, as mentioned elsewhere, they'll both save you a lot of hassle. Learn to love Data::Dumper, as well. 
I can try to address that in a future post, but I've been thinking about writing an "XS cookbook" for a while. It might make an appearance in there. =)
Local community college had a beginning and advanced perl class. The beginning class was by an older teacher who wasn't all that great, but the advanced class was taught by a sysadmin for the school, and was excellent. The best way to learn perl is from a linux/unix/mac OS X command line. Or cygwin, if you are on windows. learn how to print to the screen. Then how to read a line of input. Learn how to make a decision with if and else. learn how to loop with while. There are other ways to do decisions and looping and conditionals, but those are fairly basic. learn how to read from a file, and print to a file. learn about @ARGV. for subroutines, learn about @_ Learn about scalar variables which start with $ (numbers, strings, references to objects, subroutines, datatypes) arrays which start with @ and hashes which start with %. learn how to make a subroutine, to call one. you can google for all of these, or check out perldoc
That would be badass. I use Inline::C most of the time when I'm in the guts. I'm lazy like that. 
http://learn.perl.org/faq/beginners.html http://perldoc.perl.org/ http://www.perlmonks.org/
&gt; how do I pass the csh parameter $1 into the perl cmd line? Just close the single quotes for the perl command, use $1, then re-open the single quotes to continue the perl command, thus: perl -ne '$i++;if ( (/'$1'/) and (/^[a-zA-Z0-9]/)) {$_=~s/^\s+|\s+$//g; print "=$i:$_\n";}' $infile &gt; $outfile (untested). Alternatively, pass it as a parameter, which is probably better: perl -ne '$i++;if ( (/$ARGV[0]/) and (/^[a-zA-Z0-9]/)) {$_=~s/^\s+|\s+$//g; print "=$i:$_\n";}' $1 $infile &gt; $outfile (also untested). 
I guess you'll do a new post once the video is up on archive.org? Thanks!
Interesting - but I prefer to use https://metacpan.org/module/Parallel::ForkManager
This was one of my most favourite talks at YAPC this year.
Your first example with $1 works. Thanks! Why is $ARGV[0] better? 
Thank you very much for your work. But part of this was for me to learn more about the perl -e option. Because I might use it more if I understand it better. And 95% of the time I'm passing data into a csh script, so I needed to know how to do that. 
Using $ARGV[0] is better because it can be directly translated into a file or any other 'regular' perl without requiring a preprocessing step in bash to substitute the variable.
I also prefer using ForkManager, too. But I think it's important to know the fundamentals. 
See also: https://metacpan.org/module/Child - OO interface to fork (for tasks where a fork management module is too heavy) developed for the perl5i and Fennec projects https://metacpan.org/module/Parallel::Runner - similar to the already mentioned Parallel::ForkManager, uses Child under the hood. 
SublimeText.
The first example works... mostly. You'll get into trouble if you use anything that your shell treats specially, eg space or backslashes or quotes: gr "something with spaces" ! syntax error from shell ...or if you try to search for something including a slash: gr hi/there ! syntax error from perl $ARGV[0] (along with a slight modification, [1], to the second option) eliminates one step of variable expansion, hence one level of potential confusion. And yes, I know that this will 99% not matter for your current case -- but it will one day, and if you develop good habits early you will not suffer needlessly in the future. [1] change $1 to "$1" (double-quote, dollar, numeral one, double-quote) 
Looks cool with syntax highlighting: https://gist.github.com/ediblenergy/52fda80954d9a1d1aa9a
from the title, I thought this was a new competitor to Vanilla Perl / Strawberry Perl 8-)
Have a concrete project of some kind, no matter how simple. It makes things somewhat simpler to try and solve a particular problem, instead of just learning abstract stuff. Is there something that you regularly do that could be automated? That's how I started, with a task that took many people many days, and collapsed it into a Perl program that took a few minutes to run. We all went down the pub.
Is this what you mean? perl -ne '$i++;if ( (/'"$ARGV[0]"'/) and (/^[a-zA-Z0-9]/)) {$_=~s/^\s+|\s+$//g; print "Line $i:$_\n";}' $infile &gt; $outfile My search strings will actually often contain period or question mark or parens which I don't want expanded into a regex. Actually '$1' was working fine even when I used periods and question marks. Example: grp1 ABC123.?.L This found the correct records. Notice I didn't surround the string in any quotes. However, this doesn't seem to work: grp1 ABC123.(M5) I get an error: "badly place ()s". This also doesn't seem to work: grp1 ABC123.?.5 I'm literally looking for a question mark, not a regex. 
YAPC::US (http://www.yapcna.org/yn2013/talk/4841) YAPC::EU (http://act.yapc.eu/ye2013/talk/4636) YAPC::Asia (http://yapcasia.org/2013/talk/show/12df3f18-c8a5-11e2-a1f8-59856aeab6a4) 
Oh, I think I get it now. From davedontmind second example, the $1 near the end before $infile in `perl -ne 'blah $ARGV[0] blah' $1 $infile &gt; $outfile` gets passed to $ARGV[0]. Right? 
Minor mistake in your first code segment: sub extract_domain { my $url = @_; ... You meant: sub extract_domain { my ($url) = @_; ... Without the parentheses around `$url`, the variable would not be assigned the intended value.
I really like the idea of p2, specially if it makes it easier to experiment with new features and/or smoke the other perl competitors out there in terms of performance ( everything else is already better ). I wonder if you are going to add the new explicit sub parameters that have been talked about? edit: oh yeah and macros + threads, really want that.
The author says “I do **not** intend on submitting this to CPAN”, but look, [someone already did](http://search.cpan.org/~mjd/FakeHash-0.80/FakeHash.pm), ten years ago. 
The `use English` should always include the `-no_match_vars` option to avoid a regex performance penalty, as mentioned in the docs. Otherwise it also imports names `$PREMATCH, $MATCH, $POSTMATCH` for ``$`, $&amp;, $'``. But once you *mention* them, all matches in the script need to populate these, which results in unneccessary allocations and `local`s.
Seeing the 3 downvotes, I am not sure the readers of reddit are interested in this, but I created a Stencil: http://questhub.io/realm/perl/stencil/5234b0b2a7bb210a76000009
Could you elaborate, please, what do you mean by "simpler, more consistent and easier to find stuff"?
&gt; perl -ne '$i++;if ( (/ABC123/) and (/^[a-zA-Z0-9]/)) {$_=~s/^\s+|\s+$//g; print "Line $i: $_\n";}' $infile &gt; $outfile Perl even has some helpful variables for this kind of thing. Here's a version that gives more grep-like output, and handles multiple inputs: perl -ne 'if ( (/ABC123/) and (/^[a-zA-Z0-9]/)) { s/^\s+|\s+$//g; print "$ARGV:$.: $_\n";}'
Note that Wikipedia adds "nofollow" to external links so it won't help search engine rankings.
[Here's a perl script](http://vim.wikia.com/wiki/Vim_vlc_controller_and_lyric_synchronizer#.7E.2Fvim.2Fvlc.pl) which uses VLC's "remote control" mode to interact with it. [Here's some documentation](https://www.videolan.org/doc/play-howto/en/ch04.html#id590986) about ways to interact with VLC &amp; tweak settings of the "vlc" command-line and enable various controllers (RC, HTTP, etc.). If the RC / Remote Control script doesn't work for your purposes, you may want to investigate [VLC's built-in web server controller](https://www.videolan.org/doc/play-howto/en/ch04.html#id590873) and perhaps use [LWP](http://search.cpan.org/~gaas/libwww-perl-6.05/lib/LWP.pm) to connect to the web server interface and mimic the commands a web browser would send it. There's also [VideoLan::Client module on CPAN](http://search.cpan.org/~elliryc/VideoLan-Client-0.13/lib/VideoLan/Client.pm)
I can't imagine that Google would make an exception as it would undermine their credibility. Google created the "nofollow" standard. Wikipedia is using it, presumably, to discourage link spammers from putting a lot of external links into article pages to increase their page rankings. If Google were to ignore that, then what's next? Ignoring robots.txt? I can't see that happening.
The extent to which you can control an arbitrary external software from Perl varies. Some software (e.g. [MPD](https://en.wikipedia.org/wiki/Music_Player_Daemon)) allows you to control it while it's running; other software will only allow you to pass certain options upon startup. For the specific case you mention, searching the [CPAN](http://metacpan.org/) is your friend: https://metacpan.org/module/VideoLan::Client
I am not sure what happened, the number of links to search.cpan.org went down from 780 to 586 http://en.wikipedia.org/wiki/Special:LinkSearch/search.cpan.org?limit=1000 while the number of links to metacpan went up from 13 to 56 http://en.wikipedia.org/wiki/Special:LinkSearch/metacpan.org?limit=1000 and I know I updated most of those manually. The total link count went down from 793 to 642. That does not look good. Could you check some of those pages you updated, if the links really go to metacpan.org ?
He's aware of it. But with Peter's changes, these features (or near equivalents) will *be in core*, not simply available via a CPAN module.
I changed a small number of the links to point to perldoc.perl.org instead, but most of them go to metacpan.org. It also appears that the Special:LinkSearch report isn't accurate. http://en.wikipedia.org/wiki/Special:LinkSearch/metacpan.org?limit=1000 shows 56 results, but it doesn't include some of the pages that I have changed. For example, [Plack (software)](https://en.wikipedia.org/wiki/Plack_%28software%29) isn't listed in the report, but you can see in the edit history that [I changed 10 links](https://en.wikipedia.org/w/index.php?title=Plack_%28software%29&amp;diff=573129701&amp;oldid=569645099) within that article page.
Apparently that search does not include https links, only http links. I changed all the links on the Plack page from https to http and now they appear in the search. A separate [search](http://en.wikipedia.org/w/index.php?title=Special%3ALinkSearch&amp;target=https%3A%2F%2Fmetacpan.org&amp;limit=1000) will show all the https links. I'll update my original article with this information. The 3 numbers are now: SCO: 566, metacpan http: 66 https: 182 TOTAL = 814.
How did you come up with that solution to the music collection problem? In my head it seems like an overly complex solution unless you have a massive music collection.
Can you elaborate on the problem that you solved? That seems like quite a nice bit of work!
At the time my music collection was about 80gb, mp3 format. It was also horribly unorganized. To be honest the solution I wrote was over-complicated and not code I would touch now having the experience I do. My music collection was not much better off after I ran the code. This was roughly 8 years ago, and I was new as a programmer.
I maintain a list in [How to Identify a Good Perl Programmer](http://www.modernperlbooks.com/mt/2011/01/how-to-identify-a-good-perl-programmer.html).
Well, when you are looking for a job with any technology, you should be able to look at older versions of things and at least somewhat understand them, finding the cutting edge in already implemented software is impossible. Project Managers rarely hire new people for a new project because that adds random factors that can lead to disasters, so you'll usually be hired to maintain something to get more resources for a new project or something like that. So i'll tell you to familiarize yourself with some CGI that plages this universe, and the contents of the classic perl books to see how things were made back then.
LOL. 20-year Perl programmer here and I was thoroughly confused. But I'm self-taught, so I have no idea what things like 'variable sigils' are. 
It's easy to acquire enough Perl for a job. Write code on hobby projects, and learn whatever you need to know to do what you want to do. The question is wrong however. You have to ask yourself if you really want to do Perl all day. I would not recommend that you do that. I would recommend that time is better invested in learning general computer science concepts, data structures, algorithms. I do not think Perl is a good example of programming language. As for myself, I know way more Perl than I should, and I wish I had better invested my time in other more important things.
I'm going to recommend chromatic's [*Modern Perl*](http://onyxneon.com/books/modern_perl/). Taught myself Perl in the 1990s, spent a career coding in it, and decided recently that I should refresh my skills. (I learned Perl 4. You kids get off my lawn.) While not for the beginner, this book steps you through everything you need to know in order to write proper Perl.
&gt;20-year Perl programmer here &gt;I have no idea what things like 'variable sigils' are That's...impressive?
`$`var `@`var etc are variable sigils.
I obviously use them daily. But I didn't know what they were called until I used Google on the phrase. I'm sure you use appositives in speech daily without knowing what they're called too. :D
I completely and honestly agree that Perl is plagued with really bad codebases which results in a very bad all-around feeling. I have experienced and it's real bad. I almost got laid off because I only knew Perl. You will meet angry old men who wrote shitty Perl code. You do not, I repeat, you do not want to do that. 
You got me there.
What's your hobby? If it's something people care about, "not very much." If it's solving FizzBuzz problems, "an endless treadmill of fads." If you are someone who can program in any language, or someone who knows about some real thing and can do that thing better using programming, you should do well. If you are someone who programs in language x and nothing else, your life will be hard.
* Write modular, testable code * Don't micro-optimize * No golfing in production * Write literate code that readers will love * See the virtues of all languages * Go to some conferences * Contribute to CPAN (and have a github or equivalent) * You can never be too humble, nor too helpful
A common complaint when hiring for Perl is that everyone is senior/expert and nobody wants to do junior/entry-level jobs. If you have an interest in Perl, and good general programming and problem-solving skills, you'll probably do well.
I, too, use the at- and dollar-sign symbol thingies when making values in the one doo-dad on the right side of the equals thingy go into the other thingamabob on the left, so that the doo-dads and the thingamabobs have the same kind of stuff in them when the junk gets sucked through the equals thingy.
Not nearly enough.
It suggests using the YAML module which is horribly buggy and unmaintained. The YAML module docs even say to use YAML::XS. This tutorial only suggests using YAML::XS for speed.
Took Perl programming in college, got a C. A year later, decided to write some scripts. Between all languages familiar to me at the time (C, C++, Perl), Perl was the obvious winner for ease and speed of writing the scripts. Kept going at it. Got a sysadmin job where lots of stuff is written in Perl. Eventually became a Perl dev.
&gt; How much Perl is enough to land a job? That all depends what you are doing with it. I taught myself Perl, and I use only vanilla Perl, no third-party modules, and I save the company a ton of money and many customers stay with us because of that. If you don't have a computer science degree, and I'm the hiring manager, I would assume you don't understand system engineering or the Rules of Programming. The people at my college who were getting MIS minors (which is all they offered at the time) were horrible programmers, and as I worked in a computer lab, I was the one they asked for help. I was lucky enough to learn system engineering after college in one of my jobs. It certainly wasn't taught at my college in 1987. Also, if you are using confusing Perlish syntax, and not standard syntax which is close to other 4GL languages, you are already violating one or two of the Rules of Programming. 
Mu
&gt; Do you view yourself as bitshifters ? scripters ? I call myself "Perl programmer". Just that. &gt; What is your mentality ? I wanted to be a Mentat, but the green/black tea combo is not enough. &gt; Also, why are there loads of legacy Perl code out there that suck like a skunk ? It was useful back then and nobody tried to remove it afterwards. Also, backward compatibility. 
I don't buy twigils. Why do we need them in P5 exactly?
I think it depends on the job. I'm a senior architect on a fairly large Perl Catalyst app that vends to 15 high paying clients. Considering there are over 15 developers on this one app, I can't imagine calling us "bitshifters" or "scripters". &gt; Also, why are there loads of legacy Perl code out there that suck like a skunk ? Because perl is an old language that has changed vastly, and only relatively recently got a set of best practices? Because there was a time where you'd choose between C++ and Perl, and perl was a popular, powerful, dynamic language before we knew what to do with them. &gt; Who wrote that code and why is it so horribly bad and what can be done about it A lot of people. Best practices didn't come down from heaven. We discovered them the hard way. I've written my share of horrible code. What can be done? In many cases, refactor. Bad interfaces may suck, but the real "horrible" is bad underlying code. You build some unit tests with Test::More, then refactor the bad code till it passes again. &gt; Last but not least, why am I being asked in interview golfing questions to make things more "Perlish" ? Don't know. I don't give golf questions when I interview for developers, but one developer I interviewed that got hired suggested we should add them "to prove you know perl". I don't get it either. If I were asked that, I would ask what kind of embedded systems the job was for, to need to worry about character count of the source.
&gt; Also, why are there loads of legacy Perl code out there that suck like a skunk ? Legacy code is terrible in any language. I've worked on legacy C++, C#, and Java applications. It's as if software engineering didn't exist 10 years ago.
I think that you'll find, pretty much anywhere you go in this industry, that people are batshit insane. Am I surprised that people are testing your Perl golfing abilities? No. I've worked at places that will pay you a 6 figure salary, but not allow a second monitor (even if you offer to buy it and bring it in), or even anything newer than a 10 year old version of your favorite text editor, even if its locally installed in your home directory. Some level of obscene stupidity exists every where you go. As for whether Perl programmers are real engineers. Seriously dude? The Java guy sitting beside me is supposed to be a "real software engineer" but because I work in a language that doesn't suck as much as Java I'm a script kiddie? That prejudice really does exist out there. And the funniest thing about it is that when given a project, big or small, the competent Perl guys will finish it faster than the competent Java guys, but the Perl guys are somehow not serious programmers. I think people believe that if you're not willing to be a masochist and deal with the horrors of lesser languages, then there has to be some trade off. They believe that there is no free lunch. They're aware that Perl gets stuff done, but know that not everyone uses it, and assume that there is some undefined badness with regard to using it. So web teams using struts are praised and taken more seriously than teams using Mojolicious and DBIx::Class... Its a crazy world. 
Thanks for the note - I'll update the article.
This isn't entirely true anymore. Don't get me wrong, there's political bullshit everywhere... But Unit Testing is an easy sell in a company where code reliability is low. If the CEO is smart enough to not just keep demanding heads to roll, the Executive/Management side will see the problem, and allow solutions to be proposed by the head of IT. Any good company will have a head of IT that is aware of what Unit Testing is. Heck, this is even more true when you use outsourcing to companies that save money by stacking your team with inexperienced and untested developers. We have a lot of very weak team members.. but that's ok because they're code reviewed and must show automated test passes. Till deadlines get missed, and we go into death-march mode again.
I believe there total dev staff is pretty large. For every person that dislikes/liked working there I'm sure there are those that like it equally much. I'm married with kids and the wife says no, else I'd give them a closer look myself.
My one big thing for any perl person is finding out how well they know the perl data structures document. Knowing that bit of perl top to bottom is almost always enough for me, because it's ties into most of the other important parts of perl, and the whole point of using perl in the first place (in my mind). This is all about the array of array, hash of array, etc...
&gt; I don't agree. I'm sorry. Are you disagreeing with my *experience*? &gt; In outsourcing ? Are you kidding me ? In outsourcing nobody gives a sh*t. In outsourcing it's all about hours, it's about time. Which is why we mandate they provide estimates (which are currently matching or exceeding our internal estimates), code review and unit tests. I don't care if they give a sh*t or not (some give enough of one that we are paying for visas and hiring), this is a process, and it works. &gt; Outsourcing companies are like the McDonalds of Software. I don't really get what you're arguing. That's kinda what I just said. That's why we're mandating unit testing. They stacked our team with mostly (but not entirely) weak resources. &gt; I mean, if you don't know what you need to know to do software, how are you supposed to run a company on that. Same reason the CEO of McDonalds doesn't know how to flip a burger, and the CEO of Toyota probably cannot build a car? I think they're vastly overpaid, but you can run a company by having a good grasp of who to hire and how to keep the company running, not how to do any one specific job at the company.
Paste in some of that legendary bad code. I want to see what you're talking about.
Look, I'm not trying to disparage Java Programmers. Java Programmers can be awesome, but the Java language simply lacks a lot of features. Its constraining, and if you understand and have used tools like map, reduce, partition, compose or partial, you find it painful to use Java. I wonder what software engineering techniques you're referring to. Is it Design Patterns, which are overused to the point of absurdity in Java circles, but largely ignored by languages with better tools for creating abstractions? Is it the fact that in Perl not everything is designed to be object oriented? There's a lot of crap you have to do in Java that is not so much better programming as much as it is complex shit you have to do because you lack language features that make it easy. &gt;This would never have happened in Java or C++, because you have to read some books about those to understand what you're doing. What books? Seriously, are you talking about the GoF book? Object Oriented design and analysis books? Do you seriously believe that bad Java programmers can not exist because in order to accomplish something in Java they have to read a book to understand all the ceremony required to do it? Lastly, you shouldn't think of Perl programming as "easy" unless you also think programming with higher order functions and closures is easy. Sure, you can program without that, but Java developers can write their code without using polymorphism too. Its possible, but its not idiomatic to the language. 
No. But check your pm, I sent you a sample.
So basically, you don't know what he's talking about ?
I see myself as an engineer, and Perl is one of the tools in my toolbox... you are most likely being asked perl golf questions because people don't really know how to conduct useful interviews that ask the right questions, and a pop quiz is easy and reassuring. It could also be that it is important to be idiomatic in any language you use, or, in this case, perlish.
I know that some of it comes from hiring developers overseas on a temporary visa. They go to Amsterdam, work for a year or so, and then go back.
lol
Do you have previous experience as a developer is any language? Because there are very, very few entry level jobs in development in *any* language. Everyone with computer skills wants to be a developer, and you typically have to pay some dues doing something else first.
I'm a Perl programmer. I certainly view myself as an engineer. Perl can be used to write quick throwaway scripts. It can also be used to write complex applications with many thousands of lines of code. There's a lot of bad code out there for many reasons. * Perl became very popular in the mid-90s for CGI programming. Many of the people who were writing CGI programs had no experience of programming and didn't see the need to learn as the quick hacks they threw together seemed to do the job. * Many people got their first experience of Perl from looking at Matt Wright's scripts. These scripts are examples of terrible Perl code. Matt admits that he was just learning to program when he wrote them. Unfortunately, his code was the first Perl code to get really popular and the Perl community is still dealing with the fall-out from that today. * At about the time that Perl got popular for CGI programming, Perl 5 was being released. This means that a lot of early Perl CGI programs are written to work in Perl 4. Perl 4 really was a horrible hacky scripting language. * Much of the power of Perl is in CPAN modules. If you're running Perl CGI code on a low-end hosting solution, your chances of getting CPAN modules installed is close to zero. This encourages wheel-reinvention by people who are often frankly not up to the job. * Perl 5 has changed and grown since it was released in 1994. For some reason many people seem to be completely blind to this fact and believe that Perl is still the same language that it was almost twenty years ago. They therefore still write code like it's 1994. * Because people often see Perl as "just scripting language" they don't see the need to study it. They therefore learn by copying and hacking on old programs. And old, bad, habits get propagated. * Because Perl's peak of popularity was in t he second half of the 90s, a lot of the tutorials out there on the web date from back then. And Google is happy to find horrible and out-of-date tutorials for people to learn from. Perl is a great language. But many people's perceptions of it are stuck fifteen or more years in the past.
When I'm saying "easy", I mean it's extremely easy to write something that gets the job done and stinks from a mile away. The entry bar is really low for Perl, that's what I mean. You don't see too many bad LISP programmers or Haskell programmers. Just like you don't see wounded animals in a forest. Either they're good at what they do, or they don't exist. And higher-order functions ? That's a fancy name for map/grep/etc don't you think ? Let's not glorify easy simple concepts. Yes, Java doesn't have them. But they aren't something vital either. And closures ? Yes.. they are there, but how often do you use them ? You get to use closures more in Javascript than in Perl. Unless you're doing stuff with AnyEvent or POE I really don't think you'll be using too much closures. And if you're using them excessively your code will be very prone to a wide range of problems. If you want to talk about higher-order functions I think one should look at [Y-combinator](http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator) or concepts from lambda calculus. Mere map and grep are just some for loops. Let's not make more of it than what it actually is. And about books, yes, reading books is important. Or at least being in situations where you realize "Hm, maybe my half-assed programming skills acquired by learning Perl over the weekend will not get me through this one". And these kinds of situations provide some incentive for reading stuff and learning.
Y-combinator in production code ? That's funny :) You made my day with that one. Yes I have used partial and compose, but they don't really belong to Perl. Why did you feel the need to use Y-combinator in production code ? To brag right ? Or ... ? &gt; Are you so sure that higher order functions and closures only enable you to do looping? Don't put words in my mouth. I said map and grep are just loops. Yes, they do enable a wide variety of things. But Perl is not home to higher-order functions. If you really want to do that kind of stuff you choose a language which is designed for that, and Perl is not designed for that. Newsflash ! Perl is not designed for that. Haskell , LISP, Clean. Those are good exponents of languages where you can properly use higher-order functions. And No, Higher Order Perl does not impress me. But we're diverging completely from the topic which is: &gt; Are Perl Programmers also Software engineers or just Mere Scripters ? 
&gt; For some reason many people seem to be completely blind to this fact and believe that Perl What can be done about this ? How can we identify and fix this problem. It gives Perl an extremely bad reputation.
Per my recent post in this subreddit, I'm done with sweatshop style programming employment, and Booking sets off all of the alarm bells for me -- managers using productivity metrics and culling based on them, stress, competitiveness rather than collaboration, a culture of cutting corners, etc. A couple of very bright, very talented people I know didn't "make the cut" there. I don't want that kind of stress. I don't want to write Perl for money so badly that I feel I need to do that. C++, C#, Java, and the old guard have more reasonable deadlines, strong professional ethnics (tests, documentation, code quality), larger teams assigned to each sub-project, better retention and training, etc. If the only thing marketable about Perl (to corporations) is that programmers are cheap and disposable, then I personally do not want to be in that business.
"Dutch IT workers must be awful No. The Netherlands has a fantastic hacking culture. The problem is simply that most of Europe has a severe shortage of skilled workers." I've worked extensively with a team of Dutch programmers. They *are* good. They also demand good treatment, which one of our clients did not offer them, and a reasonable work/life balance.
People have been talking about marketing Perl (because, let's be honest, that's what we're talking about here) for years. * Things like the Perl Ironman (http://ironman.enlightenedperl.org/) and http://blogs.perl.org/ are helping to get better Perl information into Google. * The Perl tutorial hub (http://perl-tutorial.org/) is now the first result in a Google search for "perl tutorial". I think it's largely an SEO problem. And one that we're (slowly) solving. Any other suggestions would be welcome.
They are like sigils but twice as good! More seriously they solved some namespacing issues that actually were coming up for people as they wrote actuall code. Think of $! as the Perl way of spelling 'this', but shorter and it interpolates.
env.js or WWW::HtmlUnit, http://search.cpan.org/dist/WWW-HtmlUnit/. The former is an implementation of the browser DOM in pure JavaScript that you can run under various command line JSes (but you have to get one built your for JS or build it yourself, which requires Java). I run it under spidermonkey for unit testing JS UIs. A good friend wrote WWW::HtmlUnit. It's a Perl wrapper around a Java library that includes a Java based implementation of JavaScript that also emulated a browser. Good luck, and have fun!
Um, yours is a very _specialized_ account, I guess.
Ah, gotcha. I was wondering if it was something like Lynx, or whatnot.
&gt; And higher-order functions ? That's a fancy name for map/grep/etc don't you think ? &gt; [...] &gt; And closures ? Yes.. they are there, but how often do you use them ? You get to use closures more in Javascript than in Perl. It may surprise you, but one of the more appreciated Perl books is this one: [Higher-Order Perl](http://hop.perl.plover.com/). A bit from the preface: "For example, the book Paradigms of Artificial Intelligence Programming, by Peter Norvig, includes a section titled What Makes Lisp Different? that describes seven features of Lisp. Perl shares six of these features; C shares none of them." I am certainly not saying that every Perl programmer write in an high order style, and not even every good Perl programmer. But some of them do, at least some of the time. And you are short selling Perl if you think it is impossible. If I may add an observation, and I hope you'll forgive my impertinence, but it really seems like you are extrapolating a bit too much from your personal experience. Nothing wrong with that, but your comments have a bunch of sweeping generalizations that do not makes them seems well informed.
A try perl website like many other languages have, an official try perl website that is, would be great. Usually it's hard to suggest where to start, so people end up googling "perl tutorial". A good interactive official tutorial would be great to solve this.
This is pretty much what I expected and I very much appreciate that you're realistic. I'll read your post also to find out more.
Gtk3::WebKit some slides: http://potyl.github.io/Talk-WebKit-Perl/ http://bratislava.pm.org/presentation/WebKit-en.pdf
I am not sure I am able to follow you. I am also pretty sure you were responding to things I did never said. I was just responding to your statement that higher order functions is just a fancy name for the map and grep functions. This is needlessly pejorative. You can, if you are able and you wish, use the higher order style of programming in perl, to good results. Nothing more, nothing less. To say that HOP did originate elsewhere is correct, but irrelevant. To say that Perl is not know for its use in artificial intelligence applications is also correct, but even more irrelevant. To put words in my mouth about compensating for lack of OO, is downright bizarre. If you want an answer to your original questions, I consider myself a Perl programmer, among other things, without overthinking it. And I mainly agree with what davorg says in his post about why bad old code exist.
Although not strictly an answer to this question, but somehow related: For anyone in need of a headless WebKit with JS, have a look at [PhantomJS](http://phantomjs.org)!
I've dealt with legacy Perl as well (mostly just reading on PerlMonks, but that's enough for me). Legacy Perl is completely unlike legacy C++, much like Perl is completely unlike C++. But legacy code is bad, regardless of the language.
Use DBIx::Log4perl.
I'm a developer at Booking.com. Some numbers: We have about 7000 employees, ~400 of which are IT staff. That includes devs (~160 perl), sysadmins, DBAs, designers, usability researchers, product owners, mobile devs (android/ios) and departmental support staff.
Pretty much all Dutch employers offer 1 year contracts, and with the expectation they will renew, and after the third renewal the company has to either fire you or give you a permanent contract. This was how Booking operated for many years, being a Dutch company. However, asking people to move overseas to Amsterdam and only offering them a 1-year contract didn't seem fair and we were unable to relocate people because of that. We now offer devs we relocate permanent contracts up-front. Your work visa is tied to your contract, obviously, but as long as you have a permanent contract the visa situation shouldn't be a problem. We have HR staff that is dedicated to making sure everybody's paperwork is filed on time, and (as far as I can tell) a lawyer who does nothing but fill out paperwork for Booking.com expats.
Booking.com dev here. What in your mind qualifies a "mid-size or large-size tech giant"? Our IT department is a little over 400 people (not sure the exact number) of which 160 or so are Perl developers. We're maintaining and adding features to a 2-million line code base that supports the largest online accommodation reservation site in the world. We really are growing massively. When I started 3.5 years ago, the IT department was 65 people. We've been hiring 30+ devs a year every year I've been here. (Our target this year was 46.) Our codebase is not in maintenance mode: we're constantly improving the front-end website our visitors see, the backend sites for our hotel partners, our mobile apps, scaling our existing infrastructure (worked when n=1000 but now n=2000000), building new systems to support the needs of the business (see for example my talk at YAPC::EU Kiev: https://www.youtube.com/watch?v=dwbauqh0kK4 ), and all the internal reporting and monitoring that goes along with operating at our scale. If you have any more specific questions, I'll try to answer them.
I don't have the right sort of hubris, impatience or laziness to make the following happen. But I'd help others that did. I recommend development of a perlsearch.com that is a community owned and developed metasearch engine with the charter of being, in effect, a google for Perl aimed at delivering fresh, high quality results in response to arbitrary searches. Keep it very simple looking. Cleaner than google.com. Make it work nicely for iOS, android, and html5 from the get go. Do state of the art load balancing of requests from the get go so it never encounters a bad reputation for responsiveness. Maybe start with it being a [custom google search](https://www.google.com/cse/all). Or a duckduckgo thing. Then incrementally improve it. Maybe have custom regexes that are matched against searches. If the word "perl6" appears in the search string, then make darn sure some doc appears, perhaps in a sidebar, titled "Perl 5 vs Perl6" or some such and make sure that that doc is kept up to date and contains something with very wide community consensus about what that page says. Add feedback sensitivity. Maybe leverage google's +1s or whatever. Make sure it gets steadily better at coordinating with SEO efforts so those efforts pay off doubly (altering both google results and perlsearch results). Make sure it gets progressively better at weeding out old crap. Incorporate CPAN. Ironman. Job searching. SO Qs with perl tag. Questhub's Perl realm. Etc. The business model should include non-intrusive advertising. If you provide a Perl contribution, advertising goes away ($10 per year for individuals, $1k per year for group accounts). Proceeds go to fund perlsearch.com's infrastructure costs; excess goes to one or more funds selected by the community (presumably the lion's share goes to TPF's Perl 5 maintenance fund). After a year or so, once it gets good enough to reliably give significantly better results than a plain google, start heavily promoting its use, both for Perlers to find stuff, and for non-Perlers wanting to see what Perl is really about according to Perlers. I've been pondering Perl's marketing challenges for about a decade, ever since it became clear to me that Perl 6 was going to be a thorny problem. I've been a marketer on and off for two decades. The above is pretty much the only thing I think realistically could, and it seems to me, if done well, likely would, properly address many of Perl's problems and opportunities in both the marketing and ecosystem quality arenas.
Oh scrottie. &gt; Managers using productivity metrics [citation needed] &gt; and culling based on them [citation needed], &gt; stress [citation needed], &gt; competitiveness rather than collaboration [citation needed], &gt; a culture of cutting corners [citation needed] Dude. Come on. That line is so completely full of bullshit and you know it. If it were truly that way, do you honestly think some of our strongest community members (in terms of contributions) would have stuck around? 
And now with a little less of a recruitment pitch from [dgryski](http://www.reddit.com/user/dgryski). I work there. I enjoy it a lot. I've had my ups and downs. And at the end of the day, it is still a job. If it were fun all of the time, you'd pay to be there, right? Anyway, your first link will continue to be a thorn in our side for a very long time unfortunately. You can see I left a comment then and my advice to the author would still be the same today. Sometimes people just don't get along or want different things. Nothing inherently bad or wrong with either party, it just didn't work out. As for your second link, Ovid is pretty spot on regarding the reasons for hiring. And it is still true today. Just this afternoon I was lamenting the fact that when we want to shift people around for new projects we always have to consider the large impact of moving away people to something else. We just don't have enough people to do all of the things we want to do. It forces us to really think about business priorities because of the resource constraint (ie. people). As for the attrition rate, I can count on two hands (maybe some toes if I forgot a couple) the number of people (not all devs) that ditched in my couple of years there. Out of the ridiculous number of us. We are constantly doing new, different, challenging stuff. It is addicting to work on projects and actually see a positive gross revenue difference because of *you*. And we're always thinking ahead to next year (Can this system we built handle the load for next year? What about the hardware?). It is just completely different from any other place I've worked. I feel vested and empowered. Hell, even my mohawk doesn't bother anyone. So that's my perspective on things. Take it with a grain of salt. Ask some questions. I won't bullshit you. 
How much is enough depends entirely on who you're working for. There is no standard of Perl knowledge across every employer that uses Perl.
I hear you. I tried a New Zealand pitch to my wife...and no.
@nrperez &gt; Anyway, your first link will continue to be a thorn in our side for a very long time unfortunately This here is a new thorn, but this time in your other side. Now that you feel uncomfortable, you have to stand up. &gt; If it were fun all of the time, you'd pay to be there, right? I don't like your tone. At all. &gt; Nothing inherently bad or wrong with either party, it just didn't work out What exactly didn't work out ? It seems like you were personally involved in the situation. And from what I read in the blogs.perl.org you are quite aggressive about it too. I also don't like your comments on blogs.perl.org . At all. Now that you had a conflict online with a former employee of yours, let's hear all the story. Don't give observers like me this cliffhanger stuff. Go all the way if your balls are as big as you portray them to be. &gt; It is addicting to work on projects and actually see a positive gross revenue difference because of you So are you talking from a software engineer perspective ? Or a manager. You don't seem very technically inclined. Maybe you're one of those business people who wears a suit all day and talks gibberish ? It seems to me that you're treating talented engineers like sh*t but you do care a lot about positive gross revenue. What are the mechanics of that exactly ? "Fuck the devs, we hire 46 new people this year. They can burn out as long as we get our positive gross revenue." Is that what financial meeting at Booking sounds like ? Go ahead, let's hear some explanation for those big hiring numbers &gt; I feel vested and empowered You feel vested and empowered being challenged and having conflicts with other people who end up badmouthing your company on blogs.perl.org ? Really ? As an observer, my nose smells a lot of bullshit. Can you explain exactly why that guy was so angry that he wrote what he wrote about your company ? &gt; And we're always thinking ahead to next year The only thing I see each year is you're thinking how to hire the next 46 programmers. Where do you keep all these people ? I imagine if you hire so many, you have to change offices each year to accomodate the "next batch". Or maybe you don't, because you fire them, or they leave Booking and then express what they feel on blogs.perl.org &gt; Take it with a grain of salt Be patient, the story hasn't unfolded yet. Let's find out together where it leads us. If you have the balls to say your company is awesome, then walk the walk, and tell us what exactly happens there. How are programmers treated. Describe the day in the life of a programmer there. What kind of activities are there. If you really are an employee there(and apparently a defender of the company's image) come forth and tell us what exactly it is like to work at Booking. 
Solid advice for any language! I'm currently reading The Pragmatic Programmer which touches on similar points.
Well, I'm currently working on outdated Powerbuilder applications. How much worse could it be? (don't answer that!)
First ever documentation on implementing simple /special-purpose languages using the NQP toolchain. Examples start at http://edumentab.github.io/rakudo-and-nqp-internals-course/slides-day1.pdf around pp 118. See also https://github.com/edumentab/rakudo-and-nqp-internals-course which includes sample code etc.
Should $self be some variant on $! as well? I feel like $self should have to be explicitly declared somehow. But at least $!self would avoid name clashes.
I was flown over for an interview. I think it's a tough company to get hired at, to be honest, and probably pretty hard to stay at. I did pretty well with one interview, but another one I had personality clashes with a developer and really found that part of the process to be very unproductive. It was nice to get a free trip over for a few days though, and I doubt it's horrible to work there. The benefits they offered were great. In the end I think I'm glad I didn't get the job though. I think it would have been pretty stressful, in all honesty. I think it is worth looking into though. 
&gt; so it is gonna be factory style programming That's what I was expecting. Apparently @nrperez hasn't proved me wrong yet. I'm still waiting to see what he has to say about this. &gt; but there is chance to progress Did you ask them what that means ? Does it mean that all devs aspire to become managers there because they're treated with such disrespect that they feel awful ? &gt; source: i applied for a job Great. Good luck !
One of the posts specifically deals with the culture of "get it done and fast" and how they do not encourage refactoring or basic testing. I actually work in a Perl shop where management has the same kind of mentality, and it is slowly killing our efficiency. I was thinking about working for Booking.com but don't want to a shift into the same kind of culture. What is the code quality like at Booking? As you scale to hundreds of developers, is it because of the rapidly growing feature base, or is it you need that much manpower to maintain a fragile or spaghettified architecture? I am interested mostly because I have only worked for two Perl shops and both had little interest in testing, documentation, refactoring or maintenance of existing code, only tacking on features.
&gt; If you really are an employee there(and apparently a defender of the company's image) come forth and tell us what exactly it is like to work at Booking. So which Java-using company [are you astroturfing for](http://www.reddit.com/r/perl/comments/1mkd4s/are_perl_programmers_also_software_engineers_or/cca2862?context=3)? Let's see how much balls you have first, throwaway sockpuppet troll account.
If you don't have anything to add then sshhhh and observe.
I know two of their leads and both guys are top flight perl and java mavens
Man, talk about aggressive. I don't frankly feel uncomfortable at all. And tone is certainly difficult to read in a medium like this. And no, I was not personally involved in the whole ordeal. And if I were, it would be absolutely terrible to air this in the public (to the person involved, myself, and the company). That said, at the time that was written and I commented, I had my own issues of which I was resolving so I could empathize on some of the original authors points and I commented as such. And it seemed destructive, watching this guy basically burn bridges. So, there is no great conspiracy, or cliffhanger. And I am talking from a software developer perspective. Seriously. We measure all kinds of stuff. And yes, we can measure if code changes lead to a net positive. And if you had done the most basic of research of me before assuming the worst, you'd realize who I am and how I operate. This isn't some psuedonym. This is me. I am a real person. I have come forth. If we truly treated people like shit, who would stay? If we really burned out developers at the rate you propose, why aren't there more angry blog posts on the internets? Take two seconds to think through your accusations and see how obtuse they are. You have, exactly, a sample size of one on angry blog posts. How can that possibly be a representative sample? Can I explain why that guy was so angry? No. I really can't. And to be honest, I don't even know who that person really is. I have a good guess, but there is no certainty. Like I said, sometimes people want different things or have different expectations. It just didn't work out. Why does it need to be anything more than that? Where do we keep them all? We recently (within the last year) moved to probably the largest office building in the center of Amsterdam. IT took up the first floor. As we hire more people, we've expanded to now include the second floor. This is just IT too. Other departments take up the other floors (of a six floor building). We aren't throwing people away. In fact, space can be an issue because we have so many people we are really happy with. And I'll be happy to tell you everything you want to know if you treat me like a person, realize that there are multiple view points to any narrative, and drop the snark. As for how programmers are treated: We are an extremely international company. The IT department alone has something like 50 different nationalities represented. We move people (including families, belongings, etc) from all over the world to work here. That is no small expense. The amount of investment put into each and every developer is higher than you will probably see in most other companies (save for the handful of tech giants). Our teams are self-steering. You help decide on your team's priorities. Developers' partners are given job hunting assistance. There are free/low-cost Dutch classes offered after work. We have a conference allowance for every developer. Want a book to help with what you are doing? Just order it from Amazon and expense it. Something broken in production and you need to get into one of the boxes to debug? Just ssh in. Hate meetings? Because we certainly avoid them as much as possible. Hate getting up early? We're really flexible on hours. Need to work from home to sign for a package, contractors redoing your kitchen, etc? No problem; here is an RSA keyfob. Need hardware for your project? Put the request in and probably see it racked in the DC before the week is over. This simply isn't comparable to other large corps where I've worked previously. Anyways. I hope this gives you a little more insight. Any more questions? [edit]: Some grammar.
(B.com employee here) One perk of being such a quickly growing company is that there's generally opportunity abound and competitiveness with colleagues isn't something I've had to spend an iota of thought on. There also isn't a single butt I've had to kiss and none on the horizon. Another trait that you can view as good or bad is that we constantly have to reinvent ourselves. That's true in technology, as @dgryski already explained, but it's also true in terms of organization and process. We constantly have to put a lot of effort into improving our hiring process both in experience for the candidates and in terms of developer time spent on interviewing. We're picky in hiring and expect additional skills on top of being bright in tech. We also prefer to make false negative mistakes in hiring instead of false positives. If in doubt, it makes more sense to pass and attempt to learn from the process. My background is in natural science: It's to my great anguish that hiring isn't a science, but a lot more of an obscure art. If you've been paying attention you'll know it's no different for other big tech companies. I'm currently a manager for about fifty-ish people in infrastructure development &amp; devops, most of them are devs, all but one technical. In the past two years as a part- and full-time manager, I've had to let exactly *one* colleague go and I've lost *a lot* of sleep over it. By the way, that's not one out of fifty. It's one out of all the people I've managed in the past two years. That's not culling and it's no different for my peers. Also, a number of my CPAN modules are actually published code from work with little to no adjustments for CPAN (namespace change, duh), so go ahead and figure out if those are good enough for you? [SMUELLER on CPAN](http://metacpan.org/author/SMUELLER) [and github](https://github.com/tsee/)
Hi. I work at Booking.com as a senior dev in the Infrastructure team. I'll have been here for 3 years this October. I'm also a [CPAN](https://metacpan.org/author/AVAR) contributor and an occasional perl core contributor. I thought I'd chime in here because occasionally I'll get asked to comment via private E-Mail on the blogs.perl.org post mentioned at the start of this thread, and I'd like to be able to answer some of those questions by linking to this thread. &gt; basic testing Regarding testing, it's true that we're not very *unit* testing focused. This is mainly because we've decided to spend most of the time/money/infrastructure that you might usually spend on unit testing on monitoring instead. If you have unit tests you still need monitoring, but in practice if your monitoring is good enough and you have an infrastructure to quickly rollout &amp; rollback systems you can replace much of unit testing with monitoring. We've open sourced [part of the toolchain we use for rollouts](https://github.com/git-deploy/git-deploy), I think you might find it informative. So essentially instead of desperately trying to unit test our huge systems which rely on various databases and have issues that only manifest at scale we've essentially opted to mostly do live integration testing instead. We still do unit tests as well (for e.g. core templating/database/cookie code etc.), it's just not the first tool in our toolbox when it comes to seeing if something works as intended, for the reasons explained above. Quite a few developers we've hired, including myself, at first have a head-on cultural clash with this idea. Some of them never come around to doing things our way. I did, because for our setup it's a simply a better option in most cases. I'm testing some code I wrote right now. If you go to [booking.com](http://www.booking.com) you'll become part of that test. I can see how it's affecting our live page load times, CPU time, what impact it has on our databases, whether it's affecting your purchasing behavior etc.. Before I committed some fixes a couple of weeks ago I could see it spewing the occasional warning or error that I'd never have thought to unit test for. &gt; "get it done and fast" Due to deploying code like this we don't per-se have a "get it done and fast" culture, but rather a culture of trying to make small incremental changes that are *deployed on live systems*. I sometimes have this conversation with recently hired people, they're not sure if something works and are hesitant to deploy something, or have been working on some massive feature on a branch for a week. I tell them that I'm not sure my code works either, but I try to find out incrementally deploying code I'm writing piecemeal and see how it does at scale with live traffic. We'd rather have an incomplete first draft of something live than wait 1-2 weeks for the "full" version. Often you have no idea what the "full" version should even look like without the feedback loop you get from live testing. &gt; do not encourage refactoring Shortly after starting at Booking.com I and Ovid were on a project to improve our search engine. We eventually rewrote the entirety of the existing search system, threw the old system away. Around the time Ovid was leaving I was introducing ElasticSearch to the company which now powers all of our frontend searching. I've been involved in other similar core infrastructure rewrite projects. If that's not refactoring I don't know what is. We're not adverse to refactoring when appropriate. But if you're going to propose rewriting some code here you'll actually have to make a compelling case for it which isn't just "the old code is hairy". Do you actually understand what it does? Maybe it's hairy and complex because it's solving a hairy and complex problem. Are you not aware of where this system fits into the big picture? Maybe you're proposing to rewrite and improve something that's reached the end of its useful lifetime due to how we're scaling up, and we're planning to eventually replace it with something completely different that you haven't even thought of. &gt; What is the code quality like at Booking? It has its ups and downs. We have some shitty old code, some shitty new code, some fantastic old code and some fantastic new code. Anyone with a non-trivial codebase that solves real problems has the same. What I'm personally much more concerned with is *systems quality*. I.e. you may not like the coding style in some file we have, but what system is it part of? How does that system scale? Does it need to be replaced? Is the fact that it was written in some style you don't personally like an actual problem or do we have more important issues to deal with? We've also had code that's looks fantastic, had tests, used lots of best practices that we've had to throw away completely because it was implementing some idea that turned out to be plain stupid. The reason we somewhat discourage refactoring, in particular from people that have been recently hired, is that it takes time and experience to realize where some piece of code fits into the value equation given the variables above. I could go on, and I haven't fully answered all of the things you brought up in your post, but hopefully covering some of the topics you brought up in depth makes up for that.
Do you guys do Continuous Integration / extensive code coverage? If not, how do you make improvements to 2 million lines of PERL w/o breaking things or losing your mind grepping through the code base? I don't see the word "test" anywhere in this thread... (except for where you wouldn't want to see it) 
&gt; I am not allowed to write tests. I am allowed to copy that 500 line subroutine into another module. &gt; Foreign keys "slow thing down". Joins are expensive, so like our code, we cut and paste our data. Much of our data is copied from table to table and lots of code is written to make sure it stays correct. &gt; We pay you to get job done. We can always hire more people to figure out the code later. Sorry but that's fucking ridiculous. No thank you. You could not pay me enough money to write shitty code for someone else to have to lose their minds fixing later. And unlearn sane programming practices, fucking up my future. Why would anyone want to work this way? Why would you want to pick up terrible habits? "Not allowed to write tests"? Really?
Do you write tests for your CPAN modules? How is it ok to not write tests? That's insane. Who would want to go and learn absolutely terrible development practices and other awful habits?
Go read the first link from OP. All of the citations you requested are right there, many being obvious and correctly inferred. "full of bullshit" is not writing tests, not being 'allowed' to write tests, copy and pasting code, etc. That's sweatshop garbage and YOU know it. Where did you learn that these awful habits are OK? You enjoy writing legacy code? 
I've responded to this article previously ( http://www.reddit.com/r/perl/comments/1kd5h0/list_of_decent_sized_perl_employers/cbr13f0 ) , and /u/nrperez's and /u/avar's comments above also clarify our development culture.
this is true. they write thousands of lines of original code though, these two. not sure who you mean. its too bad thats in there if so :/
Well, it was more than 15 years ago, so my memory's a little fuzzy. We were working on a multimedia CD-ROM product, localizing it into some language or other. This was on a Mac, PowerPC, Classic OS. A ton of images were stashed in the resource fork of the application. The poor bastards in the graphics dept were extracting these by hand, one at a time, and editing the text on them. I wrote a MacPerl script that extracted these resources in a directory structure for the photoshop oompaloompas to work on; the reverse process reassembled the edited images back into the resource forks. Of course, it was a little more involved than that, but that's the gist of it. It saved days of manual effort though.
That article is not representative of the development culture at Booking.com.
I've been working for Booking.com for four months now, so here are some notes from a new hire: I moved to Amsterdam and I have a permanent contract, other new hires have it as well. It's simply not true that people work for a year on a temporary visa and then leave. It's not true that we're not allowed to write tests. I've written some my self. Unit tests are not mandatory though. As other colleagues have mentioned, we rely heavily on monitoring, so sometimes is not very useful to spend a lot of time writing unit tests. You're supposed to use your judgment as a developer. We do refactor. In fact, I've been working on a big refactoring for a while. But we avoid refactoring just for the sake of it, there should be a good reason to do it. It's not true that managers are encouraging competitiveness over collaboration, it's completely the opposite. All the colleagues I've worked with have been really helpful, teams collaborate with each other. I think Booking has a very unique development culture, and it's not suited for everyone. Here are some things that are different from most other places: - Pragmatism is preferred over dogmatism. If you religiously think that unit test are the one true way of testing software, Booking is not for you. - Instead of having a rigid set of rules, there is a lot of freedom for you as a developer. This can be a little bit annoying when your team mate decides to use his/her favorite coding style instead of yours, but it's fantastic when you can experiment and try things outside the box. Freedom involves using your judgment, that can be stressful for some people. If you prefer to have someone telling you how to do things all the time, Booking is not for you. - Extremely agile process. Code goes live really fast here. That sometimes means errors go live too. Reverts are really fast too, so no big deal. Failing early is much better than failing late. In my experience, working for Booking is far from the horrible experience described in that post. There are ups and downs of course, and, as I said, this is not a place for everyone. There are a lot of smart developers here, I've learned a lot in these months. There are many interesting technical challenges, and you can have a lot of fun, if you use the freedom they give you wisely.
&gt; WWW::Scripter .. is considered alpha, the POD seems a bit incomplete, but thanks for the hint! [WWW::Scripter](https://metacpan.org/module/WWW::Scripter)
Original code is great if it doesn't become legacy the day it's written because of readability, testability (or lack of tests altogether), and maintainability issues.. edit: if you're not writing tests, you're doing it wrong.
Problems - Part I @nrperez Come with me Mr. Perez. Let's go together down the rabbit hole in search of the truth. Our next stop is Glassdoor where former Perl developers at Booking.com voice their anguish, torment and disapproval and frustration. Together, let's read their oppinions. I read them because I am interested. You however, are not, but no worries Mr. Perez, that's what I'm here for. Let me make this clear: I've nothing against you as a person, as you are, like myself, a software engineer. However, I have something against what you're defending, because considering the reviews below, I think it's very hard to defend what you're trying to defend and hipocrisy starts to emerge. Software engineers are at the heart of companies where software is crucial. That much is obvious. If you don't treat software engineers good, and you treat them as dogs, then drop the website and open up offices for "offline" bookings. @Managers of Booking.com I am sure that by this time, you received this link. I'm quite sure you feel embarrassed by it. I am not a Booking employee, I never was, and from the reviews I read I don't want to be. You have misrably failed to understand that Software engineers are the heart of your company. I will not overlook this. I will shut you down. I promise I will literally destroy your reputation if you don't treat Software engineers well in your company. This is not a joke. This is not a warning. I've already started doing it. Aug 8, 2013 -- "About Booking.com" Frontend Developer (Current Employee) Amsterdam (Netherlands) I have been working at Booking.com full-time for more than 3 years Pros There are many good people around to learn from. Strong use of MySQL, there are many training offered by company. Cons They have a chaotic way of implementing software. They break a big task into many small tasks, which can be implemented by different people and there is no documentation to make sense of the code. Advice to Senior Management It would help a lot to provide developers with a high level overview of the other teams. No, I would not recommend this company to a friend May 7, 2013 -- "Nice to work there for a bit but not a plae to build a technical career" Programmer (Former Employee) Amsterdam (Netherlands) I worked at Booking.com full-time for more than a year Pros There is a nice social atmosphere in the company but really beacuse of the colleagues, not the management. It is very internatioal with people from all over the world but most;y from Europe. Being in the center of Amsterdam is really nice too. Cons Senior management treated people like cattle and with no compassion although I am told that is changing. The technology used at bookings is outdated for development purposes and bookings seems to be one of the last group using it meaning the skill developed here are not very exportable. Yes, I would recommend this company to a friend Jan 2, 2013 -- "Immature, mediocre talent, incompetent management" Perl Developer (Former Employee) Amsterdam (Netherlands) I worked at Booking.com full-time for more than a year Pros - Nice offices - mostly friendly people - nice location in the middle of Amsterdam Cons - Bad pay, poor bonuses - Most of the people working there are young and have no experience working anywhere else. They are therefore still immature in how they handle things and place great value on moving up the career ladder. Much more politics than you would expect. - Unclear requirements from management, refuse to clarify no matter how often you ask, then blame you for doing something that wasn't in the requirements. - Really disorganized. They call it "constant change", but really it's a bunch of chickens running around with their head cut off, not knowing what to do next. The company is growing faster than the structures that are in place, and it is causing big internal problems. Advice to Senior Management: Resign No, I would not recommend this company to a friend 
&gt; I promise I will literally destroy your reputation if you don't treat Software engineers well in your company. This is not a joke. This is not a warning. I've already started doing it. I think that's the money quote in this entire thread.
"how much testing is enough" is an economic question, with the usual set of cost/benefit trade offs of any economic question. For instance it seems pretty clear that software for a deep-space probe requires much more thorough testing than software for controlling a model train set. Are you really going to test *everything* that could possibly go wrong on your model train set? I don't think you will. Do you test your .bashrc? I bet you don't. Same trade-offs apply for us. We deal with customers speaking 40+ languages, coming from 200+ countries and sometimes there are minor bugs, like us showing text in the wrong language, something which we probably wouldn't do more than cursory testing for. On the other hand our customers are buying hotel rooms and we do pretty thorough testing to ensure that when they do the room is there waiting for them when they arrive. In other words we focus our testing where it counts, and spend the money we save on better monitoring than you can imagine... And frankly, if you *really* are a software developer then I find it extremely unlikely that you would have never written any code without a regression suite. Does your .bashrc have tests too? 
I think reserving one variable ($self) is not bad, making it a twigil would end up with confusing semantics.
Cause Perl 5 can always use more line noise! Just kidding, we decided to add them after porting a bunch of modules to use the MOP (Plack, Bread::Board, Action::Retry, etc). We noticed that having attributes look like lexicals (```has $foo```) made it very hard to distinguish attributes from normal lexicals. Using the twigils made the attributes stand out ultimately making it easier to read. I will admit that they do take a little getting used too, but once you do they make perfect sense. 
&gt; basically that it is scoped by the invocant You say "scope", I say "visibility". Let's call the whole thing off!
Relatedly, are you going to http://localhost/whatever.CGI (why .CGI and not .cgi?) or file:///whereever/whatever.CGI? The former can be set up to work but the latter cannot as the webserver has the job of launching perl, not the browser.
Apache. I am running on localhost:82 and use that for my sandbox with html and js files....it runs fine. Of course I realized that I was loading the browser from the file directly rather than from the local host....feeling brilliant right now. I am getting an error still, but at least I will get an error log now. 
Placks' CGI adapter (http://search.cpan.org/~miyagawa/Plack-1.0029/lib/Plack/Handler/CGI.pm) might be a lot easier to get running than Apache.
Well the first question I have is does "\strawberry\perl\bin\perl" actually exist? Is that folder hierarchy accessible to Apache?(every folder in that chain must be read/exec for Apache to access and run the script. Is apache configured to run CGI? Can you run some other trivial CGI scripts? Have you read your Apache logs?
all caps 'cause I'm mad :-) exactly, I was (not) launching perl with the browser rather than the server. Now I'm tracking down the inevitable vague error message...
Your question doesn't contain a question.
the path definitely exists...but from one folder back from htdocs.... i.e. all of this is in a folder called WebDevXAMPP/apache WebDevXAMPP/htdocs WeDevXAMPP/strawberry..... In terms of running CGI, I followed the directions to assure apache is configured to run CGI. I don't have any trivial scripts...this is my first experience the perl &amp; CGI.... Looking for apache logs now. 
Fair enough...will edit... 
Apache actually uses the hashbang, but to find out how it interprets it you should ask the windows kernel what paths apache tries to access. You can do that with this tool: http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx Once you know the exact path, you have two options: * either you move your perl to match up with that * you can use [http://sourceforge.net/projects/ntfslinkext/](ntfslink ext) to set up a hard link between your perl and where apache thinks your perl should be
Thanks!
I feel like it would be more Perlish to declare your 'self'. Either as the first method param or as part of the class definition. Predefined variables in Perl are traditionaly all caps (use English) or a single non-alpha character. $a/$b are the only exceptions I can think of. $self just feels wrong to me. Either way, I look forward to using this. Thank you and you're awesome.
I think that apache is executing the perl scripts now. I am pressing "submit" on the page, and I am getting an error message..that error message is driven by a javascript which is buried behind perl scripts, so I think my main question has been answered. 
&gt; to distinguish attributes from normal lexicals I see, I missed that part at first. Is there any plan to add other twigils from p6 like "$.var" etc? 
we tend to outperform other groups when something needs to get done as soon as possible. sometimes we will get something done in a day that takes the java guys 2-3 weeks.
ITT: people who want to write tests
Actually in Perl 6 it is ```self``` without any sigil, that is something we have discussed as a possibility too. As for being able to declare your own invocant, the plan is to support this in the signatures using (again) the Perl 6 style, which would look like: ``` method foo ($self: $bar, $baz) { ... } ``` but right now we are not diving too deeply into the signature stuff until the other Perl 5 signature effort is more finalized. 
The issue we have with the ```$.bar``` syntax is that it is supposed to create a public lvalue accessor for that attribute. Lvalue subroutines in Perl 5 are pretty ugly and very tricky, so being that we can't support that well, we have (currently) opted to not support it at all. But, keep in mind, the current goal is to just get something into the core that is stable and we designed enough that it can be built upon. I hope that over time some of the features we have punted on will be able to make their way in. 
Perl has a long and glorious history of being a go-to language for data munging. Really, any language with a good support for regular expressions, dynamic data structures, and string handling is going to be acceptable. Some folk prefer python, some folks prefer ruby. I, personally, reach for Perl.
I made it all the way through a degree in math, concentration in statistics, with minimal programming. Mistake of epic proportions. Then my first internship, the guy insisted on using JavaScript for the data handling as well as the statistics. Mistake compounded. Anyway, thanks for the input! It seems like learning some small portion of the "go-to language for data munging" is exactly what the doctor ordered. 
"How did you learn Perl?" and "I am wondering if you have any tips or warnings for a brand new perl coder." are very different questions. I learned Perl from knowing some sh from hacking around with my NetBSD system and MUDs (and from knowing other languages before Perl). Then I got a job at Motorola and was handed the Camel book and told to "go learn Perl". I don't recommend NetBSD any more, working for Motorola, or using the Camel book (Larry Wall's _Programming Perl_) to learn programming (great if you know how to program and want to learn *Perl*, though). As for what you should do, ... heck, I don't know. I guess wanting to learn to code without having an idea for a thing to code is alien to me. I learned to code because of the billion different things I wanted to make. To me, that reads like "I want to learn how to fly!"... "okay, let's go, where do you want to fly to first?"... "uh... I don't know... no where, I guess". You could ask for people's github usernames and look at their projects up there. That would at least give you something more concrete to talk to people about, as far as code. I'm scrottie there too. 
There is also a good book on the argument, titled [Data Munging with Perl](http://www.manning.com/cross/) ! Is quite a bit old, from 2001, but what it says in the general section is still valid, as the language has not changed a lot (at least for this kind of task). Any information on specific modules on the other hand is to taken with care, it's quite possible that now there are better alternatives.
Very cool. R is great for day to day work, but has two shortcomings: data handling (mentioned above) and very heavy computations. People often use Matlab &amp; C to juice up R...if that can be done using PDL, so much the better. Thanks for sharing! 
I love you nparez, but "you're wrong and you know it" isn't a compelling argument. I could re-phrase more moderately: the reports I've heard and read from Booking are plausible to me because they sound painfully familiar to negative experiences at other companies. Also, my sample size is small and probably biased. I also realize that repeating second hand stuff isn't useful, but I felt like I had a little bit to add. "If it were truly that way, do you honestly think some of our strongest community members (in terms of contributions) would have stuck around?" You're assuming knowledge I don't have. I don't know which strong contributors work there. If they stood up and defended the place, that would affect my opinion. The highest rated comment on here is currently a defense of not unit testing but doesn't address any other objections. I have known other strong contributors who worked at terrible places. I was working at Shopzilla at the same time nclark was. He later wrote a post on his use.perl.org blog on that subject, stating that taking a job at a place just because a high level developer is there is a patently bad idea. He punched a hole in the breakroom wall and walked out of the place. I'm glad that some place is hiring high level Perl developers. I see a lot of people like chromatic mostly working in other languages and complaining on Twitter about the idiocy of the jobs they do get. Maybe I'm cynical (I'm cynical), but just because some high level developers are employed somewhere, I'm not taking that as an endorsement of the place. You need to actually say "it's nice here and I like it", not "do you think we'd be here if it sucked?".
Hey, be nice.
wow, I should have listened to my little brother a while ago...reddit communities rock. I had found tutorials on perl but wanted to get into the data handling side, not the normal first six chapters (at least for now)...thanks a bunch for sharing, I will look at getting that book. I'm at an academic library right now, it shouldn't be a problem! 
&gt; I work there. I enjoy it a lot. Thanks for this. Shooting down the "truth about booking" article won't happen through discrediting it but through a consensus of insiders against it. It makes me happy that Perl programmers are taking a stand on quality of work and asking questions about it.
This discussion becomes more refined every time it comes up, and I think it has progressed a lot. I hear a lot of "it's not for everyone" and "it has its ups and downs". It sounds like there are a lot of strong personalities as well as a large dev team doing something other than defaulting to industry generic practices. One of the main reasons companies stick to industry generic is to settle debates before they happen. Asking people "do you write unit tests?" is perhaps more about asking them "do you fit into the mold?" than assessing their skills. You can say that personality conflicts are rare there, but they are generally rare to the point of being non-existent. I don't mean that as a criticism. I think Booking employees talking about this stuff helps people know what they're getting in to and changes the tone of the dialog. It's interesting. Thanks for sharing.
So let's take a look at glassdoor more closely. There are a total of eight reviews with "developer" in the title. Of those eight reviews, five of them are negative (or rather, would not recommend). Of those five negative reviews, four of them are of sufficient time that we can consider them former employees (contrary to the stated status). So my first question is this: Do you have data on how many former employees leave positive reviews on glassdoor? Is it really a credible, non-biased source? You seem incredibly keen on the idea that these five people are victims based solely upon their review; without any additional context. More than that, it also seems you are interested in generating controversy over what is by all definitions the most normal human experience possible: disagreement. But let's take a step back for a second and consider happiness objectively. Happiness can be defined as the sum of reality minus expectations. In each one of these reviews there are expectations that are unmet. Are they realistic expectations for the situation at hand? What was the reality of the situation surrounding these reviews? Without these additional data points, all we can see is the result of the equation and it doesn't tell us very much. In addition, the sample size of the data you have presented doesn't seem sufficient to draw the conclusions in which you think we treat people poorly. And this ignores the fact that organizations are made up of individuals. And painting an entire organization with a brush this broad from the context-less reviews of five former employees (from a two year length of time, I might add) seems disingenuous or downright malevolent. And what about the 160 other developers still around? What about the new hires? How do these numbers of people who have not expressed unhappiness weigh into your equation? And in the absence of such expression, only one conclusion can be drawn: qui tacet consentire videtur. So, given all of the above: Is this really a crusade worthy of such vitriol? As for your threats of defamation, I find them lacking in any [credibility](http://knowyourmeme.com/memes/internet-tough-guy), whatsoever. 
&gt; maybe there's something wrong with the truth Your 'something wrong with the truth' turn of phrase is shocking--it almost acknowledges that the "Truth about Booking.com" opinion piece, an editorial on the World Wide Web, might perchance contain some inaccuracies. The shadows in this cave are so lovely, I can't imagine anything nicer to look upon.
Good questions, I'll start from the end: &gt; Unit testing only tests the cases YOU already know about. Why bother, when you already know the result? There are volumes of literature that address why testing is important. It basically goes like this. With tests, when the next guy comes along and goes to improve, change, and extend your code, he can easily run existing tests to see if he's broken anything (instead of having to grep through a million lines of code and pray that production doesn't blow up when your code is "..actually covered by real-life traffic..".) You're saying that you test your code in production? I must be reading that wrong, you seem intelligent. Also, having tests means that when you change something adjacent, or even far away yet somehow affected by your changes, you can kick off those tests to make sure you haven't broken something totally unexpected! And easily! Tests aren't one-offs, they help with something called Continuous Integration. 100s of people hacking on the same code base, a Continuous Integration server constantly polling the source code, looking for recent checkins, and kicking off thousands of unit (and functional) automation tests, all day, every day. That way, when a change is made that affects performance somewhere, the build machine complains. When a change is made that breaks the build, the build machine complains. When a change is made that breaks functionality, everyone knows it. Otherwise, every individual programmer has to waste his time figuring out if he broke shit or not, and you're NOT testing in production (where you serious by the way?). I guess I'll leave it at that -- ever notice that CPAN modules have a test directory? Why do you think that is? Ever heard of eXtreme Programming or Test Driven Development. All bunk? Like I said, not sure where you came up with this 'unit tests aren't helpful' thing. I mean .. it's pretty shocking to hear someone speak against it, especially with all the education and literature, and everything else that is strongly behind it, as a basic fundamental part of Software Development. 
Yeah I guess I didn't consider that the article could be largely fictional. I just assumed that a at least a major portion of it was indeed this person's first-hand experience. I must be nuts.
Depends on the type of data cleaning. I keep seeing people do awesome things with R and think I need to learn more. R and plplot sure make it quick and easy to look at your data. When people talk about "cleaning" data in Perl, they're probably mostly talking about regular expressions things like Regexp::Common that have libraries of input checking things, and probably aren't talking about picking out mistyped, misobserved or otherwise anomalous data using stats functions. You might as well use if that's what you're talking about. 
Yeah I must admit that a "monitoring stack" is something totally foreign to me, which I'm starting to think may explain my jaw-meet-floor reaction to this notion that copy + pasting, and developer testing sometimes not necessary thing. I've also spent most of my career working with data storage systems, where monitoring was happening but in a different realm or whatever. But performance (File System or otherwise) was huge. I still shake my head at it being ok to write hard-to-read code. No coding standards? Having a coding standard means that no one complains (and wastes time) trying to read "clever" convoluted code with no tests to help you figure out what the code intends (and help you figure out if you've broken anything after touching it). I don't see how you could roll something untested into production and not fear thrashing your DB with a bad query, blowing up DB tables, bringing down systems, etc .. IDK, seems crazy to me. Where I come from, there's dozens of MIT grads (some who teach there as well) hacking away at the same code base. Duplicating large routines is globally considered "absolutely retarded". We do XP, Continuous Integration, Pair Programming, etc.. I also spent many years at EMC where what you guys are saying is A-OK would be laughed out of any discussion. So yeah, this just sounds crazy to me .. but if folks don't mind digging through a clever, redundant, codebase all day .. I mean, really? Edit: Also, it's not just an economic question -- it's a quality of life issue. Duplicating code is a guaranteed headache for you or someone else to solve later if/when they need to improve that code. It's legacy code out of the gate. Hard to read code is .. well, hard to read. Sucks, sucks to have to dig through someone else's crap, you know? Better to have a standard. You can get a whole lot more done, in time, when your codebase is a fortress of robust checks and balances. I'm not happy when I'm reading crappy 'clever' code. Are you?
Yeah I must admit that a "monitoring stack" is something totally foreign to me, which I'm starting to think may explain my jaw-meet-floor reaction to this notion that copy + pasting, and developer testing sometimes not necessary thing. I've also spent most of my career working with data storage systems, where monitoring was happening but in a different realm or whatever. But performance (File System or otherwise) was huge. I still shake my head at it being ok to write hard-to-read code. No coding standards? Having a coding standard means that no one complains (and wastes time) trying to read "clever" convoluted code with no tests to help you figure out what the code intends (and help you figure out if you've broken anything after touching it). I don't see how you could roll something untested into production and not fear thrashing your DB with a bad query, blowing up DB tables, bringing down systems, etc .. IDK, seems crazy to me. Where I come from, there's dozens of MIT grads (some who teach there as well) hacking away at the same code base. Duplicating large routines is globally considered "absolutely retarded". We do XP, Continuous Integration, Pair Programming, etc.. I also spent many years at EMC where what you guys are saying is A-OK would be laughed out of any discussion. So yeah, this just sounds wild to me .. but if folks don't mind digging through a clever, redundant, codebase all day .. I mean, really? Also, it's not just an economic question -- it's a quality of life issue. Duplicating code is a guaranteed headache for you or someone else to solve later if/when they need to improve that code. It's legacy code out of the gate. Hard to read code is .. well, hard to read. Sucks, sucks to have to dig through someone else's crap, you know? Better to have a standard. You can get a whole lot more done, in time, when your codebase is a fortress of robust checks and balances. I'm not happy when I'm reading crappy 'clever' code. Are you? Or are you the senior guy that gets to write all the new stuff, gets to be 'clever', and lets the horde clean up the mess .. ?
This. I use Perl to *extract* and *select* data that I want, but then move to R to *clean* them and *do statistics*.
I don't know what parts of it are true or to what degree. Unless you were in the room for these conversations, neither do you. In such a case, skepticism is in order.
I really struggle to understand how R can be considered poor for data handling purposes. Can you provide a link to support your statement please?
Nope, I am organizing a Perl conference.
So, don't believe anything unless you witnessed it. Have fun with that. I have no reason to think that this person has lied. And, in fact, I have employees, current and former, (or people that may be lying and were not employees), here in this thread backing up his claims. Annoying.
What I don't understand is why NQP has a need to exist when there is microperl which could be used to bootrap a language and the libraries. The best reason I can think of is because there is no standard to microperl other than the source code. Maybe I will understand after I finish my research.
I am seconding that book. Invaluable.
I would have Perl 5 increment a version number or two around 2008 or drop a major number around Wed Dec 25 00:00:00 EST 2013. 
I didn't know script kiddies could develop software and therefore would have any need for debuggers or write tests.
Nice project, i was going to do something like this, but but i discovered that sms providers offer simple apis with scheduling and all so it all boils down to a post request with the datetime you want the sending to happen.
So, besides Yves, we have nperez, AEvar and myself (I trust you can do the Reddit account =&gt; CPAN account mapping) who have spoken up in the thread. That counts three core committers, a PAUSE admin, and four long-time CPAN contributors. That's a fun anecdote about Nicholas, by the way, and there's certainly some truth to what you're saying with that. But keep in mind that we *are* speaking up. So for the record: It's nice at Booking.com. I've worked here for 2.5 years. I get a lot of freedom and opportunity. Interesting challenges abound. I like it a huge lot. *edit: grammar*
I work mostly in Perl, but I use other languages occasionally. JavaScript needs ten more days of design though.
Every Booking.com employee participating in this thread has identified himself as such. Nobody in this thread (with the exception of the Glassdoor reviews) has identified themselves as Ex-Booking.com employees.
I dont think you have many people backing up those claims, instead you have a lot more explaining that the post contained gross simplifications or distortions of how we do operate. The post you keep referring to is obviously by a disgruntled former employee, and I think you should take it with a grain of salt. Very few of our devs leave, and lots of our devs refer their friends and colleagues. 'nuff said. 
If one doubts it from your posts here, a look at your Profile makes it clear what you are doing here: trolling.
"With tests, when the next guy comes along and goes to improve, change, and extend your code, he can easily run existing tests to see if he's broken anything (instead of having to grep through a million lines of code and pray that production doesn't blow up" I have two issues with your comments, a) a test suite is NOT a replacement for understanding the code you are working on, and b) we do not put it into production and pray. We put it into production, watch for trouble, and can rollback in an instant if there is any. And here, ill go and say it, in a complex and rapidly changing web development environment unit tests of business logic are of little value in comparison to sophisticated monitoring and deployment infrastructure. You have repeatedly in this thread ignored the point that not all code is equal, and you keep mentioning CPAN. CPAN is a repository of *library* code. And library code is exactly the kind of code where comprehensive regression testing is vital. But obviously not all code is library code. You need to get a sense of perspective. 
Most of our code is *in* libraries, but it is not "library code". It has exactly one or two "users". We certainly do have lots of modular libraries that are reused, and those have tests for the important pieces, but as /u/demerphq said above, most of our code is business logic at one level or another and changes as the business requirements do.
Unit testing is a great practice, no doubt. It's just not well suited for all scenarios. For some years I worked on a very well tested code base and it was fantastic. All the advantages that you mention are true, that's why TDD and similar practices exist. There is one important trade-off of unit testing: It slows you down in the short term, but increases maintainability in the long term. Writing properly tested code is way slower than just writing code. But in the long run, well tested code is easier to maintain, which means that you will recover that extra time you spent writing tests and much more. In practice, that means that unit tests are only worthwhile when you have long-lived functionality and when you can get that payoff. Library code is one good example of that. However, if you work on a very dynamic business, where functionality is created and thrown away constantly, where a lot of code only sees the light for a few weeks or even days, unit-tests might be only a ballast without any of its perks. And when you have a great monitoring system and a safe rollback mechanism, there are less reasons for testing. Would you spent a lot of time writing tests and documentation for a script that will be run only once in life? Would you do it for a experimental thing that you're almost sure it will be replaced soon? I would say no. Unit testing is great, just not a silver bullet in software development.
You should check out the other MongoDB client that Sri wrote: [Mango](https://github.com/kraih/mango). It's non-blocking and packed with awesomeness.
That does sound like something I should check out. Does it play nice with mongoose ?
I would call it more of a replacement than a playmate.
&gt; Those that trumpet refactoring seem to be unaware that many a tech company has gone out of business because they decided to waste their dev resources refactoring their code while their competitors were using their dev resources to make a better product for the end user. *There*'s a strawman argument, but I guess that's okay, because most people use the word "refactoring" to mean something that's not what it meant when it meant something interesting.
Mango is awesome.
Aiui: microperl is a tiny language intended to alleviate use of shell scripting for the initial stages of building perl. (Perhaps you meant miniperl, but miniperl is almost all of perl, sans XS.) Key characteristics of NQP: * the NQP lang is designed to be heavily **optimizable**, which tightly constrains the constructs available. For example, no variable assignment (you can't write $a = whatever), only binding ($a := whatever). * HLL, an **inheritable generic compiler** with things like command line processing, compiler options, a compilation pipeline, REPL, etc. Just add a grammar (to parse lang input) and some actions (to write AST output) and you've instantly got yourself a pretty robust compiler. * a **grammar lang and runtime engine** for writing and parsing grammars. This has almost full Perl 6 power -- enough to parse full Perl 6. * **QAST, for writing ASTs**. * **Worlds**, for storing and manipulating the persistent results of declarations processed by a given compiler. * **backend agnostic ops** for backend portability of those ops (memory management, io, concurrency, etc.) * **backend code generation** (specific to each backend) * **6model** as a flexible oo foundation that's good for language interop. cf CLOS. * A **small subset (almost) of Perl 6 syntax** so it's easy for Perl 6 users to hack on compiler guts. It's arguably easier to hack on the guts than write libraries! I recommend your research includes a trip to chat about it on [the freenode IRC channel #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) when someone suitable is online (best would be pmichaud or jnthn).
From the R GUI there is a drop down help menu....a pdf there talks about getting data into and out of R. It was there that perl was suggested as a good tool. I was surprised, to say the least. I think scrottie, above, speaks to the point...once the data is in R, data handling is great. 
fair point. but about the next guy "breaking" the code, doesn't that just mean that there is another use case that wan't handled properly? if that guy didn't handle that use case in his unit test, then you wouldn't catch it either. developing unit tests involves knowing what cases to test in the first place; shouldn't the next guy know what he is working on before he does something? to me it sounds like lazy coding; as long as i don't see any "reds" in my test, then i can modify it all i want. it may add another layer of security for "common" code, but it adds a lot of overhead, just to say that you have 100% code coverage. you'd be better off understanding the code first, before you make modifications, instead of modifying it, crossing your fingers, and hoping the tests are all "passed".
Perfect. Again, I earned a degree in math with an emphasis on stats, but we got further and further from data as we went. In fact, stat theory had no data at all (just a set of random variables {X1, ..., Xn} Even lower division classes had pristine data sets imported from cd's. The struggle for employment has me renewing my effort to understand R, not just to get a job but hopefully spend a fair amount of time doing it. I went to a meet up talk and the presenter said that "statisticians are used to data being thrown over the wall to them". People in the audience guffawed, and when they were done, said about 80% of their work involves banging data into usable shape. 
&gt; you'd be better off understanding the code first, before you make modifications, instead of modifying it, crossing your fingers, and hoping the tests are all "passed". Yes, of course. Who suggested otherwise?
&gt; I promise I will literally destroy your reputation if you don't treat Software engineers well in your company \&gt;being this autistic
Awesome. Thank you for taking time to comment. I am second guessing my original impression. Or at least I'm tempering it. I think I've created a false dichotomy in my head. Large companies I've worked for have fit one of a few molds: 1. Inept but mostly harmless. 2. Programmers are utter plebians. 3. Strong dedication to professional norms. Booking obviously isn't #1 or #3 so accepting it as a case of #2 was easy, but I can accept that it isn't that clear cut. 
Had to check. That used to be a common novice mistake.
Do you think all of that potential flexibility in the language would make it susceptible to The Lisp Curse?
I just dug an even deeper hole for myself.
All devs live in/near Amsterdam?
Yes, relocation to Amsterdam is required.
Has anyone got cpan working on Android? 
Thank you. Maybe if you're ever in Amsterdam, we can call an emergency Amsterdam(X).pm meeting and chat over drinks. As for #2, I may add that demerphq/Yves outranks me while being no manager at all. ;)
This is an awesome post. My problem is at my new job almost all external access is blocked; wget and curl don't work outside of our environment and all FTP traffic is simply blocked at the border. So my problem is access to CPAN is blocked at the firewall by the corporation. I *can* download the tarball of the source then install the module from source, this works with modules that have limited dependencies (e.g.: I installed CAM::PDF rather painlessly) however, this becomes quite tedious when trying to install modules that have hundreds of dependencies (Try installing Moose or Dist::Zilla by downloading all of the required tarballs and running the make files). Honestly, it frustrates me to no end that my access to CPAN is rather limited. The best response I've received is "We need to vet the modules" as to why I can request access to CPAN... And the response I got from #perl on IRC (freenode I think... could have been #perl-help but I don't think they have webchat... [IRC is also blocked by the firewall so I've been reduced to web irc...]) "That's stupid" and "Your company is dumb" when I asked for assistance solving my "can't install from CPAN" problem (because there was a module that did do what I wanted but not being able to install modules from cpan easily as it required a number of external modules and after an hour of running the make file, find a new dependency, trying to install that and finding another dependency... etc). I know my situation is less common than the scenarios presented by mst in the article, however, a "solution" of "Your company is dumb if you can't use CPAN" is a bullshit answer. (I blame freenode as the people on irc.perl.org are typically more helpful)
Hahahaha.... Wow. It seems it was that simple. Can I do that with cpanm? Dunno why I never thought to try that before. Holy Crap!! Thanks for the idea.
ISA server here. As a Unix admin in a primarily Windows world it gets... interesting... The security group here is kinda strict... there are stories of people establishing an ssh connection outside of the company and that worker showing up the next day to a missing workstation while the "forensics" guys look over and make sure we're not giving away secrets... I think it's more of a lack of understanding than a focus on security... "We don't understand it, let's block it" I think I remember from somewhere that cpanm uses CPAN::MyConfig but I can't find it again...
You might find [minicpan](https://metacpan.org/module/minicpan) useful. It allows you to fetch a full backup of the latest modules on CPAN. My previous minicpan mirror was 2.4 gigs; small enough to fit on a DVD-R. Once you've got a minicpan mirror, you can install the module you want and all its dependencies from your minicpan mirror using [cpanm](https://metacpan.org/module/cpanm): cpanm --mirror file:///path/to/mirror --mirror-only Some::Amazing::Module
It might be possible to install a local copy of CPAN on your workstation (e.g.: via [minicpan](https://metacpan.org/module/minicpan)), or copy that over from some place else. Mine is about 5.1GB in size at the moment. And as you can ssh into that firewalled box, config your isolated CPAN client to use a SOCKS5 to said workstation ([installing CPAN inside firewall](http://mail.pm.org/pipermail/sanfrancisco-pm/2006-August/000590.html)) .. Wild guess, haven't tried that, but seems possible. Or what [nrperez](/u/nrperez) said .. :)
I have brought up the idea of having our own internal CPAN mirror. But this is a large lumbering corporation so that decision could take anywhere from a week to a year... Unfortunately, there is no SSH to the outside world so your second link doesn't help me here, but it is rather interesting so thanks for the link.
Cool, I didn't know cpanm could do this. Thanks!
So if I read that right, your solution to "can't run cpan as root" is to do a full perl install as yourself? I understand that works, but no wonder people get frustrated and leave. That want to accomplish a small task likely, not reinstall perl.
Is it just me or is the online perl community more insular and dickish these days? I started programming Perl about 11 years ago and back then I felt like I was part of a helpful community. I took several years off and now I'm back to working in Perl and sometimes I'm made to feel like an idiot when I ask questions online. Almost like there is no such thing as being allowed to be a beginner in some things any more. You're either an expert or shunned. Not all the time, just sometimes.
local::lib is not perlbrew.
This is exactly what I do!
I don't believe it is any better or worse than any other programming community.
Aside from the fact that the article does not actually suggest it, doing a full perl install is 1) not a bad idea and 2) not really hard.
Do you know if remote developers have ever been considered? Seems like you would increase your talent pool significantly. I understand, of course, there are challenges as well. Just curious.
Considered, yes. Done in exceptions, yes. A general thing to do, consciously no.
First, to make sure we're on the same page. I'll define The Lisp Curse as being about a significant reduction in collaboration and quality of libraries and tools because there is no canonical way to do some particular thing that many people need, and it's super easy for folk to write their own versions of that thing such that none of these versions gains the attention and effort necessary to make them a world class library or tool. **I don't understand what would lead you to think that this could in theory or does in actuality apply to NQP or Perl 6.** ---- **In NQP's case**, it is very narrowly targeted at writing compilers. There is a canonical way to write a compiler with NQP; inherit from HLL, write grammar, actions, and world, and boom, you have a compiler. While multiple individuals or groups could choose to start writing "competing" compilers for the same language, it's obvious (to me) that this would not be a problem. **Larry specifically designed Perl 6 to steal some of the best bits of Lisp's evolutionary capacity while carefully avoiding The Lisp Curse.** In particular, unlike Lisp, the STD Perl 6 language is very rich, providing a canonical way to do an enormous range of things. Sure, it's flexible enough to support all the homebrew object oriented systems created for Perl 5. But have you played with the built in Perl 6 oo system? It is so good that there is very little incentive to write one of your own just because you can, and it would not balkanize the community even if someone did. It's also interesting to consider the Perl 6 compilers themselves. Multiple compilers have been written over the last decade. What happened? They share the same spec and test suite, algorithms and grammar fragments from one get used in others, and devs happily move around the projects. This is meritocratic collaboration at its best. Fast forward 10 years and we now have Rakudo as the consensus leading compiler (and NQP as an outstanding compiler toolchain available for folk to write compilers for other languages). This is the exact opposite of the outcome of The Lisp Curse.
&gt; But this is a large lumbering corporation so that decision could take anywhere from a week to a year... In my experience, the solution to problems like this is JFDI. Unfortunately, taking on so many yak shavings yourself does eat into your productivity (at least at first), but it is oh so satisfying to be able to just do what you need to have done, rather than wait for some other department to get around to doing it (if it ever happens at all). And it's always easier to apologize later than to ask for permission... ;)
Don't take it personally. Just because your question may be ignorant doesn't mean *you* are stupid. If you ask your questions with an open mind and prepare to receive answers that make you go "doh! of course!", and not take it as a knock against your ego, you'll learn tons, and then you won't be a newbie anymore. It's a near-universal constant that to be part of tech communities online, you need to have a bit of a thick skin. But don't worry, we've all been there, so we'll do our best to be gentle and only call your question dumb, not you :)
I installed 5.19.3 via perlbrew into an SSD drive using -j9 (parallel testing) in under five minutes. I hadn't even come back from getting my coffee and it was already done.
subtest is beautiful. It is very useful for embedding tests into other tests -- e.g. say you have some Test::Bloorp module from the CPAN that does everything you want it to, but (like lots of Test:: modules) it does its thing right as soon as you `use` it, including declaring its own plan. That means you can't do any other testing from the same file... unless you wrap it in a subtest: use Test::More; subtest 'bloorp' =&gt; sub { require Test::Bloorp; Test::Bloorp-&gt;import; # we get a plan from here }; # other tests... done_testing; 
Config::Any will read YAML, as well as JSON and several other formats, automatically detecting the format from the file extension. It's very useful if you want to allow users the flexibility to choose their data format.
Here's one for you. I work for a major software corp that is extremely paranoid about open source (rightly so, they are a big lawsuit target) I work on some embedded Perl code on a closed appliance. I technically 'can' get individual CPAN modules for new versions of the appliance, but it is a huge pain and terrible legal process. It is much simpler and less work to write my own code using core.
Hey I remember when I was a kid, my mom used to say "don't hate the sinner, hate the sin." So I guess the corollary is "don't call the person stupid, call the *question* stupid."
I think we disagree on the definition of The Lisp Curse. I define The Lisp Curse as the reduction of collaboration and quality of libraries and tools because the expressiveness of the language makes it too easy to not collaborate. Here is a quote from http://winestockwebdesign.com/Essays/Lisp_Curse.html &gt;Lisp is so powerful that problems which are technical issues in other programming languages are social issues in Lisp. The Perl6 project has demonstrated having an array of social issues. Perl6 has 5 major competing compiler projects endorsed by perl6.org. http://perl6.org/compilers/ NQP itself tries to target ParrotVM, JavaVM, and MoarVM. NQP tries to the golden hammer of compiler projects, ~~but I can't find any evidence that NQP can host itself. That in itself wouldn't be important if NQP wasn't stated to be for bootstrapping Perl6.~~ **EDIT:** Slide 18 of Rakudo and NQP Internals: Day 1. By Jonathan Worthington 
The Lisp Curse is a social problem, not a technical problem.
One of the issues I think perl seems to suffer from is that it has been around for so long. This is not a bad thing, but each 'generation' of developer seems to latch onto the 'cool new thing' even if it is not significantly better or different from what already does a fantastic job (such as perl.) So... do we need fresh meat? Let's look at places like http://www.codecademy.com/learn who utterly lack threads for teaching perl, perhaps, and design for them some coursework that could be so represented. Alternatively, perhaps something could be invented that utilizes perl (or some syntactically identical but sacrificing backwards compatibility for convenience) for something young folk are avid to do... like game scripting. I'm not suggesting that it be the language in which, say, the game itself runs, but as a superficial scripting language that allows these kids to use to script their games using some game dev toolkit. They then discover... hey wait... this language for so much more than just this, and what they learned could be transferred to more productive avenues. I don't know... but I 'marketing' perl too overtly seems to me like it would do more to dissuade new users. Instead, give people reason and/or places to discover it themselves.
http://onyxneon.com/books/modern_perl/
I cannot say I fully agree with that slide. While I generally agree with the sentiment against cargo-cult programming, I also think that using `strict` by default is worthwhile, because even in short and simple programs it helps to catch typos right at the place where you made them, rather than having them cause bugs somewhere else in the program.
Does Object::Tiny provide a smaller runtime cost than Moose? Not that Moose is really a problem, I love Moose, just curious. 
I suspect we're in violent agreement on the definition of The Lisp Curse. {1} Regardless of theory, I see no signs that Perl 6 is suffering from a version of The Lisp Curse in practice. . ---------------- &gt; Perl6 has 5 major competing compiler projects endorsed by perl6.org **There aren't "5 major competing compilers".** While there are several, and we occasionally hear of lone wolves creating more, just one compiler has emerged as the clear front runner (the Rakudo Perl 6 compiler). The core Perl cultural value **"There Is More Than One Way To Do It" does not conflict with eventual collaboration** and has not, in the case of Perl 6, led to "The Lisp Curse" effect: * Audrey, a dazzling Haskell hacker, created the first Perl 6 compiler called Pugs, written in Haskell, in 2005. This project was a critically important early driver of collaborative Perl 6 language design (and had a big impact on Haskell too!). Pugs also spawned the Perl 6 test suite, a critically important collaborative contribution now shared by all Perl 6 compilers. * Stefan, who said he did not want to work on Rakudo as it then was (around 2010), created Niecza, another Perl 6 compiler. He wanted to prove some points about optimization, Perl 6 on .NET, and so on. So he built a pretty substantial compiler which proved (or disproved) his points. In 2012 he stopped working on Niecza. He then did a bunch of extremely valuable work on Rakudo this summer, and some others have ported parts of Niecza that Rakudo didn't have in to Rakudo. This is the opposite of The Lisp Curse. Maybe we should call it The Perl Blessing. * One of the main devs of KindaPerl6, an early "competitor" of NQP is now writing the Javascript backend for NQP. * Etc. . -------- &gt; NQP itself tries to target ParrotVM, JavaVM, and MoarVM. "Tries"? What's leading you to use the word "tries"? NQP has had Parrot as a backend from the start of NQP's existence. If by "tries" you mean that, after 6 years, it hasn't gone as well as some hoped, I'll grant that, but the Rakudo team consider this to be weaknesses in Parrot, which is developed by a completely different project, not NQP, which is developed by the Perl 6 project. For many years the Rakudo team focused on other things, hoping Parrot would mature over time. Once the team had gotten NQP and Rakudo sufficiently mature in other ways, and Parrot still wasn't where they needed it to be, they started building other backends: * The **JVM** backend is already in good shape, in particular being the only platform currently supporting experimentation with Perl 6's concurrency and parallelism constructs. * **MoarVM** is also advancing rapidly. It has attracted a team of contributors. It's leading the way in several areas, eg NFG, a key part of Perl 6's innovative and comprehensive approach to Unicode, and interop with XS modules in Perl 5, both of which would be much more difficult to initially develop on the JVM or Parrot. * As I just mentioned above, pmurias is working on a **Javascript/V8/node backend** and (perhaps because I know the quality of his work and know he's nearly finished an initial version) I consider this a good thing. * Since 2009 NQP has, in design terms, also specifically targeted **.NET**, though I could well imagine it'll be a year before someone actually starts implementing that backend. If you choose to view more backends for a technology that's designed for multiple backends as a curse, regardless of their quality, well, I can't stop that, but I just don't agree. :) . ----------------- &gt; NQP tries to the golden hammer of compiler projects I wouldn't say NQP is trying to be anything other than what it already is. It's basically a done deal. Sure, there's room for improvement. In particular, the doc's weak, it currently only supports native types, there isn't a source level NQP debugger along the lines of the awesome Rakudo debugger, and there's been no substantial effort to optimize it despite it being carefully designed to be optimizable. . -------- {1} We're both referencing Winestock's original article, so I think our actual differences are simply one of perspective. When I wrote "canonical" I should perhaps have written "world class" or some such. When I wrote "super easy for folk to write" I meant expressivity. My point is, if enough folk have collaborated to produce a world class option, then it's OK if many other folk feel free to not collaborate and instead to experiment with other ways to write much the same thing. Indeed, this freedom is, presumably, a blessing, not a curse.
I've recently had a play with [Moo](http://search.cpan.org/~mstrout/Moo-1.003001/lib/Moo.pm) and think it's hit a sweet spot between simple blessed objects (with all the boilerplate) and Moose (with a bunch of dependencies and a small startup cost)
Thanks for the reply. Moose does suffer from a huge list of dependencies. I'll take a look at this module. 
I think that we need a phantomjs binding now :)
This is a great find, thanks!
You can pretty much use Moo until you need Moose features.
check this out, a very interesting talk by Matt http://www.youtube.com/watch?v=GzyvPqkNKYY
If we get [a MOP in the core](https://github.com/stevan/p5-mop-redux), it might look like this class myBaseClass { has $!myID is ro = 0; has $!myName is ro = ''; method doMsg ($m) { say $m } } class myDerivedClass extends myBaseClass { method hello { say __LINE__." Hello from myDerivedClass" } } I'm sure it's hopeless for 5.20, but I'd love to see this in 5.22!
Most of what makes Java a bloated nightmare is in the culture surrounding the language rather than the language itself, though. Here's a translation of your example in Java that's kept simple: public class Simple { static class MyBaseClass { long myID; String myName; MyBaseClass(long myID, String myName) { this.myID = myID; this.myName = myName; } void doMsg(String m) { System.out.println(m); } } static class MyDerivedClass extends MyBaseClass { MyDerivedClass(long myID, String myName) { super(myID, myName); } void hello() { int linum = new Throwable().getStackTrace()[0].getLineNumber(); System.out.println(linum + " Hello from myDerivedClass"); } } public static void main(String[] args) { MyDerivedClass v = new MyDerivedClass(new java.util.Date().getTime(), "DC"); v.hello(); v.doMsg(v.myName + " Very nice! Did you know you can invoke javac from the command line?"); } } 
That was an interesting watch, cheers!
That's the craziest and least useful use of reblessing an object I've seen in ages. What could the possible point be here? If you create an Animal object, it'll have different defaults than the ones provided by the overridden "new" in each sub class. It also won't have its own constructor run, so if has any new attributes the object will now be in an invalid state. Also, the base class now knows about all its sub-classes ==&gt; poor maintenance. *People, do NOT do this!* Module::Runtime looks somewhat useful. However, the right way to create an object that can e.g. deal with a specific format for a web site is for each module to know/recognize a format that it supports. After all, the module is what knows what it can do. So, ask it. [Module::Pluggable::Object](http://search.cpan.org/dist/Module-Pluggable/lib/Module/Pluggable/Object.pm) from the [Module::Pluggable](http://search.cpan.org/~simonw/Module-Pluggable/) distro is useful for that. One way is to have the factory method call a method -&gt;can_handle($this_input) on each plugin class to determine which one to instantiate. The docs have similar useful examples.
What is going on here? At the risk of sounding angry, why isn't Moose and simple roles being used here? Moose's "`with`" operator you use to consume roles happens at runtime, so you can morph your class into whatever the fook you want at runtime by consume roles whenever you'd like. A common practice, to use the example in the above would be something like: package Animal; use Moose; has 'name' =&gt; ( is =&gt; 'rw', lazy_build =&gt; 1 ); sub BUILD { my $self = shift; if( $self-&gt;name eq 'seahorse' ) { with 'MyRole::Seahorse'; } else { with 'MyRole::Chicken'; } } __PACKAGE__-&gt;meta-&gt;make_immutable; And build a few roles: package MyRole::Seahorse; use Moose::Role; requires 'name'; # Because why not sub respirate { my $self = shift; say "I'm a breathing seahorse!"; } sub _build_name { 'seahorse' } 1; Use it with: my $seahorse = Animal-&gt;new( name =&gt; 'seahorse' ); $seahorse-&gt;respirate(); # "I'm a breathing seahorse!"
If you look back, you'll see how I demo Moose and Roles in a previous example. Just because you have Moose in your toolbox doesn't mean you have to use it for everything, and it doesn't mean everything other than Moose is wrong. It certainly isn't worth getting angry about. Calm down a bit, this is just sample code demonstrating very simple abstraction. It's nothing to get upset about. Finally, be careful using words like "operator" for things which aren't operators. It is very important to understand the fundamentals of the language, and that's why I focused on two methods here which weren't using CPAN. If you don't know how to do these things without CPAN, you really don't know your fundamentals. jplindstrom is right in that I certainly shoe-horned the re-bless example here a bit too much (I would agree that re-bless isn't terribly useful for this purpose). I really should have come up with a stronger use for re-bless.
Moose is pretty widespread and readable. Alternatives like Mouse can be used to optimize performance. I would start developing with Moose and swap in alternatives as necessary for performance.
I think it is important to clarify that Moo is not 100% compatible with Moose. https://metacpan.org/module/Moo#INCOMPATIBILITIES-WITH-MOOSE (BTW, shouldn't Moo really be called "Ose" since it is basically Moose without the (M)eta?)
More like "Everything is better if we make a factory class!"
Parrot started out life as an offshoot of Perl 6, just as Perl 6 started out life as an offshoot of Perl 5. A few years later Parrot had completely different infrastructure (repos, mailing lists, wikis, irc channel, etc.), its own legal foundation, a mission that didn't mention Perl 6, hosting of dozens of languages unrelated to Perl 6, and its own separate identity "speaks your language". But I wasn't talking about the past, notwithstanding your insertion of "was" in to your (mis)quote of what I said. **I was talking about now, September 2013. Are you really pedantic enough to argue that Parrot *remains* a Perl 6 project?** Edit: added bold
I know i'll sound crazy but even if i like perl's syntax, twigils look like a hack. What's the damage of having a keyword for 'private' or 'public' maybe? The usual criticism i get when showing Moose or the like to non perl programmers is that it looks like a hack. Why preserve the hack syntax? I just want perl to be easier to grok for beginners (and parse) instead of saving maybe a few keystrokes. edit: self worked fine for python and the like, maybe use that?
It's pedantic to expect you to get the history right? Fine, I'm being pedantic. Rakudo used much of Parrot's infrastructure up through the first several versions of NQP, though why that matters is beyond me caring. The word "offshoot" is also misleading, but I expect that from you. Why do you think the mailing list was called perl6-internals from the start?
It looks like the comments on that post are closed, so: &gt; What happens when you pass an array into a function? &gt; How do you pass one or more distinct arrays into a function? Both these questions seem to be testing the same thing, a bit redundant IMHO. &gt; Where do tests go in a standard CPAN distribution? &gt; How do you run tests in a standard CPAN distribution? Are these questions really relevant at the basic level you're aiming to test, given that most people just use `cpan` or `cpanm` on the modulename and go about their business? These may be good things to know, but a bit jarringly different from the level of other questions in this list. &gt; How do you ensure that the default scope of a variable is lexical? Could you explain what the "default" there means? To make the scope of a variable lexical you use "my", but why say "default" there? &gt; What is the difference between reading a file with for and with while? I'm with the other commenter in that neither of these is a file reader, and that's not just being pedantic, I don't even know what you mean by "reading a file with for". 
Is "Hamburg" some kind of code name for a new version? The article assumes I know what it means but I have no clue. It's good to see a well-maintained Perl module though, that's sadly becoming a rarity nowadays! 
It isn't just you, I see this more and more especially on PerlMonks. People who's sincerely trying learn are laughed at, insulted, and pointed at either utterly ridiculous or needlessly overcomplicated solutions simply because that method uses their favourite module/feature. Not sure what the reason is though. 
&gt;In Perl, we would do this with roles. I didn't even mention roles above, but I think I could do another whole post on Role::Tiny, Moose roles, Moo::Role, and mop roles. Great, I can't wait, bring it on! 
I think it's because Perl is no longer a "trendy" up-and-coming language like Ruby, JS/Node, and even lags behind Python in terms of a nice scripting language. So it's like there are only old heads, not young guns.
Well, up until recently I was part of the first wave response team for outages and these days we have enough devs that I am now part of the second wave response team. And the fact is no sane business calls out someone like us in the middle of the night for an edge case that affects one or a few customers -- that is what the Customer Service department is for. Indeed despite being a senior dev there is very little that I can do to actually directly help a customer. I can fix things so the *next* customer doesn't see that problem but our customer care department is going to have to fix things for the affected customers no matter what - if we are going to upgrade them, or change their hotel, or whatever, then someone with different responsibilities and skills than me needs to do it - heck, there is a decent chance I don't even speak any of the languages the customer or the hotel speak, so I couldn't even understand what the problem is! Since we are a large scale international business and we sell something that is very dear to people, where they are sleeping that night, we have a very competent and efficient customer care organization. There is 24 hour coverage, multi-lingual support in a gazillion languages and people with authorization to solve any customer issue that might come up. For them a technical issue that affects a very small part of our business during the night is no different from any other minor business issue that might come up, like a hotel closing due to earthquake, and they would not involve an engineer until working hours. And yes, I consider myself lucky to work for a sane company. :-)
I actually find "-w" just as useful for typos, and more so for other errors like bad file descriptors.
Neat!
It points to another module "Compiler::Lexer", but I can not find such a module on that GitHub repository.
He is referring to this https://github.com/goccy/p5-Compiler-Lexer 
Here's a list of recent blogs, most of which I deal with Catalyst development. http://profile.typepad.com/d5931 There is some plan to update the Catalyst website, and I will make sure that the development process is spelled out. 
Everybody has to create their own for some reason. The newest kid on the block is [Class::Tiny](http://search.cpan.org/dist/Class-Tiny/).
My guess here is that web scraping might be one of those jobs where a dedicated module isn't vital (from the fact I see quite a few on CPAN gives me the feeling that the job isn't as readily made generic as one might think.) You might want to look at Mojo::DOM, as I understand people like it and I am pretty confident SRI will support you with it for a while. good luck.
Also check out -- https://metacpan.org/module/Class::Tiny
We use a combination of www::selenium and test::more at work for functional testing. We've started work on synthetic monitoring and ideally we want to drive phantomjs using selenium, we're not quite there yet, my understanding is that frustration has reached the point of writing it in house. I wish I had a magic bullet for you, maybe someone else does.
A lot of the perl web frameworks offer testing suites. If you're not running a framework (Dancer, Mojo, Catalyst) Selenium is probably your best bet. You can always run selenium in headless mode with ice weasel , you may just have some issues with js. I am pretty inexperienced in running selenium in headless mode but I have tried it and know it *works*.
What's Rstudio? I assume it's Visual Studio for either R or Ruby, though I would have to Google which. In any case, the answer is "kind of" -- Google for details.
Yeah, we are using a custom framework...I'll have to take a look at running ice weasel headless. Thanks. 
Reading this further employs my wish for a better solution. I've even thought about writing/forking my own solution. 
The real answer is, "switch between windows", though if you just want a constant compilation of your stuff done on a timer, or on file changes, you've a few options. Eclipse has a Perl plugin, EPIC. It comes with all the questionable features of using Eclipse, though. I ditched it fairly fast. These days, I use vim with a host of plugins and customized for my workflow. When working with Catalyst or some other similar app, the "server" script auto-reloads on changes. When I'm doing something else, I'll usually use [inotifywatch](http://linux.die.net/man/1/inotifywatch) inside a `while sleep 5; do inotifywatch ...; done;` loop. 
There is [Padre](http://padre.perlide.org/), an IDE written in and for Perl.
I'm sure that your text editor of choice has an output console somewhere. If it doesn't, time to switch to vim.
Just d/l-ed this. Is there any way to get the output into the same console? The 'output' window shows me nothing, and a separate window (Xterm) pops up with the output
It's slightly better than bearable. I wrote some functional tests for the zimbra webmail interface, I had more issue with the crap code than WWW::Selenium
See also http://www.reddit.com/r/perl/comments/1mkqz6/headless_web_browser_with_javascript_and_xml/
I have a very hard time believing that it's even possible to replace manual browser testing (w/all sorts of different version of different browsers) with a headless &lt;anything&gt;. Even with non-headless, actual browser automation like Watir, it's still super-challenging, considering history and state, things simply 'not looking right' stylistically, heavy javascript and DOM manipulation w/single-page-apps, and hordes of other considerations. If I'm wrong, I'd love to hear it because I've long considered this a difficult and largely unsolved problem. I can see how some automation toolkits can help with some pieces of the problem however.
At least in the case of Class::Tiny, [he tries to tell us his reasons](https://metacpan.org/module/Class::Tiny#RATIONALE).
If you use custom web engine, it's better to implement a testing framework for it.
We use Selenium::Remote::Driver a lot, it works pretty well for us. The Selenium IDE records horrible test code, selenium will be a lot more useful for you if you write your own code. Three bits of advice: 1) Setup a remote selenium head. This will save the focus stealing issues and ensures things run in a more consistent state. Make sure you work from a perfectly clean test basis each time. 2) set_implicit_wait_timeout is your friend, use it to deal with ajaxy pages. 3) page objects and other good testing practices will make your testsuite a lot more maintainable, some kind of CI system will make your testsuite pay off much quicker. 
WWW::Selenium uses the old Selenium RC protocol. That was replaced by the webdriver protocol. With selenium 2.0+, when you speak SeleniumRC protocol to the server, it is translated through the RC -&gt; WebDriver converter on the server. I strongly recommend using Selenium::Remote::Driver instead. Google's Tech Lead for Browser based Testing talking about migrating off SeleniumRC: http://www.youtube.com/watch?v=cSLmfegT36A
Ah, got it. I had to deal with a similar problem; I ended up recording wireshark traces and tweaking/playing them back (more or less), sloppy regex assertions (the GUI was to a NetApp appliance), etc... I probably should have used WWW::Scripter -- the task was such a pain in the ass! The HTML was crappy and not XML compliant, etc ... yuck. 
I've found inotifywatch + prove is a great combination to get in the habit of using.
That linked [adoption candidates](http://neilb.org/adoption/) page itself is very useful, thanks to neilbowers for both this nice writeup and that work. 
Interesting. Some people like Moose, some don't. I used it i one big project, and that exp wasn't good ) I guess we didn't know how to cook it ) Since that time, no more Moose in my projects :)
Can you elaborate a bit? What was poor about the experience?
Emacs has a \*compilation\* buffer which can be used to run Perl scripts or tests. If you're using [Devel::PerlySense](http://search.cpan.org/~johanl/Devel-PerlySense/), it's easy to run the tests/scripts correctly. Look here for [docs and a screen shot](http://search.cpan.org/dist/Devel-PerlySense/lib/Devel/PerlySense.pm#Testing) of what that looks like. For some things you don't even have to run anything. You can get [syntax checking highlighted in the source](http://search.cpan.org/dist/Devel-PerlySense/lib/Devel/PerlySense.pm#Displaying_Code) (and also Perl::Critic if you want) as soon as you save the file (screen shot of that). 
No, they don't ignore it, they *used* to ignore it because there was no good Moose-lite, now they basically just recommend Moo.
That would probably just make me write tests that always passed. ;)
So I should code my project for your environment? I mean, I'm sure there are plenty of people who don't like Moo or Mouse and would have the same reaction if I put my code up with Moose dependencies. So what is the solution?
In general you shouldn't feel forced by any of these choices. If I write some code and put it on CPAN you can use it and not be forced to use Moo or Moose or whatever my shared open source code uses. Use plain old Perl blessed classes if you want (I still do sometimes when it makes sense to me). All you must do is install the distribution dependencies. Personally I have no trouble installing Moose or Moo and I think you won't either if you have a reasonable Modern Perl setup. As a CPAN author I tend to use either Moo or Moose based on the context of the intended use case for my shared code. If I am writing Plack Middleware, I would likely use Moo or even the basic system that comes with Plack, since I want lightweight and to be a nice player in that ecosystem (I know Plack users expect this light touch, no strong opinions approach). On the other hand if I am writing Catalyst code, I don't shy from using Moose, since Catalyst already is Moose in core, so my choice has no additional burden on someone who wants to use my code. That is how I do it, but other authors are free to do as they wish. As a Perl programmer using CPAN all you need to know is the popular approaches and the relative merits and disadvantages of them and to consider the needs of your project and what is in the best interest of your client. 
great content, but the way the code looks in that blog hurts my eyes. maybe my eyes are getting old, but grey and black isn't great to read.
Direct link: https://archive.org/details/sfperlmongers "We're pleased to announce the new SF.pm collection on Internet Archive. This is where we will be storing and serving up all of our SF.pm-related media. For starters, it's now hosting the video and slides for our most recent event: Adam Kennedy presenting a Few of His Favourite Things. Please have a look and let us know what you think!"
&gt; So I should code my project for your environment? Of course not. But if you code your project using Moose, then any code using it will have a large number of dependencies and slow start-up. If either of these is a problem in my environment, I can't use it. That's not your problem, but it does mean that your code is that much less useful to the rest of the world.
[Here ya go](http://oylenshpeegul.typepad.com/blog/2013/09/thats-how-we-role.html)! I just continued the same example. I'm not entirely happy with it.
Eh, sort of. UAV::Pilot is for homebrew toys. It isn't like the US DoD could or would release such code for the "real thing".
I'd be surprised is the DoD used Perl to control their drones...
How about some cheaply made Linux shoveware games that run in text mode so I can look like I am working. If you really want to market Perl well, make the games multiplayer over a network or have a csound audio backend.
I am okay with cutting out some cruft or maybe making the standard library more modular.
I use: perl -lne'print eval'
True. A little vertical spacing would be nice too.
As a module maintainer on cpan, it is already a huge hassle sometimes to deal with multiple versions of perl on multiple platforms, particularly when threading/forking/XS are involved. Forking perl would only compound this. Ultimately I think the reason it hasn't happened is because it would be near-impossible to gain support. For instance Schwern has created perl5i, and despite his clout, perl5i usage is not a big percentage of perl usage (afaik). MST has attempted to get support for pumpkin-perl, theoretically he could fork perl to just make it happen, but he is a smart guy and has so far opted not to do that. I cannot speak for the whole community, but I personally think that a consolidated effort to improve core, by the core maintainers, as we have now results in a more cohesive community. CPAN is the real power of perl. Forking perl would potentially lead to fragmentation where some modules only work on one of the forks, and possibly competing modules that target a specific fork. Also lets not forget perl6, for a long time perl5 improvements were minimal, and little effort was put into perl5 because of perl6. In the last several years perl5 and perl6 have been recognized as the separate entities they are, and perl5 has once again picked up speed. But there are still people who would argue that there is no point in forking perl5 when perl6 will be finished by Christmas (but nobody knows what year).
There are, you may be just now aware of it. Ruby was the first, then came qore, perl5i and kurila, and recently perlito, gperl and p2. Improving core is not working out as there were no new MAJOR features added since years, even those which were discussed back in 2001, before perl6/parrot. p5p perl lost native threads and types and will make no progress with signatures, better parsing, coros, threads, optimizations (e.g. readonlyness, types, methods, inlining, efficient vm, ...) and an optimizable OO model. Signatures will get into 5.20 in a rudimentary way, parser hooks (macros, destructuring) are stalled, and the rest is not being worked on. 5.22 might get native but inefficient roles.
Aren't Strawberry and Active Perl forks of Perl?
I didn't hear about most of those. I also didn't know Ruby was a fork of Perl.
They're distributions of Perl. As of Perl 5.005, the WinPerl fork merged into the core Perl distribution, and Active Perl is almost entirely pristine.
&gt; I also didn't know Ruby was a fork of Perl. That's okay; neither did Matz.
The problem with parser hooks, aside that the idea itself is problematic, is that they did it in XS. Having Perl parser hooks would have made much more sense. 
Because perl is very complicated, and there are not many people capable to work on the core anyway.
It's not. Perl is among the languages that inspired Ruby, but Ruby is absolutely not a fork of Perl.
Woosh :) But technically, you're correct of course.
No 'technically' about it: perl5i is not a fork. I can see why my message may have implied that it was, but that was not my intent. My intent was to highlight how difficult it can be to get users to adopt something new, even when backed by big names. Of course there are exceptions too, moose comes to mind.
Mason?
Guessing you want more than print a http header and a blank line and wrap it with pre and slash pre, although thats how I rocked it in 1996 or so.
Serving plain text as "Content-type: text/plain" would not be nearly 2.0 enough for this guy.
It's easy to commit something to new project, and hard to old.
Essentially, I think you're asking about a [CGI script](http://www.tutorialspoint.com/perl/perl_cgi.htm).
What do you mean by "command based"? Like a bunch of CLI programs? In that case, just using GetOpt::Long would work. There's nothing particularly special about Windows versus Unix in this regard. If you mean like a full Perl shell, you probably want to look at the ReadLine libraries. I'm not sure how well these work on Windows, though. I [wrote up a blog post](http://www.wumpus-cave.net/2013/09/06/perl-modules-anyeventreadlinegnu/) on AnyEvent::ReadLine::Gnu a while back.
&gt; Perl parser hooks would have made much more sense. My parse of what you've written has generated an ambiguity warning. Is your point that hooks are OK provided they are first class elements of the language and not something like XS? What is your view on DSLs?
Except that it isn't 1997 any more.
[Dancer](http://perldancer.org/) [Kelp](https://github.com/naturalist/kelp) I like both of those micro frameworks. Quick and easy, but powerful. Mojo is nice too, but I prefer these. 
Please explain what you mean. Have you heard of Cygwin?
If your needs are pretty simple, just use HTML::Template. After a certain level of complexity you need a framework but for one page? HTML::Template, which is pure Perl and has no problem dependencies, should be fine. 
Well, it ain't 1979 either, but this guy wants to implement a teletype.
I second Dancer as the simplest if you want to get up and running quickest without learning too much about how the framework works. It won't tie your hands too badly if you decide to get more complicated later on either. Something like Catalyst or Mojolicious sounds like it'd be overkill for your needs and maybe more work to get up and running if you've never used them before.
You mean writing a bourne again shell equivalent for Windows? Might be tough due to the close source nature of Windows but I would imagine writing that in C would be a better idea. I think windows people use power shell or something like that but I don't use windows so I really don't know.
Sadly I missed the Stevan's OO presentation last week but I'm not going to miss this!
I uh, what? Edit: Doesn't it also say Practical Extraction and Report Language at the top?
They are all backronyms.
Funny you mention this. I just read this for the first time last week and I have been using perl for 10+ years.
I would use Mojo....not external dependencies and you can go from lite to full blown.
How is Mojolicious overkill and Dancer not?
Oh no, you told people!
Yes, they should be a part of the language, first class elements. or maybe in the B:: namespace. but not XS. I don't like DSL. every time someone suggested it to me, it was a PHB that liked the idea. (with the famous line "then non-engineers will be able to modify the program!". yeah right.) I usually end up making some abstraction objects that hid all the details and the writer uses high-level domain-specific operations. Anyway, if you are making a DSL, make your own parser and don't force Perl's parser to jump hups. 
I agree, Mojolicious, especially the Lite flavour, is probably the simplest option here.
We already change how the parser works without using C - by method prototypes and 'use'ing modules. there is no reason why we can not have a perl command that injects new callback to the parser.
Those don't do the same things.
I did. what is that I hear? A knock?
I'm not getting it. Do you need to do this multiple times? Is it on a computer you control? Short answer, you can do anything in a script which you could do in the command line by putting it in a `system()` call. Security and permissions are probably going to be an issue of course.
Yes, it's done multiple times, there will be and index-like page, with links to other sub-pages that are simple overviews. From those 'overview' pages, where I already have a path to an archive and a destination path, I want to click a button and the web app will copy the archive to it's destination. The problem is that it's done in CGI, and I want to also have a progress bar. I knowI have to use javascript and ajax calls, but I don't know how to run perl system() calls with javascript/ajax 
Well I feel like we're giving you enough rope for you to hang yourself, but ... an AJAX call is just like a browser visiting a URL, and cgi programs are scripts run at URLs. So make an AJAX to a cgi URL which runs `system("copy $foo $bar")` and your copy will happen. As for progress, I have no idea what happens when Windows copies a big file from one place to another so I wouldn't know where to start.
I got working the part, where sending the call to a cgi program, and that in turn copies the file. I'm interested more in the part of progress bar. The way I do it now, is to write in a file how much is copied, as a percent. I'm curious how to write something of an event emitter, so that whenever that percent gets changed the script should sent to the front-end a message with that amount.
Care to elucidate? (Genuine question in order to learn more).
I'd do it by getting the original size of the file from somewhere, then doing '-s $dest_file'. With those two numbers, you can calculate a percentage. By making repeated AJAX calls (perhaps every 10 seconds or so) to a script that calculates that, you can update a progress bar with JavaScript on the frontend.
As a suggestion, the web-app could be used to insert what should be copied to where in some database. Then let that insert trigger the real sync. Advantage would be the separation between web-app and sync routine.
This mess is the main reason I almost always avoid `$_` itself (with a few exceptional cases like `map`s or `grep`s). It seems like too much bug-potential for too little benefit. 
Mojo Lite is good, but personally, I'm just a fan of Dancer. I don't think Mojo is overkill though, just not my first choice. 
https://en.wikipedia.org/wiki/Perl#Name
This is a dream come true!
Gotchya on the hooks. Have you ever found it hard work to keep the high-level operations simple and the abstraction objects performant?
My experience with Mojolicious is that it can be simple, but you do have to read the docs to find that simplicity. Those docs (great though they are) are intimidatingly huge and lead you towards thinking "how much of this can I get away with not reading, or am I going to miss something important?" With Dancer, I was up and running from just reading the synopsis and then editing the code. I didn't ever feel I had to read further or would regret not having read further. So, if you know the ins and outs of both systems, there's no real difference setting something up that's simple. If you don't know both systems, IMO Dancer gets you up and running faster. YMMV, and taking time to ask reddit and read replies probably takes longer than either. :)
Searched for XML to test it and found out about XML::Rabbit. And it looks awesome. Wish I had this about a month ago, I might have used a different library :) I'd suggest dropping a firefox/chrome/whatever search button thing onto the page so people can add this to their Search Engine lists.
[I Stopped Parsing XML thanks to XML::Rabbit](http://www.modernperlbooks.com/mt/2012/10/i-stopped-parsing-xml-thanks-to-xmlrabbit.html).
Yeah, I am not a web designer, nor do I feel I should need to be. I already have an option to export the output as an html file or a text file, and I can tell you that the html version is generated by something not much more complex than that. 
Maybe, but I want a framework wrapper because in addition to not being a designer, I am not a web security expert. 
Okay, I'm going to check out Mojolicious lite, in the hopes of challenging myself to tackle learning the full Mojolicious at some point and leveraging what I learned with the lite version. Probably learn how to build a DB backend too. I am fairly new both to formal Computer Science and Perl (I'm going to my first Perl meetup tonight :-) ) so I appreciate the advice as I learn. I will check out Dancer, Kelp and Catalyst (not necessarily in that order) at some point soon. Anyway thank you again, r/Perl! 
In the problem domains that I worked on and needed that kind of abstractions, performance were not important. (mostly automated testing) The problem with that kind of abstractions, is that they usually leak in one way or another. unless you have some very rigid op set, people always want to do something that is not covered in the abstraction. So I usually end with "half abstraction". for example: I created a Selerium (website testing) suite. so I had high-level commands (i.e. "click Entry-&gt;create from the menu", that is a lot of Selenium commands and page searching) but still left the regular Selenium commands to be available. (i.e. to click on a button that only exists on one screen) Other example is one time that I created a test suite for location engine of a mobile phone. so each test is basically: move the phone to pos1, wait, verify, move to pos2, wait, verify and so on. so I had functions for moving, waiting and verifying. but the script still had access to the phone itself (for any other command) and other testing equipments. (the moving was done using a private base station and channel simulator.. cool stuff)
Perl's "insane levels of backwards-compatibility" are exactly what make it useful.
I'm on a phone so can't give this the answer it deserves, but essentially CGI is old, slow and relatively hard to work with compared to PSGI and the awesome tools (many of which are mentioned elsewhere in these comments -- e.g. Dancer, Mojolicious) that have been built on top of it. CGI is probably still fine for small simple projects, but recommending it steers newcomers away from the alternatives that will serve them better as their needs develop. If you want more specifics reply, and I'll try get to it over the weekend :-) 
This is really cool, i'll try it later.
Devel::REPL works on win32. If not, bug reports and patches welcome!
Thanks. Something to look at. I've found CGI scripts work well for what I've been doing, better so since I dumped the behemoth that is CGI.pm, but that's no reason not to look at other possibilities.
It's been 2 days and I still can't work out what this means :-/
Perl::Critic is not a replacement for fluent programmers.
crosspost on [stackoverflow](http://stackoverflow.com/q/19213995/1521179)
Yeah I ended up making an account and posting the same thing over there after this post.
POD is by design (and name) not able to do complex things like this. While it's ostensibly useful, I think the reasoning is that the author should be focusing on writing actual documentation, not invoking the right magic to get an ordered list to behave properly. That said, something in Pod::Weaver might work for you (I have no idea, it's a huge namespace that can do a lot for you), or if you're feeling particularly frisky, you can write your POD into a Template Toolkit template and process your templates into `.pod` files when necessary. I'd suggest against both.
[Really this is nothing new](http://imgur.com/a/4IjSC)
&gt; I'd suggest dropping a firefox/chrome/whatever search button thing onto the page so people can add this to their Search Engine lists. That's an excellent suggestion. Thanks.
The problem is not incrementing the numbers, but keeping it ordered when you add items in the middle, re-arrange them, etc.
Upvote for frisky Perl coding. It's the only way!
Thanks for the feedback; I'm glad you enjoyed the post! I was thinking about putting more information like that in, but the post was getting pretty long, and it important to me that the reader remain interested throughout the post enough so that he/she would research that extra information on his/her own. 
See https://news.ycombinator.com/item?id=6511251 
Can someone ELI5 for me please? 
This may not be helpful but I looked into using Perl for things like this in the past and ended up using Autoit instead: http://www.autoitscript.com/site/autoit/
Well you have some cool frameworks like Mojolicious and Dancer, or Catalyst. Also there's the Plack shenanigans. Many OOP options are out there now too if you are into that kind of thing, and well, there's a general consensus on not using CGI anymore. But you can do it if you want, you are a free person. The frameworks i named are feature packed, and "modern" as far as i can see.
So aborting on the CGI interfaces, what web server is being used to front perl these days? nginx? apache? How standard are the OOP options, or do they all vary semantically (even if slightly)
Moose is popular for OOP, but has a big set of dependencies: http://search.cpan.org/~ether/Moose-2.1005/lib/Moose.pm You can still deploy with Apache either using mod_perl or mod_wsgi. 
There's the Moose (Mo, Moo, Mouse, Moose, and maybe something else) family of things for oop, from light to heavy, and they share the same syntax even, so you can just scale as you need features. They all have a startup penalty but it's nothing compared to the startup time of a java program or a rails application for example. Your mileage may vary. As for what people are using for delivery, there's this thing http://plackperl.org that should answer your questions i think.
I use NetBeans for pretty much all my coding work. So, for Perl I use Netbeans plus this plugin: http://plugins.netbeans.org/plugin/10668/perl That plugin is fairly basic (no debugger support, for example) but it meets my needs.
Sounds like that will give rise to a family of Perl-like languages, is that the goal? 
Apache httpd or nginx or even Varnish as a caching proxy in front of a PSGI server like Starman is a nice approach.
programming directly in mod_perl is out of fashion, unless you really need to mess with Apache's internals. Now days everyone are WSGI (or as we call it, PSGI) compatible, and run on every environment that is PSGI compatible. (everybody) We have our own PSGI servers, such as Starman. As for frameworks, the most popular now are Catalyst (stable and have wide support) Mojolicious (still advances rapidly) and Dancer (lean web development) Other things, you should check out Moose for objects, and DBIx::Class for DB access. Try::Tiny. Take a look at the [Modern Perl book](http://www.onyxneon.com/books/modern_perl/index.html), it is free to read on the web. (but you can also buy it) 
Not so much a family of different languages as multiple dialects and v5/v6 pidgins. Some projects focus on language extensions (Moe), others primarily on the underlying Vm (p2). But keep in mind that the Perl5 syntax is already somewhat flexible, see for example p5-mop, Moops, signatures, Function::Parameters, …. The various Perl11 projects will differ mainly in how much shiny syntax they support out of the box, and how compatible they are with existing code. The elephants in the room are XS extensions, which are tightly coupled to `perl` internals. The core API can be mocked to some degree, but e.g. most projects do not use reference counting as a GC strategy, which causes a conceptual mismatch. One of the more advanced projects in this direction is [Perlito](http://perlito.org/) – it can run considerable subsets of v5 or v6 *in your browser* (it was simply compiled with Emscripten).
Would Apache in front of Starman have advantages (of some kind) over simply Apache + mod_psgi? (Newb question obviously.)
Here's some links to applications on Github that are all in the Modern Perl way: https://github.com/dpetrov/formhandler-example ^^ Great example using HTML::Formhandler, Catalyst with Jquery and Twitter bootstrap. Worth a look and consideration. Mojolicious probably has the most stable support for modern stuff like Websockets. Catalyst has some support for this but its considered beta level, examples here : https://github.com/jjn1056/Perl-Catalyst-AsyncExample Web::Simple is another very lightweight web framework that plays well in the Plack ecosystem and is built on Moo, which is very similar to Moose but without the startup penalty (and can inflate to real Moose when you need it). If you prefer to build things your own way, Web::Simple is probably the best approach. see App-EzPz or App-SCS or App-IdiotBox in git.shadowcat.co.uk for examples of that. Dancer and Dancer2 are Perl's version of the popular Sinatra so if you've used those and liked them is worth a review. There's other options for Web development, if that is what you are looking for, but I think those cover the ones with the largest communities at this time. Definitely don't use mod_perl, that's where otherwise decent applications go to die. Regarding Perl and cutting edge, I think Perl's OO with Moo/se and the like are really quite good and PSGI is a very strong version of the WSGI idea. We also have pretty good support for async IO, but maybe not as well documented or as pervasive as say it is in node.js. Perl also supports a very wide array of traditional databases, nosql, etc and strongly supports popular search engines such as Elasticsearch so I think Perl has a lot of goodies. There's always room for involvement and for stuff to get better! If you do decide to work with Catalyst on the web side, I'm always looking for volunteers to help test out new features and drive development.
Is perl5 really slow (compared to its competitors CPython, MRI, PHP)? Let's not include JavaScript/v8 in here.
Moo and Mouse are more or less equivalent. I can't imagine why you'd move from to the other. I've not seen anyone recommend Mo for real use either.
I have no problem with mod_perl itself, but for most of the projects that only need to handle requests it is a gross overkill and unnecessary complex. So it is not bad, just out of fashion. It is still the right tool for some of the tasks. Moving to fcgi can give equal request handling performance (YMMV) for fraction of the complexity. Which is good, as this is most of the projects need anyway. And after you PSGI container testing, please post results :-)
Oooo, makes sense. Thank you.
I haven't used Ruby extensively. Could you explain to me how Ruby differs in those points when compared to Perl? From what I have read, it has a pretty similar situation, except that mature alternative interpreters exist that should provide more performance.
Wouldn't you configure Apache to handle the static requests in either case? Or do you mean that starman would still be responsible for the static requests but would pass the whole thing up to Apache to deal with the slow client?
You may have a different definition of "many" than others. I had to add/update 15 distributions to my build when I added Moose. That's not including test-only modules.
Hi Sosaiththespider, Usually the first thing I do when trying to solve a problem with Perl is to look on the CPAN (Comprehensive Perl Archive Network) to see if someone else has already solved my problem. You can use the websites http://cpan.org and http://metacpan.org to search for modules. After using either one of those sites and searching for "Bio" I came across the BioPerl module which may be useful to you (https://metacpan.org/module/BioPerl) That page links to some other good resources and gives an overview of the module. As for the problem itself, are you trying to find what is essentially a palindrome in a sequence? For example, the word racecar is a palindrome: abcd**racecar**efgh Or do you mean something else? *Edit: It looks like you probably mean something other than a palindrome: http://www.bioperl.org/wiki/Reverse_complement 
I'll leave it to more experienced perlers to suggest actual code, but here's my first crack at an algorithm. I'm not claiming it's the most elegant idea. Before doing anything else, you'll need to generate the complemented sequence. That can done efficiently using the tr function. You will need to iterate like crazy to generate all possible starting sequences. A pair of nested for loops can be used to generate all the valid combinations of offset and length to be applied to the substr function. You would attempt to find the substring in the complemented string using the index function. In order to find all matches for a given string, you would enclose the index function in a third (innermost) loop so as to continue searching for all matches by incrementing the starting position parameter until there were no more hits. You would save each substring and a list of all its match offsets by inserting them in a hash of lists. The substring itself would be used as the key, and the list would contain the substring's offset and length followed by the offsets of any hits. For efficiency's sake, before entering the innermost loop, you would check to see that no corresponding key already exists for each prospective substring If a given sequence had already been searched for than it would be redundant to do so again. Otherwise, you would insert a new key for that unique substring into the hash along with a list of its offset and length as data. If any hits were found, their offsets would be appended (pushed) to the list. After all the searching had been completed, you could do interesting things like things deleting the keys for sequences that had no hits, and sorting the remaining keys by their length, and generating a report. This is a cool problem. Good luck.
You can try coming over to /r/bioinformatics, where this might be a bit more on topic. That being said, here's some quick code: $rev_seq = reverse $seq; $rev_seq =~ tr/ACGT/TCGA/; That'll do a reverse complement of the sequence. You can then use an established program (e.g. BLAST, BLAT) to compare the two sequences and find areas of high identity. Check out http://www.bioperl.org/wiki/HOWTO:AlignIO_and_SimpleAlign
Are you looking to just count complementary base pairs or are you interested generating secondary structures? For the first case, there will be a large number of complementary pairs, but as someone pointed out in this thread, you can enumerate them just by searching each base for it's complement. That's O(N^2) comparisons. If you're actually interested in secondary structures, the simplest algorithm is probably the Nussinov algorithm. There's a perl implementation [here](http://www.movementwithin.com/perl/bf1_web/discuss/algorithm/html/nassinov_pl.html). Nussinov will give you the structure with the maximum number of base pairs. It's not necessarily a realistic biological structure. Nussinov is a dynamic programming algorithm Dynamic programming is a real workhorse method in bioinformatics, so it's a good thing learn and to try to program.
I guess its all relative. I find if you are using a reasonable modern version of Perl and have a modern Perl setup (local::lib, installed Perl for development via perlbrew or other, not using the system Perl) then installing Moose is not a problem. If you have a really messed up setup, where people have been screwing around with installing CPAN modules into the system Perl, usually with root, etc. then yeah you might not be so happy. And if you don't have a normally setup compile chain, gcc or similar and the normal make utilities, you will not be so happy. On the other hand, if you have such a setup, you will find lots of stuff hard, not just Moose. You can use mod_perl but its fallen out of favor as an interface for web frameworks such as Catalyst since it tends to be hard to do upgrades (you are compiling perl into apache, and I find the effort involved is hard enough that people usually stick with whatever perl they started with, also I find it can introduce some stablity issues with Perl modules that are compiled). Generally its thought that separation of application from the web interface is a good practice nowadays. 
Not just because it's hard. I had a client actually see a 30% reduction in resource utilization by changing nothing beyond moving their cat app from mod_perl to FastCGI. This may not be common but it was a significant argument for them.
== is numerical comparison, try using eq.
Bingo. That fixed it, thanks! Awww man, I just realized that had I used a regex test like I had originally planned (e.g. $section =~ m{etc}), this would have been a non-issue. But at least this way I got a solid reminder about numerical comparisons vs string comparisons!
Cool, thanks. My ultimate goal is to change one line but only in the [Xdmcp] section. Here's the current version (with line breaks for readability): cat /etc/kde4/kdm/kdmrc | perl -ne '\ m/^\s*\[(.+)\]/ and $section=$1; \ $section eq "Xdmcp" and s/^\s*#?\s*Enable\s*=.*$/Enable=true/; \ print' &gt; /etc/kde4/kdm/kdmrc-tmp I actually had your regex in an earlier version. I went with the simpler one on the basis that it was easier to read, even though it was less specific. The longer one has a *lot* of square brackets. :-, 
Why are you doing cat &lt;single_file&gt; | cmd rather than cmd &lt; file Just to drive old 'nix guys like me crazy?
If you just want to print the single line, "[Xdmcp]", then maybe this will work: perl -ne 'print "[Xdmcp]"'
I've re-implemented Smith Waterman in perl before, it's not that hard and runs ok for the lengths you are proposing. If you want to learn perl try re-implementing it.
That is probably not a step towards OP's goal.
I like the sense of flow from the start of the pipeline to the end. It bugs me when the source of data comes at the end or middle of the line. Either way is about the same for the shell (except for the extra process invoked for cat, obviously) but I find my way easier to read six months later. Edit: clarification
Programming is a fashion show, and Perl programming is no exception. To be cool, your code should probably involve "Plack", "Catalyst", "Mojolicious", and/or "Moose". Also, it's important to distinguish between "modern" and "Modern" -- the latter is a marketing slogan.
You're right, that's really useful. It gave me this: Argument "Xdmcp" isn't numeric in numeric eq (==) at -e line 3, &lt;&gt; line 1. I'm definitely going to use this from now on. Thanks.
Freelancer here, using perl for almost automation of my house
Thank you for the tutorial. I have been following Perl Maven for a while and this was especially fun as I was a Digital Ocean customer. Should you always use Dancer instead of the older cgi scripts?
Thanks! Yeah, the name is a little awkward, but I couldn't think of anything both concise and descriptive, and eventually I just had to choose a name and go with it.
Oh, been there, I understand. I've even stalled projects for a long while trying to come up with a good name, then said "screw it, it's only a name" and went with my very first choice! :) As they say, "there are only two hard things in Computer Science: cache invalidation and naming things." 
So why not use &lt; file cmd syntax?
&gt; So why not use &lt; file cmd Hmmm, I'm not familiar with that syntax, and I can't find it in the bash, ksh, or dash docs. Are you sure you didn't mean this: cmd &lt; file ...or are you actually leading the command line with the redirection operator? 
...and off-by-one errors.
Yup. I meant exactly as I typed it. Order doesn't actually matter in bash if you put the command first or the '&lt; file' first.
Have you seen Plagger: http://plagger.bulknews.net/trac/attachment/wiki/PlaggerPresentations/Plagger-YAPCNA.pdf?format=raw#40 
Good Lord. &lt;blush&gt; Thank you for spotting that. I can't believe I missed it. At least now I know that the *facility* works and can go looking for what the heck I'm doing wrong in my *real* program (I'll be doubly horrified if it's the same problem there). \*vast feeling of relief\* I'll also consider using *strict* in such circumstances in future.
You should really *always* use strict. It will save lots of headaches in the long run and generally make your code more readable.
On 5.14+, that'd be `$rev_seq = reverse $seq =~ tr/ACGU/UGCA/r` ;-)
I'm kind of a lazy programmer; I pick up enough of a language to do what I need, and then never (well... maybe after many years...) get around to reading up on what some random feature "really does," and how much more is behind it. My Perl tends to look like C++, for example, because I've never really dug into the "Perl idioms" in any detail, so don't know what side effects I can take advantage of (like /$pattern/ being equivalent to $_ =~ /$pattern/). My understanding of regular expressions is extremely minimal -- really hasn't advanced much since I first started using systems that *had* REs back in 1998. I just read the first one-fifth or so of **perlre** last week and as soon as I ran off the end of what I already knew, it immediately stopped making sense and I lost interest. And so it goes. By way of illustration, last week I tried to whip up my own UUencoder/UUdecoder scripts: it included file I/O, various gyrations using pack() and unpack() and ord() and chr() and whatnot, and was probably fifty lines long -- and I finally gave up because I couldn't find the right combination of pack/unpack/ord/char. And that was *before* figuring out how to compute the character to put at the beginning of each line to indicate its length. Then the light bulb came on above my head and I Googled for "UUencoder Perl" (or words to that effect) and found two **one-liners** that did the job. How humliating! The *whole damn thing* in *one line!* I still don't know how they work, except that it turned out pack() and unpack() have a specifier that UUencodes/decodes, SPECIFICALLY. I don't remember ever seeing that before, when I've wrestled with pack()/unpack() in the past, so maybe it's new since 5.6 and my ignorance is semi-justified -- but if not, well, it's just one of those things that I don't even know about, despite having used the language since 1998... So, using strict is just the tip of a very large iceberg of other things I probably "should be doing!" 
I am more interested in a NQP ELF backed. That would have the potential to be far more useful in my opinion. It would be the return of the metacompilers which haven't been seen since the Meta series (for example Meta II) in the 1960s. I still don't comprehend the application, but it would be interesting. 
I already looked, but it didn't give me any insights, however I eventually discovered that I needed to specify the SSL_ca_path in ssl_opts so it would pick up the certificate. Thanks!
Dunno if that helps, but I also read somewhere you need to run `dpkg-reconfigure ca-certificates` and mark the new certificate as trusted in the dialog that comes up.
Oh, I didn't know about non-destructive substitution! Thanks!
You may need to specify the CA file in the ssl_opts for LWP.
I don't think this would be a concern of NQP per se. Aiui ELF would be a particular packaging of a particular backend. So, for example, there might be an ELF option for the MoarVM backend. I started [a discussion on #moarvm about having a single binary](http://irclog.perlgeek.de/moarvm/2013-10-16#i_7721583).
The same way you schedule everything else using cron. Shock and awe!
What it misses out is that while Perl cron jobs may run as "you", they don't always run in the environment you're used to. I nearly always have to add a `BEGIN { }` block to make sure the environment is the same as when I'm typing in a terminal window. If your cron job doesn't do what you expect, compare what's in `%ENV` with what's there when you're at the command line. 
"You may want to add a shebang line to the of the script for the Perl binary you want to execute." Am I suppose to be compiling these things and modifying the binaries?
Excellent point. The first thing I put (or often, forget to put) is a chdir into what should be the working directory.
note it's a szabo project: http://blogs.perl.org/users/gabor_szabo/2013/10/perl-tv.html i usually ignore anything he writes because of his shameless self-promotion, but i'll give him the benefit of the doubt on this one.
No, where did you get that from?
Wait. Craigslist has 'art?' I thought it was grayscale with pictures. 
And I love them for it. The site continues to be clean and easy to use. They've made some small changes over the years, with recent ones being the addition of filtering by rental type (house, apt, town house, etc), mapping locations.
It was sarcasm, and I got that quote directly out of the article. After rereading that line soberly I realize he didn't say edit the binary.
I wouldn't be surprised. I work as a sysadmin/Perl hacker, and I know how people miss even the largest differences, especially when it comes to computers, just because they aren't paying attention. Another new feature I didn't mention (new within the past year?), is the motorcycle section now has a subsection for accessories. No more wading through millions of parts, helmets, jackets, etc.... unless the user doesn't post it in the right section. Judging by your statement, are you perhaps a developer/employee of Craigslist?
Yes, @jzawodn works at craigslist: https://en.wikipedia.org/wiki/Jeremy_Zawodny Lots of people probably are curious about craigslist, how it operates, how it uses Perl, etc. Maybe he should run an AMA. :)
yeah, that was unfortunate about presentingperl. quite a far cry from http://www.confreaks.com/
He is a bit self-promoting, but I don't really fault him for that as long as his projects are useful to the community at large, which they usually are.
You know what's worse than self promoting? Doing nothing and complain about it.
if you're not already doing this, try calling it explicitly with perl c:\perl script.pl arg1 arg2
Voila! Yes, that works fine! But, I already have C:perl\bin\perl.exe associated with the .pl extension in the 'set associations' control panel. Do I have to set it somewhere else too? Or does Win7 require me to always specify perl? 
Works fine for me in 64 bit 7 Professional w/ ActiveState. How are you executing the script? Are you using ActiveState, Strawberry, or something else? Reference: #!/usr/bin/perl use strict; use warnings; if (@ARGV) { print "Count: " . $#ARGV . "\n Args: @ARGV\n"; } else { print "No args.\n"; } C:\Users\(me)\Desktop\InDev\tests\args&gt;perl argtest.pl one two Count: 1 Args: one two
Is your path set properly in the terminal? (Run 'echo %PATH%' ) If you just installed it and just set it without closing your shell, try restarting the shell first.
read carefully. he said "shameless" self-promoting.
See http://stackoverflow.com/a/3013830/100754
Actually personally I don't mind if this PerlTV is a just a YouTube channel, a collection of playlists, or whatever feature YouTube happens to have. What's needed is an organized, up to date, and comprehensive collection of talks (e.g. by speaker, conference, conference year, module names, and some other tags/keywords). Perl does not have any, at the moment.
Windows ignores the commandline arguments when it invokes perl through an "association".
Modern Perl (web) stack for me: 1. perlbrew - isolated perl installs; forget your vendor / distro's perl 2. Carton - can't live without freezing requirements / dependencies. i.e. equivalent of Python's pip and Ruby's bundler 3. App::cpanminus - for a contemporary, CPAN client 4. OOP framework - Moose, Mouse, Moo 5. Web microframeworks - Dancer, Mojo* are hip these days. 6. Plack/PSGI - choice of deployment, from mod_perl, FCGI to Starman, preferrably behind an LB like nginx/haproxy 7. AnyEvent and family - async / evented IO Most of these are conceptually inspired/related-to, or heavily borrows from other platforms such as Python / Ruby / Node. #4 is required as Perl is not a first-class OOP language.
 Edit: Okay it's been 19 hours and this is the second problem (in just as many days) I've tried to help you with that you haven't even replied to. Good luck with all your future Windows 7/perl question posts. --------------------------------------------------------------------------------- Original response: Works for me on 7: #!/usr/bin/perl use strict; use warnings; my $x = `dir /ad`; print "\$x: $x\n"; C:\Users\(me)\Desktop\InDev\tests\backticks_for_dude&gt;perl test.pl $x: Volume in drive C has no label. Volume Serial Number is 8800-F227 Directory of C:\Users\(me)\Desktop\InDev\tests\backticks_for_dude 10/18/2013 03:59 PM &lt;DIR&gt; . 10/18/2013 03:59 PM &lt;DIR&gt; .. 0 File(s) 0 bytes 2 Dir(s) 429,982,265,344 bytes free --------------------------------------------------------------- 1: Why does your print statement not have a variable in it? 2: Can you paste the actual code? 3: Can you answer my question from yesterday about what perl you're using? *Edit: Added script output*
Okie doke.
Yeah, in the last year or so we've actually broken out a number of larger categories into smaller ones to make it easier to find thing. Glad it's been helpful.
Host an AMA? Heh. If I thought there was enough interest, maybe...
Keep 'em coming! 1. Since I have your ear, how about sub categories for types of motorcycles? Sport bike, cruiser, dual sport/enduro, standard, etc.?
* install XAMPP * understand where the root level of your apache server is on your hard disk, probably something like `C:/XAMPP/httpd/htdocs` * put your `hello.pl` Perl script in the root level of that folder * go to http://127.0.0.1/hello.pl or http://localhost/hello.pl and tell us what happens. 99% of the time with newbies the problem is, you don't know that you need to do `print "Content-type: text/html\n\n" ` before the browser can get any output. 
I can't comment on Abyss at all. People used to do "CGI" or "mod_perl" (mod_perl in an Apache thing). The same webserver that serves all of the static content also fires up perl to generate dynamic content (ie, run web apps) (or else embeds the perl interpreter, in the case of mod_perl). This is less common these days. Nowdays, people like to have the perl web app embed a small webserver but only serve dynamic requests from it, and have something like nginx listening for web requests, serving static content, and then proxying the request the perl app's built in http server if the request is for dynamic content (HTML, JSON, etc generated by code rather than stored on disk in a file). For example, nginx will be listening on port 80 (the default port, when you go http://whatever.com) and the perl app will be listening on port 8000 (eg if you go to http://whatever.com:8000). If you request a dynamic page from http://whatever.com, nginx makes another connection to whatever.com:8000 and requests it from the perl app and relays it to the browser. Most popular frameworks work in that later model, including anything that advertised that it uses or is built on top of Plack. For example (bias alert), here's Continuity: http://search.cpan.org/~awwaiid/Continuity-1.5/lib/Continuity.pm. One advantage of this design is that Plack, HTTP::Daemon, etc will all also serve static content for you, albeit not very scalably, so you don't need to set up another webserver at all. Just install the framework, run the "hello world" code, point your browser at http://localhost:8000 or whatever port (eg 8000) it runs on instead of 80, and you can do development without a full-on webserver. Often they'll tell you which port they're listening on if you don't specify one. Another advantage of this design is that it's language agnostic. You can write web apps in any language and they all interface with the webserver the same way. Apache will proxy requests for you, but it's ugly and hard to set up, and most of Apache's features are only of interest to previous decades. It's slow and bloated and has a sad security track record. Again, I don't know anything about the webserver you're looking at using. tl;dr having the main webserver proxy requests rather than run CGI or embed perl is how things usually work these days, and it's also easier to get started on. And, no, sorry, I can't recommend any particular tutorial other than a tutorial on whatever "web framework" you decide to use and then later one on setting up nginx or some other proxying server. 
print "Content-type: text/html\n\n" seems kinda 1995...
This is all correct, but I'd add two things for OP's benefit: * ignore any temptation to use CGI * ignore the scare quotes around 'modern'. This is simply the modern way to do it.
Well, ultimately printing that header (or equivalent) needs to be done -- but yeah, if someone's doing it directly and not having a framework handle that kind of thing for them, I'd be interested to correspond via fax or pager with them about it.
Thank you for the note about the cron. I think in the long run a cron job is really the right way to run this, because I will want it polling the API as frequently as possible.
Yeah I was trying extra hard to be balanced. I use Mojo for *everything* I can now.
Thank you. You've summed up scrottie's notes above well. I think I had been in a loop with the "traditional" model, but I still do want to learn how to properly set up the environment. I should have gone with my gut and used Apache, which I'm more used to doing. Thanks!
lol - thanks, duly noted. question: why avoid CGI, out of curiosity? thank you.
Thank you very much. You are correct: I really am not exactly certain of what to do, but what you've outlined is so similar to my experience with regular web code that it makes sense. For some reason my take is/was getting a little muddied by the tuts I was using. This is the kind of rundown that will help me troubleshoot. I'll do this this weekend. Thanks, 2319.
Can you explain? What makes it an older thing to do?
Balance for balance's sake considered harmful :-)
What's LWP? I was thinking of doing this piece of web code (hence the webserver) because I will eventually port it to an actual webserver where it will run. Would your approach work the same way?
Thanks. I have a lot to learn yet. CGI just lets web servers talk to web code, correct? If you didn't use CGI, how would the web server know what your perl code is trying to generate? I know nothing. Apologies.
Yeah, circa 1996 they came out with CGI.pm... where you go: use CGI; my $cgi = CGI-&gt;new; print $cgi-&gt;headers, $cgi-&gt;start_html; ... but even that's old school now. See Plack and Mojolicious and things (later comments). I still use CGI quite a bit, but if I'm going to have more than just me using it, I tend to look at things like CGI::Fast or pick one of the frameworks.
No worries :-) You either use a specialised server that is designed to run Perl applications (Starman is one to look at; morbo is the one Mojolicious bundles, there are many others). Then your regular web server just proxies the requests to that -- so you can still use your regular web server for static content, SSL layer, etc. Alternatively your web server can use PSGI instead of CGI to invoke your script ... but it's not quite the same.
Google libwww-perl
Plenty of the frameworks can function as CGI (rather than using HTTP::Simple or whatever's under the hood). They're always going to be a better choice, particularly if you're new. The only counter example I can think of is someone that's been doing CGI.pm for 20 years. Convince them to switch... harder. 
&gt; ignore the scare quotes around 'modern'. This is laughably wrong. "Modern" w.r.t. Perl is a cynical marketing slogan. You should always read it with scare quotes.
I accept it's used as a marketing term, but what's your basis for denying that Perl in 2013, with the availability of things like Moose, Catalyst and DBIx::Class is not worthy of the term "Modern"? If nothing else, it's how perl is done today, and by that definition modern... **EDIT**: removed unhelpful edit.
&gt; "... a cynical marketing slogan" Said in a thread discussing easier, simpler, faster, and more flexible ways to write and deploy web applications in Perl in 2013.
You're right, it's a bit old fashioned doing it that way but as jkg5150 says, a) it's happening somewhere, no matter what framework you're running, and b) the OP wants to learn. Let's get a three-line "hello world" out of the way first before we install 300 modules and go MVC. 
&gt; Let's get a three-line "hello world" out of the way first before we install 300 modules and go MVC. He said he has recent web experience in another language, so suggesting he use a framework is probably exactly what he needs. * There's no reason for him to learn outdated perl if he can comprehend the MVC model * Mojolicious::Lite isn't very heavy and is remarkably easy to understand * The Mojolicious docs are clear and come with examples * Mojolicious has a very nice web-based debugger for troubleshooting * Mojolicious is easy to install and setup * He inferred a need for LWP+DBI. Mojolicious abstracts a lot of the lifting and makes it (even more) trivial. So yeah, he doesn't **need** a framework, but there's no reason not to install it and try it out. It will simplify his life, there are plenty of docs and tutorials, and he can get something running in almost no time with very little effort. And it's a useful framework that he can re-use for lots of projects once he's familiar with it.
I just noticed today that Mo only requires 5.6.0, which is a Big Deal for those of us who need to write stuff that's 5.8.x compatible.
OK, so "web code" can mean different things. A perl program that goes out and accesses web pages and loads data into a database does not need a web server. It just runs. One way to think about it is that the program is pretending to be a browser for the sake of accessing web pages. This is where LWP comes in. However I would suggest you don't spend too much time on LWP and use WWW::Mechanize. The other type of "web code" would be a program that produces output that's meant to be viewed in a browser. Another user mentioned that you may want some kind of dashboard that shows the results of a query to your database to show the results of the first program. But you don't need to interact with requests from a browser to write a program to scrape data off the web. The program is the browser.
You could try clarifying your point of view, if you like. How is "modern" perl just a cynical marketing slogan, and **not** easier, simpler, faster and more flexible?
At least until Perl 5.20, CGI is core, making printing it by hand the wrong thing to do in any sense... soon after he'd be decoding entities with regular expressions and wondering why the basics are so hard in Perl... here's an opportunity to start him off on the right foot instead. use strict and warnings while you're at it, etc. Seek a framework right away. telling Apache your encoding and mime type is probably not relevant to webs if you're starting out in 2013. better to not learn to talk to a modem first either... but otherwise I agree with what you say.
and if you need an LWP thing, Mech @ISA LWP anyway.
Thank you.
Gotcha. Thanks for the explanation. 
For me personally, kind of like you're saying, I am inclined to do things the fundamental way first, even if most people jump right into frameworks. I like to see how things work and it helps me understand. I'll use a server stack and just make things work as you've outlined.
I am familiar with MVC. I think I will get into Mojolicious, but I do want to just want to start with a few bare components in an standard (older) methods so I can at least see things working. When this is done, I'll move toward a framework to make things easier and get the benefits you outlined -- especially debugging. I think the things you're both mentioning make sense, but for me personally there's a chronology where I just want to start as reasonably atomic as possible and then use a framework when I see that I'm getting the basics. It's like that itch you get when you have an idea and you just want to see parts start moving first.
This is basically exactly my thinking and preference. Thank you for the input and clarity. Everyone's ideas have been valuable here, and I'm finding some good reasoning for making choices in getting up and running.
PM me for help if you get stuck. 
Moose just requires 5.8.3
That makes sense. That said, I highly recommend [Mojolicious](http://mojolicio.us/). There are a few other major Perl frameworks ([Dancer](http://perldancer.org/), [Catalyst](http://www.catalystframework.org/) come to mind) but Mojolicious has been my favorite. It's easy to work with, easy to understand, quite fast, and they even have [video tutorials](http://mojocasts.com/) so you can walk through the basics. I really recommend Mojolicious after you get your feet wet with [basic Perl](http://www.youtube.com/playlist?list=PLE7511681ABEA8635). Mojolicious reminds me of the PHP [Bonfire](http://cibonfire.com/) framework - based on CodeIgniter, very easy to work with, and quite fast. I think you'll *really* like Mojolicious once you start playing with it.
&gt; How is "modern" perl just a cynical marketing slogan I assume you realize that pretend-anonymous you-know-who wrote a book with that title, and is trying to make a living as a consultant based on that book.
I assume you're ignoring the rest of the question because there isn't a better answer.
Yes, very cool. I've played around with codeigniter. I will definitely take a look at mojo. BTW I hadn't seen Bonfire until just now. Looks like a strong, super clean tool.
Thank you very much. 
No, I just didn't think it was worth my time to write one down. EDIT: Consider the fact that the "Modern::Perl" module uncritically force-imports the "warnings" module, rather than actually thinking about what it does (c.f. [common::sense](http://search.cpan.org/~mlehmann/common-sense-3.72/sense.pod), whose author took the time).
Might be a bit too granular (we can probably solve this in another way) bout I'll put the suggestion in. Thanks!
Thank you for considering it. Might another way of solving it be the following: a tagging / label system, where an object can be in multiple sub groups and therefore allow filtering based on these tags?
&gt; the simplest one is the one that's been working for 25 years No, it really isn't. How is this quicker/easier to get working than, say, Mojolicious::Lite? What's most familiar to you is not necessarily what's simpler -- please, stop pushing this 1990s style Perl, it makes us all look bad.
OK, you're citing MLEHMANN as a positive example, I think it's time we agreed we have nothing constructive to say to one another. It's been interesting, though, thanks.
Drop a file into a directory which will exist on most *nix installations and chmod it to be executable. Everything you print goes to the web browser. Easier. And quicker. I didn't say it was better or followed MVC principles or had a name with Mojo in it. I said it was simple and effective and yes, it has been working perfectly fine since the 1990s, thank you.
Just to burn the straw man away: I don't care about MVC or having a cool name in it, here, and nothing I said suggested I did. All I'm saying is that using something like Dancer or Mojolicious lets you get simple things working faster, which is *exactly* the spirit in which Perl was designed: make simple things easy, and complex things possible. Using CGI will work, of course, but as soon as you get beyond printing "Hello, World!" you're writing considerably more code to achieve exactly the same thing -- which is not better, not easier, and not simpler. Hope that clarifies, but if you're still confused as to my point -- as you seem to be, by your argument -- let me know.
Old-fashioned, inefficient CGI doesn't scale but it's perfectly fine for (low-traffic) internal stuff (assuming you're not having any issues). But if you are, I'd choose (a) Dancer for simplicity, (b) Mojolicious for more power (insanely powerful!), or (c) Catalyst if you don't mind the added complexity for a bit more pluggability (i.e., you can customize everything if you want). If you're unsure, pick Dancer because it's just beautifully simple.
I'm not having any issues so far. Thanks!
You'll see me elsewhere banging the "don't start with CGI!" drum quite a bit, and taking stick from Modern Perl malcontents for that. But I find myself in a similar position to you -- in a company with lots of old Perl that uses CGI, and really nobody around me who knows enough to do anything about it or even that they should. Key point: don't panic. If it's working, and the business is running, you don't need to migrate it tomorrow. You may want to migrate the old stuff, but you may well want to leave it be for now and focus on new features -- these are what keep the business happy and keep the paychecks flowing :-) I'd say, pick up a newer stack of your choice (seriously, it scarcely matters) and try do something new in that, next time something new is required. Make management aware of the ancient and crusty nature of what they have, and introduce them to the concept of technical debt -- while conceding their inevitable point that it appears to work. Over time, migrate -- if you can. When you get stuck, come here or try stack overflow. Good luck :-)
Well CGI.pm is a monster. And I can understand why you want to get rid of it. First thing I'd look at is how much of its functionality you're actually using. It could well be that you could drop in CGI::Lite with minimal hassle and rewriting. Or if you're **really** lucky, it could be that your scripts are like mine, where the only CGI.pm functionality in use was parsing the arguments passed to CGI scripts. Which meant I could drop 256k of CGI.pm for 768 bytes of a custom module.
I have a presentation of one of these applications to the bigwigs this Tuesday. Being just short of freaking out, I'm worried that more is going to be thrown my way and I would rather do things a better way from this point on. Thanks kindly for your help and I'll be back here for sure. :-)
I have to agree here. Stick with CGI.pm
What others are saying: you don't *have* to update. You probably should but you don't have to. What you really need is a plan to move incrementally to whatever new framework you pick. Are you set up so that **your-domain/foo** can run as it does now, but **your-domain/bar** can use a framework? That would be the first step. Then you can migrate at your own pace. 
If you want to stick with rather simple CGI-Applications, you could give CGI::Prototype a shot. It's easier to use and highly modularizeable. I've tried it once or Twice and it fitted those purposes quite well. 
One option is to switch your scripts to FastCGI with CGI::Fast. It allows you to make a (usually) very minimal tweak to your existing code, but converts it to use a persisted server which eliminates the script's startup cost (caused by normal CGI execing the process for each request). I know that doesn't help make your programs more modern, but it *does* help if you are running into any performance problems.
I just moved a out dated cgi system to dancer. I knew catalyst but wanted something simple and easy to get switched over. Dancer is pretty sweet, there are a few dancer plugins that really make it awesome. I would try it out.
He's a jerk, but at least he bothered to pick through the "warnings" grab-bag to figure out which ones were useful to him, and he's not trying to make money from it. But yeah, nothing constructive.
Wrong title. They already know about TAP, since 2010. This article is about calling for a TAP renaissance with nodejs devs.
renaissance of classical perl thought is arguably a catchier title I suppose. .. 
Is my NoScript too paranoid, or are there really no explanations of all the slides?
Here's a [45 minute youtube video of nick presenting what looks to me like the same slides](http://www.youtube.com/watch?v=X2FQHUHjo8M). Hth.
That's a pretty good talk (and yes, same slides), thanks a lot. The `\p` part was the most useful new thing I learnt there, very convenient. 
What you're doing is like petting a cat backwards: perl -ne 'print if /KDUX ....55Z/' $(find $starting_path -name 2011\*) &gt; KDUX_METARS.txt
Hi, I can't tell you how to build a community around your project, but there's nothing stopping you from putting the code out in a public repo (like Github). Make sure you purge your revision history of anything sensitive, like passwords, etc. After that, you can advert it to people and see what happens. How is the application built? If you used one of the common popular web development frameworks, you might approach that community as I am sure most woould love to have a full app they could point to as a success story. 
Just downloaded the program, looks really good, i've never seen a CAD program made with perl before. You'd get quite a praise for it in the perl community. But i suggest that you put it on github.
Perl conference presentation videos are low hanging fruit. I hope they all get into the play list.
[**@stevanlittle**](https://twitter.com/stevanlittle): &gt;[2013-10-26 01:46:15 UTC](https://twitter.com/stevanlittle/status/393916450676543488) &gt;[#p5mop](https://twitter.com/search?q=%23p5mop) 0.02 is now on CPAN w/ most internals re-written in XS, thanks to [@doyster](https://twitter.com/doyster) and [@perldition](https://twitter.com/perldition) (please RT) [#perl](https://twitter.com/search?q=%23perl) [*metacpan.org*](https://metacpan.org/release/STEVAN/mop-0.02-TRIAL) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1p980g%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
You aren't calling main()...
Aaahhh got it!! thank you!!
cool
Thank you! That was it! Forgot to close subroutine.
I didn't know about `mop`, looks like it would be a good improvement to OOPerl if it comes into core. I'm not sure going with the Perl6 type syntax (with twigils and such) is appropriate though, users will have to switch between Perl5 and Perl6 syntax which is bound to get confusing (for eg. the perl5-er in me sees `$?FILE` as $? followed by the bareword FILE, not as a single variable; I can't change that instinct like for a new language either, because that's exactly what it's gonna mean in the non-OO parts of the same codebase.) 
This looks so cool! I would have never guessed that this was written in Perl. The neat thing about putting stuff on the Internet is that people that are interested will find it somehow. I think you'll get people that will want to work on the codebase if you write about it in several places. Even open-source code needs marketing. :-)
Hmm. This feels like messing up an entrenched language's design with more (and worse) syntax oddities for the sake of a new language that might or might not see wide use. I'm actually conflicted about this getting into core now, part of me hopes it doesn't in the current form. While the transition idea is fine and all, Perl5 is also going to be a language by itself for several more years, and having two conflicting syntaxes within it is just awful language design IMHO. Incompatible syntax like new keywords (`class`, `has`, etc.) is fine, but existing syntax for something as fundamental as variables starting to mean something different in _parts_ of the code is just too "yuck". 
No talking about local and state. Not 100% right on our…
I personally dislike twigils, and part of their design rationale is not applicable in Perl5. However, they do lend a degree of orthogonality to object attributes and don't add yet another scoping to scalars: We already have globals (which in a way have a `::` twigil), lexical globals with `our`, lexicals with `my`, and lexical `state` variables. Instead, mop-twigils always have a lexical instance scope, this is good. The argument that the different syntax and semantics in P5 and P6 are confusing isn't valid: These are different languages, and P5+mop just closes the gap a little, thus making it actually easier. I see the parallels between P5-attributes (e.g. `sub foo :bar`) and mop-traits `method foo() is bar` much more critical. I have been using the mop for some time now, and it makes your code much more expressive (despite all the prototype quirks). I cringe whenever I have to write traditional OO with all the `bless` boilerplate, and even the other object systems like Moo/Mouse/Moose are much more verbose than the syntactic sugar offered by the mop. The mop project is an important step towards keeping Perl5 a modern, viable language – especially so when it sneaks into Core.
&gt; The argument that the different syntax and semantics in P5 and P6 are confusing isn't valid: These are different languages That isn't an argument I made though. I specifically said this syntax oddity is only a problem in this case because "I can't change that instinct like for a new language either, because that's exactly what it's gonna mean in the non-OO parts of the same codebase." &gt; P5+mop just closes the gap a little Unfortunately, as you say yourself in the last sentence, P5+mop is going to be just P5 in a few years, which means there's going to be two conflicting syntaxes within P5 the language - which is definitely ugly and makes the language that much more confusing for the newbie. I understand the rest of your argument about the expressivity and making Perl a modern, viable language (which is what excited me about this proposal in the first place), but I feel attempting 100% blind syntax compatibility with Perl6 in mop parts is going to leave Perl5 a worse language than it is. Taking the reasonable parts of Perl6 (like the new keywords) and providing workarounds for parts that clash with Perl5-thinking (like the twigils) would lead to a better cohesive Perl5. 
To me, the moose syntax seems cleaner in most places than the perl6 syntax. Actually, I'm not sure what $?x does. perl6 seems to have traded readability for brevity, which sometimes happens in perl. This might be something that just takes getting used to though. I was half okay with attributes using $!x after staring at it for a bit, but then I found out there is also $.x, and others just to keep things interesting. Better objects should be a core perl5 goal and I applaud the work that is being done to promote it. I just don't know if I like the perl6 ways. :)
&gt; partially transitioned to Perl 6 and therefore ready for the future. I think you misspelled "past" -- Perl 6 had its chance at being the next version of Perl, and blew it. It's doing its own thing now.
FWIW, we are not supporting $.x, only $!x.
One of the reasons we really wanted twigils was because the attribute variables really didn't stand out very well among regular lexicals inside a method body. I found this to be particularly tricky when porting the Plack module.
The only example I can think of where that worked is `say`; all of the other attempts that come to mind have failed for one reason or another. Edit to add: I just thought of `...`, but that's not really a success story either.
Twigils are the most questionable part of p5mop for me, but I'm willing to give them a chance. You're not *really* going to parse `$!blah` as `$! blah`; they look different, and `$! blah` is a syntax error in every context I can think of anyway, since it's a term followed by a term. Having attributes actually behave like variables can make a lot of code more concise and expressive.
What version of perl and openssl are you using? It is possible that the SSL libraries are out of date and contain a bug
Finally you crazy bastards. I thought you guys were completely retarded, this post is starting to change my mind. Finally you're doing the right thing. Thanks. I'm gonna study your code. You better get this through p5p and into the Perl CORE, or I'll be back here again mad as hell. P.S. : Make sure you don't go crazy with all the Moose features. Keep it simple you idiots, go for the Moo syntax first. Again, thanks so much for starting this, you are still not in Perl CORE with this, but you're on the way, this is encouraging and I hope you go full circle on this and make it happen. P.S. 2 : THX_peek_version in mop.xs is a convoluted parsing thing. You can either replace it with a regex or you can go yacc/flex style on it. 
Perl -v in command prompt says 5.18.1. Open SSL... I'm not quite sure. If that's server wise it's not my server, it's a friends, but she keeps it pretty well updated since it gets DDoSed quite a bit.
You should check out AnyEvent::IRC::Client as an alternative.
I've written a lot of bots in perl, some quite complex, and I use a different technique. Not saying it's the best, but it saves a LOT of effort like this. Run irssi (or xchat, or weechat) in a screen session and use its perl interface to do your scripting. Irssi takes care of the connection, reconnects and deals with all the overhead like the problem you're having - you just have to do the front-of-house stuff. 
I'll check it out, pretty much just came to the conclusion of trying to use Bot::BasicBot due to what the google searched for 'Perl IRC bot' came up with.
I'll give it a go. I use mIRC and I know they have a 'scripts' section but I haven't considered it for whatever reason so I'll try that. If it doesn't work I'll switch over to irssi and see if it changes anything.
Actually, I would disagree, p5mop encourages using accessors much less then regular Perl OO or Moose. The heavy use of accessors in Perl OO came about as a means of avoiding issues such as typos in hash key names, which will silently just work, whereas a typo in an accessor method name will cause an error. Of course this leads to a heavily polluted public API for the class since Perl can't support private methods as a means of hiding those accessor methods from the API. In p5mop, since attributes behave like variables, any typo you make will be caught at compile time and be a syntax error. So there is no need to create accessors for your attributes unless you actually want them to be part of your class API. Also, the `repr('HASH')` trait will not store instance data into `$self`, so poking `$self-&gt;{foo}` will not work as you say. The `repr('HASH')` is there so that non-MOP subclasses can store their data in the instance just as if it were a regular vanilla Perl blessed-HASH style object. 
&gt; I'm not quite sold on the syntax. Are there real problems/limitations on using a keyword for $!x et al? I am not sure I understand what you mean by "using a keyword for $!x" can you explain more? Perhaps you mean "bareword"?
Mirc has its own scripting language, but x-chat and the free hexchat are gui clients with both windows versions and excellent perl interfaces that are well documented. If you have a linux shell somewhere, then I'd still recommend irssi, but you can do it with the above on windows, no problem.
 print "$!is an error\n";
&gt; Unfortunately, as you say yourself in the last sentence, P5+mop is going to be just P5 in a few years, Don't be so pessimistic. Even if this gets shoved into the language, it will take another few years, and it will be much longer before you have to deal with it much on CPAN. All the Kool Kids have been using Moose/Mouse/Moo for years now, yet I still rarely have to deal with them. The "smart" match boondoggle never spread much, either.
Presumably such code would fail to compile, either complaining of an unknown attribute, or of an invalid context (not in a method), if compiled by a perl with a fully baked version of this p5mop. I suspect such compilations (where code with `$!` or `$?` or similar immediately followed by a letter is compiled by a perl with the new p5mop) will be rare, to say the least. I could easily believe it'll cost less than an extra ten hours total over a 10 year period, for the entire world perl community, to process such problems, with half of that time being taken up by writing a good error message and it getting mentioned in READMEs and blogs etc. as a (tiny) break in 100% backward compatibility. It would be interesting to see how many instances of this there are on CPAN. (Fwiw my guess is none.)
$Two::two is still visible in one.pl. The one strict is complaining about is $main::two. It's still global. #!/usr/bin/env perl use warnings; use strict; use Two; our $one = 'one'; print "$one $Two::two\n"; 
Good to see some practical examples.
i don't like it. i like the idea, but i don't like the new syntax. why the class, method etc. i know it's o be more perl 6ish, but i like perl 5.
Perhaps? self-&gt;x Do you really need direct access to attributes?
Please do! And let me know how it goes. I'd be more than willing to help you if you uncover any bugs or problems.
I don't know anyone who uses an IDE for perl. I think it's part of perl's culture. Learn vi. Embrace Perl's UNIX DNA. OH, and don't ever run without warnings turned on. Good luck. (And notepad??!? Ewww. My sympathy)
I've written exactly one non-trivial perl app, and used Komodo Edit. It was hooked in to the Perl interpreter by default, and was very useful in highlighting syntax and other errors as I went. This may be worth a shot? I've not written any perl since, however, and so did not explore further.
Absolutely. The documentation needs some work.
I've used Eclipse with the EPIC plugin for years. It has good features, not great, but I don't tend to need much from my IDE. Vim is actually just as good with the right setup. 
I use emacs, with flymake, Devel::PerlySense among other general emacs plugins.
Komodo Edit.
http://padre.perlide.org/
So wrong :)
heh, what's so wrong about it?
Why have method call overhead if you don't need it? Why add an accessor method to the public API if you don't need it? Direct variable-style access to class-private attributes is a key feature of most OO languages.
I am a Win32 Perl user, and use UltraEdit, which basically amounts to a stronger notepad, but can be a coder's best friend for more than just Perl. I can't speak to Komodo, but many use that as well. I would honestly recommend staying away from IDE's for learning; they can be a terrible crutch with which you won't learn as much as you would actually left to your own coding devices. As others said, get a "use warnings;" in there, maybe even "use strict;". Debugging depends highly on what exactly you're doing, but I imagine you should be able to do okay with printed/logged variables in place of breakpoints and watches, and some deeper reading into http://perldoc.perl.org/ to see how you may be misunderstanding your use of any feature. I doubt this helped much. Do you have specific problems you want to try to lay on us?
Komodo Edit is nice for Perl. If you aren't up to using VIM, then Komodo Edit would be the next best thing for Perl coding.
What does this do that using Dancer/Mojolicious::Lite via Plack::Handler::Apache1 (or Apache2) doesn't?
SublimeText 2 is my favorite
To add onto this, I would highly recommend Notepad++, as it's a free option. I'm also of the opinion that Notepad++ is superior due to it's find/replace bookmarking functions.
Nope. Notepad++ is the best editor on Windows, IMO. ;-)
I use Netbeans + this plugin: http://plugins.netbeans.org/plugin/10668/perl
One thing to note on this - I don't recall all my settings at work off the top of my head - but :syntax on :set expandtab :set tabstop=4 and &gt;%, &lt;% is your best friend when a { or } is highlighted, it finds the associated { or } and shifts the entire block left or right.
 &gt; and &gt;%, &lt;% is your best friend when a { or } is highlighted, it finds the associated { or } and shifts the entire block left or right. Interesting. I don't think I've ever used that before. I usually have :set showmatch going. Sometimes I randomly type over existing } to see where they go. :D
You can also use the text objects that have been around since vim 7.0. `&gt;a{` to indent the current block, `&lt;a{` to outdent it, you don't have to be on the opening/closing curly. There's also `a(` for a paren group, `a[` for a square-bracket group, `a"` for a string, etc. And for all of those if you use `i` instead of `a` it will only affect the contents of the block/group/string but not the delimiters themselves. They work for most operators where it would make sense, for example `da{` to delete an entire block.
I actually use eclipse + epic + vwrapper which is a vim plugin for eclipse. 
I love emacs, but it isn't easy to learn. The first time I tried it, I couldn't figure out how to get out, so I used ^Z to return to the shell, top to find the PID, and kill -9 to terminate emacs. But then I discovered I could compile C code from within Emacs, get a list of errors, and automatically go to the right line numbers, using some command, so i became motivated to learn. Since becoming a Perlomaniac, I don't need to compile, of course, but the debugger is much nicer with an emacs wrapper. 
I use Vim, you can learn the basics of it in a day, it's not that bad as it seems to learn. As for errors, i suggest that you do use strict; use diagnostics; The difference with warnings is that diagnostics is more verbose about the errors. Learn to use perldoc , it's a great and easy tool for consulting things about perl.
Back in my day, we wrote our perl scripts in ed on a teletype machine. AND WE LIKED IT. No, but really, vim is where it's at for me.
I use the Test modules, if that counts.
 if has("autocmd") au BufReadPost * if line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") \| exe "normal g'\"" | endif endif Puts the cursor on the same lines as it was when you last opened the file. :set si Smart indent. 
Windows Perl people often use IDEs. Probably because their command lines are so awful.
BBEdit on Mac, Notepad++ on Windows. I've done it in Dreamweaver (there's an Extension) but I wouldn't recommend the experience. BBEdit has nice integration, things like Run and Run In Terminal menus, and customisable filters so PerlTidy can be run with a command of your choice. I use Control-T. Source control hooks too. I have been waiting since about 1997 to discover something BBEdit couldn't do. If that ever happens I guess I will move on…
BBEdit rocks. There aren't a lot of text editors for the Mac, but one it's got is golden.
&gt; something BBEdit couldn't do Multiple cursors. When you look at it for the first time you think it's a pretty stupid idea. Once you get used to it, you can't think how you've ever lived without it. 
Used Eclipse+Epic on Windows, moved on to Vim. Today I'd just start from a free version of Sublime Text. It's pretty awesome and very extensible, like Vim for the 2000s.
Uh, please explain? BBEdit does have discontinuous selection by the way. 
[SublimeText cast](http://www.sublimetext.com) starts with it. (I have to admit I have only used TextWrangler, not the full BBEdit.)
Right? My thoughts exactly when I saw it: Who on Earth gonna need it? (I use it 10-20 times a day, for renaming, refactoring, splitting, etc. Actually of their cast, 3 of 6 examples use it.)
Note: To learn vim, use "vimtutor". On Linux and Mac systems, ou can just type vimtutor in a terminal. I don't know how you access it in Windows.
[A necessary reading for everyone who loves Vim](http://delvarworld.github.io/blog/2013/03/16/just-use-sublime-text/). I use Vim everyday, and I cried when I read it.
vim + bash + ack
I prefer UltraEdit for Perl in Windows, and actually all text editing, including data. I've tried others but keep coming back to this one. It's not free though, my company has purchased licenses.
i use the command terminal in Ubuntu 
Interesting. I've always used Vim out of the box (other than a few simple customizations on my main development box). I've never installed any plugins and I feel that I'm as productive as the next guy. Probably because we have about 100 servers and we are just used to it being exactly the same on every server. Either that or ignorance is bliss? I think I'll look into some of these plugins.
[Emacs Rocks! Episode 13: multiple-cursors](http://emacsrocks.com/e13.html)
Think of it as a macro, but instead of executing the macro in a serial fashion in every place you want to change, you put a cursor in every place you want to change something and do your edits in real time.
[vimdoc/autocmd](http://vimdoc.sourceforge.net/htmldoc/autocmd.html) with `BufNewFile` comes in handy when creating new `.pl`, `.tt`, `.html`, or anywhat files to have your favourite boilerplate ready.
Emacs with evil (Vim-emulation) Magit (git integration), DB shell to e.g. Postgres, Projectile and helm for getting around. For Perl development I use cperl-mode and [Devel::PerlySense](http://search.cpan.org/dist/Devel-PerlySense/lib/Devel/PerlySense.pm#DESCRIPTION) (disclosure: I'm the author). From the description: * PerlySense is a Perl IDE backend that integrates with editor frontends, currently Emacs. * Conveniently navigate and browse the code and documentation of your project and Perl installation. Navigate between tests and source, and between related files. * Search through the project for method declarations, invocants or free text using Ack. * Run tests and scripts with easy navigation to errors/warnings/failing tests. * Automate common editing tasks related to source code, tests, regular expressions, etc. * Highlight syntax errors, warnings, Perl::Critic complaints, and Devel::Cover test coverage in the source while editing. * PerlySense has a plugin system for understanding custom syntax, e.g. Moose. Devel::PerlySense doesn't actually do any IntelliSense-style completion, but here's a new package that actually does seem to do that: [plsense](https://github.com/aki2o/plsense/) (slightly unfortunate possibility for naming confusion there :) I haven't tried it but it looks very promising indeed. Aside from that I have also written a refactoring "Extract Variable" in elisp, which is surprisingly useful: [lang-refactor-perl](https://github.com/jplindstrom/emacs-lang-refactor-perl/blob/master/lang-refactor-perl.el) It's part of Devel::PerlySense, or you can install it separately as the lang-refactor-perl package from MELPA. *Edit:* Added cperl-mode (d'oh)
If you do any perl scripting, odds are you're going to have to do some coding or text editing on the fly on a box with no mouse or gui. When this happens, you're really going to need to know how to use vi, as none of the other editors are available on every unix server ever installed. And the best way to learn vi is not with a book, but with a notecard, and jumping into the vi world feet first. You've got to force yourself to use it every day for awhile. gvim is helpful for that. It's not my everyday editor, but when I need to do some RegEx substitution on a local file with long lines, I'm glad it's there, and I know how to use it.
Agreed on everything. Then again, maybe not regex substitution where I'd reach for perl first.
Same here, I don't use any plugins (or even a .vimrc) because it's not helping me in the field.
So far Geany is the best thing I've found in the open-source world for replacing my previous editor, BBEdit, which sadly is Mac-only.
 lot of deps for this simple functionality. multi-method route endpoint? stacked handlers? 
SublimeText is the bomb. Cross-platform, consistent. I've moved to version 3 with no issues. 
Eclipse/E.P.I.C.
It is tied to mod_perl! \o/ /s
So unhelpful, hobbified. 
Who says the perl community is welcoming and friendly :(
Seems to be the most popular here. I'll try it out... thanks.
I can certainly see the advantages and I haven't come up with a good alternative. So, what's the story with the 'optional-twigils' branch?
We're very welcoming. But we're still going to point out the paradox of writing new code atop mod_perl in 2013, when its shortcomings are well-known and there are thoroughly established alternatives and successors already in place.
^^^^^nano
Nano.
I think we all know how tired mod_perl is at this time, and that Plack is the bee's knees. But it's not like it's risk free or effortless to just switch the underlying platform of a large system. If he has a chance to clean up legacy code with this module within an existing system in a feasible way, then who are we to argue.
Protip - run Plack::Handler::Apache2. Get the rock solid stability and performance of mod_perl in a production environment with the versatility of Plack based interfaces.
I used vi(m) for about 17 years to write Perl/C/C++/Java .. I never understood what the necessity for an IDE was .. until I took a class that required it. The class used Eclipse. and while I was doing Java for the course, I started to realize how much more productive I was with it. There was a slight learning curve, but Eclipse + EPIC is a fantastic environment to code in. 
Successors are great when you are writing brand new code. There are lots of things that you can do with mod_perl that you *cannot* do with plack. They may not be at all useful to you, but to the people that they are useful to, they are life savers. Say for example you have a website with a variety of different applications, written in different languages and some static HTML. Now you're told you have to put interstitial ads on the whole site. Pretty easy to do with mod_perl. mod_perl isn't for everyone. And if you're starting a brand new project right now, you probably don't want to start with it. But it's also an incredibly powerful tool.
I will make an effort to notice a time when it would be useful. For the record BBEdit has discontinuous copying/cutting and pasting, via the "paste column" command. So it's about 70% there, and I never would have noticed if it weren't for this discussion. 
Geany is great. The syntax highlighting is perfect and I can quickly see if my code compiles or not.
Even if you love mod_perl, what is the advantage of writing a routing module tied to mod_perl rather than using one of the existing modules that are server generic?
It's certainly reasonable to point out that mod_perl is useful -- but this doesn't at all relate to what the OP has written. And the example you give can still be done with plack (you can proxy traffic to a separate endpoint, then modify the result as it comes back, before returning the final response to the user -- indeed this is one of the things middleware is GREAT for).
&gt; haven't been vetted in very large production environments like mod_perl has This is FUD. I personally have written and deployed plack-based applications that serve hundreds of pages per second, producing six figures of revenue a month -- and I'd consider that small, compared to some of the other environments I've heard of.
An "optional-twigils" branch would be a huge amount of work and very difficult to keep in line as development progresses.
I'm not sure what your actual problem is (are you checking the debugging output that is commented out which emits the username and password to STDOUT?) That said, you have bigger problems you should look out for... for one thing, if someone sends in a username with a quote it looks like they could do string injection and execute arbitrary commands as the user running the script (this line below is really bad): `echo "$date: no patronid found for $userid" &gt;&gt; $logfile`; Also, I hope that $bindpass isn't your real LDAP password...
Oh. I just saw it on github and assumed it was something being worked on to eventually be merged in.
Edit Plus is a good lightweight code-aware editor. It does syntax highlighting, lets you create multi-file projects, and has various indenting and commenting functions, among others. I've been using it for 10 years. 
Ohhhh, that branch, I had forgotten about that branch. Yeah, that is really old and was from when I first introduced twigils and not everyone thought they were a good idea. For the record, most of those people were eventually converted :)
This isn't a "config file", and it's unclear what it's supposed to be doing or where it fits into the system. Can you explain a little bit more?
&gt; What, \^H-T wasn't obvious enough to you? You mean the way backspace made crazy things happen? That was even more confusing than the way leaning on Control-C didn't get me back to the shell.
nginx
Almost always Dancer or Mojolicious
Padre's good; you can write plugins in Perl! The only really annoying thing is that it doesn't support JS highlighting in HTML. Drives me up the wall. I've been thinking of trying to fix it. EDIT: Apparently certain themes don't have highlighting, not Padre itself. Solarized Dark/Light have support for embedded JS. Who'dathunkit.
We tried Starman in a test environment but ran into a an issue with missing sigint, and also high cpu load compared to apache/mod_perl. It seems to be good for development, but not up to par with mod_perl in production. We do use PSGI in the stack.
Did you talk to the starman author about that? Whenever I've run into issues they have always been dealt with promptly and competently.
Vim for sure (on Linux). Runs in the terminal unlike many other text editors which run in a GUI Window (including sublime right?). Running in the terminal means easy switching to the command line for fast: exec, testing, file updates, cpan downloads, and access to perldoc. Emacs is also a good option.
I think you're looking for csound, not a perl library.
Audio::Beep can create beeps at arbitrary frequencies.
I love vim too. Though I kinda wish there was a good omni-completion plugin. 
It seems like I can't just use csound as a perl library either because no one written the bindings yet.
There's no reason to use perl at all.
Do you want to write the synths and effects in perl itself? If so you can look into PDL which provides some algorithms to make this stuff easier. But Perl is kind of a funny choice for DSP work. It may not be very efficient. As far as actually playing sound you will need to find a library that allows you to write sound data directly, perhaps SDL/perl will work? Or perhaps not...
I used to use Notepad2 because it was lighter-weight but I don't use Windows anymore.
I want to write some CSound bindings for Perl! Unfortunately I lack the XS skills right now. I've got perlxstut printed out right next to me — I just need to make the time to read it. I've coded CSound in the past, but Perl bindings will allow for doing more live algorithmic music in Perl rather than having to write the score in straight C or use the Java/Python bindings. BTW, have you seen [Hacking Perl in Nightclubs](http://www.perl.com/pub/2004/08/31/livecode.html)?
Last I looked (a few years ago) SuperCollider couldn't work in 64-bit. Hopefully that's changed now.
Piping packed data to gstreamer using open3 with gst-launch would be quick &amp; dirty, but effective. The Gstreamer library might be appropriate, but you'd need to set up an appsink or a fakesink element in gstreamer and have it handle buffers &amp; pads appropriately. PDL could speed things up if you're mixing waveforms; gstreamer certainly handles mixing, but it's sometimes not straightforward to set up.
The bigger the code base the more files I tended to have open. It's easier to switch back and forth within an IDE. Also, I click one button to compile and run, highlighting lots of rows and tabbing them over, automatic code generation .. that kind of thing. 
I know I sent a reply already, but I was just mulling over your question a little more. Here is the [EPIC users documentation](http://www.epic-ide.org/guide/index.php). Anything after chapter 4 are really helpful in terms of being a productive coder. Like you, I was a diehard vi guy and couldn't see the point of an IDE, until I had to use one and begrudgingly liked it. I still use vi for small stuff and quick fixes, but the IDE is an awesome tool. 
I have tried it (at home, not in a club), is kinda hell to get working today since some of the modules aren't on cpan and some are only experimental. Seems nine years are some time, even in the Perl-World. Edit: Oh yeah, and try [Inline::C](https://metacpan.org/pod/release/SISYPHUS/Inline-0.53/C/C.pod) for the binding, you'll get something that works faster, but it isn't as fast and clean.
First rule of optimization – DON'T!! Second rule of optimization – PROFILE!! Basically the issues you're asking about most likely won't make any real difference unless your array size is in the hundreds of thousands (perhaps millions), at which point Rule 2a comes into play, which is "always profile under real load". 
I have not read the relevant parts of the Perl interpreter to know the exact answer, but a benchmark will probably give us a clue, and more importantly it will tell us which is actually faster, without having to reason about the performance implications of the implementation. use Benchmark; my @array; foreach (1 .. 400000) { push @array, $_; } my $i = 0; timethese(200, { 'array' =&gt; sub { my @filtered; for (&amp;return_array) { $i++ if !($_ % 4) } }, 'ref' =&gt; sub { my @filtered; for (@{&amp;return_ref}) { $i++ if !($_ % 4) } }, }); sub return_ref { return \@array; } sub return_array { return @array; } Benchmark: timing 200 iterations of array, ref... array: 11 wallclock secs (11.68 usr + 0.00 sys = 11.68 CPU) @ 17.12/s (n=200) ref: 8 wallclock secs ( 7.48 usr + 0.00 sys = 7.48 CPU) @ 26.74/s (n=200) So iterating over that reference is faster &gt; Building on what's been asked, is there any benefit to return an arrayref, when you know you're going to want to iterate over the entire array in a for loop? Since I use Template::Toolkit a lot, I find that arrayrefs are much easier to work with since they work like arrays in FOREACH calls but you can get the size of the result as well if you want it. Also, apparently they are faster. &gt; Finally, does the compiler treat these two exactly the same, or is grep perhaps faster? They are not the same &gt; is grep essentially a for loop grep is *like* a for loop that builds a return list, so if you don't need the return list then grep is slower than a for loop. Also, maybe grep is just slow. use Benchmark; my @full_set = (1 .. 40); timethese(0, { 'grep' =&gt; sub { my @filtered; @filtered = grep !($_ % 4), @full_set; }, 'for' =&gt; sub { my @filtered; for (@full_set) { push @filtered, $_ if !($_ % 4) } }, }); Benchmark: running for, grep for at least 3 CPU seconds... grep: 2 wallclock secs ( 3.10 usr + 0.00 sys = 3.10 CPU) @ 234116.13/s (n=725760) for: 4 wallclock secs ( 3.18 usr + 0.00 sys = 3.18 CPU) @ 168163.84/s (n=534761) ~~I'm surprised by that, but grep seems to be slower.~~ grep is faster, had labels backwards. Also, for finding whether an element exists, grep is much slower. &gt; Forget about List::Utils, for now, which I understand has a function like what I'm asking about (implemented using for?) Actually, it's List::MoreUtils::any that provides this, and it's written in C for higher performance than the equivalent pure Perl version written with a for which would be sub any { $_ &amp;&amp; return 1 for @_; 0 } edit: backwards labels, fixed.
&gt; I'm surprised by that, but grep seems to be slower. I believe you got your labels backwards ;-).
&gt; In Perl, when a copy of a data structure, such as an array, is returned from a sub, is the array actually a full copy in memory, or is it still a reference to the same memory, until or unless it is altered? I believe it's copied, but see [illguts](http://cpansearch.perl.org/src/RURBAN/illguts-0.46/index.html) for details.
1. The list that a subroutine returns exists on the stack. If you `return @array` (and the subroutine was called in list context), the contents of `@array` are pushed onto the stack and then the caller does whatever with it (like assign it to another array). The scalar values within the array don't need to be copied as long as `@array` is the only thing holding a reference to them. 2. Yes, map and grep "fully realize" their input and output lists on the stack. It would be cool if they did some kind of coroutine stream processing, but they don't. (Also, I would be surprised if you find any multiples of four that aren't multiples of two). 3. No, the dereference in `@{Fetch::My::data()}` isn't performing a copy, it's just telling `for` "this is the array you iterate over". Dereferencing isn't expensive, copying the contents of an array potentially is (see answer #1). 4. `first` is best but ignoring that, use the for loop. `grep` might be natively a little faster, but the early-out is a bigger win.
Right you are.
Yes, that seems harmless.
Yup, thats me. The plan for p5-mop is to have the prototype on CPAN for a little while, gather feedback from folks and improve on it. Then turn it into a core-distributed module, allowing it to be "dual-life" for a little while (available in the core and on CPAN), again gathering feedback and improving it. Then, eventually integrate it into the core of Perl once all involved feel it is stabilized. Basically we are going to be cautious about things so that we can be sure to get it right (for some value of "right" of course). Now, back to your question. I really don't know the answer and honestly I doubt anyone but the more dire of core hackers does either. Perl is pretty optimized internally and things like copying an array of 20 strings is likely no more of a penalty as the overhead of creating and dereferencing an array reference (note: I am making stuff up here, but you get my point). Small operations like this are not worth optimizing unless you are doing them inside a tight performance critical loop, at which point breaking out the C code is likely a better option. There is more of a chance that the actual work of fetching in `Fetch::My::data()` will completely overshadow any performance difference found by it returning an array ref or a list. Things like making sure your database is properly indexed and your query is properly optimized will make a far bigger impact on the performance of you loop. So again I will say that the real only way to really know for sure what is causing you performance problem is to profile and to profile with real load. Cause what you think might be the source of your performance problem, often times, is not actually the source of your problem. Blindly guessing and acting on those guesses is a bad idea all around, **_especially_** when there are tools like [Devel::NYTProf](https://metacpan.org/pod/Devel::NYTProf) which will tell you with pinpoint certainty where your bottleneck is. In short, write some code to test it under real world load and profile it. And avoid micro-optimizations at all costs, they only lead to convoluted and hard to maintain code. 
Cool that you're learning Perl. So hmm, are you looking for this? foreach my $key (keys %hash){ print $key if $key eq 'chr14'; }
I ran `perldoc -q hash` and I got things from perlfaq4. Basically, I think you are going to have to process the hash then check the values one at a time.
How would you go about doing this? I'm really new to all of Perl. I literally have only learnt arrays, basic hashing, while loops, if/else statements really. If you have a link to a tutorial, that would be lovely. 
One of the links on the sidebar links to Perl Tutorial Hub, as seen here http://perl-tutorial.org/. 
 say join "\n", grep { $hash{$_} eq 'chr14' } keys %hash
Yeah, I'll admit I don't know what happens in the windows world. Good to know.
Thank you for the link. This is great help. :) 
One of the tutorials I googled into before turning here talked about 'grep', but I could not find a succint description of what it does exactly. Would you mind explaining its function in this context?
Okay, thanks. :)
I think you're actually looking for for my $key (keys %hash) { say $key if $hash{$key} eq 'chr14'; } which could also be written say for grep { $hash{$_} eq 'chr14' } keys %hash; I see where chubbyMcstubbins got confused; you should be a little more careful to say things like "print the key if the value corresponding to that key in %hash is 'chr14'" instead of things like "print the key if it has a value of 'chr14'", which could be misinterpreted :)
Ahh, thank you for the explanation. Perl is (or will be) my first coding language, and I'm still learning some of the tools built into the program. 
`say` is `print` that also prints a newline at the end. It's available in perl 5.10 or higher, as long as you say `use 5.010;` or `use feature 'say';`.
A little triva for you: grep stands for "global regex print" and is a command from the editor vi (where "re" is not literal, but is replaced by a regex, like so: g/whatever/p). It's also the name of a Unix command which does just what the vi command does.
It's actually [far older](http://en.wikipedia.org/wiki/Grep), having been extracted from `ed` ([THE STANDARD!!! TEXT EDITOR.](https://www.gnu.org/fun/jokes/ed.msg.html)) in 1973.
I'd like to say that this is condensed perl, there are 4 different functions all put together - which can be confusing for someone trying to learn the language. if we break this out into individual operations: # return an array of all the keys in the hash @hashkeys = keys %hash; # take each element of @hashkeys and make it $_, ask if $hash{$_} equals 'chr14', and if so - return that hash element. This gives us all keys who's value is 'chr14', @hashkeysfilterred = grep { $hash{$_} eq 'chr14' } @hashkeys; # make a long string of all the elements in @hashkeysfilterred seperated by newline characters. $string = join("\n", @hashkeysfilterred ); # print dat shit to screen. say $string;
Yeah, well, vi was based on ed...
Thanks for the pointer. If I used the Perl debugger more, Eclipse would really be appealing, but I tend to use a mixture of internal sanity checks, debug prints, and a REPL. As for the rest, it seems to run into the problem that "only perl can parse Perl," as illustrated in the "refactoring" section: &gt; Note &gt; &gt; The extraction might not work properly at the moment because the Devel::Refactor module is in an early stage of development. With upcoming versions of the module, this function should become more reliable. 
Stick with Moose, or one of its derivatives. Moose has some fairly significant start-up costs in terms of time spent compiling and doing the various MOP-related stuff. For applications that need quick startup, this is a killer. However, for web apps, which are usually "Always on" and the startup is paid for once in a blue moon instead of on every request, Moose gains you so much more flexibility and so many powerful and useful features, it's silly not to use it. 
I just wrote this year an app in dancer and used mouse. It was light and had enough for what I wanted.
&gt; the authors of Mojo use Moose. Huh? They seem to have [their own object thing](http://cpansearch.perl.org/src/SRI/Mojolicious-4.53/lib/Mojo/Base.pm). I wouldn't junk up your program with multiple object systems. Either use theirs, or roll your own.
I'm pretty sure I've seen 'use Moose;' in their code, and some of their methods are declared in the spirit of Moose with 'has'. I can't point to where I saw 'use Moose' but you can find 'has' all over their code
Mojo definitely does not use Moose, the has you see is their own object system. You can make use of the 'has' function in your own projects to declare hash based objects. 
I read it, and I tried Sublime, but I feel like I focus more on the code I'm trying to produce with Vim. Jumping to lines, top and bottom of the code, doing a quick search, that's all I feel like I need to be 100% productive. Whatever makes it easier to work and focus on your work is the best. You can make Vim a great IDE, and you really don't have to learn every keyboard shortcut, but you should know the key ones like search and replace and navigation. I'm ten times more productive with Java in eclipse, so I use that because I can code an application by pressing tab and space. But for Python, Perl, C, C++, I prefer Vim. Sublime is neat with Vim mode, but I still don't feel like I need it or that it makes me more productive.
I 100% agree that Eclipse is great for Java, but for Python/Perl/C, I feel more productive with Vim. Eclipse/Java is all Package dot down down down enter dot down down down down down enter dot down up left right left right enter. 
Thanks for the this explanation, that's really cool. All I need to do now is to find how should I use it :p because I'm still thinking in the 'classical' oop style
This is very helpful! I really like to know the meaning of whatever function (or condensed function) I am using so this explanation is great. Thank you so much!
For now, the simple solution is what I am looking for, but I am definitely going to ask my teacher if she can go over reverse hashes with us. I feel like they would be useful after looking at some of the tutorials that have been linked to me. Thank you for the advice. :)
But the real question is, ... did you profile? :)
Hi, I'm on the Mojolicious core team and I can definitively say that Mojolicious does not internally use Moose, but rather uses our own Mojo::Base mini-framework which does enough for what we need. Also, IIRC it predates Moose (certainly predates wide knowledge of Moose). Mojo::Base does a few things really well. It is incredibly fast and it has an easy semantics for adding lazy attributes. In Mojo::Base all attribute defaults are lazily evaluated. One other difference is that setters return the instance for chaining. Mojolicious does support using other object systems in your code, but for 90% of what I do, Mojo::Base is enough for me. For that other 10% I use Moo. Mostly for non-web things. I would recommend using Moo until you know why you would need Moose. I would avoid using Mouse for new projects as it isn't as compatible with the other two. Moo and Moose were designed to play nicely together (ok Moo was designed to play with Moose). Stay away from a thing called Any::Moose. Hope this helps a little bit. :-)
I haven't adopted it in any of my code, partially for backward compatibility reasons. Perhaps more importantly, they have [some annoying potential traps](http://modernperlbooks.com/mt/2012/03/inadvertent-inconsistencies-each-versus-autoderef.html), so I've been considering them something to avoid. Post-deref seems neat, and a much better solution than auto-deref. Even so, typing @$foo (or @{$foo-&gt;bar} on some occasions) isn't a huge burden, so I'd happily trade away auto-deref to gain back the safety. As for each @array, it doesn't seem great, but I usually prefer keys/values to each with hashes, so it's not something I often reach for.
I've been using auto-deref quite a bit in my scripts but haven't found any use for each with arrays.
for my( $key, $value ) each ( @flat_hash ) { &amp;do_something( $key, $value ); } Seems like it might be useful fo walking ordered hashes... Granted, sorting provides A SORT ORDER or two, post hoc, but suppose the scenario of an arbitrary user defined order &amp;askformypreference. Since the data's already got, it's be nice just to use it, and not invoke &amp;askformypreference again.
I haven't started using the autoderef yet so I wouldn't miss it. After smartmatch, I'm a little more reluctant to start using new features. But the postfix deref seems like a more general solution, language-wide, so I like that. The syntax is still a bit ugly to my eyes though. What is that extra '*' for on the end? Somebody suggested something like $aref-&gt;ARRAY which I actually like, even though it is longer. It better mirrors existing syntax.
Start with Moo.
Moose is older than most people probably realize (2006). Then again, I was surprised to find that Mojolicious goes back to 2008.
No. They're both designed wrong. Auto-deref is fundamentally ambiguous and can't cope with overloading, and `each` is a liability even on hashes — why extend the badness to arrays? `keys @array` and `values @array` don't bring anything to the table (they're equivalent to `0 .. $#aray` and `@array`). They could have had *some* use if they interacted correctly with `exists $array[$foo]` and `delete $array[$foo]`. But the p5p position is that the difference between nonexistent and undefined array slots should be swept under the rug, so they don't.
I was glad to see how many of you liked sillymoos' posting of my previous post in this series. As such I wanted to be sure to post this one here too. Please feel free to comment here or there.
I was glad to see how many of you liked sillymoos' posting of my previous post in this series. As such I wanted to be sure to post this one here too. Please feel free to comment here or there.
I was very excited by these features, but I was quickly bitten by them in terms of backwards compatibility. Now I'm fine with making a choice to support old Perls or not, but I once broke backwards compatibility on accident by using an array operation on `$arrayref` rather than `@$arrayref`. It worked fine on my newer Perl, but I was flooded by failing test reports from older Perls. Easy enough to fix, but it has made me wary of the feature.
Note also: http://www.modernperlbooks.com/mt/2013/11/would-you-miss-autoderef-in-520.html
Agreed, but IMHO `each/keys/values` are way worse. Like every polymorphic operator in Perl, they can't be trusted: * If you write `$x ^ $y`, you will eventually be bitten when Perl invisibly thinks `$x` or `$y` is a string when you assumed it was a number, or vice versa. Use `(0+$x) ^ (0+$y)` or `(''.$x) ^ (''.$y)` instead. * If you're using smartmatch, you have to compensate for at least two complex behaviors.
&gt; After smartmatch, I'm a little more reluctant to start using new features. Same. Although I'm not rigorous about it, I tend to target Perl 5.6's features, since most of the stuff added since then is at best marginally useful. This isn't a knock on Perl -- like C, it's very good at what it does, but its newer features can mostly be ignored.
&gt; &gt; &gt; So iterating over that reference is faster I think you tested the difference between copying an array returned by a subroutine to a new list vs. copying a dereferenced arrayref from a subroutine to a new list. I see a marginal difference in looping performance in this test. I wonder if you can reproduce? I'm perl 5.14.2 use Benchmark; my @array; foreach (1 .. 400000) { push @array, $_; } my $array = \@array; my $i = 0; timethese(200, { 'array' =&gt; sub { my @filtered; for (@array) { $i++ if !($_ % 4) } }, 'ref' =&gt; sub { my @filtered; for (@$array) { $i++ if !($_ % 4) } }, }); Benchmark: timing 200 iterations of array, ref... array: 8 wallclock secs ( 7.44 usr + 0.02 sys = 7.46 CPU) @ 26.81/s (n=200) ref: 7 wallclock secs ( 7.47 usr + 0.01 sys = 7.48 CPU) @ 26.74/s (n=200) Benchmark: timing 1000 iterations of array, ref... array: 40 wallclock secs (39.27 usr + 0.01 sys = 39.28 CPU) @ 25.46/s (n=1000) ref: 40 wallclock secs (40.18 usr + 0.02 sys = 40.20 CPU) @ 24.88/s (n=1000) but a significant difference in this test, with no iteration: use Benchmark; my @array; foreach (1 .. 400000+int(rand(0))) { push @array, $_; } for my $iters (200,1000) { timethese($iters, { array =&gt; sub { my @a = &amp;return_array;0 }, ref =&gt; sub { my @a = @{&amp;return_ref};0 }, }); } sub return_ref { return \@array; } sub return_array { return @array; } Benchmark: timing 200 iterations of array, ref... array: 11 wallclock secs (10.34 usr + 0.08 sys = 10.42 CPU) @ 19.19/s (n=200) ref: 5 wallclock secs ( 5.15 usr + 0.01 sys = 5.16 CPU) @ 38.76/s (n=200) Benchmark: timing 1000 iterations of array, ref... array: 48 wallclock secs (47.47 usr + 0.06 sys = 47.53 CPU) @ 21.04/s (n=1000) ref: 24 wallclock secs (23.95 usr + 0.02 sys = 23.97 CPU) @ 41.72/s (n=1000) for comparison, your original test run on my machine does show a large gap in performance: Benchmark: timing 200 iterations of array, ref... array: 17 wallclock secs (17.11 usr + 0.08 sys = 17.19 CPU) @ 11.63/s (n=200) ref: 13 wallclock secs (12.89 usr + 0.00 sys = 12.89 CPU) @ 15.52/s (n=200) Benchmark: timing 1000 iterations of array, ref... array: 87 wallclock secs (86.08 usr + 0.03 sys = 86.11 CPU) @ 11.61/s (n=1000) ref: 64 wallclock secs (63.73 usr + 0.03 sys = 63.76 CPU) @ 15.68/s (n=1000) Also, confirm that grep is faster: Benchmark: running for, grep for at least 3 CPU seconds... for: 4 wallclock secs ( 3.26 usr + 0.00 sys = 3.26 CPU) @ 207784.05/s (n=677376) grep: 3 wallclock secs ( 3.22 usr + 0.00 sys = 3.22 CPU) @ 258909.63/s (n=833689) 
Yes, that's the case. OP was wondering if it was faster to return an arrayref or an array when iterating, and it is. My benchmarks on your code return the same results you got (I am also using 5.14.2).
Hi Joel, thanks for the input. I've been thrown of by the 'has' method that's why I thought it uses Moose. Anyways...so you're telling me I can haz 'has' with 'use parent Mojo::Base' or 'use Mojo::Base 'Mojolicious::Controller' '? Thanks :)
Well I don't know Dancer very well, I've worked only with Mojo, and I really need the powerfull features that it has. The app will get fairly complicated with time... Thanks though :) 
Good ideea, thanks
Wasn't saying to move it to dancer just saying for a easy and quick oop system mouse was pretty good .
I had assumed that "use 5.008" or similar would work, since the docs claim: &gt; "use VERSION" also enables all features available in the &gt; requested version as defined by the "feature" pragma, disabling &gt; any features not in the requested version's feature bundle. Sadly, that doesn't work: &gt; $ perl5.16 -we 'push $foo, 1; print @$foo' &gt; Not an ARRAY reference at -e line 1. &gt; $ perl5.10.0 -we 'push $foo, 1; print @$foo' &gt; Type of arg 1 to push must be array (not scalar dereference) at -e line 1, near "1;" &gt; Execution of -e aborted due to compilation errors. 
Moose most certainly predates Mojo::Base and in fact, inspired Mojo::Base. I remember having the discussions with Sebastian (Mojolicious's author) about whether he should use Moose or not, in the end he opted to create Mojo::Base and go the whole "no dependencies" route.
I do find defined-or to be useful. And say can be nice for one-liners.
The `use VERSION` is only a shortcut for `use feature :VERSION`. In the past, new functionality has been introduced without making it a proper `feature` first, especially when the syntax was previously illegal. Examples include: * `//` defined or * `each` and `keys` for arrays * autoderef (or more specifically: the `+` prototype instead of `\[@%]`) * regex extensions, e.g. `/u` or `/a` modifiers, the new `(?[])` character classes. * `package Name { BLOCK }` syntax However, most of these are marked experimental in the docs. The `feature` route is usually taken for new keywords (`say`, `state`, `given/when`, `fc`, `__SUB__`) or incompatible changes that do make a lot of sense (array base, `eval $str` semantics, unicode strings). 
Please apply your rule (2) to yourself.
This was posted a few years back on slashdot. The fact of the matter is, with just 6 people they might have picked some that are bad coders, and the sample size doesn't reflect it. Secondly, they don't take advantage of modern language features. From what I recall they don't even use strict, and they have some perl4-isms. So their comparison becomes does this 15 year old language perform as well as our contrived pseudo-code? Third, most people have moved on from code==math ideas. They share some similarities but most modern code is not math heavy, so a coder doesn't have to spend all their time understanding algorithms. Their example programs were math based and it's possible that of their 6 random people, they got some in the perl group that were just bad at math. Yes, the other group might also be bad at math, but as you show in your blog post, their sample size is small enough to be meaningless. Despite all it's problems, like a political ad this pdf has probably done damage. At the very least you'll have potential new adopters who read it and steer clear of perl. Hopefully they got poor marks for it. EDIT: rereading the paper I found that they produced this POS as part of a grant from the NSF. So it's not a student paper but actual published professors who think this is a proper study. I don't know how much time and money they spent on this part, but the grant is for $447,053. It's supposed to be for "Building an Educational Infrastructure for Students at K-12 Schools for the Blind to Broaden Participation in Computing" http://www.nsf.gov/awardsearch/showAward?AWD_ID=0940521
I wrote the post because this was on /r/programming today. I had never heard of these people before today and I wish I had remained blissful in my ignorance ;-)
You can do all of that in vim - ctags, easy compiling and running, tabs, etc I haven't found anything an IDE can do that vim can't with the correct plugin. Combine that with the *nix OS and you've got an IDE. However use whatever tool makes you happy. :)
something like this? #!/usr/bin/perl use strict; my $lsout = `ls -la`; my @lsoutlines = split /\n/, $lsout; foreach (@lsoutlines) { my ($char1234, $filename) = /^(.{4})[^ ]+ +\d+ +\w+ +\w+ +\d+ +\w+ +\d+ +[\d:]+ +(.+)$/; printf("%-16s %s\n", $filename, $char1234); } 
Do your own damned homework man... Wtf?
http://perldoc.perl.org/functions/sprintf.html http://perldoc.perl.org/functions/printf.html Could you post the rest of your assignments for the semester so we can get a head start on them?
I've often wished for an `each @array`-like feature, for cases where I need to access the element previous or next to the current element in a loop. The C-style for loop results in some pretty ugly code where the logic isn't as apparent, and `each` there would allow using the current loop value as it is while using the index in the few places where it's needed. I don't know the semantic implications of this `each` though, why do you say this polymorphic each is even more harmful that the auto-deref? 
That's quite the transparent attempt to make the submission relevant to this sub. :) Don't take me wrong, I found the PDF useful and interesting, just found the title funny. The code snippets in there look great though, very readable, kindles some P6 interest in me. 
A very nice, terse solution that makes efficient use of the perl command line switches (e for code execution, n for implicit looping line by line, and a for automatically splitting each line into list @F). Thanks for exposing me to this. It's little stuff like this that really makes me appreciate the mad power that Unix/Perl experts wield.
&gt; The code snippets in there look great though, very readable, kindles some P6 interest in me. Danger Will Robinson! I encourage you to read my stock PerlMonks warning which is the footnote of my [recent PerlMonks post about one of the very few examples of P6 being used for $work](http://www.perlmonks.org/?node_id=1047676). Perhaps you have experienced the ignorance, ridicule, vitriol and occasional home truth targeted at Perl 5 users? It's a whole bunch worse for P6 -- and it comes from P5ers! So just don't let anyone know you're looking at P6, OK? :) Seriously, if you wanna take a look at P6, your best bet, by far, is to [visit the #perl6 IRC channel](https://kiwiirc.com/client/irc.freenode.net/perl6) and chat with Larry Wall (TimToady) and the rest of the crew. Hope to see you there. :)
&gt; it has to guess whether a scalar wants to be converted to a hash or an array Ah, so its harmfulness comes back to auto-derefs is it? If auto-derefs went off as p5p talk indicates, this ambiguity would be gone, right? 
&gt; I encourage you to read my stock PerlMonks warning which is the footnote of my [recent PerlMonks post about one of the very few examples of P6 being used for $work](http://www.perlmonks.org/?node_id=1047676) . &gt; Perhaps you have experienced the ignorance, ridicule, vitriol and occasional home truth targeted at Perl 5 users? It's a whole bunch worse for P6 ...which was proved by the very thread you linked to - I just made the mistake of scrolling down! It's enough to sap out any excitement one might have initially, so it's great that you keep replying level-mindedly in the midst of that. And to be honest myself, at this point of time I've pretty much stopped expecting Perl6 to "happen" and would only be pleasantly surprised if it does, but the -Ofun element interests me. The documentation issue was discussed there, if I was interested in writing some stuff myself, where should I go to gather the existing bits and pieces? I'll follow the links mentioned there but wanted to know if there were any others. 
Agreed. Eventually you will want to look into Data::Dumper after you've figured out the basics, and start diving into "nested data structures." The code below might be a little over-the-top for someone just starting, but should illustrate how useful Data::Dumper can be. # create and print/dump a hash reference use strict; use warnings; use Data::Dumper; my @numbers = ( "zero", "one", "two" ); my %numbers = ( 1 =&gt; "one", 2 =&gt; "two" ); my $data = { foo =&gt; "bar", array =&gt; \@numbers, # array reference hash =&gt; \%numbers, # hash reference }; # prints the inner structure of $data print Dumper( $data );
Right, but so would the ability to write `each $thing-&gt;returning-&gt;hashref` instead of `each %{$thing-&gt;returning-&gt;hashref}`, which is what I think people want to do.
&gt; I don't see the problem though with making autoderef only work on exactly 'ARRAY' and 'HASH' refs. I guess you could do that, but it would neuter `overload`. And it runs counter to the way that the (r|b)est of Perl works.
First and foremost, if you are interested in doing anything with P6, even just writing about it, visiting #perl6 and saying hi a few times over a week or two period will be by far the most productive move. (For one thing it's a friendly place where just about everyone and everything P6 meets and coordinates. For another I continuously catch up with the "backlog" (so I can stay abreast of what's happened and pick lines that go in to the [#perl6 summary](http://irclog.perlgeek.de/perl6/2013-11-07/summary)) and **if someone asks something and doesn't get good answers, I end up seeing that and then I try to arrange for better answers** which they then see when/if they rejoin the channel a few days later (and say something to trigger personal message delivery).) I've just updated my [PerlMonks post about Perl 6 documentation](http://www.perlmonks.org/?node_id=1033899) from earlier this year. But I concluded that both what I had done before, and what I updated it to, was still too confusing and just not what was needed. I've since decided I will review the whole of P6 doc, because I have a fairly good sense of it now, and hope to produce more useful doc about P6 doc over the next week or two, time permitting. Finally, I've added a new issue to p6doc, and a corresponding [questhub Perl realm quest](http://questhub.io/realm/perl/quest/527bcaf69f567a1d4c00004c) tagged Perl6 and lhf (lhf = [Low Hanging Fruit](http://www.urbandictionary.com/define.php?term=low-hanging%20fruit)). Hth
TIL: A new trick for JAPH obfuscation. perlfunc even includes another awesomely confusing use of scalar example beyond this one.
To save others the time to look it up, here's the full paragraph: &gt; Because "scalar" is a unary operator, if you accidentally use a &gt; parenthesized list for the EXPR, this behaves as a scalar comma &gt; expression, evaluating all but the last element in void context &gt; and returning the final element evaluated in scalar context. &gt; This is seldom what you want. There's no point denying that contexts make reasoning about code significantly harder.
(NB I don't intend the following to be taken too seriously, even though I'm seriously trying to make a point.) In theory your framing ("no point denying") makes it both significantly simpler and significantly harder to reason about your assertion about reasoning about code. Simpler, because it theoretically cuts off debate. Harder, because cutting off debate makes no sense in this context so something is amiss. In practice I think I can make some reasonable assumptions based on this context (namely online dialog). First, you don't intend to engender a closed minded conflict. (While applying this assumption generally to online posts might turn out to be incorrect in many cases it's still a reasonable assumption to make both in the general case and also based on a quick look at other posts by you.) Second, "There's no point denying ..." can be translated to something like "Generalizing, I strongly suspect ..."). With those assumptions in place it's significantly easier to reason about your assertion. In response to "Generalizing, I strongly suspect that contexts make reasoning about code significantly harder" I'd say fair enough but that, generalizing, I strongly suspect that contexts make reasoning about code significantly easier in most practical contexts. length := sheep.pen $length = @sheep Which line is harder to reason about?
Dammit, Jim, I got it wrong!
I was expressing my personal opinion, not speaking for others, so "there's no point" was meant in the sense of "I don't see it", not in the sense of "don't try", yes. I would dispute that points that are valid for natural languages are necessarily equally valid for programming languages. For programming languages, it's important that the reader of code can easily get an understanding of the machine's interpretation of it. The interpretation of a list in scalar context is a clear example of a case where the evaluation rules are not obvious at all. The advantage of the Perl line in your example rests in my understanding mainly on the type information provided to the reader by the sigils. The mechanic behind it could just as well be implemented by implicit type conversion alone, without the concept of contexts.
&gt; The interpretation of a list in scalar context is a clear example of a case where the evaluation rules are not obvious at all. That's because no one bothers to learn the rules, mostly because almost no one bothers to *teach* the rules. &gt; The mechanic behind it could just as well be implemented by implicit type conversion alone, without the concept of contexts. Maybe so, but the effective effects on the semantics of the code would be the same either way. You have to understand arity, precedence, type (value or count) coercion, and possibly what constitutes a term and what constitutes an expression.
yes, and perldoc isnt very good at explaining this. you can figure it out by careful reading and some fiddling in a repl, but something like perltrap would be nice for things like this.
I'll see how much clearer I can make it in the 2014 Modern Perl book.
&gt; I would dispute that points that are valid for natural languages are necessarily equally valid for programming languages. Fwiw I would dispute that points that are valid for natural languages are necessarily not equally valid for programming languages. &gt; For programming languages, it's important that the reader of code can easily get an understanding of the machine's interpretation of it. Imo, if code is working, it's much more important that a writer can easily express their intent and a reader can easily understand the writer's intent. Perl's expressivity, of which context dependence is a part, addresses this. Imo, if code isn't working, it's important to be able to figure out what's going on but the need for it to be easy doesn't go remotely as far as to outweigh the benefits of clarity of expression of intent. &gt; The interpretation of a list in scalar context is a clear example of a case where the evaluation rules are not obvious at all. Imo this problem has nothing to do with context in general and everything to do with the particular rules. Which in this case have counter intuitive results if you don't know them. &gt; The advantage of the Perl line in your example rest in my understanding mainly on the type information provided to the reader by the sigils. The mechanic behind it could just as well be implemented by implicit type conversion alone, without the concept of contexts. I see implicit type conversion as entirely about the concept of context. The code `if foobar ...` means foobar (or its result) is implicitly converted to a boolean because it's in the context of a condition. I agree this limited form of context dependence doesn't mean the concept needs to be expanded, but it's obvious appropriateness is an example of the intuitive nature of context dependence and a hint that broader use of it in a programming language _might_ be interesting. Imo such expansion was successful enough in Perl 5 that it's very much a positive, though I'm glad Perl 6 fixes known warts such as the topic of the OP.
I don't get it... what's hard about this? I read the man page then looked at it, and okay it's going to [skip everything as void until @ar2 and then return the length](/spoiler) Am I wrong about this? It seems very straight-forward given the man page..
Ok, I'll defer to you on this one. Both predate my entry into the Perl world :-)
When you get that error, is it also true that your output for those same variables is nothing? I am a beginner at perl as well. I do know that even if you have declared the variables (like you have) if there values are never changed from undef. You will get a warning saying they are not initialized. To test this, on your declaration line (my ($dest_ip...) set these all equal to a value, 0 or "". That should remove the error. But the bigger issue is likely that some of your variables are not being assigned the values from the back references.
First off, see what happens if you add 'use strict;' just above the use warnings. If it reports anything fix it before continuing. strictures will make it easier to spot incorrect variable names and similar.
'my' declares the variable, but doesn't initialize it. If you try to print an undefined variable, 'use warnings' lets you know. I assume your regex isn't matching, so the variables are still undef when it comes time to print.
Ah, that makes sense. I don't know why I thought that "my" also initialized it. It really just sets the scope of the variable, right? Thanks!
I'll give that a shot. Thanks!
Yep, that's the problem. Brain fart on my part. For some reason, I was seeing the "my" and thinking that it was also initializing the variable and not just declaring it and setting the scope.
scratch that, I did it for you, strict found nothing. that said this code is not exactly straight-forward. For starters we have no sample of the files it processes, that might help. Second the regex's are not commented, and that first one is a real doozy, and should probably not be a regex, but rather a split /.../, $data. As for your specific problem, you have a conditional with 4 possible branches, 1, 2, 3 or none. in the second 2, as well as none, at most 2 variables will be set, meaning that unless you hit the first conditional you will have uninitialized variables. I am guessing the first doesn't have all the variables either, so really you should have uninitialized until all 3 conditionals have been hit once. I am going to take a guess here and assume that the file has 3 lines, one to match each conditional. I am also going to guess that they are laid out in order. I am making this guess based on the 'next' statement in the first 2 branches. If my guess is correct than you really want to move the print statements to the very end, outside the loop. You probably also want to remove the loop and just apply the regex to the correct line. With these assumptions, here is a cleaned up version. Even if the assumptions are wrong you can still use a lot of this to fix up yours. #!/usr/bin/perl use strict; use warnings; use Data::Dumper; my $datafile = 'router-tcam-acl-out.log'; open( my $df, '&lt;', $datafile ) or die "$datafile: $!"; my @data = do { local $/; &lt;$df&gt; }; close $df; chomp @data; print join "\n", @data; my %values; @values{qw/dest_ip src_ip dest_port src_port tcp_flags protocol tos/} = ( $data[0] =~ /^_V_\S+\s+(\S+,)\s+(\S+)\s+P=(\S+)\s+P=(\S+)\s+(\S+)\s+(\S+)\s+\S+\s+\S+\s+(\S+) /g, ); @values{qw/dest_mask src_mask/} = ( $data[1] =~ /_M \S+ (\S+) (\S+) /g ); @values{qw/result hit_cnt/} = ( $data[2] =~ /rtr\_rslt_(\S+) hit_cnt=(\S+) /g ); print Dumper( \%values ); 
Thanks! I'll need to do a little research to understand your version. My exposure to Perl consists of a three-day class I took last week. :) Your assumptions are correct. The log file is full of three repeating lines and I need data from all three before I print the result. Then again, I could just print the variables as they are assigned instead of doing the "next" that I had. Here's an example of the output of the log file: V 10186 0.0.0.0 10.0.0.0 P=0 P=0 ------ 1 ---- 0 0 -- C-- 0-0 M 10187 0.0.0.0 255.0.0.0 0 0 ------ 255 ---- 0 0 R rslt: PERMIT_RESULT (*) rtr_rslt: PERMIT_RESULT (*) hit_cnt=0 V 10194 0.0.0.0 10.0.0.0 P=0 P=0 ------ 6 --F- 0 0 -- C-- 0-0 M 10196 0.0.0.0 255.0.0.0 0 0 ------ 255 --X- 0 0 R rslt: PERMIT_RESULT (*) rtr_rslt: PERMIT_RESULT (*) hit_cnt=0 I appreciate the help!
Then maybe you should only print out the lot if the third pattern matches.
That's what I'm doing now. I realized that the print was outside the last elseif, so I moved it inside. I think I have everything working conceptually, but my regexes aren't matching yet. This is turning into a crash course in Perl regular expressions.
I'm still working on getting the regex stuff to match. I'm clearly not matching anything because none of my new test print statements are printing at all. Here is the latest version of my script. I'm sure there are much better ways to write this regex in a way that's a little more clear and, well, accurate. EDIT: Egads. I'm using underscores to match whitespace, but that's not valid in a Perl RE. lol I think if I write these correctly, they'll actually work! #!/usr/bin/perl use warnings; use strict; my $datafile = 'router-tcam-acl-out.log'; open DATAFILE, "&lt;$datafile" or die "$datafile: $!"; my @data = &lt;DATAFILE&gt;; close DATAFILE; chomp @data; my ($dest_ip, $src_ip, $dest_port, $src_port, $tcp_flags, $protocol, $tos, $dest_mask, $src_mask, $result, $hit_cnt) = (0,0,0,0,0,0,0,0,0,0,0); foreach my $data (@data) { if ($data =~ /V_\S+\s+(\S+)\s+(\S+)\s+P=(\S+)\s+P=(\S+)\s+(\S+)\s+(\S+)\s+\S+\s+\S+\s+(\S+)/) { print "\nFirst if is working.\n"; $dest_ip=$1; $src_ip=$2; $dest_port=$3; $src_port=$4; $tcp_flags=$5; $protocol=$6; $tos=$7; next; } elsif ($data =~ /M_\S+\s+(\S+)\s+(\S+)/) { print "\nSecond if is working.\n"; $dest_mask=$1; $src_mask=$2; next; } elsif ($data =~ /rtr\_rslt:_(\S+)_\S+\s+hit_cnt=(\S+)/) { print "\nWe're in the third if now.\n"; $result=$1; $hit_cnt=$2; print "\n$src_ip,$src_mask,$src_port,$dest_ip,$dest_mask,$dest_port"; print ",$protocol,$tos,$result,$hit_cnt\n"; } } 
You have spaces around your hello string.
And I believe I answered my own question.... The leading spaces are throwing things off. Probably because of some hidden character being at the beginning of the sentence. Brownie points for anyone who can show me how to make the split work without manually ripping off the preceding spaces (this is what I'll simply do for now).
http://perldoc.perl.org/functions/split.html It's not doing what you think it is.
Please excuse my ignorance, as I read before this post, and once more when you linked, and still do not understand what is wrong. Say I have the string 'hello world my name is anothernametaken' and I only want the tokens from that array. What would my split look like then? As opposed to the string preceding with a space, ending with a space, or both, I don't see why that matters.
It's because you're telling split to split on space, with the default limit of one. So split see it as this: **' hello'** So you are seeing it exactly as you asked for it. If you gave split an higher limit for split you would also caputre the last space as well my @tempArray = split(/\s+/,$currentLine, 4); It would return this: $VAR1 = [ ' ', 'hello', ' ', ] **[EDIT]** If you want just **'hello'** try this: my @tempArray = split(/\s/,$currentLine); getting rid of the "+" (regular expression more then one). 
Ohhhhh! So split() looks at either side of the space, not just what is between the spaces?
Ohhhhh! So split() looks at either side of the space, not just what is between the spaces?
If you tell it to.
Auto-deref is a nice idea, it a bit more python like. But it such a new feature I have not played around with it. Maybe it would be good to have it as a Module so user can just use it when they like.
Use the Text::Trim module from CPAN (does what you want): https://metacpan.org/pod/Text::Trim
It *splits* on spaces.
 my @tempArray = split " ", $currentLine; The [`split` documentation][1] explains &gt; As another special case, `split` emulates the default behavior of the command line tool **awk** when the PATTERN is either omitted or a literal string composed of a single space character (such as `' '` or `"\x20"`, but not e.g. `/ /`). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were `/\s+/`; in particular, this means that any contiguous whitespace (not just a single space character) is used as a separator. [1]: http://perldoc.perl.org/functions/split.html
I've been using Moo (which uses Role::Tiny for its Roles) and can say that it's a very great perl way to do Roles (and Moo is great in general, of course). Everything works exactly how I would expect it to.
I don't like the last sentence of that article. &gt;Using Role::Tiny is a nimble way to add roles to the existing Perl object oriented syntax without using an entire object system such as Moose. The benefits of roles especially come into play when you have an object system. And Moose::Role even has the exact same syntax. I understand why someone would like to give an introduction in Roles without all the other things involved, but this sentence makes no sense to me. Furthermore it should point out that the `does` method is in the UNIVERSAL package and therefor build into perl itself. Any Role implementation you use should overwrite that method for you. And why is the area of a point 1? I'd have expected it to be `0` or even like this `sub getArea{...}` (not implemented).
This doesn't contain anything specific to 5.18, does it? That looks like it would run fine on 5.8. 
First sprintf the number into a variable. Then printf the resulting (string) variable into a fixed width field. That will justify or pad it.
just like in the printf(3) manual: "%5.8e" -- except that is nonsensical since 8 digits plus other stuff won't fit into 5 characters. Try "%13.8e" and see if that works for ya.
How do you expect to fit eight digits plus a dot plus whatever is before the dot, in five characters? :)
i don't get it. i guess that's because i don't know whio rammstein is. sounds german
yeah, but you should look in the sprintf(3p) manual, which is likely not installed on your system. [`perldoc -fsprintf`](http://perldoc.perl.org/functions/sprintf.html) could help.
Magic!
If you could program your way out of a paper bag, you wouldn't need an intro course. Take the course and stop being a baby. People will help you, and by help you, I mean they will explain things to you that you're confused about and point you at helpful things to read so you can understand the material. Programming can be fun. Figuring things out can be fun. Learning can be fun. Embrace it!
I'm not sure if he was asking for help/tutoring, or outsourcing...
I still don't really understand why you'd want this in the cloud though. What's wrong with a config file in your VCS?
TIMTOWTDI. If config files in VCS work for you, then stick with it. But for some shops, a private CPAN is a preferable solution. And putting it in the cloud improves accessibility and eliminates the hassle of maintaining it locally. I think Stratopan can add value in other ways too. Like enabling sharing &amp; collaboration, the dependency graphs, and upgrade notifications. Sure, you can find ways to do all that yourself. But you've probably got better things to do.
can someone explain me how to interpret this? Although I'm german I can't relate to the "Du hast" Lyrics in any way. does this even make sense?
Is CL written in Perl? I did not know that. 
Yup. At least one CL developer hangs around here, too.
I hope [Larry's on the design committee](http://www.wall.org/~larry/).
I love that color so much I use it everywhere I can.
Brilliant irony in the job title.
See also [earlier post of this same news](http://www.reddit.com/r/perl/comments/1omgp5/larry_wall_now_an_artist_in_residence_at/).
I helped with this in #catalyst, but the advice applies pretty well to any kind of PSGI app that uses SCRIPT_NAME/PATH_INFO to figure out where it's based and generate URLs, not just a Catalyst app.
For regex in perl it would be something like this: $ssn =~ m/[0-9]{4}-[0-9]{2}-[0-9]{3}/;
Here.. have an[other] upvote. Thanks! Works perfectly!
You're welcome! Another thing I noticed, is that if you want to match that the string is only that, you can do what /u/TrollJoel did by adding a ^ at the beginning and $ at the end, so mine would become: $ssn =~ m/^[0-9]{4}-[0-9]{2}-[0-9]{3}$/; 
it should be: $ssn =~ m/[0-9]{3}-[0-9]{2}-[0-9]{4}/; [SSNs are 9 digits long](http://en.wikipedia.org/wiki/Social_Security_number#Valid_SSNs) in the pattern 3 digit, 2 digit, 4 digit.
No it doesn't. [SSNs are 9 digits long](http://en.wikipedia.org/wiki/Social_Security_number#Valid_SSNs) in the pattern 3 digit, 2 digit, 4 digit. this regex is a pattern of 4 digit, 2 digit, 3 digit so it won't match SSNs, but numbers in XXXX-XX-XXX form (where X is a number). 
Maybe I'm missing something, but why not just use vHosts? That's how I handle multi-tenancy, which is essentially the same thing.
It's what I'd do too, but it's not what the user wanted.
Give the people what they want... Actually, these days, if it's a plack/psgi app, I'd have starman serve the app over an alternate port [firewalled to the "outside" of course], 8080 or 80443 seems to be "standard" ([whatever that means](http://xkcd.com/927/)), then have ngnix reverse proxy my web server(s). This paradigm allows for easier scaling, even if starman and nginx start on the same server, adding additional web hosts is just a matter of turning up starman and pointing nginx to the starman. And again, I'd use the nginx equivalent of vHosts (which really, is just additional `server {}` blocks). Any thoughts comments on this approach as opposed to the Apache approach?
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Alt-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 77 time(s), representing 2.74118903524% of referenced xkcds. --- ^[Questions|Stats|Problems](http://www.reddit.com/r/xkcd_transcriber/)
Actually, these days, I think [Varnish Cache](https://www.varnish-cache.org/) is the "recommended" way to go. I've not used it in a project, but I hear it's the "wave of the future"... It seems to work well in front of bot Apache and nginx, I wonder how it would do against starman.
Excellent article! I would just like to point out that some of us still use Usenet and lurk comp.lang.perl.misc here and there. Usenet is not dead. Yet. 
Very sexy website. This is just what the Perl community needs.
Apparently you can hire them to do [Java Enterprise Solutions in the Cloud](http://www.evozon.com/about-us/meet-the-evozon-team).
yes, we also have strong .net, mobile, it and php departments. Is anything wrong if an outsourcing company like evozon wants to give back to the community and allocates design, dev and marketing resources to promote the beauty of perl? we are more than 40 perl devs in the company and most of us were trained or converted to perl by evozon. About 2 weeks ago evozon organized a cluj.pm meeting with 120+ attendees, in order to promote perl locally even more. While the final objective for evozon is profit, as it is for any company, I'd say that evozon is the clear example that profit can be obtained beautifully for all the parts involved: developers, the community, the perl ecosystem and evozon.
&gt; perl echosystem Did you just make that up? There are zero matches for that on google. The OP site, your above comment, and the "perl echosystem" phrase are all great exemplars of things I love about Perl. Thanks! 
it's ecosystem, I corrected it - thx for pointing that out
Nice site! Very well done.
Love it - great work guys!
Your match is wrong. It will never match a SSN.
Freudian slip, perhaps? :)
Downvoted? Hmm. tudorconstantin and other Perlers, I apologize if you took my comment the wrong way. I love Perl, puns, and self-deprecation alike and I thought it was both deliberate and funny.
http://www.youtube.com/watch?v=Sc8PqAU7Cgk http://en.wikipedia.org/wiki/Du_hast
I'm an systems admin at a Fortune 10 company, I have a small library of scripts that I've written for various tasks to manage 2000+ Unix systems. With so many systems even routine tasks become incredibly complex, and a well written Perl script can be a life saver. I also write ad hoc scripts often for special cases that come up all the time
25% doesn't really mean anything. 25% of what? Generally though, I wouldn't really be concerned unless it continues to grow over time.
This has happened every day for the last 3 days. And it happens intermittently throughout the year including in some of our very slow times. This happened last year on one of the biggest days and we lost a *huge* amount of traffic during the times it went out, yet oddly it works on some of our highest traffic days without a problem. I'm at a total loss as to what to do, and with my actual monetary losses hitting several thousand dollars that we can't necessarily afford I'm starting to freak out. 
What kind of hosting are you using? For your web host to be telling you you need to fix stuff, it almost sounds like you're using shared hosting. If that's the case, and this is important to your business, get yourself on a dedicated server / VPS pronto, where you have plenty of RAM all to yourself. RAM is cheap these days. 25% might not be a big deal - depends how much it is in real terms and whether it's actually causing you problems. You've also not told us what your code is running on, whether the usage grows slowly until you restart, etc... not much to go on. Other than that, if the RAM use really *is* excessive, you probably want to hire someone who knows what they're doing to review your code for you, if your tech guy can't solve it. Oh, as for "My tech co-founder says this is normal as it's PERL" (it's "Perl", by the way), Perl can use more RAM than, say, compiled C, but RAM is cheap these days, and programmer time isn't - so, yeah, your tech guy isn't far off, and the most efficient fix (in terms of cost and time) is often to throw more RAM at it :)
I guess I don't really understand what is being asked. Why does this flat file ever need to exist? Why wouldn't you just write your `Project` class so that it directly queries the database to implement methods like `$project-&gt;date()`? Are you asking how to do that? Have a look at [`DBI`](https://metacpan.org/pod/DBI) and the various DBD drivers (e.g. [`DBD::mysql`](https://metacpan.org/pod/DBD::mysql).) 
You shouldn't really think of it as "creating objects." You're designing an API for someone to use. You'd want to sit down and think about all the possible interfaces that a user might need to do whatever they want to do. Those roughly become the methods that you'll implement in your class. You'll also have to think about what state the class maintains, i.e. what bits of information does it need to store locally, and what bits of information can just be queried from the database when required. You can start sketching out a class design once you have rough ideas of the behavior and state.
&gt; what bits of information does it need to store locally, and what bits of information can just be queried from the database when required. I think this is my problem. Querying the database is kind of slow. In my mind I query the database, get all of these rows back and then allow someone to iterate through the results getting what they need from the rows through a typical "getter" interface. I'm just not sure about the best way to set this up. I think the link I added is close to my question. 
In that case it sounds like you need to write better queries. The database should be doing all the work, not the thing querying it. If you find yourself pulling down huge result sets that you then iterate over to find some result, you're doing it wrong. Do all of that in the query.
I'll just point out there is a [DBD driver for CSV](http://search.cpan.org/~jzucker/DBD-CSV/lib/DBD/CSV.pm). This will let you do CSV/flat files today, and flip drivers to hit a database tomorrow. If you do both at once you can have a migration.
Perl doesn't give memory back to the OS, ever. It will garbage collect internally and reuse that memory so it doesn't leak, but it won't give it back for the OS to use for other purposes.
1. What is your code -doing-? That would be good to know. 2. What is your environment? For example, is it PSGI, mod_perl, or...? 3. Suggestions to get help via jobs.perl.org or scrottie are good suggestions. There's -tons- of expertise for hire, although most of it is off the radar (but still accessible). 
$50 an hour for scrottie *is* a steal.
&gt; In that case it sounds like you need to write better queries. The database should be doing all the work, not the thing querying it. That's the bit I find interesting, because the goal is to have all of this information. For example if I have a dataset all generated at different times but all measuring the same thing I'd want a collection of those returned to me. The set I would then go through and run a procedure on. After talking to some coworkers (in a group more focused on programming) they agreed with you. That the queries need to be more specific. So i'm going to go back to the drawing board on this. Sometimes just saying this kind of stuff aloud helps get perspective. 
So far everyone has said this which leads me to believe that I don't know my question either. I believe I was trying to figure out a design pattern for making classes that talk to a database that then make iterable objects... but I'm not sure if I even understand my question anymore!