how about just sed? sed -e 's/,/\t/' file.csv &gt; file.txt
What do you mean by .txt? A .csv file is just a file where values are in rows (per line) and fields (seperated by ,).
.csv is already a plain text file format. You can simply change the extension from csv to txt. mv file.csv file.txt If you wish to convert from comma delimited to tab delimited, that's a bit more complicated. Try Googling "csv to tab delimited" and check out the possible solutions. 
Why should be impossible to compile to bytecode? It's trivial to compile and run with the bytecode compiler. $ perl -MO=Concise -e'my ($x, $y) = (q($y = $x), q(x)); eval "$x"; print $y;' f &lt;@&gt; leave[1 ref] vKP/REFC -&gt;(end) 1 &lt;0&gt; enter -&gt;2 2 &lt;;&gt; nextstate(main 1 -e:1) v:{ -&gt;3 7 &lt;2&gt; aassign[t3] vKS -&gt;8 - &lt;1&gt; ex-list lKP -&gt;6 3 &lt;0&gt; pushmark s -&gt;4 4 &lt;$&gt; const(PV "$y = $x") s -&gt;5 5 &lt;$&gt; const(PV "x") s -&gt;6 - &lt;1&gt; ex-list lKPRM* -&gt;7 6 &lt;0&gt; padrange[$x:1,2; $y:1,2] lRM/LVINTRO,2 -&gt;7 - &lt;0&gt; padsv[$x:1,2] lRM*/LVINTRO -&gt;- - &lt;0&gt; padsv[$y:1,2] lRM*/LVINTRO -&gt;- 8 &lt;;&gt; nextstate(main 2 -e:1) v:{ -&gt;9 b &lt;1&gt; entereval[t256] vK/1 -&gt;c a &lt;@&gt; stringify[t4] sK/1 -&gt;b - &lt;0&gt; ex-pushmark s -&gt;9 9 &lt;0&gt; padsv[$x:1,2] s -&gt;a c &lt;;&gt; nextstate(main 2 -e:1) v:{ -&gt;d e &lt;@&gt; print vK -&gt;f d &lt;0&gt; padrange[$y:1,2] l/1 -&gt;e - &lt;0&gt; padsv[$y:1,2] l -&gt;e -e syntax OK $ perl -MO=Bytecode,-oa.plc -e'my ($x, $y) = (q($y = $x), q(x)); eval "$x"; print $y;' $ disassemble a.plc #magic 0x43424c50 #archname "x86_64-linux-debug" #blversion "0.11" #ivsize 8 #ptrsize 8 #byteorder "0x12345678" #longsize 8 #archflag 0 #perlversion "5.020000" # [GV 1] gv_fetchpvx "Regexp::DESTROY" sv_flags 8421385 # 0x808009 xgv_flags 2 # 0x2 gp_refcnt 1 newpv "-e\000" # -PV- 2 stpv 2 gp_file 2 gp_line 4294967295 # [GV 3] gv_fetchpvx "IO::File::DESTROY" sv_flags 32777 # 0x8009 xgv_flags 2 # 0x2 gp_refcnt 1 gp_cvgen 17 gp_file 2 gp_line 2 # [GV 4] gv_fetchpvx "IO::File::AUTOLOAD" sv_flags 32777 # 0x8009 xgv_flags 2 # 0x2 gp_refcnt 1 gp_cvgen 17 gp_file 2 gp_line 2 # [leave 5] newopx 24120 # size:56, type:188 op_flags 13 # 0xd vKP op_targ 1 op_private 64 # 0x40 REFC op_slabbed 1 # [print 6] newopx 28984 # size:56, type:226 op_flags 5 # 0x5 vK op_next 5 op_slabbed 1 # [padrange 7] newopx 48424 # size:40, type:378 op_flags 3 # 0x3 l op_next 6 op_targ 2 op_private 1 # 0x1 1 op_slabbed 1 # [nextstate 8] newopx 23632 # size:80, type:184 # [SPECIAL 9] ldspecsvx 6 # (SV*)pWARN_STD # [STASH 10] gv_stashpvx "main" sv_flags 838860812 # 0x3200000c newpv "main\000" # -PV- 11 stpv 11 xhv_name 11 sv_refcnt 2 # [GV 12] gv_fetchpvx "main::_&lt;-e" sv_flags 32777 # 0x8009 sv_refcnt 5 gp_refcnt 1 # [PV 13] newsvx 17411 # type=3,flags=0x4403 newpv "-e\000" xpv # -GP/AV/HV/NULL/MG- ldsv 12 gp_sv 13 newpv "\000" # -PV- 14 stpv 14 gp_file 14 op_flags 1 # 0x1 v op_next 7 op_slabbed 1 cop_stash 10 cop_filegv 12 cop_seq 2003 cop_line 1 cop_warnings 9 # [entereval 15] newopx 42288 # size:48, type:330 op_flags 5 # 0x5 vK op_next 8 op_targ 0x000000100 op_private 1 # 0x1 1 op_slabbed 1 # [stringify 16] newopx 8760 # size:56, type:68 op_flags 6 # 0x6 sK op_next 15 op_targ 4 op_private 1 # 0x1 1 op_slabbed 1 # [padsv 17] newopx 1192 # size:40, type:9 op_flags 2 # 0x2 s op_next 16 op_targ 1 op_slabbed 1 # [nextstate 18] newopx 23632 # size:80, type:184 op_flags 1 # 0x1 v op_next 17 op_slabbed 1 cop_stash 10 cop_filegv 12 cop_seq 2003 cop_line 1 cop_warnings 9 # [aassign 19] newopx 4920 # size:56, type:38 op_flags 69 # 0x45 vKS op_next 18 op_targ 3 op_slabbed 1 # [padrange 20] newopx 48424 # size:40, type:378 op_flags 51 # 0x33 lRM op_next 19 op_targ 1 op_private 130 # 0x82 LVINTRO,2 op_slabbed 1 # [const 21] newopx 688 # size:48, type:5 # [PV 22] newsvx 134300675 # type=3,flags=0x8014403 newpv "x\000" xpvshared op_flags 2 # 0x2 s op_next 20 op_slabbed 1 op_sv 22 # [const 23] newopx 688 # size:48, type:5 # [PV 24] newsvx 134300675 # type=3,flags=0x8014403 newpv "$y = $x\000" xpvshared op_flags 2 # 0x2 s op_next 21 op_slabbed 1 op_sv 24 # [pushmark 25] newopx 424 # size:40, type:3 op_flags 2 # 0x2 s op_next 23 op_slabbed 1 # [nextstate 26] newopx 23632 # size:80, type:184 op_flags 1 # 0x1 v op_next 25 op_slabbed 1 cop_stash 10 cop_filegv 12 cop_seq 2002 cop_line 1 cop_warnings 9 # [enter 27] newopx 23976 # size:40, type:187 op_next 26 op_slabbed 1 main_start 27 main_root 5 # [CV 28] newsvx 13 # type=13,flags=0xd # [PADLIST 29] newpadlx 1 # [AV 30] newsvx 1073774603 # type=11,flags=0x4000800b # [SPECIAL 31] ldspecsvx 1 # &amp;PL_sv_undef # [PVNV 32] newsvx 17414 # type=6,flags=0x4406 newpv "$x\000" xpv cop_seq_low 2002 cop_seq_high 2003 # [PVNV 33] newsvx 17414 # type=6,flags=0x4406 newpv "$y\000" xpv cop_seq_low 2002 cop_seq_high 2003 # -GP/AV/HV/NULL/MG- ldsv 30 av_extend 3 av_pushx 31 av_pushx 32 av_pushx 33 # [AV 34] newsvx 1073741835 # type=11,flags=0x4000000b # [NULL 35] newsvx 262144 # type=0,flags=0x40000 # [NULL 36] newsvx 262144 # type=0,flags=0x40000 # [NULL 37] newsvx 131072 # type=0,flags=0x20000 # [NULL 38] newsvx 131072 # type=0,flags=0x20000 # -GP/AV/HV/NULL/MG- ldsv 34 av_extend 5 av_pushx 0 av_pushx 35 av_pushx 36 av_pushx 37 av_pushx 38 # -GP/AV/HV/NULL/MG- ldsv 29 padl_name 30 padl_sym 34 # -GP/AV/HV/NULL/MG- ldsv 28 xcv_padlist 29 xcv_flags 1280 # 0x500 main_cv 28 curpad 34 dowarn 0 ret And you can re-assemble the disassembled bytecode and run it. Any of the compilers which see eval needs to include libperl to be able to parse it, and executing any function needs to include the runloop. B::CC unrolls most parts of the runloop and ops and uses optimized version if the code is not too dynamic, but regular perl code runs through the perl ops. On the various compiler projects: you want to checkout http://perl11.org/. rperl uses it's own parser because it extended the syntax to much, p2 also uses it's own parser and vm, perl5 on perl6 uses the perl6 parser and vms, perlito parses and compiles it by itself to any vm, gperl is like p2, but compiles to LLVM, not lua-like bytecode or jit. 
yes
A .csv file already is a text file, so your question in not quite clear to me. Could you post an example of the input you have and the output you expect ? A couple of lines should suffice.
Fields within a line of CSVs may have commas embedded in them, so that regex would split them erroneously.
As everyone else has pointed out a csv file is already a text file. Is there any chance that your question is more complex and the file is actually in excel or some other proprietary format? Also it should be pointed out that if you are using windows, you don't need to open it in excel and "save as txt" you could just rename the file, or use "open with" and open the csv file using something other than the program windows chose for you.
What is "len"? Is that your function? Are you sure the error you are getting is actually on the line you say it is on? Does len have any unexpected side-effects (like altering the value of $t1)? The built-in string length function in perl is called "length". Also, your regular expression already implicitly guarantees that the length is greater than zero.
The article's about **X**HTML and XML::LibXML; the rules and common practices for creating/consuming HTML are looser than those for XML. I was hoping to find out some esoteric tricks for HTML::Parser when I saw the link title. For instance, I've had an issue where HTML::Parser doesn't process the last bits in the buffer unless I append an otherwise-extraneous closing tag, e.g.: $parser-&gt;parse( $text . '&lt;br /&gt;'); Don't know why that's necessary, but I'd hoped that maybe there was something I was overlooking that might have been covered here.
Why not [Text::CSV](http://search.cpan.org/~makamaka/Text-CSV-1.32/lib/Text/CSV.pm)? 
Thank you reini_urban for the time you've taken to enlighten me.
A CSV could also have quotes(") as the text qualifying and escaping if some of the text has quotes or commas in it. If it's a true CSV with the potential of all that entails, I tend to use [TEXT::CSV](http://search.cpan.org/~makamaka/Text-CSV-1.32/lib/Text/CSV.pm)
For spreadsheet solutions without Windows, LibreOffice will also handle CSVs just fine.
Ugh. Unless you **KNOW** it's gonna be XHTML, please don't use libxml for parsing HTML. Except for XHTML, HTML is not XML. Perl has excellent libraries for parsing HTML - I suggest HTML::TreeBuilder. 
You may want to watch [perlcc made easy or, how to make a CGI Moose app](https://www.youtube.com/watch?v=PkvaqgyGDEc) from YAPC::NA 2014.
Awesome, thank you!
The only other one I've heard of which looked enterprisy was Bricolage. Never used it though. 
[Mojo::DOM](http://mojolicio.us/perldoc/Mojo/DOM#SYNOPSIS)
changing the extention doesn't work, I'll try to tab delimited 
yeh, that doesn't work for some reason
I expect the input and output to look the same if opened in excel but one is comma separated, and one is tab seperated
Thanks I'll try it in work tomorrow!
Might check out [Catalyst](http://www.catalystframework.org/) and/or [Dancer](http://www.perldancer.org/)
They're not CMSs though. They're frameworks. You would use them to *build* a CMS but they're not out-of-the-box solutions. In fact there isn't really a box. 
Those are frameworks, as opposed to "ready-to-go" content management systems. Catalyst is like CakePHP, not WordPress... right?
There is Movable Type. Old but still kicking around. but not open source anymore. 
Write your own CMS, it's a rite of passage.
&gt; a rewrite based around Moose There goes your speed. This pretty much implies it will be unusably slow without mod_perl.
Even though I already chipped in for that WebGUI project, I'd rather support any Kickstarter (or sponsored in any other way) Perl project that is - Mojolicious based, or has other minimal CPAN dependencies (not more that 5-7 non-core modules), or has all modules as part of installation - "Drop-in" installable on **shared web hosting without shell access** - Skinnable - Extendable via plug-ins - Easy to configure (UI configuration options, minimal-to-none config files / .htaccess editing) Doesn't need to be big flexible CMS (a successful project can grow into one if needed, i guess). Can be something smaller, more more specific than a general CMS: - a blog engine - an independent ad/banner rotating app - social network kind of site - a classifieds directory - a job board - a real-estate directory When there'll be Perl apps I can just drop files in via FTP to a share hosting account, install a couple of dependencies (not half of the CPAN) via CPanel UI, configure a few things... and I have a working application that just may need a face lift.. then more people will use Perl web apps.
Moose is slow to start but not slow to execute. Assuming this app ran in a FastCGI process, the app would already by in memory.
With cheap virtual hosting services, proper shell access isn't the limit it used to be. There's still the do-your-own-sysadmining issue, but it's workable. There's also technical reasons why it's easier to do that with PHP rather than Perl. The mod_php approach is a lot less sophisticated than mod_perl.
Version 0.07 has been released to CPAN and should be available shortly for use. The following features have been added: * "mbxilinx" commandline program can now take a YAML file with your parameters and generate the Build script instead of the user having to write a Build.PL file. This simplifies the workflow by not forcing the user to write any Perl and to instead write/generate some YAML with all the required parameters. 
Great video, seems to cover all the bases. I'm writing a new module atm and am wondering what the most modern / hip framework to use for it is these days?
[Moo](https://metacpan.org/pod/Moo) is a good choice which implements most of the features of Moose without the big dependency chain. 
I meant the framework for managing the distribution. Like Dist:Zilla etc
I've used Module::Starter before, using the default of EUMM. Can you outline the basic advantages of using Dist::Zilla?
I like Moo but at the moment I'm messing around with Moose and using it for built in type support.
&gt; Assuming this app ran in a FastCGI process That is a lot to assume. For cheap web space providers, PHP is working properly (pages served in 50ms or less), while perl is very often limited to CGI. And then, Moose is a speed killer, especially for the startup time.
Should be fairly easy to hack that change in. I haven't released this as a module, so if you want to do something interesting, go ahead!
left of ajax (which is left of the bigger jquery), with 38490
Thanks for the info, I started looking into it earlier and am moving my stuff over.
People who write Perl need less help :D?
Broke but tweeted it. Yay internet? sadface
Perl people don't do such complicated things!
Most of the questions Perl folks have have already been solved on perlmonks long ago. A quick search for an issue will pull that solution up first, so it never ends up on stack overflow.
Could you elaborate? Thank you.
I write all of my new modules in perl-6. It's up-to-the minute, by which I mean that when Rakudo developers stop drinking beer long enough to squat out a new commit, it's likely to have broken everything and I have to scramble to make my code work again. That's why my bioinformatics lab switched from Python 2 to perl-6, because its more exciting to be on the cutting edge where everything is changing and nothing is stable than to get actual work done.
1. #perl6 is full of weird stalkers with weird names like Ralphie boy 2. #perl6 is full of in-jokes by a weird crowd of drinkers who abuse other people 3. #perl6 can't finish anything it starts
Ha, I really hope Perl 6 does manage to come together and become a practical language.
Maybe in another 14 years!
I hope that if anything comes together you wrap it up and chuck it on CPAN :)
Do people still use CGI for anything other than a one-off function?
Will these be demonstrations of good coding style, examples of practices that new programmers should imitate? or, well, the other kind?
lol. I guess you could say they were coded with best practices in mind. Probably not the best practices of today, as they were written before some people in this sub were born. The most enlightening section would be where I rolled my own cgi.pl (with basic html template parsing) before I knew about modules
Thanks for posting, always enjoy reading John's Catalyst updates and musings.
Just a thought... you're accounting for the \n in the last line, right?
This may be of use to you http://perldoc.perl.org/perlrebackslash.html#Character-Escapes
This works fine for me. Are you using Windows? If so newlines are \r\n instead of \n. Chomp might just be removing the \n and leaving the \r.
It works for me. Let's put quotes around the name part, to test if the newline you're getting is inside the `$namme` variable or if it's coming from somewhere else. I'm running $ perl -e 'use warnings; use strict; print "Hi there.\n"; print "What is your name?\n"; my $namme = readline STDIN; chomp ($namme); print "Hi \"$namme\"\n";' and getting Hi there. What is your name? mao_neko Hi "mao_neko" 
You could separate the contents with a specific text cat $path1 ; echo "separator"; cat $path2 But you're better off using tar and sending the output to stdout: "ssh remotehost tar -cf - $path1 $path2" Then have perl decode the tar stream. What will suit your environment best totally depends on your use cases. If it's just the two files then writing a simple parser would work as well as tar. If it might expand to any number of files or they're large sizes then tar works much better. You can use gzip to compress before sending and uncompress with IO::Uncompress::Gunzip (or the perl tar thing might be smart enough to do it automatically) Even this has it's limitations. If you're doing this for systems management for hundreds of machines, look at puppet, chef or salt or something. You might consider a distributed NFS mount but it'll depend on your network as to whether that is a good idea.
A distributed NFS mount is a bad idea because some of the services on many of the machines start before NFS does. I am planning on migrating the user accounts to the freeipa systems we are barely using. That way the accounts are in a highly replicated, and highly distributed and centralized for easy management. making a tar steam sounds like a wonderful idea. I am going to have to rework the data structures anyways so I can even open up the possibility for it to be asynchronous. I am glad I written the program in a functional style.
That was the problem. It's my first day roflz. Thanks for helping.
Go SF.pm! (And thanks for all the free pizza.)
Those thanks belong to craigslist. :-)
...and on one will miss it.
https://metacpan.org/release/MCE is what you need. perl threads - just say no. 
As a rule of thumb, everything you ever do is IO bound. Unless what you're doing is computationally difficult, aka 3d rendering or bitcoin mining, your program does relatively no work and just waits for the disk all the time. If you're on a conventional non-raid spinning rust disk, the only way that threads will help you is if when you reimplement your code with threads, you accidentally fix some bottlenecking bug. ALSO, whenever you're doing work in parallel and then aggregating at the end, don't use threads, use processes. At the point where your computing dwarfs the IO cost, and you have a modern computer with a bunch of cores, you can just use a program like gnu parallel to split up your job in to pieces and still just use your regular single treaded perl program to process each chunk.
I'm not sure you'll see much speedup threading this. You may even see a slowdown. File IO is probably going to be the slowest part of the program unless you're doing some hardcore analysis on each line. Splitting the computational analysis between multiple cores when you're IO bound isn't going to improve things and the overhead of the threads may actually hurt your speed. But to answer the question you asked, here is a pretty simple and clear example of asynchronous threading with perl: http://chicken.genouest.org/perl/multi-threading-with-perl/ 
What? But I heard right on this subreddit that it was basically production ready, if you had to pound several paper cups of koolaid before deploying something to production! Ralphie boy was VERY CONFIDENT that this was the case!
maybe "gnu parallel/split/xargs + your script" will be sufficient
To add to this, you do not want to feed the data around 100 lines at a time. Your entire program would shift from IO bound to CPU bound with interprocess/interthread communication being the only thing happening. You want to use chunks and the chunks should be fairly large because passing them is a thing, then processing them is a quick thing, then handing back the results is another thing. If you want to do this you should mmap the file, which tells the operating system to treat the file as a memory buffer. Here are some webpages to check out: http://perldoc.perl.org/PerlIO.html#:mmap http://stackoverflow.com/questions/1052765/linux-perl-mmap-performance edit: one more thing. mmap might be overkill or the wrong approach since you're hopefully doing sequential reads in chunks. You could just open the file and seek() to the right area then read a chunk. A problem amongst many is the file may be fragmented on disk and seek times might be slow. Better IO is the only solution for things like that though, SAN or SSD. 
Can you elaborate?
[Don't optimize without measuring. Premature optimization is the root of all evil.](http://c2.com/cgi/wiki?PrematureOptimization)
&gt; sleep(0.1); `sleep` doesn't work on fractional seconds.
It does if you &gt; use Time::HiRes qw(sleep); 
yea I think multithreading this is gonna be a waste. you need to run through the entire file no matter what. So, perhaps you are better off sticking into an RDBMS of sorts, indexing whatever you are looking for and doing lookups then. sqlite maybe?
Whoops! That's what I get for not waking up all the way.
I was gonna say this. Unless this file is already in memory, threads won't help. I doubt even RAID sharding would make that much difference.
http://www.gnu.org/software/parallel/man.html#example__processing_a_big_file_using_more_cores
As others have said, you're bottleneck is in the IO of the file itself unless you are doing something very computationally heavy. But if your delay is in fact in processing the data - use http://perldoc.perl.org/Thread/Queue.html and have the master read the file and drop data into the queue that the work threads each eat of out.
One more thing - try IO::File using sysread($buffer, 8192) and read the file in 8k chunks - you might see a 10x speedup on the file reads - but you need more logical to then separate that data into individual lines becaues the buffered read will likely land in the middle of lines. There is also this: http://search.cpan.org/~msergeant/DBD-SQLite-0.31/lib/DBD/SQLite.pm Read the files in an in-memory SQLite database and execute SQL calls against it for your processing.
Does MCE somehow implement a true shared memory execution model?
By "spin", do you mean distro?
&gt; everything you ever do is IO bound This is hooey. Languages like Perl are slow as hell at all sorts of things compared to compiled code and it has nothing to do with IO. I have had to rewrite a dozen things in C++ to get decent performance. Just a straight port to C++ of some vanilla process that reads in data, processes it in various ways, and spits it out has resulted in 100X performance improvement. Now, I must say I'm usually grateful to have done the prototyping in a dynamic language and get a design working. This "IO bound" lie needs to stop.
You should profile your code before you resort to parallelization. What exactly do you mean by "parse"? What is this log file? Are you simply using one line at a time? Or is it a more complicated multi-line format? If you're running a dozen complicated regular expressions it's not unlikely that tweaking the code could buy you 5X improvement. If this log file is in a format that has a proper C module to parse it, that might help enormously. If you're on a 64-bit machine with 64-bit perl and you're copying lots of lines around to process them, you might get a big improvement by mmap-ing the whole file.
&gt; you're bottleneck is in the IO of the file If it's taking 15 minutes to get through 2gig on a modern machine the problem is almost certainly not IO. Even low end hardware can grep through 2gigs in a matter of seconds. I would lay money he is doing something very wasteful in the processing that is taking all the time.
The story was strangely missing from /r/perl6 so I fixed it. You are welcome.
We are not talking about computationally difficult stuff. We are talking about things like aggregating data into simple structures in memory. Even the most trivial processing beyond what grep does is going to be measurably slower in a dynamic language than what can be achieved with C++. You have drunk the "disk io bound" kool-aid and I have to break it to you that you've been mislead. While we're on the topic, cpu cache io is a very important bottleneck in all kinds of code. Languages like Perl have horrible characteristics when it comes to the instruction and data caches, nevermind all the VM overhead. Perl is great for all sorts of things but you really need to understand that it very, very slow and disk is usually not the problem.
That's what I was thinking.
Do you mind me asking how you're parsing this file? I just finished a similar project to parse 6 IIS logs that total 4.5GB and around 19.5 million lines. The six logs parse in 6 minutes and 36 seconds. I just timed it when I saw your post. What kind of hardware is this script running on? 15 minutes is way too long. I work at a very large university if you're wondering about the size of the IIS logs.
None of this money better be squandered in any Perlsix related adventures. Even I sticked a fork in that thing. It is only a matter of time before even TimToady will say Perlsix is not Perl. **EDIT:** I consider PHP to be more like Perl more than Perlsix. At least it has database drivers.
You are simply wrong that IO is the typical bottleneck. I don't know why you can't understand this.
An up-to-date system perl (5.18 at least), and various alternate versions/compilations pre-installed that you can switch to using perlbrew or similar.
The master thread is more or less your own version of GNU Parallel. GNU Parallel is free software (GPL), so maybe there is code in that, which you can use. Especially the code for --pipepart seems relevant.
You could use xargs to multiprocess it xargs -P 3 -n 1 &lt;COMMAND&gt; &lt; &lt;FILE_LIST&gt; Where "3" is the number of processes to spawn
This is mostly wrong. A decent spinning disk should be able to give you that log file in and out in under a minute. You are bound by your algorithm here or you are doing your IO wrong. Unfortunately your question is also way too generic to answer correctly. The answers would range from simply improving the algorithm all the way up to Hadoop. I think what this commenter meant to say is that most data heavy workloads are IO bound, and there is not you can do about a straight IO bound workload except for finding ways to avoid IO (cache, etc), making the access less random, or simply making the IO faster.
vim
Do you have your code for reading the file? There's probably some faster method you could use instead. When I have a big file like that, I use sysread to read in raw chunks, and use application logic to break it into whatever structure I need. I also typically update/compute things as I read through the file, like updating an average or sum or whatever. 
I think you replied to the wrong post. 
I'm not entirely sure what you hope to achieve with this. Built for general Perl development can mean so many things. Now if you were building it for a specific purpose like a web stack, then it might make more sense (Perl + Plack + Starman + nginx + MySQL + ElasticSearch + Memcached + Beanstalkd). But here goes... Required: Perl 5.18+; cpanm; vim; git; Common C libraries that Perl modules use such as zlib, libxml, libpng, etc. Nice to have: Komodo Edit / IDE; A bunch of commonly used CPAN modules such as Plack, List::MoreUtils, HTTP::Thin / LWP, DBI, Moose, Moo, DBIx::Class, Dancer / Mojo / Catalyst, etc. 
Try google, there is a fair bit out there. The author of MCE is also amazingly helpful, and there are a lot if very good examples bundled with the distribution, including a couple which are basically exactly what OP needs, if memory serves (parallel processing of massive input files). 
IPC via pipes or similar I believe.
Sorry! Mobile app.
Sounds a bit similar to forks, which uses sockets.
^^ This is how I would do it. 
Sorry. Can you point me too why Perl threads are bad? 
Data::Dump::Color for debugging.
Sure. First up, perl threads are very 'heavy'. The implantation is more like the fork model. This includes the fact that the entire process space is copied, all variables are separate for each thread (except for those you specifically share). Secondly, and more importantly almost nothing in CPAN or even core is thread safe. You have to work quite hard to avoid the usual simple multi-processing problems. Lastly, though the stock perl with most distributions includes threads (to maximise compatibility presumably), the default if you build your own is to not enable threads. What does that tell you?
The "killer feature" of a perl-centric distro for me would be a good way to sync the system's package manager with cpan(m).
https://github.com/perl6/DBIish/ https://github.com/bbkr/mongo-perl6-driver/ https://github.com/Cofyc/perl6-redis/ https://github.com/supernovus/perl6-db-model-easy/
I'm thinking the first 'two' is being parsed as a subroutine, and the second one is parsed as an argument. The plus sign here is handled as *unary* plus. See what happens when you add some parens: $ perl -le 'print((two + two) == five ? "true" : "false")' syntax error at -e line 1, near "two +" Execution of -e aborted due to compilation errors. This is also why you use strict. Edit: should have guessed at the filehandle explanation. In addition to `use strict`, this is also a pretty good argument for `say()`.
That was the conclusion I came to, also. I think it's being parsed as you say, like this: perl -le 'print(two ( +(two == five ? "true" : "false")))' EDIT: that's still not right, because if you put the parens against the first `two`, you get an error: perl -le 'print(two(+ (two == five ? "true" : "false")))'` Undefined subroutine &amp;main::two called at -e line 1.` so the first `two` can't be being parsed as a sub call... I'm too rusty on my Perl to figure this one out - I give up!
(This article was written yesterday, so the link that says [I will discuss the surprising answer tomorrow](http://blog.plover.com/prog/perl/barewords.html) works today, and explains the answer.) 
but i did guess it :)
That is a great explanation! 100 bits /u/changetip
In Perl, `print` forces all its arguments into list context. Roughly, the first "two" is assumed as a subroutine, though invalid. The second "two" and the == comparison and trinary operation is all forced into scalar context by the unary + operator. Best I can tell, perl is trying to print `two == five ? "true" : "false"` to the `two` filehandle. Since -le doesn't enable warnings, the "printing to an unopened filehandle' warning doesn't fire. Change it to -lwe and oh my. edit: Just read the explanation. I'm smart!
hmm thanks. I'll give it a try.
Are you running the script like this: &lt;script name&gt;.pl &lt;args&gt; or perl &lt;script name&gt;.pl &lt;args&gt; ?
&gt; How does this compare to Data::Dump::Color? $ perl -MBenchmark -MData::Printer -e 'my $foo = Benchmark::new(); p $foo' Benchmark { Parents Exporter public methods (26) : clearallcache, clearcache, cmpthese, countit, cpu_a, cpu_c, cpu_p, debug, disablecache, enablecache, import, init, iters, mytime, n_to_for, new, real, runloop, timedebug, timediff, timeit, timestr, timesum, timethese, timethis, usage private methods (1) : _doeval internals: [ [0] 1405619707, [1] 0.06, [2] 0.01, [3] 0, [4] 0, [5] 0 ] } vs.: $ perl -MBenchmark -MData::Dump::Color -e 'my $foo = Benchmark::new(); dd $foo' bless([1405619721, 0.02, 0, 0, 0, 0], "Benchmark")
&lt;script name&gt;.pl &lt;args&gt; 
Try the other way. Otherwise you are leaving it up to Windows file associations to figure out how to execute the script. Also check to see if perl -v produces the same output on both machines.
That did it - THANK YOU! (Yes, I am that inexperienced with Perl)
No problem, happy to help.
two is 'two' two + two is 'two' + 'two' which is 0, because strings are converted to int five is 'five' so two + two == five is 0 == 'five' , but 'five' is zero in numeric context, so this is true so the script prints 'true'
Using sane practices, this Perl will give all kinds of warnings. It's not meant to be an example of how to write good Perl, just a fun puzzle about the peculiarities of the parser.
this is even better: perl -le 'print("" + two == five ? "true" : "false")'
That was what I was expecting. Instead, it *appears* to do nothing.
I'm surprised none of the resident perl-6 culties have come along to tell you how wonderful perl-6 will eventually be at concurrency, parallelism, palm-reading, flying cars, and time travel. Maybe when they sober up they will scrape together some commit that actually works and, for a brief shiny moment, there will actually be a perl-6 release worth using.
How exactly would windows go about this?
Wow, so Servlets but worse... Full recompile every time? This sounds like what we were forced to do 10 years ago.. Why not something that can benefit from static caching and dynamic asynchronous communication (only reload what is changing). I'm thinking play framework or node or meteor
So.. The Java Spring Framework 4 years ago
ive seen these sort of issues too. it's bizarre. 
Here they are for those too lazy to check: Unquoted string "two" may clash with future reserved word at -e line 1. Unquoted string "two" may clash with future reserved word at -e line 1. Unquoted string "five" may clash with future reserved word at -e line 1. Name "main::two" used only once: possible typo at -e line 1. Argument "five" isn't numeric in numeric eq (==) at -e line 1. Argument "two" isn't numeric in numeric eq (==) at -e line 1. print() on unopened filehandle two at -e line 1.
Awkward. I not only got it wrong, but got it wrong in exactly the way predicted. Well played :-)
This is trickier than just the synchronisation, unfortunately. The chances are a number of innocuous looking but important distro-provided packages are written in Perl, and are tested against the specific versions of dists that make it into the release. Futzing with the system package manager's perl/module versions is a recipe for breaking these other packages. I'm kind of done with the idea of using system perl for real applications at this point.
&gt; to the two filehandle. D'oh! I got most of it but forgot about print taking a filehandle like that. Well, I did say I was a bit rusty. :-) Thanks for the explanation. 
Yup, fun with barewords! You can also help both the parser and the human reader by using the following syntax to disambiguate such things (from the docs on `print`): print { $files[$i] } "stuff\n"; print { $OK ? STDOUT : STDERR } "stuff\n"; First saw it in PBP, I think.
In this particular case it looks like concurrency is quite likely irrelevant. So I wasn't going to post. But given that you insist... The P6 spec does not cover palm-reading, flying cars or time travel. [Implicit parallelism is already baked in design-wise.](http://perlcabal.org/syn/S17.html#Implicit_parallelism_is_OK) Concurrency in P6 is well beyond the design stage; I'm not going to speak of "how wonderful perl-6 will *eventually* be at concurrency" because [what it already does](http://perlcabal.org/syn/S17.htm) works nicely right now. For those interested, I think jnthn's examples are the nicest, eg [the concurrency part of jnthn's Perl 6: what can you do today? presentation](http://jnthn.net/papers/2014-fosdem-perl6-today.pdf#page=57) or his [Reactive Programming in Perl 6](http://jnthn.net/papers/2014-nlpw-reactive.pdf) presentation.
In this particular case, as well as all other cases except for faffing about rewriting compilers, perl-6 is quite likely irrelevant. So thanks for demonstrating the real problem with perl-6 threads, Ralphie-boy. They always get deadlocked by the problem of non-deterministic termination.
Everyone here is right about the "CSV is just a text file" thing. If changing the file name doesn't work, then it's not a CSV file. Changing the extension doesn't affect the contents of the file any more than changing the rest of the name does. You should be able to open it in any text editor on any system. If you can't then it's not a CSV file. So far as using Perl, I *never* touch a CSV file without using Text::CSV_XS, unless the data is *very* simple and I know *for sure* there are no commas within the fields and no quoted fields. CSV is a ridiculous mess of a format with any number of potential problems (delimiters within fields, double quotes as escapes, ...). But I have to work with it because Windows opens CSV in Excel on double-click by default. 
Java...number 1? This makes me sad. Efficient as a compiled language, yes, but otherwise ugly, obtuse, and inconcise. 
I'm a fashion-follower, so this position news is very concerning for me. For example I wrote a Perl program yesterday for doing some processing of data. I'm concerned that when Perl drops its position in the latest programming language rating, the shame of using the 13th or 14th most popular language will start getting to me and I won't be able to use Perl any more, and have to switch to Erlang or Haskell, or become a "JavaScript Ninja", or resort to Google Go. PS. can anyone tell me the best way to get started on being a "JavaScript Ninja"? 
Don't know try https://metacpan.org/. Edit: If you are on a newer version of Activeperl it probably easier to install PadWalker with "ppm install PadWalker" or "cpan install PadWalker" in the command prompt. The later should work with any Perl :-). 
It is down a lot lately...
No--it's really down. And that's bad news for me because I'm supposed to set up a server tomorrow and it's going to need many modules installed. I tried typing "cpan" from the Linux prompt and it seems to be working. 
From [perl.org/cpan](http://www.perl.org/cpan.html): &gt; \[CPAN\] is searchable [http://metacpan.org/](http://metacpan.org/) or [http://search.cpan.org/](http://search.cpan.org/) and [mirrored](http://mirrors.cpan.org/) Use [search.cpan.org](http://search.cpan.org/) or [metacpan.org](http://metacpan.org/) for information, download from one of the [mirrors](http://mirrors.cpan.org/). edit: Here is PadWalker from some mirror near [ftp.acc.umu.se/PadWalker](ftp://ftp.acc.umu.se/mirror/CPAN/authors/id/R/RO/ROBIN/PadWalker-1.98.tar.gz) :)
&gt; the shame of using the 13th or 14th most popular language will start getting to me and I won't be able to use Perl any more The problem is instead that there are fewer *jobs* available primarily using Perl. With a series of data points such as this one, the Dice index, or the RedMonk guidelines, where the number of jobs is a data point for the rankings, popularity declines as the number of jobs declines. Recent Perl advocacy seems to misunderstand things; it's not the other way around. TIOBE is a joke, but arguing "Perl's not dead because TIOBE is a joke" does no one any good.
The Perl NOC is moving machines around in [planned maintenance](http://log.perl.org/2014/07/7182014-scheduled-maintenance-moving-day.html). But, you don't need search.cpan.org to install modules. Are you using cpanm?
[cpanminus](https://metacpan.org/pod/App::cpanminus)
&gt; I'm not sure why this is a response to my post. Your first reply strongly implied that you think these language rankings are all about fashion following. That's likely true of TIOBE, which has little statistical coherence to back it up.
These are IEEE spectrum rankings not Tiobe ones. Edit: Removed incorrect statements, thanks for pointing out my error. 
Yo, damn those bare words, man....
How does this.... differ from.... diff?
I am guessing the OP means "word-by-word diff" in the terminal using colors.
That's correct, **but** note that every line is compared to the line before it using word diff. Edit: emphasis
Thanks for you comment. I added an example to make it more clear.
They do occur, and when you're least expecting it. Every experienced Perl programmer has been bitten by it more than once, and that's why they're telling you that you're better off not using the syntax at all, or even writing `no indirect` so that you don't use it "by accident" because of a typo. One really interesting example of the havoc caused by indirect object syntax: what does try { do_something(); } catch { error_handler(); }; do if you forgot to write `use Try::Tiny;` ?
There's no real upside, considering that you are just introducing a potential future point of failure with a very hard to debug failure mode. Everyone that has been bitten by this thought that it would be unlikely, too. 
Indeed, the only case I ever use them (verb before noun) at the moment is with new and throw. I can't imagine how I could end up running afoul of the parser in these situations provided I'm careful but I don't have so much experience. Can you remember any real problems off the top of your head? Many thanks for Modern::Perl btw. I've started using the module recently and just finished the book (though I think it was like the 2011-2012 edition).
Oh god, does that end up trying a method call (or two)?
The upside for me is that for these cases I find it easier to read and prefer it. Though I tend to not write complex statements of this type which is perhaps why I haven't run afoul of it yet?
Ah, that's how I thought it would play out but thanks for going through it so well. Definitely shows the type of problems that can happen but that only indicates that forgetting to use Try::Tiny can potentially give you some debugging hell? The only case where I use this idiom is given in the OP and so far I haven't managed to find documention of this going screwy. Unless I have functions new or throw etc. So I guess I'll stick to my aesthetic choice for now and then on my head be it if it blows up.
The problem isn't the complexity of the statement. The problem is that it's easy to create situations which are ambiguous for the parser by loading other modules in a different order than you expected.
I believe that the interpretation depends on whether you have a `new` function already defined in your current namespace, but I also find `Exception::Type::("Something happened")` ugly, like C++ templates ugly.
It is less than ideal, but for me the indirect variant is also ugly and less intuitive to me. Having looked into it it seems that even the direct invocations have potential ambiguity with the class bareword so they should also be ::'d. Granted it doesn't have the compounded issue of the method bareword ambiguity. If I'm going to write code that is more reliable, but not how I really want to do it, I may as well go the whole hog :P.
 my @prev_words = (); my @words = []; It doesn't matter, 'cause the next time we see `@words` you're replacing it, but that's weird.
Given that you seem hell-bent on continuing to use this fragile syntax in the face of experienced, expert Perl developers (i.e. not me) telling you it's massively fragile ... why did you ask in the first place?
&gt; but not how I really want to do it Forgive those of us with years and years of practical experience for trying to help you write working code and avoid the pain of debugging problems that you don't have to experience. You should have said "I don't care about writing reliable code" in your original post. I, at least, wouldn't have wasted my time giving you an informed opinion that you don't care about.
Your [username](http://www.reddit.com/user/StupidCrowd) is quite appropriate. 
Because if I say Larry Wall's talks don't make any sense, it's because I'm stupid, or a member of a crowd of stupid people? 
Nope. You just sound stupid.
It's dead and it's not coming back. Just move on. Everyone else has.
Sorry, my intent wasn't to imply you're wasting your time. On the contrary, I'm thankful you took the time to help me out. I've decided to switch to direct style and always append :: to the package name, for the reasons you describe. I do however have every right to prefer indirect notation for personal reasons just as much as you do to find a trailing :: ugly, don't I? It's great that the Perl community is active enough on here to get so many response so quickly. That said I don't think there is justification for the kind of aggression I felt in that last post. There are already enough places on the Internet for people to shout at each other and I hope that isn't what this place is used for :(.
To find out how and why it is fragile, from experienced and expert Perl developers. This enables me to make an informed decision, weigh up their experiences and facts with my own, and factor in personal taste and opinion. Then make an overall decision on what style I wish to adopt in future in various situations. If I already had the answer to my question I wouldn't have asked and I believe that people have the write to make their own decisions without bullying :).
Perhaps presentations by Jonathan Worthington will be more appealing to you and others who don't like Larry's. Jonathan's style is comparatively conventional. For example, here's [an hour long presentation of some data munging using Perl 6](https://www.youtube.com/watch?v=YW75CXY-P3M&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK&amp;index=8#t=4m) from earlier this year. (More curated [English language videos about Perl 6](https://www.youtube.com/playlist?list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK).)
I might be betraying my... something here... lack of knowing maybe, but when I read through the spec of Ruby a while back I thought "this is pretty much what Perl6 should be". Since Perl6 never happened, and whatever parts of it I read just seem odd. I hear over and over, it's coming and every time I quietly thing "it's already been here for a while dude".
I think it's quite hard to view the videos and not have some concerns. 
If it was dead and everyone had moved on, that would be one thing, but it seems to be in a permanent limbo of endlessly being tweaked and fiddled with and redesigned and generally messed about. If you watch the videos it is almost incredible that after fourteen years Larry Wall is still making these kinds of changes, and it looks like a deliberate action. I don't think Larry Wall even wants to finish Perl 6 any more, he just wants to carry on fiddling with it, and making sure it's never finished, for whatever reason. 
Even assuming that's true, so what? We also have Perl 5. That didn't grind to a halt the first time someone talked about a Perl 6. Maybe you really care about the big number on the left of the decimal, but lots of interesting things are happening over on the right. 
You already know the answer to your question — what's going on is the same thing that's been going on for years, whether you like it or not. Now quit being a dumbfuck just to get a rise out of people.
&gt; Of course, it's also making the Perl 5 community wither away as it flounders on endlessly Yes, I think Perl 5 is being seriously damaged by the ongoing Perl 6 fiasco. 
Disregarding this "feature" regularly produces failures: It simply is not Perl. Perl has no constructor or throw keywords. Perl has method calls. So why not write it like that but disguise it without a real advantage.
It works for me.
README
Thanks for spotting that! I pushed a fix.
I found jnthn's recent talk at NLPW rather interesting. [Reactive Programming in Perl 6](http://www.youtube.com/watch?v=JROvKKei4u8) Weekly updates are posted at http://p6weekly.wordpress.com/ 
Where did you install the modules to? Perhaps you haven't set your PERL5LIB correctly depending on where they were installed to. $ mkdir tmpdir $ cat &gt; tmpdir/Blah.pm package Blah; sub hello { "Hello from Blah.pm!" } 1 $ perl -MBlah -E 1 Can't locate Blah.pm in @INC (you may need to install the Blah module) (@INC contains: /home/user/localperl/lib/site_perl/5.18.0/x86_64-linux /home/user/localperl/lib/site_perl/5.18.0 /home/user/localperl/lib/5.18.0/x86_64-linux /home/user/localperl/lib/5.18.0 .). BEGIN failed--compilation aborted. $ PERL5LIB=$HOME/tmpdir perl -MBlah -E 'say Blah::hello()' Hello from Blah.pm! If you don't want to mess with his stuff manually, you could use [local::lib](http://metacpan.org/pod/local::lib#The-bootstrapping-technique) along with [cpanm](http://metacpan.org/pod/App::cpanminus)
I partly understand your anger (hopefully not an allegation). This first video from 2014: Yes it is hurtfully impertinent. But calling Perl 6 a toy language is disproportionate. What I see as a user are two things: A. Perl 6 as a joke - visit perl6.org - then listen to Larrys talk with your eyes closed Yes. It is allowed to scream. Tears? Some say its healthy. Calm down. Breathe. In. Out. In. Out ... And now try to focus on: B. Perl 6 as an accomplishment - visit rakudo.org/ - check out the MoarVM 
This is a pretty shitty troll.
&gt; rakudo.org OK, &gt; A useful, usable, “early adopter” distribution of Perl 6 Fourteen years into Perl 6's development, and more than six years into Rakudo's development, we have an "early adopter" distribution? 
OK
there is a list of the features of the Perl 6 implementations: http://perl6.org/compilers/features The combination of some of this features can explain the high workload involved. But I agree, it would have been better to put something usable out there much sooner. And in my opinion, especially after looking through the mentioned talk, Larry should move over. It's about time. 
&gt; Also the language design seems pretty questionable (even ridiculous) to me. That's the only part I want to comment on. As it happens, I wrote a book on just that. Around 2008, APress wanted a book on Perl 6. I proposed a slightly different take: A book that showed some Perl 6 syntax, but was mostly about the *concepts* in the language with working examples written in Perl 5. This is _Perl 6 Now: The Core Ideas Illustrated with Perl 5_: http://isbn.nu/9781590593950 It has chapters on Coro (continuations and coroutines), concept of types (illustrated using my typesafety.pm module), hyper operators/operations (illustrated using PDL), suppositions (demonstrated with Quantum::Superpositions), multi-dimensional memory efficient arrays (illustrated using PDL), and various other things (changes to context, also illustrated with a module, changes to method syntax, also illustrated with a module, smart match syntax, etc, etc). It's easy to decide that Perl 6 is some kind of monstrosity that came out of nowhere, but in another sense, it really just cleans up a lot of things people are trying to do with Perl 5 and makes them work together nicely. It's much cleaner to be able to define an operator and have it added to the language grammar than it is to try to source filter and parse the language so that you can do text based transformations. It's a lot nicer to have to have method signatures that can control when arrays and hashes flatten and when they don't, and to have method signatures at all (recently added to Perl 5! yay!). Perl 6 defined the "smartmatch" operator which attempts to do membership tests or something similar between different types of data to create a more useful switch statement (because people use hashes and arrays a lot in Perl). This also got backported to Perl 5 and is currently an experimental feature, but the whole concept started life originally as a source filter hack written by Damian Conway for Perl 5. I'm very pleased to see that Coro/Async is taking off in Perl 5 space, with people like SawyerX doing talks on it. PDL is fantastic, but I've been learning R lately, and I'm really, really appreciating its powerful slice syntax and all operators being hyper by default rather than trying to bolt that syntax on to a language. I guess Python has essentially the same problem. So if Perl wants to do data sciency stuff, memory efficient arrays (declared with additions of little keywords, C/Java style) and hyper operators are really important. Some things I didn't cover, such as lazy lists, for lack of a working Perl 5 prototype. Perl 6 was also a bit ahead of its time in that more (partially Perl inspired?) languages like Go are coming out, that mix a lot of functional ideas and computer science-y ideas with hyper expressive syntax. I think there's a maxim in here: when programming, someone will benefit from your work, though it may not be you. But your friends are more likely to benefit than your enemies. Watching things bounce between Perl 5 and Perl 6 continues to amaze me. Anyway, taken all at once without context, Perl 6 can seem scary and alien, but the ideas all come from somewhere (often from the Perl 5 community and Perl 5 modules) and are each things that different people in different situations could really use. As with Perl 5, you don't have to use any feature you don't want to (except strict... haha, suckers, strict is on now whether you like it or not!) but can still learn and work in baby steps for as long as you like. In a lot of ways, you're already doing (or already successfully ignoring) a lot of Perl 6 stuff just because clean-ups planned in Perl 6 are folding back in to Perl 5.
Maybe if he drank less and gave less presentations, he could get to the next big rewrite faster.
&gt; NC (you may need to install the Blah module) &gt; (@INC contains: /home/user/localperl/lib/site_perl/5.18.0/x86_64-linux &gt; /home/user/localperl/lib/site_perl/5.18.0 &gt; /home/user/localperl/lib/5.18.0/x86_6 well, i installed them to a subfolder in a shared directory so we could ultimately make this a module if I get it up and running so i think they are in /usr/share/ngs/circos/circos-0.66/perllib/MODULE NAME I have been putting the PERL5LIB line in my ~/.bashrc ... is that the right place for it? that could be the issue...
&gt; Tearing down Larry for being "weird" or "meandering" misses the point. I don't have any regrets about my choice of words. &gt; Either lend a hand, or stop being a malignant asshole and be nice to people. I have no intention of lending a hand, and expressing doubts about Perl 6 and Larry Wall doesn't make me a "malignant asshole". Once you start resorting to ad hominem it's clear who's won the debate. 
&gt; Perl 6 defined the "smartmatch" operator which attempts to do membership tests or something similar between different types of data to create a more useful switch statement (because people use hashes and arrays a lot in Perl). This also got backported to Perl 5 and is currently an experimental feature And smartmatch turned out to be a disaster. You can find acres of text about it on the Perl 5 porters mailing list. It's scary to see people putting faith in hypothetical features and ideas which may not even work in practice, and working for years on designs which are unlikely to achieve anything. &gt; PDL is fantastic, but I've been learning R lately, and I'm really, really appreciating its powerful slice syntax and all operators being hyper by default rather than trying to bolt that syntax on to a language. I guess Python has essentially the same problem. So if Perl wants to do data sciency stuff, memory efficient arrays (declared with additions of little keywords, C/Java style) and hyper operators are really important. Having a working implementation of a language is really important. It is scary that you think data scientists are going to stop using their current tools if Perl 6 is implemented. At this point, absolutely nobody except the devoted faithful has any intention of using Perl 6. &gt; Perl 6 was also a bit ahead of its time in that more (partially Perl inspired?) languages like Go are coming out, that mix a lot of functional ideas and computer science-y ideas with hyper expressive syntax. I don't think that Go was Perl inspired. You can find lots of information about the history, [for example this article](http://commandcenter.blogspot.jp/2012/06/less-is-exponentially-more.html). It doesn't even mention Perl: &gt; Starting point: C, fix some obvious flaws, remove crud, add a few missing features. Pike also worked on languages like Limbo with similar features to Go, which predate Perl 6. &gt; Anyway, taken all at once without context, Perl 6 can seem scary and alien, but the ideas all come from somewhere (often from the Perl 5 community and Perl 5 modules) and are each things that different people in different situations could really use. The ideas in Perl 6 aren't what scares me. What scares me is the words "could really use" in the above, and the implicit "if only we had actually implemented them" after it, and the weird fantasizing that anyone is ever going to want to use Perl 6. It isn't going to happen; one implementation after another, and one project after another, has been abandoned, and all that is currently out there is a toy system, after fourteen years. 
I'm not going to lend a hand (probably, unfortunately) to Perl6, though I think it is already great, especially the comment from /r/scrottie below re: "just cleans up a lot of thing people are trying to do with Perl 5": a big YEAH! to that.... and I (also) think that Larry Wall meanders, embarrassingly meanders.
No. This talk was an absolute disaster and every single of those adjective where justified. I've written many thousand lines of Perl code. I've registred for giving talks in my local Perl user group next month. I like Perl. But talks like this destroy my pride in my profession and my skills. I don't want to be remotely connected to this childish/narcisstic gibberish is any way. Talking of disasters. Perl 6 is never gonna make it. It will never run on production servers. It will never be really useful for a broader range of people. It will never attract younger folks. It will never die. So if you really have to talk about Perl 6, then please make sure that you're entertaining the audience and not yourself .
So if I see my neighbour beating his wife, or setting fire to his cat, I shouldn't have any concern, because it's not my wife/cat/whatever? 
&gt; the biggest problem with perl 6 is attitudes like yours Well *that* is debatable. If "put in a happy face and contribute to the efforts as they exist now" or "shut up and ignore it" are the only two options, there seems to be a failure of imagination. P6 should not be immune to honest criticism. "It's been 14 years and I can't tell what's going on" is a legitimate criticism.
The object wasn't to reimplement Getopt::Long but rather to implement a simplified version. As you indicated above it's SIGNIFICANTLY lighter. If you don't need all the whistles of Getopt::Long, you can save a lot of overhead of using my function.
That's not more specific.
&gt; Yes, I think Perl 5 is being seriously damaged by the ongoing Perl 6 fiasco. Perl 5 puts out releases every year. Every May to be precise. Many features put into Perl 5 come from ideas from Perl 6. What part of Perl 6 is damaging Perl 5?
&gt; And smartmatch turned out to be a disaster. You can find acres of text about it on the Perl 5 porters mailing list. It's scary to see people putting faith in hypothetical features and ideas which may not even work in practice, and working for years on designs which are unlikely to achieve anything. Perl 5.10 wasn't a great release. It was a rocky period where people were worried that a major release hadn't happened in a while, and some people wanted to put *something* out there. That being said, those mistakes are getting fixed by marking the feature as experimental, fixing it to not be so magical, and then eventually putting it back into a non-experimental status.
This discussion feels like talking to members of a religious cult rather than people rationally discussing a computer programming language. 
&gt; Why has Perl 6's design been so relentlessly churned? [Whirlpool development](http://strangelyconsistent.org/blog/second-system-syndrome-done-wrong#Whirlpool).
&gt; Well that is debatable. If "put in a happy face and contribute to the efforts as they exist now" or "shut up and ignore it" are the only two options, there seems to be a failure of imagination. &gt; Fair enough. Rather than trolling, had OP said "It's been 14 years and I can't tell what's going on. Whats up?" I think this would be a substantially different conversation. I simply fail to see the useful purpose in publicly stating that the "language design is questionable", and Larry is "embarrassing, meandering, weird, incomprehensible" Want to have an honest conversation? Lets do it. Want to bitch about it without a putting forth a question or proposal of any kind? Go use python. 
Amen. OP's crass manner betrays an ignorance of several key human factors in the perl6 saga. *english good
&gt; Want to have an honest conversation? Lets do it. Want to bitch about it without a putting forth a question or proposal of any kind? Go use python. Yet another false dilemma. 
I've tried to avoid sarcasm so far, but now you are claiming that if I knew all about various people's illnesses then I'd start thinking Perl 6 was really great? You're clutching at straws. 
You're the one coming in biased from the original post. It's pretty obvious that nobody is going to change your opinion.
So, who or what exactly is being beaten/set ablaze here?
I'm saying that if you knew some of the backstory, and some of the quite amazing people involved, that perhaps you'd be more inquisitive, and less of an unrepentant ass. I hope perl doesn't slip to the 13th most common language, because that would be deeply [unfashionable](http://www.reddit.com/r/perl/comments/2b3l0i/ieee_spectrum_ranked_programming_languages_perl/)
&gt; I'm saying that if you knew some of the backstory, and some of the quite amazing people involved, that perhaps you'd be more inquisitive, and less of an unrepentant ass. Here's a thought: I've sat through several videos on YouTube and one real-life talk by Larry Wall, none of which made much sense, trying to figure out what on earth is going on with Perl 6. Am I **more** inquisitive than the average person about Perl 6, or **less** inquisitive? And what impression does Perl 6 make on a person who is **less** inquisitive than me? You're just clutching at straws with this stuff about how I should find out about all the amazing people and their tragic misadventures, and the story behind the story. Anyway, I apologize, but I think I've already said enough, so I'm going to end my contributions to this discussion at this point. Thank you to all contributors. 
Perl 5, preferably 5.16 or later.
silly question, perl5.
Okey! thanks for fast respond
Definitely Perl 5. Out of interest, which other languages have you already tried?
And 5.10 as an absolute lowest version
I made the effort of finding the optimal buffer size for sysread for multiple Unixes. Depending on the OS the optimal is 32768-131072.
I am maybe missing something. Who are the people put in harm's way that are you trying to save, exactly ?
The book "Modern Perl" covers Perl 5 from the ground up the way you "should" do it, and is available either in print or in free electronic formats like PDF here: http://onyxneon.com/books/modern_perl/ …although of course "Programming Perl" (Christiansen, foy, and Wall) or "Learning Perl" both from O'Reilly are the classic starting points. 
After using C#, Python, Java and Ruby for years I went the perl5 road and felt in love with it. Its such a fun language to work with. I don't understand how it is not used more in projects. I guess the mainstream mostly wants to use/hear/see/eat whats inferior. On a side note, Java can make you depressed and bored to death. 
i've been digging abit into them, and it's not only syntax i dont like, i have trouble writing good programs in it
That may be true, but you don't know until you tried ^^
How's haskell
Perl 5 for something practical to get real work done. Perl 6 for something experimental to play around with or for pet projects; could also be interesting from the perspective of language design. 
That's a years-old post hoc justification. The design has been so relentlessly churned because there are no serious uses of the language driving a practical resolution or deferral of open specification questions. Everyone who was pushing for a completed 6.0 spec and release (that list includes people such as Nat, Dan, Jesse, and Allison, not just me) was driven away years ago. If you ask "How long until the spec will be complete for 6.0 purposes?" you'll get the same answer you've been getting for years--6 to 18 months.
Watch another talk if you don't like Larry's, what's the problem? Considering how many people are involved in perl6, it's very healthy. And remember that perl6, unlike perl5, is actually *have* specification, so there obviously will be more fooling around in this part. PS: I think people imagine perl6's state to be far worse than it actually is. It is ready for small projects, even for production. 
Perl 5 (but learn modern dialect and use recent version) for production. Perl 6 for fun. It's far more advanced, but is not ready yet. 
By "small projects", ITYM "math puzzles on rosettacode" and "advent calendars that won't work next year". At this point in perl-6's life, it's older than Perl was when perl-6 was announced. Chew on that for a while. It has fewer users than candles on its birthday cake.
People who stupidly think that 6 is a bigger number than 5 because of an anti-perl-6 conspiracy fueled by thousands of years of Arabic numberlines. Those fools.
5 if you have work that you want to get done. 6 if you want to have fun with something experimental and maybe improve the language along the way. Both if you have endless free time.
It's a perfectly reasonable question.
&gt; And smartmatch turned out [poorly, so far]. You are confused, or at least are being confusing, because while smartmatch is problematic in *P5*, it's a big win in P6. &gt; Having a working implementation of a language is really important. ... if Perl 6 is implemented. Heh, you are really confused aren't you? :) My [caveat list](http://www.perlmonks.org/?node_id=1047676) still mostly applies but [Rakudo is a working implementation of all the absolutely essential features, and many others besides](http://perl6.org/compilers/features). &gt; absolutely nobody except the devoted faithful has any intention of using Perl 6. I've seen a bunch of folk comment on this combination (their view of P6, and their intentions related to using it) over the years. Many folk who don't care about it still say they intend to try it out if and when they think it looks good enough to do so. Imo things like the [debian usage spike this spring](https://qa.debian.org/popcon.php?package=rakudo) and new users appearing on #perl6 this summer probably reflect Rakudo's continual improvement. &gt; What scares me is ... the implicit "if only we had actually implemented them" Rakudo already implements most of P6. Which missing bits scare you? &gt; all that is currently out there is a toy system Ha! **Many of your comments strongly suggest you haven't actually used P6. Have you?**
The lies are thick in this one! Rakudo is basically done, except that the spec isn't done, so it's basically not done! But everyone should totally use it, because every time some poor punter tries it, Ralphie-boy gets another gold star taped to his big boy shirt so when he gets sent home at the end of the week, his mum is ever so proud of him. 2002 called, Ralphie-boy. It want's to know just how wonderful perl-6 will be when it's finished. Oh, scratch that, 2012 already responded. It says to nevermind.
&gt; By "small projects", ITYM "math puzzles on rosettacode" That made some sense as a caricature a few years ago. (There were larger projects, eg the Rakudo compiler itself, but most end-user code was indeed puzzles and the like.) But only someone who hasn't used Rakudo recently, or a troll, would argue that it's still only usable for the compiler toolchain and puzzles. &gt; and "advent calendars that won't work next year". Again, that's a misleading caricature. Given that some were written 5 years ago, and the language has changed since then, it should come as no surprise that some of the entries might no longer work. But I did an audit last year and found almost all of the ones I tried were still working with the latest compiler, in some cases 5 years after they were written. (And since then David Warring has been updating the entries that don't work. It looks like he'll be done in a few weeks, or at least in time for this year's advent calendar. He's done it the right way, with tests to ensure we spot any breakages, so going forward all the calendar entries, from 2009 on, will likely all work with the latest compiler, ignoring the handful that rely on Parrot or Niecza specific features.)
The problem isn't #perl6 attracting younger folks. The problem is that #perl6 doesn't have any adults who actually know how to release working software.
For a depressing thought, compare it to LLVM, which started slightly after P6.
"It should come as no surprise that some of the entries might no longer work." Stable. Ready for production use. Fully tested and documented. Spec completed. Ignoring the compilers that, years ago, you claimed were stable and ready for production use, but upon further reflection, have fallen into abandonware and disrepair. Do you even code, bro?
&gt; what impression does Perl 6 make on a person...? It varies of course, but I'd say the key factor is seriously using it. Some folk who use it fall in love with it. You evidently didn't use it and that's a pretty big hole in your inquiry right there. If folk want to watch videos, I recommend [talks by Jonathan](http://www.reddit.com/r/perl/comments/2b94le/what_is_happening_with_perl_6_and_larry_wall/cj33fxw).
It's important to note that, unlike Python 2 and 3, say, Perl 5 and 6 are less "two versions of a language", and more "two languages" 6 started with a spec, which I believe is now pretty stable, and there are multiple implementations in various states of readiness. You can do stuff with it today -- but it's not really "ready" 5 started with an interpreter. There is no formal language spec, rather the language is defined by the interpreter and its test suite. It is a hoary old battle-tested thing, but which still has an active community maintaining it (hi, P5P!), adding new features, and generally doing a stand-up job of keeping it relevant. The biggest draw of Perl for me is the enormous pool of well tested modules on CPAN -- obviously Perl 5 has been accreting libraries for a lot longer than 6, and so for that reason, I suspect I'll be sticking with 5 for a long time to come. But hell, try both -- you never know what you'll like :-)
Why would anyone use it? It's a toy, it won't be ready for at least another 18 months. If you want to play with languages, you could try something that has been created and released seriously since the whole sad perl-6 saga begun, like Rust or Swift or Elixir or....
&gt; compilers that, years ago, you claimed were stable and ready for production use, but upon further reflection, have fallen into abandonware and disrepair. Please quote one of these claims you claim I made so I can figure out how you misunderstood me.
I'm not rewriting history. I agree that you and many others talked about such things from the start. I recall you in particular consistently and mercilessly putting down folk who had the temerity to suggest all was not well with P6. But, perhaps mistakenly, my focus is on how things are now. There are still optimists (typically newcomers) who think it's "any day now" but most P6ers focus on keeping quiet and just doing the work to get to 6.0.0. This isn't nonsense, it's just how things are.
Thanks for clearing that up.
&gt; I recall you in particular consistently and mercilessly putting down folk who had the temerity to suggest all was not well with P6. I was wrong. When the facts change, I change my mind. What do *you* do?
&gt; Larry has talked of his preference for what he calls whirlpool dev since at least 1994 and he mandated this approach to P6 from the start. I apologize for breaking my promise to end discussing, but my original query was not about whether Perl 6 is a disaster, but about whether Larry Wall deliberately caused the disaster. There is nobody left except fantasists who doesn't think Perl 6 is a disaster. The very strong impression I get from the talks is that Larry Wall is not motivated to finish the language, and that he's deliberately causing the floundering, for whatever reason. He's like a dog that has got hold of a ball and is determined not to let go of it, or let anyone else play with his ball, so he invents all kinds of witty remarks about how people are attached to their sloppy thinking, or everyone wants the colon, or something, but ol' Larry knows better than that, so he's going to change a few more features around, and he's going to keep on and on fiddling with Perl 6 while Rome is burnt to a smouldering ruin. This has been something I've been wondering about for a few years, and I have searched on the net about this and trying to find out what could be happening, but found no mention. I also don't see anyone actually saying that Larry Wall is no longer responsible for language design. Larry Wall seems to have caused this disaster with his "preference for whirlpool dev". Am I wrong about this? Sorry if this causes offence, but nobody seems to want to address this. 
I want to preface this by saying I am a very big fan of perl. I spent 6 years at my last job using perl, I have some modules up on CPAN, and I all around care about perl. My current job is with Ruby, just for a bit of perspective. There are a lot of reasons it's not used in more projects: 1. The legacy -- perl has a legacy (rather deserved, too) of being a soup of symbols and poor coding techniques. Modern Perl doesn't have to be that way, and it usually isn't, but most of us had years of "perl is disgusting code golf" drilled into our heads. 2. OO -- perl's native OO implementation is functionally non-existent. That's important for modern CRUD web apps. Moose improves that, but it's not native. It has to be both installed and learned in addition to perl. 3. Tooling -- Ruby/Python have much better and more uniform tool support. For example, Bundler. I can write something in Ruby and provide a Gemfile, and it would be a reasonable expectation that a user has Bundler installer (or could easily install it). That's not the same case with Carton for perl. Same with something like rvm/rbenv -- I can very easily require Ruby 2+ and expect users have an easy way to install user land copies of Ruby. On the other hand, I'm lucky if someone has perl 5.10 installed, and even luckier if they know about perlbrew/plenv and can install and maintain them. 4. Second-class citizenship -- people don't write modern code in perl, so perl SDKs and Libraries aren't prioritized. Then, if we have a tool we need to use, we can't choose perl because the SDKs/Libraries aren't as good as alternatives. It's a vicious cycle.
The spec isn't stable, they're still figuring out how lists work.
&gt; The very strong impression I get from the talks is that Larry Wall is not motivated to finish the language, and that he's deliberately causing the floundering, for whatever reason. I think that's unfair; the truth as I see it is subtler. Larry prefers to lead by gently nudging people back to the path when he thinks they're being unkind to each other, rather than setting out to blaze a trail where people fall in line behind him. He deliberately set out to refine the community to let multiple implementations emerge to target multiple interests and ecological niches, but it's not his practice to tell people to focus their efforts in one place or another. That's really never been his nature. The project has burned out multiple project managers (even Audrey had a proposed timeline when Pugs was new) who've tried to focus the efforts of people toward one practical goal or another. I suspect--but cannot prove--that the project now attracts people who don't mind that the whirlpool process has neither serious dates nor technical milestones attached.
&gt;Want to bitch about it without a putting forth a question or proposal of any kind? Go use python. Seems like good advice anyway if you care about your career.
Pretend you don't know anything about Perl. You've heard Perl 6 will be out sometime soon. Would you invest a lot of time in learning and writing a program in Perl 5?
To put it another way, I feel there is something really bad going on which nobody wants to talk about. I don't have information on Perl 6 beyond the public information such as the videos of talks, so I really do not know what the actual problem is. The response by mr_chromatic seems very diplomatic, but also seems to hint at a lack of direction and leadership. This doesn't square with the story of the videos, where it looks like directions are being chosen which are akin to obfuscation. I guess people like me will never know the true story. To put this into context, I'm a Perl 5 user, but I'm currently considering moving away from the language, and Perl 6 is one of the issues which is making me think about this. 
&gt;&gt; pretty stable &gt; isn't stable Agreed.
&gt; Second-class citizenship -- ...perl SDKs and Libraries aren't prioritized. Then, if we have a tool we need to use, we can't choose perl because the SDKs/Libraries aren't as good as alternatives. Hmm, for what kinds of apps is an SDK needed, these days? Everything I use has an API. I agree there are fewer SDK's for Perl but just personally, I haven't missed them much.
You're posting on the /r/Python subreddit so it looks like you also learnt that: &gt; Basicly learn the diffrent between the syntax, you can try to use a cookbook http://shop.oreilly.com/product/0636920027072.do You also mentioned Ruby and C# in another post. &gt; Im in for it .^ what languages is going to be used? I got some experince from C++/C/Java/Ruby/Python/HTML/CSS/C# and a minimal haskell 
Yeah, SDKs suck. Everything is a web-based API nowadays, and thank god. And for anything open source, there's probably a CPAN module for it.
&gt; Programming Perl Programming Perl edition 2 (pink camel book) was authored by Randall Schwartz, jchrist, and Larry Wall. Jchrist continued authoring editions 3 and 4 (blue camel books), but the co-author Jon Orwant was added for editions 3 and 4, along with Brian Foy for the fourth edition. 
I think 5.8.9 is the lowest version for practical purposes. 
&gt; he's really not steering the ship. Then who is? 
I'm sorry that I've offended you, but endlessly countering the enquiries I've made here with a response that I need to be more polite to get an answer looks like a way to avoid the discussion. 
&gt; For ActiveMQ, perl has to use the fallback to STOMP instead of getting the higher performance ActiveWire protocol. There's a ton of modules for RabbitMQ.
Not without a better idea of who said it and the context. Stevan Little has been working on a core (Perl5) object system based on Moose which was based on (early) Perl6 designs. This system is known as p5-mop. I haven't had a chance to talk with Stevan since his recent decision to move to Amsterdam, so I have no idea how his new job will impact the development of p5-mop. Obviously any impact there would affect it's timing for 5.22.
Although this would be awesome...I am really unsure about how or when this would happen.
&gt; Larry is a really really nice guy I'm not sure in what world you are living, but I suppose it must be pretty comfortable. Let's not say any bad bad word because I have such a warm fuzzy feeling in my belly? Is this a church or what. 
Yeah, RabbitMQ uses AMQP exclusively I think, so it's fine there, and ZeroMQ uses unix sockets. Sometimes, you've got to work with what you're given, unfortunately. That means ActiveMQ seems some use in my experience.
I don't think that's particularly true. Perl 5 development has moved out of "blindly import features from Perl 6, ship them, and then realize that they don't work well because Perl 5 is a different language" mode and back into "improve the language, taking good ideas from anywhere and adapting them to be Perlish" mode.
After 14 years of having honest questions met by "You just don't belieeeeeeeve enough!" and "Shut up or fall in line and help!" and "Its only 18 months awaaaaaaaay!" why would anyone be surprised that it takes harsh words to get anywhere close to an honest response from the perl-6 krew?
Pretend you don't know anything about Python. You've heard Python 3 is out. Would you invest a lot of time in learning and writing a program in Python 2? Edit. I thought the popular answer was well known but perhaps not. The vast majority of Python newbies in the 5 years since Python 3 was first released have chosen to invest a lot of time in learning and writing programs in... Python 2.
What facts changed?
I think what is being talked about are the modules such as Moose and Mouse that are inspired in part by advances first seen in Perl 6. Many of these improvements have been available for a few releases of Perl 5.
Python's migration was a mess for a lot of reasons but I've hardly used Python so I can't really speak to it authoritatively. Still, at least there is a roadmap for success.
Calling 999 my house is on fire Can you be more specific? Which parts of your house? There are flames coming out of the windows! Are the flames coming out of the downstairs windows, the upstairs windows, and which side are they on? My house is about to burn to the ground and you are asking me specifics about which parts of the house? Our current fire service is only designed to put out fires on the left side of your house. Our ladder is only one metre long so we are currently unable to put out fires on anything other than the ground floor. We're currently busy redesigning our fire service. When the new version of the fire service is finished, we'll be able to put out fires not only on the ground floor, but we'll be able to put out fires on any floor, including floors not labelled with a number, negative floors, and imaginary floors! At the moment we're optimizing our fire service for fun, so don't expect it to be finished before Christmas. Also, we're not saying **which** Christmas! *house burns to a cinder* 
I think this list was generated by word count in IEEE articles. I don't roll with that crowd and don't know any other perl programmers that do. My dad was an IEEE member, I'm an open source programmer. So my guess is the data is pretty self selecting and not amazingly useful.
And we are using 5.8.5 in our company. Sigh!
Perl6 has all the cool Perl6 features already why do you want them back or sideways ported? Historically that doesn't do well (smart match) plus in "production" you are often tied to the features of 5.10 and maybe even 5.8 rather than use experimental in 5.22! For funtime programming or something just for yourself why not just use Perl6 if its stuff you care about?
For question #1, it depends on if it's in use. You can check the download counts on CPAN and if nobody has started using it yet then you can just remove it and put it up with a new name and I don't think anyone would object. #2. For MakeMaker you can add 'recommended' to the PREREQ_PM section. Here is the best documentation I could find on it. It seems to be simpler in Module::Build. http://grokbase.com/t/perl/module-authors/09agnmgrga/how-can-i-tell-makemaker-to-insert-recommended-modules-into-meta-yml #3. You could test for internet access first, or you could require an environment variable to be set if they want to run internet based tests. Here's an example of how to skip the tests: plan skip_all =&gt; 'set environment variable INTERNET to run this test' unless ($ENV{'INTERNET'}); For the notes, documentation and testing requires you to get in the habit. I generally document when I think about it and write tests whenever someone presents a failure condition. If I'm being diligent then I'll write tests before i start a new feature, or right after finishing the feature, but it depends. Sometimes if the project doesn't change much then the "Changes" file can be enough documentation for people to figure things out. You can use git tagging to tag each release, then look through your git log to figure out what's been done since the last release. That's how I make my Changes files.
This is not bad at all if its your first module. A few things: -- I usually don't check in the MANIFEST since that gets generated when you build the dist for sending to CPAN -- I appreciate you wanting to keep the dependency count low, but you might want to look a Moo which is a OO framework that is very light and would likely neaten up the initialization -- At some point you might want to look at some advanced tools dealing with your Makefile.PL such as Dist::Zilla or Module::Install since they can make it easier on you. This project doesn't manage a lot of dependencies but is just good for you to know about where the community is at with the build chain. 
I'd recommend http://metacpan.org/ since this is managed as an open source project (code is on github) and people actually work on it (there's a Google summer of code intern hacking on it). However CPAN can't easily go down since its a distributed network of servers worldwide. If your local CPAN mirror is down you can choose another. 
For Internet access tests, checkout [Test::RequiresInternet](https://metacpan.org/pod/Test::RequiresInternet).
That module isn't very well documented, so I'm not entirely sure your use of it is correct. As far as I can tell, it binds to a given port or sock to communicate with postfix in some predefined manner as a "policy server". I'm not sure that postfix is supposed to delivery the email to the policy server directly, or interface with it some other way. However, to verify the connectivity in general: * Try using netcat to connect to localhost, port 10025 * Try using netstat to see if the process has bound to the port * Try using strace/ltrace to see what the process is doing
[edit: basically rewrote this comment after a terse initial reply; it's not clear if you're trolling or if you're trying to have a serious conversation] &gt; Also the language design seems pretty questionable (even ridiculous) to me. (From your original post) &gt; The ideas in Perl 6 aren't what scares me. (Just now) Okay, I wasn't clear what your concern was/is. In what way does the language design seem ridiculous? Are there some RFCs that shouldn't have been accepted, or is the entire RFC process inappropriate in your mind, or...? &gt; It is scary that you think data scientists are going to stop using their current tools if Perl 6 is implemented. Ooh, a false dichotomy hidden behind a generalization! I love those! If Perl implements hyperoperators, every single data scientist is going to instantly convert to Perl 6 and all of data science will suffer from every problem Perl 6 has. Therefore, Perl shouldn't implement hyperoperators. This is absurd. Or did you mean to say something else? &gt; I don't think that Go was Perl inspired. Okay, perhaps not, but (and this is just a theory), I think languages with richer syntax than C have come into vogue partially because of legends of Perl's expressive power. APL also long predates Perl and is highly expressive. SNOBOLers golfed long before Perlers did. But expressive language have made a come back, and I personally suspect that Perl had something to do with this, even if credit isn't given. Previously, Java, C#, and "clean" languages that happened to be C-like were the vogue. &gt; What scares me is the words "could really use" in the above, and the implicit "if only we had actually implemented them" after it, and the weird fantasizing that anyone is ever going to want to use Perl 6. I'm sorry, but despite your arguments, I fail to see the general problem with implementing features. When implementing features, there is a risk that they might be implemented poorly or integrated into the language poorly. MJD railed against pseudohashes, and history proved him correct. Pseudohashes are fine as a Perl module with a tied interface but integrate terribly with the language. So I consider this a valid concern, but I don't think that means that we shouldn't implement features at all, ever. Both Perl 5 and Perl 6 should implement features, speaking very generally. The fear that people might use the language (such as data scientists) if features get implemented also seems not compelling to me. &gt; and the weird fantasizing that anyone is ever going to want to use Perl 6 I hope you're not attributing this to me. It isn't clear from what you wrote if you are. I'm sorry that advocacy for and interest in Perl 6 strikes you as odd. That's a different concern than you originally outlined which I'm still not clear on ("language design seems pretty questionable"). That some people are interested in Perl 6 seems perfectly normal to me. I have some interest in Perl 6, but even if I myself were working on adding features to it, you might just have to accept that I'm adding features for some more terrestrial reason than "a weird fantasy". Perhaps I like the set of RFCs selected and I want to realize a Perl with those changes just to see what happens. I'd discourage you from attributing motives to people. If you're wondering what peoples motives are, just ask. Otherwise these conversations become both a lot longer and a lot more tedious. Also, keep in mind that different people have different motives. And yes, you do have to take their stated motives at face value until inconsistent actions or statements give evidence to the contrary. From my point of view, it seems like very few Perl people are interested in Perl 6 and even fewer care about marketing it towards other people but instead have personal interests in it. The small core team feels they have it at a point where they can market it and they have their own reasons for marketing it (probably related to wanting people to take advantage of their work, but you'd have to ask them to find out for sure). Perhaps the best thing for you to do if you want to talk about this stuff is to write a medium sized blog post explaining what (giving specific examples) people did or said that seems odd to you rather than generalizing about the odd behavior of the entire Perl camp. Otherwise people like me are just left speculating about what exactly strikes you as odd, and the whole discussion starts to feel like techsupport.
&gt; I fail to see the general problem with implementing features. One of the risks of implementing a language with a large core of features (as opposed to a small core language, such as Scheme, Smalltalk, or Forth) is adding a feature to address a perceived use case but prematurely generalizing the solution, misunderstanding the use case, or never actually needing to address that use case. Pseudohashes are a good example (though `tie` is a poor example of how to allow that extension). One of *my* harshest criticisms of p6 is that its current implementors seem to focus on implementing things that they believe will be fun to implement or that people might want to use someday. (For example, see Carl Masak's long-running grant to add hygenic macros.) There is no obvious project management which sets a priority for some features for 6.0.0 and defers other features for subsequent releases. I believe that this is because no one *implementing* the language has any practical use case which only p6 can address, and so there's no pressure to develop, release, document, support, and maintain anything useful. (Why do I not trust the p6 developers? Four years ago, *I* had a product based on the language with a handful of customers ready to pay for it, but Rakudo Star turned out to be immature and unreliable and I couldn't convince its developers to address its deficiencies before we had to cut our losses and cancel the product, but I've explained that all at length elsewhere.)
&gt; One of the risks of implementing a language with a large core of features (as opposed to a small core language, such as Scheme, Smalltalk, or Forth) is adding a feature to address a perceived use case but prematurely generalizing the solution, misunderstanding the use case, or never actually needing to address that use case. Absolutely. There are a lot of ways that adding features can go wrong. I only pointed out a couple of ways. In talking to StupidCrowd, I'm failing to get a grasp on what with respect to features the exact problem is, in his mind. S/he vaguely complained about the language design, and not knowing his/her level of experience, I tried to give useful background, but that wasn't met with elaboration, so we're at kind of an em passe. If the concern is that data scientists might start using a language, for example, that doesn't seem like a problem, at least not taken by itself. As for your point, yes, picking features without clear need or specific use case can be problematic. As far as which features get picked, I'm mostly interested in Perl 5 between the two, I like a lot of these features, but I'm not going to comment on the maintenance or implementation costs of them. Okay, maybe a little. So, I've been learning R. It has an amazing slice syntax that lets you do tons of things, idiomatically. It also lets you name rows and columns (and 3rd and 4th etc dimension items). So you can write dataset["rowAA", ] for example to access all columns of row "rowAA". You can also write dataset$rowAA # edit: stupid markdown trying to interpret characters to do the same thing... exactly like xmath's ` patch which I lobbied for which would let you write $dataset`rowAA # or $dataset`0 in Perl. And alias and Coro in core in Perl 5 would be really nice. Okay, I'm done. &gt; There is no obvious project management which sets a priority for some features for 6.0.0 and defers other features for subsequent releases. Well, 6.0.0 is theoretically an implementation of the RFCs specifying Perl 6. Any implementation of Perl 6 can go crazy with other things. But I didn't want to get into a debate about what's right or wrong with 6. I was just hoping to try to encourage one person to be more specific and articulate about what they saw wrong, and I was hoping to project too much of my own bias onto him/her. Edit: It's probably also a good idea not to conflate quality of ideas, quality of implantation, quality of integration, and wisdom of attempting implementing them.
&gt; The presented example does the same work as lex plus yacc, systems which date back to the 1970s. Sure. Ignoring physical constraints, any problem that can be correctly solved with one [Turing complete](http://en.wikipedia.org/wiki/Turing_completeness) language can also be solved with any other. And it'll do the same work. Anything Rust can do now, C from the 70s could do then, but so what? The only interesting technical differentiator between such languages is how one expresses the work to be done and how efficiently it gets done, not what they can do. The P6 code uses [P6 rules](http://en.wikipedia.org/wiki/Perl_6_rules), which are a particularly nice way for a language to deeply integrate [PEGs](http://en.wikipedia.org/wiki/Parsing_expression_grammar). PEGs were first formally introduced in 2004. PEGs are not at all the same as lex + yacc except in the trivial "equivalent work" way and that they are also a parsing technology. The P6 code also uses concurrency. Sure, the same work gets done with or without concurrency, but it makes no sense to me to simply ignore differences like that. &gt; The only part of it which isn't a demonstrable fact is the words "toy system". Your "toy system" claim is an evaluation. You can demonstrate why this is your evaluation, but it'll always remain an evaluation, one that requires mutual agreement that the evaluation is definitive if it's to be used as a sort-of-fact in a given context. Fwiw my own evaluation, which is based on trying P6 over the last few years, and looking at what folk are using it for, is that it's already a very powerful tool, not at all a toy. You haven't made it clear what has led you to evaluate it as a toy system. Have you ever used it? Have you tried it this year? Or is your evaluation based on appearances? Another curiosity you might wish to ponder: how can it be a toy if it's doing the same work as lex and yacc?
It stops being a toy when people like you don't have to vomit out walls of semantic games to prove that its not a toy anymore. Same as "what does production ready mean?" It means that people spend more time actually doing things with it than trying to twist words around to prove that all of their playing with it might look like they're doing something productive with it if you squint the right amount and are very vague with the words you use. So that means things like documentation, stability, libraries, working code examples, and not having to wade through all of the talk about drinking in #perl6 just to keep your code running from day to day.
&gt; people like me are just left speculating about what exactly strikes you as odd The following things strike me as odd: * Larry Wall's talks on Perl 6 resemble deliberate obfuscation * Larry Wall seems to be the Schrodinger's cat of Perl 6 design. He is both in charge, and not in charge, at the same time. 
&gt; One of my harshest criticisms of p6 is that its current implementors seem to focus on implementing things that they believe will be fun to implement or that people might want to use someday. You aren't paying close enough attention. Most folk are having fun implementing things in the spec that either they or some other folk want implemented asap. &gt; I believe that this is because no one implementing the language has any practical use case which only p6 can address, and so there's no pressure to develop, release, document, support, and maintain anything useful. Are you really expecting there to be practical use cases which only P6 can address? Are you really saying that there are practical use cases that only P5 can address and that these are the sole source of pressure that might lead P5ers to develop, release, document, support, and maintain something useful? &gt; There is no obvious project management which sets a priority for some features for 6.0.0 and defers other features for subsequent releases. It might not be obvious to a casual onlooker but it's there for those involved. For example, any feature, library binding, or module that's mentioned in the [Perl 6 most wanted repo](https://github.com/perl6/perl6-most-wanted/blob/master/most-wanted/README-wanted.md) is considered a priority for 6.0, anything not isn't. Lead devs also talk about priorities on #perl6. For example, in the last few days there's been the suggestion that NFG might not make 6.0 and that lazy strings probably wouldn't either. In a recent discussion jnthn suggested "a tri-color marking of the spec ... Implemented in Rakudo, not implemented but we agree we really should for 6.0, deferred to 6.*". And so on. It's definitely not IBM, and it might represent too little too late for you, but to me it feels about right.
If you don't need Unicode support and CPAN modules, that might be OK. But I actually only started learning Perl at 5.8.8 so I'm not exactly sure. I usually write for 5.8.9 even though I'm using 5.18.2 at the moment. 
In the face of the years of failure to deliver a single working product worth using, words about the good intentions of the people still working on p6 are wasted on me. &gt; You aren't paying close enough attention. *I* spent a decade working on Parrot and almost that long working on p6. A lot of that was doing unfun work like fixing bugs, reducing memory use, getting rid of segfaults, et cetera--not to mention documenting almost every design meeting on a weekly basis. I saw the people who wanted to ship a working system pushed out of the process, whether through active conflict with other people or the passive-aggressive disinterest of the remnants just refusing to help. To prove people wrong--to demonstrate that p6 isn't in a little hobby bubble of endless tweaks and rewrites--then ship something worth using, something on which people can build reliable software. Setting artificial milestones and celebrating when those milestones are reached (or whitewashing them out of history when they become embarrassing millstones) doesn't impress me. &gt; Are you really expecting there to be practical use cases which only P6 can address? That was the point of p6 in 2000. Without some such unique reason to exist, the mind boggles at why anyone continues to work on it in 2014.
&gt; I saw the people who wanted to ship a working system pushed out of the process, whether through active conflict with other people or the passive-aggressive disinterest of the remnants just refusing to help. Did Larry Wall want to ship a working system? Did he express an opinion about the people being pushed out of the process? Did Larry Wall attempt to solve the active conflict and the passive-aggressive disinterest? 
hey StupidCrowd: I'm absolutely sure you need no support with this, but I agree with you. It feels good to see that someone has the same concerns I did, when most cheer in the other direction. This discussion let me think a lot and help me find distance to Perl. In the last years I was becoming more and more a defender of Perl and somehow my personal identifaction with this language become inreasingly stronger. Now every post in this thread in the style of scrottie's loosened my pathological clinging to Perls well-beeing. Reading the same fanboish and patronizing stuff again like I did in the past few years made me suddenly realize: Yes Perl 6 is really dead (to me). And now I'm free. Perl has a special place in my heart, but the word has a lot to offer. Scala, Go, F#, etc. lots of interesting and/or useful languges out there. Bye. 
I won't speak for Larry beyond this: from the start of the P6 process, he wanted an independent language specification so that multiple, independent implementations could exist. At various points I was personally frustrated by what I perceived as fragmentation and competition for scarce resources, but Larry's point was insightful: volunteer interest and effort and availability isn't fungible. Perhaps with stronger project management, some of that energy which went toward fragmentation could have been shepherded into unified efforts which could have produced something more usable by now. I can't prove that, though. P6 is a difficult enough language to implement anyhow, and the spec isn't finished yet either.
&gt;Are you really expecting there to be practical use cases which only P6 can address? Are you really saying that there are practical use cases that only P5 can address and that these are the sole source of pressure that might lead P5ers to develop, release, document, support, and maintain something useful? Are you kidding me? The reason I started learning Perl 5 was because it didn't get in my way when trying to do stuff and it wasn't a pain in the... to use regular expressions. Similarly, I use R for all the statistics packages, C for speed and low memory usage, blah blah blah... What is P6's niche? What is the ONE thing that P6 does better than any other language? What is the thing that will make people switch from another language to P6 because it makes it all that easier for them to do it?
I have the impression, that what you are trying to accomplish here no longer works. Before StupidCrowd started this thread I thought I was the only one that felt 'fooled' (not sure if accurat description) by the development Perl 6. I'm a developer. I know about setbacks and delays. But when you see the video of Larry and the reaction of the audience and the commenters, it is clear that Perl 6 doesn't have a technical problem. The problem is the behaviour of Larry and the Perl Community that follows him. There is a very strong and weird leadership in play, which I used to follow too. People like you now, that are trying to turn the table by asking for specifics don't impress me no longer. It doesn't work because you are not plausible. Too many have been waiting for too long for too little. You can ask for specifics, for help, for patience or whatnot. If you ask nice most people try to help. But when I see the founder of Perl 6, not presenting Perl 6 after a decade, but beeing busy with 3rd grade language details, toying with vim and beeing highly amused by his own puns, it is time for me to slowly and sadly walk away.
&gt; I won't speak for Larry beyond this: from the start of the P6 process, he wanted an independent language specification so that multiple, independent implementations could exist. Fwiw, aiui, what he most hoped for was a comprehensive test suite (roast) and a passing reference compiler (Rakudo). In his own words, from [his speech that included the initial P6 announcement](http://www.perl.com/pub/2000/10/23/soto2000.html): "I don't know how strict a spec it will be from the language design point of view. I'm not really big on that sort of spec and there is some value to using the reference implementation approach and what we currently have is a reference implementation with no second implementation, well, unless you count the JVM work, but, obviously there are benefits to having things justified well enough that you could implement another one even if you didn't want to, so we'll definitely be working in that direction ... what we particularly want to stress ... is not perhaps so much the spec as developing our current regression test. Well, we call them regression tests, but they're almost more acceptance tests, but, [if] we developed our acceptance into real regression tests then you'd further develop the real regression tests into a validation test of what the language actually means and actually go out and explore all the nooks and crannies and say, "This is Perl, this is not Perl," and then we actually have a machine-readable spec. And to me that's actually a lot more important than what the verbiage on the human readable thing says."
At a minimum, I would change the old-fashioned indirect style of "new Class" around to the direct, more modern "Class-&gt;new". my $tar = Archive::Tar-&gt;new( IO::Uncompress::Gunzip-&gt;new( IO::String-&gt;new($archive))); You could break it up into separate lines: my $tar = Archive::Tar-&gt;new( IO::Uncompress::Gunzip-&gt;new( IO::String-&gt;new($archive) ) ); This might be newbie-friendly: my $a = IO::String-&gt;new($archive); my $b = IO::Uncompress::Gunzip-&gt;new($a); my $c = Archive::Tar-&gt;new($b);
Thank you.
1) $a and $b are special 2) single-letter variable names are bad for maintainability
I feel that the Perl style is to use an underscore which says "this function is private. You're free to poke around and use it, but don't come running to me when your code breaks after a CPAN update" Basically, trust developers to do the right thing. Stop them from using a private function inadvertently (by adding the underscore) but don't try to stop them from using it on purpose, because you probably won't win that battle. Even lexical subrefs can be defeated.
I figured out what was going on. When I get a file out of a tarball like my @remote_file = $tar-&gt;get_content('etc/passwd'); It strips out newlines and stores the whole thing as one array element. my @remote_file = qx(ssh user\@server "cat file"); The new lines get saved when I cat it.
I would be great if the talk were posted after the conference.
Great answer and explanations. Would it spew warnings under *use strict* due to the undef interpolations? 
Use strict would not cause warnings, as long as $usedCards was defined via my/our/whatever If the script was run with -w it would cause a use of uninitialized value warning - that could be worked around by using something like this: for(0..max($#usedCards,$#dealersHand){ if(defined ($usedCards[$_])){printf ("%20s",$usedCards[$_]);} else{printf("%20s");} if(defined ($dealersHand[$_])){printf("%20s\n",$dealersHand[$_]);} else{printf("%20s\n";} } There's probably a more elegant way to do it, but this is pretty is a pretty straightforward way
I am fairly certain it will, testing now. edit: Yeah it's not happy with undefined junks in the shorter array: Use of uninitialized value in printf at ./21.pl line 226, &lt;&gt; line 3.
The general rule of thumb: Is it prefixed with "_"? Yes: Did I write it? Yes: I should know what to do. No: Do the docs say I can use it for whatever I'm doing? Yes: Horray! No: Don't use it. No: Horray!
Probably: printf("%20s%20s\n", $foo[$\_] // '', $bar[$\_] // ''); 
use defined to test for values before printing and it'll fix the uninitialized value warning
Thanks, I checked that the listener was listening on 10025, it was. I tried to talk to it via telnet and there were no reply packets coming back from the 10025 port process :( I think a moose based system is overkill for what I want anyway, so I think I will bail out of the POE stuff for this and go old school. I know Chromatic and his kittens will shed a tear but I can't help it, sorry.
Thank you! About API.. I actually though about doing this when I first wrote it. But I was thinking, what would one use it for? This module is useful mostly as SEO monitoring tool, and it could either be use to check one site at a time (for which your API description is perfect), or to run this check against many (maybe even a lot) of sites in a batch -- in which case wouldn't creating a new object for each site eat a lot of memory? That's what I thought, and decided to make it as a "tool" to look up a site's info (thus, the name).. Am I overthinking this?
I haven't worked on a Perl project complex enough to require protected methods, but I see your point. It would be good if the object system (e.g. Moose) provided attributes to handle this.
yeah even the above throws the warning. Which really bothers me. but if I comment out the use warnings; it works just fine. Which leads me to my next question. How serious is that warning? like I know that there are warnings in php that are pretty severe, causing your sites to 500 and junk, so is that similar with this warning in perl?
this bloc still throws that error... I am not sure why. for (0 .. max($#dealersHand,$#playersHand)) { if(defined($playersHand[$_])){printf ("%20s", "$playersHand[$_]"); }else{printf("%20s");}; if(defined($dealersHand[$_])){printf ("%20s","$dealersHand[$_]\n"); }else{printf("%20s");}; };
Attributes are really neat features, and in my experience at least, poorly known and sorely underutilized. Sub::Private is a neat example of making and using them, regardless of whether you agree with its necessity. The only other attributes I've experienced are the ones from Catalyst. I'm sure there must be more interesting ones out there, though.
An issue with the `$#array` notation is, as mentioned elsewhere, $#array is the index of the last element in the array, not the length of the array. `scalar @list` will tell you the number of elements in the list. You might want to do something like: print "$_", shift @dealersHand for @usedCards; With the caveat that the operation is destructive on `@dealersHand`. A quick bit of coding: $ cat test.pl use strict; use warnings; my @cards = qw(one two three); my @dealer = qw(four five six seven eight nine); print "$_ - ", shift @dealer, "\n" for @cards; Yields: $ perl test.pl one - four two - five three - six 
I fixed this too. I first pulled the file into a scalar, because that is the only format it comes in. my $remote_file_scalar = $tar-&gt;get_content(''etc/passwd"); Then I split it at the beginning of the line to unchomp it. my @remote_file = split(/^/, $remote_file_scalar);
You could use the [zip_by](https://metacpan.org/pod/List::UtilsBy#vals-zip_by-ITEMFUNC-arr0-arr1-arr2) function. use strict; use warnings FATAL =&gt; 'all'; use v5.10; use List::UtilsBy qw|zip_by|; my $dealer_cards = [2, 3, 4, 8]; my $player_cards = [5, 6, 7]; for my $cards (zip_by { [ @_ ] } $dealer_cards, $player_cards) { my ($dealer_card, $player_card) = @$cards; $player_card = defined $player_card ? $player_card : ''; $dealer_card //= ''; # the 'defined OR assignment' operator does exactly what the above statement does # ... } 
Perhaps there's an alternative solution that avoids the problem altogether. What if you instead used [Unicode characters](https://en.wikipedia.org/wiki/Playing_cards_in_Unicode) for the suits and single letters/digits for the numbers (plus 10, of course)? Depending on terminal width, you should generally easily fit largish hands together on a line. A 72 character line would give you 36 characters per side, minus two in the middle for separation. 35 characters fits eleven 10s plus suit plus one other card with suit. Since you'd bust at two tens and a non-ace, and you'd hit 21 with eleven aces and 22 with eleven 2s, you should never run out of space. If your terminal is 80, even better. Smaller terminals may give you trouble, but since only an idiot hitting on 21 with eleven aces can hold more than twenty-two characters' worth of cards, any terminal 45 characters or larger will work. Also, the dealer needs less space due to never hitting past 17. Nine 2s gives you eighteen characters, meaning any terminal forty-one characters wide or wider will support two hands filled to capacity.
Congratulations, now you know how to write private functions in Perl. That wasn't so hard.
&gt; I also know a lot of people using Perl in companies are totally in their own silo and don't even think to go outside their office for help. Yep, just got a job where one of my primary tasks is to fix this :)
So I have seen hundreds of talks on many subjects in my life. And dozens (maybe hundreds) about programming. And many about Perl. I have been programming perl since 1990, although I have kind of wandered away as my career has done whatever it is that careers do. But this was a horrible talk. A potential game ender. A talk that really brings into sharp focus the point that something truly wrong is going on here. Now, I can easily accept (and, after seeing this, really want to believe) that others have taken up the task of getting Perl 6 up to spec and out the door, and that would, I think, make me really happy. But this talk was just horribly depressing, in each and every way I can think of.
Wait...so that's *really* chromatic? It appears to be. It is not clear to me that anybody has more skin in the game. So a serious query: is there any way to coach/cajole/manage Larry Wall so he doesn't give a talk like that one ever again? I am being completely serious here. The lack of preparation was the obvious biggest problem, but even perfect preparation would not have saved a presentation that really only seemed to communicate what you just said: &gt; "It's been 14 years and I can't tell what's going on" That really boils down everything I've been thinking about perl lately.
So OP is not exactly a sunshine/rainbows kind of person, and I completely understand how health issues can really mess with progress and deadlines, but I would also suggest there are issues with the whole process if fourteen years isn't long enough to work around what is basically just Real Life. The other possibility is that the core team is just too small, but then the counter to that is that an interested bystander would take months/years to get up to speed on Perl 6 to be able to help. And that's a huge problem, also not unique to Perl 6 development, but one that is the real underlying issue so far as I can see.
When I was a lot younger, I kind of scoffed at the notion of software engineering, but Perl 6 does really seem to me to be essentially a process/engineering failure. I'm not sure whether the cause was the vague/moving target spec (and really, the whole apocalypse/exegesis stage of Perl 6 development always freaked me out), the complete over-ambitiousness of the plan, the apparent desire to make the whole language unparsable, or any of the other issues that happened, but, yeah; at this point people's expectations have been set that wrapping it up "quickly" could be two years, or twenty.
So that *sounds* attractive, but unless I am missing something (totally could be), that would still stick us with that lovely, classic subroutine argument list syntax that looks like it was designed for punchcards or something.
So this was actually a kind of humorous comment at one point: hey, why not just tell people Ruby 1.8-whatever was Perl 6? But we all knew that Perl 6 was about to be released, so... And now it's not funny anymore, which is why you got downmodded, I'm guessing.
That's a good question. Now that I'm looking around I can't find download counts either. It seems even their "popular distributions" count is done by #favorites and not by download count. I guess without being able to be certain the only safe thing is to do as they said and deprecate the command.
Ah. OK, I'm glad to find out that other people thought this. I... kind of didn't mean it as a joke. A while ago I was reading how Ruby worked, and it's clearly got some Perlish thinking in parts of it. 
&gt; The other possibility is that the core team is just too small, but then the counter to that is that an interested bystander would take months/years to get up to speed on Perl 6 to be able to help. If you read the posts by mr_chromatic on this thread and in other places about Perl 6, it seems that the reason that the core team is so small is that a lot of people (including mr_chromatic, Audrey Tang, Allison Randal, and various other Perl notables) have left. Mark Jason Dominus also seems to have been involved at the start, there is a blog post about it somewhere. Interestingly a lot of people seemed to be in doubt about the project at the start. 
A couple of years ago Active State opened distrib search for their repository, and they had download count for each distrib. But, download count is no longer available there either.
You can argue if you additionally need protected. Sometimes it is useful, sometimes I have to create a dummy class just to be able to access private functions. The problem is that the creator has to guess what privacy level is best for the function and regularly is wrong. By the way. That also would have been my first choice for the P6 object system. The underscore syntax that creates automatically a warning when called outside, but is suppressable by no warnings 'private'
I worked out a perl script to do it with a guy I work with! CSV is a mess but it's what it comes in (from the NCBI BLAST website).
I do use WAMP at work, for a perl CGI webapp. My perl version is from ActiveState 5.10.1 and wamp 2.2e. I don't get the question. There is no 'system perl' in Windows. There is only the one that you manually install, be it Strawberry or ActiveState, whatever version you want. If I'm assuming correct, to install modules 'locally' in WAMP you'll have to download, compile and test them manually into a 'lib' folder in WAMP and then tell your application to load modules from that folder. I mean tell your perl CGI or other app to load that lib folder something in the likes: use lib '/lib'; If you'll be more specific you'll get a better answer 
I'd suggest using a toolkit like BioPerl. You can work with FastA files pretty easily with Bio::SeqIO from memory, which treats them like objects.
Could you give an example of the file format you have? Looking [here](http://en.wikipedia.org/wiki/FASTA_format) suggests you can just not touch the first line of the file, then apply the transposition to the rest?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**FASTA format**](https://en.wikipedia.org/wiki/FASTA%20format): [](#sfw) --- &gt; &gt;In [bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics), __FASTA format__ is a text-based [format](https://en.wikipedia.org/wiki/File_format) for representing either [nucleotide sequences](https://en.wikipedia.org/wiki/Nucleotide_sequence) or [peptide sequences](https://en.wikipedia.org/wiki/Peptide_sequence), in which nucleotides or [amino acids](https://en.wikipedia.org/wiki/Amino_acid) are represented using single-letter codes. The format also allows for sequence names and comments to precede the sequences. The format originates from the [FASTA](https://en.wikipedia.org/wiki/FASTA) software package, but has now become a standard in the field of [bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics). &gt;The simplicity of FASTA format makes it easy to manipulate and parse sequences using text-processing tools and [scripting languages](https://en.wikipedia.org/wiki/Scripting_language) like [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)), and [Perl](https://en.wikipedia.org/wiki/Perl). &gt; --- ^Interesting: [^FASTA](https://en.wikipedia.org/wiki/FASTA) ^| [^Sequence ^alignment](https://en.wikipedia.org/wiki/Sequence_alignment) ^| [^FASTQ ^format](https://en.wikipedia.org/wiki/FASTQ_format) ^| [^Stockholm ^format](https://en.wikipedia.org/wiki/Stockholm_format) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj9ya6g) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj9ya6g)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes. BioPerl is the way to go. I use it all the time. So many nice functions.
unless ($line =~ /\^&gt;/) { $line =~ tr/U/T/; }
Thanks
Thanks for reply. By 'system' I meant the one you installed manually on your system, outside of WAMP. XAMPP, for example, comes with Perl interpreter (as I just looked on their website it's Strawberry portable), and this is the Perl that is supposed to execute when you run you Perl code under this WAMP stack, and it will use modules used for that Perl, not the ones you normally install for your "system" Perl. And there's suppose to be a way to install modules from CPAN for XAMPP's Perl, but for the version of XAMPP I installed a couple of months ago this didn't work, and Googling revealed it was a known long standing issue. I'm not home now to try a new version, but I wanted to find out what others are using, to maybe switch to something more stable Perl-wise.
I follow the [README-driven development](http://tom.preston-werner.com/2010/08/23/readme-driven-development.html) approach by writing the SYNOPSIS first. That way you can see very early how useful another developer will find working with your package. It can show when you've got the level of abstraction wrong, as evidenced by needing many lines to do the most common operations. If you use [POD::Usage](https://metacpan.org/pod/Pod::Usage), then you can also use the SYNOPSIS in scripts as the default help text.
It is ok, but slow and you have to install it. The unless statement from /u/neurobry is all that is needed. 
Am I a hipster to have heard of something before it got on HN? Or is HN's standards/etc lowering? Either way, good for Mojolicious. It's a fantastic web framework that is only second to Catalyst (&gt;_&gt;)
Something like Method Signatures would be a nice addition to the default too. I haven’t yet played with the new subroutine signatures in 5.20, but they look nice – so hopefully this issue will be solved. 
True, it is the second framework we made after Catalyst. ;-)
&gt; CGI &gt; ActiveState 5.10.1 Commiserations. I wish you every success in getting your workplace onto a vaguely recent or supported technology stack, or finding somewhere that uses one :-)
I wonder if it depends on your area. [I am looking](http://www.reddit.com/r/stljobs/comments/2a9940/seeking_software_developer_for_the_genome/) for Perl programmers.
Not to mention Windows server...
I know about all the goodies, but unfortunately they are mostly not an option on shared hosting.
That took a lot longer than I expected :D I wonder if Moar will last until 2015.
But that should not have taken 14 years...
&gt;Wow, so Servlets but worse... No, nothing like servlets. &gt;play framework or node or meteor The goal is to create a static website - a set of files and super-simple deployment. A better comparison would be with tools like Jekyll or Wintersmith. 
&gt;Commiserations. In case that wasn't sarcasm, thanks very much, I hope for the same. In case it actually was sarcasm, well it's was a requirement from the client, even before I joined the company, I couldn't change it, and it's too late now. But I told the client I'm very concerned about CGI and there are new web frameworks...so I got that. Which is nice 
Apache on windows...it's ok, apache is not the issue in this context, CGI is
Thanks for the informative article. I don't run a website anymore so I really hadn't looked at the details of Disqus at all. As you mentioned, security vulnerabilities can affect a large number of users or sites but the advantage to a system like disqus would be automatic updates when threats are found. One of the biggest hassles of running a CMS like Joomla or Wordpress or whatever is staying on top of security updates and platform upgrades. Unless managing a site is someones full time job, security is frequently #11 on their list of priorities. Even getting hacked sometimes doesn't wake anyone up since it's seen as easier to restore from backup and fix the security problem afterwords than to become proactive (the fix action in their mind is to restore the site, not to alter policy to stay ahead of the hacks) So I guess what I'm getting at is that something better than Disqus is needed, but it should be as easy to administrate as Disqus.
Not to mention Disqus is completely handled client-side so integrates perfectly with a static site
To an outsider, the comment linked to clearly looks like Rakudo-JVM is totally dying, but let's look at the numbers actually: https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv here we can see, that rakudo-jvm still has more passing tests than rakudo-parrot does. This is partially due to rakudo-parrot not doing any of the multithreaded or asynchronous I/O tests. You also have to understand that our spec testing works like this: We aim to have the number of failing tests at exactly 0. When a test begins failing, we investigate the failure first. If it's a quick fix, we do it, if it's a more lengthy fix we create a ticket in RT and "fudge" the test, meaning we either mark it as todo or skip it. Thus, the number of failing tests signalizes how much attention people are paying to the given implementation. Finally, when the bug is fixed, we remove the fudge on the test so that it is run again and is expected to pass. If a test was marked "todo" rather than "skip", it'll also show up as "todo unexpectedly passed", which is recorded as a failing test, too. You can clearly see, that all of our backends have upwards of 1k skipped tests and 500 todos. This is a combination of tests that show bugs that have not yet been fixed, semantics that have not yet been covered, features not yet implemented, etc. Sadly, these numbers are hardly representative, as some features have about 20 tests covering them, while others have hundreds of tests directly covering them and then there are features that crop up as a byproduct in pretty much every test we have (consider testing that sorting lists work, which we use to test hashes in results, as their order isn't guaranteed and varies across backends). We didn't give up on rakudo-jvm. In fact, just look at the irclog of the same day about 3.5 hours later, where jnthn says this: [http://irclog.perlgeek.de/perl6/2014-07-28#i_9093827](jnthn should spend some time teaching the JVM some of the things we've learned in the Moar backend) Thank you, carlosdelrey, for giving me the opportunity to show outsiders a clearer picture of how our development process works.
Actually, there's something else I completely forgot to mention that outsiders probably should be aware of: Rakudo as a code-base shares a great deal of code between the parrot, jvm and moarvm backends. A bunch of improvements to rakudo's performance that have been worked on recently not only benefit MoarVM, but also parrot and jvm. And implementations of semantics, parser bugfixes/improvements, work on the built-in classes are all shared out-right. Thus, even if we didn't change the rakudo-jvm backend for a long time, as long as it still compiles, it'll receive still improvements. Same goes for rakudo-parrot.
The JVM backend support is not dying, the problem is just that the manpower is limited. We currently host two GSoC projects, which means that we also spent quite some time mentoring our students, and teaching good programming practices has a higher priority than a test matrix of a compiler IMO.
Okay, let's assume that I'm not trying to turn the tables. You said "which I used to follow to". So at one point, you weren't aware of strange behavior in the community. What would you point out to your past self? I'm not asking for proof but please consider the possibility that I really don't know what's being referred to here. Advocacy/fandom always comes across as a little strange so I might be being forgiving as an allowance of that.
 &gt; Larry Wall's talks on Perl 6 resemble deliberate obfuscation I could see that. Especially with being non-committal about anything including whether stuff is going to all change again. I've been following it for so long that I'm used to it. It's unusual and not necessarily good, but it's become something somewhat predictable to me that I can point at and say "yeah, that's Perl 6 development". PONIE, Pugs, p5, a perl5 translation project... a pile of p6 stubs written in various languages... there have been about 20 projects I can think of. I look at it kind of like undirected random natural selection. &gt; Larry Wall seems to be the Schrodinger's cat of Perl 6 design. He is both in charge, and not in charge, at the same time. Yup. He tries hard not to be in charge but keeps falling or getting pushed in that position. At one point, all he was doing was leading the RFC process and then working on a perl 5 translation layer (which involved hacking on the perl 5 core to record and dump more metadata). Things were also going well-ish when Audrey was hacking on pugs and Larry was just kind of being a sounding board, but perl 6 implementation projects are especially prone to getting eaten by grues. To be clear, I'm not disagreeing or rationalizing it, just sharing bits of history that I think mostly support your conclusion. I can completely understand why those things strike you as odd. Again, I'm just kind of used to it (and otherwise not really inclined to take a position).
Larry is known for his meandering and weird talks. This observation checks out.
&gt; In case that wasn't sarcasm, thanks very much, I hope for the same. It was wholly sincere - I'm not exactly working with my dream technology stack either, right now!
That's funny, I have always thought that "good programming practices" includes things like "keeps the test suite running" and "doesn't break code for your users". But I guess those things aren't important when you're writing a toy project that isn't suitable for production and never will be.
&gt; Would you at least say that Perl 6 and Rakudo are today in a better shape than, say, the mentioned four years ago? Today is the fourth anniversary of Rakudo Star 1.0. Could I build a shipping product on it back then? I tried for almost a year. Would I build a shipping product on it today? No. Is it in better shape than it was four years ago? Not for my purposes.
Before we do a release, we always go through all backends and check their status much more in detail than we do every single day in between releases. If our users decide to run their production code with a daily checkout from git, then maybe they shouldn't expect that we do a full Quality Assurance run for every single commit we commit to any repository. On the other hand, we are happy if our users run the latest versions of the compiler against their project's test suites to point us at bugs as soon as possible. Ideally, those tests would be part of our regression tests, but the world ain't perfect.
I see. I failed to understand that static generators were a thing.TIL, thanks
Don't worry, I don't expect you to assure any quality at all for every single commit you commit to any repository. I don't assume that you demonstrate the professionalism not to waste your user's time. No comment about "users" and "production code" besides a good natured chortle. It's adorable until Ralphie-boy comes along and spews out a lecture about how "production means different things to different people and he's confident that Larry Wall has said he's thinking about starting to plan about writing a new Camel book one of these years, and isn't Nicholas Clark just dreamy while he's lurking on #perl6, the friendliest IRC channel if you want to talk about drinking beer".
You know, you really should get some help.
You know, if you perl-6 trolls stopped blaming other people for your problems, you might be able to write software worth using.
Great news. I've been using it to write a REST based API since version 3. It's now &gt; 5, and although there have been a few breaking changes, not enough to cause our API any real issues. Mojo's extensive testing has been a blessing when the documentation wasn't quite clear enough. The docs and grepping the github repo covered all my needs.
You expect that every commit to Perl5/blead is perfect and does not fail a single test? That is not how deveopement works. The testsuite is meant to be clean for a release, but not neccesary in between as already mentioned. You seem to be the most awesome superhacker. Can you point out a single codebase you have contributed to?
Discus solves a problem. Make a self hosted, productize and key in hand solution that runs on run of the mill hosting and voila! (Or even paid for with kick ass TOS and a moral conscience)
So, how is Rakudo-XS coming?
Perlsix is the one that can use some [help](http://ddumont.wordpress.com/2014/07/18/looking-for-help-to-package-perl6-moar-and-others-for-debian/). I doubt Gaben would have any use for it though, I know I don't.
Are you kidding? We run the daily smokes about the spectests, the module tests and the star distribution tests to know exactly that: are there regressions. It is like you telling a guy who cares about his cpanteser results than he should fix his stuff before he gets a negative report. And also, who's mission is to insult everyone? That's certainly you. And again I ask you to show me just a single line of code of your valuable work. It is interesting that you just ignored that part of my post.
I do not see here that (s)he's blaming anyone for problems of Perl 6's past. It was just pointed out that you could probably need some help so that your personality can improve a bit. (Which is never bad, mind)
I meant get some help for whatever problem you have that causes you to come up with conspiracy theories about IRC logs being edited and claiming that everyone developing Perl 6 is an alcoholic. I guess Perl 6 doesn't have enough valid problems if you need to invent such outrageous claims.
Exactly. Try combating spam with a home grown solution. Good luck with that!
Probably like [SocialSharePrivacy](https://github.com/panzi/SocialSharePrivacy) does for Facebook, Twitter, etc. *edit spoke too soon, it does the same for Disqus too. :-)
What should that be?
You seem not to listen. I work on rakudo since 2012. And since then I think I did a pretty good job. What did you do?
I'm not an alcoholic fwiw. I am a fulltime employee, I've three little kids and an awesome wife at home, and I spend like four to five hours a day hacking on making rakudo better when my kids are in bed. So come on, make a joke about that.
The one TPF was going to spend ten thousand USD on? To be completed in nine weeks, starting anytime? Abandoned before it was started? http://news.perlfoundation.org/2013/07/hague-grant-application.html
Ahh, that has not much to do with XS so I did not get the connection. Yeah, it is sad that he did not start that project.
Ohh, I address important things while you slightly miss the point: https://github.com/rakudo/rakudo/commit/c506f5dc5ad58e0408f21ef057f7910e0f05cff6
Here's one way to do it with BioPerl. Many Linux distros have BioPerl and make it relatively easy to install. use strict; use warnings; use Bio::Seq; use Bio::SeqIO; my $in_file = 'test.fa'; my $out_file = 'test_dna.fa'; my $in = Bio::SeqIO-&gt;new(-file =&gt; $in_file, -format =&gt; 'fasta'); my $out = Bio::SeqIO-&gt;new(-file =&gt; "&gt;$out_file", -format =&gt; 'fasta'); while (my $seq = $in-&gt;next_seq()) { my $seq_str = $seq-&gt;seq; $seq_str =~ tr/Uu/Tt/; my $new_seq = Bio::Seq-&gt;new(-id =&gt; $seq-&gt;id, -desc =&gt; $seq-&gt;desc, -seq =&gt; $seq_str); $out-&gt;write_seq($new_seq); } $in-&gt;close(); $out-&gt;close(); 
www.meetup.com/The-New-York-Perl-Meetup-Group/events/197002932/
Source: https://twitter.com/tudorconstantin/status/468653061133840385/photo/1
Thank you for responding. 
Nice one. I often wish that the Perl Camel would show a bit more toe :-) Btw does anyone know of a sweet Perl mascot, that doesn't come with trademark restrictions? 
"Perl is horrible because it lacks a static type system like Haskell, which allows you to enforce invariants...blah...blah..blah..."
Perl 6 [in one image](http://hbfs.files.wordpress.com/2009/11/perl6book-parody.jpg).
Push an array ref to the results array, instead of the individual elements
Like this http://pastebin.com/uku4ie4y#
thank you both so frickin' much, How on Earth I never thought of doing so..... I'm now off to go grab some more Caffeine I think :) 
Good luck and remember that lists / arrays flatten
I wrote one.
Except for some reason, sometimes people don't wear a helmet.
I used to write Perl code for real users, until our lab switched to Python because Python has a future.
Can you post your code?
Also check out [Modern Perl](http://onyxneon.com/books/modern_perl/modern_perl_letter.pdf) (PDF), which has good chapters on references and nested structures.
It was something like this package My::Class; has '_ua' =&gt; ( is =&gt; ro ); package My::Class::Sub; extends 'My::Class'; has '+_ua' =&gt; ( is =&gt; rw );
I am subclassing to break encapsulation to more effectively test an upstream system. I've worked around it be creating seperate classes for testing with different values of _ua.
I wrote a bunch of modules, I am working on a Perl 5 interoperability layer (called v5) and I am working on getting up to spec besides fixing things... And also I can speak for all Perl 6 devs that starting from scratch will not happen. Rakudo in combination with MoarVM shows that it can compete with other languages feature and performance wise.
In light of [the recent PHP news of specifications](http://hhvm.com/blog/5723/announcing-a-specification-for-php)... I'm still quite saddened by Perl's lack of big boy toys.
At least that guy is going somewhere. Boo, that was really low... =(
Hm, can I respond to myself almost a year later? "Too late, doesn't matter."
Perl has a Raptor: http://blog.kraih.com/post/43196105956/a-logo-for-perl-5
May I ask why it is too late, and/or why it doesn't matter?
What does a specification provide? * it solves arguments about the intended behavior of the language * it allows multiple implementations I'll grant that #1 is interesting, but it's not useful. I don't believe #2 is helpful, because, to make any alternate implementation worth using, you have to deal with the XS problem. To deal with the XS problem, you either embed libperl and adopt a new problem of marshalling data between your new implementation and libperl, or you spend the time designing an alternate extension mechanism for Perl to replace XS, deploying it across the CPAN, and waiting several years for enough of the CPAN to have adopted it that you can do useful things with your XS-free implementation. Oh, and that's after you've spent years working on the specification at all. What do you hope to get out of that? I'm not sure.
"starting from scratch will not happen" -- yeah, everyone believes you, just like everyone believes you when you say "ready for production" and "useful and usable" and "basically ready to use in the next eighteen months" and "done by Christmas". In other words, no one believes you after 14 years of saying the same thing over and over and over again.
/u/Lallana
According to the non-existent Perl spec, PHP is an implementation of Perl. That is why it can't get to version 6 either.
I have some more ideas on how to come up with a spec. * Extend GNU AWK until it can interpret Perl source * Extend GNU Emacs until it can interpret Perl source * Extend GNU CLisp until it can interpret Perl source * Extend GCC until it can compile Perl source Take anything that works the same between the interpreters and say that is a spec. The XS problem can be solved by not including it in the spec the same way GNU CLisp and Steel Bank Common Lisp solve their implementation incompatibilities. I am not in need of a spec right now, so I won't be working on any of those. I also don't want Perl to catch a case of the Lisp curse.
Honestly, I would be surprised to see folks over there say practical things about Haskell, too.
Quite happen about this given I live in SLC.
An excellent opportunity for non-authors to contribute to CPAN by sending such sentences to the author/maintainer of the modules they use.
Could you move it to the winter so it can be a ski trip also?
 Thanks I didn't know that and it's quite good IMO – definitely T-shirt/mug worthy :-) (The onion is a good logo, but not exactly a mascot) 
+1 to this, very good resource for starting out.
&gt; I will never understand why you would work on it Are you getting paid to deliberately not understand, or did you escape from the zoo?
Oh no, you caught me. The knights Templar have funded a campaign with money funneled from the Vatican's blackmarket sales of Nazi-stolen artwork solely for the purpose of badmouthing perl-6, a project which is going swimmingly on time and, fourteen years into that timeline, is hitting its milestones of quality, usability, and production readiness. Other things i don't understand: getting excited about the Commonwealth Games. Now go on, get your beery #perl6 persecution complex on and whinge about that too.
Nothing really jumps out at me. Getopt::Long::Complete is kind of cool though.
I would love to see data on that shirt question over other years.
Exactly! I have two sets of static pages, and I ended up using Disqus because (a) I *really* didn't want to write a comment system, (b) Disqus was easy to drop in to static pages, (c) it's free. There are a number of things I wish were different about Disqus, but (1) see (a) above, and (2) a brief look at the other options (albeit a while ago) just reminded me of (b) above. Would be great if someone created an open-source alternative, which was also hosted (see (b) above), but which also had a strong funding / monetization strategy, so it wouldn't be pulled from under us. I suspect someone starting such a project would quickly realise that creating an easy-to-use for end users, easy-to-use for builders, scalable, secure, spam-coping commenting system is harder than it looks. I'd be prepared to pay a small amount per month to use (really "to support") such a system, but not much (see (c) above).
Wrap it in a sub, like this: package Deck; sub get_deck { my @deck; # etc .... # ... return @deck; } 1; And then in your program you can do: use Deck; my @deck = Deck-&gt;get_deck(); The convention is that package names begin with an Uppercase letter. Also, try not to use globals (variables defined in the top scope) as that may limit you later on. What if you need to use two distinct decks within the same script? Your script may work but it's very simplistic. If you want to improve this, a good first step would be to make it object oriented. So then you make a Deck class with a constructor sub new() (returning a Deck instance) and object methods shuffle, sort, etc that work on that instance. 
I'd recommend exporting a function if the module isn't really OO. Edit: This does scream to be OO though
Here is an example creating an object and using Data::Dumper to print it out. I've placed it into a single file here, but you can split it up into 2 like your initial example if you wish just don't forget to add in a "use Deck;" if you do. package Deck; sub new { my $class = shift; my @deck; my %cardValue = ( '0' =&gt; 0, '2' =&gt; 2, '3' =&gt; 3, '4' =&gt; 4, '5' =&gt; 5, '6' =&gt; 6, '7' =&gt; 7, '8' =&gt; 8, '9' =&gt; 9, '10' =&gt; 10, '11' =&gt; 10, '12' =&gt; 10, '13' =&gt; 10 ); my %cardFace = ( 0 =&gt; 'A', 2 =&gt; 2, 3 =&gt; 3, 4 =&gt; 4, 5 =&gt; 5, 6 =&gt; 6, 7 =&gt; 7, 8 =&gt; 8, 9 =&gt; 9, 10 =&gt; 10, 11 =&gt; 'J', 12 =&gt; 'Q', 13 =&gt; 'K' ); my %cardSuit = ( 'D' =&gt; 'diamond', 'S' =&gt; 'space', 'H' =&gt; 'heart', 'C' =&gt; 'club' ); # build a deck of cards, and shuffle them in an array. my @preDeck; foreach my $suitKey (keys %cardSuit) { foreach my $faceKey (keys %cardFace) { my $value = $cardValue{$faceKey}; my $face = $cardFace{$faceKey}; push(@preDeck,$face . $suitKey); } } while(@preDeck){ push(@deck,splice(@preDeck,int(rand($#preDeck + 1)),1)); } return bless \@deck, $class } 1; package main; use strict; use warnings; use Data::Dumper; my $deck = Deck-&gt;new(); print Dumper $deck Not sure what material you're following but you probably want to check out http://metacpan.org/pod/perlobj and http://metacpan.org/pod/perlootut You can also read them in your shell using perldoc perldoc perlobj
Since your primary question has been answered, I wanted to bring up that the Fischer-Yates algorithm is the standard way to shuffle arrays. I mention this because, while what you did is fine for learning, this particular problem is known to have a lot of easy and wrong solutions. See List::Utils for a premade `shuffle()` solution.
as its just an array I am shuffling I guess this method would work fine, but for the same reason there is a cost hash called "cardValue" my original plan was to have a randomized hash that held the value of the cards" %deck = ( card_name = '10' #value ) and randomizing that would have mixed my keys and values if I remember right.. is that true? or can you shuffle on a keys / values?
Thank you so much! I am 'bless'ed enough to work in a company that uses perl (which is why I am learning it) and a very talented young man from one of our development teams came over and helped me rework the above iteration into an OO module. Still playing catch up with OO as a whole, and perl seems to handle it pretty uniquely. I think I have enough understanding of it to make some really bad scripts then have someone help me again :P.
Yes, the basic implementation of OO in perl is "peculiar", to say the least, but very powerful. Modern frameworks like Moose (or Moo, a more light weight version) give you access to a simpler and more "traditional" OO approach (and even more power). 
The simplest way to do what you want while making sense will be to use exporter. In your module at the top for example: package Deck; use Exporter; @EXPORT = qw(deck); ... Then in your main script you can 'use Deck' and then call deck() (the parens are required). You could go for an OO solution like some other people have mentioned but its way overkill for this module unless you add a LOT more functionality.
This is actually very cool. So much is done in Excel, from finance to sciences like genetics, in spreadsheets that it boggles the mind. 
I cringe at the idea of a 32MB Excel file. There comes a point where it needs to go in a proper database. The expanded row limits in 2007 were a terrible idea.
I whole heartedly agree. Unfortunately, "this is the way it's been done" and I'm an engineer, not a bureaucrat. To be fair, it used to be 80MB, but they broke it up into 10 different excel files... it's all horrible.
I use these pretty frequently. They do the job well and are extremely simple to use. I like that they give me very fine grained control of my formatting for color coding, bold, etc.... Also, being able to parse and output multi-sheet workbooks is very handy. If you've ever tried to stack multiple "conditional formatting" in Excel or tried to do complex logic in Excel formulas, you'll probably really like these modules.
Um, am I missing something or does this solution skip over processing formulas? About 4 years ago for my job I implemented a way to parse formulas and convert them into Perl code, parse text and numbers into a 3-dimensional hash (workbook-&gt;row-&gt;col), and a partial formula engine that can execute the formulas after they were parsed into Perl to get the same results that Excel would. Very easy to interface an Excel file into our Perl scripts.
If the script hasn't changed then the problem is probably with your environment. Did you update sendmail or replace it with another MTA (e.g. no more /usr/lib/sendmail?) Are you getting an error or just not receiving any email? Have you looked at your mail logs to see if there is something going on there?
What happens when you run the script. What error output do you get, if any? Also, perhaps you want to use [Net::SMTP](http://perldoc.perl.org/Net/SMTP.html).
I'd be very interested to see that go into Spreadsheet::ParseExcel. Its list of [Known Problems includes](https://metacpan.org/pod/Spreadsheet::ParseExcel#KNOWN-PROBLEMS): &gt; This module cannot read the values of formulas from files created with Spreadsheet::WriteExcel unless the user specified the values when creating the file (which is generally not the case). The reason for this is that Spreadsheet::WriteExcel writes the formula but not the formula result since it isn't in a position to calculate arbitrary Excel formulas without access to Excel's formula engine. I believe the formula output is written by Excel itself, so ParseExcel can read the value, but it doesn't know how to get at the formula itself. From the last time I looked into this, the textual representation of the formula doesn't exist in the Excel format. Instead, it gets some kind of encoded AST. So ParseExcel needs to know how to decode that data and rebuild the AST. This has [been in the TODO list since at least v0.25 from 2002](http://search.cpan.org/~kwitknr/Spreadsheet-ParseExcel-0.25/ParseExcel.pm#TODO), so I don't expect it will be done otherwise anytime soon.
If the MTAs were updated recently, then this would no longer send mail. The culprit would probably be SMTP WRAPLONGLINES. They are truncate by default on most mail systems now. Rewrite this. Remove the inline HTML, use a modern framework like Mojolicious, and use a proper mail module from CPAN. Also, you should retry connections to the MTA, and you should put in a counter around the mail module to ensure you don't attempt to resend the mail a billion times. Source: I am a Perl email developer and email architect for a Fortune 100 company.
I know this is a r/perl. I have been using Perl since 2007+ on a number of projects and had a job using Perl for our ETL process (for 2 years up until March 2014). I have recently switched jobs and the new place uses python. I still use both languages. But for excel hands down [pandas read_excel](http://pandas.pydata.org/pandas-docs/dev/generated/pandas.io.excel.read_excel.html) is a game changer for how to interact with excel files. I am still doing ETL and pandas is always amazing me on how excel just becomes another file to deal with. I want to build something like pandas in perl!
I've never used these particular ones before, but for many years I've been heavily using [Spreadsheet::ParseExcel](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.65/lib/Spreadsheet/ParseExcel.pm) and [SpreadSheet::WriteExcel](http://search.cpan.org/~jmcnamara/Spreadsheet-WriteExcel-2.40/lib/Spreadsheet/WriteExcel.pm). They aren't perfect, and some things require a little understanding of Excel file guts to use, but they are very powerful and work really well. I would definitely recommend them. I haven't had any issues reading and writing large Excel files with those modules at acceptable speeds. It is kind of nice to be able to read from a database and create a fully formatted Excel file with many worksheets, formulas, etc. You could also write really nice importers that read data from Excel files. The only thing I've never found a satisfying way of doing is modifying Excel files with Perl. It has been a few years since I tried. I haven't looked closely, but maybe the ones used in this article can do it? Has anyone had much luck with opening an existing spreadsheet, making some changes, and rewriting while maintaining all the other formatting, formulas, and other features?
&gt; Ask Ralphie-boy about Moritz censoring the IRC logs. He remembers when Jonathan went on an epic public rant and now there's absolutely no evidence of it in the IRC logs. Hi, "Ralphie-boy" here. *About Jonathan's "epic public rant"* I've been on #perl6 a good bit over the last three years. I vividly recall Jonathan Worthington writing an IRC line which was mostly or entirely upper cased. I hadn't seen him do that before (and haven't since), and he was clearly irked, so it caught my attention. I'm 100% sure I saw such a line. (This line is what carlosdelrey referred to as "an epic public rant".) *About there being "absolutely no evidence of it in the IRC logs"* Some time later someone was suggesting Jonathan chased people away. While this rang hollow to me -- Jonathan seems to be consistently friendly -- I like to look closely at whatever counter-evidence I have that can challenge my confirmation bias. I decided I wanted to see Jonathan's comment again. I couldn't recall what he had said but was pretty sure it was in Feb/March 2013 and 100% sure it was entirely or mostly all caps. So I spent time searching for it. But I failed to find it again. *About "Moritz censoring the IRC logs"* More recently someone claimed Moritz was censoring the logs. That was an "aha" moment; perhaps I didn't find Jonathan's comment because Moritz deleted it. I think it's plausible that Moritz censors the log and that's what happened to Jonathan's comment. (It's also plausible that I just failed to find it again because I didn't look carefully enough in the right place.) ------ So there you have it. I relayed a simpler version of this story to carlosdelrey and he writes it up as "Moritz censoring the IRC logs when Jonathan went on an epic public rant and now there's absolutely no evidence of it in the IRC logs."
Good to know, thanks for the update. I basically just searched for 'perl smtp', I haven't used either module. Doing my part to try to avoid reinventing wheels.
Perl likes to take good ideas from other languages. I'm interested in how pandas work. From what I can tell with a quick glance, it looks like it reads an Excel worksheet into a big datastructure. That's not all that remarkable by itself, but maybe I'm missing some context?
No you are exactly right. It loads it into a pandas data frame (which is like a excel like data structure). It is easy to do calculations on rows/columns, add/remove columns, remove/replace nulls and a lot of other neat things. We really only use pandas for reading the many files we have to process including excel, csv, tsv, but in the end all build the same nice data frame structure. For all inputs it can write all those outputs including excel.
Maybe someone who organizes conference can explain more of the behind-the-scenes expenses. It sounds like conference organizers are cleaning up. Between conference admission prices and corporate sponsorships that can go as high as hundreds of thousand of dollars, they have a lot of money coming in, but it sounds like they don't compensate speakers much, if anything, and renting space can't be *that* expensive. OSCON must pull in at least 10 million dollars per conference, and from the outside it doesn't seem like it costs them anywhere near that much to put on. They can't even provide working wifi! I must be missing some piece of the puzzle.
If _at all possible_, you should be using DBI to connect to databases in Perl. MSSQL presents some challenges, as there's no native driver for DBI for MSSQL. There is, however, an ODBC driver. If your server is configured to handle ODBC connections, you should use this. The starting docs for DBI are [here](https://metacpan.org/pod/DBI). The ODBC driver docs are [here](https://metacpan.org/pod/DBD::ODBC). The very short version of your problem, though, appears to be that you're not doing anything with that well-formatted query string except formatting it, which is neat, but not very useful.
Without actually looking at the code: try to run the script with 'perl -d script.pl' for debugging and see where it hangs. Tutorial about debugging with -d: https://github.com/chiselwright/perl-debugger-tutorial
The WiFi wasn't too bad at OSCON, a lot better than I've had at many conventions. The big costs as I see them are: * Convention space rental $10k/day (OCC doesn't post it's rates, I'm basing this on what I've seen for several other cities) * Catering $66k/day (Based on an average of $22/plate and 3000 attendees) * A/V equipment/staff $62k/day (Looks like ~$2500/room/day for audio/projection/video recording, say ~25 rooms) * Conference staff $9k/day (the door guards, etc, say 50 of those billed at a rate of $15/hr, 12 hours worked a day) So, that's about $150k per day of the conference. I'll fully admit I'm not an expert in any of these areas, based on the sheer number of AV techs they had on site I wouldn't be shocked if my estimate is &lt; 50% of reality. Catering might be low considering I'm not accounting for the coffee and afternoon snacks. No real idea of what the rental rate at the OCC is or what the real staffing costs are. Let's just assume the real cost is twice what I'm estimating. If we just look at the main event that's three days of conference, making the total cost (not including what they may/may not pay the speakers) $900k. IIRC registration was $1100, so they pulled in $3.3 million in registration fees alone!! Either I'm WAY off on the estimated cost or O'Reilly is raking in the cash!
Props for helping out OP without being a complete and utter dick. I wouldn't have been able to resist, so I'm glad you got here before me. Cheers. 
The key issue seems to be transparency, I find it abusive to charge huge amounts of money for tickets and then give nothing to the speakers, which are the justification for the conference. Or just be transparent and explain the costs to the attendees, business is sparked in conferences but the conference itself should not be the business.
OSCON's speaker compensation is pretty poor, IMO. They charge a *lot* of money to attendees. The compensation for tutorials is truly offensive, given that a 3 hour tutorial costs something like $700 per attendee. OSCON pays for one night in the hotel and a flight for tutorial presenters (so about $700 total). YAPC, OTOH, charges very little (probably too little) for these things and compensates speakers fairly well. FWIW, my all day Intro to Moose class at this year's conference cost $130 per person. I received $100 per student, which is more than fair, IMO. In other words YAPC charges 1/12th per hour for a tutorial and the tutorial presenter probably makes more money for their trouble. As far as compensating non-keynote, non-tutorial speakers, given the economics of YAPC I think anything more than free admission is out of the question, unless ticket prices go up tenfold or more. Paying travel expenses for speakers that will attract more attendees seems entirely reasonable. Paying them an additional speaking fee also seems reasonable if the organizers think that the speaker will bring in enough additional attendees to make up the cost, or just because it makes the conference better for the attendees who are already planning to come.
Which of the different Windows Perl distributions did you install? You may have chosen one that doesn't include that module.
I tried both strawberry, and activeperl. both 64 bit, both failed. 
If you want to launch firefox with Google, from within perl, this works for me: system("firefox", "http://www.google.com");
so as a question, can I include a variable in the URL? I want to do a selection of random searches as part of the code. IE www.bing.com/%randomvar%asldkfjasdklfjdsf ?
Uh… generally you would use LWP or something similar to GET/POST URLs instead of trying to drive a browser. You may want to check into that. That said, ppm or ppm3 is ActiveState's perl package manager. 
I actually want the page open, which is why I was asking about browsers. I'll keep that in mind, though!
1. how would I call this arcane "ppm?" Sorry, I've been out of the code mindset for a good bit of time (thanks to some hospital "fun") so I'm really rusty, and I'm a newbie to begin with. 2. I actually want the browser window, because I get rewards for triggering the search using their search page.
Bing it and see.
&gt; I actually want the browser window, because I get rewards for triggering the search using their search page. This sounds like you are trying to game some system, which typically is not to be encouraged.
I haven't used Windows in a few years, but I seem to remember ActiveState putting Start menu shortcuts for ppm and ppm3. The first is a console program (Start-&gt;Run-&gt;cmd.exe, type 'ppm') and the other is a gui. Both should be in the Start menu, or you could open a cmd window and type 'ppm3' or 'ppm'. 
Go to the location mentioned in the error i.e the location that is saved in @INC. Check if you can see the module there. It might just be a case of the module not being in the location that Perl is looking in.
I've looked up the Win32::FileOp module and to me it doesn't seem to be part of the base distribution, so you would need to install it. On the other hand, it seems the built-in `system` command would work just as well for your purposes.
&gt; (Start traversing directories, or using static paths in variables and you will encounter some WTF moments if you leave out an escape somewhere.) You can use forward slashes in paths instead of backslashes. (And if you already knew this, never mind.)
Timely link, thanks. I just started doing work over HTTPS against a vendors dashboard.
It's good to ask for help and great that people will but if we always expect to be spood fed everything we'll never learn to eat ourselves. Edit: If you're getting the parametres from somewhere you should probably sanitise them before putting them into a system call
Probably from the start menu, there was something about installing modules in there when I last used it.
Sign me up as a coder. You organize the project and the programmers. Give me a task and I will work on it. 
Error message? Details?
Thanks for the pointer, will take a look
whats wrong with YAML? didn't YAML come from a perl developer? 
Have you checked out slaughter? It's a Perl thing. https://github.com/skx/slaughter
Just reminding there is https://metacpan.org/pod/Object::Remote ;)
Not the OP, but I quite disliked Ansible's YAML configs. They were basically a programming language encoded in YAML which was kind of frustrating (it puts them on the road towards XSLT, though they aren't nearly that bad yet). Plus they have a "compact" syntax that means they have to parse the plain strings they got from the YAML which means there are subtle inconsistencies between quoting and syntax when you do things the compact way.
ingy was involved: http://www.yaml.org/about.html
&gt; you should be using DBI to connect to databases in Perl. I agree. I just started using Perl to connect to Postgres via DBD::Pg, and I'm already producing reports. It's not that bad. 
Technically I agree with you. Financially, many companies can't afford the cost of conversion to a database. And even if they could afford the conversion, the people may not like the new db and not use it, and go back to the spreadsheet anyway. I've seen it happen. 
I have nothing against YAML in itself. It's great for simple configs, or even complex things sometimes. But if you take a look at Ansible YAML syntax, it is horrendous. Ansible started with a small thing, but then grew quickly, but YAML is at it's core and they can't move away from it. There are a bunch of conditionals, includes, syntax conventions, variable interpolation, etc... Example: https://gist.github.com/marktheunissen/2979474
Awesomesauce!!!
I suspect in the real world you'd want `Net::SSH2` instead..
Use DBI instead of shelling out to an external SQL tool? Also, don't put needless quotes around "$variables", especially if you're trying to use them as numbers.
I'm a little rusty, and don't have a SQL Server handy to test with, but it'd be *something* like this. The connection string's the tricky bit: #!usr/bin/perl use strict; use warnings; use DBI; my $host = 'hostname'; my $user = 'username'; my $pass = 'password'; my $dbh = DBI-&gt;connect("dbi:ODBC:Driver={SQL Server};Server=$host;UID=$user;PWD=$pass"); my $query = &lt;&lt;'EOSQL'; select SUM(ocount) TotalCounts from ( select dbd.DateStart, count(oo.id_orders) As oCount, DATEPART(dw, dbd.datestart) as DayNumber from [dbo].[DaysBetweenDates](dbo.BeginningOfDay(CURRENT_TIMESTAMP), dbo.endofday(CURRENT_TIMESTAMP)) dbd left join orders oo on dbd.DateStart = oo.orderdate and oo.OrderPlacedBypk = '011CA1AF-0C20-4B87-93CC-11886C530E2D' group by dbd.DateStart ) As Total where DayNumber not in (6,7) EOSQL my $result = $dbh-&gt;selectall_arrayref($query); my $finalResult = $result-&gt;[0][0]; if ($finalResult &gt;= 20 ) { print "OK - Order count is at or above average.\n"; exit 0; #Nagios OK exit code } elsif ($finalResult &lt;= 7) { print "CRITICAL - Order count is below average.\n Current Average = $finalresult"; exit 2; #Nagios CRITICAL exit code } else { # $finalResult between 7 and 20, exclusive print "UNKNOWN - Unable to determine order average.\n Variables are:"; exit 3; #Nagios UNKNOWN exit code } 
That's the problem though, I can't for the life of me seem to get an ODBC driver for MSSQL to install properly on my linux machine. Searching for tutorials online has been no help whatsoever, as they're all completely different. I have no idea which one to use. Not to mention, in half of them the commands they tell me to run don't work on my machine for one reason or another. 
Thanks, it's nice to see this level of advocacy!
If I recall Matt had issues using `Net::SSH2` and dumped to qx() and ssh instead to deal with it. Matt rarely does crazy things without a reason, he just comes up with reasons very easily.
Have you tried CFEngine?
Improving Perl 5 by borrowing more ideas from Perl 6 is awesome in two ways, even when most people at work are tied to an older version of Perl 5. 1) Perl 5 need to improve, otherwise it will get forgotten. 2) When more Perl 6-like features are part of Perl 5, then the barrier that stops ppl of using Perl 6 will go away a bit.
I am one of those people that loves Perl, and have stood by it for years. I couldn't fathom why Python was gaining in popularity when Perl was in the same space and didn't seem to have any additional features that would sway me into making the switch. Sure, Modern Perl is cool as heck, but the reality is that sometimes great products fall to the waste side - possibly because of marketing or popularity. At some point, the perception becomes the reality. If we were geared to better products: * the BetaMax would have beat out the VCR * the Amiga would have beat out the PC * ogg music format would have beat out mp3 format There are literally hundreds of examples of better products losing in popularity because of marketing perception. Perl may be the victim of one of those. A recent article shows that ["Python bumped off Java as the top Learning Language"](http://www.computerworld.com/s/article/9249607/Python_bumps_off_Java_as_top_learning_language). I've noticed that some of my local universities are using Python as a teaching language too. This will seal the fate of Perl over the next five to ten years. The market will become flooded with Python developers right out of University and Python will enjoy the same popularity as Java did when it surpassed C/C++ as the most popular teaching language. So - I don't agree with this guy that Perl is a great career option for someone that is starting out. There is a lot of legacy Perl code out there, but it seems like new development is happening in Python. I'm seeing it in the investment banking and finance industries. These industries have ALWAYS had a ton of Perl - They've been using it for years and years and were early adapters to Perl because of how awesome it is at regular expressions and parsing data. It's the duct tape on more financial systems than most people will believe. But, it's recently that I've been noticing that Python instead of Perl is a requirement for many of the jobs. I love Perl - I have a TON of code on my computer that is in Perl and I've been using it for about 15 years. I've been a staunch supporter and defender of the language for a long time, but I can see the writing on the wall. Perl will continue losing market share and anyone who disagrees is delusional. Here's why: * It's not being taught at schools * Python has become the main teaching language and every college graduate will already know this language * Python supporters have done a fantastic job at bashing the Perl language for years on message boards and forums .. questions like "I'm going to start leaning how to program.. should I choose Perl or Python" - Those python coders bashed the heck out of Perl with very little in response from the Perl community. I've seen this hundreds of times. [This cartoon illustrates the point](http://www.padhokhelo.com/wp-content/uploads/2014/04/perl-and-python-hackers-compared.png) * Industries that have long supported Perl are now moving to Python * Modern Perl came out a little too late - it should have been done five years earlier * Perl 6 stole the next logical version number from Perl 5 - I know that many people don't think this is a big deal, but to anyone new to Perl, or considering learning Perl - they view Perl 6 is the upgrade that isn't deployed anywhere and by all accounts not production ready and happens to be very different than Perl 5. This causes a LOT of confusion. Why would anyone choose learning Perl 5 when they think that the skills they are going to learn will be obsolete in the near enough future? They don't realize that Perl 5 and Perl 6 are completely different languages and will both continue to grow on different development trees. Naming Perl 6 really put the nail in the coffin for Perl. They should have just called it something else. 
Perl is still taught at schools; I still help students with homework.
This last one. Perl 6 has been "under construction" for as long as the time from the introduction of FORTRAN (1957) to the introduction of C (1972). Perhaps the only longer vaporware software project is GNU Hurd. Both Perl 6 and Hurd are fine as pet research projects, but please, please Mr Wall et al, take the advice here and call Perl 6 something else! Let Perl 5 get on with life!
This post really needs a link. 
I would have bought a ticket, but there was no link, and the tilt.com home page has no search option. 
Why are people so desparate for a new major version of Perl? What is bumping 5 to 7 going to add? We're still 2 ahead of Python, for crying out loud ...
Rik Signes found the link for me: https://www.tilt.com/campaigns/ppw Thanks Rik!
Is running Perl on a Windows box an option for you?
&gt; Why are people so desparate for a new major version of Perl? Because it's been in the works for 14 years and was marketed by publicizing the flaws of Perl. *Some* of those flaws have been addressed, but the marketing message that "someday there will be a successor to Perl version 5" has persisted. See also Osborne Computer Corporation.
&gt; Modern Perl came out a little too late - it should have been done five years earlier It would have predated Perl Best Practices, PPI, and Moose then. That's a tough sell.
I noticed you do not have saltstack in the list. I personally like saltstack a lot. Randall Schwartz had Thomas (creator of saltstack) on FLOSS weekly a while back and I really enjoyed the segment. Personally I dislike the tools you mentioned but seem to really enjoy working with salt and salt api. 
I've never thought of Perl 6 as a successor to Perl 5. We could call Ruby "Perl 7" and be done with it ;-). As for flaws (warts): to me they are a part of the language. Some I could certainly do without, removing others would make Perl less Perl, to me.
I've been programming in quite some languages over the past 20+ years but somehow Perl stuck with me, and I use it the most. I have plans to learn Haskell (better), because I think it gives me the same kind of pleasure as Perl. I sometimes think that choice of programming language has a lot more to do with taste than what once can achieve in it. I can't advice on what to do, though. I wouldn't mind to program in C++ if it pays well. And small tools, etc. can still be written in Perl, right?
if you think that Perl is in nearly as many universities as Python, you're crazy. If you really looked, I bet you could find a cobal course too. I wouldn't make a career out of it.. Python is the requirement in many universities now .. not just an elective. 
you bet. Nevertheless a Modern Perl book should have been written regarding the best practices of the time. There have been updates and the author is doing a great job of keeping it current going forward, but it should have been done sooner 
One of the interesting things I have noticed is that Perl is a language where beginners and experts can code on entirely different levels. There are a few languages I also like very much (Rebol and Red for starters) but they are less developed than Perl 6 at present..... Perl is one of those languages where the more I learn the more powerful it becomes, and where I went from simple scripts twelve years ago to hopefully reasonably expert level today. Perl is an amazing language which can seemlessly move between extremely advanced and extremely basic stuff. The real problem is that there is so much legacy crap written in it that the language suffers from the experiences of many who have maintained crap in it. However, if we keep pluging away.....
because businesses don't want to start a project on Perl v.5 when Perl v.6 has been released in Beta (parrot), yet Perl 6 is not production ready and nobody is using it and its not backwards compatible. Unless you're an active member of the Perl community - you probably feel like Perl is in limbo caught between versions. There isn't much on any of Perl's own websites that outlines this. It's not publicized unless you're an active member of a forum like this. And the same reason that businesses don't want to move foward with perl, neither do potential new developers. Why choose Perl when Python is in the same space and is less confusing? Perl is a victim of it;s own crappy marketing. It's not that anyone is desperate for a new Perl version . but when you make the announcement and don't deliver a completed new product (which is supposed to NOT be backwards compatible) and show no real indication of what the upgrade path is for the current version .. and don't make any real mention of it on any of your sites .. people are going to stop using the product
You are very much correct. And thanks, you reminded me that I tend to lean on Cygwin if I really must use perl on windows. While not perfect, it does tend to facilitate cross compatibility and also gives us back full-blown cpan with some caveats and a little effort. (its been a while since i have needed it, so user experience will vary) Edit: The effort and method to "just get sh*t to work" varies based on what you are trying to achieve and what limitations you may have on your workstation. Cygwin works, ActiveState usually works and in last ditch efforts, a simple CentOS (or linux flavor of choice) VMware image is always an option. (The VM option will not work for this particular problem, but just throwing it out there.)
I think we need a Postmodern Perl book ;-) Though I suppose we already have Higher Order Perl....
Never heard of such a business. You mean the manager decides which version is going to be used? Because an experienced Perl programmer should be aware of the situation IMO. Sounds like a business that can decide on a whim to reimplement everything in "Hot Language of the Day 0.01 alpha". Aside, my experience is more the opposite; quite some of my customers are running old versions of Perl, some even pre-5.10. Anyway, whining about Perl 6 is flogging a dead horse. Not saying Perl 6 is dead, but hasn't it been clear for years that a) Perl 6 is a very different language and b) it's not going to be production ready soon. Regarding the latter, even if the language is production ready it will take quite some time (~ 3-5 years) to have "native" Perl 6 library that can be considered production ready, at least in my opinion. edit: the upgrade path for Perl 5 is ... Perl 5. Think of Perl 5 as OS X and it's clear. So the stable release is "Perl 5" 20 and the next one is "Perl 5" 21 ;-). Maybe we should give them funny names? Perl 5.20 "Critical Camel" and Perl 5.21 "Laughing Llama".
What held you back?
You wrote "It's not being taught at schools", to which I replied "Perl is still taught at schools". And you have to be crazy to read that as "if you think that Perl is in nearly as many universities as Python" ;-) So, yeah, Perl is still being taught (as a required course, as far as I know, even), and new projects are still started (and finished, for that matter) in Perl. And sure, Python is the hot lingo for teaching, and has taken Java's crown. And Java got it from Pascal/C/C++. Nothing new. When at university I didn't get a single class in Perl, yet I became a professional Perl programmer. And it wouldn't suprise me if quite some of those who get Python at the university right now will be programming in a different language at their future job.
I wonder how some of the downstream users would react if they were told _SSLeay is OpenSSL_.
I'm not qualified to write "The Definitive Book" on Perl. I haven't used a lot of the modern application or web frameworks, and I tend to write Perl like a C programmer. Most of the Perl I'm writing is backend UNIX automation tools and reporting. To say it simply - there are far better Perl coders out there then me.
The business decides to a degree what a project is being developed in. If you told your manager that the next project you were going to develop was going to be in RPG3 or Cobal, tell me what happens. The writing is on the wall. [Perl is on a downward trend](http://www.indeed.com/jobtrends?q=Perl%2C+Python&amp;l=). Few managers will want to start new development in a language that is [trending downwards](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html) on [every single matrix](http://langpop.com/) that I could [find](http://blog.codeeval.com/codeevalblog/2014#.U-WqUvGwdHA=). I wish it were different, but [it's not](http://spectrum.ieee.org/static/interactive-the-top-programming-languages). It would be irresponsible to start a project in a language in such decline. Python will be the teaching language at most universities over next few years. Python developers are already starting to graduate in droves and they are having an effect on development already. It shows it in the stats I've showed above. Denying the facts isn't going to change anything. I know the upgrade path from Perl 5.20 is 5.21 - but a lot of people out there don't. It's probably the reason that Java 1.7 is called Java 7 and Java 1.8 is referred to as Java 8. It's a flippin' marketing ploy that apparently works. 
I don't know of any University that has Perl as a required course .. but The point of this thread is that the author is saying that Perl is a good career option, and I'm disagreeing. &gt;And sure, Python is the hot lingo for teaching, and has taken Java's crown. And Java got it from Pascal/C/C++. when's the last time you've seen pascal? C/C++ is still in use because it fills a different space than Java does. Perl does not fill a different space than Python. As students begin to graduate, they will be comfortable with Python and it will be deployed instead of Perl. So - if you want to keep believing that Perl is a great career option, that's fine. I'm not trying to change the world and hey, I'd love to be wrong on this. I just don't think I am. I actually hope that you;re right. I love Perl too.
When you say Perl is being taught at schools, in what context is it being taught? I've seen it presented as a general scripting language in an IT degree and also as the core language of a bioinformatics degree.
So my prediction is that the reign of Python may be pretty short. For better or for worse, a ton of money has gone into optimizing Javascript compilers, to the point where V8 is within an order of magnitude of the performance of C++ and within shouting distance of Java, so unless something really serious happens on the Python optimization front, I don't see any room for major progress by Python (or Perl, for that matter). And, when Ecmascript 6 (Harmony) really does happen apparently sometime next year, things could move pretty quickly. 
Javascript works for the web. I've never seen it used for anything else. and HTML5 is moving in on it fast. Python is becoming the MAIN teaching language at colleges. There is a generation of developers coming out of school knowing how to code in python. It's reign will not be short lived. Just like any other technology that infiltrated college campuses (java, apple, UNIX) - it won't go away soon. For speed - It's listed as one of the [JVMLanguages](http://en.wikipedia.org/wiki/List_of_JVM_languages). and, like Perl it is an all around good language. The problem I see a lot of people here having, is that they are sentimental about languages they know already. It's part of being a technologist - you have to keep learning new things to stay current
It is never a "bad career option" to learn a language, even Pascal, Fortran, LISP, Smalltalk...
&gt; I think it's plausible that Moritz censors the log Well of course, wouldn't it suck if there were something, anything, that showed perl-6 in a negative light somewhere on the internet? The apostates must be purged!
&gt; Note: "Perl 6" is the language (spec), "perl-6" is an implementation, like with Perl/perl 5. Perl is Perl 5. I don't know what perl-6 is. Back 14 years ago I thought I knew, but the longer ago that gets, the less coherent the messaging gets. Right now I think it's some kind of public performance art to make Duke Nuke Em Forever look like reasonable project management.
ok - bad choice of words. Lets call it a less useful option
If I think language X suits the requirements best, I will recommend that. If my customer (I work freelance) decides that I am wrong because the language is not hip enough or similar nonsense I will wish him/her good luck. Sure, Perl is on a downward trend. But I think (but might be wrong) that a majority of programmers who jumped ship where not that good as a Perl programmer. And a large part of the people who are left are good at Perl (at least, that's what I think ;-) ) Moreover, stop putting words in my mouth. I am not denying any facts. Python is hot. A decade ago it was Java. And now look: http://www.indeed.com/jobtrends?q=Java%2CPython OMG! Java is dying!!!!!
I don't think I am qualified either, and there are sure better Perl programmers than me. But still, "The Definitive Book" could be crowd sourced. You can maybe make an outline of each chapter, and write down what you would like to see in each chapter, and ask people to contribute. I would have no problem to do so. I've done some minor reviewing of a chapter of Modern Perl, and am very happy with being listed in the credits. I think Perl needs 3 additional books, besides Modern Perl: Modern OOP, Modern Testing, and Modern Web Apps. If I recall correctly, Toby Inkster has plans for the first one. And no, I don't think it's too late for such books because "Perl is dying". I think I will use Perl in various projects, including new ones, for at least 10 years more.
You might want to read up on Node.js, e.g. https://github.com/joyent/node/wiki/Projects,-Applications,-and-Companies-Using-Node And compare it with Rails: http://www.indeed.com/jobtrends?q=Node.js%2CRails
You don't give enought details to receive useful help except to say: * Perl is old. * Mailing lists are empty - try [perlmonks instead](http://perlmonks.org/) * OTRS is hard to code with, which seems like an OTRS problem rather than a perl problem. If you have specific problems, or questions, then I'm sure you'll find help. But complaining that perl is old/bad/hard is not likely to engender any perl-community to you..
It sounds like you're simply not familiar with Perl. The fact that you capitalise it as "PERL" instead of the [proper spelling](http://www.perl.org/about/style-guide.html) indicates that you know even less, and probably learned what you do know from very crappy tutorials. While it may be confusing or even "write-only" as some might say, Perl has saved myself and many others countless hours of time. Sure, we could have made our one-liner "properly" in Python(or whatever hip new language is popular this week) with classes and whatever. Unfortunately, it is true that many applications written in Perl are poorly done. This may be due to how forgiving or TIMTOWTDI it is. Still, it is foolish to discard a language because of one of its uses. Let's say you were learning French: would you call it crazy because you failed to understand slang right away? Surely not? Perl -- and every language for that mater -- has shortcuts. You might be lost because they are unfamiliar to you. &gt; the mailing lists of PERL has practicly had no activity since 2012 False. There are plenty of lists that still get activity. [beginners](http://lists.perl.org/list/beginners.html) for example is still very popular. Also try [PerlMonks](http://perlmonks.org/)(linked from sidebar), which is probably more active than the mailing lists. As long as you are able to post a [coherent question](http://perlmonks.org/?node_id=174051), you'll get a response from someone. &gt; Further debugging ... seems non existent RTFM. See [perldebug](http://perldoc.perl.org/perldebug.html) and [perldebtut](http://perldoc.perl.org/perldebtut.html). Also try PerlMonks' [Basic Debugging Checklist](http://perlmonks.org/?node=basic+debugging+checklist). &gt; a proper IDE seems non existent. Almost everyone uses their favourite text editor and the command line. That said, ActiveState has an IDE, which I hear is pretty good. There is also [Padre](http://padre.perlide.org/), which I haven't used in a long time. &gt; We were to implement a small SMS gateway ... some 20 hours in PERL[sic] Chances are you could have done it in the same way as you had in the other two languages. We'll never know if you don't post your code... &gt; Now we've been battleing with a simply data type in perl where we cannot access the data in it This is precisely where the debugger comes in handy!
SE and CS are not equivalent. In CS, you should learn AI concepts (fuzzy logic, neural nets, classification/clustering, planning, concepts of knowledge about knowledge), topics in compiler design (code generation (done as late as possible), lexers, etc), functional language concepts (currying, combinators, closures, coroutines, etc), type theory (type inference, propositional logic, etc) and a whole big list of other things. SE is applied. CS is theoretical. SE, you need to know how to use systems other people built. CS, you need to understand the ideas behind all of the existing system, including cutting edge ones. If you took Prepositional Logic, you would immediately see the fallacy in "we have to fix things in our version of OTRS, and it takes FOREVER". I'm not writing this to defend Perl. I have a love/hate relationship with Perl. However, when discussing it, I insist on intelligent discussions, and this one needs a boost. To that end, you will learn more CS in this one link than you will in a SE program: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ To answer your general question, "What is the best way to get into this god-forsaken language?", the best way to get in to Perl is to be a Unix old timer. Perl is a massive cacophony of sed, awk, C, and bash -- all old Unix things. They're all extremely powerful things in their own very particular domain, and the mix is amazing. Then it mixes in stuff from Lisp (more CS stuff) and other things. You can easily compose from functions a recursive grammar where each piece of regex closed over in a function resumes where the last left off and the closures back track. It might look something like this: http://perldesignpatterns.com?self. ... but if you aren't a Unix old timer, the very concepts of sed, awk, bash, etc are going to be completely alien to you. They're going to frustrate and annoy you. You'd be happier, in the short term at least, if they weren't there. The second best way is to pick up some good books. _Perl for System Administration_ is a great short book that doesn't get too advanced and shows a lot of Perl's features in a good light. For a more comprehensive tour of the features without delving into maddening things they can do, Larry Wall's _Programming Perl_ is top notch. For functional stuff, _Higher Order Perl_ (which would be redundant with the Wizard Book if you took CS). For a gentle introduction, chromatic's _Modern Perl_. Since you're throwing around "CS", I'mma give you some unsolicited advice: study all of the old Bell Labs languages: SNOBOL, R (previously S), awk, C, ... and other things from that era: Forth, Lisp, Self. Generally speaking, they're very domain specific languages (good for one very specific type of problem), but in that space, they're amazing, and the ideas will stretch your brain. I've written longer essays in the past of the amazing ways amazing features in Perl combine. If you're really interested, I could try to dig that up, but as one wise man said, every minute spent debating programming languages is a minute that could have been spent actually learning them. 
Thanks for the reply. I'll try and look at the debugger. A bit surprised my entire education has been negligated by not really paying attention to when to use Perl and perl and never PERL - That's the entire language I guess. I guess I should rant more about people writing c#/c++ instead of C#/CPP or whatever. I was not terribly impressed by Padre, and ended up using sublime. It's just far from what one is used to in Visual Studio which I still (amongst all the programs I've tried) reckon to be the best IDE. The reason I have not actually posted any code snippets, is because it has been a multitude of things. I reckon my self a rather decent programmer and when I face a problem I usually go to the documentation or stack/the interwebz. My main issue with perl has been exactly that it seems to just be a new odd thing which is causing problems every single time. Which is why I think it's probably a more general "get into perl" or "otrs" kind a thing rather than a specific code problem. For example I ran into loads of issues with the packages I was trying to use being vastly outdated and not complient with newer perl versions, or some of the dependency packages being that. The reason I call Perl crazy is because it has sacrifised a fair amount of readability for flexibility (loads of specific keywords, like qw(), why not let it take parameters?) which is why it is further away from what I've usually read. I would even go as far as saying I find Perl harder to read (in the OTRS context at least, small programs aren't really a big deal, but then again, that hardly ever represents the language per se) than when I had to get my head around functional programming. 
I would rather hire the guy who can write readable, maintainable code than the guy who looks up "How to write your new language abbreviation/name correct" as the first thing on their list.
At the Danish Universities they do not differ before the Masters Degree. I've had everything you've mentioned on my SE Bachelor, which is why I can swap readily to a CS Masters Degree. The kind of SE you describe is more like the study called "Datamatiker" which is not at the University in Denmark. The main difference between SE and CS in Denmark resides in the latter parts on the masters degree and which specializations you can go into (where SE is more practical oriented at making actual software and CS is more theoretical). I am very much a believer of the "right tool for the job" - but as you say, Perl seems very influenced by the ideas from the 80s-90s. All programming languages has been made because some thought it could be done better according to their beliefs (and language design theory). I've been looking at Lisp but have not really put a lot effort in it because I have not needed it yet. Most of what I have done has been C, C#, C++, Java and the odd bits here and there of ASM and what not (not counting in web technologies). My biggest issue with this perl odeal, has been that I've been thrown into a new perl language which has a gazillion use-case specific keywords, prefixes and functions. On top of that it's on OTRS which is a rather complex system and on top of that it has been modified by previous employees who no longer work at my place, so no one really knows anything beside the fact that it needs fixing. Of all of those I know (from university and my network) it is a very very very few select people who has even worked in perl. I will look at some of the books you suggested, thanks.
If you had used those 20 hours to read a book on Perl, like "Learning Perl" you would've had no problem to make it work in 5 minutes in Perl as well. This has always been Perl's main problem, in my opinion. People starting to program in it because "It's a programming language! I know this!", only to get utterly confused and often ending up writing the kind of code that gave Perl it's for a large part (again IMO) reputation of being unreadable. Cargo cult coding at its best. Perl comes with documentation, very good at that. Use perldoc perldoc (at the command line) to get started. As for qw(): what parameters do you want it to take? Maybe you're looking for split? (See perldoc -f split).
&gt; like qw(), why not let it take parameters? [`qw`](http://perldoc.perl.org/functions/qw.html) is a function that is designed to facilitate the quick creation of arrays. Thus, it takes parameters: the desired array contents. I've always thought of `qw` as short for "Quick Words"(not what it actually stands for AFAIK), as it allows one to quickly do arrays without having to type the quotes and commas around each word. 
Apologies for the generalizations. I'm from the US. Still, you say you've had everything I've mentioned, but then you say haven't really dived into Lisp. Where I took CS, at the University of Minnesota, Scheme, a Lisp dialect, and functional programming concepts in that language, is a 1xxx level requirement: http://www.cs.umn.edu/academics/undergraduate/class_desc/csci1901.php So if you studied functional programming and not in a Lisp dialect, what language did you study it in? Java, C, C#, C++, and assembly don't meet the criteria. None of those languages curry, have coroutines, treat the program code itself as structured data, etc. "have not needed it yet"... well, you won't know when you need the tool unless you understand the tool. Sorry to be so antagonistic. &gt; My biggest issue with this perl odeal, has been that I've been thrown into a new perl language which has a gazillion use-case specific keywords, prefixes and functions. Absolutely. In this way, Perl is not especially friendly to learn. In Java, almost everything you want to do is an API method. Figuring out how to do something involves locating the correct class. In PHP, everything is a function, and figuring out how to something involved finding the right function. In Perl, what you want to do could be a function (perldoc perlfunc), operator (perldoc perlop), standard class library method (perldoc perlmodlib), a CPAN module (metacpan.org), or, very, very likely, an idiom using both operators and built-in functions (perldoc perlfaq documents a whole bunch of the most common cases). You kind of have to read through each of those to get a feel for where things are. But once you do get a feel for it, it really is very nice how things combine. Perl has many flaws but this part is well done and can be quite fun =) And by the way, you can play with some of the ideas from Lisp, though not the whole "the program is just a datastructure you can read and modify" thing, at least not in the elegant way Lisp does it. You have lexical closures. And it integrates well with objects. See http://search.cpan.org/~sartak/autobox-Closure-Attributes-0.04/lib/autobox/Closure/Attributes.pm for an example. Where it does: my $from_3 = accgen(3); ... you can make multiple different variables (eg, $from_4 = accgen(4)), and each one will attach to ("close over") a different instance of "my $n". Any number of distinct copies of $n will exist concurrently even though most languages would consider the variable to have gone out of scope. So, anyway, it sounds like the project itself is a pain in the ass, and I definitely sympathize with Perl being annoying to learn, but I hope you manage to have some fun with this project anyway. Or at least find it a good educational experience.
This example of using awk just appeared in another subreddit: http://c2.com/doc/expense/ (Perl takes a lot from awk, and awk is designed to spit out quick little parsers.)
&gt; I think (but might be wrong) that a majority of programmers who jumped ship where not that good as a Perl programmer. Oh, I see where we disagree now. You believe that Perl has fewer available jobs because Perl programmers have chosen to use other languages. I believe that there are fewer Perl jobs because businesses have chosen to use other languages.
We don't disagree, I think. It's an interaction between the two. Programmers dump Perl, businesses follow. And also businesses jump on the next band wagon, and force their programmers to dump Perl. Or businesses can't find suitable Perl programmers, because they switched. Vice versa, rinse and repeat. And you might be right it started as a business decision, I don't know. I've seen both forces in action: programmers who convice a company to switch to "the next best thing since sliced bread" and companies who tell programmers to "program in X, don't know what it is, but everybody is using it". I have been asked on a few occasions to write something in Ruby because it's very similar to Perl. I declined, because I am a Perl programmer, and not interested (at the moment) to learn Ruby. But I can certainly see others, (maybe a majority) accepting such offers. In my experience, a lot of people who started to program Perl in the 90's took Perl on the side, and switched to something else later on. Or: jumping the ship might have been a bit harse, my apologies for that . Well, actually it's the correct term, the ship *is* sinking, but I certainly don't blame them for dropping Perl one way or another. I am in the lucky position that I still can find work as a freelance Perl programmer. The past 12 months have been excellent.
No idea if it still works, but I remember the Sybase DBD worked some time back for connecting to MSSQL Server.
yes. If your intention is to make a living with them. If it's just for learning stuff, than no.
Java isn't dying, It makes sense to build a project in a language that will have longer term support. As I said, the market will be flooded with a generation of programmers that are comfortable supporting Python. Since Perl and Python have a lot of the same functionality, I can't find a compelling reason to choose the one with a lesser life expetancy. 
I love it. Lets do Modern Web Apps first. I'm in if you are.
In college I had people telling me I was crazy spending so much time writing Perl and that there were no Perl jobs out there. I just did what I liked and hoped it worked out... and it did. I just got my first real programming job, writing Perl. It's web development so I write a fair amount of Javascript as well. During the interview I got asked, "*So why is a 23 year old writing Perl... do they even teach Perl in college?*" The answer was no, they don't teach it in college. I asked him why they are doing web development in Perl in 2014... "*Because it was the 90s*" was the answer I got :)
In general I don't mind problems at all, that's why we are engineers / software developers. We live to solve problems. However, when it takes forever and the systems I work with generally are designed as poop (might just be the 'real' world and not the university, although I've worked with a rather successfull startup who managed to write good code) it gets frustrating. In terms of Perl as a language, my oppinion so far is that Python seems to be the updated better version. That is just what I've seen on the surface though, as you say, perl might have some awesome domain specific usecases where it is exactly the right tool for the job (which is generally how I like to code things. Don't get stuck on a language, but figure out which language solves what you need to be in the most efficient manner). That being said, I looked at some more of the debugging, however, how does one use -d on a large tenth of thousands line codebase where all (or at least a huge part) of the files are interconnected (in an not so apparent way). Can I hook the debugger up to a specific point? I've been using Data::Dumper so far, but with changing success. Edit: Oh and to answer your functional programming - I've touched the paradigme in compiler theory / language design theory, however, it has not been a fully fledged used paradigme on a semester for a project (My university is a little bit atypical with a huge emphasize on project oriented group work with real problems. So you have 4 5 ECTS coursed in 4 months, and on top of that you have a 20 ECTS project so you roughly work 8-16 every day at university). I have touched LISP on my own accord and rotated into F#. 
i don't want to use javascript. the reason perl is dead is pr. there's no new big projects, there's no one making noise and so on. look at /r/programming, i see loads of stuff on other languages, nothing on perl, because that all goes to /r/perl . what we need is perl wordpress, perl magento perl forums etc. and it needs to be easy to use, and better than what it's trying to compete with. that's why perl's dying, because there's never any noise outside the echo chamber
But the Perl marketing initiative has been going for five years now. Why is it having no effect? Things like the Perl Iron Man mean that Google's results for Perl are better than they have been for years. People have been speaking at non-Perl events (in particular, the stuff that Liz and Wendy have done at FOSDEM is great). Why is no-one listening?
I have not used Salt, but I did look at it. It is still YAML, although much cleaner than Ansible I have to admit. But overall, it is still just as confusing and not a native language.
IMO programming languages go through a natural course, not that dissimalar of a human live. They become teenager, they might become popular, they mature, and then they die. Perl isn't dead yet, and if my personal experience counts for anything, I will program Perl for at least 10 years more. But it's on a irreversable decline. I am not saying that we all should buy clothes for mourning and have a funeral, but let's be realistic. Perl is at a ripe age for a programming language, let's enjoy the years it will be with us instead of weekly sounding the alarm "Perl is going to die! Abandon ship! Nobody uses it anymore". If you're working professionally with Perl, you have seen the signs by now.
&gt; but now seem to be in such a need to toll the death knell, weekly. I found the article interesting and worth posting. (Goodness knows there aren't many articles posted here.) Don't read into it more than that.
Maybe you don't need a job, but most of the people I know do.
Sure I do. But I do need an actual job, not one rooted in wishful thinking. We both agree that Perl is on a irreversable decline. And I don't think it can be fixed by tweaking popularity rankings.
Agreed, hence why I deleted my original comment.
I can't imagine this message will be popular here, but I also see a lot of very lamentable denial about the undeniable fact that Perl has fallen from near-top language for implementors to something like the 10th choice, and seems destined to fall further. The problem, as far as I see it, is that Perl fails to be as fast, useful, and as convenient as its competition. This is not a marketing or perception problem. It fails on objective metrics because the other languages caught up with it, then kept on improving, and went far ahead while Perl has barely changed in the last 10 years. Sure, I know there's been a little bit of progress here and there, but to me it looks like mostly the same language now as it was 10 years ago. It still has slow performance, big memory footprint, no working threading (I heard that support got removed altogether recently), same weird I/O layer which I never quite understand, and many old and ancient warts at syntactic and usage levels. The biggest improvement I heard about was that you now finally have function arguments that don't need to be collected from @_. Awesome! If I can write a function declaration in 1 line instead of 2, then that's just the sort of improvement I would like to see in Perl. But I won't get to use that for many years because at work we just got standardised on 5.18.1 and there won't be another upgrade -- perhaps ever. To save what can be saved, I'd advocate breaking backwards compatibility in gradual ways, and start fixing Perl's ancient warts. Just announce a vote for 5 most hated features to be deprecated for next Perl release and kill them one year later. I'd kill the ' as package separator right away, so that "$name's something" could be written and not mean that Perl tries to look up $name::s. I love Perl's warnings, but hate that they mostly go to some log file that nobody reads, so I'd turn warnings on by default and would make most of them fatal runtime errors. I hate the I/O layer and its myriad classes (FileHandle! IO::Handle!) and alternative syntaxes for mostly the same thing (TYPEGLOB! No, wait, you want $fh!). And why do we still prefer 2-arg open in &lt;&gt;? Who on Earth wants 'while (&lt;&gt;)' to potentially fork shell because user supplied an argument with '|' at start or end of its name? I hate a whole bunch of the syntactic issues like the "this that other more stuff" potentially parsing to some sequence of package method invocations. Jesus, those don't even look like packages nor methods, just fucking crash shit like that at parsing stage. In fact, Perl's loose syntax wastes a lot of time for me. Just miss out on a single ) or } and get like 50 lines of parsing errors because Perl just doesn't know when to quit but keeps on whining irrelevancies. And I hate the weird shoot-yourself-in-the-foot variables like $[ which nobody can ever change without breaking everything, or mucking with $/ to get some means to read whole file into memory at once. And then there's the graveyard of CPAN full of what amounts to abandonware. Maybe if some small syntactic changes were implemented in Perl that break compilation of those packages, and nobody cared that these packages broke, maybe they could be removed after a few years. Then we'd see just how much of that stuff is still in active development and important. I bet 90 % of packages would just go away. Chances are that my medicine is worse than the disease. Perhaps Perl can't be saved. But not doing anything is IMHO not an option. This language is just way behind competition in many respects. It must evolve or die.
Good advice.
I hadn't looked at Perl since late '90s when I was first learning how to program, but I found the Modern Perl book, started reading through it, and have had a great deal of fun in the past 2 weeks rolling my own little markdown-&gt;HTML build tool and a data munging text-&gt;Excel script. I've had so much fun with picking up Perl again. Nothing else gets out of my way and helps me in actually doing what I want to do. Even my installation of Perl, abused as it is inside a Cygwin installation, has worked wonderfully. I've also recently used Python and node.js for little side-projects, and I always felt that they were fighting me (especially node vis-a-vis control flow), even if I was able to get things done with them as well. Perl is a lot of fun and I will deeply regret if it becomes impractical to use it. I honestly don't know how to help, though - start my own blog and blog about Perl? I'm not skilled enough to implement new language features for Perl 5 or 6.
Should it be sub _build_config instead? Edit: No it shouldn't
True, it can't be fixed but the popularity can be a good influence on people and their perception, and I'll take that over no influence at all.
I've just tested this and it works for me. However, since it is lazy it will of course only be run in the event that you actually use $object-&gt;_config somewhere
I've no real Moose experience but the I found the following from http://metacpan.org/pod/Moose::Meta::Attribute lazy_build =&gt; $bool **Note that use of this feature is strongly discouraged. Some documentation used to encourage use of this feature as a best practice, but we have changed our minds.** The examples at http://metacpan.org/pod/Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild all seem to use `lazy =&gt; 1` and define builder manually like you said you've done. Hopefully someone with more knowledge can tell you the reasons why. 
Your builder will *only* be called if you try to use the `_config` attribute before setting it. It is _not_ called at object construction (hence the lazy part). If you supply a `_config` in the constructor, the builder will _never_ be called. If you'd like to force the builder to be called, either remove the `lazy_build` and specify a `builder` name yourself (which will behave almost the say as a `default` does), or do something like: sub BUILD { my $self = shift; $self-&gt;_config; } ..this defeating the purpose of "lazy".
As @pwr22 pointed out. Lazy build implies that the builder method is only called when the attribute is accessed, hence the name "lazy". When you are specifying just "builder" method, that implies that the attribute value is built right away when the object is instantiated. Lazy builders are useful when you might not need some attribute value during the run, or might only need it later on. This speeds up the start up time.
10 years ago was 2004, we were already on 5.8.5 by then. The number you're looking for when ' as a package separator became deprecated is people with &gt; 20 year old codebases. The Perl5 committers *are* doing what you say, but in a more measured and careful way. For example a couple years ago they deprecated `for qw(...) { ... }` infavor of `for (qw(...)) { ... }` because the former made the lexer and parser much more complicated (if I remember correctly it had to inject invisible parens properly). I've recently had to fix some code to deal with this fact because it was causing test failures for downstream modules on more recent perls. On the other hand eliminating ' as a package separator could be done but why? It won't improve performance, it won't substantially eliminate complexity in the lexer or parser. What's the solid benefit? The ability to use `"$foo's bar"` rather than `'${foo}'s bar"` in interpolated strings? Is that worth breaking existing code on CPAN? (Test::More::isn't() is the most useful example I can think of offhand). If you feel that strongly that it is, supply the patch and argue for it. There have been "a whole bunch of small fixes meant to improve performance, reduce memory consumption, and fix ancient warts." There just hasn't been the ones you want. Which I think is really what your complaint is. They haven't been radical enough with the changes they've made for your satisfaction.
Today I asked Moritz if he ever removed lines. He replied: "I sometimes remove spam or if somebody accidentally pastes a private email, and asks me to remove it." I then pointed him at this exchange and pressed him on this issue. His answer was "no, I didn't remove any ranting from the logs". After the exchange I found the line I was talking about: "[NO THE POINT IS THAT THERE IS NO FUCKING WAY TO FINISH PERL 6 WITHOUT LEAVING PARROT BEHIND.](http://irclog.perlgeek.de/perl6/2013-02-07#i_6423589)" I have no interest in posting about this again, except to link folk to this exchange, so feel free to wrap up as you see fit.
this puts it more in context: http://www.indeed.com/jobtrends?q=Java%2C+Perl%2C+Python%2C+ruby%2C+C%2B%2B&amp;l= 
&gt; I don't think you can break backwards compatibility within a major version number To whom are you beholden?
On top of that, it seems to me that since the testing, ratings, etc. is all public, you get to tie your own reputation as a coder to how well you do. I always link to my CPAN author's matrix on CPANTesters in my resume for example.
I no longer consider myself Perl developer, though I have one client that hires me to do Perl stuff. I'm mostly looking at it from the outside, hoping that some of the unnecessary complexity would go away, like the surprising ' as package separator. I've been dealing with the fallout of the for (qw()) change myself as well. I don't care, though, a simple grep found all the instances with only a few false positives.
Probably worth pointing out that all users need the appropriate perlbrew script sourced in too Edit: Also that scripts with a shebang of #!/usr/bin/perl for instance will not use the perlbrew perl even if set up properly
I don't understand... I want to have perl script #1 use the system perl, and perl script #2 use Perlbrew's 5.20. I'd prefer to hardcode which script uses what via the shebang line.
So, wasn't that post written by the same guy who stalked, hounded and harassed a woman online who had published a Perl book that he was scared would compete with his own? Perl's community was great, then it was meh, then it was poison. No matter how much better it is now, the damage is done.
It is pretty simple to build Perl 5.20. You would install it in /usr/local (/usr/local/perl-5.20.0) or /opt (/opt/perl-5.20.0). You might look into using perl-build (Perl::Build) to make it easier, which is what plenv uses. perlbrew is meant for installing multiple perls for a user and switching between them and you don't need the multiple perls or switching environment.
I would guess that the author has decided they don't need the module anymore and don't want to support issues. It looks like their might be quite a few problems with it: https://rt.cpan.org/Public/Dist/Display.html?Name=Graph However, it looks like despite the note they have released a Graph 0.96. And a dev release was done on Mar 09 2014. It also looks like their are two listed maintainers, but only JHI has written code. NEILB makes use of it in Graph-ReadWrite so he might be interested in maintaining it, or at least keeping it out of module-death. You could contact https://metacpan.org/author/JHI to see if you can become a maintainer. Even if you only wish to update the documentation, you could take on parts of it. I don't see a listed public repository so it might not be easy to share patches except through the RT issues system, which is kind of awful.
My Perl career is flourishing, and i am able to do more than ever before and faster with Modern Perl techniques and projects like Moose and Mojolicious. Those projects in particular are at the bleeding edge of technology, and way ahead of node and python in my opinion. They aren't the only ones either. Perl turned the static web into the interactive web, and now it is evolving it yet again. 
Python 3 simply suffers from the slow pace with which popular packages are being ported over. And although it's been slow, there is an increase in momentum: https://python3wos.appspot.com/ Perl 6, on the other hand, isn't something one would use in production at all. Not comparable, really. The Perl 5/6 situation is much worse. 
I think this is a very valid comparison, and part of the reason Perl 6 isn't out yet. Honestly, I hope it never comes out. With the way Perl 5 is shaping up with it's recent releases it's better than ever.
Over the years I've come to determine that Perl **really** shines at system administration tasks. It's has amazing utilities to munge text, deal with ARGV, and manipulate strings. I use Perl for all my CLI based tools. Like: https://github.com/scottchiefbaker/perl-git-prompt
Yes, I think it's fairly similar. I heard about a guy at a recent Python conference who went around wearing a T-shirt that just said "2.8".
First, Python 3 is an actual stable product that can be (and is) used in production. Second, the whole debate of Py2/Py3 is about practicality: some people feel that we ought to use Py3 going forward, while others say that Py2 is "good enough" and "don't force me to port". Py2 is ubiquitous and has just recently received another 5 years of life from its BDFL. Third, porting Py2 projects over to Py3 is rather simple. In Perl's case, it's rather different because perl 5 and perl 6 are not "both viable alternatives" in the sense that python 2 and python 3 are. There is also a similar split about ruby versions but I'm not versed in it.
Python 3 is usually provided by distros as a replacement for Python 2.x, which is extremely painful. You have to use virtualenv everywhere (and in some cases I couldn't get it work at all, like with Mozilla's Add-on SDK tools) and every script you download or copy and paste is liable to break because of the subtle differences between the two versions. On the other hand, while Perl 6 is not widely available, it is at least not purporting to be backwards compatible with Perl 5.
They are aiming for that, actually: every perl6 interpreter should be able to understand perl5 and assume it is perl5 unless told otherwise. 
Sounds pretty similar to what many perl 5 folks say about perl 6. New major revision breaking backward compatibility isn't "mature enough", "fast enough", or "missing libraries for X, Y, and Z". With Perl 5, it has become increasing clear that backward compatibility, the complexity of the legacy codebase, and inconsistencies in the language are becoming an increasing large burden on forward progress and long term viability. Over the last 20 years, several prominent lead developers have made unsuccessful attempts to refactor, rewrite, and address these issues in Perl 5. So when a Guido or Larry decides it is time to break backward compatibility and do a major rewrite... I'm inclined to bear with the labor pains and help the new baby mature. The Perl 6 folks have the first 90% done; with the emphasis on correct and clean. Now the emphasis is on making it fast and porting the highest priority libraries. So it sounds like Python 3 and Perl 6 are in similar straights. Both are production ready now for very narrowly defined definitions of "production". However, unless the major revisions attract enough mindshare to port or otherwise allow access to gazillions of old libraries... The last 10% will likely get done and production ready around the same time as the heat death of the universe...
I don't think there are many areas where a scripting language is objectively *better* than the other. Ruby and Python are more popular today and enjoy broader API support etc. Perl is generally faster than Ruby and Python and probably has better legacy library support (Gopher anyone?). I also think metacpan is better than RubyGems, PyPy or NPM. For the big stuff, like APIs to major applications, web frameworks, OO, testing, ORM etc, Perl has just as much to offer, perhaps with the exception of scientific computing, where Python is really leading right now (we have PDL which is a powerful but less capable library). Personally, I like the power of being able to solve almost any problem with Perl. I love the flexibility from writing a one liner to a script, through to developing an entire application. I love metacpan. Perl maps well to my mental model / problem solving process. I actually *love* programming in Perl. I expect many script developers feel the same way about their language of choice. 
Perl 5 and Perl 6 are different animals. Many of the features of Perl 6 have actually been backported to Perl 5 with great success. So even as Perl 6 has broken new ground, it has continued to help Perl 5 advance - and that has accelerated development of Perl 5. This is very different from Python, where most of the focus is on porting Python 2 libraries to Python 3. Many will simply not end up moving, and new libraries will arise to take their place. This may also happen with Perl 6, so there lies a similarity.
You can do a lot with bash yes, but every time I try and use bash I'm always frustrated with the syntax and end up going back to Perl. Plus bash doesn't support floating point math.
Perhaps not natively in bash, but `val=$(echo $expression | bc -ql)` is pretty easy, if you need to do floating point math in a shell script. edit: The best way to not be frustrated by syntax is to use it more frequently.
The thing with existing libraries is that developers are willing to jump into vastly different languages all the time. Consider where C# was around 2001 compared to Java. Python, Ruby, and PHP were all young upstarts at one point, too. You can see some of this going on right now with Go, Dart, and Swift. So what is it that makes developers willing to jump into a whole new shiny, but not a backwards-incompatible take on an existing language?
I think you replied to the wrong message.
Hi, disclaimer: author of rex i think in one of the next versions there will be a communication type that acts like you described it. (except of the 2nd point with the own communication port, but it could be extended to communicate over zeromq) There is already code for a first draft written and about 90% of the tests are successfull. If you have ideas how to extend rex to better fitt your needs, feel free to join irc.freenode.net #rex 
Isn't that the old plan from c. 2000? The two are going almost completely separate ways now.
Could you provide a source on this?
my feedback consists of post it to hackernews and r/programming, the more perl projects people hear about the better. other than that i have firefox sync, so i don't really have a need for this service.
Thanks - good places to post it &amp; will do so. It's not directly comparable to services like Firefox Sync - I'm terrible at organising my bookmarks, so find full text search a much more useful way of finding content, especially as the bookmarks swell to the thousands. Also I star a lot of projects in Github, +1 stuff, and tweet links I find useful - this collects all of those links for me and puts it in one place. The automated hooks are a key reason why I now use this as my way of bookmarking stuff; there's also a basic API for automating addition of bookmarks from other places.
NEILB is (very slowly at the moment) working on a new release of Graph. Definitely open to patches, suggestions, pull requests, etc.
I can't think of a better way to do this myself, only a few far worse ways, so I'm interested to see what people recommend &gt; I have to set up a 'handles' section to map real Net::LDAP::Entry methods on to this object Since these objects are presumably meant to be a specialisation of Net::LDAP::Entry, would you not make them a subclass of it as you've done with Net::LDAP. No need for a handles then?
Hi!
Well, "Right tool for the job" is a nice saying but sometimes life is more complex. Often any number of tools can be the right choice in your context. For me I tend to reach for Perl since I know it well and am involved in our community. I think that Perl has a good balance between features and immediate usefulness that makes it a good choice for a lot of tasks. It a language that gets out of the programmers way and doesn't force an opinion. I personally use it for web application development, but when I need to do systems stuff I tend to use chef or anisble.
I think that's the crux of my question really. I can get ordinary Net::LDAP::Entry objects back, but if I want those objects to be my own type then I have to get the data of the returned Entry type into my own type in some way. I'm sure I'm just being blind but I'm not seeing a clean way to do that by subclassing. 
A million upvotes for this. I have also considered trying to extend Net::LDAP, and I just couldn't see a clean way to do it that didn't involve wrapping a bunch of stuff. Now that I think about it, though, you could monkey-patch it. Before you cry foul, I'm pretty sure I've seen some clever examples of using caller() to make sure that only *your* code sees the patches, and anything else calling patched functions get the original version, which is much cleaner than indiscriminate patching.
I did, sorry for that.
It is still necessary to put *use v6;*, otherwise it will be treated as v5. The interpreter has to at least exec the perl 5 interpreter.
And they can even receive a gag order, and people even won't be able to challenge the subpoena. They have got to the extreme of asking the Internet Archive what someone was reading online, and put a gag order on them.
Actually,now that I think of it, the example in my original post isn't any good. One of the major reasons I wanted to do this in the first place is because recently I've had to use AD a lot. By default that only gives me the first 1000 entries back. What I do instead is use paged searches and get a couple of hundred entries at a time. Then it just goes round in a loop getting page after page until there are no more. The problem is that the way to do paged searches is to pass a code ref to do the work on each entry as they are found. At that point the Net::LDAP::Entry object is passed in to the function directly as a Net::LDAP::Entry object. I will certainly be using the entries method, but this way will be just as common. I suppose ideally what I need then is a means to force any creation of a Net::LDAP::Entry object into an object of MyType, no matter the context in which it is created. Am I asking too much of Moose? 
Hmm, the only way I can think of is to have the constructor take the superclass and build a subclass from it. That's basically no better than your delegation method, except preserving the inheritance hierarchy. Maybe it would be better to actually use delegation to do this? I've never subbed a non moose module so I'm just thinking out loud. Sorry if it isn't very useful :(
Warning: webdev analogy ahead Perl 6 is turning out much like the HTML 5 transition. A lot of quietly working on specs for the past decade, followed by implementations gradually appearing over the last few years. Now, maybe you can't run your ActiveX controls from 1997 in a HTML5 browser, but there's all these much cleaner APIs in one place now, and those tables-for-layout websites you made in Dreamweaver 15 years ago that didn't abuse a gazillion win32 plugins will still be usable. Python 2 and 3 would be XHTML 1 and 2. Do you see anyone getting excited over XHTML2's syntactical purity and rewriting their web pages en masse for those new semantic line-of-text tags? Didn't think so. ^(In this analogy PHP would be MS OOXML)
The Python community sounds pretty harsh.
Something seems askew about that analogy. Oh yeah, people actually *use* Python 2 and 3.
You will find this as hard to believe as I did, but Ralphie-boy did the research for once: http://www.reddit.com/r/perl/comments/2bzulc/rakudojvm_put_out_to_pasture/cjo736s
Ah, so after your incessant lying squealing that the logs are censored was flatly shut down, you looked for a way to twist it out of context because you're desperate for attention? Of course you did.
Why did you choose Mojolicious? I've been looking at Perl MVC frameworks and tried playing around with Catalyst but I have recently heard about Mojolicious and I wonder how it compares.
Ohhh papi, spank me harder! The only problem with perl-6 is that an "Internet troll" here or there is "desperate for attention". Not like it's 14 years and counting or anything, noooo. Every time I whinge about something on the Internet I get a punch on a card. 10 punches earns a free kebab. You wouldn't take food out of my mouth would you? But as it turns out, I was wrong about the logs. It happens. I'm man enough to admit it. Now what X-mas is perl-6 coming out by again?
I can't really comment on the others much; I looked briefly at Catalyst but seemed quite complicated. It's the first framework I've used of any kind and took a while to get started but it was well worth it as I use it for pretty much everything now. The MojoCast videos help a lot in getting started, plus once you get into it there's tons of awesome sub-modules like Mojo::UserAgent, Mojo::DOM and Mojo::JSON that you can use elsewhere. Mojo lite is also great for prototyping new stuff. Also the speed of development on the project is a huge plus, getting better pretty much every day :)
If you provide the entry processing function then you can wrap the entries in there? Otherwise it sounds like monkey patching time. Though maybe you could alter parts of Net::LDAP in your own type to create entries or your type instead?
Actually, I could do that. I could just override searching the ordinary way with the paged way. Then like you say I can just wrap them in the coderef I pass in. Consistent interface and works across multiple directory types, which is just what I need. I think this is the beginnings of a winner. Cheers.
&gt;and ISN'T a different language Then explain why the migration problem even exists.
instead of return map { Wrapper-&gt;new(entry =&gt; $_) } $self-&gt;$orig(@_) just return map { bless $_, Subclass } $self-&gt;$orig(@_) where `Subclass` is your class that isa `Net::LDAP::Entry` but provides extra stuff. Reblessing is a little tricksy but perfectly safe if you're sensible about it.
I think the motivation for posting this is utterly jackassed (hi Carlos) but Jonathan is also right. Parrot was a solid idea 10+ years ago, but it didn't pick up the momentum it needed to succeed. Luckily there are other perfectly good implementations. MoarVM is cool for being able to push the limits, but I like the practicality of JVM myself.
&gt; The Perl 6 folks have the first 90% done; with the emphasis on correct and clean. Now the emphasis is on making it fast and porting the highest priority libraries. Here is why that scares me: "The last 10% of performance generates 1/3 of the cost and 2/3 of the problems" -- Norman Augustine. 
Ok, so natural language analogy here: Python 2 and Python 3 are like Danish vs Swedish, very close and easy to port between. Many things said in one will be understood in the other. Perl 5 and Perl 6 are like Dutch vs English. The languages are fairly close, but structurally and lexically different in myriad ways. There are very few things you can say in Dutch that will be understood in English or vice versa.
I think the most amazing aspects of Perl are actually those things which beginner to intermediate programmers are most likely to see as bugs, such as direct access to the symbol table, being able to change global configuration parameters regarding input or output, etc. These take some time regarding how to use effectively (you *can't* just do imperative programming with them without thinking things through), but once you have learned that, you can do some absolutely amazing stuff with it. It is far more like lisp than Python or Ruby are and that's a good thing. Perl does much better at DSL creation than Python or Ruby because of these features. Similarly with system administration, the fact that regexps are built in is very helpful (though I also like Rebol here due to the fact that instead they build recursive descent parsing into that language). I do a lot of web development on Perl. I like it for that but to a large extent when you are looking at large application design, choice of language is partly about preference.
Depends on the areas of scientific computing. Bioperl is used by some very major biotech firms.
I think, iirc, you can use DBD::Sybase. See http://www.perlmonks.org/?node_id=392385
You've taught me a trick there. This looks perfect, thank you very much. 
I am curious, are you using a server that comes with mojolicious or a Plack one?
I'm using nginx as the front end server, which acts as a reverse proxy into the Mojolicious Hypnotoad server. Very easy to set up and pretty solid in my experience
Front-end is the only thing not using Perl. If I found Dancer sooner I might have used it, but all backend work is Perl. Feedback is welcomed. I really enjoy working on AI stuff with Perl.
Yeah, the complexity of Catalyst was kind of overwhelming which is causing me to consider other things. Seemed like Mojolicious lacks the documentation that Catalyst has though.
Cool. I searched "perl" and found the commentary on Wikipedia is "sarcastic" which feels right. What's your stack look like?
.com uses ElasticSearch and .org uses Lucy?
Just give it up and create JPERL already. I have been using JRUBY for years now and like it more than regular ruby.
I guess I'd step back and ask what goal are you trying to achieve by parodying entries? Are you adding methods for example?
Cool thanks for sharing, looks very interesting - what are you using for crawling? Is that where Java comes in?
Just had some Friday afternoon experiments with this and it's working well. Thanks. Just for reference though it seems this is the preferred Moose way to do this: __PACKAGE__-&gt;meta-&gt;rebless_instance($instance); ...where __PACKAGE__ is the object type you wish to convert to. 
I launched about a year ago now, and been gradually making improvements, from front-end code to optimizing performance on the backend. Improving memory utilizations and really learning the in and out of Mod Perl and many other parts of the stack. It appeared in the Globe and Mail here in Canada, and TechVibes, but no love from TechCrunch despite talking to them a few times. NBC was nice but they decided to cut the story at the last minute. 
Yes Java and Perl glue together very well for crawling.
Its (almost) here! (depending on where you live)
Mod perl is basically dead. Or at least there are plenty of people like me around currently bludgeoning it to death. 
Don't think so brah. http://metacpan.org/pod/Moose http://metacpan.org/pod/Moo
Nice, so what kind of traffic do you see on the site? How many visits do you handle?
im not twisted about people doing fun and interesting stuff in Perl 6 - good for you I say. My issue with Perl 6 is the name. It has stolen the next major version number of Perl 5 and it is a completely different language. This more than anything else has led to the decline of Perl. New developers don't want to learn Perl 5 because they think it's going away; why in the world would someone want to learn the old version of something? To someone that doesn't know any better, it would be like learning Windows 95. Not useful. - yet they don't want to learn Perl 6 because it's not used in production. Perl.org doesn't explain any of this, and perl 6 isn't backwards compatible. so - happy you Perl 6 guys are doing what you love, but change the name please
&gt; This more than anything else has led to the decline of Perl. Is that really true? I know many think so, but popularity itself is cyclical and fickle. Empires rise and fall. Perl was king, it had nowhere to go but down. But now it's arguably where it belongs, fiercely challenged but still adapting. Is that bad? Was Perl going to be king forever? Ruby is undergoing its own mid-life crisis. Python is not as exciting as 5 years ago. Lots of new, young, powerful languages are thriving. That's life. Having said that, it would be nice for Perl 5.30 to jump to Perl 7 with the caveat that it's strictly a feel-good measure. PR matters, but other things matter more.
Letting the perfect be the enemy of the good.
&gt; It has stolen the next major version number of Perl 5 A "stolen" integer is the trouble here? &gt; more than anything else has led to the decline of Perl It's bizarre to me that you externalize Perl 5's decline. I guess folks just want something to blame.
I agree that those people shouldn't be bothered by Perl 6, but the question is: why are you bothered by them? They are the children in our community. We have to gently guide them.
How does a careful, considered, evolving design of a new language "damage... the reputation of Perl as a whole"? 
It gives the appearance that Perl 5 is stagnating and irrelevant.
Only Perl 5 could possibly give that appearance. It doesn't give that appearance, but only it could give that appearance. Again, folks externalizing Perl 5's decline, wanting something to blame.
During initial launch the site required a sign up to use and after IBM graciously offered to support our hosting needs I decided to open it up publicly. During the last year as users sign up it allowed us to build a strong community, get feedback from users and understand who was interested in our technology. When the Italian Media caught wind of it I was seeing a new user sign up every 10 min for days on end. And the same thing happened in GBP when the largest ISP featured us in their newsletter. Recently Harvard University came on board with our education edition. So if you have a Harvard domain email at sign up you will get access to additional features and our beta social analytics platform which is built on our existing APIs.
&gt; A "stolen" integer is the trouble here? yes. It created confusion among new developers who didn't know if they should learn "the old version" or "the new version" - the "new version" was not going to be backward compatible, but also not production ready for a number of years. So - why not just learn Python or Ruby. &gt; It's bizarre to me that you externalize Perl 5's decline. I guess folks just want something to blame. I don't externalize anything. you asked, I answered. If you don't like the answer, don't ask. The question I have, why not just change the name of Perl 6? The only people using it are you Super-de-duperity smart people. Why I'm sure if Larry just changed the name, smart people like you could adjust very easily. 
 &gt; So - why not just learn Python or Ruby People didn't do that because of a "stolen" integer, or confusion about Perl. People did that because Python was simpler and Ruby was "sexy". It was a popularity game Perl 5 could not win, but instead of being graceful and reflective everyone cries and points to a long experiment that has nothing to do with Perl 5's decline. It's sad to watch. Thanks for chiming in, though, the picture is getting clearer. &gt; If you don't like the answer, don't ask. I believe you have an order of operation error. But please do let me know when you find the "redo" button. 
Looked at the page... clicked a few links including the Github page... still have no idea what PPI is. I can't be the only one.
Tbh, i assume people will be able to find the module on CPAN and will go there before anything else. It's a project to parse perl code into a structured document tree. Important for things like Dist::Zilla.
&gt; But then who would you blame? I bet you don't have a lot of friends.
It basically allows you to do static analysis of Perl 5 code. Prior to [PPI](http://search.cpan.org/dist/PPI/lib/PPI.pm) it was assumed that you couldn't do static analysis of Perl 5 (the saying was "only perl can parse Perl"). One important project that uses PPI is [Perl::Critic](http://search.cpan.org/dist/Perl-Critic/lib/Perl/Critic.pm). If you don't know what static analysis is, it allows you to gather information about the code without actually executing it. This can be used to do things like rename variables, enforce coding standards, etc. It is important to note that PPI doesn't actually fully parse Perl 5 code. Perl 5 cannot be statically parsed. It just does a good enough job that it works for most files (so long as you don't do weird things). 
&gt; People didn't do that because of a "stolen" integer, or confusion about Perl. People did that because Python was simpler and Ruby was "sexy". wrong. people generally don,t choose learning something that has no clear future, and no direction from it's governing body (perl.org) &gt; Thanks for chiming in, though, the picture is getting clearer. I don;t think you're able to understand. No worries if its beyond your scope. &gt;I believe you have an order of operation error. But please do let me know when you find the "redo" button. wrong once more. You asked the top level question to which I answered. Apparently you didn't like my reply because you started getting dickish about it. it's a simple operation .. unless the top level question was rhetorical and you just wanted to hear yourself spout something you think was smart. and then you found out that other people had the nerve to have a different opinion and you went and got your panties in a bunch. 
It's been considered and unfortunately, rejected. If you want to try to persuade The Perl Foundation, you will receive a tremendous amount of support. http://www.perlfoundation.org/
&gt; I bet you don't have a lot of friends. Why?
it's not my fight. If Larry Wall and the foundation want Perl to fade out of existence over a marketing issue, that's their business. I've written Perl code for about 18 years. I love Perl, but I can write code in a lot of languages. It's not a religious war for me. If it dies, it dies. I'll just code in something else instead. 
What? I wasn't writing that in reference to the object system... I meant this about this part: &gt; From what I've heard of Perl 6 this should be changing relatively soon. 
Not sure what that means. My point was that it's been 12 years and people are still hoping that Perl 6 will appear "relatively soon."
The "this" in your quote was explicitly about "clean OO" in "Perl". Perl 6 led to the design and development of what became Moose (clean OO) in Perl. So someone *could* write the message you originally quoted, 8 years iirc after Moose was first released, but it would make no sense.
&gt;My question is, what would be a good technique for turning these Entry objects into something else? Like what? Your design sounds a bit strange, tbh. I just woke up so I'm not in the OOP/D mindset. Gimme an hour
There are enough differences that you can't just take a Python 2.7 program and run it under 3 but there are compatibility tools which greatly simplify the switch. Python 3 is fully production ready, and more and more Python 2 libraries are being ported. 
Does your 'shebang' line point to the right perl executable? Or are you running `some_perl.exe path_to/your_script.pl`?
I reckon mod_perl has a lot to blame. A neat but over engineered solution to the wrong problem. But then again it means that a lot of the shit code out there is now php, so swings and roundabouts ...
The shebang line is a line at the top of your code file that looks something like `#!/usr/bin perl`. The "shebang" is the `#!`, and that line tells unix shell which interpreter the script should be passed to, unlike windows system which use the registry to map extensions to programs.
Post it somewhere, so people can look at it.
I posted it in full to /r/learnprogramming last night and got no response there: http://www.reddit.com/r/learnprogramming/comments/2ds2r5/im_trying_to_run_a_perl_script_in_windows_cmd_and/
OMG, okay, when you post code, use a pastebin. Anyway, as others have said, the error is due to not being able to parse the first line (#!/usr/bin/perl -w) correctly, because (most likely) some invisible characters are present, instead of just a nice, clean newline. You tried to clean that up with "dos2unix myscript.pl" but sometimes (as has been said) you have to clean it up in a text editor, e.g., delete the first few lines, and type the shebang line yourself. But no matter! Typing "perl myscript.pl" instead of "./myscript.pl" is probably the easiest fix. 
&gt; a careful, considered, evolving design of a new language That's the current marketing tagline, of course, but plenty of people think that a better description is "an experiment in language design with no pressure to ship, no pressure to keep stable, no pressure to deliver something that allows users to deliver software that can stay working without continual maintenance". The intent of Rakudo Star was to get real feedback from real users who were writing real software, in an attempt to introduce that pressure. I believe that did not succeed. I spent almost a decade on the design team and most of that in the project's programming leadership, and *I* think it's a project that lost its way long before I left. Lots of other people left too, citing similar reasons (but they can speak for themselves). I've personally seen companies which used to be serious Perl shops gradually adopt other languages, citing that Perl's star seems to be fading, in part because no one really knows what the future of the language is. I've been on revenue-producing projects written in Perl and then rewritten in other languages, and I haven't seen those projects replaced in the wild by more new projects written in Perl. After 15 years of writing Perl professionally, I haven't been paid to write it since the end of last year, and that's not for a lack of trying.
Some might say I'm troll baiting here (they're wrong). I'm legitimately interested in hearing your input on this question, mr_chromatic: What approach would you recommend to reenergize that fading star (understanding that there's no silver bullet or quick "fix")?
i believe Larry Wall and/or a number of people from perl.org and the perl foundation read this subreddit. They know how I feel. 
What does &gt; which perl at the command line say (in Cygwin)? 'which perl' should return the path to the perl interpreter that's currently being used.
You're right. Sorry, I posted this not even thinking about the object portion... only that Perl 6 will still become available "relatively soon."
Invent the equivalent of Ruby on Rails. It has to come out of nowhere, have amazing marketing, and gather attention to solve a problem that isn't obviously being solved by anything else that's popular. Other than that (and as unhelpful as that is), I have no idea.
I signed up, added my github account, but it didn't import my starred repos... is there a button I have to press or something? Edit: they just appeared - I guess it's a background job - it would be nice to have some indication to the user that it's pending. Edit2: looks like it only picked up recent stars... how do I get the older ones?
Probably this thread is what finally persuades them.
Do you all go to the spa together, beating each other with oak leaves, crying about the glory days? Do you wear your lettermen jackets with Perl 4 patches while you rub and tug and say "there there, we'll market this ship back to port"?
Okay, I'm done trolling now. Your true colors are showing.
The voice of reason often comes from strange places. One can only hope
I've found [Date::Manip](http://search.cpan.org/~sbeck/Date-Manip-6.46/lib/Date/Manip.pod) to be extremely useful for things like this. There's a bit of a learning curve up front, but you can do pretty much everything you'd want to do with date calculations. *Edit:* I think this is the first time I've ever contributed something to /r/perl that was upvoted, so I thought I'd throw out an example of how this module is amazing. For one of my clients I had an interface for handling sample orders that they wanted to put time tracking on, workday time, specifically. Depending upon production lab location and sample type, turn times were variable, and they wanted to be able to automatically flag specific requests in the interface when they expired/needed attention. This had to account for regular workdays, holidays, and their own scheduled non-operational times. Were it not for this module, I would still be working out the code. 
I'm not mad at Perl6 but I'm sad and disappointed. I'm disappointed that P6 did not live meet its promise of being the next, great version of Perl (even though we now say P6 is a different language, that was not how it started). I'm disappointed that even with P6's new mission of being 'something else' well that feels like a pragmatic fail since languages like Scala that started years AFTER P6 was announce I can find work while P6 is still a hobby. I'm disappointed that I need to constantly defend Perl5 on the job and in my personal interactions and in my long term career planning. I guess I can't totally blame the status of P6 on that, but I am also sure the way this all rolled is a partial contributor to that problem. I'm sad that while Perl's leadership leapt to work on P6, P5 was left to flounder for nearly a decade until new leadership finally realized P6 was going nowhere and we had to do something if we wanted to keep our real Perl5 jobs going. Like a lot of people I committed myself to Perl as a main focus of my career. That's a lifetime commitment, and its a big deal because if Perl fails me it impacts my livelihood and my ability to take care of my family. O do only get one lifetime after all. So Perl6 is a total fail for me when I look at it from that perspective. Not only am I sure I will never be paid to work on P6, but the fact it sucked the wind out of P5 for a long time (and continues to hurt P5 be being such a public perception fail) has hurt the growth of the P5 language and negatively impacted those of us who use it for real life work. I'm 100% certain that if instead of designing a new language we had focused on sane iterations of P5 we'd be in a better place today. I guess I can't prove that, but I can be sure we'd at least not be in a worse place today. There's really nothing useful to say or do because at this point the community has worked around most of these leadership issue and it looks to me like the people working on P6 would never had contributed to p5 anyway. So the harm is done and mostly over with. AFAIK the only real unsolved problem is the fact that Perl6 is calling itself Perl in some way, when it really shouldn't and that makes it tough on Perl5. My suggestion is that the Perl5 community ignore the existing of Perl6 and up version Perl5 to Perl6 whenever we feel its warranted. Or jump to Perl7 or even Perl 22 (5.22.0 would be a good time to do this). I wish the P6 community the best of luck and hope they have fun with their hobby. I need to get back to actually working my Perl5 job.
&gt; I'm 100% certain that if instead of designing a new language we had focused on sane iterations of P5 we'd be in a better place today. I guess I can't prove that, but I can be sure we'd at least not be in a worse place today. One of the reasons for rewriting everything way back in 2000 was that people thought that gradually improving the Perl internals would take years, perhaps even a decade. We couldn't afford to wait ten years to get Perl to the place we wanted it to be by 2002 or 2003.
I couldn't get very far with this. Just to point out a few things that kept me from reading on: * The HTML-escaped less than/greater thans are confusing. * The "legacy" open calls should be 3-argument style. * In *rule #2* the author says "Always put a semicolon at the end of every line." but doesn't explain why, in the example that follows, they haven't put a semicolon at the end of every line. I appreciate the effort this all took to write out, but I don't think it's a very good "introduction to perl" reference and may, actually, enforce some bad habits. ----------------------------------------------------------------------------------------- *Edit: Because why not?* * No mention of strict and/or warnings. * (Personal preference): Cuddled elses = gross. * Associative array? Does the author mean a *hash*? Because that's what it's called. * "Even the Karate Kid had a few things to learn from Mr. Miagi." -- EVERYTHING. Daniel-San owes Mr. Miagi EVERYTHING! * Loops are called *command structure*? Maybe it's just me, but I've never heard them called that. * Rule #6: "All loops must end." -- while it's a good idea for introductory purposes, and technically correct, I don't think this should be presented as a *rule*. Consider the uses of while (1) loops. * "(Foreach loops are) like a lazy version of the for loop." -- Does the author mean the same exact thing? Because they are. * "File handles are always written in uppercase..." -- Unless you use file handles correctly. I'm only halfway through and I believe this "reference" does more harm than good, so I'm downvoting this and moving on. The author has a lot to learn about the language before trying to provide a reference for people that are new to perl.
Several Perl monger groups have strange schedules, you can look into their newsletters there's often a golf tournament around those tasks.
Also in that first example with the HTML-escapes: my $in{'logdata'} = ... This is terrible.
Useful feedback thanks, yes GitHub and Twitter are background jobs... Spent so much time on back end stuff easy to forget useful details like user notification! At the moment it only pulls from recent stars yes; will look into how/if it's possible to pull out older ones (dependent on GitHub api of course). 
Do you believe not using a native language has any benefits? Take for instance in Salt if I need functionality that does not exist I can write my own salt module in python which is very simple. I would offer the opinion that native code deployments have been a big problem for organizations that want to scale and iterate quickly. One might even argue that native code is what brought us orchestration in its current formats.
I can't find anything to back me up now, but when you use lazy_build =&gt; 1 you add a bunch of methods (clear_attribute, has_attribute and _build_attribute), which you may not need, it's better to specify lazy only and then specify a clearer or predicate if you need them.
Some people do more than passively hope too. Like download Rakudp and use it, maybe write a module or two.
how has your experience been with es? 
Love it, really good perl support, not quite as accessible as mongodb but extremely quick and powerful as a DB &amp; search engine. 
I agreed completely. It was a bold decision in 2000 and it made sense for a lot of reasons. I know how I'd do things differently now if I could do it over again. My biggest project management disappointment of the past decade and a half is that that desire to rewrite everything has been repeated over and over, without any apparent learning from the mistakes of the previous rewrite.
ok so lazy_build is now discourages because it does too much (it creates clearer and predicate methods) and this can pollute your namespace. However lazy is still considered a fine idea. typically you can just do lazy=&gt;1 and then set the builder method manually. Or if you prefer (and like the way Moo does this) you can use https://metacpan.org/pod/MooseX::AttributeShortcuts and do is=&gt;'lazy'. 
yes this is the exact reason lazy_build is now considered discouraged and we prefer to be explicit with setting lazy and the builder method separately. If this feels very verbose you can use: https://metacpan.org/pod/MooseX::AttributeShortcuts and that gives you is=&gt;'lazy'.
That's just how an inverted index works; the search engine uses ElasticSearch's English analyzer which breaks down English words into easy to match sub-sets. Since AngularJS isn't a real word in the index it is actually indexed as 'angularj' (lowercased with 's' stripped out which could be read as plural). There's a good explanation of how it works here: http://rosssimpson.com/blog/2014/05/02/customizing-elasticsearch-english-analyzer/
&gt; Perl 6 will still become available "relatively soon." For the record, because some folk might take your original post or the above comment literally, I'll note that **the Rakudo Perl 6 compiler has been available for several years**. Perhaps the following is closer to the sort of thing you're meaning to convey: It's been N years (for large number N) since the start of P6 and neither P6 nor Rakudo are really close to a respectable "1.0" release yet. There is (deliberately) no plan or estimate yet predicting how many years it'll take before either might get there. (And then they'll need to mature well past their 1.0 releases of course before they'll have a chance of gaining real traction.) Enthusiasts have come and gone over time but many repeat the same it'll be "ready for general consumption in the next 18 months or so" mantra that has been implicated in prior disappointment. (Even my relatively conservative guesstimate from 2009 of 5 years to a mere 1.0 has turned out to be off by an unknown number of years.) For some the much more important issue is that they think/feel P6 and/or perceptions of it are seriously negatively impacting P5. Close?
Yes, thank you! This was exactly the point of my post. I'm glad *somebody* got it. :)
"metacpan should provide installation instructions for every package, which would be easy boilerplate using the cpan command line tool" This seems like a good suggestion. Edit: I've suggested it here https://github.com/CPAN-API/metacpan-web/issues/1295
yeah, it could provide instructions for cpan and cpanm and cpanp. but metacpan isnt a package manager, _dammit_ :)
Let's all just be glad this wasn't a review of the PAUSE website.
Does the CPAN installation command finish successfully?
Yes. I actually got a library working by putting this at the top of my script: use lib '/usr/share/perl5/build/HTML-Template-2.95-8jf9B7/lib'; Is this what you have to do for every module? I ask because when I've used other hosting providers and installed a module, I've been able to just include it as use My::Module without needing the full library path. Are they maybe adding this path to the @INC variable every time I install one?
Hmm... Would it help if I posted the full text that from an install? Maybe I'm thinking it's installing correctly but it's not.
&gt; The path to where the default perl modules are installed is /usr/share/perl5 If you are certain of this, look in /usr/share/perl5 to see if the module is there. If it is not there, then it did not successfully install. The directory where you found the module (posted on a previous comment) looks to me more like a build directory where cpan does some work during the install. Post the full output from the cpan installation to pastebin (or something of the like) and link it up here. It failed if it doesn't show something like this: Installing /Library/Perl/5.16/HTML/Template.pm Installing /Library/Perl/5.16/HTML/Template/FAQ.pm Installing /usr/local/share/man/man3/HTML::Template.3pm Installing /usr/local/share/man/man3/HTML::Template::FAQ.3pm Appending installation info to /Library/Perl/Updates/5.16.2/darwin- thread-multi-2level/perllocal.pod WONKO/HTML-Template-2.95.tar.gz sudo /usr/bin/make install -- OK 
It can't hurt to upload it to pastebin
If this is with the system Perl install why not use the package manager for your OS? something like: sudo apt-get install libhtml-template-perl 
Have you dumped the file in a hex editor and verified the \r characters were removed? Not really anything to trouble shoot without the related file. 
I'm not sure I agree that metacpan should give download examples. In general the correct way to manage dependencies for your application is to use a Makefile.PL or one of the common other tools such as Dist::Zilla or Carton. Nobody should 'cpanm ....' from the command line as it results in an application where the dependencies are not tracked properly. Although I appreciate the work here, I don't think we are comparing packaging tools right? its more like comparing the search websites or something. Honestly there's a ton of other differences at play. NPM allows you to have more than one version of a given module installed, which is interesting (it has pros and cons compared to the Perl approach). Really there's a lot more going on.
[pastebin link](http://pastebin.com/nLHxn5Zt)
&gt;Nobody should 'cpanm ....' from the command line as it results in an application where the dependencies are not tracked properly. I'm sure you don't mean that ... what about when you're developing a script or you just want to test a module? Almost every other package manager provides installation instructions, and we have it better than some languages as `cpan` comes with Perl.
[locations of Template.pm](http://pastebin.com/9808eEvg) Seems the one that's in /home/user/perl5/lib/perl5/HTML/Template.pm is the one I want installed in a location in @INC. All of the installations you see in /home/user/.... are from the initial install. Everything was being installed in my user directory, so I updated the .conf for cpan to install everything in one of the directories on @INC.
Yup! So the core issue is that @INC doesn't include your user directory, or that cpan is installing to the wrong place by default. Once you updated .conf were you able to reinstall and call the modules without error?
I guess if I wrote a script that dependent on non core dependencies, then yes, I would bundle that script properly with a minimal Makefile.PL and any other bits it needs to run. Otherwise I am just leaving someone after me with headaches when they go to set up a new server, and run my script and it doesn't work because it was assuming certain non core dependencies were already installed. and I guess I am still confused since I don't see metacpan as a package manager. Its a website where you can search for and review CPAN modules. it does give you links for a module where you can download the associated tar ball though, and I do find that useful sometimes. One thing I always wonder about, if intend of a tar ball with .tgz file name, if we'd not be better off using .cpan and have an associated registered mime type, which I suppose could make it easier for someone to 'one click install' a cpan module from a website. I still wouldn't think it the best way to do things, but I suppose it might lower the barrier to entry for some people.
AFAIK they *all* fail at having hooks to facilitate building native packages. ಠ_ಠ
Wow, just wow. Lead with "perl-6 has been available for several years". Bold even. Then weasel it down to "Well, but even though I personally had great confidence that it would be usable and useful in 2014, it realy won't be." I do not understand how you fail to understand that you, personally, popping up everywhere to yell out in bold "perl-6 is available!" damages your cause more than anything you whinge about me doing. If you all had only had the maturity to shut up about all of the things you might eventually produce until you actually had produced them in a "useful and usable" fashion, maybe people would take you seriously and you wouldn't have killed off Perl.
I don't know any details about the structure of a PNG file, nor about ADB. 'screencap' presumable performs a screencapture, and considering this winds up in a PNG file, the screencap data should be a binary file ... therefore it should not require Unix&lt;-&gt;Windows newline translation. As well, an image file should contain information about the image width and height. Therefore, converting any CR/LF pairs to simple LF, alters the number of bytes in a row, without updating the counts. What happens if you run adb shell screencap -p &gt; screen.png and try to view the file? 
adb has a bug/feature: it converts \x0a to \x0d\x0a ... 
Try executing this before you run your script: export PERL5LIB=/home/user/perl5/lib/perl5 If this works, then you can add this to your ~/.bashrc file so that it exports that environmental variable by default, any time you log in. If this script will be running from a cron (ie - in an environment where you're not loading variables from ~/.bashrc) you may want to include the path to the module at the top of the script: use lib '/home/user/perl5/lib/perl5'; Either way, now that you know the path to your cpan module you can see how you'll need to get the path included. Technically if you're compiling your own version of perl you can modify the @INC in the binary itself (as a very permanent solution), but since most people don't roll their own binaries, I'm guessing you're not either. 
*tl;dr: Perl is faster to write and more expressive than C or bash, and more portable than Python or Ruby for distributing to users.* One thing I like Perl for is CLI tools that are distributed to end users. I can't tell you how many times I've read about some cool CLI tool online ('csvcut' is a recent example) and then discovered that I needed to go through the following steps to even try it: 1. install newer version of Python/Ruby than my system has (5-10 minutes) 2. Did #1 even work? If not, do I even bother trying to debug a {Python, Ruby} build failure? If it did work, try {pip,gem} install $FOO (1-3 minutes) 3. Did #2 even work? If not, do I try to debug the {pip,gem} failure? If it did install, did it install correctly? Sometimes when I try out the command: $ cool_command args ... stacktrace... It's common (IME) that Ruby or Python barf a stacktrace because something in the {Python,Ruby} environment isn't set up correctly. Generally this is easily avoided in Perl by using a coding style that sticks to using features and core modules from Perl 5.10 or so, and if you need non-core modules, there's [App::FatPacker](https://metacpan.org/pod/App::FatPacker) so your users don't have to care. It's nice to write a portable Perl 5 CLI program and know it can run almost everywhere with no issues. I like telling end users they can just do something like this example from cpanm (which uses App::FatPacker to bundle all its dependencies in one file): $ curl -L http://cpanmin.us | perl - App::cpanminus Leaving aside the security implications of random curl installs, it speaks to the portability and ubiquity of the Perl 5 VM that you can just do that. I think this speaks to "modern" development in the sense that I as a user am pretty busy and have very little interest in debugging any given UNIX tool's implementation language and tools ecosystem just to get my real work done (which may be data science, ops, whatever). Even as someone with programming experience, I just groan when I see that {pip,gem} has failed with some crazy backtrace that I don't have time to dig into. Compared to C++/Bash/Ruby/Python, I see perl ranking in terms of expressivity and portability as follows: C &lt; bash &lt; perl &lt; (python OR ruby) where bash is more expressive and more portable than C, but still not as expressive or portable as perl. Perl, python, and ruby are fundamentally similar in terms of capability, but perl's portability is (IME) vastly better than the other two. I don't know if that answer is exactly what you were looking for, but hopefully it helps. EDIT: C is obviously *highly* portable; perhaps I should have said writing a script is an easier way to get something portable *fast*.
&gt; Whirlpool dev approach (spec is incomplete, no target date) Honestly, this is the only thing that really bugs me. It's just the fact that it's been over a decade and we still don't even have a spec. I get it. It's a complete shift in the architecture, and it'll be amazing and everything. I'm enthusiastic too! But, good grief. How long did it take McCarthy to write the LISP spec?
Why didn't I see the link a month ago? Whatever, just invested in my share.
I was going to learn some python recentlyish but the lack of a well documented straightforward perlbrew equivalent really put me off. I didn't bother with ruby because it was too much like OK perl code. [edit] bad perl is fun thanks to tools like [PPI](https://metacpan.org/pod/PPI).
&gt; Nobody should 'cpanm ....' from the command line as it results in an application where the dependencies are not tracked properly. What are you talking about? cpanm understands how to extract prerequisite information from running Makefile.PL or Build.PL, and parsing the META.* files. You have to go out of your way to install something with cpanm and not have fulfilled all of a distribution's prerequisites first. I think perhaps you meant "no one should run Makefile.PL from the command line as it results in an application where the dependencies are not satisfied".
I dunno, that seems [like an awfully lot of work](http://stackoverflow.com/questions/956379/how-can-i-word-wrap-a-string-in-perl)
You could manually extract that option from @ARGV, but you need to configure Getopt::Long to ignore unknown options: Getopt::Long::Configure(qw|pass_through|);
That's a good idea, thanks! 
Why are you doing that replacement on a PNG?
If it's a full-time paying gig, jobs.perl.org is a good start.
By the way, `tail -5` is deprecated and you're not supposed to do that. Check the [POSIX spec](http://pubs.opengroup.org/onlinepubs/009695399/utilities/tail.html). BSD and GNU implementations will support it, but they all but hide that fact from their documentation (e.g. the [GNU manpage](http://manpages.ubuntu.com/manpages/trusty/en/man1/tail.1.html) says nothing of it, but it is mentioned as a footnote in the texinfo manual) because they really don't want you doing that. 
Oh that makes sense, thanks! 
As someone who's unfamiliar with this area, what exactly does this do? Give more prominence to more "shared" links? The sentiment analysis seems like just a quirky perk, I think I'm missing the core function here. 
Augean stables looking for a Hercules.
Yeah, I just wanted to implement what I thought was standard behaviour, but as rhomboid pointed out, that's not the case anyway. 
This is an admirable and, IMO, inspiring combination of passion and reality from which the Perl community can learn.
This is some kind of weird single-page-app version of HN that simply doesn't load for me. I think that [this article](http://logicaltypes.blogspot.com/2014/08/dylan-harsh-realities-of-market.html) ([comments](https://news.ycombinator.com/item?id=8224469)) are what it's pointing to.
Thanks for sharing! I like and have used a number of the languages the author mentioned. The same passion keeps me coding in Perl (I don't get paid for it, but it's my data-slinging, idea-to-product-in-less-than-twelve-parsecs secret weapon.)
Apologies. The link I posted worked for me. I mistakenly assumed it would for all. Thank you for posting a working link here!
&gt; Algebraic types? Dependent types? You'll never see them. They're too ... research-y. They stink of academe, which is: they stink of uselessness-to-industry. You'll be dead and buried to see them in this form, even after they discover the eternity elixir. Sorry. I dunno. Virtual Machines and Garbage Collectors were academic oddities until Java normalized them. I think this is the best thing Java did for the industry. Maybe the trick is not to be *too* different. Java was otherwise unremarkable when it came out; just a simplified C++, really. So maybe try to get type inferencing into a language without trying to fix everything else academia sees wrong with languages in popular use.
Unreadable. Perhaps the author or someone else will take the time to rewrite it in grownup prose.
Not perfect, but not bad: for i in `scan-perl-prereqs .`; do perldoc -T $i 2&gt;&amp;1 &gt;/dev/null || cpanm $i; done :P
http://builtinperl.com
Perl and bioinformatics are good pals.
Modern web development in Perl is quite nice and it can be used for most the same scripting tasks that Python can.
Anything involving a lot of data munging, especially text, is pretty good in perl. 
1. I read and write XLS files with Perl. (Spreadsheet::WriteExcel and Spreadsheet::ParseExcel) There is also a module to read and write XLSX files. [Excel::Writer::XLSX](http://search.cpan.org/~jmcnamara/Excel-Writer-XLSX-0.77/lib/Excel/Writer/XLSX.pm) 2. I also send and receive email with Perl without installing an MTA. 3. I can process a 500,000 line spreadsheet. 4. I've also processed enough text lines to fill 800,000 printed pages. 
these are decent but honestly? the reddit is where i spent most of my time.
MetaCPAN 11 times?
Well Reddit is a human curated site showing the best from the web. When I designed Enginuity I wanted to factor human curation into the search algorithm, so it ranks on traditional methods plus the number of Facebook Likes, Reddit Votes, Tweets, Pins, Linkedin shares. It provides sentiment analysis based on an algorithm I wrote about the content and the conversations around it from Facebook Comments, Tweets and more. (similar to the comments section of a Reddit post) but summarizes the conversation. It becomes very effective at weeding out click bait since it is less likely 10k people will share an article in which the content just isn't very useful.
&lt;troll&gt;GUIs?&lt;/troll&gt;
As in, write one? Or work within one? http://perl-begin.org/uses/GUI/
As a sysadmin I used it for many different tasks. Log analysis (in many ways), cleaning infected .php files (iframes got inserted...), splitting files inside a .zip, managing DB backups, ... I can't remember them all. For instance, I used it on our Windows fileserver to manage the folder hierarchy (each client folder has a set of subfolders, one by department), along with NTFS rights for restricted (sub-)folders, based on information from our Active Directory and a text listing of the clients (which can be regenerated by the script).
Write one. Of course it can be done, but the point is... not easily. If you can't tell the users "just install this [well-known] distribution and double-click on the .pl file", almost nobody is gonna use your script/app. I did try Perl/Tk once. Once.
Lol. No. It was 900 books of about 900 pages each for our customer's customers. One customized catalog for each of 900 their customers. 
Log::Log4perl is my favorite. Lots of features, well documented, and easy to use.
I haven't used them myself but [Log::Log4perl](https://metacpan.org/pod/Log::Log4perl) and [Log::Dispatch](https://metacpan.org/pod/Log::Dispatch) seem to be the big contenders.
My team switched everything to [Log::Any](https://metacpan.org/pod/Log::Any). With Log::Any you get a simple, great API that lets the application decide where log messages go. The application, in turn, may choose one or more logging mechanisms via Log::Any::Adapter, like Log::Dispatch or Log::Log4perl.
Not sure why your module got installed to /usr/share/perl5/build/ when its not present in any of the paths in @INC. By any chance did you have a PERL5LIB or PERLLIB env var defined when you installed the module? Low probability, but do you have two different perl compilers on your system (maybe one from Ubuntu and an external one?). 
Mason is largely in disuse right now, for a variety of reasons. Part of it is that it's so easy to embed Perl in the templates that it practically *encourages* developers to put business logic in the template when it properly belongs in the controller or model. Catalyst is great, but it's down to a single maintainer. Today, many new projects are switch to [Dancer](http://perldancer.org/) or [Mojolicious](http://mojolicio.us/).
I'll put another word in for Log4perl, due to its abstraction, but I do want to note that what's on the back end is probably more important than the Perl interface. I recommend logging to a document database as opposed to the traditional text file. A good specific solution is logging (via Log::Log4perl) to syslog with logstash involved to store the data into an ElasticSearch database with a kibana front end.
&gt; DBIC How's this compare to Rose::DB::Object?
Haven't used rose, but it looks much lighter weight. DBIC is massive, arguably making your model layer too complex. It aims to completely replace SQL in your application, and understands the database table structure and relationships, and the queries you run. You can do stuff like make a ResultSet matching all records a user is allowed to access, then pass that to some other logic that searches within it for only records matching a users current search/filter, then read it. Only one SQL query will hit the database. edit: [Catalyst::Manual::Tutorial::04_BasicCRUD ](http://search.cpan.org/~ether/Catalyst-Manual-5.9008/lib/Catalyst/Manual/Tutorial/04_BasicCRUD.pod) is probably the best short-ish example of how DBIC is actually useful in an application. 
Thanks for replying again. As before, what you said is not literally true so I'm going to clarify what the true state is, then guess at what you mean, and see how we do. :) &gt; we still don't even have a spec P6 has [a spec](http://perlcabal.org/syn/). It's a pretty comprehensive spec. The original set of chapters was modeled on the Perl bible Programming Perl which ensures that the spec addresses at least that much ground. Almost all of it is solid. Most apparent problems aren't as they seem. For example [the html version of the Unicode spec](http://perlcabal.org/syn/S15.html) is a 404 but one can view the [raw Unicode spec doc](https://raw.githubusercontent.com/perl6/specs/master/S15-unicode.pod) instead. (The renderer is P6 code and this fails to correctly handle S15 because it contains Unicode characters such as ṩ and more of S15 needs to be implemented before this handling will come out correctly.) ---- I'm guessing your point is that the spec is not yet frozen and you think it ought to have been long ago. Perhaps the best explanation is in [The specification overview](http://perlcabal.org/syn/S01.html). I recommend those interested read the last 4 bullet points, written years ago: * The language designer is neither omniscient nor omnipotent ... If you are unhappy with the current rate of {reaching 6.0.0}, please cooperate more with someone else you think is interested in convergence. * The spec will not be frozen prematurely ... Many parts of the spec are already effectively frozen ... * All specced features that have not been proven in an implementation should be considered somewhat conjectural ... It is quite likely that the first practical implementation will largely determine which features are considered to be required in 6.0.0. * Everyone is allowed to panic once. ... This means you. So, if you are panicking about P6, and this is your first time doing so, fair enough. If not, please either join in the effort or just let P6ers do their thing while you focus on other things. :) ---- I fell in love with Lisp when I first read about it (late 70s) and went on to play with it in the 80s (using metacomco's lisp, written in BCPL, which I spent 3 years coding in professionally). Originally there was to be [s-expressions](http://en.wikipedia.org/wiki/S-expressions) for data and [m-expressions](http://en.wikipedia.org/wiki/M-expression) for code. But, to quote wikipedia, "The first working implementation of Lisp interpreted encodings of M-expressions as S-expressions ... The project of defining M-expressions precisely ... was neither finalized nor explicitly abandoned.". Over 5 decades later the M-expressions spec is still neither finalized nor explicitly abandoned and McCarthy has passed away. ---- Anyhoo, I appreciate that you read this far and hope it provided useful information. :)
Very informative. Thanks!
Haven't used mojolicious. Dancer can promote a lack of separation of concerns which is a problem. Catalyst's relative-lack of maintenance isn't really a big deal. It's stable, and pretty much abstracted out such that no new features are needed for core. I mean I'm currently wrestling with a mod_perl app whose architecture has been neglected for 10 years (nasty plack conversion so that we can test, profile, remove copypasta etc). Catalyst is in no way likely to become obsolete in the way that mod_perl became so.
nah, you want your templates as dumb as possible.
indeed, but I think its nice to use the nearly the same syntax, rather than different for and if/else blocks in TT. And calling DBIC accessors and doing URI generation that already kind of blurs what the view or "display layer" really is.
It seems nice, but it's one of these things when you get a not-so-disciplined developer working on something it all goes to shit quickly. 
I used Rose, and I find it awesome :) You can bootstrap it very easy, and just make it run after reading the tutorial. For more complex stuff you'll have to get deeper into the PODs but it's worth it I find it very capable (my 2 cents) 
And the most bloated thing you could ever throw at conditionally writing a single line of text to a file. EDIT: Downvote/disagree at your own peril. 1.3MB of code to accomplish this task. You can write your own logger in less time than it takes to read the documentation on how to use Log4Perl. You wonder why applications are slow and bloated? This is a good place to start.
I've never been in a situation where I would consider Log4Perl was an appropriate tool, and I've written some very large applications and application clusters.
I don't believe so. I logged in, and installed CPAN, and now CPAN is installed in my user directory. Was I supposed to navigate a specific directory before installing? Maybe it being in my user directory is not allowing it to access certain variables or something?
You're a funny guy, ralph. perl-6 is the new Lisp. I love it. Only problem is Lisp actually had users, not just gossip-rag groupies who put out press releases every time someone starts a proof of concept on Github. Did you seriously think it was good to brag that "someone made a call to libperl" even though it leaks memory like the perl-6 spec and will probably not survive a couple of months, like all of the other proof of concept interop attempts? What is so difficult about biting your tongue and only banging the drum of "we are so bloody awesome" when you have something stable to report?
Nice to see some perl events in Scotland, thanks!
Log::Contextual is another choice in the 'have a common wrapper that let's you defer the underlying choice' I also use log dispatch and Have l4p on the job
As someone fighting with perl5 speed issues now, I kinda welcome the idea of easy concurrency. I hope it's not a bolt-on for the sake of having a killer feature though. An example of what I'm fighting with is calling new() to build 60,000 objects when the new method isn't fast. Since perl5 is (usually) single-threaded you're faced with blocking waiting for each of the calls to be done in order, even if order doesn't matter in the calling program. So I hope it's not just a pretty fork/exec wrapper. If we build objects concurrently they shouldn't just disappear when the thread dies. 
Don't worry about it. This is a real threading model integrated with the language, it actually works and is useful, unlike that coprolite ithreads. You can pass arbitrarily complex stuff around just as easy as using a shell pipe. (Though if you're calling new() that often, the JIT will probably kick in and render threads unnecessary anyway)
Hey, you're the guy who crossposted someone's blatant trolling to /r/perl6. Are you being intentionally obtuse with this trivially googleable question too?
To provide a different answer (and one consistent with my replies to your inquiries replies), most perl developers write their own loggers. They're incredibly easy to write.
Yup too cerebral. The trauma-handling centres of your brain may have already blocked it out but--reality check--it reads like the tumblr post of a tween who's just been dumped by dreamy Dylan, her one true love. &gt; But two, not one, but at least two people loved Dylan enough to risk everything, and ... &gt; They lost. &gt; Wait. What? &gt; Did you think I was going to paint the rosy picture and lie to you and say 'they won'? &gt; Because they didn't. Richard Gabriel's famous _The Rise of "Worse is Better"_ says everything this essay does (I assume cuz I sure wasn't going to finish it) and much more, in the same number of words, simply by writing like someone who has completed high school.
Yeah, that's actually what I did. I went with tsocks. Thanks!
The Edinburgh Perl Mongers meetings aren't new. They've been taking place monthly for many years.
&gt;An example of what I'm fighting with is calling new() to build 60,000 objects when the new method isn't fast. This module caught my eye recently [Hash::SharedMem](https://metacpan.org/pod/Hash::SharedMem). Might be helpful?
"Garbage collection doesn't work" is kind of a big deal. Such a premature announcement. Whatever happened to that pure-perl-6 DBI anyway, or is that one of those sweep it under the rug things that wen're Not Supposed To Talk About Anymore?
I also follow up with [I learn something about tell(), then abuse it.](http://blogs.perl.org/users/brian_d_foy/2014/08/i-learn-something-about-tell-then-abuse-it.html) I didn't mean for the answer to be that generous, but it got away from me by being too interesting. :)
https://github.com/perl6/DBIish/ has a commit in April 2014 relating to Rakudo on JVM so not exactly swept under the rug... But it's easier to just spread the FUD. A post on Reddit linking to IRC logs is hardly some mega official announcement. The Perl5 lib stuff is a new module (nothing to do with core Rakudo) from a new developer, why shouldn't they get some kudos for contributing? 
Piqued my interest. How would I go about writing a GUI in Perl? I know how to do it in C and assembler when it comes to building kernel modules, but Perl is much more cross-system than a binary dependent on other binaries.
After 15 years, can you excuse people for getting tired of lots of announcements of 0.01 versions and no announcements of 1.0 versions. It's just tiring. If I wanted search.6pan.org/recent I know where to find it.
This module (https://github.com/niner/Inline-Perl5) has been around for 5 days not 15 years. It isn't on any package management list. Perl5 has been around for twenty years does that mean I shouldn't care about anything new created in it? Why would I even be on /r/perl if that were true. I'm tired of hearing over the last 15 months your foaming at the mouth posts following anything with P6 in the title. Let everyone else ignore or not at their leisure without having to first chug through your twisted vitriol. I get what you are saying about not shouting from the roof tops about half baked core stuff in Rakudo, its one of the few positive comments you've made. But someone producing a module? A developer from outside the P6 echo chamber no less?! This module happens to be a reasonable show case of NativeCall usage in Perl6. Maybe it's not your cup of tea, maybe you think its the worst thing in the world to have Perl5 running from Perl6. Even discussion about why P6 posts are cross posted from /r/perl6, or why this links to some IRC logs with no explanation, rather than the git repo would all be comments with some merit. But that isn't what you post. You just post FUD and negativity. So, no. I personally wouldn't excuse your behavior. I rather doubt you care about my opinion though. I probably would excuse it if I didn't think this was all just a direct campaign of FUD against the Rakudo team from a sock puppet account. There is basically no language use difference between carlosdelrey and educatedpoo the previous P6 troll account that was deleted. Your account has *no* activity outside of being awkwardly aggressive on P6 posts. Go figure. I think you have been near raiphs cool aid for too long, the vapors are getting to you. Perhaps take a break and get some fresh air and perspective. Is a not yet released scripting language this critical to your enjoyment of life? If Perl vanished in its entirety from existence would you as an individual be so hard hit you would never recover, and have to spend your days shouting in the street about how you were once an important Perl5 developer? If so you have bigger problems than Perl6 being late to the party. I'm only bothered because I am interested in P6 posts and am really tired of jumping to read some comments, only to find you lurking under every stone. I'm happy to just walk away and never read this reddit again. I already keep up with Perl6 and Perl5 more directly. I come here to get a wider perspective. I guess I've found it in you. Bit of a shame. Kind of tired of everyone around here tolerating you or treating your comments with legitimacy. Kind of stinks of elitism and nepotism at a level I wouldn't want to comment on.
When somebody talks about progress on a project that is a few days old then this is already a "premature announcement"? As the other comment states: DBIish (aka "pure-perl-6 DBI") is still there and healthly, and is not related to this new project.
There's actually a pretty big tech scene in Scotland ... :-)
Reference: http://en.wikipedia.org/wiki/String_interning :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**String interning**](https://en.wikipedia.org/wiki/String%20interning): [](#sfw) --- &gt; &gt;In computer science, __string interning__ is a method of storing only one copy of each distinct [string](https://en.wikipedia.org/wiki/String_(computer_science\)) value, which must be [immutable](https://en.wikipedia.org/wiki/Immutable_object). Interning strings makes some string processing tasks more time- or space-efficient at the cost of requiring more time when the string is created or interned. The distinct values are stored in a __string intern pool__. &gt;The single copy of each string is called its 'intern' and is typically looked up by a method of the string class, for example String.intern() in Java. All compile-time constant strings in Java are automatically interned using this method. &gt;String interning is supported by some modern [object-oriented](https://en.wikipedia.org/wiki/Object-oriented) [programming languages](https://en.wikipedia.org/wiki/Programming_language), including [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)) (with its symbols), [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)) and [.NET languages](https://en.wikipedia.org/wiki/List_of_CLI_languages). [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language\)), [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language\)), and [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk) are among the languages with a [symbol](https://en.wikipedia.org/wiki/Symbol_(programming\)) type that are basically interned strings. The library of the [Standard ML of New Jersey](https://en.wikipedia.org/wiki/Standard_ML_of_New_Jersey) contains an atom type that does the same thing. [Objective-C](https://en.wikipedia.org/wiki/Objective-C)'s selectors, which are mainly used as method names, are interned strings. [.NET languages](https://en.wikipedia.org/wiki/List_of_CLI_languages), [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language\)) and [JavaScript](https://en.wikipedia.org/wiki/JavaScript) string values are immutable and interned. &gt; --- ^Interesting: [^Hash ^table](https://en.wikipedia.org/wiki/Hash_table) ^| [^Flyweight ^pattern](https://en.wikipedia.org/wiki/Flyweight_pattern) ^| [^Symbol ^\(programming)](https://en.wikipedia.org/wiki/Symbol_\(programming\)) ^| [^Hash ^consing](https://en.wikipedia.org/wiki/Hash_consing) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ck4i9l8) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ck4i9l8)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
When the irc logs are boring, then you perhaps should read something more interesting. It's not an announcement channel after all. So please do us a favor and go. Go to somewhere that is interesting for you.
What's better in jruby? Can you explain (in short) for a non-ruby dev?
On StackOverflow, it has a rep of -9. Still, it gets posted on Reddit.
Interning can save time for comparisons, since you always know that if two pointers are referring to the same address, then they must be equal. The converse is not true - that two pointers refer to different addresses doesn't mean they're not equal, they could just be clones of each other. In that case, you still need to do a full string comparison. So when interning is used, an O(n) comparison (scan both strings) is turned into a single pointer check, in the successful case. This explanation is for Java but the concept would apply to Perl as well: http://stackoverflow.com/questions/22030798/runtime-complexity-of-string-equals-in-java
Excellent! I've added that to my answer.
Perl had hash key sharing before it had general string COW (since 5.003, if I'm not mistaken), so you don't have to worry about that. You can have a million objects with the same set of keys, and each key string will only be stored once.
Oh, I know it can speed up some string comparisons, I just doubt that amount it speeds up a program is going to be worth the cost of releasing memory on equal comparisons and then having to reallocate memory and coping the string into it. Interning literal strings and hash keys is a no-brainer, but just interning a string because it is equal to another seems fishy to me, it may speed up some very specific programs, but slow down the normal case. I often see a string fetched from an outside source compared against a literal and then thrown away. Interning that string doesn't save space. It certainly doesn't save time (in fact it adds time, but it is constant time in XS-land, so it probably doesn't matter). In short, the only case where interning on equality comparisons saves time is when the same variables stick around a long time without changing and keep getting compared against each other, and I really don't see that as a common case. 
I did not know this (and I have poked around Perl's hash implementation in the past). I wonder what data structure is being used for this. Time to go code spelunking.
When my comments are not to your liking, then you perhaps should read something more interesting. it's not /r/stuffonlyfroggslikes after all. So please do us a favor and take your own advice. Read something that is interesting for you.
Perl 6 is pretty much what I am interested in, and it is not like your posts are boring, it is just that you are spreading FUD.
Image::Grab is not installed. Run `c:\Perl\bin\cpan.bat` then type `install Image::Grab` 
Try doing a forced install `force install Image::Grab` It's only one failed test, it might just be a quirk of that module on Windows, or a missing test dependency.
+1 for funny, -1 for incorrect, so it's a wash. The module was last released in 2004 and was obviously not designed for Windows support, see [here](http://matrix.cpantesters.org/?dist=Image-Grab+1.4.2). I recommend using another user agent such as Mojo::UserAgent, HTTP::Tiny or LWP::UserAgent to download the file.
 #!/usr/bin/env perl # You should always use strict and warnings! use strict; use warnings; use Mojo::UserAgent; my $ua = Mojo::UserAgent-&gt;new; my $time = time; $ua-&gt;get('http://i.imgur.com/4YCwgtW.jpg')-&gt;res-&gt;content-&gt;asset-&gt;move_to("$time.jpg");
You should be able to specify the path in *$filename* e.g. my $filename = 'C:\foo\bar\dog.jpg'
 open('W.txt').lines[1..*].fmt("%s\t") Z~ open('Rs.txt').lines
Or maybe I could use something like Netx::WebRadio to listen to the stream. But that would give me chunks of mp3 stream. How would I test that chunk for silence? 
Further to everyone else's answers, if you're on Windows and don't depend on anything specific to ActiveState's (?) Perl, then try Strawberry Perl instead; it comes with a C compiler for those modules that require compilation (although it might be hairy if they in turn require additional C-based libraries that you don't have already). The image will be "saved" to whatever location you specify in your code at: open(IMAGE, "&gt;$time.jpg") ...if you don't specify an exact path, the file will appear in whatever you have your current working directory set to; fuck knows where that might be under Windows... On this system, that module failed some tests so I had to force it to install, with: cpan force install Image::Grab You might want to look at the **WWW::Mechanize** module instead, it's more general and lets you do stuff like very easily.
A quick google lead me to [SilentJack](http://www.aelius.com/njh/silentjack/) and a [blog post](http://www.talkunafraid.co.uk/2011/03/interfacing-silentjack-and-nagios/) about someone integrating it into a larger application, in this case Nagios via Python and Redis. That may be overkill for your needs, but perhaps the application itself would be useful.
How is "garbage collection doesn't work" FUD? Did you ever read my comment? Someone wrote a proof of concept and announced it on IRC and Ralph thought it was so interesting that it had to be posted on all the reddits. But it's a proof of concept and it only does the easy things, using NativeCall, and it doesn't do the hard things that would make it useful, like not leaking all the memory. This is not good advocacy. This is the kind of thing that the director of my lab looks at and says that there's no one left in Perl that cares about making anything "useful and usable". Now you and I might disagree and think he's wrong, but can you see how he might get that perception? A little bit? At all?
Oh, Ralphie-boy. Oh oh oh. From one side of your mouth, you say "Garbage collection works!" and then "DESTROY doesn't work yet". And this proof of concept handles both of int and char! Wow! For all of the simple integers in Perl and very basic C-type strings, that's great! If all I ever worked with was ASCII I would be more impressed. But the most giggleworthy bits of your post is where you say the very people you're trying to market to are "blind and stupid". How is that evangelism working out for you so far?
It's not the question, it's the answer.
Thanks. That is almost exactly what i was looking for. 
I've only skim-read it but the linked [research paper](http://asrabkin.bitbucket.org/papers/oopsla13.pdf) looks very insightful. It answers many of the questions we Perlers debate about our language's popularity. 
From the paper: &gt; Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not.
MoarVM's GC (like Parrot's and JVM's GC) are working perfectly. DESTROY is a P5ism that needs to be implemented somehow to aid that P5interop project.
Right. Which ties with Joel Spolsky's claim that Perl was successful in the late 90s because it had incredible marketing. And resonates with the current popularity of node.js for "non-blocking" development despite the fact that JavaScript is no better or worse at it than many other languages.
I mostly write command-line stuff, so I usually just write a quick sub to format a log message with a time stamp and write it to STDERR. I then redirect STDERR to a log file. That gives me the benefits of being able to do a dry run or debugging mode for free (just don't redirect); and it captures all unexpected/unhandled error messages to the log file. I usually want errors written to the log, so throwing messages into that stream makes sense. YMMV --- works for the kinds of things I do. 
Node.js is not popular because of its non-blocking features. it is popular because now dumb javascript devs can write server code. earlier they had to learn real languages like Perl/Java/Python etc. to do that..
Author of Device::WebIO here--that's certainly my hope. The market for System on a Chip computers (Raspberry Pi, PCDuino, etc.) is exploding, and a lot of them come with some kind of Debian or Ubuntu install that has a working perl by default. I haven't released it on CPAN yet, but I'm hoping [Device::WebIO::Dancer](https://github.com/frezik/Device-WebIO-Dancer) will become a go-to web interface for these sorts of devices.
IMO, the very end is most applicable for Perl: &gt; Through social influence and legacy code, our oldest and most popular computer languages have powerful inertia. How could Go surpass C? If the right people and companies say it ought to. &gt; “It comes down to who is better at evangelizing a language,” says Rabkin. IMO, we lost the evangelizing years ago. The torch has been picked up once again in recent years but the damage was already done. Now the key lies in getting enough of those right people and companies to once again buy into the efficacy of Perl for more than just one-liners. To do that, we need more DuckDuckGos and their ilk in the world.
The difference between "new projects are written in this language frequently" and "the few remaining legacy projects written in this language will continue to be maintained" is very important, though.
Is SP/K available for x86 Linux yet?
Why are some people still speaking Greek?
This is the payload line from the posting: "Most of the time programmers choose programming languages they know."
I just want to say I saw this story right under the "Opportunity rover to be reformatted after 10 years on Mars". I was both very confused and wondering why the fuck a Rover was running win32. 
&gt;space constraints ?? Oh yes :) it's a *curated* look at CPAN. Every month there are many modules that do not make the cut. &gt;Maybe you should create a separate blog post that says new hardware packages in Perl Well volunteered! Seriously though it would be interesting to read an article on the overall state of Perl's hardware modules, what's out there, where things are heading etc. All the cool things you can do with them. At YAPC NA this year, one speaker ran `prove` on his unit test suite which consisted of making a drone take off, invert, and land again. It was awesome.
Yes but DESTROY is nothing Perl 6 needs, because unlike Perl 5 the compiler is not forced to implement a refcount driven GC, so there can't be a promise *when* such a DESTROY method would be called. (You might know that refcounts mean quite a bit of book keeping almost everywhere.) Perl 6 offers other ways to do what DESTROY does in P5, like LEAVE phasers and similar.
It's fantastic all the work you've been doing on the hardware front, thanks!
Perl had horrible marketing in the late 90s. It just happens that horrible marketing is all you need when there is no serious alternative.
TLDR: &gt; Blah blah blah blah, blah blah blah blah blah. Blah blah. Blah, blah blah blah. Patches welcome.
This interop project needs something like DESTROY, correct, which does not mean that the MoarVM GC *does not work* as you said. That is the point I want to make.
And that is surprising for a few days old project?
I also released my very first -Ofun modules last month. Their main purpose is to let me familiarize myself with CPAN: * [Acme::Iota](https://metacpan.org/pod/Acme::Iota) * [My::Object](https://metacpan.org/pod/My::Object) Let me know if there's anything horribly wrong with how I did things.
It's not. It just been doing such an awesome job they thought they would try expanding the mission a bit and have it package a dist or two on the side.
There was no announcement, there was just a comment on an IRC chat. These channels are there so devs can chat about what they are up to, what problems they have and what issues they solved. As I mentioned before an IRC chat is not a channel of announcements. Also, it would be better for all of us when you'd just ignore topics that make you tired or make you feel sad.
"There was no announcement"--except for this post here on Reddit, the post on r/perl6, and a post on Perl Monks. Except for the announcement, there was no announcement. As I wrote. "when you'd just ignore topics that make you tired or make you feel sad"--that's why I stay out of your weird IRC room. It would be nice if its "not announcements" stayed in your room instead of leaking out to other places, especially when they're not suppised to be annoucements.
Define "real language".
*"main finding? Most of the time programmers choose programming languages they know."* This is such a brilliant insight that I will have to ponder it for quite a while to fully grasp its implications.
I looked at Acme::Iota - it looks fine. If there is a scenario where Iota is useful, you could mention it in the documentation. You could use `is` instead of `ok` for value comparisons, that way if it fails, `prove` will print out the expected and received values, making it easier to debug. You might want to think about edge cases, like what happens when you pass `undef` or a reference to Iota. What happens when you pass a reference to Iota to Iota, does the world end?
I think this exchange will be moot pretty soon (because DESTROY will be implemented) but anyhoo: &gt; "as you said"--no, that is straw man clownshoes Ralph tried to claim I wrote. I do not play such games. I see I have caused confusion and apologize for that. Perhaps we can agree on this description of where things are at today: * If P6 calls code in another run-time that has its own GC then it needs to trigger that external GC via the DESTROY hook if memory leaks are to be avoided. "Garbage collection doesn't work" was carlosdelrey's way of saying that Rakudo HEAD as of Sept 5th doesn't implement DESTROY, so Inline::Perl5 isn't triggering P5's GC, so isn't avoiding memory leaks. * I posted here, /r/perl6, and Perlmonks. I did not provide any explanation with the reddits. Folk might have interpreted my reddit posts as announcements of fully working P5 interop. carlosdelrey finds that annoying. ---- [The post on Perlmonks](http://perlmonks.org/?node_id=1098790) did include a little explanation: *The feature this post is about is just a few days old. It doesn't yet destroy P5 objects, there's more marshaling work to do, etc.* (I'm bringing this project to {folk's} attention at this very early stage in the hope that at least some of you consider [joining the freenode IRC channel #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) over the next couple days to encourage P6ers, play with this new P5 interop, ask questions, etc. Here's hoping.)
SecRing, PubRing, and maybe Config options to the constructor. The docs aren't *that* bad.
Only you could wedge your sad boilerplate plea for attention marketing-pitch into an apology. Does it include an offer to call them "blind and stupid"?
Also: Does Perl 5 have a formal code of conduct yet? Is anyone going to draft one? Is /r/perl representative of what the rest of the Perl 5 world's like? This is a wasteland where most of the signal is drowned out by some of the most utterly toxic bottom-feeders I've encountered online, while supposed "moderators" give them the implicit go-ahead by doing sweet sod all. You couldn't write a better advertisement for Perl 6 (or any other language, for that matter): "At least we're not *this*".
I remember removing a post where you threatened physical violence against someone you disagreed with. Other moderators have sent private warnings to him/her to shape up or be banned.
You probably meant this as a reply to *Ralph*.
Yes I admit I slipped for a moment, and lost my temper responding at a statistically-modal level of civility for this subreddit. Well aimed strawman! Squarely below the belt, as usual. Next time, may I suggest fixing the greater problem instead of demonstrating it?
No
hi /u/carlosdelrey. This is your first and last warning: be civil or be banned. [This isn't the first time you've been incredibly rude](http://www.reddit.com/r/perl/comments/2dkljk/worthington_there_is_no_way_to_finish_perl_6/cjqd8rc). If anything, this situation is ugly enough because I've been lax as a moderator, so I'll take responsibility for that part. Argue with me if you will, but from now on, be respectful, period. Disagreeing is OK, but if you can't understand how to be treat other people with respect, you're banned on /r/perl.
&gt; A white dude telling a brown dude "why can't you be nice, more people will listen to you if you do what the tone police say"--classic! You are now banned for 30 days. If you return and continue your behavior, the ban may be extended and possibly made permanent.
Control-D will send EOF (End Of File?) to your running program, that means that for example if you are inside a while (&lt;STDIN&gt;) loop, it will end and perl will go on executing the code that is after the loop.
Ah there was a typo in the task, same code works perfectly with ctr D rather than ctrl Z THANKS!!!
It's not, I just started learning perl so i'm just learning as i'm going. I had a feeling the code was incorrect..
I don't see anything obviously wrong with it from a syntax perspective. I'm on my phone so I didn't test running it. From a beginner perspective it looks like a good demonstration of using functions and "my" variables. What was it that you thought was wrong?
Did you see the Perl tutorial link on the sidebar? Don't post beginner questions on the main language subreddit, it's rude. But I'll give you one thing anyway - Perl doesn't have variable types, as such (it sorta does but never mind that). What you get from &lt;STDIN&gt; could be "I am not a number! I am man!" and trying to multiply with that will mess things up. _Always validate your input_.
There's always a better way to do something! And a worse way! And sometimes both at the same time! I shaved a few lines off of your code using self modifying code: https://gist.github.com/scrottie/8965a4db3d4487de82d0 Edit: You need to install the B::Generate module to run that. You probably want "cpanm" to install modules with. cd /usr/local/bin sudo wget http://cpanmin.us -o cpanm sudo chmod ugo+x cpanm sudo cpanm B::Generate 
Control Z *on Windows*, read up on Windows ;-)
Hah... right. My apologies. Been a while since I used Windows, and I _may_ have skimmed your post a bit.
I wouldn't say your code is incorrect. This is how you learn. As you write more and more with any language you will find more efficient ways of solving problems. Keep on writing! =)
if you create a loop like: while(&lt;STDIN&gt;) { .... Its a perl shortcut for: while(defined(&lt;STDIN&gt;)) { .... The EOF will be undefined and you will fall through the loop.
Posting beginner questions is rude? Epic lulz.
Such wow.
&gt; Don't post beginner questions on the main language subreddit, it's rude. Why? I see nothing in the sidebar to suggest that beginner questions are inappropriate here. In fact, given how quiet this subreddit is, I'd say beginner posts should be welcomed with open arms. 
I think people have already hit upon most of key issues with your code. Here's my input. None of it is critical, but it's advice that I think you should follow if you intend to write more than a quick script. - There's no real need for subs here. Each one is so simple it could just be done in-line, as /u/mike413 demonstrates. But I guess you're just doing it to learn about subs, so in that case it's ok. - If you care at all for the mental health of anyone who will look at your code in the future, including yourself, please use meaningful and sensible names for variables and subs. A sub that multiplies two numbers should NEVER be called "add" (because it does NOT add!), it should be called something like "multiply". And what does "moless" mean? Those subs should have been called "add", "subtract", "multiply", and "divide". - Your comments could do with some work, but I imagine that's just because you're new to Perl so you're making little notes to yourself. Comments like "#This is the script fo the math." are pretty pointless. In general, you'd be better off with a comment above each sub saying what it does, what the parameters are, and what it returns, but in the case of this program those subs aren't really needed. Commenting code suitably and sufficiently is harder than it looks and can take a lot of experience to get right. 
You have two basic problems in your code: naming and repetition (aka failure to abstract). The first is often listed as one of the [hardest problems in computer science](http://martinfowler.com/bliki/TwoHardThings.html). The second is a bit easier, but often requires you know the language you are using well. Whenever you find yourself writing the same code with minor differences, stop and ask yourself if there is some way you can write more general code. This often will involve things like functions, closures, loops, etc. For instance, you created functions to add, multiply, subtract, and divide, but you didn't create a function to get the users choice. That was the only piece of code that really needed to be a function. You also have almost identical print statements. A loop over the math functions can remove the duplication. It requires your to store the functions in a hash to make looking them up easy. #!/bin/perl use strict; use warnings; sub get_choice { my $prompt = shift; print "$prompt\n"; chomp(my $line = &lt;STDIN&gt;); return $line; } my %functions = ( sum =&gt; sub { $_[0] + $_[1] }, product =&gt; sub { $_[0] * $_[1] }, difference =&gt; sub { $_[0] - $_[1] }, quotient =&gt; sub { $_[0] / $_[1] }, ); my $x = get_choice "Enter a number!"; my $y = get_choice "Enter a second number!"; for my $func (qw/ sum product difference quotient /) { print "This is the $func result: ", $functions{$func}-&gt;($x, $y), "\n" } 
I really like reading Joel's post's. Positive, polite, informative. And the code looks good too.
What they meant was that having an add function that just does $op1 + $op2 is pointless but that this is clearly done intentionally so don't worry about it
I will work on this, thank you!
There is not an age limit that I am aware of for the workshop. There are evening activities often involving drinking that might be an issue. Maybe these are closer? http://www.perloasis.info/tbpw2014/ http://dcbpw.org/dcbpw2013/
I think that YAPC::NA made good progress in this area this year. They ran a "Not Perl" track and invited Charlie Stross to give a keynote. It's just a shame that these things weren't widely advertised outside of the echo chamber.
Which OS are you using? On *NIX shells ctrl+z suspends the running process. Can't remember what is what on Windows, sorry :(.
It wasn't his post either ;)
An interesting read, I've been using [fdupes](https://github.com/adrianlopezroche/fdupes) recently to do some similar house keeping
The happiest and most interesting week of the year for anyone who is (or wants to be) part of the Perl community.
I'd say something, but I'm afraid I'd screw it up.
Bah js is kind of like perl with yucky syntax and depauperate features. 
Maybe so, but it's growing *unambiguously*. Reminds me of [Network Effects are More Important than Technical Quality](http://outspeaking.com/words-of-technology/network-effects-are-more-important-than-technical-quality.html).
May I ask what percentage of attendees (a) were not programmers at all, and (b) were programmers outside of the Perl world?
I think YAPC::NA is having trouble deciding if it wants to be a grassroots Perl Family Reunion or a professional Perl Conference both are great goals and they are not mutually exclusive.
Use [sytnastic](https://github.com/scrooloose/syntastic) for syntax checking instead, it can optionally work with perlcritic as well if you want it to. I don't use it that much, but give [quickrun](https://github.com/thinca/vim-quickrun) a shot for actually running your script.
I add this to after/compiler/perl.vim CompilerSet makeprg=perl\ -c\ %\ $* and I can manually run :make from within vim. I tried syntastic but it has freezing issues that the devs don't care about fixing, since they keep closing tickets related to it.
Yeah, I was scheduled as a speaker and had *two* trainings I was giving (before I had to pull out) and I never heard about this.
Sorry, don't have a number for that. It is incredibly hard to keep track of who's who when you have 1300+ people. I'll give you my best guesstimate, based solely on the blog writeups(reference: blog posts about yapcasia that we have compiled: http://yapcasia.org/2014/08/blog-entries.html), tweets, and impression of the crowd: * 80% of the total attendees were not Perl programmers by profession. * 10% of the total attendees were not programmers at all. Again, I know this has no scientific signifiance to it. this is just the gut feeling I get.
I'm using Notepad++ with the plugin NppExec with commands that will upload the script to my remote server and execute.
yup, perl -c always
Here's how I would do it: #!/bin/perl use strict; use warnings; print "Enter a number!\n"; my $choice1 = &lt;STDIN&gt;; chomp($choice1); print "Enter a second number!\n"; my $choice2 = &lt;STDIN&gt;; chomp($choice2); # We only accept whole numbers. if ($choice1 =~ /\D/ || $choice2 =~ /\D/) { die "We can only accept whole numbers as input.\n"; } my $added = add_numbers($choice1, $choice2); my $multiplied = multiply_numbers($choice1 , $choice2); my $subtracted = subtract_numbers($choice1, $choice2); my $divided = divide_numbers($choice1, $choice2); print "This is the addition result: $added\n"; print "This is the multiplication result: $multiplied\n"; print "This is the subtract result: $subtracted\n"; print "This is the divided result: $divided\n"; # Returns the product of two given numbers. sub multiply_numbers { my ($x, $y) = @_; return $x * $y; } # Returns the sum of two given numbers. sub add_numbers { my ($x, $y) = @_; return $x + $y; } # Returns the difference of two given numbers. sub subtract_numbers { my ($x, $y) = @_; return $x - $y; } # Returns the quotient of two given numbers. Dies if the given denominator is zero. sub divide_numbers { my ($x, $y) = @_; die "We can't divide by zero.\n" if $y == 0; return $x / $y; } You need to have consistent spacing and syntax. Also, make subroutine names more descriptive, and always put a comment on them saying what input it expects, what it does, what it returns, etc. You need to remove the newline from input, and only accept numeric input. Always be wary of user input! There's no need to comment obvious code. A general rule of thumb is to comment data, not code. If the code is clearly written then it should be obvious what it does, and commenting it just clutters things up. Data, on the other hand, can vary and it is often times nver obvious what the data is by looking at source. An exception would be things like special cases, unusual circumstances, or a note explaining why you coded a certain things that way. If all you ever wanted to do is add, subtract, etc then you could easily lump everything into one subroutine. But I left them separated. Also note that you can return the result of an operation. There's no need to set a local variable just to return it. Good job on the strict and warnings, BTW. I don't even write a throwaway script without them.
You're giving that to a newbie? Well, forgetting that you did it to begin with, but why give that mess to someone just starting out?
Edit: [This](http://webcache.googleusercontent.com/search?q=cache:Y_O5-GUe-MsJ:www.epic-ide.org/guide/ch06s04.php+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=uk&amp;client=firefox-a) might be what you need This uses [PadWalker](https://metacpan.org/pod/PadWalker) which allows introspecting of lexical scopes but doesn't seem to be anything to do with package, which you call global, variables. I've never had much use with EPIC myself but see if you can get it to let you display the contents of package somehow. Else it might not be possible
What does the -c switch do? 
Guffaw. 
From http://erldoc.perl.org/perlrun.html#Command-Switches &gt;causes Perl to check the syntax of the program and then exit without executing it. Actually, it will execute and BEGIN , UNITCHECK , or CHECK blocks and any use statements: these are considered as occurring outside the execution of your program. INIT and END blocks, however, will be skipped.
I'm glad about this. I had some time for development a while ago, but couldn't stomach subversion so skipped over Padre.
Do poeple still make typos...
Conversation starter. Did you see how I also slipped in how to install modules?
Not in *this* organization. Failure is not tolerated. 
I wonder how much can differences be accounted to the fact that YAPC::Asia was organized by the same people in the same city every year (AFAIK) while both YAPC::EU and YAPC::NA switch hands and location every year with almost nothing common between the consecutive events. I wonder if it wasn't better for TPF and YEF to have central team doing one part of the organization while having a local team doing the local part? (and if I am not mistake YAPC::NA actually started to go that way in the last 2 years) 
I use Filesys::Notify to watch for file system changes, syntax check any changed files and run any necessary unit-tests on those changed files. The downside to this is that I still need to watch the output in a separate terminal but it's good enough for me.
upvote for hilarious username
noep, never
Why not use the Bigmap2 link that is recommended on the link you gave us? Update: err, what I mean is, you can go to the website, select the area and hit SUBMIT. You will get a image and can right-click &gt; save. Is that not what you want?
How are you trying to run it, and what happens when you do? 
The image that it spits out is a bunch of small images, in this case over 400. The perl script is supposed to stitch them together and produce one file.
I just tried this. All you have to do is run the script provided. Download perl: http://strawberryperl.com/ Install it, download the bimap.pl and run it (double click) and it will produce your map in the png format. You don't need to know anything about programming for this to work and this way you can do as many as you want.
It looks like you can just click the enqueue button, wait a bit, refresh the page and download the [png](http://bigmap.osmz.ru/result/wtx20568415-140913-0034.png)
* "FWIW I now consider Inline::Perl5 safe to use" ~~ nine, from [#perl6 log](http://irclog.perlgeek.de/perl6/2014-09-11#i_9338106). * [P6 "DESTROY"](http://irclog.perlgeek.de/perl6/2014-09-10#i_9331999) was implemented in the NQP toolchain about a week ago. nine wired it up in Inline::Perl5 soon thereafter. * nine said he had [fixed all known memory leaks](http://irclog.perlgeek.de/perl6/2014-09-11#i_9337885). * Inline::Perl5 has been made installable by the module installer Panda and added to [modules.perl6.org](http://modules.perl6.org). * nine updated [Inline::Perl5's README](https://github.com/niner/Inline-Perl5/blob/master/README.md) to show how to use the module to do various things. * Afaict, Inline::Perl5 covers the aspects carlosdelrey complained about below (presumably) such as "Garbage collection doesn't work" and "doesn't do the hard things that would make it useful, like not leaking all the memory".
Booking.com 
DuckDuckGo
IMDB makes extensive use of Perl I believe. 
BBC
Bluehost.com
Ticketmaster.com, booking.com
Can't believe nobody has mentioned Amazon. Not as much Perl as there used to be, but still tons of mason floating throughout the code base.
The one I'm building right now, there's a very tiny chance it'll be famous one day ;)
It used to be an almost totally Perl shop, but the BBC moved to [a Java and PHP based stack](https://support.bbc.co.uk/platform/platform.htm) some years ago.
[Interchange](http://www.icdevgroup.org/i/dev/about) is an e-commerce system that's used extensively, and it's all written in server-side Perl.
Petfinder
http://youtu.be/vWZ-pLUb9L8
Poor bastards :)
&gt; If two expressions are lexically equal, they are always numerically equal too. This is not strictly true and so you should always use the correct operator for the correct operation. Bonus points if someone knows when that is not true :-)
I should note that I meant a "pure string" which is `eq` to itself but not `==` to itself. Of course there are dualvars and objects which overload stringification and/or numification.
The Game Crafter
America.gov
villas.com
[perltricks.com](http://perltricks.com) ;)
["0 but true"](https://stackoverflow.com/questions/129945/what-does-0-but-true-mean-in-perl)
Isn't it weird how this was first posted in /r/programming and then nary a mention here? (as far as I can see, and I'm not a good see-er) It'd be nice if the chrome of this subreddit was spruced up so we can see the latest versions of Perl/bleed and what not. (see /r/naruto /r/bleach for examples)
that is another interesting perl string but it does no fall into the question I'm asking. sauntcartas already hit it, any string starting with "nan"
What value do you expect from "$v1%3" when "it is divisible by 3"?
Couple hints. First, always "use strict" as well as "use warnings"; it will often save you time in the end. Regarding the mod operator, it will evaluate to zero if the right side divides evenly into the left side. So you might want to rethink your comparisons to - 1.
What I wanted to do was get the remainder and then use that to determine if the number($v1) could be divided by 3. The remainder shouldn't be a decimal. If it was it would print out a blank new line. I'm sorry, I don't know if I'm being clear.
Thanks, is there any way to see what the remainder is? I wanted it to only print out the words if the remainder wasn't a decimal.
How do I do that?^sorry We have a new assignment to write a program similar to a pez dispenser. It should be interesting.
Like this: print "DEBUG: vt is $vt\n"; So doing something like: $vt = $v1%3; print "DEBUG: vt is $vt\n"; Will result in output: Give me a number: 3 DEBUG: vt is 0 
 #!/usr/bin/perl -w use strict; # Write a program that prompts a user for a number and then checks to see if that number is divisible by 3, 5, or both 3 and 5 print "Enter a number: "; my $number = &lt;&gt;; chomp $number; unless( $number =~ m/^\d*$/ ) { print 'ERROR: Not a number!' . "\n"; CORE::exit( 1 ); } # If it is divisible by 3, then it should print the word "Fizz" to the screen. if( $number % 3 == 0 ) { print 'Fizz'; } # If the entered number is divisible by 5, then it should print the word "Buzz" to the screen. if( $number % 5 == 0 ) { print 'Buzz'; } # If both cases are met, both words will have been printed. print "\n";
Thanks!
Thanks, I'm going to try it right now.
Thank you. I'm going to try it out.
To answer your question, yes you can see what the remainder is, however it looks like for your assignment you only care if is divisible or not. For example, $ perl -le 'print 10 % 5' 0 So "ten mod five" is zero, which means five evenly divides into ten. If it said something other than zero, it didn't divide evenly. In perl you might say it cleanly this way, if (10 % 3) { print "ten is not divisible by three\n"; } which will always print, because % returns nonzero there.
I had set the header to both that and text/plain but did not have any luck. Thanks for the response. I am now getting a 500 Internal server error with addition of +ExecCGI in an htaccess for the directory.
I'd do two things to solve your problem: * First, does the CGI load if you run it via "perl"? As in "`perl myscript.cgi`" at the command line? Toss a "`use diagnostics;`" up at the top and run it a few times until all the problems go away. * Second, is there a reason you're not using something like jQuery? It's good to know what's going on in the background of an Ajax request, but you can read about that. Doing "`$.ajax({ url: "myscript.cgi" }).success(..)`" is so, so much less pain-in-the-ass-ful. I notice you're getting a 500 error. That's either an issue from the first point, or server permissions somewhere along the line. 
Jquery is a no go for the client who's server it will lie on, but the request is sending properly. I am getting a premature end of script headers issue in the apache logs now so I have made some progress. I am able to run the script manually via perl as myself and as www-data and it operates properly.
Running your example on my local perl cgi server produces no problem, the perl and javascript both check out. I've only ever seen "premature end of script headers " when sending malformed headers and the browser cuts the connection. Are you behind a proxy or firewall that may be behind the issue? Try accessing the script through curl; curl -v http://local/mods/hello.pl?unique=some_id
xerox.com
Closed environment - very limited usage of CPAN here, also that module has a few dependencies that would require me to upgrade some core perl modules to get functioning. I did look at it. Also - my status.dat file in nagios is 1.5 million lines and I needed to write something that is _fast_. Parser is under 2 seconds now.
The magical part is that my %hash = regex part.
Always nice learning new tricks in Perl!
Pretty nifty. I'd suggest at least changing the regexp to something like: (\w+?)\s*=\s*(.*) so it behaves correctly with input containing more than one '=' per line. I'm not sure of the context, so maybe it can be assumed that this will never be the case, but in my experience it's less of a headache in the long run to deal with those cases before they come up with a nice testing suite.
I'm guessing you're doing this because you don't have control over the input?
Nice magic.
In this particular case - the Nagios status.dat file is in a controller format - and also the string values for each key are sometimes very long and can contain special characters, including ='s and I'd want that captured for each line - not as a separate value. The above example is just a test case to parsing out a single object entry form the status.dat file.
Blessed art thou RegEx.