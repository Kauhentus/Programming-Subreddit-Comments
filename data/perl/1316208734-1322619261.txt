&gt; anyone administering *real servers* knew enough to set up mod_perl as well, or had the aptitude to learn Emphasis mine. PHP's popularity didn't come from people administering *real servers*. It came from people willing to pay $2.95 a month for FTP access to cheap shared hosting. &gt; he finds Perl's syntax distasteful. Really, it's a big deal. Ah, hipster driven development.
I think I see.. that may have caused a problem for me later then if I had tried to jump straight into hashes with the limited knowledge I have. What I will be doing once the array is built is using it to build another predefined script. To build that script I have to read the first entry to see what program I'm running and then write/append to my new script using a template chosen based on the program name. Then I just fill in various pieces of information from the rest of that row. 
Don't do as bittermeltdown suggests and use hashes. If the positions had some sort of name then it might make sense to use a hash, but as you've said they are positional in nature, then just use arrays. Something like this: #!/usr/bin/env perl use strict; use warnings; my @results; while(my $line = &lt;&gt;) { my @numbers = split(/,/, $line); push(@results, \@numbers); } *NOTE*: I think Q&amp;A questions are better on a site like StackOverflow.com . The audience is larger and IMHO more experienced (eg, the top voted answer probably wouldn't recommend using hashes like the one here :)
&gt; people willing to pay $2.95 a month Maybe. My point (which seems reasonable to me but which I can't prove in some compelling way) was that anyone using apt-get to administer their Apache installation wasn't driving the adoption of PHP over Perl, due to administration savings. I'd imagine the $2.95 crowd aren't doing *any* server admin, that's being handled by support at the $2.95 host, which again makes/made the appeal of PHP linguistic, as opposed to ecosystemic. Assuming that's a word. 
Thanks, I'll keep that in mind. I used to always use an iterative approach to these things, but a few more senior co-workers did the my @lines = &lt;&gt;; approach and it's just easier to work with arrays, so I started doing this.
thanks for the advice! I think that solution is a bit over my head compared to the while loops that keep track of $old for my purposes (I understand the last map, but in particular I don't understand the $_-&gt;[1] and $_-&gt;[0], I don't recall seeing syntax like that in any perl references I've seen
He also said "To build that script I have to read the first entry to see what program I'm running " in reply to imMute. That would indicate that the first entry has a name.
That is even worse. Try running your program with data: #!/usr/bin/perl use strict; use warnings; my $old = ""; while (&lt;DATA&gt;) { if (/2/) { print "$old$_"; next; } $old = $_; } __DATA__ 1 a2 b2 it prints 1 a2 1 b2 If you don't want the previous matching line to print when you have two (or more) matching lines in a row, you need to empty `$old` as well: #!/usr/bin/perl use strict; use warnings; my $old = ""; while (&lt;DATA&gt;) { if (/2/) { print "$old$_"; $old = ""; next; } $old = $_; } __DATA__ 1 a2 b2 3 4 c2
&gt; but it wasn't admins driving the adoption of PHP, it was programmers, and what those programmers cared about was the appeal and ease of the language itself. Regarding who was driving adoption, I think we disagree. Put a new user in front of Perl vs. PHP, and -- all other variables being equal -- I don't see them choosing PHP over Perl by any significant amount. &gt; Perl, however, couldn't offer those kinds of domain-specific features and that kind of domain-specific documentation, because it is truly an all-purpose language. It's possible that Perl couldn't offer that. Or maybe it's that it wasn't deemed important at the time? I don't know the answer to that. But if it's something that Perl 6 could build in now, from the beginning -- as an optional mode of operation -- I think it could be huge. &gt; The fact is that doing anything even just moderately complicated in web programming means, these days, a complicated setup, possibly including a CMS, an app framework, middleware, whatever. But there's an awful lot of people doing things that *aren't* moderately complicated. And they're currently using PHP. And when they need something "moderately complicated", they tend to stick with PHP. I could see these same users using Perl 6 in the near future if it's as easy as PHP. 
Yeah, I realized that and I'd already followed up my own comment with the fix. :-)
or better yet, [perllol](http://perldoc.perl.org/perllol.html).
Sorry, I assumed you knew about references enough that I can just throw some code (turns out I had a typo) to exemplify my point. Let's deconstruct for a bit. First, let's replace the bogus snippets with real ones and some example data: #!/usr/bin/perl -l use strict; use warnings; my @array = ("red", "green", "blue"); # find the colornames longer than 3 and print out their precedents print foreach map { $array[ $_-&gt;[0] - 1 ] } grep { length( $_-&gt;[1] ) &gt; 3 } map { [ $_ , $array[$_] ] } (0 .. $#array) * perl -l means "add a newline after each print", so I can print clearer output * @array is going to be what we're processing. * `$#array` means "last index of `@array`" , so `(0 .. $#array)` produces the list (0,1,2) which is the list of indexes of @array (we're going to need these). Yes, perl's array start at 0 and the $#array construct is one short, exactly what we need. * as mentioned before, `map { ... }` takes each element of the list it's applied to and transforms it, so we're changing the numbers in the list to `[ $_, $array[$_] ]` - [ ] is an array reference, so we're populating the main list with references to arrays of 2 elements containing the position(`$_`) and the `@array` element in that position ( `$array[$_]` ) - the reason I used references is that it's the only way to put lists inside of lists without getting them flattened - so at the moment, our list now contains: `( [ 0, "red"], [ 1, "green"], [ 2, "blue"] )` * next, the `grep` does, as mentioned, filtering - it tests each element against its block and returns only the ones that tested true - we're doing `length($foo)&gt;3` as the test, what's important to take away is that you need to look at `$_-&gt;[1]` which means "assume that `$_` is an array reference, return the second element of that array", which means the test is made against the real elements of `@array` - an important thing here is that in case of a match, grep will return the *whole* array reference, which means we're getting the position of the good element along with it - the test will skip "red" and accept "blue" and "green", so after the grep we'll have `( [ 1, "green" ] , [ 2, "blue" ] )` * the final map is used to transform the list of references back to a list of values, because it returns an @array element. This is where we're free to do the transposition. - since we made it so far with the positions of the "true" elements, we can ignore the actual values and operate on them directly. They're in the first slot of the `$_` array reference, accessed with `$_-&gt;[0]`. - since we wanted "the previous element" all we need os to substract one from the index: `map { $array[ $_-&gt;[0] - 1 ] }`, which will return `($array[1-1], $array[2-1])`, that is `("red", "green")`. - an astute reader will notice that in case grep matches the first element, substracting 1 from the index is probably not what we wanted... But in Perl this gives us the last element of @array, so we can call it a feature saying that @array is a circular list :) (or, seriously, fix the bug by making the grep block to test for invalid values of `$_-&gt;[0]`) This technique of temporarily changing the array to a list of references is very common (and very powerful), and perhaps the most famous example of it is "the Schwartzian transform" (look it up). I agree it's a bit overkill for the "previous element" case which can be done more efficiently with the buffer trick, but it's still a technique that is massively used for complex data. For a gentle introduction in reference tricks, I suggest the perlreftut and perllol ('lists of lists') perldoc pages. Oh, and disclaimer: I'm by no means a perl guru, i tried my best to not confuse 'lists' and 'arrays', my code probably has more bugs than i've caught and there are lots of other ways to solve this particular problem. i just wanted to give a shot explaining what `grep` and `map` are supposed to do and how they usually cooperate "in the wild".
You can check $0 for the name of the executed program. Watch out, "alias" usually means a definition is given by the "alias" command of e.g. bash. This will not work for this purpose as bash expands the alias before executing. What you want to do is *link* your script to different names with the "ln" command. rc@ds9000:~ $ cat foo.pl #!/usr/bin/perl print "called as $0\n"; rc@ds9000:~ $ ln -s foo.pl command.pl rc@ds9000:~ $ ./foo.pl called as ./foo.pl rc@ds9000:~ $ ./command.pl called as ./command.pl Not working: rc@ds9000:~ $ alias x=./foo.pl rc@ds9000:~ $ x called as ./foo.pl 
You know you can edit comments, right?
I'm sure you know really, but your example mixes 0 and 1-based array indices - in real life, make sure you access them like so... print $array[0][2] ; # yields 3 print $array[2][2] ; # yields 11 ...ie, the first line of your input will be $array[0] .
Yes. I suppose I should have. And you could read the other comments on the short discussion to see if someone else had already posted a correction. :-)
Thanks so much for your explanation! I definitely have a much firmer grasp of your code, and I'll learn some more from the references you recommended
To build on this, the test to see if the called program is a symbolic link: if (-l $0){} 
Woah... At first I didn't understand, but now I want to tell the world.
Thanks for all the suggestions. Since I was only searching for stops (p t k b d g, in this language) + /s/ to replace with stop + /I/ + /s/, I just did something like s/ps$/pIs/g, s/ts$/tIs/g, etcetera for the column in question. I know it's the 'long' way and probably the wrong way to do it, but given the 5 days I had to learn (from nothing) how to write a script to clean up a messy set of linguistic data, this was the easiest way I could get it done. We'll see if I pass the test. Thanks again for the suggestions. 
&gt;all modules are located in /usr/lib/perl5/site_perl/ that seems a little weird. If I were you, I'd put everything in /opt/appname and then symlink the html dir so apache can serve it (or just point apache at the other path). Finally, add a `use lib '/opt/appname/lib';` to the mod_perl startup script.
From what I understand, mod_perl apps work perfectly well running that way and it's actually recommended to keep the code from accidentally being shared out as text. I'm mostly done stuff under the actual web server root that and told Apache to run it using mod_perl. Question. I've done a bunch of work in mod_perl over the years, mostly personal stuff, but I'm considering switching to running my perl under Fast_CGI. What made you decide to go the mod_perl route. 
Perl code under /var/www/html would definitely be wrong but /usr/lib is probably not the best place either. Unless maybe if you are storing the code elsewhere and then installing using a CPAN-style toolchain. Also, you should think about compiling your own perl/mod_perl rather than using the outdated system version.
mod_perl is great but if you are considering Fast_CGI, have a look at [Plack](http://plackperl.org/) instead.
They see me trollin' They hatin'
These aren't advantages so much as changes.
I am not sure if this debate is going to matter to me in my lifetime either. I like Perl 5 and will probably stick with it. However, I would think it goes without saying that P6 would bring *better* things to the table than P5. There would be no point in a P6 if it were not so.
I always try and go to all of Damian's talks. They're always some of my favorites. I ended up skipping one this year so I could go to a distributed computing one, but I think I made it to the rest of his. Plus I think I'm finally started to get excited about Perl 6.
amen! i've been using thin layers above plack recently...plack is "just enough" on its own in certain cases
P5 has a major advantage: it is being used.
In addition to being a neat programming tool that lets you get massive speedups for your compute kernels, Bacon is written largely in Perl. If anyone wants to tell me what amazing module I'm missing that does half my work for me, that'd be awesome...
Bash has the command "type" which will let you see if a command is an alias.
&gt; If you are like the majority of people out there you are still using 5.8.8 Do you have data to back this up, or is it gut feel?
Perl 6 is a better language, but Perl 5 has a better ecosystem and interpreter. Personally, I love a lot of the Perl 6 language ideas, but I also love Perl 5's fast, battle-tested interpreter and CPAN. 
It is based on talks with people at YAPCs (a constant quote is "I am using 5.14, but work is still stuck on 5.8.x") and my personal experience.
Never really wrote a compiler so I can't help you out with most of the things but here are just a few super-minor-nitpicky things that I saw: * [You shouldn't return undef / empty list](http://search.cpan.org/dist/Perl-Critic/lib/Perl/Critic/Policy/Subroutines/ProhibitExplicitReturnUndef.pm) * In Lexer.pm you have 2 labels but instead of using goto again you can just say redo token and remove the again label * pod documentation? * Also for some of the more complex regex I usually break it down into a multi-line regex and add comments -- can really help you out later when you forget why you wrote what you did. I also love using [named backreferences](http://perldoc.perl.org/perlretut.html#Named-backreferences) since you can use good naming conventions to never forget what a captured group is used for Probably not the type of hints you wanted but that's all I got heh. Overall looked like really clean code and if I weren't so lazy I'd probably take more time to understand what it was doing so I could help more. Maybe if I get bored later... Thanks for posting :)
&gt; Actually a "like" or reddit style upvote/downvote system for determining who uses modules would be a great help for users to figure out which module to use. It would also help module developers know if it's worth it to continue their project, or try to get with the competitor's author and merge the useful functions. Well, http://metacpan.org/ has a ++ button to "vote for" modules, which will help towards this; there's also http://cpanratings.perl.org/ for people to leave ratings &amp; reviews, which can be helpful.
I think it'd be worth saying, then, "the majority of people that I have talked to".
Thanks for taking a look. Those are all absolutely things I should be considering.
Main reasons for going with mod_perl were for its performance and flexibility. The integration of Perl and Apache -- and the full exposure of Apache's API to the code -- allows a high degree of control over all stages of the request process. I also like the object model for managing Apache controls. Also, since my project is an application (as opposed to a per se website), it made sense to use routines, rather than discrete 'page' files, to build screens. The entire application will be a package -- essentially a set of perl modules. A similar thing can be done within the CGI paradigm, but it feels a little hack. The weird thing for me is how using mod_perl seems to moot the website directory. It's still a requirement to configure a web root directory in Apache config, but since the bulk of requests are handled by an application residing *behind the curtain*, so to speak, the web directory and its configuration feels a bit vestigial. On the other hand, certain files -- images, Javascript, CSS, etc -- are still served from the web root, so it *is* used. Just seems like a more elegant solution is in order. I've heard good things about FastCGI, but since I haven't used it, I can't comment on how it compares to mod_perl. Just took a quick look at PSGI/Plack per suggestion of another post here -- looks great -- I'd say definitely worth investigating before going with either mod_perl or FastCGI.
It is true, many of these things are indeed advantages. I can see myself taking advantage of typed variables, the object system, method signatures, multisubs, and maybe a few other things immediately. However, twigils and the `somethingfix:&lt;blah&gt;` construct makes my head hurt, and will probably lead to even more line-noisy code. All in all, I'm damn glad the P6 project is advancing as it is, if not for working towards a language to rule them all, then for all the things that have been backported to P5.
Catalyst, dancer, mojolicious - pick your flavor DBIx::Class
Read chromatic's Modern Perl, seriously .. it'll take you only a day or so and you'll know much more ;) (+, it's free if a pdf is enough).
I'd recommend getting a copy of Damian Conway's "Perl Best Practices". Skim it ASAP and keep it around for a more thorough going over as you start getting deeper into some of the idioms of the language.
There's more to it than this, but for a newbie, this has pretty much hit it on the head. Grab one of the mature web frameworks, and a mature database interface (of which DBIx::Class is really your best option), and stick some Moose in there for good measure, and you'll have a toolset that's intuitive, well documented and stable. If you enjoy this, and decide you want to learn more, then you can start researching things such as PSGI, the lower level functions of DBI, and so on. As himdel mentions, Modern Perl is almost as necessary read these days. There's a lot of ways to write Perl, and imo, a lot of ways to write it wrong. Modern Perl will help you write readable code, and avoid many of the gotchas that can be easy to hit with Perl.
Assuming you're working on a team (because otherwise, dictating a language from above is odd), approach the next few months with humility. PHP and Perl are cousins, and a lot of your ideas are still sound, but you're going to be thrown occasionally. Rely on your teammates, ask them to review your code, and you'll get better.
given/when is nice, but I don't really use it that often. Moose is fucking awesome. Method::Signatures (and it's cousins: Method::Signatures::Simple, MooseX::Method::Signatures, and MooseX::Declare) are yummy as well.
Common perl resources : * read this free book : http://www.perl.org/books/beginning-perl/ * for more advanced stuff, see http://www.greenteapress.com/perl/ For various questions, there's the great site http://perlmonks.org .
I'm actually working on an updated version of this. It authenticates and can post to a subreddit ATM, but I am hoping to have some more time this weekend to dig through the Reddit API and extend the capabilities.
&gt; wanted to throw in something here for people who would like to use perl and reddit together, Ha, I like how your solution was to use another language.
CGI::Application, Template Toolkit, DBI
OK. I'd love to see patches, or even requests for maintainership. Please keep me posted. 
Unrelated to the post, isn't $#array obsolete because an @array in scalar context returns the number of indices? 
So, how did it turn out?
not modern enough for ya? 
Not at all; you can get a lot done with those three. DBIC, Catalyst, and Dancer all have slightly longer learning curves, but they offer more in kind.
Both of those sources are very outdated. For instance, the overview to Beginning Perl says, "Coverage is bang up to date, using Perl 5.6 in all our examples..." That is ancient in Perl 5 terms. You should start with [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html), which is available as a free PDF. The Perl documentation is available at http://perldoc.perl.org And Perl module documentation is available at CPAN: (http://search.cpan.org or http://metacpan.org)
Well, Since I've basically started from scratch I don't know that any patches will be viable. (I'm using LWP and JSON instead of WWW:Mechanize for instance.) I've build the package using h2xs under just the Reddit namespace, but have not released it as I'm not sure if this is the best choice for namespace. Why did you choose the WWW namespace originally? (Or do you remember why you made that choice three years ago?) I'd be happy to take over maintainership.
PHP is the bastard child of Perl and Apache.
I used Mech because there was no API back then. I think you're making a good choice with the change. I chose the WWW:: namespace because that seemed to be where other modules that talked to websites were, like WWW::Google::whatever, WWW::Netflix, WWW::Pastebin, and lots of others. Drop me an email with your pause ID or whatever it's called and I'll investigate how to make you the owner or maintainer or something.
Come join us at #perl on freenode via IRC. We'll answer your questions!
link to the pdf? google says [denied](http://www.modernperlbooks.com/mt/2010/10/modern-perl-the-book-the-draft-pdf.html)
That link went to the draft. The published versions are all available from [Modern Perl: the book](http://onyxneon.com/books/modern_perl/index.html).
With a neutered list structure.
I've just received the O'Reilly book "Learning Perl" in the post today. So as soon as I'm done with that, I'll move onto "Perl Best Practices." Thanks for the recommendation.
&gt; Modern Perl will help you write readable code, and avoid many of the gotchas that can be easy to hit with Perl. Yeah I'm a bit concerned about this as the lead developer at this company likes using Perl procedurally, which is strange now I think about it cause he's also a fan of Ruby -- one of the most Object-Oriented languages out there. I know a lot of people do still practice procedural programming -- both in the PHP and Perl worlds. But it just seems odd to me after years of MVC.
I hang around a lot on freenode, so yes I probably will. :)
Also buy a copy. 'Cause mr_chromatic is worth it.
You pass objects around the procedural code...
Sometimes we get stuck in the legacy code trap. You have something that works but "just needs a few tweeks". Pretty soon you have http://html-cart.com/
Yeah, but perlmonks doesn't suck...
The Perl Best Practices book is great (and definitely something to read in addition to Learning Perl and Modern Perl). One caveat is that there are a few things which are a bit out of date. You should consider complementing it with these: * this talk: [http://ontwik.com/perl/perl-programming-best-practices/](http://ontwik.com/perl/perl-programming-best-practices/) * this review of the modules: [https://www.socialtext.net/perl5/pbp_module_recommendation_commentary](https://www.socialtext.net/perl5/pbp_module_recommendation_commentary)
Don't take it too seriously, especially the stuff about OO. *Definitely* don't use Class::Std.
To learn perl itself, Perl Best Practices and perldoc.perl.org are your best friends. Aside from the basics, which you will have to push through like anyone else would learning a new language, here are some tips for the web development side: 1) Use frameworks *after* you've learned perl. Frameworks are great, and if you get to learn one or more of them well, you can whip up complete and feature-full websites very quickly, but this will only be after you know the language itself very well. Most frameworks like Mojolicious, Catalyst, Dancer, etc.. have a lot of new / unconventional syntax which may throw you off if you are just trying to figure out basic perl. 2) Start using a modern version of perl, anything over 5.10 should do fine. There are a lot of bug-fixes to perl (and many improvements and additional features) that you should get familiar with as quickly as possible. Always starting your scripts like this will save you a lot of headache down the road: #!/usr/bin/env perl use strict; use warnings; use 5.010; 3) Use CGI and Template Toolkit - CGI and Template Toolkit have been around for a long time, and are very powerful tools to help you get a modular and easy to maintain site up and running. Both these modules help keep your perl code clean of HTML, and vice versa. Once you've gone on to learn these three things, you can go on to learn other useful CPAN modules such as the following: use DBI; use Benchmark; use Config::Std; use HTML::FormFu; use JSON; Regardless of whether or not you are using a framework, make certain to separate the different elements of your project via easy to understand directory structures, for example the following: /myproject/ /myproject/t # Tests via Test::Simple /myproject/tt # TT Templates /myproject/doc/dev # Developer documentation /myproject/doc/usr # User documentation /myproject/lib # Local libraries /myproject/www # All web-accessible + CGI files go here /myproject/www/css /myproject/www/js There's so much more, but hopefully this is useful. The comments about reading "Perl Best Practices" and "Modern Perl" are also good advice.
Haha.
* Learn what Perl thinks about `undef`, truthiness, falseness, and definedness. They're not always what you think. * Almost every rule you learn has an unstated, "except when...". In most cases, by the time you can understand the except when, you don't need to. This is intentional. * Don't get caught up in the "ugly". All that extra punctuation is there for a reason. Remember, Larry Wall is a linguist, not a programmer. * If faced with a choice: "Clever" or something else, go with something else. Clever is usually a shorter way to write, "Hard to read". * See above. Please, comment your code. Not because "the next guy" will need it, but because in 6 months, *you* will.
Relevant... http://stackoverflow.com/questions/2534756/differences-between-perl-and-php
Sorry, I said that after someone downvoted me. I've been looking at Dancer a bit. :)
awesome.........PHP is a templating system that spawned something...bastardly. When I discovered Template Toolkit, my first thought was - "This is exactly the role PHP should have played; no more, no less"..
Sometimes having The One True Interpreter^tm defining the language is better than having a standard. And that's the truth! I believe this is Perl 6's failing - it's a standard, not the OTI.
SHHHHH!!!!!! Careful, next well have a TT language...
But it has .htaccess support! :)
too late ;)
 #!/usr/bin/TT canihaz loop inurloop kthxbye 
&gt; Larry Wall is a linguist, not a programmer. No, he is a linguist AND a programmer
I don't need to work with Windows lately, but when I did, Activestate was reasonable. I believe their [free community edition](http://www.activestate.com/activeperl/downloads) is up to 5.14.1
Thanks Kip. I'm aware of the Activestate version but why isn't there standard Windows version? Heck, even Haskell treats Windows as tier 1.
At a guess, the reason there isn't a 'standard Windows version' is that that has been the role played by Activestate for a great many versions along the way. No vacuum, no rush to fill it. The only difference (in so far as I know) between 'tier 1' as you put it and AS is that they take the nth version, recompile with any Windows specific necessary differences add various (usually useful) items to the distribution and then release after testing. Windows is not Unix after all, so this isn't much of a price to pay other than a fairly short length of time.
How is Windows *not* a first-class citizen? Strawberry Perl uses the exact source code released by p5p. p5p doesn't release binary builds for *any* platforms.
So why doesn't p5p(whoever that is) release the binaries instead of an external private company(Activestate)? And Strawberry Perl's page is not a wealth of information about who is behind the project(no about section, no license, no source for the installer, etc). Sorry, I'm not going to go into an irc chat just to ask what should be made clear on a landing page. Why isn't the Perl Foundation providing all of this? To compare with Python: http://python.org/download/ With Ruby there is an open source Windows installer with a clearly defined license(modified BSD) regarding the project: https://github.com/oneclick/rubyinstaller Heck, looking at PHP now even they release their own Windows binaries: http://windows.php.net/download/ . Binaries for other OSes and distributions are released directly on each website. TCL...well is it even really relevant anymore? Ok, it seems Activestate is basically carrying TCL. Hmmm...how about Lua? Yup, source obviously provided and the Windows "Batteries Included" version is provided by an MIT licensed open source project with lots of documentation: http://code.google.com/p/luaforwindows/
P5P is the perl 5 porters, they are the volunteers who develop and maintain the perl source code.
In my experience (http://search.cpan.org/~exodist/ to see said experience) perl relies a lot on unix-only features. This is largely because perl was written for unix-like systems almost as a chimera of other unix based tools such as sed awk and grep. An example unix-only feature is forking. Perl did in fact show effort to support windows by introducing ithreads. My understanding of ithreads is that part of their reason to exist is to emulate forking. Forking is not available in the windows API (afaik), but is huge in the unix world. Perl5i, which is an attempt to fix a lot of whats dated in perl has recently run into issues because it breaks the faux forking win32-perl uses.
Who is: perlpolls.com? szabgab? C'mon guys, announce who is running the site, site/poll purpose and at least make something professional looking. I realize most of our sites are not as pretty as the sites made by the dogmatic followers of Ruby and Rails but this is a genunine reason for disappointment. Are we honestly surprised that people are concerned about the future of Perl? ***And yes I do love Perl...
&gt; at least make something professional looking. Well volunteered!
&gt; So why doesn't p5p(whoever that is)... It's volunteers. &gt; Why isn't the Perl Foundation providing all of this? TPF is volunteers, too. If you'd like to help, the people behind Strawberry Perl would love to have your help. Donations of time, equipment, money, and expertise are almost certainly welcome. The only way to get a Strawberry Perl 5.14 is for people who want it to make it happen.
I have. What are my donations for then? To fund an implementation of Perl 6 with the hopes that something will be usable by 2020? Why associate Perl with a domain of perlpolls.com if it gives a bad impression? There are plenty of survey/polling js hosted providers these days that could have been used and instead of wasting the cost of a .com domain name could have been implemented on an existing TPF-owned domain(maybe perl.org would have been too obvious of a choice?). Sometimes eating one's own dogfood is not always the best decision....I mean look at Haskell and Darcs.
Perhaps you can communicate to the people behind Strawberry Perl that they can communicate their needs on the front page. Certainly Larry Wall is not the only linguist in the Perl demesne? 
Forking is available on Cygwin perl. 
Any forking you get on windows is only a bad clone of what happens on linux and should not be there at all. And i say that as a perl dev who spends most of his time making CPAN things work on windows.
Simply put: Because Microsoft doesn't do it. For every other OS, the source of p5p is taken and then binary packages are created by the OS maintainer. Since MS doesn't do that, third parties have to do that job, and they are ActiveState and Strawberry. If you wish to complain, contact MS. As for why Strawberry Perl is not available: That's not even a perl issue, that is a delay by the SP maintainers. They have decided to bundle a bunch of modules with their binary distribution, and one of them flat out does not work on Perl 5.14. So in order to not suddenly drop that, they decided to wait until it's fixed. Honestly, though at this point there's no reason to choose one over the other, both of them are different only in small details that will not affect most people at all. Just take whichever one is most current.
"Well volunteered!" works only and exclusively when in the very next breath you point out the repo so the person can actually do voluntary stuff. Without that it's just a hollow catch phrase.
http://szabgab.com/blog/2011/09/perl-poll-what-would-you-like-to-read-about.html
You can do that yourself on #win32 on irc.perl.org
The cygwin-provided fork() is simply a facade hiding the same magic that Perl5i does itself. Either way, Windows simply does not have a fork() system call, so it has to be faked.
I created this page some time ago, but it is not suitable for link from front page: http://win32.perl.org/wiki/index.php?title=Strawberry_Perl_Development
Please see my comment and links where I've mentioned the availability of other fairly common languages.
Third parties (including ActiveState) make binary distributions of those other languages too. You can help. See the support links at the top of the Strawberry Perl page.
Would you like to volunteer at any of my three non-profits? You can help too. As I mentioned, I've already helped by throwing money at TPF but I'm going to have to reconsider any further as it doesn't seem to be used very effectively. 
You never even mentioned who you actually are. As such, please stop your pointless threats and "hint-dropping". Honestly, based on your personality displayed here i'd really like to know what your projects are so i can stay away. And i say this as one of most active Win32 CPAN authors. Furthermore: The TFP manages Perl core development grants with that money to pay people with specific knowledge to work on things that they'd otherwise not have the time to work on, due to having to make a living. Without those grants the core would stagnate due to a lack of specialized knowledge, and at that point it wouldn't matter how anyone packages Perl. Quite honestly though: I don't get your complaint in the first place. You're obviously fine with other languages having binary parties made by third parties, and with ActivePerl there's a perfectly usable and up-to-date binary available. Where's your beef?
Thank you chorny. It's a good reference. May I ask why you guys aren't comfortable putting more on the website(I presume you're a project participant) regarding some of the information I mentioned?
&gt; Would you like to volunteer at any of my three non-profits? If my business depended on them, I might. As it turns out, my business doesn't depend on products or services your non-profits provide, so the question is irrelevant. &gt; I've already helped by throwing money at TPF but I'm going to have to reconsider any further.... TPF manages neither Strawberry Perl nor p5p.
I haven't had any trouble with fork() on cygwin at all. The only difference is that it's significantly slower than a UNIX fork() as it needs to be emulated by cygwin.dll - but it works. As for Perl, my biggest complaint is that it doesn't seem to even *try* to support what most of us would consider to be "real" threads.
Cygwin fakes it quite well.
All the other comments are quite good, but I'm going to be a bit contrary and suggest that you spend some time looking for replacements for Perl... do whatever is expected of you, but if you have some free time, look into stacks like Tomcat and node.js. I inherited a program that was entirely written in Perl... over the years most of it has been ported to Tomcat which has been much easier to maintain than our old code. I still stub out to the old Perl code that hasn't been ported yet,
Maybe after some time I can convince the lead to migrate some of the code to RoR/Python/Node.js but for now (as I'm the new kid) I would rather not rock the boat -- I already had one victory negotiating my salary, I think I would be pushing my luck.
Actually, the phrase "well volunteered" works in this case. If "cycles" was unhappy about the look of the poll, he could save the html+css, make his changes, and then post a mock up for people to look at. Then szabgab would have the option of taking him up on the changes. 
Yeah, trust me, as a lead the LAST thing I want the new guy to do is tell me how to do my job. After 6 months or so of kicking ass and demonstrating that you're an amazing programmer, then you can start throwing some curveballs, like "hey, I was playing around with node.js, check this out... this totally seems like we could use it." Don't do what the last guy I hired did and go over my head and tell my boss the whole project sucked because it wasn't using Spring after being on the job for two weeks.
A repo would be nice, but View Source and Save Page As still seem to work in Firefox 7.
EBCDIC should die.
Unless you give perl the -l switch, this shouldn't happen. I suspect you have simplified the script in order to post it (since perl is usually in /usr/bin/perl, not in /bin/perl), can you please make a simple script to test and post that one? TL;DR: You're hiding something ;)
If you run your code exactly as you have written it above, what happens? When I run it I get "OSkernel infologin: " and the input is on the same line.
Nope, this is really all I have. I saved the file again to be sure and ran "perl -Wall script" and get outputs all on their own line. It doesn't make a lick of sense to me. EDIT: changed it to /usr/bin/perl because why the hell not, but no change. You were right though, it is under /usr.
Nope, this is really all I have. I saved the file again to be sure and ran "perl -Wall script" and get outputs all on their own line. It's too simple to be going wrong, and that's the frustrating part.
Having previously worked as a mainframe programmer, I can promise you that it's not going to happen any time soon. So we can wish for what we want or deal with what we get :)
There is no need to run the script as "perl -Wall scriptname.pl" which is wrong. Assuming by -Wall you mean all warnings - c style, you are mistaken, because perl interprets this as "perl -W -a -l l scriptname.pl", and the -l switch is messing up your output. The correct ways to turn on warnings are either using this shebang line #!/usr/bin/perl -w or #!/usr/bin/perl use warnings; &lt;rest of code&gt; And you should run your code by making your script executable, and executing it =) chmod 755 script.pl ./script.pl
Oh man, that was it. Using warnings C-style. Hugely appreciated, and I bet that -l flag is the same in bash, which is why I got the same result.
I've nothing but strangely fond memories for EBCDIC---my first character encoding. That said, what effect (if any) would this have on Unicode? And come to think of it, why isn't it a code page (or what ever they are called) in the Unicode scheme of things?
There's your problem. perl -Wall means "perl -W -a -l -l" :) The -l does the \n magic. You probably wanted "perl -w script". Perl arguments are not like gcc's, see perldoc perlrun for a reference.
Isn't it possible to add some sort of input/output filters, and let all the internal work be done in either ascii or utf8? It would hurt speed on EBCDIC systems, of course, but that would be a minor annoyance in this case. 
I don't know much about how Perl handles it, but it was my understanding that this is how it was implemented internally. The problem is that none of the core developers have had access to EBCDIC systems for years and thus cannot verify that the code works.
If that doesn't work..."chomp" it.
What about using the [z/os hercules emulator](http://www.hercules-390.org/)? Maybe even the dev team of Hercules would be willing to make the test?
No, you're doing it wrong. If it doesn't work, find out why, make a test script, read the manual or even the source code, until you find a plausible explanation. chomp() removes a newline (actuallly a `$/`) from the end of a string that already has it (common when reading from a file), it is pointless to blindly use it for strings you *output*. IMHO, the most damaging thing for the perl community is the collossal amount of copy-pasta cargo-culting that's out there, which is a terrible shame given how little there's required to learn the basics of the language, and the availability of lots of good resources to understand the higher level idioms.
&gt; cargo culting Hear hear! At least it's not as bad as php though. 
I too have done AS400 work in the past. More recently my dealings have been with horrible giant bloated data files that have to be processed through dd before they are any use to anyone. I am happy to hear of anything that might pressure mainframe developers towards standards like ASCII etc.
I *wrote* the book I wish I'd had from the start: [Modern Perl](http://onyxneon.com/books/modern_perl/index.html). The best trick I ever learned is to keep a directory full of tiny little test programs. Every time I come across something I don't understand, I write a little test program (yes, with `Test::More` and friends), to figure out how it works in little pieces. A couple of months of experimenting like that with edge cases and executable specifications will teach you a tremendous amount.
Run [perlcritic](http://search.cpan.org/perldoc?Perl::Critic) on your code. Learn why it's whinging, understand it, and fix your code appropriately. If you do this then the people who inherit your code will not curse your name. Well, at least not as much.
I recently moved on from a job writing Perl, and one of the first things I passed on to my replacement was a link to your book. I can't praise it enough.
It's Perl's ultra-flexibility that leads a lot of people into writing line-noise code. My suggestion is to read your code out loud. If you're stumbling over syntax, then you're doing it wrong. Perl was written by a linguist, take advantage of it. 
learn your way around Perl's large documentation via perldoc. For the table of contents: perldoc perl The one I find using the most is: perldoc perlfunc perldoc -f &lt;builtin&gt;
I'm not sure about that. Perlcritic out of the box is in direct opposition to a few modern best practices. Someone who knows "just enough perl to be dangerous" won't know which is which. Example? It's a best practice in many situations to open subroutines/methods like this: my $self = shift; my ($a,$b,@rest) = @_; Unmodified perlcritic whines because it doesn't like "$self = shift;" 
1) The key features that make Perl Perl include hashes and regular expressions. These are part of what makes Perl very powerful. I've seen too many converts writing Perl code as if it was just C or Fortran with different syntax. 2) For programs accepting user input, show them how to de-taint. 
My list: * Start with strictures and warnings (with FATAL =&gt; 'all'). * Test::More and friends * CPAN is your bestestest friend * Explain Moose (if needed) Then, whatever mr_chromatic says.
Testing. The rest is nice, but testing rocks. Once you learn to test and really get used to it, it changes your entire programming world. If it's hard to test, that's a code smell. If the test is fragile, that's a code smell. If it has no tests, that's a code smell ;) Seriously, as you test more, you start writing code which is easier to test and interestingly, that tends to make your code better. You try not to do too much in one function. You try not to rely on global variables. You wind up thinking about your APIs more carefully. You also aren't afraid to change your software because you're terrified you'll break that complex function.
Unless you have a very good reason, only pass scalars (references are explicitly good) to subroutines. This solves a lot of messy, complicated issues that beginners don't know they're having, and forces them to get used to references as the default data structure in perl, which they really are. (I think this is less good advice for non-beginners.) For goodness sake, develop a consistent indentation scheme. Or use perltidy. As people have said, tests are easy and useful in perl. 
Or even easier, go to your google searchbox and type 'perldoc &lt;anything&gt;', and it works and you don't need to know if you need a -f or not! Or worry about if perldoc is installed correctly on your system.
There was a fairly decent 'Which Perl Best Practices (from DConway's PBP book) are still relevant in modern Perl?' article I came across fairly recently. I'd be surprised if there wasn't a modern-best-practices ruleset for perlcritic somewhere (although I haven't seen/used one myself)
There's [perltidy](http://perltidy.sourceforge.net/tutorial.html) which you can feed your (or more usually, somebody elses) horribly formatted script and get something at least semi-readable out. Really upsets people if you're using version control and some diff hits every single line of the file though, so warn them first. Then again, if you're using a VCS, that's a good start towards probably not writing horrific code.
 perldoc -l Some::Module Tells you were the module you installed actually lives. Handy when you're trying to track down where things are getting loaded from. perldoc perllocal Gives you a whole bunch of info about what modules you have installed, versions, etc.
To make things a little easier on a group of coders with different formatting styles, when I used tidy on their code I pointed out that this wasn't a permanent change, just one so that I could more easily read their code. Once the fear of code cops dissipated, many began to change how they formatted their code---eventually it was all pretty much looking the same only without the uproar.
Learn to write modules. When you sit down to write a new application etc, consider writing a lot of the functions/methods up in a module. It makes lots of sense of the long haul. 
...tables to replace if/else/elsif? Care to explain?
`perldoc -lm Some::Module` is more often correct. If the POD and code are in separate files, `perldoc -l` will report the POD location.
Probably a dispatch table with a hash and function references--sort of a non-OO polymorphism.
One thing I do is to try to keep routines short. All to often I have to deal with old code that begins at the top of the file and ends at the bottom of the file, with a sequence of conditions and loops in between, with a few subroutines. I begin with a main() ( or run() in OO modules ). If it grows beyond a couple dozen lines , I try to extract a clump of lines into a named routine. That way, routines are simple to understand. If I need to generate similar results somewhere else, the routine can be re-used with a variation in the args leading to different output. A wrapper routine can conceal some of the arguments, to make things conceptually simpler.
I see an awful lot of code that looks like this: if ($machine eq 'carnatst2') { $switchNum = 3; $rack = 5; } elsif ($machine eq 'txslwaka3') { $switchNum = 4; $rack = 7; } # ... Which is easily replaced by: my $lookupTable = { 'carnatst2' =&gt; { 'switchNum' =&gt; 3, 'rack' =&gt; 5 }, 'txslwaka3' =&gt; { 'switchNum' =&gt; 4, 'rack' =&gt; 7 }, ... } $switchNum = $lookupTable-&gt;{$machine}-&gt;{switchNum}; $rack = $lookupTable-&gt;{$machine}-&gt;{rack} I told you they were n00bs :) I've shown some of them how to construct the Perl equivalent of **switch** with a hash of anonymous subs... a couple of them got it, the others just backed away slowly.
What's wrong with my ($self,$a,$b,@rest) = @_? Not saying your way is wrong, just curious.
Simple answer. $self-&gt;fnord(@_); Otherwise, you'd have to run: $self-&gt;fnord($a,$b,@rest); Sometimes, argument lists are so volitile, you want to guarantee backward and forward compatibility through your forward call.
Nice! I'll be sure to throw that on the top of the list of recommended books... I'm no fan of *Learning Perl* and *Programming Perl* is way above their heads. Getting them to read it, now that's another story... apparently reading a programming book is almost as bad as reading the manual. It's just not done. Any thoughts about being an author? I've been tempted to write a programming book of my own.
Huh, good point. I banned the **my $x = shift @_;** syntax from my code years ago, looks like I'll have to allow an exception!
&gt;A couple of months of experimenting like that with edge cases and executable specifications will teach you a tremendous amount. Wait?! You mean other people don't do this? This is the pattern I use for almost any language, but *especially* for Perl. I'll have a largeish program, and I want to fiddle with something that I think will help but don't completely understand I'll write a bitty script of my own to test it. I guess I just always thought that was the best way to do it...
One of the main reasons for this is it makes you a consumer as well as a producer of your code. Seeing things from the other side is always beneficial. 
&gt; Wait?! You mean other people don't do this? You might be surprised at all of the brilliant and obvious things other people don't do. I'm occasionally surprised at the brilliant and obvious things *I* don't do.
I agree, I like to shift $self off @_. $self can become long, especially if there's logging, and I like to "x \@_" when I'm debugging. My solution is to have: \#\# no critic RequireArgUnpacking - critic doesn't see shift as unpacking. near the top of each file, to build my irritation until I modify the specs and submit a patch.
you could also shove it in your .perlcriticrc and disable it globally :)
I always teach this to everyone I mentor in Perl. Open a window and start: perl -de 0 Keep it open and use it to try out expressions and functions while you code. Bonus if you're an emacs user and dedicate a shell buffer to this. edit: that's a zero after -de 
I've been using Perl for well over 10 years now and had no idea it could do that! I get that -d puts it into debug mode, and I use -e all the time... but what does the O do?
Agreed... And that's where my point comes up... saying "use perlcritic, stupid" doesn't work if you're not in a position to provide the configuration.
It just executes "0" (zero) as your actual "program" prior to dropping into debug mode. It could be anything I suppose.
Oh, I had the letter "O"... thus the confusion :)
Others can use given/when.
no one thought about it
And just like last year, it seems PPW =&gt; [Perfect Pittsburgh Weather](http://forecast.weather.gov/MapClick.php?CityName=Pittsburgh&amp;state=PA)!
I'd like to, but I didn't book a room in time. I know, I know, you warned me!
You assume all equipment is using a newer version of Perl. We have lots of stuff that's still on 5.8.
leave perl aside, what is your goal?
Are you thinking of a named pipe? See `perldoc perlipc` if so.
This is an OS feature. Both Linux and Windows can do this. Perl (like most other languages) provides facilities (usually with modules) to interface with this OS-provided feature.
I was totally thinking of named pipes! Your reputation in the perl world is well deserved kind sir.
No real goal to be honest. I just remember reading about these named pipes and hit something earlier today where they may be useful. Mostly not remembering the name of the feature was bothering me.
Congrats! Being known as "the perl guy" is a great way to start. I hope it sticks. 
Heh, I read that as "global warming". Talk about a preoccupation.
Congrats, and kudos for being decent enough to post a thank you to show your appreciatin of the community. Always good to see.
Bajeezus! I just saw this. TOTALLY off my calendar. Rats!
We will do it again next year. Mark your calendar to look for it. See you next year :)
Would not really say it is a feature of Linux, but a generic unix feature. 
It's a generic OS feature - Plan-9 has something similar, as does BeOS. I'm not positive about OS/2, but it's a pretty common thing on multi-user systems off the mainframe. (Does AIX have it?) I mention Linux and Windows in specific because those are the two most common OSes in use. Otherwise, I'd have to talk about *nix or some stupidity and I just don't want to deal with it. If another OS is in play, then the OP would mention it at some point.
This might be what you're looking for: WWW::Mechanize::Firefox http://search.cpan.org/~corion/WWW-Mechanize-Firefox-0.55/lib/WWW/Mechanize/Firefox.pm http://corion.net/talks/WWW-Mechanize-FireFox/www-mechanize-firefox.en.html
Thanks I'll definitely look at this!
use [Parallel::ForkManager](http://search.cpan.org/~dlux/Parallel-ForkManager-0.7.9/lib/Parallel/ForkManager.pm); I too am a (relative) beginner with a liking for Tk on linux. I use Parallel::ForkManager for executing multiple system calls and managing the resultant processes in my text-to-speech GUI front-end, [TkTTS](http://superkuh.com/TkTTS.pl). With Parallel::ForkManger your Tk GUI will not freeze.
AWESOME, I'll look at this as well. Thanks for the reply!
Brilliant!
I'll gladly post the code. I wanted something to sink my teeth into and was reading up on bitcoins lately, so decided to try collecting a list of trades at regular intervals, and (eventually) figure a way to save them to a mySQL DB or something of the like. For now, I just pass the info to a .txt file. Here's the code: @trade_list = {}; use Finance::MtGox; $mtgox = Finance::MtGox-&gt;new({ user =&gt; $username, password =&gt; $userpass, }); @trade_list = $mtgox-&gt;call("getTrades"); writeToLog("Hash Count: " . scalar(@{$trade_list})); #write to log file. What fun! sub writeToLog { my $log_text = $_[0]; open (MYFILE, '&gt;&gt;trade_history.txt'); print MYFILE "[" . POSIX::strftime("%d/%m/%Y %H:%M:%S", localtime) . "]" . $log_text . "\n"; close (MYFILE); } This code (except the scalar change to try your suggestion) is what gave me the result in the OP. Unfortunately, using your scalar syntax provides an output of (blank). [08/10/2011 00:47:56]Hash Count: Crazy times. 
`@tradelist` is different from `$tradelist`. If you add `use strict;` and `use warnings;` and edit the program to pass both of those without error or warning, you'll see the problem. Try `scalar @trade_list` instead. (You don't *need* the `scalar`, as concatenation imposes scalar context, but if it's clearer right now with `scalar`, use it.)
Aaaaah ok. I get it now. the @/$ difference just clicked. makes a lot of sense. Thanks much. It worked. :) defined as my($trade_list), counted via @{$trade_list};
Always, always, always put in "use warnings;" and "use strict;" when you start a perl program.
You might want to try the 3 argument open, rather than the two argument open. Also I find that autodie and lexical filehandles make files easier to deal with: use autodie; open my $log, '&gt;&gt;', 'trade_history.txt'; print {$log} $timestamp . "$log_text\n"; 
run your script through Perl::Critic as well for other best practices hints/suggestions.
Holy shit! Perl::Critic is a godsend! Thanks for pointing this out! Great for someone like me who is just starting to dabble in it.
Thank for this, I didn't know it existed!
Looks fine to me. Copied and pasted it, and it worked fine as well. It might be a text formatting issue. Make sure there is no whitespace after the "EOF". That would break it. 
I just checked it and there is no whitespace. 
You might want to take a look at the book [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html). It's a very good introduction to Perl that encourages using current "best practices". The author is also a mod here on /r/perl.
metatron:~ jamandbees$ cat test.pl #!/usr/bin/perl use warnings; print&lt;&lt;EOF; This is a here-document. It starts on the line after the two arrows, and it ends when the text following the arrows is found at the beginning of a line, like this: EOF metatron:~ jamandbees$ perl test.pl This is a here-document. It starts on the line after the two arrows, and it ends when the text following the arrows is found at the beginning of a line, like this: 
Are you using Windows? At one point, Perl 5 on Windows needed an extra newline after the terminator. I'm not sure if that's still the case, but I've seen it confuse people before.
That should work, but if it isn't for some reason, try print &lt;&lt;EOF TEXT HERE EOF ; It's uglier and I don't recommend it, but..yeah. EDIT: wrapped this in a code tag so reddit wouldn't eat my newlines.
Perl is not PHP. This will never work. The "EOF" *must* be on a line of its own. 
Honestly, i'd suggest to not use heredoc, and instead make use of the q@@, qq|| syntax (you can substitute *any* characters for the symbols).
As it turns out, this is also true for Perl 5 on Linux. OP: also make sure to check for (and remove) any whitespace before and after the "EOF" string. And make sure there's a newline after it.
It could be a LF vs. CRLF issue. How did you create the file?
Might want to try "use diagnostics;". Should always "use strict;", though it doesn't help in this case.
I typed it into kate.
Ok, it seems it was the lack of a newline at the end. It works now.
Very odd. Can you post the output of "hd heredoc"?
I found out why it wasn't working. It was the lack of a newline at the end that had me stymied.
And the semicolon has to be on the first line, not the terminator line.
 jmunson@tigol:~$ perl test.pl hi jmunson@tigol:~$ cat test.pl #!/usr/bin/perl print &lt;&lt;EOF hi EOF ; jmunson@tigol:~$ 
I also recommend getting "Perl Best Practices" by Damien Conway. You can then lookup and go into detail what perlcritic outputs. I also recommend you run your scripts through perltidy (Perl::Tidy) and reference PBP for code style advice as your .perltidyrc configuration.
I also recommend getting "Perl Best Practices" by Damien Conway. You can then lookup and go into detail what perlcritic outputs. I also recommend you run your scripts through perltidy (Perl::Tidy) and reference PBP for code style advice as your .perltidyrc configuration.
Yeah, "EOF" is on a line on its own, here. For Perl, it doesn't matter if that line is in the middle of a statement, or underneath it.
Actually, no, it doesn't need to be on the first line, as the [other reply](http://www.reddit.com/r/perl/comments/l5qr3/im_a_newb_heredocs_not_working_what_do/c2q2wmn) demonstrates.
I just now noticed Reddit's formatting killed the newline that was in there in my original post. That would explain the confusion there.
True, but that example is more akin to: #!/usr/bin/perl print " hi " ; I can't really explain why this matters, except maybe something like this: print("Foo",&lt;&lt;EOF,"Baz"); BAR EOF which could just as easily be written print("Foo",&lt;&lt;EOF BAR EOF ,"Baz");
Using your post as input, try this: $ cat file | perl -e 'while(&lt;&gt;) { $cnt += s/\bit\b//gi; } print "$cnt occurances of [it]\n";' 4 occurances of [it] (The s// operator returns the number of substitutions performed.)
 #!/usr/bin/env perl use strict; use warnings; my $var = "the the the the the the the"; my @matches = ( $var =~ /the/g); print scalar @matches . "\n"; prints: 7 It's the "g" flag to the regex and calling the match in a list context that you need.
You also need the regexp to be /\bthe\b/g to match just the word the, otherwise you'll get 4 matches instead of 3 out of: "the one the other the thing" Probably want /\bthe\b/gi to make it case-insensitive too.
Using `s///g` just because it returns a count is inefficient. You can get the count from `m//g` by forcing list context and then converting to scalar without paying for the overhead of doing all those string replacements that comes with `s///g`. Also, useless use of cat. perl -nE '$cnt += ()= /\bit\b/gi }{ say "$cnt occurances of [it]"' file
Good call on the word boundary...
threads in Perl are fine as long as all of your code is threadsafe (which isn't always the case with CPAN code). I suppose there was a good reason the tried-and-true Unix multi-process method wasn't suitable for his purposes? 
This is funny, cause it's true.
&gt; threads in Perl are fine as long .... **&lt;insert-bullshit-excuse-here&gt;** Sysadmins might be fine using heavy weight forking, but anyone wanting to achieve real lightweight threading on a many-core machine is fucked. Forget process affinity or memory migration. To be fair, it's not just Perl.
&gt; Sysadmins might be fine using heavy weight forking... What makes Unix forks so heavy? (I can think of one reason that would require big changes in the Perl 5 core to fix, but beyond that....)
The delay you're using is 10 minutes, the default is 1 minute. While debugging try 1/60 for 1 second.
wow I hate it when I overlook stupid easy stuff like that... thank you.
 use LWP::Simple; $foo = get($url); if (defined $foo) {...
Use `my $content = $response-&gt;decoded_content;` to get the results.
Well, copy-on-write is broken (Perl 5 variables have metadata like the reference count that can change and force a copy). That can make forking memory heavy. Also forking a lot of little processes is expensive (in terms of CPU) compared to a bunch of tiny threads. Forking is good if you have long running processes that need very little communication with the parent process.
I had in mind page unsharing due to reference count twiddling (and it's not *too* difficult a fix: move the metadata from the SV, but then you still have the problem of in-place type upgrades). With that said, I haven't noticed that a preforking model is any more expensive in terms of memory or CPU than an ithreads approach. (The 15% performance penalty for ithreads doesn't help that either.)
I wasn't aware of that issue with the refcount, that's good to know. I still haven't seen any noticeable performance issues with fork vs threads in Perl, but maybe I just haven't pushed them to their extremes. The project in question didn't seem like it needed more than a handful of threads, so I doubt fork would have had any noticeable performance impact for him. Or I could have misread the whole article.
If you're going to create a crawler, you're going to want to use WWW::Mechanize. It takes care of much of the HTML handling that you're going to be doing as soon as you get the page loaded.
List::Gen - I've seen alot of convoluted Perl source, but I just can't wrap my head around this. There's so much code, and practically no comment at all. I'm confused and impressed at the same time.
I can't speak on Perl internal specifics, but I can tell you that *my* vision is a day when you have real shared memory in Perl. I don't care how it's interfaced (could be a *background* method, special threaded programming structures, or OpenMP-inspired directives), but being able to have a single interpreter spawns into lightweight threads with the ability to have shared and private variables would set Perl apart from all others. It's about performance, but it's also about being relevant on many-core systems. I don't necessarily care inter-node communication, but a threaded, NUMA aware Perl interpreter would be cooler than any syntactical sugar or new version. IMHO. And it's okay that it will break unthread safe stuff - it doesn't have to be on by default; besides, Perl's so great because it does give you all that rope to hang yourself. My primary issue with the state of threading in Perl is that people make excuses and are **OKAY** with it. It's not okay. It's embarrassing; fortunately, like I said, it's not just a Perl problem. But Perl could do the right thing and fix it once and for all. And I agree that resorting to event-based, asynchronous solutions is not always the best way to go. Sometimes you want threads (not full processes) using a fork/join, shared memory model. My immediate thought goes to OpenMP's execution and memory model (though, not necessarily their directive based way of doing this).
&gt; I still haven't seen any noticeable performance issues with fork vs threads in Perl, but maybe I just haven't pushed them to their extremes. It depends on what you use it for. If you're literally forking serial processes, that's one thing. If you want to have a set of cooperating lines of executions working in the same shared memory space, then you need a threaded environment that provides access to shared memory space. If C++ compilers can implement OpenMP, Perl can provide threads.
forking is not the "tried-and-true" way if you want to do many things at once in a single application. In the specific case of my application, baconbird, I constantly poll data from Twitter using an existing CPAN library, while at the same time, I drive the user input loop (using STFL). If I wanted the application not to block while data is being polled from Twitter, the only practical choice would have been to cease using Net::Twitter and basically redo the whole architecture using some awkward event-based programming model. And that's what I finally decided to do, I started rewriting the whole thing. But why again Perl, why again some language that already failed me once? And that's when I decided to give another programming language with a prospective future a try. Edit: nevertheless, I think Perl's a great language for some applications, I have used it every day at work for past 2.5 years, it just didn't work out in this case.
It's a nice idea but those are all shit features.
You could try [Perltidy](http://search.cpan.org/~shancock/Perl-Tidy-20101217/bin/perltidy). That should at least take care of your indent and space problems.
Perlcritic might also help
Definitely Perltidy. Additionally, [warnings::unused](https://metacpan.org/module/warnings::unused) will help weeding out unused variables. Lastly, start using [Devel::Cover](https://metacpan.org/module/Devel::Cover) to write tests and when you're done you can start ripping out things to see which tests break.
perltidy and perlcritic. If you want something other than the default behaviours ( which are a tolerable starting point ), you need to set up .perlcriticrc and .perltidyrc files. That takes a while, I spent a couple hours on each, going though the manuals item by item, selecting and discarding and modifying options. Months later, I'm tolerably satisfied with the results I'm getting from each. ( Is anyone every totally satisfied? ) So it's worth the effort. 
Good stuff!
Actually, I just use perltidy -pbp (pbp = "Perl Best Practices") I add the following to my .vimrc: # Perltidy the whole file nnoremap &lt;leader&gt;pt &lt;Esc&gt;:%!perltidy -pbp&lt;CR&gt; # Perltidy the visual-mode selected block vnoremap &lt;leader&gt;pt :!perltidy -pbp&lt;CR&gt; And then it's `\pt` to get the scruff out...
Nice. Going to add that to my .vimrc
You might want to re-think the PBP; some of it's moved out of favour these days. But regardless, sounds like this problem PBP is a huge step in the right direction.
perlcritic has a new module I'm excited about: Test::Perl::Critic::Progressive. It learns about existing code and lets you clean it up over time by setting goals. "This time require the code to pass &lt;x&gt; more tests than it did last time." You use it to make sure existing code can be cleaned up and that new code you write doesn't introduce more nastys. 
&gt; `gg=G` &gt; `:%s/\s\+$//` ~~The first line is redundant, FYI.~~ edit: I can't read
Doesn't look like it. The first line worth of commands auto-indents the full file (note the '=').
This is a lovely hack. I just can't get over Mojolicious and its ability to combine healthy guts with really nice APIs and to have different level APIs (from quick client hacks to full objective web applications) in such a clean package. And ... it works with everything. Lately our web services are transforming into hosts of intercommunicating Mojolicious apps...
After a long deliberation and experiments with different frameworks and content management systems I have discovered that Mojolicious is the best solution if you have to do different things. It lacks build-in DB integration and CRUD, but in most cases this means you are free to use whatever model is most appropriate for your case and with all that is available at this point this turns out to be more of a good thing than a lack. But what might make this the correct solutions for you is the following points: * you get a complete server and client stack, deployable in any context (from mode_perl via plack to standalone server or CGI script) * very powerful templating that does not stand in your way (an you will love the html tag helpers) * different level APIs (simple for one-liner web scraping or simple web apps, advanced for more serious things) * no dependencies - includes all you really need, but happily uses many many CPAN modules that you _migth_ need (or makes use of them via plugins) * good documentation, development environment and community * scales from the simples of CGI situations to the most advanced web site with websockets, server polling, ajax, json, jquery and whatnot The only problem is, this is nice modern perl, and it will pay if you at least understand the objective approach to things, references and callbacks.
Gosh, this is so elegant it is embarrassing. I remember how it used to be difficult to integrate different event handlers with Mojolicious. I find it amazing how the Mojo final solutions is DWIMMY in the way that it can just use any well written CPAN solution without creating a dependency mess. Neat, SRI!
Only if the file is already indented the same way as vim would do automatically.
Whoops, sorry, I misinterpreted it with lack of sleep as "`ggVG`".
You can also make vim use perltidy to indent code via it's "=" command: set equalprog=perltidy And if you have filetype detection (which seems to be pretty standard these days), you can make that the default for perl files: autocmd FileType perl setlocal equalprg=perltidy I've found these to be pretty handy in .vimrc, too: nmap &lt;F2&gt;b =a{`` nmap &lt;F2&gt;f gg=G`` That's "&lt;F2&gt;b" to reformat the current block, and "&lt;F2&gt;f" to do the whole file.
I'd be really genuinely interested to see a source for your comment regarding* "-pbp" being out of favour. Do you have a link? I always thought [thedamian](http://perlmonks.org/?node=thedamian) was incredibly well respected in the Perl community. His book [Perl Best Pratices](http://www.amazon.com/Perl-Best-Practices-Damian-Conway/dp/0596001738/ref=sr_1_1?ie=UTF8&amp;qid=1318502981&amp;sr=8-1) is a great read, in my opinion... Actually, his [Object Oriented Perl](http://www.amazon.com/Object-Oriented-Perl-Comprehensive-Programming/dp/1884777791/ref=ntt_at_ep_dpt_2) is an amazing read, too. *EDIT: daft spelling error
Check out [this](http://vim.sourceforge.net/scripts/script.php?script_id=556) too. It's great.
I like this more than my own suggestion... Thankyou! I have "gg=G" burned into my fingers and do it all of the time... 
This is nice. Have you noticed how the fact that Mojolicious supports server events is note even mentioned as something interesting in this context?
It's not so much that it's "that is the worst thing ever", but it's that PBP was written with older versions of Perl in mind (5.8-ish). Most of the cool kids suggest [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) (it's free, but pay for it please) these days. The most glaring example in PBP that needs to go away (at least, at the last time I checked) was that it was using open FILE, "&lt;/foo/bar"; instead of open my $file, "&lt;", "/foo/bar"; A small thing, but pretty important.
Yes - certainly agree with your file open idiom... Cool - I'll check it out. Thanks for the tip. (What a nice, friendly and pleasant subreddit this is turning out to be! Cheers!)
Not going to lie, the post seems a bit cheap to feed off the hype.
There's a difference between lying and not bothering to knock it.
Why do you want to change the formatting? If the scripts work as is, changing the formatting is pointless. 
So that I can read, understand and maintain them when I need to?
I would write tests for the scripts to make sure they behave as expected rather than reformat whitespace. 
You don't have to choose between the two. Perl::Tidy has minimal risk--and it's often easier to write tests when the code is reasonably consistent in formatting. (edited for grammar)
If it's not broken, don't fix it. If the person altering the script doesn't even know what it does, write a test to find out. I would not change a byte of a working script without a test in place to make sure that it was still doing the thing it was supposed to be doing after I had changed it. 
How do you know what the program is supposed to be doing? I can imagine this project has very little documentation. If this were me, I wouldn't go through and reformat everything as one huge step. You're right--that's a risk. I'd certainly reformat as a first step. I'll take the risk that there's a bug in Perl::Tidy over spending ten times the effort to divine the purpose of an unreadable program.
OK, so the situation is we have hundreds of undocumented scripts whose purpose is unclear, written in unreadable Perl. And your proposed solution to this situation is to reformat the scripts so that the whitespace becomes more correct. 
&gt; And your proposed solution.... As I wrote, that's the *first* thing I would do. Obfuscated code entries tend to remove formatting for a reason.
Whatever the intention was, it speaks truth.
&gt; As I wrote, that's the first thing I would do. If I had to do this, the first thing I would do would be to put the scripts exactly as I received them under version control. The second thing I would do would be to write a test. I would only reformat the scripts when a need for maintenance or improvement became clear, and I would only do it for one script at a time, or even one portion of one script at a time. Each time, I would commit the formatting changes to version control and re-test. 
We are almost in violent agreement. (I wouldn't push formatting changes until I had sufficient test coverage, but I consider trying to decipher badly written code a waste of my time.)
My copy of PBP shows the three parameter form of open.
Odd. I have the PBP refcard on my work box and not the book at the moment, so I don't know where he uses the two-argument form of open. I do see that item #128 explicitly states "Use either the IO::File module or the three-argument form of open", however.
Well, after the test was written, what would you do?
Capture variables only get assigned to when the match succeeds. Write instead: push @subroutines, $1 if $line =~ m|(^sub.*)|;
Ok, I can do that! Do you know why doesn't $1 get destroyed at the next iteration though? I thought it had local scope: If I wrote 'my $match = &lt;&gt;' then $match would be undefined at the next iteration.
use re.pl
They have dynamic scope, as documented in `perldoc perlre`.
Thanks a lot for your help, now I know what dynamic scope is. This really makes it clear: "Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first." If you have time, I have a question about dynamic scope: I read about dynamic scoping, and created an example to 'get it'. But it doesn't work for me. I tried local $match = $1 but that doesn't persist through the iterations. I also had to turn off 'use strict'... foreach my $line (@file_with_functions) { local $match = $1; push(@subroutines, $1) if $line =~ m|(^sub.*)|; }
It's sort of a different kind of dynamic scope. I know--it's confusing, but it's how regexes work in Perl 5. `local` sets aside temporarily the value of a package variable within the current static scope. Numbered match variables don't really do that; they hang on to their values within the scope even if control flow for normal dynamic variables would leave and enter the scope. You're probably better off using `grep` for this purpose though. (It suddenly became clear to me after seeing this latest code example.)
In addition to what chromatic says, the core issue is that you should NOT check $1 to see if the match succeeded. You check to see if it succeeded, and THEN use $1. A failed match does not clear $1.
I wouldn't do anything unless the script was not functioning as expected. If it's not broken, don't fix it. 
&gt; set equalprg=perltidy &gt; autocmd FileType perl setlocal equalprg=perltidy this is awesome, thanks!
Thank you for the explanation of how it's a different kind of scope! As far as grep, should I just use it because it's the simpler tool for the job? In general I use regex as much as possible to learn as much as possible :-)
Use `grep` here because it handles the iteration and matching and capturing for you. You still have to write the regex though.
I think the best way to handle this is to *always* use if(... =~ m//) and assign from $1,$2, etc immediately afterwards. It's worked well for me, and I've never yet run into a problem where that pattern didn't work.
1) Unreadable is broken. 2) When your boss requires a change or when a bug you hadn't foreseen arises, it's a lousy time to find out that you don't really know how the code works. And you don't really know *how* the code works with your tests, you just know *that* it works.
The script you link to isn't a script at all but a module or library. You use it to write your own script. I recommend this excellent introduction to Perl: http://qntm.org/files/perl/perl.html 
I'm going off of this [post](http://snapeyluvshermy.livejournal.com/213938.html?thread=1147058#t1147058). I don't know what the hell I'm doing, but something worked enough to get beyond a plain "ppm install failed: can't find any package that provides WWW::FetchStory". Now, when I type "ppm install WWW::FetchStory" in command prompt, I get: "syncing site PPM database with .packlists...done" "syncing perl PPM database with .packlists....done" THEN "ppm install failed: can't find any package that provides WWW::FetchStory" I don't know what to do next. D:
The ActiveState repository doesn't mirror CPAN. While the ActiveState repository does have a lot of the same packages it doesn't have this one. There is no automatic install:( The best way I can think of for you to get this installed is use Cygwin: http://www.cygwin.com/ Cygwin is a Unix-like environment for Windows. It comes with traditional Perl and you would be able to install the library directly from CPAN. That being said it is still a really complex process and you will probably bang your head against your keyboard numerous times before getting it to work. Note that while I think Cygwin would be an easier path you can technically download a CPAN module and manually install it but that requires you to have some other tools like a compilier, linker, make and so on. Those tools are easily installed via Cygwin which is why I recommended it.
Oh crap, and that comment on lj made this sound so simple.. Well, I have most of the night to spend on this. Thanks for pointing me in the right direction :)!
Actually, these days you [can](http://www.activestate.com/blog/2010/10/how-install-cpan-modules-activeperl) use CPAN with ActiveState with the `cpan` command. It should automatically download and install MinGW so you'll have a compiler and 'make'. 
Why should it be so fucking hard to download a simple text fils from CPAN? Every software company on the web can download folders full of files of all sorts with a simple click. But apparently the perl gurus can't or won't make it simple.
It's not hard. ActivePerl is what you use when you want to pay for support. The proper solution to using perl on Windows is [Strawberry Perl](http://strawberryperl.com/). From their [very own web page](http://strawberryperl.com/support.html): &gt; Strawberry Perl is a community-driven Open Source project, which means that most of the people directly involved have jobs, families and/or other commitments beyond just Strawberry. &gt; [... ] &gt; **Throwing Money at Your Problem** &gt; In situations where you simply MUST have commercial support for operations or policy reasons (you know who you are) Strawberry may not be your best option. While their ActivePerl distribution may not have CPAN support out the box, ActiveState does offers support on commercial terms and can be modified to do most things that Strawberry can, albeit sometimes with some effort. &gt; This may change in future, but remains true for the present. &gt; If the fact that Strawberry isn't released by a company worries you, remember that 100,000+ people and companies trust our releases, including Larry Wall and most of the top CPAN authors. Or, tl;dr: &gt; *But apparently the perl gurus can't or won't make it simple.* Yes they did. 
If you need Perl on Windows, [Strawberry Perl](http://strawberryperl.com/) is the proper solution. Strawberry has proper CPAN support. From [their wiki](http://win32.perl.org/wiki/index.php?title=Strawberry_Perl), it includes out of the box: * Perl 5.12 * Mingw GCC C/C++ compiler * Dmake "make" tool * ExtUtils::CBuilder and ExtUtils::ParseXS * Bundle::CPAN (including Perl modules that largely eliminate the need for external helper programs like gzip and tar) * Bundle::LWP (providing more reliable http CPAN repository support) * XML::Parser and XML::LibXML, enabling most CPAN XML modules * DBI and DBD drivers for SQLite, ODBC, MySQL and Postgres * Additional minor modules to enhance the stability of Win32
LOL, oh gosh, I could have used this post about an hour and a half ago. Cross eyed with frustration, I gave up Cygwin and downloaded Strawberry Perl. I ran into a fresh problem though, as I tried to dl the specific module from CPAN. Something about the building and testing of XML-LibXML-1.88 failing. It abruptly "bailed out the installation" at that point. Any ideas as to why that is happening? 
I am on ActivePerl on Windows, and all i had to do was: `cpan WWW::FetchStory` The result was this: https://gist.github.com/46b3b4c35891c6a6fb5b
PPM is only a packager for CPAN stuff. You use it as a fallback for when CPAN isn't able to install things and mainly useful for stuff that needs complex binary dependencies to compile, like DBD::mysql.
That is correct and on perl.com there is a much shorter guide: http://www.perl.com/pub/2011/08/using-cpan-on-win32-activeperl.html
It is actually made stupidly simple by the perl gurus to download simple text files from CPAN: http://api.metacpan.org/source/RUBYKAT/WWW-FetchStory-0.1601/lib/WWW/FetchStory.pm
I'd guess XML::LibXML 1.88 is having issues compiling on windows. Said module are bindings to the "libxml2" library, which is a GNOME-originating thing. It's amazingly portable, and I'm sure there are some windows binaries out there. Try looking at http://xmlsoft.org/ first. I don't compile things on windows, so I'm useless there. IRC (maybe not this late at night) would probably be a good place to ask for help, too.
Considering that at this point in time the Strawberry page [actively lies](http://www.perl.com/pub/2011/08/using-cpan-on-win32-activeperl.html), despite having that pointed out repeatedly, you may want to rethink your suggestion.
Meanwhile ActivePerl offers an actual and unmangled Perl distribution with full cpan support, ability to install all those things, AND Perl 5.14. Also: &gt; Additional minor modules to enhance the stability of Win32 Haha, which ones would that be? I couldn't think of *anything* that fits that bill.
While Cygwin is an excellent companion tool to Perl, due to making available tools like tar, gzip, wget, grep and many more; i have to strongly advise against using its Perl, because it won't interoperate as nicely with other programs on the system, thanks to being tied to Cygwin.
At this point you go back to ActivePerl, since dealing with binary dependencies is not something for newbies. You'll want to install that module via PPM(it's available on there), and everything else through cpan.
I entered "cpan WWW::FetchStory" into the command prompt, and I continue to get LibXML.xs errors of some sort. Pardon me for being so dense, but I'm absolutely confused now. 
Do this first: `ppm install XML::LibXML` This will install the binary package of XML::LibXML, so the other dependencies can install via cpan.
I installed that, and then tried the module again. It worked!! I was ready to tear my hair out, having been at this for almost six hours. Thank you so much for all of your help!
Glad to hear. Hope this knowledge will also help you next time. :)
It's a learning curve. It'd probably have been much simpler if you used Linux/OS X/*nix. May I suggest jumping ship? ;)
Meh. ActivePerl works perfectly fine, although it lacks a C compiler by default, but you can install MinGW, just like the one that comes with Strawberry Perl. Oh, and you need a decent make utility too, either dmake, or nmake, from Microsoft.
Strawberry Perl includes a PPM utility.
Actually, you don't need to do any of that. ActivePerl identifies your available tools and installs MinGW and dmake automatically, if needed, when you run cpan. :)
Now that's what I call progress... It didn't do that yet, when I last installed ActivePerl. Well, it's been a while.
**ACHIEVEMENT UNLOCKED!!!**
Ah, ok, that makes sense. I had wondered if I could somehow use -g on an array, and I suppose grep is more to the point!
Strawberry Perl includes XML::LibXML. I just tested 1.88, it passes tests on both 5.12.3 and 5.14.0. It is possible that something was wrong with your Strawberry install.
Awesome. I didn't know about Strawberry Perl. Thanks for the tip!
&gt;Considering that at this point in time the Strawberry page [1] actively lies... That may be going a bit too far. Strictly speaking, ActivePerl does not have MinGW installed by default or 'out of the box'. As far as I know, you have to PPM install MinGW. Does the PPM version of MinGW still come with GCC-3.4.5, or has that been updated? ActivePerl does have default support for compilation using the ancient MSVC6 compiler using nmake (I think that the WinDDK can also be used since it can also link to the msvcrt.dll). I used to compile modules that I needed to update using a version of that that came on a book + CD I found in a second hand shop. It worked fine until I got a batch of copyright messages during compilation telling me what I could not do. That is when I switched to Strawberry Perl.
Sweet! &gt;exited with 0 I want that as my epitaph.
&gt;It is possible that something was wrong with your Strawberry install. I think that the versions of the dynamic (libxml2-2.dll) and the static lib (libxml2.a) did not match on earlier versions of Strawberry Perl. That was enough to cause test failure. Compiled against libxml2 version: 20630 Running libxml2 version: 20703 DO NOT REPORT THIS FAILURE: Your setup of library paths is incorrect!
&gt; ActivePerl does not have MinGW installed by default or 'out of the box'. As far as I know, you have to PPM install MinGW. No you don't. As i pointed out elsewhere and has been posted on perl.com, it automatically installs a make and MinGW when you run cpan and it detects no make or compiler present. This has been the state for a few years now and i have made this known to the Strawberry people on several occasions. You could call it laziness if you were to be nice about it, but i'm trending more to the cynical side. And as to your question, with ActivePerl's 5.12 release it's still 3.4.5, but i think they upgraded it for later releases.
&gt;it automatically installs a make and MinGW when you run cpan and it detects no make or compiler present. This has been the state for a few years now That's good to know. It has been a few years since I last tried it. &gt;You could call it laziness if you were to be nice about it, but i'm trending more to the cynical side. This is far more likely due to the decentralized, voluntary nature of the Strawberry project than laziness or ill motive. I have found Perlists to be very helpful and forthright (you might want to try your luck on comp.lang.lisp or the outrageous lunatics that congregate on the Eiffel mailing lists). I agree that it ought to be changed. &gt;And as to your question, with ActivePerl's 5.12 release it's still 3.4.5, but i think they upgraded it for later releases. That has been a sticking point for me. I would prefer a Perl version integrated with a more modern compiler, though have found that dmake will use the first GCC compiler it finds on the path, even with ActivePerl. Mostly this can work without problems. Incidentally, any idea why so many 'nix to Windows ports only compile with antediluvian GCC-2.95.3?
&gt; That has been a sticking point for me. I would prefer a Perl version integrated with a more modern compiler, though have found that dmake will use the first GCC compiler it finds on the path, even with ActivePerl. Mostly this can work without problems. &gt; &gt; Incidentally, any idea why so many 'nix to Windows ports only compile with antediluvian GCC-2.95.3? I have no idea what you mean. Most anything XS from CPAN compiles fine for me, and the only things that really give me issues are packages that have outside dependencies, like DBD::mysql or ZeroMQ.
In general, the newer compilers should produce better optimized, more secure executables and take advantage of newer CPUs.
Great post, though I disagree with chromatic's main point (spelled out in the 2nd comment on his blog). I think Perl 6 could be popular for things that Perl 5 is good at, without having to also be sufficiently good at something "as yet unknown". The reason is because I think plenty of people are not very interested in (or looking to jump ship from) Perl 5, Python, Ruby, and PHP. Perl 6 could be a fine new (but familiar) language to try out -- once there's a usable release. I think the biggest challenge Perl 6 will face very soon is to simply not scare away curious prospective users. The Synopses are too dense for most of us to absorb, and the Rosetta Code examples use too many new features which are golfed down and combined in novel ways. 
What would attract new users though? Perl 6 has little documentation, few libraries, and no reasonably complete or usable implementations.
&gt; no reasonably complete or usable implementations. Is this why I have a hell of a time finding and running a Perl6 interpreters? Probably my biggest frustration is all of the different interpreters available for Perl6. sudo apt-get install perl and I know what I'm getting every time (or yum, or pacman, or etc. ), for Windows there are a couple of different versions, but it's not an overly complicated choice. Perl6 on the other hand is not an easy choice, and due to a lack of documentation it is not easy to find information to ease the selection. That's just my $0.02.
Perl 6 is a specification, such that any implementation which passes the test suite can bear the name "Perl 6". I know Ubuntu and Debian and Fedora package Rakudo, but I don't know about any of the other implementations.
&gt; Perl 6 is a specification, such that any implementation which passes the test suite can bear the name "Perl 6". So why such the drastic change in mantra? And then, which version do I pick, the version written in LISP or the version written in Whitespace? (I've never heard of a Perl6 interpreter written in whitespace, but IIRC there is one written in LISP). Maybe I'm missing something, but Perl6 being a specification instead of a language seems to be a detriment and a hindrance to the growth of the community. &gt; I know Ubuntu and Debian and Fedora package Rakudo, but I don't know about any of the other implementations. As far as I can tell, Ubuntu does not have a Rakudo package available from the repositories. There is a version available for [Debian](http://ddumont.wordpress.com/2011/07/24/perl6-aka-rakudo-is-available-on-debian/), but according to the announcement, the only way to get Perl6 on Ubuntu is compile from source. However, there are [packages](http://ddumont.wordpress.com/2011/07/24/perl6-aka-rakudo-is-available-on-debian/) available for most other distros. I have the unique advantage of having many different distributions available for my testing/use, so I'll probably end up installing it on one of those, but, being that Ubuntu is one of the most popular distros, and there is no available package, I think this hurts the Perl6 community. I realize that the rakudo guys are all volunteers, so maybe this is coming soon. I don't know. Am I crazy?
In that situation I would inform the boss beforehand that the code was unreadable, and I would like to make the effort to rewrite it. I would tell the boss because I think it is likely to take some time, and also there is a possibility of breaking something which is working. I only have a small amount of experience of this kind of thing though. If you have a lot of experience of this kind of situation, it would be interesting to hear about it. 
&gt; What would attract new users though? Sorry. I should have been more clear. I think new users are *already* being attracted to Perl 6. Perl 6 does, after all, look pretty amazing. Attracting new people to check it out is *not* one of Perl 6's problems. People already come around to take a look. The problem is (I think) that after trying to digest the Synopses and make sense of the Rosetta Code examples, they get scared off. 
&gt; So why such the drastic change in mantra? The wisdom of hindsight, perhaps. Perl 5 has a huge problem in that there's only one implementation and the specification is "Whatever the implementation does, if we think we want to support it." &gt; I realize that the rakudo guys are all volunteers... Some of them have modest grants for parts of the project. &gt; ... maybe this is coming soon. If someone does it, sure. Most of the recommendations I've seen are to run more recent versions than those that make it into the repositories.
As far as i know there's only one massive niche left: A dynamic language with sane threading. If they implemented that they'd be guaranteed to gain new users.
Sweet. The way mojoliciuos is coming along with new features and modern perl bonanza for the web is just amazing.
There is so much great stuff going on in the Perl world. Moose (Mouse, Moo, Mo), Plack, Mojolicious and you have all these great test frameworks and CPAN Testers to get the most out of it. We are living in great times.
Refactoring old code has been a part of *every* programming job I've had, and I've been doing this for over a decade. If you say making changes will take longer because you haven't tried to understand your existing codebase (which is what reformatting for readability will help with), well, it might not get you fired, but it'll probably look bad come your next performance review. I'm surprised you sing the praises of version control and test suites, but don't have much faith in regression testing, which is what you'll need to do whenever you change code. If running perltidy breaks existing code, go back to the previous version and hack it from there. If it doesn't, you have no excuse not to make the code more readable.
Yes, that's a possibility. It hasn't been a focus of the spec or any implementation, to my knowledge. I don't expect to see it soon.
shagadelic!
Awesome!
Reading back over this, the point which seems to have got lost is that the original post was from someone who said &gt; Note that I'm also very new to Perl itself. I've been responding to the question under that assumption, which is why I have repeatedly suggested not altering anything at all, especially not with auto-formatting tools, but instead writing tests to check that the scripts do what they are supposed to. 
&gt;A dynamic language with sane threading That's what Go wants to "feel like" [http://golang.org/](http://golang.org/)
What are the advantages over Catalyst?
keep it goin' guys. revitalize perl so i can stop having to write php for money! i feel so dirty!
Less boilerplate, less dependencies, more useful stuff built in.
I believe we all know threads are generally hard, but is there a Perl specific problem with threads? I mean, are threads in Perl harder than in some other languages? 
Threads in Perl clone the entire process at their point of creation because they were implemented exclusively to provide fork emulation on windows. This means they're a massive memory drain unless created ahead of time. And even then quite a lot of CPAN modules are not thread-safe, and the implementation itself is not very solid either. Threaded Perl code that works fine on windows may blow up on linux and vice versa.
The name is correct: according to its documentation, it only writes the OOXML format. I fail to see how this can be a true replacement form `Spreadsheet::WriteExcel`.
It's not. It can't be. But because XLSX is becoming more and more widespread, the need for backward compatible XLS files is getting smaller all the time.
Plus Excel 2003 can be made to read .xlsx files
Please explain how. I might need this for a client, and then abandon the old module for the new one. 
Isn't the fact that "perl threads" are simply cloned processes have a side effect that data isn't shared unless explicitly marked as shared? Doesn't this make all modules "thread safe" by default?
The old module is still around in case writing xls files is part of the requirement. I guess bug fixes won't be pushed to it any more so if you're satisfied with the current feature set - like I am - then it should be fine.
That part is only true for *pure* perl code, as soon as you go XS all bets are off.
From what i can see it sort of does that right, but honestly: The syntax makes me retch. Semicolons or bust. I can live without sigils, but not that.
Nothing comes to mind---but then again this is not something I'd do. Google Edward Tufte +Powerpoint to see why...
I just googled those terms and found "The Cognitive Style of Powerpoint" which I assume is what you were referring to. I didn't buy it but it looks like it's talking about what's wrong with using presentation slides to discuss a topic in a gathering. Just to give you some context, I won't be using this to generate anything even close to that. I wrote a scorekeeping system for a national academic tournament from which I currently return an Excel spreadsheet at the end that lists all the scores in each competition so the organizers can create a presentation to announce the winners. I hope to give them the option to download a standardized awards ceremony presentation in addition to the excel spreadsheet so their work is cut down even further specially towards the end of a tournament when things are really hectic. I've been exploring some html5 presentation formats - that might be a way out for me without going to Powerpoint but still maintaining the programmatic generation of a presentation.
Reposting from the entry: After having chatted with ak on his blog entry the situation is now more clear: - he hates event-based programming, which would be exactly the correct solution for this sort of thing and which perl makes easy - the next closest thing is using threads, which perl makes hard So he opted for Go because it allows him to put in zero effort, throw up a bunch of threads and have the network stuff be in its own thread. It still operates blocking in there, which means that if one request gets jammed, all other requests jam too; but that's "good enough", since the UI thread is separate and remains responsive instead of locking up.
It's API compatible, so it'd be one them to do whatever is implied from switching their workflow from XLS to XLSX. So you could create a derived class that uses Spreadsheet::WriteExcel for XLS and falls to Excel::Writer::XLSX for XLSX. Offer only new features for XLSX, and eventually everyone will be doing it. If you need to, also, you can create a Excel::Writer::XLS wrapper for Spreadsheet::WriteExcel.
So its a matter of preference rather than actual limitations in the language. Gotcha. Now he needs to stop blaming the language.
Well, he has a point. Perl aims to make hard things easy and impossible things hard, but possible. When it comes to threads though, Perl makes it a complete mess. On the other hand, Go is the *only* dynamic language i know of that gets it right. (Erlang possibly too, but it aims for cellphones.)
Microsoft created add-on for Office 2003 to read files from 2007.
Kudos to John McNamara. I have used the Spreadsheet::WriteExcel module and liked it a bunch. John was quick to help when I didn't understand something about the module as well. Look forward to using the XLSX module now. 
They're a massive memory drain *even when* created ahead of time; just try to spin up a couple of hundred threads and see what happens to your free memory. Trying to create them on-demand is (as I have sadly learnt the hard way) just a complete and utter waste of time, the cost of the interpreter clone is completely prohibitive. I'm sad that threads in perl don't work better, because it really limits the usefulness of the language as a scalable text-processing engine; basically if you hit the limits of a single core then you have to either - use threads and deal with all the crap that they bring (I'm looking at you, memory leak in threads::shared on RHEL5.x. And you, insane difficulty in handing off a filehandle to another thread), - use processes and IPC::Shared for co-operation (IPC::SysV if you're a masochist), with all the hell of ipcs and ipcrm when something goes wrong - switch to another language I think perl would potentially reach a new audience if it parallelised better. No idea how to change the design to enable that, though.
I mostly agree, especially with your conclusion, but i have to comment on one thing: You're not supposed to have hundred threads (unless you actually DO have 100 cores). Threads are a tool for making use of more CPU inside the same process when your task is CPU-bound. When your task actually requires more than 3-4 threads you're likely doing something extraordinary or haven't realized yet that you're actually IO-bound and should be using events.
You could make the argument that in almost every situation I've encountered, Perl provides a better solution that "Use threads!". Lots of programmers, though, are stuck on the idea that threading is a solution to a problem, and not a means to a solution to a problem. With Perl, threads are a complete mess because no one cares about threads because they're not required. 
I've been in situations where they *would* have been the solution, specifically rendering a world in OpenGL, pulling data from another process in realtime and on top of that accepting user input. I did use Coro to implement this, but it was neither pretty (the code) nor very performant (though still usable). In that case i'm entirely CPU-bound and there was no way of spreading those tasks across multiple processes, so threads would've been the correct solution. You're right though, most developers reach for them reflexively in all situations, even though they're not the right solution. There's a very good reason for that however: They're dead simple to use and think about, compared to event systems. When you're using an event system you have to basically implement a multi-tasking OS on your own. With threads you just have x things doing their own thing, with each of them occasionally trying to poke one of the others and all the hard work being done by the operating system itself.
So wouldn't this be a good time to make it version 1.0?
Fork() itself is really cheap in linux this days, starting up the perl runtime is not so cheap. I have written a [whole web framework](http://werc.cat-v.org/) in the [rc shell](http://rc.cat-v.org) which makes dozens of forks per request (calling grep, sed, awk, etc.), and it is much faster than php and perl systems using fcgi. One can use markdown.pl for formatting with werc, and when doing so, it takes more time than the dozens of calls to grep/sed/awk/... Python's startup performance is just as bad or worse, and [Ruby is plain ridiculous](http://harmful.cat-v.org/software/ruby/).
&gt; It still operates blocking in there, which means that if one request gets jammed, all other requests jam too It is trivial to start a new goroutine for each request, that way while the individual requests might block, they would only block their own goroutine. And goroutines are not threads, they are only multiplexed to threads as needed, they are extremely cheap, basically allocating a 4kb stack and that is it, you can start hundreds of thousands of them without problem.
Note that Go doesn't "use threads", goroutines are *not* threads. They more similar to coroutines and are much cheaper than threads.
&gt; ... starting up the perl runtime is not so cheap. I had in mind `fork` within a running Perl 5 program, which ought to skip starting up the runtime.
You could write it to PDF. or latex and then convert to nice PDF presentation
I'd thought of that but part of what I wanted to add were interactive reveals on a page i.e. reveal 3rd place winner when a key is pressed, then 2nd place winner and then 1st place winner. flex.js seems to be really good for everything I need.
[The download page](http://www.microsoft.com/download/en/details.aspx?id=3) of the compatibility pack for Microsoft Office
There are classes in latex (Prosper, Beamer etc) that will let you do that.
Interesting. Time to do some more googling about these :-) Thanks!
To paraphrase the reporter who made up the famous quote for Mallory (see Everest) 'Because it's there...' Seriously though, the ideas that are (or have been) expressed in the development of Perl 6 are more than worth the time to wrap your head around. If on the other hand all you are looking for is something to add to your resume as you hunt for a job, then keep your investigation low-key and stick to Perl 5 for the most part.
Has anyone implemented this yet so that I can bookmark it?
I love the ideas behind perl 6, and the language has some amazing things in it, but the implementations are all quite limited right now. Perl is in a very awkward place right now, with perl 5's arrow syntax being quite different from the "." syntax all the other languages have standardized on, and it's C based implementation being oriented around command line, unix, and single threaded short running applications. It's asynchronous IO is a bit clunky and it's threading, while I've found rather easy to use, seems to cause lots of people trouble. Perl 6's promises to address a lot of 5's issues eventually, it's syntax is much more appropriate for today's programming, but the implementations are all incomplete and still quite a way from being ready for production. From what I understand none of the implementations have touched threading in a meaningful way. To me, learning perl 6 as a way to broaden your programming horizons makes sense, but if you want to actually do anything with it, go for perl 5.
[Chromatic expresses why Perl 6 isn't much use at the moment as a practical language pretty well.](http://www.modernperlbooks.com/mt/2011/08/why-my-side-project-doesnt-use-perl-6.html) That being said, Perl 6 takes all the greatest and best ideas from the popular dynamic languages, tidies them up and puts them all in 1 place for you to play with, and then occasionally introduces bugs to them. If you're looking for community, Perl 5 is still the place to be, and with Moose and Method::Signatures and a few other tools you get a language approaching the futuristic idea's of Perl 6.
learn perl 5 first
The article links to a page on his site: [http://perlhacks.com/search/](http://perlhacks.com/search/) I did a search for "trim" and was confused by the results until I realized the first three were google ads. 
This isn't entirely Perl specific. Threading issues are an issue with just about every dynamic language. It comes with the territory. Check out Python, Ruby, etc, and you'll find that none of them handle threading in a great way. Personally, my feeling is that if you want to improve parallelism, fork() usually does good enough, and if I need increased flexibility from that, message queues make a great IPC tool.
Yes, and no. It's not Perl specific, but it is dynamic language specific. This is why you don't see people writing much multithreaded code in Perl, Python, or Ruby, but you see it a lot in Java and C++.
If you are interested in a useful _language_, learn Perl 5. But if your interest goes beyond that and you're interested in _languages_, Perl 6 is totally amazing and worth learning.
Ooooohh Works in Firefox, not Chrome.
In part, because it's incorporating the best features of all languages, so it's a fast education on CS and languages. Unlike Perl 5, which grew like a weed, Perl 6 has been based on a specification (a series of them). And in part, because you get to be there as a new language is developed from scratch -- some people consider that fascinating. The trade-offs, the process, the priorities, the difficulties, the ingenuity of the really brilliant minds on the project. For example, are you interested in Lisp macros? Grammars? Functional programming? Virtual machines? Compilers? Parsers? That's just some of the stuff going on.
 sub file_get_contents{ my($filename)=@_; open(FILE,$filename) or die("Could not open file $filename for reading because $!\n"); my @str=&lt;FILE&gt;; close FILE; if(wantarray){ chomp(@str); return @str; } return join("",@str); } sub logmsg{ my ($msg,$settings)=@_; $|++; my $file=(caller(1))[1]; $file=fileparse($file)."::"; my $function=(caller(1))[3]; my $dt=DateTime-&gt;now; my $datetime=join(" ",$dt-&gt;ymd,$dt-&gt;hms); print "$datetime $file$function: $msg\n"; $|--; } 
Update: ActiveState's Jan Dubois has applied the fix to the PPM servers, so 4.020 can be installed safely from them; and meanwhile Rob Hoelz has been working on fixing the module repo itself. :)
&gt; Learning something new is often a good thing in and of itself. This is the main reason for why i'd encourage people to look at Perl 6.
My boss likes to use MIME::Lite, maybe this will convince him to use something better. :)
Oh god, I feel sorry for rjbs. Email looks like a bitch to parse. Speaking of the "fixup RFCs" why the hell were they written to clean up the spec, but still allowed the old spec? .... WHY?! (in George Carlin's voice)
An alternative, if somewhat roundabout way, is to create OpenOffice Impress documents using [OpenOffice::OODoc](https://metacpan.org/module/JMGDOC/OpenOffice-OODoc-2.125/OODoc.pod) and then save it as a PPTX file using Impress (or the command line tool unoconv that comes with OpenOffice). [This article](http://www.linuxjournal.com/article/7972?page=0,1) has an example.
I rewatch [another version of this](http://video.google.com/videoplay?docid=70544011835897945950) every few months. I'm super-happy to find one where you can read the slides.
I got "We're sorry, but this video may not be available."
Because when I write my whiz-bang new software on the day the new RFCs come out, it is the only one in the world compliant with that RFC and therefore useless. We have to keep supporting what the rest of the world uses because who knows when they'll get around to upgrading. (Not email related but well known case in point: IE 6. That bastard will never die.)
What the heck is wrong with MIME::Lite, anyway? This is the second time in as many weeks that I've heard this comment. And both times there was a smiley at the end of it. I feel like there's some joke I'm not in on. At [PPW](http://pghpw.org/ppw2011/), a speaker was chided for showing MIME::Lite on one of his slides and invited to come to a later talk on [sending email](http://pghpw.org/ppw2011/talk/3611), presumably to hear about something better. I attended that talk, but I didn't hear any compelling arguments against MIME::Lite. And this rjbs video seems to tell us that it's easy to *send* email that is considered proper. It's the poor saps *receiving* it that have the hard work. MIME::Lite appears to provide a simple way to compose and send properly formatted email messages and has no opinion at all on how we should receive them. So are people just being snarky or is there something actually wrong with MIME::Lite? 
If you do, be warned: Perl 6 has, if possible, even more punctuation than Perl 5. Yeah. More keywords too.
The main issue i was told by RJBS i would encounter had to do with it being unable to properly handle non-ascii data in the headers. Particularly mentioned where problems with From/To names, which are important to me since our business is in germany. The specific issues i encountered when using it was that it provided no sane way to start out with an email stub as a simple multi-line string generated from user data and a template (so the less technical people at my company can configure the From, Subject headers, as well as the content from one simple to read file) and then augment that with system configuration and defaults for unconfigured parts and send it away. Email::Abstract and Email::Sender made this kind of data flow stupidly easy. (Sidenote: Technically the issue is flat out that MIME::Lite doesn't know anything about receiving emails, which is what i'm doing here on an abstract level: Emails are received from the templating engine, then sanitized and padded and sent out to the user.) Another issue i encountered was that testing and configuration were both non-obvious and fairly intrusive. Email::Sender handles that a lot better with its Transports system. Lastly: Due to "few deps"-itis it reinvents many wheels that have been engineered to perfection in other places on CPAN by people who were able to concentrate a lot more on getting that one small thing right. This means that i feel uneasy when using it and am less likely to trust it. In short: It's not that it's bad, it's more that it's not as good as it could be.
This bit: { local *Get::some_feild = { 'some behavior' }; # do something } In the above example, not only have we probably mispelled the subroutine name, but even if their had been a subroutine with that name, we haven't overridden it. These two bugs can be subtle to detect. ...needs more elaboration. Why "haven't [we] overridden it"?
Assigning a malformed hash reference to a glob doesn't override a function. (Yes, it's a subtle bug in the posted code.)
My eyes totally failed to notice the lack of "sub" in front of the {} - thanks!
It took me a few minutes myself.
I've been coding in Perl 6 almost daily for three years now. I feel I've reached the "comfort level" where I read and write in the language with basically no effort at all. Perl 6 allows me to write out a thought with a few powerful symbols, a bit like APL would. But it also allows me to think in big architectural structures, and write modules, classes, roles, and grammars. When I need to, I can easily "upgrade" a piece of code on the brevity-structure spectrum. If there's something Perl 6 clearly does better than Perl 5, it is this. That's the big thing. Then there are several smaller things. I like the built-in grammar support. I like the small syntactic conveniences offered me by smartmatching, junctions, and chained operators. I like how deep the meta-model rabbit hole goes. I like lazy lists and powerful signatures and the distinction between classes, roles, subtypes, and enums. Finally, I really like the community. It hugs trolls and generally treats people with respect and dignity regardless of background and skill level. It has an amazing tendency to turn people's diverse inputs into something constructive.
Perl 6 has more everything. But what matters, really, is this: how will typical code look when written in the language? I feel comfortable writing in either Perl 5 or Perl 6, and the difference isn't *that* great, but on balance, I prefer to rest my eyes on Perl 6 code. Yes, Perl 6 introduces *secondary sigils* (or *twigils*) on top of the existing ones. On the other hand, it also gets rid of almost all punctuation variables that Perl 5 has. Perl 6 also makes a number of parentheses optional that Perl 5 requires. The only syntactic difference between Perl 6 and Moose is that Perl 6 gets rid of that last bit of boilerplate requred in Moose (fatarrow and parentheses) since it plays by the rules of Perl 5 syntax.
Or you could `use File::Slurp` and stop emulating PHP functions...
Well the name was because I wanted to name it what it actually does. The extension? IDK, I didn't like that little .pl hanging of the end. Besides, I make it obvious it's a perl script.
&gt; The book Using Perl 6 is a work in progress. It needs a lot of editing. On the contrary, I've found the book to be pretty well edited. What it needs is more detail and content. &gt; Beyond that, you probably need to scour the Perl 6 specification I don't even want to *guess* at how many printed pages all the Synopses would amount to. Pointing a prospective new user to them is going to end badly. &gt; and trawl through several blog posts. This can be helpful. Which blog posts -- and in what order -- would you suggest a new user start with? 
I have three recommendations, in this order: If you want to pick up idioms and interesting features check out [the Perl 6 advent calendar](http://perl6advent.wordpress.com/). There's a [2009 edition](http://perl6advent.wordpress.com/2009/12/01/perl-6-advent-calendar/) and a [2010 edition](http://perl6advent.wordpress.com/2010/12/25/merry-christmas-2/). If you're coming from a Perl 5 direction, check out Moritz Lenz's [Perl 5 to 6](http://perlgeek.de/blog-en/perl-5-to-6/) series. Perl 6 maintains a certain "Perlishness" but has many new concepts. These are explained here. I'm pretty sure the posts are useful for people from other programming language traditions as well. If you're just starting out with programming or otherwise want a from-the-start introduction to Perl 6, check out [a month's worth of blog posts](http://strangelyconsistent.org/blog/june-1-2011-input-and-output) that I wrote back in June this year, bootstrapping from I/O and variables up to writing an object-oriented text adventure game. (Link is to the first post. The rest of the posts can be found in the [archives](http://strangelyconsistent.org/blog/list-of-posts).)
Thanks for the tip! I like!
You also make reference to a `loadConfig` that isn't defined anywhere. Get used to [using CPAN](https://metacpan.org/) instead of doing everything from scratch. You probably could make that script 60-70% shorter by using existing modules - that's 60-70% less effort on your part.
I guess? I didn't really look for markov models or viterbi in CPAN but I'd wager it's in there. loadConfig isn't necessary in the script; it can be removed. Thanks for catching that.
How do I use this script? lets say i wana grab something from the subreddit /r/funny. Could you show an example?
This was a real disappointment The perl example in the research paper was a poor example, the sample too small, the margin of error larger than the differences per language - it doesn't really tell us anything useful at all :(
This study is entirely useless because they invalidated themselves from the start by providing the worst possible Perl examples they could. I quote the salient parts: &gt; participants were given a code sample worksheet for the particular language group they were in. The general idea of the experiment is to give novice users code samples similarly to if a participant was learning to program from home on the Internet. &gt; &gt; This code shows one of the code samples provided to participants. $x = &amp;z(1, 100, 3); sub z{ $a = $ [0]; $b = $ [1]; $c = $ [2]; $d = 0.0; $e = 0.0; for ($i = $a; $i &lt;= $b; $i++){ if ($i % $c == 0) { $d = $d + 1; } else { $e = $e + 1; } } if ($d &gt; $e) { $d; } else { $e; } } **This ridiculous thing was supposed to help their test subjects learn Perl.** If all their perl samples looked like that it should not be a surprise to *anyone* that their test subjects were entirely confounded. What is missing in that paper is a description of how they actually sourced their code samples, as well as a list of *all* code samples provided.
BTW, that sample is nearly a direct translation from C. So "C users were unable to write programs more accurately than those using a language designed by chance." could have been an equally valid conclusion ...
Learn Perl? Hell no. I'm going to use this subroutine next time I interview a potential senior developer. It's a whole lot uglier and more complex than the test code we use now. "What does this function do. What possible gotchas exist?" etc etc... I'd have to do some research into any possible side-effects from the float variables. Am I going to get a rounding error? I don't think I will, but I don't know it without thinking about it. This is a great example of an attempt to scare programmers away from perl, and why we're having trouble hiring perl developers where I work. By the way, anyone in the Boston area looking for a middle-of-the-road dev job? We don't find a dozen good developers, we might become a rails shop. (Note: I am neither executive nor a hiring manager, just not in favor of our entire company migrating to perl)
Nice perspective on it! :D As for the dev thing: Tried jobs.perl.org and offered relocation?
good place to start: http://perldoc.perl.org/perlretut.html I learned by reading through Learning Perl: [Learning Perl @ Google Books](http://books.google.com/books?id=va1PSgaO4xIC&amp;lpg=PR15&amp;ots=BO4cJvf3Y_&amp;dq=learning%20perl%20schwartz&amp;pg=PR4#v=onepage&amp;q&amp;f=false)
I'm not asking "**Where?**", but "**How?**" Please actually click the link and read the post to see what kind of thing i'm looking for. :)
No, we haven't done either of those thing. We use headhunters and networking. No, I don't know why :) We're a little too cheap to offer relocation here, too. If I were in Hiring, I'd suggest changing that, but I sit and wait and hope we can double our staff before the execs come down and say "rails is hip, so we can get more entry level people willing to learn it!" Ugh. Don't get me wrong, I'd drop DBIx::Class for something cleaner in a heartbeat, but Catalyst is a dream come true vs Rails
I was actually frustrated at this in the beginning as well. It seemed most perl information was aimed at people with a background in programming who were looking to mix in some perl into their folds. I found the most effective way to do it was to come up with different project ideas and begin creating them.
What did you search for when you began? Where did you search? That's the kind of thing i'm looking for because i have a sinking feeling that the best-performing search venues result in the worst information.
One possible solution is: 1. Go to CPAN. 2. Find something interesting. 3. Supply patches. 4. Repeat as desired.
Well, if you really want to be cheap, you could try searching the metacpan api to find people in Boston. :)
My favourite suggestion, in the vein of robkinyon's suggestion is: Go to http://analysis.cpantesters.org , analyze the things you see and try to send bug tickets with RT and/or provide patches if you think you can resolve the issue. Also, make it a point to hang out on irc.perl.org
I would try things like, "How to blah blah with perl" and then use that as a framework to make my own tools. For example, "How to print contents of a directory with perl" "How to open up files with perl" "How to change files with perl".
Alright, thanks for the info. That gives similar results to "perl tutorial". :)
Yeah, I love how when you do `perldoc $sth` it so often says something to the effect of: &gt;... this works sort of like "x" in C, but users of Lisp may be more familiar with the "q" construct... The behaviour of these parameters was chosen to mimic the tool of the same name found on vax systems between 1977 and 1985. Oh, ok. So, I guess I'll just go learn C and Lisp and see if I can find some vax manuals at a garage sale so I can finish my little Perl script. :(
Good luck and keep it up. If you use Perl regularly, your knowledge begins to snowball. 
Some of us occasionally stumble across historical curiosities in the documentation and try to improve matters. There's a lot of documentation.
&gt; Some of us ...
I love the way they show syntax with extra brackets, commas, parenthesis and any other punctuation that confuses the hell out of a reader.
Yeah, once I noticed they seemed to follow a convention, reading man pages got *a lot* easier. When a friend pointed out such a thing as [BNF](http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form), then it all started to make sense.
I appreciate you looking into this. I am always disappointed by my results whenever I use Google to search for Perl-related terms. I'm sorry, I wish I could remember how I transitioned to Modern Perl sources. I think I found a list of "recommended Perl blogs" or some such thing on either stackoverflow or /r/perl. EDIT: I should add that I originally learned Perl by buying the Camel and PBP, not by searching for online tutorials.
I usually search the terms "free perl books" and "best OR highest rated perl books". I usually find a public domain/free to read legal copy of a decent e-book.
I'm in the same situation. I know where all the proper learning material is, but cannot remember what i looked at back then. Luckily my guess at "perl tutorials" being the most used one seems to be correct. How did you find those books?
It was years ago, but I probably just searched for "perl books". Even given the state of Perl search results, I'm sure the Camel came up early and often. I might have found PBP by the same method, or even by browsing the O'Reilly site.
Perl reference performs slightly better than perl learn, but still not even half as good as perl tutorial. Good point though. :)
Thanks for pointing out "perl books", the first hit there is really something where Modern Perl should be added!
What would that do?
If you want to help with my Logwatch replacement, just shoot me a PM. 
And for the dear redditors: Teal deer: This shit needs fixed: http://www.google.de/search?q=perl+tutorial
What do you not like about DBIx::Class?
I explained that in the post. It's not because it's a "good search term" (it obviously is not), it's because: [**That's what most people search for.**](http://blogs.perl.org/users/mithaldu/2011/10/how-do-newbies-find-perl-learning-materials-online.html) If a newbie goes "Well i searched for Perl tutorials and found only crap!", then we can't tell him "That's your fault, you should've searched for 'XYZ'." We have to take note and make sure he finds what he needs when he does what comes naturally.
And, suddenly, all those weird remarks by perl newbies over the years become pretty clear.
As i mentioned elsewhere: What people *should* search for is immaterial. For us in the perl community, only what people *do* search for counts.
I looked at Google Trends data and at many different possible search terms, i mentioned that in the post and described it and asked for suggestions in the previous post. The world at large prefers to use "perl tutorial" as search term. That is a fact and nothing leads around that, unless you can show me one that's used more often.
&gt; You're still assuming that people search only on the term "perl tutorial". I'm assuming the worst people and experiments have proven me right. I don't remember who, but one of the internet giants once did experiments in seeing how page load times affected user bounces. Turns out that even miniscule changes, of .1 seconds, cause big effects on the bounce rates. Similarly i assume that many people will try once, find crap and give up instead of digging more. And no, telling the newbie "You're wrong, search right!" is useless. We need to fix that. As for the cruft: I'm fairly sure it's there because there are no serious contenders. Gabo Szabor's site has managed to get up fairly quickly and it's really new.
Does anyone want to create a /r/learnperl subreddit to show them how it's really done? I think I've known Perl longer than Python but I know Python better and have done more challenging things with Python just because it was easier to learn.
You're still trying to tell people "You're searching wrong!"
I don't think an obscure sub-reddit would reach any appreciable audience. :(
&gt; Real coders I'm aiming at people in general here. You know, those people who go around yelling how perl is old and crufty because that's what they saw when they once spent 2 minutes looking at tutorials.
&gt; in this case it is entirely reasonable for me to do so. It is never appropiate to tell someone who has no previous guidance of any kind that they carry any fault due to their choice in venue of search for information. &gt; Your assumption ... that someone should find what they want ... on the first try, **no matter what search term they use** I never made or implied that assumption, or else i would have made a list of all bad search terms and their results along with suggestions for what they should return. I specifically chose the one indicated as being the natural search term. &gt; Big of ya. A person having such greatness as to want to punish the seeker requires even more greatness of another.
You consider this in too small a scope.
*Again, you seem to think that people who want to learn Perl are so incredibly stupid that they will use* one single search term *in their effort to do so.* That's quite a mischaracterization. I interpret mithaldu's comments as a call to improve the situation no matter how many search terms novices use.
Cheers. :)
&gt; It is reasonable to assume that someone who actually wants to learn Perl will try a second search term. Why? How in the world do you expect someone who does not know Perl to be able to evaluate a tutorial and say "Wow, this is an awful tutorial! I should try a different search term to find a better tutorial!" Remember, we are talking about people *who do not know Perl*. I'm glad to hear that you know motivated novices who have great research skills. In my experience, such enlightened folks are the minority.
&gt; all the others in mithaldu's graph work excellently Yeah, except they don't. The only search term that generates even remotely useful results is "learn perl" and guess what, that's searched for by only 10% of the people who search for "perl tutorial". The others may not return eye-gougingly terrible results, but they don't generate anywhere near modern results either. They hover around 2002 in material age.
One thing that might help would be to put a link to [perlintro](http://perldoc.perl.org/perlintro.html) right up at the top of the [main tutorials page](http://perldoc.perl.org/index-tutorials.html). Have it be the first one, offset from the other tutorials. 
Man, i've been getting paid to do perl for quite some time now and i never even knew about that thing. It's neat. :D
I wrote a book called [Modern Perl](http://onyxneon.com/books/modern_perl/index.html) which may be helpful. You can download electronic versions for free.
The way it does unexpectedly bad things? It's too *thin* an ORM for my liking. Two best examples: 1. Ordered subselect. Be easy as pie to deal with MSSQL's limitation on this for most queries I use. Every other ORM I've used has no such problems. I don't care that MSSQL doesn't handle them. The ORM should. 2. Query Chaining. I mean this: my @ids = (1,2,3,4,5); my $foo = $c-&gt;model("BLAHBLAH::Table")-&gt;search({ id =&gt; @ids }); my $test = $foo-&gt;all(); #this works my $bar = $foo-&gt;search({},{join =&gt; relationship}); #this appears to work. $bar-&gt;all(); #KABOOM. SQL error because 'id' has become ambiguous. Every other ORM under the sun knows the 'id' referenced by foo was unambiguous at the time, and properly handles the scope-change of later adding the join. Further, this style of programming is not explicitly frowned upon anywhere in the DBIx::Class documentation. I have to deal with one of those two problems at least once a week, especially because we try to provide (or expect) filtered data through certain model methods. Chained searches are very common in our code structure, with Resultset methods being used for complicated filtering and joined into Result methods to resolve. By the way, the only thing I had more than this is the correct way to fix it. The search needs to use "me.id" as the key, instead of "id". That. Is. A. Hack... and too hacky for "modern" perl, considering DBIx::Class is practically the default DB engine for Catalyst.
&gt; Seriously, if a wannabe coder tries once to find Perl information, and gives up after the first try, the fact is that that wannabe coder does not really want to find the information. But that isn't the problem. The problem is, the wannabe programmer isn't searching and not finding; they're searching and finding *the wrong thing*. They're not giving up; they're going on to the next step, in good faith that google has given them the most relevant results.
Network Programming in Perl by L D Stein
There's r/simpleios which is dedicated to introducing people to programming for iOS. It's worth a try if people want to put the effort into writing or linking to useful tutorials. 
Thats pretty funny I just downloaded your book a few days ago. I'll try that one.
I was wondering if you know what was the best way to program for cricket, cacti and rrdtool or if it was just personal preference. 
Well first off, I hope you know how to use git (or can at least follow tutorials for basic git usage). The project is hosted [here](https://github.com/imMute/LogReporter) on github. It's still really alpha quality, but feel free to poke around with it.
I haven't used any of those; wish I could help.
oh it's alright. From what I've read you have to use perl with cricket. For rrd tools i can use perl, lua, python and ruby so I'm just trying to figure out which one is the best for it. Thanks for you help though.
It's not just the tutorials - the entire perl documentation is a foul kludge, with multiple identically named files from different eras in different folders, and huge files treating separate little details with no organization. Maybe the problem is with the Active Perl distro I use. I've spent weeks just trying to organize the documentation. And don't even ask about trying to use Tk or Tkx, with some of the tutorials referring to programs which no longer exist, and giving examples which won't run. It wasn't till I ponied up for Larry's "Programming Perl" that I got some of it together.
It's good, but even that says "Exactly like C" when describing for loops. What about people who've never used C ? Maybe fair enough since most languages do it "Exactly like C" too?
 Reddit_Image_Scraper funny pics it'll create both 'funny' and 'pics' subdirs in your cwd.
So as newbie looking to learn perl, what are some good suggestions?
[Modern Perl](http://onyxneon.com/books/modern_perl/) should be your first step. :)
Thanks =) 
You should have linked instead to the ranking page: http://cpants.charsbar.org/highscores/many
That's a mail spam script.
Like I said, someone last December managed to upload it to my cgi-bin. It looks like somone got access to the web-based account management control panel for my account and used it to upload this file and add a few redirects. And I agree: to not even have the decency to indent properly and comment when hacking my account is the height of rudeness...
So is it to relay through my SMTP? Is that the point?
And it phones home by doing a specific lookup via a specific DNS server, possibly one they control. They can skim their logs on that end to build a list of known-compromised targets for later use.
Thanks very much for looking at that. I already reset my password periodically, so I think it's up to my hosting company now... It was the, "We_do_not_delete_anything_only_upload_change_your_passwords" part that threw me for a loop -- I don't see in that script how they'd be changing (or even finding) any passwords, but I am not a Perl genius so figured it was worth asking the community.
&gt; to not even have the decency to indent properly and comment when hacking my account is the height of rudeness Heh, but it is readable code. BTW, that's common style for this kind of crapware. Things are a lot worse with various script kiddies programmings skills one can find on "evil black hat" forums.
Or it would if the site wasn't totally broken (like it's been for the past... year? two years?) It used to show a totally garbled graph for me with the timestamps in the wrong order. Now it generates a broken PNG as my graph and the text says I only have one dist.
What's your ID? ishigaki has only recently started work on resurrecting it and i'm sure he'd appreciate an email telling him about broken profiles. Also, the site is definitely not totally broken. It works for plenty profiles i checked.
Okay fine, sorry for trolliness. I'm ARODLAND.
These are great tutorials! I didn't read any before this one, so I'm going to go back and catch up. Thanks for sharing.
I'm guessing it would be part of an automated attack that would find a vulnerability, upload the script to cgi-bin, then try to access that cgi script through the HTTP server, parse the results and dump into a list of machines they can upload and run code on. If it wasn't runnable through cgi, their test probably registered as failing, although the fact that it got so far as to write the script to your cgi-bin directory tells me they got pretty far and could have probably done a lot of harm. I'd say this is worth worrying about and I'd probably back the machine up, wipe it and reload the OS from scratch. You can't trust it anymore. If you can't do that, at least verify that all the files on the machine are as they should be. Re-verify all the binaries from the distribution and check all your custom programs, data, passwords, etc. 
Not unless any of your hostnames are smtp.yandex.ru; it seems they're just establishing a remote SMTP connect originating from your Web server. My guess is they want your Web server to be the originating IP for the SPAM sent, for source obfuscation and/or deniability. That SMTP may or may not be theirs, but if the mail is sent from some arbitrary hacked site, it's one more hop to track them. Most likely, this file was uploaded by yet another compromised system. If it's really been there since last December I wouldn't stress it too much. They're most likely done with you if SPAM was the goal. You can check your Web logs for any access to this file if you want peace of mind. If your hosting company is worth their stock they've covered their bases as far as compromises on their end, but I can tell you that 98% of these are due to exploits of vulnerabilities in common third party apps running on a site, writing wherever there's write and execute access, which is usually the cgi-bin. Consider tightening permissions wherever appropriate for your site. If you need write access somewhere, you should have a good inventory of every piece of code that uses it, and scrutinize it for vulnerabilities. This is the right way to do it with shared hosting, but if it doesn't make sense for you to bother, I'd guess this threat is well behind you.
A bit of punctuation helps: "We do not delete anything, only upload. Change your passwords." At least that's how I read it.
Coming from Java/C++/Lisp/Python/Bash/AWK/Haskell, I just read the language spec and then followed the coding guidelines around me
Coming from Java/C++/Lisp/Python/Bash/AWK, I just read the language spec was able to use it competently in my workplace. If you know C and python, you're fairly good at understanding much of perl. Here's the reference: http://perldoc.perl.org/perlsyn.html You want to brush up on regular expressions, and this reference doesn't really cover network monitoring programs, but it will get you in the door and understanding the code examples you will see.
I strongly prefer using *use Fatal* for my error handling of file operations. The old "or die" pragma, while time honored and well understood, is easily omitted from scripts. Even though this tutorial uses indirect filehandles, it doesn't explain why; it really cleans up scope, eliminates confusion with other bare words, and the file closes automatically when the variables gets garbage-collected. That's goodness all around.
What is wrong with using the [perl FileHandle module](http://perldoc.perl.org/FileHandle.html) for handling writing to files?
I see this sort of thing quite frequently at work. I'm going to make a couple of assumptions real quick. You are using a shared hosting account, running Linux? Your password may not have anything to do with it. I would check file permissions to make sure that nobody else can write to them. if someone else on the same shared server has had their account compromised they can potentially write to these unsecured files on your account. Are you running any other scripts on account? Blog, forum, contact form? Anything that has some sort of input? If so, are they all up to date? It is possible that an outdated/insecure script that you installed allowed for someone to gain access to your file system. WordPress sites get hacked all the time, mainly because of plugins. I've even seen WP theme sites that distribute malware in their themes. Be wary of anything you didn't get from wordpress.org. Who is your hosting company? Have you contacted them about this issue? I don't know about other host, but we have a team of people here that look into reported issues to try and determine how they happened. 
It's extra work for something Perl 5 has been able to do for you since 2000.
I guess I need to update my knowledge of perl! I'll look into that--thanks.
Well I did find an old Drupal install I did (which was never used or updated) and that is a top candidate. The one thing I can't explain is how the redirects were created. You are spot on: shared Linux hosting. They use CPanel for account management. So do you think it was via something like the old Drupal install that they wrote the new file to cgi-bin and updated the .htaccess file (and changes in .htaccess are read when I go to CPanel)? Because the thing that perplexes me is if they had my password, why this silliness? Why not just use the account?
i might use something like this: #!/usr/bin/perl use strict; use warnings; my $fileName; # totally optional loop to ensure a good filename is entered do { print "Enter the file name: "; chomp($fileName = &lt;STDIN&gt;); } while (! -f $fileName); open (my $fh, '&lt;', $fileName) or die "Unable to open [$fileName]: $!"; my @contents = &lt;$fh&gt;; for my $line (@contents) { if ($line =~ /^\s*(&lt;w:.*)$/) { print $1 . "\n"; # $1 is the result of the grouped capture () } } exit 0; *formatting
my $regex = "\&lt;w:"; for my $line (@lines) { print $line if $line =~ /$regex/; } Except I can't get the formating nice. [perlre](http://perldoc.perl.org/perlre.html) -- incase I messed the regex up. Or: while(&lt;FILE&gt;){ print if /\\&lt;w:/; } 
 perl -n -e '/&lt;w:/ &amp;&amp; print' &lt; my.xml 
The way to process XML is with a module from the CPAN. XML::Twig is probably a fine place to start. Trying to parse XML with regexes is fraught with terror and error.
I read about XML::Twig, and decided to download it. If I run "perl Makefile.pl -y", does that install it so that I can begin using it inside perl files? Nevermind, after a quick google search, I realized I need to install OS X developer tools to use the make function.
You should use something like CPAN or CPANPLUS or CPANMINUS (cpan,cpanp,cpanm) to install modules. It's a hell of alot easier.
Thank you! I must be missing something though, I'm not getting output when I run the program and specify an xml file. 
[The &lt;center&gt; cannot hold](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454)
Loosen up the regular expression? Maybe just /(&lt;w:.*)/g ? Line endings on Windows can be weird
perl -wnl -e '/&lt;w:/ and print' file_location
Haha wow! That answer was hilarious. I have been messing around with XML::Simple, it seems rather easy and powerful!
That did the trick! Thanks! Unfortunately, it's picking up some &lt;a&gt; and &lt;pic&gt; tags too. It seems as if the "if" statement is looking at the whole file, because if I add a lot of "\n"s, it adds a lot of line breaks after the whole line of output, rather than each individual piece of code. Hmm.
Regexes default to picking up the Last matching value, not the First. Check the manual to see how to suppress 'greedy' regexes..
/(&lt;w:.*)/g shouldn't match any &lt;a&gt; or &lt;pic&gt; tags unless: * you wrote '\w' instead of 'w' * you aren't actually matching &lt;a&gt;, but we aren't splitting @contents where we think we are It's probably the latter, but you can confirm it by looking at $#contents.. Is it a much smaller number than you expected? If so, try something like this: for my $line (@contents) { my @matches = $line =~ /(&lt;w:.*)/mg; print "$_\n" foreach @matches; } Alternatively, you might want to change the regex to /(&lt;w.*?&gt;)/, which will make sure you only get everything between the opening '&lt;w' and the first '&gt;' following it. *formatting
Thank you for the continual help, I really appreciate it. It's nearing 2:30 AM here and I'm still trying to fix this. * I used 'w', not '\w', so that's not the problem. * I do believe this is the problem. I don't think it's actually splitting contents line by line. I think it's viewing the whole contents.xml as one line. I did try using for my $line (@contents) { my @matches = $line =~ /(&lt;w:.*)/mg; print "$_\n" foreach @matches; } and the results were similar. However, when I use /(&lt;w.*?&gt;)/ it captures the first line of the code (which is something like &lt;w: .......&gt;). 
Without actually accessing your account, I can only make assumptions. The Drupal install *might* have been the entry point. It is quite common for an attacker to wait several months before using a compromised account for anything. A lot of shared host rotate their logs and the longer an attacker waits, the less likely their method will be found.
I recommend you not prompt and read filenames. The diamond operator "&lt;&gt;" will iterate through files on the command -- myprog.pl -- #!/usr/bin/perl while (&lt;&gt;) { print if /the/; # print lines contain "the" } Run with perl myprog.pl file1 file2 file3 or chmod +x myprog.pl ./myprog.pl file1 file2 file3 and you can use it in pipelines, too: my-other-filter file1 | myprog.pl because, if you supply no arguments (no filenames), the diamond operator will read from standard input, which is here piped from another filtering program. 
A while ago I came across the Dreamwidth site, and they seem to be actively recruiting help. According to their info, they;re willing to mentor novice developers. I've never worked with them, but it's at least worth investigating. http://wiki.dwscoalition.org/notes/Category:Development
You might want to have a glance at the [Perl Primer for Mac OSX Users](http://wardley.org/computers/perl/intro4mac.html) and in particular the section on [Installing Perl Modules](http://wardley.org/computers/perl/intro4mac.html#Installing_Perl_Modules).
He answered as such: &gt; Thank you for the information. The graph is updated when a module is updated. &gt; So, when he update/upload a module, it'll be fine. &gt; But maybe I need to run a script with --force option to let it mark everything as updated first. &gt; I'll look into the code and will do what is needed later.
xml is hard to parse by hand. You shouldn't use regular expressions, for the same reason that [you shouldn't use them to parse \(X\)HTML](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#17324). And since you've never used Perl, and it's not the most easy to learn language, it's probably not the best choice. If you know Python, you can try [ooopy](http://sourceforge.net/projects/ooopy/) (although it's a bit old), or lxml.
SQL? What does it have to do with perl?
in answer to your "question today" i don't think reddit works that way! on a more sensible note try [r/sql](http://reddit.com/r/sql). And I find it sometimes helps if you provide a bit more info about the structure of the tables or examples of the data.
while i admit i didn't know about /sql/ i'm still unconvinced this was the wrong sub because the sql call in question is for a perl script and must be done in perl. what it has to do with is getting expired people from a program in cron that emails a group. instead of emailing a caregiver for each patient who is expiring, i want to group them all together in a temporary table and send each caregiver one email with multiple patients. getting them into the table once it exists i can handle. i just don't know how to do it off the top of my head. I've done it in the past and likely have the code I need that I can hack but it's on another laptop with a wacky screen and overheating issues and I didn't want to deal with booting that machine and looking for the code so I decided to see what would happen if I came here. Was that bad?
Just because the SQL is called from Perl doesn't make it a Perl issue. Not anymore than Java syntax errors in a Java program running on Windows is a Windows issue.
lmao. did you read your post? "it's called from perl but it's not a perl issue any more than a perl issue on a windows box is a windows issue." you sir are right - a perl issue on a windows box is a perl issue. this call needs to be written in perl. should i be asking in r/french? i didn't think to look for r/translations or r/babelfish. maybe those would have been appropriate as well. but no, since it was perl that i needed i threw caution to the wind and posted here.
No, this should not be written in Perl. You're asking about tables and selects, which is SQL and has exactly zero to do with Perl. You can put SQL inside Perl code but that still does not make it Perl code. If you want to ask how to call SQL from Perl or how to put SQL in Perl, that's a wholly different question. And please learn to use the enter key. My eyes glaze over at your walls of text.
once again i point to needing the PERL translation of what i need. tacturn enough for you?
This is not something you can do in Perl, unless your database engine supports running Perl in the backend. You will have to do it in SQL, and call that SQL from Perl. And you could do well without the antagonistic attitude you've sported in this thread.
Show us the SQL you want to run and your current Perl and i'll show you how to put the two together.
As others have echoed here, **do not parse XML by hand**. You _will_ do it wrong. The same goes for HTML. If you need to parse XML, visit CPAN and search for XML. Your problem seems to be working with OpenOffice docs. Try using [OpenOffice::OODoc](https://metacpan.org/module/JMGDOC/OpenOffice-OODoc-2.125/OODoc.pod). 
In case no one else has mentioned it, sometimes programs store XML without line breaks. It might be the default way to do it, I am not sure. At any rate, line breaks are not needed to parse XML, AFAIK; a document can consist of a single line. If this is the case, the regex suggested by chorankates will not work for you. The /g switch is allowing you to get feedback, not because Windows of endline issues, but because your XML tags are not separated by whitespace.
Judging from what you describe, fgrep would be more than enough. Is this really it, or part of a bigger picture?
Maybe not generalizable to all of XML, but this is a beautiful example of how easy it is to do basic processing with Perl one-liners. This goes right back to Perl's roots as a replacement/extension for the old sed(1) and awk(1) utilities.
An expression isnt surrounded by curlies. grep $_ % 3, 1, 2, 3; A block is surrounded by curlies and you can fit multiple expressions in it: grep {my $x = $_ % 3; print "$x\n"; $x} 1, 2, 3; 
An EXPR (expression) is just a single Perl statement which is evaluated for each item in the list. In grep's case, if the expression returns true, then the item is part of the list returned by grep. A BLOCK is a compound statement which has its own scope (so you can declare variables within it). Its value is the value of the last statement evaluated within that block. For map and grep, the expression or block is applied to each value of the list in turn, with that value being available in $_.
If you're trying to learn perl, read Mastering Regular Expressions. If you're just trying to filter lines in a file, use grep.
Technically a block of one expression doesn't require curlies.
First thought: this is incorrect since this doesn't work: if ( $foo == $bar ) $foo = $bar + 1; but if you swap that, it does: $foo = $bar + 1 if ( $foo == $bar );
Wow, I can learn about pseudohashes.
If /g (which means global, or find all matches) is getting feedback where otherwise you get nothing, then it sounds like your XML tags are not separated by whitespace. In other words, your files might be a single line. Or worse, it might inconsistently line-broken. To get around that issue entirely, do this: open ( XML, '&lt;', 'path/to/file' ); # The following is a special setting stating what to use for a linebreak for input. # Normally it is \n. Setting it to '' means there the file is slurped as a string. $/ = ''; my $xml = &lt;XML&gt;; print "$1\n" while $xml =~ m|(&lt;(w:[^&gt;]+)&gt;[^&lt;]+&lt;/\2&gt;)|gs; Explanation of the last line. First, note that it uses *while* and not *for*. The /gs switches mean: get all matches in the string ("global"), and treat line breaks as just part of the string (the /s). Normally, regexes treat line breaks as the end of the string. You do not want to do that in this case because we've slurped the entire file as a single string. `&lt;(w:[^&gt;]+)&gt;` This means, find your specific string "w:", then match any following characters which are not "&gt;", then match the "&gt;" that closes the tag. Note that the + means there *must* be said characters (it will not match a tag like "&lt;w:&gt;"); this seems a pretty safe assumption. The parentheses grab the tag name; we use this capture to match the closing tag. `[^&lt;]+` This means, match all characters which are not "&lt;", the opening bracket of the tag closing. This is the content of the tag. Again, note that the "+" means that content *must* be there. If content might not be there for all tags, use `[^&lt;]*`. `&lt;/\2&gt;` This matches the closing tag. Note that it uses \2 to match the previously captured tag string. An alternate way of evoking that capture is $2, but that will not work here. (Edit: forgot to mention that the "2" is because the capture is from the second set of parentheses.) Finally, the parentheses surrounding the entire regex capture the entire "line": the opening and closing tags and the content. Note that we use $1 to refer to this capture in the call to print. We use $1 here because we are now outside of the regex. (This is probably not a technical enough explanation but if not hopefully someone will correct me.) We have to use the \2, above, because we are using it while still inside the regex itself. CAVEATS! :) First, sorry for the very long comment. You stated you were new to this and I figured, even if you have got your parser working as you need, that it would be helpful to see this way to do it. If you don't have your parser working as you need, maybe this way will provide you some leverage. As everyone here has said, it is *far* easier to do it wrong than to do it right when it comes to XML/HTML parsing. My little regex, while it does work (I've tested it) on simple XML, is almost certainly still Wrong. In other words, it could very likely fail for what you need it to do. Others more experienced with XML will certainly be able to poke holes in my little regex. Though I do think its cuteness is undeniable. :) It really can pay to use a module such as XML::Simple for this. If you are not able to get it working the way you want after a day, I'd say you should go that route. HTH. 
Pseudohashes were already written up in great detail in the 3rd edition. I'm willing to bet that this new edition will remove most, if not all, of that content.
That's because an if statement on its own takes a block, but an expression may be followed by a postfix if statement. { $foo = $bar + 1 } if $foo == $bar; also doesn't work.
Right, but stmfreak said above: &gt;Technically a block of one expression doesn't require curlies. which would imply that if ( $foo == $bar ) $foo = $bar + 1; should work.
I haven't read this edition; I'm going by the marketing blurb: *Many Perl books explain typeglobs, pseudohashes, and closures, but only this one shows the motivations behind these features and why they work the way they do.*
I had no idea what pseudohashes were and just now read this: http://perldesignpatterns.com/?PseudoHash Now i'm horrified and glad they're deprecated.
stmfreak was wrong. An expression and a block are not syntactically interchangeable. Many things can take either an expression or a block, but that is specific to the operator in question.
Mkay, that's what I thought (about stmfreak being wrong) I just didn't know for sure. +1 for clearing that up.
What I want to know is, will they fix the 3rd edition's glaring omission from the glossary? I'm speaking, of course, about "thingy."
If you are going to do this, you should install [`ARGV::readonly`](http://search.cpan.org/dist/ARGV-readonly/lib/ARGV/readonly.pm) first. The &lt;&gt; operator uses the two argument version of `open` and is therefore unsafe unless you make sure the contents of `@ARGV` are safe (which is what `ARGV::readonly` does). 
Honestly I have no excitement about this book. I read the last version a few times but I think there is better and cheaper alternatives now. For learning Perl the language I recommend the following: * Modern Perl (free online) * Perl Best Practices * Higher Order Perl (free online) **or** Mastering Perl (old draft free online) PBP is somewhat optional. I recommend it to cut off the bad habits before they start but Modern Perl does this as well to a certain extent. Mastering Regular expressions is a great book but it is not an all Perl book either. My view is somewhat biased since I knew a few programming languages before learning Perl so keep that in mind.
Please don't parse XML on your own... :( When programming, always think: is it vaguely possible someone has already solved this problem, and solved it better than I could have? The answer is almost always yes for most of the stuff except for the real meat of what you want to make.
He said Office XML, so I don't think that's OpenOffice.
You'll definitely want to get a copy of the Perl Cookbook.
While it's great for processing text, many smart people will remind you that [XML is not text](http://duckduckgo.com/?q=%22xml+is+not+text%22).
Love it when I'm forced to check my assumptions. Thanks guys. http://perldoc.perl.org/perlsyn.html#Basic-BLOCKs
The $search should be $1: my $cutSearch =~ s/.*?(\/title\/tt[0-9]).*/$1/;
that still returns nothing. Though just so I fully understand it(new to perl), the $1 basically says the first item that matches, right? meaning that if needed $2 would be the second and so on?
I'm not entirely sure what your data looks like but you're trying to do a string replace on an undefined variable ($cutSearch). Perhaps try this: my ( $cutSearch ) = $search =~ m/.*?(\/title\/tt[0-9]).*/;
the data ends up being the source code for the search results page, so it's a giant block of HTML code. curiously enough, using your suggested code returns something, but it's always just the number 1. Looking into it, it appears that that is the first digit of the desired number(1310375), so I'm thinking that now what I'll need to tweak is the number of numbers that the regular expression allows for. I tried adjusting the expression to be &gt; m/.*?(\/title\/tt[0-9]+).* but had no luck with that. Any suggestions?
&gt; that still returns nothing Was there anything in $cutSearch to begin with? &gt; Though just so I fully understand it(new to perl), the $1 basically says the first item that matches, right? meaning that if needed $2 would be the second and so on? $1 means whatever is matched by (\/title\/tt[0-9]). If there were any more brackets then $2 would be that. 
I was attempting to trim down $search and put it into $cutSearch. My bad on not being clear on that bit.
&gt; This edition will also have free electronic copies when the printed edition comes out. I love when authors do this! I can have a hardcopy on my bookshelf, and a digital copy for quickly searching. Thanks mr_chromatic!
Take two digital copies; they're cheap. Take ten!
Thanks for increasing the font size for the code sections. It makes the book much more readable. A quick comment... the TOC is missing the sub-headings for the chapters. Also, the X.x.x style numbering isn't a problem, but it gives the book more a tech manual feel to it, which may not be your intent. Either way, thanks for the book. 
If you've managed to install XML::Twig then here's a Twig solution #!/usr/bin/perl -w use strict; use XML::Twig; my $twig = XML::Twig-&gt;new( twig_roots =&gt; { # children of this hash determine which tags are parsed # w =&gt; sub { # this would cause the following block to be called for every &lt;w&gt; tag and follows the documentation qr/^w(:.*)?$/ =&gt; sub { # this is called for every &lt;w&gt; tag also all &lt;w: tags but I don't see it documented YMMV my ($twig, $element) = @_; # This prints only the text within the &lt;w&gt; not inner tags. # input: &lt;full&gt;here&lt;w&gt;foo&lt;i&gt;bar&lt;/i&gt;baz&lt;/w&gt;bip&lt;/full&gt; # output: foobarbaz # print $element-&gt;text; # This prints everything inside the &lt;w&gt; tags including inner tags # input: &lt;full&gt;here&lt;w&gt;foo&lt;i&gt;bar&lt;/i&gt;baz&lt;/w&gt;bip&lt;/full&gt; # output: foo&lt;i&gt;bar&lt;/i&gt;baz # the first arg 0, implies print to STDOUT, second arg 1, says to skip printing the surrounding &lt;w&gt; tag. $element-&gt;print( 0, 1 ); print "\n"; # if you want some new lines between &lt;w&gt; contents }, }, ); $twig-&gt;parsefile( $ARGV[0] ); 
&gt; Thanks for increasing the font size for the code sections. It makes the book much more readable. Glad to hear it. &gt; the TOC is missing the sub-headings for the chapters I'll probably keep them out, as I did in the first one. Does it provide a lot of value? &gt; Also, the X.x.x style numbering isn't a problem... I'll probably elide that as well.
The first character matched should be a '/' not a '1'. My first thought is that you removed the parentheses around $cutSearch. That would change the context and give you the number of matches returned, which is 1.
Section 1.2, Page 2. "Notably, Perl allows you tremendous freedom to solve problem, ..." =~ s/problem/your problems/; 
Thanks. How shall I credit you?
&gt; I'll probably keep them out, as I did in the first one. Does it provide a lot of value? Current version: The Perl Language 13 Names . . . . . . . . . . .13 Variables . . . . . . . . .14 Values . . . . . . . . . . 15 Control Flow . . . . . . . 23 Scalars . . . . . . . . . .35 Arrays . . . . . . . . . . 36 Hashes . . . . . . . . . . 40 Coercion . . . . . . . . . 47 Nested Data Structures . . 55 New version: 3 The Perl Language 13
I'm very happy about this. It's one of the best books on programming there is. I'm definitely buying it. I read most parts of it about 7-8 years ago and I still remember its funny and witty style. 
Are all lines of code in Perl expressions? So there are no statements in Perl, or what?
No need to go through it line by line. In your first attempt, you just want to match with **m**. No need to try to throw away the unwanted stuff with **s**. When I run this my $url = shift // 'http://ww.imdb.com/find?s=tt&amp;q=kevin+bacon'; my $search = get $url or die "Could not get '$url'"; my($cutSearch) = $search =~ m{(/title/tt[0-9]+)}; say $cutSearch; I get $ ./rougegoat.pl /title/tt1310375 
Perhaps. The current vim syntax highlighting definition for Perl 6 is completely horrible though. This may have affected my (short) experience. Oh, that, and the bit where Rakudo takes about half a second to start on a 2.7ghz Sandy Bridge CPU. To compare, GHC compiles Haskell programs into binaries quicker.
Not quite. In languages (typically functional languages) where all statements are expressions you can write things like my $x = if (foo) { 12 } else { bar() }; You can't do that in perl as the "if" is not an expression, so you have to fall back to using the ternary comparison operator: my $x = foo ? 12 : bar(); ...or an explicit "do" block which is an expression: my $x = do { if(foo) { 12 } else { bar() } }; 
Thanks for your answer :) If I understand your explanation correctly and also http://perldoc.perl.org/functions/eval.html correctly, it means that a code like: sub $user { my $user = eval{ my $schema = get_dbix_schema; my $test = $schema-&gt;something()-&gt;morethings(); return $test-&gt;('User'); }; } The eval will be parsed only once at compile time?
That's right. [This blog post](http://www.effectiveperlprogramming.com/blog/965) explains in detail how the two forms of eval are vastly different. ([A google cache link as the site seems to be temporarily down.](http://webcache.googleusercontent.com/search?q=cache:http://www.effectiveperlprogramming.com/blog/965&amp;hl=en&amp;strip=1)) The block form of eval forms the basis of perl's exception handling system, so think of it like the moral equivalent of "try" in other languages. But because of historical reasons it's a little clunky and awkward to use properly, so it's often recommended to use a module like [Try::Tiny](http://search.cpan.org/perldoc?Try::Tiny) to have a proper "try". (The reasons for this are explained in the BACKGROUND section of that page.) It's not clear what your use above is. Why is eval being used? It looks like it's there to catch any exception that might be thrown by one of those functions, but since the result is never checked it looks quite sketchy.
I wonder if the titles of the chapters will be renamed to non-nonsensical Ozric Tentacles song titles.
The real case code that lead me to this question, is a loop of inserts, if any of the inserts would fail (most common reason duplicate values) the whole process dies, so using an eval I could easily know if any of the inserts failed and rollback the DB.
that works perfectly as well. It's more efficient than what I was doing, so I'll go with it. I do gotta love how both methods work though. That's one of the awesome things about programming.
[TMTOWTDI](http://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it)!
I was looking to reacquaint myself with Perl. I'll give it a read. You realize, you're forcing me to learn Git, as well. ;-) (An out of practice, semi-competent old-timer.) P.S. I've had a couple of recent requests to help people with their (more, or *less* serious) book ideas. So, this may help me, as well, WRT automating the production process.
Title, copyright, ISBN, etc. page: There should be a space between the copyright symbol and "2010". (Well, I *think* there is typically a space in that position.)
Preface page ii, footnote 1 does not read well: *1Perl 6 is a reinvention of programming based on the solid principles of Perl, but it’s a subject of another book.* Better would be "but it's the subject of another book." or "but it's a subject for another book." P.S. My apology for posting suggestions to reddit. I'm about to run out; I'll look into using the Github interface for these, this evening.
&gt; I've had a couple of recent requests to help people with their (more, or less serious) book ideas. So, this may help me, as well, WRT automating the production process. I've been (not quickly enough) pushing as much of the automation as possible onto Github and then to the CPAN. The Pod to LaTeX and XHTML formatters will come out soon.
I look forward to reading this! I had "learned"(I quote learned because I am always learning new things that Perl can do for me) Perl from an O'Reilly book, so this is breath of fresh air for me. Not that the O'Reilly book was bad or anything like that. In fact,in my opinion, it was quite good. Just from what I've read so far, I really liked the way the *Perl Philosophy* was presented.
given the incredible amount of perl stuff available already, i'll be buying this more out of nostalgia
Pseudohashes have a paragraph explaining that "Pseudohashes were an experiment that turned out to be not such a great idea". 
Tell people that it's feature complete and ready for production use. NB: I'm fully aware that version numbers don't carry much significance any more these days and there are lots of modules on CPAN with version &lt; 1.0 that are in production use. I still have a bad feeling every time I need to use one of them. 
&gt; Tell people that it's feature complete and ready for production use. Spreadsheet::WriteExcel is already one of the most popular modules on the CPAN, and has been for years.
(Submitting via reddit, not github, because I can't figure out the reason or a fix for this). PDF p.22, §3.3.3, top (values.pod): my copy reads as follows: my $octal = 52; ...with no leading zero, bold or otherwise. The relevant lines in values.pod are untouched since 2009-10-16; my paper copy of Modern Perl shows that correctly; and I am unable to reproduce the error using either build_html.pl or build_pdf.pl. I suspect a problem in a postprocessing step.
I'm sorry if this sounds ignorant but I why should I care about Perl 6?
Metacomment. When I first read Modern Perl, I often wished some code snippets had comments describing the expected output. Trivial example from PDF p.23: say defined $status; # 1 say defined undef; # [empty string] Comments such as these could clarify the expected result. (This is a simple one, but I remember encountering one or two that made me pause for a moment. Can't find them now, of course). I'm reluctant to submit git patches for these, because my comments/style may not match yours, but will be glad to point out specific instances if you'd like me to.
i'm starting to lean in this general direction...perl5's supposed warts really don't bother me any more, and each new release makes meaningful improvement while the perl6 team is doing an awesome job with regular releases, none of these releases seem meaningful enough to make me actually pick it up
I to would like to know if anybody has a EIL5 of the difference between 5 and 6. 
I don't know what "EIL5" means, but here's a [differences](http://perlcabal.org/syn/Differences.html) document. 
Are you by any chance a programmer? Are you curious about bootstrapping, compilers, grammars, parsers? Op codes, optimizations and language VM's? This is an amazing time to watch a language get created. Grab the popcorn (or join in). But if what's under the hood is not so fascinating, then yeah, check back later. But it's some seriously fascinating CS stuff going on _right now_.
Okay, Timmy. First there was Perl 5. It was good, but after a while, it had growing pains. So your mommy and daddy did a special hug and made a new language, Perl 6. But Perl 5 grew up, and stole Perl 6's shiny new toys. So Perl 5 has many new toys now. Wow, so many toys. Perl 6 is still a baby. They are not two different versions of the same language -- they are two different languages.
(Another comment that's not githubable. Please let me know if you prefer another medium for reporting these). §3.5.1, PDF p.39 bottom (scalars.pod): my $next_sign = $call_sign++; This is misleading, because postincrement will modify $call_sign *after* the assignment. I think you need to find a way to rephrase this block, including the "also fine" statement below. (BTW this bug is also present in the first edition; apologies for not reporting it earlier).
I messed up the abbreviation, it's suppose to be [ELI5](http://www.reddit.com/r/explainlikeimfive/): Explain Like I'm five. It's how the cool kids are talking. 
I am a programmer, I use Perl 5 at work. But everything else you listed is a past my interest at the moment. 
I do take interest at what's under the hood and that's part of what I'm trying to find out about Perl 6. I just don't get what so special about Perl 6 and why it's taking such a long time to overtake Perl 5 or if there will ever be a need to. To me, it seems we could just continue to make improvements and optimize Perl 5 because Perl 6 almost seems like a different language and we have all these modules from CPAN already. Also, will all the Perl 5 modules from CPAN work out of the box with some kind of fallback mode with Perl 6? Because IMO it's not worth losing them and the gigantic amount of work that's been done by the community just to move from one version to another.
PDF p.75, §5.5, same situation with the EXPR form of caller(): my (...) = caller(); # B&lt;0&gt; is not displayed edit: PDF p.107, §7.1.4, same with "kitten will have an age of [blank] until next year". And, now that I search for it, same with several other instances of **C&lt;0&gt;**.
&gt; I'm sorry if this sounds ignorant but I why should I care about Perl 6? It probably depends on what's important to you. I think there's a whole slew of programmers who care most about the 4 points mentioned in the article. People who just want something that's understandable, easy, useful, and has other friendly folks using it too. Many times I've heard Perl 5 users talking about how Perl 5 got them out of a jam when they needed some oddball script at 2 am to fix something critical. I'm curious myself to see if Perl 6 will be a good fit for these programmers (that is, whether they "should care about it"). 
EIL5 should be ELI5 or LI5 = Explain Like I'm 5 (years old)
The Perl 6 community is very much aware of the lack of documentation. There are two problems with it: * Some parts of Perl 6 still change, making the documentation go out of date * You have to know Perl 6 pretty well to write good docs. The only people who know Perl 6 well enough are typically compiler writers, whose skills and tuits are sorely needed in other areas. I've started several documentation efforts (5-to-6 blog, [perlhints](https://github.com/perl6/mu/tree/master/misc/perlhints), the book, recently a FAQ list), and the problem with all of them was that most of the time I was on my own, and eventually lost motivation. What we'd really need is somebody to take things into his hand, and be the "Perl 6 doc champion". I and others would surely chime in. As was mentioned in the original post, there are lot of sources that could be "stolen" from. Any volunteers? :-) (no, you don't need to know Perl 6 yet; you can learn it, and we will answer all of your questions on #perl6. It will take time, no doubt).
Still seems like a strange feature to highlight in the marketing blurb.
The underlying premise of the article is that I think Perl 5 is "successful" (er, that is, has many happy and productive users (and contributors)) because it has those 4 things (very good docs, easy to learn, usable, and helpful community). My hunch is that if you want to emulate that success, your language should have each of those same 4 ingredients. I recognize that writing good docs is quite difficult (moreso than it seems). Hopefully, solutions to the problems you point out can be found. 
From what I remember, the 3rd edition was basically a subset of perldocs in book form. Which is not a bad thing to have. I don't believe any of the books you mentioned are structured as a "complete reference."
I think you want to use getopts to get the options as usual and then check separately that you didn't get both options. So something like use Getopt::Std; my %opt; getopts('dD', \%opt); die "d or D, but not both" if $opt{d} and $opt{D}; say "Hello, CyberBot129!"; say "option d" if $opt{d}; say "option D" if $opt{D}; say "other args: @ARGV" if @ARGV; 
The marketing blurb probably hasn't been updated since the 3rd edition…
I can't see it unless I sign in?? Google, you suck! (In case you don't believe me, here's a [screenshot](http://i.imgur.com/TedYF.jpg)) 
Usually i wouldn't do this, but: Are you guys fucking serious? blogs.perl.org provides a great service for the community and when they ask for help you vote that down? **Why?**
I didn't have to sign in to see it. 
Congrats rjbs, and thanks so much Jesse for all your hard work!
Because they are stupid?
If the people behind the website don't want to maintain it they should shut it down. 
It's not about wanting, it's about being unable to. I also want to do a thousand things to help the Perl community, but i find it hard already to juggle the tens of things i'm doing for it while also earning money AND having some semblance of a life.
Here an [alternative link](http://www.nntp.perl.org/group/perl.perl5.porters/2011/10/msg178691.html) to the message.
Florian (rafl) does great work, but Jesse is obra.
thanks for fixing my brainfart :) (Because Florian and Jesse look SO much alike, I know I know...) ;)
I think Fatal is not recommended any more. Better to use autodie. I'll explain that later. At one point there will be a separate post with bare-word file handles explaining what are they and why not use them.
OK then, if the people behind the website are unable to maintain it they should shut it down. 
It knows that you have an account, but you haven't used the site recently, so it wants you to enter your password before potentially exposing your private data. That's *not* the same behavior it would exhibit if you didn't have an account at all (in which case it would just show you the post). A little counter-intuitive, but not totally unreasonable.
Sorry, but I don't think it is reasonable. It should just show me the post just like for new users, and not use my private data.
C now: my_ptr-&gt;thing = 1; perl5 now: $my_ref-&gt;{'thing'} = 1; perl with this proposal: $my_ref.{'thing'} = 1; WTF? 
The main impetus was that Perl 6 does it like that.
...why?
It's an interesting novelty, but it's just importing Perl 6's squigglies without the underlying semantic reasoning behind them (and seems to break bitwise negation as a result). BTW that last line there would be valid in Perl 6, since everything's an object and `{...}` is a method on the hash object, but the preferred form is `$my_ref{'thing'}` (or `$my_ref&lt;thing&gt;`). I imagine *that*'ll need a lot more than a 5 line diff...
Props to those guys for keeping the DB going this long. This is looking more like a solid replacement for MySQL, especially considering the direction that's drifting in.
Because unlike perl&lt;6 which was a masterwork forged by a handful of geniuses, perl6 was designed by committee. 
Perl is not C. Congratulations on your discovery. :)
What?
For a second I thought it was going to link to [this](http://search.cpan.org/~ovid/Acme-Dot-1.10/lib/Acme/Dot.pm)
Nope.
A few years ago, I was totally into function signatures. I installed few modules, tried it in my software and forgot about it. I just couldn't get used to it. This is the same thing. I'm used to Perl looking like Perl. My internal pattern recognition just cannot be overloaded in this case. 
What is this about Perl tutorials all of a sudden? There are lots of Perl tutorials. 
I think folks noticed that search engines tend to show you [horrible stuff like this](http://perl.about.com/od/perltutorials/a/readwritefiles.htm), rather than something that you should actually write.
Yeah but it is a rather ridiculous discussion. I am very sure that Google doesn't have a "perl tutorial measuring algorithm" which comes and looks at the page and checks whether it is a good Perl tutorial or not and then bases their ordering of search results on that. They are looking at the websites and giving them a rating on whether they are good websites or not. The people who think they have better Perl tutorials than the top ranked ones probably actually are failing some perfectly obvious test which the top ranked pages are passing. I would like to say more but the nature of these discussions is that someone or other gets offended and starts downvoting and things. 
I don't like it (I think "-&gt;" is far clearer and more Perlish than "."), but I admire how easily it was implemented :)
Chuck Testa?
Honestly, if you have an idea that could improve Google results, please out with it. As far as i am concerned it's fairly obvious what happened: People started writing Perl Tutorials as books, putting them behind a pay barrier and at best published free versions in an extremely user-unfriendly format like PDF. So outside of the Perl community they did not get much attention. At the same time, within the Perl community, those books got the most attention because they were well-written, leading to the free Perl tutorials that were written to get very little attention, linking and thus also almost zero attention outside the perl community, because noone was aware of them. Next: Your ... ahem ... "idea" about how Google operates is so far from the truth it's actually fairly funny. They do not look at how "good" a website is. They operate with a publicly known popularity contest known as [PageRank](http://en.wikipedia.org/wiki/PageRank) which basically only measures how much a site is linked to from across the internet. The only reason old and bad tutorials show up at the top is that newer ones have not received as much linkage as the old ones. The solution is obvious.
Absolutely. Inspect $@ after the eval(s) to see if any errors occurred.
Okay, I'm curious: are the hash keys like that on purpose?
Yes. To answer your next question, it is a bit of a hack for some of the hash keys.
&gt; Honestly, if you have an idea that could improve Google results, please out with it. I have plenty of ideas. &gt; As far as i am concerned it's fairly obvious what happened Why do you need my ideas then? &gt; People started writing Perl Tutorials as books, putting them behind a pay barrier and at best published free versions in an extremely user-unfriendly format like PDF. So outside of the Perl community they did not get much attention. At the same time, within the Perl community, those books got the most attention because they were well-written, leading to the free Perl tutorials that were written to get very little attention, linking and thus also almost zero attention outside the perl community, because noone was aware of them. No, that's not it, that is not how Google decides which results to put in what order. &gt; The only reason old and bad tutorials show up at the top is that newer ones have not received as much linkage as the old ones. The solution is obvious. There's a contradiction here. First you ask for my idea and then you tell me that you already know the solution. 
Dangit, forgot to actually post the longer reply. Short version: My post was meant to encourage you to explain your own thoughts and to show that we aren't afraid of controversial ideas; not to display what i thought was the one and only answer. &gt; Why do you need my ideas then? Because i might be wrong. Shocking, i know. &gt; No, that's not it, that is not how Google decides which results to put in what order. How then?
One simple example: Google doesn't decide search rankings on the number of links to a page any more. Google is semi-intelligent. In other words it has some comprehension of natural language. Look at http://szabgab.com/perl_tutorial.html By each of the tutorial pages there is a date like 2011 June 24 which a human being can see is the date the page was created. But as far as Google is concerned, what is that doing, does it add some meaning to the page, does it have anything to do with "Perl tutorial", is it the author's birthday, what is it? Just those pointless dates alone are confusing Google and hurting the page's position in search rankings. 
I am not sure if you are right but let's give it a try. What else do you think? 
When Perl 5 got objects, all the single characters that could have worked for method calls where taken already, so it got -&gt;. But method calls are a very frequent operation in OO languages, so it makes sense to allocate a single character for it. Since many other languages already use the dot for it, Perl 6 does that too. And it works out very well.
That simply isn't true. There were lots of design *proposals* by lots of people, but in the end it really is and was Larry who casts those proposals into a single, coherent whole. Some of the design documents where co-authored by other people too, but Larry still feels free to meddle in their terroritory to ensure consistency among the whole Perl 6 design.
Sounds interesting. Is there a resource where one can read up on those things?
Ever get it working they way you wanted?
The first thing to do is to sign up for Google webmaster tools and check how Google is viewing your site. Check through to make sure there are no dead links, errors, dead internal links, bad response times, etc. Check for search terms via the log file or via webmaster tools and optimize pages based on what search terms people are using to find your site. Turn on gzip compression for your site (it's not on at the moment). Preferably put your pages all on a subdomain like perltut.szabgab.com, and with all the pages on the subdomain being about "perl tutorial". That way you have a site focused on one thing and that is probably worth a position in the google ranking of sites. Check your pages for spelling and grammar errors, check for format errors and stuff like that. In general the whole thing of google rankings is like a beauty contest for web sites so every detail which you can improve is worth improving. Also please remember that it takes some time for the ranking to change, especially this term "perl tutorial" seems to be entrenched with old pages which are going to be difficult to shift. 
I don't think so, I learned this from experience.
All the above makes sense, what I don't understand is this: "Check for search terms via the log file or via webmaster tools and optimize pages based on what search terms people are using to find your site." People using those search terms already found my site. Why do I need to optimize for that and what does that mean to optimize based on that?
I have no problem with the dot for invoking calls on objects. I'm objecting to its use as a de-referencing operator. References/pointers are things that you have to "go through" to get to the actual object. The -&gt; operator makes this nice and clear, but a dot does not. 
It just means to get hints from the search terms about what people are looking for on your site. If you look at the search terms you are getting there is probably a hint about why people are coming to your site and not the Leeds university one. So you make the site more appealing. E.g. if the search is for "perl tutorial 2011" then make sure you put the date on all the pages. 
I feel like this would be most useful if it also included a corresponding list of the flags and the versions they were introduced in: v5.14 a Use Unicode rules for matching, except keep the old ASCII behavior of \d, \w, \s, and Posix character classes v5.14 aa Like /a but also ensure that ASCII chars only match other ASCII chars when /i v1.0? c In global matching mode, don't reset the 'pos' counter to the beginning of string on a failed match v1.0? c (with tr///) Complement the search list v5.14 d Use default rules for matching, where behavior depends (native rules unless target or RE is UTF-8, or RE mentions Unicode code point/name/prop) v1.0 d (with tr///) Delete found but unreplaced characters v5.0? e Replacement string is a full Perl expression to be evaluated, not a string v5.0? ee Replacement string undergoes string expansion and is then evaluated as a full Perl expression v1.0? g Global matching: in scalar context, each call returns the next match (pos of last match is saved); in list context all matches are returned v1.0? i Ignore case v5.14 l Use current locale's rules for pattern matching v1.0? m Multiple line mode: allow ^ and $ to match newline in middle of string v5? o Compile pattern only once, even if interpolated values change v5.10 p Make ${^PREMATCH}, {$^MATCH}, and ${^POSTMATCH} available without global performance penalty v5.14 r Don't modify the string, instead return a new string with replacement/transliteration performed v1.0? s Single line mode: allow . to match any character, including newline v1.0? s (with tr///) Squash duplicate replaced characters v5.14 u Use Unicode rules for matching: \d matches hundreds of various digits, \w matches hundreds of thousands of word chars, etc. v1.0? x Whitespace in RE not considered part of RE; must explicitly add matches for whitespace I'm not really sure about the version numbers of the really ancient features, so someone would have to do the archaeology there if it really matters. 
I would honestly prefer to see some form of inherent concatenation so we don't need to tell the interpretor to expect something. Why is this an issue? These work: $doublestring = $string1.$string2; $doublestring = "$string1$string2"; Why can't this work: $doublestring = $string1$string2;
I like the -&gt; operator. I don't like ~ for concatenation (ala Perl 6). Carry on...
Nice. I wrote a similar batch file for Windows work about 18 months ago. Definitely a big time-saver. I couldn't believe coworkers would attempt to improve coverage and then tell me "I don't know... I'm waiting until the coverage suite [running on the development machine] finishes".
Is this for real? On a publicly accessible site? 
It's on a Windows server.
Cultivating a short attention span has made me a better developer, in some ways.
It tells me if I could exploit an existing script to write into that directory the file would almost certainly have execute permission given it's on Windows. It also has a separate drive for web files, which is generally more secure, so there's less likelihood the script could screw around with OS files (although it's still possible). I googled 'xroot' and there doesn't seem to be any software for Windows called that, so it could be a username, or just a generic directory name. I googled 'lp-validate.pm' and it didn't come back with anything, so this is a likely custom script (perhaps the original URL already told you that). That means it's more likely to have vulnerabilities. Based on the information it would certainly aid a break-in. (Btw I work for a web security company.)
&gt;I googled 'lp-validate.pm' and it didn't come back with anything Are you surprised? No module on CPAN, or available anywhere else for that matter, would ever *not* return a true value at the end. That's a fatal beginners' mistake: nothing will work if the module is used. It tells me that the site owner was probably working on the site at that very moment. (What you mean they do their development on a *production server*?? Well, it certainly looks that way...)
Since the faulty module is right next to the script itself, you can probably download it by changing the file extension of the URL from "cgi" to "pm". FSM knows what else that will reveal.
This is neat and i should steal some ideas from it. I do however dislike that it's a shell script and not Perl. Mine usually looks like this: https://gist.github.com/1347656 (And routes around a D::C bug.)
I can also tell they have 0 unit tests, no staging server and push code live as is with no checking whatsoever.
&gt; Comcast Business Class Yeah, and maybe someone might get something that's coming to them...
Is it possible that there's a function that doesn't return a true value? Or does the fact that the module doesn't return true say everything?
cgi-bin will prevent this
It was written by a monkey.
I switched to another formatter (Pod::PseudoPod::DOM), and had to fix the bug there. That formatter's on Github, but lacks documentation. When it gets some, I'll put it on the CPAN and update the build tools appropriately.
returning true is only necessary on ancient versions of perl/
It'll still be necessary in Perl 5.16, due out next spring.
Fair point - I didn't think of that. :-)
&gt; It tells me that the site owner was probably working on the site at that very moment. That they could be doing this at the time (or ever!) tells me you could probably find vulnerabilities by looking for variations on the filenames for any CGI script on the site - backup files and swap files that editors leave behind. These would not execute as CGI and might be served up as plain text, thus potentially revealing source code.
It was written in notepad. Whoever wrote it doesn't use templates for new files. Also, it's a beginner in question - doesn't c/p other people's examples of Perl modules. 
hey guys, found some back story [here](http://www.matchent.com/wpress/?q=node/439).
In the lines my @files = grep { ! -d $_ } @names; my @directories = grep {-d $_ } @names; the elements of `@names` are relative to the directory `$cur_dir`, but they're being tested as if they're relative to the *current* directory. Either prepend `"$cur_dir/"` or `chdir` to `$cur_dir`. If you look at the documentation for `readdir` (using `perldoc -f readdir`) you'll find a warning about exactly this problem. The call to `shift` in the `for`-loop probably doesn't do what you mean. Try this one-liner to see what it actually does: perl -e '@fred = 1 .. 10; for (@fred) { shift @fred; print "$_: @fred\n"; }' But you don't actually need to do anything there: since `@directories` is a throwaway array, you just don't copy any unneeded elements into `@dir_list`. You can now delete that branch of the if-statement entirely, which simplifies your for-loop. And actually, you can probably replace the for-loop with another call to `grep`. The lines @files = map { "$cur_dir/$_" } @names; @directories = map {"$cur_dir/$_"} @names; aren't doing anything useful, since neither `@files` nor `@directories` is read again before being re-set. Delete them. May I ask why you don't want to use any external modules? `File::Find` is a core module and has been for ages, so you can rely on it being present on your deployment host. Or is this just a learning exercise? General point: it would have made our lives easier if you'd specified what your script was doing and how that differed from what you expected it to do.
@files and @directories will be reset each time through the loop. You need to move the 'my's outside of the while loop.
Here's a simple recursive directory scanning function that might help you out... this will also maintain a list of files and return a full list, but you can omit the array lines if they're not applicable. my @files = scandir("directory/to/start/in"); sub scandir { my $d = shift; print "Descending into directory $d\n"; my @files; opendir (my $dh, $d); foreach my $item (readdir($dh)) { next if $item eq "." || $item eq ".."; if (-d "$d/$item") { print "Found subdirectory '$item'\n"; push @files, scandir("$d/$item"); # recursive call } elsif (-f "$d/$item") { print "Found regular file '$item'\n"; # do something push (@files, "$d/$item"); } } closedir($dh); return @files; }
Yea, it's really hard to figure out what you are trying to do here. Using shift inside a foreach operating on the array you are shifting is a bad idea. You seem to have a very muddled idea of what is going on and have mucked things up a lot. Here's a sane simple starting point that goes through a list of directories passed in as arguments and creates then displays lists of files and directories contained in them: use strict; our (@directories, @files); foreach my $directory (@ARGV) { die "Non-directory $directory specified" unless -d $directory; opendir(DIR, $directory) || die "Couldn't open directory $directory"; while ($_ = readdir(DIR) ) { next if /^\./; #This skips all . files, not just . and .., usually the right thing to do. my $path = "$directory/$_"; if (-d $path) { push (@directories, $path); } else { push (@files, $path); } } } foreach (@files) { print "File: $_\n"; } foreach (@directories) { print "Directory: $_\n"; } Edit: replaced "use vars" with "our" as per pozorvlak's suggestion.
use File::Find;
You mean the `while` loop? No, that's fine - `@files` and `@directories` contain the files and directories under `$cur_dir`, which is reset on every iteration of the while loop. The queue of directories to be visited is stored in `@dir_list`, which is not reset. Hence, it makes sense to keep the declaration of `@files` and `@directories` inside the while loop, so their scope is as small as possible.
This is the technically correct answer. 
The OP's code looks to me like the result of [shotgun debugging](http://catb.org/jargon/html/S/shotgun-debugging.html), something which I've occasionally been guilty of myself :-) OP: note that unlike your program, Dugen's code doesn't search a full directory tree; it only goes one level deep. It would be easy to modify it so that it did, however. Accepting a list of starting directories as command-line arguments (rather than only considering the first one) is a good idea. BTW: the documentation for the `vars` pragma says that it's obsolete and that you should use `our` instead.
I think the OP might be going for a breadth-first rather than depth-first search. Though if that's what they wanted, they should have used `push` instead of `unshift`.
Ooh, good point about "use vars", I'll edit the original. I always hated use vars. Didn't notice "our" showed up. I started with perl4 so I drag around a lot of perl baggage. Also a good point that mine isn't recursive. I assumed from the description that it shouldn't be. Pushing all found directories into @ARGV, or some temporary array used in it's place, would make it recursive. Of course, for large recursive work on files, I like to use a simple: open(FILES, "find . -type f |") while (&lt;FILES&gt;) { print "File: $_\n"; } It's super easy and it has the advantage of operating in an independent process and therefor giving you more parallelism. 
Neat trick! I'll bear that in mind.
But violates the "without the use of any modules" requirement.
I got sidetracked by Git. Still intending to work my way through your Modern Perl, 2nd ed. draft. :-)
 my @filenames = ( '/bin', '/etc'); my $recurse = 1; for (@filenames) { if (-d) { push @filenames, glob "$_/*" if ($recurse); next; #dont say the directory name } say "$_"; }
Not very impressive. The string "[ ]{@ $ €{ @@£$$ €"# %@!#¤% . " #¤%" looks like an email according to the first regexp. In fact it matches any random string of characters that contains a "@" and a ".", including whitespace. 
New Kitsune website: http://puszcza.gnu.org.ua/software/kitsune/
Good point. I updated the article and suggested to use Email::Valid module.
I like the \d example, because it'll also match anything that unicode thinks is a number, like arabic numbers. :)
All email address checking is a matter of tradeoffs between code complexity, accuracy and what you want the thing to actually do. For many web apps, /^ \S+ @ \S+ \. \S+ $/ will do just fine for catching the most common errors: Adding spaces and not having an at sign.
I wonder if `s/(\d+)/$1+1/e` would increase the arabic number.
Exactly!
Nope. $ perl -Mcharnames=:full -E 'say "\N{ARABIC-INDIC DIGIT FIVE}" + 1' 1 There is the /a flag in perl 5.14 to make `\d` match only the ASCII digits: $ perl -Mcharnames=:full -E 'say ("\N{ARABIC-INDIC DIGIT FIVE}" =~ /\d/ ? "matches" : "does not match")' matches $ perl -Mcharnames=:full -E 'say ("\N{ARABIC-INDIC DIGIT FIVE}" =~ /\d/a ? "matches" : "does not match")' does not match 
Your regexp still considers " @ . " as looking like an email address.
The regexp in the article matches whitespace, yours does not, assuming you did not mean for it to contain spaces.
The extension adds nothing. If you're calling it as "Reddit_Image_Scraper" and the program files /usr/bin/perl becaue of the shebang, then why introduce the artifact that it happens to be Perl?
After you do the Mech -&gt;get(), you look at $mech-&gt;text, but don't. Look at $mech-&gt;content. $mech-&gt;text is the text after all the HTML is stripped out. If you're getting back JSON, as it looks like you are, then parsing it as HTML and extracting the text is a useless and potentially hazardous step.
The extension adds nothing. If you're calling it as "Reddit_Image_Scraper" and the program files /usr/bin/perl becaue of the shebang, then why introduce the artifact that it happens to be Perl?
I manually installed Tcl::Tk and related modules on my slackware machine a few years ago. IIRC, it had problems with detecting libraries to use to compile the modules. I don't know whether those bugs were fixed in the meantime. OTOH, new theming Tk is not much better than the old style, so I mainly use what comes with the machine in my Tcl/Tk apps. That is, I do not complain about the looks, because Tcl/Tk is pretty powerful combination by itself.
Here's what I meant by the "modern Tk" look. Here is Perl's `Tk` module: [Screenshot](http://i.imgur.com/Cb25J.png) (it's ugly, imho; not a fan of the old school Motif look). Here is what Tk looks like nowadays: [Screenshot](http://i.imgur.com/CAEFL.png) (much nicer). ActiveState's `Tkx` module provides the latter look (also Tcl, Ruby and Python's ports to Tcl/Tk look like that too). But the old Perl `Tk` module provides the former, ugly, look.
I am aware of the differences, but I think it's not enough to worry about. I like the new style, but the old one is also OK. Have you tried installing Tkx modules manually from source? I think that should work... EDIT: I have just now manually installed Tkx latest from CPAN. While it passes "make test", manually running test scripts fails with segmentation fault. I noticed when PERL_DL_NONLAZY is set to '1' then it works OK. 
If you mean what happens when `@l` / `@$car` is large, then you're fine; there's no copying there. But you are making temporary copies of all the elements in `@cdr`, which would potentially be bad if that's large. To avoid that in an idiomatic way you could write this as: sub myunshift (\@@) { my $car = shift; unshift @$car, @_; } 
Since perl-5.14.0 onwards, shift / unshift / similar ops work on arrayrefs also: % perl -wE'my $arr=[1..12];unshift $arr, 100;say$arr-&gt;[0]'; 100
I would say that using a temp variable that holds an arrayref is perfectly fine, even more so in situations with deeply nested data structures that you are accessing frequently. for instance: $thing-&gt;{foo}-&gt;[42]-&gt;{bar}-&gt;[11]-&gt;{frob}-&gt;[1] is a hashref that you're going to be using for the next few lines. Rather than writing that out or copy/pasting, assign it to a temp variable first: my $tmp = $thing-&gt;{foo}-&gt;[42]-&gt;{bar}-&gt;[11]-&gt;{frob}-&gt;[1]; $thing = $tmp-&gt;{thing}; $tmp-&gt;{frodo} = "dead"; ...
Hello, former lisp programmer! The one thing I'd lose is the prototype ( the (\@@) bit). They seemed like a good idea, and people coming from languages where they work like to use them, but they're just not useful in perl. They don't save you from having to check your input for validity, they're ugly, and nobody likes them.
This example of reimplementing a builtin is one of the few good uses of prototypes. Without it, the first array flattens.
I'm always impressed by how good tempire's writing, timing and delivery is. :) While watching it i wondered about two things: * Flash Does this run the danger of losing messages with users who browse using multiple tabs? For example, on a store site: I save some changes to my user profile. Now the user profile request errors out and redirects me to my user page with an error in the flash. Meanwhile however i click on a product in another page, which makes a page load wedge right between server sending me the request, and my browser following it. This would empty the flash and leave me unawares of the error, no? Also, is the flash bound to a single user, or is it per server request, meaning multiple users would nuke it too? If any of my interpretations here are right, what would be your intended use case for the flash? * Session Expiry This is not exactly specific to Mojolicious, but since you display the expiry proudly front and center: I've found that i actually never want to expire sessions. Doing so makes for a bad user experience and security can be gained in a much nicer way by making normal longtime sessions only allow non-critical actions, while critical ones require a password (but only the password) which grants a temporary high-level authentication. (See amazon.com for this kind of interaction.) Now, the question here: Does Mojolicious allow for maintaining of multiple sessions by user (kind of awkward, but eh) or the expiry of single keys inside a session (far preferred)?
&gt; Is it better/customary to use @{$_[0]} instead? As far as i'm concerned and have seen of others, this is only permissible when your function can comfortable fit into a single statement and line. Outside of that one single cases, it's always expected to name your variables nicely to aid understanding of the intent of the code.
Without answering your question directly, the thing that made references "click" for me so many years ago was someone told me that `$foo` is a "thingy", and Perl is pretty good at figuring out what sort of thingy `$foo` is, but sometimes, it needs a bit of help, so you give it a hint, like `@$foo`. Like most things in perl, the above is not entirely accurate.
Just like when you [linked to your site four days ago](http://catonmat.net/blog/perl-one-liners-explained-part-seven/), it still thinks " @@@ ... " looks like an email address.
It's crazy!
An addendum to this is that sometimes you want to force list context but you're not interested in the actual values but how many of them there are. An example is `m//g` which if used in scalar context has to be called repeatedly to get each match, but if used in list context [returns a list of all matches](http://perldoc.perl.org/perlop.html#Matching-in-list-context), so if you just care about the number you might write this: my @matches = "Carve a car out of caramel." =~ /car/gi; say "There were ", scalar @matches, " matches."; Assigning to the blank list `()` forces list context but discards the values. In this example we just want the count, not the strings themselves, so it can be written like this instead: my $nmatch = () = "Carve a car out of caramel." =~ /car/gi; say "There were $nmatch matches."; The operator precedence rules state that `=~` has higher precedence than `=`, so it is always evaluated first. `=` has right associativity, so the above is a more succinct version of: my $nmatch = (() = ("Carve a car out of caramel." =~ /car/gi)); say "There were $nmatch matches."; Since whitespace is not necessary, it could even be written as: my $nmatch =()= "Carve a car out of caramel." =~ /car/gi; ...which leads some people to call `=()=` its own operator. I've heard the name "goatse operator" used to describe it, but that's probably not a very photogenic name. What do you think, is this kind of tomfoolery too cute for its own good and should everyone just write the first version so as not to confuse people?
Fixed now, thank you.
[Plack it up as FCGI.](http://search.cpan.org/~miyagawa/Plack-0.9985/lib/Plack/Handler/FCGI.pm)
I assume that people maintaining Perl code should be familiar with context. The empty list context idiom is an idiom, sure, but once explained anyone who understands context at all should find it sane. (Contrarily, anyone who doesn't understand it--once explained--has no business maintaining Perl code of any value.)
i don't care if a few presenters don't want to be recorded. but what gets me is all the other talks that have been recorded and the recordings are never released online. [Presenting Perl](http://www.presentingperl.org) is pretty useless because there's nothing from YAPC or OSCON or any of the perl mongers meetups.
At $WORK we usually use catalyst instead of dancer and apache instead of nginx, but the psgi part is the same as the dancer/nginx stack. I assume you can get your webapp installed and test it with plackup, so skipping that part. We use starman (a psgi implementation) as our application server, to launch it we rolled an init script around the the command exec 3&gt; &gt;(logger -p ${facility}.notice -t "${prog}[init]") exec 4&gt; &gt;(logger -p ${facility}.err -t "${prog}[init]") daemon --pidfile=${pidfile} "starman --daemonize --pid ${pidfile} --listen :${port} --workers ${workers} --preload-app yourapp.psgi &gt;&amp;3 2&gt;&amp;4" First 2 lines are getting starman's errors into syslog, then the 3rd runs starman and sets up the pid file. Rest of the init script is all boilerplate vars, status, stop, restart, etc. We also use centos so adapt the init helper functions to whatever OS you're using. This has served us fine in production.
The docs say that that feature may be changed/removed in future versions, so be weary when using it. 
You may be interested to know there's a hackaday this Saturday specifically regarding making Presenting Perl better (and Perl Iron Man too). You may be interested in participating: http://www.nwewiki.markkeating.me.uk/index.php?title=Main_Page
That was [last year](http://www.nwewiki.markkeating.me.uk/index.php?title=Main_Page&amp;action=historysubmit&amp;diff=61&amp;oldid=57). :/
Yes, it was also last year -- but it will be done again this year, this saturday: http://mdk.per.ly/2011/09/21/hackability-3/ http://lists.scsys.co.uk/pipermail/northwestengland.pm/2011-November/000167.html Hope to see you there / on IRC on Saturday :)
Well dang, that's nice. I've been meaning to hack some RSS onto PresP and that sounds like a good excuse to do it. :)
&gt; *For most Perl programmers, using Perl is more than a job; it’s part of one’s identity.* 
I didn't get to see the article, because all that's on the page is "Proudly powered by Wordpress." Is that the joke? I don't think so because I am pretty sure I remember Mithaldu saying that he keeps things positive (not snarky).
Your browser's definitely doing something weird. The "proudly powered" bit is in the html, but in a commented section.
You've got an unclosed `&lt;!--` just before the `nav-above` section. Chromium and some other parsers recover on the next comment's closing `--&gt;`. However, Firefox is trying to keep track of nested comments, so the next comment closing doesn't escape it. 
I don't think the "most" is correct there. It might be correct for the "most Perl programmers who participate in the community" but not the 100-500K other people who don't even ask questions.
I'm not affiliated with shutterstock. :) Also, wow, that reminds me why i don't use Firefox.
As a programmer who constantly hears "but it worked in the older version", your comment frustrates me. 
I'm unsure what that refers to.
Sigh, another "Moose is the greatest" article. Perl is not Moose. Lots of people love Perl who don't love Moose, or at least, don't love it quite as much.
Its taken me a long while to realise that I'm really into Perl. Myself being a bit of a "geek of all trades" I've found it really difficult to focus where my career is going. Only recently I've come back to Perl, after "getting by" for a number of years, i got stuck into learning Modern Perl and haven't looked back. Only problem is there appears to be a lack of jobs in Perl - so I treat it as my hobby language (which works out really well because I really look forward to doing some more Perl when i get home from work). Its good to see some Perl love!
You're objecting to one direct reference and one allusion in two sentences of the whole article, prefaced by the disclaimer "a few of my personal favorites"?
Sorry, I'll explain. From skeeto's comment there is a problem with the webpage's coding. As a user it's nice to have a web browser figure out what the programmer of the web page wanted, right up until it guesses wrong. As a programmer, it's hard enough to write code that works, let alone code that works with bad inputs. We tighten up the code so it doesn't make bad guesses, but that also limits the good guesses. I interrupted your comment to be "I don't use Firefox because it can't read bad HTML code." Please ignore anything I say, it's just been one of those days.
Ah, that makes sense and normally i'd agree with that. In this case however it seems that firefox is more uptight for no sane reason. I do not know the exact spec, but i doubt nested comments are an actual thing. Additionally i have never seen any other language do this kind of thing. Mind, that's not my main reason for avoiding it though. That reason has to do with FF's behavior in re memory over a long runtime.
I love perl. I'm not sure what moose is, other than having something to do with objects.
It seems to me that Perl has proportionally less semantic bullshit than other languages that one needs to wade through. Yeah, it's got its dark corners, but for the most part I find it's very easy to write code that expresses my intention instead of fiddly details of the language.
And yet we have trouble finding good Perl developers. There are Perl jobs out there, desperate for good candidates, you shouldn't have to look hard to find one.
Most of these jobs make one very important mistake: They don't offer relocation.
Nice article, even though a bit late and curiously lacking any mention of the fallout of the study: * http://blogs.perl.org/users/mithaldu/2011/10/perl-tutorials-suck-and-cause-serious-damage.html * http://szabgab.com/perl_tutorial.html * http://perl-tutorial.org I've emailed them, let's see if they'll amend or make a follow-up article. :)
The aim of the study was to see how people would learn if they googled "&lt;language&gt; tutorial" and went with the first result. I'll let you do that for yourself. :)
At the most basic level, I use Perl simply because it's the language I know best. Though of course it's not suitable for some tasks I do - obviously it can't do what Javascript can, for example. But perhaps more importantly, the whole way Perl works means that I can produce a particular result much quicker than I'd be able to do using other languages. Over the years, I've used a number of languages: BASIC, COBOL, REXX, C, Pascal, Java (oh god, that's a horrible language!), SCL, etc. but it's only when I've used Perl that I've been surprised at a job taking less time than I anticipated.
Yet, the conclusion of the study was pretty damn suspect. If you assume that the "worth" of the very first-to-google tutorial of a language is equivalent to that language's suitability to beginners, you're really making huge leaps. First, I really don't care if a beginner starts with a half-assed understanding of some of the more complicated stuff. Nobody is going to be hired as a Junior Developer after 2 weeks of reading tutorials on their first language. If you can get out of the "GOTO" habit, you can get out of any. Perl is a great language for beginners because it is so forgiving. Because you can bend the rules and even if you don't quite know why, it works. You don't want to check that in as Linux Kernel source, but what the hell. I think you're more likely to learn how to program if you can skip some of the "syntax error!" bs for a few months. I think that terrible program that's been going around is the very support for this point. A new programmer *could* have written that piece of junk. With all the serious mistakes made in it. It still ran correctly.
I'm not saying the study is in any way defendable. It was pure crap. But it did accidentally highlight an important issue with Perl.
The article makes a nice point (that the study was poorly designed; see [Mithaldu's nice links](http://www.reddit.com/r/perl/comments/me8va/perl_not_suitable_for_beginners/c3079ai) in another comment) but in rebutting the study the authors miss an important point. *Perl is a crappy language in which to learn good programming techniques*. Perl is a hyper-flexible grab bag of a gazillion tools. People who are learning to write software don't need a hyper-flexible grab bag of a gazillion tools, they need a system that imposes some understanding of architecture and steers them in the (or at least a) right direction. A novice diving into Perl programming has access to a bazillion tools including GOTO, most of which are completely unmaintainable unless used in extreme moderation. This promotes development of crappy glued-together modules that sort of work, but show lots of heisenbugs. That is not a fault of perl *as a programming language*, but it is a downside of perl *as a learning environment*. Perl is a great language to code 'most anything in, but it requires some discipline and some understanding of architecture. Unless that understanding is being imposed externally by draconian pedagogy and homework grading, Perl itself is not a great environment in which to learn the architecture, precisely because things can be made to work so many different ill-advised ways. The venerable UCSD Pascal or the more hip Python offer a little more structure and a place to develop a sense of architecture and of what is maintainable. They are great first languages. Perl is a great last language.
Pretty sure we offer relocation since I got relocated for the job. The bigger problem is most people aren't willing to be relocated, in my experience.
What's your company then? :)
&gt; People who are learning to write software don't need a hyper-flexible grab bag of a gazillion tools.... Perls 1 - 5 weren't designed to teach people how to write software. They were designed for people to get things done. Note (with as little irony as possible, please) that most of the features added to Python in the past five to seven years are for getting things done, and not to teach people how to write software. For good reason the modern version of Pascal is C#, not Pascal.
Perl was the first functional language I used "to get things done" when I became a systems engineer. I have to say that I am very grateful that I took a lot of Java classes before coming into perl, because the background and theory proved very useful and advantageous to me. That being said, I do think it is better to start with a more mainstream OOL before moving into Perl because it gives you a much more solid foundation to build on.
Liquid Web http://www.liquidweb.com/about/jobs.html We're hiring in Lansing, MI and Scottsdale, AZ. 
&gt; That being said, I do think it is better to start with a more mainstream OOL before moving into Perl because it gives you a much more solid foundation to build on. How so, and what do you consider "more mainstream"?
Alright, some criticism on that then: No mention what the minimum perl version at your company is, no mention of your policies on CPAN, no mention of test coverage of your software, no mention of what VCS exactly is predominant in your company, no mention of relocation, no mention of a salary range, no mention of how many other Perl developers you have there. If i wasn't on another continent i might be interested in applying, if only to roll the dice on where your shop is between mediocre and downright painful. If you write a job ad for a Perl developer, don't write about what you want, write about what working for you would be like.
I would consider Java and Python being in that category. Not because they are in any way better than other languages, but because there is a wealth of information available online for people learning those for the first time. 
First off, that book is very outdated and teaches bad things in this day and age. Please head over to this site and select another, newer tutorial to follow: http://perl-tutorial.org
And to answer your question: In this line: $words{$name} = $word; The lines of the file are being inserted into a hash. It is a sort of unordered arrays where you can retrieve values by using an arbitrary string as index (key). This retrieval and thus the comparison is done here: } elsif (($words{$somename} || "groucho") eq $someguess) { And the tracing part is a good idea. There are two options for that: Either using Komodo IDE, in order to get a GUI like Visual Studio; or running the script with `perl -d script.pl` on the command line.
I don't write the job descriptions, but thanks for sharing. I've never seen a job description mention much of anything you seem to think is expected. I'll answer the ones I can. We use git for vcs; we switched from svn a couple years back. We're currently stuck on perl 5.8.8, because that's what CentOS 5 has, and we haven't gotten to the point of rolling our own yet. We're hoping to remedy that early next year. We use stuff from CPAN if it fits what we need (notable examples we regularly use are DateTime, HTML::Mason, DBIx::Class, etc). There's not a lot of flak for getting new modules from CPAN, and we're working on making it even easier. If you mean contributing to CPAN, we are all for it. We haven't done it much only due to time constraints, but I've been trying to push for making it more of a priority. We don't use Moose yet because it performs terribly under the version of Perl we're using. We plan on re-evaluating it after we upgrade Perl, but if it's still a dog, we likely won't use it. We don't have detailed test coverage numbers yet (getting devel::cover into our nightly test run is being looked at, but unfortunately devel::cover is not very modular, so it's difficult to integrate), but if I had to guess, probably somewhere around 40%. The team is about 15 developers currently, up from 3 when I started 3.5 years ago. We're working towards rapid release cycles, currently every 3 weeks (although sometimes that slips). It's a growing company, they treat people like human beings (i.e. no death marches), and it's a pretty relaxed culture all around (flexible hours, lax dress code, cordial team members, etc). There is legacy code, yes, and not every dev is a guru, so even some newer code isn't fantastic, but we're good about allowing for refactoring pain points, as long as it fits in with the goals we're trying to accomplish as a company. I really enjoy working here, or I wouldn't promote it.
&gt; I've never seen a job description mention much of anything you seem to think is expected. Yeah, your job ad looks like all the others that aren't getting much response. :) Note that i don't think that's expected. That's just what **I** would like to know and what would make me excited about a company. &gt; We use git for vcs See, that's amazing. I've so far not seen a single company that uses it. And your ad shoots itself in the foot by going "CVS, SVN". &gt; We're currently stuck on perl 5.8.8 Welp, at least it ain't 5.8.6. But be honest about it upfront and communicate that you know it's not optimal and want to fix it. That's great! &gt; There's not a lot of flak for getting new modules from CPAN, and we're working on making it even easier. This is good and especially the second part shows you mean it. I've had companies tell me this before and they meant "yeah, you can copy .pm files into SVN". I've come to expect the worst, so hearing it said solidly to the opposite is great. &gt; If you mean contributing to CPAN, we are all for it. Sweet. At one previous gig i was required to fill out forms for this kind of stuff. &gt; We don't use Moose yet because it performs terribly under the version of Perl we're using. Tried Moo yet? &gt; our nightly test run You have a nightly test run! Anyhow, rest sounds great as well and THAT's how you advertise a job. Now i'm actually annoyed about being on the wrong continent. You actually have a pretty sweet thing there, but hide it behind a terribly bland and copy-pasted online presentation. Talk to your HR about getting that stuff reworked and make sure the ad looks like a description you'd give a fellow Perler on IRC.
I've been struggling with OOP and I'm most comfortable with Perl. Thank you, that's exactly the kind of resource I was looking for.
&gt; while ( defined ($name = &lt;WORDSLIST&gt;)) { The file is indeed being read in a loop...
Are you saying that *Learning Perl* is outdated, or that the version referenced is outdated?
Are those learning materials better than Perl tutorials? (Yet again, I must point out that Python's object system is *not* better than Perl's. It has better syntax because it doesn't have surface-level references, but it has the same problems.)
This one might be decent: http://shop.oreilly.com/product/9780596520113.do This one is passable (doesn't introduce strict and warnings first): http://shop.oreilly.com/product/0636920018452.do The one he linked is downright terrible to learn from.
&gt; (Yet again, I must point out that Python's object system is not better than Perl's. It has better syntax because it doesn't have surface-level references, but it has the same problems.) I keep seeing this Perl / Python object system comparison made, but googling for more info doesn't get me anywhere. Can you provide links to more info or discussion? Thanks.
It honestly baffles me why anyone would want to learn (or teach) perl OO without using Moose, these days.
Yeah, I have the 5th edition... I just wanted to clarify. Thanks.
I personally found Perl tutorials to be exceptionally underwhelming. In fact, most of them are geared towards programmers who want to incorporate Perl into their repertoire. There's been articles posted here about just how bad the state of Perl tutorials on the net are.
That was me and the title was attention-grabbing and slightly inaccurate. Not all Perl tutorials suck, just most of those you find with Google. Here's a list of pretty good [perl tutorials](http://perl-tutorial.org).
thank you!
Essentially they both take the approach that an instance is just a hash/dict with attributes stored by name. Methods are just functions that happen to be in a namespace. Anything else that happens to be in that hash/dict or namespace that you didn't intend to be a method or an attribute--too bad.
sounds good to me ( but you really got to push for &gt;5.8.8), So ... would they relocate from overseas?!!! 
No idea. The bigger issue than the relocation expense is the visa. We're not a big company; we've never done it before. You're welcome to apply and see what happens.
You can use it energetically, but you should be cautious about using it in the first place.
They may be stuck with a vanilla Perl for whatever reason?
Just mentioning Moose makes my computer memory start to swap.
I've had good experiences with nginx/starman/plack/dancer http://search.cpan.org/~miyagawa/Starman-0.2014/lib/Starman.pm For my init script I adapted Dave Rolsky's Silki init script http://cpansearch.perl.org/src/DROLSKY/Silki-0.11/eg/ubuntu-init.d/silki 
http://www.perlbrew.pl/
Moose makes sense for nearly all the times you'd want to write OO code in Perl. What are you doing where Moose doesn't make sense? 
Moose can actually save memory in the long run if done well because you don't have your drool-n-paste parameter validation code duplicated everywhere (including bugs).
Then local-install moose or one of the many "lite" classes. If you can't write to any folder on the drive you're working on, then you're not writing perl for the system anyway. If you can do nothing but type on the system you can paste http://search.cpan.org/~gfuji/Mouse-0.97/lib/Mouse.pm into a file. Availability of a Moose-compatible object library is no longer arguable. Every system has trivial access to it. More importantly, it's more perl than vanilla perl. It's easier and cleaner than perloo, as well as more hackable.
Good tutorial, thanks for the link.
Moose isn't high on memory use. It can be a bit high on startup time, if you are doing a lot of class introspection, though.
This is a terrible program for beginners. It's not doing anything really complicated or hard to understand, but it's covered by so many layers of syntactic cruft that it scares you off.
Moose is really not necessary for doing good OO code in Perl. A plain collection of subroutines in a package can be quite effective.
All too often, people think they have to use something like Role::Tiny to implement a role in Perl, when they could do it just as well in a few lines using standard features.
Perl is not really necessary for doing good code. C can be quite effective. But... it's *better* than stock, mature, stable, clean, and portable. There's a reason people started using the std &lt;string&gt; in C++ is because it was better than the char*.
All too often, people think they can reinvent something coherent in a few lines, and then they miss important features and introduce silly bugs.
tip: say $foo; is exactly equivalent to print $foo,"\n"; That is where the newlines are coming from. 
That would do it. What can I use to write into the file aside from 'say'?
I changed it to print $fh1 $row . "','"; so it looks like progress, but the program only writes some numbers, not all. The original set of numbers is: 18 29 30 31 32 33 34 35 111 104 55 68 69 70 73 92 95 96 99 103 75 77 78 83 86 87 89 109 112 114 115 The output is: 29','31','33','35','104','68','70','92','96','103','77','83','87','109','114','116', Interesting....
 while (my $row = &lt;$fh&gt;){ my $row = &lt;$fh&gt;; You're reading a line then immediately reading another line. This means your loop is only processing every other line.
In addition to skipping every other line, you're currently closing and re-opening the output file on every iteration of the loop, which is definitely not what you want. If your file is relatively small (say, less than 50MB) you might also consider doing it in list mode, which reads all the lines into memory. This way you can use `join` on the values so that you don't have that trailing comma problem. Also, `autodie` automatically adds error checking to things like `open` so that you don't have to write the `or die ...` stuff yourself. use strict; use warnings; use 5.010; use autodie; open my $infh, "&lt;", "inputfile"; open my $outfh, "&gt;", "outputfile"; chomp(my @numbers = &lt;$infh&gt;); say $outfh join ", ", map "'$_'", @numbers; 
Where is said script? I had a look around their CSV repo but didn't find it.
http://www.openbsd.org/cgi-bin/cvsweb/src/libexec/security/security You're welcome.
That code is actually good! Thanks for the link. :)
Thanks, this is nice and short. Small question, for my edification. How is it that the string does not begin with a comma? (i.e. the outputfile manages to not begin with ","). Also, what if this were... a 50 MB file that was rapidly increasing over time?
It doesn't begin with a comma because the `join` function is defined that way -- it inserts the string between list elements, but not at the front or end. If the file was large and/or constantly growing then you would read it a line at a time in a loop like you originally wrote, but you'd keep some flag that tells whether this is the first time so you can skip outputting the separator, e.g. my $firsttime = 1; while (my $line = &lt;$infh&gt;) { chomp $line; if($firsttime) { $firsttime = 0; print $outfh "'$line'"; } else { print $outfh ", '$line'"; } } Or by using the built-in line count variable: while (my $line = &lt;$infh&gt;) { chomp $line; if($. &gt; 1) { print $outfh ", '$line'"; } else { print $outfh "'$line'"; } } Or possibly using the `state` feature: while (my $line = &lt;$infh&gt;) { chomp $line; out_with_sep($outfh, ", ", "'$line'"); } sub out_with_sep { my ($fh, $sep, $data) = @_; state $first = 1; print $fh $first ? $data : ($sep, $data); $first = 0; } However, that kind of trickery doesn't scale well if you want to use the same function to output to more that one file handle, so in that case it would probably be best to make a utility class. 
I was a little scared when the first sub I saw had a prototype, but it's reasonably used.
Considering that Strawberry contains gcc, shouldn't it / couldn't it be presented as full blown alternative Mingw distribution?
Theres not that much to reinvent when it comes to roles. Multiple inheritance gets the concept out in a way that looks nicer to me than using some of the modules out there. It seems that with the new documentation Rolsky is skipping over how to implement roles using plain Perl and immediately skipping to the CPAN modules. Perhaps I may be more convincing with a concrete example: package Dumpable; use Data::Dumper; sub dump {print &amp;Dumper} package Cat; use parent "Dumpable"; sub new {my ($class, %args) = @_; bless \%args} package Dog; use parent "Dumpable"; sub new {my ($class, %args) = @_; bless \%args} package main; my $dog = Dog-&gt;new(says =&gt; "woof"); $dog-&gt;dump; For whatever reason, I like to do roles this way and its not being represented in the new docs.
This will happily run with no warnings or errors, apart from the die when the dog dumps: use strict; use warnings; package Debug; sub dump { die "CORE DUMP!!!" } package Dumpable; use Data::Dumper; sub dump {print &amp;Dumper} package Cat; use parent -norequire =&gt; "Dumpable", "Debug"; sub new {my ($class, %args) = @_; bless \%args} package Dog; use parent -norequire =&gt; "Debug", "Dumpable"; sub new {my ($class, %args) = @_; bless \%args} package main; my $cat = Cat-&gt;new(says =&gt; "woof"); $cat-&gt;dump; my $dog = Dog-&gt;new(says =&gt; "woof"); $dog-&gt;dump; If you do the same with roles however you'd get a helpful error informing you of a collision between methods. (And don't think this is unlikely to happen, i've frequently had clients ask me in confusion why their script suddenly broke then they rearranged the use statements in their application objects, because they loaded both CGI and LWP::Simple.)
Method collisions in my roles aren't always a concern for me, and if they were I'd use one of the many fine role modules out there. Although, it may work to call the method like `$cat-&gt;Dumpable::dump` or `$dog-&gt;Debug::dump`. I just don't like the phrasing in the new tutorial about how roles instantly mean to use CPAN modules. The concept is about mixing in methods, not the additional checks that the CPAN modules provide. The idea of a role, or a mixin, or an interface are not new. Lines like "Roles are relatively new to Perl, but have become rather popular." or that while multiple inheritance "is possible, we strongly recommend against it. Generally, you can use roles to do everything you can do with multiple inheritance, but in a cleaner way." bother me because its making roles seem like they are doing something conceptually different. Put more simply, the new OO tutorial makes it seem you can mix in methods with either a role or multiple inheritance, but using a role is better, and by role it means to use a CPAN module like Role::Tiny, Role::Basic, or Moose::Role. Where it should be that you can implement a role using multiple inheritance or a CPAN module.
The language is called CPAN, the Perl interpreter is merely a life support system for it. I'm not sure if you follow P5P, but the sentiment is increasingly growing that the core should function merely as an access system for the CPAN. &gt; its making roles seem like they are doing something conceptually different. They are. Inheritance is about saying X **is a** Y. Roles are about saying X **does** Z. Also, read up on this: http://en.wikipedia.org/wiki/Diamond_problem
I know there are differences in the ways methods are resolved between some CPAN modules and inheritance, but the above example shows a role, even though it uses plain inheritance to implement it. You can take the Dumpable role an use it on any class you want. It is conceptually the same as a module written this way: package Dumpable; use Role::Tiny; use Data::Dumper; sub dump {print &amp;Dumper} package Cat; use Role::Tiny::With; with "Dumpable"; sub new {...} package main; my $cat = Cat-&gt;new(says =&gt; "meow"); $cat-&gt;dump; A concept is just how you think about something. Both versions of Dumpable are conceptually the same. If you're thinking of the first version of Dumpable as a base class, you are thinking about it incorrectly, since its not how its meant to be used. **It's still a role because it mixes in methods**. You could use the builtin isa method to determine if a class does a role, but that doesn't mean you should think of it as an isa relationship.
You wrote: &gt; I know there are differences in the ways methods are resolved between some CPAN modules and inheritance, but the above example shows a role, even though it uses plain inheritance to implement it. Sorry, but this is not correct. To be true to the original intent of traits as written to avoid the issues with inheritance and mixins, [roles need to be commutative, associative, and have zero or more provided methods and zero or more required methods (at least one or the other)](http://scg.unibe.ch/scgbib?display=abstract&amp;query=traits+the+formal+model). If those properties don't hold, you don't have traits/roles. (To be fair, those properties don't hold in Moose, either, but it's very, very close).
&gt; It's still a role because it mixes in methods. Nonsense. You can put a bowl of flour, salt, and cocoa powder in the oven for 25 minutes at 350 F and claim that the eggs, milk, and butter are mere implementation details for experts and not really important, but you don't have chocolate cake. If you don't have compile time dependency resolution and collision warnings, you don't have a role. If you don't have flattening into a single entity, you don't have a role. If you suffer the diamond inheritance problem--even if you use an ordering algorithm such as C3--you don't have a role. If you don't have the option to reimplement everything and still declare allomorphism, you don't have a role. If you don't allow parametric allomorphism, you don't have a role. Programming is hard enough without half-hearted reimplementations of a tiny fraction of a fundamental concept passed off as the thing itself.
&gt;&gt; It's still a role because it mixes in methods. &gt; Nonsense. No *this* is nonsense. Forget programming. Think of the word "role" as an English word. A dog can perform the role of a guard and a companion. A cat can do the companion role. Now back to programming. If you were to try to write a dog and cat class without "roles" you might write something like: package Dog; sub guard {...} sub interact {...} sub new {...} package Cat; sub interact {...} sub new {...} Some people may start to complain since you are calling them packages in the code, but you know better that its really a class. And then they'll complain some more about how nonsensical you're being because it doesn't **even** handle encapsulation, and that you have to use a CPAN module which allows you to specify that some of those subroutines are private, or protected, or public, before you even consider calling it a class, because that's how Java defines a class. And all of Java's implementation details have to be there, or else its not a "class". Then if I take the code and extract methods to what I naively think of as roles: package Guard; sub guard {...} package Companion; sub interact {...} package Dog; @ISA = ("Guard", "Companion"); sub new {...} package Cat; @ISA = ("Companion"); sub new {...} Some people may start to complain since I'm calling them packages in the code, but Im considering them as roles. But what do I know, it doesn't **even** resolve methods the same way as Moose. Whatever you call it, and whatever the implementation details are, the purpose of it all is to take a set of methods and extract them in a way that you can mix them in with other classes. I've always considered roles, interfaces, and mixins to be the same thing. But if you don't consider the collection of subroutines in the Guard package above a role, what are they then? 
&gt; And all of Java's implementation details have to be there, or else its not a "class". I'm not talking about Java's broken definition of classes. I'm talking about what *we* defined as roles in Perl when we named them. &gt; I've always considered roles, interfaces, and mixins to be the same thing. They're not. Interfaces and mixins have problems that roles don't have. You can tell that roles are not interfaces and roles are not mixins because roles do not have the problems of interfaces and roles do not have the problems of mixins. We use different words to describe different things because the differences between different things are important. &gt; But if you don't consider the collection of subroutines in the Guard package above a role, what are they then? Methods in a base class, with the concomitant drawbacks of runtime inheritance. Note, once again, that roles do not suffer these drawbacks. Feel free to call them roles if you must, but you're going to confuse people who don't know what roles are and annoy people who do, because you're using a word with a specific and precise technical definition in a fashion completely unconnected to its well-defined meaning. Also your cake tastes terrible. Note that your base classes are neither interfaces nor mixins either.
I think you are confusing a concept with implementation details. I used to call them interfaces or mixins, then then the Perl6 and Moose people started using the term "role" and I liked it because it was the right word for the job. It may have meant "Perl6's interfaces". But with all the modules and langauges that support it now, the term "role" no longer refers to one particular implementation.
&gt; I used to call them interfaces or mixins, then then the [Perl 6] and Moose people started using the term "role"... No, we started using the term "role" because what we'd come up with was *different* from interfaces and mixins. We were well aware of the flaws of interfaces and mixins. The reason I wanted roles in the first place is because I wanted something which provided typesafe allomorphism and independent of implementation as well as composable and reusable behavior. You don't get that with interfaces and you don't get that with mixins. From my mail archive, Larry first mentioned the word "role" on 26 September 2003. (I'd been arguing for something like roles for a while. Then Allison pointed to the Traits paper; she and I had seen Dr. Andrew Black present it a couple of days prior.) Larry wrote: *As I see it, Interfaces are a degenerate case of Traits. Traits are Interfaces that happen to able to provide some or all of the implementation, rather than forcing the class to redefine it all.* ... but remember, this was based on the reading of the formalism presented in the original paper to which Ovid refers. (I read that paper while waiting in line to see "The Return of the King".) Larry also wrote: *We could also leave the door open for Traits with state.* ... which the original traits paper explicitly avoided. As for mixins: *When we add roles to a class or object at run time, we construct a new class by the Rules of Roles (hmm), which works much like mixins, only better.* ... and: *All of these roles would presumably be parameterizable, able to function as generics.* On the very day when Larry came up with the word "role" to refer to what we'd been discussing about the Perl 6 OO model, we'd already dealt with the unique properties of roles to distinguish them from inheritance (single and multiple), interfaces, and mixins.
If you get too precise with your definitions then you can't call anything anything because its not really like the thing before it. You may not like Java's implementation of the concept of a class, but if you had to talk about Java for some time, you may get tired of saying the-thing-that-you-use-to-instantiate-objects-and-define-what-actions-that-object-can-perform-but-isnt-a-class because at its core it is a class, just a different implementation than the one you're used to. I would consider the following list of functions written in C a class, even if its syntactically different from what you expect: typedef struct Dog {char *name;} Dog; Dog *dog_new () {return malloc(sizeof Dog);} void dog_guard (Dog *dog) {...} void dog_interact (Dog *dog) {...} I might use the gobject library to get the implementation details I like. But its all just a different way of defining a class than most are used to. But if you really think about it, it is just that. If I had to convert code written in another language that had a class keyword, I would most probably end up with something that looks like the above. I don't agree that a role is different conceptually from a mixin or an interface. You would never see code that makes a class that does a role, then implements an interface, then uses a mixin because its all the same concept. You would choose one and go with that when describing it.
&gt; I don't agree that a role is different conceptually from a mixin or an interface. Good luck communicating with other people then.
No, you called them roles because you wanted a way to mix in methods with your classes, and role's are a good name for that. And Larry is great at coming up with the right term for things, and is one of the reasons I like Perl so much. You wouldn't consider the concept behind "next" completely different as other language's "continue" statement, so why are you trying to mix up the implementation details of "Perl6's roles" with the concept of a "role"?
&gt; No, you called them roles because... Were you in the discussion eight years ago? &gt; why are you trying to mix up the implementation details Have you read the Traits paper? &gt; you wanted a way to mix in methods with your classes What else did we want? You left out a few things.
So is it valid to want an interface in Perl6? If someone was used to Java's interfaces and needed to make something in Perl6 would you recommend they create a library on CPAN6 that implements interfaces, or would you tell them to try out roles because the concept of what they're trying to achieve is the same?
&gt; Concept This is a general notion that doesn't have anything to do with Perl6 or Moose. I can say that a dog performs the role of a guard if its guarding someone. I can say the same about a class written in any programming language. The Dog class does the Guard role. If I said that and you didn't know what programming language I was talking about, would you correct me to say what I meant was that the Dog class implements the Guard interface? or would you need me to clarify whether the Dog class was really mixing in methods from Guard. Please, ffs realize that its all the same. Whether they knew it as a concept when they came up with it for Perl6, it is now one. &gt; Implementation How does the code implement the Guard role? or implement the Guard interface? or mix Guard in? You can write it in Perl6 with a role keyword, or use Role::Tiny in Perl5, or Moose, or even with inheritance, or just with a set of functions with a comment at the top saying that these functions represent the Guard role.
An interface is a degenerate case of a role. Define a role with requirements but no implementations and you have an interface. Note that the converse is not true: while you can easily use roles to implement the behavior of interfaces, you *cannot* use interfaces to provide the behavior of roles roles.
&gt; I can say that a dog performs the role of a guard if its guarding someone. You can also say that my nephew is going back to *class* on Monday. That's not talking about a specific technical concept in the realm of programming either. If you want to &gt; How does the code implement the Guard role? or implement the Guard interface? or mix Guard in? In different ways, respectively. That's why non Dumptyists use different specific technical words in a specific technical context to refer to specific technical concepts. We kinda like communicating accurately. See also the works of Christopher Alexander. Put another way, if I were to write a class which performs the Guard role, I want compile-time method resolution, dependency management, and flattening composition--all with the concomitant error checking. Show me how to accomplish that with inheritance or interfaces or mixins.
Yep, go with WxPerl (or Tkx if you need something quick and dirty). Have a look on a project, like [Padre](https://metacpan.org/source/PLAVEN/Padre-0.92) to see how things are done. Should you think about giving Tk a try and need some very nice documentation have a look [here](http://www.tkdocs.com/tutorial/). Tk tends to be easier, especially if you do smaller stuff and is enough most of the time. On the other hand that doesn't mean Wx is hard, so don't be afraid of simply trying it out.
&gt; Show me how to accomplish that with inheritance or interfaces or mixins. You write a language and you call an interface something that lets you do that. Some languages like Java consider an interface a collection of method definitions that the class that uses it has to define. Other libraries such as the very well thought out GObject library think of interfaces more as what Java considers abstract base classes (except it lets you use more than one of them) and lets you define code in the interface that's meant for common use and inclusion in multiple classes. http://developer.gnome.org/gobject/stable/gtype-non-instantiable-classed.html. GObject's notion of an interface is much more in line with what I consider a role to be. The mistakes of Java's design doesn't make an interface what it is, since other languages have things that they call interfaces too, and they are not wrong for differing from Java's definition. C++ calls an interface an abstract base class with pure virtual functions. People have been kicking around this idea for a while trying to get the terminology down. I think at some point people will forget the terminology of a particular language and get a concept that works like what happened with "class", and "role" seems the natural fit.
&gt; other languages have things that they call interfaces too ... C++ calls an interface an abstract base class with pure virtual functions. Subtyping? Check, but.... Inheritance? Check. Lack of compile-time detection of collisions? Check. Lack of flattening? Check. Lack of reuse at a level smaller than that of a class? Check. Lack of genericity through parametric polymorphism? Check. "I think you are confusing a concept with implementation details." &gt; I think at some point people will forget the terminology of a particular language and get a concept that works like what happened with "class", and "role" seems the natural fit. As they say of C++, you can nail extra legs to a dog, but that doesn't make it an octopus.
That's Java and C#'s definition, not Gobject's.
An abstract base class with pure virtual functions are very close to Java's definition of an interface. Thats why its such a popular answer to this guys question at http://stackoverflow.com/questions/318064/how-do-you-declare-an-interface-in-c. But Java's definition is not any more valid than GObject's. They are both using an English word to describe a useful pattern related to modifying classes. In the above example, where I consider Cat and Dog as classes and Guard and Companion as roles, that design pattern is *something* that I find extremely similar to Moose::Role, and I think "role" fits because of its English definition, not because its the same as Moose::Role.
You might want to look into Citrus Perl, which is a binary Perl distro with a strong focus on WxPerl. It includes a fairly comprehensive demo application.
Unless something has changed dramatically, Perl-Tk can't handle threads. That means that the GUI will "lock up" during long-running back end processes. I would avoid Tk. Wx seems to speak threads, so that's good.
Exactly; you wrote: &gt; If someone was used to Java's interfaces...
&gt; But Java's definition is not any more valid than GObject's. They are both using an English word to describe a useful pattern related to modifying classes. Technical communication relies on the terms of art being self consistent within the jargon domains. If you introduce deliberately inconsistent and mutually conflicting definitions for the same precise terms within a domain, you might as well use the word "thingie". We name things to communicate.
No, I'm not. Not only have I been heavily involved with several implementations (either implementing or using), read the original papers quite carefully and corresponded with the original researchers to better my understanding, I can assure you that I am very much *not* mistaken in this matter. * There was a very specific problem identified. * Various "solutions" to this problem were analyzed and rejected. * A carefully thought out, [rigorously developed](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.126.2445) solution was found which addresses both the underlying problem and the limitations of subsequent solutions. If you simply claim that something is a "trait" without a clear understanding of it, you may as well claim that polymorphic methods are traits: it doesn't help matters to claim that something is something that it's clearly not, particularly when, unlike some other terms in computer science, we have a well-defined definition here. Now you *might* make an argument that Perl's roles are not traits and since they don't conform to the definition, I may have to agree with you on that. But since I have never seen a clear definition of Perl roles (other than "traits in Perl"), it's kind of a gamble. Role::Tiny, for example, deviates so far from the definition of traits that I don't think it even belongs in the Role:: namespace but other programmers I respect disagree. However, if you don't know what the underlying concepts are, it's awfully hard to make meaningful contributions to the discussion.
Well the web ui seems quite appropriate to me, there are many tools to make it very easy and quick to do using perl. But otherwise, WxPerl is the obvious second choice.
Im saying that an interface is a common set of actions that an object can do. For example, if an object implements an OnOffInterface, I would expect that I can turn the object on or turn it off. Like a lightswitch or a checkbox. Nothing more, nothing less. This is a very clear and precise definition that I can communicate to programmers of any language. You are saying that an interface is what Java defined it to be. Sure there are on-off actions, but you can't call something an interface unless you are not allowed to implement the common code in the interface, and that its got to detect collisions of methods at compile time, etc. Gobject should have come up with a completely different name for what it considers interfaces because it doesn't have all of Java's restrictions. You are thinking that the term "interface", when it applies to any programming language, will always be tainted by what Java implemented it as. And now "role" is tainted with all the implementation details of Moose. And that just because an object has on and off methods, doesn't mean it does the OnOff role. 
Man, this got so far off-topic. I doubt you still have a clear idea of what your point even is. Let me try and cut this short: You're worried that newbies will end up thinking and being taught that roles are the ONLY way to add methods to a class from the outside. What you're entirely missing is that all we're trying to say is that Roles are the way that will protect you the most from shooting yourself in the foot. And this is, since the document is a **tutorial**, meant to be read by newbies, absolutely imperative in deciding the content. Just as any Perl developer will discover that sometimes they will want to switch parts of strict off, they will still discover that they can do class composition with much more simple tools when needed. However the important thing here is that at that point they will know about the danger to their feet and will be able to make an informed decision.
If you don't want me to talk about roles, interfaces, or mixins unless I'm talking about your pet implementation, give me another term to represent the general concept of a common set of actions that can be applied to a class. If an object is Comparable it means that I can call methods lessthan(), greaterthan(), greaterthanorequalto(), etc on that object. Comparable is a &lt;blank&gt;. If an object is a Guard. It means I can call methods guard() on that object. Guard is a &lt;blank&gt;. Without adding implementation specific details, give me a term to describe that concept is. Or do you think that there isn't one?
The referenced "Why I hate `strict`" article misses one of the biggest advantages of `strict vars`: finding typos for you. If it's something like a 20 line example in a book, it may not *seem* like typos would matter since the book is presumably edited and tested, but when you're *writing* that 20 line program there's no guarantee that you won't make a typo in a variable name, and `strict` will save your ass from potentially hours of fruitless debugging. 
When the original researchers designed traits, they defined and named them. If you choose to ignore the fact that there's an actual definition out there and [the researchers *specifically* explained interfaces, mixins, and single and multiple inheritance and why traits are different](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf), well, I can't help the fact that you didn't bother to read the original research (or perhaps choose to ignore it). If you come out and say "I am deliberately using this word to mean something different from what the creators of that word meant", then that's OK. At least we can discuss *why* you're doing that and the strengths and weaknesses of your new definition. I'm happy to do that. Simply asserting that what you say is true and ignoring the definition of traits/roles doesn't help. As for the "term" you're looking for, if you offer behavior that an object does and that's all you do, then it's possibly akin to an interface. However, interfaces as they were originally created do not offer implementation. If you're asserting a direct isa relationship, you may be talking about mixins (because they're implemented via inheritance). However, without a full, clear description of what you mean, I *can't* give you that term. You declare that these methods are present, but ... * Is the implementation provided? * Are the components guaranteed to be associative and commutative? * Is conflict resolution dealt with? * Is this implemented via flattening, inheritance, delegation, or some other mechanism? * Are requirements presented? * Are there other features of what you describe that I should know about? There are far too many things to answer for me to just "give you a term".
That doesn't work on Windows, does it?
&gt; &gt; We could also leave the door open for Traits with state. &gt; ... which the original traits paper explicitly avoided. To be fair, the traits researchers realized that traits without state was probably a mistake. See the [Stateful Traits](http://scg.unibe.ch/archive/papers/Berg07aStatefulTraits.pdf) paper for more information.
Im saying that there is an important concept being filled by roles, or interfaces, or mixins which is to group methods together that fill a common purpose and that can be applied to a class. And just because some implementations picked an english word to describe their implementation, doesn't mean they own the term as it relates to all programming languages. * Java picked the word "interface" to define its implementation * GObject picked the word "interface" to define its implementation. * Perl6 picked the word "role" to define its implementation. * Role:Tiny picked the word "role" to define its implementation. If you were to sit down and write a language with a built in way of mixing in methods to your classes. You may want to call what you come up with a role, or an interface, or a mixin without copying all the implementation details of the things that came before. If you were writing an OOP tutorial you should mention what a class is in general terms, and mention what a role is in general terms. Then say that you can make a class using subroutines in a package or with modules like Moose. And that you can make roles using subroutines in a package or with modules like Role::Tiny. Start with a concept and end with an implementation.
They didn't create the word, they chose it. I don't know too much about traits so I wouldn't use that term to describe a setup to a program. But I do know what roles are, and Im able to see that what is meant by using the term in a programming sense is to mix methods into classes. If I wanted you to make me a program with a ComplexNumber and a DatingProfile class that is Comparable in any programming language you want. The only restriction is that the set of methods that comprise what it means to be comparable be in a common location. Depending on the programming language, you might use something called an interface or something called a role to get the same concept across. And you are saying that until you know the programming language you use, you can't call Comparable anything yet. It may turn out to be a role, or it may be an interface, and I think thats not a good way of thinking about roles or interfaces because of how important the concept behind them are.
Dude, you'd be a terrible teacher. Also, no, a role is not a thing that composes methods into a class. It is a thing that composes methods into a class while preventing you from shooting yourself in the foot.
"role" is a newer term that doesn't have as many implementations that conflict with your definition. So I'd like to focus on the differences between Java's interfaces and GObject's interfaces and use that to show my definition of a role is valid without focusing on a particular implementation. Javas interfaces lets you compose methods into a class while preventing people from shooting themselves in the foot by disallowing common code, for your class to implement a Java interface that class has to fill in the methods or suffer a compile time warning. Gobject lets you compose methods into a class but allows you to write code in a common place. Methods provided by Gobject's interfaces do not have to be abstract. Both are implementing the idea of "interface" in different ways. Preventing you from shooting yourself in the foot is nice, but isn't what defines the term.
Please give me a better name for Role::Tiny. Come up with a name for what its doing. If you really believe that calling whatever Role::Tiny is doing is completely different from what you think of a role. This is the heart of my issue with everyone claiming that the term role instantly refers to Perl6's implementation or whatever implementation you are thinking of. Give me a better name.
The point is, you would tell them to use roles since that gives them the ability to do what they intend. Because roles are pretty much the same thing as interfaces. If they were accustomed to switch statements you would tell them to use the given statement.
Strict saves my ass continuously.
I've been using perl pretty heavily for a few years and never use strict. I'm a self-taught hack so I'm probably not adhering to "good practices" but I always just found it annoying. One of the best features of perl, imho, is that it allows crappy programmers to write things that work without a bunch of syntax errors and the like. As the years go by I begin to appreciate "best practices" more and more and I'm only just starting to declare variables (sometimes) but I really think if 'use strict' was on by default I'd have gotten turned-off of perl when I was trying to learn at the beginning. 
&gt; Because roles are pretty much the same thing as interfaces. Almost. A role with only requirements and no behavior is similar enough to the Java concept of interfaces that you can use it in Perl when you want that Javaesque behavior. It's not completely the same; you don't get all of the Java drawbacks, but it's usually close enough.
I'm just saying that if all I know is that if something is big and grey, don't ask me whether or not it's an elephant. That's not enough information. Just saying "under condition X, you are guaranteed to have methods with the named @names" doesn't tell me enough about the behavior to judge utility. It *sounds* like you're describing interfaces. They're broken. We're know they're broken. But big and grey could sound like an elephant, too.
I haven't tried it yet, but i doubt it. ActivePerl comes closest, since you can tell the installer to leave your path alone and then make a batch that sets up the right path.
Welcome to my list of stupid trolls; people where i can't tell if they really are that amazingly stupid, or just trolling.
To me, there is a very clear concept behind the implementations of roles, interfaces, and mixins which is to group methods together that they can be applied to any class. And its very instrumental, particularly when writing a new OOP tutorial, to make a distinction between sets of subroutines to be thought of as base classes and sets of subs to be thought of as &lt;blank&gt; (Come on, you know "roles" or "interfaces" is the right word here.).
Im not trying to troll anybody. Just trying to get a concept across to you, but failing to do so. I should probably stop trying, since you'll probably never decouple the implementation of a concept from the concept itself.
You are the unwilling one here. The concept is method compositor. Base class, role, interface, etc. are just implementations of that concept. Now go away.
"method compositor" does work for those but I'm really looking for a term to encompass role and interface but not base class. Say a Dog is your class, Animal is the base class, Guard is a what? If I like to think of Guard as a role, why is that confusing? To me, its the right word for it even if I'm not speaking about any one particular implementation.
I think we've found the problem... ;^)
fwiw, I've done a lot of useful things with perl that many people have benefitted from. I don't think you want a language that only omputer scientists can use... we already have lots of those
Does it really take a computer scientist to understand why you might not want all variables to be global? That otherwise there's a very real possibility for different parts of the program to step on each others' toes? That doesn't sound like a very complex topic to me. JavaScript has the same issue: unless you declare them with `var`, all your variables are global. Despite being told countless times by countless books and guides, people still forget to do it and pay the price. I bet JS users would kill for a language feature that could be enabled that would allow the interpreter to automatically tell them when they forgot to do that. Python got this right: you have to explicitly ask for a global variable, otherwise it's assumed to be local. As I said elsewhere in this thread, `strict vars` has saved my butt more times than I'd like to admit when I made a typo in a variable name, so even if you're not in agreement on a philosophical level of what a program should look like, there are tangible practical benefits.
I'm involved in a bioinformatics project. The bio scientists there were very grateful about having strict explained to them by me, along with many other improvements to code quality like Perl::Tidy and Perl::Critic.
s/perl/Perl/
Haven't used Critic yet, but I use perltidy all the time. 
This is my last shot. If you disagree, you disagree, but... Say you have a concept for a program that must have a class for Shoe whose base class is Apparel and which implements Tieable. I'm choosing not to think of Tieable as a base class since that is not my intent. In one language Tieable might be *called* an interface, in another it might be *called* a role, in another it might be a mixin, another might call it an abstract class. But it will be one (and only one) of those. Therefore I think of interface, role, mixin, and abstract class as the same concept and since you agree there's no name yet to encompass that idea, I draw from the English language in the same way as those implementations did. If they chose a word thats a bastardization of the English word, say "prole", I'd allow them to keep it for their implementation, but they chose the word that best fits the concept. There have been complaints in this thread about how Role::Tiny and Moose::Role deviate so far from Perl6's implementation of roles, that they shouldn't be called roles. And maybe so, but they were left with a library that implemented something useful and chose to go with the name Role to describe it. I don't think people are confused by it, because there is a distinction between the concept of role and the implementation of it.
&gt; since you agree there's no name yet to encompass that idea I've called it an allomorph for quite some time now. &gt; I don't think people are confused by it... I argued against YAML::Tiny ages ago because, whatever it implements, it violates the YAML standard on purpose. Too much of the time ::Tiny is a catchy name which signifies that you can expect correctness to go out the window in favor of footprint. As for Moose, the only practical problem I've encountered is that I haven't yet convinced the cabal that the declaration of a named class should imply the existence of a role of the same name.
I haven't seen the term allomorph used too many places before, so I guess I jumped on using the term "role" too soon. And used it as a general programming word since if I was thinking about a role in Perl 6 it would be an interface in Vala (GObject based language). I liked "role" because it sounded more like English to me. Maybe I should always refer to the concept as "role-like" differentiate it from the implementation, or start using allomorph. Either way, I think a discussion of the allomorph concept is beneficial to understanding OOP and they should put it in the tutorial.
&gt; I don't think you want a language that only omputer scientists can use... we already have lots of those Of course, if you write $omputer when you really meant $computer, strict would help you right there.
I like that Moose is there, but I usually don't have a need to use it.
haha you've got me there ;)
I don't mind Moose being out there, though I don't use it myself... I do mind that some people appear to consider it essential to Perl, just like "`use strict`" and "`use warnings`". 
I barely ever use Moose, but I use strict and warnings all the time. Sometimes, like in a short one-liner its good to not have to declare.
Thanks a lot for taking the time to write this.
You need to set the element to an array ref `\@similar_ids`. Note the backslash. However, you dont need to do all that. Hash elements will autovivify when push onto them: push @{$local_php_scripts{$script_url}}, $message-&gt;{id}; Should be ok.
I swear I tried that. Will check again.
Nope -- I have... push @{$local_php_scripts{$script_url}}, $message-&gt;{id}; print "..." . $message-&gt;{id}; Dumper($local_php_scripts{$script_url}); And I know that portion of code is being executed because I can see the periods, but dumper still doesn't show anything. EDIT: I'm a moron. I thought Dumper behaved like var_dump, automatically printing the value.
Are you printing the Dumper output? print Dumper(...);
I think you replied before my edit.
Jeez, guys: perl -l054 -pe 0 inputfile
Or to get rid of the extra comma: perl -l054 -pe 0 foo | perl -lpe chop
I can't begin to fathom how this works. When I try it I just get this output in the terminal: 73, my input file has 73 as the last line.
Could you provide an example of another language's semantic bullshit?
It's a new way of writing object-oriented code in Perl. It's so good, it's one of the poster children for the Modern Perl movement.
-l means use the following octal value as the output record separator, and 054 is the octal value of the comma character. -p means print each line of the input. -e means here's the Perl code to run for each line, in this case just a 0 since we're not actually doing anything to the lines. % cat inputfile foo bar baz % perl -l054 -pe 0 inputfile | perl -lpe chop foo,bar,baz 
I gets weary and sick of trying. 
&gt;In conclusion, PHP is a templating language. *Was* a templating language. Now its a templating language with a bunch of shit tacked on.
First of all, you should read some documentation first. Blind experimentation rarely leads to good results in these kind of things. So, open() takes three arguments like this: open(FILE, "&lt;", "file.txt") or die $!; Checking for errors is really necesary. Error messages inform you what went wrong. In your case, errors just vanished into thin air. Also, check the path to your file. Are you sure it's in the root directory? 
my guess is that file doesn't exist but to see the error do this. open FILE, "/aTextFile.txt" or die $!; Also read about three argument open and using a variable as a file handle.
You've tried to open a file that doesn't exist or you don't have permission to read, but because you're not checking for errors, Perl is complaining that it can't read from the filehandle instead. Change your open statement to this: open FILE, "/aTextFile.txt" or die "Can't open file: $!\n"; 
perl lets you be all sorts of lazy, but that doesn't meant you *should*. I don't know what your problem is, but I bet I would get more useful error messages from the way I would write that code: #!/usr/bin/perl use strict; use warnings; use English qw( -no_match_vars ); MAIN: { my $fh; if( ! open($fh, '&lt;', 'aTextFile.txt') ) { die("ERROR: Opening input: $OS_ERROR\n"); } while( my $line = &lt;$fh&gt; ) { print( STDERR "DEBUG: Read $line" ); } exit(0); } 
My main overall suggestion is that you look for a more recent Perl tutorial. A lot of the code you have here suggests you're reading something out of date. + `use warnings;` is now preferred to `-w` on the shebang line + You should always `use strict;` + You're using bareword filehandles (`FILE`), but the very strong preference now is for lexical filehandles (`my $fh`). + When you open a file for reading in Perl, you can omit '&lt;', but it's not a bad idea to be explicit about it. + You're not checking for errors. Put that all together and you would get something more like this: #!/usr/bin/env perl use warnings; use strict; # put the file's name in a variable; you'll get better error messages my $file = 'whatever.txt' open my $fh, '&lt;', $file or die "Problem opening $file: $!"; while (&lt;$fh&gt;) { print $_ } Perl Training Australia provides pdf versions of their course notes freely. Maybe take a look at those: http://perltraining.com.au/notes.html 
Besides what everyone else says, I don't believe line 9 is 'while(&lt;FILE&gt;) {'. By definition, "#!/path/to/program" has to be line 1, otherwise it doesn't work. Unless you have double blank lines but only show single blanks, line 9 is 'print "iterating...";' Check out "Modern Perl" by mr_chromatic: ... http://onyxneon.com/books/modern_perl/. You can read it for free, but you'll want a paper copy so you can have it beside you. But don't forget the documentation that's in your computer. In a terminal window, type "perldoc perl" ... with references to dozens of hours of reading material
Check out http://perldoc.perl.org/perlopentut.html
A MAIN block with K&amp;R style brackets and an explicit exit(0), and explicit if not around open. That's some seriously C'ish perl. 
This might be personal preference, but I've always preferred parenthesis around my function arguments i.e.: open(FILE, "&lt;", "file.txt") or die $!; It parses a lot faster in my brain.
Making your own tuned VM appliance is pretty easy.
Try the LAMP image from [TurnKey Linux](http://www.turnkeylinux.org/lampstack)
Right, Do it once, and clone that VM as many times as needed.
Good article about prototypes, but it didn't explain why I should avoid creating them. Also, I couldn't log in to leave a comment.
Even though I've been in C-land the last few weeks, this still looked horribly gross Perl to me. 
Mostly this: &gt; Prototypes are not function signatures Many people think they're the same and that they are needed or helpful in the general case. The article just explains that they are not actually needed.
Heh, from the downvotes it looks like everyone else agrees with you! That's OK, there's nothing wrong with being a lazy hacker. I'd rather have one lazy hacker working for me than a thousand Haskell wonks... I would never write a small throwaway program in such a verbose way. What I would *actually* do is of course perl -ne 'print' &lt; myfile changing the print to whatever combination of sort/uniq the OP actually wants to do eventually. However, if I were starting a serious program, I really would write it like that; you could (probably should) use the perlish "open or die" pattern instead of the if() block, but everything else has a reason: - use strict; use warnings; is genuinely helpful for catching typos in large, complex programs with lots of nested data structures. - use English; helps less experienced programmers who can't yet tell you the difference between $? and $! in their sleep. - A MAIN block avoids having your subroutines polluted by global variables, with all the temptations to break encapsulation that come with that (try running some code which uses globals under mod_perl, and prepare to get very confused). - The explicit exit(0) distinguishes this exit code from any others you might want to use. Come on kids, get into the habit of writing *maintainable* perl. It really isn't that hard.
I used to think that prototypes were pretty much useless, until I read Higher-Order Perl and started to see the value of the coderef (`&amp;`) as first argument, which lets you leave off the `sub` and the comma (and of course the parentheses.) This allows a certain expressivity to extend the language in a way that looks like you've actually created new syntax when you haven't. A lot of CPAN uses this to great effect, such as: use Moose; use Moose::Util::TypeConstraints; subtype 'PositiveInt', as 'Int', where { $_ &gt; 0 }, message { "$_ is not a positive integer!" }; Wow, kinda looks like they must be doing some black magic with the parser or something, right? Nope, just prototypes. A quick look at the source and perhaps some use of `B::Deparse` will show you that this is really just syntactic sugar for a standard function call: subtype('PositiveInt', { 'as' =&gt; 'Int' }, { 'where' =&gt; sub { $_ &gt; 0 } }, { 'message' =&gt; sub { "$_ is not a positive integer!" } }); And `subtype` has a bit of code that explicitly merges its second and subsequent parameters, so it effectively looks like this: my $name = shift; my %params = map { %{$_} } @_; Which means that this is really like calling it as: subtype('PositiveInt', { 'as' =&gt; 'Int', 'where' =&gt; sub { $_ &gt; 0 }, 'message' =&gt; sub { "$_ is not a positive integer!" } }); ... which is a pretty standard and vanilla kind of API call (and is also documented as supported.) I get the impression that this throws people for a loop, thinking that modules that do things of this sort must be special. But as the saying goes, Moose is just perl. 99% of the time when a module uses syntax that looks custom it's either this use of prototypes or making clever use of the fact that `=&gt;` is synonymous with the comma. 
Ah yes... Perl... There's more than one way to do it... as long as you only do it the One Approved Way...
As others have already written, the main reason for your problem is probably that you're ignoring an error opening the file. An alternative to appending `or die` after the `open` is to `use autodie;`. That makes the error handling automatic.
It's really true. Otherwise why not send people joining the chat right to perldoc? 
No, you can do it however you like. Unless you want other people to be able to work on your code... I suppose this is why Google use Python.
"You can't just make shit up and expect the computer to know what you mean, retardo!" -- http://en.wikiquote.org/wiki/Mark_Jason_Dominus Perhaps it is just unfortunate that MJD gets his finger print on this well abused troll food. 
&gt; A MAIN block avoids having your subroutines polluted by global variables... I could agree with an explicit `main` *function*, but a labeled block doesn't quite work for me. I've begun the habit of starting my programs with `use` blocks and then `exit main( @ARGV );` for much the same reasons you recommend.
haha... no, I agree with you. My comment was directed towards the downvoters that consider you code to be "wrong" because you didn't follow their one approved way...
Ah so I can install that on my irix box? (Disregarding the fact it is specifically not allowed....)
&gt;The dog registration website was ASP.NET with __VIEWSTATE and __EVENTVALIDATION post variables Ugh, that's such a pain to work with.
At the top of the script: use warnings; use strict; require Digest::MD5; use Errno qw(ENOENT); use Fcntl qw(:mode); use File::Basename qw(basename); use File::Compare qw(compare); use File::Copy qw(copy); require File::Find; why does Digest::MD5 and File::Find loaded using **require**, while the rest is using **use**?
I've never used WWW::Mechanize. I have tons of shell and awk scripting experience, and a moderate amount with Perl. I'd like to bring my scripting to the Web. Is WWW::Mechanize a good place to start, or would I be better off with a different language all together? 
WWW::Mechanize is a Perl module. Python and Ruby also have modules called WWW::Mechanize or mechanize which you can use as well. If you're comfortable using Perl, then go ahead and use Mech. Read the numerous examples and the cookbook.
First: use strict; use warnings;
Second: $password in generatePassword() is a global variable. Now why does it give the same output for each call?
ahh. I needed to a bit more reading on creating local variables in perl. Thank you.
Downvoting because: * misspellings ("we have more the 10 years", "if you searching") * Perl, or perl; not PERL
Sign me up!!
Yeah, I have the feeling if you hire these guys you're going to get perl4-era garbage from someone who googled up a bunch of 15 year old tutorials.
Fantastic, thanks!
The [Perl Tutorial Hub](http://perl-tutorial.org/) gives some good recommendations. Have you experience programming other languages?
No I haven't... I am really starting from square one. Is there a book that was helpful? 
Depends how you learn best. I am a reverse-engineer sort of person, so I got a ton of value out of the [perl cookbook](http://shop.oreilly.com/product/9781565922433.do). There is some instruction, but also real-world recipes that you can use and modify.
This has been linked to in the past but the Learn Perl in Two Hours and 30 minutes is a really good overview/primer: http://qntm.org/files/perl/perl.html 
I saw that one but I am not sure if it breaks it down enough for me to really understand what it is I am actually doing. 
Thank you so much. I think gives me a good starting point.