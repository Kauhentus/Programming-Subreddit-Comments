Question number 2 is missing the choice, "Perl 6". That is, unless the question meant to ask instead, "What's the next version of Perl **5** that you want to use when you upgrade?" 
I guess brian will publish them only after he closed the survey.
I'm not sure if OP is the author, but there is a typo in the article: &gt;firends friends*
Interesting point, touches on the naming controversy. I think most Perl people would say that calling Perl 6 an upgrade from Perl 5 is like calling C++ an upgrade from C.
Do you know Moose?
no, the OP is a friend of the author. Thanks. Fixed.
I do. One of my favorite early Moose features is that it encourages encapsulation by generating accessors and recommending their use rather than direct attribute access.
&gt; I think most I'd like to see that survey.
I think you mean the OP is a firend of the author.
yes that's what I mean. Did I make a typo? :)
Indeed...just arrived in my mailbox.
So the blog post abut Construder posted 8 days ago, and the interview with the author posted 10 hours ago wasn't enough?
Looking at the upvotes this is receiving, people seem to appreciate it. Quite a few people will go "eh" about an interview, but get curious when there's actually something to look at. :)
That's the impression I got.
The Perl Community is not one unified, exclusive club. It's like a lot of little islands - many of which truly are "one man". You don't see Perl because Perl, like the air, is everywhere. Without it the Internets would truly be br0kened.
You seem to be correct. The funny thing is that the video was directly embedded in the text of the interview, and was accessible from the blog post. Thanks for responding to my comment maturely, I apologize for sounding harsh.
You got it all wrong.
Well, feel like explaining then? That's the only message i get out of your post, even on rereading. :/
What said below. There is no one Perl community, therefore no one "in" crowd. The corollary is that you can't be in them all - especially considering most are one person clubs.
Or you could go ahead and do what you're doing now which is to try and figure it out. If this is your desired career path (programming) it's not going to hurt you to jump in and get your feet wet with a difficult assignment. All things considered, a vague assignment sending you searching for areas of knowledge outside your comfort zone is a lot closer to a real world working experience than you'll get from most of your college classes, you might as well capitalize on the opportunity. Sure, the professor might just be a lazy jerk who doesn't want to teach you anything... or he could be doing you the biggest favor anyone has so far, i.e. teaching you to learn on your own (the most important life skill of all).
What sort of environment are you working in? Is this on any system you want to design it on or do you have a predetermined environment to work in? Is the webserver setup for you in advance or is this all part of the project as well? If you want to post some more details, I'd be more than happy to help point you in the right direction on any aspect of this. Thanks.
we are using usb web server. just a localhost classroom enviroment. we can use any tools to develop it that we can get access too. OS is windows xp.
I use Fraise sometimes. Otherwise I stick to pure Unixy stuff.
vim. That's all I've ever used. That said, a coworker of mine uses Emacs in the exact setup you're talking about. He has some sort of forwarding thing over ssh that does black magic.
vim
I use TextWrangler, because I am cheap. I have tried the demo for Coda, and think it is quite good, particularly for working on a remote machine.
TextWrangler can edit remote files too...
+1 for Emacs. Emacs (native OSX one, what's it called? ) + tramp mode works well for me. It also handles the annoying command/alt key correctly. 
I use MacVim and I love it. I too develop perl on remote servers but I hate working in console vim all the time. I use MacFusion with sshfs to make the code I am working on locally accessible, allowing me to use any text editor I want. Additionally, I use the taglist vim plugin to quickly browse perl code (or any other language).
I use [Emacs](http://emacsformacosx.com). When I'm in your situation and I absolutely need linux for something (kernel hacking, etc), then I run it in VMWare and nfs share my home over to the linux client. That way I can still edit on the Mac side with my native Emacs but I can run and compile or do whatever on the linux side without mucking with tramp. I use tramp as a last resort, just because it's a bit slow when loading and saving files.
vim/MacVim
Upvote for this. Textmate = pure win. Especially when combined with transmit for handling in-place editing on servers.
Yes, but the process is not as clean.
I use vim plus MacFuse/sshfs - edit in local editor, run remotely without further deployment.
[TextMate](http://twitpic.com/4kgomp/full) (screenshot) and [MacVim](http://twitpic.com/59jray/full) (screenshot) with a clean [Perlbrew](http://www.perlbrew.pl) development environment.
Emacs (Aquamacs) + [Devel::PerlySense](http://search.cpan.org/dist/Devel-PerlySense/lib/Devel/PerlySense.pm#GETTING_STARTED_WITH_EMACS) + [Magit](http://philjackson.github.com/magit/) (nicest way to use git). I tried to set up ECB for Perl ages ago, but couldn't make it work. What's your secret sauce?
How is it not as clean? Just open it up like you would any other file. Anyway, on Mac OS X you can mount any remote directory as a virtual drive with MacFusion, so you can really just use any editor you want and it will be perfectly "clean".
vim. That is all. :)
vim most the time and then TextWrangler
Komodo Edit is free from Active State. If you're going to use Emacs, it should be Aquamacs, also a free download. 
99% of the time vim. I have Komodo installed and enjoy it, but it just never seems to be my instinct to open it up when I could just use vim.
Would your reply be the same if you hired a mechanic to fix your brakes and he replaced your clutch? A plumber you hired to install a toilet who installed a sink instead? This isn't someone pushing the OP to use their initiative and go beyond their comfort zone. It's someone hired to do a job, not doing it. 
trying transmit now
I run in full BSD mode -- live most of the day inside the X server, running emacs with a setup similar to yours. 
aquaemacs. While I haven't used it, emacs is supposed to support ftp access to remote files.
I like vim or [MacVim](http://code.google.com/p/macvim/), but it is quite different from other editors so it takes a little while to learn. I've recently been using vim and now I can't imagine using anything else. [Vico](http://www.vicoapp.com/) is a fairly new editor that is vim-like and is compatible with Textmate bundles. I've played with the development versions and I like it. [Padre](http://padre.perlide.org/) is a Perl IDE written in Perl. It has some nice Perl-specific features. There is a Mac OS X package available for download; however, that version has a tendency to be a bit out of date. It can be a be a bit of a pain to get the most current version working on OS X (Snow Leopard), see this [post](http://perlmonks.org/?node_id=910271) if you feel like giving the most current version a try.
MacVim with [some plugins](http://www.stefanorodighiero.net/wiki/Vim_Tips)
oh, am I the only one to use [Eclipse with EPIC](http://www.epic-ide.org/)? Really nice as you can get all the other plugins that work with eclipse. Epic itself can run Perl::Critic, Perltidy and many other stuffs.
BBEdit is God's One True Editor.
i use text wrangler as a text editor, but i am using EPIC for my actual coding and debugging; it is a third party extension for eclipse (java ide). would recommend.
vim and git. Also, I use App::PerlBrew to install 5.14, which is really a lot nicer than the stock OSX perl. Installing it is extremely painless.
Not specifically Perl-related, but i think it's worth a read by perl redditors, since singletons are often used in Perl.
Activestate Komodo + PDK
I've started considering this some time ago. I'm currently using tkpasman (written in TCL) but it's unmaintained, doesn't work properly on MacOS and misses a web frontend.
I like to use [Text::Chomp](http://search.cpan.org/perldoc?Text::Chomp) in cases like this. If you are dealing with CSV files, then [Text:CSV](http://search.cpan.org/perldoc?Text::CSV) or [Text::xSV](http://search.cpan.org/perldoc?Text::xSV) are useful.
Yep... I always go by the old saying... "If you're using a singleton, you're *probably* doing it wrong" 
TextWrangler also has vertical block selections, regexes, sort and unicization, case changing, separate window SFTP browser with bookmarks and nice tabs (more like a side list of open files).
I actually started work on something a week or two ago. [App::locket](https://github.com/robertkrimen/App-locket) I've been using it with GnuPG. It does not have GUI access yet, though I'd like to expand it in that direction eventually. My main use right now is running it within an encrypted VM. App::locket supports external copy/paste clipboard (via the shell), so I can have it copy into the clipboard of the host.
depends on the language really. Let's take something like a language where you can't extend primitive types and then you want a function to trim leading whitespace. Either you can create an object from the primitive string, than apply the trimming, then emit the object back down to the string primitive; or have a singleton that takes a string as an argument. The "Considered harmful" here basically means that you should to do the pony show instead of thinking. It's like the ban on goto or any of the other misguided "no don't do this" pragmatism; it's applicable in an extraordinarily limited breadth and scope but then catches like wildfire and degrades the utility of other languages.
ditto
... Are you saying you think a function is a singleton? I don't get it. I also have no idea what "do the pony show" means. Also, no, i've come to this conclusion not because it's a popular one, but because of some serious thinking. Specifically: I tried to come up with instances of useful Singletons. Two thought experiments: A sound output device handler. You might think a singleton is acceptable there, since usually there is only one of these on a computer. But a singleton becomes a problem when you want to run tests assuming a broken sound device, or no sound device, or two or more of them. A logger: Usually this means you only want to go `log("moo")` anywhere in your code. But hey, what if you want to log to screen AND database at the same time? And also test to be sure that your app does logging right? You end up having to do a lot of extra work. I flat out couldn't think up an example of a singleton that holds up to deeper inspection.
I'm trying to say that it depends on the language. Some languages only afford a class abstraction and don't permit global functions (Java) so if you want a generic global function, then you need to pull some tricks. Other times, you'd like your global things like this to perhaps have it's own scope and private variables (Javascript comes to mind) Other times, a language won't have a module or a namespace abstraction and you want to have a tidy function hierarchy without having to always by necessity be explicit with prefixes (earlier PHP for example) What if you wanted to do a factory pattern in a language where you wanted to have one factory handle the instances? A singleton there would be perfect for this. I can give more obscure examples, but it's a nice construct to have to make up for language issues. I think you are trying to make the argument of "The singleton pattern in language X is of limited scope and application" and not "The broad concept of the singleton pattern is fundamentally useless regardless of the underlying semantic structures of any given language"
I'm not very polyglot, so it's hard for me to imagine the problems you describe in other languages, but your final paragraph is mostly right: I'm trying to make the point that even after extensive deliberation i have failed to find a single example in **Perl** where a singleton is useful and doesn't end up being a liability after deeper inspection. (Also, for what it's worth: I do believe that having global functions is as bad as having global variables. If i read some code i want to be able to know where a function comes from, not to have to grep the codebase and possibly my entire language library repository.)
Oyster. :-) I'm surprised it hasn't been used yet. Or has it?
Top comment on the OP blog entry was Oyster, 3 days ago. I also like that. Or Blueberry. Something that respects its roots, but changes the tone. Honestly I don't think naming a distro should ever be a public forum, though. There's more intrigue in having the creators think something up, and the name doesn't matter much more than that, so you're cheapening the story.
This latest round of anti-singleton ranting has become pretty silly. Hard and fast rules about not using a design pattern are just as broken as is use of the pattern in the wrong context. Singletons provide exactly the right abstraction in a few critical cases. Mapping to a physical device is one. Another is an API to performance and statistics logging. I'm sure that there are more. The oft proposed alternatives to singletons is to to shuttle parameters around the call structure. Or keeping a "stash" attribute in a core object where the global data is accumulated. Both of these cases are as big a red flag as the singleton they replace. The core issue is the casual use of global state. So the argument should be: "Learn what singletons are and use them in the right way". If you are using a singleton, or parameter shuttling, or a "stash" to carry arbitrary global state then you might want to reconsider the design. Just saying.
The difference between using a singleton class and shuttling things around is that you can do testing with a LOT less work when you're passing things in as parameter as opposed to when you're working with a singleton classe, which requires a lot of grungy magic to test. This is especially a big thing when you're working with Perl. If you look [here](http://www.reddit.com/r/perl/comments/il2n5/singletons_considered_harmful/c24ptbw) it's also rather easy to come up with situations where your two examples of "acceptable singletons" create more work than necessary. I'm not disagreeing that the design can often use some improvements. Just saying that i cannot think up a situation where singletons in Perl do not create more work than they're worth.
Spinach. Popeye, ahoy!
I'm sorry if I struck a nerve. My intention was two fold, first to point out that global data in all it's forms can cause problems. Second to indicate that there are places where singletons are a good solution to a particular design problem. In Perl you will note that Log::Log4Perl and Device::SerialPort implement the singleton pattern for their functionality. thanks 
Pearl necklace.
why radio buttons?
Peel (think onion).
I use BBEdit, but that's probably because I'm always bouncing between perl, HTML, JavaScript and CSS and it's good at them all. There might be something better at perl alone, but I can't imagine whatever it is would also be great at the other three languages.
Try [Password Gorilla](https://github.com/zdia/gorilla/wiki/). I use it all the time. It is password safe compatible and runs x-platform.
A config parser would be a good one. Typically, these are created once at the beginning of the process, and never, ever changed. On logging, I don't see why a Log::Log4perl object couldn't be used as a pseudo-singleton, like this: { my $logger; sub get_logger { return $logger if defined $logger; $logger = Log::Log4perl-&gt;get_logger( ... ); return $logger; } } I often use a similar technique for database handles. Not sure if there's an official name for this pattern.
No, I think it because Chrome/Chromium-like version numbering is so cool.
Thank you, looks interesting. The feature I love the most in TkPasman is the automatic copy and paste using the X clipboard. This is really wonderfully practical for lazy people.
&gt; My intention was two fold, first to point out that global data in all it's forms can cause problems. Singletons are troublesome for *two* reasons. One is that they're global data. The other is that they're invisible dependencies for their dependent entities.
Link isn't working for me, but I think I can supply the tl; dr - - **eval "string"** / **eval $string** parses and runs the supplied string. It's slow (it has to parse *string* every time) but useful for self-writing code, especially if you do somthing like my $sub = eval "sub { print 'Hello!'; }"; &amp;$sub(); - **eval { block }** is Perl's version of try/catch: eval { die "Wah!" }; if ($@) print "eval{} trapped an error: $@\n"; 
Pepper. Because a redditor once wrote that pepper on strawberries makes them awesome. I've sinced tried it and was not impressed.
I'm interested in ways to perform logging and instrumentation that don't suffer from these problems. Can you point to techniques that don't involve global data, hidden dependencies or parameter shuttling?
The best approach I've seen is dependency injection, whether as constructor parameters or a semi-global dependency registry. You can tell from my characterization of the latter what I think about it.
The link was working yesterday, and your tl;dr is missing the dangerousness of the string version because it is compiled at run time, as opposed to the block version which is compiled at compile time.
[String::Approx::amatch](http://p3rl.org/String::Approx)? $ perl -MString::Approx=amatch -E 'say for amatch shift, @ARGV' foo bar baz fom fou boo fom fou boo 
From the documentation: &gt; If you want to compare strings for similarity, you probably just want the Levenshtein edit distance (explained below), the Text::Levenshtein and Text::LevenshteinXS modules in CPAN. See also Text::WagnerFischer and Text::PhraseDistance.
I'm not sure it's as black and white as you make it out to be, but I'll certainly concede the possibility that this teacher is lazy and bad at his job. It's also possible he's trying to make a point. I can't really tell and I don't think any of us can because we're basing our entire opinion of the teacher on the commentary of a single student. There are plenty of lousy teachers in the world, this one may or may not be one of them. There are also plenty of lousy mechanics and plumbers, too (and some of them are outright crooks). All of this aside, because it's largely irrelevant to the larger issue, the student in question here faces a dilemma that will likely be common throughout their working like: They have been presented with a problem that is outside their skillset and they are not being provided comprehensive help and guidance in accomplishing the task. News flash for the non-working members among us: This happens all the time in the real world. Learning to "google it" and how to deal with unknown variables and tasks in the real world is a skill you really should consider mastering, because it's going to come up and if you're better prepared to deal with such situations you're going to be better off for it. I'm not saying this is necessarily a gem of an assignment, but like most things in life, it's exactly what you make of it. You can sit around and complain about it or you can roll up your sleeves and get your hands dirty trying to figure it out.
Never used usb web server, but I'd start with the simplest script possible just to ensure you've got the webserver up correctly and can serve up a basic "Hello World" page first. There are plenty of good tutorials online for using the Perl CGI module, so assuming your script is in the correctly location and executable from the web server you should be able to get a basic page up. Doing this first before worrying about the additional complexities of the password and session management is a good idea so that you aren't battling multiple different issues and learning curves at once. The next step I'd tackle is the file management aspect of this. This is pretty easy in Perl and you'll find a wealth of great examples from a quick Google search. Bonus points if you store the password data in a file in a manner other than plaintext (even a basic md5 hash would be a good start), but I'm sure this is outside the scope of the assignment. Once you've served up a basic page and have a handle on reading/writing passwords from a file, take a look at the [CGI::Session](http://search.cpan.org/~sherzodr/CGI-Session-3.95/Session.pm) module. This should allow you to store and manage session info fairly easily.
I did mention that, but not explicitly: &gt; It's slow (it has to parse *string* every time) but useful for self-writing code I guess the real short version is "if you don't know which form to use, use **eval *{ block }***"
Levenshtein is fun to implement on your own too.
It also stresses that you should use the "block" form.
This is not their "working life". I'm afraid your point is completely irrelevant. College should expose students to real-life work experience too, but a formal classroom is not where they should do it. Is this teacher going to pass his students? He probably is, because he's lazy. So there are going to be a bunch of people out there with a certificate saying they know something they don't really know. And the world just gets that bit shittier. 
If you don't know which form to use ... then forget that *eval STRING* even exists.
I had no idea cPerl mode did those cool things. I think my favorite is C-c C-t, switching if (A) { B } into B if A 
From what I've seen, Moose is a long way from being low on the overhead in terms of code to maintain. Even Rose has it pipped in that department.
From today, I will strive to do _the exact opposite of what you recommend_.
Prototypes are good for at least code references without parentheses, such as for `Error`'s try-catch-finally construct; and for receiving parameters by reference while not looking like it at the call site. Subs that act as though they were constants is another use case, i.e. the empty prototype. But supposing what you mean is "prototypes as though you were writing C", yeah, that's quite right. It's just as easy to read a block of `my $self = shift; my $zap = shift; my %blammo = @_;` at function start as it is to read a bunch of verbosely-typed arguments to a C function (each on a line of their own so as to not blow the 80 column style restriction).
Sure, you could do it either this way: use strict; use warnings; my $firstmatch; while (&lt;&gt;) { # first match preprocess if (firstmatchcondition) { # whatever you want to do on first match $firstmatch = $.; last; } } if ($firstmatch) { while (&lt;&gt;) { # second match preprocess if (secondmatchcondition) { # whatever you want to do on second match } } } or, you could do it this way: use strict; use warnings; my $firstmatch; while (&lt;&gt;) { if (!$firstmatch) { # first match preprocess if (firstmatchcondition) { # whatever you want to do on first match $firstmatch = $.; } } else { # second match preprocess if (secondmatchcondition) { # whatever you want to do on second match } } } Whichever you prefer.
I never said it was their working life. *In my opinion*, College (and school in general) is a lot less about accumulating vast amounts of fleeting knowledge and a lot more about learning *how to learn* and, possibly more importantly, how to prepare yourself for the real world. You continue to make assumptions about the quality of the professor in question here without any actual evidence outside the anecdotal assessment of a particular assignment from the point of view of a single disgruntled student. You might be entirely right that this is a lousy professor and you might also be entirely wrong. You have no idea what his grading policy is and yet you are more than willing to make whatever assumptions you like to justify your opinion. For all we know this professor will fail every student who doesn't actually complete this assignment in a satisfactory manner, also for all you know this one single "assignment" is the only such vague assignment the professor plans to give and is doing so for a particular reason. My point is that *we don't know*, nor is such knowledge even relevant to the problem at hand proposed by the OP. The OP appears to have the necessary drive to seek help and attempt to do the assignment to the best of their ability and I applaud that effort. It's completely irrelevant to me whether or not this professor is good, bad, or somewhere in between and it's completely outside the scope of helping this particular student learn whatever valuable life skills can be gleaned from such an assignment. TL;DR - The OP isn't asking Reddit how to best handle a bad professor, he was asking for help on a particular vague assignment and I think our time would be better spent answering his actual question.
I recommend you use strict, use warnings, document your code, write tests and look both sides before crossing a street. :)
Just as a small note: You can do the same as your three lines in one: my ( $self, $zap, %blammo ) = @_; Also, yes, using prototypes for coderef-shortcutting is amazing. :)
I use c-perl by default, switching back to perl-mod only when I get some sort of formatting/syntax highlighting fail related to a stray ' or somthing confusing it. You might want to check out "outline-minor-mode" too.
With 3G of text, I'd stop parsing text more than once and start using sqlite. Create a small schema with something like: CREATE TABLE records ( line_number INT PRIMARY KEY, some TEXT, column TEXT, data_here TEXT ); etc. Read your text in once at startup, populate your sqlite DB, and finding the line number is suddenly much, much easier. 
Look at postprocess handlers. It runs on each directory as it leaves. You will have to organize your find command thusly: find({ wanted =&gt; \\&amp;print_name_if_dir, postprocess =&gt; \\&amp;delete_empty_dirs}, $dir); edit: forgot to 2x escape backslashes
Congratulations! I have a question: &gt; The code behind http://search.cpan.org **is not open source** (that we know of), so we're not able to contribute back to it. Why? That seems unPerlish
I'm actually designing it to go up on a web server that i beleive is run by windows (my knowledge on this is a little shaky). Would that change anything? Thanks a lot for the tips.
Thanks for the direction!
The biggest gotcha I've seen in cperl-mode is that it gets confused on single-quoted string refs, e.g.: $foo = \'some string'; The workaround is simple, should you run into it: $foo = \ 'some string'; Just add a space.
OK well, you're convinced of your opinion so there's not much point arguing. And yes, I took the student at his word. But assuming their statements can be trusted, I stand by my opinion, and I think sorting out the teacher/college will be for the greater good, not only for this one person but possibly for many students for years to come. You'll note I did give practical advice about handling sessions at the bottom of my original post.
A great conference with great coffee. 
My final solution: use File::Find; my $dir = "E:/Development/cgi-bin/Output"; find({ wanted =&gt; \&amp;delete_old}, $dir); @users = &lt;Output/*&gt;; foreach $user (@users) { @timefolders = &lt;$user/*&gt;; foreach $timefolder (@timefolders){ @batchnames= &lt;$timefolder/*&gt;; foreach $batchname (@batchnames){ rmdir ("$batchname"); } rmdir ("$timefolder"); } rmdir ("$user"); } sub delete_old { $file=$File::Find::name if -f; $age=(-M $file); if ($age &gt;= 28){ unlink ("$file"); } } Thank you clone00 and d01100100 for the help in solving this!
Anything like this in Australia?
Luckily, I already did this exact thing and got it working, although only on CentOS 5.5. Here is a link to a zip file containing all the spec files and CentOS 5 builds of each package for i386 and x86_64. Note that this is just a dump of perl modules I have packaged as RPMs. Many of these are not necessary for Catalyst. Also, these RPMs rely on dependencies from [EPEL](http://fedoraproject.org/wiki/EPEL). [http://dl.dropbox.com/u/11780410/perl%20RPMS.zip](http://dl.dropbox.com/u/11780410/perl%20RPMS.zip)
At the risk of asking a silly question, are you sure you need them as RPMs? They're obviously not vendor packages, so there's not going to be any automatic upgrades.. Why not get your Catalyst app working with a local::lib install and point `tar` at it when it's ready? Just install local::lib (see the docs for "how to"), install ``App::cpanminus`` and then do `cpanm Catalyst` and, if you've kept your Makefile.PL up to date, you're golden.
Wow...this is incredibly helpful...thanks so much :) Just curious... I see you used cpanspec, thats also the tool I've had the most success with so far on CentOS. Did you have to make any modifications or do anything special to get cpanspec working properly for all of these modules? Edit: If you take a look at perl-Module-Build, it lists "Module::Build" as a build dependency. I was running into problems like this everywhere... did you simply resolve by ignoring dependencies? Thanks again!!!! Edit #2: Most of these are from EPEL repository it looks like. I was trying to build my own to get higher versions of the RPMs, like Moose 2.0010, etc. However, I will give these modules from the repo a shot to see if they work with my application :)
There is an automatic upgrade process involved with these, unfortunately :( edit: that relies on RPMs
I was more saying that the upgrades would be from you or your ilk, not the vendor, since you're packaging them yourself. If you need to upgrade a local::lib distribution, things like rsync would be a great choice. 
Unsure but would be happy to help you start one ...
Have you had a look at [shipwright](http://search.cpan.org/~sunnavy/Shipwright-2.4.28/lib/Shipwright.pm)? I've used it on several projects that had a bunch CPAN dependancies. Keeping your vessel/modules up to date is simple and using checkinstall to build yourself a custom RPM makes packaging easy. You can probably automate the entire build process in a small shell script too. 
Sounds like it could be a plan. What's involved? 
Looks really cool. I'm going to give it a shot sometime soon. Thanks!
I really could have used this 5 years ago. However XMPP is now king and really everything else is on the decline and irrelevant IMO. /me uses perl every day and love it... no troll.
Pick a Date, find a Venue, talk with the ACT people about getting a site set up ... and promote the hell out of it. You're welcome to pester me via email or IRC for more details if you'd like.
Karma whoring off my perlmonks post? For shame. *actually, I was gonna do this myself but then thought... nah.* I quit caring so much about my points on perlmonks and don't care too much on reddit either.
XMPP is good in theory, but I know nobody who actually uses it. Very few of my friends even use the "popular" XMPP servers like GTalk.
Mmmm Facebook chat is xmpp and IMO it will kill everything else if they release a desktop client for an average user. 
Facebook's XMPP is bolted on... you can't add normal XMPP users to your facebook buddy list in an XMPP client (like Pidgin). Users would use facebook's XMPP because all their friends are on it, but it's no different than AIM, MSN, Yahoo or the next fad instant messenger. It's still locked down, centralized, and for all intents and purposes, "proprietary".
Karma whoring? Would you prefer it not be linked here at all? I doubt any of the people posting here care about their points and care more about showing interesting things to other Perlers.
And as a little bonus: http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2011-07/msg00645.html
Google's IM service is also XMPP based and Second Life too. While I like XMPP there are some thing I don't like about it. The PSYC guys have a nice [summary](http://about.psyc.eu/XMPP#Technical_Issues_in_Jabber) of valid criticism which is especially nice if you want something to work on/think about. PSYC is also an interesting protocol, but it really lacks some hype. Well there isn't a perfect protocol like there isn't a perfect $foo. ;)
It doesn't matter. Xmpp is a protocol and that's what they are using. 
Don't worry Brother, I'll upvote your perlmonk post too :)
neither of these emit any warnings as you've pasted them. the first one doesnt compile with strict on, the second one does because $b is special (see perldoc perlvar).
thanks, going to implement this to my current project.
Sometimes adding `use diagnostics;` goes a long way towards figuring things out. :)
Hmm, didn't know about the diagnostics module. For some reason, loading it (even on a blank script) doesn't work. Maybe it's a Mac OS X problem?
As much as Catalyst is developer friendly and very fast to implement things (Catalyst::Auth::Realm::SimpleDB comes to mind), I dunno if it really is this easy. I'm probably wrong though, modern perl devs really make some awesome things.
It really is that easy, if you use TT2 for your views.
I think you are confusing yourself here. In your examples, the sub is completely superfluous to the diagnostic messages; the `{CODE}` slot of `*b` is separate from the `{SCALAR}` slot, i.e. `$b` and `&amp;b` are totally different things. The reason for the lack of warning with the second one has nothing to do with the presence of a sub named "b", it's because the global scalars `$a` and `$b` get a special-case exemption from the 'strict vars' checking, because they are used as placeholders by functions like `sort` so that you can write my @sorted = sort { $a cmp $b } @list; ...without falling foul of 'strict vars' checks. Otherwise you'd have to write this as my @sorted = sort { no strict vars; $a cmp $b } @list; As to `%_`, I don't think it has any particular meaning as a special variable; you can use it for whatever you want (but please choose something with a better name.) Again, `%_` is a completely separate variable from `@_` and `$_`, so while those two have special meaning `%_` does not. 
Agreed! I travel hundreds of miles every fall just for the coffee, the perl is an afterthought really ;)
diagnostics.pm only does something when you get a warning or an error. ;)
Why wouldn't it be as easy? If you use TT, all you need to do is to drop in the new class name and then make sure all all filters are as you want them by grepping for ' | ' in your templates. :)
I didn't say it didn't do anything. I meant it doesn't even run. perl -Mdiagnostics -e 1 couldn't find diagnostic data in ... at .../diagnostics.pm line 268, &lt;POD_DIAG&gt; line 647
Seems like your perl distribution is broken. Try reinstalling a fresh localized one with perlbrew.
What were the results of his previous survey?
This is absolutely fantastic! I've been meaning to check out perlbrew and here's finally a reason. Works like a charm and diagnostics works as well. Thank you!
Ha, i was a bit worried, but in the end everything went well. Great to hear!
I bet you're on Mac OS 10.6, right? I've seen reported in a few places that Mac OS 10.6 has a broken perl install.
I regret that I have but one upvote to give.
I also just learned about and love the inline editing on github. Perfect for spelling and doc edits that don't require tests. Or even minor fixes. 
I was on Snow Leopard, yes. I couldn't remember if I was using a build I installed for an old YAPC or if it was replaced during the Snow Leopard upgrade (from Leopard).
You should *always* use strict; You will not be taken seriously by any perl hacker if you don't and that will be the first piece of advice they give. Alternatively, you could use 5.14.0; which automatically turns on strictures, as well as all the newest released features of perl (including say(), so you would not need to use that feature explicitly). Using a c style for loop is kind of old fashioned, but it works here and makes sense, so don't worry about it. As a tip, though, for and foreach are the same thing in Perl. Why do you use local instead of my? I think you meant to use my there -- the use of local has vastly decreased since perl 5, and you should not be using it unless you know how to use it. Perl interpolates variables, so instead of say 'Downloading image from '.$img_url; You can write say "Downloading image from $img_url"; (Note the double quotes, and the variable inside of them.) Also, why no shebang line?
Wha? Thanks for sharing, that is great!
Thanks, but with `use strict` i have now following errors: `Global symbol "$img_url" requires explicit package name` `Global symbol "$filename" requires explicit package name` How could I fix them? specifying `package whatever;` at the begging of script doesn't seems to work. edit: Nvm, I changed `local` to `my` and worked fine. Thanks! edit2: uploaded fixed version, sticked with `use feature` though, since I'm using Strawberry Perl 5.12 anyway (not 5.14).
You can save a lot of requests by getting 100 results per page (add `?count=100` to the base URL.) When using a regexp that contains forward slashes, it's traditional to pick a different separator than m// so that you don't get leaning toothpick syndrome. 
use 5.10.0 works just fine with 5.12 and gives you similar benefits.
 print "Just another Perl hacker" Sorry. I'm not very good at Perl.
forgot the ;
Don't need one; you can always leave the last one off. EDIT: Is it possible to have a shorter one than the one I wrote? How about say "Just another Perl hacker" Even shorter, but isn't compatible with older Perls, including the one I have...
You should localize $content and $parsed inside the for loop. You should also check that the request succeeded before calling from_json. For example: my $content = get($url); unless (defined $content) { say "Error getting URL $url"; next; } my $parsed = from_json($content); As it stands now, if the request for page 1 succeeds but page 2 fails, you re-traverse page 1 (and if page 1 fails, from_json will die). You could also have it wait a few seconds and retry on failures, if you'd prefer that. I'd also invoke the loop as for my $page (1..$numpages) but that's just a stylistic thing.
Not mine but definitely the coolest I've seen: #!/usr/bin/perl not exp log srand xor s qq qx xor s x x length uc ord and print chr ord for qw q join use sub tied qx xor eval xor print qq q q xor int eval lc q m cos and print chr ord for qw y abs ne open tied hex exp ref y m xor scalar srand print qq q q xor int eval lc qq y sqrt cos and print chr ord for qw x printf each return local x y or print qq s s and eval q s undef or oct xor time xor ref print chr int ord lc foreach qw y hex alarm chdir kill exec return y s gt sin sort split 
Holy shit, I was thinking about doing one with no literals but DAYMN
Not shorter characterwise, but lengthwise: say 'Just another Perl hacker'
aaaaaaaaaaaaaaand *that's* why they hate us. ;)
If you examine it closely, you can see where the keywords are being interpreted as literals using `qw` and `q`. The logic is just totally foreign to me though.
A few minor comments: # I would replace the filter with "([[{()f+\1" which will keep the brackets/braces/etc. properly balanced as well as photos which contain multiple women. # You might want to make your filter more inclusive so that you not only match photos with just women but include women and their partners (up to you). In that case, the filter could be "([[{(])(?:m_star_fm_star_)+\1" (replace _star_ with *, reddit keeps parsing it as formatting information). # Move "$after = $i-&gt;{'id'};" outside of all of the if-blocks so that it is only inside the (inner) for-loop. Otherwise, if you hit a page with nothing but men, you'll never advance.
Also, a typo in his comment: &gt; my $filter = '[[({]f[\])}]'; # change f to m if you wan't penis content **wan't**
&gt;Currently in an expression like (A || B || C || D), if A is true, then B, C and D aren't evaluated, but the 2nd, 3rd and 4th OR ops are *still* executed. Can someone explain the difference in being 'evaluated' and 'executed'? thx
I include this one liner in my email signature: perl -e '$x=eval { sub { $x = 'gkfnedbonmacejachemdilac'; $x =~ tr/abcdefghijklmnop/enra sjlcpukhto/; return $x; } }; print &amp;$x();'
Mine is just: print @ARGV; The rest is just name calling and arguments! ;-) (does just "say @argv" work as well btw?)
metajaph? perl -MLWP::Simple -e '@j = split "%%", get shift; print $j[int rand @j]' http://www.cpan.org/misc/japh (edited in consideration of those using older perls).
 @P=split//,".URRUU\c8R";@d=split//,"\nrekcah xinU / lreP rehtona tsuJ";sub p{ @p{"r$p","u$p"}=(P,P);pipe"r$p","u$p";++$p;($q*=2)+=$f=!fork;map{$P=$P[$f^ord ($p{$_})&amp;6];$p{$_}=/ ^$P/ix?$P:close$_}keys%p}p;p;p;p;p;map{$p{$_}=~/^[P.]/&amp;&amp; close$_}%p;wait until$?;map{/^r/&amp;&amp;&lt;$_&gt;}%p;$_=$d[$q];sleep rand(2)if/\S/;print This one is trickier than it might first appear. "If you think you understand this program, but you can't explain `@P`, then you are mistaken, because `@P` is the central data structure of the entire program." [Spoilers](http://perl.plover.com/obfuscated/) 
They hate us for our freedoms.
That was great; I just lost several hours to this. Before turning to the hints and explanation I was able to figure out that it was forking a tree of processes, one per character, and that the order of termination was the key, based on parent-child waiting and pipe inheritance. But I missed the state machine, probably because I initially stupidly read `(P,P)` as `(@P, @P)` which colored my whole interpretation of the pipe state part. (And I was too lazy to look up the ASCII values of ., R, and U before turning to the hints even though I knew they were significant.)
At the risk of being pedantic, it's an important distinction about `;` -- in Perl, `;` is what separates statements, not terminates them. 
Deparsed: &gt; `print ' ' and eval ' undef or oct xor time xor ref print chr int ord lc foreach qw y hex alarm chdir kill exec return y ' gt sin sort(split(' ', $_, 0)) unless not exp log srand xor s// /x xor s/ / length uc ord and print chr ord for qw q join use sub tied q/ xor eval $_ xor print ' ' xor int eval ' cos and print chr ord for qw y abs ne open tied hex exp ref y ' xor scalar srand print(' ') xor int eval ' sqrt cos and print chr ord for qw x printf each return local x ';`
metacpan also supports opensearch, so visit http://metacpan.org, then go to the search bar and the pulldown will have an item for "Add MetaCPAN"
This is my favorite. Originally posted on perlmonks several years ago, but I don't think I've ever topped it: #!/usr/bin/perl ($c=&gt;$i)=(shift()=&gt;shift);@i=split//=&gt;$i; $n=&lt;&lt;'for(;@s;$s^=pop@s){}';$c||=$n;eval$n;print"\n";die; $c=~s/[^\+\-\054\056&lt;&gt;[\]]//sg;@p=split//=&gt;$c;sub b(\@@){\shift-&gt;[shift]}for(@p){/\[/&amp;&amp;push@s=&gt;$s; /]/&amp;&amp;(${b@e=&gt;pop@s}=$s);$s++}@s||0&gt;1&amp;&amp;die; for(;$_=${b@p=&gt;$p};$p++){/\074/&amp;&amp;$d--; /\054/&amp;&amp;(${b@d=&gt;$d}=ord(shift@i));/\+/&amp;&amp;-${b@d=&gt;$d}++; /\x5b/&amp;&amp;(${b@d=&gt;$d}?(push@s=&gt;$p):($p=${b@e=&gt;$p})); /\-/&amp;&amp;${b@d=&gt;$d}--;/\056/&amp;&amp;print(chr(${b@d=&gt;$d})); /\x5d/&amp;&amp;(${b@d=&gt;$d}?$p=${b@s=&gt;$#s}:pop@s);/\&gt;/&amp;&amp;$d++;} $e+=++$s[(3&gt;$p?++$p&gt;0:++$d+$p++||+1&lt;&lt;0-1)&amp;&amp;0]&gt;&gt;$e++; $p[(${b@p=&gt;$p+push@s=&gt;$p++}&gt;$e++?$s+1&gt;++$d:++$b)&amp;0&lt;&lt;2&lt;&lt;-0]; $p&gt;&gt;=$d++|+$i++&amp;0;pop@s;$s++;$e++;@s=split+/./=&gt;$c; for(;$e&gt;0;$e--){--$e;$s-=1;$n="------".$s--."+".(1&lt;&lt;$e&lt;2). "\n";}$c&gt;&gt;=1;$c+=3.141592654;${b@s=&gt;--$s}--;$n=$s--.(1+$s). "+++++".$e;$d&lt;++$s?++$c:++$i;@e=split+/./;--$e{$s}&amp;&amp;exit;/-/&amp;&amp; ($s.="$c/$e");print$s&gt;--$i;$.&lt;&lt;=$&lt;;@p=split/.(?&gt;-)/; ($s&gt;$e||$s&gt;$c)&amp;&amp;$s--;$c.=q&lt;.&gt;;print$p++."\n"; print(chr(ord shift(@i)-1));$s&lt;$e&amp;&amp;push@s=&gt;--$i; /\x64/&amp;&amp;--$e;print-0||"$^O".$s[$s&lt;0?$e:$s];for(;$e&gt;0;$_.=$e){ $p&gt;&gt;=($d++)+1;$_.=$c;tr|a-z0-9A-Z|A-Za-ka-z|} &lt;&gt;;@d=sort{$a-$b&lt;=&gt;0}split/.+/;$e+=.1;push@s=&gt;$e; /-/&amp;&amp;($_.=q&lt;ff^aa+ab+ac.ad^ff&gt;);s+(\w\+)+$1\+$s\+\++sge; print"\n".$s[$s&lt;0?$e:$s];&lt;.&gt;;print${b@e=&gt;$p}; for(;@s;$s^=pop@s){} print$s; 
Yes a "cross-platform" GUI design solution with widgets that look like they're from the mid-1990s 
I really liked the one he linked to as well, the one that was perl &amp; postscript.
I think you forgot to link, dude.
oohh that's sweet
Core needs Moose.
No way in hell.
Devel::Dwarn.
Why not?
Because Moose changes too frequently? It's much easier to install an update to a module than to update all of core to get a bugfix or new feature.
http://i.imgur.com/x1rvj.png
List::Util and List::MoreUtils should be consolidated together into one package and cored (as soon as all functions have XS versions that don't leak).
Actually Moose has slowed down enough and core has sped up enough that I bet there isn't really an issue here as long as Moose were dual-life. I would never want Moose in core because you could do so much better than Moose if you had access to core. This is why Stevan is currently exploring a first-class MOP for 5.16 (https://github.com/stevan/p5-mop). There are also a half dozen things I'd put into core before Moose, but really putting things *into* core isn't the hard part. Elegantly deprecating things *from* core is the hard part. How do you handle that people expect things like CGI.pm to just be there? 
Maybe it's as simple as talking it out and taking some informal surveys. The people who care the most about how Perl affects them are the ones currently in the room, participating in the conversation. If edge cases fall to the wayside, I say oh well. If we make a mistake, pop it back into core or just tell them hey, install this manually next time. Doesn't seem like a huge deal, right?
I would cuddle the braces. The verticality is killing me... if (EXPR) { ... } I would also pad the range operator with spaces 1 .. 10 Also, the leading spacing is all over the place. How about four hard spaces instead of tabs? There are a couple more things, but cleaning up the space issues will go a long way in helping reason how complex your code is. Consider using if (!EXPR) instead of unless. I used to be a diehard unless fan but sometimes if not is just that much cleaner and hesitating in understanding your code is the devil.
&gt; Doesn't seem like a huge deal, right? It shouldn't be, but integrating features in isolation can make a real mess when considering the whole (look at PHP or the Perl 6 RFC process). Now also consider that no matter how many disclaimers you put on experimental features, someone will rely on them anyway, and if said experimental feature is in an enterprise distribution, it won't go away for seven to ten years and will continue to harass people. There's a lot of pressure *not* to make changes and it's understandable.
If a feature is experimental, shouldn't it NOT be in core? When in doubt, go for pain. If you're unsure, go with the status quo. But if you have a visceral, gut reaction like WHY IS THIS NOT IN CORE YET, then consider that your goto flag. Let the pain build over time and let that be your guide to features that people REALLY need versus want. Same goes with GOD WHY IS THIS STILL IN CORE.
So when Moose stabilized, you will be in favor of including it in core?
&gt; But if you have a visceral, gut reaction like WHY IS THIS NOT IN CORE YET, then consider that your goto flag. p5p is not a hotbed of agreement of "WHY IS THIS NOT IN CORE YET". Some things can only be done in core. Some things need more feedback before anyone understands how they really work.
Nah, I'd rather they move everything non-essential out of core and let me manage it myself. I just pointed out why others will be against Moose going in.
The "more feedback" stuff definitely does not sound like a candiate for core, unless you maybe mean core in a devel branch. If people can't come to an agreement then oh well I guess. Quite a hard problem if Perl's community is more like an archipelago than a series of continents. Maybe people need to rise up and become champions of the causes they would like Perl to represent. If we don't know who are market is, let's make one! Edit: Easier said than done, I know. But I do appreciate the work you're putting into this. Big fan!
&gt; The "more feedback" stuff definitely does not sound like a candiate for core, unless you maybe mean core in a devel branch. Prototyping (especially syntax changes) on CPAN would be much easier if Perl 5 had some sort of AST between the parser and the runtime. I'd rather generate an AST than have to build the optree by hand in XS.
&gt; How do you handle that people expect things like CGI.pm to just be there? What is the problem with that? 
&gt; Text::Soundex "Soundex is a phonetic algorithm for indexing names by sound, as pronounced in English." 日本語どうするんだろ。 
some modules should not have been there but it was taken from answers to an other blog post of the same kind: http://poll.pollcode.com/uMt_result?v We can see that Moose is wanted, which certainly points out that something to handle OOP in a easier way should be added in core (whether it's Moose or not). in fact perl5i as a lot of nice features that I would like to see get into the core (not having to write 1; at the end of a module is small but I really like that one!) it's mostly core language enhancement (ie,try catch) 
Okay, but I still don't understand why Perl doesn't have a first-class OO system in core. Doesn't that trouble you at all? It wouldn't force you to use it, it would just be there so you could count on it being installed.
I disagree. Several reasons: * It doesn't fall into the "modules you need to install more modules" category as CPAN does * It adds a rather high startup cost, which is fairly atypical for core modules that act like language extensions. * It is much larger in scope than other language extensions (strict.pm for example) in core * It is a huge step in complexity in the implementation of OO in Perl 5 I would prefer it if core stayed small, and the task of providing many users with modules by default should be solved by distributions (like strawberry and activestate) or bundles (Task::Kensho). If anybody wants to improve the state of OO in Perl 5 core, than I'd recommend looking at 6model, and porting that to Perl 5. In short, 6model provides building blocks for building your own meta object protocol. It's flexible enough to handle Perl 6's needs (which are quite high) as well as that of most other dynamic programming languages, but it is in no way specific to Perl 6. With 6model in core, Moose could become a much smaller layour around the new OO primitives, and other OO modules could also greatly benefit from it.
I think you are wrong about Moose slowing down enough and core speeding up. That is true, maybe, *now* but there is no guarantee that that will be the case in the future. Maybe things could be put in the core to help Moose out but I would keep Moose separate so as not to stifle any innovation. 
These are very good arguments. But as an application programmer I'd expect some way to define objects with more ease in the core.
You misunderstand my objection. It's more from a sysadmin perspective. Say there's some critical bug fix or huge performance boost in a version of a core module released after core was set in stone for the latest perl release. Where I work, and common to a lot of companies, we have to build rpms for any new modules we want to install. Building an rpm for the newer version of that module that won't step on the version from core is a pain in the ass. Sometimes I just give up and live with the older version because it's not worth the effort. If that module was already a separate rpm because it wasn't in core, I simply build a newer rpm and it just installs without complaint. That's what I get annoyed about. I realize that we could manage our modules differently, and there is some talk about doing that where I work, but I don't expect it to happen soon and I know others are in a similar boat. If they were to, say, make Moose syntax part of the Perl interpreter, so they could actually wrangle some decent performance out of it, I would be in favor of that, Darkpan be damned. Otherwise, let me manage it myself so I can decide which version I want installed and update it at my own discretion.
Removing things like CGI.pm^1 means that for some class of people they can no longer write applications without a CPAN dependency. This is arguably breaking backwards compatibility. Perl has traditionally tried incredibly hard *not* to break backwards compatibility. This partly is why nothing was removed from core for the longest time. I'm one of the people that trumpets how wonderful CPAN is, and that everyone should use it whenever possible. I'm also a person who's been working for several years on what an Extended Core, with *more* modules shipping, would look like. I have also worked in an environment that made installing and updating modules from CPAN more difficult than simply not. I understand that for some people CPAN can be painful. I do not envy Jesse Vincent the responsibility for dealing with all of the ramifications of changing these long held policies. Especially since many of these policies were implicit and not everybody is aware of, or agrees with them. 1: CGI.pm is a placeholder for things like autouse, Text::Soundex, and Dumpvalue as well as the Perl4 scripts that were removed for 5.14. Dual life modules are easier to deal with removal but still requires people to have unfettered network access and a configured CPAN client. edit: My footnote disappeared!
&gt; I think you are wrong about Moose slowing down enough and core speeding up. I could very well be wrong. &gt; That is true, maybe, now but there is no guarantee that that will be the case in the future. There are no guarantees about anything in this life. Moose's stated support policy however (Moose::Manual::Support) explicitly lays out the current policy which slows Moose down to only 4 potentially backwards incompatible releases per year. Considering we were averaging a release every two weeks in the past this is a huge slowdown for us. &gt; Maybe things could be put in the core to help Moose out but I would keep Moose separate so as not to stifle any innovation. Moose's innovation is being naturally stifled anyway because it's becoming a mature platform with a large user base. One of the goals of Stevan's p5-mop project is to build something in core that you can hang Moose on. Building something more akin to Class::MOP rather than Moose. Because as you say this won't stifle innovation.
Why "in the core" and not "in the distribution you target"?
`sub new { my $class = shift; bless { @_ } $class }` ? Or do you really mean you want a way to define *attributes* and *accessors* with more ease? That you want a meta-object system that provides quality introspection and meta-programming? I wouldn't disagree with these desires. I think we could do better than Moose if we were building from scratch in core.
Porting 6model naively would be nearly entirely wrong. Perl6 and Perl5 have very different object models.
The thing is that this new constructor could be written 10 different ways i'm pretty sure. And you don't check against somebody writing Package::new(). which would lead to an epic fail (I know, who would write that? but never knows, let's say you call your constructor something else than "new", like "connect" or "gotoheaven") i can't answer for catastroph but I think having a sane way to define setters/getters/constructor with some introspection available behind the scene in a standard way (inside/out objects, blessed hashref, blessed arrayref, Moose,etc-too much possibilities for the same goal) would be really helpful. If not for the new comers, at least just to allow for automatic API doc generation from code.
I had hell many other core modules that i would like to see deprecated or at least merged/cleaned into saner namespaces with a coherent documentation (http://perldoc.perl.org/Archive/Tar.html and http://perldoc.perl.org/Encode.html for example. not to say the doc is bad but it is written with different format). CGI.pm is not one of them. but I guess you were trying to explain the deprecation problem but choose an example I would not have chosen. 
 &gt; Filehandles are still globs (or globrefs, or scalarrefs to globrefs &gt; or something). You can make them kinda objecty by loading &gt; IO::Handle... er, or IO::File, or maybe FileHandle. Rather little &gt; code actually seems to do this, instead using the dozens of global &gt; i/o functions. Since Perl 5.12, they are IO::File objects internally. Since Perl 5.14, IO::File will be loaded for us if we start using its methods $ perl -E 'say "I \x{2764} Perl"' Wide character in say at -e line 1. I ❤ Perl $ perl -E 'STDOUT-&gt;binmode(":utf8"); say "I \x{2764} Perl"' I ❤ Perl I guess we could write say as method too $ perl -E 'STDOUT-&gt;binmode(":utf8"); STDOUT-&gt;say("I \x{2764} Perl")' I ❤ Perl but this is a silly example, because in practice we'd just write $ perl -CO -E 'say "I \x{2764} Perl"' I ❤ Perl 
As from Perl 5.12 'site' is searched before 'lib', you should just install all modules into 'site'.
I'm fairly sure that's been the norm for ages. That part's easy; the rpm building tools for cpan modules already have a flag for that. It's the man pages and the scripts and everything else that's the real pain, if the module has them. Try making a new rpm for ExtUtils::MakeMaker that doesn't crap all over the installed versions of files from the perl RPM. I think I finally got a newer Test::Simple, but I had to sacrifice a few goats, and I had to put prove in a nonstandard location that's not picked up by the default $PATH.
Yeah I just discovered my footnote to that extend had been eated by the markdown parser on reddit.
One positive comment: I think that though it obviously has room to grow and improve, I think that /r/perl has become a pretty darn good place to learn about new things going on in Perl. I am a complete outsider/neophyte to Perl (and practically speaking to programming) and so I believe I can speak to Veekun's worry that : &gt;if someone with a foot in Perl is oblivious to these things, what chance do those outside the community have? Between Mithaldu, Mr. Chromatic, and others' activity in this subreddit, Perl comes off as a language where visible "power users" of the language are also accessible, which is an attractive feature to have.
&gt; The thing is that this new constructor could be written 10 different ways i'm pretty sure. Yes and no. Ultimately you can't get away from bless($ref), which is the true constructor in Perl5 in that it's what turns your regular ref into an object. The point is that when people say they want an easy Object System in core Perl5 that's not what they mean. What people want are stronger opinions about OO baked into core. For example when you say: &gt; If not for the new comers, at least just to allow for automatic API doc generation from code. What you really want is a lot more complex than it seems. To really make automatic doc generation useful you're gonna need subroutine signatures, return signatures, possibly type constraints otherwise it won't really save on the typing anymore than the current package stash introspection tools. I don't disagree with wanting better opinions about what OO is in Perl5. Lord knows that writing accessors by hand is tedious now that I've been using moose for four or five years. I want to be sure we end up with the right opinions. Object Oriented Programming is over 40 years old and there is still not a single unified definition of what it means (Google it, I'll wait). To pretend that we can somehow slap a module from CPAN into core and fix Object Oriented Programming in Perl5 is absurd. Especially when the very people responsible for developing and maintaining Perl can't agree on exactly what Object Oriented programming is (see the recent threads on p5p about OO documentation). What we do have is a decade of experience with what it means to program object oriented Perl5. Some healthy consensus about opinions have formed. For example I think people can agree that a simple solution to your `Package::new()` bug is to have methods throw an exception if called as a function. Being able to do that required changes to the Perl5 core that didn't exist until recently. It certainly wasn't easily done in a module (if it were *Moose* would be doing it). Building up a consensus of opinions about Object Oriented Perl5, and then building a good representation of that consensus will take time. Is it something that should have happened years ago? Possibly. But we wouldn't have had a decade of figuring out the pain points to work with and we probably would have made some bad choices. I've been much happier with Perl5's DIY approach than I was with Java's opinions.
You realize your poll says that 9 people want Moose in core. That's not exactly a compelling statistically significant sampling.
first of all, Great Article. &gt; Things use warnings complains about but still allows &gt; Using elseif. This is only half true. The correct construct of an else-if statement is: if ($condition) { #do stuff } elsif ($another_condition) { #do other stuff } else { # do else stuff } note that else is spelled ***els***if. Additionally, elseif operates as an else statement and not an elsif. So this: if ($condition) { # do stuff } elseif ($another_condition) { #do other stuff } else { # do else stuff } fails gloriously. 
As [hyperforce](http://www.reddit.com/user/hyperforce) points out, you should consider using K&amp;R style braces ([Perl Best Practices: Rule 1](http://refcards.com/docs/vromansj/perl-best-practices/refguide.pdf)) instead of BSD style bracing. This helps with readability as well as saves vertical space. so : for (@some_var) { #do stuff } becomes: for (@some_var) { # do stuff } One line may not seem like much, but as your programs grow, that one line really adds up. explicitly dereference your refs using {}. i.e.: @$some_aref becomes : @{$some_aref} for my $i (@$parsed) { # processing } becomes: for my $i (@{$parsed}) { # processing } A minor thing, but I don't understand why you need two variables for the URL. Additionally, you can do as follows. my $input_url = 'http://www.reddit.com/r/gonewild.json?count=100'; my $url = $imput_url; Becomes my $url = my $input_url = 'http://www.reddit.com/r/gonewild.json?count=100'; 
i'm not entirely sure what his point is. he sort of lost me at the notion that SUS would impose a new regime of sh coding. 
Perhaps I didn't make that portion allegorical enough, but the point I tried to illustrate was that the system administrator who settled on using Perl because it was a better /bin/sh is from a largely bygone era. Those system administrators have kids who are likely just now going to university. I don't know about you, but my main motivation for using Perl was that it was more consistent between systems than sed and awk, and I could rely on a set of features in the language to be consistent from system to system as well, much unlike the Bourne shell derivatives from the good old days. For other system administrators, the fact that Perl largely allowed a shell-like UI approach to writing statements, which allowed them to take their familiarity with the shell to a scripting language, was probably a huge justification for adopting the language. This, too, is starting to die off because of the lack of a statically linked OS Perl on some systems now. Furthermore, system administrators are becoming increasingly expected to adopt more development-oriented responsibilities in some shops, and an increasing number of developers are finding themselves bitten by werewolves and adopting those same forms when the conditions are right... Is there anything I can say here to make my point clearer?
For me, the main point was that Perl needs to become easier to teach and learn as if it has any future, it will be in as a general purpose programming language and not a scripting one. I completely agree with this, but I also don't want to have to force thousands of authors to rewrite their scripts thus making wide-spread adoption slow. There has to be a middle-ground of some sorts.
You got it. The middle ground from the implementor's standpoint seems to be to make the required changes gradual and not nearly as shocking. So, instead of, say, getting a bucket of ice cold water tossed on you to wake you up from your dreamworld of rainbows and kittens, the goal is to deprecate old, crufty features slowly and introduce new pragmas to make the point clear that this is not the 1990's anymore.
I've been using perl to write both programs and scripts for many, many years. It started when we needed to transform some text files at work, and has grown. The reason I started using perl wasn't because it was on the machine (think Windows NT). I started using perl because it was (and I think still is) easy. It does what I need with little fuss and a gentle learning curve. Would any of those early programs and scripts pass muster for best practices today? Hell no. But that's okay. I have very complex programs that move, transform, and deliver critical data in near real time. Some of these have been running for almost a decade, through OS and Perl upgrades. The most beautiful thing about perl is that you don't have to do it the same way as someone else. It lets you develop your own style and find your own way. I think this makes perl more accessible, and easier to learn. At the end of the day, I don't care how people get the job done, as long as they get the job done. I'm not arguing that perl should be left as is — it needs to move forward, to add new features and get rid of old ones. But, like any mature language, deprecating older features should be done slowly and very carefully, while adding new features should be the priority. 
Indeed, there is a lot to be said about accessibility, and I'm disinclined--like several others--to remove that aspect from Perl, but there are definitely some rather sharp edges with that as well. While I'm not entirely of the mindset that protecting people from themselves is exactly the way to go, I'm also not of the mindset that having a collection of mutually incompatible object systems, for example, is exactly ideal. Now that I've said that, actually, let me put it this way: I'd like to see Perl actually standardize, like Common Lisp did, on a number of things like an object system and an exception handling mechanism and so on and so forth. Sure, if you'd like to continue writing code the same way you have been for years, keep doing that, but if you want to write something to be maintained by others, keep to the standard. (For bonus points, actually get it to the status of a ratified ANSI standard like Common Lisp.) Maybe I should liken everything to how the SAE works as opposed to how the ITIL-crazed froth-mouthed enterprise IT goons mechanize themselves...
Adam Kennedy's work is awesome, as always.
of course. You can vote if you did not... and it will become 26 people haha. anyhow, I am pretty sure that the needs of Moose in general shows that some easier OOP system should be shipped with perl. 
&gt; What you really want is a lot more complex than it seems. I admit. But you can start little by little. it's not a all or nothing need. First, if we can get a method vs sub separation system, it would be a real progress! Then see for the other goodies. &gt; To pretend that we can somehow slap a module from CPAN into core and fix Object Oriented Programming in Perl5 is absurd. never said that. god knows I don't want to have Moose in core. &gt; It certainly wasn't easily done in a module That's what I am saying... a constructor shipped in the core and at least a method vs sub separation system would be a huge change (closed enough to the Python system). &gt;Building up a consensus of opinions about Object Oriented Perl5, and &gt;then building a good representation of that consensus will take time. I've always thought that perl5 should look into becoming more perl6ish. so there's no real debate as to what to implement but how to implement it (if perl5 vs perl6 oop system were to become different then the naming should have been perl5 and perl++ or something like that). &gt;I've been much happier with Perl5's DIY approach than I was with Java's opinions. In fact, I like the DIY approach because it allowed me to learn a lot about OO in a more profound way than just use the keywords the language offers you without really understanding it. Java is an only one paradigm language so hard to compare gold with... I think that actionscript3.0 hit the sweet spot on that side (implementations is not good enough though) 
[pdf]
There is also HTML and original POD available: http://98.245.80.27/tcpc/OSCON2011/gbu/ However those often don't display right.
I was hinting that you forgot to include that it was a pdf in the title.
While I don't doubt Perl's Unicode credentials, the problem is that you rarely "just" work with Unicode. You build a system, and interacting in Unicode is a simple necessity as one part of that. While its importance is often undervalued, it's still hard to justify choosing a language based on that alone.
Oh, sorry, didn't even consider that could be necessary.
I know you can change the prerequistes policy through cpan via cpan&gt; o conf prerequisites_policy follow cpan&gt; o conf commit And you can use cpanminus https://metacpan.org/module/App::cpanminus which is just all around better by doing a: curl -L http://cpanmin.us | perl - --sudo App::cpanminus (btw: MIYAGAWA is a perl god, many thanks...). Just seems like a strange default to CPAN going on 10+ years 
In the past, yes. It used to be that cpan would find a module that was bundled with perl and insist on adding a new version of perl to the install queue rather than just installing the cpan module.
it looks like $iv is 8 bytes. Are the &amp;H11 12... hex? You may need to unpack them.
I never have, but then I've mostly switched to cpanminus on several boxes. The windows boxes have only recently switched away from activestate's ppm and then not completely. When I first tried to use cpan it was on a windows box and as I remember it crashed rather badly---thankfully that was a long time ago!
yeah there's 8 HDigitDigit numbers. 5 of them are H## the other 3 are H'Letter''Letter'. I'm completely confused. WHen i tried to run it with the iv as "&amp;H11, &amp;H12, &amp;H13, &amp;H14, &amp;H15, &amp;HAA, &amp;HAB, &amp;HAC" When i got it it was sent to me as IV() As Byte= {codes here} i'm really just confused with what they are and how i'm supposed to use them.
give this a try: $iv = unpack("H*", "11 12 13 14 15 AA AB AC"); also try h*.
yes
I do, all the time, because I dislike it when it tries to install a ton of other dependencies. Of course, I usually end up retrying and clicking yes anyway...
Yes, this is the only time I've ever said no. "Try to upgrade the system Perl? NAK NAK!"
i'll try tomorrow morning, thanks!
I'm not sure I understand. What does perl have to do with hardware hacking?
If you don't recognize AA, AB, CD, EF or any combination of 0123456789abcdef as a hex digit, you don't belong anywhere near encryption.
&gt;clicking LIAR
You're right, i could take that defeatist attitude and accept that this is way over my head. But we play the cards that we're dealt and this is my current task for my job. So i'd prefer constructive criticism instead of a baseless assessment of my skills. Thanks!
Yup. Same thing with apt-get install. If I'm building a really minimal machine, and apt-get asks if I want to install 50 dependencies... ummm, no.
Best example is code Encrypt lorem ipsum with openssl des-cbc mode: echo 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras id est nisi, aliquam aliquet dui. Duis risus nunc, lacinia porta volutpat quis, sagittis ac neque.' | openssl enc -e -des-cbc -K B5F7E3208567BC6B -iv 32267AF8B90EA44A &gt; /tmp/lorem.bin Create this script: #!/usr/bin/env perl use Crypt::DES; use Crypt::CBC; use strict; use warnings; our $key = pack "H16", $ARGV[0]; our $iv = pack "H16", $ARGV[1]; our $cipher = Crypt::CBC-&gt;new( -literal_key =&gt; 1, -key =&gt; $key, -iv =&gt; $iv, -header =&gt; "none" ); $/ = \1048576; # 1 MiB read buffer open ( CIPHERTEXT, "&lt;", "$ARGV[2]" ); $cipher-&gt;start("d"); while (&lt;CIPHERTEXT&gt;) { print $cipher-&gt;crypt( $_ ); } print $cipher-&gt;finish(); Run it: /tmp/des-cbc-decrypt.pl B5F7E3208567BC6B 32267AF8B90EA44A /tmp/lorem.bin | xxd
The issue here is that with CPAN you only know the prereqs for the package being installed. So in the beginning it might only ask for 2 or three bit once it downloads those you find out you need another 5 and so on. In the ned you installed 25 modules.
Personally, while cpanm is nicer for the newbies, it's still far from a good everyday client, due to complete lack of test reporting.
Yeah if i am on a system where i want to use as many binary packages as possible i will run cpan in interactive mode and check to see what libs are available in apt / yum / pacman, quit cpan, install from the repo and then go back to cpan to install anything I cant get as a repo package. 
I can follow that code, the problem is i was given 8 initialization vectors to use. I tried doing $iv = unpack("H15 H40 H36 H41 H83 HAE HBD HEF"); but it's saying that the initialization vector needs to be 8 bytes. I also tried $iv = pack("H15 H40 H36 H41 H83 HAE HBD HEF"); and it said "invalid type 'E' in pack at line 6"
It gave me a warning saying "initialization vector must be exactly 8 bytes long when using Crypt:DES cipher"
meh, tried it on one of my files and it just spit out a bunch of warnings about coding standards i don't even agree with 
I would sooner believe that the single IV itself is 1540364183AEBDEF Pack's arguments are TEMPLATE, LIST The TEMPLATE is a sequence of characters that give the order and type of values, as follows ...snip... H A hex string (high nybble first). ...snip... Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in "pack("C[80]", @arr)". The repeat count gobbles that many values from the LIST when used with all format types other than "a", "A", "Z", "b", "B", "h", "H", "@", ".", "x", "X", and "P", where it means something else... All of this can be found in the perl pack man page. Potentially try des-cbc-decrypt.pl PUTKEYHERE 1540364183AEBDEF FILE
sorry i miss-spoke. What i was told was this: "IV() As Byte = {&amp;H15, &amp;H40, &amp;H36, &amp;H41, &amp;H83, &amp;HAE, &amp;HBD, &amp;HEF}" I just assumed that meant there were 8 different iv's since in all of the examples i see the iv with an H## format. thank you very much for your patience and help. I'm reading through the perl pack page trying to make sense of it.
Hard to read
Don't like the name. Don't like the complexity. Don't particularly care for the way it is being forced on the Perl community. All that and I've actually tried it. I suppose that if forced (not the use of 'forced') I might admit that it is in some regard better than what had gone before. That said, like C++, it represents massive over kill for my more humble needs. Should someone come up with something on the 'lite' side minus the silly names, then I could get behind it---I think...
Try Mouse, it's 99% compatible with Moose and has significantly fewer dependencies, or lines of code.
When it's included in the core, then I'll use it (workplace's legal department is very picky about outside libraries, with Perl being grandfathered in).
 IV() As Byte = {&amp;H15, &amp;H40, &amp;H36, &amp;H41, &amp;H83, &amp;HAE, &amp;HBD, &amp;HEF} This looks like VB hex byte notation, not perl. If you absolutely have to take input in this format as a string, you couuuuld do it like this: $iv = pack( "H16", join( "", unpack( "x2A2" . "x4A2" x 7, "&amp;H15, &amp;H40, &amp;H36, &amp;H41, &amp;H83, &amp;HAE, &amp;HBD, &amp;HEF"))) But you might as well just write the hex bytes yourself by looking. e.g. &amp;H15, &amp;H40, &amp;H36, &amp;H41, &amp;H83, &amp;HAE, &amp;HBD, &amp;HEF = 1540364183AEBDEF used like this: $iv = pack "H16", "1540364183AEBDEF";
ah ok, it's starting to make sense, thanks!
I prefer Class::Accessor in Perl 5 code personally. It's readable, obvious and fast.
Wow... 611 pages!!! How long is this presentation!?
How is it being forced on the community?
I never understood this. Are they worried about the license to use it or something?
Two problems there: 1. The maintainers of perl don't want Moose in core. 2. The maintainers of Moose don't want Moose in core.
It's a three-hour tutorial. And it's very, very good. It doesn't just explain what Moose does, it actually puts the features in a context of where you would use them, and why you would want them done the Moose way instead of some other half-assed way.
Ahh makes sense. Its gone from 10 slides a minute to 3 slides a minute! 
If you've used Moose and think it's complex, you're doing it very, very wrong. Every feature Moose provides _reduces_ complexity of your code. Perhaps your problems stem from your poor OO design being shoehorned into a proper OO framework?
Dear god I can't imagine using perl without outside libraries. Talk about eliminating Perl's greatest strength. Edit: thanks literal
99% is probably overstating the reality of the situation somewhat. But that said, Mouse is a good alternative to those who can't use Moose. 
Lucky for you, we (me) are working on a proposal for a better OO system in Perl as I type. By default it won't be as featureful as Moose, but it should be a step above what is currently there. 
I don't think it is being forced upon anyone, people are using it by choice. Just because they find value in it and therefore evangelize it does not mean they are forcing it upon anyone. Personally, I have always said "if you don't like it, don't use it", after all, this is Perl, and TIMTOWTDI is always in effect. 
You can always cat the build.log when something fails. 
You can run Perl on the Arduino hardware, google it and see.
&gt; I've always thought that perl5 should look into becoming more perl6ish But you don't like Moose? I am confused because Moose is *heavily* based on Perl 6. I should know, I wrote Moose as a reaction to all the time I spent writing Perl 6 MOP prototypes for Pugs.
&gt; it represents massive over kill for my more humble needs. Then don't use it. 
I meant reporting as in cpantesters, i know i can look at the logs if i need it. :)
You're absolutely right. Of course, it depends on your use case; you always have the option of upgrading later.
yep, because it's not as well interleaved with perl5 imo. Certainly because it's done on top of it instead of being built from the ground up for it. and I did not say that i was fond of perl6 oop system btw. there are some stuff that i don't like... but... sometimes you have to pissed off some people to get things done. you can't make everyone happy. and when i read that we have to get people to agree on a OOP system, i really wonder why? Larry Wall has already explained how it should be and this is what perl5 should try to become. I won't be happy with everything but c'est la vie. 
6model is not an object model, it's a toolkit for building object models. I'm pretty sure you can build a fast, p5 compatiblity object model and ship it with core, and allow others to build their own object models. I don't see what's wrong with that.
Also, there's a slide for every transition. There aren't really six hundred unique slides.
&gt; yep, because it's not as well interleaved with perl5 imo. Honestly, it is pretty transparent and integrates very tightly with perl5 guts. In fact, that is the biggest headache about the implementation, the fact we must work so closely with the existing Perl 5 OO system. You should also keep in mind that the vanilla Perl 5 OO itself is a bolt on (as described by Larry). &gt; Larry Wall has already explained how it should be and this is what perl5 should try to become. I won't be happy with everything but c'est la vie. First, let me say that I would love to see Perl 6 come to fruition. In fact, the Moose effort was a major part of Audrey Tang's "Perl 6 on Perl 5" plan. But having studied and prototyped the Perl 6 meta model several times, and having looked over the more recent Perl 6 work, I doubt that it is as simple as just "Perl 5 becoming Perl 6". The Perl 6 object system reaches to the very core of the language, to do this in Perl 5 would be impossible (assuming of course we care about things like backwards compatibility). There is currently an effort underway by Jesse Vincent (the current Perl 5 Pumpking) to bring some sanity into the Perl 5 core. I am working with him in trying to create a new Perl 5 MOP based object system for the core. It will be heavily influenced by Perl 6, but will not be exactly like Perl 6. I do promise that I will keep Larry in the loop and get feedback from him on a regular basis though, so do not worry :)
I always have trouble with perl6.org links for some reason.
"This page is in Croatian, would you like to translate it?" — Chrome
Well, if Moose looked like below, I would find it transparent and integrated with perl. class Point { has Int $x is rw; has Int $y is rw; method clear { $self-&gt;x(0); $self-&gt;y(0); } } class Point3D is Point { has Int $z is rw; method clear { super(); $self-&gt;z(0); } } Certainly a matter of test... &gt;I doubt that it is as simple as just "Perl 5 becoming Perl 6" Try to become like Perl 6, within the limits of what is feasible within Perl 5. Not all the features of Perl 6 could be imported into Perl 5 (else Perl 5 would be Perl 6!) and they should not anyway. Just narrowing the barrier between the two version of the language would help. &gt;a new Perl 5 MOP based object system for the core Good news! 
Are you even kidding me?!? And then we wonder why we get a bad name... lol.
I am an organizer of the Pittsburgh Perl Workshop we are proud to have Dave Rolsky teaching his Intro to Moose class. If you find Moose confusing Dave's class will clear that right up. I took his class and highly recommend it. http://pghpw.org/ppw2011/mooseintro.html Regarding Moose being forced on the perl community that seems an unfortunate conclusion. The talks and courses we have received over the past few years have been Moose related because it is the new shiny and help helps a lot of people really enjoy OO in perl. I have been to four perl events this year and no one has told me I had to use Moose:) I would be very happy to offer other competing OO talks. 
&gt; Well, if Moose looked like below, I would find it transparent and integrated with perl. Actually the current direction of the proposal would have core Perl OO looking something like this: class Point { has $x; has $y; method clear { $x = 0; $y = 0; } } class Point3D { extends Point; has $z; method clear { $self-&gt;next::method; $z = 0; } } Things like type constraints and auto-generated accessors would have to come from an extension like Moose, but by default you would at least have a proper object system that is backed by an extensible MOP.
WTF can anyone figure out what this is? I'm afraid to play with.... aaaa... aaaaaaaaaa aaaa aaaaaaaaaaa
That looks more integrated with the language indeed! is there a reason not to do class Point3D is Point {} ? or at least use "is" instead of "extends" would be nicer. On the semantic side: next::method recalls the process done behind the scene of climbing back the inheritance chain(or tree in multiple inheritance),which, has a user, is not something we should have to care about. method clear { super;#or $self-&gt;super or $self-&gt;super::method $z = 0; } seems more natural. on the other side, why do we have to use $self here but not on the instance variables? I am asking the points that concerns me but in anyway, it is still way much better than the actual system! 
From what I can tell from a 5 minute glance over it, The program will read it's self in, translate all the lines of 'A' into something useful or if it's in English, translate to 'A's. Not sure if there is any other code in there. Neat little bit of obfuscation though.
It's Schwern, do you really expect anything else?
The funny thing is, that code isn't really even magical. Code that *uses* that module will be a bit more messy, but that code itself is perfectly valid code, and with a little bit of effort, you'll realise that all there is wrong with it is all the identifiers are arbitrary. * package names are just big lists of aaaa, but thats fine, because package names don't really indicate how it works, just a label * variable names are just big lists of aaaa, but that's fine, because variables are arbitrary anyway, could be the letters of the alphabet or peoples surnames * subroutine names are just big lists of aaaa, but like the previous 2 cases, this is just arbitrary Once you get past the distraction/confusion that arises from the difficulty of discerning one 'aaaa' from another 'aaa_a' it starts to become more straight forward. * All the builtins are still the same * All the keywords are still the same * All the syntax is still the same * Flow control is still the same Once you see that, you can see how the flow control operates, you can see the *types* of data they're working with ( @ = array, $ = scalar ,etc ) and easily know when array reads/writes are being done, when string substitution is being done, and soforth, and take reasonably accurate guesses at what is happening. I'll just rename a few variables on this example: my @aaaaaaa = ('a'..'z', 'A'..'Z', 0..9); my %aaaaaaaa_aa_aaaa; for my $a (0..$#aaaaaaa) { my $aaaa = sprintf("%06b", $a); $aaaa =~ s{0}{a}g; $aaaa =~ s{1}{A}g; $aaaaaaaa_aa_aaaa{ $aaaaaaa[$a] } = $aaaa; } And it will become much clearer: my @symbols = ('a'..'z', 'A'..'Z', 0..9); my %translation_table; for my $symbol_index (0..$#symbols) { my $binary = sprintf("%06b", $symbol_index); $binary =~ s{0}{a}g; $binary =~ s{1}{A}g; $translation_table{ $symbols[$symbol_index] } = $binary; } The transformation is almost magical. 
&gt; or at least use "is" instead of "extends" would be nicer. It is possible it might go that way it is still pretty early in the design stage. A lot of this has to do with how we ultimately handle class metadata and also what the Perl parser is capable of handling sanely. &gt; re: next::method I agree with your points, but it is important to keep in mind that the goal of the core object system and MOP is to provide more then the current object system, but still try and retain much of the flexibility and power it had, albeit through a much saner API. This means that extension modules would be able to implement more user-friendly/opinionated/DWIMey features like a 'super' keyword *and* still be performant. The goal here is not to build the One True Way (if you want that, there is a snake around the corner who would be happy to help you out), but to make TIMTOWTDI saner and more compatible across different extensions. 
I don't really understand how offering next::method would allow more easily people to monkey-patch it to get some sugar around it that looks "super". why not implement it this way in the first place? someone could perhaps create a module the other way around then. I am likely to use only the core features offered by default in the language (Ideally I would use CPAN for things that allow me to resolve some problems for my day to day job,say, connect to a twitter account, not the one that fix the language,say try catch) Perl6 offers everything you need and more. OOP is in the language by default. it's not because Perl6 ships with OOP and predefined way of doing things (right) that it will become the new snake. it offers you the best tools by default and then you can make them even better or why not, worst,afterward. you are still free to pick. well, it's just that next::method soundenot much better than Next::* that is itself kinda ugly. 
I'm a little confused as to why that %06b isn't working as I'd expect. `perl -E 'for ('a'..'z') { say $_, ": ", sprintf "%06b", $_ }'` &gt;a: 000000 b: 000000 c: 000000 
That's because you're `sprintf`-ing the character itself instead of the characters position in the list. What you want to do is either `ord( )` that character, or this: perl -E 'my @s = ('a' .. 'z'); for ( 0 .. $#s ) { say $s[$_] ,": " , sprintf "%06b", $_ }' &gt; a: 000000 &gt; b: 000001 &gt; c: 000010 &gt; d: 000011 
Numbers, not letters. perl -E '@a = ("a" .. "z"); for (0 .. $#a) { say $a[$_], ": ", sprintf "%06b", $_ }'
Lol. It appears there's more than one way to do it, but people tend to do it the same way anyway &gt;_&gt;
What is it?
Someone's been playing Impossible Mission!
It is quite simple, something like next::method is, as you pointed out, a more low level feature. And it would therefore allow more access to things at a lower level, which means it is more powerful and flexible. The responsibility (as I see it) of the base language (which includes the MOP) are to provide powerful and flexible features which users can build upon. By heading down the road of next::method, you open up a number of possibilties, such as the ones that are found in the current [mro](http://search.cpan.org/~jesse/perl-5.14.1/ext/mro/mro.pm) pragma, such as next::can (testing if any of the superclasses have a viable method) and next::maybe::method (which will only dispatch if a superclass method is available). Additionally we could explore dispatching to multiple superclass methods, similar to how BUILD/BUILDALL works in Moose and Perl 6. All this would be possible by simply extending the semantics that next::method is based on. Something like 'super' on the other hand, would be more opinionated and less featureful, which would, in my opinion, ultimately restrict the language. Which is why it makes more sense to implement somethng like 'super' on top of something like next::method. 
Yeah I was looking along the same lines. the /[b-z][B-Z]/ match after the open in the first function looks to read itself in, drop all the a's from it's own file and presumably comes out with some more valid Perl.
[A perl IDE](http://padre.perlide.org/)
&gt;provide powerful and flexible features which users can build upon. perl5 already did that then. I would wish for something else now. &gt; maybe::next:method. you're taking an example based on an extension written in XS so perhaps we'll have other modules that wrap up next::method with a super thing but still: - the semantic is purely based on the mechanic instead of the general concept - too much strokes for something i will certainly use very often (whereas all the extensions would perhaps come in handy once every 2years or so ) - i will have to load yet an other module to just get super (and most of the time, the module will come with other stuff that i don't need so i will write my own and boom dark zone here we are) people has been able to change the mechanism of perl until up to now so i still don't really see how calling something super would be that less flexible(if we use perl it's certainly not to have to deal with low stuff) as long as the implementations allow to hijack it and allow to change its behavior when we want. i can understand that having something "low" would certainly allows some sugar on top of it but well, where did perl5 implementation of OOP lead us? if this come into perl5 core, i really wish this "next::method" will be supported by a super method by default (loading a bunch of modules just to have access to a language that can handle oop would be missing the point don't you think?) you certainly thought it out longer than me so I certainly won't change your mind but again, perl5 should tend to be like perl6 so why not go all together with nextsame (i don't like this one though lol but if I were to choose, i'll go with the method that is shorter) 
I tried it (Snow Leopard) and a simple printf("Hello world.\n"); made it crash as soon as I clicked "Run". Your mileage may vary.
what about just print "Hello world.\n"; EDIT: I installed it and ran both printf and print and both caused the program to crash. I'll file a bug report if someone will point me in the right direction.
Cool, thanks for the in-depth analysis. I guess what I'm really not understanding is the purpose of this: my $binary = sprintf("%06b", $symbol_index); $binary =~ s{0}{a}g; $binary =~ s{1}{A}g; $translation_table{ $symbols[$symbol_index] } = $binary; It seems to be converting characters (a .. z, A .. Z, 0 .. 9) to their binary equivalent? but then everything is converted to a or A and assigned as a value to the %translation_table hash list. 
Well, not binary equivalent, its more a "cipher" of sorts. `@symbols` is your base character cipher map, ie: mapping a specific order of letters to numerical values, ie: ` a =&gt; 0, b =&gt; 1, A =&gt; 26, Z = ..... ` etc ( You could just apply a random sorting algorithm to `@symbols` and get different values, but then you'd need to somehow store/read the seed or you'd never decode the encoded data ;) ) It is *this* value which is converted into binary, and then the '0's represented by 'a' and the '1's represented by 'A'. And it then builds a hash of "input symbol" =&gt; "output symbol" for quick lookup Here is the same concept but using some other alternative arbitrary indicator for "0" and "1" : https://gist.github.com/1111274 
You can report bugs here: http://padre.perlide.org/trac/ If you do not have a Padre Trac account yet, go to the Padre IRC channel and ask for it. See here: http://padre.perlide.org/contact.html
For anyone else running into this problem, I've created a ticket at http://padre.perlide.org/trac/ticket/1269
Very nice, I've been seeing some interesting things about MetaCPAN.
I would've loved to sign in and connect my PAUSE account, but doing so manages to direct me to api.metacpan.org/user and a nicely-formatted bit of JSON in my browser.
Article does suggest you read the documentation and configure the static analysis tool to suit your taste - what policies to apply is beyond the scope of a single article and my choices wouldn't be yours.
first 3 times i saw this post i was sure it was a perl module to access C-SPAN programming schedules ...and it didn't seem odd to me at all..
Arg, I wish I could have attended OSCON this year. The slideshows are hard to follow without a speaker.
I got a JSON response from the confirmation link in the email, ignored it, and afterward it seems to be OK.
Moose in core? Hahaha, that would be worse than C++.
&gt;Dear god I can't imagine using perl with outside libraries. Talk about eliminating Perl's greatest strength. Don't you mean *without*?
i will be in Riga
Why is using @$array_ref worse than @{$array_ref}?
unless { ... } else { ... } makes me cringe (and my brain explode) every time I see it. 
I've thought about Mouse and it is quickly rising to the top of my 'eval' to-do list. Thanks for the reinforcement.
I've thought about Mouse and it is quickly rising to the top of my 'eval' to-do list. Thanks for the reinforcement.
I've been reading most of the Perl blogs and it is the only subject when it comes to object orientation. I don't know---is that 'forceful' or not. I think yes, you think no. I'm guessing that it will become the standard, silly names or not. Just not sure I'm all that comfortable with it.
You make a number of offensive assumptions. Not un-common in other language fora, a bit rare for Perl. You don't know what I've done or not done in Moose. And until I find the sweet spot, you are not likely to. Why don't you think about your attitude and re-phrase in terms that might persuade rather than put off? Or were you just taking your ego out for a walk?
I would rather keep @$foo... It's much less punctuation.
Most reasoned reply in the chain---thank you! Between my still not finished evaluation of Moose and the suggestion about Mouse, I'd have to say the verdict is still out. One of the problems is that I use OO in a way that many Perl programmers might not. Coming from a very early C and then C++ (when it came along) background I tend to not use many feature that others might find necessary---I take a 'tool builder' approach that uses just enough OO and no more than that. My initial dip into Moose has thus far required more than that which I find frustrating. Perhaps it is the simple lack of someone to ask 'stupid' questions of; I'm not sure. I will continue to work away as if I can find a common meeting ground between my needs and Mouse, I suspect I will in fact find it a good deal simpler than my previous code. As for TIMTOWTDI---the dark side is that it applies all of the way down and without authoritative documentation (assumption free and with copious examples) choices often lead to 'twisty little passages' without any clear cut path forward.
Most reasoned reply in the chain---thank you! Between my still not finished evaluation of Moose and the suggestion about Mouse, I'd have to say the verdict is still out. One of the problems is that I use OO in a way that many Perl programmers might not. Coming from a very early C and then C++ (when it came along) background I tend to not use many feature that others might find necessary---I take a 'tool builder' approach that uses just enough OO and no more than that. My initial dip into Moose has thus far required more than that which I find frustrating. Perhaps it is the simple lack of someone to ask 'stupid' questions of; I'm not sure. I will continue to work away as if I can find a common meeting ground between my needs and Mouse, I suspect I will in fact find it a good deal simpler than my previous code. As for TIMTOWTDI---the dark side is that it applies all of the way down and without authoritative documentation (assumption free and with copious examples) choices often lead to 'twisty little passages' without any clear cut path forward.
Love too---on the other hand, I live in Boise, Idaho. A bit of a commute to any city large enough for a Perl Workshop with such notables as Dave Rolsky. Would love to talk to him about documentation though :) Yes I should avail myself of on-line resources since I live in the back of the beyond regards technology, but Moose is not the only 'ooh shiny' that I have been attracted too :)
Why? Can't evaluate something if I don't use it. You were expecting all users to magically fall in love with something as radical as Moose? That isn't going to happen. It is both an on going project as well as new enough that it suffers from the usual---documentation is certainly not as good as it could be. I gathered most of it in as I worked my way through my evaluation. It needs help. Yet at the rate of change in the project it is a bit dangerous to start such things now---moving target and all that. It will have to come though; beginner to expert with enough examples to choke a horse (poor horse)! Given that it will take over and perhaps rightfully so.
Why? Can't evaluate something if I don't use it. You were expecting all users to magically fall in love with something as radical as Moose? That isn't going to happen. It is both an on going project as well as new enough that it suffers from the usual---documentation is certainly not as good as it could be. I gathered most of it in as I worked my way through my evaluation. It needs help. Yet at the rate of change in the project it is a bit dangerous to start such things now---moving target and all that. It will have to come though; beginner to expert with enough examples to choke a horse (poor horse)! Given that it will take over and perhaps rightfully so.
Why? Can't evaluate something if I don't use it. You were expecting all users to magically fall in love with something as radical as Moose? That isn't going to happen. It is both an on going project as well as new enough that it suffers from the usual---documentation is certainly not as good as it could be. I gathered most of it in as I worked my way through my evaluation. It needs help. Yet at the rate of change in the project it is a bit dangerous to start such things now---moving target and all that. It will have to come though; beginner to expert with enough examples to choke a horse (poor horse)! Given that it will take over and perhaps rightfully so.
If they allow perl, I'd think they should legally be okay with any perl library. Very strange.
&gt; Can't evaluate something if I don't use it. So you evaluated it. You don't like the name. Don't like the complexity. It's massive overkill for your more humble needs. So don't use it. Nobody is making you use it.
So just the top Perl articles on reddit each week?
Really? I've run a lot of Mason 2.0 stuff fairly fast with just plain old plackup. I've never noticed it being slow at all.
Strange... must be my own idiocy. Although I did notice that placking up with a specific server (e.g. -s Starman) *seemingly* results in a tremendous speed increase. A clue, perhaps?
This picture was a little discouraging upon confirmation. Not that I hate python but shouldn't perl be handling this? http://i.imgur.com/h6cp6.jpg
i got suspicious that it might be a email aggregator scam...
Maybe... szabgab is a name that I recognize from reading about perl on the web for a while now. I guess we'll see.
Best tool for the job and all that...
sounds nice, but what I'd like is an rss version of this, there's enough stuff in my mailbox already
I bet you have reverse DNS problems.
Which operating system on the server side and which browser on client? There's a known issue in IE9 and Chrome incognito mode where it hangs the default Plack web server (HTTP::Server::PSGI) causes any requests timing out. https://github.com/miyagawa/Plack/issues/191
This isn't a perl problem, it's a shell problem and then (maybe) a perl problem. Write a small script to just dump $ARGV[0] to STDOUT. Iterate it until you see what you want in terms of the string. Repeat with the output and pipes until you get to the next station along the way. And yes it is a matter of escaping things, but which things depends on the shell...
You have convinced me that you and several others have no interest in a dialog. How nice for the future of both Moose and Perl. I used to follow your comments on PM with interest. What happened? 
I'm not sure what you're trying to do, but maybe this "$@" bash trick will help? $ a() { perl -le 'print join ":", @ARGV' $@; } $ b() { perl -le 'print join ":", @ARGV' "$@"; } $ a 'bash quoting rules' 'can be confusing' bash:quoting:rules:can:be:confusing $ b 'bash quoting rules' 'can be confusing' bash quoting rules:can be confusing HTH!
nice. will be signing up
Two things! **First,** Your issue stems from your shell. Roughly, in the command line, put " " around what you'd like to save. Depending on the shell, this may be different. **Second,** More a preemptive strike: Stop trying to parse command line options yourself. See one of the various Getopt:: modules. Getopt::Long (for --foo bar style command lines) or Getopt::Std (-f bar style)
I think you need to tell us more about what you're trying to do. Are the quotes there because you want to pass arguments that contain spaces, or are the quotes there for their own? If the former, then you really don't have to worry about actual quotes, you just have to be sure to use the list form of things like `system()` so that you maintain list semantics without reparsing. Example: suppose `showargs` is a program or script that simply lists its argv[]. If you use the string version of system then this fails: $ perl -e 'system("showargs " . join(" ", @ARGV))' "this is arg one" "this is arg two" argv[0] = 'showargs' argv[1] = 'this' argv[2] = 'is' argv[3] = 'arg' argv[4] = 'one' argv[5] = 'this' argv[6] = 'is' argv[7] = 'arg' argv[8] = 'two' You could try to fix this by ugly escaping: $ perl -e 'system("showargs " . join(" ", @ARGV))' '"this is arg one"' '"this is arg two"' argv[0] = 'showargs' argv[1] = 'this is arg one' argv[2] = 'this is arg two' or: $ perl -e 'system("showargs " . join(" ", @ARGV))' "\"this is arg one\"" "\"this is arg two\"" argv[0] = 'showargs' argv[1] = 'this is arg one' argv[2] = 'this is arg two' However, if you use the list version everything is much easier: $ perl -e 'system("showargs", @ARGV)' "this is arg one" "this is arg two" argv[0] = 'showargs' argv[1] = 'this is arg one' argv[2] = 'this is arg two' There was no need to worry about actual physical quote characters, or messy backslash escaping, because when you use the list version your arguments are already separated into words and don't undergo another word-splitting. This is another way of saying that the list version does not invoke the shell to run your command, and it's the shell that is the source of heartbreak in this scenario. Avoid the shell at every step and you'll be fine. 
Two key strokes? lol. I recommend [Perl Best Practices](http://oreilly.com/perl/excerpts/perl-best-practices/appendix-b.html#perlbp-APP-B-SECT-11) (&lt;- that's the part about dereferencing specifically).
According to [Perl Best Practices](http://refcards.com/docs/vromansj/perl-best-practices/refguide.pdf), you should dereference using arrows: $foo-&gt;{bar}-&gt;{baz}-&gt;[0] because it is more obvious. When using prefix dereferncing, it is best to use brackets so it is not confused from soft references (or variable variables for that matter). %{$hash_ref} @{$array_ref} ${$string_ref} When only using one layer of references this is not as important as when using deeply nested references of references, however, it is always *best* to use *proper coding techniques*; I will concede that ***proper coding techniques*** and ***best practices*** are largely subjective and should be agreed upon by the team of developers (consistency is key), in a single developer environment *best practices* are largely the developers preference, but it is best to keep it consistent. (Which the OP did.) I used to be notorious for doing the same things differently even within lines of each other... The code would run, but go back to it months later and it's like "WTF was I thinking?!? Was I drunk?" Really it boils down to better/worse is mostly subjective. Just keep it consistent.
Actually, Getopt::Long accepts both -f --foo, but Getopt::Long is much more flexible then Getopt::Std. See [this thread](http://perlmonks.org/?node_id=886569) more on Getop::Long. (Especially read the comments.)
What kind of dialog are you looking for? You said you don't like it. What would you like me to say?
And let us see what you have tried that isn't working!
Escape the quotes.
As usual, there is a module for that: https://metacpan.org/module/String::ShellQuote Just have it quote the first string, insert that into your shell call, then quote that and call it on the shell.
Is there a compelling reason to use activestate perl now we have strawberry?
Good question. One i know of is that it acts more like perlbrew in that you can tell it to not modify your windows environment; making it easier to run different Perls on the same Windows machine. The Perl versions available with it are also more current: AP comes in: 5.14.1 and 5.12.4 SP comes in: 5.12.3 and 5.10.1
Strawberry has Portable version.
Yeah, I wrote a little application in Java that will fetch the top items from Reddit and post it on a Python based list so I can harvest the e-mails :)
That was the easiest to start with but it is changing soon. Watch my blog if interested.
Keystrokes add up. And that book is six years old. PBP isn't the Bible.
You know, I've never even tried to use ::Long for the -f style stuff. I always just assumed (mostly because I vastly prefer the GNU-style --foo stuff). And you know what assuming does.
that was my thought too. CPAN was a big reason I originally switched to Strawberry - it bundled a compiler. Activeperl could be configured beforehand, but it just wasn't reliable. It's nice that they now make it easier, but I doubt I'll switch back.
By God you're right. I was contacting the server through Chrome Incog (on a machine running OS 10.6.8). Funny, though, my request didn't time out... I mean, it eventually got a response. I really feel like I tried at least once opening a Chrome in normal mode and contacting the server (and it was still slow) but I'll verify tonight. Thanks for the information!
What it mean reverse DNS problem?
and lack of key strokes make code harder to read. Would you rather: 1. Use a few key strokes as possible, be able to code the fastest, but always have to start a project over because you can't read your own code 2. Use as many key strokes as possible, code the slowest, but be able to go back and read you code and know what it was doing? The best code is self documenting, and typing comments are key strokes.
It actually looks pretty neat. Thanks for pointing it out, wasn't aware.
This isn't a binary debate.
The point was more to raise awareness that there is no reason to warn people away anymore. The idea that ActivePerl "doesn't do cpan", which is sadly spread by the strawberry site and has never been correct, is fairly entrenched even now still and this article serves to highlight that it had been wrong and has recently become even more wrong.
local::lib and App::cpanminus are poor examples to demonstrate the included power of the setup, as both are pure perl modules, and thus you don't even need a bloody C compiler to install them. 
How does assigning a code name let me know when it came out? I don't get it. 
I guess he could've installed OpenGL, but that's equally boring. :) https://gist.github.com/6e9e38076042403ce4a7
A code name doesn't tie a release number to a year, but code names compare more easily to each other in two ways: * by alphabetical order, B is closer to A than G is * by denoting each major yearly release as a major thing in a way which incrementing the second integer in 5.xx does not
I mostly prefer the --foo style too, but if there is only one option that starts with -f I usually cheat when I'm quickly banging out commands. Personally I've never seen a reason to use Getopt::Std
I still use ActiveState. I have no problems with it and it has served me very well.
01010011 01101111 00100000 01111001 01101111 01110101 00100000 01110011 01100001 01111001 00101100 00100000 01100010 01110101 01110100 00100000 01101001 01110100 00100000 01110011 01110101 01110010 01100101 00100000 01110011 01100101 01100101 01101101 01110011 00100000 01100010 01101001 01101110 01100001 01110010 01111001 00100000 01110100 01101111 00100000 01101101 01100101 00101110 00101110 00101110 
I mostly prefer the --foo style too, but if there is only one option that starts with -f I usually cheat when I'm quickly banging out commands. Personally I've never seen a reason to use Getopt::Std
In all seriousness, you are right, however, I was using hyperbole to make a point. Often times, the 'key strokes add up' mentality is pushed to the extreme and makes code unreadable. Sure it may take me fifteen minutes longer to type $explicit_variable_names, but then I don't get confused with $e_v_n and $ex_v_n. (again here is the hyperbole)
Well one of the things I noticed along the way in my evaluation, was a lack of useful documentation. Note that I did not say lack of documentation, I said lack of 'useful' documentation. Much of what I say was in the nature of Jack Web's 'Just the facts ma'am' and written with other developers in mind. What I didn't see is a community effort (wiki comes to mind) built by both users and developers. Those of you still working with bricks and mortar are obviously busy, but the rest of us still need the 'how-to's for new technology, particularly technology as radical as Moose. I also noticed that much (or at least that which I was looking at) suffered from the assumption game. That is, written with the notion that the reader knows much if not all of what the developer knows (excepting of course the new 'stuff'). Regrettably this is many notches higher than what the beginner needs. I'm aware that just getting things down on paper, digital or otherwise is a major accomplishment. Likewise I'm aware that there is nothing resembling a decent set of tools to help in this task. It takes hard work by two disparate groups; writers and developers. Worse the writer must 'understand' what the developer is telling him. Rare indeed. The original Perl docs grew over a long time and are beginning to show signs of their age and perhaps this has caused hesitation in the Moose world. I no more know the answers than anyone else---all I know are the problems that I've run into. Couple of things before I forget. 1. my crack about the name was a gut reaction. Moose is as good a name as any, it is just that we actually have them wander through town (Boise, Idaho) every very great now a so the name kind of throws me off a little---it will make a great cover for the book though :)
I'm afraid I don't get it either. 2 is also closer to 1 than 7.
None of that addressed your previous complaint that I "have no interest in dialog".
What's the correlation between 5.14 and 5.8 in years? 5.20 and 5.16? Our brains see numbers and we try to figure out patterns, even if those patterns don't mean anything.
Perl 5.14 has been out for almost 3 months. Where is the strawberry release? Maintaining a distribution is hard work and ActiveState has a solid track record of staying up to date. 
As far as i remember the reason is that Strawberry bundles a bunch of hard to compile cpan modules and one of them is flat out broken in perl 5.14 (not strawberry, it's really the module itself on all platforms); so they're delaying until that is solved. Others may correct me though.
[Ummm......](http://thedailywtf.com/comments/One_Version_to_Rule_Them_All.aspx)
come on! nothing!!!
And then there's [this guy](https://rt.cpan.org/Public/Bug/Display.html?id=60275)...
That is a good and horrifying read. :)
How does adding the name of a flower tell you anything about the year?
i still don't understand what is so shiny about metacpan. it looks like another cpan mirror to me. maybe i am missing something fundamental...can anyone tell me what i am missing?
It doesn't. Only adding the year number to the release number would do that. Because *that* isn't going to happen, perhaps another strategy (codenames perhaps) could provide that benefit in addition to others. Perhaps not.
Perl Millenium Edition!
The big problem is that I have to read in arguments that themselves are to be passed to another program entirely: So we wind up with: -indirect_option "-option_indirect blah"
The GNU tools avoid this problem by using a comma instead of a space. For example, say you're linking a C program that needs an executable stack. You need to inform the linker of this fact so that it can mark the section appropriately but you aren't invoking the linker directly because gcc needs to add a number of objects and options to the link, so it's standard practice to link by just running gcc and having it invoke the linker. gcc has implemented the `-Wl` option to pass arguments to the linker, so you'd invoke `gcc ... -Wl,-z,execstack ...` and when gcc goes to execute the linker it will add `-z execstack` to the command. 
Oh, sorry for the delay. I've talked to the author, and he says it's not in the releaseable state. You should be able to catch him on #perl6, freenode (mberends), to maybe contribute or alpha-test it.
Your reply is self referential. What I wrote consisted of things that might have been suitable to have a dialog about. Your answer is your answer. Take care and have a nice life.
Oh. I didn't have any comments to make about your assessments. Everything I've seen you say in this thread has been a pronouncement, and I didn't see any reason to rebut any of them. You don't like the name, you think it's overkill, the docs are hard to write. I get it. I just didn't have anything to argue about. I'm not going to argue with you just to argue with you.
Ouch, why import an entire module? perl -le 'print map { (a..z,A..Z,0..9)[rand 62] } 0..pop' 8
The important question here is: **Why not?**
Some additional discussion on the topic: http://news.ycombinator.com/item?id=2843715 Also, this is posted here as well because the SICP actually explains really nicely how to use lambdas and constructs like map and grep effectively.
Efficiency.
Oh nice, premature optimization.
Sigh. No wonder it is so hard to hire a new graduate who has any *theoretical* skills (that are applicable to any language *de jour*), as opposed to simply knowing how to write 1000-line programs that do very little in PHP or Java... :/
This might be off-track, but I wonder if the industry might follow some sort of $n-year cyclical scapegoating pattern where the new generation of consultants come in and explain to executives looking for a magic bullet to fix their problems: "Oh, yeah, jeez, this aged system of yours is written in old and broken $language_x. We've gotta bring you out of the stone ages and rewrite your system in $language_y." 
Also available as PDF or text: http://dl.dropbox.com/u/10190786/oscon2011-perl5-16andbeyond.pdf http://fsck.com/~jesse/tmp/2011-07-05/221c115e-a9cb-43fa-b949-6a58192e91e7/slides-for-yapc-na
Perl Dancer is amazing! If you're into web development, definitely give Dancer a look, you might be surprised how fun and productive web development can be these days. Dancer is two things packed together: it stays out of your way if you like that, but also provides you with very powerful primitives to get the complex web tasks done in just a few lines of code. Highly recommended to both novices and experts!
Ah, a brand new Reddit account created just so you can troll, pretend to be a well-known member of the Perl community and attack the project. Don't you have anything better to do my friend?
You're just being ignorant now, even the second longest standing member of the Dancer core team SawyerX called using global variables a huge mistake that should have been addressed a long time ago. Yet, in two full years you've not even done that.
Another new account to troll? Excellent. For what it's worth, though - yes, there are parts of the codebase which use global variables and singletons; we *are* aware and do acknowledge that this is sub-optimal, and we do have plans to re-write those parts of the core, an effort which is starting soon.
HEY LOOK IT'S A MORONIC TROLL. Got tired of your dupe accounts being deleted from cpanrantings? Bored of having your blog comments rejected? So now you think it's a good idea to impersonate *me*? Jesus H fucking christ on a rainbow unicycle but you aren't very good at this are you? I mean, come on, trying to impersonate *me* when you can't even insult meaningfully? If this was a battle of wits, you'd be a pacifist. When you were born, did the midwife slap your mother? If this is all that Dancer's detractors can manage, jesus, maybe there is something fucking wrong with it - Catalyst and Mojolicious have both managed a far better class of enemy than you, you mindless little fucking moron. Now, next time before impersonating somebody, think - can I convincingly be this person? Because on a scale of one to ten, your current attempt is an integer underflow. Piss off. -- love, mst
Regarding globals: I brought the issue to the team's direct attention for the first time 3 days ago. They had not considered the issue yet because they were busy fixing other things and almost immediately agreed it needs to be fixed. The core team has been nothing but stellar in responding to criticism.
Oh, really. It works. It's fuck ugly and I believe I told sukrieh he couldn't design his way out of a paper bag. But it works. Maypole and Class::DBI (and early DBIx::Class) had a bunch of stuff as globals. A lot of code still uses mutable class data for a bunch of things, which is basically just a shiny way to hide having ... globals. I restricts some things. It needs to be refactored away. But for the sort of small-scale apps that most of the Dancer community are writing, it works FINE. It still annoys the hell out of me, and personally I'd still far rather use Catalyst, but I'm working on way bigger apps most of the time. One size does not have to fit all.
So what you're saying is that absolutely nothing has been done and peoples jobs are still on the line over this.
An interesting way to go. Multiple languages within one language, where you choose which one you get by doing `use 5.$x`. And the higher the $x, the more cleaned up the language. Seems similar to what Racket does. 
If you are choosing a technology to power a business and you know nothing about it before doing the implementation, then you *should* be fired. Always research your platform beforehand, anything less is irresponsible at best.
Bless you sir!
It had to be done. Thank god it's being done by you.
What about symbols? :) perl -le 'print map { chr((33..126)[rand 94]) } 0..pop' 15 I have that as a bash function: genpass() { echo -n 'Give me a number: ' read -e number perl -le 'print map { chr((33..126)[rand 94]) } 0..pop' $number }
I like the thinking behind those ideas.
this is awesome. thanks jesse. never been a fan of exceptions but i also expect that any implementation will be sufficiently perlish and not javaish
Awesome, will be hard to top this again next time. :)
Mojolicious is an unparalleled web application framework for Perl. Its strengths are not only in its feature-set, but in its architecture.
The second in Glen's awesome Mojocasts, every bit as excellent as the first.
It was a good talk. I was debating going to that or something else, and I ended up being glad I went. It encouraged me to take the time to compile a newer Perl on the Solaris boxes at work (since our UNIX admins refuse to do much more than keep the machine powered up and install the Oracle patches).
I have other book projects at the moment, but I support the idea and am willing to help with advice, publishing tools, proofreading, or whatever my time allows.
maybe this is something we should undertake. although my perl Fu is shaky at best...
Are you allowed to talk about how your publishing company is structured or is not something you own ? Maybe you could do an Aunt JIAMA...
~~_Learn Ruby the Hard Way_ is illegitimate.~~ [See below.] Zed Shaw has [spoken out](http://www.reddit.com/r/programming/comments/e1uuv/please_take_this_down_and_write_your_own_book_zed/) against it. [Here's a guide by him on how to do it right.](http://sheddingbikes.com/posts/1288945508.html) &gt; I've ran into a few people who think it'd be a good idea to take Learn Python The Hard Way, pull out the Python, and put in language X. This is like taking a Chinese cookbook and trying to make a Mexican version by swapping out all the spices for Mexican ones. It just doesn't work because there's more to food and a book like Learn Python The Hard Way than the ingredients.
I'm an owner and it's a private company, but I figure most of the business details are uninteresting. Is there something specific you'd like to know?
Mostly that, I didn't know if it was a group or just you. Mostly interested in how you profit share or do royalties.
Excellent, then.
Re "Learn Perl the Hard Way": Was there an Easy way? When I started it took me over a week just trying to get the Documentation into some kind of rational order so I could Start to learn. Now I'm having the same problem with Perl TK. The Active Perl distro has all this documentation for Tk, all of which blows up when you try to run it, because they shipped Tkx, not Tk. I'm so nostalgic for C! You bought K&amp;R and in a week you knew the language!
We've experimented with a couple of models, but we currently have a base royalty rate of 25% of profit (expenses are minimal) which rises to 50% as unit sales exceed a couple of milestones.
Niiiiccccee. Do you guys publish any numbers for units sold paper/electronic?
`perldoc perlintro` is a good getting-started guide, with links into other parts of the documentation which you can follow when you need to. chromatic's book *Modern Perl* is free on-line, excellent and aimed at beginners.
Buy O'Reilly's _Learning Perl_. It's the K&amp;R equivalent. There's even a new version out with the latest language features covered!
1. Try Strawberry Perl if you're on Windows. 2. O'Reilly has a (very old) Perl Tk book which I found useful. I bet it's pretty cheap if you get it used.
But to be fair, ANSI C doesn't include Tk either. And just because you thought you understood C didn't mean you ready to understand [Duff's device](http://en.wikipedia.org/wiki/Duffs_device). 
I wouldn't call Learning Perl a K&amp;R equivalent. Learning Perl barely scratches the surface of Perl, but K&amp;R includes the whole language. A K&amp;R equivalent would be Programming Perl.
Fair statements all. Although a good pointless argument over lager is occasionally good fun. I would like some advice though---I'm familiar with the old system of OO, and I am weakly up to speed with Moose, so is Mouse more likely to fit my poorly expressed need for something lighter? A second question---if I wrote a beginner's guide to Moose or Mouse, are there people who would critically review it, towards making it a useful document to put in the pile?
 use protection;
use Safe; FTFY
We can't track all of the numbers for electronic copies of the books for which we allow free redistribution, and I'd have to talk to authors about disclosing sales numbers for paper copies. As a rule of thumb, selling 5000 paper copies of a book is a substantial financial success.
...and if you're doing it alone, you're doing it wrong.
me thinks that amount of code can be cut by half ;) Szymon.
Writing Perl code is like writing English: just because you can omit punctuation doesn't mean you should.
Awesome, that is a great data point. I will have to check and see if O'Reilly makes any sales volume data available because I'd like to compare. Are there any topics that you are thinking/hearing that would be good for publishing - I guess this starts to go down into the future of books, tech books and electronic publishing, monopolies, if amazon is really a monopoly in e-books or not and if they are what does that mean, etc. I was talking to someone who was thinking of re-packaging "The Right to Read" essay in to various digital book forms and posting them on their site - I don't know if Stallman would approve or not, I assume not. I thought it was interesting that what was to some a laughable, impossible hippie fantasy when it was written, has come to be close to reality in a few years since he wrote it. http://www.gnu.org/philosophy/right-to-read.html
Except I don't get paid for having sex.
A so-called "traditional" publisher probably won't make sales figures available either, but they wouldn't publish a book unless it could sell at least 5000 copies, and even then it's probably a financial loss.
use strict; use warnings; damn. this analogy can make anything seem dirty. edit: [relevant](http://search.cpan.org/~mschwern/Sex-0.69/Sex.pm)
It's a thread about publishing books, right? If /r/perl needs an AMA, I'm game.
I tend to use Getopt::Long and IPC::Run for this. IPC::Run has great options to pipe commands together. here is a simple example: #!/usr/bin/env perl use strict; use warnings; use IPC::Run qw(run); use Getopt::Long; use Pod::Usage; my %config = (); my @specs = qw(help|h bar=s); pod2usage( -verbose =&gt; 1, -noperldoc =&gt; 1, exit =&gt; 0 ) unless GetOptions( \%config, @specs ); pod2usage( -verbose =&gt; 2, -noperldoc =&gt; 1, -exit =&gt; 0 ) if $config{help}; pod2usage( -verbose =&gt; 0, -noperldoc =&gt; 1, -exit =&gt; 1, -message =&gt; "Error:\n missing value for bar\n" ) unless defined $config{bar}; my ( $out, $err ); run [ 'echo', '-i', '-foo' =&gt; 'foo', '-bar' =&gt; $config{bar} ], \undef, $out, $err; exit 0; __END__ =head1 SYNOPSIS pass [OPTIONS...] =head1 DESCRIPTION Pass options =head1 OPTIONS =over =item [B&lt;--help,-help,-h&gt;] display help =item [B&lt;--bar,-bar,-b&gt;] "STRING" string to parse =back =head1 EXAMPLE $ ./pass.pl -bar "bar baz" -i -foo foo -bar bar baz =cut 
No, No, No---everything is a parser :)
This is why I love Perl and especially CPAN.
&gt; If Pod::PseudoPod built a tree of objects in a document object model and emitters visited those nodes and produced their transformations, producing the correct transformations would be easier. That's what [Pod::POM](http://search.cpan.org/~andrewf/Pod-POM-0.27/lib/Pod/POM.pm) does. POM == "Pod Object Model".
isn't Programming Perl's new edition due soon? not sure if anyone, even chromatic, can top that
By no means do I intend to write or edit a thousand page book with a 58 page index. I'm quite comfortable with a 250 page book that explains the most useful parts of the language.
Mojolicious.
Or in more general terms, there's more than two options here and you shouldn't be limiting yourself to them.
Catalyst for largish apps and Dancer and Mojolicious for small to medium. I don't know how you would really break those down. I have no idea also if Mojo scales to a larger application well. They all have great teams behind them though.
There already is one: [LPTHW](http://greenteapress.com/perl/) But it isn't the one you are thinking about. :)
Experience: a few medium apps with Cat. Looked at Dancer. Not even read POD for Mojo. I peter Cat simply because its so flexible. Dancer looks like it doesn't scale well. ymmv.
I've tried both. Dancer is easier to get started with.
Doesn't scale in what sense? Are you talking about "this app has too many routes for Dancer's style" or ...?
&gt;ANSI C doesn't include Tk either&lt; Right, which is why I had to write my own graphics system for C, which was relatively easy to do back in the pre-Windows days.
Yeah, I got the O'Reilly "Mastering Perl/Tk" book, but it takes a lot of undocumented translation to get from Tk to Tkx. Active Perl makes it even more confusing by retaining a lot of documentation for Tk, which is incompatible with the Tkx system they actually provide.
Perhaps a quick glance at StackOverflow might help? http://stackoverflow.com/questions/5080017/dancer-vs-catalyst-perl-web-frameworks
I would think that Mojo scales since SRI had a big hand in the Catalyst code bin for a while.
If it's really just a CRUD, Dancer is simpler and faster to get going. If there's more to the glorification, Catalyst is extremely flexible. You can do really complex things with it, particularly their concept of event chaining. I'd go with Dancer if you're unsure. I have never tried, but I also suspect porting from Dancer to Catalyst would be possible, with effort relating to how big the application got by then - if you do it smartly, your model classes should be interchangeable, and you can use the same view templates, so it's just the controller, and you should be putting as little code into the controllers as you can anyway.
There is a [Learning Perl the Hard Way](http://greenteapress.com/perl/) but I guess it's not part of the same series.
I'm gonna agree with this guy; Where I work we use Catalyst occasionally for large things - Do you really need a cannon to swat that fly?. That said it's a very powerful framework and I advise you to learn it; Dancer is good for small things, though I mostly use it for proof of concepts - also, I think dancer is *fun*
As long as you don't use Mojolicous::Lite I can image Mojolicious would be a good fit for large apps. :) I haven't tried though. EDIT: AFAIK, Mojolicious were built with that in mind as well, using the knowledge of Catalyst development.
Just a feeling I got. I haven't gotten around to writing a full app with Dancer yet (and I really need to), so I can't say for sure what it is.
let me put them here: * "PHP is like C" - Perl...you know, is also like C. * "PHP never let me down" - IDK, but Perl never let *me* down either, what about you? * "PHP is robust" - *"but the bottom line is that code that I wrote more than ten years ago has been working absolutely flawlessly and without any changes for all that time"*: back-compatibility. * "PHP’s documentation is great" - perldoc is great too. * "Universal support" - that goes without saying.... * "High reward" - The same here. downvotes are welcomed here.
I've always thought PHP is closer to Perl than C... PHP is robust.... ROFLCOPTER sorry, I gotta go puke now.
I'm convinced that this blogger is just a troll.
Those who can't see a parallel between PHP and Perl probably arrived at web development post 2000. A bit of context on web development should clarify things. Back in the day Perl was the web language. Yahoo!'s directory, arguably the WWW's largest site, was written in Perl. There was no ASP, PHP, cold fusion, whatever. UNIX servers either had server side includes(shell scripted!), executables or Perl scripts executed within a BIN directory, usually called ....you guessed it, cgi-bin/. So Perl was *the* CGI language. Along comes an interesting Apache module to let scripts run within the httpd process, not forking and returning HTML via STDOUT. That module needed a templating language to embed within HTML and allow the creation of dynamic HTML. In a smart move, that templating module copied the syntax for the most popular language used for that purpose at that time. That language was Perl. PHP is not based on C or Java, which is common to hear coming from the PHP camp these days. Back in the day, Java was an experimental technology. I got into Java pre 1.0 and believe me it was full of quirks and bugs and it never, ever, was used for CGI development until a long time later. PHP was an interesting Apache module which needed a templating language. That language was copied from Perl. PHP grew so much, rivaling or surpassing Perl, so their followers became "ashamed" of their "original sin". PHP was not even a language, it was a templating module within Apache, it didn't have objects, it was more of a patchy mess than javascript ever managed to be. So after PHP grew really big, somehow, somewhere, someone decided to not acknowledge Perl as the obvious mature and more powerful father of PHP. By the way. The blog post linked above adds nothing to the discussion and it doesn't even belong in the Perl subreddit, in my not so humble opinion.
Here's the metric I use: If I can **absolutely** without a doubt state that the project will not grow beyond it's original scope, I'll use Dancer or Mojo, depending on medium or small scope, respectively. Otherwise, Catalyst. So far, I've always used Catalyst.
I'd guess [Google::Search](https://metacpan.org/module/Google::Search), but your mileage may vary. A good question for such things would be to hit up [metacpan.org](metacpan.org) or [search.cpan.org](search.cpan.org) and try some sort of relevant search.
Great! I can't wait for "Choosing a Plack Server"
What do you use?
Dose there exist a project that *absolutely without a doubt* **never** grows beyond its original scope? so really: &gt; ~~Here's the metric~~ I &gt; ~~use if I can absolutely without a doubt state that the project will not grow beyond it's original scope, I'll use Dancer or Mojo, depending on medium or small scope, respectively. Otherwise, Catalyst. So far, I've~~ &gt; always use ~~d~~ Catalyst. ;) I agree. I've spent the day rockin out with catalyst and I love it so far. DB access is kinda confusing though.
Not really... Provided more questions than answers. haha. But seriously, thank you, this link did provide some good questions to consider. 
&gt;perl doc is great too I have to say that I find perl doc ok, not great. PHP has a really good documentation,better organised than the language itself! it supports multiple languages, which is very nice. each functions follow the same layout(general description of the function, description of each parameters, description of possible returned values and multiple examples followed by comments from the community) I think if perl should steal from PHP, it should be the doc. 
Ok, verdict is, don't. Here's the abridged version: $ mysqldump --compatible=ansi --skip-opt -p test &gt; dbase.sql $ bash mysql-to-sqlite.sh dbase.sql $ sqlite3 dbase.sql.db ".dump" &gt; new.sql $ sqlite3 users.db &lt; new.sql It's late for now, I'll explain all this later.
Catalyst on one intranet app I maintain, Mojolicious when I get a choice. I haven't tried Dancer but it looks pretty similar to Mojolicious (i.e. doesn't weigh several tens of megabytes).
Alright, thanks for pointing this out. Back in the day I was a PHPer, I do find the doc are (more-or-less) well-written and helpful, especially the examples from comments. When I have to write some PHP, I will directly head to the doc and find my answer. perldoc(official, and the CPAN modules) might not be so "great" to you, but I think I find it as much helpful as PHP's. If your skill improves, you can also read the source code ("the ultimate doc") to get what you want. (It's not that hard!) Let's say, the docs aren't so great, but I will argue that the Perl community will "cover" it. (I don't know much about the PHP community). My own experience: the community helped me solve any problem I've had, very politely, yet with some sense of humor. I am very grateful to Perl and the whole community, I will try my best to let people know that. 
&gt;I think I find it as much helpful as PHP's I really find perl doc less clear and easy to grasp than the PHP doc. I guess the audience is not the same so it might explain it. For example(a very simple function): http://perldoc.perl.org/functions/abs.html against http://php.net/manual/en/function.abs.php or http://perldoc.perl.org/functions/splice.html against http://www.php.net/manual/en/function.array-splice.php I like the fact that the PHP doc also puts the result of the example in a comment, it's not much but help... or http://perldoc.perl.org/functions/ucfirst.html http://perldoc.perl.org/functions/pop.html against http://www.php.net/manual/en/function.ucfirst.php I like the fact that the PHP doc always follow the same format, even if the function is very simple. it's really easy to scan through it,and once again, the doc being in different language, it really helps. my favorite perl doc: http://perldoc.perl.org/functions/import.html &gt; you can also read the source code ("the ultimate doc") to get what you want no. Having to dive into the source code is a sign of very bad documentation and should be avoided (you start by reading the source code and then play around with the internals in your code and then you're screwed with an update that changed some internals you've used. obviously, one should not do this, but one should write proper documentation too). Most of the time, I have more line of docs than code in my modules. I don't say that perl doc is bad, you got me right? it's ok not much when compared to the PHP doc (obviously PHP has to cover with some docs the fact that their functions are a real mess) 
this seems to be deprecated too. the most recent once might be: [WWW::Google::CustomSearch](https://metacpan.org/module/WWW::Google::CustomSearch) but the doc is very lightweight. 
I recently tried Perl after 7 year-long break (I had used it just twice before, first time it was 5.004 afair). I'ts cute and lovable ! I decided I like it (now) and should learn Perl this year. Although Perl is cute, hype is not. This "article" has many superfluous statements. &gt; and even enter the realms of functional programming as MJ Dominus book Higher Order Perl demonstrates. I don't know of many scripting languages that can do that.... some scripting languages can do (most or all stuff from Higher Order Perl): HOP (there is Scheme-based scripting language named HOP), emacs lisp, gnu smalltalk, gnu guile, python, ruby, io, js, tcl 8.5, lua, F-Script, R, J (now free as beer) and probably many others I've never tried or never heard of. &gt; it not only refuses to show signs of aging well it was outdated 20-smthing years from the start ;&gt; &gt; but still drives innovation after 20+ years I'd love to see eGzamples (no offence). 
please people, this was already uncovered as a well-crafted satire. you can stop trying to correct him.
And I don't get paid enough for writing Perl.
Indeed. Why rewrite the wheel when a module exists to do it - and do it more powerfully (if required in the future), not to mention more clearly for someone coming to pick up your code. Who cares about loading a module? Computers are pretty fast these days ;)
Do they also make you chop down the trees and build all your office desks yourself too? Did you literally have to reinvent the wheel for your office chair wheels?
Isn't most of this in Moose::Autobox?
In Vista: C:\&gt;cpanm http://github.com/vti/underscore-perl/tarball/master --&gt; Working on http://github.com/vti/underscore-perl/tarball/master Fetching http://github.com/vti/underscore-perl/tarball/master ... OK C:\Program Files\GnuWin32\bin\tar.exe: Unknown file type 'g' for pax_global_header, extracted as normal file ! Bad archive: master ! Failed to unpack master: no directory ! Failed to fetch distribution Needs a bit of distribution testing...
So basically you want your documentation to teach you programming and math instead of documenting the language?
Please fix the contrast of the website, it's pretty hard to read. I'm also kinda horrified by all the camelcase. That said: This actually looks pretty cute and useful! It doesn't mess with UNIVERSAL and really doesn't contain *any* magic, has a small footprint for a lot of functionality and the features are all implemented based on underscore-named methods instead of CamelCase. I'll probably use it once it hits CPAN. I am wondering a bit whether it is such a good idea to new() on *every* call to it, but i'm not entirely sure are many better solutions to it. Maybe a dispatch table that can short-circuit. Also, i'd like to see an example in the dist of how one could make a My::Underscore class by, for example, sub-classing and changing the template system with Role::Basic. (I think it would also be neat if the template functions were factored out into their own module in the first place.)
I too am a fan of the complete lack of magic. +1.
anyone have experience trying to insert a caching layer into this easily? i.e. memcache etc?
Different target audiences.
I have used all 3 frameworks. I personally enjoy Mojolicious the most. Not bashing Catalyst, its an awesome framework. But the learning curve and examples for Mojo make getting up and going a pleasure and fast. Not sure why someone would say it isnt for large apps. Thats just very wrong statement from what I have seen. 
I'd like to be an early adopter of Perl 6, but the language just isn't complete enough for doing very much with yet (though this is partly due to a lack of modules for it). A viable CMS written in Perl 6 today would need to be full of hacks due to a missing Image::Magick-like module and other similarly useful things.
That's the thing for me, too. I played with Rakudo about a year ago, and it seemed reasonably complete. For the most part, you had to dig a fair way through the language specification before you hit something that didn't work right. But the lack of CPAN modules holds me back. Much more so than any performance penalties. Many of my projects are highly IO-bound, so a suboptimal runtime makes little difference.
A good web framework would certainly be another compelling reason to try out Perl 6 for your next project. It would probably attract a lot of potential users. However, I think that, *at this stage*, most people trying it out would -- given the circumstances as of today -- soon leave Perl 6. The reason is that there are no perldocs for it, nor is there a Perl 6 "Camel book". Off the top of my head, there are: * the Synopses (dense and deep -- not suitable for those wishing to learn Perl 6), * a number of blog posts (see perlgeek's 5-to-6 articles, also szabgab's and others' posts), * two holiday seasons' worth of advent calendar entries, * tons of rosetta code examples, * and even the beginnings of [a book](https://github.com/perl6/book) covering some basics, but there are no real quality docs *anything* like what Perl 5 has got. And learning Perl 6 by asking endless questions on IRC is not optimal. If Randal wants to help bring in new users, he'd have a *far* greater impact writing the next "Camel book" (Butterfly book?) than he would writing a web framework. (Besides, it sounds like a Mojolicious port will make it over at some point anyway.) Randal wrote the original Learning Perl Oreilly book and the original Camel book. He's written a huge number of highly-regarded magazine articles. Countless detailed and informative replies on Perlmonks. He's easily one of the top 4 or 5 best writers in the Perl community, IMO. 
want randal wants, and what would be awesome, is mojolicious on perl6 but first i think there needs to be something like cpan. the current perl6 packages and tools seem broken and flaky
agreed, although my understanding is that chromatic and others are indeed writing a perl6 book to get all of this in one place...https://github.com/perl6/book 
Based on the comments I've read here, the thing I'm hearing is "I won't program in perl6 until other people start programming in perl6". There isn't a mojolicious written in perl6 because everyone keeps saying they want it already written and no one seems to want to to be the one to write it. Seems to be a catch-22. I do agree with effusion though, it needs a Camel-esque book to get people started.
The complaints I've regularly heard up until now have been: 1. "Perl 6 is too scary|complex|difficult!" This is something that could be fixed by having real docs in place. 2. "There's no 6.0 production release!" or "The Spec|Implementation isn't complete yet!" FWICT, the spec is pretty solidified these days and the main implementation (Rakudo) has [quite a lot of language features implemented](http://perl6.org/compilers/features). And that feature table gets more green every time I look at it. 3. "Perl 6 (well, the primary implementation, Rakudo) is way too slow!" This is actually getting much better recently, from what I understand. 4. "There's no CPAN for Perl 6!" I find this complaint to be a non-issue right now, since most Perlers just put their work up on github and the existant tools (`panda`) pull and install right from github. I'm sure as more modules are written the tools will get even more polish. 5. "There's not enough modules available!" The chicken-and-egg problem you mention. I think the only way out of this one is to get more new users learning Perl 6 and writing modules. They've already gotten *interested* thanks to the blog posts and advent calendars. Now they need to learn more so they can start writing modules -- and the only way they can do that is if great docs are in place. 
&gt; it needs a Camel-esque book to get people started. Quick, Chief O'Hara get to the roof and light up the Chromatic signal...
disagree on 4. dealing with a collection of github links is a nonstarter we need a real cpan for perl6
No he is busy enough!!!
It's not really a collection of github links. You have a module installer, and `panda install LWP::Simple` does its job.
It still lacks a decent search interface on the web.
you're basing your analysis on mere examples... it is certainly not a good way to analyze/abstract (examples were here to support a bigger picture/idea,being that all functions should follow the exact same layout, with examples,even for the simplest one) what i am saying. but whatever...
i've been playing around with perl6 by gleaning info from the links below but it is still hard to reach a point where you can feel confident about writing a module (modules i've written so far in perl5 all uses other modules that for some of them do not exist yet in perl6). but to get more people into it, a doc is definitely necessary, doc.perl6.org, then the community will follow and create the modules from which will certainly raise some web frameworks. as for tightening up the web framework with jQuery, it's not necessary even though the necessity to tighten up server side and client side does exist. it does not have to be jQuery. a declarative style a la JSON that could work for both JS and Perl would be enough. 
At the moment, it doesn't matter whether there's a decent search interface or not. The available modules are listed at http://modules.perl6.org . You can search it with Ctrl-F. Until great docs are in place, it's not going to matter. To get enough modules (such that you *need* a CPAN) you need new users learning Perl 6 and *writing* those modules. 
I noted that book in my the last bullet point of my post. (Btw, chromatic is not listed among the authors of that book.) 
http://www.downforeveryoneorjustme.com/perl.com &gt; It's not just you! http://perl.com looks down from here. 
back as of 2:20 pdt 
Not downvoted, but however many similarities there are, there is one huge difference: the feel of the language. I personally really dislike PHP, and love Perl. To me, PHP is the VB of web programming -- and I say that as someone who got his start with VB, and doesn't dislike it. I guess I dislike PHP because by the time I heard about it, I'd been exposed to Perl, which opened my eyes. Anyway, my dislike is not an objective comment on PHP -- obviously it can get the job done. But I think a huge difference between the two languages is going to be the "user experience" of the programmer. I don't think the experiences are going to be anything alike. Regardless of where one's user experience preferences fall, that IMV always means that there is going to be a huge bump for anyone going from one to the other. Being "like C" is pretty but it'll have hardly anything to do with whether a PHPer enjoys writing Perl. PS Good God, I'm not sure how seriously I can take someone who asserts that anything one can say about C or PHP can be said about the other. I only know a little of either and that just sounds demented.
Upvoted. Fascinating to learn that PHP is originally a copy of Perl. Clearly, though, not being as powerful (having less to learn) was advantageous, in the same vein perhaps as C being advantageous over Lisp for being "good enough".
I guess so if you define Ruby,Python etc as 'scripting' languages. But are they? The author refers to scripting languages as to 'cut-down' languages and not full general purpose ones and in particular refers to the Unix shell scripts. This definition is also consistent with Wikipedia [Wikipedia Scripting language : Text processing languages](http://en.wikipedia.org/wiki/Scripting_programming_language) which uses the term scripting for the shell tools : &gt;"Perl was originally designed to overcome limitations of these tools and has grown to be one of the most widespread general purpose languages." and &gt;Some languages, such as Perl, began as scripting languages but were developed into programming languages suitable for broader purposes. 
hm, comparing original/modern awks with Perl is like comparing cherries with melons. Original awk weights (uncompressed deb) &lt;200k (modern ones &lt;500k, gawk 1700k), Perl 30000-40000k or more. My melon is larger than your cherry! HA. Ok, I agree that Perl 5.14 is vastly better than combination of bash, awk and sed. It's bold fact. And no one is interested in comparison between Perl and Ruby because Ruby is not an scripting language in some sense ;) Btw, try that (debian-like distros) for l in perl ruby1.9.1 lua50 gauche scsh ; do grep-available -nXP $l -sDescription | grep -C1 script ; echo ; done ;&gt; 
I don't think that he compares Perl to the Unix tools.He says that Perl is not a scripting language but is called that way because of its relation (as a replacement) to the Unix shell/scripting tools 
Just for clarification, chromatic is our publisher (and probably editor), not an author. And yes, the lack of user-level documentation is a big problem, and it's sort of a bootstrapping issue. It takes effort by many people, but first you need to have many people interested who are committed to write such docs.
See http://log.perl.org/2011/08/brief-downtime-this-afternoon.html
I've been using "$sth-&gt;fetchrow_array()" since always now, I see no slowing down of my code. OTOH, I might consider switching to "bind_columns()" approach anyway, just to try something new.
I doubt there's any performance increase, but he's right about the copy - what's the first thing you usually do with the arrayref? Copy elements into scalars to use.
Not me. I use fetchrow_array() just to avoid that. Maybe there's performance increase fetching large resultsets. Most of results I fetch are limited to 50 rows at most. 
Ok, i'm retreating, perl logic is powerful indeed ;) btw, last little question: is Gauche scripting language or not ? "Scheme implementation developed to be a handy script interpreter, which allows programmers and system administrators to write small to large scripts for their daily chores." http://practical-scheme.net/gauche/
&gt; I see no slowing down of my code. Compared to what?
Compared to what I've read in Tim Bunce's DBI presentation? :) Actually, I have never benchmarked DBI methods themselves, so I cannot really tell (but I believe what Tim Bunce has to say about it). I did some benchmarking of our codebase at work and DBI itself never was an issue. (The main issue was *always* MySQL itself slurping all the RAM.) 
That could be why you see no "slow downs" certainly.
I assume you mean this one: [DBI Talk](http://cpansearch.perl.org/src/TIMB/DBI_AdvancedTalk_2004/index.htm)
I believe that's the one.
The only slowdowns lately in all database code we have comes from MySQL and it's bugs or quirks. I can't remember the last time I optimized some Perl code, but SQL is another story. 
Or, use [DBIx::Class](https://metacpan.org/module/DBIx::Class) and not deal with any of that crap.
Can someone explain the \my part? I've never seen that before.
It is explained in the article. It is just a way of passing references.
Reminds me of this classic article: [DBI is OK](http://www.perl.com/pub/2001/03/dbiokay.html)
This is a neat trick to know if you're processing large volumes of database data, and every microsecond matters. In general usage, I almost always just want a hashref back if I'm not using an ORM already.
Ah, thanks. "just a way of passing references" is what I needed. The article's explanation-by-example didn't cut it. 
+1 hashref ftw!
Try again with zipball
I was thinking about making _ a global object, but wasn't sure about that. Since you can add methods on the fly, this could create problems for other scopes. Maybe it can be improved. I am not a pro in optimisation. Subclassing example is a good one. I will try to work something out. As always: patches and ideas are very welcome.
ORM ftw!
Main thing to remember is not be lazy and do a "SELECT * FROM table"; if the schema changes the columns each variable refers to will be different. Always name the columns you are interested in, in your select statement.
&gt; and it's sort of a bootstrapping issue. It takes effort by many people, but first you need to have many people interested who are committed to write such docs. I don't think that's quite correct. While it's true that writing *all* of the Perl 6 man pages (that Perl 5 has) would indeed take a lot of contributors, writing the core man pages (i.e. "getting bootstrapped") could (and probably should) be done by one champion with strong writing skills. If I were on the Perl 6 team, I'd email Randal to at least run it by him. Having some core perl6doc pages (or, a much greater endeavor: a Perl 6 "Camel book") written by one of the Perl community's best writers would have a *huge* impact on bringing in (and keeping) new users. 
congrats and thanks for the work
I recently assumed responsibility of a reporting department, er - what was once a reporting department (massive lay-offs). I spent a great deal of time going through all the old reports that were manually generated with a nasty mixture of excel, access and java. It was all been replaced by a nasty mixture of mysql, bash, perl and latex - but now it is fully automated. I could die in my office and nobody would notice until the place started stinking... a little depressing but true. Automation is great.
Never heard of it, but it's a big internet so what does that mean. Thanks for the pointer :)
Q&amp;A questions are better on a site like stackoverflow that's designed for Q&amp;A.
[someone's already approached the topic on StackOverflow](http://stackoverflow.com/questions/6209160/ternary-operator-in-perl-yields-unexpected-result-when-assigning-a-variable-in-th) **TL;DR**: The assignment(s) in the ternary break it.
&gt; but that can't be true since $f is undef No, you had it right until then. 1 ? $f = "true" : $g = "false" parses as (1 ? ($f = "true") : $g) = "false" which gets optimized to ($f = "true") = "false" (because 1 is always true), which ends up assigning "false" to $f. For future reference, [B::Deparse](http://search.cpan.org/perldoc/B::Deparse) is your friend. $ perl -MO=Deparse -e '1 ? $f = "true" : $g = "false"' ($f = 'true') = 'false'; -e syntax OK
The problem is that ternary binds weaker than the equals sign, which is why it parses that way.
Thanks for sharing! I set up several online ecommerce sites a few years ago for an employer (zen cart). I'd LOVE to get into this -- which dropshipper do you use? Does it specialize in a niche of some kind? How did you get started? What are your monthly expenses? Revenue?
interesting. I have a strong background in magento, and a background in perl. What's your reason for using perl instead of php? It sounds like you're using the webservice api. PHP's soap client is about as simple as it gets. What are you selling?
Well, let's consult the operator precedence chart from [`perldoc perlop`](http://perldoc.perl.org/perlop.html): left terms and list operators (leftward) left -&gt; nonassoc ++ -- right ** right ! ~ \ and unary + and - left =~ !~ left * / % x left + - . left &lt;&lt; &gt;&gt; nonassoc named unary operators nonassoc &lt; &gt; &lt;= &gt;= lt gt le ge nonassoc == != &lt;=&gt; eq ne cmp ~~ left &amp; left | ^ left &amp;&amp; left || // nonassoc .. ... right ?: right = += -= *= etc. left , =&gt; nonassoc list operators (rightward) right not left and left or xor In this case, we only need to be concerned with these lines left terms and list operators (leftward) . . . right ?: right = += -= *= etc. From this we can see that the conditional operator has higher precedence than the assignment operator. The easiest way to fix this is to make the assignment operator have higher precedence. How can we do this? The trick is that top line: terms. What is a term? Well, `perlop` defines them this way (I added the emphasis): &gt; A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, **any expression in parentheses**, and any function whose arguments are parenthesized So, to get the behavior you want, just say 1 ? ($f = "true") : ($g = "false"); That said, this is a terrible use of the conditional operator. The conditional operator should only be used in expressions where it allows you to factor out a piece of code. Look at this example: if ($test) { $value = 5; } else { $value = 10; } The code above repeats `$value`. This is a violation of the [DRY principle](http://en.wikipedia.org/wiki/Don't_repeat_yourself) and a perfect candidate for the conditional operator: $value = $test ? 5 : 10; Another great example is what you stumbled into: $test ? $f : $g = "f gets this if true, and g does if false"; Although this is a case where parentheses are nice, even if they are unnecessary: ($test ? $f : $g) = "f gets this if true, and g does if false"; Its utility is a little more obvious in this example: my @odd; my $even; for my $num (0 .. 9) { push @{$num % 2 ? \@odd : \@even}, $num; } 
Are you able to sell something you can't find at Amazon? Are you willing to lend us the name of your dropshipper? 
Yes, it's a very specialised dropshipper, my website is [PlaytimePleasure.com](http://www.playtimepleasure.com) (NSFW). There are a number of broader dropshippers, but finding one with a robust API may be a problem...
I started my dev career with php, but for the last 5 years or so I've been developing in perl (extending Request Tracker specifically), so perl is very easy for me currently. Plus, command line php just never made sense to me.
I'm selling sex toys, the dropshipper is [MuffsandCuffs.com](http://muffsandcuffs.com/), and my store is [PlaytimePleasure.com)(http://www.playtimepleasure.com/)
Non perl quesiton... How did you go about finding drop shippers that where not a scam? I wanted to start a similar thing, but not in the sex toy industry, but I am unsure of anything that is out there. Any pro tips for finding reliable drop shippers?
Does anyone have this stably running with 64-bit Perl on OS X Snow Leopard? It looks interesting, but like a ton of work to get running for my system. 
Unfortunately I just got lucky. All you can really do is find a dropshipper that looks good and do as much research on them as possible, look for reviews, etc. From what I've seen, a good API is not all that common amongst dropshippers unfortunately. Good Luck!
Bricolage maybe?
Now that's an interesting use, of, er, Perl...
fair enough, although I don't see your point about cmdline php. to do a cmdline script in Magento: require_once($path . 'app/Mage.php'); Mage::app(); //use Magento api $product = Mage::getModel('catalog/product')-&gt;load(123); $ php myscript.php 
Plain Black? http://www.plainblack.com/
It's so easy to just write one.
Point taken :)
That WebGUI thing? It looks atrocious...
http://openmelody.org/ - the MT fork, perhaps? Can't say I've used it but the website is shiny. Personally, I've used and enjoyed both Wordpress (I know it's PHP + MySQL but it works really well...) and Jekyll, the Ruby based static site generator. An additional benefit of Jekyll is that you can host for free with github pages.
That's what I've been doing (a custom script that is quite similar to ttree) but I found that organizing linked "blog" pages is a PITA this way.
I will not necessarily disagree...
Harass dhoss to make his project fit for public consumption. Last I heard, it runs [dhoss.net](dhoss.net).
It's not atrocious but it's a heavyweight "everything's included" approach which also aims to be enterprise-class. But the development is active. I went my own way and built something lighter-weight, loosely coupled, easily extensible (also in Perl). A different approach. It's so easy to bang out a micro-CMS and then evolve it as you see fit. 
Can you be more specific? Do you mean having a home page with snippets of the first 10 articles (each one linked to its full version) and then paginating to the next 10?
Right stuff linking to articles that aren't on the article itself. Pagination can be handled quite easily, its the next article, previous article, archive listings, keyword listings, etc that are hard 
Ah, okay. Well, each of those things is just a little SQL + a template to render. But I get your point if you're saying that it's time-consuming to craft all that (it certainly is, and I certainly understand why people would want something ready to rock). I should clean up mine and release the code...
Oh look, some asshats who moderate on Wikipedia are looking for yet another article to delete. Seriously, why is anything even allowed to be deleted from that??
What is this I don't even...
Hasn't this happened before?
Fortunately, the deletion request got rejected...
O' Wackypedia, the insularity and zealotry of your puerile editors provides a never-ending supply of hilarious drama for me to laugh at from afar. Keep up the good work!
Awesome, again, thanks for sharing the info. I'm curious what your reason for choosing this niche is -- is it more lucrative? Undercapitalized? Just because you were interested? Congrats on the success. Drop shipping seems to be, on the surface, pretty low maintenance, but the barrier to entry is much higher than expected. Do you know of any other folks with any success with it? Any tips you'd share with a noob? Who to avoid, what mistakes to avoid, any gotchas or general advice? :-)
Put up a site where nothing is deleted. See how long it lasts. Who gives a crap whether his article is removed or not? It is hardly the canonical resource for information about him. We shouldn't be so petty.
Right, take the argument to the opposite extreme. And it's not just that article, there are plenty that have been deleted solely based on the subject's "non-notability". Along the same lines that I shouldn't care if its deleted, the guy who wants to delete it shouldn't care if it stays. 
Looks nice. Isn't it somewhat redundant with [perl buzz](http://www.perlbuzz.com/)?
I guess he needs a sex tape or a reality show to be relevant to wikipedia. I know nothing about wikipedia's structure but shouldn't you have some level of knowledge on a subject to moderate it?
I had been thinking about doing a dropshipping store for a while, but was having trouble coming up with a niche - at first I was thinking cellphones, but the profit margins on those is razor thin because of all the competition. With sex toys, the markup is enough to make it an interesting prospect, plus I figured most people would buy online because nobody likes walking into their local sex shop :) I priced my products to stay competitive with adameve.com which was the most popular store I knew of when starting. I don't know anybody else dropshipping, so can't speak to success, as for tips, the biggest mistake I made starting out was to spend WAY too much money on google adwords. I launched in November of last year, and went on the advise of the google adwords rep who helped me start out - with a $100/day ad campaign. It got me traffic, but conversions were pretty low. I think what hurt me the most was, I was a brand new store, competing for attention during the christmas rush :( So now I have an outstanding business credit card balance I am still paying down from a month ad campaigns. I'm making sales, but it's nothing to write home about. Looking forward to the point I can say I'm profitable :)
Nope. In fact, they specifically discourage people from editing pages that they know anything about.
Repetition is the key to learning
You're right, it's pretty much the same roundup with just a small amount of additional commentary. I find it more convenient than perl buzz. You might not; horses for courses (TMTOWTDI). 
It's a red herring, really. The means of fetching the data from the API is rarely the limiting factor. You're better off optimizing the statement, or making sure everything is properly indexed, or running the database off an SSD, etc. Fussing over the API is premature optimization in most cases.
agreed, the first four issues have been excellent
Looks like the "saturn" obfu: http://www.perlmonks.org/?node=saturn
While not the one I saw, that is rather pretty! Thanks.
I just found [this](http://mamememo.blogspot.com/2010/09/qlobe.html) in my search, which, while not the old 2D spiral galaxy, and not in perl (it's in ruby), is perhaps even more impressive. The one I've asked about I saw back around 2000-2001, so it's possible it was only up briefly, and in before search engines had really explored much of the web. It may be lost to the sands of time.
For one, it's a different format from Perlbuzz. If you want all your news in email, that's one good thing. If you don't want day-by-day tweets, which is where most Perlbuzz links go, that's another. On the other hand, having a set schedule where it's published on Mondays is a good thing, and one I'm trying to adopt for Perlbuzz. Finally, redundancy is not necessarily a bad thing.
Recently, there has been progress with Padre on OS X, but it may not be 100% stable yet. I would encourage you to give it a try, maybe ask on IRC for the latest infos before trying. The more people actually run it, the more stable+comfortable it gets ... and Padre is already a really awesome tool. I use it as my standard editor (on Linux, though).
 perl -MSocket -e 'print "Defined\n" if defined inet_aton $ARGV[0]' not.exists perl -MSocket -e 'print "Defined\n" if defined inet_aton $ARGV[0]' google.com Both oneliners work as expected on Ubuntu, perl-5.14.1, Socket 1.94 perl-5.10.1, Socket 1.82 Maybe, problem is at 'return ""' instead of 'return undef' ?
 #!/usr/bin/perl $_=' $q ="\ 47"; wh ile ($ ;= $z += .5 ){ %c= $r=0;$/ ="";whi le(2 0+ $z&gt;($;+=.05)){$c{int$ _+ 2 6+ 2*($ r+= .0 2) * s in$ ;}{1 -$_ +1 0+ int $r*c o s $ ;} =1for(0. .1) }$ t =r ever se;$ /. =` c le ar `. " #! / usr /bi n/ pe rl \n\ $_ =$q \n" ; fo r$y (1..20){$c{$_} { $ y }? $ /.=chop$t : ($/ . =" \4 0") for(0. .53) ; $/. ="\n"}pri nt"$/$ q; s; ". chr(9 2)."s;;g;eval\n "} ';s;\s;;g;eval 
I agree 100%. I learned that the hard way. Even when your write crappy code, I rarely needs optimizing (in my case, at least).
return undef; would make sense I guess..
the code is very un-modern. thought i was looking at PHP for a sec, or even transported back in time 10 years. also, why did the author choose to host the source on a microsoft site, which is barely functional for non-IE browsers? especially since he also has accounts on github and launchpad.
&gt; the code is very un-modern. thought i was looking at PHP for a sec, or even transported back in time 10 years. Ditto here, this is why perl gets a bad rap.
Yes, I know the code is not-so modern, but that's by design - i didn't used any frameworks because i wanted easy deployment - this script uses only core modules.
By Jove, I think that's exactly it! Are you the original author? I haven't seen this thing in 10 years. It runs *way too fast* on my modern hardware :) Thanks!
If you don't have something out there equally as good, or better, I don't see how you can possibly criticize. This guy wrote a pretty cool piece of software, offered it free, and you're crapping on it. Simple software is very stable, easy to install, and it can be used by people who want to learn Perl.
and then they'll learn really bad habits and perpetuate the shitty perl that gives the language the reputation it has... how is this a good thing?
Ran it through perlcritic: kitsune.pl source OK Downloaded it with FF6...and had no problems doing it. Your "un-modern" is not a valid critique here I think. Not in the way I take "modern Perl" to mean.
I think it's worked just fine here.
http://www.movabletype.org/
I think it works better on something like stackoverflow and here's why: * More eyeballs. /r/perl is pretty small * Programmers don't search reddit when looking for answers to questions, most come to post and read about cool things happening in Perl (or programming, etc). * Reddit threads don't rank very high on google so any answers you give are less likely to be found by others in the future. * There is no way to mark an answer as accepted. You have to read all the comments to see which answer the OP preferred. * You can't tell whether the person answering the question knows his stuff or is just making things up. Sure they have karma points, but just because someone got a lot of karma for some cute cat pics in /r/pics doesn't mean that reputation has any significance for /r/perl. I really like reddit and /r/perl, I just don't think it's a good fit for Q&amp;A style questions, especially those that are technical in nature.
Just because you didn't use a framework, doesn't make it "un-modern".
&gt; I think it works better on something like stackoverflow and here's why: I didn't say it doesn't work better on SO. Just that it's worked fine here. &gt; You have to read all the comments to see which answer the OP preferred. I don't see why one would be interested in what answer the OP preferred.
&gt; Ran it through perlcritic... Does perlcritic lack rules for "There are much easier ways to iterate over an array" and "That comment adds very little"?
`return;` is better; then it works in both list and scalar contexts.
the problem isnt lack of frameworks, the problem is deprecated modules and bad idioms.
what do you think modern perl means?
no, I found it on perlmonks http://www.perlmonks.org/index.pl?node_id=176043
&gt; I didn't say it doesn't work better on SO. Just that it's worked fine here. And I didn't say it doesn't work on Reddit. Just that it works better on SO :) &gt; I don't see why one would be interested in what answer the OP preferred. Most threads have a "I followed this advice and it worked for me" answer from the OP to a poster. Sometimes those are also accompanied by advice from the community not to actually do that because it has other problems. I think both data points (which worked and which is actually recommended) are useful to determine the solution. Lots of times they are the same but sometimes they are different. It's pretty obvious on SO which is which. 
I see. Thanks for tracking it down for me. My searches with the terms rotating, spinning, galaxy, and quine were going nowhere. I guess it never was a galaxy, and it looks like it wasn't 2000-2001 when I saw this, but some time in mid/late 2002.
MT is a huge, untractable piece of software. It's so complex that I decided to use blosxom instead...
No, it's not. This particular function is supposed to return a scalar value. Always. Also, consider these pieces of code: my $info = {host =&gt; $host, ip =&gt; myip($host)}; my @ips = map {myip($_)} @hosts;
&gt; This particular function is supposed to return a scalar value. Always. If it's documented as such, fine. &gt; Also, consider these pieces of code: I could argue the second both ways, but I prefer the "returns an empty list in list context" approach for the uses I imagine.
Really? Bad code is 'by design' ಠ_ಠ Not using frameworks because it makes deployment slightly easier, at the (huge) time cost of reinventing the wheel ಠ_ಠ not to mention, many CPAN modules/frameworks are actively maintained, bugfixed and battle-tested with a huge userbase. Why anyone would roll their own buggy, less maintained and less functional code rather than re-use publicly available components is beyond me. If deployment is your argument, consider local::lib, bundling the modules locally, or switching to a host/environment that isn't stuck in the early 90s. 
What's your invocation? perlcritic only looks at the top 'severity' level by default, which is very generous.
It's not as if this code reinvented CGI or date handling or file paths. At 200 lines (probably 140 lines of idiomatic code), it might or might not be worth using something like Dancer or Mojolicious.
perldoc perlintro
How about my [Modern Perl](http://onyxneon.com/books/modern_perl/index.html)?
Might just want to google some perl samples. If you've been doing C for years, then you should have no problems picking up perl. Look for: * regular expressions * associative arrays I typed "perl sample" into google and found a bunch of very simple perl scripts that show off different perl bits.
Are any of those sample scripts elegant, or do they look like bash programs ported halfway to Perl 4?
You might like one if the perl cookbooks. They tend to provide examples and and info about the language alongside actual real-world solutions to common tasks. Another choice might be [learning perl objects, references, and modules](http://oreilly.com/catalog/9780596004781). it has some quick intro stuff at the beginning but then jumps into te more oo things you will want to work with anyway. Good luck!
Definitely the place to start if you're already a clueful programmer, even a clueful Perl programmer.
I like the sound of this one. I'll give it a look. Thanks.
You want this: http://qntm.org/files/perl/perl.html
Good gravy! Just skimming through the Perl Language chapter in that PDF has my head spinning. Talk about a frantic pace! I love it! I don't need to see long drawn out descriptions of how a loop works, I just need to see the possible syntax options that I can use and see them quickly. I'll definitely be digging in to this one more.
Fortunately, there is a book written exactly for this purpose: http://blob.perl.org/books/impatient-perl/iperl.pdf I was not a former programmer when I picked up Perl and still got great use out of that book because I too have a short attention span and would rather make mistakes than memorize all the miscellany beforehand.
Ack! I missed something. I technically should have said C++. I've never done proper C. I don't know how I missed that. Although, I'm not positive exactly what's different between the two since I've never had call for C. Anyway, I've been working with these Perl scripts that we have now for a couple years, and I've got a decent feel for it, but you have to realize, that the scripts we have, like I said, are very straight forward. Before the previous programmer left, and I was learning how to at least cope within the system (trust me, it's a mangy beast! - more on that in a moment) I was just trying to understand some of the things I saw in the Perl and when I'd ask him, he'd say "I have no idea, it's just something I found on the internet" So he was just making it work. He didn't even know how to code Perl. Yeah, fun. Now, as for it being a mangy beast? Just to give you an example of what kind of garbage I'm writing.... I first copy over a script that reads in a flat text file, and takes each record from the flat file and converts it to two files. An HTML file and a control file (another text file). Once those two files are created (I get their names from an imcrementing number in yet another text file) they get sucked in to a database system. The HTML file contains a button that allows the user to send an email. the button opens another browser window that has another hard coded html file with a form. The form then submits to another perl script that collects the information and creates another set of html and control files, plus an extra html file. The first html and control are also sucked back in to the database, while the extra html is put in to a folder where yet another script (this one is standard, I don't have to write it every time) will grab it and forward it to a mailer. And how do all these scripts get called you ask? oh, that's easy. there's a handful of scripts that call them. And one master script that calls all of them. None of them are complex, just repetitive. And how does that one, master script get called? Oh, that's simple, it's run by a little app written 8 years ago in an old version of VB and compiled. The source is gone, the programmer is gone, even if we still had the source, nobody has the old version of VB installed anywhere, so it'd probably be easier to just rewrite it anyway. So my job may not be much easier if I learn to code better Perl, but at least it will be more interesting, and therefore, take my mind off of just how god awful the system is. :)
In many ways Perl and C are closer than C and C++. You might want to check out Modern Perl (linked elsewhere in this thread). Still, I think for someone with a lot of expereince and not a lot of time, you can learn a lot just by playing around with some simple perl scripts and then reading up on the topin in a good book to see what you missed.
&gt; deprecated modules That are shipped with perl &gt; and bad idioms. do not get any warnings by Perl... ok, it might have some old fashion things here and there but if you see it as an exercise, i don't see why people are so nitpicky... it's not the content of the comments but rather the way of saying it... I guess that these people,criticizing all the time, give perl community a bad name (snobbish image)... if he used what is said to be bad idioms, it is perhaps because there is not much blog entries about modern perl yet (googling perl still brings you the 90s tutorials). so... We could go as far as saying that it is the community's fault. Write an entry blog and explain what was wrong and how to fix it (as mr_chromatic has done in the past). THIS will be good for the community... 
My understanding is that Parrot's original reason for existence was to provide a platform for an implementation of Perl 6. So I would guess that the Parrot team is populated with some of the most dedicated die hard Perl 6 supporters around. Is this the case? At this stage I'd expect the Parrot developers to be working single-mindedly on allowing and helping a "Rakudo 1.0" to happen ASAP, even if it might not be the best thing for other Parrot-hosted language implementations. 
i absolutely do not care about anything parrot might do other than execute perl6. honestly, is there one person on the planet that gives a poop about parrot's potential ruby support? 
programming perl
&gt; honestly, is there one person on the planet that gives a poop about parrot's potential ruby support? I think, originally, the plan was to have all these other languages implemented so that Parrot would allow them to interoperate. &gt; i absolutely do not care about anything parrot might do other than execute perl6. I'd like to see the results of a poll asking: "On a scale from 1 to 10, how upset would you be if Parrot broke other language implementations in efforts to more fully cater to the Rakudo Perl 6 implementation?" 
AKA "The Camel Book" Did a pretty good job introducing syntax, program flow, data structures, and regexps -- I'd probably recommend it on those points alone. Writing was to the point but enjoyable. Not sure if it covers objects and modules? Perhaps in the later chapters? Been a while since I poked at it.
*I think, originally, the plan was to have all these other languages implemented so that Parrot would allow them to interoperate.* i've been following parrot since day one, i'm aware of this goal, but its a stupid goal. back in 2002 when CPAN was the only library repository of merit, it may have seemed alluring to extend the good mojo to other langs, but at this point, ruby, python etc all have excellent package selection, they don't need or want to deal with a watered-down translation layer
How does it compare to Blosxom? That's my standard yardstick for really short blog software. It's also what I'm using now. [Official web site](http://www.blosxom.com/) [Why it's great that Blosxom sucks](http://blog.plover.com/oops/blosxom-sux.html)
Perl has a reputation for being a language in which you can quickly whip up something that works pretty well. I think that's good, and I think 200-line blogging software will help promote that reputation.
Huh so I ran those quick tests on a bunch of our servers and most of them it worked properly. Of course on the build machine where I need unit tests to run it's screwed up for some reason.
&gt; I would guess that the Parrot team is populated with some of the most dedicated die hard Perl 6 supporters around. Is this the case? Not exclusively. Several people with no interest in Perl 6 have an interest in Parrot.
That also provides you a possibility to use Perl 5 code from Perl 6. And that's, iirc, only bridge that works on Parrot now.
I believe it does, but I used it more for the earlier chapters.
I'd also like to read: * Why is NQP a separate project from both Rakudo and Parrot? * Why is NQP imported into Parrot? * Why are there multiple semi-compatible versions of NQP in Parrot? * Why is NQP sometimes covered by Parrot's deprecation policy and sometimes not? * Why is NQP so much slower than other code written for Parrot? * Why does the current version of NQP reinvent so much of Parrot? * Why does the current rewrite of Rakudo need a VM independence layer? * Why are features of NQP not getting pushed into Parrot, especially when NQP was promoted as a high-level language toolkit suitable for the implementation and interoperability of multiple languages on Parrot? What Moritz wrote is accurate, but giving people the impression that "metacircularity is hard, whee!" explains away what I wrote about Parrot's deprecation policy and the problems of Rakudo and Parrot is ... insufficient for my tastes.
Please don't make the mistakes of confusing NQP (the new, 6model based thing) with NQP-rx (the one which has .pir files shipped with parrot). * NQP is separate from parrot to not fall under the deprecation policy, and to allow fast development. It's separate from Rakudo so that other projects can easily use it. * Mu. NQP is not imported into parrot. Only NQP-rx is * Which versions are you talking about? There's NQP-rx, which is needed to build parrot. I'm not aware of others. * Dunno * Because it uses parrot's lexicals extensively * Because it needs to. * It doesn't. It's mostly for bootstrapping. Read my post again, at your convenience * Because nobody's done it yet. Whiteknight is working on some of it, afaict.
porting parrot to a new platform is a completely separate problem than limiting the languages it executes. 
But the whole point of porting Parrot to Android is that you're not porting just one language while you're at it.
I think the main point of porting Parrot to Android would be so that you could use Perl 6 there instead of Java. 
&gt; Please don't make the mistakes of confusing NQP (the new, 6model based thing) with NQP-rx (the one which has .pir files shipped with parrot). *I* know what NQP and NQP-rx are and the differences between them, just as I know why metacircularity is useful (see also Lorito, M0). I would like to see those posts to help *other* people who may find the names confusing. Also your comment about lexicals does not match my experience.
This intrigues me. Can you share an example that would be considered quality code in one of these other languages, but awful in Perl? And what would the Perl equivalent be? This is precisely the kind of stuff I want to find and understand. Perl definitely seems to dance to the beat of it's own monkey and I'm trying to get a better grip on that.
It would help if you post perl version (something like perl -e 'print $]') and Socket.pm version (just perl -MSocket -e 'print $Socket::VERSION'). Maybe we discussing something that was fixed years ago? Also did you run your tests or oneliners I provided?
I ran the one liners you provided as tests. Socket.pm is version 1.78 Perl is version 5.008008 I'm stuck to some out of date things due to IT only wanting to use what's in the Centos yum repos. :( At any rate, this seems to only happen on some servers (possibly one) which has me back to thinking it's a server misconfiguration somewhere, not a perl issue.
A large part of the problem with that is how you define "quality" code. In some languages, being expressive and explicit is a blessing. Java comes to mind. In others, it's a curse -- things like sed and awk favor compactness over expansive. Picking the right tool for the job is a huge part of the job. Perl is _not_ Java, nor C++, nor sed or awk, or any other language. Unlike other languages, though, Perl is a lot more forgiving when you treat it like Java or C++ or sed or awk. If you hit it with a hard enough hammer, you'll get the results you want. Consider a simple problem, given a string, say, "1 2 cherry 3 4 orange 5", find the items that's are not a 1-digit number. It's a task well-suited to Perl's strengths: In Perl: my $list = "1 2 cherry 3 4 orange 5"; my @fruits = grep { !/\d/ } split( /\s+/, $list ); I have no idea how to accomplish such a task in other languages without a lot of typing I'm not really willing to do. But, how would _you_ solve that task in say, C++?
assuming: string list = "1 2 cherry 3 4 orange 5"; vector&lt;string&gt; fruits; bool singleDigit(string str){return str.length()==1 &amp;&amp; isdigit(str[0]);} short version (eliding #includes of &lt;algorithm&gt;, &lt;iterator&gt;, &lt;strstream&gt;, &lt;functional&gt;): copy(istream_iterator&lt;string&gt;(stringstream(list)), istream_iterator&lt;string&gt;(), fruits.begin()); fruits.erase(remove_if(fruits.begin(), fruits.end(), not&lt;singleDigit&gt;)); //this code seems to match closely to what perl is doing, but is is MUCH less readable long version: less includes (only &lt;strstream&gt;), more readable code: stringstream stream(list); while (stream){ string token; stream &gt;&gt; token; if(!singleDigit(token)){ fruits.push_back(token); } } //although this takes a few more lines, I find it very readable. Assuming you know what a stringstream is and how it auto-parses its arguments. Hey, you asked.
Man, C++ never fails to make me want to hurt someone. ;)
I wonder if Perl 6 would've been "completed" or at a 1.0 release a *long time ago* if they hadn't been trying to deal with Parrot and everything too. It looks like they were over-designing it, and now having to sync Rakudo's development with Parrot seems to be slowing everything down.
Perl 6 has to run on *something*.
That *something* could've been C, like Perl 5. Or whatever Ruby or Python was programmed in. Getting Parrot involved seems like it was an over-design choice, like, "we're going to create a new language from scratch, so why not go all out and build an entire virtual machine that can run multiple languages too?" Admittedly, I haven't been following Parrot very closely so feel free to downvote if I'm just being silly.
Parrot has its problems, certainly, but the only way of knowing the exact capabilities of a VM that Perl 6 needs is to implement Perl 6. You end up with is something that looks a fair bit like Parrot anyway in terms of features. Besides, another of the long goals of Perl 6 is to run in process with Perl 5, so language interoperability has always been a goal.
You mean the casual bystander would wrongly assume (for no apparent reason) that there are two incompatible versions of NQP are shipped with parrot, and wonder why? Somehow I've trouble believing that. &gt; Also your comment about lexicals does not match my experience. Do you think that lexicals perform as well as registers? I don't, so I think it is an issue, though maybe not "the" issue. You're welcome to share your experience though.
Ouch... really old stuff. Current version of Socket.pm is 1.94 and I really don't like idea to track changes of whole perl to find out if there was any bugs related to inet_aton fixed during last 5 years or so. To make sure it's perl and Socket.pm bug or system-related, you can get perl 5.008009 on your dev machine via perlbrew, but anyway only 5.9 available there, not 5.8
If you need just a short documentation... Maybe you'd better go with perldoc? I'd maybe started with Perl Syntax http://perldoc.perl.org/perlsyn.html than go through Perl Data Types http://perldoc.perl.org/perldata.html and then go down through the list at http://perldoc.perl.org/index-language.html Stop when you feel it's enough and go coding. And turn back when that feeling disappears.
submit plackfile as a patch for addition to the pkg!! this is a no-brainer
What are you referring to, specifically?
&gt; Do you think that lexicals perform as well as registers? That's not NQP's biggest performance problem.
&gt; Why anyone would roll their own buggy, less maintained and less functional Less functional? Ok. Point. Less maintained? Hey. It's 200 lines of code. Will there be gotchas? Sure. But you're comparing apples to oranges. Debugging a 200 line program is a piece of cake. A 200 line program has hardly any wheel to reinvent. This is clearly going for a bare-bones level of functionality and *not* rolling one's own in that situation is simply not an option. Put alternately: why would anyone not roll their own when they want minimal functionality and the options out there are huge piles of code that are striving to be everything to everyone, and would be headaches for casual coders? Seeing as he's going for light and fast, I'd actually recommend that he ditch the CGI and use CGI::Minimal (and change the CGI-&gt;br calls to just '&lt;br /&gt;', etc), and ditch the IO modules and just use Perl's native file operators. Not sure what Time::Piece does but that might be ditchable too. 
Someone on perlmonks wrote a shorter, faster version (I wrote the initial perlmonks post). Does anyone here care to give it a go?
i think you're the only one who thinks the point of parrot is to make android development easier
What is it then?
mojo is amazing. i have no idea why everyone isn't using it. this could be a killer app like rails was for ruby
Isn't there some personality issue?
Yes, the main developer is a very polarizing character. I personally wouldn't touch Mojolicious because the API is constantly changing, so upgrades tend to break old code. Plus, the author feels the need to reimplement everything from scratch instead of using existing battle-tested code. I prefer Dancer for small to medium projects and Catalyst for large projects.
I hear $x for small to medium projects and Catalyst for large projects constantly. What consists of a large project to you? More than 5 developers? More than 10k lines of code? Is there just a "feel"?
I use Catalyst for several projects with one or two controllers and half a dozen actions. Those projects are likely to grow larger, but that's about the size where I prefer it to Dancer.
This is simply not true, Mojolicious has very strict deprecation policies these days. http://mojolicio.us/perldoc/Mojolicious/Guides/FAQ#What_about_backwards_compatibility3F And we do in fact use battle-tested CPAN modules, there are always reasons for why we decided to reinvent a specific wheel. http://mojolicio.us/perldoc/Mojolicious/Guides/FAQ#Why_doesn27t_Mojolicious_have_any_dependencies3F http://mojolicio.us/perldoc/Mojolicious/Guides/FAQ#How_does_Mojolicious_compare_to_other_Perl_Web_Frameworks3F
Embiggens is a perfectly cromulent word.
Nice article. I was vaguely aware of the B::* modules, but poking in there and using the internal Perl hashing function was interesting enough to go explore. Thanks!
This is hilarious. I got my start writing Perl CGI scripts 10+ years ago, but I haven't touched it for web development in several years. So I came across /r/perl, saw this post, and thought, "Huh, I wonder what modern Perl web development looks like. Only 200 lines? Let me take a look..". So I looked at the code, and it basically looks like all the horrid crap I wrote 10 years ago.
It's 2011, do we really need to sell unit testing to programmers now?
agreed. and there's no mention about perl in the article.
Based on my professional work, yes we do.
I need to get some meat on it :)
I wish your rhetorical question just had the obvious answer "no". But the Unit Testers' Underground Movement has some ways to go still.
As author said: Make perlresume your home page! Every time you start your browser think: what can I do for CPAN today? :)
That's fucking amazing....
context: http://blogs.perl.org/users/marcel_grunauer/2011/08/being-anti-social.html
Based on my interviewing experience, I concur with you. I don't think a single interview candidate has written automated tests as of yet. It's really sad.
I've had a quick look at [his modules on CPAN](http://search.cpan.org/~marcel/), and I was wondering if there's any one in there that was particularly interesting, as I saw nothing I use myself, anyway...
You don't need a tutorial - Google what you need to know with "in perl" tacked on the end. Want to do a for loop? Type "how to do a for loop in perl" into Google. edit: This is how I learned Perl.
Same. Even he says that he only uses a handful of them, and most of them were specific to his work projects and are unlikely to be used elsewhere.
https://github.com/marcel-maint/marcel-maint.github.com/wiki/Voluntary-Maintainers # Volunteers here =)
This just made me realize I haven't uploaded anything to CPAN in nearly 2 years. I should prolly get on that. I have some beta level modules I've been playing with and could probably put up on CPAN in the mean time (one to connect to yahoo messenger for i.e. a chatbot)... modules with basic functionality is better than nothing?
Very nice. It just seems to have trouble counting github repos. It showed I have 0 of them, though I have a few (CPAN id 'MORITZ', github id 'moritz').
if his modules aren't *broken*, then just let them be. the ones that attract legitimate interest will pick up maintainers as needed. otherwise the modules will work just as they did when he left them
I've actually told people on IRC "you keep using that flag. I do not think it means what you think it means."
This is a very great explanation of what that flag actually means. I had no knowledge of this before. (Though granted, i never actually used it.)
A Padre dmg for OSX (which works on Leopard, Snow Leopard &amp; Lion) can be found here: http://wildperl.com/padreonosx/ See recent blog posts on http://wildperl.com for more info.
W3C is working on CSS4 now?! When did that happen?
That briefly happened for me, too, then it updated; looks like it uses some Javascript to fetch the count via GitHub's API then update the page.
Nice book. Here's the [fixed](http://onyxneon.com/books/modern_perl/) link.
That's great!
Well, thanks guy/gal for the downvote. I use perl for system admin tasks and wanted to expand that knowledge I have to do things a bit easier in the web world. But, shit like this will get a lot of converts. I'll just stick with PHP and maybe learn RUBY or something for building dynamic web pages. Thanks guy/gal.
I've found the mod_perl or fastcgi are the best ways to use Perl with apache. You can find a bunch of information here: http://perl.apache.org/ http://perldoc.perl.org/CGI/Fast.html
There are lots of different ways to nicely use Perl for web projects. Currently I'm writing a continuous code review app in Mason (2.0). There are lots of nice (and fairly fast) things like Catalyst and Dancer. I don't really know enough about them to tell you the ins and outs of them. CGI is okay for small things or one off projects, but of course you're getting a huge startup cost from running every process from scratch. So yes, there are much better ways to do it than CGI.
Hey, at least they only anonymously downvoted you. I submitted an (admittedly somewhat blurry) but I thought interesting pic of a novel failure of a bike part and got downvoted *and* someone decided to practice their epic douchebaggery skills in the comments of my submission. Here's some links for ya: [Catalyst](http://www.catalystframework.org/) [Dancer](http://search.cpan.org/~xsawyerx/Dancer/) [Comparison of Perl frameworks](http://en.wikipedia.org/wiki/Comparison_of_Web_application_frameworks#Perl) 
What kind of project do you have in mind? It's easier to answer that question with more specific information.
Thanks for the reply. Are there any good books you can recommend on those subjects that you've used and found helpful.
It's a simple website with dynamic content. Pulls information from a DB. It's just an easy pull information form a DB type website, and it's nothing fancy. Currently it's done in PHP and works alright, but some of the things I'd like to implement I'd rather do in PERL if only because I like writing in perl, and I'd rather do that over PHP. 
Thanks for the info on mod_perl. it seems like the way I would want to go. Do you know of any good books on the topic of writing perl websites that heavily utilize mod_perl. The book I bought, is a rather disappointment on that front as it heavily utilizes CGI (not fast cgi or anything like that slow CGI). 
&gt;huge startup cost from running every process from scratch. And this is the reason right off the bat I'm kicking myself for not reading into the book more when I bought it. It heavily uses CGI, and well it won't be efficient enough, imo, for a website that gets hit a lot.
mod_perl if you want to integrate deep into the apache guts, but I think mod_wsgi is gaining some traction recently as an alternative if you like to be less tied to your webserver. I don't care for mod_fastcgi at all, given it's extremely limited Auth phase handling capabilities (no custom responses for failures, for example) and the need to fire off a wholly separate process for each phase.
You'll need to install [this](http://search.cpan.org/~jmcnamara/Acme-Inline-PERL-0.01/PERL.pm).
Not really, sorry. I didn't really look around, I just started playing with Mason because it seemed to be mostly what I wanted. I fiddled around with the POD manual and the examples provided. If you decide on Catalyst, I think they have a fairly recent book available. For something like just pulling info from a DB and displaying it, you can use Plackup and RoseDB with any of the Perl web frameworks and be up and running in zero time. There's not much of a need to hook it in to Apache when you start the project.
Please stop saying PERL. It's not an acronym or initialism. It's Perl the language and perl the interpreter.
Alright. I've been writing it like that for awhile and you're the first to bring it to my attention. I'll attempt to remember this fact for the future. 
You can use [Plack::App::CGIBin](http://search.cpan.org/perldoc?Plack::App::CGIBin) to get Plack goodness, Perl persistence, and the simplicity of CGI compatibility until you know enough about Perl web programming to use Plack or something which uses Plack directly.
Practical Mod Perl by O'Reilly was the go-to resource for mp1 for me. The same authors also wrote this: http://modperl2book.org/ This is also a fantastic resource: http://perl.apache.org/docs/2.0/user/intro/start_fast.html
CGI is old and not that fast but its perfectly fine for your average website. I'm wondering what kind of book this is - for me connecting Perl and Apache is fairly trivial. Its what you do in Perl that really matters.
Reddit also fudges up/down votes to thwart spammers so you can't even know if someone really did downvote you. That's why many posts are at or around 66% up/down vote ratio.
Plack/PSGI is a good way to make Perl and Apache/nginx/lighttpd/FastCGI/etc. play together in ways that your code can be moved around in different server styles and even uploaded to the two Perl cloud hosting (Stackato and dotCloud). Further down the chain, web frameworks I've read about: * Web::Simple * Mojolicious * Dancer * Catalyst
Perl and perl are much more common in the community. PERL is fine, but is mostly used by people new to or unfamiliar with the language 
mod_perl is also useful for going fast, as it is preloaded. 
Best start for catalyst is the tutorial [here](http://search.cpan.org/~bobtfish/Catalyst-Manual/lib/Catalyst/Manual/Tutorial.pod), but if you want something more there is [this book](http://www.amazon.co.uk/Definitive-Guide-Catalyst-Maintainable-Applications/dp/1430223650?&amp;camp=2486&amp;linkCode=wey&amp;tag=enligperlorga-21&amp;creative=8882) which is a bit outdated now. Try the tutorial first.
I'd look at the mod_perl book from Oreilly But probably more useful would be the Catalyst book or just spend some time checking out the Mojolicious or Dancer modules on cpan.
Mojolicious has online 'Guides' which are something like book actually. http://mojolicio.us/perldoc#GUIDES and it cross-reffers the documentation, so you may like it 
Make sure you take a look at [Mojolicious](http://mojolicio.us/) too. It is similar to Dancer, and my current choice of framework.
What he said. It really annoys me when people complain about a downvote here or there.
Does it still need 250MB just to run?
Plack
&gt; PERL is **incorrect**, but is mostly used by people new to or unfamiliar with the language Fixed that for you...
Be aware of a couple of things: 1) mod_perl tightly couples your application to Apache. Unless you're using a web framework with middleware that abstracts this for you (e.g. Catalyst), it is going to be a royal PAIN to redeploy into something else. 2) mod_perl is seeing less and less use as the days go on, in my experience. The community isn't really rallied behind it like we were in the 90s and 00s. These days most people (again, in my experience) prefer to use PSGI, as it's much more flexible in terms of deployment options. I strongly recommend you take a look at the Plack tools (which implement PSGI) instead. Or better yet, just choose a web framework (mojolicious, catalyst, dancer, etc) that implements this for you and you never have to worry about deployment details.
Most people don't use CGI anymore. If you want tight integration with Apache look at mod_perl. If you don't care about Apache but are using a different web server you can use FastCGI. Of if you want to use one of the new Perl web servers you can look at Starman. Also: Sites like http://StackOverflow.com and http://PerlMonks.org are better for questions like these since they have bigger audiences. /r/perl is usually more useful for sharing links about perl things around the web.
I should make a note that mod_perl is being somewhat deprecated by the perl community. It probably shouldn't be used for *new* projects and the only real reason you'd need to learn it is if you had to support a legacy application that uses it. For newer applications use FastCGI or Plack/PSGI. Or use a framework that abstracts this for you (even better).
Also, please use a descriptive title for your post. Many people (rightfully) downvotes post just for that. It's basic netiquete.
Yes. PERL is a made up backronym created by the community some time after the creation of Perl. Can't find a good source right now, but the story from Larry usually goes like. "I wanted to name the language Pearl, but there was already something something that used that name, so we dropped the 'a'." 
I gave you an upvote. Please don't use PHP. :)
use mojolicious
If you're looking for serious scale perl is the wrong language to be using. It's fantastic for small scale stuff and prototypes, but I would research alternatives rather than try to bleed every drop of performance out of perl, which will quickly sap all your energy and time.
This isn't for a web app. This is just for a website, building a simple site that pulls content from the database, user login. I mean the only thing I want to do with perl is what I do with PHP on websites ie pulls content from the db, puts content into the db, most importantly it just displays this information on a website. Do you think wesbite would be to taxing on perl? What I've read from mojolicous seems to be great for writing apps, but, I'm more or less just wanting to write a website and expand my use of perl.
How many concurrent users do you expect? The thing to bear in kind with perl is there isn't a massive amount of web dev using it. That might impact if you want experience for future employment. If it's small scale stuff and just for fun, crack on with perl and don't worry about it. You can use bdb too and have a nice small file based nosql install.
Roughly thirty requests a second give or take during popular hours 9-9 (really getting hit hard at lunch time). 
It's assumed that all of the discussed methods are faster than plain CGI, since he's asking for the difference between various methods of speeding up plain CGI.
I'd be surprised if perl gave the performance that you want. Good thing is knocking up a test is very easy, so I'd do that. You never know.
&gt; If you're looking for serious scale perl is the wrong language to be using. Two things: * Nonsense. * A novice who's just starting with Perl isn't going to need "serious scale".
&gt; The thing to bear in kind with perl is there isn't a massive amount of web dev using it. Nonsense.
&gt; I'd be surprised if perl gave the performance that you want. Why are you guessing at answers in this thread? Why not measure? For example, the example benchmark in the Starman documentation suggests that it can serve 6800 hello.psgi instances per second. Certainly that's the minimal benchmark, but add some caching, add some backend instances, put in a reverse proxy with gzip, tune your database, and if you're over two orders of magnitude slower, you can still do 30 requests per second.
Why not read before you get a chip on your shoulder?? "Good thing is knocking up a test"
* http://jobsearch.monster.com/search/perl_5 * http://jobsearch.monster.com/search/php_5 I say again: what's with the chip on your shoulder? I'm a perl developer, I use it every day. I also develop C++ and C#. I also use a hammer for nails and a screwdriver for screws.
God, excuse me for not making an assumption!
&gt; Why not read before you get a chip on your shoulder?? Why not test your assumptions before you mislead a novice?
http://jobs.perl.org/
I suspect you don't have the experience to back up this assertion.. from my experience at places like LoveFilm, Slando, and Venda that isn't the case. When scaling up the issues you hit against are almost never in the application logic - it's things like Databases, network latency to your caches, cache-miss ratios, I've even hit cases where the number of sockets available to handle requests has hit operating system limits. Also, only beginners mistake performance for scaling - it's not about how fast you serve 1 request, it's about the slowest or median response time when handling thousands - eeking every drop of performance out of application code is a sign of severe design and architectural failure.
Really - 30 requests a second? That's trivial even on very low end hardware. I've had single servers handling 300 pages/second for nontrivial web-apps *despite* waiting for the databases (both RDBMS and NoSQL) being the main limitation. I'd be surprised if you've ever tried using perl for a significant web application - your suggestions here to this new user would mean you failed the troubleshooting and scaling parts of job interviews I've done (averaging a couple a week at the moment, including some senior roles - I've seen better answers from juniors and still turned them down)
You may want to look at getting a quick and simple win by using Apache::DBI and mod_registry (an apache module that allows you to run cgi scripts within mod_perl)
ShinyCMS - I dont believe it's tied to mysql - should work fine with postgres
You're not a perl developer I'd want to hire - it's not a chip on his shoulder or mine - it's that you're giving ill-informed bad advice to a relative novice who asked earnestly for help based on his rational and reasonable decision to use perl. Your trolling and whining just wastes everybodies time and kills goodwill in one of the less troll-infested parts of reddit
I'm neither trolling nor whining, I'm giving my opinion, which you're entitled to give too. Guess what, yours is no more valid than mine.
Fair enough, the OP can take whatever advice he likes. I'll stick to node js for serving and perl for backend processing. Thanks for your opinion.
My OPINION was that you don't sound like you'd survive even a junior perl developer interview anywhere decent. My EXPERIENCE is that he shouldn't have any problems scaling with perl as opposed to anything else to the point of being a householdname with millions of paying customers and a cluster of dozens or hundreds of servers. That's not just my opinion, based on stuff that I read online, that's from real world commercial success, and what I said about the actual problems of scaling are well documented by other authorities in Books like O Reilly's Art of Capacity Planning, or proven case studies on websites like http://highscalability.com/, as well at conferences and workshops.
You know the saying : "Opinions are like arseholes, everybody's got one". I didn't the read the OP as saying he wanted opinions from anybody regardless of experience or ability, and I didn't see any caveats in your off-topic trolling replies saying they were just your humble opinion either. The other answers on here are pretty good and helpful, so I only quickly mentioned the quickest, shortest low hanging fruit he could try first to get some immediate results - that was from experience - I've seen Apache::DBI and mod_perl registry work in action - I've also seen substantial benefits using plack, pure mod_perl and catalyst on substantial real world projects (as well as having spoken to people at perl mongers and conferences who have more experience with various specific solutions like Dancer, etc) - aside from your unhelpful interjection the feedback has been pretty good and encouraging.
actually it's only deprecated as far as some frameworks are concerned - if you need serious power (whether through directly sharing code/data/etc between processes, handling or customising, different parts of the request process, etc ) then it's still the best option. It's not the easiest, nor the only or even the recommended solution for small to medium stuff, but all the largest projects I've worked on have made use of mod_perl for good reason.
In the first moment I though "oh my, IBM is showing of CGI again". But then, suddenly, Plack! It's good to see them caring.
thought the same thing.
Me three.
Nope, just a little bit below 100 MB (Padre trunk on Ubuntu 10.04, with Perl 5.10.1 Wx 0.99 wxWidgets 2.8.10). 
A very cool september for perl and it's only 5 days in!
Wow, great news :)
I needed a mail queue monitor so I wrote one. Anyone have any suggestions, comments, questions?
Haha, you're a dick! But, I loled. *The power of Perl from within PERL!!!* Just what I always needed!
This.
But, I'll only give you this up vote if you promise not to use PHP.
Seriously, with the exception of PaulMDK, there has been some very good information in this post. Stick with the Perl! Stay away from PHP.
Ok, I'm sold, but I'm not really sure where to start. Can you provide some reading material and maybe some examples? (The reading material carrying the higher precedence.)
Thank you for this bit of information. You've relieved my main fear with dealing with perl to perform what I would normally do in PHP, and do such things that are trivial that have next to zero overhead as is. Knowing this much, that perl can easily outperform 30 page requests a second and going up to 100+ makes me feel much more confident in a language to hardware performance that I would require to consider a rewrite of important parts of the website that is very RDB dependent. 
Doesn't look too bad. The only real oversight i noticed was that some of the stuff in the last for loop was duplicated and coult be cut out: http://pastebin.com/uiHVQthf
So the reason I wrote get and getnext as separate options is, in developing the script to monitor other components, etc. some components will require a different response for getnext. (this is my rational, not saying it is correct. I did ask for the critique. :)) With that in mind is there even a better way? I started [this](http://perlmonks.org/?node_id=924306) perlmonks thread, any thoughts on developing this into a component/pluggable architecture? I think it would be easier if I could write the monitors separately, and have one main driver that loads the different monitors from a ./plugins directory for instance. What I don't what to have to do is define every monitor into the main monitor engine. (if that makes sense.) Thanks for the critique, in the present form, this absolutely makes more sense. Any reason you use 'or' instead of '||' ?
There's this whole fear of breaking some legacy systems which depend on deprecated features. The problem with that theory is the people with those legacy systems are extremely unlikely to update their Perl version as well.
Are you seriously complaining about having to write a one-line use statement in software that is either a) new or b) actively-maintained so that the hojillions of lines of existing Perl code (including unmaintained-but-critical code) don't randomly break?
It's not just deprecated features. Sometimes semantics change slightly as well, not to mention things like bareword handling (e.g. if the parser encounters the bareword 'state' does that mean a bareword like in 5.8 or the state keyword as in 5.10+?)
A friend of mine is just starting to learn Perl, and I had to tell him to `use 5.14.0` so he could use all the features of modern Perl, and then thought to myself, "this is a weird requirement for a language, isn't it? Other languages I've used don't selectively turn on new features when you specifically say you want them."
That's understandable, but you also need to think of how you'd feel if suddenly code you wrote that worked, didn't anymore and you had to figure out why, and how to fix it. Even someone new to the language should understand that code you wrote shouldn't auto-break periodically if you run it on different perl. It's not like this stuff is compiled and deployed as an executable and all you need to do is get it to work once on a development machine. There's also the case of running a single version of code on both old and new versions of perl. If you make old-style code say use 5.8 and some machine tries to run the code on 5.7, it won't work. Also, if you write code that depends on the new semantics and leave the 5.14 out, you'll get unexpected behavior on older versions of perl. This way isn't perfect, but in the places it counts most, it's better. I'm curious, what 5.14 specific features is he using that he needs the use 5.14.0?
Do people running unmaintained-but-critical code upgrade their perl?
He's not really using any new features much yet, but I mention in passing now and then a new feature that wasn't in 5.8... like when I explained ternary operators, the example I gave was the old, `$x = defined $x ? $x : "default value"`, and the defined-or operator naturally had to be mentioned then.
Sure. Just because someone can run "yum update" or whatever on their server doesn't mean the critical software being run on the server has a maintainer.
Because Perl 5 has never had a policy of requiring programs to specify the precise version of the Perl 5 semantics they want. In the absence of a declaration that a program wants Perl 5.8.x semantics, the best anyone can do is guess, and that's no way to produce robust code.
I am the author of both the module and the blog post. I am happy to answer any questions or accept any criticism.
Yes because hardware fails and sometimes you are forced to upgrade off of it.
defined-or doesn't require a use line if I recall (a quick test confirmed it), only things that could actually break existing code should require the use line.
Why not make it a Perl compile-time option? In the last 5 years since 5.10 I wrote hundreds of scripts, each one of them containing "use 5.010;" because I wanted "say" or "given". (For the record, I do have vim template for Perl containing that acutual pragma, so I don't have to write it all the time, but still.) 
That's actually an idea I like. I don't know about the Perl 5 maintainers though.
That's like argument number 1 against ever writing a default handler for a token into a parser. If, for example, the default is to ignore things you can't understand, you can _never add anything backwards-compatibly to the language ever again,_ because some jerk will have used that functionality to comment his code or something.
Oh I agree, but the Perl 5 parser/language is just on a planet of its own, so I'm not at all surprised that they have this issue.
From what I can tell, and I'll admit to not giving it a _lot_ of thought, it seems like DCI is a way to think about Models as Data, and Controllers as Context and Interactions? Sort of fleshing out the role of the Controller, yes? (the Views are outside sniffing glue) 
New features might be incompatible with legacy code. If new feature are auto-enabled and breaks legacy code, people tend to downgrade perl to make their code working. The scenario goes like: "I don't know how many percentage of my app is going to be broken after upgrading perl, maybe I should not do it." If nothing is broken when upgrading perl, people can start upgrading and test their programs one by one and add the statement of "use v5.14" to declare "the following code is good on perl 5.14 or latter". People can then learn new language features by refactoring their code to use new features without causing massive damages in their app, or worries to lost their jobs. Also, the behavior of "use 5.8.8" does not mean "I want the exact behavior of 5.8.8" in perl5. It merely checks the minimum required version of perl5. It does more than just that in perl 5.10 and latter versions, but it still does not mean to ask for the exact behavior of the wanted version. Even if it works that way, having to add "use 5.8.8" to all .pl and .pm files after upgrading perl5 is just annoying. Not to mention when the number of program files are massive. It is just a sweet decision made by perl5 porters to always keep new perl5 releases very backward compatible. I am really grateful for that. :) 
Um.... re-read what I posted : I said *NON*-trivial applications (i18n, complex business rules, dealing with caching and distributed file storage like mogilefs, etc) blocking on *NOSQL* backends (Lucene, Memcache, etc) dealing with hundreds of dynamic pages a second (excluding static and cached content like js, css, etc). My point being you can scale to market leading web businesses in multiple countries on a handful of servers and still be blocking on databases and caches not even coming close to hitting any performance limitation in perl. This is why any claim about perl not "scaling" is nonsensical - nobody has seen it cause an actual bottleneck in professionally put together high end systems, the same applies to most other programming languages. The key thing to scaling is architecting the solution to handle the inevitable bottlenecks of databases and other shared resources, replication of caches and databases, and making sure that applications can be horizontally scaled without causing bugs like race conditions or over-whelming shared resources 
Quite honestly, i posted this here to try and get people talking about it, reason being that i don't get it. The module seems to do two things: 1. teach a programming paradigm 2. provide helpers for said paradigm But i honestly cannot tell with certainty, since i keep getting hung up on small mistakes and oddities i notice: - "the problems of OOP" ... uh, which? - principal vs. principle - recipt vs. receipt - why are scalars and array refs being used as objects? - why does he do this? one should only shift when one actually *wants* to modify an array, but he's just extracting parameters and not only that, he uses two difference parameter extraction paradigms without any need for it. why?! ` my $self = shift;` ` my ($line) = @_;` - wait, there was no moosish stuff before, why is it coming in now? - is `package Transfer;` an object, or a role or what? - oh, it's a function module? - wait, why does he `use` it and then `import` it again? And finally, at the end of the Synopsis, i am left not only asking myself: "Ok, just what is this meant to accomplish?", but more importantly: "Why would i care?"
I feel like DCI was conceived to solve a set of problems Perl doesn't suffer from.
I understand the pain but let's go back a version earlier. What if you wrote a 3 parameter open open my $fh, '&lt;', 'filename' and accidentally run it on perl 5.005 ? It would blow up with some cryptic error message. OTOH if you had use 5.6.0; or some higher number in your code then the error message would indicate the requirement of a newer perl. So in a way the fact that you have to indicate that you are using a newer feature will save you from wasting time on some cryptic error message from an old version of perl. 
This is a common item in feedback. I am working on a second blog post that provides: * A brief, succinct, but complete description of DCI (1 paragraph, 1 bullet-list) * A complete example of a problem in OOP * A complete example of the same problem in DCI * Compare+Contrast. I have been running it by several people in both Perl and DCI. Once I have enough feedback + edits I will make the second post. (Note: I have also recruited the help of grammar nazi's and spelling geeks for this one)
How it's different from any language that has keywords and recognizes other symbols as identifiers? Like adding a new keyword to C without causing problems for existing code using that as identifier?
It's not, provided that the language makes no syntactic distinction between using a keyword and using a user-defined symbol. If Perl 5 disallowed ambiguous barewords and required the leading ampersand to call functions, the problem would be much less visible.
&gt; [P]eople can start upgrading and test their programs one by one and add the statement of "use v5.14" to declare "the following code is good on perl 5.14 or latter". The problem is that while you can promise that the code works on Perl 5.14, you can't guarantee that it will work perfectly on future versions of Perl 5 which do not exist yet. The semantics of `use 5.014; # or later` are broken.
There are a couple of great modules that make this much easier. Rather than telling your friend to write *use 5.014*, along with *strict*, *warnings*, etc ... you can tell them to use Modern::Perl; or use common::sense; While these are slightly different from each other, and slightly different than what you or your friend are typically writing - they give you some good sane defaults all in one tasty line. 
Your reply is anti-helpful.
It's funny how Perl fits well not only with the problems I frequently need to solve, but also with my whole outlook toward computing. Great article; thanks for ~~sharing~~ writing. :D
&gt;Yes, the prompting for this piece came from attempting to moderate a very frustrating discussion between two projects where one revels in its ability to be wrong frequently and expensively while actively prohibiting the other to be wrong even in small ways. Dependencies are difficult. I can't be the only one wondering which two projects these are...
If they're projects you've heard of, I'm not going to call people out in public. If they're projects you haven't heard of, any details I haven't mentioned aren't that interesting. Either way the general point stands.
I'm surprised this got downvoted but if you're not sure what I'm talking about then I'd recommend reading [Perl Cannot be Parsed](http://perlmonks.org/?node_id=663393) for a description of the difficulty involved.
Great to hear! I was a bit worried that my criticism wouldn't be taken well, but you took it exactly right. :)
In that case you should be calling separate sub-routines with names according to their purpose. More likely though you'll end up with one subroutine and a parameter that allows you to switch a single behavior on or off. As for making it modularized, Module::Pluggable is likely what you want. But really, before you do that, you need to embrace splitting things up into well-named sub-routines much more. As for or vs. ||, they do different things and have different precedence (see perlop). Plus, i find or to be more readable. :)
let me guess, rakudo and parrot?
&gt; In that case you should be calling separate sub-routines with names according to their purpose. More likely though you'll end up with one subroutine and a parameter that allows you to switch a single behavior on or off. That makes sense. &gt; As for making it modularized, Module::Pluggable is likely what you want. But really, before you do that, you need to embrace splitting things up into well-named sub-routines much more. Are you familiar with Module::Pluggable at all? I'm having the damnedest time getting it to work for me. Actually, I'm having the damnedest time figuring out how to get a list of "plugged in modules". Someone recommended creating some sort o API, which I think will help my "modules" talk to the "engine", but I think I need to figure out how to get the engine to "see" the modules first. As for "or vs ||" I understand that "or" has a lower precedence than "||", which is why it is best to use it in die statements i.e.: open my $FH_IN, '&lt;', $some_file or die "Cant open $some_file"; is better than: open my $FH_IN, '&lt;', $some_file || die "Cant open $some_file"; but in a simple if statement does it really make a difference? if ($a &lt; $b or $b &lt; $c) if ($a &lt; $b || $b &lt; $c) if ($a &lt; $b or $b &lt; $c || $c &lt; a) My initial thought is yes, but I'm not sure why. Thanks for the response
[Object Oriented Perl](http://goo.gl/Ie4Y8)
While it's fun to consider Rakudo running on other VMs, and while it would be neat if Parrot could cater to and have interop between every HLL that comes its way, both of these projects need to cater to and serve *eachother* if they're going to flourish. Very few are going to be interested in Parrot if it's not the premier VM for Rakudo, and Rakudo is going to run out of steam, resources, and relevance if they think they're going to port to another VM within a reasonable amount of time. 
I agree, but that's not what the post is about.
Several times I've wanted to use something like Beautiful Soup or NLTK without writing Python.
Thanks :)
Just a couple of minor typos in the module's pod: s{ammount}{amount} s{SYNOPSYS}{SYNOPSIS}
Yes, you're correct. I suppose I was contemplating that last paragraph of yours (in the article), and -- thinking only of it -- posted my comment. 
you have to wonder how many snipy passive-aggresive blog posts it will take before people start leaving rakudo and parrot
Everyone suffers from the problems of data being insufficiently hidden. Perl perhaps more than most, since there's no compiler-enforced way to create private/protected members. What DCI does is make some "Data" classes that are basically public data structures, but only a handful of "Context" classes are supposed to interact with those data structures. It doesn't solve the real problem, which is that bad programmers tend to break encapsulation despite your best efforts. There is no Silver Bullet. It's a potentially interesting approach for good designers to take, but good designers already have a decent sized set of approaches.
Looks like the url they are parsing has changed In the module it has if ( $url =~ /info\/(\w+)\/comments\/$/ ) { # http://reddit.com/info/abc123/comments/ return $1; but the links now look like http://www.reddit.com/r/videos/comments/ka7g0/best_exit_from_a_reality_tv_show_ever/ changing the line to if ( $url =~ /\/.*\/comments\/(\w+)\// ) { might fix it 
Oh. Where would I find this, in the module? Thanks for your answer; I would never have guessed that, ever.
In the module around line 241, you should raise an issue with the dev as well 
It would appear to be obsolete, not updated since 26 Dec 2007. Look at the login method: sub _login { my $self = shift; my $mech = WWW::Mechanize-&gt;new(); $mech-&gt;get( 'http://www.reddit.com/' ); $mech-&gt;submit_form( form_number =&gt; 2, fields =&gt; { user_login =&gt; $self-&gt;get_username(), passwd_login =&gt; $self-&gt;get_password(), } ); $self-&gt;set_mech( $mech ); } Now look at the reddit source: &lt;input name="user" type="text" maxlength="20" tabindex="1" /&gt; &lt;input name="passwd" type="password" maxlength="20" tabindex="2" /&gt; The field names have changed and no longer match (`"user" ne "user_login"`). In general this module is probably completely obsolete as it's trying to do screen scraping instead of using the Reddit API. I don't know if the API even existed in 2007, but it does now and it's the preferred method. 
Thank you; all these response were much appreciated. Now that I know that my problem isn't with my program as much as it is with the module, I'll probably just switch to Mechanize. 
I see; thanks. Honestly I'm not sure exactly how the API squares with using perl, as I'm very new to this, but as I understand it, if I login, that (and spacing out my requests) will honor the spirit of it. Starting now I'll be using the module Mechanize to access reddit, login, etc.
OK. I may email him, just to see if he plans to update it.
Hi there. I'm the module author. It's not you; it's me. That's a rather old module, and the site has updated quite a bit since then, so it doesn't work at all anymore. Please at least ignore it. I welcome patches, as I do offers to maintain it. I should probably remove it from the CPAN, I guess. 
I'll take patches, but I don't think that small improvement gets us very far. I haven't looked in a while, but I think that module should be taken out back and fed to the dogs. 
myopenid.com worked for me. Google and LiveJournal did not.
I remember reading that you can post anonymous/guest comments too.
Yeah, basically same problem with MT blogs. Google OpenID doesn't work, and that's bothersome to say the least.
Thanks for the reply; I understand. It's neat to see a CPAN module creator here, btw - I'm glad you made it regardless.
I wanted to throw in something here for people who would like to use perl and reddit together, since this discussion isn't very helpful for that (tl;dr module doesn't work, move along). I wish I could say I used WWW::Mechanize and it worked, but I couldn't figure out how to do it. However, I was able to access reddit using python and the package below. Python's pretty perl-ish anyway, for the simple purposes of this program. https://github.com/mellort/reddit_api I followed the instructions: first I installed setuptools (required), then I installed pip, *then* I installed the above with the command pip install reddit. This program works; run as is except replace whatever with your username and hunter2 with your password. I saved it as red.py. import reddit r = reddit.Reddit(user_agent="whatever") r.login(user="whatever",password="hunter2") whatever = r.get_redditor("whatever") stories = r.get_subreddit("perl").get_hot(limit=10) for j in stories: print j print whatever.link_karma,whatever.comment_karma Just typed 'python red.py' and it worked, to confirm. 
Is this your homework?
Okay, before anyone helps him; OP do this: put "use strict;" at the top of the script. fix any errors. now put "use warnings;" at the top of the script. investigate any warnings that pop up. now your problem should be obvious. For bonus points, switch your open statements to: open (my $file_fh,'&gt;','favorite-Test.TAB') or die "open: $!"; open (my $report_fh, '&gt;&gt;', 'report.txt') or die "open: $!"; open (my $script_fh, '&lt;','script.txt') or die "open: $!"; and modify statements that use those filehandles accordingly.
I am not intending to offend you when I say that your reply was not very helpful. This subreddit seemed like the most appropriate place to ask about perl questions. I expressed my concerns in advance of the possibility that this was post was too beginner-level for the subreddit. No need for that kind of hostility, man! If you must know, I am volunteering at an after-school program for city youths. The program is designed to teach basic principles of audio engineering, music producing, and media business to high school students. I am leading a class for audio post-production for films and television, and I want to make a script that will automate the report files that the students would otherwise need to type manually, thereby preserving valuable teaching time. If you have any helpful advice towards those ends, I would gladly welcome and appreciate it.
This is the best way to start, and then come back if you still have questions. It's better if you figure it out, rather than us telling you. 
Exactly why I posted it as such :)
I appreciate the pedagogical approach, however, I came to reddit to ask about my program in specific because, as I near closer to my deadline, I have yet to make substantial progress. I don't think I have been able to understand yet how to implement the solutions provided by the resources I've gathered in my own findings. I am doing the things that imMute has suggested. So far, none of the warnings appear to pertain to the problem at hand. I will post the new code momentarily. Cheers!
How dare you sir. This isn't for homework, its for a job interview ;-)
Hey that's really cool! I wish you well. imMute's suggestion (currently top-voted) should do the trick.
Another suggestion would be to debug line by line. Make sure your regular expressions are matching what they are supposed to by making your script print the matches. Things like that always help too. 
I made all changes you suggested, however I did not implement the three lines at the bottom of your reply because they completely broke my code. Perhaps that was the point, but the script actually wrote OVER the favorite-Test.TAB file (even after changing the &gt; to a &lt;) and my program became completely useless. It printed the following over and over in the terminal: &gt;Use of uninitialized value in numeric eq (==) at qcreport2.perl line 85, &lt;&gt; line 4. &gt;Use of uninitialized value in scalar chomp at qcreport2.perl line 75, &lt;&gt; line 4. &gt;Use of uninitialized value in split at qcreport2.perl line 76, &lt;&gt; line 4. &gt;Use of uninitialized value in string ne at qcreport2.perl line 78, &lt;&gt; line 4. None of the warnings or errors pertained to the question at hand (to my knowledge). This is my code now: #!/usr/bin/perl use strict; use warnings; my $n = 0; my $m = 0; my $o = 0; my $timecode = ''; my $problem = ''; my $missingLine = ''; open (FILE, 'favorite-Test.TAB'); open (REPORT, '&gt;&gt;report.txt'); open (SCRIPT, '&lt;script.txt'); #ASK USER FOR SESSION INFORMATION# print "Name:"; my $name = &lt;&gt;; print "Date:"; my $date = &lt;&gt;; print "Session name:"; my $session = &lt;&gt;; print "QC Station:"; my $qcstation = &lt;&gt;; print REPORT "Name: $name\n"; print REPORT "Date: $date\n"; print REPORT "Session: $session\n"; print REPORT "QC Station: $qcstation\n\n\n"; while (&lt;FILE&gt;) { chomp; ($problem, $timecode) = split("\t"); for ($timecode ne ""){ my @markers = (\$timecode, \$problem); $n++; $m++; } if ($timecode == ""){ ##If timecode is null, the report file is completed. close(FILE); } elsif ($problem =~ m/Missing /i){ #if problem contains the phrase 'Missing ' my $timecodeMissing = $timecode; $timecodeMissing =~ s/(^.{8}).*$/$1/; my $problemMissing = substr($problem, 8); while (my $line = &lt;SCRIPT&gt;){ chomp($line); if ($line =~ m/DUB\[0 N $timecodeMissing.+$problemMissing/i){ my $missingLine = grep(m/DUB\[0 N $timecodeMissing.+$problemMissing\n{1}/i, &lt;SCRIPT&gt;); #$missingLine =~ /DUB[0 N $timecodeMissing.{18}$problemMissing\n{1}/i; print "Found missing line!\n"; } else{ print "Not found!\n"; } } print "Timecode: $timecode\t\t\t"; print "Problem: ****$problemMissing is missing!****\n"; print "$timecodeMissing is the APPROXIMATE timecode of the missing line\n"; print "$missingLine\n"; } else { ##timecode and problem are organized into an array and printed print "Timecode: $timecode\t\t\t"; print "Problem: $problem\n"; print REPORT "$timecode\n"; print REPORT "$problem\n\n"; } } my $numMarkers = $n - 1; print "\n\n\nThere are $numMarkers markers in this session.\n\n\n\n"; close (FILE); close (REPORT); exit; ...and the output: Name:Andrew Date:09/11/2011 Session name:Test QC Station:1 Argument "" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 1. Argument "01:03:08:07\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 1. Timecode: 01:03:08:07 Problem: Start Favorite Argument "01:10:16:24\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 2. Timecode: 01:10:16:24 Problem: Bad Take - Lara Argument "01:13:58:03\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 3. Timecode: 01:13:58:03 Problem: Commercial B1 Argument "01:14:16:13\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 4. Timecode: 01:14:16:13 Problem: Commercial R1 Argument "01:25:15:23\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 5. Timecode: 01:25:15:23 Problem: Commercial B2 Argument "01:25:33:05\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 6. Timecode: 01:25:33:05 Problem: Commercial R2 Argument "01:34:19:21\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 7. Found missing line! Timecode: 01:34:19:21 Problem: ****Vanderlei is missing!**** 01:34:19 is the APPROXIMATE timecode of the missing line Argument "01:36:09:21\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 8. Timecode: 01:36:09:21 Problem: Commercial B3 Argument "01:36:27:05\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 9. Timecode: 01:36:27:05 Problem: Commercial R3 Argument "01:45:39:12\r" isn't numeric in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 10. Timecode: 01:45:39:12 Problem: Dodi? Use of uninitialized value in string ne at qcreport2.perl line 78, &lt;FILE&gt; line 11. Use of uninitialized value in numeric eq (==) at qcreport2.perl line 85, &lt;FILE&gt; line 11. readline() on closed filehandle FILE at qcreport2.perl line 85. There are 10 markers in this session. 
[Result after reformatting with perltidy](http://pastebin.com/raw.php?i=UG7gr6aT) for those that prefer non-eyebleeding. 
I do have the code printing that it finds a match... that's how I was able to deduce that the problem is in the code that locates the NEXT line, and not the regex finding the match. Thanks for your - and everyone else's - help so far!
It's not obvious what the problem is, but it's simpler to just read the whole file into an array (assuming it's not gigantic). @script = &lt;SCRIPT&gt;; for($i=0; $i&lt;=$#script; $i++) { if ($script[$i] =~ /whatever/) { print "problem: " . $script[$i+1] . "\n"; } } 
This didn't seem to do the trick, but the txt file is 1971 lines long. Could that be inhibiting your solution? Thanks all the same for the help!
1,971 lines is very small, it should read into an array in less than a second. Something funny is going on here. Are you sure the file doesn't end right after the line you're looking for? Or maybe the next line is blank, or all spaces, or filled with one or more extended characters. Some things to try: * print the line with stuff around it, like this: print "&lt;&lt;" . $script[$i+1] . "&gt;&gt;\n"; * print the string length: $#script[$i+1] * print the total number of lines: $#script (also print $i so you know what line it's on) * print several lines before and after ($script[$i-1] , $script[$i-2] , $script[$i+2], etc).
I honestly don't know if that's possible if you read your file in line by line. You could make Perl read your file in as a one-lined string with some kind of special character appearing every other line (depending on how big it is, this may be a problem for memory usage) and then alter your regular expression to read between the special characters. 
OK. I made the if statement print the line number as if it found true. Strangely enough, it is finding the match on line 0, which is completely incorrect. Now it's pretty obvious that the regex is the problem. Here is the line that SHOULD get matched in the txt file, and then the following line, which I want to print: &gt;DUB[0 N 01:34:19:16&gt;01:34:24:15] VANDERLEI &gt;I reserved some kaki here for you. It’s sweet, so sweet. Will you take it? It's an overdub sheet for a television show. The numbers are timecode for when the dialog is to begin and end. The first timecode's first three values (xx:xx:xx) = $timecodeMissing. The capitalized name is the name of the character saying the line = $problemMissing. How would I construct my regex so that it looks for: 1. DUB[0 N 2. $timecodeMissing 3. $problemMissing ... in that order? Thanks so much for your help!!
Here's what you do... put the string you're searching for into a text file with a few other random lines. Make a tiny perl script which uses the regex to find the target line (hard code $timecodeMissing and $problemMissing). Tweak your regex until it matches. If you can't figure it out, ask for help, but I'm taking off for now. Good luck :-)
Print your regex to debug it with something like: my $overdub = qr/DUB\[0 N $timecodeMissing[^\]]+\] $problemMissing/; warn "Regex '$overdub'\n"; if ($line =~ /$overdub/i) { $missingLine = &lt;SCRIPT&gt;; .... }
stackoverflow.com is more appropriate - that's /made/ for answering questions. 
Thanks for the tip! Stackoverflow looks like a great resource.
You forgot about [Moo](https://metacpan.org/module/Moo), which is actually useful and tested.
Don't do this: if ($line =~ m/DUB\[0 N $timecodeMissing.+$problemMissing/i){ my $missingLine = grep(m/DUB\[0 N $timecodeMissing.+$problemMissing\n{1}/i, &lt;SCRIPT&gt;); Just thinking about that gives me herpes. This should be sufficient for what you're doing, which is grabbing the next line after the missing line. my $missingLine = ''; if ($line =~ m/DUB\[0 N $timecodeMissing.+$problemMissing/i){ $missingLine = &lt;SCRIPT&gt;; chomp($missingLine); } *Note* that if you do it the other way (with 'my' there, then you're going to go out of scope when the if closes and $missingLine will be blank. You should define $missingLine before the if. I'm not sure if the grep you were attempting would work anyway, but you could always print $missingLine to see if/what result you're pulling in. 
Try and tweek this, until the regex does what you think it's supposed to do. use strict; sub test { my ($line) = @_; my $timecodeMissing = '01:34:19:16&gt;01:34:24:15'; my $problemMissing = 'VANDERLEI'; die "no timecodeMissing" unless $timecodeMissing; die "no problemMissing" unless $problemMissing; print "TEST&lt;$line&gt;\n"; if ($line =~ m/DUB\[0 N \Q$timecodeMissing\E\]\s+\Q$problemMissing\E/i) { print "MATCHED\n"; } else { print "NO MATCH\n"; } } test("some junk"); test("DUB[0 N 01:34:19:16&gt;01:34:24:15] VANDERLEI\n"); while(&lt;&gt;) { test($_); } 
Downvoted as there's absolutely nothing to talk about here (no link or substance).
That's "LOVEFiLM", "sponsor", "full-time", "The Perl Foundation" and "NET-A-PORTER".
I think he's referring to [the module Mo by Ingy](http://search.cpan.org/dist/Mo/lib/Mo.pod)
I clicked and got something. Maybe your network connection went down for a sec?
Clicked where? It's a self post, and the post contains no link.
WTF the [source of Mo](http://cpansearch.perl.org/src/INGY/Mo-0.21/lib/Mo.pm)???
Presumably golfed to keep it as small as possible..?
&gt; There may be situations where you want to inline Mo into your code, For this &gt; reason, Mo will try to be in one minimal pure Perl file, with no comments or &gt; documentation.
There's a [design document](http://api.metacpan.org/source/INGY/Mo-0.21/lib/Mo/Design.pod) now.
For sake of completeness, could you post the input files to a pastebin somewhere?
do perl -d scriptname.pl and that will bring up the debugger use n to step next, s to step into
`use autodie` Is Your Friend.
Personally I'd just use grep with the context switch. 
Don't get me wrong, I love Perl but this is the reason why some people hate perl.
It's Ingyware.
The HTML5 video quality is amazing.
I don;t know about finding the next line explicitly, but you could do something like this: my $usenext; open (TT) $file; while(&lt;TT&gt;){ if ($usenext){ $usenext =''; -- do nextline stuff-- } else{ -- do current line stuff -- if(need next line){ $usenext = 1; } } } close TT; 
hmm sorry, I did provide a link butt hen added the comment assuming the link would stay. Anyway I thought it was a cool module
Yes I did, thanks for pointing that one out, would have made the headline better too!
There's also [M](http://search.cpan.org/dist/M/lib/M.pm), which is designed to be even more minimalist than [Mo](http://search.cpan.org/perldoc?Mo) or [Moo](http://search.cpan.org/perldoc?Moo). It achieves this goal by doing absolutely nothing.
Cause we all know lines are scarce in source code!
Where can I find out more about the competition?
How is this cheating? It's a legit programming question, and this seems like a reasonable place to ask. What kind of programming competition forbids you from asking around online?
The point being that this thing has the potential to act like a virus to introduce Moose-isms into darkpan software.
I have to agree. He's not asking anything about how to program the game algorithm. He's just trying to figure out why the XMLRPC module he's using is misbehaving.
Blimey! In all the years I've used Perl, I've managed to miss given/when. I'm crap, but this is worth an up-vote for teaching me something useful and new.
&gt;&gt; Aristotle | September 14, 2011 12:41 AM | Reply &gt;&gt; &gt;&gt;&gt; If done right, given would have been the same as for, except for only accepting one value and imposing scalar context on it. The given we have now looks as if it’s that, but isn’t, and is broken for many edge cases. Just avoid given and use for instead. I like Aristotle's advice. Another bonus is that `for` lets you work directly on a list: use 5.010; use warnings; use strict; use List::MoreUtils qw/any/; for ('test1', 'test2', 'test3') { when ('test1') { say "test1: any" if any {$_ == 2} (2, 3); } when ('test3') { say "test3"; } default { say "none of the above: $_"; } }; produces test1: any none of the above: test2 test3 But if you rerun the above, after changing, `for` to `given`, perl 5.14.0 gives you: Useless use of a constant in void context at /tmp/tst.pl line 16. Useless use of a constant in void context at /tmp/tst.pl line 16. test3 
In all of the years you have been using Perl, it likely hasn't had given/when. They were introduced in 5.10. If you are like the majority of people out there you are still using 5.8.8 (although this is starting to change). You may find the perldelta files interesting to read if you haven't been keeping up. Go to http://perldoc.perl.org/index-history.html and read the ones that have an even middle version number (like 5.12.3). The ones with odd middle version numbers are development releases.
That is because given provides scalar context to its argument, so it is equivalent to saying given(scalar('test1', 'test2', 'test3')) { ... } The comma operator in scalar context evaluates the left hand side in void context and the right hand side in scalar context. The practical upshot of that is 'test1' and 'test2' are evaluated in void context (and evaluating constants in void context yields a warning because it is a useless thing to do) and returns 'test3' to given.
It's subtle bugs like this that make me still use dispatch tables instead.
Built-in: no. Module: sure, no problem. Really though, just use a templating engine and be done with it. * There's nothing good about having a webapp be one file. It just means you aren't keeping your model and view separate, which is just painful. * There's nothing about having inline code that provides fast feedback. * If by "fast deployment" you mean "copy files and it's done," that's pretty much how you'd deploy anything. It's a trick of fate that PHP is as successful as it is, not because of any design decisions that were made. There's very little worth ripping off from PHP.
The design of PIR means this is essentially irrelevant. Languages are defined by grammars, and so to create a grammar for inline code should be pretty trivial. I imagine it's already been done, but I don't have the energy to google :D
You can do that now, in Perl5. Both Text::Template and TT2 behave that way with the right Apache setup. That's not necessarily what made PHP popular, though. Mostly, it's that PHP stays inside its own little world in a way that works for shared hosting plans. That's not true of mod_perl, or mod_python, or most other Apache modules that embed language runtimes like that. Conversely, mod_perl and its cousins also provide deeper hooks into Apache that PHP can never use.
Sounds like [Mason](http://www.masonhq.com/) to me
If you're using regex, match the end with `/[^aeiou]{2}$/`, the beginning with `/^[^aeiou]{2}/`. As for the middle, it would depend on what you consider the middle. `/^.+[^aeiou]{2}.+$/`. I can never keep the regex escapes for different languages straight, so you'll probably need to add some backslashes in there.
Thanks!. Maybe a dumb question, but where do I put what you suggested? right now it looks like this: #!/usr/bin/perl $text = &lt;&lt;endtext; All frogs have four legs. They have two front legs which are short and two back legs which are longer and stronger. They use their back legs for jumping. gsont endtext $text2 = $text; $text2 =~ s/Th/D/gi; $text2 =~ s/gs/kz/gi; print "$text$text2 \n"; exit; Where must I put /^[^aeiou]{2}/ to only return "gsont" as "kzont" Looks ridiculous, I know, but I'm experimenting with the stuff on a small scale which will eventually be used to manipulate large text files and word lists. Thanks again. 
formatting is all gaffed up, but I think it can be made out.
Upvote for being one of the few who understands this.
Begin a line with four spaces to preserve the code formatting. It looks like you're rather unfamiliar with regex, so I've done by best to keep it simple: $ perl demo.pl s-tart en-d midd-le $ cat demo.pl #!/usr/bin/env perl $text = "start"; $text =~ s/\b([^aeiou])([^aeiou])(.*)\b/$1-$2$3/; print "$text\n"; $text = "end"; $text =~ s/\b(.*)([^aeiou])([^aeiou])\b/$1$2-$3/; print "$text\n"; $text = "middle"; $text =~ s/\b(.*)([^aeiou])([^aeiou])(.*)\b/$1$2-$3$4/; print "$text\n"; The parentheses create groupings which can be referenced with $_number_ based on their order. The `[^aeiou]` translates to "match anything that isn't a vowel." 
Why are you tired?
&gt; That's not necessarily what made PHP popular, though. Mostly, it's that PHP stays inside its own little world in a way that works for shared hosting plans. That's not true of mod_perl, or mod_python, or most other Apache modules that embed language runtimes like that. Ok. Then what Perl 6 could probably use would be an apache module that 1. does the "Perl 6 embedded in html" trick (like php), and 2. allows a safe subset of Perl 6 to run, and 3. works well for shared-hosting plans (like mod_php) &gt; Conversely, mod_perl and its cousins also provide deeper hooks into Apache that PHP can never use. Look at the massive popularity and use of PHP and mod_php. Only a small percentage of people need the deeper hooks. The vast majority just want an apache module that they can `aptitude install` that will simply provide a persistent scripting language runtime so they can start coding up their webapp. 
&gt; There's nothing good about having a webapp be one file. It just means you aren't keeping your model and view separate, which is just painful. What perhaps you're not seeing is that new users who need a simple and easy solution for a tiny webapp *like* the idea. Who's to tell them they're wrong? They're prospective users who later will be the ones touting Perl 6 for their company's next big project. Python takes the road of telling them they're wrong to want what they want. I don't think Perl 6 should take that road. &gt; There's nothing about having inline code that provides fast feedback. I think there is: 1. update file in your editor 2. reload page in browser to see changes *That's* immediate feedback. It's simple, works without any fancy configuration, and new programmers writing some simple internal webapp that their boss asked them to whip up *love* it. &gt; If by "fast deployment" you mean "copy files and it's done," that's pretty much how you'd deploy anything. Once you have your webapp set up, such that it recognizes when you've updated files and then does a graceful restart, then yes -- "copy files and it's done" is the way it works. But PHP does this out of the box. You don't have to configure *anything*. &gt; It's a trick of fate that PHP is as successful as it is, not because of any design decisions that were made. Disagree. Perl was the *king* of CGI scripting and PHP came along and handily dispatched it. Perl had mod_perl, which provided all kinds of power. Didn't matter. FastCGI too. Nope. But surely Mason would win them back, right? No. Even with all of PHP's drawbacks and disadvantages, it *still* managed to mop the floor with the competition because of 3 reasons: 1. code embedded in html (so new users had an easy onramp), and 2. easy deployment: just copy the file to the server and you're good to go 3. easy install and admin for shared hosting setups (mod_php) Those are the lessons to be learned. If you want to blow the doors off the competition (with regard to web apps), do those 3 things. 
&gt; does the "Perl 6 embedded in html" trick (like php), and Easy, no reason the Perl5 modules that already do this can't be done in Perl6. &gt; allows a safe subset of Perl 6 to run, and Tricky. Sandboxing languages really need their implementations to be built that way from the ground up. Doing it ex post facto (e.g. Safe.pm) is never going to work. &gt; works well for shared-hosting plans (like mod_php) PHP gets away with this because it was designed to be integrated into Apache that way from the start. Same with some of Microsoft's ASP stuff on ISS. &gt; Look at the massive popularity and use of PHP and mod_php. I don't necessarily rate my languages of choice by how popular they are. &gt; Only a small percentage of people need the deeper hooks. The people who do tend to have more interesting web apps, and are therefore the sort of people I want to work for.
&gt; &gt; &gt; mod_perl and its cousins also provide deeper hooks into Apache that PHP can never use. &gt; &gt; Look at the massive popularity and use of PHP and mod_php. &gt; I don't necessarily rate my languages of choice by how popular they are. I'm saying that *most* users don't care about the deeper hooks. The majority simply want someone to have already installed the proper apache module so that they can simply drop their code into public_html and have it *just work*. Popularity is nice. It means more users. And users write modules, blog about what they're doing, bring aboard other users, and even schedule and show up at conventions if there's enough of them. 
&gt; &gt; allows a safe subset of Perl 6 to run, and &gt; Tricky. Sandboxing languages really need their implementations to be built that way from the ground up. Doing it ex post facto (e.g. Safe.pm) is never going to work. Hm. That's key though. Unless it's safe and easy for admins of shared hosting servers to install, it won't happen. Perhaps could a `mod_safe_perl6` take care of the sandboxing? 
I think you're seeing some facets of PHP's success and thinking that's all there is to it. Have you seen php.net? It's one of the best websites for documenting a language ever (arguably it's too cluttered, but the content is amazing). I wanted something like that for perl, but I think the developers for php steer their project better than the perl developers. In contrast perldoc.perl.org is useful but not as friendly or navigable. Try pulling up the entry for "pop" as an example. On php.net you would get a list on the side of functions in the same category. In perldoc it's a couple of clicks away. I figure half their users came from LAMP provided by hosting providers, the other half came from people who tossed the learning perl book to the side the second they saw how easy it was to copy an example from phpuser555 they pasted on the array_split page. PHP has bad flaws and has made several missteps. Their users are very forgiving, probably because working code trumps neat code and they fix security flaws before most websites would die from it. I'm really digging the mojocasts. When I first saw a screencast for turbogears I thought "this is the new way I want to learn things" and was disappointed nobody had made a good one for a perl MVC framework. I think the best way to get users back is to release perl6 so people have a version number to rally behind, and to really put some work into CPAN. Start modernizing some of the deader modules, and pick some as "standard" so people know what will be supported in the future. Examples: SNMP,SOAP,IP addressing.. Actually a "like" or reddit style upvote/downvote system for determining who uses modules would be a great help for users to figure out which module to use. It would also help module developers know if it's worth it to continue their project, or try to get with the competitor's author and merge the useful functions. 
I find it questionable saying mod_php works well for shared hosting plans or in that case works in any useful manner other than reducing load a bit. This is because mod_php unfortunately can't be used safely in a shared environment. For shared hosting, one needs to use either suphp or suexec.
Admittedly, I'm a total noob with all of this stuff - just 4 days of programming under my belt. Your suggestions are enormously helpful. 
you can start with the code from mod_perlite and update it to work with perl6 http://www.modperlite.org/2008/12/why-mod-perlite.html
There's no value in beating PHP if we don't end up being better than PHP. I'd rather copy PHP's easy of deployment and benefit from that.
Try finding a shared host that runs mod_perl. Now find one that runs mod_php.
That is not my point. My point is that any shared hosting provider using mod_php is extremely subpar. Mod_php can only safely be used used in situations where privilege separation between site etc is not needed. 
It usually isn't. The safety involved here is not stepping on each other's namespaces, intentionally or not.
When PHP first appeared, it eliminated the need for CGI. Perl 6 can't solve that same problem, because it has already been solved. Even if you embed Perl 6 in HTML for newbie users, you'll have to come up with something extra that PHP can't do, because most web hosts and most tutorial writers still assume new users are going to go with PHP. Unless you can convince *them* to change, you'll have a hard time making the case to the users.
That isn't a job for Perl's `grep`. Perl's `grep` is for filtering a list. What you want is more like: #!/usr/bin/perl use strict; use warnings; my $old = ""; while (&lt;&gt;) { print "$old$_" if /pattern/; $old = $_; } 
Do you mean that you have something like: @filtered = grep /somename/ @lines Or are you simply reading in a file and outputting the filtered line?
Thanks for the solution. I was just hoping that since it was called 'grep' it would try to do the same thing, just with a list instead of a file :P
Yes, I meant something like @filtered = grep /somename/ @lines (and @lines just had the contents from some file)
PHP's success was not the trick of fate alexdodge seems to think, but it also was not necessarily due to the points you bring up. Those things are done now equally well by both Perl and PHP. Since we know that Perl isn't as popular as PHP for web apps, we could say that ipso facto your door-blowing-off points aren't really as important as you think. Your point 2 (and 3, which is really just another flavor of 2) has *always* been possible with Perl. (At least for as long as PHP's been around.) All you need is to have the server be able to point your scripts at the interpreter. Perl doesn't hold anyone back in that regard. As for your point 1, I don't know my history about that. Maybe PHP had a coup at the time it came out, maybe it did it better than Perl then. But I'd bet that Perl could do it (i.e. there were web app templating modules available) back when PHP came out, and certainly Perl has lots of templating options now. IMV, the main thing about Perl vs PHP is just the nature of the languages themselves. I'd love Perl 6 to become then next hot new scripting language, by the way. And I have loved Perl like crazy since I first encountered @a = &lt;FILE&gt;. But the fact is that Perl is intimidating. There are various factors affecting that. The fact that it has been written to do *anything* might make some people turn away; documentation for Perl is not only going to tell you how to do regexes but also how to work with processes and threads. Web app coders don't really want that stuff. There's how the languages look. While I'm certain it's possible to get some nice obfuscation going in PHP, Perl has a reputation for reading difficulty and it *is* pretty easy to ramp up even simple code so that it's not immediately obvious what is going on. PHP won't do that to you, I think. In a similar vein, I think of PHP as a kind of VB of web scripting languages. That's not a slam. But I do mean that, at least when I tried it out a little, years ago, that compared to Perl, it was clunky, sort of inefficient. It was less able to do the acrobatics Perl was. This is beyond simple readability. Depending on your goals for writing a program, that could be a plus, actually. I'm not judging PHP here. It does the job and that's great. But IMV the main way Perl 6 has any chance at "beating" PHP is really not going to have anything to do with ease of web programming. Ease of web programming is going to be there for Perl, just like for PHP, from now on until the end of time. The real factor now is *whether coders want to use the language*.
Manning has a book titled [Minimal Perl](http://www.manning.com/maher/) that discusses how to use Perl to replicate common Unix utilities like grep, sed, awk, etc. It makes heavy use of one-liners, and is a decent read if you're interested in this aspect of Perl.
Thanks, I'll check it out
That is equivalent to grep, but not grep -B 1. 
In general, if `@lines` has the full contents of a file, you did something wrong. Files should be processed line by line wherever possible. Saying things like my @lines = &lt;&gt;; is (often) bad form and you will (mostly) be better served by using an iterative approach: while (my $line = &lt;&gt;) { #do somehting with $line } In this case, it is fairly simple: #!/usr/bin/perl use strict; use warnings; my @filtered; my $old = ""; while (&lt;&gt;) { if (/somename/) { #if you only want the line before the matching line, omit $_ push @filtered, $old, $_; } $old = $_; } #do something with @filtered 
Greedy stars may not be what you want. The asterisk is greedy and may scarf up more chars than you'd like. Use question mark to make the asterisk not-greedy. Using "not-vowel" for consonant is problematic. You'd best be explicit. my $cons = qr/[b-df-hj-np-tv-z]/i; Use of qr//i to make Perl parse the sub-regex "now" and store the regex object. Using a string (a scalar) instead: $cons = "[b-df-hj-np-tv-z]"; would work, too, but the string is expanded and parsed by the regex parser each time $cons appears in a pattern. Compiling the regex "now" is more efficient than using a string. Using the \b word-boundary escape is good. Using the \B not-a-word-boundary is even better. How many hyphens should be added to "battleground"? * bat-tleground * bat-tleg-round * bat-t-tle-ground To get more than one substitution, use s///g; the "g" for global. (BTW, grep comes from g/re/p which is globally search for regex (re) and print). So a s///g will get you "bat-tleg-round". But it won't get "bat-t-leg-round" because the engine has moved past the "batt" before it handles the "le..". So when the engine see the "l", the t has been no longer available to match "tl". To catch that, you can use lookahead (?=pattern) it matches the pattern without scarfing it. #!/usr/bin/perl -w use strict; my @str = ("j.r.r.tolkien", "j r r tolkien", "fritz lieber", "rosencrantz", "guildenstern"); print "--stars--\n"; for my $str (@str) { my $t = $str; $t =~ s/\b(.*)([^aeiou])([^aeiou])(.*)\b/$1$2-$3$4/g; print " [$str] [$t]\n"; } print "\n"; print "--stars !greedy--\n"; for my $str (@str) { my $t = $str; $t =~ s/\b(.*?)([^aeiou])([^aeiou])(.*)\b/$1$2-$3$4/g; print " [$str] [$t]\n"; } print "\n"; # qr//i -- "quote" regex, case-insensitive my $cons = qr/[b-df-hj-np-tv-z]/i; print "--not a boundary--\n"; for my $str (@str) { my $t = $str; $t =~ s/\B($cons)($cons)\B/$1-$2/; print " [$str] [$t]\n"; } print "\n"; print "--not a boundary, global substitute--\n"; for my $str (@str) { my $t = $str; $t =~ s/\B($cons)($cons)\B/$1-$2/g; print " [$str] [$t]\n"; } print "\n"; print "--not boundary with lookhead--\n"; for my $str (@str) { my $t = $str; $t =~ s/\B($cons)(?=$cons\B)/$1-/; print " [$str] [$t]\n"; } print "\n"; print "--not boundary with lookhead, global--\n"; for my $str (@str) { my $t = $str; $t =~ s/\B($cons)(?=$cons\B)/$1-/g; print " [$str] [$t]\n"; } print "\n"; print "--not boundary with lookhead, global--\n"; for my $str (@str) { my $t = $str; $t =~ s/ \B ($cons) # not-a-boundary followed by consonant -- save consonant to $1 (?=$cons\B) # lookahead for consonant followed by not-a-boundary -- scarfs nothing /$1-/xg; print " [$str] [$t]\n"; } print "\n"; 
&gt; Perl 6 can't solve that same problem, because it has already been solved. Sure PHP solved the problem. Any language can do the same, but they aren't -- which is why PHP is still king in their particular specialization. PHP raised the bar regarding what you need if you want to compete for web dev mindshare. Now any language that wants to directly compete with PHP needs to have *the option for* the same easy deployment, easy mixing of html + code, and the same easy and safe apache module setup. But going with that option has to be as dead easy as it is with PHP, or PHP still wins. 
But, if pattern matches on consecutive lines, it'll print a line twice. Instead, use while (&lt;&gt;) { if (/pattern/) { print "$old$_"; next; } $old = $_; }
&gt; Your point 2 (and 3, which is really just another flavor of 2) has always been possible with Perl. I don't think it's about being *possible*. I think it's about being easy. PHP is easy enough that anyone who can apt-get install libapache2-mod-php5 and follow a quick tutorial can get a small webapp running *that evening*. When Perl 6 can do that, it will be able to compete language-to-language with PHP. 
While it might share a name with grep(1), perl's grep only does one thing: filters arrays by performing tests on each individual component. It has no concept of context, it doesn't modify the element it tested. map is the one that changes a value for a different value, but does so for all elements. map has no concept of context either. If you really want to return a different element of the list just for the ones that pass a certain test, you can do something like: map { $array[ search_from($_-&gt;[0]) ] } grep { test_of($_-&gt;[1]) } map { [ $_, $array[$_] ] } (0 .. $#array); Where search_from($i) produces a different index starting from the one that matched, test_of($elem) does the actual testing of the elements, and the final map produces a list of array references that contain the index and the element (so position gets carried over to the other map. Take care that any edge conditions like "return nothing for the first line, even if it matched" must be taken care of inside the grep block (using $-&gt;[0] as the compass), since map cannot prune further the values and must return something for every slot it sees.
ah that's the tool I was thinking about when I read this post. Doesn't look like it went anywhere in the end?
Doh! while (&lt;&gt;) { if (/pattern/) { print "$old$_"; $old = ""; next; } $old = $_; }
&gt; I don't think it's about being possible. I think it's about being easy. ?? It's easy. Anyone who can apt-get install anything has enough aptitude to read a quick tutorial about Perl and knock out a quick Perl app. Again, to go back to your point 2, that is simply a non-issue. Deployment of Perl scripts can be exactly "just copy the file to the server". It's always been like that for Perl and all web programming scripts. Wrt your point 3, ok, it's not entirely another flavor of 2, and I don't have much experience as a server admin, but the day that server setup for "shared" or more complicated environments is as easy as you describe, the day that it doesn't actually require a lot of experience and attention to set up correctly, is the day I eat my hat. Basically what I'm opinionating is that ease of setup for mod_php was also a non-issue, because anyone administering real servers knew enough to set up mod_perl as well, or had the aptitude to learn. That question would have been important for admins, but it wasn't admins driving the adoption of PHP, it was programmers, and what those programmers cared about was the appeal and ease of the *language itself*. Wrt ease of language use, again, stuff like templating was there for Perl. Like I say, maybe you are right, and there was something significantly easier about PHP's approach that made it really appealing. I kind of doubt it. I think the appeal was simply: (a) web apps were in demand, and (b) PHP limited its domain to web apps, *and so* could offer domain-specific features (templating, handy global input hashes, etc) *up-front*, and describe them *up-front* in the documentation. Perl, however, couldn't offer those kinds of domain-specific features and that kind of domain-specific documentation, because it is truly an all-purpose language. I would say going forward it still can't do that, because it's still more all-purpose and more powerful than PHP. However, I think going forward that's not going to be a big deal. The fact is that doing anything even just moderately complicated in web programming means, these days, a complicated setup, possibly including a CMS, an app framework, middleware, whatever. In that regard PHP is not any more appealing than Perl. By which I mean, the Perl web app ecosystem is now up there with PHP's. Perl 6 will get this stuff too, probably quicker than Perl 5 got them, once it's officially released into the wild. Those things aren't going to be major factors in any "competition" between the two languages, I'd say. A very strong reason still why people don't choose Perl is really because people don't like the language, for the reasons I mentioned. Someone who works for my client, after setting up an *extensive* commercial web site in Perl, led the charge to convert everything to Ruby on Rails, and the basic reason he offered was that he finds Perl's syntax distasteful. Really, it's a big deal.
[ack](http://betterthangrep.com/) can do it. [ack](http://search.cpan.org/dist/ack/) is written in Perl.
a while
Can you describe what you are trying to do with different words? I am not understanding it.
[perldoc perlref](http://perldoc.perl.org/perlref.html#Using-References) :)
I would use a hash of hashes. This will allow you to index your information and access it directly. This would index your information by your first column: #!/usr/local/bin/perl -w use strict; my %table; while(&lt;&gt;){ chomp; my($column1, $column2, $column3, $column4) = split/,/; $table{$column1}{'column2'}= $column2; $table{$column1}{'column3'}= $column3; $table{$column1}{'column4'}= $column4; } Then you can: print "$table{1}{column3}"; &lt;-yields 3
Yes, basically i have a set of lists in a file. The list is a program followed by information used to identify how to run the program properly. I was going to read this all in an array so that my perl script could then reference it to build various predefined script files that get used later to kick those programs off in sequence.
What bittermeltdown suggests below.
I might need to look into this. I read that hashes are a faster way, but I haven't had to use them yet because most of my scripts aren't very large so run time isn't a major issue. 
Hashes used with numeric keys (which is basically what column_x is) are actually slower than arrays since perl has to compute the hash of the key to lookup where it is. #!/usr/bin/perl use strict; use warnings; my $table = []; while(&lt;&gt;){ chomp; push @$table, [ split /,/ ]; } is what I would prefer. Edit: not to mention that bittermeltdown's solution seems to use the first item in each row as the first dimension key. Thus $table{3}{column_2} would throw an error (because $table{3} isn't a hashref) rather than return the expected 11
Sorry, downvoted because wrong. The first item in each row of the file is *NOT* a row index. Not to mention using hashes as if they were arrays - this is NOT PHP! DON'T DO THAT. &lt;/rant&gt; Edit: thought about not downvoting because you did use strict; but then I saw the -w and decided it was necessary.