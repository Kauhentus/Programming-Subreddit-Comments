I *just* built 5.16.3. It pays to check reddit first I guess. 
So how did we end up with the mess that smart match turned out to be? Was there not enough prototyping of actual uses before putting it into core? Not enough language design and discussion on p5p? **Any lessons to learn from this?**
The entire point of that is to provide a hurdle to *prevent* foot-shootings.
&gt; If Perl broke the fact that the same program, on the same machine, with the same input, and the same random seed, gave the same output by default, then it was just wrong from the start. Fortunately, it didn't, and you just feel a compulsion to talk about things you have no clue about. `PERL_HASH_SEED_DEBUG` and `PERL_HASH_SEED` exist for exactly that reason.
&gt; restart the program with the same inputs and random seed That's a good point, and it came up in the past few weeks. Set the environment variable `PERL_PERTURB_KEYS` to 2 (or set `PERL_HASH_SEED` to a non-zero value) and you'll get repeatable hash key randomization.
&gt; you just feel a compulsion to talk about things you have no clue about. Not especially. And I don't even find this discussion much more fun than training a misbehaving pet. srand() has existed for the exact reason I mentioned, for several decades. Perl's new pile of environment variables, which will probably just change in a version or two, are just a nuisance until I un-break them in various config files. If you're experiencing a DDOS attack exploiting hash order (how many of those have you seen?), just set PERL\_RANDOMIZE\_HASHES=1 and be done with it. 
Is there anybody who can still tell the difference between perl 5.12, 5.14, 5.16 and now 5.18? I know I can't.
You can just `perlbrew install 5.18.0` now
So they broke perl. See also the hash ordering stuff. Note that their changes only trivially enhance security.
The built in doc has lots of tutorials in it they are available at http://perldoc.perl.org/index-tutorials.html. Google searches for perl tutorial return lots of results. Two of my favorite are http://perlmaven.com/perl-tutorial and http://www.perl.org/books/beginning-perl Also if you are anywhere near Austin TX the first week of june one of the main perl developers conferences is being held there. http://www.yapcna.org/yn2013/
What the hell do you mean 'old school'? This is the idiom I use all the time and I'M NOT OLD!
Me too, except I always bless $self, ref($class) ||$class;
Why not use Moose?
Using blessed array/scalar refs just introduces more complexity to a language that really doesn't need it.
As typical, I can completely disagree with that. You're using nasty positional attributes (how do I know that the parameter in index 2 is $b?). For your example, I'd much prefer to encapsulate my return value in a simple object, and have a property to determine whether it's successful or not (or even always have it successful and have it throw an exception if it's not successful... depending on what "not successful" means in this context). Ah well, apples and oranges. package MyResult; use Moose; has 'is_success' =&gt; ( is =&gt; 'ro', isa =&gt; 'Bool', default =&gt; 1 ); has 'a' =&gt; ( is =&gt; 'ro', isa =&gt; 'Str' ); has 'b' =&gt; ( is =&gt; 'ro', isa =&gt; 'Str' ); has 'c' =&gt; ( is =&gt; 'ro', isa =&gt; 'Str' ); __PACKAGE__-&gt;meta-&gt;make_immutable; ... sub my_function { return MyResult-&gt;new(a =&gt; 'blah', b =&gt; 'foo', c =&gt; 'baa'); } my $data = $self-&gt;my_function; if ($data-&gt;is_success) { do a, b, c } else { do x, y, z }
It is still probably a good idea to familiarize yourself with non-Moose OO.
Which is why I use shell scripts for everything it's possible to do in shell; why add a dependency on perl? Perl is good, but it's one more thing to manage, so you should think if you really need it
&gt; flexibility, simplicity and speed. Just thought I'd point out that Mo is essentially the same speed as raw blessed hashes, and even full Moose once you make_immutable is not far off.
Oof. I'll take my downvotes like a man. For the record I also disliked it in the context of Apple System Folders back in the day. 
Typical sh scripts still use awk/sed etc which makes it difficult to choose between sh and perl for me. I typically stick with sh for cross-platform stuff and perl for single-platform.
&gt; if something makes sense as a shell script then I would do it as that. Totally, and if it's easier to do in perl, or means you make something more expressive, succinct and so more easily maintainable, perl is clearly the right choice. Even if it does add that dependency on perl 
More complexity than meta-objects and an ad-hoc type system?
woohoo!
Most definitely. You never know what your production environment is like.
Why? (I know what it does; I'm curious as to why you do it?)
Most certainly. Not knowing Perl OO would be like not knowing SQL while using DBIC, or HTML while using a WYSIWYG editor.
Um, Dancer is in the list...
And why would you ever want to do that? Why perfer that over `$class-&gt;SUPER::new`?
you should back that up. as far as we know the changes drammatically enhance perls security. if you have information to the contrary (and i bet you dont, but im willing to give you the benefit of the doubt) please send information about your attack to the perl security group and we will do what we can to mitigate the attack. since the hash behaviour is now random we can make any changes we wish to the hash function even in a mnor release.
I'm afraid this post itself wont be immediately helpful, but generally: * "Help needed" isn't a very productive title. It just distinguishes your post from those offering articles and suchlike, and highlights it as one that's probably not had much thought put into it (which, then, leads to the assumption that not much effort has been put into finding the solution yet). I don't mean to say that's necessarily the case here, but it's a likely first impression. * When you have existing code that you wish to modify the behaviour of it's best to show us the code you've already got. There's a few ways to do any given task in Perl, and it's not overly useful when we offer modifications to the way we do it if it's not the way you did it. Generally, we only need the smallest snippet of code that explains what you've done, along with any supporting information (like which module you've used to get a particular object). 
Were I to attack something like this, the first approach I would take is to not directly attack the hash but rather points where the code uses references to it, likely an iterative loop. Ultimately at some point you end up with a useful memory location and can gain access to the contents of the hash completely bypassing the randomization.
As I understand it, the exploit is a remote vunerability you can perform without seeing the source code. By providing data you know will eventually go into a hash, you can perform a denial of service against vulnerable code simply by understanding the properties of Perl's hashing strategy.
Wouldn't a significant part of the decline in searches come about as people master the languages? You're far less likely to search for something you already know and understand than something you don't. Additionally, mature code bases are going to largely be maintained by the developers who created them, who by now are far better with the language than when they started.
Perl, Python and Ruby, all have have an emphasis on packaging and centralised repositories [metacpan](http://metacpan.org), [pipy](https://pypi.python.org/pypi), or [RubyGems](http://rubygems.org/). These take traffic away from google; particularly once you've mastered the core language and built-ins. The same isn't as true for PHP; which has a far bigger built-in library and fewer centralized resources.
Respect for not backing down. Now that we're hidden from the masses, I'd like to ask you this: **[What do you think of faster-than-light non-physical communication?](http://www.youtube.com/watch?v=V7V6D33HGt8)**
Not everyone had root access. Not everyone has enough competence to do a local install. Not everyone has enough competence to extract the correct files to the correct places to make it just work anyway. Years of writing code targeting shared hosting environments has left me a tad jaded.
WHAT YEAR IS IT?! ;) On a serious note, I wonder what effect this might have on all the people still inevitably using it at $work.
I'd rather have CGI.pm split into several modules in core (for example a module for parsing, a module for cookies, a module for file uploads and, deity forbid, a module for generating html using functions), than the bulky CGI.pm itself.
All I ever use CGI for is retrieving query string parameters. use CGI qw(param); am I loading 5000 lines when I do that? Surely it's split and only loads that subset of code. And what would I do instead if it wasn't there? A lot of very useful stuff goes on in that little command. Security, handling duplicate param names, grabbing both POST and GET. 
Don't do much dotnet coding, eh?
&gt; Am I loading 5000 lines when I do that? Yes. (Assuming CGI.pm is actually 5000 lines...) use CGI qw(param); is exactly equivalent to BEGIN { require CGI; CGI-&gt;import(qw(param)); } `require` loads the specified module with the `do-FILE` mechanism. In effect, it's running an `eval` on the file's contents. If you want to split query parameters of a URI for a client-side script, you'd be better off using something like the URI module. If you want to get parameters for incoming requests because you're running a web server, you'd be better off using one of the several viable web frameworks on CPAN.
&gt; Surely when you are writing code targeting shared hosting environments you expect to synchronize more than one or two files with the remote host. While this is true, users *still* struggle with simple things like, oh, I dunno, FTP ASCII mode vs binary mode. Normal, non-developer users aren't trustable to get these things right. The less I have to have them do to get things to Just Work(tm), the easier it is for everyone. We actually ended up bundling specific CPAN modules, including a cut-down CGI.pm with our application. I'd imagine that this is not an uncommon pattern...
&gt; We actually ended up bundling specific CPAN modules... There you go! Throw in Plack and deployment magically gets easier.
&gt; require loads the specified module with the do-FILE mechanism. In effect, it's running an eval on the file's contents. Isn't there some kind of splitting of code into seperate files, and a lazy-loading process which only pulls up the code which needs importing? I definitely read that somewhere. &gt; If you want to split query parameters of a URI for a client-side script Client-side? Did you mean server-side? &gt; If you want to get parameters for incoming requests because you're running a web server, you'd be better off using one of the several viable web frameworks on CPAN. This is what I think is nuts. If I use Catalyst, I'm loading about five *million* lines. Catalyst needs to run in mod_perl/as its own server or whatever, because it's frigging *enormous*. All I want to do is display a form or two to the user, and parse out the form response safely and reliably. I don't need a million lines of Moose and 473 other modules to do that. Maybe I should just stripmine the param-parsing code out of CGI.pm and make it into a local lib module. 
That's definitely the right way to go. 
Would you like help me through installing CPAN modules on a shared host, no root, and Perl 5.6?
[CGI::Simple](http://search.cpan.org/~andya/CGI-Simple-1.113/lib/CGI/Simple.pm) is what you need.
I'm no perl expert, but as I understand, grep takes a sub and a list as arguments, feeds each member of the list to the sub as $_ and keeps it if the sub returned true. The `{ /re/ }` form is a consequence of this, rather than an intended effect. What would you want your mygrep to do?
The trick is to use function ~~signatures~~ prototypes, which aren't used very often in perl. Telling perl your function takes a function followed by an array will change the parser so that it lets code call your function just like it was grep or map: use strict; use warnings; sub my_map(&amp;@) { my $callback = shift; my @b; for my $a (@_) { local $_ = $a; push @b, $callback-&gt;(); } @b } sub my_grep(&amp;@) { my $callback = shift; my @b; for my $a (@_) { local $_ = $a; push @b, $a if $callback-&gt;(); } @b } use Data::Dumper; print Dumper [ my_map { $_ * 2 + 1 } my_grep { /\d+/ } qw(1 a 2 b 3 c) ]; 
Looks good. The bits I need and much less of the bits I don't need. 
Now we're just being silly.
Silly or not that's what I spent most of yesterday doing. Ended up saying "fuck it" and using my own server in an iframe. Life's too short and my client's too cheap. 
Not from my perspective. My most recent ICT role involved being in a similar position to BonChicBonScott, the difference being that it was Perl 5.8.8. Yay RHEL's Perl policy. :-/
What is wrong with CGI.pm exactly?
Excellent! Thank you! I knew there was going to be a way to do it.
Not that silly, sadly. Move it up to 5.8.8 and you've got yourself "downright common", honestly. 
I read their list of gripes and for the most part I was laughing at them. I looked at the top to make sure this wasn't an April Fools joke. 'Difficulty configuring CGI?' It's on by default on any apache instance! 'You have to know too much about the CGI protocol?' No more than anything else. And I'm supposed to abandon countless sites and rewrite them with a new framework? Yeah, I think not.
&gt; And I'm supposed to abandon countless sites and rewrite them with a new framework? Who said that?
... which is irrelevant to this discussion, because by the time 5.20 has replaced 5.6 in Enterprisey Distro Magic Antique Shop Land, most of us will have retired.
I think I first started using CGI.pm in 1996. Since then I've used it for everything that needs some html interaction, including several business apps. The only thing that bothers me about this announcement is the idea that I or someone will have to rewrite those business apps. At least we have a year or so to do it. Maybe longer. One of those apps is running on Fedora 9 because, if it ain't broke... So what's the recommended web framework these days?
If you use Catalyst for something like that, then yeah, you're shooting yourself in the foot. Better options would be Web::Simple or Mojolicious::Lite. But if you're familiar with CGI.pm, then by all means use it. It works. As said in the first message in the linked mailing list (which you should probably read if you haven't): &gt; If you need CGI, it's easy to install after installing perl, just like everything else we've dropped from the core distribution. It's not something I or many other people would call a core module anymore.
That's what I've been using. Interesting though, while CGI.pm weighs in at 8149 lines and 256k, CGI::Simple.pm is still 2900 lines, 123k. Which still seems an awful lot just to parse the query string. 
/u/strawman
cpanm CGI
&gt; Luckily noone uses cgi anymore. Fortunately, you can still install it from the CPAN, just like DBI, even though everyone uses NoSQL instead anymore.
Just a small nit. They aren't called "signatures" they are "prototypes." And they give hints to the parser to allow subs to be called with arguments without parentheses. And there is apparently a large regret in even calling them prototypes considering the dissonance with other programming languages in how the term is used. 
As well as tchrist's [FMTEYEWTK about prototypes](http://www.google.com/url?q=https://groups.google.com/d/msg/comp.lang.perl.modules/SVhwH2tRVaM/WwgB6-VNSIQJ&amp;sa=U&amp;ei=X5mjUdmICKaH0AXSyYC4Cw&amp;ved=0CBsQFjAA&amp;usg=AFQjCNGJEBhBZ-az_vu4WgWYVU1jfByEkw) (This is the original; later the FMTEYEWTK articels were grouped and posted on perl.com and on CPAN)
You're right. I fixed my comment.
Because the tide turns. Sure, if I upgrade I can pull CGI.pm in from somewhere, but eventually support fades and the complexity of using an old, lesser-supported package is no longer worth it. I understand your point that the old code will just continue working, but these apps are in a constant state of change.
Thanks! I think I saw a demo of Mojolicious a while ago. I'll take another look.
&gt; ... eventually support fades and the complexity of using an old, lesser-supported package is no longer worth it. That's a good description of the state of CGI.pm right now, though. It seems to get a bug fix or security patch a couple of times a year.
Hear, hear! This is the state NOW. The problem is that since it is in the core people think that its blessed by p5p, when in fact its been on life support for a very long time. People are still starting new apps in CGI.pm because of this fact and all of that is effort that would be better put elsewhere! Support has faded and the complexity of using an old, lesser-supported package is no longer worth it.
I have been trying to get into Mojo but I have been having a hard time relating the syntax of Mojo::Lite to Mojolicious (with regards to routing). It seems like a majority of the screencasts and tutorials are geared toward Mojo::Lite. I guess I have gotten spoiled to the syntatic sugar of Catalyst and its built in dispatching.
Also, I know about placing DoEvents() in the mainloop, but it slows down the processing quite a bit and does not help during page retrieval.
I know about Mechanize. I'm using it. It's in the code above.
I've also tried Win32::GUI::Timer (putting the dequeue and append command in the _Timer sub). It still seems to freeze when pages are being retrieved.
CGI has never been removed from Apache. See https://httpd.apache.org/docs/2.4/howto/cgi.html. I doubt Apache would get rid of it anytime within the next decade or two given its importance and usefulness.
Anything that works with Plack. I've been using Poet as a framework a fair bit, but there are plenty of others.
got an answer from perlmonks: http://www.perlmonks.org/?node_id=1035533 
I've done something similar before but I put the gui in a child process and communicated between the two with AnyEvent. use common::sense; use Win32::GUI (); use Storable use AnyEvent; use AnyEvent::Util; use AnyEvent::Handle; my $gui_handle; my ($parent, $child) = portable_socketpair(); run_fork { child { use GUI; GUI::run($child); } }; my $parent_reader = AnyEvent::Handle-&gt;new( 'fh' =&gt; $parent, 'on_read' =&gt; \&amp;on_read, ); my $exit = AnyEvent-&gt;condvar; $exit-&gt;recv; sub on_read { my $self = shift; $self-&gt;push_read('storable' =&gt; sub { my $data = $_[1]; #process data from gui #maybe send a response return 1; }); return 1; } sub send_gui { warn 'GUI Handle not defined.' &amp;&amp; return 0 if !defined $gui_handle; my $message = freeze \@_; Win32::GUI::PostMessage $gui_handle, 1030, length $message, $message; return 1; } #then inside GUI.pm sub run { #defined globally $child_handle = AnyEvent::Handle-&gt;new( 'fh' =&gt; $_[0], 'no_delay' =&gt; 1, ); #defined globablly $main = Win32::GUI::Window-&gt;new send_main('handle', $main-&gt;{'-handle'}); #add buttons or whatever #listen for messages from AnyEvent $main-&gt;Hook(1030, \&amp;on_read); $main-&gt;Show; Win32::GUI::Dialog(); send_main('exit'); exit 0; } sub on_read { my ($self, $length, $data) = @_; my $data = thaw unpack("P$length", pack('L', $data)); return 1; } sub send_main { $child_handle-&gt;push_write('storable' =&gt; \@_); return 1; } In the main process I used AnyEvent::HTTP and there was no lag on the gui part while it was downloading pages.
I had not heard of this module before. Thanks for pointing it out! :)
I thought this was a help request with a punctuation error. I was going to suggest the following: perl -e 'close STDIN; open STDIN, "&lt;", "256colors2.pl"; exec "perl";' 
I pipe to `perl -lne` almost every day. Lots of things I could do in shell, but it's quicker to slam out the perl.
It's time to get honest with yourself. You either like working with computers or you don't. Kind of like me and -- well, plants. I get that you like this professor. And this job sounds like a good opportunity, botanically speaking. But now you're saying two things that don't jive with one another. One, that you need to learn Perl, like right away. The other, that you're "computer illiterate" (one of my least favorite phrases, especially in this day and age). I read a [great post](http://www.businessinsider.com/learn-basic-programming-2013-1) not too long ago, in which the author told a story of a lesson he had learned while taking guitar lessons. “You need to learn to sing. Because if you don’t, you’re always going to be at the mercy of some asshole singer.” He used this quote to make a point. Everybody who wants to be useful in today's workforce needs to learn to code, at least a little. Because if you don't, you'll always be at the mercy of some asshole programmer. And I'll tell you what: If you can learn to put that "computer illiterate" bullshit on the shelf, and learn Perl -- yes, in 2013, learn Perl -- you may just find one of these days that people find you to be a rock star. Perl is incredibly useful. This professor you dig... he finds it useful. There's probably something to that. Oh yeah, like I said. You either like computers or you don't. So if you don't, then don't bullshit yourself. Just keep rockin' that "computer illiterate" swagger, and flaunt that mediocrity in the workforce. You'll fit right in. Good luck to you. 
another good one (especially for bioinformatics): http://www.amazon.com/Beginning-Perl-Bioinformatics-James-Tisdall/dp/0596000804/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1369804508&amp;sr=1-1&amp;keywords=perl+bioinformatics 
Indeed. The comment of mine you replied to was a facetious parodising of the comment above which is now deleted. In that comment, which for some reason got a lot of upvotes, the author waxed lyrical about how Moose is a bad idea because it adds a dependency to your code which just gives you one more thing to manage, so you should really think about whether you need it before using it. Which to me seems somewhat weird; cpan is a massive part of what makes perl good. Avoiding making use of it is a massive waste of developer time imho
Another one found out that making a Perl clone is frigging hard. Check out Compiler::Lexer for the latest attempt. 
Since you're the author, why not simply use `do "print.txt";`? Also, i'd suggest IO::All instead of File::Slurp. :)
*mind blown* - fantastic tip, had no idea about that. Thank you.
To misquote Brian Kernighan, I wonder if parsing a language is twice as hard as writing code in that language, then if you write the language as cleverly as possible, are you, by definition, not smart enough to parse it?
Not much.
So, I would recommend taking a look at [POE](http://poe.perl.org). There are a number of articles that explain how to accomplish network programming in an event-driven way. Specifically, I would look at [The Evolution of a POE Server](http://poe.perl.org/?Evolution_of_a_POE_Server).
[Network Programming With Perl](http://www.amazon.com/Network-Programming-Perl-Lincoln-Stein/dp/0201615711/ref=sr_1_1?ie=UTF8&amp;qid=1369858729&amp;sr=8-1&amp;keywords=network+programming+with+perl) Most of the lower-level network-related functions/modules match the traditional BSD Sockets API naming, so any C sockets reference is pretty translatable into perl.
You probably want to start looking at Object::Remote, if you plan to grab data from remote systems via SSH.
POE is worth looking into, but also have a look at MooseX::POE. Using POE's API on the low level is pretty arcane but using MooseX::POE or a similar abstraction layer makes it almost pretty!
You are quite right. No existing virtual machine is a good match for Perl, except perhaps Lua, and a Lua implementation offers no compelling advantage over a C++ implementation. AFAICT, anyway.
Dammit! Why can't I ever used "waxed lyrical" in a sentence?
I love how you used so many words to show your ignorance.
I know of several active projects related to alternate Perl VMs and implementations. Some of these projects are scheduled to be discussed as part of the [Perl Neighborhood track](http://www.yapcna.org/yn2013/talks#182) of YAPC::NA 2013 in Austin, TX next week. And before that, at the [Hackathon](http://www.yapcna.org/yn2013/wiki?node=Hackathons) this weekend that kicks the conference off, the main focus seems to be Perl VMs. (Note the mention of Topaz). So if you want answers about Topaz, or Perl VMs or re-implementations in general, somehow getting (virtually) connected to the Hackathon this weekend seems the way to go.
In some ways, that's good. Rapid release, small changes, no earth shattering ones... You're right though. I have no idea what the difference is (other than looking up the deltas).
Have you looked at [Mojo::Parameters](https://metacpan.org/module/Mojo::Parameters)?
I've got that book on a shelf near my workstation at work. It was really useful when it did came out. It did a lot to tech to write perl programs in a clean and simple style, AND to learn network fundamentals. It is pretty old, from 2001, and I have not opened it in a long time, but I think that a good chunk of it is still relevant.
OK, this is pretty interesting. I took a flyer and sent emails and my resume to a bunch of companies in Scandinavia.
**Update:** "MoarVM reboots the whole VM idea for Perl". Perhaps [Carl Mäsak's initial blog post on MoarVM](http://strangelyconsistent.org/blog/a-vm-for-6model) is a better starting point. Jonathan's introductory link for those interested in [MoarVM, a new Perl 6 vm](http://6guts.wordpress.com/2013/05/31/moarvm-a-virtual-machine-for-nqp-and-rakudo/), announced the day before the hackathon begins.
nginx is rising in popularity. It might take the #2 most popular web server spot from IIS in a few years. It doesn't appear to support CGI out of the box. Even in Apache, it's a modular feature. You could not load it and never miss it for most part. CGI's days are definitely ending.
Will it be ready by Christmas?
A confusing API with a bizarre implementation and some poorly documented features. Do you know what the CGI.pm `cache()` function does? 
ha. Not a clue. Point taken! What are the alternatives?
**Updated with couple clarifying details in italics** Good questions. The focus of the core Rakudo team is to have one backend that works. Until one works, they either need to fix one of those that doesn't or build one that does: * Currently, Parrot's design and implementation are deficient in major ways (eg speed) relative to Rakudo's needs. In addition, it is a relatively large and complex project with a great deal of technical debt. The core Rakudo team were and are not interested in the dangerous strategy of putting all their eggs in the Parrot nest while it is so deficient. * The JVM works, but will never work adequately for some users and scenarios. Development time attributable to JVM per se (as against to making NQP portable in general) is a few weeks and easily justifiable. The JVM was never intended to be the solution to the Parrot problem. * MoarVM is the core Rakudo team's new *(14 months old)* approach to both mitigate the Parrot problem *and address other known issues (eg directly addressing 100% p5 interop, especially XS)*. * Folk outside the core Rakudo team continue to work on other backends. For example there's a GSOC project to create a JavaScript/V8 backend *(for NQP; a Rakudo on JS/V8 would be a natural next step)*.
Young (and promising) startup here. All our services are built with perl, and more specifically Mojolicious and POE. The stability, maturity and rich eco-system of Perl make it a good choice to use professionally.
I user Perl on a daily basis at my job. Fortune 1000 company.
Same here. 
Sysadmin for a regional ISP in New Zealand; I script most things that aren't web interfaces in either Perl or Bash.
Hi, awesome that there are startups using Perl. Would you mind sharing in which industry are you working? Country or continent would be useful too. 
In couple of days, no more than week, will publish results of the survey in this thread. 
I am in the company and team that develop Movable Type - a Perl CMS. So it is Perl everyday for me, but also JS and a bit of PHP. 
I work in BioInformatics and develop Perl code for data migrations into an application with a MS SQL backend. I connect to Oracle, MS SQL, Excel and LDAP as data sources and targets. I use ActiveState Perl and compile these apps to run as scheduled tasks on Windows servers.
Not yet, but this summer I'm going to be interning at a well-established company in the UK which primarily uses Perl for all of their services.
SaS company with about 200 employees worldwide in the recruiting/HR industry. Our Entire product line/system is in perl.
Website developer here. I was hired into my last job because of my perl knowledge (6-7 years ago). They had no-one left who knew it. They had already switched to PHP. While I was there, I learned PHP and became their head PHP guy, and PHP has been my primary language since. There are still a handful of legacy maintenance scripts that run on perl, but newer scripts are done in PHP since they can share the same config files. I'd still gladly use perl for any tasks for which it is best suited, but none of tasks are ones that my job entails.
Oh, Movable Type is Perl? Definitely going to look into that.
That's crazy. When I think about running regular batch jobs to process data, I automatically think cron jobs in Linux.
I use Perl at a big company to do all sorts of things from weather data to news feed processing. Some of my applications have been running since early 2000s, often without any issues.
I'm in the aerospace industry. I use Perl for a lot of data parsing/formatting, as well as using it as a driver to automate tasks in other programs.
I work for a very large OSS group and not commercially, but we use Perl in a few places. I personally use Perl for the software that is used to build the aforementioned very large OSS project.
Yeah I know. I have these scheduled tasks looking for source files in folders at regular intervals throughout the day. When it sees the files it parses and writes data to the database. 
Our primary apps are in java and c++, but we use perl on production customer servers for lots of misc glue jobs, reports, etc. as well as for building releases.
Sr. Unix System Admin for a global company with &gt;100k employees. I/we use perl for quite a lot of our Linux related solutions.
same here, except i'm a master's student. I use it for file processing geological data.
I work in the network engineering department at a large university. We use perl all of the time, mainly because when it comes to doing string manipulation and parsing its hard to beat. My biggest use is working on [NetDB](http://netdbtracking.sourceforge.net) which we rely on heavily for tracking devices, on over 1400 pieces of networking equipment. 
I've been writing perl since 1996. My current company (only two developers, web development sort of) uses it for pretty much everything on the server side, unless it's incredibly performance intensive in which case it's C++.
Founder/lead developer at a small (7 guys) web development company in Poland. We've been using Perl in various projects, mostly as part of the web application backend, or as a web services platform (courtesy of Dancer). Some of the scripts that make up our internal toolset are also written in Perl. Although it's currently not the most used language in the company (at the moment that title belongs to JavaScript), it always played a significant role and will definitely continue to do so.
I'm working at a successful London web-based company where Perl is the sole language used (apart from javascript in webpages). There are 12+ Perl devs currently. This follows on from working at another successful London all-Perl company bought by Amazon a couple of years ago. 
I've had the same thoughts. But the cost of migrating/rewriting a giant system in another language would be absolutely outrageous (plus training all the ops people who know a smattering of Perl in a new language...) So I spend time instead mitigating technical debt and modernizing the system as best I can: using modern Perl practices, refactoring using objects, DBIx::Class, etc., writing unit tests (imagine that!), stripping out custom code in favor of frameworks and CPAN modules, writing POD documentation, encapsulating duplicate code, etc. etc. I've made progress. My successors owe me big time. 
I'm at a forture 500 and we use Perl as the glue that keeps everything together. Unfortunately everything is run on perl 5.8 which make some tasks a pain. 
I use Perl as a day trader on the Foreign Exchange market. Many brokers have [Forex APIs](http://forexfeed.net/developers/perl-forex-data-feed-api) that allow for data to be streamed and manipulated. I've written a couple scripts using these APIs to set trade levels based on daily thresholds and market volumes. Perl has saved me a ton of time by allowing me to automate majority of my tradings. 
It's frequently said that you can write bad code in any language. Perl offers flexibility and relies on the author to not be an idiot. Most other languages have some safety railing built in to prevent terrible design. Perl's all, "You want to fuck with the symbol table? K. It's a bad idea, but go ahead," and suddenly, things like "print" don't do what you thought they did. When leveraged correctly, that's _awesome_. Things like Moose and POE and Catalyst and Plack happen. When an idiot tries it, you end up with things like the codebase I get to work with daily.
Big data company that uses perl for our ETL.
Perl is the second scripting language for our Linux servers (after shell script obviously) so I use it on a daily basis. We got around 3000 servers and about 500 employees.
Perl at a mobile video game startup here. I use it to parse JSON, to script other processes (hadoop jobs mostly), systems management, and glue different systems together. 
Perl 5.10 at a financial institution in TN. Automating file conversion, import, export, and transmission of data.
If you have not tried it, have a gander at [Perl Data Language (available from CPAN)](http://pdl.perl.org) - it makes numeric stuff a lot easier and faster!
I use it professionally, but I work in a smaller company where we use pretty much whatever we(the dev team..which is now down to two people including myself) want as long as it does what the boss asks for. We're by no means exclusively a perl shop, but currently the most important thing we do runs through a Catalyst based backend. Though that is getting rewritten in Go.. 
I use Perl on a day to day basis - usually to the shigrin of my coworkers, who usually prefer an "enterprise" solution for every one off task. Ive made believers out of some by just using cli tricks, like perl -pi -e and showing them how quickly we can prototype fake endpoints for some of our larger rest api's. To be honest in the ten years or so ive used Perl, its been a language that has "just worked" and has saved the companies ive worked for more money in man hours then they probably ever tracked.
I use Perl daily in managing a 3k+ node network usually on an ad hoc basis, writing one off scripts as the need arises. At a Fortune 200 company in the US, did the same at a Fortune Global 100 previously.
Most of my day job (not in term-time when I'm being a student) is Perl -- various automation bits and bobs relating to chip manufacture and instruction set-wrangling.
Use it whenever I can. Only person that uses it. 20 person Federal Gov't contractor Yes, Perl is used for projects for clients.
Daily at job and on phone systems handling thousands of calls/hour.
Yep
I do computation biology research at a university. I use Perl for data manipuation and glue for analysis pipelines.
I'm a computational chemistry research student. I use perl for automation and because I had a program that I only changed one or two strings in the program, so I made a template and used perl.
200+ person company and our main service is written in Perl, so I use it daily and enjoy it immensely.
So is the remote box running an SSH server? or an FTP server perchance?
What he said. (use some ksh scripts but anything I write is perl because I'm stronger in it (AIX or I'd use python probably))
I worked in digital forensics last summer writing Perl scripts to extract data from iOS images and backups
I lead a department of perl programmers.
I'm effectively a freelancing (legally a full Canadian corporation, but it's just me, myself and I) sysadmin in Montreal -- I tend to use Perl (and Haskell) in various one-offs. The usual sysadmin stuff, the odd test dataset generation (say, generate 20T of CSVs for a sort benchmark on a hadoop cluster), etc. Throwaway code that somehow ends up as a major load-bearing component (except that sort benchmark generator).
I work for Spokeo.com. We are primarily a Ruby on Rails shop, but we use Perl for a number of backend processes and the DevOps team uses Perl heavily for most of their work. On the backend we do a lot of natural language processing all in Perl.
Opera Software uses Perl in several key components, serving hundred of millions requests each day.
Although I've been working at a Microsoft shop for a couple of years and I tend to not contribute much to the code that my team works on, I still use Perl every day. So yes, I use it professionally, because I use it to do my job. On a funny side note, I saw a "Perl Scripts" directory recently added to my team's current project (complete with the capital letters and the space in the directory name -- ugh), because I had given them some sample code as a starting point, and they just kept it in Perl. Well, it relies on my Data::Maker module, so I guess they had little choice, unless they want to port it to C#.
I wish. :( Using it for personal projects so far because I just love it. Been poked by headhunters from a big online travel agency because of it.
If you are monitoring anything with SNMP the Net-SNMP tools has a [perl module](http://net-snmp.sourceforge.net/docs/perl-SNMP-README.html) wrapper.
&gt; The signature seems to start with an R, More specifically, it looks like a stylized "RS" turned into a single curving line.
That's Merlin alright... did you buy the book used?
OOP, heavily structured. We have roughly 7 million LoC. We serve about a trillion requests per day if you count our ad servers. around 300 million req/day if you don't.
And how do you find scaling, team-wise, with Perl? What city are you based in?
we're in the san jose CA area. I find scaling the team to be just fine. Set some standards and do code reviews to make sure they're adhered too. The ones I've set leave some room for personal style so nobody feels like creativity is stifled. Just some overarching guidelines to improve maintainability and performance scalability.
Use Perl daily at a small startup, for web development alongside two Ruby guys.
Public utility here, used daily. 
Randal's signature [is certainly quite similar to that](http://www.vromans.org/johan/images/P5PR-Stonehenge-sig.jpg), as noted on [Johan Vroman's Squirrel Consultancy](http://www.vromans.org/johan/main.html) website.
Man, I wish I was doing Perl professionally. I'm stuck with Powerbuilder at the moment :'(
Please forgive the stupid question; with [Module::Build](https://metacpan.org/module/Module::Build) on the way out, [ExtUtils::MakeMaker](https://metacpan.org/module/ExtUtils::MakeMaker) being doomed (according to the original article), and [Module::Install](https://metacpan.org/module/Module::Install) being a fancy wrapper to MakeMaker what is the recommended install system nowadays?
Chip Salzenberg abandoned that in 2000 and gave a talk at OSCON on why C++ wouldn't be able to do the some things that the perl interpreter would need. Not knowing C++ well, the details escaped me, but they were particularly thorny problems related to types, as I recall.
"Merlyn"
So I follow that link and .. immediately feel the urge to look for what's going on there instead of watching the show. Let's say: * [LBJ Auditorium](http://new.livestream.com/accounts/3585172/events/2037842) * That gets some info from [here](http://new.livestream.com/api/accounts/3585172/events/2037842/viewing_info), that's: `$pageURL . "/viewing_info"` * From where I grab the parameter [play_url](http://api.new.livestream.com/broadcasts/20628881.smil) .. * .. and stitch that together as: `http://livestream-f.akamaihd.net/3585172_2037842_66715307_1_2096@108752?system-bitrate=2096000` .. which now can be opened with VLC, et.al. Unfortunately from my side of the internet the result is as choppy as the webpage embeded live streaming from the first link and needs frequent reloading, bummer .. But I'm really happy that there is live streaming going on! Thanks a lot, dear organizers of YAPC::NA::2013! And: &gt; If you're watching this video remotely, please consider a donation to The Perl Foundation to offset the costs: [Donate via donor.com](https://secure.donor.com/pf012/give)
If you are SSHing to the machine you can use, [Net::SSH::Expect](https://metacpan.org/module/BNEGRAO/Net-SSH-Expect-1.09/lib/Net/SSH/Expect.pod)
Startup Company here, 90% of our backend is Perl for our social search engine. http://theenginuity.com Stability, speed and most of all productivity was why Perl was the best tool for the job for us with some of our engines like sentiment analysis.
If you are running Perl 5.6 and will not upgrade, why do you care what comes in 5.20 core?
My client has bought a crappy hosting plan, that's all. Rather than try to explain why they should move to a new host I tried to work with it. But it was a pretty bad strategy, you're right. 
Use it for a Fortune 500 company. Wouldn't do my job without it. Mostly use Perl for automated deployments, load testing, and as a glue to hold all the bullshit java applications together.
The discussion of Perl 5.6 just *came up* in a discussion of Perl 5.20. Do you not understand how conversation works?
I realize I'm 3 weeks late to this party.. but really, you removed render_json? -_- at least through deprecation notices for a release.
Or you can just go 8 years back in time and use inside-out objects. 
Yep. I use Perl at work. Smallish team in a big company.
I admit I haven't really looked into this nor even used a version of Perl where smartmatch exists, but I'd turn this into a lexical feature where the nature of the match is determinable at compile time with no runtime capability. For instance, $a ~~ $b is never valid because it is not possible to say what this should do at compile time, or what the expected type of a or b should be. As an example, $a ~~ [...] could be defined as a grep looking for that value in the provided list, and would always coerce $a to a string. I suspect this sort of proposals are already out there, though, and there were probably arguments that shot down lexical/compile-time determined behavior.
&gt; nor even used a version of Perl where smartmatch exists You've never used perl &gt;= 5.10.0 ?
With regard to http://www.effectiveperlprogramming.com/blog/1333 when running the first example: use v5.10; my $s = "abc"; try_given($s) for 1 .. 3; try_do($s) for 1 .. 3; sub try_given { my $s = shift; state $n = 0; given ($s) { /./g; printf "%d. given: pos=%d\n", ++$n, pos; } } sub try_do { my $s = shift; state $n = 0; do { my $_ = $s; /./g; printf "%d. given: pos=%d\n", ++$n, pos; }; } on v5.16.3 I do not see the behaviour as detailed on that page, out put I get is: 1. given: pos=1 2. given: pos=1 3. given: pos=1 1. given: pos=1 2. given: pos=1 3. given: pos=1
That is the case. I think the update attempts at work were foiled by some changes related to the compile-time pseudohashes, which we were using. We are planning on migration to 5.14 or 5.18 or something such, but it has a low priority.
Ouch, you have my sympathies
given's $_ handling was fixed in 5.16 (https://metacpan.org/module/RJBS/perl-5.16.0/pod/perldelta.pod#given-and-when ) and in 5.18 (https://metacpan.org/module/RJBS/perl-5.18.0/pod/perldelta.pod#given-now-aliases-the-global-_ ).
As the OP, getting away from Perl has been a goal for the past year or two for me personally. This pretty much serves as the last nail in the coffin. The Perl development cycle is an abhorrent mess and I'm sick of it. What the hell is `use features` anyway? From 5.10 to 5.10.1 they redefined the way Smart Match worked entirely. From 5.10.1 to 5.18 nothing was said anywhere of a problem with smartmatch on the horizon. In 5.18 smartmatch is effectively deprecated but rather than coming out and saying it, they call it *experimental*. And, in 5.20 it'll be forever changed with the primary selling point -- syntax `@foo ~~ $bar` removed. So again, what the hell is `use features`? For years we didn't have `use features`? In between perl versions there was no assumption of backwards or forwards compatibility. Where did psuedo-hashess go? "Fuck off, they were a bad idea", -- Perl dev team. It was a big issue, but there was no veneer of deceit like `use features`. Use features is just a guarantee that you'll have to write another line of code for features you possibly should be using as a default (ie., `unicode_strings`), or should not be using at all (ie., smart match). I remember reading Learning Perl over a decade ago. In the book, it says the trick to understanding perl is to *thinking like Larry would*. Ok, well that's not really a rigorous definition but it worked well for me and for others. On the same merit, smartmatch worked well for me and others. It may not have been the right tool all the time, but for simple things it was often-enough the right tool to make Perl substantially more user-friendly.
I agree, `use features` is mad ghetto. It's like you're dragging your feet into the future.
Why would you use pseudohashes?
They provided us with lower memory consumption for objects as they were based on array references rather than hash references, faster runtime access, and per-class private fields. And yet the syntax was the familiar $self-&gt;{foo} even if it got turned into something like $self-&gt;[2] during compilation.
Remote Infra Management - 99% of monitoring is done via perl. 
Thanks for these links. I admit I've not kept up either but have been using this for many recent projects. I am a bit concerned.
Correct me if I'm wrong but I thought there was a recent effort to "rip-out" much of Parrot that was not relevant to Perl 6. Did this end up as fruitless?
Out of curiosity, what language are you moving to?
I am moving to Python, Go or Haskell. Not sure yet. :)
It never went anywhere. What was the point? [The Rakudo developers made it very clear they didn't expect it to succeed anyhow](http://irclog.perlgeek.de/parrot/2013-02-09#i_6432607).
Same for me. I had to watch it with [livestreamer](https://github.com/chrippa/livestreamer) which opens it up through VLC.
Thanks for the link. I have no idea the point nor do I have any idea the point of Perl 6 anymore either.
Well just don't pick Go or you'll be stuck in the same sort of language design ghetto (Ok ok, it's still a hell of a lot better than perl...)
Thanks for sharing. What was their talk about? Are many people using Perl with Cuda?
ECMAScript/Node, though I'd love to use Haskell more if I could wrap my head around it and start to feel comfortable with it. I'm pretty comfortable with Node, and with v8 supporting Harmony I have good reason to believe ECMAScript will march forward without the kicking and screaming found in Perl.
If you know Perl you pretty much already learned PHP :D I have learned a lot more about how CGI works using perl and C however. PHP is nice but if I am writing a web application that requires a more general purpose language Perl is where its at.
Another blog post says "[among the best and most thoughtfully organized technical conferences I have attended](http://www.sportsfirings.com/?p=10106)"
Doesn't that sort of obsolete a lot of CE/EE jobs in chip design in favor of programmers or do I just not understand enough about the hardware world? Not that there's anything inherently wrong with that replacement, it just seems like that should be bigger news. It doesn't seem like that bodes well for future CE grads.
Gonna guess it was originally a tweet with a hashtag.
Sensible. Or maybe they use Perl-sharp. 
I don't know much about the hardware world, either, but I think its been this way for a while. I suppose it turns CE grads into specialized programmers, really.
Is it too late to reply? Boston-area university, almost all of our in-house code is Perl. Very small web dev team. Fun fact: I never made it past my Associates degree, yet got hired at a 4-year university with no Perl experience and a bunch of freelance PHP under my belt.
Shhh! This is to be announced at BUILD conference(end of June) and a prominent feature of Visual Studio 2013.
I'm waiting for Perl plus-plus. 
Then I'm afraid you're always going to be disappointed by Perl 6, as there will never be an "official release". There will be a 6.0.0 spec, probably described in the upcoming months, with Rakudo as the current standard bearer. But any implementation that follows the 6.0.0 spec and passes the test suite is "official" enough for me. But you won't have to play games with different versions of implementations, either, because Rakudo is planned to run on MoarVM (C), the JVM, and even JavaScript -- the same implementation with a different backend. That should make the code more portable that ever. I'm honestly not sure what you expected from the OOP system. Everything is an object, so the MOP works throughout the code. I think that the implementation is simple to use, but the documentation is still lacking. Maybe if you have a chance to play around with all of the big features like grammars, built-in threading operators, and lazy lists you'd appreciate it more. But let's not expect too much from an alpha release -- and keep in mind that moar`^W`more goodies are coming down the pipeline very soon.
Ah, I see you're continuing your streak of reposting my blogs on /r/perl, raiph :) ^ is a great blog entry too. So many of the conference management details went right, for a larger than expected turnout, that I was impressed every day.
Perl + catalyst
&gt; I'm honestly not sure what you expected from the OOP system. Everything is an object, so the MOP works throughout the code. I think that the implementation is simple to use, but the documentation is still lacking. The object system is one of the few things I think they got right.
7pm I know a few people may be showing up a bit late. I'll be there and traditionally it's at 7.
I ended up doing just that, actually. Noticed #yapc tags and added that column in Tweetdeck.
Anyone know where their development offices are located?
&gt; Will Perl 6 have an argument here? That's a good question, in more ways than one. ;) I've followed Perl 6 on and off since the start. Here's my speculation based on watching very closely for the last 2 years: * **Now** No one is currently using Perl 6 to do much of anything, especially dynamic web page generation. The leading compiler, Rakudo, is extremely slow (around 100x slower for most things than the Perl 5 compiler) and that's not the only problem. Right now the emphasis is speeding it up and turning it in to a product for general use. * **Next 6 months** Based on the ground work done over the last 18 months it looks like Rakudo's speed and polish will improve a lot over the next 6 months. Maybe a few brave souls will deploy Perl 6 dynamic web sites by the end of the year. * **2014** I am optimistic that 2014 will be a great year for Perl 6 due to things like: * **More major speed increases.** Enough that it starts to execute at speeds comparable to Perl 5. * **Compatibility with CPAN.** Including XS. * **Outstanding Unicode support.** Enough to start building a reputation as an attractive text handling tool for roughly half the world's programming population. * **Publication of several new Perl 6 books** including an equivalent of the Perl 5 focused Programming Perl (the Camel book). * **Availability on the JVM.** 
Meh. If you are dealing with numbers and structured arrays you should be using [PDL](http://pdl.perl.org), not lists of lists.
&gt;That leads us to warning. Whyle (sic) Perl is ok with you having the exact same variable name for an array and for a scalar, it is strongly recommended you don't have them in the same code. It can just confuse the reader. In some cases I think having both @foo and $foo can make sense. foreach my $foo ( @foo ) { # Something mildly complex that could clobber $_ }
Why not pluralize: something like @foos ? for my $foo (@foos) { # do stuff } Reads pretty clearly. 
Sometimes it feel awkward to pluralise collections of things (arrays, database tables, etc.) - especially for things where the same word is used for both singular and plural. Not that I run into too many lists of sheep, salmon, or moose in my day job! It's also one of those religious things for some people.
Thanks for your feedback! I can't get insight like yours from reading on my own. &gt;Any particular reason why you've used a labeled GETINPUT loop? I labelled the loops because in an earlier version I had nested "while" loops and I was using "next" and "last", so I wanted it to be clear which loop these commands applied to. But now they're superfluous, and should be removed. &gt;Also, why are you calling _translate_move with '&amp;' prefix? I thought that's how subroutines were supposed to be called. Maybe I was reading from an old source, or about an older version of perl. Without knowing more, I like the '&amp;' because it shows that a subroutine is being called rather than something else. It sounds like this is bad practice though - Is that by convention or some other reason? &gt;You're also using $self-&gt;{keys} mixed with accessors. Unforunately, my being a novice shines through here: I don't know that means ("mixed with accessors") . . . :( Is it incorrect because I call methods on the object and call attributes of the object? It looks like I could also update attributes with something like: $self-&gt;attributename("New value"); Is that what I should have been doing?
I don't find myself wanting multidimensional arrays often, mostly using arrays mixed in multi-dimensional hashes. Here's a rough sample of one I did recently (past 2-ish months): Key -&gt; Value (key ref) -&gt; Value of 2nd-level key (array ref) The first "Key" is a filename (without extension), the value is a hash key of a file related to the first (CSV file that contains the base filename in the name), and the array ref are values from the CSV file.
Oh, one more thing: `no Moose;` is better implemented by having `use namespace::autoclean;` at the top of your class, and `__PACKAGE__-&gt;meta-&gt;make_immutable;` at the end, before the `1;` https://metacpan.org/module/ETHER/Moose-2.0802/lib/Moose/Manual/BestPractices.pod#namespace::autoclean-and-immutabilize has more :-)
Thanks!
Thanks for clarifying! I don't know what happened there. Maybe I was reading some non-Moose OO documentation and got them mixed up? I meant to use Moose's autogenerated accessors.
Last time I looked at that (a good few years ago) it already looked as if it had been abandoned for some time. At the time I gave up on it pretty quickly as it didn't seem to work very well (if at all). If that *is* the case, then I would imagine anything you manage to install will be aimed at a much older version of Qt than you've got installed, so I'd be surprised if it works (or at least, works well).
There are a few QT bindings for Perl out there, or at least a few pages that seem to talk about different projects. The Sourceforge project seems specific to QT 3. [This PerlQT](https://code.google.com/p/perlqt4/) seems to be the official QT 4 binding as far as the KDE project is concerned, since it's been merged into kdebindings. I expect it will support QT 5 when the KDE Bindings require that QT version. I was able to install perlqt on my OS X system via MacPorts and run the simple "Hello World" script listed at [the KDE Bindings page for Perl](http://techbase.kde.org/Development/Languages/Perl). So it works on at least one platform.
&gt; it's a lot of overhead with little gain This isn't so much a matter of opinion (although I guess it is that), as a matter of circumstances. I think I agree that for a simple Tic Tac Toe game Moose is unnecessary other than for the sake of learning to use Moose, but it does offer some real power for larger, more complex systems. Also, it's important to note that, used with `make_immutable` etcl, Moose's overhead only really appears at startup -- for a long running process it's basically negligible.
I'm not sure I'd recommend any Perl book from 2001 to a newcomer today. Nice that it has the bio-informatics angle, but the idioms of Perl in 2013 are very, very different from those days, and likely to confuse someone who's learning from more modern resources first.
Regarding labels, didn't Perl Best Practices suggest using labels for loops when using "next" and "last" for readability, especially within nested loops? Granted this doesn't fit OP's case, but I wouldn't go so far as to say labels always indicate something sinister.
Don't do this. # some code // this is a new line // this is a new line # more code There should only ever be one blank line of whitespace between any code. Vertically align your commas. function_call_or_anything( # this is ugly apple =&gt; 'fruity', orange =&gt; 'healthy', strawberry =&gt; 'tangy', ) Versus function_call_or_anything( # better apple =&gt; 'fruity', orange =&gt; 'healthy', strawberry =&gt; 'tangy', )
Interesting, as this is the way I'm teaching myself right now. Do you have any ideas?
Moose's overhead isn't just from CPU performance. It has a substantial memory footprint as well. We're (fortunately) not living in the world of systems with 32MB of RAM anymore, but when you're running a large number of executables the ~5MB of overhead starts adding up quickly.
So does that mean that using Moose causes perl to lock up ~5MB regardless of whether I'm using `no Moose;` or the other method that [jkg150](/u/jkg150) describes above? Does it also mean that on a web server that serves web pages, each request that requires Moose will cause the server to lock up another ~5MB? It seems like that would make Moose untenable for all but small web hosting projects. Doesn't Catalyst use Moose though? Thanks for helping to clarify!
The books in the comment you replied to are excellent :-)
Not 100% sure on the 5MB mem hold, so I will leave that to others that know better, however with the Catalyst part, you use a middleware such as mod_fastcgi or starman that is a separate process the webserver forwards the request to. It has X amount of workers and those workers each use up a few MB, however they do not close after each request. I have used it on some larger projects (few hundred concurrent) without any issues using a fairly low memory footprint because of this.
This is symbolic in both shallow and deep ways. And, so far, not controversial here on /r/perl: 7 upvotes, zero down, in the first 30 minutes. :)
I'm not super familiar with perl, but does this mean it's syntax is now more like Python in terms of method calls? $self.sub(); ?
Yep. Python, Ruby, Java, C++, Perl 6, ... I love the feature. I have no idea whether I'll be able to apply it at work, but I love the feature.
What about the braces for attributes? `$obj.{property}` looks pretty silly. 
Meh, . or -&gt; makes no difference to me. I think I prefer the arrow though, because it's a pointer, which is what's really happening. But still, either is fine. Don't think I'll use the module though, no point complicating things. I learned a long time ago to adapt to the system, don't try and adapt the system to you, you end up being different and support is a nightmare
rjbs listed some pitfalls [in response to that](http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-06/msg00316.html). But I guess those will be accounted for.
Accessor methods! 
If we were designing a new language I could see the point. If dots are more prevalent for the same meaning in other languages it would help new comers to adapt to Perl. But we are not designing a new language so the advantages of the new comers should be balanced against the disadvantages of the current Perl programmers need to learn something new. In the long term it would make no difference to me. I would take some time to get used to, but I don't consider either syntax superior. In my opinion the worst case would be if we would end up with half of the code base using one style and the other half using the other style (CPAN *is* my code base). That would be confusing. So if p5p really would like to support this change I would recommend that using arrows would be right out deprecated in the near future. Something like adding 'use dots' in 5.20 and then have arrows deprecated in 5.24. Well not sure about the schedule, but at least plan to only have a single long term syntax.
In keeping with Perl tradition, the Perl 6 OO system keeps simple things simple and complex things possible. I find it hard to believe your beef is with the basics: class dog { method bark { say 'woof' } }; class shitzhu is dog { method bark { say 'yap' } }; dog.bark; # woof shitzhu.bark # yap I've watched a lot of folk explore the system on #perl6, and the reactions I've seen are routinely positive, with the exception of advanced aspects of object initialization (which most languages don't have because they don't support such advanced capabilities). For example there's a low level built-in called *bless*. But most programmers will have no reason to ever call bless, because there's a wrapper called *new*. If you could list one or two specific examples we could explore them; I suspect the issue you had was due to lack of familiarity, and thinking that you are expected to use the complex bits to do simple stuff.
Get into the habit of using [Moose](https://metacpan.org/module/Moose), [Moo](https://metacpan.org/module/Moo), or even [Mo](https://metacpan.org/module/Mo) Less typing, briefer class definitions, type checking, roles - there's a whole world of awesome in those modules! edit: s/object/class/
Agreed. If you want to write for perl6, do so. Mixing the two is only going to end in tears.
&gt; Everyone else uses + but we've got to be different. That's right. Perl 5 operators impose value contexts on their operands. That's why you use `==` for numeric equality comparison and `eq` for string equality comparison. If `+` had to be polymorphic with regard to string concatenation or addition, you'd end up with the problems of JavaScript. Alternately, forbid whitespace around the invocation operator (`.`), but then you run into the problem of significant whitespace like around Perl 6's chained methods.
In general Perl operators decides the types of the operands. For example the == operators forces the operands to be interpreted as numbers, while the eq operator forces the operands to be strings. This means that you need one operator to combine strings and one operator to combine numbers. There are a few operators that works the other way around: The bit-wise logic operators and the smart-match operator. All of them has some problems where the history of a variable interacts with how the operator is working. Basically, Perl's type system with implicit coercion between number types and string types is a very bad combination with these kind of operators.
Beefs from your example: 'method'. We already had a great thing called 'sub' which does the same damned thing. Yes, I know 'method' is supposed to be private, but why not just: private sub foo { } which then makes this obvious. Add on there's no such thing as 'protected'. Then there's 'say'. It doesn't really do anything that useful for me. We don't live in a terminal world so much anymore so the newline isn't that big a deal. I know when perl 6 was designed, that was not the case, though. I'd almost rather see PHP's object system overlayed onto perl. PHP5 got a lot right.
I still intend to use Module::Build. It won't be in the core anymore, but its not going away, most likely you'll never see the difference.
In a sense, yes, but it's not as bad as a 100% cgi solution or a multiple non-threaded solution. If you're using FastCGI and import it before your loop or mod_perl, and use Moose in the handler module or in the apache config, it will only load once per processes. You're still using the same footprint as if you used it later, but you don't have to rebuild/recompile it each time. With that benefit, if there are parts of the code that aren't being used, the OS can swap those parts of it to disk if physical memory starts getting tight, assuming you let your processes handle a large number of requests.
I'm fine with switching -&gt; to "." but using a tilde for concatenation seems weird. although from other comments I see the issues with using +.
I realise that it'll still live on cpan, was just curious as to whether there was a build system which has been declared the new hotness without me noticing
Why?
Do you make use of frameworks such as catalyst or dancer? Do you guys use Moose to simplify OOP with perl?
Sorry but I don't understand Larry Wall's talking.
Maybe your left ear has some hearing impairment? Try turning your headset around.
Hopefully the sound issue gets sorted out for the final archived versions of the talks. The half-headset functionality was distracting while listening to the live stream. I still enjoyed the talks, though. Particularly this one.
I didn't know Larry had cancer until I watched this talk... Is this the first public announcement about this fact? I can't find any other information about this on the Internet.
I can hear him clearly, but I don't understand it. 
PDL has a lot of very nice, very fast tools specifically for manipulating numeric data -- iterating over rows/columns/what-have-you, selecting loci, logical accumulation, etc. Perl's lists-of-lists approach to multidimensional arrays is more general but also very awkward for that specific case.
Not sure about the announcement but this sucks. I hope nothing too bad happens. At least not soon. Too many good people have succumbed to the Reaper lately. OTOH, Larry as a comedian could probably be a much better career for him than that as a programming language inventor. He is funny :) 
Stream truncated. Video aborts after only a few seconds, can't view in any browser, retrieve with wget or anything else.
At one point it was going to be _ in Perl 6. I think I like ~ better though. Imagine a little piece of string pulling the two parts together.
I like the idea but I think I'd prefer being able to use both. You could choose, for example, to use -&gt; for hashes and . for method calls.
I don't mind the idea of '.' for methods calls, but why use it for dereferencing? Doesn't anybody else think that having the same syntax for method calls and dereferencing is problematic at least some of the time?
Many people on linux have mentioned that there are problems. Try upgrading your Flash or switch to a windows box.
Such a good guy, I hope Larry is with us for a long time. Love, don't hate.
I'm having that problem on a Linux box ...
Perhaps this shift is part of an emerging process to evolve Perl 5 in such a way that a reunification with Perl 6 over the next few years will go more smoothly. Perl 6 was designed from the start to be Perl 5 friendly in many ways, one of which is addressing transitional aspects, including syntactic. I may be wrong about Perl 5 syntax (it's so long since I wrote Perl 5 code I no longer recall much with confidence), but I'm thinking the . as deref means both dialects (Perl 5 and Perl 6) would be compatible without translation in the following case: $foo.[3] # val in 4th elem of array pointed to by $foo; P5 and P6 $foo[3] # P6 only; means the same And likewise for hashes. Does this make sense or do I have the Perl 5 syntax wrong?
Sorry, i meant switch to windows.
Same problem (on linux), alternate source? EDIT: I switched from firefox to chrome and got it working.
That returned JSON might come back with an `error` key, whose value occasionally tells you to calm down: 'error' =&gt; 'Too many connections from IP address: [..]' ;)
daxim says: Since 2012, PerlKDE and PerlQt are maintained at https://projects.kde.org/projects/kde/kdebindings/perl. This is the official one insofar because that's what the distros ship. If you are a Perl and/or Qt and/or KDE developer, I recommend openSUSE - you always get fresh packages. Subscribe to http://lists.kde.org/?l=kde-perl and http://lists.kde.org/?l=kde-bindings - Qt5 bindings/updated libsmoke are coming soon. http://code.google.com/p/perlqt4 was used before for this codebase, but was moved to kde.org - update your bookmarks. teh_moth says in a comment above this is not based on smoke, but that's wrong. Some snapshots from that time are on CPAN, namely http://search.cpan.org/dist/Qt and http://search.cpan.org/dist/Qt4. These are outdated - always check out the bindings code from the KDE git repository and compile that. Alternative Qt4 bindings: http://search.cpan.org/dist/QtCore http://search.cpan.org/dist/Qt-Core These are one-man efforts each that lag behind and are incomplete. ---- Useless outdated software, avoid: http://sourceforge.net/projects/perlqt is Qt3. http://perlqt.wikidot.com teaches Qt3 and is a vehicle for marketing an obscure Linux distribution. http://search.cpan.org/dist/PerlQt is Qt1 and Qt2.
The 'private' suggestion you make wouldn't make sense in Perl 6, which supports private methods that are not ordinary methods.
We have some in-house frameworks that help accomplish our design goals. It started coming together about 13 years ago and the momentum is hard to stop in favor of any other framework. 
Which again emphasizes my original point: it's not what I was looking for.
Is there anyone else struggling with audio quality? 
I never considered using the same variable name as the array in a foreach loop. It makes sense because $foo is only in scope of the foreach loop but it just never occured to me :P
This really comes down to personal preference, but consider taking advantage of Perl's postfix syntax. For example, a simple loop like this: foreach my $cell (@$row) { say $cell; } could be replaced with this: say $_ for @$row;
Fine on Firefox 21/osx
Ricardo Signes (our beloved Pumpking) has spoken: &gt; So, this sums up my feelings: starting from scratch, dot might be better, but from where we are now, offering a choice of either is worse. and &gt; I don't think dots.pm would be good for perl, and am not going to ship it in 5.20. http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-06/msg00551.html
Well written. I agree 100%
As a Perl maintainer, I must agree that this is one hell of a missed opportunity. Imagine how much harder you could make reading your code by mixing dots and arrows? Most people would read them both, mixed together in the same program, and assume that they did something different. It would be impenetrable to Perl newbies, yet simple for guys like myself that have been following Perl for years. Employers would be forced to hire me and pay me huge chests full of gold coins to decipher their systems.
I really hope Perl 6 actually becomes a successful language/programming platform. The little I've heard about it has been fantastic, and the only downsides I've heard are performance related (but they can hopefully make it faster!). Having it work on the JVM would be awesome as well. 
It's for the best. I couldn't think of a single scenario where I would use it at work. I'm already not using Rakudo and Moe at work - no point in adding to the pile.
Good, I don't see the point. "It looks nicer/It's easier to read" - that's an opinion, and in mine it doesn't. "It's less to type" - seriously? It's one key less, it's not like pressing - then &gt; is hard. Add to that the introduced complexity. If people are using this and putting it on cpan, and I see it and think, "hey that module does what I need" and I install it, then I find a bug and have to start writing perl in not perl because I didn't go to the effort of not looking at the code before I used it. Or worse, someone else builds upon that in normal perl... fyi, I'm also against Devel::Declare things as well, I can't see the point of MooseX::Declare, when I see people complaining about Moose, I can't help but wonder if they've only seen MX::D stuff... tmtowtdi - but I won't use your stuff if you do it with the above...
Good. Like perl needs more syntactic confusion.
http://ecgur.evancarroll.com/meme/perl_dots.png
Thanks for being patient and implementing this for everyone!
I'd imagine Larry could only serve as a commedian for academics, most of his jokes rely on contextual understanding of complex terms, and making puns on these complex terms. ie: Average folk don't understand what he's saying enough to find it funny. 
Uhm, some of us are still waiting on "SuperPython in a Nutshell", mister.
Good luck with this. Hope you have a lot of fun.
I fear I probably wrote worse 15 or so years ago when I was learning Perl. Scary thing is, some of it's probably still in production...
It's readable, so it gets marks for that. Maybe the most misguided perl ever? The more I look at this the more afraid I become. There is a startling lack of knowledge about basic things coupled with a lack of enough sense to google "easy way to do this" I want an AMA from #kevin, the guy who took credit for having to comment out use strict.... and... yes, that is the only comment in the whole file. Also I don't know what zamfoo does, but is this an official script of theirs or just something you stumbled across? This code looks dangerous and I wouldn't recommend running it to anyone.
This is a shell script that's been mangled into perl. For every 1 shell command, there is at least 2 perl commands (1 to initialize the command and one to run it). Somebody must like typing in "system()" 
Kind of cruel to link to it ...
Not even close to the horrors I've seen
It got real shitty around line two; Kevin, you are an ass;
If it were only that... Replacing every `$command = ` *shell code* `; system ($command);` with `system (` *shell code* `);` alone would make this script tremendously less WTF-worthy.
well it works, doesn't it? *duck and run*
&gt; I fear I probably wrote worse 15 or so years ago Me too. It took me some tome to recognize the power of CPAN, and then still some time to use it seriously.
i manage development for a little struggling saas company (building industry, USA). 90% of our code is in perl.
Direct link only loads a blank page for me. It is however (atm) the top post on http://www.perltricks.com/.
Holy Shit! That was a bowel-loosening read.
It indeed does prove 'There is more than one way to do it"!
He's selling this stuff to customers.
Wow. My initial reaction was sympathy for the poor newb being mocked on the internet. Not after I saw that forum, though. Wow.
Ya, but he deserves it. http://www.webhostingtalk.com/showthread.php?t=1275572
A more minimalist horror: I fixed once a perl script that concatenated input from IRC chat into MySQL queries.
Why does Perl attract terrible programmers?
It [apparently comes from here](http://www.zamfoo.com/updatezamfoo), which in turn comes to us from [a company with a loose connection to good security practice](http://www.reddit.com/r/programming/comments/1gfve8/how_not_to_handle_a_critical_security/). All sympathy evaporates away.
So they used perl programming (which perhaps they knew a little bit about) instead of learning shell programming. That's a valid use of company resources. It ain't pretty, but it gets the job done. 
Apparently you have never seen my scripts.
Not even close, it's very readable which makes it vastly better then much of what a google search will provide.
You can interpolate the body of a regex like a string... But I think for the regex flags, you will need an eval. $text =~ /$regex/; # does not need eval What are you building that dynamically builds regex flags? Does it really need that level of dynamism?
"#use strict" Nuff said.
You can use `(?adluimsx-imsx:pattern)` syntax to change modifiers within the body of a regexp. From perl 5.14 you can use `(?^aluimsx:pattern)` too to make it a little less crazy.
First, if you are simply looking for words and phrases, such as 'quick', it's probably more efficient to use string functions, rather than regexes. RE have overhead setting up the system, while scanning a string to see if a substring is present is fast. So if you can, I would use index() as my first line of attack. my $sentence = 'The quick brown fox'; my @vocabulary = ( qw( cat dog bunny fox goldfish parrot fast slow dead Norwegian-blue black brown white gold end ) ); my $N = scalar @vocabulary; my @words_to_find; # Build up a set of words to search for this time ... may be empty # while ( my $word = $vocabulary[int(rand($N)) &amp;&amp; $word ne 'end' ) { push @words_to_find, $word; } SEARCHTERM: for my $word ( @words_to_find ) { if ( -1 == index( $sentence, $word )) { say "Didn't find '$word' in '$sentence'."; last $SEARCHTERM; } else { say "Found '$word'."; } } Note: This only checks that all words are present, but doesn't say anything about their order.
This is perfect: print $text =~ /(?$mod)$regex/, "\n"; It works even if $mod is empty. Thank you ! Now, is it actually possible (because I am curious) to eval the entire regex ?
Of course, it's just code. eval $ANY_EXPR;
If you DO want to search for a number of words using regex, you can accumulate an array of words, like before, or of regex bits. A saved regex bit is denoted by a qr chunk: my $colour_re = qr{brown} If you want to make it case insensitive, slightly more complicated: my $colour_re = qr{(?i:brown)} You could put other modifiers after the ?, as well. If you don't care about the order, but do want to ignore case, you can do a loop, like the string example. If you want a particular order, I would join the bits together with '.*', in between, to say I don't care what's in between. The easiest way to do this is with the join() my $regex = join '.*', @bits; if ( $text =~ m{$regex} ) { # do something .... You can also use more sophisticated regex bits, for example, if it's a zombie fox, you might accept 'brown' or 'brain': my $colour_re = qr{(?i:brown|brain)} or if you're even more accepting, going for any work that begins with B and ends with N ... my $colour_re = qr{b.*n}
There are sections on string processing and regexes at [http://www.onyxneon.com/books/modern_perl/index.html][Modern Perl Books]. Read the sections for free, and you'll ant the whole book.
Just found the Save As PDF function. That is one sweet preso. Slides are very useful; I'm sure the talk was quite worthwhile. Thanks for posting *mr_chromatic*!
TIMTOWTDI? :)
I think [this is the talk](http://www.youtube.com/watch?v=X2FQHUHjo8M) from the YAPC::NA 2013 conference. Tom Christiansen (tchrist)'s [Perl Unicode Cookbook]( http://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html) articles are a wonder of good Perl Unicode whatnots. 
You might also find my article [Unicode in Five Minutes](http://richardharr.is/unicode-in-five-minutes.html) helpful - it's Perl specific. And of course [tchrist's absurdly long post on Unicode best practices](http://stackoverflow.com/a/6163129/74496). As a developer who works with various encodings, Perl is a blessing. The Unicode/encoding support of other scripting languages I've used has been *very poor* in comparison.
It works now. Thank You!
You can even construct the code on the fly; and wrap it in a sub if you have to do it often: $actions = eval "sub { $STATEMENTS }"; and then you can do `&amp;$actions` or `$actions-&gt;(@params)` to execute it. 
Hey man, thanks for the reply. I looked at mojolicious before choosing catalyst as it seemed too "Web design" orrientated at that time. Perhaps it's time I go back and have another look at it then. Have you had any experience with Perl Dancer?
I have never coded anything in it, just read about it. Typically, anything that I would use Dancer/Kelp for I can also just use Mojo::Lite.
Does http://sedition.com/a/2733 help you at all? They have an example for using amazons apa api which is pretty far away from the standard
This looks like it might be heading in the right direction. Let me read through this and reply back. Thank you!
As far as I understand the intention is that your models would not need to be tightly coupled to your web application, and in most cases, why would it? In the The Definitive Guide to Catalyst book, an example application is used to turn English text into "lolcat" speak. So they have a separate class that transforms the text, which they then load into Catalyst with Catalyst::Model::Adapter (I this kind of thing is what you refer to as glue?). Some of the arguments for doing this are for: easier testing without needing to invoke any of the framework, the ability to re-use the code in batch scripts or other things outside of the framework, and so on. They like to keep anything that's not specifically to do with the UI (i.e. the Catalyst web app) out of the main web app.
Catalyst::Model::Adaptor is what I use to decouple data models from catalyst so I can still import them for use in scripts and testing where the web framework isn't necessary.
This information was very helpful. I read through some of the examples and it seems that the step I was missing was extending the catalyst::model parent. One of the other problems I've had with catalyst is that when I create objects from a controller, the object doesnt die when the request stops. This led to objects retaining attributes from Previously ran queries, however I suspect that might be limited to the glue design. Thanks again for the link! 
If "it works 100% even if you don't have DBIx::Class on your system and have never heard of it" constitutes tight coupling, then loose coupling must involve parallel universes or something.
I really don't see what the problem is here. There's no dependency on DBIx::Class or any ORM. You can have exactly the API client you want, it will be easy, it will be testable, and all you have to do is get over your irrational hatred of "glue". It's just a couple of lines of code to get some dependency injection magic out of the way, and then any class you want is available to your app as a model. What's not "properly integrated" about that?
Hi. Thank you very much for your reply. The catalyst model adaptor is exactly what im using now. The biggest problem I'm facing is this : Let's say the first request made to a controller instantiates an object, $obj And then the controller calls a function of that object : $obj-&gt;setDate(Tuesday); Which returns a string that gets set as the response. Fairly simple. I wpuld think that because the function came to an end and sent back a response that the object would die off as this would signify the end of its lifetime. However if a new call is made, to a different sub in the controller, which instantiates a new object called : $foo ANd you say : $foo-&gt;getDate (); It will be set to "Tuesday" from the previous request. This caused major headaches in the design of the application. I'm sorry if my reply lacks detail, I'm typing this from my mobile on the way home. I'll revise and update once I get near a pc again.
Thanks man, it's there any special way I need to access this model from the controller or doi just make use of the frameworks model accessor methods? I'll give that article a read once I get home! 
Catalyst, by design, doesn't force you to use any particular separation between your models, views, or controllers. You could put everything in one spot, and it would work. You'd kill yourself later because you wrote it, but it'd work. In _general_, you can use `Catalyst::Model` objects (see script/myapp_create.pl model ...) as light wrappers around some other CPAN module. In fact, you probably should. You don't necessarily need to _extend_ some CPAN module with your Catalyst::Model being a subclass, but rather use it in a "has-a" relationship instead of a "is-a" one. I.e.: # somewhere in one of my Model "Foo" class.. sub get_a_foo { my $self = shift; return SomeCPANModule-&gt;new( @_ ); } And in your Controller.. $c-&gt;stash-&gt;{'my_foo'} = $c-&gt;model('Foo')-&gt;get_a_foo('args', 'here'); It's important to note that Catalyst models are instanciated once, so you either have to clean them up manually, use some sort of factory to generate new instances of what you really want, or use [Catalyst::Component::InstancePerContext](https://metacpan.org/module/Catalyst::Component::InstancePerContext) to generate new instances on the fly.
Hi. You may very well be correct, perhaps my hatred of glue files are irrational. What I really don't want to do is go down this path only to find there's something I missed that could've enabled me to avoid it completely. Check my reply to this post, perhaps there's some light you could shed on this? http://www.reddit.com/r/perl/comments/1gkvrp/mvc_and_perl_catalyst/cal8brl
Are you sure this couldn't be something else, like you needing to clear your cache or something similar? I've written catalyst apps and never had a problem like the one you're describing with regard to controllers. 
I like Mojoliscious too, but Catalyst is not coupled with DBIx::Class. This is just incorrect. 
Great feedback.
Sounds like you're doing something strange. I assume you're talking about using $c-&gt;model. Models live forever, unless you use something like Catalyst::Model::Factory , so if in your model you do $self-&gt;{something}=123; then on your next request that will still be set. Same for controllers. You shouldn't do that, but I can see why you do as you're coming from php where your scripts are ran on each request. With catalyst your app runs at the start, then your functions are ran on each request, if that makes sense. So you need to be thinking that if you store something somewhere, in an attribute or in $self or w/e, it'll stay there until you restart the whole catalyst app.
This
Thanks for your reply. That makes sence. In terms of model design, would it then be more beneficial to build your models so that no attribute data get saved indefenitely or use Factory to create new models everytime? Or is it based more on your specific scenario - sometimes the one way might be better, other times the other?
Depends on what you're doing. But if it was me, I'd make them long lived where possible, and pass variables around where necessary. Having said that there's nothing wrong with using factory, but I think it's good form not to unless needed. No point doing extra work when you can avoid it. Eg if you wan to send email with Mail::Builder::Simple then you'd use factory and set the class, but if you have a homebrew model that validates user input then you'd write it long lived and not touch any accessors or $self-&gt;{foo}, except for reading things that are set at startup and don't change. E.g. you might have an accessor with common used regex in or something, saves you typing it out over and over. But you shouldn't store the username in an accessor then call another function, just pass the username with the function call. Hope that makes sense!
It does and it gives me hope. Thanks man. I'm going to be doing allot of playing this weekend, I've had a project in mind for a while now but didnt want to start with it before I have some clarity on these subjects.
Glad I could help
Distant cousins if anything.
Distant cousins if anything.
Distant cousins if anything.
A post about someone updating a post on PerlMonks? Removed.
&gt; But let's not expect too much from an alpha release Three years after Rakudo Star, there's still the issue of no official release. How much less should anyone expect? I'm sure it's fun to work on all sorts of proofs of concept, but how many spectests does Rakudo pass on the JVM right now? How many spectests does Rakudo pass on the MoarVM right now? &gt; There will be a 6.0.0 spec, probably described in the upcoming months.... Yeah, I heard *that* for several years too.
It does depend, which is why they're all available. A lot of times, your model object is a thing that's relatively stateless and knows how to *get* data rather than storing it — like a database connection or a service client. In that case, there's no harm in having it stay around as long as possible, and it's faster that way.
I was able to watch it [here](http://blog.yapcna.org/post/52127089421/larry-wall-stranger-than-fact-on), albeit with a lot of buffering.
Catalyst is awesome, good work jjn1056
Thanks to the folks who do all the hard work bringing this to fruition.
Heh. 5 votes up. 5 votes down. I'm guessing the downvotes are because the post is too raiph/weird/long/complex/boring/non-sensical/annoying/pointless/broad/opinionated/open-ended/divisive/self-serving/pro-p6/wrong/???? If downvoting folk could add comments saying something about what they don't like, I'd appreciate that. If you can be kind too, all the better, but I've got a thick skin.
"We are mollified to release..." :)
I agree; the one thing that Perl 6 is going to need if it's going to be successful is contributors. I don't just mean people hacking on the runtime or compiler itself (I think that these are in capable hands); I mean we need people writing modules, writing applications, and working on tooling/packaging. People are more likely to try it out and do something with it if a module exists to help them, or if their favorite editor supports Perl 6. Scaring people away from Perl 6 only seems to contribute to the notion that it will never be ready.
Thanks for the feedback. In the hope you might give more: What did you think of [the divided brain](http://www.youtube.com/watch?v=dFs9WO2B8uI) -- which is hard science and probably the most important bit? Do you have any ideas about how the Code of Conduct discussion could go better when it comes up again? Most important to me, what ideas do you have about talking about Perl 6 next year so that the mere act of talking about it a lot more does not cause deep division? Also, thanks for saying *to me*. Using the Truth/truth lingo and divided brain perspective I covered in the OP, saying *to me* is a technique that shifts a statement away from being an assertion of Truth that might divide us to an assertion about truth that is easier for some folk to hear, including me. (Upvoted for that.)
Well lately most of the Perl coding I've been doing lately is on whatever comes with the cheap GoDaddy Linux hosting accounts. In one case it's whatever comes with the default installation of RHEL that you get with Amazon Web Services. So it's not like Perl 6 is going to have any impact on my life. I just subscribed to r/perl to try to keep up with things, just in case. But I spend a lot of energy just on getting my code to work, and dealing with office politics where I work. I don't work with any other developers and no one at work cares about Perl 6 so I can't justify spending a lot of energy on it. Hope this doesn't sound too cynical to you but it's my reality--I just need stuff that works with very little effort (I work on LOTS of different stuff and I'm an hourly employee so I have to justify every hour I bill to every project).
So P6 isn't really relevant to you at the moment, and vice-versa, and divisiveness even less so. Fairy 'nuff. (Btw, if you don't already use PerlMonks as a resource for getting your code to work you should.) I glanced at some of your reddit comments. Three things came to me: * First, the [divided brain video](http://www.youtube.com/watch?v=dFs9WO2B8uI) (which was supposed to be the core of this "Divided we fall" post, but I think I messed up the presentation). Imo this is about the best 12 minutes anyone could ever spend if they're interested in better understanding themselves and western civilization. * Second, the preacher/Kumbayaish ["Is it possible to live in this world without a belief ... So that one meets life anew each minute?"](http://sandorian.us/newslog2.php/__show_article/_a000245-000047.htm) * Third, [Happiness is getting it done](http://en.wikipedia.org/wiki/Eudomonia). Thanks again for your helpful comments.
Have you ever read [Julian Jaynes](http://en.wikipedia.org/wiki/Julian_Jaynes)'s [The Origin of Consciousness in the Breakdown of the Bicameral_Mind](http://en.wikipedia.org/wiki/The_Origin_of_Consciousness_in_the_Breakdown_of_the_Bicameral_Mind)? You would probably like it, the linked video was all so familiar while being off on a bit of a tangent to what I read in Jaynes' book oh so many years ago. I've always taken the divisions to just be a few strongly opinionated groups of people who happen to be in the limelight and no more interesting or important than the likes of Hollywood stars on some personal media crusade or a Left or Right Wing pundit mouthing off on the talk show circuit. CoC - WAH! I'm not being taken seriously and being told to go through proper channels. WAH! these are proper channels. WAH! not. WAH! I'm taking my toys and going home. WAH! Coc. WAH! module author is an ass. WAH! module author has peculiar requests. WAH! authors' modules are evil. WAH! author's modules rock. WAH! Devel::Declare is evil. WAH! named arguments. WAH! Moose is heavy. WAH! plain old objects are fine. WAH! CPAN is the language. WAH! dependency hell. WAH! only core deps. WAH! local::lib OMG! somebody mentioned Perl6, cue standard predictable diatribe. OMG! I use Perl6 in production, what's your deal. I tend to think all of that is the Perl equivalent of "Your Band Sucks" and deserves the same amount of mind space. Perl6... I'm patiently waiting. I've been excited since the Synopsis and Apocalypse stage and thinking that I'll really like this when it actually is, but past the Pugs era when it was obvious (and maybe stated) that it wasn't going to be Perl5++ and wasn't coming any Christmas soon I let go of any anticipation. The few times I've tried Rakudo in the past, it's been just to slow for my old laptop and development style to be practical. But it's going about the way I'd expect and pretty much how I remember it was supposed to go... Perl6 is a spec that anything can implement and if the tests pass... it's Perl6. So the primary development started with a top level and a bottom level and worked towards the middle somewhat. Doing what parts of the top can be written in Perl6 in Perl6 and that on top of some middle (NQP). The bottom level may have been too ambitious in wanting to support other middle-top levels. This isn't strange or bad or anything. I often do the same thing myself, going at a problem from the top and bottom at the same time hoping to meet nicely in the middle. Sometimes it works sometimes it doesn't and either the top has to be re-done to fit the bottom or the bottom re-done to match the top. So Parrot is either a bust or just a much longer wait, JVM and .NET are probably workable but there's still a mismatch of sorts between those bottoms and the NQP/Rakudo top. But it seems to me that a bottom built just for the top (MoarVM) might be just right. And if I can get a Perl6 that's about as fast as a Perl5 plus all the bells and whistles needed to get it close to Perl6 I'll be happy to start using it for things in my ~ and my laptop's /usr/local. Probably a bit longer to get it doing $WORK things. Anyway, I hope there are plenty of others like me that have no beef with either Perl5 or Perl6 and are just waiting patiently for one more WTDI to TIMTOWTDI it and this 'division' is just an illusion that's only there when someone is looking for it. (not really edited because it's midnight)
I don't know. Thinking about Perl makes me sad these days. I'm having a lot of trouble articulating it. Some folks want to move Perl forward, whether through P6, Moe, Moose, or whatever. Others want to keep to a Perl that has worked 15 years for them. I understand some of the thinking on both sides. Progression vs. stability, stuff like that. All I know is that it's exhausting to be around the tug of war online. I use Perl 5 at work. There's new code and legacy code. I already experience my own progress vs. stability conflict every time I sit in my cubicle. By the time I get home, the last thing I want to do is look at any Perl: 5, 6, Moe, or whatever. Well, that's the next-to-last. The actual last thing I want to do is read arguments about the which is the correct vision of Perl. The hardening attitudes lead me to believe that this exact same debate will continue regardless of how useful Perl 6 is. Legacy Perl 5 code will continue powering large chunks of the Internet, while interesting new projects will continue to be dominated by non-Perl languages. Maybe I'm just in a particularly cynical mood at the moment. I don't know.
Well, the neat thing about MoarVM is that it's a bottom end built not for the top, but for the middle. It's built specifically for NQP. And anything willing to use 6model for its objects can run on NQP, including a Perl 5 grammar and compiler. As for your other points: yes, programmers can be champion complainers, but I wouldn't call the waaamublance on everyone. There are legitimate concerns by people with a lot of insight. Actually that might be part of the answer to raiph's question. Programmers are pretty smart, and quite a few appear smart to others. And the easiest way to do that is to criticize other things, and parrot other people's views. So dissent becomes an end in itself to some people, even without them realizing it. I spent several years with a political organization. At first I was a rabble-rouser from the outside, but eventually I became an insider. I found it easy to complain about insiders when I was out, and outsiders when I was in. Until finally, I learned to just shut up and listen -- and only to speak when I had a clear idea in my head. And then, everyone started treating me like some sort of guru, just because &lt;90% of everything I said was crap. Learning to think before I spoke is probably the single most valuable thing I learned in college. Er, when I actually remember to shut up, that is :/ Either way, we're not actually as divided as we seem, it's just that the noise often overpowers the signal.
Well, there's the rub. P6 is really slick at a few things. P6 is weak or worse for many other things that P5 does in its sleep. The metaphor of a precocious excitable 13 year old distracting adults trying to get stuff done is fairly apt. What do you make of sundialsvc4's comments? (In **Hardening attitudes** above.) Is it not conscious identification as a utilitarian that leads him to feel justified making such a divisive comment (the 2013 comment) rather than the open minded comment from 2011? I'd like to be able to announce [Perl 6 on android](http://blog.brentlaabs.com/2013/06/camelia-at-age-13-perl-6-on-jvm-debuts.html?showComment=1371892705632#c7738352542971889617) and solicit help knocking it into shape. But if do, I can pretty much bank on hearing how bad P6 is, how pointless it is, how it's never going to be finished, how it is hurting P5. All of this is damaging to both P5 and P6. None of this can be satisfactorily answered until she's in shape. But it'll take far longer to get her in shape if we don't solicit help, and even longer if Perl is getting a bad reputation.
More to the point: What are the alternatives you imply? Commit to perl5 only? Even with improvements and modification that is not going to catch up with other languages, so the result of that is death. Commit to perl6 only? Rushing it so that something trendy like perl6 on android can be made usable means abandoning the long effort to do the best with perl6, so the result of that is death. If short development time and breadth of possible use are the best criteria for language choice then isn't PHP the obvious choice?
Thanks for your fun comment. I too hope there are plenty of others like you. :) I vividly recall the first time I read the wikipedia page for The Origin of Consciousness. I've been studying brain science for nearly two decades. That moment was definitely a highlight. Fwiw Iain McGilchrist writes, p261 of The Master and his Emissary, "I believe Jaynes was near to making a breakthrough -- did in fact make one -- but that, perhaps derailed by [an incorrect view of schizophrenia], his conclusion was diametrically opposed to the one he should have drawn." Another favorite of mine is this [20 minute video by a brain scientist who studied a gradual shutdown of her left hemisphere as if her life depended on it then spent 8 years carefully rebuilding her brain and mind with the insights she gleaned from that experience](http://www.ted.com/talks/jill_bolte_taylor_s_powerful_stroke_of_insight.html).
Imo it's timtowdti all the way. (The "Divided" part of my OP was a pun that was as much if not more about the divided brain than the divisions that appear to appear. The right hemisphere's contribution to thinking, according to contemporary brain science, or rather Iain McGilchrist's exposition of it, or rather my Perlish interpretation of his work, is clearly consistent with timtowtdi in contrast to the the left hemisphere's, which is about seeing a One True way unless one teaches one's left hemisphere to explicitly, consciously respect the right's view, so that the One True Way can be timtowtdi.) I see timtowtdi, a siren call to open mindedness, as a deeply defining characteristic of Perl culture, much more fundamental than, for example, utilitarianism. I've seen pride in the latter lead folk to diss -Ofun, which is absolutely nuts imo. So imo the best alternative is timtowtdi and to be united about timtowtdi.
:( Thanks for commenting; sharing can be the start of healing. :) Personally this reddit is bringing my focus to timtowtdi as a rallying cry. For example, should YAPCs have a CoC or shouldn't they? I'd say timtowdti wisdom suggests that we respect the right of YAPC organizers to decide what they want. Of course someone else might say, no, TIMTOWTDIBSCINABTE, and they would of course also be right. But by anchoring our consciousnesses in timtowtdi, we should find tugs of war either dissolve naturally or become constructive, not destructive. Imo seeing can be a form of doing, so we can apply timtowtdi to seeing too. (Maybe we can abbreviate timtowtdi to timtow?) So maybe everything in the Perl world is just peachy, and 3 years from now there'll be folk singing the praises of Perl 5.24 where P6 is nowhere in sight, of P6 on android with Perl 5 nowhere in sight, of the descendant of Moe on android with P6 nowhere in sight, and of a range of combinations of P5 and P6. Maybe I'm just in a particularly upbeat mood at the moment, but who knows? :)
That's not a bad point about letting the principle of "more than one way" affect our perceptions of all this. Perl 5 w/minimal add-ons *is* an excellent way to manage infrastructure. I've already seen that Perl 6 and Moe *are* great ways to explore what can be done by applying Perl habits to new programming languages. I won't be discarding Perl any time soon. I just need to step away from other people's debates ^_^
We use mod_perl over here, and we are patiently waiting for mod_perl 2.x to officially support Apache 2.4+. How likely is it that Perl6 will be able to run mod_perl? Would it be better just to move to a Perl-based HTTP server and get off Apache entirely if we ever want to do mod_perl-type stuff with Perl6?
The weekly Perl community drum beat ... now 100 issues old! I always look forward to this on Mondays. Highly recommended if you are not already signed up to it. Thanks to Gabor for an awesome resource!
This post is way too hippie. Just focus on the facts.
congrats!!!
Hear, hear. Three cheers for Lincoln Stein. CGI.pm may not be the best tool for today's job but it definitely deserves some sort of lifetime achievement award. Mark Stosberg also deserves thanks for picking up maintenance and working down the bug queue.
I was going to ask what is supposed to replace CGI.pm, and it appears that is Plack/PSGI. Just for anyone else who was curious about this, and hasn't been paying attention to the state of things. http://plackperl.org/ and http://www.modernperlbooks.com/mt/2013/05/ejecting-cgipm-from-the-perl-core.html have more details. I wonder why there aren't attempts to make CGI.pm more modern, instead of ejecting it completely. I realize a big complaint is that it tries to do too much, but, it could probably be improved, and retain the same function.
I just wish that something would replace CGI.pm **in the core.** I guess the justification is that nowadays, access to CPAN is a given, but still, it's nice to be able to have CGI.pm available in a pinch.
Exactly. Like with GoDaddy hosting plans. It's a lifesaver to be able to cook up something on one of those cheap hosting accounts. That's why I still use the crap out of CGI.
Yet another thing Perl can't do.
Yeah, that was where I kinda groaned about the 'replacement', I can only hope something replaces CGI.pm in core, as well. We're pretty damned web-centric these days, and not having that be a core library is going to cause issues. Then again, most modern distributions have packages for perl libs outside of cpan, so hopefully the new champion will be readily available in RHEL and Debian systems. It'll be just absolutely 'splendid' if there happen to be two competing libs. I say that with heavy sarcasm, because it's just going to turn into yet another pissing match over which is BEST.
The goal of re-factoring the code would need to be preserving compatibility. Given the articles I read about this and the complaints people lodge against CGI.pm, one of the easiest to resolve seems to be that the code is inefficient and not modern. Instead of complaining that the code uses principles from 1996 perl teachings, why don't people fix it?
Sweet! 
No, I just think CGI scripting is a bit dated. It was all the rage circa 2000, but 13 years later, it's all about MVC frameworks. Rails, Django, Catalyst, etc. 
Lovely.
Here are a few good blog aggregators. http://ironman.enlightenedperl.org/ http://blogs.perl.org/ This is a nice weekly news email. http://perlweekly.com/ and of course irc.perl.org is a great place to discuss Perl.
CGI.pm *does* seem like a huge behemoth for what little of its functionality I've ever used myself (mostly just parsing POST and GET data), which I suspect (but without any real evidence) is probably all that a lot of people use it for. What seems really to be needed is separate modules for the various areas of functionality that coders might need - even CGI::Simple, though smaller than CGI.pm is still a good-sized module (it still weighs in at about half the size).
Is there any news on making PSGI long-poll friendly or async buffering friendly? As I understand it at the moment, there's no standard way for a PSGI app to know that the client has closed the socket (quite an important error case, since using inactivity timeouts limit your long-poll window). I also don't understand how an async PSGI app (one which uses the delayed response and streaming body): http://search.cpan.org/~miyagawa/PSGI-1.101/PSGI.pod#Delayed_Response_and_Streaming_Body can do any flow control with only -&gt;write and -&gt;close methods. You can't throttle writes in async-land by blocking in -&gt;write. Would be very nice if PSGI could address these issues.
Hi, The Perl Monks website is still active and a great forum. You probably know [stackoverflow](http://www.stackoverflow.com). And last but not least my own awesome site: [perltricks](http://www.perltricks.com) :)
You may want to sign up to the Perl Beginners mailing list: http://learn.perl.org/faq/beginners.html
Yeah, the productive outcome for me from this post is the notion that the answer I seek is to focus on promoting timtowtdi. For example, the YAPC::NA organizers picked a name for a conference track that was designed to encompass projects such as Moe, p2 and Perl 6. Suggestions were phrases such as Language Horizons, Perl Family, Research, and Perl Neighborhood. We settled on the latter. I'm now thinking that a good name for such tracks at YAPCs and elsewhere is the Timtowtdi Track, or perhaps the TimToady Track, if Larry thinks that's better.
There's a lot involved in usefully answering this question. I urge you to ask that same question on the [IRC channel #perl6 on freenode](https://kiwiirc.com/client/irc.freenode.net/perl6) and then wait for answers from the right folk (I'm thinking at least Moritz Lenz, Carl Mäsak, and Jeff Horwitz; the latter would have to be invited back to #perl6 especially to discuss your question as he has not been on #perl6 in years afaik).
You are rambling.
Fwah, I do too. I'll be sloooowly moving away from it, taking my app from no framework and heavy use of CGI.pm (none of the HTML generation stuff), to CGI::App, to most likely a backported to Perl v5.8 version of Mojolicious. That's to maintain support for CGI, as well as start getting into PSGI support, while still attempting to keep up with whatever ridiculously old Perl version shared hosting plans seem to keep around. Sigh. 
The problem is that one of the reasons why CGI.pm made me cringe, is still a problem in "modern" Perl: there is *no way* to reliably tell whether a sub is called as a method or as a function. 
You're asking the wrong person. I strongly feel that HTTP and HTML need to be replaced with something that is designed to handle modern 'web' interaction from the ground up.
I think Perl congregation still mostly happens on mailing lists. That said, Perl has a large variety of truly wonderful resources out there: http://www.onyxneon.com/books/modern_perl/index.html - Modern Perl book. This would be the first thing you should read on the language, as it will walk you through the features for perl from the last 10 years. Most tutorials tend to skip this. Free ebook. http://hop.perl.plover.com - Higher Order Perl book. This is another free ebook that provides insight into the more abstract parts of perl, like First Class functions, clojures, proper paths for recursion, etc. Following on this, it's all what you want to do, really. There are a variety of great frameworks and modules for anything you could want to do. If you think "I want to do X", check http://metacpan.org and I'll give you good odds someone had written a module that will do at least half the grunt work for you. 
Sound reasoning
Don't do it in code, do it in templates. There are lots of great templating modules out there: Template Toolkit and HTML::Template are old stalwarts, and Text::XSlate seems to be the new, fast hotness.
I've looked at Template::Toolkit and HTML::Template (I'll checkout Text::XSlate), so far they are all pretty basic, they do let me merge html and perl with ease but if I want anything fun or interesting I really have to write it myself, I end up generating pieces of templates in code and stitching them together to get the flexibility I want, I can already do this with mason, was kinda hoping for something better. Sounds like wishful dreaming on my part?
I'm not sure what you are looking to do, but Mojo::DOM is a nice module to manipulate HTML and has a ton of syntactic sugar to make traversing and modifying the DOM simple. http://search.cpan.org/dist/Mojolicious/lib/Mojo/DOM.pm
Having a hard time understanding your question. What do you mean by "complex HTML"? HTML should not be complex. And if it is, it is usually the output of nested components or loops or something. So, if you have complex data, you would then emit an appropriate amount of "complex HTML". Still not sure where the actual problem is.
Come join us on irc, at irc.perl.org!
Example: I need to create html tables (tabular datasets) that contain both columns and rows that can span as well as putting in sub total rows and the like. I'm starting to write something to handle this dynamically since none of these libs seem to be able to handle it, I'm also still reading up on Text::XSlate, and I'll check on Catalyst-Plugin-AutoCRUD as well. I guess I'm surprised nothing has gone public for this sort of thing. Surely I'm not the only one building tabular datasets in html tat aren't just basic datasets.
Have a look at [HTML::Table](http://search.cpan.org/~ajpeacock/HTML-Table-2.08a/lib/HTML/Table.pm).
That looks promising, ty
I really don't understand what you mean about them being "pretty basic" - I've never had to do anything like generating templates in code, I'm somewhat baffled by what your idea of "fun and interesting" is - you haven't given any examples of what you're trying to acheive and what problems you've had with templating, or what "something better" would look like or do. Honestly, it sounds a lot like you're fairly unfamiliar with this area and don't fully understand the tools or languages (both templating and HTML, CSS, etc) - all the clever stuff IME of web dev has primarily been done using CSS. I've had the chance to work with lots of good web designers, and their HTML has always been a fairly simple framework with CSS providing the clever stuff on top. Maybe it's worth looking at it from a different angle - try using html frameworks like bootstrap to see what you can acheive by using CSS appropriately.
I wouldn't think that would be a difficult framework to put together in the first place. And when you write it yourself, you aren't being restricted by some arbitrary limitations imposed on you by another framework's author. Of course, it's easy for me to say that when I have 15 years of code base to reference, and a lot of that does exactly what you want to do.
In **vi**, of course
Amen.
[Yup](http://2.bp.blogspot.com/-s5KLvZmbFfg/T8UdebIMcEI/AAAAAAAABQ4/XaSWcVsnfmM/s1600/ryan-pointing-the-office.gif)
naturally
Ok, so I've resigned myself to writing something from scratch to handle this in as generic (thus re-useable) a way as possible. Many of these libs get close-ish and I'll likely use then to some degree. Thank you everyone for your suggestions and help. I'll blog my progress for any interested on blogs.perl.org, assuming I don't get flamed off there.
Unfortunately it's all currently in pdf form (samples provided by a client) and it's all proprietary. I'm in the process of sanitizing some of it so I can put up a sample.
[this](http://imgur.com/qvqCpDf) is a small example of what I want to auto generate. I could easily write this using any number of tools/libs/etc but I don't want to write it specific for this format since it's only one of many possible combinations of headers, colspans, etc. I believe I have a solution which I'll present once I have it coded and tested enough for needing comment. Thank you again for trying to help.
&gt; there's no standard way for a PSGI app to know that the client has closed the socket I really want this one too. I don't even need a *standard* way -- any way would work for me, at least in the short term. However the bottom line is that Plack, like most other Perl distributions, is volunteer-driven, and either the patches need to be submitted from the outside, or Tatsuhiko Miyagawa gets to take an unpaid vacation from his job to add things. Maybe someone should put up a crowdtilt fundraiser and we can vote with our pocketbooks on what features we want most? :) (And then we just need to find someone who is willing to take the money to do the work.. not always an easy task in itself.)
There's probably a way if you write the sub in XS. After all, we have the 'indirect' pragma, which detects similar things, doesn't it?
Template::Declare rocks
It is simple. Rather than adapt code to handle either usage, simply use methods every time if you aren't EXPORT'ing methods. And if you are, remove the exports. I mean, solve this problem by adopting a consistent usage. OO is imho better than procedural because of the availability of the implicit state with $self, so OO is superset of what can be achieved procedurally. So why use procedural code at all?
If perl has the best unicode support of everything, I sure wish the stuff I try to use with Perl didn't always have so many bugs. Granted, I use ancient perl and modules, like 5.8.9 era or so, but IMHO there's a lot of code that simply doesn't work properly with unicode. Here's a few modules that seem to corrupt data routinely and which I've run into just this month: - DBD::DB2: seems to ignore the UTF-8 flag entirely, just writes whatever you give as octets. Not good. If database is in UTF-8, it should encode binary-string going into character column to UTF-8 first, for consistency. - Text::CSV_XS: give it string with utf8 flag, receive array with the same octets but utf8 flag off. This probably just a bug that's fixed in some newer version which I can't upgrade to. I was able to add a copy of Text::CSV_PP that preserved the utf-8 flag correctly, though. But seriously, calling Perl's unicode support top notch when I routinely run into issues sounds like someone might be in denial. While it may be technically true that Perl's unicode support is really great *in the language core*, in practice the unicde strings and binary strings are often confused for each other in XS interfaces, resulting in corruption of the data. Perl's own handling of unicode seems good, though, but it would imho be more likely to work in practice if the byte arrays and unicode strings were completely separate types like in java or python 3.
So now that CGI.pm is going out of style, what is the best possible module for the use case of "Here's a HTTP::Request, give me the names and the values for the parameters that can be found in query string for GET, or application/x-www-form-urlencoded or multipart/form-data in POST"?
It all depends on how you define risk. You could make the case that depending on Moose is a huge risk, because: - Moose isn't in the official RHEL/CentOS repositories, so you have to use unofficial repos or install from CPAN. In some organizations, this is not allowed or it requires jumping through extra hoops. - Moose currently requires perl &gt;= 5.8.3 but the project has warned that the requirement will be increased to perl &gt;= 5.10.1 in the near future, whereas RHEL 5/CentOS 5 users could theoretically be stuck with perl 5.8.8 until Q1 2020 when it finally reaches the end of extended life cycle support. - Even if you have the luxury of using RHEL 6/CentOS 6, which ships with perl 5.10.1, what happens in another few years when Moose decides that 5.14 or 5.16 is the new minimum requirement? RHEL 6 will be around until Q4 2023. - Some unenlightened organizations still insist on perl 5.6.x because they don't see any value in upgrading, which takes Moose right off the table completely. Now personally, I find working under such circumstances to be insufferable and I would never voluntarily do so. But for the poor unfortunate souls in such a position, an argument could be made that avoiding Moose is being risk-adverse. (Again, I very much do not subscribe to this philosophy, but it's out there.) 
There's been 10 *years* of Unicode improvements since Perl 5.8. 
Putting Moose in the core would not achieve the goal of being able to assume that it exists. Just look at [enterprise distributions](http://www.reddit.com/r/perl/comments/1h9h01/is_the_procon_modern_perl_divide_a_symptom_of/cas57qu) -- enterprise users will be using perl 5.8.8 until 2020 and perl 5.10.1 until 2023. If the decision was made at this very moment to put Moose in core as soon as possible, it would mean 5.20.0, due to be released around May 2014. It would almost certainly miss the development cycle for RHEL7, which is due out in the latter half of this year, which means it would live on until 2013 + 13 &amp;asymp; 2026 in extended lifecycle support with perl 5.14 or whatever they decide to ship. That means that at a minimum, if you made the decision right now at this very moment, it would be at least 5 - 15 years before "coreness" would result in any appreciable change in status. And at what costs? The perl5porters do *not* want to be saddled with the burden of all that maintenance for the entire future. Removing things from the core if at all possible is the name of the game now.
Managing big modules in core is a mess that the Perl maintainers are generally moving away from. If you want something small that you can package with your script, try Moo.
Yeah, unfortunately, Moo does have a few dependencies. But if you are willing to bundle one pm file with your script, how much more difficult is it to bundle four? There are many ways to do this with Perl. FatPacker, for example. I'm not really close enough to the core maintenance issue to explain it better myself. You can find much discussion on modernperlbooks.com. http://modernperlbooks.com/mt/2009/02/hanging-the-core-out-to-dry.html http://modernperlbooks.com/mt/2009/05/what-is-a-stable-core-anyway-the-dual-lived-problem.html
Pretty much the entire point of Moo is that it has minimal dependencies and zero XS dependencies, for the *specific purpose* of making it easy to bundle or fatpack with scripts, without any hassle or worry about whether it will work on different platforms.
Moo is faster with certain XS modules installed, but it works just fine without them. And most things just aren't that speed-sensitive.
I argue the opposite. Core should only include the bare minimum that gives a way to install things from CPAN. If you are stuck with the distro perl because of political BS, it's nearly impossible to update any module that is part of core because you mess with files provided by the perl package, so you're stuck with ancient versions of everything, not just perl itself. Maybe make a perl-libs-common or something to contain a lot of commonly used modules for people who are forbidden from installing things from CPAN, and let the rest of us disassociate perl from the libraries. My $0.02
As the [documentation](https://metacpan.org/module/Crypt::OpenPGP#pgp-encrypt-args) specifies, `Recipients` is supposed to be something that identifies the public key, not the text of the public key itself. When I fix that, the text is encrypted as expected. Please strongly consider using strict and warnings in your code. [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) is a great resource you should check out.
That page linked to the source I got the list of non-core deps from. You can always look it up for any given version of Perl.
I'm writing some crypto software that uses GPG extensively. I looked into that module and found it quite lacking. It's actually easier to call out to gpg2 manually. To do that from perl, you just need IPC::Open2 or IPC::Run.
So, maybe it just works now. I actually do hope that I can make the upgrade happen sometime next month.
If installing CPAN modules is problematic for your clients, what about distributing your scripts as a perl module, with a makefile? You could even package the whole thing as a sharchive, so that extract+make+install can all be done with a single command or double-click. I've never tried to do something like that, but it ought to be relatively simple. Of course, using the \_\_DATA__ directive, you could even make a perl version of a sharchive. Something like use Archive::Tar; my $tar = Archive::Tar-&gt;new; $tar-&gt;read(*DATA); $tar-&gt;extract(); chdir('yourdistro-1.2'); system('make install') __DATA__ #raw tar.gz data goes here
Or indeed, you could just directly call CPAN.pm methods to install your dependencies, e.g., CPAN::Shell-&gt;install "Moose"
Or better: http://search.cpan.org/dist/PAR/lib/PAR/Tutorial.pod
Yeah, when you call `gpg --list-keys`, it shows your keychain. Each key is identified by a hex string. Use that string as the ID. It think you can also use the email address as the key ID. I don't remember. I remember Crypt::OpenPGP being a bit of a pain in the butt. But we ended up using it anyway. Hang in there.
&gt; enterprise users will be using perl 5.8.8 until 2020 Whoa, that’s depressing.
Two factors: 1) Moose is actually quite heavy. As such, maintaining it and all of its dependencies in core would be quite a pain 2) A lot of people don't use it. I know a lot of perl developers and only one of them uses moose. When we're asked by him why we don't, we always site the same reasons: very heavy for what we see as not much benefit.
Remote subcontractor for a fortune 100 co on a multimillion dollar product. good money, interesting work and they leave me alone to get on with it. Also use perl to support academic research (text analysis). 
Also worth nothing is that there are many add-on policies that people have written. My own set is http://search.cpan.org/dist/Perl-Critic-Bangs/ but there are plenty of others. Writing your own policies is a little arcane but not difficult.
I'm also looking for comments about experiences with, or published results of using, [perlbench](http://cpansearch.perl.org/src/GAAS/perlbench-0.93/README), [perlformance](http://renormalist.github.io/Benchmark-Perl-Formance/), and any other useful perl benchmarking tools.
I wanted to note that this is available as a Debian package: libcpan-uploader-perl (in fact, [apparently I was the person that uploaded it](http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=559066))
[Dist::Zilla](https://metacpan.org/module/Dist::Zilla) has this ability, and does lots of other awesome stuff for you as well - make your make/build file, tie in to pod weaver, auto generate your prerequisite list, auto generate readme from pod, tag and commit to git and more! It's incredibly extensible, and incredibly awesome Tutorial for it [here](http://dzil.org/)
Did you mean perl C:\bla\bla\test.pl with no leading slash?
If I type it that way it tells me "No such file or directory".
That suggests that you're trying to run a file that doesn't exist. Are you sure you're using the right filename?
Are you running test.pl or hello.pl? Be sure to verify the correct directory and file name.
You should stop reading that tutorial. It is terribly outdated and teaches bad Perl. Please stop by http://perl-tutorial.org and start with an up-to-date and modern Perl.
What advantages do Pinto/Stratopan offer over Carton for this use-case? Under what circumstances should one choose one over the other? AFAICT Pinto/Stratopan would be useful if for some reason you want to maintain shared modules that don't get posted to the public CPAN; otherwise, Carton or something similar looks like less up-front and ongoing work. And in an academic context, "ongoing work required" generally means "this will become unusable when the grad student/postdoc who maintains it moves on". What am I missing? NB: I'm a CS postdoc, and I'm deeply concerned by the problem discussed in this blog post! I'm very interested in anything that can help increase the reproducibility of my experiments.
Post jobs to jobs.perl.org.
Hey there, It sounds like Windows cannot find the file - probably the filepath is wrong or not formatted correctly. Try the following two methods: 1. Open the folder containing the file in Windows explorer (start windows explorer by pressing windows key + e). If you click the address bar it should display the filepath to the folder. Start cmd.exe and copy and paste this into the command line and add a slash plus the perl script filename to get the complete filepath. The path should begin with "C:\". Every folder should be separated by a backslash. Now enclose the entire filepath in speech marks - this is incase any of the folders have spaces in their names. Now type perl before the filepath and press enter. 2. If 1. didn't work, open cmd.exe and trying navigating to the folder containing your script. Use the cd &lt;folder name&gt; command to change directories (replace &lt;folder name&gt; with the name of the next folder to move into). If you aren't sure what the folder name is, type "dir" and press enter to get a list of folder names. Once you reach the folder containing the perl script, just type "perl test.pl". Definitely try to find a more up to date tutorial if you can, as recommended by mithaldu.
I second the recommendation for a different tutorial. But I still have a few questions for you. Why are you entering the full path in the first place? Running "perl scriptname.pl" should work just fine as long as you're in the directory where the script is. What's your actual path to the file (i.e., does it have spaces)? I doubt you have multiple levels of a "bla" folder. So if you've got a path that has spaces, you may need to quote the path -- something like `perl "c:\my folder\some scripts\hello.pl"` Of course that's only really relevant if you're trying to run a script in some other directory. Why are you using forward slashes instead of backslashes? On Unix, the directory delimiter is a forward slash, so /path/to/my/filename.pl looks right. On Windows, it's a backslash -- so your pathname should be something like \\path\\to\\my\\filename.pl Further, command line switches to Windows command use the forward slashes (example: "dir /a") so that fits the error message you're seeing about an invalid argument.
It still doesn't work for me when I use the 8 digit Key-ID. My exact code is here - http://www.codesend.com/view/543adb2ec6ee920a719187074f933fa7/ If I take out the line "Recipients =&gt; $key_id,", it encrypts the string perfectly. I assume I'm missing something else. I'm very new to PGP. From what I've read, as long as I have someone's public key I should be able to send them encrypted files. Is there something else I need?
You can use `C:\bla\bla\test.pl` with backslashes or `C:/bla/bla/test.pl` with forward slashes or even a mix of the two, but your syntax, with the "/" at the front, makes no sense at all.
You're exactly right: Carton is great for projects that consist of just one local distribution (or pile of files) and several CPAN distributions. But as projects become more complex, it is often prudent to divide them into several distributions, even if you never plan to release them to CPAN. Pinto is ideal for those cases. Even if you don't have multiple distributions of your own, you often end up patching distributions from CPAN, either because they have bugs or you want to add some feature. Pinto makes it easy to inject those patched modules into your repository. With Carton, that is not as straightforward, but I think miyagawa has made some improvements by integrating with git. Pinto also allows you to "pin" modules to a specific version, so if you learn that a new version of a module breaks your code, you can prevent it from being accidentally upgraded. Carton does not offer that feature natively, but you can use Carton with a Pinto repository to get the best of both worlds. Stratopan will have the advantage that it requires absolutely no software. Everything is hosted on the Stratopan server and all you have to do is point the installer at your repository in the cloud. That should minimize maintenance costs for you and your grad students :)
You should remove the `Passphrase` - that is for symmetric encryption, and you are trying to do asymmetric.
it looks like "/c/blah" where blah is the path to a file on C:\
Everyone users Perl.
Yes, that is also true. Pinto and Carton both aim to produce consistent builds with a predictable and precise set of dependencies, but they use very different strategies to accomplish that goal. Pinto creates a local repository of all the modules your application depends on (directly or indirectly). So when you build your application from the modules in your Pinto repository, you always get the same ones. The versions of the modules will only change when you choose to upgrade them in the repository. But dependencies often have complex and unexpected interactions. Upgrading one module may cause breakage in another module several steps removed from your application. So Pinto gives you an additional level of control called a "pin" which blocks a module from being upgraded in the repository (until you remove the pin). Locally patched CPAN modules are probably the best use case for pins. When you place a locally patched CPAN module in the repository, it is wise to pin it immediately because you don't want to "accidentally" get a newer one from CPAN until you know it has your patch (or has been fixed by other means). That reminds me of another difference: Carton has a modern distributed philosophy and can gather dependencies from lots of different sources, like CPAN or a Git repo. On the other hand, Pinto has a more traditional centralized philosophy and stashes a local copy of everything. So choosing one also depends on your infrastructure constraints (i.e. security policy) and your preference for one or many points of potential failure. I think the best thing about Carton is its simplicity and seamless integration with the VCS. And when/if @miyagawa fatpacks Carton into a single script, it will be super easy to deploy. In contrast, Pinto is a fairly heavyweight application. Pinto is reasonably easy to deploy if you use the [installer](http://metacpan.org/module/Pinto::Manual::Installing) or one of the Chef/Puppet kits out there, but it still has a lot of moving parts.
This perl script is missing one vital command: (Around the second or third line should do the trick.) unlink $0; #this is where all bad perl scripts kill themselves
OK, my mistake.
Aha, I think I see. Thanks very much!
DZ actually uses CPAN::Uploader. :)
Yet more evidence of its awesomeness! or something :)
I still believe language specific package managers (CPAN, Gem, CTAN, Pypi, etc.) were invented to make sysadmin's lifes miserable :) In an ideal world, such package repositories would provide a proper interface for querying each package's metadata which can then be used by distributions to generate the required packages on the fly, to be installed via the distributions package management system. This is at least partially done (e.g. g-cpan on Gentoo), but doesn't work in all cases due to some shortcomings of the upstream metadata, sometimes requires manual intervention etc.
That's why I like Perlbrew. Keeps the OS perl and the perl I actually want to use completely isolated. 
Package management conflicts are subtle and annoying. My CPAN modules do not always get along with my apt-get modules. This kind of problem should be mentioned. Sometimes they are built differently and sometimes packages overlap in peculiar ways.
unreasonable sysadmin, or it policy is surely the number one cause
I like Perlbrew, too, but I have run into some limitations -- the same limitations I experience with similar environment systems in other languages: How can I ask Perlbrew to ensure the right version of Debian package is present for a module I am cpanm-ing in? How does Perlbrew handle the case where I make use of "lib" to install different versions of the same Perl modules, requiring different versions of Debian packages to be present on my system? A perfect example for this might be a need for support of legacy Gtk 1 applications, where the old packages are not easy to simply apt-get. I am fairly convinced that the simple environment-changing solutions are not enough, that we need smooth integration with technologies like [vagrant/VirtualBox](http://www.vagrantup.com/) or [Docker](http://www.docker.io/).
Probably useful: [Learn perl in about 2 hours and 30 minutes](http://qntm.org/files/perl/perl.html) Definitely useful: * [metacpan](http://metacpan.org) - Nicer module search/browsing than cpan.org. * [Task::Kensho](https://metacpan.org/search?q=task%3A%3Akensho) - Recommended modules for writing non-shitty perl code. * [Moose](https://metacpan.org/module/Moose) - A better object system for perl (but you should still read and understand [perlootut](http://perldoc.perl.org/perlootut.html) and [perlobj](http://perldoc.perl.org/perlobj.html) at some point). * [Mouse](https://metacpan.org/module/Mouse) - Smaller, faster alternative to Moose w/ compatible syntax. Easy to deploy because all of its dependencies are in the perl core. * [perlbrew](http://perlbrew.pl) - Easily maintain multiple perl installs in your home directory. No need to mess with your system perl. (Be sure to run perlbrew install-cpanm after you set it up. [cpanm](https://metacpan.org/module/App::cpanminus) is a simpler way to install modules from the CPAN.)
Firstly: &gt; Install cpan (or even better, cpanm) and: HA! even if we assume that is done mnyeaah This makes me think you have not encountered the true depths of banal evil to which sysadmins/corporate policy can reach. How would you suggest doing that when you dont have any access to the box on which applications must run? Oh [App::FatPacker](https://metacpan.org/module/App::FatPacker), totally that'll work around those issues Aside from those xs modules you want to use because of the performance benefits OK so we can use the PP versions of those libs and take the performance hit Ah, but (for example) database access. Well for that we can plead with the SAs Oh, production boxes have a policy of not having make/cc/gcc on them Right so lets just wheedle the SAs into using a package of the XS lib in question Ah, there OS doesn't have one for the DB in use/it's so out of date that it is horrendously slow/lacking in features No problem we'll build our own package On the build environment, which doesn't exist or you don't have access to and so on and so on
I do at that. Thanks
Reposting the comment i posted on that blog post (it's still awaiting moderation): I find your conclusion quite flawed. fileinput is even more a piece of magic than @ARGV is. Just by looking at it you’d never suspect that it’s a wrapper library around system.argv that constructs iterators around the argv elements and then hides them away as globals. Even after reading the documentation i thought that `line in fileinput.input()` just generates an iterator which you slurped and printed wholesale in the line of `print(line, end="")` and only after adding debug statements and running it did i find out what fileinput actually does. A more fair Perl script to compare with would be this: #!/usr/bin/env perl use 5.010; use IO::All; for my $file ( map { io( $_ )-&gt;open } @ARGV ) { say “\nReading File: ” . $handle-&gt;file; print $file-&gt;getline until $file-&gt;eof; } It does exactly the same thing, is exactly as readable as the python variant and has a critical advantage in that it does not create *any* global state, but handles everything in neat objects. Addendum: After asking experienced python programmers, the current line of thought is as follows: 22:36:57 (Mithaldu) yo _habnabit, how often is python’s fileinput used in the wild? 22:38:05 (@_habnabit) Mithaldu, almost never; it was an okay idea with a bad implementation. there’s ways of doing it with the more modern argument parsing bits though
Please don't post code samples as images. Just cut &amp; paste the code into your question.
I'd do this: use HTTP::Request; use HTTP::Message::PSGI; use Plack::Request; my $request = Plack::Request-&gt;new(req_to_psgi($http_request)); my $query_parameters = $request-&gt;query_parameters; my $body_parameters = $request-&gt;body_parameters; ..but then, I'd be already doing this from a plack application, so I don't have to munge from an HTTP::Request object. There are also accessors available in [URI](http://metacpan.org/module/URI) (for GET query parameters), and [HTTP::Message](http://metacpan.org/module/HTTP::Message) (for POST body parameters). see http://metacpan.org/module/Plack::Request for the various interfaces for accessing arbitrary parameters by name. 
The prereqs of a dist can be pulled out of its META.json file. That file, from the latest stable release, is: https://metacpan.org/source/ETHER/Moose-2.0802/META.json Note that you only need 'runtime' and 'test' requirements. Users do NOT need anything listed under 'develop' -- that's just for people hacking on Moose itself.
Moo won't ever be cored either, though.
No, do not do that, that is terribly dangerous and error-prone code. Instead do what i pointed out already in [my comment](http://www.reddit.com/r/perl/comments/1hl9yh/program_error/cavf4xr).
Is it feasible to export the Excel files as HTML and then parse that? I've had some luck with that approach in the past.
I apologize in advance for the lameless of this answer. Perhaps you've already seen it. It requires a manual step, and VBA (Visual Basic for Applications), which I wasn't even sure I had. The good news is that it makes it possible to extract the URL from the hyperlink and put it in another column, so this data could then be parsed in Perl. http://howtouseexcel.net/how-to-extract-a-url-from-a-hyperlink-on-excel Essentially it tells you how to write a custom Excel function in VB, which you can then call from a new column that you create in the spreadsheet, as any other formula. You put that formula in every cell of that column and save the spreadsheet, and you'll be home free. But alas, I'm sure you're looking for a pure-Perl solution.
Hi, this might be an option, as long as I can do it from a perl script, I'll have to investigate this and come back with a reply and a possible solution thanks for the idea :)
Yes, in the spirit of finding a solution to the problem, no matter how lame that solution turns out to be, you can add this to the list. And it's not even THAT bad of a solution. But I would definitely prefer a pure-Perl solution in your shoes. While researching this, I learned something surprising. I thought that some combination of WriteExcel and ParseExcel might help you, and I saw in the "Known Issues" section of ParseExcel that it can't evaluate formulas in a spreadsheet created by WriteExcel. Silly me. I assumed that everything was speaking the same language... that what WriteExcel writes is the same thing that ParseExcel parses. But it actually has to go through Excel first, because apparently Excel puts the evaluated result of the functions into the file itself, which enables ParseExcel to read them. I guess that makes a tiny bit of sense. Otherwise ParseExcel would have to have a function engine built in, and I guess it doesn't. That's off-topic, I realize. But it was interesting -- sort of :)
can you be a little more specific on how can I do that?
http://search.cpan.org/~mschwern/URI-Find-20111103/lib/URI/Find.pm#EXAMPLES
I do this kind of thing often, but: `return 0;` is bad. As autodie says: &gt; It is better to die() than to return() in failure.
Sometimes. If it's a fatal "you didn't pass the expected parameter", then yes definitely. Other times, things may not be as clear cut. As usual, it depends... With artificial examples, and bad sub names like "process_quote_data", it's difficult to have actual opinions on what the right call is.
 my $sex = $args-&gt;{sex} // 'M'; You fucking sexist!
Thanks but that's not really what I need, as it says in the documentation: "Finds URIs and URLs in plain text" My problem is a bit different The thing is Spreadsheet::Parser module, which I use to get content out from an Excel file, doesn't read the part where hyperlinks are stored I can see them if I open the xls file with a hex editor, but the module doesn't read that far into the file, it simply was designed (yet) to do that So I don't have yet, any plain text to subtract the URIs I was looking for a module that can read the hyperlink data from the binary Excel file..or something like that
I went with @readparse solution, I populated another column with a VBA function that extracts the links and puts them as plain text in every cell, then I read the values in those cells with Spreadsheet::ParseExcel Seems to be to only solution atm Thanks
This stuff is really cool but it makes me fear for the viability of Perl6 overall. Like... who cares about all the innards stuff. Let's just get something working and out there in the hands of the masses before we lose the the mindshare war.
That is so funny. I am a recent Scala convert with a very long history with Perl. Looking forward to reading and maybe contributing to your guide! I wonder how many of us are out there? Perl + Scala?
&gt; I see alot of old stuff on the Perl Monks site, is that still a large area for perl congregations? Lose the idea that "old" == "bad". Some of the best stuff on PerlMonks (and some of the best written about Perl) is some of the oldest.
+1. Perl programmer, switched to Java (as part of a job change), trying to get started with Scala as it seems a middle ground.
I have drank all the kool aid. Scala is very expressive (in its own, type safe way) and VERY awesome. I love it.
[part 2 of 3](http://www.josetteorama.com/all-about-perl-6-interview-of-jonathan-worthington-part-2-of-3/) is now available.
I'm guessing these backslashes are a mistake? &gt; Note, however, that multiline comments need to be set precisely with `/\*` and `*/` (unlike C, you can't write something like `/*****\*`) and, if nested, comment tokens cannot be left unbalanced.
&gt; Perl version not high enough Note that this may be caused by h2xs's stupid insertion of a line requiring at least the Perl version used to run h2xs. Other boilerplate generators may do something similar.
instant job security, anyone? :)
this is r/perl. Why shouldn't we care about innards? As a data point, I care.
For those that are unaware of it, I've found Data::Printer to be much more useful than Data::Dumper. It's got "prettier" output, and handles complex hashes and objects a lot better.
It was even stated in Part 2. Could all this VM stuff be a distraction from the goal of having a working Perl6. Apparently Worthington does not think so. It's debatable.
This is cool, and it works fantastically on "basic" data. When I pointed it at the context object in a Catalyst app, however, it didn't do much beyond $VAR1 = Hash at 0xfoo
&gt; I'd say there's universal acceptance by regulars on #perl6 about the wisdom of doing both the JVM port and building MoarVM. I'm sure there's universal acceptance by the denizens of the wolf den about the wisdom of eating sheep for dinner too.
You're absolutely right. But I don't think that's such a horrible assumption to make, from the user side of things.
Sure! I can forgive someone who hasn't paid attention to P6 in the past few years for making that assumption.
I tried to think of all the relevant differences but let me know if there's anything I missed.
Gosh darnit this is what I came here to say.
Maybe clarify that arrays cannot be passed around *directly* by subroutines. I think after this mental model is established, it is okay parlance to say "it takes [a reference to] an array" or "it returns [a reference to] an array".
Would my $sex = $args-&gt;{ sex } // int rand 2 ? 'M' : 'F'; be better?
After reading something by MJD way back when, my understanding has always been: * Arrays get evaluated at compile-time, and their value depends upon context. * Lists exist at runtime, in the Perl 5 interpreter. One of `@these` is an array. Something like `1, 2, 3` in your code is a *comma-expression*. It *might* evaluate to a list, or it might not, depending upon context. 
I like the phrase "comma-expression." I might have to steal that.
Yeah, I totally get that and I sympathize with that argument, but for a beginner-level article I didn't want to get sidetracked in the semantics of what multi-dimensional really means. 
I don't think it's semantics, the can/can't be multi-dimentional part of that article is a terrible comparison. A array holds scalars, which can be references to other arrays A list contains scalars, which can also be references to other arrays. An array entry can't hold an array or a list A list entry can't hold an array or a list They behave the same way. You are comparing a list of lists to an array of arrayrefs which is a bad comparison, it's better to just say that lists-in-lists always collapse down into one list. IMHO
The best thing i can recommend for you is to stop by in #win32 on irc.perl.org and talk with bulk88, who is currently doing the main development work on Win32::API.
Can you give an example of a multi dimentional list in general, and then a perl implementation example? I do write code in perl, but aside from arrays that hold references to other arrays I can't think of any other solutions Thanks
Thanks for the tip! I don't want to bug bulk88 before I understand Win32::API better, and I'm starting to get the hang of it, so I'll definitely give #win32 a shot if I have more specific problems than just asking someone else to figure it out for me. Passing off the work onto VB/C# is always an option, so I feel a little better knowing the Perl community is doing its best to integrate into Windows, but I have a safe fallback even if Win32::API comes up short.
I would probably have my Task just take a subroutine reference with exactly what I want it to do. Less behind the scenes magic with dynamic class loading and method invocation. 
I'm pretty sure the point of this implementation is that you can easily serialize the Task parameters and store them in a database or message queue.
I got the first one then I lost interest. Fun idea, though.
&gt; Notice! In order to save your progress you have to login with Facebook. NOPE! Really interesting idea, but this is such a turn off, I closed your site as soon as I saw that.
thank you so much !!!! please accept my humble upvote, i will digest and implement this soon!!
thank you to you too, I really appreciate the help, can't wait to sit down and try/figure this stuff out late this weekend, thanks again!
I just read through this and i think I pretty much understand it, fantastic, looks like this is exactly what I need thanks so much
It's your website... You tell us.
Is it my site? Oh those bastards changed domain and it's now fucking crosswords all over it :(
I assume the "python powered" image in the subscription confirmation page is a joke. Right? No offense to python. It would just be ironic.
I honestly checked the date on that release to make sure it wasn't April First. To each his own, but making HTML in that way looks like hell on earth. Rose::DB::Object is my model, Template Toolkit is my view, and Dancer is my controller. I am happy.
Yeah If you want to delegate auth to a third party, use [Mozilla's Persona](https://login.persona.org/) instead.
I must have implemented this exact thing a dozen times.
Welp, I feel like a nerd now.. [1.5 hours later](http://i.imgur.com/9qP0Bsq.png)
In particular, perlopentut is up for replacement ([old](http://perldoc.perl.org/perlopentut.html), [new](http://www.nntp.perl.org/group/perl.perl5.porters/2013/02/msg198673.html)). I don't care one way or the other for the new one, but I hope that the old version is not memory-holed like the previous OO documentation.
"Using Sun Studio Compiler for the Linux OS" This is the problem with how Perl5 is maintained and developed. Look at the recent changes in Python/Ruby/PHP and you see a list of real language features and additions. Yet P5P are worrying about whether a compiler from a dead platform will run on an OS it was never designed for.
.. [1.5 minutes later](http://i.imgur.com/L2wQ8AB.png) and I feel a bit like I cheated: $('.bar').width("100%"); ;) .. but I'm also kind of addicted solving it for real.
I guess that should be $class-&gt;new... Also, probably outside the scope of a simple example but I really love this little shortcut: if (my $method = $entity-&gt;can( $self-&gt;method_name )) { $method-&gt;( $self-&gt;method_args ); } (Comments are broken on the blog)
And this is why Perl runs everything important on the internet, and those other languages are only used for blogs and other high-noise disposable entertainment, where nobody cares if the foundation of their website ships with failing tests or known security vulns.
Don't expect to use returns from a callback function. Store your values in the object.
You don't want h2xs. I created Module::Starter as a successor to h2xs. It will get you started. RJBS created Dist::Zilla as a successor to Module::Starter. It has far more features that you may or may not need.
Thanks much for your reply. My understanding of the Windows SDK, event hooking, and most importantly Win32::API has improved significantly since I posted this. I realized quickly I needed a "P" type in the import, but I appreciate you explaining it in detail. As it turns out, my call didn't even require this parameter to be defined anyway, but it's important to understand. The most important part was realizing the need for a Win32::API::Callback definition for the WINEVENTPROC parameter, as well as the necessity of the local type (vs. C prototype) import format, using the "K" type in import, which is well documented, and simply my fault for overlooking it. Overall, my eventual discovery of the need for Win32::API::Struct, Win32::API::Type, and Win32::API::Callback was the game-changer. My code looks like this (some omissions): my $SetWinEventHook = new Win32::API("user32", "SetWinEventHook", "IIPKLLP", "P") or die $^E; Win32::API::Struct-&gt;typedef("POINT", qw( LONG x; LONG y; )); Win32::API::Struct-&gt;typedef("MSG", qw( HWND hwnd; UINT message; WPARAM wParam; LPARAM lParam; DWORD time; POINT pt; )); Win32::API-&gt;Import("user32", "BOOL WINAPI GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)") or die $^E; # void CALLBACK WinEventProc( # HWINEVENTHOOK hWinEventHook, # DWORD event, # HWND hwnd, # LONG idObject, # LONG idChild, # DWORD dwEventThread, # DWORD dwmsEventTime # ); my $pWinEventDelegate = Win32::API::Callback-&gt;new( sub { my($hWinEventHook, $EventType, $hwnd, $idObject, $idChild, $dwEventThread) = @_; print join(", ", @_) . "\n"; return(0); }, "NNNNNNN", "V", ); # WINEVENT_OUTOFCONTEXT = 0x0000 my $hWinEventHook = $SetWinEventHook-&gt;Call(0x0800c, 0x800c, 0, $pWinEventDelegate, $ProcessID, 0, 0x0000); my $Msg = Win32::API::Struct-&gt;new("MSG"); while (GetMessage($Msg, $hWnd, 0, 0)) { } This is missing some definitions, but that's the core of the process, and it's working. Anything you care to mention that's wrong is appreciated. I've done more careful reading of all the documentation now that I understand this all better and I'm realizing it was really just my lack of understanding of defining types and the entire hooking/messaging procedure that had me lost, not the documentation. One thing: I am using strict and get warnings for undefined variables on line 317 of Struct.pm, for every variable in my packed "MSG" type, which is undefined until a message is received. I see you have "no warnings 'uninitialized';" on the previous branch, but I'm not sure why it isn't on the one my code is using. Have I don't something wrong? Is it unwise to suppress warnings on line 317 of Struct.pm? Overall, I'm really happy with this module. I feel... powerful &gt;:D thanks for your work on this. EDIT: Oops, just realized I had my $out in my Callback as "I", should be "V". Changed.
That's nice to hear. Don't feel compelled to learn every modern trick to use this thing, just try stuff and be yourself. Plain old perl is great too, just keep that in mind.
I personally prefer Dist::Zilla. It takes some effort to set up (you can go with a "sensible" bundle to start with, though), but it has saved me a load of time and pain. Miyagawa started a project called Dist::Milla, the goal of which I think is to simplify getting started with Dist::Zilla.
People who liked this also liked [Higher Order Perl](http://hop.perl.plover.com/). 
I've used ExtUtils::MakeMaker, Module::Build, and now settled on Dist::Zilla. I really love it. It's simple to use, convention-over-configuration, and supports plugins. It's kinda like Maven for Java, only with more and better plugins. I've not heard of most of those - I personally don't think they're really all that popular anymore. This Dist::Milla thing people keep talking about sounds interesting, miyagawa is a really prolific CPAN author, and people love cpanm, so that one seems like it might be worth a try :-)
By closures he means anonymous subroutines that can contain multiple statements.
Definitely Dist::Zilla. I have all kinds of reservations about it (mostly around speed and the awfulness of error messages propagated from POD::Weaver) but even with all that, I still find it to be the best option. Once it's setup, it makes publishing new releases MUCH cheaper, which is a huge win for the CPAN.
The classic example of a game written in Perl is [Frozen Bubble](https://github.com/kthakore/frozen-bubble) which uses [SDL](http://sdl.perl.org/). Another route to consider is making a game with a web-frontend and a Perl backend, ala [Lacuna Expanse](http://www.lacunaexpanse.com/).
You know, I have been playing Frozen Bubble on and off for the past eight years. Never would have guessed it was Perl in the backend. 
I use Module::Install for the sole reason Catayslt also uses it, and when I first wanted to make a cpan module I didn't know how so I kinda copied Catalyst. I like it, works well and is easy to use
for portability/purity/64 bit compatibility, you can't use all Ns, under the hood on x64 windows, the high bits are uninitialized garbage, things are not promoted to register size. If they happen to be all 1s (negative signed) or all 0s, meaning you N which really should be an I, is a valid number, that is just by luck. I include conversion to 32 bit parameters where needed. On 32 bit windows, DWORD and pointer are same size, so N==I, but on x64 N != I. N is longer than I. Problem with DWORD not being equal to a pointer on x64 is so big MS made a DWORD_PTR so you can regex your code and convert all the DWORDs to DWORD_PTR so "DWORD" can then hold a pointer safely on x64. # void CALLBACK WinEventProc( # HWINEVENTHOOK hWinEventHook, N # DWORD event, I # HWND hwnd, N # LONG idObject, i # LONG idChild, i # DWORD dwEventThread, I # DWORD dwmsEventTime I # ); For the official docs on basic win32 types, use (http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx). "I see you have "no warnings 'uninitialized';" on the previous branch, " what previous branch? What version of Win32::API are you using? I have to research line 317 in struct.pm before I give you a detailed answer which i dont have time this second to do. update: "One thing: I am using strict and get warnings for undefined variables on line 317 of Struct.pm, for every variable in my packed "MSG" type, which is undefined until a message is received." That is by design. undef doesn't translate to C well, it does, it is NULL pointer, so if you have a Win32::API::Struct and you didn't set some of it's slices, and you pass it to a C function, if some of the hash slices in it were undef, then you get undef warnings when you pass it to the C function. A number can be 0 in C, a number can't be empty or undefined (let us ignore #INF). Undef becomes 0 in numeric context in Perl, same thing happens in Win32::API::Struct. YOu get a warning in both cases. It is a feature, I think ;-)
Tools like Dist::Zilla don't produce boilerplate that you have to delete, as they build the whole dist in a separate dir, not into the same dir that you will check into SCM later.
Yup, Dist::Zilla is not perfect. Its startup time is truly horrible, plus the error messages are cryptic. But it's still a great and useful tool, the best the community has to offer at the moment.
why only two choices? why cant it be undefined?
"Introduction to functional programming in PERL"
[Higher-order Perl](http://hop.perl.plover.com/) is definitely worth a read for anyone interested in this
Except that it's an iterator that can stop at any time.
If you want that functionality wrapped up in a handy module, look at [File::Next](https://metacpan.org/module/File::Next). It is the basis for file finding in [ack](http://beyondgrep.com). The big benefit of this approach over File::Find is that you can stop the searching whenever you want. File::Find will keep calling your callback function until File::Find has decided it is done.
That "ack" tool looks very very promising, thanks for pointing it out
It's indispensable for me. There's a "standalone" version on the project website that's handy for your portable environment. ack won't replace grep for you, but it will save you a lot of time when searching code!
 my $sex = $args-&gt;{ sex } // @{[ undef, 'M', 'F' ]}[ int rand 3 ]; To allow easy addition of more choices you could even do: my @genders = ( undef, qw( M F )); my $sex = $args-&gt;{ sex } // $genders[ int rand @genders ];
If you tried to "sign up with email" and sign up button didn't do anything, please try again. I just fixed a nasty issue with Persona initialization :(
SDL has a [rich ecosystem](https://metacpan.org/search?q=SDLx) on CPAN. The IRC channel (#sdl on irc.perl.org) seems to be one of the friendlier channels ... even if they have a distinct lack of redditors amongst them. I'd start there, and ask #sdl if I had any questions.
This is a reimplementation in Perl/SDL. The classic game was a Java applet running in the browser.
&gt;Another route to consider is making a game with a web-frontend and a Perl backend, ala Lacuna Expanse. Great, very detailed game. Crown of Conquest is also web front end, Perl back end. http://blitz.crownofconquest.com/
&gt; ack won't replace grep No, that's not what it's for. It's a replacement for `find | xargs grep`. I can't thank Andy Lester (= petdance) enough for writing that tool. Thanks Andy!
The machine is probably giving you some other prompt string than what you expected. Maybe you should "waitfor('.*')" to see what's going on. 
Use [dumplog](http://search.cpan.org/dist/Net-Telnet/lib/Net/Telnet.pm#Debugging) - helps you figure out where things hang on waitfor.
Try setting prompt before making request. It's an [object method](https://metacpan.org/source/JROGERS/Net-Telnet-3.04/lib/Net/Telnet.pm#L2024).
Holy shit quit using telnet. Stop. Please stop. Please.
Telnet can be used as a generic communication with any open port; if you are saying "quit using telnet for shell access" then I agree with you--but as another goodie in the toolbox it's indispensable. 
Personally I would be spooked using the $ in a waitfor() command. For one thing, without a /m modifier it doesn't mean "end of a line" it means "end of the entire string." Exactly what is the "end of a string" in a streaming telnet scenario--the very last thing it sends before it disconnects? Just guessing here, but maybe try this instead: waitfor('/\&gt;\s*/'); Another tip: when writing interactive telnet software there always has to be some way to resolve an infinite waitfor(). You do know you can set a timeout, right? E.g. $telnet-&gt;waitfor(String=&gt;"&gt;",Timeout=&gt;15);
Great news, i can't wait for a working release.
Δ: https://metacpan.org/module/ARISTOTLE/perl-5.19.2/pod/perldelta.pod
Interesting bit from that delta: &gt; Under copy-on-write builds (the default as of 5.19.1) ${'_&lt;-e'}[0] no longer gets mangled. This is the first line of input saved for the debugger's use for one-liners [perl #118627]. Is that @{'_&lt;-e'} array new? I don't see anything about it in perlvar. Are there analogous arrays for named files?
https://metacpan.org/module/RJBS/perl-5.18.0/lib/perl5db.pl#DATA-STRUCTURES-MAINTAINED-BY-CORE
Starting to sound a lot like COBOL.
unfortunately it's true...and it's not the first time I've heard this comparison, that perl will become like COBOL...
This is interesting but the analysis needs comparison data for other languages in order to be meaningful.
very true but perl isn't the only one that's doing this, there are other languages that do this also, and the problem, perhaps the real problem is that perl lost it's "cool" factor (or whatever you want to call it), and this makes young developers go with other solutions (javascript, ruby, etc). Maybe a better, or a more aggressive marketing campaign, and cool new web-apps will solve this 
good point of view :)
Sure, I'm not trying to say that there isn't a growth problem in the Perl community. I have made several efforts over the years to make sure that at least one of vmbrassure's points in Part 3 is met. There will be Zero to Perl training at YAPC::NA next year. We will hopefully have a good volunteer program to help people afford to attend and get indoctrinated into the community. I just think that this idea that Perl is the New COBOL is reductive in this one case. People can still found modern projects and companies on Perl. They would be hard pressed to do this with COBOL currently. If we don't do something that may change, but for right now there is still hope.
It's sad that the community is not making its soft skills more of a priority. I agree so much it hurts. /perlabandoner
I keep turning my iPad on its side to read it then the damn screen rotates :)
Buy the three or so perl books by orielly, study hem as you are comortable, and program with a new library object everyday. 
See the side bar and go to http://perl-tutorial.org/. At a glance you probably want to start with http://learn.perl.org/ and then move over to http://p3rl.org/perlootut Possibly follow that with http://rjbs.manxome.org/talks/moose/Moose.pdf
Don't reinvent the wheel, learn to search http://cpan.perl.org.
Hi, would you consider changing your perlootut link to http://p3rl.org/perlootut or http://perldoc.perl.org/perlootut.html so that it's more likely to stay up to date in the future?
Done. I grabbed the link from the perl tutorials site so it may need updating there too.
Re: tricks, sorry, I worked my fucking ass off and my career still hasn't exactly been a smashing success. If you don't get much sympathy when asking for help, keep in mind that a lot of people are bitter, angry old men like men. In addition to the other suggestions here, you might also see if you have a Perl Mongers meeting in town: pm.org. Often dealing in real life is a lot... nice... and more productive... than begging time from over taxed people who are trying to triage the entire fucking Internet.
This is more for when you've worked your way through the beginner's Perl books, although it also does a handy job of explaining Perl quirks that may be of interest when you're trying to wrap your head around something: [Modern Perl](http://onyxneon.com/books/modern_perl/) I'm mostly self-taught, and am finding that this book is filling in the holes in my knowledge of Perl.
Stevan's since fired into action writing [p5-mop-redux](https://github.com/stevan/p5-mop-redux).
You realize you're talking about the creator of Moose here? There are few people who love Perl more than him, which is why he's brave enough to say the hard things; AND come out with a positive conclusion. Read to the end, please.
I didn't suspect anything, I read the code man.
The "Interactive Perl Tutorials" website linked on the perl tutorial hub is exactly what you are looking for. :)
I'd go Web::Simple and Text::Xslate. It should fit the embedded device effectively because Xslate is fast and Web::Simple provides just enough framework without a multitude of features you won't use.
Text::Xslate is very easy to plugin to Dancer and the framework provides a lot of nice functionality with not a lot of overhead. 
No, I would say COBOL or FORTRAN would be stronger candidates for decline and fall. Perl may be a little cryptic for the beginner but it has got a strong community behind it. Perl is widely used in the higher-education IT departments.
The current version is just a prototype to work out the syntax. Optimization comes later.
I got a reddit account. We prefer the sdl-devel@perl.org email list actually. Both me and Tobais (FROGGS) are all over the place in terms of time to be on the irc channel enough. Please email there for questions!
It's noble effort to get/create MOP support for Perl. I wonder if things won't tend to more towards Model Driven Development in the future with languages like AADL. We seem to be headed towards higher levels of abstraction, at least when it comes to software architecture. 
And even if the underlying daemons do not support it you can set up [stunnel](https://www.stunnel.org/index.html) on both ends to encrypt the connection.
I would start with reading the book 'Learning Perl' and maybe view some perl tutorials videos on youtube. There are many different ways to learn to program in perl. There are free perl parsers available so there should be worries about that. Then find a good editor to use for perl programming that highlights syntax and displays compiler errors. Eclipse+the epic plugin is pretty good for that.
Try Flask.
This was a very interesting read. Since it's not dedicated solely to Perl, I'd like to crosspost this to /r/python, if you don't mind.
You're latting irrational hate blind you to the fact that he isn't saying "Perl is COBOL", but "if we don't do something it might become cobol".
Obviously a joke. And a good one, IMHO. 
From the comment area: &gt; Shouldn't the entities be singular? "customer" not "customers"? This guy is right. Do you get a pickle from the "pickles jar"? Do you get a cookie from the "cookies jar"? Of course not, it is a pickle jar, a cookie jar, and a user table. /Pedantic rant
No, I only play acoustic. And I only know 3 chords. I thought "Stratocast" sounded better than "Screenocast" or "Stratoscreen" or "Screenopan" :)
It's not a joke. It means use "eval" in C -- i.e., evaluate C at runtime.
&gt; Do you get a cookie from the "cookies jar"? Of course not, it is a pickle jar, a cookie jar, and a user table. I'm trying to find out where, in the standard, it says to name tables in the singular, but I can't find that section in the Table of Content.
Great presentation, could not have said it better myself. Now if only people could get the ball rolling on some of these breaking changes...
So, do you have a clue? Will it be just about as slow as Moose? Is it great?
Don't bother buying Perl books -- unlike Ruby, Perl comes with excellent documentation in its man pages. If possible, use an older (5.10 or so) version of the docs, as newer versions are increasingly verbose and Bowdlerized. Use the CPAN, via http://search.cpan.org/ 
Really looking forward to this
I wouldn't have put it there, but I don't run things here.
Catalyst
Are Mojo and Dancer similar to Tomcat as far as containers go or are they more like a library for creating web applications?
I am kind of confused what Carton is able to do based on the write up. It sounds to me like it is a simpler way to tell CPAN shell what packages to install. Or do Carton also track the entire dependency tree and make updates as needed a la apt/yum?
The original AI Mind, available at http://ai.neocities.org/AiMind.html or at http://www.scn.org/~mentifex/AiMind.html in JavaScript, and of which I am the author, is not a toy or outdated, because it has developed the ability to engage in automated reasoning with inference. http://ai.neocities.org/AiSteps.html is the series of steps for creating a new version of the AI Mind in Perl or any other language. http://mind.sourceforge.net/perl.html is an outdated resource for the AI Mind in Perl. http://developers.slashdot.org/story/13/06/13/154226/learn-about-the-frdcsa-weak-ai-project-video seems to be an AI project involving Perl.
btw i have a one-page app for this: https://github.com/komarov/cpan-digest what's interesting about it is that it hides all but the latest releases of the same module
Is this a thing? When we conduct technical interviews, we tend to keep the questions fairly light - read a regex, shuffle an array, parse some common data, do some SQL, that sort of thing. Maybe a few opinion-ish questions, like when would you /would you not use objects. We're trying to weed out people that are clearly in the wrong room, and get a feel for your problem-solving skills if you're not. Brain teasers aren't a good test of that.
I had a interview that was like that today. I guess there are different interview procedures for different companies.
Keep in mind that interviews are two-way streets. You're collecting information on the company, and you should be weighing whether or not you like the company. I've found that interviews with lots of 'gotcha' questions and brain teasers are companies where the people think highly of themselves, and want to impress you. 'Conceited' might be the better term for some of them.
-9 is OBJID_CURSOR. Look it up in winuser.h, it is written as "((LONG)0xFFFFFFF7)". If you look at the letters table at the end of Type.pm, you will be confused, since you are looking at internals of Win32::API, those are mostly pack() letters in the table, not Win32::API letters. Win32::API letters are "inspired by" but **are not compatible** with pack letters. Don't read the source too much mkay? ;-) If you are dying to know where is Win32::API::Callback's "Win32::API to pack letter converter" is, start reading at https://metacpan.org/source/BULKDD/Win32-API-0.75/Callback/Callback.xs#L473
Well, I didn't get the job anyway. I was in no way prepared to do that many brain-teasers in that short of a time limit. Maybe I should look into something else like doing Java or C++. I've only been programming Perl for about 2 Years.
We'd be more likely to ask you to go through some of your code on CPAN if you had any; if not, we might pick a module that you tell us you use and ask you to walk us through it and explain how the code works. We will not ask you to explain Damian code, unless you really want to.
I'm maintaining one of Tim Bruce's modules. Still trying to figure out how the main engine does its magic... ;) I refactored it and achieved a nice speedup. But still need to meditate on the main engine.
Learned that tidbit at a career fair from USAA. (and to be honest, I wish I had learned sooner) Ironically, the next company I interviewed with gave me an IQ test; almost left it blank for the reasons mentioned.
I already know Java and C++. I've been programming in those for many years now. Maybe learn Ruby since that is the current cool language?
That's one problem that I have right now. I'm in a rural area with few software companies to work for. Moving is an option, but I would like to have a job offer first.
This was one of the puzzles: #Write code to generate the following histogram display based on the frequency of occurrence of characters in the first argument to the program. Example: $ perl histogram.pl "Mississippi borders Tennessee." s: ####### e: ##### i: #### : ## n: ## p: ## r: ## .: # M: # T: # b: # d: # o: #
Can't... resist... golfing! perl -le 'map{$f{$_}++}split//,$ARGV[0];for(keys%f){print"$_:".("#"x$f{$_})." "}' 
Nice one liner. I can see that there's still lots that I have to learn. This is my answer: use strict; use warnings; if (@ARGV) { print $ARGV[0]; my %occurances; my $occ = \%occurances; my @input = split '', $ARGV[0]; my @result_array; foreach my $char(@input) { if (exists($occ-&gt;{$char})) { $occ-&gt;{$char} = $occ-&gt;{$char} . '.'; } else { $occ-&gt;{$char} = '.'; } } foreach my $key (reverse sort {$occ-&gt;{$a} cmp $occ-&gt;{$b}} keys %occurances) { my $str = $occ-&gt;{$key}; $str =~ s/\./\#/g; print ("\n" . $key . ":" . $str); } } else { print "\n Usage example: histogram \"Mississippi borders Tennessee.\"\n"; }
I agree. Right is way better than fast. Just because you can hack out an answer under the time limit doesn't mean you can write good production code that is easy to maintain.
That's dumb. And entirely dependent on how you look at how the name of the table is used. In your case, you're saying it is an adjective. What type of jar is it? A cookie jar, where cookie is a singular noun that describes an entire set. We could also describe a set using the plural, a set of cookies, where cookie isn't a substance but an enumerable number of things. Select star from these cookies, or Perl as English syntax, `@cookies`, these cookies. I prefer plurals. A table is a collection of rows/relations. Cookies.
Well you can call it "dumb" if you want but it's the commonly accepted standard (e.g. see IDEF1X.) That's what it's really all about: so that if you pick up somebody else's database in a job setting you don't go nuts constantly getting errors like "users table does not exist". As programmers we have to do it one way or the other, and about 40 years ago we decided. You can go on with your plural table names if you like, but I feel sorry for whomever picks up your work in the future.
It's arbitrary. "commonly accepted" is debatable.
The sample output suggests sorting the output (by descending frequency and ascending character): perl -E '$h{$_}++for split//,pop;say"$_: ","#"x$h{$_}for sort{$h{$b}-$h{$a}||$a cmp$b}keys%h' Assuming that each bar is to be printed on a separate line. Edit: slightly smaller. perl -E '$h{$_}++for pop=~/./g;say"$_: ","#"x$h{$_}for sort{$h{$b}-$h{$a}||$a cmp$b}keys%h'
Yes, the output was supposed be on a separate line. reddit took out the newlines.
Score for taking over one of Tim's modules; double-score for not breaking it!
Mojo and Dancer are frameworks (a library of some sorts) that let you create web apps easy and modular and have a bunch of tools/features that you can use and not write everything from scratch. I know few things about Tomcat, something that it runs java servlets...but nothing more :)
I would break the functionality into subroutines, so that the main logic flow is a sequence of self-document routine names, such as: archive_files( $dir_to_archive, $new_archive_file ); I would use a command line args module ( I like Getopts::Long, but there are dozens to choose from ), so that things like the number of days to keep, the location of the backup root, and such, can be over-ridden on the command line. There seems to be some confusion between deleting the 3 day old and the 4 day old files, based on filename, and then deleting all over-old files, using John's quoted code. Also, using File::Find is excessive, it is more appropriate for searching a directory hierarchy, while here you are looking at a bunch of files in one directory. I would simply a "glob", ie a search on file by name-pattern: # near the top of the file my $file_pattern = 'backup.*.zip'; my $glob_pattern = "$backup_root/file_pattern"; # later on .... while ( my $filename = &lt;$glob_pattern&gt; ) { unlink $filename if -M $filename &gt; $number_of_days_to_preserve_files; }
If you're not a Perl developer or have one on hand then you might want to look into either a freeware or commercial back up tool to replace this process. Depending on how important your data is; you also might want to have online backups so that if you have a disaster hit your place where the servers are all the data is safely off-site some place. http://lifehacker.com/398229/five-best-windows-backup-tools
The script dies if the zip fails: $zip-&gt;writeToFileNamed($zipfile) == AZ_OK or die "Can't write &gt;$zipfile&lt;: $!\n"; However, it would not be a bad idea to sort the array of old backups and lop off the three most recent in case Archive::Zip lies or someone makes a stupid change to the script at a later date. However, this does not protect against a corrupt archive. It would be a good idea to verify the integrity of each archive new archive after writing it. Opening the archive for reading and getting a list of the contents would probably be good enough.
Thank you. I already have offsite backup, however I am preparing for the worst. I am creating duplicate backups of everything critical in a separate location such as IIS and SQL
If you want to find files older than 10 days, it's easier to use `10 &lt; -M $file` than calculating it yourself. See [perlfunc -X](http://perldoc.perl.org/functions/-X.html) (Note: ("Script start time minus file modification time, in days." sounds a bit complicated, but it's just the file's age (time since last modification) in fractional days.)
 #!/usr/bin/perl use List::Util 'first'; # find the hash which has the key we are looking for sub hash_with_key { my ($key, $hash) = @_; return exists $hash-&gt;{$key} ? $hash : first { ref $_ eq 'HASH' &amp;&amp; hash_with_key($key, $_) } values %$hash; } # find the value of the key in nested $hash sub get_key_val { my ($key, $hash) = @_; my $hash_with_key = hash_with_key($key, $hash); return $hash_with_key ? $hash_with_key-&gt;{$key} : undef; } Edit: updated variable names to get rid of warnings.
Very elegant looking solution, but I gave it a shot and came up with nothing. Here's what I plugged in to test it out; maybe I didn't understand the requirements of the subs correctly: my %hash = ( key1 =&gt; 'val1', key2 =&gt; { subkey1 =&gt; 'val1', subkey2 =&gt; 'val2', subkey3 =&gt; { this =&gt; 'is', a =&gt; 'test', so =&gt; { deal =&gt; 'with', it =&gt; 'son', }, }, }, ); my $v = get_key_val('deal', \%hash) || 'not defined'; print "\$v is $v\n"; And the output: $v is not defined
That apostrophe does not do what you think it does: http://perldoc.perl.org/perlmod.html#Packages &gt;The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to emacs macros. &gt;
Not sure how elegant this is, but it works with the test data you gave: sub get_key_val { my ( $self, $sought_key, $hashref ) = @_; # Recursion 101, start with termination case return $hashref-&gt;{$sought_key} if exists $hashref-&gt;{$sought_key}; # check for hashes in values of hash KEY: foreach my $subkey ( keys %{ $hashref } ) { next KEY unless ref $hashref-&gt;{$subkey} eq 'HASH'; if ( defined( my $found = get_key_val( $self, $sought_key, $hashref-&gt;{$subkey} ) ) ) { return $found; } } return; } 
Finally (unless I need to avoid work a little longer), if this is all you want the XML for, this is easier to do by directly looking at the XML. Twig is my go-to XML module, but most of the XML parsing modules will let you do something similar. #!/usr/bin/perl use strict; use warnings; use XML::Twig; my $xml = &lt;&lt;'EOXML'; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;root&gt; &lt;key1&gt;val1&lt;/key1&gt; &lt;key2&gt; &lt;subkey1&gt;val1&lt;/subkey1&gt; &lt;subkey2&gt;val2&lt;/subkey2&gt; &lt;subkey3&gt; &lt;this&gt;is&lt;/this&gt; &lt;a&gt;test&lt;/a&gt; &lt;so&gt; &lt;deal&gt;with&lt;/deal&gt; &lt;it&gt;son&lt;/it&gt; &lt;/so&gt; &lt;/subkey3&gt; &lt;/key2&gt; &lt;/root&gt; EOXML my $sought_key = 'deal'; XML::Twig-&gt;new( twig_handlers =&gt; { $sought_key =&gt; sub { my ( $twig, $elt ) = @_; # If the value can be nested XML rather than a simple # string, you'll need to do something different than grab # the text() my $value = $elt-&gt;text(); print "$sought_key is $value\n"; # Stop processing return $twig-&gt;finish_now(); }, }, )-&gt;parse($xml); exit 0; 
&gt; this is ridiculous I tend to disagree - IMO it's a *(desperate)* move to intorduce more "life" in Perl ~~cementary~~ community. You should watch [Michael Schwern's talk "Perl: Next Generation"](https://www.youtube.com/watch?v=TAOxGjNbp_Y) to see that many of these CPAN modules actualy *need* adoption. CPAN has a very important role in Perl world. There are more than 120_000 modules published by 10k authors, many of which are really great but unmaintained. I say this as "newbie" in Perl community - I've been working as a Perl developer for 3 years but only recently started to seek for more in Perl world. Occasionally I answer Perl questions on StackOverflow and [just yesterday I found a mature module people actually use](http://stackoverflow.com/a/17946723/708434) which has [five year old bugs](https://rt.cpan.org/Public/Dist/Display.html?Name=HTML-TagFilter)... THAT is why modules need adoption. P.S. Just not to be a hypocrite, I'll see if in the list there is a module I use and adopt.
A few suggestions: * When you're writing Object-like things, but don't want to commit to Moose, choose [Moo](https://metacpan.org/module/Moo). It is in pure-perl, won't slow your code down, and save you a lot of typing. * Please use [Perl::Tidy](https://metacpan.org/module/perltidy) to format your Perl code. Optimally you'll have a shortcut in your editor to do it. I've configured Ctrl+E to do that in mine and hit it after pretty much anything i type. * For file operations, use [autodie](https://metacpan.org/module/autodie). to avoid having to add a lot of "or die", or even more conveniently, use [IO::All](https://metacpan.org/module/IO::All). * Instead of Getopt::Long, [Getopt::Long::Descriptive](https://metacpan.org/module/Getopt::Long::Descriptive) provides a much nicer API. Otherwise this code looks pretty good. Thanks for taking the time to release this. :) (Next step: Release it to CPAN. ;) [Dist::Zilla](https://metacpan.org/module/Dist::Zilla) is cool for that.)
That's what I get for testing only cursorily. Sorry about that. The first subroutine needs fixing. # find the hash which has the key we are looking for sub hash_with_key { my ($key, $hash) = @_; return unless $hash; return $hash if exists $hash-&gt;{$key}; return hash_with_key($key, first { ref $_ eq 'HASH' &amp;&amp; hash_with_key($key, $_) } values %$hash); } Here's my test that I didn't paste in earlier reply: use Data::Printer; my $look_for = shift || 'foo'; my $h1 = { foo =&gt; 42, bar =&gt; 10 }; say '$h1 ==&gt; '; p $h1; say "find '$look_for' in '\$h1' =&gt; ", get_key_val($look_for, $h1) // "not found"; my $h2 = { blah =&gt; 0, h1 =&gt; {%$h1} }; say '$h2 ==&gt; '; p $h2; say "find '$look_for' in '\$h2' =&gt; ", get_key_val($look_for, $h2) // "not found"; my $h3 = { blarg =&gt; 99, baz =&gt; 1, h2 =&gt; {%$h2} }; say '$h3 ==&gt; '; p $h3; say "find '$look_for' in '\$h3' =&gt; ", get_key_val($look_for, $h3) // "not found"; And, here's the output looking for 'foo': $h1 ==&gt; \ { bar 10, foo 42 } find 'foo' in '$h1' =&gt; 42 $h2 ==&gt; \ { blah 0, h1 { bar 10, foo 42 } } find 'foo' in '$h2' =&gt; 42 $h3 ==&gt; \ { baz 1, blarg 99, h2 { blah 0, h1 { bar 10, foo 42 } } } find 'foo' in '$h3' =&gt; 42 
Part of me regrets not learning perl before a few years ago because I'd just know things like this. Thanks for the catch; sub name's been updated locally!
I didn't even know about Twig... I've been using XML::LibXML::Simple (because it's one of those things that was just "there"). If twig can do this kind of stuff then I think you just added another module to my to-learn list. Thanks for the reply!
https://metacpan.org/module/Data::Leaf::Walker
YAML::Syck is old and deprecated. from the POD: This module has a lot of known issues and has only been semi-actively maintained since 2007. If you encounter an issue with it probably won't be fixed unless you offer up a patch in Git that's ready for release. And as this module is basically an XS wrapper to Syck, and handling tied variables in XS is extremely problematic, this bug will never be fixed. So this module doesn't need adoption, it needs a deprecated flag. and anyway, nobody nowadays directly depend on it, but uses YAML.pm to abstract your YAML needs. Maybe that is not a bad idea, to make a deprecated flag for modules. 
I'll check out Moo, Getopt::Long::Descriptive (I looked at Getopt::Long:GUI already) and IO::All, but I wanted to avoid making people deal with dependencies or installing from CPAN. That's why I have people use curl, because they have to use Crypt:SSLeay to download files inside perl. CPAN may be too hard for some HN users/employers, and I'm writing it for myself, for people to use, and for a programming portfolio so I can get work, now that I'm out of school. Is there a good way to package modules into the program? Otherwise I may fiddle with those elsewhere. autodie is a good idea, and I may go through and implement it. It's probably not a huge priority over user facing features, but it's good to learn about common practices. vim runs perltidy with %!perltidy. but I've been bad about doing it each time before committing, and I'm still learning git, so I haven't figured out a good workflow for going back. I may set it to :make for perl files, now that I think about it. Anyway thanks for your suggestions and compliments. :).
hmm... hadn't thought of that. 
Wanting to avoid dependencies is noble, and possible. With Carton you can install a number of libs into a directory you can ship along with your script. The only thing you need to pay attention to is that those libs need to be pure perl, so grep the carton lib for .so after you installed things. Most of the things i suggested are purely stuff to make things easier for you, so yeah, nothing user-facing-important here. As for perltidy: The important bit is to make it reachable in such a manner that you can trigger it in such an easy way that it can become subsconscious in application. Since it's just a simple Ctrl+E for me, i find myself habitually doing it even when it's not necessary, or just when opening a new file that i don't know if it's tidied or not.
Sure, just save the results to a db then having the links for searching/displaying at the users requests. 
&gt; What kind of sick, perverted idea is it, by the way, that the Perl people seem to take pride in the randomness of order of hashes? An understanding of data structures and a deep respect for mathematics and the nature of identity. &gt; though for both PHP as for Javascript the spec appears to say that ordered in, ordered out is an accidental feature Even languages with as little design rigor as PHP and Javascript warn away from relying on particulars of implementation which may not always hold true.
Fork the project and jump on in- there's plenty of work to do in the [issues list](https://github.com/CityGenerator/CityGenerator/issues).
Carton seems to still be in alpha, but I will definitely keep an eye on it. I starred in on github
If you indent your code by four columns, it will be displayed inside &lt;pre&gt; tags.
FYI, ActiveState is a company. I don't think you installed a company on your computer. You probably meant that you installed ActiveState Perl. It's like saying you have a USB with files on it, when you mean that you have a USB flash drive or USB hard drive.
The reason is, the internships and junior positions for perl programmers aren't out there. Or if they are there, they aren't advertised. If you want people to stay with the language, You need to connect to students and graduates and build a pipeline from the colleges and teachers who teach perl to their best students, and hire them for internships and junior positons so they will continue to develop their skills. 
Is this using PPM? You can also use: cpan Module::Name on the command line. There's a build environment there including a compiler. 
Luckily you don't have 5.20 to target, when you probably won't even get to use CGI.pm (as it isn't shiny and modern perl-y enough for CORE anymore). But actually only using core modules is not a good strategy at all. Storable or *DBM_File (Model), no HTML except CGI (or Pod::Simple::XHTML perhaps), no templating except sprintf / heredocs / regex (View), bless or Class::Struct for your OO (Controller). Sure, possible. Perhaps you should Fatpack (or Bundle) the useful modules from CPAN, or better yet, convince your client of an alternative strategy. The one they have adopted will make the project much more complex and take much longer and likely have many more bugs (as you will need to be building everything, not just the app itself). 
As for routes, you could probably use File::Spec-&gt;splitdir to parse CGI-&gt;path_info() into parts and applying the parts incrementally or decrementally to a dispatch table.
Thank you. After the fact, I realized that I could've done this in fewer lines of code.
 $mem =~ /^MemFree:.*?(\d+).*?kB/m; See `perldoc perlre` and search for /Modifiers/ http://perldoc.perl.org/perlre.html#Modifiers
I am sure you understand these were the top 1,000 modules based on his current metric. He could have published the top 27,000 as well.
Here, have some Gold!
I don't see a valid reason for still doing it like that, unless you can charge them for all the boilerplate work, the extra overhead of doing mvc with plain cgi would make things sluggish, and you'd be rewriting Dancer or Catalyst.
I like devel::REPL personally. Along with perlcritic and perltidy, they are my required tools when working on a perl project.
This isn’t magic “calling methods without an object ref”. This is simply called *method chaining*, and is a fairly basic API design choice. The object reference is still there, it’s just the return value of the preceding call. The point about “Perl allows multi-line statements” is just plain silly, as insignificant whitespace is a basic feature of Perl. (If you were targeting Pythonistas, explaining the `bless` would have been more important than mentioning multiline statements …). It would also be false to attribute method chaining to “Perl’s flexible syntax”: Method chaining is possible in, like, *all* OO languages. Significant prior art would be C++’s unholy `&lt;&lt;` overloading for streams. I appreciate perltricks as a compendium of Perl idioms, but this post was a bit too far on the “obvious” side. However, I have to admit that the Boomerang was a very good example for this pattern!
Well, that's an incredibly inaccurate title.
Also very common in Mojolicious.
Mojolicious has no non-core dependencies, is written in pure Perl, and can run under CGI servers. All of that together means that if you manually "install" Mojolicious you aren't straying too far down the CPAN dependency chain. However by doing so you will have all of that power that you know you will lack using only CGI.pm. Have you asked this new employer why they would prefer to use an obsolete and under-maintained module just because it comes packaged with Perl?
Holy shit, so you would have complete access to all the Perl5 modules on CPAN? Maybe perl6 won't be vaporware after all...
ActiveState seems to be lagging with Perl and Python. Python hasn't had a release in a long long time.
even the last ones in the list have bugs open and no new release for a couple of years. The really last 20 doesn't have a dependencies, so they might be less relevant. I think that he cut in the right point.
&gt; any advice on general code improvements. 1) too much comments. You don't need comment like "Iterate over fourth-pass tokens". Just write "fourth pass" or rename loop variable accordingly so the code documents itself (you already did that). 2) iterating over array is much better done intuitively like: for my $token (@token) You never used index variable (my $i) but for accessing array element. 3) we use lexical filehandles now (see http://perlmaven.com/open-files-in-the-old-way). 4) try to trim line length to 80 chars per line or so, it's much easier to read. Otherwise, your code works, it's tidy and it's pretty good job :) 
I haven't switched to using 64-bit strawberry perl yet for a server at work and are using 32-bit 5.16 on win2k8. I haven't really had a need for extra memory yet for our applications we run. I did start testing a 64-bit strawberry perl I think 5.18 and wasn't able to finish install all the needed modules.
As others have stated, "Only Core Modules" is a silly requirement. Also, 5.18 is the current stable release, and 5.14 and earlier are unsupported aside from security patches. You may want to review the Perl maintenance policy (or have your client do so) at http://perldoc.perl.org/perlpolicy.html#MAINTENANCE-AND-SUPPORT The source code for Catalyst, Mojo, and Dancer are all available as examples that you can study. Look at Mojo in particular to get an idea of just how much code you're going to have to write to solve the problem - what you are faced with here is essentially re-inventing that wheel. 
&gt; too much comments. Yeah, and you try and find any bike-sheds that need painting too.
It looks for files with the same size, and then double-checks with MD5. Works fine as is, but any suggestions/tips are of course welcome.
Random thoughts from the few times I've thought too hard about this sort of duplication finding... If you're checking whether 2 files of the same size have the same contents you might as well just open both, read a BLOCK from both and directly compare BLOCK by BLOCK whether they're identical. Because: A) since hash sums **can** collide, even if the hashes match you'll still have to check them byte by byte to make sure you haven't found a collision; B) It should be faster to read BLOCKS and compare than to read all BLOCKS and do some heavy-ish calculation on BLOCKS to get the hash sum in the first place. Ideally, I'd take a set of say 12 files with matching size, read the first BLOCK from each and compare those, then I might find that 6 files had unique first BLOCKS, and then there were 2 sets (like one of 4 files and one of 2 files) where the first BLOCKS were the same. Then recurse and check the second BLOCK of each file of each set of matching files. Think of something like where you have 20 full DVD sized ISO images all of the same size. If you calculate hash sums of each you'll read in 20 humongous files and do hard-ish math over the full size. Do it the alternative way and you might find that all of them differ within the first few BLOCKS. Hash sums are good for many things, but not necessary for finding duplicates. Given two files to compare, doing a simple `cmp` is going to be faster than doing `md5sum` over both, comparing the results, and then still doing a `cmp` if the sums match. Though there's probably some break even point depending on how many files (of the same size) you have to compare and how large the files are, and how likely they are to be the same (or differing in the last BLOCK), how much memory and how many file descriptors you have to work with, program complexity, etc. Personally I just use `fdupes`.
&gt; you try and find any bike-sheds that need painting too. I don't think I've lurked here long enough to get the reference.
I believe OP meant this: http://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality
https://gist.github.com/bvierra/6164647
Man I feel dumb sometimes.... I thought it would be that simple and actually tried "last /var/log/wtmp.1" forgetting the "-f" 
He makes some good points but I don't think we can't call Perl ancient just yet. It has a few problems that need to be cleaned-up at some point though.
I thought that forking was a lost cause in windows, thanks for the info.
`require` is discouraged?
Language feature: autovivification -- this allows easy construction of complex data structures that accurately reflex their actual structures.
As an aside, instead of forking, you might want to investigate using one of the many Async modules like POE or AnyEvent, depending on your application needs, of course.
Sublime Text + strawberry perl Sublime Text Plugins for perl dev: (installed via package control): * SublimePerlTidy * CodeIntel (symbol detection) * SublimeLinter 
An alternative to the 'last' command you can use the Sys::Utmp module to parse the wtmp.1 file.
Can anyone tell me the source of the hostility for Eclipse around here? I use it daily for real world development with the SVN plugin and the E.P.I.C plug. It works great for me. EDIT: I use ActiveState Perl 64 for Windows.
I'm not an expert, but as far as I'm aware, the story goes like this: While the NT kernel in principle supports forking, the Win32 subsystem doesn't. This means that Cygwin has to jump through some hoops to fake it, which in particular means child processes need to load DLLs at the same address as the parent. This makes it necessary from time to time (in particular if you compile your own libraries) to rebase your complete Cygwin environment to keep the loader hints consistent; if this is not done or the loader fails to load the library at its preferred address (eg due to interference from a virus scanner), the program will blow up. In the past, you needed to manually rebase, but now the package manager takes care of it. Anyway, cross platform parallelism is better achieved through threads, but Perl has some issues with that...
Maybe as opposed to use()?
This.
Well earned bloat arguments. The last time I was in a situation where I had to fire it up, it seemed very slow on my Macbook Pro Retina -- which has an SSD drive. After realizing it was taking a long time, I timed it. It took significantly more time than starting up Windows 8 under virtualization. Think about that: what is more or less a text editor took more time to start up than an entire operating system. That is a poorly designed product.
Good start on solving your problem. As others have said there are dedicated solutions already, but hey learning is good too. I wanted to note a couple of things though, particularly that you are re-inventing the wheel using your recursive folder searching code. Use File::Find, it is part of the Perl core modules and saves you a bunch of time. Simply using the checksum is correct, but time consuming and, as has been noted, prone to collisions. I don't know how much it reduces the chance of a collision to require that both the file size and content be the same, but it might help. However this is a good approach to reducing the resources used by the app because you can get the file size from the file system, which uses a lot less resources compared to computing the hash for every file in the searched dir. On big systems this simple filter would greatly improve the performance as you now only need to compute the hash on files that have two or more files of the same size. Anyway here's a suggestion using File::Find; #!/usr/bin/perl use File::Find; use Digest::MD5; my %groupBySize; find({ no_chdir =&gt; 1, wanted =&gt; sub { -f $_ || return 0; push(@{$groupBySize{-s $_}}, $_); }, }, @ARGV); my $md5 = Digest::MD5-&gt;new(); for my $fileList (grep { @{$_} &gt; 1 } values(%groupBySize)) { my %md5sums; for my $file (@{$fileList}) { open(my $IN, '&lt;', $file) || die "Error opening: $file: $!\n"; $md5-&gt;addfile($IN); push(@{$md5sums{$md5-&gt;hexdigest()}}, $file); } for my $fileList (grep { @{$_} &gt; 1 } values(%md5sums)) { print join(' ', sort(@{$fileList}) ), "\n"; } } You can exlude ".DS_Store" in the "wanted" sub using substr($_, -10) eq '/.DS_Store' &amp;&amp; return 0; But what happens if you want to do this to more than one file? Then you could use GetOpt::Long to add command line switches support to exclude files. E.g. use Getopt::Long; use File::Basename; my @exclude; GetOptions( 'x|exclude=s', \@exclude, 'help' =&gt; sub { print "$0 [--exclude=&lt;filename&gt;] &lt;dir&gt;\n"; exit } ); Then in wanted() add this before the push() my $file = fileparse($_); scalar(grep { $_ eq $file } @exclude) &amp;&amp; return 0; Anyway, just some ideas to simplify it and flesh it out. **TL;DR Use File::Find, maybe turn it into a full command line app**
Why do you think it's in alpha? I see nothing here that indicates that: https://metacpan.org/module/Carton
This is for a design position ( HTML, CSS, etc) not perl development. 
I also use Eclipse/EPIC and my only real complaint is load time. I do prefer Sublime Text but it's file-tree panel chokes on v.large codebases so I cant use it at work (Eclipse handles this fine). 
Just timed my setup and it took 17 seconds to load on a Core i5 laptop with 8GB of memory. 
...which in my world is really slow. I'm not sure if you have an SSD or not, though. Here are some load times on my end: Word: &lt; 3 s Mathematica: &lt; 3 s XCode &lt; 2 s Windows 8 (Virtualized): &lt; 7 s Eclipse: &lt; 10 s
Numbers from TFA: &gt;&gt;&gt; 5194 / 7239.0 0.7175024174609753 &gt;&gt;&gt; 179 / 289.0 0.6193771626297578 &gt;&gt;&gt; 0.7175 / 0.6194 1.15837907652567 Assuming relative popularity is that matters, the smaller numbers differ from the large values by about 16 %. Therefore, it isn't terribly unfair to use the smaller figures to compare perl and python to each other, though they are no doubt less accurate.
Yes, it's the paid version. But Komodo Edit also support both Perls. Actually the Sublime Text CodeIntel plugin is taken directly from Komodo Edit. 
No SSD here but like always first load after startup is slow, subsequent loads much faster due to caching. My Word loads in about 1 second.
Each of those was a fresh start. Word is Word for Mac, not Windows.
Rick got it right. Click the links to see the actual search results. Of the first 20 hits for Perl, 17 are actual hits on Perl. Meanwhile for the 20 Python results, 5 are actually about the programming language.
Confirmed. So there are indeed many results under "Perl" which are not counted, and there seems to be far fewer results under "Python" which are not counted. Curious that this is the case.
One solution, which I'm considering falling back onto, is compiling this loop function into a standalone executable, which will cooperate with some flavor of IPC to communicate with my app as it obtains event results, and using Win32::Process to manage it. This seem bulky compared to a possibly more elegant solution using threads/forks, but so far, that's not proving true.
Not all that curious. As Rick explained and the article mentioned, Perl is Perl, Python is a snake, a comed troupe and a language (and quite a few other things). :)
Would it be unreasonable to contact the TIOBE folks and ask them to update their algorithm to account for cases like this? That seems a much smaller effort than updating every perl resource to work with their algorithm. The algorithm is clearly flawed as it is now.
Wow, beautiful code.
Wonderful examples with very relevant use cases. A great balance between generalization, usability, and configurability.
Thanks for the kind words!
Looks very interesting. But I'm surprised that you only deal with RSS feeds. Don't you ever have to handle atom feeds? Perhaps you could look at replacing XML::RSS with XML::Feed, which handles both types of feed.
[Plagger](https://metacpan.org/module/Plagger) is another similar, though stagnant project.
Atom support would be nice, but so far almost every feed I've been interested in has been readily available in RSS form, so the feature has lacked urgency. One notable exception is blogspot.com, which supplies an Atom feed by default and refused to yield an RSS version, no matter what I tried by following various tips--extra CGI parameters, alternate paths, nothing. Finally, after way more searching than I ever thought I'd have to do to resolve a straightforward technical question, I found that I got RSS if I used the user-agent ID "Friendster". That problem provided the impetus to switch from LWP::Simple to LWP::UserAgent and implement a configurable user agent string.
I didn't think people wrote perl in windows, is this really a thing?
No mention of Notepad++? 
Padre IDE -- Has TONS of options (regex editor, Package installer ((cpan or local)), debugging, breakpoints, extensible plugins, etc.) but is still pretty lightweight. Notepad++ -- (You already have it installed)
Because I need mod_perl, which won't compile unless perl has threads.
http://perl.apache.org/docs/2.0/user/install/install.html You only need threads if you use the "Threaded MPMs" all other choices list threads as optional. Most people go with the pre-fork in my experience. 
I have that very same page open six tabs over.
Yeah, unfortunately. I'm kind of constrained.
Prefork is the correct answer. Edit: Actually, these days the "correct answer" is psgi compatible backend (plackup, starman, etc.) then you can use any web server to proxy requests to the backend server. This sets you up to scale by decoupling the application from the web server.
Actually, I believe I've asked the wrong question. All I'm really trying to do is get apache to load alternate libraries in @INC without having to call out libraries in every freaking perl script. And I have f***ed it all up. 
Maybe it would help if you took a step back and explained what your problem is and what you are trying to accomplish? I know, especially after looking at a problem for 3 days, I get tunnel vision and only explain the small piece I'm looking at (since I have the big picture in MY mind) without regard for the big picture, then I only get partially helpful answers. Anyway, just my $0.02
Everywhere you have linked to the issues returns a 404, is this the link you were intending: https://github.com/CityGenerator/CityGenerator/issues?state=open ?
set the PERL5LIB or similar environment variable.
I don't think that having "perl programming" on every page that talks about Perl will solve the main problems. I don't think this will suddenly increase the number of people looking for Perl http://szabgab.com/perl-python-ruby-php-and-html5-on-google-trends.html BUT I do think that TIOBE has an impact on perception and the comments of RickTick and then of mithaldu convinced me how the lack of "perl programming" on the Perl sites lies to TIOBE and any other organization who checks thes numbers. "Of the first 20 hits for Perl, 17 are actual hits on Perl. Meanwhile for the 20 Python results, 5 are actually about the programming language." You could also try "perl -programming" and "python -programming" to see which pages have the could be updated. So I added "Programming Perl" to all the pages on the http://perlweekly.com/ and on the http://perlmaven.com/ sites. That's about 400 pages. Now we only need Google to re-index those pages and to see them as "important". 
I'm trying CodeIntel, it says that it can't resolve symbols, tried with moose and plain old blessed refs, no luck. Does it work for you?
CodeIntel is somewhat weak with perl, unfortunately. Pretty much just detects CORE + stuff that's in file.
Do you happen to know what secret sauce these modules use to implement forking on Windows?
Could you give an example of where this is useful?
yes- my bad; we recently moved it to an organizational repo as more devs join me. I thought I had edited all of my comments to fix this :/
The thread this reddit post links to also has an incorrect link I believe.
Danke- fixed it as well.
I'll be there tomorrow
This is a good way to get hacked. 1. Quit running stuff as root unless you REALLY need to. 2. *IF* you have to, drop privs ASAP. 3. DO NOT EVER DO THE EQUIV OF 'env perl' unless you want to open yourself to having a trojaned perl injected via prior path in your local environment.
Apropos username.
It was fantastic to learn about Larry Wall's history and personality. Amazing stuff, thank you. 
From AnyEvent::Util &gt; Win32 spoilers: Due to the endlessly sucky and broken native windows perls (there is no way to cleanly exit a child process on that platform that doesn't also kill the parent), you have to make sure that your main program doesn't exit as long as any fork_calls are still in progress, otherwise the program won't exit. Also, on most windows platforms some memory will leak for every invocation. We are open for improvements that don't require XS hackery. &gt; Note that forking can be expensive in large programs (RSS 200MB+). On windows, it is abysmally slow, do not expect more than 5..20 forks/s on that sucky platform (note this uses perl's pseudo-threads, so avoid those like the plague).
Which is 100% true and valid for programmers (which I understand why it is said in here), however remember that manager types could care less. They want it to just work, so finding a way to make it work is a great piece of information to have. If my CEO asked me if Work works under linux, the answer is yes. The answer is not yes, but it really doesn't run in linux it runs in wine which is not really an emulator but is similar, what that? no not wine like you drink... never mind...
I don't get it ... why not just use the full path when needed? Also, in bash, don't use which, it may be confused. Use type. Which will get confused about echo because it is usually a shell built in (even though the binary exists).
I suspect getting TIOBE to change their index would require a much *larger* effort than updating Perl resources to work with their algorithm.
This version uses perl as the sink in a pipeline. It builds a hash of arrays of filenames with the same md5 sum, then prints arrays with more than one filename. find . -type f -print0 | xargs -0 md5sum | perl -naE ' push @{$s{$F[0]}}, $F[1]; END{ for (keys (%s)) { say join " ", @{$s{$_}} if ( @{$s{$_}} &gt; 1); } }' 
Being stuck on Windows does not mean you do not need a text pattern matching tool.
Stuck is the right word XD
lol
I'm assuming your web user is not in your default users group, and maybe your perl libraries are not set to read all? Are you running the perl scripts from the command line as the webserver user?
 You might be able to your OS's package manager (probably rpm or yum) to force re-install or repair the perl package. For example, if you're on a Debian based system, this might work for you: apt-get install --force perl. You haven't given people much to go on here, so I think that's why you got downvoted hard. Without some concrete details, people like me can only guess at vague catch-all fixes like "try rebooting" or "try re-installing". That's crude at best. Here are some details that would help a lot in a report like this: * Which OS you're running. Ubuntu? RedHat? CentOS? Debian? Which version? * What was the actual text of the error message you saw? Don't paraphrase them; cut and paste them. * What did you do (exact commands if possible, fetch them from 'history', or else a description) that you think led to the breakage? For a list of things to include in questions like this and some good strategy for helping people help you, please please read this: http://www.catb.org/esr/faqs/smart-questions.html That'll save you and the people trying to help you much grief over your career. Good luck! 
Also, http://perlmonks.org was created to help people with perl. They might be more... helpful. I think people mostly want to see news and discussion on here. #perl-help on irc.perl.org is also for help. The problem with offering help in a discussion forum is that questions and problems completely drown out any other discussion, and then people have no where to go for news and discussion, so people find it useful to segregate the two.
&gt; Are you running the perl scripts from the command line as the webserver user? Unfortunately, I can't test that, as I can't su to apache. However, the modules are globally readable.
To answer some questions: RHEL 6.4 running perl 5.18.0 / apache.2.2.15 / mod_perl 2.0.8 Cryptic error messages: [Tue Aug 13 15:02:21 2013] [error] [client 69.171.160.52] Can't locate CGI.pm: Permission denied at /home/washoe/www/test.cgi line 3. [Tue Aug 13 15:02:21 2013] [error] [client 69.171.160.52] BEGIN failed--compilation aborted at /home/washoe/www/test.cgi line 3. [Tue Aug 13 15:02:21 2013] [error] [client 69.171.160.52] Premature end of script headers: test.cgi And what could I have done to cause this mess? I've been down so many dead ends it's hard to say, but I *think* it has something to do with apache/perl/mod_perl But let me throw a hypothetical out there: when I started setting up this server, it was running perl 5.10, and there were many, many modules installed. Now that it's running 5.18.0, do I just need to reinstall those modules? 
OK, that "Premature end of script headers..." is because the script did not finish the HTTP header. It can be ignored; it will go away when the script works. Check to see if all the directories are also readable by the user, group, and other. The "Permission denied" is also given it a directory along the path of the file is not readable.
&gt; I can't su to apache Do you lack permissions, or is there some other problem? If it's merely complaining about the lack of shell, use `su - apache -s /bin/bash `
It appears I've got perl installed in two locations, however both are world readable and executable: drwxr-xr-x 59 root root 4096 Aug 9 15:11 /usr/lib/perl5/5.18.0/lib/perl5/5.18.0 drwxr-xr-x 60 root root 4096 Aug 9 23:23 /usr/local/lib/perl5/5.18.0 And if you follow this [link](http://www.washoemedia.com/test.cgi) it shows what's getting loaded to @INC
Find out what perl you are using, and what perl apache is using, like this: $ which perl /usr/bin/perl $ su - root $ which perl /usr/bin/perl $ su - apache $ which perl /usr/local/bin/perl If they are different, as I have shown here, you'll know your problem.
Check all of the paths in @INC, they should be world readable and executable. 
Confirmed.
Professional game designer at a big company with no coding skills, but I've been using Perl 10+ years to perform many utility functions at work. The Technical Director wasn't super fond of it initially, but over the years he's made peace with it and even let me integrate some scripts into the localization chain. If you know what you're doing, you would look at my scripts and laugh, but they get shit done.
Ideally you should check them into some version control service, such as github. Then on other machines you can check them out and run them, using git to manage any updates. ( you could host the repos yourself but github do a damn fine job of it ). Alternatively http://gist.github.com if you just want to host the files and don't mind them being public.
look for a tiny vps service. They can be had for a couple bucks per month. Just google or maybe look here: http://serverbear.com/ 
I'm a big fan of Digital Ocean. $5/month VPS
you can do a full user directory CPAN install. the docs I used were very old but worked with almost no modification.
Why not use BitBucket (Free GIT hosting) and VM's with VirtualBox or something like that?
I think he's looking for a host on which to run the code. "run them on a remote server because I don't want to keep my PC running 24/7." BitBucket can store the code, but you have to have a CPU running somewhere :p VirtualBox or VMWare don't really work if the computer is turned off.
Here's a simple refactor: https://gist.github.com/wchristian/98bdbf20c109f300557d It can be made much better by using more CPAN modules, but since you seem to think that that would be a valid "complaint" i skipped that. ;)
It's only a complaint because quite often when I would need this, it would be on a box with no internet access and only the base perl modules loaded.
Nice clean-up, btw. :)
Can you go into this further? This may be a good topic for another thread, or if you have a blog, a blog article you could post as a thread starter here.
Thanks, feel free to ask about details of it. :)
You could replace nearest with this: sub round ($;$) { my ($num, $places) = @_; $places ||= 0; return int($num * 10**$places) / (10**$places); } Obviously the syntax changes slightly (nearest(0.01, $foo) becomes round($foo, 2)), but it should do the trick without any extra modules.
Couldn't you just then run a cron script that starts a remote shell?
please dont suggest prototypes.
I think I followed this: http://www.dcc.fc.up.pt/~pbrandao/aulas/0203/AR/modules_inst_cpan.html a search for "perl cpan user directory" turns up a variety of instructions similar to this page.
Putty with reverse tunnel to a minicpan on your machine! :D (I can keep going like this for a while. ;) )
The perlmonger groups closest to you seem to be: Milwaukee, Madison, Des Moines, Omaha and Chicago. Maybe you could try asking on their mailing lists.
I use NFS (nearlyfreespeech.net). I haven't tried or googled, but is there any reason you couldn't just use perlbrew and just install your own perl?
Why not?
because with the above proto, you can no longer do my @x = (2.81238121, 2); round(@x); why break that? what do you gain by using that proto? if you wanted to declare arguments and have them checked, use Function::Parameters. protos exist so you can replicate the behavior or certain builtins with user code. what builtin's behavior is being replicated here?
Any major financial company has LOTS of perl. JPMC/BofA/Wells/Morgan Stanley/ - you get the idea. They have loads of Perl. also [http://www.indeed.com/jobs?q=perl&amp;l=Minneapolis-Saint+Paul%2C+MN](http://www.indeed.com/jobs?q=perl&amp;l=Minneapolis-Saint+Paul%2C+MN)
make test
Have you talked to the local PM group mailing list? There were a good half dozen companies that did Perl in the cities a few years ago.
Amazon
"Sort of". You're paid in Euros, so that changes things. Rent is higher, but groceries are very cheap and high quality. Health coverage is cheap (and socialized), so again a major monthly cost is eliminated. Internet and cell phone plans are fast and cheap. International travel in Europe is cheap and easy. I get 5 weeks of holidays that I'm expected to take. Life is all about tradeoffs. I'm happy with my choices. (I moved from Montreal). Edit: missed the fact that public transit is great and so is the bike culture: no need for a car.
Milwaukee.pm (brew city mongers) sits in #milwaukee-pm on irc.perl.org all day, feel free to join us!
Maybe it's just resting after a prolonged squak. Great lists MPLS.pm, beautiful plumage!
Good news! I just got a new computer and got permission to install Linux on the old computer and have both at my desk with a KVM. https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcQ77AJF2dYNezoI8bQrz3yQ5AkGLbum0-Biwxq8DDj_iYfi0RdOMw
Do you use the 64-bit version?
Right tool for the job! I use Linux Mint here at work and at home and an Ubuntu headless server both at work and at home. Just curious, what are you using?
Here's mine: https://gist.github.com/mperry2/6250046 I moved the count to the first argument so you can specify more than one directory to search.
That's pretty clean. How are you handling the rounding? Just truncating?
Also, you're quite the lurker here...your name is kinda familiar too...
The rounding is being handled by printf. I'm telling it to expect a floating point number for the size. I also tell it to show two places to the right of the decimal point and display with a minimum width of 7 characters. That's what %7.2f does in the first argument. printf then does the heavy lifting.
Yeah, I'm not that into the internet, so I don't post or hang out on these sites much. I'm no one you'd recognize. Just another Perl hacker and everyday joe.
&gt; By your logic, perl should never have prototyped it's built-ins as they are susceptible to the same issues. Builtins have something like prototypes because that's how language syntax works, otherwise you'd never get any syntax errors out of your parser as it wouldn't know anything about arity or types or context coercion.
... because if there's anything Perl needs more of, it's context coercions to memorize.
Yes
Also, Moritz Lenz provided links and short reviews on each of the talks in his blog: http://perlgeek.de/blog-en/perl-6/2013-yapc-day-1.html http://perlgeek.de/blog-en/perl-6/2013-yapc-day-2.html http://perlgeek.de/blog-en/perl-6/2013-yapc-day-3.html 
If the box is on the other side of the planet, then you have a network, therefore you can reach the CPAN?
lolNo. Corporate firewall rules.
http://blogs.perl.org/users/bookingemployee/2012/03/truth-about-bookingcom.html
&gt; So what would have to happen in order for the Perl Foundation to support a move such as that? With the caveat that I don't understand why anyone ought to care what TPF thinks, someone would have to do the work and demonstrate stewardship of Perl 7 at least as good as the stewardship of Perl 5.
perldoc perlipc
&gt; Or maybe that's not even the right question. TPF holds the trademark to the Perl onion logo and the Artistic License suggests that if you fork Perl, you have to call its binary something else, but someone who forked Perl 5, renamed the binary `perl7`, and didn't use the onion logo would kick off a very interesting and difficult conversation about legal ramifications, responsibilities, rights, and remedies. The only way to make that more amusing is to throw in a venue change, such as if someone in Brazil or the Ukraine were to do this. &gt; But if someone could please throw us a frickin' bone with a version number, it would surely help. Only renaming P6 would help at this point, and that's not going to happen.
_sigh_
Since this seems to be getting upvotes, I'll respond. First, "truth" needs to be taken with a grain of salt. I don't think this is at all representative of the opinions of the majority of our developers, and it certainly is _miles_ away from my personal experience. Many of the claims require context: * "no new technologies" (conservative introduction of new technologies means we're _very_ skilled at the tech we do use), * "not allowed to design anything big" (because we run continuous deployment with modified kanban -- if all your stories are &lt;2 days development time, there *is* nothing "big" to design..), * "not allowed to write tests" (because we favour monitoring over upfront testing, especially when we roll out changes dozens of times a day to millions of users who will test combinations we could never think of, and also so we don't have to spend time writing tests for an A/B experiment that will be killed in a week because it's conclusively negative..). (That being said, my code has tests and I wrote 1000 lines in Go to help test my recent project.. ) And that's not even the first paragraph... I'm not going to respond further to this post, but I wanted to point out that "truth" in this case is subjective, to perhaps the point of being inaccurate. If anybody still wants to chat, ou can message me here on reddit or to my work email account: damian.gryski@booking.com , and I'll do my best to answer you.
I know, but think about it. P6 has been, in the public eye, "The next major version of Perl" for 13 years. To anyone not well connected to Perl, it looks like `perl` developers can't get their act together and do anything. If P6 gets renamed, that perception persists. If Perl 5 gets renamed, that perception persists. To some degree, it gets worse, because it looks like the Perl developers gave up on P6 and are trying to jump over the version number 6 to change the perception of Perl without doing anything technically to justify it. With that all said, renaming P6 is the best of those two options because it at least gives Perl a chance of gradually adding features and removing things that have outlived their usefulness with the yearly release schedule and the stronger version policy. That's been going on for a while, and it'll take a while longer to get into public perception, but it's the truth. The other possibility I consider so remote that I mention it only for completeness: P6 will eventually come out in a usable form and will eventually either run enough Perl 5 code that you can use both in the same process or will be so much better than Perl 5 in every way that Perl 5 will gradually fade away. Ask me again in a few years and I might change my mind.
What a rambling, pointless talk.
Nicely written tutorial. But using Perl in this case is a little overkill, when the following will do almost the same: for %i in (%PATH%) do @echo %i If you want numbering, it gets a little more complex: set n=0&amp;cmd /v:on /c for %i in (%PATH%) do @(set /a n=!n!+1^&amp;echo %i) The above snippets works without perl, but only on Windows/DOS.
Hmm, well I don't recall him saying "major" or anything equivalent actually. But to take one (overly and probably annoying) example, turning on "use strict" by default would be both (a) a major breakage for really, really old scripts etc. while simultaneously being merely (b) "one little thing" that wouldn't affect anyone writing in the post-1999 style. Shipping Mo* in the core would be a much bolder example. It's just a symbolic gesture, sure, but why do people feel symbolic gestures don't mean much? Oh well, back to coding.
Are the tildes in the output?
Nope, that was just for demonstration, there is a lot more user's than listed here.
was bored a bit, here is a modernized version of your script. #!/usr/bin/env perl use strict; use warnings; use v5.10; my $file = "/var/log/wtmp.1"; open(my $last, '&lt;', "last -f $file") or die "Couldnt open file '$file'"; my %times; while (&lt;$last&gt;) { my ($name,$days,$hours,$mins); if (($name,$days,$hours,$mins) = /^(\w+).+\((?:(\d+)\+)?(\d+):(\d+)/) { $times{$name} += 1440 * $days + 60 * $hours + $mins; } } say "$_ $times{$_}" for sort keys %times;
It would be a good idea to post the input file. unless of course it contains sensitive information. then you should post a similiar file with censored content that demonstrates the problem aswell.
Have you ever **seen** a wtmp file?
You're right, it was a typo, I'm missing the '|' in there. I'm still getting the same output regardless though, and this is indeed my whole script. My plan is to call this with Cron at 0001 on the first day of the month, so I can get last month's total login time per user.
Just replace "say" with "print" and add a new line. That's all say does. In this example, make this: say "$_ $times{$_}" for sort keys %times; With this: print "$_ $times{$_}\n" for sort keys %times; 
&gt; You're right, it was a typo The reason I pointed it out is that it tells me that this _isn't_ the same script. It means you re-typed instead of copy/paste, and if there's one difference there might be others. I don't see any way that the above script can produce repeated output, which leads me to suspect that the problem is (a) something different between the above copy and the real one; or (b) something about how the script is invoked. &gt; I'm still getting the same output regardless How are you invoking it? Command line? Cron? Another script? Is there something else different between the above excerpt and the true script? Even something trivial-looking that you might not think worth mentioning?
Here's the pastebin of the actual script. http://pastebin.com/Zu5pwXHK
Ugghh.... Nevermind, I'm an idiot. The original version works fine, but my dumbass was using '&gt;&gt;' to redirect the output, not realizing that was APPENDING to what was already there. Sorry everyone.
Thanks - that rules out a difference in the script. But how is it being invoked? [EDIT] never mind, I just read your '&gt;&gt;' comment.
It's worth knowing how to use perlbrew, so check that out too.
This nifty syntax is for Windows PowerShell. Thanks for posting this!
I swear by perl -d -E0
As mentioned by shimoco the snippets above won't work, when path elements contains spaces. In that case a one-line is (AFAIK) impossible with cmd, but it is possible in a script: @echo off setlocal EnableDelayedExpansion set P=%PATH% set N=0 :loop for /f "tokens=1,* delims=;" %%p in ("!P!") do set car=%%p&amp;set cdr=%%q set /a N+=1 echo !N! !car! set P=!cdr! if not x!P! == x goto :loop endlocal 
Nice to know it works for someone else. Thanks. I'm working in a cooperate linux environment, so I expect socks to work. I've used it in the past to connect to a gentoo system at home(don't have the system up and running now, unfortunately). At least this gave me a direction to focus my debug. Digging through more of the documentation of our socks proxy it looks like the mapping for the imap port 993 is likely not available. So I'll probably have to abandon this, since I doubt they'll want to open the port. Thanks again for the help. 
Web Developer for a top 20 asset management firm. Perl backend.
We could also turn on a bunch of useful [feature](http://perldoc.perl.org/feature.html)s and remove a bunch of syntactic oddities (like single quote being equivalent to ::), all of which we're shying away from in the name of backward compatibility, Edit: Also, regarding Mo* becoming core, [I was told](http://www.reddit.com/r/perl/comments/1h9i27/why_isnt_moose_core_yet/) by knowledgeable people that it'll be a maintenance nightmare, they're trying to avoid adding any more modules to the core apparently. 
That is rather true, a pretty unproductive session. I posted it for the five minutes of useful discussion and the opinions expressed (by brian d foy and larry), sorry it had to come with 35 minutes of fluff. 
While this doesn't solve the problem, if you use the command: ulimit -c 0 Core files won't be written
Well if you are really interested try running gdb on the core and getting a backtrace. It might give you a hint.
.cpanm/build.log
There is no such directory /usr/lib/perl5/5.8.8/.cpanm/. I just found them under /export/home/root/.cpanm. (The root home dir.) Now to find out where Text::Iconv went. It doesn't seem installed at all. 
Pretty much all Perl module installations are going to make their way back to either `Module::Build` or `ExtUtils::MakeMaker`. Where the file ends up installed will depend on what they decide to do. To get these to install where you want, append to your .bashrc (or .profile): export PERL_MB_OPT="--install_base /path/to/perl5"; export PERL_MM_OPT="INSTALL_BASE=/path/to/perl5"; What you may want to do is check out [local::lib](https://metacpan.org/module/local::lib), which sets up a directory in ~ for your CPAN modules.
&gt; why do you want to change where it's installed into? The problem is, the Text::Iconv was installed to /usr/lib/perl5/site_perl/5.8.8/i386-linux-thread-multi and even @INC contains that dir, but my Perl program is saying "module not found". At this point I have no idea what to Google even. Here's the error message when I try to run my test script: &gt; Can't locate **auto/Text/Iconv/New.al** in @INC (@INC contains: /usr/lib/perl5/site_perl/5.8.8/auto /usr/lib/perl5/site_perl/5.8.8/i386-linux-thread-multi /usr/lib/perl5/site_perl/5.8.8 /usr/lib/perl5/site_perl /usr/lib/perl5/vendor_perl/5.8.8/i386-linux-thread-multi /usr/lib/perl5/vendor_perl/5.8.8 /usr/lib/perl5/vendor_perl /usr/lib/perl5/5.8.8/i386-linux-thread-multi /usr/lib/perl5/5.8.8 .) at ss-xlsx.pl line 13 
Any entirely perl modules can simply be extracted to whatever directory you want and referenced via a use lib statement. Of course, you should go through the make process to run the test suite, but still.
Perl Packages generally come in a .tar.gz file, which is simply a tape archive that's been gzipped. They come with a meta information about the package which allows your CPAN utility to install it in the appropriate location. There's probably other ways to do it, but that's the way I've always done.
&gt; ss-xlsx.pl line 13 What exactly is on that file that line? use Text::Iconv; or something else?
It's this: `$convertor=Text::Iconv -&gt; New("utf-8","windows-1251");`
OMG it works! It works! (I'm a full-grown man flapping his hands happily.) Thank you! 
Glad to see it helped. Have a nice day, happy hacking and perling!
I see you've solved your problem, but as an answer to your original question: Use `cpanm` with the `-L` option. I.e., `cpanm -L /path/to/dir Some::Module`. As a side side note, in almost every possible case, it's almost always better to install and use perlbrew rather than muck around with system-wide perl installations: http://perlbrew.pl/
Another way is to use the -a (autosplit input lines) and -F (field-separator) switches: # on Unix/Linux $ echo $PATH | perl -F: -lane 'print ++$i, $", $_ for @F' 
&gt; As a side side note, in almost every possible case, it's almost always better to install and use perlbrew Goes double if you're stuck on redhat :-)
Before you abandon it a couple of ideas if the issue is the proxy blocking you; 1. Are all of your boxes inside of the proxy? If not could this be scheduled as a cron job on an otherwise quiet box, or on the proxy itself? Or on virtual host outside of the network. 2. Alternatively do you have access to POP3 through the proxy? If so then configure a Gmail filter to forward the messages that you want to see to a new Gmail box and using POP3/POP3S to get to the messages. (see https://metacpan.org/module/GMail::Checker) 3. When those status messages are sent, can you change the address that they are sent to? For example they go to your work address which you forward to your gmail account. If they initially go to your work account can the mail admin copy the messages to your script, or can you have them stay in your company mailbox and go to Gmail and thus access the company mail server from inside of the proxy? 4. If it is a Google Apps domain then you could access the inbox as an RSS feed. (see https://developers.google.com/gmail/gmail_inbox_feed) 5. If you have to fall back to screen scraping then there are probably modules to help you. I found https://metacpan.org/module/WWW::Scraper::Gmail but who knows if it still works with more recent updates. 
Stick with Oracle and learn Java. Seriously.
Thanks for the suggestions, but truthfully, it's not really work related. Just something I was messing with while waiting for code to compile. Eventually, I'll find some time to run the code at home where I won't have to mess with the proxy.
Have you not done programming before? I could not recommend Perl to anyone as a starter language.
Thanks for all the comments. I have done SQL, PL/SQL coding in my last job but my profile is more like Oracle ERP Consultant. Been looking for work in my background for 4 months, had some interviews but no offer and then due to the certifications I got an offer for Perl. It completely blew me off.. I mean I never ever thought I could get it. And so while I'm happy that I did get a job offer but not sure if I want to continue in this path. I do not want to program forever, I would want to move to Business Analyst or Project Manager position in some years and so would starting as Perl developer lead to this path?
Thanks, Oracle with Java. hmm.. this is something I had never thought before. Is this more like an application developer opportunities which these skills?
Perhaps not to learn the fundamentals of OO programming, but once you have a good sense of the basics, imo it's a pretty easy one to pick up and start writing with.
That's basically been my path. I learned Perl, then SQL, then became a "sysadmin who programs," and now I'm a "manager who programs and knows project management." Perl has been really good to me, because it's at home in app dev, sysadmin, databases, ETL, provisioning, etc. In any given company, there are relatively few who are willing to build things -and- manage projects.
Perl makes it far to easy to shoot your own foot/implement atrocities for a first language. Source: a career spent cleaning up such atrocities.
come to the dark side, we have cookies! :-) In you case, Perl will help you jump to the web side of programming. You will probably also learn HTML/JS/jQuery/CSS on the job, which will let you continue advancing in that world. So, good luck.
&gt; and has had some problems in it's community. Not sure what you mean. I haven't seen this. If anything, I'd say that Perl has one of the nicest communities around. Now, as for my *complaints* about Perl ... :) 
This is some bumper sticker shit. I agree.
Perl's community is shit. I can think of a couple of jackasses and weirdos. And before you say "every community has jackasses and weirdos" I'm asserting that Perl attracts an inordinate number of them. There's something about being a loosey goosey language that attracts loosey goosey people.
I wrote most of RedditAnalytic's API in pure Perl. Welcome to the community! I have it set up to search the previous 1,000,000 comments in about .1 seconds but I could easily scale to a billion comments. The only other language I know that could handle that volume of data that quickly is C (but I do have some inline C in my Perl scripts, so I guess I'm cheating a bit! :) http://api.redditanalytics.com/searchcomments?query=perl
Like any tool ever created. Don't blame the tool, blame the stupid.
Perl is an incredibly deep and flexible language. This flexibility can be both a blessing and a curse. On one hand the openness of Perl forces you to develop good discipline. On the other hand it's very easy to hang yourself with your own rope. This is especially evident when you start doing OO Perl. Perl's OOP is more of a discipline than a feature of the language. 
Oh I don't, one can make a terror with any tool, no matter how elegant.
Really? Perl was my very first language. I still use it for most of my tasks, even though I occasionally write code in R, Common Lisp, C...
I would suggest that whilst learning Perl might be useful, you shouldn't *only* learn Perl. Fewer and fewer new projects are started in it, and, especially on the web, other languages have more momentum and more active communities.
The community is having some marketing issues. They aren't pushing Perl as much as the Python commnunity is pushing Python. Also, there seems to be some fragmintation between Perl 5 folks and Perl 6 folks. Furthermore, it looks like it became popular for pundints of other languages to bash Perl as a language publically. The Perl community just wasn't fighting back. It looks like that is starting to change now though. As a community we're also not bringing in a lot of younger developers, they seem to be picking up Python or Ruby instead. Probably because they both have better Web frameworks/API's or Perl was just late to the game to either come up with a better one then its CGI. [http://blogs.law.harvard.edu/dlarochelle/2012/04/01/the-state-of-perl/](http://blogs.law.harvard.edu/dlarochelle/2012/04/01/the-state-of-perl/) 
The customer still owes me an xkeyscore login.
Very excited. Dates are Oct 4-6.
and me.
I know some will think I'm trolling, but honestly: been coding in Perl professionally since '98. I've tried all kinds of IDEs and editors on Linux, HP-UX, OS X, and Windows, and I always end up back at vim. It's clean, lightweight, configurable, portable, and easy to pick up. Use a package manager like Vundle or Pathogen, manage your .vimrc file and .vim folder in git. Code away. SublimeText, Notepad++, Komodo, Emacs, Textpad...the list goes on, but always ends with me being back on vim. Just two cents from an older Perl guy. 
Is it worth learning Moose now that 6 is around the corner?
Sorry about that! I just redid my site, and the mobile version is kinda wonky. I guess I'll have to get a hold of a nexus 4 for testing! 
P6 has been around the corner since Moose first hit the CPAN in 2006. Don't worry about P6; use Moose.
It really, really depends on context. In some cases, it makes perfect sense to not use "new". For example, the DateTime module's `-&gt;from_epoch()`, etc. set of methods. 
I wouldn't use DateTime as a model of clarity, wonderful though it is. It isn't at all clear from usage that these return objects and not some other kind of value (maybe a string representation), whereas something like: # alas, no my $dt = DateTime::FromEpoch-&gt;new( ... ); or: # nor this my $dt = DateTime-&gt;new( 'from_epoch' =&gt; 1, ... ); would be.
Although I agree that "new" is very often the best name for a constructor, I also remember when I had the realization that I could really call it anything I wanted to. In my case, I had a session class, and I wanted to take the current web context, retrieve the current session for that context if there was one, or create a new session and issue a cookie if there wasn't a cookie, or was a cookie and wasn't a session for that cookie. Then, given the session object, I would store data in it, to be persisted between requests. I was pleased with myself that I came up with the very natural-looking: `my $session = get Foo::Session;` ...as opposed to what I was going to do originally: `my $session = new Foo::Session;` In this case, I think the concern that I had about it was that I was asking this constructor to not only make a new object, but to also make a new session, OR to take an existing session. The word "new" for the constructor, then, became confusing. The word "create" would have been confusing in the opposite way. I needed a verb that fit either case. You could argue that I should have named my constructor "get_existing_or_new," or something like that, but "get" seemed to meet my needs perfectly, and it was easily understood by new developers when I introduced them to the code.
True, as well as DBI-&gt;connect(...) Having said that, I always use "new".
Er, every language lets you do those things. Wait, is that your point?
I'd say both of those are significantly worse designs. A DateTime object is always a DateTime object, regardless of which constructor you use. Using different class names just to provide a difference constructor is bizarre. The other option, allowing all possible parameters to a single method, would be a validation nightmare. What happens when someone writes: DateTime-&gt;new( from_epoch =&gt; 1, epoch =&gt; 1234567, year =&gt; 2013 ); This would also be a documentation nightmare. "This constructor accepts 20 different parameters, but you can only use some of them with some others. If you pass from_epoch, don't pass year, month, day ... If you pass a year, month, or day, don't pass ..." Ugh, horrible. While there's plenty of things I got wrong in DateTime, the constructors are not one of those things.
Every time you use indirect object method invocation, a kitten is sacrificed.
DateTime-&gt;new_from_epoch() seems like it would be better, but I don't know how many constructors DateTime has.
This is such a bad idea. 
That just because you *can*, doesn't mean mean you *should*. Conventions are there for a reason.
Its common in just about any language with OOP that methods return objects - usually the same othe called with - to allow method chaining: $obj-&gt;method1()-&gt;method2(); With this idiom its possible to return a *different* object, and makes perfect sense for stuff like DateTime. 
Oh, yeah? If you want to make a connection to a database, what do you think is the best name: $db = DBI-&gt;new or $db = DBI-&gt;connect ? I *clearly* prefer the latter, because it enforces the idea of a database connection, and not about some vague object. 
http://blog.michaelfmcnamara.com/2013/01/automation-with-perl-soap-xml/
http://www.helpdeskusers.com/e107_plugins/content/content.php?content.59
http://www.servicedeskusers.com/forum/lofiversion/index.php?t2262.html
Yeah, `new_from_epoch` is a good name. It has a whole bunch of constructors, actually. There's a lot of ways to calculate a date (ymd, day of year &amp; year, from another calendar object, now, today, etc) 
doesn't seem to be supported by the product so it'll have to be done mostly on the script end
If there were a usable API for perl for this product I'd definitely be using it over this type of retrieval method, but there doesn't seem to be one. Alternative I guess would be running queries on whatever server the info is stored on but in a secure environment there's no way it would let me connect if I knew the addresses for all that. (If I did have access like that I'd probably report it as a security vulnerability lol) Honestly all I want to do with this interface is pull up a list of incidents that have a location attribute I set with an incident status I set (e.g. open, closed, etc) in a raw list and then have the ability to view all the info on that incident that I'd normally see in the web interface, only in pure text so that I can do some handy things with the data I could generate with it. Once complete, I'll have a great starting point for generating performance or trending reports for my group.
One of the points of object oriented programming is that you're supposed to be able to abstract away implementation details. $db = DBI-&gt;connect is not "connecting" if you're, say, opening a sqlite database; you're just opening a file for reading/writing. Whereas you are *always* creating a new object.
check this out http://www.servicedeskusers.com/forum/lofiversion/index.php?f16.html Maybe SOAP modules would be able to pull the actual data and avoid dealing with the interface mess? I don't much about soap's mechanisms or how to use it.
check this out http://www.servicedeskusers.com/forum/lofiversion/index.php?f16.html Maybe SOAP modules would be able to pull the actual data and avoid dealing with the interface mess? I don't much about soap's mechanisms or how to use it.
Usually what's happening is that javascript is creating and/or populating a form for submission, then displaying the results. If you can read the javascript to find how it's doing it, the results are probably being returned as json. You should be able to use WWW::Mechanize to submit the form yourself, then read the json directly in perl. I used to do this all the time in the early days but most webpages didn't use much javascript automation. Now, because I don't want to maintain ever-changing scripts more than anything, I almost refuse to do anything like this. You should contact the vendor of this product and yell at them for no API. Edit: I see in a later post that it might be servicedesk? I too use it and (to me) it provides no extra features over the free request-tracker. Furthermore, it crashes a bunch. If you and your team love it then stick with it, but I've been trying to get my company to migrate away from it between now and the next time we need to pay for it.
You may be better off simply using [PhantomJS](http://phantomjs.org/) - a headless WebKit. At least for the first part - page load and JS eval, nothing is stopping you from dumping the resulting DOM to a file and parsing it with WWW::Mechanize.
In this instance of DBI-&gt;connect you're actually calling a factory method, not just a constructor. There is a a **huge** difference between a constructor and a factory method.
The "object" isn't all important, the database connection (of whatever type) is. A different example: opening a file. Let's use a not-quite-perl example. Let's say you open a file this way: $fh = File-&gt;open($path); Surely that is a lot better than $obj = File-&gt;new($path); because the latter suggests you're creating a new file. The important thing is you're *opening* a file, not that's you're "creating an object". And object vs. file handle: the differences between them are irrelevant. Those are just implementation details.
Strongly concur with the SublimeText suggestion. Best editor money can buy. 
The `WWW::Mechanize` documentation contains an FAQ with a [whole section dedicated to JavaScript](https://metacpan.org/module/WWW::Mechanize::FAQ#JavaScript). It lists the following suggestions that can handle JS: * Gtk2::WebKit::Mechanize, * Win32::IE::Mechanize, * [WWW::Mechanize::Firefox](https://metacpan.org/module/WWW::Mechanize::Firefox) (which has an API similar to WWW::Mechanize), * WWW::Scripter, * WWW::Selenium.
it got to happen before the code you posted
This worked for me if I just print the var $Query: &gt;print "$Query\n"; From the '&lt;br&gt;' tag it looks like this is being embedded into HTML even though it is a SQL call, is that right? If so then how are you calling the contents of $Query? Is it just in perl or is this being called from somewhere else? Also I suggest you [use strict](http://perldoc.perl.org/strict.html) refs even though the code you are modifying did not. Here is all I ran: &gt;\#!/usr/bin/perl -w use strict; my $Item = "item_here"; my $compania = "compania"; my $CriterioCAV = "t_item = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$Item'"; print "Esto es CriterioCAV -&gt; " . $CriterioCAV . "&lt;br&gt;\n"; my $Query = " SELECT t_csig FROM ttcibd001$compania WHERE $CriterioCAV "; print "$Query\n"; Output: &gt;bash$ ./test.pl Esto es CriterioCAV -&gt; t_item = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;item_here'&lt;br&gt; SELECT t_csig FROM ttcibd001compania WHERE t_item = ' item_here' 
Thank you for the answer: @hipyhop yes i am using my to declare the variables. the one in the problem ($criterioCav) its only used in the function @Edge_effect the print is used only to see what is going on. The variable is used on a sql query. The script is using strict. this is the function sub consultarCav{ #Variables de entrada. my ($Item) = @_; #Variables locales. my ($Query, $Sth, $CriterioCAV, $cav); #Definimos el criterio de consulta por item. #$CriterioCAV = "t_item = ' $Item'"; $CriterioCAV = "t_item LIKE '%$Item'"; print "Esto es CriterioCAV -&gt; " . $CriterioCAV . "&lt;br&gt;"; $Query = " SELECT t_csig FROM ttcibd001$compania WHERE $CriterioCAV "; #print "Esto es query -&gt; " . $Query . "&lt;br&gt;"; $Sth = $dbh-&gt;prepare($Query); $Sth-&gt;execute(); $Sth-&gt;bind_columns(\($cav)); #Finaliza la conexión. $Sth-&gt;finish(); #Retorna el dato consultado. return $cav; } The problem is that the query doesn't return any row, because the column has the nine spaces before the data. 
&gt; because the column has the nine spaces before the data. I'm not sure what your data actually looks like, but be careful when using LIKE or RLIKE in this context, since you might get more matches than you actually want. You may also want to look at whichever script is being used for this data collection, and modify it to strip leading/trailing spaces.
What about using brackets instead of quotes? Perl produces the spaces like you wanted but it would appear than SQL is having issues. 
thank you, can you give me an example on the use of the brackets?
*I have limited experience with SQL* and I usually need to manually run queries before I build strings in php... but [this caught my eye](http://stackoverflow.com/questions/3551284/sql-serverwhat-do-brackets-mean-around-column-name). I'm curious about what happens when you run the query directly against the DB. Does it work with the nine spaces trapped in single quotes?
yes if i execute the sql sentence, i got a resulset
You have to assign something to your $cav variable! Use something like $cav=$sth=&gt;fetchrow_array() to fetch THE row and assign it to $cav Suerte. 
how about $s = join("", map { $_.": ".join(" ",$hash{$_}) } sort keys %hash; print $s; ? 
Easy peasy: print join(' ', map { @$_ } values %hash);
Thanks for the tip with map, after I made a few tweaks I got it working perfect: print join(" ", map { @$_ } values %hash);
Not sure why I never considered using map, thanks for your help!
This did cross my mind but would have involved moving too much data from the way it was already stored. Using map ended up doing the trick, thanks for the help though :)