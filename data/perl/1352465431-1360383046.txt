Here are two practical reasons: 1. CPAN may have libraries that will solve your problems and are quite mature. This can make writing software much easier if large chunks of it are already done for you. 2. You may have to work with one of the millions of Perl scripts that are out there. If you do learn Perl, a good book to get is Perl Best Practices. I think it's a little out of date right now, but it still provides a lot of great guidance to keep you from shooting yourself in the foot.
You might be surprised by how many AIX, HPUX or Solaris systems are out there that don't have python installed, but have Perl installed by default. Also, CPAN. That said, given the opportunity to make a language choice for a new project, Python has finally matured enough that pip install will solve a lot of problems right out of the gate and programming object oriented Perl really does look like hieroglyphics. TL,DR; Perl for glue, Python for anything new
Who wouldn't want that!?
A few things. I learned of some weaknesses in Perl that I'd been mostly blind to before. Introspection on objects, and objects in general, are just more natural in Python than Perl, unless you use something like Moose (which didn't exist back then). I hadn't really recognized the benefits of OO, in some situations, and Python helped show me some stuff I didn't realize Perl could do. I should also point out that I didn't really *understand* objects in Perl until I learned the module pattern in JavaScript and study how objects are implemented in Scheme (which, it turns out, isn't entirely unlike how they are implemented in Perl via closures and built-in data structures, and things became clearer; somewhere along the way in there I also read about objects in C++ and how they derived from structs; so it's not a simple progression wherein I grokked objects better because I learned some Python, but it helped). I saw quite a bit of clever code that would do things like take a database, objectify it, and then create a GUI for it, based on the objects. It's possible in Perl, and I'd even done it before with simple hash-based config files (thinking I was pretty clever, too), but, the object introspection and such took it to a new level. The Roundup bug tracker was an interesting learning experience, for an example of this kind of thing. It not only produces a web GUI based on what's coming out of the database (to some degree), it produces a command line UI, as well. Serialization of data structures to store program state was something I'd never done before, either. I'd always just used config files. All my stuff is mostly quick-running sysadmin tools and storing a bunch of state isn't useful, but it was educational to see it done and see how one could revivify a session entirely from a file. Python also made me appreciate some of the stuff in Perl that I took for granted. Regex is really natural in Perl, and clunky in Python, even though Python has Perl-style regexes...using them feels like you're doing something wrong (and by many Pythonistas reckoning, you are). Interfacing Python to C *seemed* easier to me than doing the same in Perl, when I first used it. I had never interfaced Perl to custom C at the time, and it remains somewhat intimidating to me today. I've done tons more of it with Python, even though I've done a lot more work overall in Perl. I think this one was just a matter of having some really good Python developers around me. I've never been surrounded by great Perl programmers on a daily basis (even though I work with one in my company, he's on the other side of the country, and we speak weekly via Skype). But, having a whole lot of people treat hooking up to C code like it's a natural thing was somehow educational. I think it opened my brain a little, and made it more likely I would write a C+Perl module than before I worked in that environment (though I'd have to learn how to do it in Perl, I'd be less frightened of it). So, Python (and JavaScript) taught me OOP, even though I'd read about it for Perl, I'd never used it (I'm still not convinced it is the right way to do it in a lot of cases, since we also have awesome functional constructs like map; I take what I think is an old lispers sort of approach to OOP, which is to say I use a dash of it, when it makes sense). Which brings me to the fact that I often missed functional tools in Python, even though some of the lispy stuff hadn't been removed back then, the writing was on the wall, so I didn't use it. Generators and list comprehensions were theoretical at the time, documented but not implemented, and the writing was on the wall for map/reduce in Python, so I think I was intentionally not using them (which might have been unnecessary caution, since one can convert map/reduce code to list comprehension code relatively trivially, I think). But, I came back to Perl with a better understanding of that stuff, somehow, and I use a lot more map, grep, etc. in my code today than I did before. Also, I learned that Perl is faster than Python, by a *lot*, in the tasks I use them for, at least at the time. Benchmarking ack vs grin was an educational experience; they're two tools that provide a programmers grep...one in Perl, one in Python. grin was created by one of those awesome Python guys I worked with, and so I'm confident it's good Python code. And, yet, ack was an order of magnitude faster, at the time (and grep was an order of magnitude faster than ack, given the appropriate options to get similar, but not quite as flashy, results). I do a lot of text processing type work; editing config files, processing log files, etc. Sysadmin stuff is just faster in Perl, or was back when I was frequently doing comparisons and benchmarks. But, really, (and **this is the important bit!**) it's more about the vague "how do you think about solving problems" stuff in Python made me a better Perl programmer. Python has some very "Pythonic" ways to solve problems. Sometimes they're very good solutions, and I wouldn't have thought of them on my own and I probably wouldn't have seen them in Perl (because there are Perlish ways to solve the same problems). Knowing about those things makes it easier to pick the right solution. TMTOWTDI is better when you've seen a few One True Ways, and Python has a lot of One True Way solutions to things. Seeing how others think about problems is very instructional. It wasn't *just* that I was learning Python, it was that I was working on code written by good developers, and the idiomatic way in which they used their language of choice made me think about the ways I used the languages I choose.
It's fun and kinda charming.
What year is this again?... get off my lawn! Not quite so far back, but yes I think your estimate of the past 6 years or so is accurate. I see the same thing with python that I used to see with Perl - easier just to concede and use whatever everyone else uses than to get approval/acceptance for a new language in many enterprise-y situations. These are often the same situations where Perl is banned in favor of Java for fear that someone will use an eval/system/exec regardless of whether you are writing a web app or a script to munge log files.
Perl steals from enough different languages that it's a little bit like, and yet sufficiently different from, most languages you can come up with.
Basic stuff but i guess people new to perl could appreciate :)
Especially with the implied operator. Do other any languages have it?
Cool. I actually do know some lower level stuff, mainly C/C++. Always wanted to get around to learning some dialect of Lisp though.
It has been rather interesting learning Perl within the last three years and then talking with people that stopped using at 5.8.8. They seem to fail at grasping the idea that Perl is having just as much work and development as any other language, if not more. If you do ever get into Moose, its easy to see one neato feature and use it everywhere. Then you realize you should have used this other neato feature for this and that. It's a big module that takes a little bit of practice to get used to. After that learning curve, its odd doing objects in other languages. I keep wanting things like method modifiers, roles etc. and then not having them. The Regex::Grammar module is really interesting too. Glad I played with that one and it also seems odd that no other languages are really work on that one (at least LAMP languages, not really sure about languages outside the LAMP stack).
I want a more in-depth comparison of CPAN vs PPI vs RubyGems. Increasingly I cannot find software in CPAN which I can in Python or Ruby (a syntax highlighting library like pygments, as a recent example). 
To be fair to Python, it also has some bolt-ons in the vein of Moose. The Python shop I was talking about in the first thread (the one with a whole bunch of amazing Python devs) was developing Traits for Python at the time I was working there, and my exposure to that made some of Moose make a lot more sense on first glance. Pythonistas are not lost in the desert...they have pretty good tools, too. Moose does, admittedly take it even farther in many directions; it's almost silly how many fun tricks Moose has up its sleeves (or antler mittens, or somewhere). But, it's cool to play with other toys and know what's out there.
Some Perl 6 array sorting info: * [Also by Gabor](http://perl6maven.com/tutorial/perl6-sort) * Thundergnat (who contributed the Perl 6 Sort::Naturally mentioned below) wrote the 2010 Advent post ["Day 23 – It’s some .sort of wonderful"](http://perl6advent.wordpress.com/2010/12/23/day-23-its-some-sort-of-wonderful/) that Randal Schwartz summed up in one word: "Beautiful!". * Search for "sort" within [the Perl 6 Rosetta Code index](http://rosettacode.org/wiki/Category:Perl_6). At this time of writing all but one of the 23 sort related entries also has a Perl 5 entry so you can compare idiomatic Perl 5 and Perl 6 solutions. (In many cases Perl 6 will also accept and correctly run the Perl 5 code.)
No mention of Schwartzian? wut? I'd at least [reference this](http://en.wikipedia.org/wiki/Schwartzian_transform) and [this](http://www.perlmonks.org/?node_id=9108)
That's good to hear that some of the neato object stuff from Moose is making it into some of the other LAMP languages. This is the first I've heard of it. Python 3 I assume?
Traits predates Moose. I suspect they both draw on some of the same sources.
I noticed a range of issues mentioned above that Perl 6 addresses differently from Perl 5. &gt; Introspection on objects, and objects in general, are just more natural in Python than Perl, unless you use something like Moose (which didn't exist back then). Note that [Moose started as a backport to Perl 5 of Perl 6's OO as it was around 2006](http://perlmonks.org/?node_id=835936). In his new [p6doc](http://doc.perl6.org/) project Moritz Lens has written ["Perl 6 is an object oriented language at its core"](http://doc.perl6.org/language/objects). Add in an elegant and powerful MOP (which is informing the design of the evolving [p5mop](https://github.com/stevan/p5-mop)) and **OO in Perl 6 is very much a strength, not a weakness**. &gt; somewhere along the way in there I also read about objects in C++ and how they derived from structs [Zavolaj](https://github.com/jnthn/zavolaj/blob/master/README.markdown), which is bundled with [Rakudo Star, a Perl 6 compiler bundled with modules, doc, etc.](https://github.com/rakudo/star/downloads) provides [slick integration of Perl 6 with C libs in general](http://justrakudoit.wordpress.com/2011/01/28/zavolaj/), and **[slick integration with C struct based objects in particular](http://perl6advent.wordpress.com/2011/12/21/native-libraries-native-objects/)**. &gt; Serialization of data structures to store program state Serialization is native to Perl 6. Here's an ["example that shows off an interesting use of bounded serialization in combination with meta-programming"](http://6guts.wordpress.com/2012/03/09/meta-programming-slides-and-some-rakudo-news/). (I think the example will be pretty straightforward if you're pretty familiar with a Moose-alike or with Perl 6, but might be a bit much if you're not.) &gt; Regex is really natural in Perl, and clunky in Python, even though Python has Perl-style regexes... The next gen regexen in Perl 6 are (is?) one of its many big and beautiful innovations. Perl 6 regexen do everything Perl 5 regex do, add big new features, clean up the syntax, and so on. Much more importantly, they have been unified with OO methods to form a feature called Grammars. In a recent blog Solomon Foster writes ["The STEP (that’s ISO-10303) Part 21 standard provides a BNF (I think) grammar for ASCII STEP files."](http://justrakudoit.wordpress.com/2012/10/10/parsing-step/) and continues with **"It was downright trivial to translate [the BNF] to [a Perl 6 grammar](https://github.com/colomon/perl6-ISO_10303-21/blob/master/lib/ISO_10303_21/Grammar.pm)."** Perl 6 compilers use grammars such as [STD](https://github.com/perl6/std/blob/master/STD.pm6) to parse Perl 6. Because this grammar technology is made available to userspace in thoughtful ways it's easy to modify Perl 6 itself, [starting with creation of new operators](http://perl6maven.com/perl6-subroutines-and-home-made-operators). &gt; Which brings me to the fact that I often missed functional tools in Python **Perl 6 natively supports a lot of FP capabilities** such as lazy and infinite lists, immutable elements, and so on. (But in a sort of M expressions way, avoiding the ((some would argue) excessive) use of S expression syntax.) &gt; Also, I learned that Perl is faster than Python, by a lot, in the tasks I use them for, at least at the time. Aiui this is no longer as true as it once was. But I predict the next 3 years are going to be a revolution in Perl space, both Perl 5 and Perl 6, as far as execution speed is concerned. In the case of Perl 6, Niecza (another Perl 6 compiler that currently targets the .NET/Mono CLR) showed the way. [The Rakudo dev team has also sped Rakudo up about 30 fold in the 18 months up till the middle of this year](http://www.youtube.com/watch?v=tCel6lpDTZI&amp;feature=player_embedded) and continues to produce impressive speed and memory improvements each month, which look set to accelerate now that NQP, the Not Quite Perl 6 subset specifically designed for writing compilers, upon which Rakudo relies, has gotten ready for major optimizing in the last month or so. **Just watch what happens as the devs starting optimizing NQP...** &gt; But, really, (and this is the important bit!) it's more about the vague "how do you think about solving problems" stuff in Python made me a better Perl programmer. **A central theme for Perl 6 is the notion of mixing languages.** Perl 6 already allows for switching between Perl 5 and Perl 6 (and inline C via a new Inline::C module) but is very much intended to one day support whatever languages folk write compilers for in Perl 6 (well perhaps NQP for anything larger than a DSL). (Parrot, the only VM that Rakudo currently runs on, was at one time considered the primary platform for writing these other compilers; the emphasis is now shifting to NQP and its back-ends, with, I predict, a JVM back-end becoming a serious option in late 2013 if not before.) edit: typos, running sentences together, emphasis, and a correction (NQP does not yet have an optimizer).
&gt; If you want to disregard the case in the strings - what is usually called alphabetical order - you can do so as given in the next example: &gt; &gt; my @sorted_words = sort { lc($a) cmp lc($b) } @words; &gt; &gt; Here, for the sake of comparison, we call the lc function that returns the lower case version of its argument. Then cmp compares those lower case versions and decides which of the original strings must go first and which second. Sorry, no, wrong. [You cannot reliably use `lc()` for case-insensitive sorting](http://www.effectiveperlprogramming.com/blog/1507) in the modern non-ASCII world. 
Have you got an example of the form of the log lines?
Sorry, but that I can't give you. I haven't used Python at all and rarely use Ruby. I'd be interested if you find anything.
If you want to learn Lisp, I recommend the Structure and Interpretation of Computer Programs (for Scheme). It's an absolutely excellent book and is available free online.
What've you looked into on CPAN?
I'm not trying to discourage a fun programming project but have you considered rsyslog or syslog-ng?
Then try Perl 6. ;) Seriously, as [Larry Wall was willing to say a week ago](http://irclog.perlgeek.de/perl6/2012-11-04#i_6125243): "in a sense, Perl 6 is finally inventing [M-EXPRs"](http://en.wikipedia.org/wiki/M_expressions). (An interesting update on the sorts of Lisp comments he was making 10-15 years ago such as "I think ugly can be beautiful, and that beautiful can get ugly real quick. I think in particular of Lisp, which is the most beautiful language in the world, and every program in Lisp is real ugly." from a talk he gave in 2000 ([transcript](http://www.mail-archive.com/perl6-meta@perl.org/msg00409.html)).) I don't mean to imply that Perl 6 is *really* a dialect of Lisp. It's a unique creation by Larry that blends his own innovations with elements drawn from many languages including Lisp. (Aiui the breadth and depth of Larry's knowledge of both human and computer languages rivals that of anyone else on the planet). My point is that Perl 6 is arguably more "radically new" than the languages rjberry just listed. To get started, fire up an IRC client, visit the #perl6 channel on freenode.net, and say "hi". edit: s/hundreds of languages including Lisp/many languages including Lisp/
Probably better to take this to IRC. freenode. has a nice #perl channel
http://i.imgur.com/h9VBr.png SO BRAVE 
I've also heard good things about The Little Schemer, and that it's a better *beginner book* than SICP. 
I haven't looked into this before, going to do some read!
Most perl users use cperl-mode simply because it covers a much larger part of perl syntax. perl-mode tends to fail miserably with regular expressions and here documents, for example (ha, it even says ";; FIXME: handle here-docs and regexps." in the code). So that would be my personal preference, too. On the other hand, perl-mode is 1074 reasonably complex lines of elisp (with comments), while cperl-mode has 8979 reasonably scary lines (and has less comments than perl-mode). So we have to understand some reluctance on the maintainers' side. Cheers...
Which version of Perl are you running? If you use Strawberry Perl (http://strawberryperl.com) you get a full toolchain and don't have to go fetch the make from Microsoft. But I think you don't even want WWW::Curl, really. If what you want is to just fetch a web page, then you can use the libwww-perl package, specifically the LWP::UserAgent module, or even the LWP::Simple module, to fetch the page. You probably already have libwww-perl installed on your system. Finally, if you're going to do things like extract links from the page you fetch, or want to follow links spider-like, then you'll want to use WWW::Mechanize which is a wrapper around LWP::UserAgent that removes a lot of the drudgery of those tasks.
Learn Go.
i tried with strawberry perl previously, but got nowhere. I have activeperl 5.14.2 atm. I'm only looking for Curl b/c the script that I have available utilizes it. If theres something that I can replace it with and retain the script's functionality I'm all for it. As said, the script basically pulls down a domain/ntlm authenticated webpage, clocks how long it took to get said page (from initial request to finding the search string), looks for a text string, and outputs a number code to represent the result along with the page load time data. Problem is, I don't know enough about how the package usage / writing perl stuff in order to know which package would be best to use or how to change said script to use one or the other. I actually don't even recall which specific package I installed on my linux system to make it work now..
Just downloaded it, what are the advantages? Seems like a python-esque language that needs to be compiled.
Compiled, so you distribute a binary: no dealing with package-hell on the enduser machine. Better performance, closer to C than Perl/Python/Ruby (and performance is still improving because it's such a young language). Write-once, run on Linux/Windows/Darwin (as long as you don't dip into C, which you shouldn't need to most of the time). Package management built into the language. You import packages from github/bitbucket/code.google.com, and go install/go get knows what to do. Type-checking, which is usually annoying, but Go has a really excellent inference system that takes away the headache while giving you all the benefits. An excellent standard library: built-in http server/client, built-in tar/zip/gzip, built-in crypto, built-in json/xml, built-in arguments parsing, etc. (http://golang.org/pkg/) Built-in code formatter (go fmt), which short circuits the usual style battles. It really is a refreshing, clean language, without the warts of 90s language design. 
Interesting. I might try it out, although I'm leaning towards Lisp after I finish getting the basics of Java down.
I had to do some similar stuff a couple of years ago that required authentication (with my usual credentials); I ended up using Win32::IEAutomation.
I found something though could possibly work instead or CURL: http://search.cpan.org/dist/libwww-perl/lib/LWP/Authen/Ntlm.pm
I don't mind them, although it would be nice if they were implemented better. Pythons ternary if is so ugly though (&lt;value1&gt; if &lt;condition&gt; else &lt;value2&gt;).
Yes. As petdance says, use WWW::Mechanize, it's very nice if you simply need to grab a given URL. I use this fairly regularly, instead of poncing around with LWP.
OO has its place, I think. There's a lot of stuff that doesn't require it. I think Perl can be used for either pretty well.
That's rather promising, and I certainly hope for the best, but I'm still not sure if Reini's work can translate to my day to day scripts and applications anytime soon. For now, B::C and B::CC have never done anything to me other than segfaulting even for the simplest and shortest scripts. I admit I benchmarked Rakudo over a year ago, when it was about 1000-5000x slower than Perl 5. I'm downloading Rakudo Star 2012.10 right now to try this out again. Will be posting an update after having done some timings with it.
Here are some casual timings between Rakudo 2012.10 (perl6) vs Perl 5.14.2 (perl) on a Debian box. Startup: $ time ( for i in `seq 1 10`;do ./perl6 -e1;done ) real 0m2.833s user 0m2.220s sys 0m0.544s $ time ( for i in `seq 1 10`;do perl -e1;done ) real 0m0.025s user 0m0.000s sys 0m0.000s Can we say that Rakudo is over 100x slower than Perl 5 (note especially the user and sys numbers). The native int benchmark described in http://pmichaud.com/2012/pres/yapcna-perflt/slides/slide32.html ($N increased to reduce the portion of startup time, since I'm timing with 'time'): $ time ./perl6 -e'my $N=500000; my int $i=0; my int $j=0; while $j &lt; $N { $i = $i + $j; $j = $j + 1 }' real 0m3.381s user 0m3.108s sys 0m0.244s $ time perl -e'my $N=500000; my $i=0; my $j=0; while ($j &lt; $N) { $i = $i + $j; $j = $j + 1 }' real 0m0.065s user 0m0.060s sys 0m0.004s Here we can see Rakudo is already only around 50x slower than Perl 5. I stand corrected. Good for Rakudo. However: $ time ./perl6 -e'my $s=""; for (1..100000) { $s ~= "x" }' real 0m1.979s user 0m1.788s sys 0m0.164s $ time perl -e'my $s=""; for (1..100000) { $s .= "x" }' real 0m0.009s user 0m0.008s sys 0m0.000s About 200x slower. And for arrays: $ time ./perl6 -e'my @a; for (1..10000) { push @a, 1 }' real 0m19.772s user 0m18.381s sys 0m1.224s $ time perl -e'my @a; for (1..10000) { push @a, 1 }' real 0m0.006s user 0m0.004s sys 0m0.000s Here Rakudo is about 3000x slower than Perl 5, plus at the end process size grew to about 4GB. I can probably produce more benchmarks like this and show that Rakudo is hundreds or thousands of times slower than Perl 5, or inifinitely so (since it crashes, for example). So I think I can still stand behind my original statement. Even with 100x improvement, this Perl 6 implementation is still quite behind Perl 5. I am not dissing the Perl 6 efforts at all, in fact I hope for the best. But currently, the implementation's performance is a joke. I'd even suggest that the developers stop telling people that Rakudo can be used to do "useful stuff". It will disappoint people and hurt the project itself. I'd say until Perl 6 is at least only 3-5x slower than Perl 5/Ruby/Python (in general, not on a single specific benchmark; and with comparable memory footprint), the claim that it's useful/usable shouldn't be made. *EDIT*: fixed some typos and mispasting of string append benchmark. 
Oh, there are times and places where it's useful. I just don't like the 'everything should be an object' paradigm.
&gt; Can we say that Rakudo is over 100x slower than Perl 5 (note especially the user and sys numbers). Not if you're as reasonable as I think you are. :) **Startup** First, startup time. I acknowledge the startup speed regression you've noted that seems likely to have lasted for a few days around the time the 2012.10 Rakudo Star release was cut. ([More](http://irclog.perlgeek.de/perl6/2012-11-14#i_6153990)) Putting this anomaly aside, the current Rakudo startup time compares well to (in June was three times as fast as) the current perl 5 interpreter when started with Moose, as well as being less than 50x slower than that of a plain perl startup. **int increment loop** As you note, the int benchmark shows P6 running less than 100x slower than perl -- which doesn't (maybe one day will?) have a way to speed things up via appropriate typing info. In one sense this is very underwhelming; shouldn't P6 smoke P5 in this case? I don't think this is the time for me to discuss why I'm not concerned about this; suffice to say, to stick with the current context, it's less than 100x. **Repeated string append** I'm confused by the numbers you show for the string append benchmark. Did you mispaste? [Larry Wall responded](http://irclog.perlgeek.de/perl6/2012-11-14#i_6154191) to your 200x slower comment by noting a related optimization he added to the perl (5) interpreter (and is implicitly saying should be added to Rakudo). And I also got [a useful response from jnthn](http://irclog.perlgeek.de/perl6/2012-11-14#i_6154472). **Repeated push** The array benchmark is indeed impressively slow, and 4GB impressively large, to say the least. :) The issue? ["Rakudo doesn't do sink context yet"](http://irclog.perlgeek.de/perl6/2012-11-14#i_6154035) (sink = void) so ["you end up making a 5 million element result array"](http://irclog.perlgeek.de/perl6/2012-11-14#i_6154053). (There are ways for users to, er, avoid this.) The team has discussed the need for actually implementing sink context for 18 months (and [Moritz may be working on it](http://irclog.perlgeek.de/search.pl?nick=moritz;channel=perl6;q=sink;offset=0)). Why hasn't it landed? Because it's mostly "just an optimization" and the Perl 6 teams are being fairly studious and patient about following the maxim "make it work right, then make it work fast". That said, the emphasis is currently shifting toward optimization and sink context is high on the list so I anticipate sink context landing in 2013 if not before. &gt; **I can probably produce more benchmarks like this** I'd be interested in seeing more benchmarks that avoid void context and take advantage of the Perl 6 approach to strings (they are immutable) as compared to the Perl 5 approach (they are mutable). Otoh I think the team is starting to turn its attention to benchmarking and optimizing so perhaps special effort right now by those outside the dev team is a little premature and would quickly become redundant with their presumably more formal efforts. &gt; **or inifinitely so (since it crashes, for example).** It crashed during your testing? Segfaults and the like are quite rare these days. It would be great if you could visit #perl6 and let them know. &gt; **So I think I can still stand behind my original statement. Even with 100x improvement, this Perl 6 implementation is still quite behind Perl 5.** Well, I'd agree that even with sink context implemented, plus an all round 100x execution speed improvement, Rakudo would still be quite behind Perl 5 in a lot of ways -- just not execution speed. &gt; **I am not dissing the Perl 6 efforts at all, in fact I hope for the best. But currently, the implementation's performance is a joke.** I hope that you can see that this conclusion is at least debatable. I don't see Rakudo's performance as a joke; I see wisdom in the "make it work, make it work fast" maxim; I think 100x slower, prior to most of the benchmarking, profiling, and optimizing effort, is reasonable, especially because I know several of the core devs (not to mention Larry Wall himself, who is no slouch) are themselves optimization wizards who have been setting things up to have a fun 2013/2014. &gt; **I'd even suggest that the developers stop telling people that Rakudo can be used to do "useful stuff".** It is used by a handful of folk to get $dayjob work done because, they claim, they can get some things done much faster with Perl 6 than they can get it done with Perl 5 or any other tool they know. Imo that means the label is more than reasonable. Not only can it be used to do useful stuff, it's actually the best tool according to those users. &gt; **I'd say until Perl 6 is at least only 3-5x slower than Perl 5/Ruby/Python (in general, not on a single specific benchmark; and with comparable memory footprint), the claim that it's useful/usable shouldn't be made.** How much slower than perl as it was then were Ruby and Python 10 years ago? Are you suggesting that it was inappropriate of folk to suggest that Ruby or Python were useful/usable 10 years ago? edit: typos, formatting, Moritz considering working on sink context
I get your drift, but will point out that there are users using it with real data. So your formulation still isn't right. How about "Speed of its compilers is the most glaring remaining problem with Perl 6. Current Perl 6 compilers generate code that generally runs about two orders of magnitude slower than Perl 5. This immediately rules them out, and hence rules Perl 6 out, for a wide range of work. There are other notable weaknesses too. However, having reached the point that most of the language is implemented, the Rakudo Perl 6 team have begun to turn their attention to optimization, so the future looks bright. Right now, if you have a high powered computer, and some jobs that are not execution speed sensitive, Perl 6 has a wide array of innovations that can radically boost programmer productivity. And if you are a benchmarking/profiling/optimizing specialist, consider visiting #perl6 and joining in the fun."
Debian x86 64bit. To be honest, I'm just a regular Perl user with no real knowledge of Perl internals. So I will perhaps be of no help to Will or Reini. But I'm still keen to try out Rakudo as well as B::{C,CC} in the future. Moar speed is always welcome :) It's just that I'm not holding my breath. Perl 5 is working fine for me and that's what I'll be using in the next X years.
curry.pm looks pretty useful, first I've seen of it.
As a quick and dirty hack you can try PERL5LIB=/path/to/v6.62 cpan Devel::StackTrace But I'm not sure if such a practice is any good in general.
Have you thought about creating your own "version" of [staticperl](http://search.cpan.org/~mlehmann/App-Staticperl-1.43/bin/staticperl). With that you could use whatever modules you want.
I'll never understand the argument for locally developed code over community developed infrastructure. I'd recommend a management upgrade.
Ignoring the people that aren't answering your question and instead suggesting perlbrew, local::lib, or telling you to get a new job (if they haven't already, all of these suggestions _will_ show up here eventually) -- I would _avoid_ the above style of composition if there are any cases when the "end user" (your .pl) ever uses CompanyDB or CompanyMailer directly. Instead, pass pre-made objects into CompanyReport's new(). If CompanyReport is the sort of thing that is never going to use a different CompanyDB or CompanyMailer, then go ahead and keep going like you are. 
It would be really helpful if you showed the output of installing 6.62. Bit hard to tell you why you're getting the wrong one if you've not actually shown us where the right one went :)
EUMM defaults to installing into core dirs. Of course he might have something stupid like INSTALLDIRS=site in his cpan config, in which case removing that should help.
Generally a good idea if you're upgrading dual-life modules against a perl this obsolete, but given EUMM defaults to installing to core dirs anyway it might not help here.
Look at using Moo and the builder attribute so you can have a method that builds your related object, either eagerly or lazily depending on how you set it up. If you can't use Moo, then you can reproduce this pattern by hand with something like sub foo { $_[0]-&gt;{foo}||=$_[0]-&gt;_build_foo } sub _build_foo { &lt;build the foo object here&gt; } You could also use something like a coercion, but that's going to start getting really annoying to implement by hand. Maybe something like - sub new { ... some_thing =&gt; $class-&gt;_new_some_thing_from_args($args{some_thing}) ... } sub some_thing { if (@_ &gt; 1) { $_[0]-&gt;{some_thing} = $_[0]-&gt;_new_some_thing_from_args($_[1]); } $_[0]-&gt;{some_thing} } sub _new_some_thing_from_args { my ($proto, $args) = @_; return $args if blessed($args); # already an object SomeThing-&gt;new(&lt;whatever&gt;) }
I keep meaning to blog that, Import::Into and Safe::Isa - the three together might make quite a nice post. Then I fail to get around to it. Sorry.
You must live a pretty miserable life if you have to take out your frustration by posting weak python trolls in every perl thread you see on the internet. Your entire comment history is full of this whining, lying fanboy butthurt and you have serious passive-aggressive issues. I think you should see a psychiatrist about your real life mental health problems and/or depression. I truly feel sorry for you. Have a hug.
Articles like this keep remind me that I am a perl noob no matter how many years of experience I have.
It even respects it's own depths of ancient history. This one is always useful in obfu: package Don;sub t{print"stop!\n"} package main; Don't 
[Interesting discussion on PerlMonks](http://www.perlmonks.org/?node_id=22524) about that. i personally believe that for and foreach should show in an 'IRL' context of code. For example: 1. foreach(@apple) { $apple_one = $_; }; 2. for(0 .. $#apples ) { $buffer = $apples[$_]; }; While they are exactly the same thing by definition, the context of the variable names can indicate a *type* of operation that is in progress. it personally assists me in my personal variable naming 'mico-conventions' that i have developed over the years. How something looks can be synonymous with how it functions in larger code structures ..... or not.
&gt; which looks like bad syntax, but whatever It's not bad syntax. A `do` block is handy when you want to evaluate multiple statements and return the last one, for example to slurp the entire contents of a file handle `$fh` by temporarily setting the input record separator (`$/`) to `undef`: my $contents = do { local $/; &lt;$fh&gt; } 
First, it's going to depend how you want to represent a card and a deck. You could write this in a few lines yourself or you could just use a library: http://search.cpan.org/dist/Algorithm-Numerical-Shuffle/lib/Algorithm/Numerical/Shuffle.pm Just for example, you could take the numbers 1-52 inclusive to be a deck, with 1-13 inclusive the Diamonds, 14-16 Hearts, etc, you could do this: use Algorithm::Numerical::Shuffle qw /shuffle/; my @shuffled_deck = shuffle (1 .. 52); If you don't like numbers, you could also use a bunch of strings: shuffle("1H", "1D", ... "KD", "KD"). If you want to do six decks, you can just concatenate the arrays and shuffle those.
Huh! Interesting. I've seen plenty of `do-while`-type of blocks, but I don't think I've ever seen a bare `do` like that in the wild.
[`List::Util`](https://metacpan.org/module/List::Util) has been a core module since 5.7.3 and includes a `shuffle()` function. use warnings; use strict; use List::Util qw/shuffle/; my @suits = qw/H D C S/; my @ranks = (2..10, qw/J Q K A/); my $num_decks = 6; my @deck; for my $suit (@suits) { for my $rank (@ranks) { push @deck, "$rank$suit"; } } my @shoe = shuffle ((@deck) x $num_decks); print join ", ", @shoe;
http://cpansearch.perl.org/src/MSCHILLI/Games-Blackjack-0.04/lib/Games/Blackjack.pm 
 use Algorithm::GenerateSequence; use Algorithm::Numerical::Shuffle qw(shuffle); my @cards = (Algorithm::GenerateSequence-&gt;new( [qw( Heart Diamond Spade Club )], [qw( A 2 3 4 5 6 7 8 9 10 J Q K )]) -&gt;as_list()) x 8; @cards = shuffle @cards;
Does anyone know if Padre supports VI-like key bindings?
You don't even have to shuffle. Put all your cards in order in an @array, generate a random number $n from 0 to length @array - 1, then splice $array[$n] out.
{local $/; &lt;$fh&gt; } This'll do without the do.
I actually had not though of that, thanks. This sounds like a much easier way of doing it
I suggest you start by reading this [OO tutorial](http://www.netalive.org/tinkering/serious-perl/) on Perl OO.
&gt; So although Gabor has a point that instead of writing a blog post just to emphasize negative aspects instead of reporting a bug. I do not understand this. Why am I supposed to report a bug, just because it is open source? That argument carries no weight because it is not a requirement to report bugs for any product released. Source code licenses, like gpl, lgpl, apache, mpl, etc... have no clauses dealing with bug reporting or providing feedback in any way, shape or form. Where do people get this idea that if you as an end user use an open source project you must report bugs. This dogmatic idea is dumb. Furthermore, people write product reviews on everything under the sun and people are not out clamoring about bug reports not being filed with Apple or Samsung or Google. &gt; I think kimmel[2] is completely justified to talk trash. I do not think what I wrote is [trash talk](https://en.wikipedia.org/wiki/Trash-talk) it is [constructive criticism](https://en.wikipedia.org/wiki/Constructive_criticism). I offered valid observations based on reproducible behavior that involved both positive and negative feedback about Padre's feature set. If I had trash talked Padre it would have been more like "Padre crashes so much it reminds me of using Windows Millennium Edition."
&gt; Don't learn algorithms by implementing them in Perl. That's good advice it OP *doesn't* actually want to learn Perl. Perl is as good as any other language to learn algorithms, although it's not best choice for studying their performance issues (big Oh notation etc). As for OOP study in Perl [this](http://perldoc.perl.org/perlootut.html) is a much better starting position. 
This might not fly too well here, but rather than going down this path you might want to check out Ruby. It's like Perl with much stronger OO. 
No. UPDATE: You can't get a good understanding of what Perl is today by just studying Perl. That's ignorant. A lot of Perl modules borrow from a lot of other languages. You also get a different perspective by studying a different language. There's a lot of "revelations" like *"Wow, it doesn't have to be like it is in Perl, it can be better organized etc"*. You get a lot of those when you study other languages.
You're right, "much stronger OO" is too poorly defined to fly here. Do you mean that more of the native things you interact with are objects? While true I'm not sure that for someone writing a blackjack simulator and learning OO that the purity of the environment matters beyond a certain level. Any other argument about the quality of Ruby OO vs Perl either has to arbitrarily exclude things like Moose ... or are highly subjective (or both!). In my admittedly limited experience some aspects of OO are easier in Perl, especially with Moose than I have seen demonstrated in Ruby. None of those things is something that a beginner, modeling a fairly simple process like a BJ game, should run into. So while charitably you may be right that in some subjective ways Ruby's OO may provide some benefits over Perl in equivalent projects, you've failed to explain how that applies to the OPs needs other than stating a random "hey change the language your using!" Could you provide something more useful that a discussion could at least be formed around? Something perhaps about the merits of Ruby's OO as it applies to this thread when compared to Perl's? That would at least fly.
I have no idea if an example of how someone else solved a trivial version of this same issue but I did write a blog post on this at one point where I implemented BJ in 10 lines of code. The post is archived at: https://github.com/perigrin/the-room/blob/master/blackjack.md
I guess the answer depends on what the OP's goal is. Is it to learn Perl or write a Blackjack program? I've written a fair number of Perl packages for my projects and you can absolutely write OO Perl code to handle projects like this, but here's what I wasn't crazy about. Disclaimer: I may be a crappy Perl programmer, so please enlighten me if there was a better way to do this. I've never used Moose, only Packages. If he creates packages for a deck and a card, and wants to retrieve an array of cards from his deck, the method would look something like this. sub getCards { my $self = shift; return @{ $self-&gt;{cards} }; } In Ruby it is something like this. def getCards return cards end When I have errors in my OO Perl code, 9/10 it's because I forgot to shift the main object into $self. Also, the syntax for returning arrays is odd. Ruby's standard classes also have lots of great methods available, like for converting hashes to json, formatting strings, etc. I don't think it's controversial to say that Ruby is more OO than Perl. Edit: Removed semi-colon and brackets in the Ruby code. Too much Perl on the brain. 
You also need to call binmode() on UPLOAD after opening it on line 54.
The Content-Type of the Request, not the response. Base64 would probably be easier. CGI.pm would probably try to decode a param as if it were url-encoded anyway, even if the content-type for the binary data is correct.
You'll have to show the HTML/javascript in order to actually debug this, you're doing such odd things.
If I understood you correctly.. you want to have a script that you can call like "../script.pl ../index.prop" and ../index.prop would contain lines like "index=do_not_delete_me" and script.pl should then proceed to delete everything other than the files listed in the "index=" lines. Well you can try this. #!/usr/bin/perl -w use strict; use Data::Dumper; use File::Path qw(remove_tree); my (%files_to_skip, @delete_these); while(&lt;&gt;) { chomp; next unless /^index=(.*)$/; $files_to_skip{$1} = undef; } $files_to_skip{'.'} = undef; # Skip . $files_to_skip{'..'} = undef; # Skip .. opendir(my $dir_handle, '.') || die "Could not open .: $!"; while(my $dir_entry = readdir($dir_handle)) { next if exists $files_to_skip{$dir_entry}; push @delete_these, $dir_entry; } closedir($dir_handle); my ($errors, $result); remove_tree( @delete_these, { errors =&gt; \$errors, result =&gt; \$result, keep_root =&gt; 0 } ); print "errors are (",Dumper($errors),")\n" if $errors &amp;&amp; @{$errors}; print "result is (",Dumper($result),")\n" if $result &amp;&amp; @{$result};
I still need to test it, but I think this pretty much nails it. Thanks man!
"Want coding help? See PerlMonks or Stack Overflow for timely Q&amp;A assistance."
Looks interesting, but feels weird that a decent chunk is written in Ruby. :P
If you get into Perl, there's a down side -- people who will sneer: Perl is old-fashioned, Perl isn't enterprise-worthy, Perl is a write-only language, Perl doesn't do OO to their liking. The upside is, you won't have to listen, because you will have already finished the task you were working on and be in the pub. But seriously, Perl is not the kind of language that CS purists swoon over. But that's as it should be. Perl's a practical, get-stuff-done language. If you're going into the practical area of networks, system admin and the like, you should definitely learn it. Apart from anything else, sooner or later you're going to have to work on a Perl script you inherit from the last guy in your job. You might as well be ready for that. http://perl-begin.org/learn/#why-learn 
Perhaps I'm reading this project proposal incorrectly, but, having watched open source for some time now, I think this guy might be taking the wrong approach. It seems to me that trying to drum up support for an open source project from the ground up almost never works. "Hey guys, I have this great idea, here it is, help me build it." Yeah, but no. What does work, though, time and time again, is to build and *ship* /something/ - even something that's incomplete - that people find useful and begin using. Once that happens, if the project scratches enough itches and people actually use it, a community of contributors and bug fixers and documenters will naturally happen, and the project founder (benevolent dictator) can influence the contribution culture and manage traffic from there. Isn't that how open source usually works? 
Right. And why would I? Why does the open source exists at all? You'll be surprised by how different the answers are in this survey.
&gt; Because perl can't know if whatever takes an argument or not until runtime... Perl will decide how to handle that when it *parses* that line. By runtime, it's already decided. The comments are long gone by the time execution hits that line. Comment away.
Short Answer: No they don't. Long Answer: Perl goes through a compilation stage at the startup of a script before running the code. This is the only stage that comments and POD exist. They obviously do have an effect on compilation time (aka the 1-time overhead required to start your script) - but it is immeasurably small. Seriously, as in I can't detect a difference in compilation time between a script with 10,000 comments and one with none. At run-time, the comments no longer exist, so have no effect on performance whatsoever. It doesn't make a difference if you have 10 billion comments in a frequently used sub, or none at all - after the compilation stage they don't exist anymore. This is the worst kind of micro-optimization - one that doesn't actually do anything at all!
&gt; Perl is actually a just-in-time compiled language While I see what you're trying to say, this isn't what "just-in-time compilation" usually means :-)
Thanks for the clarification, I've edited my post to remove the misleading statement.
Is the value after the WXZ assignment always 'Allow'?
This should do what you want: use warnings; use strict; use IO::File; IO::Handle-&gt;input_record_separator( "\t" ); my $ofh = IO::File-&gt;new('&gt; data.csv') or die "cant write data.csv: $!"; use Text::CSV; my $csv = Text::CSV-&gt;new({ eol =&gt; "\n" }); foreach my $file ( @ARGV ) { my $ifh = IO::File-&gt;new( $file ) or die "cant read $file: $!"; while ( my $raw = $ifh-&gt;getline ) { chomp $raw; next unless $raw; # strip tab and skip if record is blank my @record = ('Path'); my @all_fields; my @raw = split "\n", $raw; my $path = shift @raw; foreach my $line ( @raw ) { if ( $line =~ /^WXZ/ ) { my @fields = split /\s+Allow\s+/, $line; push @all_fields, \@fields; } } push @record, map $_-&gt;[0], @all_fields; push @record, $path; push @record, map $_-&gt;[1], @all_fields; my $status = $csv-&gt;print($ofh, \@record); } } 
Heres an example output file: Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername01\programs\Instron Files",FullControl,FullControl,FullControl,FullControl Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\slp-everyone,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername02\programs\Instron Files",FullControl,FullControl,"Write, Read, Synchronize",FullControl,FullControl Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername03\programs\Instron Files",FullControl,FullControl,FullControl,FullControl Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername04\programs\Instron Files",FullControl,FullControl,FullControl,FullControl Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername05\programs\Instron Files",FullControl,FullControl,FullControl,FullControl Path,WXZ\MIS-Domain-Admins,WXZ\WPM-Domain-Admins,WXZ\WF-HelpDesk-Admins-CA,"WXZ\Domain Admins","\\servername06\programs\Instron Files",FullControl,FullControl,FullControl,FullControl
That's helpful, but not quite what I need for output data...The first row should be just the path and names of users and groups, then the other rows would contain what the permissions are for that User/Group. I've faked an output in Excel to explain better: http://i.imgur.com/I5mUz.png Regardless, thank you very much for your help! At the end of this, I'll happily drop a few bucks in a charity of your choice.
Done. $10 to them as of 5 minutes ago!
Holy shit - I sure coulda used Path::Class a couple weeks ago!
I think it's OK to link each calendar, or particularly interesting posts as they appear on each calendar. If you spent the next 24 days posting every article linked on every perl advent calendar I'd probably get pretty bored pretty fast. A daily round-up of the best, posted as a self post; now that'd be useful!
I say go for it. I always tell myself I'm going to remember to visit those sites daily but I never get around to it. 
Do the same files always fail? Is it only with uploading the files? Can you download these files another way and then do an md5sum to verify that the files download correctly?
Idiot, here. :-) I'll take a start at answering the question. I'm sure there's a dozen other reasons. Disclaimer: golfing is a recreational sport, not to be used in industrial code. 1. TMTOWTDI. There's more than one way to do it. Some languages, like Python, aim for one standard way to do things, do it explicitly with out hidden features, and do that one thing well. Perl instead aims to provide may different solutions. Operators are more likely to have a variety of different behaviors, depending on context. For example the diamond operator reads in all the lines in a list context: while (&lt;&gt;) { do stuff with $_ } but gives one line in a scalar context: my $answer = &lt;&gt;; 2. Which leads to [Sigils](https://en.wikipedia.org/wiki/Sigil_%28computer_programming%29). The %- @- and $-prefixes on variables allow us to specify intended context with one character. This is one way to steer the operators where we want them, tersely. 3. Tersely. Many times, variables aren't even needed, because, like in that while() loop above, the diamond operator has set the working pronoun $_ for us so we can refer to it in things like s/// without even assigning a variable. I'll stop there 
Nice article, missed it first time. Maybe I could take the other side for discussion? First, writing industrial code is clearly a different endeavor than golfing. When you're accountable to a process, to some measures of testability and quality, to robustness upon errors, to repeatability, to communicating clearly to current team members and future maintainers, and to satisfying your customer, you clearly have a professional conduct to maintain. There might be a few more barrels of requirements in your office; definitely in mine. When you're golfing, you're there to learn the language, exercise your problem solving muscles, and have some fun. There's probably no overlap of requirements between the two: nobody's going to post industrial code to the IOCCC or to perlmonks, and there's no place for golfing in Shuttle Orbiter code. You can probably golf in any expressive language. You can write crap code that should get you fired in any language. I don't see any harm to anyone's advocacy for their language, or to any language's community, if users have some fun on the side and then use the very same language in a professional manner elsewhere.
I'll just hit a couple points and let you have the last word. Most importantly, that was no diss on the Monks. It's merely the current [best place](https://encrypted.google.com/search?hl=en&amp;q=site%3Aperlmonks.org%20japh) maybe to show off a JAPH or golf. Codegolf.com seems out of favor, so you're not alone :-) or maybe the maintainer got busy... Of course there's production code on monks too, which is just supporting my point: professionals can and should make a distinction about golfing or working. If you need a one-liner throwaway to answer some question or chainsaw some text and move on in a few minutes, you're being way more productive than our mouse-bound friends. Throw that oneliner and move on, maybe after learning something. So it's most certainly not a waste of time. 
I'll pipe in here and say that golfing should _never_ be used in anything near production code. I find myself going back over code I've written already and adding explicit things all the time, simply because the people that will be looking at my code in the future may turn out to be drooling morons, and I would rather not have to speak to them. That said, golfing has helped me learn those obscure features and do things that you couldn't do before. For example, the Schwartzian Transform (map-sort-map) didn't make sense until I saw it used in a golf somewhere. Similarly, golfing has helped me understand the intricacies of how things like list context, map, grep, and other things _work_. Understanding those "Best left unlearned" stuff is most certainly not for beginners, or even intermediate developers, but for some, it's vital. And learning it can help you move from "pretty good" to "freakin' expert" when working with Perl.
When did it become "code golf"?
wiki says [1999, or about 13 years ago](http://en.wikipedia.org/wiki/Code_golf).
Precisely my point. Perl begat "code golf", so the right question is - what about Perl made it invent the game of code golfing? 
I think it is fine.
I was with you until you started dissing Dist::Zilla. rjbs is one of the finest perl authors of all time and Dist::Zilla is beautifully designed to do what it intends to do, and its large uptake by CPAN authors is evidence of that. We've heard the arguments about long dependency chains before, but sorry, it's not the doom and gloom that you make it out to be. There are rarely install failures, and the number of modules you need to install for something should not be a factor. So what if 100 modules are installed vs. 2 if they both take just a minute to install? No one's making you "run around in circles" - your toolchain handles all this for you. Go get a cup of coffee and relax. As for "stuff everyone needs", take a look at the Task::Kensho family of distributions - these are intending to list module recommendations for each type of problem. Come join the #epo-ec channel on irc.perl.org if you'd like to modify this list or otherwise editorialize on it.
Perl - the only language where you CAN, if you try hard enough, to cause comments to negatively impact runtime performance of the code.
dzil doesn't work. I'm using Perl 5.14.1 and I'm installing with cpanm. when I try to install dzil it says CPAN::Meta::Prereqs or something like that I can't remember and I'm not gonna try again. It is a **huge** problem if a lot of people grow to depend on a tool and then the tool suddenly breaks. Dist::Zilla doesn't work and it **sucks** I'm not interested in participating in a circlejerk like Task::Kensho. If you want a contribution make the project public on github and then I might think about it. Plus, externalizing the collection of modules into a "Task::Kensho" kind of thing, lowers their importance. This has no place in some fake/virtual module which has as deps all the modules which will be installed. That's bs. Those modules need to be in CORE definitely. I think you're constantly under-estimating the importance of this. UPDATE: &gt; rjbs is one of the finest perl authors of all time and Dist::Zilla is beautifully designed to do what it intends to do Are you seriously going to give me **emo**tional bs like that ? I really don't care who or what rjbs does, he better fix his shit..
&gt; dzil doesn't work. I'm using Perl 5.14.1 and I'm installing with cpanm. when I try to install dzil it says CPAN::Meta::Prereqs or something like that I can't remember and I'm not gonna try again If you can't be bothered to make a bug report, no one can be blamed for not being aware of the problem. I can assure you that installation problems *are* fixed promptly. &gt; If you want a contribution make the project public on github and then I might think about it. Funny, because everything I mentioned *is* on github. &gt; I'm not interested in participating in a circlejerk Yeah, I think you're just interested in complaining. 
&gt; If you can't be bothered to make a bug report, no one can be blamed for not being aware of the problem. I can assure you that installation problems are fixed promptly. Instead of telling me that I'm complaining, why don't you show me how well you know the ethics of opensource and make the bug report yourself. I don't usually make a bug report, but when I do, it is usually accompanied by a patch (this is a classic requirement of opensource). For Dist::Zilla, the huge clusterfuck that lies in the source code is not my problem , nor do I want to engage in such a huge dep-chain disaster as Dist::Zilla is. So fix your own bugs so people can be happy again. If you don't, I swear I will post everywhere that Dist::Zilla is shit and it doesn't work. How that may affect you, is your own problem and you will have to deal with it. I don't care. Bye
That is not a global variable. Variables declared with `my` are lexical variables, which means they are only visible in the block they were declared in, and any contained blocks. If this function is just displaying an element from the array why can't you just type `$lin[$lpos]` in the debugger instead of calling this function? If you really want this variable to be global then remove the `my`. If strictures are in effect then you'll need to declare it with `our` or `use vars` otherwise it will be an error. 
Thanks, that helps. Though the code only shows it printing one position of @lin, in my description it says it is printing the current position ($lin[$lp]) plus 10 more positions after $lp. I was using Perl 5.4 so maybe there was a bug. The @lin declared with "my" used to be seen by my library subroutine *showlin2*. 
Even those variables are not global; they are package variables (sometimes called dynamic variables). That is they exist within a given package. You can reference package variables from one package in another by prefixing it with its package name: #!/usr/bin/perl use strict; use warnings; { package A; our $foo = 5; print "A: $foo\n"; } { package B; our $foo = 10; print "A: $A::foo\n"; print "B: $foo\n"; }
Two things: 1. Why don't you just put that at another input to your subroutines? 2. Isn't "my($lp)=@_" making a new variable in the scope? Why is that even there?
push poll
I didn't participate because "pissing off Java and Python users" was not in the list of "Reasons for participation". I get tired of trying to explain why it is ok to use perl, it is not dead even though no Indian outsourcing companies use it. jboss is a fountain of evil.
It's a rehashing of Algorithms in general. I'm sure he's shocked by the worst case of such algos as bubble sort, merge-sort. ;)
When I talk to corporate developers about Open Source, it's always hard to explain the reasons why people contribute. Regardless of the actual language. This survey helps.
IMHO one of the most important tools I was missing, when arriving at a new client to help them improve their code. I hope to see it on CPAN as a command line tool.
How much is "enough"?
When you say "efficiency" in this case, you're really saying "execution speed". There are many different types of efficiency besides execution speed, such as memory usage. That said, your boss is wrong about comments inside the subroutine. They do not affect anything because the code is compiled once and then executed.
Just sayin'
To answer my own question, CSS::Packer is slow and doesn't remove new lines. CSS::Compressor is easily the fastest Pure Perl and gets the best compression. However, CSS::Minifier::XS is twice as fast and compresses nearly as well. Rate minify packer css_compress minifyxs minify 4.49/s -- -78% -97% -99% packer 20.5/s 357% -- -87% -95% css_compress 156/s 3361% 658% -- -60% minifyxs 392/s 8627% 1810% 152% -- 
On the other hand, if you *do* insist on doing it via regular INSERT statements, then you should enable server side prepares by adding mysql_server_prepare=1 to your DSN. Doing this will save the server from having to parse your SQL on every single query. (Yes, believe it or not, without that option, that's what it does, despite the fact that you prepared your query outside your loop.) For further reading: https://metacpan.org/module/DBD::mysql#Prepared-statement-support-server-side-prepare-
Unfortunately he said "[I] need to perform a file scan, from a Windows machine, on a bunch of networked Windows machines"
Ah, I see. The problem with that is that the files table would be massive and not current. The reason for the dropped table is to know what exists whenever the scan is run (thousands of files a week, scan runs 5 times a day). If I just inserted to a single table without a reference of records to delete from it (when the files are deleted) it seems like the table would get a little massive. Is there a way around that that I'm missing?
Haven't looked into this in years but from what I can remember Perl 6 is supposed to safely support threads. Perl 5 threads were never recommended in production. It was never that much of an issue since Perl always supported multi-process IPC.
I've not even touched Perl6. But I want to give it a go. Just 'cause'. Edit: Perl6, not Perl5.
Dude, what's your problem ? I told you I'm using Perl 5.14.1 , switch your perlbrews to 5.14.1 and try to install Dist::Zilla. What the Fuuu... No comprende ? What do you want ? You want me to send patches or BUG REPORTS ?!?!?!, I'm sure you'd love that, but I'm not gonna do that, because I have OTHER STUFF TO DO !!
Generally it's accepted by both the Perl5 and Perl6 communities that Perl6 is a separate language and not a new "version" of Perl. It wasn't always thought of this way but that has been the accepted truth for the last three or four years now. 
You realize you haven't pointed to a single specific thing that is missing right? The fact they are having a contest makes your argument here specious and sound like uninformed trolling. I'm sure that wasn't your intent because really who trolls on reddit? Why don't you honestly take a whack at some of the programming challenges i the contest and then post an informed critique of the language and its current implantations? That would be more useful and interesting to those of us who have obviously paid more attention in the last decade.
Well, I work in Perl 5, but I got the job mostly because I was a Perl 6 dev and a GSoC participant so I guess it does pay off :)
Larry Wall created Perl and is developing Perl 6. It was his (great) idea to introduce the butterfly so that Perl 6, especially during its early years, would repel folk who were pathologically serious or mean, or at least their stereotypic behaviors. He's not realistic? Patrick, formally the lead Rakudo dev, has been "director and/or principal investigator for over $36 million in externally funded projects." Do you think he'd get that sort of responsibility if he wasn't realistic? Jonathan, informally the lead Rakudo dev, hits tough development goals set years out. You can't do that if you're not realistic. The REAL functionality in Perl 6 is impressive, as is its handling of [rationals](http://www.perlmonks.org/?node_id=1004081), complex and imaginary numbers, infinities, and so on. You haven't said what's missing. What's missing? Vaporware? There have been over 50 releases of Rakudo, one of several Perl 6 compilers. It sounds to me like you haven't actually used Perl 6. (Otherwise why would you be saying it's vaporware, and why would you be so ignorant about its actual status?)
&gt; I agree Perl 6 is relatively impressive math-wise... Oh look, you're putting words in my mouth again.
&gt; You realize you haven't pointed to a single specific thing that is missing right? How about documentation, packaging, and a stable ecosystem suitable for deployment?
Perl functions only understand lists of objects. The parameters to a function do not understand non-scalar objects like arrays or hashes. So if you call a function like: pushmodel(@tout,$t1); Perl sees: pushmodel($tout[0], $tout[1], ... $tout[n], $t1); So the array @_ is just a long list beginning with the values in @tout and ending with $t1. So when you say: my(@arr,$mdl)=@_; Perl doesn't know that your parameters were once an array and a scalar. Perl decides to load all the values into @arr and leave $mdl undefined. To fix this, pass in the array as a reference to an array and read it as a reference to an array: @tout=pushmodel(\@tout,$t1); and sub pushmodel { my($arr,$mdl)=@_; ... See http://perldoc.perl.org/perlsub.html#DESCRIPTION
Thanks CaptShocker, that's what I tried and it worked. But I still need to learn about Perl references as I do use them from time to time. So I've looked at examples in several webpages now and they are far more complex than what I need, and I learn better by example, rather than by documentation. Is this correct to print an element from an array? sub pushmodel {my($arr,$mdl)=@_; print "$arr[0]\n"; print '$arr[1]\n"; return $arr; } 
Thank you. So does the arrow dereferencer work in double quotes like this? print "Stuff: $arr-&gt;[0]\n"; 
On the first question, what does it mean "Reason for participating"? Is it "Reasons for participating in /r/perl"?
As a suggestion, if you get an array there are good chances that you world use it in a loop. Here is a concise way to dereference an array ref in this situation: sub pushmodel { my ($arr,$mdl) = @_; for my $row (@$arr) { print "$row\n"; } }
To take a reference, you use the `\` operator: my $ref = \@array; To index into an array pointed to by a reference, you use either the scalar dereference operator `${}` or the arrow operator `-&gt;[]` (I prefer the arrow operator in most cases): my $first = ${$ref}[0]; my $second = $ref-&gt;[0]; When you need to access the whole array pointed to by a reference, you use the array dereference operator `@{}`: push @{$ref}, 5; If you need access to the index number of the last element of the array (ie $#array) you can use the derreference operator $#{}: my $last_index = $#{$ref}; print $ref-&gt;[$last_index]; Hashes work the same way, but use `%{}` or `-&gt;{}`. Function references also work in a similar fashion, but use `&amp;{}` or `-&gt;()`. Note: You may find the following confusing. If you do, just ignore it and always use the braces with the dereference operators. The dereference operators (${}, $#{}, @{}, %{}, and &amp;{}) do not require the braces if the reference is held in a simple scalar variable. So you can say my @array; my $ref = \@array; push @$ref, "foo"; print $ref-&gt;[$#$ref], "\n"; #prints "foo\n" But when you have a complicated expression (like a function call or a reference stored in an array or hash), you must use the braces: my @array = ( [ 1 ] ); push @{ $array[0] }, 2; print "@{ $array[0] }\n"; #prints "1 2\n"; Speaking of references held by arrays or hashes, you only have to specify the arrow once, so $ref-&gt;[0]-&gt;[0]-&gt;[0]; is the same as $ref-&gt;[0][0][0];
awesome. nice well thought out rewrite.
Everything should work in double quotes like that - I believe I've used this exactly like this, though it's been a while.
also, to initialize a reference to an array, use [ ], like in my $array_ref = [ 1, 2, 3 ];
http://rationalwiki.org/wiki/Concern_troll
That doesn't make sense. Where are you expecting the breakthrough to be? Evolution, by ... definition? Convention? Is crazy slow. With tiny deltas.
I must have done too much reddit today because I read that as 'Evolutionary Image Republican' at first.
source? my boss is a big Perl guy, this will make him feel old...
All valid points, not a single one caused by a mass of operators or unicorn infestations. But then I know you actually would prefer unicorn infestations... If the unicorns documented stable APIs.
Most big Perl guys are old
Whoa! Perl is older ~~then~~ than me
perl -e "$_='3235207965617273206f66205065726c';for(m/../g){print chr(hex)}"
Here's the link from the Perl foundation: http://news.perlfoundation.org/2012/12/the-first-twenty-five-years.html
I am 34 and a "Big Perl Guy". I resemble that remark! Just wait for Perl6. We will see if it is still deemed an old man's tool. ;)
Only in software and professional sports is 34 old. heh.
&gt; All valid points, not a single one caused by a mass of operators or unicorn infestations. Maybe. I see opportunity costs in chasing featuresets to the exclusion of documentation, packaging, and ecosystem. With that said, volunteers will work on what they want to work on.
I'm 26 and I'm "a Big Perl Guy". 
I didnt say ALL big Perl guys are old. I'll be more precise. I'll make a statement then you prove me wrong. It will be a game and we will enjoy it. Here goes: The mean age of enthusiasts of the Perl computer programming language is at least 5 years greater than the mean age of enthusiasts for Ruby, Javascript, or Python. 
You can just do this from the command line perl -pi -e 's#\.{2}#~/captain/#g' input_file.txt
&gt; Effort on implementing the language is not being done to the exclusion of other elements, including the three you list. Nonsense. Remember "Using Perl 6", the book that was going to come out concurrently with Rakudo Star? I guess macros and rewrites and ports to other VMs are more important. &gt; imo, in practice, #perl6ers do a good job of balancing their attention between whatever is their personal focus and whatever it is that folk say they need at any given moment. In my own personal experience, stuff I asked for years ago still hasn't appeared, and I was a committer perfectly willing to trade bugfix for bugfix or feature request or review or whatever. You write plenty of florid prose about idealistic fluff, but I question whether we even live on the same planet.
I'm assuming the 'CONIFG' in the second line of Ref #2 is a typo, and not in fact the cause of your problem.
Perhaps the FindBin module could be of use.
 [@LiquidWeb](http://twitter.com/LiquidWeb): &gt;2012-12-18 21:03 &gt;Happy 25th birthday Perl! [pic.twitter.com](http://twitter.com/ctreinhardt/status/281107495487954944/photo/1) [^[Imgur]](http://i.imgur.com/edyvn.jpg) ---- This comment was posted by a bot. [[Did I make a mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/152kzp%0A%0APlease leave above link unaltered.) [[Make a suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [[Translate this tweet]](http://translate.google.com/#auto/en/Happy%2025th%20birthday%20Perl%21%20http%3A//twitter.com/ctreinhardt/status/281107495487954944/photo/1) [[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) 
Not using strict shouldn't be allowed. I made the same misstake at first "woah, no need to declare variables! Sweeeeet!" then many hours later I can't figure out why $foo isn't updating, I'm clearly setting $fooo = 1; up there. hmm...
Dave made a nice slideshow, check it out guys: http://perlhacks.com/25-years-of-perl/#/header
Fixed. Thanks for pointing that out
 perl -e 'print chr hex for"3235207965617273206f66205065726c0a0d"=~/../g' Or, with more recent Perl: perl -E 'say map{chr hex}"3235207965617273206f66205065726c0a0d"=~/../g'
I only half understand anything you said. I need to do some reading to figure out exactly what you are talking about since my background is primarily in C. According to what I read in the documentation, I used require because it will link (is 'link' the correct term?) at run time rather then compile time. The config file has references to the ENV hash as well so those need to be pulled in when the file is referenced and no sooner. Your method seems a little..."Heavy" for what I am trying to do though..Maybe that is just how things have to happen in Perl. But I noticed that my Ref #3 in my OP works in some files and not in others. Do you have any explanation for this and/or maybe an answer for my original question? I just cannot make sense of why some things will work in one file but not another when it is the same lines of code. The file that it does not work in, simply doesn't see any definitions of those variables. Thanks.
No, it's fine, I appreciate the help. I wish I could just post the files I have, but can't. I will put together an example to post that will hopefully have the same issue. Also, I am not getting any errors. (I don't think I said I was..) It just doesn't work in one of the files, as in the variable has no value (at least in terms of a string, it could be null or whatever; but let's not get into semantics) 
&gt; switch your perlbrews to 5.14.1 and try to install Dist::Zilla It installs just fine. &gt; What do you want ? You want me to send patches or BUG REPORTS ?!?!?! Yes, I expect you to send a bug report if you actually expect someone to be able to figure out what the problem is and fix it. We're not mind readers, and we can't magically know what your issue is if you can't be bothered to show what you did and what you got as a result.
you need something like this: splice @array, 2, 1; Where @array is the name of the array you want to modify, 2 is the positition (which happen to be your case) and 1 is the Lengh. 
You don't even need a second array. This works: @arr = grep { $_ ne '' } @arr; 
No! It means "participation in the perl opensource community". See the original survey - http://berekuk.wufoo.eu/forms/perl-community-motivation-survey/.
I don't think that's true. People who *contribute* to perl ecosystem are driven by creativity. People who *use* perl - 99% of them - don't participate in open source at all, are are often driven by money or career.
So do this: @arr = grep { defined $_ and $_ ne '' } @arr; Full example: % cat !$ cat greptest.pl #!/usr/bin/perl use strict; use warnings; use Modern::Perl '2012'; my @arr = (undef,'',1,'two',undef,''); @arr = grep { defined $_ and $_ ne '' } @arr; say foreach @arr; % perl !$ perl greptest.pl 1 two 
The string `'0'` is false, however. The second `grep` will not include it in the result even though it is defined and `ne ''`.
That is far more helpful than you could imagine. I'll try to use some data from [wiki](http://en.wikipedia.org/wiki/USS_Constitution) Say we're indexing that ship data in this style. my %ships = {name =&gt; USS Constitution, Build_dates =&gt; { Start =&gt; qw/1 November 1794/, End =&gt; qw/21 October 1797/ }, Size =&gt; { foremast =&gt; 198, #in feet mainmast =&gt; 220, mizzenmast =&gt; 172.5,} } Okay so typing that out helps me understand it a lot better, I think the biggest thing I was getting grief was the fact that some of the data was returned from a sub. So you'd see something along the lines of my %ships = {name =&gt; USS Constitution, Build_dates =&gt; { Start =&gt; get_start_dt(), End =&gt; get_end_dt() }, Size =&gt; { foremast =&gt; get_mast_size("fore"), #in feet mainmast =&gt; get_mast_size("main"), mizzenmast =&gt; get_mast_size("mizzen"),} } I guess I don't really have a question in there, but I'm hoping you'll see what I'm trying to do and help me fix it.
Braces create a hash reference. That's what you want for the interior values, but it's not what you want for the outermost level if you're assigning to a hash (as opposed to a scalar). You want normal parens for that. In other words, either: my $foo = { bar =&gt; .... }; $foo-&gt;{bar} or my %foo = ( bar =&gt; ... ); $foo{bar} Also, you need quotes around strings on the right hand side of the `=&gt;`, so you'd have to write `name =&gt; "USS Constitution"`. You can get away with omitting the quotes if the string is a single word and it doesn't clash with some other keyword or identifier and you haven't enabled warnings, but you should always enable warnings so don't count on this working. Also, if you want a list of items on the right hand side of `=&gt;` you need to use `[ ]` to create an array reference. Writing `Start =&gt; qw/1 November 1794/` is not going to do what you think: $ perl -MData::Dumper -E 'my %foo = (Start =&gt; qw/1 November 1794/); say Dumper \%foo' $VAR1 = { 'Start' =&gt; '1', 'November' =&gt; '1794' }; This is due to the fact that when assigning to a hash, it's really just a regular list that happens to be interpreted by the assignment as a series of key/value pairs. The `=&gt;` acts like a "fat comma" that allows the thing on the left hand side to go unquoted, but it's otherwise just like a comma. But lists flatten, i.e. `(1, (2, 3, 4))` is the same as `(1, 2, 3, 4)` in the same way that `('Start', ('1', 'November', '1794'))` is the same as `('Start', '1', 'November', '1794')` is the same as `('Start' =&gt; '1', 'November' =&gt; '1794')`. 
start here: perldoc perlref
[Data::Dumper](http://search.cpan.org/~smueller/Data-Dumper-2.139/Dumper.pm) can be pretty helpful to visualise complex data structures. use Data::Dumper; my %stuff = ( foo =&gt; [1, 2, 3], bar =&gt; [[10, 20, 30], [40], [50, 60]], baz =&gt; [[[qw/red green/], [qw/blue purple/]], [qw/yellow black/]], ); print Dumper (\%stuff);
I've looked through those several times. Unfortunately I can't make heads or tails of their examples and was honestly hoping for a few more.
From what I can tell it looks very similar although the output of *Dumper* can be used to reconstruct the object. my %stuff = ( foo =&gt; [1, 2, 3], bar =&gt; [[10, 20, 30], [40], [50, 60]], baz =&gt; [[[qw/red green/], [qw/blue purple/]], [qw/yellow black/]], ); my $object_string = Dumper (\%stuff); my %stuff_2 = eval($object_string);
Well, I like it. I am proud to be part of a community that sees a link between programming, philosophy and poetry.
I think it's more like PHP's print_r()
Data::Dumper::Simple is a slightly nicer (IMO) variant on the theme, outputting variable names with their contents. 
you may want to flush your output after each print statement: select((select(TMP_ENV), $|=1)[0]); I'm not sure about freenode, but occasionally on logging into undernet, you'll get this: *** Ident broken or disabled, to continue to connect you must type /QUOTE PASS 10052 where you'll have to respond back with print socket "/QUOTE PASS 10052\n" I'm also a Linux user, so we have a program called fortune: [biff@new-host-3 ~]$ rpm -qa | grep fortune fortune-1.0-37.2.el6.rf.x86_64 I generally like to have my bots something unusual on occasion. just for fun # do a fortune ever few messages if($counter == 700){ if(!(open(Fp, "/usr/pkg/games/fortune |"))){ print $client "fortune not available now\n" }else{ while(&lt;Fp&gt;){ print $client "PRIVMSG $channel :$_"; print "$_"; } } close(Fp); $counter = 0; } 
You might want to take a look at [POE](http://poe.perl.org/), and [this](http://poe.perl.org/?POE_Cookbook/IRC_Bots) in particular.
Add `use strict`. Try running [Perl::Critic](http://perlcritic.com/) on this too, if you want to get some really good advice from a static analysis tool.
First, run perl -V and look at the bottom of the output under "@INC" to see where the Perl install on your box expects to install and find modules. If you have write permissions on those directories, enter curl -L http://cpanmin.us | perl - --sudo App::cpanminus to install the cpanminus script. Then just enter cpanm PDF::API2 to install that module.
Thanks. I installed cpanm and now have errors trying to install PDF::API2, which are in my original post.
Sounds fun. I'd love to look at your concept.
I sent you a PM, but just in case it gets lost in the shuffle. I have a metric ton of cpanel &amp; perl experience, I'd love to look at it.
I remember checking this out a few years ago. Is it on par with rakudo yet?
Yes, I was there 7 years and decided it was time to move on and do something different. I loved working there, I just stopped growing in the way I wanted to after so long. Plus I wanted to work with different sets of technology.
This has been on the fridge at my job for 6 months
Psh, too easy. Any excuse to link my favourite regular expression... http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html
I created these a while ago and just recently started using them in a real-world application. Now I'm here to see if there is anyone out there interested in this, if there is, I intend to publish it as a module and add more gauges. Right now, the parameters are passed through the URL, they are kind of self explanatory... http://opinax.com/cgi-bin/dialmeter1.pl?title_l=Text%20Left&amp;title_r=Text%20Right&amp;title_b=Text%20Bottom&amp;val=257&amp;max=400&amp;size=400 The size is the image height in pixels, image width is 1/2 of height. 
The other thing that's often missing is licenses. Which is a problem if I need to make a Debian package of something to redistribute.
 The Perl 6 saga == sad
Go soak your beans!
Very informative for someone like me that knows very little of Perl
How so?
I don't know if anyone would be interested in this specific set (i'm also curious what your specific application is), but i'm pretty sure the code would be very useful on CPAN for people looking to do something similar to these. So yes, please publish. :)
sigh.. *adds test descriptions to latest project* 
When you say "scraping", do you mean screen scraping web pages? Look at Web::Scraper and/or WWW::Mechanize on CPAN http://search.cpan.org/dist/Web-Scraper http://search.cpan.org/dist/WWW-Mechanize Mech specifically has docs with examples and the start of a cookbook.
When you come back to it months later and one suddenly fails, you'll be very thankful.
There's no performance impact other than the very little time required to check whether the file has already been pulled in previously. [link](http://perldoc.perl.org/functions/require.html)
Indeed. Many times I've "finished" a module, and started writing tests, only to go back and add or remove large swaths of code.
The only two on that list I can recommend are "Modern Perl" and "Higher Order Perl"
Yes that is what I mean. I checked out Web::Scraper before and it wasn't much help. I'll check out mechanize too then.
Agreed, but I think Allen Downey's *Learn Perl the Hard Way* might be worth a look, based on his other work. Also, *Perl &amp; LWP* is bit dated, but the original author did update the book in 2007. It's still a decent resource for anyone using modules that work with LWP. 
That's a great link matey! Thanks!
So to clarify, you're saying it's probably better to call in those libraries that aren't used every time a script is run, throughout the script only when the script is needed (even though it may end up calling the library several times), instead of just once at the head of the script where it loads in every time, whether or not the library is used. Did that make sense as an accurate recap of what you're saying?
It works like this: $qp = qp($filename); $qp-&gt;find('title')-&gt;text('Hello World.')-&gt;writeHTML(); It would be a great alternative to templating, if it is fast enough. However, it needs to be safe and not break the HTML code after applying qp translation back and forth. I tried a few Perl modules and they seem to be unsuited for templating, rather targeted for HTML scraping.
are there any perl or regex or even programming related free books on epub or mobi format? such a list would be great.
I think mostly I'm saying that it doesn't matter how often and where you include other files. Including them multiple times carries no real performance quality so do whatever you are comfortable with.
http://onyxneon.com/books/modern_perl
it looks very nice! thanks.
But it does effect performance by including libraries that don't get used, right?
The author has expressed a long-standing wish to convert the book to wiki format with protected transcluded passages from the book &gt; like this for example intercalated with community commentary like this.
Yes.
[Mojo::DOM](http://search.cpan.org/~sri/Mojolicious-3.72/lib/Mojo/DOM.pm) does what you want probably, I think there's a few other DOM manipulation libraries on CPAN too, take a search for "DOM". Mojo::DOM would do the same as your example with something like: use File::Slurp; use Mojo::DOM; my $html = File::Slurp::read_file($filename); my $dom = Mojo::Dom-&gt;new($html); $html = $dom-&gt;find('title')-&gt;replace_content('Hello World.')-&gt;all_text(); File::Slurp::write_file($filename, $html) or die "Unable to write $filename: $!"; Note that I haven't tested this code, so it's bound to have an embarrassing error in it somewhere, but it's a starting point for you.
I should also add that it has been available in PDF format for several years from http://hop.perl.plover.com/book/ .
Really helpful would be to see the date of publication right away, since Perl 5 has gotten a lot more good convetions in the last couple of years. (Or so it seems to me)
That would be cool!
 use lib LIST; Where list can be one or many separated by a comma, or you can define an array and use the array in place of `LIST`. http://perldoc.perl.org/lib.html
Have you seen http://prepan.org ? It may be a good place to discuss this.
That's one way, yes. The article lists others.
Where's `local::lib` and `perlbrew`?
As a Perl amateur, can't you just push your non-standard location onto the @INC array?
Yeah, but you probably want to make sure you do it within a `BEGIN` block. 
Whenever we encounter a problem with @INC, we just do a re-deploy with the newest code in production, it's usually an issue with SVN. But, to stay on topic: http://learn.perl.org/faq/perlfaq8.html#How-do-I-add-a-directory-to-my-include-path-INC-at-runtime- 
I just put my personal subroutines in a file "mySubs.pl" in perl/lib, where perl is sure to look, and then put do "mySubs.pl"; at the top of my scripts, right after the use statements. It's easier that a begin block and setting @INC. 
You're missing the input argument for harness() my $in = ""; my $h = harness \@cmd, \$in, \*$out, \*$err, timeout(30); I tested that and I think it should do what you want. 
That's more or less the same as use lib. There are cases mentioned in the article when this is not what you want.
That's how things were done in perl 4. What if you don't need all the functions? What if you have two sets of such subs in two files myCalc.pl and myStore.pl and in both you have a function called add() ? And what about modules that you download from CPAN?
This is a bug in how selects are handled with a timeout, it was solved in the 0.91 release which just fixed this. It is described in the cpan RT [here](https://rt.cpan.org/Public/Bug/Display.html?id=57277) There are ways to handle it, but not a way that makes sense in my implementation, looks like the best way forward is an upgrade. 
So this would be a way to officially measure skill in Perl? I find that because there are no Perl certifications out there( that I know of ) and TMTOWTDI, Perl was the coolest of the major languages used out there, sworn never to enter the mainstream. Alas, it has to become popular some time, given that it provides a great way to do things.
I like to keep my programs as system-configuration independent as possible. If I give the program to someone else, I don't want to give him a faq on how to reconfigure his system in order to run it. I accept the responsibility of keeping my own library files from interfering with one another. And, the system seems to have no problem finding CPAN downloads.
That's good. I'd probably still "use lib" but with relative path.
UPDATE: http://blogs.perl.org/users/davewood/2013/01/nginx-fastcgi-vs-starman-erratum.html
eagerly waiting how rakudo on jvm will fare. however, i suspect startup time will be enormous. on another note, does anybody know of some benchmarks for niecza (especially startup time)?
Try installing Devel::NYTProf and running both scripts with that. The resulting analysis should show you how much time the printing takes up compared to the calculation. :)
On my (fairly speedy) desktop machine, niecza startup time is 0.67 +- 0.01 seconds, Rakudo's is 0.24 +- 0.01s. Though at run time, niecza is often one or two orders of magnitude faster.
thanks, i'll check it out.
I outgrew IRC in the 90s. I can't believe its still used.
It's easy to set up, administrate, and host. It has thousands of modules, bots, and features. What's not to love? Need a quick and secure operations server for whatever? ssh and ssl on a private server. I don't understand how you can say that you "outgrew" IRC. It's just a protocol, one that's still widely run and widely compatible today.
I like you.
Tainting would in no way help something that's explicitly designed to evaluate arbitrary user-supplied code.
Ah, I didn't realise that was what the bot was for, I thought this was a code-injection attack.
Well, in our defense: Our corporate messaging uses the jabber(?) protocol, and for whatever reason, the server goes down fairly often. Plus, it's all logged. So, for all the reasons /u/CaptainDickbag listed, we use irc to chat.
This is not gonna work..
I don't get it. How is this not exactly what Perl 6 was (is) trying to do? &gt; the difference is that I want to do it for Perl 5. What does that mean if not backwards compatibility, which is clearly not a goal?
Absolute perl noob here, but I think your answer is: $time =~ s/[0-9][0-9]/$&amp;/ Just did a little research, yep, it's $&amp;: [Capture Groups](http://perldoc.perl.org/perlre.html#Capture-groups)
That is perfect. Thank you. I'd also say you're +1 up from an absolute perl noob, because that title is for me only.
I like what you are doing. The choice of Scala concerns me. I like my Perl close to the OS. Choice of JVM complicates that. I am also not sure how well Scala will age as a language.
Wow. Bold. Also, github repo: https://github.com/stevan/moe Also, unrelated to the actual content here: love all the great pics and illustrations in the slides, and am *especially* grateful for the text of the verbal content of the talk at the bottom of the slides. Wish more people would do this. 
In theory once the underlying naughty bits are straightened out they could rewrite moe in moe then escape from scala/JVM. 
Man this was hilarious. And about right, dare I say. Though I'm quite surprised by the choice of Scala.
This is the same guy responsible for the monstrosity known as Moose. The slides were amusing, but I don't agree with many of his conclusions. It sounds like he wants to jump on the hipster wagon.
Make sure you read the warning associated with $&amp; about performance. You are probably better off using () to make a capture group and then referencing it with $1. 
I agree with a lot of the points made and share many of the frustrations, but I'm still missing something. If a Perl 5 fork would break backwards compatibility in the name of progress, and run in a VM, isn't that what Perl 6 is aiming to do? Why not focus the effort there? How much work is needed to get 6 'I can use it at work'-ready I wonder? (I've only played with it a little bit). Sorry for the dumb question, but this seems like duplicate effort. 
Perl 6 may have been trying to do that at some point, but long ago it turned into a much different language than "Perl 5"++, to the point where it's best to think of it as something similar but much different. What I got from the slideshow was that what they want is something like Perl 5 with all the backward compat hackery removed completely, all the rough edges over 18+ years of use sanded down, and just the best parts remaining. This language would still be closer to Perl 5 than Perl 6 though.
what he's looking for already exists. its called jRuby...
I'm not sure I agree with all the decisions here but I think the argument would be... &gt;If a Perl 5 fork would break backwards compatibility in the name of progress, and run in a VM, isn't that what Perl 6 is aiming to do? Why not focus the effort there? The JVM is already a stable, mature and well-optimized platform that has millions of man-hours of work gone into it and testing in the field. The same is not true of Parrot and probably never will be. As for incompatible language features, *"Perl 5 with Moose built in and some of the terser constructs deprecated"* is a more practicable goal than *"a superset of all known languages only with more complicated syntax"* which I believe is a verbatim quote from the latest Perl6 spec. &gt; How much work is needed to get 6 'I can use it at work'-ready I wonder? It's been over a decade already. If it's not going to ship now, it's not going to ship. &gt; Sorry for the dumb question, but this seems like duplicate effort. It would only be duplicative if Perl 6 was going anywhere.
I don't need to use Moose but what about it? Isn't it better than what we have natively?
I like it a lot more than the native options. It's performance leaves plenty to be desired, but you can buy a faster computer for much cheaper than you can hire more experienced developers to spend more time on the code to make it do half as much as moose does.
&gt; It's performance leaves plenty to be desired Citation needed. You lose much on startup time, but it's no slower than bare Perl; actually, a guy who did a perlformance talk on YAPC::EU showed benchmarks when Moose perform method calls (or was that accessor calls) faster than bare Perl.
Anecdotal evidence, unfortunately. The thing that is so great about moose is it does a LOT of things for you. Things that are slower than not doing them, but arguably worth it (input validation/the entire type system, inheritance, etc). When you compare straight perl not doing any of that to moose doing all of that, its obviously going to be slower with moose. The question becomes whether or not your task needs raw performance more or cleaner safer code more. I've always leaned towards the moose way, but its also always been slower than my less safe more hackey prototypes. 
See also Topaz
Because we've been hearing stuff like this... &gt;Perl 6 is a new language which is on the verge of being production ready, next twelve months or so probably we can start using it. It’s already released, we’ve had probably 35 or 36 releases of various Perl 6 compilers, it runs quite well... It’s not as fast as Perl 5, but... It’s not a production ready language yet, but... for over ten years now.
Today on #perl6: [0:08 Sketch a frontend](http://irclog.perlgeek.de/perl6/2013-01-13#i_6326360) [16:10 nqp nqp-jvm-cc.nqp --setting=NULL -e "nqp::say('omg jvm!')"](http://irclog.perlgeek.de/perl6/2013-01-13#i_6327788) jnthn doesn't hang about. :)
Agreed. Bagging on perl is neither novel nor a particular hindrance to the thousands of times a day when perl solves people's problems.
He's not saying Java is better. He's demonstrating how one of the slowest languages on the market managed to pull ahead of Perl in terms of OO before Modern Perl was even an idea in any one person.
If you're using Perl to solve big problems, you've probably run into a few cases where Perl itself *is* the problem. Why not try to solve some of those?
Who is in the Perl community is saying "We must support CGI"?
I am not bagging on perl (hi, talk author here), I am saying that we need to save it from dying more. 
By declaring it a dead end? No offense but you may not be the man for this job.
Actually, you pretty much understood a lot of the goals I have for this project (hi, talk author and the insane person who is doing this)
Yup, thats pretty much it, but that said, I really want this to be an effort with the Perl 6 folks as well so that we have a real decent chance of interoperation between the the languages.
Honestly, if you say that then either you didn't read all the slides, or it wasn't clear enough to you. The dead end here is the current C implementation of Perl 5.
&gt; That said, the case for "fixing perl5" versus "rewrite it in new shiny language" seems to hinge on the claim "fixing it is too hard"? Or did I miss something? No, you didn't miss something, thats the point. The amount of people capable of doing this with the exisiting perl.c is severely limited, not to mention that it would be a horrible job and no fun at all. 
Well, you would be surprised actually, when Plack was first written it was voiced by many as a major concern. But you know, I think I over emphasized it a little, it was meant to be an example of how much time is spent keeping antiquated features while neglecting the more modern features we really need.
Exactly what mithaldu just said, the dead end is not the language, it is the current state of the Perl 5 core and the fanatical devotion some parts of the community has to backwards compatibility. 
You'd be surprised how many people say "We must support formats".
I figured someone here would enjoy this. It's a large, and I'm a medium, so no-go. Let me know the address of where to ship it, and you can just pay for shipping via pay-pal. I'm in PA, USA, for reference.
You can also use the `\K` feature added in 5.10 which is sold as being more efficient than using capture groups: $ echo 1234 | perl -pe 's/[0-9]{2}\K/:/' 12:34
Two things here: If you disagree with the wording, i'm sure stevan meant mostly to get people roused up by applying hyperbole. I can understand how some would not like that though. As for Java, keep in mind it's not Java. It's the JVM that's being used with the language Scala. (Scala actually kind of smells like Moose.) The JVM itself is a great piece of software engineering, if only for the massive portability it gives. It may not necessarily result in a polished and as usably endorsed end product, but it will allow implementers to quickly get stuff done and produce documentation that can be used to implement Perl 5 then in another language more easily.
There are actually many Perl developers who want to (and do) build solid big applications where startup time is irrelevant. Having multiple implementations available means both camps can choose their favorite one to get the job done.
Startup speed is only an issue for some applications. Measure runtime speed with and without Moose, given equivalent code. *That* is the interesting comparison under question.
I haven't used Go. How is its Unicode better than Perl 5.16's?
&gt; ... because taking two years to rewrite what will likely be a microscopic subset of perl4 won't solve anyone's problems. Maybe, maybe not. I see a way in which creating a usable subset of Perl 5 (which can evolve better than the existing Perl 5) can succeed, at least if it can avoid the Bullwinkling that's ruined existing Perl 6 implementations.
&gt; Citation needed. You lose much on startup time (...) That's what I said. Read the entire comment :)
One of the goals for this project is a formal language spec of a modern with less unncessary back-compat. Armed with that implementing it in lower level languages becomes much easier than trying to redesign Perl 5 in C from the start.
Perl had to build up its portability. Any project starting in C again would need to do the same thing. With the JVM you get it for free even if you start from zero. Also, as i replied to you elsewhere, one of the goals is a formal language spec.
Dropping 32-bit support might even be viable. When was the last time you deployed a 32-bit server? 2006?
This is great news. Last year I downloaded and modified the PDF version to hyperlink the table of contents to the relevant sections. I also added the cover. I emailed the author asking if he wanted the updated copy but he never responded. The epub version will make this easier to navigate for everyone.
The most recent information I saw (about a year ago) suggested that Unicode normalization was a work in progress. Casefolding appears to work correctly, but I need both normalization and casefolding.
More importantly, how is supporting CGI holding back other improvements in Perl?
It is not, it is symptom of a larger disease (IMO anyway)
PHP-&gt;Java bridge We have had https://metacpan.org/module/Inline::Java since 2001. 
Why bother? It is great if you have the luxury to re-implement perl the way you want it. But if you achieved this, I still am not moving back. Perl5 syntax is sh*t. I love perl, and used it for many years (1997-2009) but like many others, I've moved on to python because I got real work to do. I only regret not moving on sooner! Actually, CPython's got multi-threading issues in the form of the GIL. But there is also Jython, IronPython, and PyPy, which does not have that issue.
Interesting, what did you have me pegged as? 
That's an interesting perspective. Axiom: "CPAN is XS" Axiom: "XS is perl5" Conclusion: Some kind of "modern perl" must either provide an XS compat layer or a way of updating/migrating CPAN to a new interface method. Such a modern perl could then have greater latitude to reshape/redesign it's internals. Is that about right?
Might be better to just build something on the Rubinius VM. Ruby still has a lot of Perl heritage. 
Dumb question: Why is it unquestionably better for everything to be an object?
It's a matter of how it is used. Development cost + execution cost. Sometimes it is better to write unoptimized "quick and dirty" code when developer time is expensive and the code would be executed only one time or rare enough not to make a dent in the server load. Other times, such as when processing huge amounts of data on many servers, a slight improvement in code is worth a lot of investment. That's when you go low level, such as C.
I suspect it actually conflates two things. First, "everything must be backwards compatible forEVER" ... which, yeah, it can be taken too far, and I think sometimes is. Second, "fast startup is useful" + "pure perl is useful" - which sometimes gets referenced as "CGI style deployment" but honestly I (at least) care a lot more about the intersection of those two for small command line scripts than for CGI.
It's not just about startup/runtime speed, it's about *development and maintenance speed*. And it's *easier* to develop and maintain code using Moose than the alternatives.
... or you could use a module. You would have options.
&gt; clearly if no one will maintain the source, users eventually lose too. That's the primary concern. &gt; if a perl5 fork doesn't come with a fantastic batteries-included SDK... p5p has long struggled with this question. Is it better to focus on providing a working runtime which allows other people to bundle and distribute SDKs, to provide a minimal library which allows much easier access to the CPAN, or to attempt to provide and maintain (and, when necessary, prune) a large standard library? The sense on p5p seems to be that the latter hasn't worked well, though whether the problem is the idea itself or p5p's implementation of that idea is up for debate.
It's not really. But it is better for everything to have a consistent interface and objects may not be the best way to do that but they are a common way and better than nothing. IMHO the need for objects is just a symptom of not taking "everything is a string" quite far enough, but I'm not sure even I would want to program in a language that took it that far.
Tcl took "everything is a string" to its logical outcome. While that makes some things easy (creating GUIs is as easy as anything else I've ever used, with the possible exception of Rebol), it makes other things far too difficult.
So what does anyone think we should do to excite the graduates about Perl?
Yeah, I just went with formats because I vaguely remembered the syntax so it was fast to implement. But I understand they're old, unimportant, and may not be supported forever.
Hipsters ride bikes.
&gt; it makes other things far too difficult. Like what? Just curious...
Exactly....supporting Perl 4 should not even be on the table.
You sure that isn't too much of a bite?
I found that this blog post: http://mjtsai.com/blog/2002/11/25/perl_vs_python_vs_ruby got me interested in Perl again, esp. this response, from pavel kudinov: http://mjtsai.com/blog/2002/11/25/perl_vs_python_vs_ruby/#comment-13467 
I don't have much time to organize this into a cohesive reply, but here are some thoughts: * Perl *is* readable and maintainable, if you follow best practices. I run my scripts through [perlcritic](http://search.cpan.org/~thaljef/Perl-Critic-1.118/bin/perlcritic) (-4), fix the problems, then I run it through [perltidy](http://search.cpan.org/~shancock/Perl-Tidy-20121207/bin/perltidy). Over time, I've come to catch the problems that make perlcritic and perltidy mostly a thing of the past. Coding Perl is exciting and fun because of how easy it is prototype. It's also relatively easy to debug, when compared to other scripting languages like Bash. * Give graduates a purpose when you give them Perl: they need a real world example to drive them. I started learning Perl at my previous job because the Bash script I wrote was not maintainable or even remotely debuggable, so I started rewriting it in Perl, reading [Learning Perl](http://shop.oreilly.com/product/9780596520113.do). I finished writing that script; eventually, it was authorized for company-wide use by 300+ admins (large web hosting company). I started work on another but left before I finished it. The first Perl script was left in maintenance mode. * Teach them vim, how to turn on syntax highlighting, autoindent, etc., and working in a proper linux environment. Learning vim several years ago, way before I started Perl, has greatly boosted my production. As a colorblind person, I found the default color hightlighting difficult, yet I was able to come up with a reasonable one that worked for me. That's all I have for now.
https://github.com/fglock/Perlito Does a subset of Perl 5 and Perl 6.
Used perl for the first time in my grad job, mainly use it for manipulating text and its brilliant. before this job I had only heard negative things about perl but I think its brilliant, its a great language, easy to write, easy to read. What more do you want in a scripting language. 
To come at this sideways: Try https://metacpan.org/module/Moo If startup time is an issue for you it's extremely unlikely that you're using -&gt;meta and Moo supports everything Moose does, except for -&gt;meta. So for 99% of all cases Moo is perfectly fine. :)
Ha. Same reason I learned perl... shitty slow legacy bash script replaced with zippy perl script with tons of new features to boot. Now I automate anything I can with perl. It wasn't a requirement for my current job (or even on the job listing), but it definitely was a huge bonus point.
How much ambiguity are you willing to live with? If the static analysis can reliably find statement terminators, the worst thing you're *likely* to see is the wrong arity of functions with prototypes used without parentheses.
My rationale is that production code doesn't rely heavily on ambiguity. So, how much can we gain by focusing on the subset of Perl that is very (or should be) regular (as in predictable, boring, not regular like grammar).
I did a lot of perl programming from 1996, when I first learned it (Perl 4, actually) to early 2008, when I mostly switched to Ruby. I occasionally use Python now, too, but only when forced to. My Perl skills only come out now to maintain other people's code. The main reason I switched is that I find Ruby's syntax easier to deal with. (I hate Python's indentation-fixation and the fact that regexes are not first-class citizens.) Doing complex data structures in Perl is a nightmare.
Started in BASIC, school in Pascal, university in Java. First job was Perl, next job C# and Javascript, next job Objective-C. Now I'm back to Perl, though it looks like we might be using Java in the future.
Perl was the first language I learned in 1995. Still use it for almost everything involving text manipulation. Also use C, scheme and some ocaml.
Still mostly using perl, actually. Picked it up to deal with legacy code at my company a few years back, and slowly just gotten more and more happy with it. It's one of the better ones for what we do, and CPAN makes it easy to put anything out there. I'm working my way around Groovy and Scala as the opportunities present themselves, but perl is what I keep coming back to. It's my safety blanket.
More Perl.
I think you'll always have a problem because you can't *prove* that the parse as done by PPI is correct. If, as stated by mr_chromatic, the problem is subroutines with prototypes, there may be a way around it: * collect a list of all source code files used by your project * analyze all those files and collect the prototypes for all subs * determine which modules export what subs. If you can't do this statically, you might just compile the source and with some B tool (like, I don't know, B::Xref perhaps), scan the stashes and see what subs are aliased where. In principle you should then be able to determine if prototypes could be a problem, and if so, if the PPI parse is likely wrong. 
I still am; I don't plan to stop using Perl. It's the one language I've felt truly comfortable using, and CPAN is awesome. (Modern Perl is not dying, contrary to some peoples beliefs.)
Still Perl. Dabbled with Python, found it lacking. I now maintain a large Python project, and find it even worse than my first impression. Ruby looks promising but is not quite stable enough for my needs. So... Perl.
I'm guessing most people viewing /r/perl are still using Perl. I definitely am, in several projects right now. I keep meaning to pick up another language but I have too much to do and I can get so much done in Perl.
We don't use prototypes all that often. So how much of the problem is left? Like I said, I get that some features are hard to parse. So why not avoid parsing them altogether?
I like Perl, but due to Python's popularity I have been giving it a go.
Ruby (Rails). PHP (Eek! But it really gets stuff done.)
Perl. And some JS, but that's ~~hateful~~ not really in the same niche. I learned Python, but I can't understand why anyone would use it by choice. It feels so...soulless. All of the fun was engineered right out. Maybe that's desirable in a corporate setting, but I'm just a hobbyist.
Considering it's the **P**ractical **E**xtraction and **R**eport **L**anguage, no wonder it's useful for manipulating text. ;)
Still writing Perl code but I've been moving to Python. For whatever reason I feel more productive and find more enjoyment in writing Python code these days.
Here's the [relevant StackOverflow answer](http://stackoverflow.com/questions/2021482/how-do-i-read-a-single-character-from-stdin-using-perl-on-windows) to your question.
i occasionally use perl for the job but not enough, sad to say I use more PHP stuff and also have gotten into Qt C++ programming. ;(
Haha, damn right! It's quite a way off though, so I'm not too worried yet.
My employer banks on Java because our biggest client wants their code in Java; otherwise, they'd be writing it in C/C++ and/or Perl.
I started learning python, but it wasnt to move away from perl, it was just to expand my knowledge and have more options. 
I'm currently teaching myself PHP and Ruby, in order to land a job. I love Perl, and have been doing it for a decade. But it's a skill that doesn't (currently, in my location) seem to be in much demand.
I've recently re-discovered my interest in Perl (it was what I used at work already but I wasn't exactly excited by it) by discovering "modern" Perl. So, I've migrated from Perl to Moose ;-)
I use Perl at work. Modern Perl had made things a lot better. I've migrated lots of code to more up-to-date idioms, made liberal use of Moose, etc. Outside of Perl, I use Ruby. I like both Perl and Ruby, for opposite reasons. In a perfect world, I'd use Ruby at work and Perl in my off-time hacking, but it's actually the other way around for me right now. (I also know JavaScript, C, C#, PHP, a smattering of Java. I'm learning Go at the moment. ) 
where you at btw ?
Thanks! Will check it out. Luckily this form is pretty static.
As long as each field is named correctly, you can use PDF::FDF::Simple. Basically you generate a FDF file and then use pdftk with the fill_form option (ie pdftk template.pdf fill_form form.pdf output output.pdf) to generate your output.pdf file. This is completely untested but should be close to what you need: use strict; use Data::UUID; use Path::Class; use IPC::Run; use PDF::FDF::Simple; my $template_pdf = Path::Class::File-&gt;new( "/path/to/template.pdf" ); my $dir = dir('/tmp')-&gt;subdir( Data::UUID-&gt;new-&gt;create_str ); $dir-&gt;mkpath; my $fdf_data_file = $dir-&gt;file('data.fdf'); my $fdf = PDF::FDF::Simple-&gt;new( { filename =&gt; $fdf_data_file } ); $fdf-&gt;content({ field_1 =&gt; 'Content for field 1', field_2 =&gt; 'Content for field 2', field_3 =&gt; 'Content for field 3', }); $fdf-&gt;save; my $output_pdf = $dir-&gt;file("output.pdf"); my $cmd = [ pdftk =&gt; scalar $template_pdf, fill_form =&gt; scalar $fdf_data_file, output =&gt; scalar $output_pdf, qw{flatten} ]; my $out = ''; my $err = ''; IPC::Run::run( $cmd, \'', \$out, \$err ); die "Cover Page PDFTK error: $err" if $err; #Copy your $output_pdf file somewhere and then #$dir-&gt;rmtree; #to clean up the temp space
Yeah, it's **implementation** is a dead end. The language itself, I'm unaware of anything as expressive and flexible. 
I don't see anything that would cause me to think that it's skipping any lines. Are you sure something isn't happening else where? I would localize my variables differently though: my $log_data_ref = readlog($filename); sub readlog { my $logfile = $_[0]; my @log_data; open(my $logfile_ref, $logfile) || die ("Unable to open file. Please check the path and try again\n"); # Gather only lines beginning with two white spaces while(&lt;$logfile_ref&gt;) { if(/^ {2,}/) { push(@log_data, $_); # Breaks here } } close(FILE); return \@log_data; } 
I've isolated it down to specifically that line. The sub itself has been written both ways, however it's currently written like the above. I'm currently using the script to read only two log files, one of which is 50 lines, the other is larger at ~2000. The smaller log file is parsed properly, but the larger 2000 line log does not. edit: It was the scope of the variable @log_data that caused the problem. 
Your regex seems correct and I don't see a reason why only fewer lines are being added to `@log_data`. One thing that strikes me is that `@log_data` is defined outside the subroutine `readlog`, so it's scope is wider than `readlog`. Is it possible another part of your program is modifying the array? In order to avoid such possibility, I'd suggest changing your code slightly. Declare the array to fill inside the subroutine and return a reference to it. sub readlog { my $logfile = $_[0]; open(FILE, $logfile) || die ("Unable to open file. Please check the path and try again\n"); # Gather only lines beginning with two white spaces my @log_data; while(&lt;FILE&gt;) { if(/^ {2,}/) { push @log_data, $_; } } close(FILE); return \@log_data; } my $log_data = readlog($log_file); say "count of lines filtered = ", scalar @$log_data; Aside: Your regex could be simplified to say `/^ /` (caret followed by two spaces), which I think is a tiny bit clearer.
After a little tweaking, it appears that the scope of the variable is what caused the problem. Returning a reference to a local variable and pushing it onto the global variable fixed the problem.
Maybe some of the lines start with tabs instead of spaces? Or more unlikely, maybe some of them have carriage return as end of line marker? 
As a general rule, I'd do a few things differently to eliminate existing or future bugs: 1. Stop using "`&lt;FILE&gt;`" and similar filehandles. Modern Perl versions allow (and even suggest) using "`open my $file, "&lt;", "input.file" or die $!;`". This is a good idea because "`FILE`" and similar are globals. Don't use 'em. 2. If your expected input is relatively small (a few thousand potential lines) and/or memory consumption is not a concern, try using `File::Slurp` to read the entire contents of the file. Try this: use strict; use warnings; use File::Slurp qw(read_file); my @lines = read_file('input_file'); unless( @lines ) { die "Error! $!" } my @log_data = grep { /^ / } @lines; # Do someting with @log_data There's also the potential that your lines don't start with what you think they start with. If you're trying to catch things that have "white space" at the beginning, try the regexp `/\s+/` or somesuch. 
I've seen several things now that tell me not to use "&lt;FILE&gt;", so I will try to adjust the method as you suggested. Regarding File::Slurp, the logs that I'm testing now are relatively small (less than 5000 lines), but some of the production logs that will be read are larger than 50,000 lines each and there will be many of them. I will have to see what the memory constraints are with both methods. This code definitely looks more elegant.
Still have a couple of programs to maintain but we've upgraded to RPG IV.
This is from my teacher: http://voyager.deanza.edu/~perry/index.html He's great, but retired.
Wow, kudos for finding my ancient reply-less thread.
The function you want is caller. From the perldoc: ($package, $filename, $line) = caller; 
Just noticed that a bunch of the new's are not so new...
Oooh. Weird.
Yea, I messaged the mods just now... I saw something similar happen on /r/arch, I guess one of the mod's was clearing something out...(?)
Write a subroutine that uses [caller](http://perldoc.perl.org/perlfunc.html#caller).
instead of printing line numbers for debugging try using a debugger? Often this can save time as you can actually pause your code and inspect the state of the variables whenever you need. If you're unfamiliar with the perl debugger (command-line) try the *Devel::ptkdb* graphical front end from CPAN. perl -d:ptkdb test.pl
Same situation here. Every time I think that it might be time to look at something else for a project, Perl slaughters the problem in a welter of gore. EDIT: Also, CPAN almost always has the answer to every problem; or at least makes the problem easier to solve by giving us a good foundation. WWW::Mechanize, for instance, is very good at replacing lazy humans with a machine for certain tasks.
Log::Log4perl http://search.cpan.org/~mschilli/Log-Log4perl-1.40/lib/Log/Log4perl.pm 
If there are no other takers I would love to have the shirt. Just curious where did you get it?
Voila! Thanks! sub printLine { printf "\nat %s: $_[0]", ( caller(0) )[2];} 
Yes, I should. But I'm an old dog and new tricks are troublesome. (I've been doing it this way for 49 years. Well, no, actually in those days I'd do a core dump. :-)) When my program goes bad, I have some idea of how to find the problem. When a big fancy featureful CPAN edifice doesn't work as expected, I don't want to have to start debugging THAT.
&gt;the assumptions of the JVM are different from the expectations of Perl 5 or Perl 6 such that you either need a genius willing to perform heroics or you suffer at the gap between the two That may look strange, but often heroics is available and performs better than uhm.. traditional way of doing things. Like in Audrey Tang vs. Perl 6 committee etc. 
If nothing else, a competing implementation could force perl5 to move on.
You might also want to consider _logging_ instead of just plain ol' printing. Any decent logging framework should have this as one of its basic features: Log::Log4perl, Log::Any, pick any (hint intended). Aside from adding line number/file/package/subroutine location, it provides other information too like date/time, elapsed time, level, etc.
&gt; Doing complex data structures in Perl is a nightmare. Can you elaborate? (Bonus points for code examples.)
as if perl5 did not move on in the last 1-2 years (5.14 in 2011, 5.16 in 2012, 5.18* in 2013). in fact, it moves on so fast the linux dists couldn't keep up :) squeeze is still at 5.10 ffs... 
But they're mostly bug fixes or some general improvements of the interpreter. No shiny new features people expect for years..
I think there's no need for examples in that case. I fully agree with [ebneter](http://www.reddit.com/user/ebneter). Simple data structures are a complete nightmare in Perl purely because of notation.
Why do you think there's no need? I asked specifically because i need them, as i do not know what he is talking about. Perl data structures have always been easy and self-evident to me. Also, "Simple data structures", what? He wrote "complex data structures".
what exactly are those *shiny new features* people expect for years?
&gt;changing object access from -&gt; to . (like what moe plans to do) Please, don't! It's the same notation as C's pointer and that's good because it has the same semantics - Perl's reference to object (yes, bless returns *the reference*, not an *object* that is the thingy referenced by) is basically a pointer.
@{ $they-&gt;[are]-&gt;{fucked}-&gt;[up]-&gt;{@{completely}} } %{ $this-&gt;{ ${$one}-&gt;{sucks} }[even]-&gt;{more} } 
Had one guy said he wanted it, but he just stopped responding :/ I think I got it off ThinkGeek a while back - it's just a bit big and I'm trying to only wear shirts that fit me for once. Besides, I do the opposite of perl - I'm a .NET guy, haha! Where are you located?
I'd be interested to know how the scope really matters here. It's not at all obvious from the small code snippet. Can you elaborate?
That really is quite the opposite of perl! Yeah after a quick google search it looks like think geek used to carry that shirt but it doesn't look like they do anymore. Anyway I'll PM you.
&gt; Which can be cleaned up to this: You can't clean it up. Stop jerking off, be a man and admit the syntax is a complete fuckup.
Why am I a troll ? Because I'm pointing out to you with clear examples how weird looking and convoluted the syntax is ? On a different note, do you have any idea how horrible it is that there are a lot of people out there who don't write OO Perl and they produce untestable code ? Do you know how wide-spread that is ? Between this, and the lack of method/function prototypes, no explicit types on variables, the language not having a grammar and no tool out there to decompose it into an AST to provide nice refactoring tools or code-smell tools, I'd say Perl is the biggest mistake in computer language history. If you had two languages, let's take Python for example and you put Bash and Perl and Python on a scale it goes like this: &lt;---Bash---Perl-----------------------------------------------------------------------------------------------Python&gt; Do you want to shove those nasty aspects of reality under the carpet and just say "Oh, you're just a troll" ? Really ? REALLY ?! Wow.. you must really love this language. Plus, I'd say you're the troll here. This thread on reddit was specifically not made for you, it was made for people who have switched from Perl to a different language. So I'd say you're offtopic and you are the troll here, so go troll elsewhere.
&gt; Why am I a troll ? As i said: Your examples were flawed, no actual explanations offered, no counter examples of cleaner syntax offered; despite being explicitly asked to provide. Also, the rest of your post really makes your activity as a troll quite obvious. I really enjoyed the dissonance between a post that's 90% off-topic to the context it was posted in, followed by an accusation of going off-topic.
Some people wanted proper given/when or better sub prototypes or better OO, like Moose, or at least MOP in Perl core. Some people like this new perl features better, I for one care less for them.
| changing object access from -&gt; to . (like what moe plans to do) I would really like to see the reasoning behind this. For me, this is ugly.
&gt; The thread itself is not off-topic at all. Wow, pretending i said things i never said to continue a fake argument. Really impressive. You need to work on subtlety though. :)
[here you go](http://www.reddit.com/r/programming/comments/16ia7f/perl_is_not_dead_it_is_a_dead_end_forking_perl_5/c7wlf6j) i am also personally against the syntax change. it belongs in the syntax microoptimization department that does little but breaks 95% of perl5 scripts out there.
Ok.
aren't all of those already present in the current perl 5 ecosystem? (mop in core planned in 5.18). 
No. Given/when/smartmatch is still broken as hell, progress on a core MOP is dead as far as I know, and signatures... well, it might happen, but it's more likely to go the same way.
&gt;that does little but breaks 95% of perl5 scripts out there Yup. I just don't get it - if moe will not be CPAN-compatible, what's the whole point? Yet another JVM language with no CPAN? We have bunch of them already. 
Thank you very much! - I will study this carefully.
My guess is that the point is this: if you fix just the *most* complained-about things in Perl 5, then folks will *want* to upgrade their modules. But hang on a sec. If you change too much, then it becomes a different language and that's a whole 'nother ball of wax. If you don't change/improve enough, then folks have no reason to migrate b/c it's not a big enough improvement. I suspect Moe will look for that sweet spot. Change just what parts of Perl 5 that bug long-time users the most. We'll see though. I'm waiting to see more details of what their plans are.
Based on the comments from Stevan that I've read, my impression is that he is not trying to create something useful. It is just an experiment but if that experiment turns into something useful, then great. On the dot vs arrow, he only said maybe.
I think ebneter is probably referring to accessing data inside something like: my %data = ( a =&gt; [10, {x =&gt; 100, y =&gt; 200}, "hi"], b =&gt; [20, {x =&gt; 400, y =&gt; 440}, "yo"], c =&gt; [30, {x =&gt; 600, y =&gt; 610}, "oof"], ); Suppose you want to get at b's list's y value. Thinking in terms of dereferencing as you go, the thought process might go like: `%data{b}` `$data{b}` `@{ $data{b} }` `@{ $data{b} }[1]` `${ $data{b} }[1]` `%{ ${ $data{b} }[1] }` `%{ ${ $data{b} }[1] }{y}` `${ ${ $data{b} }[1] }{y}` Which is a handful. You might instead use your knowledge of the arrow shorthand: `$data{b}-&gt;[1]-&gt;{y}` and then further shorten it to `$data{b}[1]{y}` So, the final syntax for accessing the element isn't bad at all, but arriving at it requires knowing about and using shortcuts. 
I still use Perl and will continue to use Perl. That said, I also use PHP and Ruby for things which formerly would have been done in Perl.
While i admire your willingness to put some thought into it, this is pure speculation. Newbies i encounter who learn about data structures don't think like that at all. Also, the complex data structure tutorial itself teaches it in the style of your last piece of code: http://perldoc.perl.org/perldsc.html So, i'd rather hear from someone who actually thinks that it's a nightmare why it is so.
The whole concept of complex data structures in Perl is based on references, and you have to understand them to do much of anything. In Ruby, everything is an object; an array of hashes is no different, fundamentally, from an array of integers. I can provide some code examples later, to illustrate; I don't have time right this minute.
Fwiw, the whole concept of complex data structures is based on references *in Perl 5*, but in Perl 6 ["References are gone (or: everything is a reference)"](http://perlcabal.org/syn/Differences.html#References_are_gone_(or%3A_everything_is_a_reference%29). In general you can expect Perl 5's syntax warts to be gone in Perl 6.
Try it you may like it. Its pretty intimidating at first but once you know the commands its pretty useful
That comparison seems invalid to me. Pugs hasn't been active for *years*. Rakudo has its problems, sure, but I still believe that heroics aren't sustainable.
Thank you for answering. :) I'll really love to see straight comparisons illustrating what annoys you, and will happily wait for however long it takes you. :D
Just out of interest, are these PDFs with "proper" PDF form fields, or just graphic boxes where people would normally print them out and have their Butler fill out using a quill and ink? EDIT: Whilst looking at a related problem to yours, take a look at CAM::PDF; never used it myself, but it seems to have some form-filling functions.
I still use Perl. I don't know what the future holds. Honestly, I think that ten years from now I may no longer be programming professionally anyway. Once my wife has a decent paying job (as a nurse practitioner) I may use that as an opportunity to take a low-paying job in animal advocacy. 
| the syntax is a complete fuckup I'm not at all bothered with syntax on this example. I'm more bothered by the 4D array you have to hold in your head while programming (regardless of notation). That thing could be much better abstracted IMO. So, in real world when you encounter code like this it's probably some lazy programmer that failed handling the data, and not Perl being stubborn with crazy syntax on purpose.
I'm afraid you have no real-world experience. 
Pugs? Really? Gah...someone please scrape this taste of 2003 off of my tongue.
It's probably best to think of Perl 5 not as a language, but as a Unix tool. "perl" the One_True interpreter is a thoroughly powerful swiss army chainsaw and Unix utility - just like awk, find, grep, etc. If you replace "perl", you destroy Perl 5, since it is implementation defined. If you want to formalize the language supported by "perl", then go for it. You'll get Perl 6 - a set of specifications. From that, you'll get a thousand half-baked implementations: Pugs, Rakudo, Ponie, and now it seems...Moe. All of these to sit along side of "perl" if an executable tool is ever the result of such an effort. The best one can get is to create a variant of "perl" that supports a sub or super-set of what "perl" does - like grep has egrep for fastgrep or macgrep. Like Lisp has 800 interpreters/environments. Go for it. There will always still be the primary Unix util sitting in /usr/bin/perl. Saying one wishes to create a "better" Perl is more like saying one wants to create a better grep. Been there, done that. Go for it. In the meantime, I'll be here doing amazing things using this amazing tool that was born and raised in an awesome OS environment and is based on a crazy interpreter written in an amazing language. Is the formalized version of the "syntax" of "perl" transcended the One_True interpreter and become robust enough to compete with much more formal and academic languages? I suppose, but trying to force Perl 5 the formal language (i.e., Perl 6) to compete with things like Java or Scala or whatever is sort of like taking your sister to the prom. It's just not right, but really tempting. I still would not recommend it, because in the end you're going to do something you may regret.
Someone who would be much happier with Python or Java or Scala. Someone who goes into a manic state about creating something that will finally kill off "perl" the One_True interpreter. Someone who mistakes the syntax of "/usr/bin/perl" as a true formal language, then shits on everyone who has contributed to this tool for the last 25 years. Someone who says "fuck" too much because he can't make any truly technical points, relying much more on shock value. Someone stuck in 2003.
Elaborate?
In Java, not everything is an object.
In this case, I don't. I can't remember ever referencing something beyond third level of nesting. And I purposefully avoid doing that.
This form is an NIH Inclusion Report form that must be filled out from time to time. Looks like a great candidate to grab the numbers from the database and drop them in here and send electronically. http://grants.nih.gov/grants/funding/2590/enrollmentreport.pdf thanks
OFFTOPIC: Get used write `or die` instead of `|| die`, as it has much lower precedence, so it's easier to avoid silly errors if you have logic expressions before `or die` or `and die`
Try profiling or benchmarking some test cases for real results. But I would presume that the map approach will be much more efficient than map-grep as the list will only be iterated once. Also the documentation for map mentions omitting an element is usually done by return an empty list "()" in map, not undef. Try benchmarking this and *undef* to see if there is any difference in performance
Indeed, just as I thought it would be. `map` can't reduce the number of items, returning `undef` just places an empty item in the array. I made a faulty test that leaded me to the wrong conclusion.
As you say, map + grep looks better, and it's more self-documenting. You could benchmark it, but you're more than likely talking about micro-optimizations at this point. If you don't have a performance issue, it's not worth the sacrifice in readability, and if you do have a performance issue, this isn't likely the culprit.
You can simulate a grep in map by passing an empty list instead of undef. map { ? : () }
You need to iterate two lists, and build two new anonymous lists in memory, how would you say the difference is small? A map + grep is incredibly inefficient, especially because a map can complete the task on it's own. The grep is just redundant. 
Oftentimes seemingly intuitive things about optimizations in time are completely wrong and should be benchmarked. Like I said, it's probably not going to make or break your application. And since perl makes it so easy with the various benchmark modules, I'll give it a shot when I have a break.
 use strict; use Benchmark qw/cmpthese/; sub iseven { return $_[0] % 2 == 0; } sub addone { return $_[0] + 1; } sub mapgrep { my $i = shift || 100; my $sum = 0; $sum += $_ for map { addone($_) } grep { iseven($_) } ( 0..$i); return $sum; } sub mapmap { my $i = shift || 10000; my $sum = 0; $sum += $_ for map { iseven($_) ? addone($_) : undef } ( 0..$i); return $sum; } my $range = 1000; my %subs = ( mapgrep =&gt; sub { mapgrep($range) }, mapmap =&gt; sub { mapmap($range) }, ); #make sure they return the same thing for my $sub (keys %subs) { print "$sub: ", $subs{$sub}(), "\n"; } cmpthese -1, \%subs; $ perl mapgrep.pl mapgrep: 251001 mapmap: 251001 Rate mapmap mapgrep mapmap 998/s -- -5% mapgrep 1054/s 6% --
It depends, but if you have a list with 20,000 items or so, it will be noticeably slower and use considerably more memory. There usually is not a good reason to loop the same set twice. In this event, in can be done during the first iteration so there is no reason to go ahead and iterate again. Especially since this not just iterating a list, but building a new list while it's iterating. If you're making this for a webpage and you have a large result set, this can bring your server close the memory limits as every page request will load the large list into memory twice. 
Because iterating two lists vs one list is still just `O(n)`. Also, because benchmarks tell us that the difference just isn't there for most data sets: #!/usr/bin/perl use strict; use warnings; use Benchmark qw/cmpthese/; my @a = (1 .. 10); my %subs = ( both =&gt; sub { return scalar map { $_ * 2 } grep { $_ % 2 } @a; }, map_only =&gt; sub { return scalar map { $_ % 2 ? $_ * 2 : () } @a; }, ); for my $sub (keys %subs) { print "$sub: ", $subs{$sub}(), "\n"; } for my $n (10, 100, 1_000, 10_000) { print "\n$n items\n"; @a = (1 .. $n); cmpthese -1, \%subs; } output: map_only: 5 both: 5 10 items Rate both map_only both 148945/s -- -13% map_only 172031/s 15% -- 100 items Rate both map_only both 17772/s -- -10% map_only 19728/s 11% -- 1000 items Rate both map_only both 1846/s -- -7% map_only 1981/s 7% -- 10000 items Rate both map_only both 177/s -- -10% map_only 197/s 11% -- The performance gain is low enough that the clarity of the `map` and `grep` is a clear win. And a lot depends on how much the `grep` removes. For instance, with a `grep` of `$_ % 4 == 3`, there is no difference at 10,000 items: 10000 items Rate map_only both map_only 190/s -- 0% both 190/s 0% -- And if the `grep` returns everything, we start to see a reason to get rid of the `grep`: 10000 items Rate both map_only both 171/s -- -30% map_only 245/s 43% -- But even then, it isn't the order of magnitude growth that should characterize good optimizations. 
The format of your benchmark looks a lot like my standard template. Is this a case of convergent evolution, or did you grab it from somewhere?
The issue is not just in speed. map and grep build anonymous lists so your doubling the amount of memory used for no reason. If your serving a large website and you have thousands of requests per minute, that memory will matter, especially for larger size lists. Additionally, 10% is a significant gain in speed when you script gets executed that many times a second. There is no reason to chain a map and a grep. It can even be argued it is more difficult to read a map+grep then just a map as there is two code blocks to read as opposed to one. The map+grep is just so redundant. Your looping a list, building a new list, looping the new list, building another new list and then returning it, still retaining the original list. For what reason would one do this? I understand perl is founded on the idea of there is more than one way to do it, but some of those ways are inherently wrong and this is one of them. Redundancy is never desired and this way is overly redundant. If you are concerned about readability, then use a for loop. The script shouldn't have to work harder and consume more memory because someone is concerned with readability. Besides, this is perl, not python. 
 #!/usr/bin/perl use warnings; use strict; use Benchmark qw/cmpthese/; my @smalllist = (1..1000); my @biglist = (1..100_000); my @hugelist = (1..1_000_000); cmpthese(10000, { 'small grep' =&gt; sub { map { $_ + 1 } grep { $_ % 2 } @smalllist }, 'small map' =&gt; sub { map { $_ % 2 ? $_ + 1 : () } @smalllist }, } ); cmpthese(1000, { 'big grep' =&gt; sub { map { $_ + 1 } grep { $_ % 2 } @biglist }, 'big map' =&gt; sub { map { $_ % 2 ? $_ + 1 : () } @biglist }, } ); cmpthese(100, { 'huge grep' =&gt; sub { map { $_ + 1 } grep { $_ % 2 } @hugelist }, 'huge map' =&gt; sub { map { $_ % 2 ? $_ + 1 : () } @hugelist } } ); small grep 5479/s -- -4% small map 5724/s 4% -- big grep 54.0/s -- -3% big map 56.0/s 4% -- huge grep 5.26/s -- -5% huge map 5.53/s 5% -- I had thought that maybe the larger lists would show a bigger performance difference, but that appears to not be the case. Maybe my benchmark is wrong?
Please see my (and rootmarshfield's) benchmarks. The result is not as you expected.
Thanks for doing this benchmark. I don't agree with your interpretation of the results, but at least the facts are settled.
Perl will never die, it just fade's away. For a interested Kid, searching for a Script, today, on a growing Amount of Sites, showing such stuff, the Name 'Perl' is not even mentioned anymore. Other Sites link to dead Urls, broken Links, etc., what's left, is mostly Stuff out of the late 90's. Still, the Kid does not give up, because it found something, like's it,and want to play with. But he found a problem. Next step, a Perl User Forum. The Kid decides to ask for Assistance at the Forum. Typical replies: Poorly written Software, start from scratch... Rewrite the Hash... better use the CGI Module to handle those routines, it has been built to do such things... and just before giving up, one fellow replies with a simple line, containing exactly that, what the Kid was looking for, the whole time. Before Facebok &amp; Co., we had Me-type Userpages as one of many Subs in our Scripts. Nobody ever dreamed, making real money with an extended MePage Site. Everybody wanted an Auction, like that fast rising eBay. Money was the Word to follow... So, as a result, no more Scripts. And, as long as everybody fears, other suddenly could make millions or billions, using someone else's knowledge for their own advantage, nothing will happen, regardless of what version of Perl will be available. I try, with very limited Perl Knowledge, to use my rather impressive Perl Archive to somehow keep the old Community Idea alive. At least, when it comes to the Perl Software I am playing with since 1999. I wrote 10thousands of lines and created several platforms. The only reason I never went public with them, was, I could not guarantee 100% Functionability, beeing a copy-paste-edit Perler, not a Perl CODER. As soon as real Coders come back into the Community GPL Scene as Suppliers of Source and Knowledge, not just as Ciritics, I expect Perl to be able to make it back to the Scene. If not, it can soon be history. At least for Site Designers. Sorry, hasch words from an old (66) Man, but, unfortunately, 15 years of Forum-experiences. But I figured, it would match well here... Good luck to all Ernie 
If you're that concerned about performance, why are you using a scripting language at all? Just think of all that extra work your server's doing dispatching opcodes, maintaining runtime symbol tables and counting references.
Well because scripting languages are great for websites. They have a lot of functions tailored to text processing/manipulation which is all a website typically is. Additionally, it allows for easy modifications without having to re-build. It's not that I'm so concerned about performance, but there is no reason to go ahead and deliberately put slow, memory inefficient code into a routine because you like it better.
http://blogs.perl.org/users/neilb/2012/12/modules-that-are-candidates-for-helping-out.html
Ah cool thanks! I worry my skill level is far too low to contribute though? Nor would I know where to begin on fixing the bugs, but I shall have a look none the less :)
You missed my point. I was not worried about speed. 
When you have a single presentation to judge a man, that's what you get. I am sure (hopeful) not of it applies.
I submitted to soon, you may want to read my full comment.
The problem is that you are always cutting the size of the original list in half, so map has less to work on than grep. You can see a more drastic performance hit if you make the grep return more items: #!/usr/bin/perl use strict; use warnings; use Benchmark qw/cmpthese/; my @a = (1 .. 10); #can't just use a constant because #constant folding will speed the map section up #but won't speed the grep up at all my $t = 1; my %subs = ( both =&gt; sub { return scalar map { $_ * 2 } grep { $t } @a; }, map_only =&gt; sub { return scalar map { $t ? $_ * 2 : () } @a; }, ); for my $sub (keys %subs) { print "$sub: ", $subs{$sub}(), "\n"; } for my $n (10, 100, 1_000, 10_000) { print "\n$n items\n"; @a = (1 .. $n); cmpthese -1, \%subs; } output: map_only: 10 both: 10 10 items Rate both map_only both 147540/s -- -27% map_only 202868/s 38% -- 100 items Rate both map_only both 16999/s -- -30% map_only 24325/s 43% -- 1000 items Rate both map_only both 1745/s -- -29% map_only 2462/s 41% -- 10000 items Rate both map_only both 171/s -- -30% map_only 243/s 42% -- 
I learned it from [watching you](http://www.reddit.com/r/perl/comments/12cfpp/which_is_more_idiomatic_correct/) cowens. I've gotten a bit of mileage on that technique since you demonstrated it. Strange that my mapgrep was faster than your mapmap (care to tackle that one? - my guess is the inefficiency of the addition operation with the unnecessary undef values), but I agree on the mapgrep for clarity. Cheers.
 use strict; use Benchmark qw/cmpthese/; sub iseven { return $_[0] % 2 == 0; } sub addone { return $_[0] + 1; } sub mapgrep { my $i = shift || 100; my $sum = 0; $sum += $_ for map { addone($_) } grep { iseven($_) } ( 0..$i); return $sum; } sub mapmap { my $i = shift || 10000; my $sum = 0; $sum += $_ for map { iseven($_) ? addone($_) : () } ( 0..$i); return $sum; } my $range = 1000; my %subs = ( mapgrep =&gt; sub { mapgrep($range) }, mapmap =&gt; sub { mapmap($range) }, ); #make sure they return the same thing for my $sub (keys %subs) { print "$sub: ", $subs{$sub}(), "\n"; } cmpthese -1, \%subs; $ perl mapgrep.pl mapgrep: 251001 mapmap: 251001 Rate mapgrep mapmap mapgrep 1068/s -- -0% mapmap 1068/s 0% -- 
It seems to be coming from the overhead of calling the functions. Inlining addone and iseven puts mapmap back in the lead: Rate mapgrep mapmap mapgrep 954/s -- -3% mapmap 979/s 3% -- But not by much. Removing the other functions (using only anonymous functions like my version of the benchmark in another comment) brings the difference to 7%. It is odd that the there is such a difference though. They are both calling the same functions.
I have what might be a great project for you. According to a recent report, Freenode now appears to be the world's largest IRC network. Moritz's logging software [ilbot](https://github.com/moritz/ilbot), written in Perl 5, generates [nice web logs for many channels](http://irclog.perlgeek.de/). Daily logs look like this: http://irclog.perlgeek.de/perl6/2013-01-18 Last summer he added an "Enable summary mode" link to this daily view (immediately below the line "All times shown according to UTC."). I have been scanning #perl6 logs since Sept 1 last year to select a subset of lines that then appears at the "summary" link on the daily view (to the left of Camelia, the butterfly, or immediately above the line "All times shown according to UTC."). This works as far as it goes. But a few tiny tweaks (probably one line changes) would make things noticeably nicer. And some bigger tweaks (probably still just a few dozen lines) would make a big difference. Moritz has encouraged me to try to make those changes but I'm really a marketing guy, not a coder and I haven't touched Perl 5 since the 90s. Interested?
I'm interested, but I'm not too sure I follow what you want exactly. However it is 2AM so I going to sleep and hopefully will read your reply in the morning :)
Weird that this is five months old, but has only just turned up in /new If you want to do logging/try and fix the undefs somehow: my $joined; my $separator = '|'; foreach my $item (@f){ if( defined $item ){ $joined .= $item . $separator; } else{ # write to log file, fix the undefs or whatever } } or if the logging/ability to do something when you hit an undef isn't important the below will filter out the undefs and join the array: my $joined = join($separator,grep{defined}@f);
It's 5am so I'm going to go to sleep soon too. :) In the meantime, here's a starting point: http://irclog.perlgeek.de/perl6/2012-12-20#i_6259785 If you scroll to the top of the log page you'll see the line of links ← Previous day | Channels | #perl6 index | Today | Search | Google Search | Plain-Text | plain, newest first | summary. Note that last link "summary". If you click on it you get a summary (subset) of the day's log and the "summary" link changes to "full mode". If you click the "full mode" link it displays the full log and the link changes back to "summary". If you combine doing that with changing days you'll see what timotimo was talking about. It's probably just a few lines of code to change that, and this change has been requested by several #perl6 folk, so it seems like an excellent way to contribute to the many projects logged by ilbot, including, and especially, Perl 6. And then I have other ideas. I think it should be possible to make a small change, perhaps a few dozen new lines of Perl 5 code and a small mod to the MySQL database, that would hugely enhance summarizing by moving it closer to the manual #perl6 summaries I did before Mortiz added his summary feature. For example, take a look at: http://blogs.perl.org/users/perl_6_reports/2012/09/perl6-summaries-for-2012-09-02.html Make sure to scroll down the page to see the pretty parts. :) Now imagine that small tweaks to ilbot could close the gap between how the summary feature looks and works now and how that manual blog entry looks and worked then (many hours of cut and paste!).
I'm sorry I don't really understand :/ I think it is a bit out of my scope
Writing log parsers is good practice, pick a log you're interested in and write a script that generates a nice report
No problem. I'm sure you'll find something in the Perl world that's fun to hack on. Fwiw I think my explanation is the problem rather than the task itself. I'm curious to know if you became confused before you clicked the links I provided or after? It would help me if I knew how to simplify or improve my explanation. **Is anyone else interested?** Now I've put it out there, I'm hoping someone understands what I was suggesting and is interested in having a go. I would recommend starting by joining the #perl6 IRC channel on freenode and mentioning the comment made by timotimo and asking for help from Moritz (who wrote and maintains the Perl 5 ilbot code, is knowledgeable and friendly, and spends a lot of time on #perl6). Or reddit pm me. Here's hoping!
[Project Euler](http://projecteuler.net/)
Interested to be part of a LGPL Community/eCommerce Project? I have all it takes, even a platform under development, all based on good old Perl, HTML, CSS &amp; some JS Code. I am finally retired, so, the time has come to make use of 15 Years of archiving specific knowledge in all forms, writing and testing Perl Scripts and Platforms, and this all around my favoured, quite legendary little EveryAuction 1.53 Perl Source. I hear you, but don't laugh now, but it's not longer just a simple programmed EA1.53 Hobby-Script, trying to show off! The EveryAuction 2.53 Platform fully incorporates brandnew 'Flatfile' MAD-DB Indexing, custom-designed by Mike Ward (ex EA Madclicker), http://www.webzstar.com , one of the first and best DB/SQL Coders around the once so popular EveryAuctionDB Forum Scene. EveryAuction 2.53 shall ALSO serve as 'Perl Learning-Software', built by me, someone widely unaware of english 'Script terms pronouncing'. But I am Copy/Past/Edit/Adapt-Pro and I have everything 'in Stock' in 'some' adaptable form, so, I managed to find Ansnwers to most Perl-related Questions after the unfortunate closure of the EA User Forum in 1977. The different Scripts are therefore written in a Style to enable Newbie's to easy understand, how the Software functions. They so should be able soon to modify parts of HTML Sections without a risk of killing the Script, all important Sections, Tables, Functions or so, will be 'titled' to assure easy orientation (and assistance). I will do it as I would have liked to get it, 15 years ago. At least, my first EA 1.1 Version had already translated Content into german..., my School Language, I'm a Swiss, english is strictly picked up, not learned in School. You may excuse 'now' some of the kind of writing. BUT why Flatfile DB's?? Do you ever read Security News? Flatfile-DB's, placed in a secure cgi-bin section, are usually not in the News. Besides, Testers like me need to fast access such files by ftp, because, once in a while, one screws up and possibly so damages a file. Last, but not least, to keep a 'certain' compatibility to hundreds of existing EveryAuction Add-On's. This is my Project-Site: http://www.everyauction.info/cgi-bin/253/index.pl The EA 2.53 Platform will not be enhanced further, I would like to motivate Users to 'bring in' their own Ideas, their own 'Design', their own 'Corporate Idendity', or even their own 'Mod's. I have tons of possibly 'partly matching' subscript or add-on links ready for anyone, looking for part-solutions to start something own. So, everybody is invited to participate, as engaged Perl- HTML- CSS- or JS-Coder, and so finally create the utmost perfect matching Application to serve the foreseeable coming 'Local/Regional' Web Community Trend. You know, hopefully know, what I'm writing about. I have no Forum yet, I may find someone, operating one for the Project, or then, I have to use something like this: http://www.jti.li/cgi-bin/webapp2/index.cgi http://www.jti.li/cgi-bin/jti_0/YaBB.pl Interested? Then, tell me please, how you would like to be part of this. Don't just ask for the Softwarelink, to try it out..., I am to old for this kind of Crab, the Software can be tested online. But if you 'know', what your'e talking about, when it comes Scripting (of any kind). You should also be willing to donate, at least Parts of, your own EA 2.53 Project-Ideas, AddOn's or Mod's as free GPL Contributions. And if you are a real Guru, You could refresh your PP Account , when demand for enhanced membership applications, payment systems, additional Main Sections such as Job-Ad's, Personals, Chats, Facebook-Youtube-Twitter-etc-Linking, Uploads/Downloads, eventually starts to rise. It all exists, I 've got, in some form, you could use an old version to see, how they did it. Enough talk, let's see action. I go back to my index.pl. 16'618 Lines long, 833KBytes heavy, still all-in-one, exept for the Image Uploaders. Will not be split before all Mayor Work has been done. CSS is waiting to be cleaned, JS is waiting to be checked, HTML is waiting to be repeatetly 'equalized', and now, I go to bed. Good Night from the snowy home of the UNITED BANDITS of SWITZERLAND and me Ernie not affiliated, controlled or connected in any form
I haven't migrated away from Perl, I've migrated away from participating in the Perl "community". In the past I published popular modules on the CPAN, tried to be helpful on p5p (including submitting patches that landed), and submitted many bugfixes to various module maintainers. But people started yelling, and the echo chamber got too loud for me, so I left.
[ I don't know the actual arguments being made by brian d foy or anyone else, so this may be completely off base. ] One of the issues with tying packages to the filesystem is that if you are the author of `Some::Cool::System` you might eventually grow to have `Some::Cool::System::ThirdPartyPlugin::Foo` or `Some::Cool::System::Contrib::Bar` or whatnot. And now you have files that are "owned" by other projects inside your directory. When upgrading to a new version of `Some::Cool::System` you can't just nuke the tree and unpack a fresh one, for example. You have to carefully maintain a manifest of all the files that you own, and you have to carefully delete only those files when upgrading, and carefully deal with what happens when files are added or removed from that list between versions, and carefully add logic to remove directories only if they are empty, and so on. It would also be nice from a disk IO standpoint to be able to implement things like binary eggs (or now "wheel" files) from the Python world, where you can stick a bunch of files in a single zip file and import from them as if they were separate files. That might save you some startup time if there's dozens of files that need to be read and parsed. 
Isn't that first point negated by the fact you can have multiple directories in your lib search path?
I suppose anything is possible if you add callback hooks. Doing that in a way that's transparent and backwards compatible would probably be a lot of work though, and you'd probably run into modules here and there that rely on the module name &lt;-&gt; path name correspondence. 
Ok, point taken. =)
That's true; I suppose I should have been a little clearer. You're unable to do it without violating the file &lt;-&gt; package relationship convention, is what I should have said!
There must be more to his argument (I haven't read it and don't see a link) because there is nothing tying package names to the filesystem use/require translate :: and ' to the path separator and compile that file. The convention is to do 1 package per file with matching namespace but it work fine if you don't, ie: zeek@dash /tmp $ cat test.pl #!/usr/bin/perl -w use strict; use warnings; I::ain't::in::a::separate::file::itworks(); exit; package I::ain't::in::a::separate::file; sub itworks { print "F yah\n"; } And the execution: zeek@dash /tmp $ perl test.pl F yah tldr; package names and filesystem paths is convention, not a requirement. 
Currently, I am trying Ruby. There are things I like: * like Perl and unlike Python, it has `unless`/`until` and multiline anonymous blocks and allows `if`/`unless`/*etc.* at the end of a statement * there are numerous and easy to install packages (still like Perl) * [Pry](http://pryrepl.org/) is a *great* REPL and other things that I don’t: * the declaration syntax (*i.e.* none, I miss `my`) * resource management (conservative GC + the fact that file handles are not automatically closed even when the garbage collector kicks in (you can use the version of `open` that takes a block but writing similar constructs for other resources forces you to be careful about exception safety, unlike in C++ for example)) * strings that are incompatible with those of different encoding instead of just being either “text” or “binary data” (like they are in Perl and Python)
You have a point that it's not a requirement, but it is a convention that is followed very closely.
&gt; So you're saying the community is shitty? I didn't say that. &gt; Can you explain why you got angry at the community and left? I didn't say that, either. I didn't say either of those things. I said "people started yelling, and the echo chamber got too loud for me". 
That's not necessarily true. As soon as you put your new namespaces into their own .pm file and try to `use` them, you start looking at `@INC` and such, and the filesystem tie comes back into play. So you _could_ get around this, as you demonstrate, by placing all of your required code and supporting libraries into a single file and `require`-ing it by filename, but that just seems like a really bad idea on several levels. ;) 
I just came off of a year long project that used Ruby. One of the things that bugged me about Ruby was that their "requires" were file name based instead of package name based. Ruby gem (gems are the Ruby equivalent of CPAN modules) creators generally name their files based on the namespace (downcased and camel-case converted): require 'rspec/core/rake_task' gets you the class RSpec::Core::RakeTask The problem is, since this is only convention, the convention can be broken. And it is. A lot. The most glaring example is in the standard Ruby class "OpenStruct". You'd guess you'd require 'open_struct' to get it, right? Nope! You have to require 'ostruct'. This is confusing, and, I might add, not documented very well. This ends up forcing you to pour over each gem's documentation hoping that they'll include an example (this is, believe it or not, *very* rare in Ruby-land, unlike Perl-land), and then start poking around their source code to figure out what exactly you have to require. Interestingly, despite having the ability to manage things based on a well thought out directory structure, the Ruby community has embraced "bundler". Bundler puts each Gem in its own isolated directory so that you can manage gems without worrying about whether they follow any conventions or not. There's a CPAN module called [Carton](http://search.cpan.org/perldoc?carton) that does the same thing but I've not seen any Perl projects that use it. I may start using it in my own Perl stuff because my experience with Bundler in Ruby was huge improvement over how I normally manage my Perl CPAN stuff (with half-baked home-grown scripts and lots of environment variable magic).
I'm curious about a couple things: * Your attitude toward Audrey Tang's 2005-2007 era -Ofun ("optimize for fun") project participation philosophy and/or it's 2013 descendant [Ofun](http://Ofun.pm). * Perl 6. (I've been following the freenode IRC channel #perl 6 daily for 18 months and yelling just doesn't happen.)
I see Ofun starting to happen this year. (Ofun is "Optimizing Perl for fun". Like -Ofun, but applied to the whole Perl toolchain, and possibly beyond.) Can you see this being relevant to you? Can you see yourself participating in the Perl 6 community, beyond lurking, this year? jnthn is another gem (he's brilliant, breezy, and the center of an emerging whirlwind of others' productivity) and Rakudo is now sufficiently robust that a fresh newbie generation are starting to have fun. For example, "timotimo", who reckons he's been "active" in Perl 6 for two months, is clearly having fun, landing a great feature, getting very excited about it, and generating a lot of happy vibes all round. But is it enough to interest you? (One last thing. I realize what you meant by Audrey leaving, but for others that might read this, please note that Audrey never actually left Pugs. She has not been updating Pugs features, and nor has anyone else, so Pugs is only passing around 40% of the spectest suite, but she and Coke have been keeping it building and running the test suite all along; she last fixed a build issue a few weeks ago.) Edit: corrected comment about timotimo's activity.
Well, at the dumbest level, in windows it'll be Foo\Bar\Baz?
"echo chamber, too loud" .. don't know what you mean by that, sorry
The biggest issue in comparing Java packaging to Perl packaging has nothing to do with how Perl maps package names to file system names. It's the fact that many Perl modules are backed by compiled C (or other language) libraries that are not platform independent. Something like App::FatPacker can take a pure Perl program and package it into a single "archive" (I use the term loosely) that only requires to you copy it and run "perl script.pl". The issue is that packaging like this doesn't work when there's platform specific code libraries that are required. In the Java world, everything is platform independent byte code, so it's much easier to package and distribute a JAR. But it also means Java code isn't known for it's execution speed. ;-) In response to some of your more specific complaints... &gt; * Perl (on *nix and Mac OS X) modules are installed in a fixed path. Java packages can be kept anywhere. I think you're mixing two issues - program installation and module (aka library) installation. You can install a Perl application anywhere you please and run it. You can install a Java JAR application anywhere you please and run it. If the application demands external library modules, both Java and Perl will default to looking in the current directory and the system library directories. If you're installing external library modules in non-system paths for either language, you need to let the interpreter know. In Perl, you can use -I or PERL5LIB env. In Java, you can use -classpath or CLASSPATH env. &gt; * By default, you need root access to install/modify Perl modules. You can dick around changing permissions (if you have root access) or use PERL5LIB to work around it, but that's it's own hassle (making sure that the env variable is set when running cronjobs and such). See above, this applies to both Perl and Java equally. &gt; * It's hard to distribute a Perl app. You can't hand someone a file and tell them "just run it". In a best case scenario, you need internet access and run a few commands &gt;tar -xzf myperlapp.tgz &gt;cd myperlapp &gt;sudo ./install-myperlapp.sh I think there are two reasons this feels true, but is really a cultural problem masquerading as a technical issue. 1. Major Java applications tend to come with all requisite libraries and sometimes even a JRE bundled in an installer. Perl applications tend to be bundled for distribution via CPAN, which implicitly assumes you are operating in an open source and internet connected system. There's no reason you couldn't package a Perl application the way most Java applications are packaged, it's just not a common thing to do in the Perl culture. 2. See above for the issue regarding platform independent libraries. "Binary" distribution of a Java application is easier because of the choice Java made to implement as a platform independent bytecode interpreter with poor/non-existent support for external compiled libraries. Perl made the opposite choice for performance reasons, with the resultant tradeoff being you can't really produce binaries for distribution. A footnote on point 1 is that this Java application distribution convention, while easier from a development and delivery view point, is much MUCH harder to manage from a system integration &amp; security view point. For example, if you're using VERITAS NetBackup and HP ArcSight ESM on the same system, they both install a bundled JRE specific to their installation (with associated classpaths, etc.). And if the underlying platform has Java installed (i.e. for browser plugin support) there are potentially three completely independent JRE installations on one system. If a security patch is released for Java, this becomes much more difficult to deploy, particularly since vendors packaging JRE typically do not want you to independently update their embedded JRE, or they threaten to void your support status. &gt; * It's a pain dealing with apps which need different versions of foo.pm installed. As Perl has ONE TRUE LIBRARY PATH, you can't have multiple versions of foo.pm installed unless you are using PERL5LIB to point to a different location with the hassles involved. With java, you can package each app with the version of foo.jar the app wants. Again, you can do this with Perl as well, using -I or PERL5LIB. When you say you can package foo.jar with each Java app, that's what you're doing in Java - ensuring the CLASSPATH for each app points at the version it needs. Also, it feels like you're implicitly assuming that in Perl Foo.pm would be installed as a system module, but in Java Foo.jar would not be in the system CLASSPATH? So it doesn't feel like you're really arguing about an apples-to-apples situation here. Virtually any major Java application I can think of comes with a BAT or .sh file that manages all the CLASSPATH arguments for the user. If you do a ps -ef | grep java and look at what's running, the actual java interpreter command line is commonly hundreds of characters long. Culturally, I think Java's adoption for enterprise development has meant that they are better at hiding this type of complexity from end users. But that doesn't mean it doesn't exist, and that they don't pay the price for the trade offs implicit in their decisions. If the Perl community adopted more of the techniques and crafts used by the Java community, they could produce similar results. But fundamentally, I think the Perl community is just not interested in doing so. The legacy of technical decisions at the core of Perl is that it will always be more of a "hacker"-ish language than Java. The incredible breadth of external libraries and applications that have been wrapped in Perl and made available to coders via a Perl API that directly maps back to a non-Perl block of code is a huge hindrance to package deployment. Also, the Perl community's adoption of CPAN and the philosophy behind it means that while you COULD package everything your application needs, people would look askew at you for doing so. If you're willing to abandon these cultural and technical touchstones though, you could write a pure Perl application using only pure Perl libraries/modules and bundle it for distribution just like Java developers do. **TL;DR - Perl and Java are actually very similar from a technical viewpoint of package management; it's Perl's embrace of external libraries, Java's embrace of enterprise development methods, and the related cultural idioms of the two languages that make them seem so different.**
Possible source [link](http://blogs.perl.org/users/brian_d_foy/2012/02/what-if-we-could-drop-archives-into-inc.html) 
Seems to work without looking at @INC or worrying about the filesystem: zeek@dash $ cat test2.pl #!/usr/bin/perl -w use strict; use warnings; use Hippie; Whoa::There(); exit; zeek@dash $ cat Hippie.pm package Whoa; sub There { print "Hello there\n"; } 1; zeek@dash $ perl test2.pl Hello there 
You should start leading other languages until you feel comfortable with them to make an educated decision. Also doing so will improve your Perl even further, too.
Looking a person up on CPAN isn't all that hard. :) https://metacpan.org/author/STEVAN
Oh, I got comfortable in other languages as in could code in them; I just never really enjoyed it like I do with Perl. 
Fair comment. I've been expressing an opinion, not (due to time constraints) defending it. The Python code I've seen, from various sources which are considered good programmers by others, has suffered from the cut-and-paste school of coding. Yes, that's bad programming, but my experience—again, multiple unrelated projects and programmers—has been that this style is more common in Python than in other languages I've maintained. And when I've tried to refactor I've found it inordinately difficult to clean up; but this may just reflect my own inexperience with Python best practices.
that’s not at all my experience. i’m bioinformaticist, and have to deal with really bad cut&amp;paste code in java and perl, but much more seldomly so in python. i think that’s because people here have to learn perl and java, but everyone knowing python has chosen to learn it. soo… unless you have at least a theory about how python specifically encourages cut&amp;paste, i’ll say that you have no reason to blame python instead of your predecessors.
seems to have moved: https://github.com/MoeOrganization/moe
Does this work? open IN, "infile.txt"; while(&lt;IN&gt;) { chomp; my @cells = split(/\t/); print join(', ', @cells); }
I think you're being too terse about the problem and the solutions you've tried. Pastebin some example input, and the source of your script so people can have a go at what you're trying to do. I agree with TrollJoel that you probably should be using a library unless this is a one-time thing, but I prefer to not dismiss the problem just because you're going down the wrong path. You might start by not slurping the contents, instead going over them line by line: while(&lt;&gt;) { my @rows = split(/\t\); } 
As long as each thread initiates it's own handle there should be no problem.
The raw file you posted has new lines. $ wget -O foo.txt http://pastebin.com/raw.php?i=K31euJLq $ wc -l foo.txt 179 $ hexdump -C foo.txt # shows 0d 0a newlines in the data aka \r\n With your data on pastebin, your script works (well the sub where you don't alter $/ works, If you change $/=undef; to $/="\r\n"; then the first sub works too). It looks like the data you generated for pastebin differs from your other data, which you've stated has no newlines. Since the lines are of variable width the only way you could strip out rows would be to split on tabs, then splice out rows with a fixed number of columns. Furthermore.. you mentioned that "it is jumbling up the headers and data!!" so you may want to check that the number of columns is always the same. $ awk -F "\t" '{print NF}' foo.txt | sort | uniq -c | sort -n 180 20 Which says there are 180 lines with 20 columns.
It's a tab delimited file. Assuming it's following common TSV standards (which Excel does), there will not be any tabs or newlines within the data fields. I'd be interested to know if a library even exists to fix the problem of extra tabs without having field start/end delimiters as well. 
&gt; It's a tab delimited file. Assuming it's following common TSV standards (which Excel does), there will not be any tabs or newlines within the data fields. I just opened exel and stuck some tabs and newlines in the data and saved it as tab separated and there are tabs and newlines in the data so I'm not sure what you're saying here. &gt; I'd be interested to know if a library even exists to fix the problem of extra tabs without having field start/end delimiters as well. It would be impossible to use the delimiters in the data without field delimiters so I'm also not sure why you're calling this a problem. Its just how it is. 
Seconding creating a handler for each thread. Also, check out [Parallel::ForkManager](http://search.cpan.org/~szabgab/Parallel-ForkManager-1.02/lib/Parallel/ForkManager.pm) as an alternative to the default threads functionality. It's not built in, but has been way more efficient in my experience.
&gt;The biggest issue in comparing Java packaging to Perl packaging has &gt;nothing to do with how Perl maps package names to file system &gt;names. It's the fact that many Perl modules are backed by compiled C &gt;(or other language) libraries that are not platform independent. &gt;Something like App::FatPacker can take a pure Perl program and &gt;package it into a single "archive" (I use the term loosely) that only &gt;requires to you copy it and run "perl script.pl". The issue is that &gt;packaging like this doesn't work when there's platform specific code &gt;libraries that are required. &gt;In the Java world, everything is platform independent byte code, so it's &gt;much easier to package and distribute a JAR. But it also means Java &gt;code isn't known for it's execution speed. ;-) Not quite true, Java apps -- and even the JVM -- can have native components that are compiled from C/C++/etc. The API is called [Java Native Interface aka JNI](http://en.wikipedia.org/wiki/Java_Native_Interface). In any case, the JNI components are still bundled into a jar file. Java being slow might have been true back in the JVM 1.2 to 1.3 days (8 to 10 years ago), but now a days Java can be very fast (some cases faster than C) for long running code * Blogger's comparison of fractal generation code in C vs Java: http://paulbuchheit.blogspot.com/2007/06/java-is-faster-than-c.html * Wikipedia article describing some of the techniques used by the JVM to speed up Java execution: http://en.wikipedia.org/wiki/Java_performance But it still comes down to the quality of the code. I've seen good, reliable Perl code replaced by shitty Java code and it caused serious drops in reliability and performance.
Haha, I mentioned making people's work more fun for them in an academic/corporate change agent job interview thing last week. I got really weird looks from the panel like they didn't know what I meant by fun. 
It took me a long time to understand perl's data structures. Perl Best Practices and Moose fixed it for me, so I'm pretty much happy with them these days. I can see how the ({[ soup drives people mad though.
The top 2 tickets are spam, the others are either deadly uninteresting (write a test... WTF?) or writing documentation. Meh. 
I'd love to help out on one of these. Should I just comment on one of the tickets to ask for direction or should I email p5p?
&gt; the others are either deadly uninteresting (write a test... WTF?) Surely you don't think that all contributions to open source projects must somehow be glamorous. It's all important.
&gt;Please elaborate. I can't see any spam tickets there. They must have been deleted. One was posted by someone from India and was spam for SEO. I don't remember what the other one was. There's a new one, in Russian, and I'm pretty sure it's spam too. (Google Translate translates the title as "Request for interview") &gt;given your comment about the test, i question whether you should be writing Perl at all. I resent your remark. And, come on: "write test to ensure perlhist has size for blead-final release"?? That must be the most boring task they could possibly ask anyone to do. It looks to me like the other requests to write documentation are gone, too.
&gt; ... i question whether you should be writing Perl at all. That seems uncalled for.
you could always use waitpid($pid, 0) with alarm to track the timeout, if the OS supports POSIX signals: if ($pid &gt; 0){ eval{ local $SIG{ALRM} = sub { kill_everyone($pid) }; alarm 300; waitpid($pid, 0); alarm 0; }; } 
&gt;They must have been deleted. One was posted by someone from India and was spam for SEO. I don't remember what the other one was. &gt;There's a new one, in Russian, and I'm pretty sure it's spam too. (Google Translate translates the title as "Request for interview") Are we looking at the [same thing](https://dl.dropbox.com/u/10190786/ticket.png)? &gt; It looks to me like the other requests to write documentation are gone, too. I see no russian tickets linked to [this ticket](https://rt.perl.org:443/rt3/Public/Bug/Display.html?id=116469) and it has a history which shows that seven tickets were linked to it and no links removed. &gt; I resent your remark. Maybe i misinterpreted your remark: &gt; &gt; (write a test... WTF?) It seems to express to me an extreme incredulity at the concept that someone would expect someone else to write a test. Am i wrong? &gt; "write test to ensure perlhist has size for blead-final release"?? That must be the most boring task they could possibly ask anyone to do. For an absolute newbie it can be a nice introduction to perl, while getting to play with the big boys. By labeling this as "deadly" uninteresting you are being quite self-centered and are unnecessarily pushing others away from this.
Commenting on there will in fact email p5p, so you might want to just do that. :)
Does the system's waitpid(2) syscall actually support the flags? Try it in C.
Any particular reason why you're using 5.10.0?
Don't get me started, we're still on 5.8.8 because - fuck me. :(
Perl &amp; threads: here be dragons.
Red Hat?
&gt; Can you see yourself participating in the Perl 6 community, beyond lurking, this year? I could see that. And thanks for the clarification regarding Audrey/Pugs.
I once fixed some Perl test file (no code, just broken link in reference to outside documentation) and got the credits in AUTHORS file so this kind of experience is pretty rewarding and encouraging.
As the author of File::Next, I'm extremely pleased to see that its speed is identical to File::Find. I spent quite a few hours profiling it with [Devel::NYTProf](http://search.cpan.org/dist/Devel-NYTProf/), which let me identify all the slow spots in the code. Without NYTProf I'd have been lost.
Basically, We're on CentOS. Doesn't mean our sys admin couldn't upgrade them servers a bit. Believe it or not he used to downgrade back to apache 1.3 because of old legacy httpd.conf stuff he didn't want to have to migrate. 
Try $customer{$acctno}-&gt;{"address"} Excuse the brevity, on iPad
Dump the structure so you can visualise it. use Data::Dumper; ... print Dumper(\%customer); tbh it looks like $customer{$acctno}{address} is returning another hash reference, is address a hash structure such as {'address' =&gt; { 'street' =&gt; "195 streetname", 'postcode' =&gt; "NG7 2GJ" } }
Expanding on this answer... The reason for `-&gt;{address}` is because a hash element must be a scalar. A hash is not a scalar, so you have to use a hashref. That hashref, when stringified gives you your `HASH(0x9999999)`. So you make a direct hash lookup with `$customer{$acctno}` and then a hash dereference with the `-&gt;{address}`.
I had tried that. Same result. I believe i also tried $customer-&gt;{$acctno}-&gt;{customer} but perl then complained about $customer not being a declared variable. Stopped seeing it as a hash. Thanks tho!
The information from Data::Dumper looks good to me. $VAR1 = { 'G0002878' =&gt; { 'address' =&gt; { '875615' =&gt; '875615' The number under the address field are id numbers for the address that I have to look up somewhere else. I stored it as the key and value until I can get the actual address. Maybe there's a better way to do that. 
I'm using ActiveState Perl on Win 7. Don't know if that makes any difference. That being said, your code looks pretty much just like mine. I used the unquoted string literal as I am trying to store multiple pieces of data in the hash under the account number, like contact information and other customer data aside from the address. So it's like $customer{$acctno}{address} = value $customer{$acctno}{contact} = value $customer{$acctno}{quantity} = value Is there a better way? I'm definitely no pro at building a hash of hashes but I'm trying to learn. Thanks for the help.
I've often seen problems with hashrefs if they're in quotes. So assuming your actual code has a double-quote at the end of the print line, you could try: print "$acctno\t" . $customer{$acctno}{address}; 
Perl 5.14.2 for Xubuntu 12.04.1 here, but the operating system shouldn't affect how hashes work as far as I know. You can still quote the literal even when using multiple subkeys, so $customer{$acctno}{'address'} and $customer{$acctno}{'contact'} will both work. Again, Perl assumes the quotes inside curlies, so this is just me being overly paranoid.
Oooooh. The light goes on. I think. I need to to go one step further. foreach $acctno ( keys %customer) { foreach $addressid ( keys $customer{$acctno}{address} { print "$acctno\t$customer{$acctno}{address}{$addressid}; } } That works! Is there a better way? Thanks so much!
So is it better practice to quote the literal strings?
Well, I was just using it as a placeholder as I have to use the id to go and look up the address from another DB. I wasn't/am not sure how to better structure that.
So the %s in the printf statement is a reference to the key you define after the comma? I get that you are just literally saying use the first key, [0], for that hash. I'm storing the number twice as a sort of placeholder as I have to go and use the addressid to look up the actual address in another DB. I'm not sure how else to do that. When I grab the address, I will replace the second instance of that value at that point. Is there a better way to do that? Thanks!
Yes, it looks like for some bizzare reason you've got a hash reference stored in $customer{$acctno}{address} Is it perhaps the case that you're storing it incorrectly like: $customer{$acctno}{address} = {something, "some address"}; Instead of: $customer{$acctno}{address} = "actual address" It sounds kind of strange if it is set up that way, unless you're expecting more than one address for each customer.. In any case, you're storing a hash of addresses in $customer{$acctno}{address} not a literal address string, even if that's not what you intended. Perhaps when you're assigning it to the customer hash after looking it up, you can do: $customer{$acctno}{address} = $addresshash{$addressid}; instead?
I would probably store those IDs in an arrayref rather than a hash ref, but maybe you have a good reason for doing that.
I find it more confusing to quote the literal strings, but if it's clearer to you, it works the same way to Perl.
I hadn't meant to store them in a hash at all. There is only one address per customer. Its just that I have to procure the addressid's from one place and then use them to get the actual addresses from another place altogether. I just didn't get deep enough into my hash so I was getting the last hash reference instead of the hashed value.
Why not explicitly store the address_id - then use it later to add the address, e.g. $customer{'GOO2878'} = { address_id =&gt; 875615, contact =&gt; 'whatever', quantity =&gt; 1234, }; 
Well, when perl says it is a hash reference, you need to dereference it. So it says this is a hash reference: $customer{$acctno}{'address'} So dereference that: %{ $customer{$acctno}{'address'} } Perl says the above structure is a hash. That means it has keys and values. print keys %{ $customer{$acctno}{'address'} }; I bet at some point you've hosed your data structure up and don't realize it. print values %{ $customer{$acctno}{'address'} };
As you can see from mr_chromatic's comment, there are differing opinions. But that's Perl for you: TMTOWTDI.
Question; why Data::Dumper, rather than Data::Dumper:: Simple for this?
Cool! Thank you for the help.
I never knew you could do that. Has this always been the case? Why does that function if it's a reference and not just a hash?
Like lostjimmy said, it's a shorthand. `$whatever{bar}[123]{baz}` is equivalent to `$whatever{bar}-&gt;[123]-&gt;{baz}`. IIRC, there was a passage about it in Programming Perl 2nd ed., so it's been around a long time. You can't store "just a hash" in a hash or array. Their values must be scalars. To get multi-level data structures, you keep hashrefs as values. See more at `perldoc lol` and `perldoc dsc`.
I wish we had one, but all of this stuff falls on my shoulders at the company, for which, I work. I have a manager who's "retired" from coding and I'm a lowly *Junior* developer responsible for all of the things. :(
The reason it works is because it's unambiguous. The result of the hash lookup is always a scalar, so you can: 1) use it as the scalar; 2) look up an array index (if it's an arrayref); 3) look up a hash key (if it's a hashref); 4) use it as a sub (not sure if this works without the dereference, it's been a while). Clearly if you choose option 3 (as in your case), and since we know it's always a scalar, then the interpreter can implicitly dereference the hashref for you, with a run-time error if it's not actually a hashref.
See: https://github.com/moritz/ilbot/pull/7 Is this what you wanted?
Yeah, agreed on existence and safety. You'd want some checks around that. Oh, there's one more example in the cookbook: delay loading a bignum library until some condition (big numbers?).
I'm glad to see alternatives to Mech being presented.
I second that. I tried various modes with cperl-mode being the most usable if you really, really want to stick to emacs ;) What is http://www.emacswiki.org/emacs/CPerlMode missing to use it?
When you are in your perl program buffer, run `M-x cperl-db` which will prompt you to run the program (`perl program-name.pl`). Just hit `ENTER` and the program is run and the output will be shown in a buffer. When prompted, change the command-line to `perl -d program-name.pl` to run the program under Perl debugger. I use the version control (`vc` and `pcl-svn`) from emacs fairly often. There is a Google group for talking about [Perl + Emacs stuff](https://groups.google.com/forum/?fromgroups=#!forum/emacs-perl-intersection). It's pretty low traffic, though. [Search on Perl Monks](http://www.google.com/search?q=-Re+emacs++site%3Aperlmonks.org) for some useful articles/conversations. CPAN offers [PerlySense](https://metacpan.org/module/Devel::PerlySense), [Sepia](https://metacpan.org/module/Sepia) and [Emacs::PDE](https://metacpan.org/module/Emacs::PDE) for more extensive customization/integration of Perl and Emacs. (Disclaimer: I haven't used much of any of these myself).
I use M-x perl-db, wasn't aware of the cperl-db variant. Dunno if it's any different or better; the one I use gives you a half-window debugger and half-window code, with an arrow showing what line you're on. You can enter any Perl expression into the debugger, besides the regular debugger commands. @prakashk doesn't mention you can provide command-line arguments when you specify the program to run: perl -f program-name.pl arg1 arg2 arg3 Also, you can have several debuggers running at the same time. If you want to re-invoke something you had run earlier and then closed, use the up and down arrows to bring up previous command lines. I sometimes run a Perl debugger without any program in a Linux xterm, to test Perl expressions. I type perl -demo * -d invokes the debugger; * e specifies an immediate expression, rather than a program; * mo is meaningless junk and generates a warning message, but it makes it all memorable.
I must say that I love [`Web::Scraper`](http://search.cpan.org/~miyagawa/Web-Scraper/lib/Web/Scraper.pm)’s declarative approach to parsing Web pages.
What did the original comment say? It's been deleted. 
lib::abs does the work for me. Though I never had problems with FindBin, for some reason I believe lib::abs is safer. Just read the source of that library! 
I took [perltidy.el](http://www.emacswiki.org/emacs/perltidy.el) and bound `C-M-\` (normally `indent-region`) to `perltidy-region`. If you have a ~/.perltidyrc file that you are happy with, this will save you tons of time.
My one recommendation is to keep things simple and use tags for quick navigation. * Put a "tags:" target in your makefiles that runs etags on all your perl. * then **M-.** over a subroutine call will take you to that call. Okay, two would be use **M-x perldb** to step through in the debugger: source in one window and perl -d in the other. 
Yes, something like that.
http://emacswiki.org/emacs/perlcritic.el is useful
Another useful thing to do besides writing code is to help improve docs. If you use a module and find that something isn't documented well, write it up and submit a patch. Often people new to a module are in the best position to improve the docs, since they're the ones who struggle the most when the docs are missing something.
I think shlomif meant http://shlomif-tech.livejournal.com/65955.html (shlomif you linked this to http://www.reddit.com/r/perl/comments/16xmph/ask_perl_reddit_why_is_tying_packages_to_the/ !! :)
Good suggestion, I shall look into that! Thanks
HURRY!!!!!!!!! This FOSDEM is to be held in one week!
Hi prakashk, I don't know you, but you rock. :) I plan to follow up on this in the next week or so by installing the stuff to test it if Moritz doesn't get to it himself. This has totally made my day. Thanks!
cperl-mode should be the default. :(
Not sure I understand the question, but DBI is the usual interface for databases (including SQL types). http://dbi.perl.org/ http://search.cpan.org/~timb/DBI/DBI.pm 
Ok. I guess I thought you could write in SQL to draw the data that you needed from MySQL. Why is it exactly that you need Perl to do this instead? (I'm a little ignorant on this, the department I work in now has IT takes care of most of these large scale data issues for us, and I do the analysis..)
Things that Perl is frequently used for, that are made more useful when a database is used: * web applications * report generation * [ETL](http://en.wikipedia.org/wiki/Extract,_transform,_load) operations Perl is a glue language, so it's often used to convert data from one format to another, so that two disjoint applications can now talk to each other. One example might be sucking the data out of a database, reformatting it slightly, and outputting it as a .csv. Or an [.xls](https://metacpan.org/release/Excel-Writer-XLSX).
I mean no offense, but it seems you're right about being ignorant about this. Your question doesn't really make a lot of sense, so I think you need to back up and try to understand just what it is you want to ask better. You seem to have some misconceptions, but I don't understand them. Perl *does* use sql queries get data from a database. There is no "perl instead of sql query" which seems to be what you're getting at.
&gt; What I am wondering about is what purposes would you use Perl for to draw out data from a database that you could not simply write a query in SQL for? Normally you wouldn't. But Perl is a general purpose programming language, and SQL isn't. So you can do more interesting things with Perl in the mix, like interacting with other systems, read/write in various data formats, creating graphs, presenting data in web apps and such. Some of this overlaps with R, but that isn't a general purpose programming language either so far as I know. Since you know R, you probably know of CRAN. The Perl version of that is CPAN and it's one of the nicest features of the language. Other posts have linked to modules on search.cpan.org, which is one of the web front-ends.
&gt; What I am wondering about is what purposes would you use Perl for to draw out data from a database that you could not simply write a query in SQL for? There are tons of potential utilities that may be created for interacting with databases. Perl is often a good choice. It is a very powerful language. Complicated tasks can be implemented fairly quickly in Perl. There is a ton of support for interacting with other libraries, systems, and file formats. The usages aren't unique to Perl, though. It is just anything you may write a program to interact with a database for. Here are some examples: * Report generation. Scripts can easily be written to read from the database and generate output in whatever format is needed. From Perl you can easily create things like Excel files or charts. Perl is wonderful for producing data in different formats. You also asked why this would be better than simply writing an SQL query. While SQL is fairly flexible, writing complicated queries is a pain and difficult to maintain, and real report generation isn't really doable. A Perl report may make hundreds of queries, reorganize the information in memory, and then produce a report in a format that would have been extremely difficult, if not impossible from an SQL query. It can even use multiple data sources. I often write reports that read from excel files and one or more databases and from that generate reports. You may also do some statistical analysis of the data. You can do a lot more than is possible from just SQL queries. * Utilities. Command line tools can be created to check on the status of things in the database or change states. For example, in one system I maintain I have a perl script that lets me manage users and permissions from the command line. It connects into the database, shows me the status of whatever I need, and makes changes. Administrative tasks such as adding users or changing access are trivially easy and quick to perform with these types of tools. Utilities like this also work great when used within automation. * Automation: In some systems there are things in the database that need to be updated regularly. It could be for performance reasons that tables with logs are pruned, or maybe just something needs updating for some reason. Maybe email is generated for notification if a certain state occurs. Creating Perl scripts that run in cron (or equivalent) that regularly connect in and use the database to do tasks is very common. If you are doing data warehousing, Perl may also be used to help bring everything together. As for learning database programming with perl, as others have pointed out, [DBI](http://search.cpan.org/~timb/DBI-1.623/DBI.pm) is what you want. In Perl there are always a ton of ways to do anything, but if you are going to be working with databases you should know DBI, even if you switch to a different interface later. 
You do write SQL code inside your Perl code. The advantage of perl is the ease in manipulating large amounts of data with regular expressions.
Thanks for doing these!
If you are going to do a lot of stastical work, you might also want to check out PDL ... 
Anyone know if slides are available, I found the oo presentation hard to read. Thanks for posting these!
We're planning on getting as many of the recent presentations as we can up on our wiki soon. 
You need to feed parameters into Mysql, and format the output, for example converting it to CSV, XLS, XML, or plain HTML (a web page). For that you can use Perl. And you can use Perl to generate graphics from the data.
Perhaps working on ilbot looks more appropriate for you now that [prakashk has proposed a solution to the task I focused on below](https://github.com/moritz/ilbot/pull/7). The [proposed fix is two *if* statements in Perl, plus some changes to a template in some template language](https://github.com/prakashk/ilbot/commit/9f7b43e167e27168277da09bc91a9f1f8abcb46d). The next thing needed is to test his/her solution (and debug it if it doesn't work). I can help with that too.
you still write sql (unless you use DBIx::Class.) You use perl to parse the data into data structures for analysis and/or printing. You typically use and array of arrays (each row returned is an array) though there are other data structures DBI puts out. See http://dbi.perl.org/
This question is so bizarre it's hard to answer. &gt; what purposes would you use Perl for to draw out data from a database that you could not simply write a query in SQL for? There are almost no uses for SQL data that don't involve another language/output format. If your managing director wants to know how many widgets you sold in Albuquerque last year with subtotals for each month, what do you do? Run a command-line query then have him come to your desk and look at the screen? 
Can your database produce Excel sheets? Perl can, with Spreadsheet::WriteExcel. Can your database do HTTP requests, parse the resulting HTML, and use that to fill in some missing values in "grown" data? Perl can, with WWW::Mechanize. Can your database produce plots? Perl + GD::Graph (or any other number of modules, for that matter)... by now you've probably guessed the answer. Last week I wrote a script that generates a config file for each user, asking an LDAP server, a mysql database and a postgres database for data, and incorporating some local JSON files in the mix. You simply don't want (and probably cannot) do that with a database and its query language alone.
&gt;A default installation of Red Hat Enterprise Linux today incorporates Perl 5.10, which was released in 2007. As if that is Perl's fault. Three major releases have come out since then.
TFA says that bash is experience a spike in use; It would be interesting to see if this spills over into Perl 5. If you like developing shell scripts, then you'll reach the need for something better for larger scale development - but still tightly coupled with the *nix programming environment. Many go to Perl through this route. All of these people saying that Perl sucks or it's dead/dying are coming at it from the other end (rather non-*nix end). The wrong end.
Given how useless Google is for searching for Perl content, then no wonder it looks bad on TIOBE.
I just used google's "search tools" feature. Afaict the earliest "perl is dead" match where Perl is the computer language rather than a fella named Perl is this ["perl is dead" post from January 5th 2000](http://computer-programming-forum.com/53-perl/645c49f6986b8427.htm ) in which the poster says "Perl was never designed to be secure and is plagued with problems. Put your money in MSFT, Active X, and Active Server Pages." Paul Venezia mentions in his 2010 article that for much of his coding he had moved from Perl to PHP. I rest my case.
I think it is possible he means that it doesn't implement the full Perl 6 spec (which wasn't even complete the last time I paid attention to Perl 6).
What's the difference between "Perl" and "Modern Perl?"
&gt;"perl id dead" post from January 5th 2000 That seems to be a joke though.
Why won't Red Hat ship the latest version of Perl?
I'm having more and more trouble arguing against this claim. In fact, it's starting to feel like we perl developers are cancer patients saying "I don't have anything wrong with me!". Here's what I've seen in the last year alone that's made me *say* those 3 evil words: 1. Two of our vendors did 100% purges of their perl codebases to Java. One, a support vendor, has informed us of waning perl support. 2. One of our contract-developer firms informed us that they were no longer going to attempt to hire perl developers for us, due to the waning value of said developers and difficulty in hiring. The other has been redirecting your queries to "more appropriate languages" for the job. 3. I personally am a "best tool" developer that ended up using perl 99% of the time because it was the "best tool" for most jobs. In the last 6 months, a little research has ended me in Ruby, Python, or (gasp) Javascript on Node.js more than 50% of the time due to better library support. Yes. Better than CPAN. We're losing. We've *got* cancer, and denying it just means we can't work to fight it. I think we have to accept that Perl *is* dying or dead, and it's time to resuscitate if we want to be as relevant as we've historically been. I don't think Perl6 is resuscitation. It feels like it's just getting in the way of the more obvious idiosyncracies that are drawing people to the younger languages. Perl is slow. It seems to benchmark 10x slower than Javascript V8, 3-4x slower than python or ruby. What does it have above all those languages to justify that slowness? Perl libraries are a few diamonds in a giant cpan mudpile. Python, Ruby, and Javascript all have package managers full of fresher packages with more developers on them. How do we get cpan to be more updated and active? Truth is, I used perl because I could do more in less code, and know it works. I'm finding we're falling behind on that. I want desperately to see that change... But the first step is admitting there's a problem. Unless my experience is extremely atypical, there is *definitely* a mass-exodus going on from Perl. Our own ownership is officially blowing 1.5-2 million in rewriting our primary platform in J2EE and Ruby because of all these movements they're seeing from our vendors.
i learned perl early on, wrote quite a lot of it, but more recently, i've found employment in python and a lot more of my toy scripts outside of work tend to work in python. as for python vs perl - i don't mind explicit self. I kinda like it because self is now lexical - i always found sigils for dereferencing clumsy (I would get it wrong a lot). the everything is a reference and call by value style has been less frustrating to use. - I miss inline regexes and dynamic scoping. (and real lexical scoping), but not enough to give up python. - I found python behaved better on windows than perl did. i still write a lot of one line perl, but perl to me now is just a better awk, even with cpan. 
I cannot agree more with what you wrote. Finally I get confirmation on my thoughts. Thank you
Red Hat has a long release cycle. The current version came out in Nov 2010. Perl 5.12 was released in April of 2010 but Red Hat was already in Alpha phase so it was too late. Red Hat 7 will probably include Perl 5.14.
Perl 5 of course has a lot of good qualities that people still like, such as: * easy things are easy * practical and useful * lots of handy operators * numerous well-named functions * string interpolation * built-in regexes And that's not counting all the helpful friendly folks in the community. I can't help thinking that there's a trimmed-down simpler language inside of Perl 5 waiting to get out. Perl 6 is said to be Perl 5's spunky little sister. Maybe [Moe](https://github.com/MoeOrganization/moe) will become 5's spartan little brother. 
Thanks for your post, I found it to be accurate if not somewhat depressing. Personally i've used Perl for years and have found the community and language a pleasure to work with. So if admitting to a decline of Perl would serve the community at large to better Perl in terms of speed improvements, improving the CPAN 'mudpile', updating the CPAN interface or all the above, I will admit it. But when you mention better library support in your third point, could you give an example of what libraries you found to be better than those available in CPAN? I'm more interested if this is a failing of the available libraries not being updated or if CPAN is missing those libraries altogether. All in all, your post raises some good points especially around the issue of CPAN not being more active and updated. Personally I think having a system similar to npm where you could easily publish to the CPAN registry would make the whole process of participating in Perl module development easier and more fun. 
It would be interesting to see a graph of how many people are newly adopting or learning Perl (although I don't know how or where you could gather such stats). I imagine that has tapered considerably.
[We are searching for people like you](https://github.com/smonff/Shurf). We are building a (physical) book shelf platform for individuals who want to share their shelves with others and become a public micro-library. I, as the lead developer of the project, have learned Perl while developping the project since 2011. So I'm not searching for the-killer-dev, anybody is welcome... If you are interested in working with Catalyst and many CPAN modules, [Open Library API](http://openlibrary.org), Open Street Maps and Leaflet, you are welcome. We have huge things to build with JSON and AJAX these days, so, if you are interested, [please contact me](https://github.com/smonff). More on http://selfshelfswap.org/wiki/
&gt; You don't seem to be trying to Great attitude. Attack the messenger. I've been exclusively perl for the last 6 years. I see heads-in-sand about perl being dead, and want to see that not happen. &gt; In fact, your post smells like a quite subtle troll. When I see someone troll, I don't reply to them. &gt; So, even when competing against three other languages, Perl is the correct choice half the time. I'm a perl guy. I try to use the best tool for the job, but I know how to use this particular hammer a whole lot better than I know python. &gt; What the hell are you talking about? The language shootout does not bear this out at all. I'll have to dig up what benchmarks I was looking at. They were being benchmarked against C being a score of 1. Perl was around 90*C on them, python and ruby were 30-40*C, and Javascript V8 was 8*C.
&gt; Your company (I don't know which it is) should, in this market, directly hire their programmers and keep them. It is a good thing to do anyway, and more so when dealing with limited availability. Tried. We got our sites on two of the guys in India, and are willing to pay their move. Their NCAs are too ironclad, and the company (who is still contracting them, just not willing to hire more) is unyielding. :( &gt; Btw, the difference between CPAN and other languages collections is about ten years. they too will have these problems, just not yet. I think as long as they remain popular and relevant, the diamonds will rise to the top. There aren't quite as *many* in those other languages, but that seems to be changing looking at github. It also looks like some of the top devs in ruby and javascript (sorry Python, no clue here) are taking as many as a hundred libraries each subtly under their wings to see that they succeed. I had to use Node.js for some routing stuff recently... and check out the substack user. He is flagged an owner of a hundred projects, easy. I just...I can't see how this language that used to be the best of the best is sticking their fingers in their ears singing "nah nah" about the reality shift.
&gt; could you give an example of what libraries you found to be better than those available in CPAN? RPC I've never found what I needed without having to hack libraries... and nothing like Cucumber on Python. Finances. Oh hell. Pugs is just lightyears behind every python solution. ORMs. DBIx::Class is wonderful. It's awesome. Until it's not. I can't count my hours of headaches trying to build smart db objects that let me chain search queries. The moment you provide a related_resultset(), you end up with table-name issues... which should be obvious since it defaults you into a generic resultset instead of the relevant one. I know it has to do with how DBIx::Class is handling it all, but I've used ORMs that just do it much less painfully. Deployment libraries. Yes, I know, you can *use* fabric or capistrano, if you want to add a second language into your world... and you don't get any language-ties. There's a couple more, but now I'm on the spot. Our team is *not* being pushed away from perl, but are voluntarily adding some decouple-steps to allow non-perl code to be added... to prevent us from hitting a wall on libraries. 
I started perl-tutorial.org in january last year, and while i don't know how to make the google analytics stuff public, here's a screenshot of the visitor counts: https://dl.dropbox.com/u/10190786/tut_stats.png
&gt; Great attitude. Attack the messenger. I've been exclusively perl for the last 6 years. I see heads-in-sand about perl being dead, and want to see that not happen. If the messenger is doing more damage then he is communicating anything useful, then yes, i will do so. In other words: Standing around yelling "something is broken!" is not useful. Pointing at a specific thing, saying "that is broken and this should happen to fix it" is useful. You've not provided a lot of the latter. Personally i see one thing is broken: Perl people tend to stick to CPAN, perlmonks, blogs.perl.org when they build cool shit; so it doesn't spread past the echo chamber; meaning tiobe gets faulty data; which will be parrotted by people who can't even read a graph; which gives unsuspecting bystanders a false impression and leads them to make real decisions. One way to fix it is to talk more about cool shit in outside communities (which is hindered by there being a bunch of dedicated trolls who pounce on every post about perl) and another is to dissuade people who try to claim from half-understood half-knowledge that perl is dead from doing so. &gt; When I see someone troll, I don't reply to them. I don't believe you're trolling. I'm saying that due to the specific style of writing you used it looks very similar to one. &gt; I'll have to dig up what benchmarks I was looking at. Please do. I wouldn't be surprised if it was an entirely useless benchmark, but even explaining that would be great. (Also, Ruby has consistently had the criticism of being slower than most other dynamic languages, so being faster than Perl would be a great surprise to me.)
Sorry, that's not possible for legal reasons. But there's not much context anyway, something like: "Perl features variables, subroutines, ions and regular expressions."
So, the original text is in english?
Yes.
Yeah, my guess is 2, some sort of editing mistake. It's just weird that they insist everything's correct. Why operators, though? Are they called ions in other languages?
Wait a minute. [Pugs](http://www.pugscode.org/)? I think I'm missing something, because I was not aware that Pugs was still in use. I don't know enough about DBIx::Class myself. From my limited exposure, it's somewhere between Python SQLAlchemy, which I find quite nice, and the agony that is Rails ActiveRecord. Anyways, I just wanted to mention that Perl is and always has been a great glue language. Never had any qualms about using it with other languages and tools. I've got Rakefiles (because I happen to like the structure of Rakefiles) controlling Perl 5 programs which invoke Python (for the sake of a particular library). The stuff at work gets downright bizarre at times. Adding a second language to a mostly-Perl project is nothing new.
Operat-ions?
Yeah, i was thinking that someone had written the text who didn't have full control of english.
&gt; Standing around yelling "something is broken!" is not useful. Well, he's not *yelling*. We're all mates here, mate. :) 
If the language version released in RHEL is any indication of a language's livelihood, Python would be considered long dead.
I've been exploring Node.js, but it's been challenging. My reaction to JavaScript is similar to the reaction of other folks to Perl. Even CoffeeScript doesn't help, because _I know there's JS under there somewhere._ Oh well. That's my issue, and I'll deal with it.
Someone send this link to the asshats claiming Perl is dead.
&gt; Tried. We got our sites on two of the guys in India, and are willing to pay their move. Their NCAs are too ironclad, and the company (who is still contracting them, just not willing to hire more) is unyielding. :( You're having trouble finding Perl developers in the States? 
We were, and desperately. Now the new ownership has changed the game, and we're not hiring for Perl at the moment.
 thanks a lot my problem is now solved. Trouchelle had every package i needed. I simply added trouchel as a repository like it's indicated on the site and everything went A1 after that!! Have an upvote and a wonderful day kind sir
&gt; Maybe the better question is how to manage language internal "rot?" That's one of the two most important questions about Perl 5.
Seems like some languages get stuck in a place where, they've kept the language backward compatible for so long that it becomes expected it'll *always* be that way. Wait. What's the *other* important question? 
The only thing that comes to mind is that it's a typo for `l10n` which is a shortening of "localization". While perl certainly supports locales and various other forms of localization, so does pretty much every other language to some degree. And it makes no sense to list that as a bullet point item in between variables, subroutines, and REs. I'd chalk it up to some HR drone making a typo or not understanding what they were reading. 
Nagios?
You probably just need to [embed that SVG into an HTML document](https://developer.mozilla.org/en-US/docs/SVG_In_HTML_Introduction). As far as generating the HTML, there are three basic options. 1. Strings embedded in your Perl code. OK for small stuff but not really sustainable. 2. The [CGI module](https://metacpan.org/module/CGI#GENERATING-DYNAMIC-DOCUMENTS), already mentioned. 3. Templates. [Template Toolkit](http://tt2.org/) is one popular option.
It is a nice image. I guess it would be possible to create image maps - there are online tools search for image map tool. However I think that this approach is not the best. Since the image is a nice table, I would use html table to make similar structure and fill it with links to the page with detailed text. You can generate the page using perl. Check CGI.pm, HTML::Template.
Should be able to embed links directly in the SVG. There are a lot of nice Javascript visualization libraries out there too.
&gt; We were, and desperately. Did you consider training them? In our company i've brought two complete perl newbies from zero to surpassing most people i see on IRC by giving them six months, a copy of Beginning Perl by Ovid and a copy of Modern Perl.
Firefox has a similar problem. The developers refused to admit their problems and fix them. It had many massive memory leaks, but they shifted the blame entirely to plugin developers. Turns out the community was right. By the time they fixed the bugs, most of the community had moved on to chrome. Perl's long delay between 5.8 and 5.10 bled off a huge percentage of developers to Ruby and Python (which were actively releasing good, new features on a semi-regular basis and had a growing community). Sure, they've corrected course somewhat now, but I worry that it's too late at this point. And I concur that clinging to backwards-compatibility to the cost of all else is holding them back immensely. Who are these mythical developers that both a) cling to deprecated/broken features of Perl and b) update their Perl installation to the latest release without verifying that their code still works?
&gt; The premise is wrong; Firefox is dying. Prove it, with facts. (I know the discussion isn't about Firefox, but Ovid's central point is epistemological.)
another guess: ...variables, I/O and regular expressions.
It's not difficult, Ovid's graph doesn't quite frame the dire situation of the Firefox. It curiously cuts off at Dec 2011. Guess what? This isn't 2011. It's not 2012 either. And, we're one month into 2013. We can say with hindsight that Ovid was wrong when he failed to identify the trend of Firefox, and he's wrong when he failed to identify the trend with Perl. In Dec 2011, [Ovid's source](http://gs.statcounter.com/) shows Firefox at 25.57% mkt. share; and, as Ovid shows that's down 20% from their peak. As of Jan 2013 they're down to 21.42% market share, ie. FF lost another 4.14% of the market: or a loss of 16.2% from the low that Ovid cited. Better put, they're 16.2% closer to dead then the graph Ovid showed.
Orders yours today. Better yet get a dozen and give some to some friends. http://www.adafruit.com/products/1232
&gt;Tried. We got our sites on two of the guys in India, and are willing to pay their move. Their NCAs are too ironclad, and the company (who is still contracting them, just not willing to hire more) is unyielding. :( You where already contracting them. why do you fight to hire them? totally weird. &gt; I think as long as they remain popular and relevant, the diamonds will rise to the top The question is, of course, how to mark these diamonds and comunicate this to the uninformed user. It is nice that the JS people solved that by having power-users take ownership (part ownership? I don't know what 'flagged as owner' means) on modules. Maybe it is an idea that the Perl world can steal. (if everyone will agree that we have a problem, first) However, on CPAN, a module is considered more or less the private property of the author. metacpan have a '+1' functionality, which is a start, but it is much weaker then personal patronage of a power user. 
Here's a fun bit of context you're ignoring: is the market growing, shrinking, or staying flat? Until you can answer *that* question, you can't address anything more interesting about Firefox's present or future. (You can't even get to the question about exclusivity or overlap among users or the presence or absence of identifiable cohorts among the statistical groups because *that* data isn't present either. What you have is chart junk because you don't have the context to analyze the information.)
Upon skimming, this seems like a real physical badge... Do I put it on my tie during interviews?
The market's future doesn't matter -- it's not the subject of discussion. So what the market in itself is in flux? What matters is that the Firefox, like Perl, has a shrinking share of that market.
&gt; It was ousted by a better technology that is more stable and feature-full. Bull. Shit. Chrome has been able to successfuly cannibalize IE users by virtue of doing something a pure open source product was unable to: Advertise en masse in the physical space, using Google's cash. I don't know about other countries, but in Germany a few years ago i used to see big billboards advertising Chrome. I've never seen that for any other browser. (**Edit:** Forgot advertising for free on the most-used website on the planet.) Also, you're ignoring a massively important fact: That market share is not equal to absolute user numbers. If there is a rising number of users it is easily possible for a product to lose in share, while gaining users. I'm not saying that Perl doesn't have a problem. Just that everyone and their dog seem really intent to use half-understood half-knowledge on statistics to proclaim the problem being orders of magnitude bigger than it is and thus actively compounding the problem. In other words: Either make sure you use real science, or shut up about matters you're not a 100% sure you're not ignorant on; otherwise *you* are the problem.
Usefulness.
&gt; The market's future doesn't matter.... Sure it does. As a businessman, I don't really care if my market share is shrinking if the market itself is expanding fast enough that my customer base is still growing sufficiently. A mature market can sustain multiple competitors. In fact, that's one mark of a mature market.
Thanks. By now I'm pretty sure "ions" really has no meaning in this context, so the client will have to explain what they mean. I'm really interested in their response after they were so sure it's not a mistake. If they still say it's not a mistake and come up with some bullshit explanation... well, there's always a literal translation.
Or [Dancer](https://metacpan.org/module/Dancer) - I find it far more pleasant to use than CGI A brief talk on how Dancer is better than CGI [here](https://www.youtube.com/watch?v=tu6_3fZbWYw), a little biased because it's by the creator of Dancer but I certainly agree with him
&gt; You where already contracting them. why do you fight to hire them? totally weird. Nah. That's how they all work. Our attempt to hire would be seen as corporate theft. While we would pay the employees *more* than they do, we would no longer be paying a premium to the outsourcing company... We're contracting those employees through a very large outsource firm that makes all its money from leasing out their developers &gt; The question is, of course, how to mark these diamonds and comunicate this to the uninformed user. A really good question. I wish I knew the answer. I think the second question is how to get the diamonds under more active development or refactoring. POE, for example, is a pretty damn awesome perl-only library... but it also has a pretty damn high learning curve. Other languages have libraries like that, don't get me wrong. Node's crdt library comes to mind. On that topic, that's another technlogy I have yet to see ported to perl. &gt; It is nice that the JS people solved that by having power-users take ownership (part ownership? I don't know what 'flagged as owner' means) on modules. Maybe it is an idea that the Perl world can steal. (if everyone will agree that we have a problem, first) If a library starts to succeed, people seem to allow it to become a group project. You end up with a dozen developers as "owners". It's not exclusive, but it is a tendency. Most rubygems and the like (all 3 languages, really) tend to be hosted on github, where pull requests are honored due to library activity. For example, I wanted to use the barista routing library in something I was trying. Since every routing library I've ever seen lacked one feature (deleting routes at runtime), I picked one with the most favorable-seeming architecture, copied it, and checked in an improved version with test cases. Within 3 days, it was verified and in the master branch. We have TONS of manipulated CPAN at work. Even grand-daddies like DBIx::Class. Some, we've even tried to contact original developers for patches/upgrades. Others were so hacky from the start that our changes really were too specialized. &gt; However, on CPAN, a module is considered more or less the private property of the author. metacpan have a '+1' functionality, which is a start, but it is much weaker then personal patronage of a power user. It's exactly what *was* the best way of doing libraries 5 years ago. Nobody had great library packagers except perl. Over the last 5 years, there's new cities of code, with designs and expectations that are much more friendly to improvement... and make it easier to keep dust off the libraries.
No mention for Mojolicious? It's perfect for small projects. 
It appears to be for teachers, and such, to reward achievement in learning Perl.
Honestly, the people who maintain search.cpan.org should just add the redirects themselves to the benefit of the entire community. There's literally no reason to use the old site any more.
That's a link to another thread. ;) Also, please replace "Effective Perl Programming" in your suggestions with this book: http://ofps.oreilly.com/titles/9781118013847/ It is infinitely much better suited for newbies. :)
We use it at $work and well, it still needs a lot of work. It's most useful when you're not actively depending on specific dependency versions.
&gt; There's literally no reason to use the old site any more. Not correct. MetaCPAN still has a number of issues to iron out. Some search results are [flaky](https://metacpan.org/search?q=fcgi) and sometimes it will fail to find and render the pod of a module that sco has no problem with. (Yes, i report those things whenever i see them.) That said, metacpan is my main site and i only use sco when it metacpan seems to fail me.
Get familiar with the perl debugger (perl -d). It's scary at first, but you will love being able to skip around the code on the command line. NYTProf is good if you need to optimise anything, and can just be added to your server with a single line in your httpd.conf. If you're thinking of rewriting stuff, I would advise against php (that's just my opinion) but I would advise using perl modules and a templating framework, perhaps template toolkit. Make sure you think about your REST interface too. Probably best to write an API and run the website off this, it will help with separating the program layers (data engines/backend/frontend). Also keep in mind that if you're going to start entirely from scratch, you will probably repeat the same bugs that have been fixed in your current version. 
I suppose the application wasn't developed from scratch. It probably uses a framework (Catalyst, Dancer, etc), or at least some other system (like Mason). Find which of these tools is used, read its documentation. Learn about the template system that was chosen. For general info about Perl, "Modern Perl" is a good book, freely available online. Beware of obsolete documentation and tutorials.
Perl is powerful. Write Perl applications with Perl. Programmers new to Perl tend to copy their favorite language with it (wich is possible most of the time) without using it's features. Take a look at the Modern Perl book and definitely get Higher Order Perl.
Unfortunately I haven't seen any code yet, but I assume the same.
::Concise
Great! This book is exactly what I need.
Perl is a tremendous language, but it's very forgiving of bad code. This could be seen as a strength - in that it makes it easy for new Perl coders to get things done. But it's also a weakness in that there's now 25 years worth of pretty awful code sitting out there! If you search Google for example Perl code to solve certain problems, you will often find 100 completely different solutions, most of them with a few problems, some of them with a great many problems. And of course as a new Perl programmer, you can't easily tell which ones are awful and which ones are great! Read [Modern Perl](http://www.onyxneon.com/books/modern_perl/) (free e-book), and try to make things as easy on yourself as possible. There's an accompanying module, Modern::Perl: https://metacpan.org/module/Modern::Perl If you can install your own choices of CPAN modules, install that, and start every script with: use Modern::Perl '2013'; # or as recent a year as possible Otherwise, start with: use strict; use warnings; That'll tell Perl to stop you doing a lot of stupid things, allow you to do the latest and greatest things, and should be enough to get you started without doing too much damage :-) When you have more specific questions (and you will!), head back over here and we'll help if we can.
&gt; The search on sco has always been godawful {{citation}} Seriously, what the hell. The search may not have sorted well by relevance, but i've never seen modules outright missing, or replaced by what amounts to distribution linenoise in the sco search.
PHP is relatively unstructured. It might make more sense for PHP projects to move to Perl than the other way around. One thing you really need to know is what version of Perl and which modules are used.
&gt; Also, you're ignoring a massively important fact: That market share is not equal to absolute user numbers. If there is a rising number of users it is easily possible for a product to lose in share, while gaining users. In the same sense that middle classes can *get more money* but isn't keeping up with inflation or the growth of the upper class so their buying power dwindles and the class *dies*? Death isn't just in absolute numbers and follows from a relative failure to compete. Things that become *more* obscure don't tend to survive in markets.
PHP's lack of consistency will drive you insane: http://tnx.nl/php.html
Not a very good business man? I'll make you a deal any day of the week: I'll sacrifice one client here and now if you destroy all of my competition.
Get a copy of "Perl Best Practices" as well. It will be useful to have written coding standards, and it will teach you that not always the most concise or most clever code is the best one to maintain. 
[Curtis “Ovid” Poe](http://blogs.perl.org/users/ovid/2012/06/read-my-book-online-for-free.html) write a very nice book for beginners about Modern Perl. It's called *Beginning Perl*. You can [read it online](http://ofps.oreilly.com/titles/9781118013847/), but I recommend you to buy a Paper one to reward Ovid's wonderful work. Some people don't recommend Camel Book for beginners, cause it's too hard in a first time and trouble your head with too many stuff. I agree with this position (partly because I tried the Camel Book first). Lama one is OK. 
Really? That's all I've ever seen. I've searched for exact module names and got pages of crap that had nothing to do with what I searched for many a time, but not the actual module I wanted. I had a friend that made a firefox shortcut to take him straight to a module's page because the search was so useless. Admittedly, because of these problems, I quit using it probably 5 years ago. Maybe they fixed it at some point?
That might be, but again you fail to grasp the real problem with people who write articles about how Perl is dying: They're making guesses. Yes, Perl might be on a deadly slope, but it might also be not. The tools that they try to use to prove their points do not give enough information to accurately decide either way. Frankly, i'm baffled as to how this point STILL hasn't gotten through to you. I made it 3 times, with different words each time in the previous post. Maybe i need to do this: **Show absolute numbers so Perl's progression can be determined in isolation, or shut the fuck up.** Have [an example](http://www.reddit.com/r/perl/comments/17hdws/economics_101_ovids_response_to_perl_is_dying/c85kgfl) for how one does this.
&gt; Maybe they fixed it at some point? Sounds likely, since i started with Perl in 2005 myself.
Stevan is 1 of 1 people in the Perl community that doesn't totally suck. Give or take two or three people. It's not likely that he'd be saying "fuck" too much or not making technical points where they are due.
&gt; What do you think is the greatest advantage of using perl instead of php? Perl has steady progress (calendar-based releases) and a clearly defined future (5+6). PHP does not; after years of false starts they've given up trying to even support Unicode and most innovation seems to be from 3rd-party reimplementations.
Definitely read PBP, but some of the module recommendations are out of date, so read this too: https://www.socialtext.net/perl5/pbp_module_recommendation_commentary 
Use the following functions: first, grep, map. They'll do you good. Also as others have said: Data::Dumper is good, and 'use strict' at the top of your files is pretty much mandatory.
&gt; They face the data Except it has been bountifully proven that the data in question is meaningless, which unravels the entire rest of your carefully crafted religion comparison. Edit: Or can you put a number to the absolute size of the market?
Is this a common experience with Carton? 
grep, map and even use strict reminds me of Javascript, and that's a good thing!
[Perlmonks](http://www.perlmonks.org/) is your friend. Well, I mean, *one of* your friends. You've got a lot of friends. :) 
Know CPAN. Know Perldoc. If you like the terminal, install Pod::Cpandoc and use `cpandoc` to read the docs for everything (including the modules you haven't installed yet). If you like the browser, set up a shortcut called `perldoc` or something that goes to `http://p3rl.org/%s`. Use cpanm to install stuff. Look for the community, it will help you out a lot.
This has happened to me several times in the last year. I wouldn't call "not rendering the documentation I'm looking for" or "failing to find a module" obscure.
I didn't know that I could find the docs without leaving the terminal, love it!
I find these very helpful: (flymake-mode) (icomplete-mode) (tabbar-mode) (ido-mode) 
[Metacpan](http://metacpan.org) is nicer than [cpan](http://www.cpan.org) [Moose](https://metacpan.org/module/Moose) makes the object system not crap [Test::Most](https://metacpan.org/module/Test::Most) and [Test::Class](https://metacpan.org/module/Test::Class) make testing easy to organise and perform use strict; use warnings; [function prototypes don't do what you think they'll do](http://stackoverflow.com/questions/297034/why-are-perl-5s-function-prototypes-bad) 
Global warming at the hands of humans isn't a *lucky guess.* Perl's demise isn't a *lucky guess.* Your threshold for conclusive data is laughably high.
"I hope that I don't have to start entirely from scratch, but at this moment the application is really slow (1s+ response time), so most likely large parts do need to be rewritten." Really? .. do you have any evidence to back that up, given you haven't seen the code, the database schema, the server configuration or the logs and monitoring of the servers? Before you touch a line of code, go and buy yourself http://www.amazon.com/Art-Capacity-Planning-Scaling-Resources/dp/0596518579 read it, apply the tools and techniques and you can probably sort most of the scaling issues without modifying the code beyond small changes to allow the infrastructure to scale better. 
Meh - I've asked and answered questions like that in job interviews - rewriting the code is one of the worst answers to give/hear - there are about a dozen things you need to look at before you even read a line of source code or look at the database schema
 As I said in a different comment I won't rewrite if it isn't necessary, I haven't seen the server configuration etc. yet so I don't know for sure if it's the code or not.
and/or `Data::Printer`
And, that'd be our fundamental *theoretical* difference. Now, the burden is on you making that claim to show that the amount of Perl programmers is growing at all.
&gt; Without the context of total market size and its change over time, you can't use this graph to say that the number of Perl users is growing, staying put, or shrinking. Now the argument falls to absolute numbers which isn't even mentioned once in Ovids article. Not just that, but it is just as silly for reasons that we've already covered; AND, you've never demonstrated that the talent-pool for Perl is growing at all. Here is the opposition to the theory that perl is dying: * TRENDS DON'T MATTER, BUT MY ARGUMENT DOESN'T REST ON THAT * YOU CAN'T ASSUME IT ISN'T CYCLICAL OR TRANSIENT, BUT MY ARGUMENT DOESN'T REST ON THAT * ONLY ABSOLUTE NUMBERS MATTER, BUT MY ARGUMENT DOESN'T REST ON THAT It's just a bunch of Gish galloping from zealous Perltards.
It's probably getting a bit dated, but back when I started with Perl I learned a lot from the *[Perl Cookbook](http://shop.oreilly.com/product/9781565922433.do)*. It gave me solutions to problems I had yet to encounter. I'm not sure this is relevant for you, but Randal Schwartz' book *[Perl Objects, References, and Modules](http://shop.oreilly.com/product/9780596004781.do)* is a pretty good basic intro to, well, objects, references, and modules. It might be a bit too basic for you. Since I came from a non-comp-sci background I learned much from it. 
&gt; The perl 6 regexes aren't that revolutionary, if you've ever used prolog or definite clause grammars. I first used prolog (via smalltalk/v) to write parsers in the mid 80s. (Also some lisps, snobol, etc.) Have you used Perl 6? &gt; They seem to owe a lot to parsing expression grammars (pegs) Appearances deceive. It would make more sense the other way around, but I think this is an example of independent invention of similar notions. (The basics of the Perl 6 regexen design were established in 2002. PEGs were first introduced in 2004.) &gt; and like most top down parsers they have a bit of a problem with left recursion. (personally, I'd rather have earley deduction over backtracking) Jeffrey Kegler, creator of [marpa](http://jeffreykegler.github.com/Marpa-web-site/ ), has had several interesting [dialogs on #perl6 with Larry in 2007, 2008 and 2012](http://irclog.perlgeek.de/search.pl?channel=perl6&amp;nick=jeffreykegler&amp;q= ) , including discussion of weaknesses of recursive decent parsing and backtracking and strengths of the Earley algorithm. I'd say Larry's response to Jeffrey's points has been that these haven't been an issue for the biggest Perl 6 grammar to date, namely the grammar for Perl 6 itself. &gt; Perl 6 has come up before and every time the caveat "Perl 6 is great unless you actually want to write code in it" is mentioned. ... by folk not using it. I see folk saying how great it is to write code in Perl 6 almost daily. (Though not here on reddit.) &gt; it will be another decade of hacking on the libraries to catch up with the rest of my toolbox. What about the elegant FFI in Perl 6 which basically provides for convenient and nearly instant access to the world of C libraries?
&gt; Now the argument falls to absolute numbers which isn't even mentioned once in Ovids article. Ovid assumed people would apply even modest reading comprehension skills when he wrote "If a product is very successful, very profitable and has a relatively low barrier to entry, competitors will arise...." &gt; Here is the opposition to the theory that perl is dying: Quit it with the strawmen. &gt; zealous Perltards Quit it with the namecalling.
I never made that claim. You and others crowing about the death of Perl made the claim first that that number is shrinking and i'm not even saying that it isn't. I'm saying none of the data can be used to actually claim any movement in either direction and absolute numbers will be required to do that.
&gt; Ovid assumed people would apply even modest reading comprehension skills when he wrote "If a product is very successful, very profitable and has a relatively low barrier to entry, competitors will arise...." No doubt, competition that conquerors the market causing a dwindling market share and a status of obscurity?
Quit it with the question begging.
That's not true, your foundation is flawed. Like I said, I'll sacrifice a single client any day you want to take out the rest of my competition. Markets are in flux they're not absolute, the question about Perl's death is implicitly referencing the market it exists in. If Wal-mart turned a profit of one dollar, and Target turned a profit of 150 million you wouldn't say that Wal-Mart was dead, or that the returns aren't indicative of doom? As an investor, would you invest in Wal-Mart? Now apply the same statistics to programming languages and put yourself in the shoes of a business or an aspiring programmer? Which are you going to invest in? And, I'm still not conceding that Perl is quantifiably *"growing"* in any absolute respect even with your poor definitions.
 use List::Util qw/first/; had to look it up.
&gt; And, I'm still not conceding that Perl is quantifiable "growing" in any absolute respect even with your poor definitions. Wow, your reading comprehension is quite bad. I'm sorry i wasted my time on trying to educate you in basic math.
The book recommendations here are fantastic. I'll put another one on the pile for Modern Perl, and PBP with the caveat that it's somewhat outdated in its module suggestions. That said, the one thing that helps most when grokking Perl is the idea of context. Things in Perl are given context by the things around them. Things are treated like lists when you try to treat it like a list. Things are treated like scalars, or numbers, or hashes, when you try to use them as such. Sometimes, Perl converts it, sometimes it can't. Sometimes you get to use `wantarray`. Whichever book you're reading, when you come across the section on context, don't skim. Re-read it if you don't understand it, and ask stupid questions on IRC until it clicks. Once it does, using things like `map` and `grep` and the `=&gt;` operator will make much more sense.
And, I you.
&gt; at this moment the application is really slow (1s+ response time) Don't guess at why it's slow. Use Devel::NYTProf to profile it and find out which functions are slow. :)
The number one argument for not rewriting (in PHP or any other language) is that rewriting is almost certainly a horrible idea. So, get good at Perl and fix what's broken, rather than assuming you can rewrite it effectively in less time. You probably can't, no matter how bad you think the code is (it'll look really bad, at first, because you don't know Perl and Perl has some idioms that seems scary at first glance but are very concise and clear to one fluent in Perl).
I agree. Modern Perl is a good book. I think the 'Programming Perl' book is good as well.
 Profile it
Because it's already written.
Not one else mentioned it, but I have been using [DBIx::Simple](https://metacpan.org/module/DBIx::Simple) more and more lately. It uses DBI as the backend, just has nicer features/syntax than straight DBI.
You definitively must know about "Modern Perl" and Plack and PSGI
Further to what archier100 said: For profiling, try using [NYTProf](https://metacpan.org/module/Devel::NYTProf).
~~Moose~~ Moo
Tried Pinto earlier today. Failed with some ORM error. Apparently it still needs some work too.
I tend to start with moose, then scale it back if it becomes an issue. Do you always go straight for Moo? 
I wouldn't overwrite "perldoc" since it's useful as-is. You can do "perldoc Some::Module" to look up installed docs for that module. "perldoc -q keyword" shows answers from the Perl FAQ on that keyword (try "perldoc -q shuffle" for instance). "perldoc -f function" shows documentation on a builtin function (try "perldoc -f sort"). The installed manual is pretty good for the language. I'd avoid the object oriented pages (due to Moo and Moose being more awesome and yet simpler than anything they have) but the rest hold up pretty well.
&gt; Beware of obsolete documentation and tutorials. Because of Perl's age you can find lots of blog posts from the early 2000's. How old is obsolete in Perl-time would you say? 
Php makes it very hard to make a secure application. You really have to know what you're doing.
&gt; Previously the startup outsourced their web application, however their web application is their main product This is simply awful; I'm surprised nobody else has commented on it. It's a major red flag when the company's core value proposition is outsourced, and it sounds like this startup has been doing it wrong from day one. If I had to guess, I'd say it was probably founded by a business major who thought he had a great idea but didn't know shit about software engineering. My advice would be to have fun with Perl and look for another job. People have suggested great resources here, so there's not much more I can add to that list, but good luck :).
And dont forget "[Learning Perl](http://books.google.no/books/about/Learning_Perl.html?id=va1PSgaO4xIC&amp;redir_esc=y)". Even if you are a good software developer, you need to learn perl; not PHP'ish Perl. This book is a great entry level book that will teach you a lot of the peculiarities that will make your life so much easier. And, get to love Regular Expressions! Read [Mastering Regular Expressions](http://books.google.no/books?id=sshKXlr32-AC&amp;dq=mastering+regular+expression&amp;sitesec=reviews).
I think Perl has ceded its niche (dynamic scripting language, useful for quick scripts, &amp; CGI) largely to Python and Ruby. And with good reason - I'm sure plenty of Perl programmers would be happy to concede there are serious design flaws with Perl that have been exposed by more modern languages that Perl 6 was largely written to address. I don't see many people recommending Perl as a language to learn for anything anymore - except those in the community itself, which is largely insular. Even Ubuntu has switched over to using Python as its de facto scripting language. I'm not sure how much we can take from those statistics either. Do you know what people are coming to the site? Are they people who visited previously and are still using the site or genuine newcomers? What is making people newly adopt Perl if they are? Is it by choice or is it because they've inherited a Perl project? I'm not stating it's one way or the other but we've not much data. I also can't help but feel the Perl community is starting to resemble the Lisp community in a way. So many of the posts on /r/perl are saying "Perl isn't dying" or "Perl is superior to x". That tends to signify something is awry.
What are the things that you do mostly, BTW? Having a quick startup never hurts. Even for web apps that are meant to run persistently, being deployable under CGI (or Plack::Handler::CGI) is nice and beneficial for testing/debugging. Moose and a lot of web frameworks make it painfully slow for that. But it *is* possible, PHP is the prove.
&gt; What are the things that you do mostly Bit of everything small to medium sized web apps, reporting guff, automation of asset management/monitoring and small adhoc scripts all over the shop When it comes to testing/debugging - unit testing means I'm only ever loading a single module for the majority of the time, with only the occasional integration test which loads the whole thing and gives it a run through
&gt; And with good reason You have made your mind up already. Why should i even *bother* to try and answer your questions if you make it clear from the get-go that you have all the answers in your head already? &gt; Do you know what people are coming to the site? Do you even know what Google Analytics is? &gt; So many of the posts on /r/perl are saying ... "Perl is superior to x". {{citation}}
I haven't had an excuse to use Perl 6 yet. Honestly some of the one liners I see, scare me. My brain is too fragile and seeing the periodic table make tremble in fear. Before I talk about Perl 6, endulge me in some parser chat: I'd say less independent innovation, but similar approaches to declarative languages for recursive decent parsing, and that goes back to the 70's with TDPLs. PEGs novelty in 2004 wasn't the language, but the algorithm—packrat—and demonstrating that backtracking + memoization for top down parser languages could get linear time at the expense of memory. Meanwhile, if you ask some mercury users, memoizing to get linear time is overrated (c.f "DCGs vs Memoization, is it worth it"). Thing is, If you're already memoizing, early parsing isn't a big leap. Earley parsing is basically a breadth first search, as opposed to the depth first search of packrat. They are complementary approaches, not conflicting ones, without the loss of linear time either. It's actually possible (and i'm sure you know this already, as marpa demonstrates this) to get linear time parsing using a modified earley parser for all lr-regular grammars. That's a very, very large space. You also get nice error correction, ambiguity handling too. Left recursion isn't much of an issue, for those who have spent their lives hacking around it, but my experience has been that elimination complicates grammars. Some PEG engines allow left-corner parsing, but really full context-free parsing is just as easy to add. Anyway, back to Perl 6, although I could do parsing chat *all day*. If you haven't picked up "Parsing Techniques 2nd Ed" I would heartily recommend it. Ok, really back to Perl 6: Don't get me wrong—I'm happy other people are having fun with it, but like many folk not using it, most of the languages I touch on a day to day basis are mostly two decades old. I'm a luddite, and if I can't trust it in production, i'm less inclined to use it for fun stuff. That and having easy vendor packages for the library and third party components is a joy. As for the elegant FFI, if I need to wrap a C library, Python has ctypes and now cffi. The latter was written by the authors of PyPy, and their JIT shenanigans can take advantage of it. I haven't needed to use it yet myself, as most of the c-libraries I need have been wrapped, packaged and tested already. At the moment I find myself being lured by niche languages like erlang, especially the process supervision, and occasionally I get jealous of postgres' transactions covering updates to stored procs (yes, you can put any ddl in a transaction). Although Perl 6 has a glut of features, they don't seem to be geared at the operations headaches I suffer—Show me how writing Perl 6 makes code more fault tolerant, isolated, and easy to roll out and rollback, and I will listen avidly. In the meantime i've learned to live without traits, lazy evaluation, multimethods, and junctions. Really, I'm not really driven to use a language because of the features, operators or syntax, i'm driven to use it out of convenience—stability, libraries, packages and documentation. I am a very, very lazy programmer, and although perl 6 looks fun, it is still far too young for me. If I haven't escaped programming in another decade, I may give it more of a look, especially if it turns out one of Perl 6's crazy features turns out to be *exactly what I need*. So i'm still going to keep an eye on it, and Perl 5. There is too much neat stuff happening
I really liked audrey's mantra of "optimize for fun", and the free-for-all she created with pugs. With my personal projects i've always handed out the commit bit—people don't just feel part of the project, they become it. However, with the rise of git, github and pull requests, it's a lot easier for drive by contributions, where you don't have to ask to hack on the code. To me, Optimizing for fun is closely related to the process of eliminating suck. Thanks for sticking that information up. It's nice to have something to link to.
Learning Perl might once have been good. However the bulk of it still assumes we're in March of 2000 and teaches bad practices (coding without strict/warnings, bareword filehandles as default). Please do not recommend it, and instead check http://perl-tutorial.org for current books.
Anything that's older than 2010 can be quite obsolete. The question is made more difficult to answer though since some things were written ~2000 and rereleased in new editions with minimal updates. The easiest way to check for obsolescence is to look for how early strict/warnings are mentioned (should be the first thing, period) and whether they teach bareword or lexical filehandles as the default. If in doubt, just refer to http://perl-tutorial.org
Oh hell yeah I love perl CGI... hell sometimes I write CGI in C. No one is developing like that anymore though, I really only use it for personal projects and some in-house code for work. The main idea with CGI is that whatever goes out on stdout is what the browser gets so you can use really any scripting language or even compiled binary to generate the page. Something like PHP is really just a wrapper for CGI. Input, via GET or POST and cookies, are accessable through environment variables and stdin when the code gets executed. You really don't even need any modules to do it however you can use the [perl CGI module](https://metacpan.org/module/CGI) which makes a few things easier. Pretty much all the documentation you need is on that page.
I've been doing a lot of C development in CGI, and the best reference I ever found was [RFC 3875](http://www.ietf.org/rfc/rfc3875). Don't get discouraged, the system itself is fundamentally very simple, and the Perl module for it takes care of the dirtier parts. You can download [this book](http://www.wiley.com/legacy/compbooks/stein/), too. At its simplest level, a CGI script is an extension of the web server. Your server will start to send headers to the client and will pass the stream to you without closing those headers. The only additional information a CGI script needs to pass is the MIME type of its content, although you can specify more information. (Look at the [RFC for HTTP/1.1](http://tools.ietf.org/html/rfc2616) for examples of header information.) Send an empty line to close headers, and then all the content that follows is sent as the body content. Things become a little more complicated if you use Keep-Alive (which modern applications should in most cases), but try playing with the basics a little bit before digging too deep into the legacy code. Content-Type: text/html; charset=UTF-8 &lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; ...
Generally, if they're using the CGI module, just read the Perldocs. Ovid's guide still stands for this - there weren't any additions to the protocol after that (that would affect web app development. If the code is really old, you might see code using cgilib through a require. In that instance you might want to look at refactoring :-) A common issue I find in old code is the lack of data untainting and subsequent lack of using placeholders in DB queries. Keeping an eye out for those as you move forward will help save you some pain. 
thanks for the link - I'm already pretty happy with webdev in general and Dancer in particular, was just hoping there is a 'Modern ~~perl~~ CGI.pm' book for best practices when using CGI.pm :)
Well, if you're looking for best practices for CGI.pm, you'll want to watch this entire video: http://www.youtube.com/watch?v=tu6_3fZbWYw
Yeah, seen that and the poor response before :(
&gt; poor response What do you mean?
I use Dancer a lot. I've been given a legacy project which is all CGI.pm (and other assorted horrors)
Alright, watching that now.
No cgilib, so apparently it could be worse - woo! The whole data layer is horrible, and is going to be the first ~~up against the wall when the revolution comes~~ thing I refactor if I'm given a chance
Frankly, i don't know where to begin. I could *literally* take that talk apart sentence by sentence, pointing out a fallacy of flat our error in every single one of them. I am not kidding at all. That dude managed to either by willfulness, or ignorance, misunderstand every single part of Sawyer's talk. It's like watching a forums troll perform IRL. If you really care to hear why he is so damn wrong in every single thing he says, feel free to hit me up on freenode or irc.perl.org, i use the same nick as here. I'd strongly suggest you though not to waste your nor my time, and trust me when i tell you that you are better off entirely ignoring this dude and trusting in Sawyer.
Yeah, as I said I was not impressed by what that guy said in defense of CGI. Certainly wont bother wasting your time any further with his nonsense!
Haha, ok, i misundestood you then. Cheers. :)
I think it would make more sense to keep to a way of interacting with the webserver though wouldn't it? There's 30kloc of CGI.pm code in this project; rather than adding in Plack::Handler::CGI code as well I think it would make future maintenance less of a headache to stay on CGI.pm only. Or shift all of it to something else, but if I am allowed to shift it away from CGI.pm I'll just go to Dancer/Catalyst
Kinda depends on your codebase but it might make sense as a gradual refactor. Plack::Handler::CGI allows you to keep your current server config and eventually move to something better.
&gt; ... we've not much data. It seems to me that a response of "Let's get better data!" is more productive than "I know this data is incomplete and the conclusions we may draw from it are unsupportable, but panic!" Regardless of whether Perl use is growing, staying put, or shrinking with respect to a market that's growing, shrinking, or staying put, I think right-thinking people should be able to question data sources, collection methods, analyses, results, and projections with an eye to honest empiricism without having those called completely into question by suggestions of bias. In other words, I'd like to see Perl succeed as a programming language for a long time, but if good data shows something else, then that will change how I behave.
I repeat: A mature market can sustain multiple competitors. MySQL didn't get better because it was the only free-ish database project.
&gt; I repeat: A mature market can sustain multiple competitors. Ah, I guess the finance market wasn't *mature* enough to sustain Washington Mutual. It's stupid vacuous statements like this that don't even address the data that you're faced with.
&gt; I guess the finance market wasn't *mature* enough to sustain Washington Mutual. That's funny; I thought it was losses from sub-prime mortgages that drove them to Chapter 11, not "too much competition" or "A line went down on a Google Trends chart." You should get on the phone with the SEC--they'll want to hear your new insight into fiscal policy.
I've found that pretty much everything I need is in CGI::Simple, which has the advantage of being about half the size of CGI.pm. 
&gt; [packrat/depth first and earley/breadth first] are complementary approaches, not conflicting ones, without the loss of linear time either. No comment on the theory, but in practice [Longest Token Matching](http://perlgeek.de/en/article/longest-token-matching) declarative prefixes have a big impact on the performance of Perl 6 parsing. [jnthn wrote just a few weeks ago](http://6guts.wordpress.com/2013/01/18/a-quick-jvm-backend-update/): "the declarative parts of a grammar are analyzed to build NFAs: state machines that can efficiently decide which branches are possible then rank them by token length. It’s not only important for a correct parse (to get longest token matching semantics correct), but also important algorithmically. If you look at the way Perl 6 grammars work, *the naive view is that it’s recursive descent.* That makes it nice to write, but if it really was evaluated that way, you’d end up trying loads of paths that didn’t work out before hitting upon the correct one. The NFA is used to trim the set of possible paths through the grammar down to the ones that are actually worth following, and their construction is transitive, so that we can avoid following call chains several levels deep that would be fruitless. If you’ve ever used the debugger to explore a grammar, and wondered how we seem to magically jump to the correct alternative so often, well, now you know. :-)" &gt; You also get nice error correction, ambiguity handling too. There was [an exchange on #perl6 between Jeffrey and Larry a few weeks ago that included discussion of Ruby Slippers, parsing broken html, and hacks in the Perl 5 parser](http://irclog.perlgeek.de/perl6/2013-01-10#i_6318000). &gt; Left recursion isn't much of an issue, for those who have spent their lives hacking around it, but my experience has been that elimination complicates grammars. Imo that's one of the nicest things about Earley parsing. &gt; back to Perl 6: Don't get me wrong—I'm happy other people are having fun with it, but like many folk not using it, most of the languages I touch on a day to day basis are mostly two decades old. I'm a luddite, and if I can't trust it in production, i'm less inclined to use it for fun stuff. That and having easy vendor packages for the library and third party components is a joy. Right. These will be key hurdles Perl 6 must overcome over the next few years; I don't see it taking a decade for it to become sufficiently robust for mass adoption, but it sure won't be this year either. &gt; As for the elegant FFI, if I need to wrap a C library, Python has ctypes and now cffi. It may be a weakness of the documentation or my attention span but when I've looked at ctypes and cffi they look like a significantly more complex solution (from a usage perspective) than the [Perl 6 FFI](https://github.com/jnthn/zavolaj/blob/master/README.markdown) which is [a shockingly simple to use FFI](http://justrakudoit.wordpress.com/2011/01/28/zavolaj/) (though of course automated generation from header files is the way forward). &gt; At the moment I find myself being lured by niche languages like erlang, especially the process supervision [Larry Wall has mentioned Erlang and Perl 6 features inspired by it many times over the years](http://irclog.perlgeek.de/search.pl?channel=perl6&amp;nick=timtoady&amp;q=erlang). &gt; Although Perl 6 has a glut of features, they don't seem to be geared at the operations headaches I suffer—Show me how writing Perl 6 makes code more fault tolerant, isolated, and easy to roll out and rollback, and I will listen avidly. Larry claims to keep graceful failure modes (in the sense of mistakes by a coder as well as code) in mind. Couple examples: * KEEP and UNDO. (These are ["phasers"](http://perl6advent.wordpress.com/2012/12/15/day-15-phasers-set-to-stun/)). * Smooth support for Failure objects (which contain "unthrown exceptions"). &gt; So i'm still going to keep an eye on [Perl 6], and Perl 5. There is too much neat stuff happening Indeed.
Wasn't planning too. I won't fix stuff that isn't broken.
If you want to make a secure application you should always know what you're doing, regardless of the language.
Why do you feel the need to capitalize Perl?
Oh wow, so you mean the *downward trend* in sub-prime mortgages was really a trend and not just a random artifact pulled from the aether like the downward trend of Mozilla? One of them directly relates to the fate of the company, and other does not directly relate to the fate of perl. You're totally reasonable, but only sometimes.
Your epistemology is quite curious; does it really start and end with lines on a chart irrespective of what those lines mean, the method of data gathering, and the broader context of those numbers? Because you can plot two separate things on a chart and those charts look a little similar, those two things are the same?
Sounds like you are well on your way to figuring out which.
Even if "Learning Perl" teaches bad practices, it is a easy to read, and a good introduction to perl. IMO, it is not a great book for Perl-beginners coming from PHP. Since the thread already talked about Modern Perl, I felt that it should be mentioned. (The sixth edition does talk about strict and warnings. And it tells the reader about filehandlers in scalars, and why you would use them. But, it also explains how to use the bareword filehandles; you will find them all over legacy code. It might have been added in earlier editions, but this is the onlyone I have access to atm.)
Plain CGI.pm? Yow. Best practices have moved on in 10 years, but that module sure hasn't. I got forced to work on a new project using it a few months ago... I find PHP nicer to use.
Oh maaan, you're in for the ride of your life ! :) 
I mean, recursive descent in the sense that it's an LL parser at heart, rather than 'it is implemented by recursive descent', i use it as a synonym for top down parsers. Anyway, Longest token match shouldn't make any difference on the speed of parsing, you can do the same thing with a packrat parser. NFA precomputation is constructing an lr-0 or lr-n automaton and using lookahead to eliminate states. Once you have the rule, you can order your backtracking search across the states. For packrat, it goes in left-to-right, for perl 6 rules, it goes by the length. The speed is relatively unchanged by order. Aside: I found the article here http://6guts.wordpress.com/2012/11/08/lots-of-improvements-coming-in-the-rakudo-november-release/ further back in the blog you linked. Even marpa does it too! Based around the aycock and horspool earley parser, it constructs a LR nfa to replace the predictor step, replacing dotted rules in earley items with numbered references to possible states. You could still get a reasonable performance gain without creating an nfa, by memoizing the predictor step in the earley loop. (and while i'm at it, marpa's lr-regular mechanism, or leo joop's trick is also similar to memoizing the completor step). And you can have smarter automatons when you have smarter grammar operators—AT&amp;T's Yakker adds data dependent grammars (i.e length delimited fields) to an earley parser. Or Once you've got an nfa, why not go full dfa? For example—Shift-Resolve Parsing might be amenable to perl6 rules http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/FSF-ciaa06.pdf offers unbounded lookahead and linear time, without memoization or backtracking. Through my earley goggles, all parsers are just chart parsers. Some are highly restrictive and some are optimized, with different strategies for dealing with ambiguity and non determinism. Personally I think you could get quite far by using earley deduction on parser derivatives, but that's another story altogether, and that's still without covering boolean grammars, or non canonical parsing, or tree adjunction grammars!. but back to perl 5/6 and python although cffi and ctypes are less effort than writing a c-extension, i've never needed to go that far, and ffi isn't going to get you pyqt/pyside levels of integration. and with cffi, i can run a maturing jit that is actually used in production environments as e speak. As for erlang, sure, some of it's features have had some influence, but erlang's backbone—otp—hasn't had a look in. Process supervision is a substantial part of erlang's robustness, along with other choices explained in Joe Armstrong's thesis (which is rather fun). Phasers are akin to go's defer statements, and there are other approaches too. Other languages have 'with'/'using' statements, or destructors in a sort of raii style (some people even use type states! oh my!). None of these let me push out updates or switch running code. Rollback, versioning, deployment, these are features in terms of package management and service management. I should have been clearer about the pony I want. mutation is transactional! mvcc for code and data! software isolated processes supervision trees, and failing fast! these are some of the features I crave in a platform, not just perl 6's Sisyphean attempt at eliminating boilerplate code by creating new syntax rules :-)
Bizarre reply. I wasn't being particularly fractious. Your reply that Perl is 'useful' is hardly a sufficient answer - what language isn't in some domain? My point is the domain Perl traditionally occupied has a bunch of languages with better design principles. Ruby and Python both do OOP better. They both have much nicer and cleaner syntax for data structures. More sensible default scoping and error reporting (having to put autodie on all the time is stupid). They both have a fully functional Repl. (the one on CPAN is buggy as hell). A lot of the design choices Larry Wall made seem to be based on 'hurr I think this looks cool and mysterious!' rather than anything useful. Perl's best feature, its regular expressions, are available in a nicer syntax in Python and Ruby.
*Update: http://irclog.perlgeek.de/perl6/2013-02-05#i_6416456* I plan to ask on #perl6 about some of what you've written. In the meantime: &gt; Longest token match shouldn't make any difference on the speed of parsing That surprises me. My understanding is that LTM semantics and the LTM declarative prefix optimization makes a big difference in practice. &gt; leo joop's Heh. Joop Leo. :) &gt; ffi isn't going to get you pyqt/pyside levels of integration. I don't think that follows. Aiui, the value of pyqt/pyside mostly derives from SIP, right? &gt; As for erlang, sure, some of it's features have had some influence, but erlang's backbone—otp—hasn't had a look in. That doesn't square with what I've read Larry write.
Way to avoid my questions and entirely prove my first comment. Just now you put out a massive list of things that you regard as irrevocable facts, pretty much all of which i have contentions with in that i either think they're flat out wrong, or at least need clarification. You're also demonstrating a general lack of knowledge about Perl, which makes it even strange that you put out statements as absolute and universal facts. You don't make me think that you'd even be interested in seeing other view points. So yeah, are you going to answer my two questions? I'd especially be interested in seeing which "many" posts are being interpreted by you as "Perl is superior to x".
Yes, it talks about these things, it mentions warnings as a sub-chapter on page 23 after plenty other code has been shown. It shows strict on page 72! (Again only as a small sub-chapter.) It also shows lexical filehandles, but again, only as a small sub-chapter; at the very end of the IO chapter. It also continually talks about the differences between Perl pre-5.6 and post-5.6, which are entirely meaningless to a newbie beginning to learn Perl in 2013. This stuff is flat out damaging to Perl as a whole. Perl has a reputation problem for being unmaintainable and unreadable. Showing newbies code they **WILL** copypaste and use in production that has these and other faults, will only hurt Perl's image more and inflict unncessary suffering on people who try to help learners or end up having to maintain their code. Learning Perl is a terrible book for beginners of *any* kind, and for people who aren't beginners, it's ... probably not gonna help them either. (I should not need to explain this and i'm getting frustrated that people keep on suggesting things that are a clear danger even after being told this.)
For any decent hardware I doubt any improvement would be worth the effort of re-implementing it and checking that everything you were using in CGI.pm was working OK. That said, I *did* redesign a couple of sites to change from CGI.pm to CGI::Simple, but that was because I wanted to mirror them on my Nokia N900, where the slow processor meant that the benefit of compiling 123K of CGI::Simple over 256K of CGI.pm for each page was significant. Though I use CGI::Simple for new code on the principle that lightweight is a Good Thing.
[Further reading](https://rt.cpan.org/Public/Bug/Display.html?id=81793).
And the short version of that: Max "Corion" Maischein wants experiments with different possible APIs to happen outside of parent.pm, which is why david created yet another parent/base-like module, in the hope that the changes go upstream to parent.pm eventually. At least that's my reading of the ticket.
Moose, Mouse, Moo, Mo, M. Now base, parent, inherit. Is this a good thing or not? Should the Perl community spend its time reinventing stuffs or conquering the world?
Reinventing things (to see what can be done better) is one way to conquer the world. If LWP had been enough for Mojolicious, we might not have had Mojo::DOM.
It is. But in reality, on a modern webserver the speedup from changing one module isn't likely to be noticeable. When it's only taking a small fraction of a second to actually build the HTML through your CGI, any tiny improvement at that stage is going to be swamped by network-lag and the time it takes a browser to render the page. On anything but the simplest system, you'll probably spend more time checking that everything's working than the webserver will save over a very large number of page-views.
Author of carton here. I've been actively working on cpanm 1.6 for the last couple of days to add a better version range specification, which would finally accelerate the development of Carton 1.0. There's a couple of known issues (some of which are documented on github issues) that causes unreliable behaviors in some environments, which I plan to fix in 1.0 in coming weeks. Nothing is set in stone in terms of schedulewise, but take a look at https://github.com/miyagawa/carton/issues and see if there's a known issue for it.
Seems rather silly, everyone uses Moose these days and if they don't they should. &gt; extends 'My::Parent' =&gt; { -version =&gt; 0.01 }; I like the syntax of extends better too. You can always simply put the version in the use statement. use Object v2.0; our @ISA = qw/Object/; And in fact, that's usually a good idea.
There is always [goto](http://perldoc.perl.org/functions/goto.html)
Well, since you deleted your comment while I was replying, here is my reply. ----- Yikes. There's lots of bad things going on here. First of all, I don't see a single lexical variable, which implies that you're writing the bad old kind of perl where `use strict;` is not in effect and everything is global and there are few subroutines and it's a big giant mess. I urge you not to write code like that. Turn on all warnings and strictures, factor things into subroutines, and avoid globals. But the real issue is that you're not using the proper data structures. You're searching each element of this `@identity` array but you only seem to care about elements where `$qchr eq $tchr`. That should scream out at you that you should be using a hash, not an array. With a hash you don't have to search the whole thing each time, you can group the entities by fields so that you can quickly access only those that apply. Moreover, you're re-parsing this from CSV every time through the loop which is hugely inefficient. You should make a single pass over the file once to do the parsing, and from that create a proper data structure that has the data arranged in such a way as to facilitate whatever analysis you're going to perform. There are other algorithmic problems too. For example, if you want to keep a running list of unique things, just use a hash. Don't use an array and then constantly recompute the number of unique items in it every time something changes. This is applicable in a larger sense -- you should never have to go manually searching for duplicates or repeats. A properly designed data structure automatically reveals these relationships. Also, there seems to be a lot of use of counters to detect whether one element came before another, but that's indicative of a lot of wasted effort. If you only care about elements that come after a given element, then only search those items, don't search the whole list. (Although searching should generally not be present at all -- data structures are the key.) &gt; My initial solution was to just tag the innermost foreach loop and have last statement after it's tagged as a repeat/in range etc. The problem with this is we started incorrectly tagging a lot of repeats as being inrange instead (being assigned as a repeat needs to take precedence over being assigned to be inrange). If you want the repeat case to take precedence, then change the order of the `if` statements so that you check that condition first. Also, you only need labels if you want to break from the non-innermost loop. A plain `last` statement breaks from the innermost loop.
But beware that when using *goto* is the best way forward you usually took a wrong turn earlier in your travels. You really should rethink how you parse that data.
I wish Moo could do that `:\`
So I guess the world runs on (reinvented) wheels :) BTW, You probably meant WWW::Mechanize instead of LWP? 
I don't use Moose (not directly after all). You seem to think that I don't exist :)
Anyway, let's have a vote. Which syntax do you like better, *and (this is important) state why*. use inherit 'MyParent' =&gt; 0.01; #1 use inherit 'MyParent', -version =&gt; 0.01; #2 use inherit 'MyParent' =&gt; { -version =&gt; 0.01 }; #3 use inherit 'MyParent' =&gt; { version =&gt; 0.01 }; #4 I kind of like #1, but what if someday we want to allow inherit to import stuffs from MyParent for us ('use MyParent qw(foo bar)')? I don't have strong preferences between #2, #3, #4 but wonder about #3, why does the option still need to be prefixed with a dash if it's already inside the hashref. Moose even silently ignores if we leave out the dash, which is not helpful.
Why not a camel? Licensing issue with O'Reilly?
Yeah, I was wondering about that too. The article does not mention what sites the API is powering, right? I've never come across a single site that's powered by DDG.
While Google is doing billions upon billions per day. Which kind of makes me sad somehow.
That COBOL programmers are getting good money for what they do? (And good for you BTW).
Wow, what a thrill! I love cpanm! Cool, man, my issue (which I'll verify upon further inspection come Monday) sounds like it might be related to issue #58. I need to be a good Perl citizen and pull a copy down from github and start digging into my issue a bit. Instead, I just pushed pause on using carton in production, worked on other stuff, and just starting thinking about it again recently. I think it's promising and it'll be a very useful utility. Thank you for all you do.
i18n - internationalization?
There is no best-practice for CGI. It's a "paradigm" that doesn't support best practices. It only supports practices.
Maybe look into Test::More is_deeply() function to compare what is returned (array), and what you are expecting. Something like this: #!/usr/bin/perl use v5.16; use Test::More; is_deeply(['file1.txt', 'file2.txt'], ['file1.txt', 'file2.txt'], 'matched files are what we expect'); done_testing();
Thank you for stating the obvious: &gt; PHP is really just a wrapper for CGI I hear PHP fans talk about it like its the "new way"--sure its great that you can let the software manage the nitty-gritty for you, but it's the same nitty-gritty, folks. Servers talking to clients, clients talking to servers.
It's always better to use a smaller module than a larger one but it really shouldn't make much of a difference.
Re scoping, I meant if you don't prefix variable declarations with 'my' they're global by default. It's not a major issue, just a blemish (much like the necessity for var in JavaScript.) Dynamic scoping is a terrible idea. It allows you to do 'clever' things, yes, but in a very stupid way. It's not missed in Python. If it were there as an option people would use it and make bad libraries, so it's better that it's not there. That's a major issue actually. Perl is massively hackable (imagine writing Moose in another language for example - it wouldn't be possible, unless the language were Lisp or something), but it means the libraries are hugely inconsistent in quality and style. Libraries in Python are for the most part very predictable in design and mostly of high quality. This means it's very easy to quickly get to grips and use a library, and very rarely does a library do something that confuses you. The whole of Python is like this actually. I experienced something very confusing early on while writing in Python. A lot of the time I would write a script and run it and it would work the first time. I never experience this in Perl - too many gotchas in both the language and the libraries. Similar argument about true lexical scoping, which Python does indeed lack. Guido purposely restricted a lot of stuff that Lisp programmers might expect to be in Python. I think for Python this is a good thing (although for myself, not so much, so I rarely use Python anymore - I've moved onto Scala), for again the above reason. I guess this is one of Perl's other major problems, it allows you to do things in way too many ways. It's the mantra of the language. I don't think it's so good a thing though. I think it's also better if you're going to be 'clever' to be so using the natural extension of a small set of principles. e.g. you can do a lot of clever amazing things in Haskell, but it's based on a core set of ideas that work well together. (i.e. functional programming). Perl's ideas are just a mish-mash of what Larry Wall liked in other languages. To clarify, all the useful features Perl put into reg-exps are available in any PCRE library. And storing reg-exps in strings is more useful than reg exp literals, because reg-exp literals in Perl have bizarre, nonsensical semantics, i.e. my @matchers = (/a/, /b/, /c/) doesn't work.
I didn't think they were serious questions, I thought you were just trying to be insulting. Yes, I know what Google Analytics is - my point is you don't know who those unique visitors are. You don't know why they're learning Perl - a lot of people have to do so to maintain shitty old scripts. There haven't been that many recently. I remember a slew of posts a while back about how the Perl infrastructure (essentially CPAN) is really good and other languages are only just catching up now, but Perl was doing it from the start because Perl is better! But more the Perl is dead posts, admittedly. You get a lot of them on the Lisp forums, too, you know ... you don't tend to see them on forums for languages that are in a healthy state. How have I shown an ignorance of Perl? I worked as a Perl programmer for a few years, both a while back and more recently. The language has come on a lot in some ways - Moose especially is amazing. But to deny it has horrendous blemishes is just to be disingenuous. You must know there were a lot of bad decisions made on the way with Perl. This is why people wanted Perl 6. And look at what they *took out* of Perl!
Dude, if you aren't going to drop your "my opinions and half memories are **facts**" thing, there's no point in wasting time with you.
&gt; implying `use strict;` isn't default since `use 5.012;` ... &gt; all the useful features Perl put into reg-exps are available in any PCRE library No, JS regexes for example are terrible. Don't care to address the rest of what you're saying because there's so much incredibly wrong with what you think is fact that i'd need hours to address all of it.
I think deep down you agree with me. :-)
I made a somewhat similar Perl module for work. It uses File::Find::Rule for the heavy lifting (searching). The request was for lay persons to create a config file (text) that contains the following, one per line, separated by a colon: genericfilename:regex Once you've loaded the Perl modules, call it with: returnfiles($configfile, @dirs) This would return a hash of files found, with the 'genericfilename' as the key and an array matching that key as the value. 
Another one to add to that list of books: [Effective Perl Programming, 2nd Edition](http://www.amazon.com/Effective-Perl-Programming-Idiomatic-Development/dp/0321496949/). It's one of the best books on Perl you can read. Note: It shouldn't be your first Perl book, and maybe not even your second. It won't teach you Perl. However, after you've learned the basics (and a little more) somewhere else, Effective Perl will make you a **better** Perl programmer.
&gt; It seems like it depends on the directory I pass it in the beginning, but if changes occur to the files inside it starts failing the test. Maybe create a known directory structure as part of the setup? [File::Temp](https://metacpan.org/module/File::Temp) should help you with that
I'm not the op
You'll get recommendations for the author/module entered there. :) In order to recommend things you just hit ++ on metacpan.
This is well random
Random wasn't what was required! [Obligatory dilbert](http://dilbert.com/dyn/str_strip/000000000/00000000/0000000/000000/00000/2000/300/2318/2318.strip.gif)
[And XKCD](https://xkcd.com/221/)
Another tip: find docs for the various file test ops in `perldoc perlfunc`. 
You should link to the python version so it can be compared. :) Also, please try replacing autodie and File::Slurp with IO::All, it is reliable and you'll be surprised how much more concise your code is. :D
no, you have to login via any of facebook, twitter, google, ... first. Meh. anyways, perhaps it would improve usabililty if you change the buttons label s/Recommend/Get Recommendations/ my 2 cents.
Why not use something like `File::Temp` rather than hardcoding the `/tmp` directory? You know, for us lowly Windows users out there.
There are a lot of modules he *could* have used. Most formidably `Template::Toolkit`. Internally he is using [pandadoc](http://www.johnmacfarlane.net/pandoc/) (I'm not sure why he didn't write this in Haskell other than sheer difficulty; but, that said not relying on pandoc seems like a good idea to me. I think he'd be better off not using `/tmp` and not using `pandoc`. From a design approach he could get rid of the dependency on /tmp by, 1. write the css to the a folder `$APPROOT/default/appdefault.css`. 2. if the css isn't provided by the user via a command line argument, or available in the CWD, read from `$APPROOT/default/appdefault.css` directory Generating static HTML inside code is yuck.
Props for contributing usefully, but please, Module::Install is a very bad decision. Module::Build or EUMM are in all cases better choices.
Why is that? Module::Install works great for this. A lot of [well regarded perl modules use Module::Install (Catalyst, DBIC, etc.)](https://metacpan.org/requires/distribution/Module-Install?sort=[[2,1]]).
Yeah, I probably should use File::Temp. Thanks for the tip. I suppose I'm spoiled by having been on GNU/Linux systems long enough that I just assume there's a `/tmp` directory there. :) 
&gt; but, that said not relying on pandoc seems like a good idea to me. See [this part of the Gouda FAQ](http://www.unexpected-vortices.com/sw/gouda/faq.html#why-use-pandoc-under-the-hood-why-not-my-favorite-markdown-implementation). 
I'm just telling you it's a bad design decision unless your workload requires those things the Discount bindings, or more liberal and feature-full Text::Markdown would have been better.
&gt; Find the patches here: https://github.com/uvtc/gouda/pull/1 Thank you, though, at the moment, I'm happy and content to have it remain a single standalone script. Also, I think I left my cpan credentials in my other wallet. &gt; Not bad for a first script. Pff! Not a bad first pull request! :) 
The primary goal of Gouda is to make it as easy as possible for folks to create high-quality project docs. After having used all sorts of other doc processing tools over the years, and after having used or at least tried most of the popular markdown-processors available, Pandoc is the tops, IMO. Maybe it takes a few extra moments for the user to install, and maybe it takes a few extra jiffies to shell out to `pandoc`, but I think it's worth it. :) 
... I've done hundreds of pull requests and patches. [My CPAN (PAUSE) credentials aren't in my wallet](https://metacpan.org/author/ECARROLL). You don't need CPAN credentials to merge a github repository. And, I never broken your script up into anything -- it's still [a single script](https://github.com/EvanCarroll/gouda/blob/master/script/gouda). I just added a [build-system that tested to make sure your prereqs were there (both Perl libraries and the external bin `pandoc`)](https://github.com/EvanCarroll/gouda/blob/master/Makefile.PL); I even made you the author with your email address.. If you don't want peer review and you don't want contributions why did you post it to /r/perl? Do you think our small community here really cares about about your doc-assisting script? We're not about applied uses of the languages, we're about questions, answers, developer tools (regardless of what language they're written in), perl internals, apis, and essays. Perl, as a community, uses a doc format called POD. I'll be the first to tell you it's god awful horrible: it's actually a festering pile of shit; but, that's the old entrenched crap we use and until you get Markdown into `perldoc` your chances are nil of any perl user using `gouda` for a perl project.
&gt; &gt; &gt; Not bad for a first script. &gt; &gt; &gt; &gt; Pff! Not a bad first pull request! :) &gt; &gt; ... I've done hundreds of pull requests and patches. I was just joking, since you'd assumed that was my first Perl script. :) Perhaps humor doesn't travel as well across text as I'd hoped. &gt; If you don't want peer review and you don't want contributions why did you post it to /r/perl? Sure I'm interested in peer review and discussion. Though, as is my prerogative, I may not accept all the advice (or pull-requests) I'm offered. :) &gt; until you get Markdown into perldoc your chances are nil of any perl user using gouda for a perl project. This might be off-topic here, but my hopes are for anyone to use Gouda to document anything they'd like. It's not necessarily for Perl projects. That said, I posted it in r/perl simply because I thought the blog post might be of general interest here. 
Thanks, that's very reassuring. I just submitted some code doing just that. Unfortunately this was my first time working with the module and I didn't really have much direction.
Fwiw: Even on windows you'll be fine with /tmp, Perl will just create that dir in the root of the current active partition.
They're using it out of tradition. Remember: Popularity does not equal merit. It's just badly designed with too much magic and implicitness. For the guy making a dist with it it's all cool, but god help the dude who comes later on and doesn't have an obscure plugin installed that the original author used. (Also, your link there has a quite incomplete list.)
&gt; Re scoping, I meant if you don't prefix variable declarations with 'my' they're global by default. It's not a major issue, just a blemish (much like the necessity for var in JavaScript.) Well, assuming things are local also has its problems, especially if the language does not force pre-declaration (like in PHP). Assuming things are global but forcing pre-declaration for locals, like Perl's strict mode, is perfectly okay IMO, not blemish. Your mentioning blemish in JavaScript is because JavaScript does not use something like strict mode. But I heard ECMAScript already proposes a strict mode. &gt; Dynamic scoping is a terrible idea. It allows you to do 'clever' things, yes, but in a very stupid way. So things that allow us to do clever things are terrible ideas? How is it stupid? BTW, I think that's one of the problems in Python. Programmers are forbidden or discouraged to do clever things, just because. It's a language that does not encourage full expression of creativity. &gt; Libraries in Python are for the most part very predictable in design and mostly of high quality. Have you seen what craps (of varying level of crappiness) get registered daily to PyPI? Compared to what's uploaded to CPAN, or even RubyGems? &gt; This means it's very easy to quickly get to grips and use a library, and very rarely does a library do something that confuses you. Please use real examples instead of exchanging anecdotal evidence, as I can give you the opposite of what you experience. I have not found this to be the case at all. Most libraries in Perl can be used in 1-2 minutes by glancing at the Synopsis. &gt; my @matchers = (/a/, /b/, /c/) It should've been qr/a/, qr/b/, qr/c/. Your ignorance shows. 
&gt;Python, Ruby, and Javascript all have package managers full of fresher packages with more developers on them. How do we get cpan to be more updated and active? I would like to see the NPM repository in 2 years. Will it still be an exciting place, or everybody will have move to the next-hype-framework-place ?
You assume a lot about me that isn't true, but that's ok. Even prior to Moose and DBIx::Class, many people were using Perl for many complicated systems; that's not anything new. Once you get past the hokiness of the object creation and inheritance syntax, it really is a very flexible, expressive language. But things got stagnant, people moved on (to other languages primarily, not Moose as you claim, which from what I've seen is used extremely rarely even within shops that heavily use Perl), and the momentum was all but lost. It has improved lately, and Moose is a big step in the right direction, but it really needs a performant MOP built in to the core in order to be usable in a lot of scenarios it currently isn't. DBIx::Class prior to the mro changes is god-awful slow (especially at compile time) and they have to keep in the checks for Class::C3 to support older Perl which comes at a pretty big penalty once you scale to hundreds of schema classes (I've spent a long time profiling compile speed issues in a large codebase that heavily uses DBIx::Class, and upgrading Perl gave it a 75% reduction in compilation time due primarily to the mro change, but DBIx::Class was still more than 50% of the remaining 25%). The fact of the matter is, most of the community has moved on, most employers have moved on, and we can argue all we want about the awesome things people are doing on CPAN, but Perl has all but been written off by a lot of sectors it used to dominate. If we pretend that isn't the case because some random example like DuckDuckGo comes along, then we're doing the community a disservice. I don't know if there's even a chance for it to recover at this point, but it would take something drastic, IMO, and I don't see that coming given the track record and current state of affairs. I hope I'm wrong. I'm not writing off Perl, I'm working on a contingency plan because I see the writing on the wall. My job is still almost exclusively a Perl shop, and I don't plan on moving any time soon, but I also don't want to limit myself.
&gt; You assume a lot about me that isn't true, but that's ok. The rest of what you wrote deserves proper reading and consideration, and I'll come back to it and do that -- in the meantime: guilty as charged, sorry. I was aware it might come across that way, and couldn't put it better. Sorry about that!
&gt; The fact of the matter is, most of the community has moved on, most employers have moved on, and we can argue all we want about the awesome things people are doing on CPAN, but Perl has all but been written off by a lot of sectors it used to dominate. I don't know that that's a fact. How would we even go about measuring that? TIOBE is a joke and Google Trends doesn't provide enough context for its figures. Buzz is ephemeral and dominated by the cult of the perpetual novelty. Job trends may be more useful. Anecdotes are still not data. I welcome honest discussions based on facts, but the kinds of articles that the OP is complaining about don't work for me--not because they're critical of Perl but because they're empty of measurable facts.
Eh... Node.js was hip 2-3 years ago. Now it's becoming a solid future player. Fortune 500 companies are swapping to node.js because it scales and clusters well. It's not perfect, but it's one of the less convoluted scalability solutions. I don't think it'll necessarily overtake ruby's progress with their gems and the way the community is about keeping it going... but I don't think it'll die out quickly, either.
I used to prefer puts()'s (like in Ruby) behavior instead of say()'s. But nowadays I think it's rather moot.
&gt; I don't know that that's a fact. It's posted multiple times on reddit, so it must be.
It's his opinion you needlessly aggressive cunt.
&gt; the Perl version with its sigils, curlies, and slightly more numerous operators seems a bit easier on the eyes than the previous version [in Python]. This is a joke right? Perl is supposed to be line noise after all :) 
I still have no idea what you mean. But I don't think you want to make it clear, so whatever
Someone somewhere wanted backward compatibilty for all eternity. 
Perl does not suck in 2013, a codebase that you encountered might.
Why only 5.14? 5.16 has been out for more than half a year and 5.18 is coming soon.
No, you misread what I wrote. I wrote "Why does Perl suck in 2013", I didn't write "Why do certain Perl codebases suck in 2013". So put on your glasses son !
but Bash is backwards compatible too, and it also sucks... wait ! that's not what I wanted to say lol
If you had to choose between asking stupid questions and not asking questions at all, what would you choose?
But my question isn't stupid, it's a very smart question. &gt; If you had to choose between Perl and not writing code at all, what would you choose ? See ? It's **very** smart
Well you're in a perl subreddit so I'm guessing a large majority of us actually enjoying writing code in perl. Why do you not like it?
Dude, are you french?
No bro, what's a french ? :P
Well if you like it, then you should not comment on my thread, thanks :)
Wow do you have a PhD in English Grammar ? Or perhaps you are a natural language parser and not a human being ! See those spaces I put above ^^ ? Those were for you mister parser, I hope you cough on them ! :D
I have no idea why you're upset about well-meant advice. (Also, telling me you put them there for my sake doesn't work when you would've done that either ways.)
I'm not mad bro. I embrace your advice, I just can't be bothered to use it :)
'larger' companies have so many divisions that pinning down 'underlying architecture' is really not possible without narrowing focus. Consider a Major Bank. They have hundreds if not thousands of discrete applications, so it's likely that functions which have been around a while would certainly be written in Perl. I know at the Major Bank I was with for a while, on the project I worked on, we used Perl everywhere we didn't need to optimize with C for performance. ( We did a *lot* of volume )
Probably far from exhaustive: [Companies that use Perl!](https://www.socialtext.net/perl5/Companies%20using%20Perl)
It appears to be a pure-perl module, so yes, in theory you could unpack it and load it without running make. Note that you'd need to already have all the required modules listed in Makefile.PL or the module won't work. If you unpack it into ~/Nagios-Plugin-0.36/, and your script is in ~/script, then you could do: mkdir ~/script/lib cp -R ~/Nagios-Plugin-0.36/lib/ ~/script/lib/ And then the script snippet you posted above should be able to load the module. Good luck!
Google is your friend...
That's fair. I don't have hard facts. I am basing this on my own experience searching for Perl jobs (there aren't many good ones) and anecdotal evidence that most of my former Perl-wielding coworkers are no longer using Perl. My experiences have been shared by many others, so while it may be anecdotal, it's a lot of anecdote to ignore while you hide behind the lack of hard data (that would be next to impossible to gather).
I'm not suggesting to ignore anecdotes, but if we claim to be interested in truth and knowledge, I think we have to treat anecdotes with health suspicion and not elevate them above what they provide. If I went by my current work experience alone, I'd say that it's easy to hire great Perl programmers (it takes some time, but we have some great developers) and 25% of them are women.
Are you drunk? (Or, were you drunk at the time?) Because you sound drunk to me.
Morgan Stanley uses Perl EVERYWHERE. They joke that even the cleaning crew knows Perl
I know, but I'd rather hear you read it to me. Give me your best Larry Wall impression ;-)
BofA, JPMorgan Chase, AIG, Morgan Stanley (first hand knowledge as a UNIX Infrastructure engineer) Goldman Sachs, Knight Capital, NYSE, Bloomberg also have a lot of Perl, though Bloomberg is also a C shop too. I just know this because I know guys that work there. Most financial companies have so much Perl that they will never be completely off of it. 
Any company that is using an LSB-compliant Linux distribution. 
Summary: Perl5 has a marketing problem, in that people think the language is "dead" because it hasn't had a major version number change in a while. Ovid first suggests going to Perl7. However, that sorta implies that Perl6 is a failure, whereas it's really its own thing branching off of Perl5. An interesting suggestion later in the comments is to move to year-based version numbering, e.g. Perl 2013.1. A similar system is used by Mandriva and Gentoo.
I wouldn't want to work with (or for) anyone who would or wouldn't use Perl 5 primarily because of the version number.
Quoting from what I commented at the Perl Weekly's Google+ post: I'll have to agree with the opinion of renaming one of the two languages to something else such as Camelia. Otherwise, we're between two bad choices: (1) Renaming Perl 5 to Perl 7 and watch Perl 6 getting shadowed forever. (2) Leaving things as they are and watch Perl 5 still being perceived as a dead language from people outside the Perl community. There have been many discussions on whether Perl 6 was eventually the reason for Perl 5's status decline, along with the rise of Python, but that's a whole different story... 
&gt; ... but that's a whole different story... Yes, but it's also the *relevant* story.
Booking.com, we use it for everything.
petfinder.com
My sentiments exactly.
Citation/source?
Careful. Wandering awfully close to something like RPG IV or Cobol 85. :)
If Perl had followed a more sane numbering scheme then 5.005 would have been 6.0, 5.10 would have been 7.00 and perl 8.00 with the release of 5.16. 
Fortran 4 programmers unite!
But it is not unreasonable for someone to note the existence of Perl 6 and reach the preliminary conclusion that he or she should postpone learning Perl until version 6 is ready so that his or her time is not wasted learning a deprecated language (namely, Perl 5). That might not be correct, but it is an understandable first impression, and people don't have the time or inclination to thoroughly research everything that crosses their path. Good marketing is not just about making your project look shiny, it is about effectively communicating to people what you are about in the small time that you have their attention.
I agree with you that there is a marketing problem, but I think that the real problem is not so much that Perl 5's version hasn't changed but rather that the existence of Perl 6 strongly implies that Perl 5 is deprecated (even if that is not the case) and why would anyone want to waste their time learning a deprecated language? For this reason, I think that renaming Perl 5 to Perl 7 is a good idea because it communicates that Perl 6 is no longer considere to be the "modern" version of Perl. The fact that Perl 6 is then shadowed is a feature rather than a bug because it is no longer competing for the same audience as Perl 5. At that point Perl 6 can be renamed to something else and then hopefully there will not be so much confusion.
Here's what I would love to happen: 1. Perl 6 gets renamed to something else, possibly not even Perl related 2. The next version of Perl 5 that has a really spicy/compatibility breaking feature gets to be the first Perl 7. 3. Perl 5 Porters adopts the Google Chrome-style "increment per the schedule, not per the architecture" style of version numbering 4. Version numbers are "obviated" in the context of informing people what generation of architecture they are on 5. Perl's with absurdly high version numbers (Perl 23) will clearly be better than Perl's with low version numbers, incentivizing people to upgrade more frequently (aka wake up call, this ship is moving and moving fast)
&gt; ... people don't have the time or inclination to thoroughly research everything that crosses their path. Sure, but I choose not to work with those people.
That's pretty much exactly not what I said at all. I choose not to work with people who make important decisions based solely on superficial criteria.
What problems? I really cannot see why you would assume things are global by default. Decent programmers always try to minimise the amount of global mutable state. I think it's fairly obvious by 'clever' I actually meant what a bad programmer considers 'clever' because it helps him get around what was initially a poor design. Show me one situation in which dynamic variables is used to cleanly solve some problem that could not have been solved more cleanly with better techniques, such as function composition, correct separation of concerns and modularity, or well-thought-out composition of objects. No, in Python programmers are restricted from doing 'clever' things and forced to program in a particular style. This style does allow a lot of genuine cleverness and good design within it, however. You might as well say the Renaissance poets were 'forced' into using iambic pentameter and a particular rhyme scheme when they adopted the constraints of the sonnet. You can be extremely creative within the constraints Python requires - and the core set of features it gives you are much, much better designed than the ugly Perl equivalents. Qr// is essentially just quoting a string and proves my point. a) The reg-ex literals are not really literals in the sense of any other literal in the language, as they require special syntax to hold in data structures. and b) Perl is full of bizarre, silly, unpredictable things. Why should I have to quote my reg-ex literals? I've been told they're literals. Also (as far as I'm aware, but maybe Perl has some more bizarre syntax for this) you can't use qr// to quote substitutions. If you wanted a data set full of reg-ex substitutions you're basically screwed as Perl offers no support for that.
Nobody can know it, I don't pretend to know better than you, sorry. I am just a huge CPAN admirer, so I feel a bit bad with NPM. But, maybe the-new-way is Github-for-all, so this is *the* real repository. We just need a solid directory to guide ourselves inside, or a namespace system per-language ?
&gt; That's pretty much exactly not what I said at all. Actually it is what you said in your earlier reply, given the quote from my post that you chose to respond to and how you responded to it, even if that had not been what you were *intending* to say. &gt; I choose not to work with people who make important decisions based solely on superficial criteria. Fair point; I wasn't really disagreeing with your original comment so far as pointing out why people might start with a not wholly unreasonable bias against learning Perl 5 that derives from the version number. It was more intended as a side point then a criticism.
Perl 6 should change its name, and Perl 5 should become Perl 7 after that (but not immediatly after). Changing name is not easy, but it is doable and it can be a success, as it has been demonstrated by Racket.
Well... there's [Padre](http://padre.perlide.org/). It has the bonus of itself being written in Perl. Back in the early 2000s on Windows I used [Open Perl IDE](http://open-perl-ide.sourceforge.net/). Nowadays I mostly just use vim.
These days I'm not entirely opposed to renaming Perl 6, if we can find a good name for it. So far I haven't seen a good suggestion. (And no, 'Perl++', 'P++', 'Camelia', 'Rakudo' aren't good names for Perl 6,).
I use Sublime Text. It gives you automatic indenting, brace matching, and some form of code completion. Also wrote a plugin for it to help find your way in the code. https://github.com/semuel/Sublime-Text-Perl-Subs 
Sublime text is awesome If anyone is going to try it get the package manager: http://wbond.net/sublime_packages/package_control Also worth mentioning is /r/sublimetext which has a load of useful posts
Emacs with [cperl-mode](http://www.emacswiki.org/emacs/CPerlMode)!! - Automatic indenting: yep. - Brace matching: ditto. - Code completion: I personally feel that [hippie-expand](http://emacswiki.org/emacs/HippieExpand) is sufficient for my needs. But if you want to get more fancy, there's [auto-complete](http://emacswiki.org/emacs/AutoComplete) or [perl-completion](http://www.emacswiki.org/emacs/PerlCompletion) ([screencast,](http://vimeo.com/4739908) I've never tried any of those, so can't comment on that) Other niceties: - Jump around between function definitions with [imenu](http://emacswiki.org/emacs/ImenuMode), or good old etags/ctags. - Integration with perldoc, debugger, and etags (if you don't want generate TAGS by hands) - Regexp beautifier. - [regex-tools](https://github.com/jwiegley/regex-tool) to debug, well regexp. Here's a short [blog post](http://bc.tech.coop/blog/071103.html) by Bill Clementson describing regex-tool. - /u/shmuelfomberg mentions his plugin for Sublime Text that can show which function are you on. Emacs has this by default, just turn on `M-x which-function-mode`. - Editing related functions: - jump to beginning/end of a function. - mark a function - indent an expression - and most important of all: `self-insert`. EDIT: add links.
And plain old [etags](https://www.gnu.org/software/emacs/manual/html_node/emacs/Create-Tags-Table.html). This is the fastest way to navigate in a large code body.
vim with syntax highlighting? Plus a second shell to run in?
This looks great - I've downloaded it and am trying your plugin currently. It looks like it's not a free application - That kinda sucks, but I'll use it for a few weeks and see if it suits me!
In my experience, you don't need much of an “IDE” to program Perl. My setup consists of a few shells for running code and reading documentation, plus the Kate editor (pretty simplistic, but has good syntax highlighting). Kate also supports autoindent, auto closing braces, primitive text completition, and good search &amp; replace. You could write macros (in javascript), but I don't usually need them. It's invaluable for CGI programming that I can directly edit files over FTP. I must admit that I once tried Emacs/cperl, which was *heavenly*. Then again, you would have to get used to Emacs. Either way, there is the saying that *Unix is your IDE*. I just use Kate for the actual editing.
There is a Perl plugin for Eclipse called Epic which was quite good the last time I used it
I've used emacs since ~1991. Love it. Replaced it with sublime text late last year (I feel kinda cheap and dirty, but I really love ST) The learning curve is brutally steep in emacs, but really rewarding.
Checkout Eclipse with EPIC 
I use komodo from active state, it costs money but its awesome. 
Just be advised that Eclipse is so slow that it takes more time to start than Windows 8 does under virtualization. No, I'm not making this up.
No, he said he wants a *good* IDE.
Disclaimer: I detest Eclipse. It's obese and entropic (thermodynamic entropy: a measure of the amount of energy in a physical system that cannot be used to do work). It eclipses a coder's understanding with its moon-like bloat. I much prefer a good editor (with syntax-highlighting, highlight-all-occurrences, and easy access to a terminal) to any sort of IDE. Some good editors have been mentioned. I like Notepad++, Geany, Gedit, even Komodo (http://www.activestate.com/komodo-edit/downloads) despite its flaws. 
Just wanted to add links for each of these (please correct me if I'm wrong): * [vim-perl](https://github.com/vim-perl/vim-perl) * [perlomni](https://github.com/c9s/perlomni.vim) * [syntastic](https://github.com/scrooloose/syntastic) * [ack.vim](https://github.com/mileszs/ack.vim) * [nerdtree](https://github.com/scrooloose/nerdtree) * [easytags](http://peterodding.com/code/vim/easytags)
[perl-support.vim](http://www.vim.org/scripts/script.php?script_id=556) he said in an emacs thread, thereby inciting a [religious war.](http://michael-prokop.at/computer/images/vi-emacs-final.png)
Nah, vim is ok in my book. I use it myself to edit my `~/.emacs` whenever my configs are acting up.
I used Notepad++ for years (still do as a notepad replacement, actually), and I tried Padre for a few months, but a few days with Sublime was enough for me to know I'll be using it for a long time to come.
I don't know if it makes sense to give examples here because the process is random by nature; moreover, I am a Spanish speaker, so I use it to process text in Spanish. But I'll see if I can translate some lines: . has entered the truth, which is a magnificent absence . I was in the belly of a painful situation . Oh, the party in your mouth . when the tongue (was) imitating the shoot . so the light turned the corner under pressure . same one from the Department of Amazement . explain the love or mask . We still don't know the time of emotions brought up by the lights of next weeks (and son on) 
The trial is unlimited but the license cost is also extremely low. I strongly urge you to buy it after you've used it for a while, it's the best editor I've ever used for development (even better than Vim).
I would really like if things stay as they are. New people will be attracted to Perl5 when some new features arrive, not if some numbers change. 
Are there in French?
Wow thanks, I didn't know that. Some programming languages are a little French though by this standard :P
+ ido-mode + yasnippet + http://damien.krotkine.com/2011/05/27/perlbrew-emacs-flymake.html
Yeah, was going to suggest Padre. Has plenty of Perl-specific functionality in it while a lot of other IDE's seem more designed for other languages. 
At the moment I use Geany, which is ... ok. Nothing special, but it works for me and has the three features you listed (depending exactly what you mean by code completion) I tried the EPIC plugin for Eclipse but I'm not a fan of Eclipse at the best of times, and Padre, and they both had advantages over Geany but also had little annoyances that I couldn't adapt to quickly enough, so I went back to Geany. Ultimately choice of IDE is as personal as choice of underwear -- just go with what gives you the right balance of freedom and support, and feels comfortable, and don't be afraid to try a few options before settling. You can always dabble with thongs, or Emacs, another time if you're not content with the environment you end up settling on.
The extra features in the paid version are pretty useful. I also got the devkit, mainly for perlapp which is awesome.
I tried Eclipse, but it won't let you specify what language a file is (e.g. Perl, XML, Python) except by file extension. Since the scripts on the code I maintain seldom have file extensions, this was a deal-breaker for me.
I agree with this for editing. But sometimes I find and IDE very helpful for debugging.
Yeah, I don't want to work with those people either, but unfortunately I think we need some of them if Perl is going to continue to stay relevant. Otherwise it will just be an increasingly isolated group of people "in the know". It's sad that we need to do dumb marketing, but simply declaring that dumb marketing is dumb doesn't solve any underlying problem.
I just tried Sublime Text, but I can't take a syntax highlighter that shows everything from the `=~` operator till the end of the file as a single color, seriously.
&gt; ... simply declaring that dumb marketing is dumb doesn't solve any underlying problem. I don't understand how changing a version number does anything to reach the people that: * the Perl community needs to reach * would be convinced by something substantive Perl's in this mess because of a decade-plus of press release stunts that don't have anything behind them (Perl 6, Ponie, Rakudo Star). There are so many better things to brag about--modern Perl, regular releases, the continued growth of the CPAN ecosystem, Mooses--that changing one number and bragging about that seems so petty and small, like begging the popular kids to invite you to a party you're not going to have a good time at anyway because they're only doing it to humor you. Maybe I'm wrong--maybe this is what Perl 5 needs to shake off the shadow of Perl 6. (Assuming that Perl 5 even needs to do that. I could be wrong about that too.)
Try [UltraEdit](http://www.ultraedit.com/downloads.html), it is really good and it also gives you options like column selection, editing files directly on the server. One of the features that I really like is formatting the code. It is really simple and makes sense to me. One of the huge plus is that it works on mac and does not consume all the memory when it is running!
Yeah, I'm not necessarily advocating that Perl 5.18 suddenly be released as Perl 7. However, I do think releasing a Perl 7 that is an evolution of Perl 5 would be good. The fact that Larry has said this can never happen is what really ticks me off. I think this creates a lot of stop energy. We can't take Perl 5 and make backwards incompatible changes not just because people want back-compat, but also because we don't even have a way to name a release with some incompatibilities. So it's Perl 5 forever, and Perl 5 is backwards compatible to an extreme.
I used to think that too, but Jesse's "A Plan for 5.16 and Beyond" changed my mind. It's kinda like I used to needle Schwern for supporting ancient code with MakeMaker: "So you're releasing new code for people who don't update their code to not update to?"
FuzzyFinderTextMate is also worth having, but it's a bastard to install.
Good points. You're right.
Komodo Edit, will check perl code for syntax errors as you type, for me who makes a lot of typos it is invaluable. You need to add a few of the plugins to make it truly useful. I also have some custom command scripts to launch the perl debugger etc.
I haven't noticed this, which color scheme are you doing? If someone did a half assed job, it could cause this I assume.
A lot of stuff can be scripted back in though.
Make an end run. Name it "Perl YYYY.MM". So this month if there was a release it would be "Perl 2013.02". Takes the numbering scheme totally out of sequential versioning (5,6,7, etc.) and does an end run around Perl 6. This also takes away the "Perl hasn't released a major version" bunk. 
Tooting my own horn here, but please try out [PerlySense](https://metacpan.org/module/Devel::PerlySense#DESCRIPTION). It provides lots of things on top of cperl-mode and smooths out a few annoying things (e.g. flymake from the correct directory, with the correct @INC) that don't quite work out-of-the-box. A few highlights: * Syntax and Perl::Critic checks with source highlighting * Navigate the source tree * Find stuff using Ack. Subs, method callers, free text. * Run tests (and programs) easily inside emacs * Highlight code coverage in the source (if you run Devel::Cover) 
&gt; What is it if not a literal? As I said, // (m//) is a regex matching operation, you use it to match a string against a regex. qr// is a regex literal qoute operator, you use it to create a regexp object. Is that so hard to understand? Perl's doomed then. &gt; Don't need to? What if I follow a data directed style of programming and want to extract my matcher and substitutions from data structures? In Perl I can't, because of the queer way regexes are implemented. You argued about "bizzare regex syntax", now you complain about the "queer regex implementation". Also, some people would ask if they don't know how to do things. You just declared that you can't, so I can't help you there. 
This is what I still use. GNU Emacs with cperl-mode. Thanks for an informative post! Been reliable since 1996 for me.
&gt;Oh, the party in your mouth Definitely going to use that one. Thanks.
I used ST2 after being a Vim user for years. It is very good and I even purchased a licence. With the Vintage plugin you get the best to both worlds. However I recently went back to Vim as I found it more comfortable and the default colour scheme is superior to anything in ST2. The big thing I miss from ST2 now is auto complete of variable names and the tab management. I use Vim with gnome terminal tabs as an alternative. I just use ST2 for plaintext and Markdown notes. Random ST2 tips: * look up the tuts+ videos - some amazing plugins * monokai and solarize (see github) are good colour schemes for Perl * buy a license if you really like it - its not that expensive. * install the package installer plugin and experiment 
Doesn't happen on my machine. (Windows7 and MacOS) weird. Try to reinstall?
Nice idea. In this way we can convey the message to the world that Perl is not dead. Either we can go for Perl 7 or can agree on yearly releases.
The 100th problem is the bruised forehead from the facepalm when he realized he coulda done that last month...
Padre is nice. Lightweight, a simple and clean interface, it does what it needs to (at least for me).
If you're going to use flymake, I'd suggest my fork which fixes a few bugs, and adds perlbrew support out of the box, I'd also suggest taking a look at my other flymake modules: * https://github.com/illusori/emacs-flymake - flymake with patches. * https://github.com/illusori/emacs-flymake-cursor - shows the flymake error for the current line in the minibuffer. * https://github.com/illusori/emacs-flymake-perlcritic - hooks up Perl::Critic so you get static analysis/linting as well as syntax error checking. If you set your package manager to look at http://marmalade-repo.org/ then you can install them automatically from there. :)
Instead of FuzzyFinderTextMate I'm using [CommandT](https://github.com/wincent/Command-T) it does the same but there is no problem to install and in MacVim it is possible to configure to use as Command-T, instead of Control-T (=
After all these years and he's still funny. Thats cool!
It's the portable version, thus, no install.
It's independent of the color scheme, which only changes the color. It does depend on the perl code, though. This is the line that trips it up: $qpath = $path =~ / / ? qq("$path") : $path; (This snippet puts quotes around the path if it contains spaces.) If I put anything in front of the "`/ /`", then it doesn't happen. Also notice that the "`=`" is colored differently from the "`~`". Which would indicate that the syntax highlighter doesn't recognize "`=~`" as a single operator. 
Poor comic, just a repeat from a meme from [1997](http://www.codinghorror.com/blog/2008/06/regular-expressions-now-you-have-two-problems.html), it seems.
Always look on the bright side of Perl.
Wow. I just pasted that and tested it and even took a screenshot and completely didn't notice until the last second. I'm just using something with text coloring, no background highlight, so I did not even notice it. This might inspire me to learn the syntax highlighting code....
Hmm, that's interesting. It's not exactly the interface I prefer, but maybe it's close enough. Thanks for the link :)
Well it's that plus a reference to a Jay-Z song. I'm sure the overlap between people who know Jay-Z and program Perl is super low.
I think you underestimate the ability of programmers to follow popular culture.
s/super low/OVER 9000/; 
I think Perl 6, in some ways despite any technicalities, is a failure. However unfairly it has a lot of emotional baggage attached to it and has left people wanting. Moving past it sounds like a good idea. It can always be renamed to something else.
You live a sad life then.
Perl 5 *has* yearly major releases.
I live a sad life because Perl programmers don't listen to Jay-Z?
Sweeping statements like this are not helpful.
jay --help should recommend the -j -w -z flags.
What does that make me, a unicorn?
We should come up with some project that intersects rap or hip-hop and Perl.
 my $wu = Music::HipHop::Wu-&gt;new; say "Hey!"; say "Ho!"; say $wu-&gt;man('tical'); Outputs Hey! Ho! Blazin
I don't mean to be rude by asking the following, so please don't take it that way. I am genuinely curious why they hired you if this Perl application is their main product and you state that you haven't worked with Perl. Again, I'm not being rude, I'm just really curious how you came to be in this situation since it seems like the primary coder of a Perl app not knowing Perl would be a fairly important issue. I suppose what I'm asking is, did they not mention it until you where hired, or did they say so and you feel confident enough to tackle the role anyway? Kudos to you either way, I'm just curious.
I have worked there. You can quote me.
I am confident enough that I can handle the job. A good software engineer isn't depending on one or a few languages. He should be able to understand the underlying principles and use a programming language as a tool. I've worked with quite a lot of languages before and I know I can adapt to most languages in a few days, or perhaps a few weeks. I was recommended by a guy who has seen me tackle projects like this before, so they invited me and this is what I told them as well. 
to make sure I'm not missing something ... it's basically saying regex's are hard to get right, so the 99 original + the 1 regex not working = 100, right?
I don't know, I think the question is a bad one. I feel each tool can give you a unique benefit, depending how you use it. I like Python personally.
Lojban.