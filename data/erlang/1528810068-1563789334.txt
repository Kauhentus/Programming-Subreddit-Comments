Data storage on the blockchain is not feasible, unless you’re storing very little information. The guys working on IPFS and similar have explained this multiple times. You need central storage otherwise the costs explode. This company looks like another scam/people who don’t know what they’re doing. Best wishes.
Interesting! I am curious to know what you think about Filecoin then? As they rasied a hell of a lot of money and seem to really have something interesting set out?
Yeah, a lot of people have raised a lot of money and made big promises. Honest companies build products, scam companies make a nice website, pretend to work on the”project” for a certain time and then quit with the ICO money. Filecoin is another thing that cannot work.
Kuberneedy
Filecoin uses IPFS for the actual files and I believe so does STORJ. The blockchain is an extension/addition on top.
Hmm, I am going to bring this up the client I am working with and see what they say actually...you got me thinking!
Yeah I guess, but sometimes (and as I presume with Filecoin) the money is so large, it's kind of difficult for it to be a scam. Although I am aware they don't have a fully functioning product just yet lol. My client in Berlin have done it the other way around...built out a product which the founders have worked on themselves for the past 10months and then raised some okay funding for R&amp;D and engineering. I am no expert anyway - but I know that us here at Blockchain Works are really cautious about who we work with. Feel free to sign up and check the full JD and company details anyway and do a bit more deep diving yourself :)
&gt; the money is so large, it's kind of difficult for it to be a scam. Just looking at the amount money raised by many really obvious scams that part can't be right.
I'm not sure I understand. Is your client Arweave, and are you a recruiter? What part would you bring up, hoping for which kind of answer. I must admit I'm slightly confused.
Sorry yes, I thought that was obvious with the link to Functional Works above! I just meant I am curious to learn more about their platform, so was stating that I will ask them a few more questions about the points you've raised, that's all. Well I can understand the hesitation, irregardless of us here at Functional Works being pretty different to most out there! I am more than happy to jump on skype or something if there is interest and you want to run through a few things a little deeper? Feel free to ping me a direct message or something.
Sounds legit, thanks.
I love the illustrations :)
Thanks! They're from Scott Wlaschin's blog post [Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)
It makes you to solve things in functional manner while not being Haskell. Overall, it gave me a great learning experience.
Datastorage on blockchain may not be feasible, but you could use it to store contract who has the responsibility to store you data. See sia: [https://sia.tech/](https://sia.tech/) Useful project, product works (although when I tried it \~6months ago it was minimal in terms of usefulness)
So what happens if they lose the data? They have to pay a couple of cents back?
Not actually pay back, they just won't get fully paid. Renter can't be scammed because money was put on the blockchain so it's not up to a user to decide if he will pay but rather consensus based on the performance on the host. Can't remember the details since it was a long time I researched that. Slightly irrelevant: Data is also redundantly uploaded to multiple hosts so you don't need to be afraid of somebody disappearing. Ps. Oh my cake day!
Happy cake day ))
Lists are a chain of items composed of a value and a pointer to anoter list. Yes it is implemented at the VM level. I do not see the problem with pointers to immutable data :)
I see, so it's implemented at the VM level. Then when the list changes, it becomes a new list of new/reused pointers?
It does not necessarily copy the whole list. For example if a new item.is added to the head of the list, the "new" list is just a pointer to the new item which is linked to the item that used to v be first, and the old list still just points to that ild first item. Similar when the first item (head) is popped off. There are lots of optimizations available for sharing references to data wheb data is immutable. It ia not just lista either, even trees have all sorts of fun attributes when immutable. There is an interesting and fairly large body of literatue on functional data structures which google makes easy to find :)
The list never changes. You just create new lists with its elements, use a sub-list or adding on top of the list by referencing a new list in a new variable. The lists.erl module is a collection of functions to work with erlang lists but does not contain the implementation of lists.
If you want to understand how to design data structures in a functional language then look at the books: https://mitpress.mit.edu/sites/default/files/sicp/index.html http://www.htdp.org In short, one of the ways to define linked list is through tuples: https://pastebin.com/3Ud94jnn But as already mentioned erlang list internals is written on C. 
Thank you!
Thank you!
Thank you!
https://scotthelme.co.uk/are-you-ready-for-the-symantec-distrust/ They should move to LetsEncrypt. Open source, free, easy.
I notified them of this problem 5 days ago ( https://twitter.com/minaguib/status/1009258068411076609 )
You can also get Erlang downloads from Erlang Solutions: [https://www.erlang-solutions.com/resources/download.html](https://www.erlang-solutions.com/resources/download.html)
As a Canadian, are you guys planning on recording this meet up? :) that talk sounds quite interesting!
weird
\~ Save the tuple calls! \~ With the latest release of Erlang (R21) tuple calls are opt-in. What that means is you have to use a compiler flag to make them usable. [https://www.reddit.com/r/erlang/comments/8y8ump/erlang\_tuple\_calls\_oop\_principles\_in\_a\_functional/](https://www.reddit.com/r/erlang/comments/8y8ump/erlang_tuple_calls_oop_principles_in_a_functional/)
It sounds like your client read a blog post and got excited, but erlang shouldn't actually be a requirement. If they weren't able to give you better direction on the whys and hows, thats a red flag. Are they going to pay you hourly to struggle through all this? There may be better ways to go about this like exporting batches from the mail server. 
Yup, I've thought about the red flag part but I got excited with the client as it's a new language a new challenge. Even if I don't take this job I would like to fulfill my eagerness as I develop at least something in Erlang even if that would be in my spare time. Anyway thanks for your reply, any suggestion to continue/start my learning curve? Like any posts in this subreddit or any other books? or I should be able to learn the basics from the sources which I've got? 
Well, I'm not sure how much time you have but I would recommend you to read [Erlang and OTP in Action](https://www.manning.com/books/erlang-and-otp-in-action). It is an intermediate level book. It shows how you can architect, build, release, monitor an OTP application(in the book the example is distributed cache server).
“Sophia as a smart contract language”... so they learnt nothing from ethereum, they want to replicate the solidity comedy. Good luck, take the ICO money and run ;)
Care to elaborate on Ethereum?
You don’t need to reinvent the wheel https://www.reddit.com/r/ethereum/comments/72096k/is_solidity_a_great_language_what_does_the/
aeternity is EVM/Solidity compatible!
Check out rebar3\_osv, a rebar plugin to turn an Erlang/OTP application into an OSv (Unikernel) image. See [https://github.com/OtoloNetworks/rebar3\_osv](https://github.com/OtoloNetworks/rebar3_osv)
[worker\_pool](https://hex.pm/packages/worker_pool) maintainer here, from the [x-inaka](http://github.com/inaka) community. Really happy to see your renewed interest in our library :) Just a tiny correction: `worker_pool` is not maintained by Erlang Solutions. It's actively maintained by the x-inaka community. Erlang Solutions provided some great contributions lately and we're super-thankful for those, though.
If XMPP is a requirement, you could build your entire application directly on top of ejabberd or mongooseim (a commercially supported fork of ejabberd focused in part on extensibility). Or you could use one of the xmpp clients and talk to an xmpp installation: https://hex.pm/packages?_utf8=✓&amp;search=xmpp&amp;sort=recent_downloads Or if xmpp is not a requirement and you just want a chat stream and wsbsockets are ok for you then you coupd build a Phoenix Framework app and use its Phoenix Presence features to relay updates via a chat channel to all connected users. It is quite scalable and if xmpp is not a requirement coupd be easiest for you and your users.
What's wrong with mnesia? Simple curiosity.
Nothing at all. In fact, it remains a possibility, I just don't know the specifics of how I would integrate this with other existing data storage. JSON of CouchDB seemed more conservative in that regard, although I would prefer to look at more Erlang code.
XMPP is not a requirement. This is just a kind of proof of concept-type of side project thing on which I'm brainstorming. I just read about ejabberd as good for chat backends. Although XMPP might be the wrong choice, if I end up needing message receipts (https://xmpp.org/extensions/xep-0184.html), which would be excellent for this. What I need to figure out first, I guess, is what kind of clients it will have. I need mobile devices to be able to use an application with a specific type of graphical UI, so I am unsure if this would be best achieved via browser. So I've tried weighing out something like NativeScript versus a native Android app. I need these applications to really just update certain data forms to a server within certain intervals, where, if an interval is missed, alarm signals are sent across all devices accessing the server. Anyway, thanks for the help. Lots of unknowns here for now.
Translating a record to json is super easy. 
Think it's better to stick with Mnesia? I'm open to various suggestions, just planning this. I have the UI planned out in sort of OOP terms, in which it will likely have to be implemented for mobile as either Java, JavaScript, or Kotlin or something. Otherwise I don't have many strict requirements. This is just a sort of personal project for now, etc. Server-side I am looking at Erlang, or Go or something that would be nice for handling concurrency. And partly I probably just think Erlang is interesting.
I feel like there should be a way to get the byte_size of an IO list without first turning it into a binary, but I have no idea how. This is a question that has been on my mind, but I noticed it in your code (in condor_packet:encode/2) and I couldn't give a better way of doing it.
Oh Ok, I didn't even consider that aspect of it. Doesn't gen_tcp take in IO Lists?
Returning iolist in send would be nice, even if initially it does flatten it to binary. Just for convince. Also it would be nice to also support line based protocols, like SMTP, irc, http, prometheus metrics, logs streaming, where new lines (with cr or without) are used to delimete packets, and to strip these whitaspace at the end before calling handle_packet. On the API side, ip address opt should allow listening on multiple ipv4/IPv6 addresses, and by default listen on ["::0"]. Also beyond init, I think first packet should be treated specially, or even before first packet, i.e. so behaviour can log connection attempt/establishment itself, increment external metrics, perform reverse DNS lookup, or do simple initial ACL check.
What is the size of the data? 
Not sure, but the individual entries wouldn't be large. It would just have multiple devices updating it 24/7. It would be handling health information, so security and reliability is a big concern.
Thanks for sharing your ideas. I will consider them for the next version of Condor.
How does this compare with [Ranch](https://github.com/ninenines/ranch)?
Hello Robert!
Hello Joe! 
For a moment I thought he had died! 
Hey, Findlaech, just a quick heads-up: **prefered** is actually spelled **preferred**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
Ok what is aeternity? I clicked three links and read the article and still have zero clue how erlang is related to blockchain.
Check out the Nerves Project.
Wireless sensor network
Thanks for the info.
[https://github.com/sinasamavati/condor/commit/b6a7afef18752a841e252fb0ac99cfebd94be60d](https://github.com/sinasamavati/condor/commit/b6a7afef18752a841e252fb0ac99cfebd94be60d) send\_and\_stop is added. Packet len is now limited to two bytes.
I too steered away from gen_event and went with gen_server for most activities one might use for event processing. I think gen_event was intended for incredibly lightweight usage. 
I'm afraid I must disappoint you there, still alive and kicking. And programming blockchains.
Simple, the aeternity system is implemented in erlang.
Props to you for taking your time to make this, but this is an awful shitpost so I unfortunately have to downvote it
Downvoting things is the cancer thats killing the world so I have to upvote it and would otherwise leave it be if it wasn’t my thing. 🤷‍♂️
What is a shitpost exactly?
1. I do not like PBKDF2 and I will always use `bcrypt` unless forced otherwise (NIST compliance). Maybe in near future Argon2 will jump from second to first choice. For now I still trust bcrypt more. 2. AES-CTR? Why no AEAD mode? In general why AES, which is known as a hard in implementation without CPU support. Instead I would suggest you to use ChaCha20-Poly1305 (not block, but AES-CTR is more stream than the block cipher). Nice idea, but for me there are some questionable choices about algorithm choices. 
no wonder people moved onto Elixir... no replies in a whole day, no libraries to speak of
Because inside a string, a backslash escapes the following character, and thus `\(` turns into `(` - but you actually need the backslash in the string for the regex to work! So you need to escape the backslash itself, by typing a double backslash: 3&gt; {match, Strings} = re:run("()", "(\\(\\))", [global, {capture, first, list}]). {match,[["()"]]} This gets clearer if you try printing each character in the string on its own line: 4&gt; lists:foreach(fun(C) -&gt; io:format("'~s'~n", [[C]]) end, "(\(\))"). '(' '(' ')' ')' ok 5&gt; lists:foreach(fun(C) -&gt; io:format("'~s'~n", [[C]]) end, "(\\(\\))"). '(' '\' '(' '\' ')' ')' ok 
So the issue is that I am not writing a regex per se. I am writing a string which will be parsed into a regex. That means I need to first follow the string rules for escaping and then follow the regex rules. Is that correct?
yep :)
Is a single process going to be running forever? What happens when that contract fails? What you're leaning towards here is in-memory replication which guarantees that a single process failing will never lose data that isn't available to another process, but... that's a really hard guarantee to accomplish. Remember: Erlang processes should crash early and crash often. Supervisors and similar recovery mechanisms will allow the process to restart and continue function, but where did the data go? Nowhere, unless someone persisted it.
Ohh, you got me wrong. I was talking about the immutable data structures which erlang uses likes singly linked list, tuples. The are also called [persisted data structures!](https://en.wikipedia.org/wiki/Persistent_data_structure). They have nothing to do with persisting it on db.
Ah, my misunderstanding. Persis*tent* as opposed to persis*ted*. Immutable data structures have a couple of advantages. First, in the case of tuples, it means *contents are identity*. A tuple with different contents isn't the same tuple. That's generally what tuples *mean*. Also, because tuples are immutable, their size is known at construction time (and often inferrable at compile time) which makes allocation fast and cheap. More generally, immutability simplifies the requirements for understanding the program. Inputs result in outputs, but the inputs don't actually change.
Even in a single-threaded application, there are benefits to immutability. While immutability increases your overall memory footprint and object allocation, *it simplifies reasoning about mutations*. Even though processes have their own memory space, mutations are happening asynchronously in response to messages. Depending on the sequence of messages, mutations could happen in different ways. Having immutable datastructures make it easier to reason about how the data changes. It also makes it easier for the Beam VM to understand how to allocate memory, because it knows at runtime (at the latest) exactly how much memory to allocate, and doesn't need to worry about fragmenting a structure across memory.
Mutations happen in an orderly fashion, certainly, but the actual *order* of mutations is unknown to the individual process at development time. If my process responds one way to message X, and a different way to message Y, receiving a series of messages XXY versus XYX may have different results on the internal state of my process.
I don't think this has much to do with immutable data structures. Final results will be same, if you guarantee changes in orderly fashion. 
Order absolutely matters. As a simple illustration- `5 * 3 + 1` is wildly different from `5 * 1 + 3`. While immutable data structures don't mean your processes aren't stateful, what it does mean is that each received message has a very clear, side-effect-free impact on the process's state. Again, it's not so much about the *behavior* as it is about *how you can think about the behavior*. Immutable data structures offer advantages for reasoning about the behavior of an application.
I am not saying order doesn't matter. What I meant was mutable data structures can handle the same if there was no concurrent access. 
Could you point to information where it says that message passing copies whole list when sending a message? I tried to find it and I couldn’t find any. 
It can, but it still introduces hard to reason behaviours, like with immutable data types you can always be sure that: foo(X); X = X. For any `X`. With mutability you cannot make such assumptions. For me it is big thing to be able to reason about my data in sane way. 
Ya I posted on stackoverflow, and got the same answer.
https://stackoverflow.com/questions/3406425/does-erlang-always-copy-messages-between-processes-on-the-same-node
THX
There could be value with immutable data structures for compilation optimizations. Obviously there are plenty of compilers for different languages that do so on top of mutability, so this argument may be going nowhere.
Is this an advert for a conference talk? I couldn’t find any relevant technical detail and the title seems very clickbaity in retrospect.
Yes, your are right, no technical inside :'(
Awesome! Congratulations on launching! You've accomplished more than most. The link "explore API documentation" on the front page gives me a 404.
Hi, Thank you for your kind words. Strange that I missed to check that link. It has been fixed now :-)
Where’s the code? 
What was it?
An erlang operating system (massively fault tolerant), microkernel + multikernel. I've watched the keynote from last year. [https://www.youtube.com/watch?v=8OyRFbf6MDk](https://www.youtube.com/watch?v=8OyRFbf6MDk)
Sounds cool thanks!
Based on what I found on GitHub ([https://github.com/samcamwilliams/hydros-site](https://github.com/samcamwilliams/hydros-site)), leading to [https://github.com/samcamwilliams](https://github.com/samcamwilliams) I'm guessing [https://www.arweave.org](https://www.arweave.org) is what happened
Yeah I've found the same also, but seems like a dead end :/
Yeah I mean I think he lost interest and moved on to focus on arweave 
Wrong place dude!
I get a not found error, got a mirror?
All these videos are very informative. Thank you for making them
Thank you for watching them, please subscribe and I would be very thankful if you could tweet or share them on facebook
Will that meeting be lived on another platform ? I just want to watch, thanks
Yep Erlang has List and Binary to store strings, we called them bitstring and string. So in Erlang, we have to manipulate these type of string in 2 different ways, right?
Thanks :)
Strings are my one of my only complaints with Erlang 
Thank you so much !
r/lostredditors
Not 100% sure, but I think [cowlib](https://hex.pm/packages/cowlib) might be what you're looking for.
Cowboy is good. Probably now only reliable choice.
To be fair, parsing HTTP messages is easy in Erlang. Alternatively, just copy the patterns from cowboy. 
Can't really beat cowboy for REST handlers: [https://ninenines.eu/docs/en/cowboy/2.6/guide/rest\_flowcharts/](https://ninenines.eu/docs/en/cowboy/2.6/guide/rest_flowcharts/) &amp;#x200B; Best designed flow I've ever seen in any library.
other people already mentioned Cowboy [https://ninenines.eu/docs/](https://ninenines.eu/docs/) so I will recommend [https://github.com/elli-lib/elli](https://github.com/elli-lib/elli)
Is that a competitive salary in Europe? Seems super low.
Is this a learning project or are you making a product? The answer with vary depending on what you're trying to achieve :)
It is a learning project, to understand distributed systems, and I think such a simple project would help understanding it :)
**Gnutella** Gnutella (possibly by analogy with the GNU Project) is a large peer-to-peer network. It was the first decentralized peer-to-peer network of its kind, leading to other, later networks adopting the model. It celebrated a decade of existence on March 14, 2010, and has a user base in the millions for peer-to-peer file sharing. In June 2005, Gnutella's population was 1.81 million computers increasing to over three million nodes by January 2006. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/erlang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
There's such thing as a Registry where you can register PIDs. There's also an ETS table that can be used to store global state.
Ah yes. ETS looks like exactly what I would need. Thanks I'll read more into that
I like inets httpd server because it is built in, so less dependencies for my clients to care about. And once proper options are passed performance is as good as other Erlamg servers (i.e. `{nodelay, true}`), despite http parsing done in Erlang, and not using C parser built-in into gen_tcp. Afaik it doesn't support sendfile as other Erlang Servers, so sending static big files will be less efficient in httpd. Some json library is useful to have too. For client I can't really recommend inets httpc too much. One of the reasons being not handling redirects transparently (but you could write some wrapper to do that) and no very efficient and easy handling of cookies. Again it isn't a big issue in majority of cases. You can build good clients with it. I made oath2 client for Google Cloud with it without that much issues. Otherwise ibrowse is nice library. It is also useful when you need socks5 support, i.e. using strange proxies or Tor. Inets client and server doesn't support pipelining or http/2 or spdy or quic or websockets. But really unless you know you really needed it, there is no need to care about iy. I think if you do not have experience with inets, start with inets anyway, to know what is standard in Erlang. It gets a lot of undeserved hate. Where in fact both client and server have good code, otp principles, code upgrades, logging, custom modules, authentication, support for Apache style per directory configs, etc. etc. And all behaviours are pluggable and can be removed for higher performance. 
Erlang as a language has no notion of strings. There are many io libraries that will happily receive list or binary or iolist (recursively nested lists of lists and binaries, implicitly concatenated, for easy building of strings and fast output / prepend / append).
There are two methods in Erlang. Spawning a process that will be managing table of connections. It can be registered locally or globally (in a cluster) with well known name (atom), and all users can use this atom to find it. Or spawn it once and pass it's Pid (or list of Pids in replicated scenarios) around to all processes that need it. Second is using ETS table which is per node. You can store Pids or connections there by key, do iterations, etc.
Well, I'm all for the more erlangish way. The data would be small, storing a few values next to the PID that may be used to uniquely identity the websocket, even with maybe several thousand connections I wouldn't imagine this going past 100Mb, and there'll be relatively little state updates, since these are long running socket connections where lots of data can go back and forth over them. So perhaps it's not the perfect solution. As far as I can tell, registering a process is effectively allowing it to be looked up via an atom. But if I have a user ID, eg 12345, how can I use that to a) register the process, so that b) I can lookup that process again when I receive some data for 12345? &amp;#x200B;
This looks interesting, is the name of the process group my user\_id? I don't understand the docs here (haha shows my level). It specifies the data type as \`name() = any()\`? Does that mean the name can be anything, like a tuple or a record? I saw \[this\]([https://pdincau.wordpress.com/2012/01/12/a-survival-guide-on-pg2-erlang-module/](https://pdincau.wordpress.com/2012/01/12/a-survival-guide-on-pg2-erlang-module/)) blog which seems to use atoms to create the groups. If that's the case I can't quite see how it can be used to access a connection process by user ID, what am I missing? Thanks, much appreciated. &amp;#x200B;
That sounds like a reasonable approach, I guess then my question is how does this top level process manage the connections? Wrapping my not-so-pure javascript brain into it, I'm envisioning some list variable which is accessible to all the functions in the process, but I feel like I'm way off the mark there for Erlang.
Yes, the `any()` type means any term. This is a good reference for typespecs: http://erlang.org/doc/reference_manual/typespec.html So it can be an atom, it could be a map ... in this case, you don't want to use atoms, though, as you would end up creating a new atom for every group (e.g. user_id) and they are limited (by default, to a little over a million). A bitstring is safer and should be sufficient. The way Phoenix does this is it lets you name your process groups ("channels", as they call them) with strings, so you might make "userid:&lt;id&gt;" channels and then you can easily send data to those sockets (processes registered with that channel). If a socket handler process registers (or, "subscribes") to another channel it also gets messages sent to that channel .. so you could have an "all" broadcast lobby-style group, or group chats with names that multiple handlers register as being part of ("subscribes") and thereby can get messages sent to them from there.. For a bit more abstraction, you could also look at the (syn)[https://hex.pm/packages/syn] library which makes it a bit more straight-forward to send messages around, but otherwise is very similar. It is very nice to use, though it means another dependency for your app (usually not a big deal). At work we use syn a fair amount, but also Phoenix's PubSub in our Elixir code... both work like champs .. Have fun exploring Erlang! :)
&gt; 50-100ms I got 13µs round-trip latencies with OCaml on one machine and 114µs door-to-door latencies with a distributed fault tolerant system in F# on .NET. So, for any decent language, I don't think the runtime is the bottleneck but, rather, the network layer. Latencies on contended ethernet are orders of magnitude longer than that. 
very nice. This is based on the https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/ I think
Close, but not quite. AWS added support for arbitrary runtimes, so this isn't tied directly to the C++ runtime. Alert Logic put together a runtime and all the tooling for it.
This is super cool, but I wonder: does anything stay running or are you paying a penalty for VM startup on each run?
Runtime starts in a container, which is recycled if it's not used for some undocumented period of time (I've seen containers recycled after 10 mins of inactivity). VM is started only once when container is provisioned (cold start). Start time depends on a mode in which erlang is started (embedded or interactive mode) and resources available to the container. Here are numbers for [erllambda sam example](https://github.com/alertlogic/erllambda_sam_example): &amp;#x200B; Cold start + execution time: Init Duration: **849.31** ms Duration: **52.19** ms Billed Duration: 1000 ms Memory Size: 512 MB Max Memory Used: 83 MB &amp;#x200B; Execution time on already started container: Duration: **66.99** ms Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 83 MB
Thanks for measuring the numbers. I've heard that (just anecdotally) that the cold startup was in the range 100-300ms but never measured it myself. I'm curious if the numbers I heard were wrong or it's due to the size of the package. I ran the hello world example provided by Alert Logic and I got: Cold: Init Duration: **834.09 ms** Duration: **3.35 ms** Billed Duration: 900 ms Memory Size: 512 MB Max Memory Used: 89 MB Warm: 1. Duration: **30.30 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 M 2. Duration: **2.87 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 3. Duration: **2.67 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 4. Duration: **28.81 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 5. Duration: **14.97 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB So it looks like the startup penalty is the roughly the same. There's quite a bit of variation in the warm runtimes though.
I'm in SF. Seems absurdly low but maybe that's just spanish wages. You won't get an elixir Dev in sf for under 120k. 
What's your project structure like? I suspect it would be less work to move to rebar3 than to add dependency support to your makefile
Hey thanks for your help! It looks like this: config/config.json //some config for our run.sh ebin/*.beam src/*.erl Makefile run.sh web/ .. all the html, css, js [github](https://github.com/Skatinger/CDCProject) I made it public in case you want to look at it on github. And I'm well aware it's pure spaghetti. More of a trial and error approach than actual development process. Refactoring comes last.
There's not much there, I would have a go using rebar3 for at least the compilation :)
This is the article which made me try to embed it directly: [codeproject.com/websockets](https://www.codeproject.com/Articles/1131438/Handling-Websocket-Connections-in-Erlang-Applicati). Maybe you see a way I could apply this. I wouldn't mind using rebar, but it would be nice to not need to restructure everything.
Alright then, I'll give it a shot. Thank you very much! Now go get some eye-bleach :'D
You can continue to load the beam files and run a function manually if you want :)
Please check that the syntax is correct. It looks like the 'case' is missing. Also, use "ok/error" tuples instead of exceptions.
what do you mean with case? and is this the right approach?
rebar is working nicely, I can compile everything with it and my run.sh works as well. Actually, it's even cleaner than before. Sadly however, cowboy is not as easy to use as I thought. If I include the cowboy application in my myapplication.app.src the application does execute without error, but I don't receive any output, and it halts too quicky. I assume it fails but doesn't print any error as any print statement in the start-method won't be printed to console either. When I don't include cowboy in the app.src file, the crash dump states bad_return for cowboy, start_clear. So cowboy is missing. I am really stuck on how I could make this work. Steps I took so far: *add rebar, edit rebar.config to include cowboy as a dependency: {deps, [ { cowboy, ".*", {git, "https://github.com/extend/cowboy.git", {tag, "1.0.3"}} } ]}. *adapt my project starting structure by adding the application files: cdcproject.app.src {application, cdcproject, [ {description, ""}, {vsn, "1"}, {modules, ['cdcproject_app', 'cdcprojet_sup', 'ws_h']}, {registered, []}, {applications, [ kernel, stdlib, cowboy ]}, {mod, { cdcproject_app, []}}, {env, []} ]}. startmethod: % start cowboy server Dispatch = cowboy_router:compile([ {'_', [ % index, websocket and sources (js), emtpy atm {"/", cowboy_static, {priv_file, websocket, "index.html"}}, {"/websocket", ws_h, []}, {"/static/[...]", cowboy_static, {priv_dir, websocket, "static"}} ]} ]), {ok, _} = cowboy:start_clear(http, [{port, 8080}], #{ env =&gt; #{dispatch =&gt; Dispatch} }), % start websocket supervisor websocket_sup:start_link(), % start my part of the app cdcproject_sup:start_link(). For my start-script I use the line: erl -pa ebin ../deps/*/ebin -eval "application:start(cdcproject)" -eval "init:stop()" inside my ebin folder. As required by rebar cowboy is in myproject/deps/*/ebin and compiled as well. If I got this right erlang will load missing code modules upon call looking in the paths given by -pa. I cannot see why this would not work. Am I forced to do a release for this to work? I got the impression that this goes a bit deeper into large application standards than necessary for a small project with a websocket. I really don't expect to work out the issue, but if you can quickly spot something that might be wrong or know about some common mistakes I'd be very happy. I've come too far to give up now :) 
If you just want to boot all the applications you can just run `rebar3 shell`, it will handle loading the beam files and starting the deps listed in your `app.src` file. You're supposed to use a release but for a toy project it's perhaps not needed.
Sadly I tried this already. When I include the cowlib in the app.src deps it doesn't generate any output. I'll have a go at creating a release. Thank you anyway :)
What do you mean by it doesn't generate any output?
No output meaning that my run.sh or any other way starting the application just opens the erlang shell, and after a few seconds closes again. It does not even print the io:format that I placed right at the beginning of the start method. Ours of trying confused my language. I include cowboy and use cowboy. Cowlib itself is used by cowboy if I got that right. Also ranch is used, but this is already a dependency of cowboy itself, so I should not have to include it myself.
Assuming that the first code snippet starts successfully, you should try creating 
&gt; The problems all occurred, simultaneously we believe, on Thursday December 6. An issue with certain nodes in core network equipment resulted in network disturbances for “a limited number of customers in multiple countries” using two specific software versions of the SGSN–MME (Serving GPRS Support Node – Mobility Management Entity). An initial root cause analysis indicates that the main issue was an expired certificate in the software versions installed with these customers. A complete and comprehensive root cause analysis is still in progress. &gt; &gt; ... &gt; &gt; More detail on the situation as provided by Softbank. It announced that its LTE services of “SoftBank,” “Y!mobile,” Fixed Line Services called “Ouchi-no-Denwa” and a part of “SoftBank Air” services were not available for its use for over four hours on Thursday, “due to our network outage caused by Ericsson-made software errors related to its packet switches” covering its customers nationwide. A good reminder that no matter how well a language handles errors and how carefully you plan for failure, it's still possible to be felled by something as simple as an expired certificate. For an overview of Erlang's use on the SGSN-MME, check out [this presentation](https://www.youtube.com/watch?v=HyiSYHfESX4) at Erlang User Conference 2012. Slides from the presentation can be found [here](http://www.erlang-factory.com/upload/presentations/597/sgsn.pdf).
Thanks for coming back at me! The first snippet does execute successfully. I can also just start my small simulation with master:start() inside the app.erl snippet when I remove cowboy. Could I just spawn s new process starting in my master? I am unsure what you are trying ro say with creating. Creating what exactly?
I am so sorry, I was typing it on my mobile and seems like I accidentally posted only a portion of the reply. What I meant to say was that use the start/0 function in master.erl to start the desired applications.. for e.g.: ```erlang start() -&gt; DataDir = dms_utils:priv_path(dms, "mnesia"), application:load(mnesia), application:set_env(mnesia, dir, DataDir), mnesia:create_schema([node()]), application:start(mnesia), {ok, _} = application:ensure_all_started(cowboy), ok = application:start(?MODULE). ``` In your case, you will start the main application, and then the simulation. Simulation need not be a part of the main application supervision tree.
I don't use amnesia if I got it right I don't have to (got no DB or anything like that). I read that it's possible to write several smaller applications and then start them side by side. In my thought process I thought I could use cowboy like I would use an import in another language. In your example this seems not to be the case. My master.erl currently looks something like this: -module(master). start(Some Args) -&gt; spawn(simulation part), spawn(simulation second part), time:sleep(some time i set for the simulation to run), AllPids ! {stop}. So my master is not actually a proper application with start/2 and stop/0 but rather just a very basic erlang file which allows me to start several processes handling the simulation at once (I think such a clutter of modules is just called a library?). Now to use application:start(master) I would have to make it a separate application right? (containing a master.app.src and a master_app.erl). Then I would create a application which has cowboy and my own simulation as dependencies? My current folder structure is like this: myProject/ /deps /cowboy /ebin /src myproject.app.src myproject_app.erl myproject_sup.erl master.erl other_simulation_modules.erl This does not allow me to use application:start(master). However, following your example it looks like you start the dependencies first, and as they are started you start ?MODULE, which in this case would be the file itself? Does this mean I can then append my master:start(args) without making it an application on itself? Also in your example I cannot see how you would set the routes for the cowboy server. Is that done within the cowboy dependency? I am really confused on how the structure is supposed to look like. If you got any resources that might explain coupling of apps in detail that would be of great help as well. Looking at your example I'm under the impression that something like this would be correct: myProject/ /deps /cowboy /ebin /apps /simulation /master.app.src /master_app.erl /other_simualation_files.er cowboy_router /cowboy.app.src /cowboy_app.erl /src myproject.app.src myproject_app.erl myproject_sup.erl Like this I could do something like this in my myproject_app.erl: start() -&gt; application:ensure_all_started(cowboy), ok = application:start(simulation). Forgive me if I don't try all ideas right away, as there is so much that can be done wrong and so little possibilities to make it work. I have already seen about 10 ways to not do it :')
Your current project structure is fine. Keep it like what it is right now. &gt; So my master is not actually a proper application with start/2 and stop/0 but rather just a very basic erlang file which allows me to start several processes handling the simulation at once That is correct. &gt; Now to use application:start(master) I would have to make it a separate application right? (containing a master.app.src and a master_app.erl). Not really. You can straight forward call the start/0 of master if you start erl this way: erl -pa /dms/deps/*/ebin /dms/ebin -s master I ship using docker so I dont have to deal with erlang releases, and can execute the above command and get a running erlang application.
I started my app with the same command as you before using cowboy. I'll try to add cowboy to master with the structure in your example to then start it with this command again. However the question remains on how I can set routes for my cowboy router. Can I do that as well inside my master? If I got it all right it will look something like this in my master.erl: start(Whatever Args) -&gt; % start cowboy part of my app Dispatch = cowboy_router:compile([ {'_', [ {"/websocket", websocket_handler, []}, {"/", cowboy_static, {priv_file, cdcproject, "index.html"}} ]} ]), {ok, _} = cowboy:start_clear(my_http_listener, [{port, 8080}], #{env =&gt; #{dispatch =&gt; Dispatch}} ), application:ensure_all_started(cowboy), % start the simulation part as before spawn(simulation part), spawn(simulation second part), time:sleep(some time i set for the simulation to run), AllPids ! {stop}. Using this structure I no longer use anything like _app.src or _app.erl to start my app but only *erl -pa /myProject/deps/*/ebin /myProject/ebin -s master*. I used to deploy with rebar but struggled to achieve my goal and then decided to change to erlang.mk because it's used in most tutorials. Thank you for your help, really appreciated. I was on the brink of giving up, especially as errors are crypting and mostly just something like "badarg" for some library function. 
I recommend that you start all cowboy dependencies in master:start/0 using: &gt; application:ensure_all_started(cowboy) You must compile cowboy routers and start cowboy in myproject_app.erl first before starting your supervisors.
Oooh I get it! Thank you! I'll try as soon as I'm home :D
I am SOO happy! It finally works! I could never have done it without your help :D Just gotta figure out on how to implement a websocket and sending messages to it :') But this is hopefully well described in several tutorials. Now for anyone reading this in the future, I have done it the following way now: I got my own file master.erl which has a method start. Now using rebar I get all dependencies and compile them with *rebar compile*. Once this is done, i can start my project with a small script which only contains the following: erl -pa ebin deps/**/ebin -eval "master:start()." To start the actual cowboy server you need your "myproject_app.erl file aso documented above to dispatch the cowboy server. One issue I encountered here is that cowboy did not start its dependencies on its own. I had to start them by myself in my master:start() like so: application:start(crypto), application:start(cowlib), application:start(ranch), application:start(cowlib), application:start(myproject), % my simulation start stuff Hope this helps someone else as well. And thanks again to /u/fileagodotcom !
Glad to know that it is working fine. Don't give up on Erlang. It is too good to let go off once you overcome the initial hiccups. 👍
Webmachine ? [https://github.com/webmachine/webmachine/wiki](https://github.com/webmachine/webmachine/wiki) Not just an HTTP Library, but not really a Web Framework either..
persistent\_term !!! No more mochiglobal.
When would this be used? How is it different from defining a module function with a fixed return value?
Updating configuration on the fly for example. &gt;Some examples are suitable uses for persistent terms are: &gt; &gt;\- Storing of configuration data that must be easily accessible by all processes. &gt; &gt;\- Storing of references for NIF resources. &gt; &gt;\- Storing of references for efficient counters. &gt; &gt;\- Storing an atom to indicate a logging level or whether debugging is turned on. &amp;#x200B;
Didn't give up and ended up with a quite nice (result)[https://imgur.com/a/es8SYwZ]!
cool! thanks!
Oh, this post is just in time :) My 2018 was start with Erlang and after this text I see Im on the right (but long shot) way with .erl 
As I mentioned in the corresponding ["Show HN" post on Hacker News](https://news.ycombinator.com/item?id=18798933), this is in a very early stage of development, but it's technically in a working state (at least in the sense that it can run OTPCL scripts; there's a lot left on my TODO list before it's ready for a 1.0.0-release primetime). Some specifically-missing things: * Docs and tests are woefully incomplete * There's no way to define functions from within an OTPCL script (no equivalent to Tcl's `proc` or Erlang's `fun` or anything of the sort) * No REPL yet (you'll have to fire up `rebar3 shell` and pass stuff into `otpcl:parse/1` by hand) * No built-in support for reading/parsing/evaluating actual files (but nothing stopping you from doing that yourself :) ) * No compiler; everything is evaluated at runtime * Standard library in general is pretty barren (but does have `set`, `if`/`unless`, `incr`/`decr`, and `print`, so at least there's *something*). Feedback is welcome. I don't have high expectations of something for which I hand-wrote the lexer, parser, and interpreter, though :)
Very cool! I'm interested to see how this progresses.
Thanks! I'm hoping that once the remaining "hard" parts are done (namely: the REPL, compiler, and a useful stdlib), all sorts of stuff will fall into place for a beta and eventual stable release.
Hi guys! In this article I introduce Elixir Streams as a powerful and elegant way to process large CSV files. I compare the greedy and the lazy approach with some memory and cpu benchmarking. As always. if you have any question or feedback, please leave a comment in the article's comments section .
Whatever you like more. In the end you can use both at the same time. 
Sounds great,but how
I do not know how to handle Elixir code in Rebar3, but Mix will automatically handle everything that matches `src/*.{erl,yrl,xrl}` and compile it with proper compiler (Erlang, Yecc, and Leex respectively), and everything that matches `lib/*.ex` will be compiled using Elixir compiler. So in fact if you use Mix then you can use both without anything extra. 
To be honest neither of both. If you knew Elixir/Erlang you wouldn't ask this question. If you have a stack you are familiar with, use that. Otherwise if you are new to start out with software development, I recommend you python. If for whichever reason you want to try functional programming, go with Elixir.
It doesn’t. It helps with Elixir web application development, but not in general Elixir app development. In web applications development it helps by providing abstract layer that simplifies building REST APIs and socket connections. You can work provide that without Phoenix though, by using Plug or even Cowboy directly. But in the end what Phoenix is is abstraction that helps with building such services. 
thanks &amp;#x200B;
Phoenix, specifically their channels (conveniences around websockets and other two-way communication protocols), and presence (knowing who else is logged in).
In this article we see how to solve an issue we faced in the previous article, scaling horizontally the Phoenix Chat app. We'll see how to integrate the PubSub Redis adapter to our chat app, and make it distributed. For any feedback or question, please post a comment here or at the bottom of the article :D
Nice write up. The problem I see here is SPF (Single point failure) on Redis.
I agree with you and this is actually the case. We could have different redis nodes, or event better we could use beam distributed messaging and PG2. The reason why I started describing Redis pubsub, is because it's easier to setup on kubernetes. My idea is to publish a second part where I'll talk about clustering the chat servers using purely elixir nodes, and make them work on kubernetes.
That's been the standard banner since forever? [Here from the official docs](http://erlang.org/doc/man/shell.html#example): strider 1&gt; erl Erlang (BEAM) emulator version 5.3 [hipe] [threads:0] Eshell V5.3 (abort with ^G) 1&gt; Str = "abcd". "abcd"
Learn you a Haskell for Great Good! Functional Programming for Scala The Joy of Clojure &amp;#x200B; Scala is the most versatile in making money, but if you just want to learn, then Haskell is the best tool to explore this sector. You will have a hard time learning if you don't use a language, you will basically be reading math papers...sorry I fell asleep thinking about that, and I'm a math major. &amp;#x200B; If you want to be a phreaking crazy man then Erlang with OTP If you want to be an amazing front end devloper? Elm Elm is probably the easiest language to learn with the best balance between being useful in industry and teaching you a lot about a purely functional language. The language is a Javascript transpiler and you will never look at web development the same again. Are you curious? Go for it bud. Do you think you can use this in industry? maybe if you ever find yourself in NASA or Jane Street. &amp;#x200B; Honorable mentions O'caml -&gt; this language's compiler was adopted by Jane Street and it is the main language they use for all of their financial business logic. It is a very "safe" language in terms of transporting and manipulating data. Elixir-&gt;easy to setup and lets you write code easier. Erlang is safe as well, given the following rule, once you write a variable say, cashIn = passedParameter; this combination or "binding" can NEVER occur again. You could assign passedParameter to another variable but cashIn's job will forever stay as a passedParameter assignment. However, Erlang is almost impossible to setup unless you are good with linux, it took me about an hour to get the repl running, then you need to point it towards an LLVM to "compile" the language. A good resource could be [codewars.com](https://codewars.com) and choosing Haskell or O'caml in a Kata. Cheers!
is there any resource for Elixir?
[The Little Schemer](https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992) is a great place to get some practice with functional programming and recursion. I actually worked through the first 5 chapters [using Erlang instead of Scheme](https://gist.github.com/jared/f87eced03f150bfb84aedca80887df67), and only had to make minor changes for the examples to work.
the pragmatic programmer has a book but then I found this: https://pragmaticstudio.com/elixir $65 and seems like a great product to approach this project. The OTP is important for communicating and Erlang used to be the only language that could use it; however, I am guessing they have opened it up to Elixir? The important thing to know is that Elixir was written in Erlang...I think. Therefore, some of the problems that you can find from Erlang forums could help with Elixir development. DO NOT go to Phoenix before you have learned Elixir. I know nothing of the language, but it is not like python where you can learn the heavy tools in Django and then stack overflow the glue logic. Phoenix framework is extremely dependent upon knowledge of Elixir. The course for $89 is basically the future of web development; however, it is almost way too early to wrap your mind around that stack...notice I said "almost". Learn these tools, but if you don't have a "normal" stack don't put too much time or thought into these projects. Managers and Senior coders won't be able to read your github, but I would definitely make the project they give in that course. Books are good, but Elixir is such a wierd language, it is popular enough to be recognized, but noone wants to use it based upon the lack of resources that come with it. If you work on these tools by 2025 you will be one rich man. Trust the stranger on the internet haha...
Hey, knickerBockerJones, just a quick heads-up: **wierd** is actually spelled **weird**. You can remember it by **e before i**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Honestly, just take the language you're best at, and rewrite something functionally (no loops, use map; no side effects; pass state in and return it) You can go for one of these books, and they'll tell you their spin on functional programming. If you get a Haskell book you'll be told everything has to be in a monad, which just about nothing has, for example. Erlang isn't actually a functional language, though, even though it does offer functional language tools; it also offers the process dictionary and mutable datastructures and sockets and all sorts of things that some FP people will think aren't pure and others won't. But you already know what map does. You already know what fold does. It's just a question of using them until they're intuitive, and a book won't give you that. Take an app and re-write it.
Is Docker an option? If so then you can treat single node Erlang applications like any other language.
We are running Erlang on Docker in Kubernetes in AWS. Just make it a docker container and you are good to go. :)
Take a look at EDeliver: https://github.com/edeliver/edeliver I don’t use it myself though. I use my company’s in-house tool, which is not open source.
Hey everyone! In this article we see how to cluster Phoenix Chat nodes, using distributed Elixir. We see how pg2 works and inspect how Phoenix efficiently broadcasts the messages in a distributed chat app.
nice thanks, I thought docker/kubernetes wasn't an option as from what I understand Erlang has OTP that manages the multiple nodes running on bare metal. I am a bit confused. So multiple Erlang processes are actually spawned into the same docker container? OTP does not manage hot code reloading? As it's happening thru docker/kubernetes
Don't let Docker distract you too much. Docker is great, and you can incorporate that into your setup, but that's a different topic, really. I highly recommend you check out [https://learnyousomeerlang.com](https://learnyousomeerlang.com). Specifically, [creating releases](https://learnyousomeerlang.com/release-is-the-word), which is just the prerequisite knowledge for the chapter on [code hot-loading](https://learnyousomeerlang.com/relups) and release updates that you're really after. It is rather involved, so depending on your Erlang background I recommend you take your time to soak up all the detail. The [whole book](https://learnyousomeerlang.com/content) is great, though. Once you get to the chapter of [distribunomicon](https://learnyousomeerlang.com/distribunomicon), for example, you could start thinking about whether or if Docker/k8s fits into your picture, but that's more about managing infrastructure.
That's a wrap on applications for our [**Code BEAM SF**](https://twitter.com/hashtag/CodeBEAMSF?src=hash) [**diversity**](https://twitter.com/hashtag/diversity?src=hash) scheme! &amp;#x200B; Next step: Code BEAM SF partners Travis Foundation and Diversity Tickets will review all applications and award places to those who would most benefit from them. The Code BEAM SF team be in touch with all applicants by 08 Feb! 📷
In this video we are going to see how to cluster Elixir and Phoenix nodes with libcluster, locally and on Kubernetes using Docker containers. 
You’ve got the what outlined, but why? I’m curious what this buys you that native Erlang clustering does not?
hi, I started with the books, they are good (at least for my way of learning). &amp;#x200B; otherwise [http://spawnedshelter.com/](http://spawnedshelter.com/) has a lot of resources.
This might be another good resource: [https://howistart.org/posts/erlang/1/index.html](https://howistart.org/posts/erlang/1/index.html)
Thanks will look into it
I mostly prefer videos/tutorial but don't mind books also. Will look into the resource. Thanks
Just unsolicited advice... IMO learning Erlang is the easy part. Groking OTP for me was the tricky part. Once you understand the primitives of the language, I would dig in to not just the how of OTP, but the why. Learn you some Erlang is good. I found the published books to be dodgy for my learning style.
Thank you so much for such a detailed help.
this video series is a nice intro: https://www.youtube.com/playlist?list=PLR812eVbehlwEArT3Bv3UfcM9wR3AEZb5
Learn you some Erlang is _fantastic_. Easily one of the best programming books I've read.
I did the prolog 99 problem list. Then I learned OTP. Then I wrote a poker server. Then I was ready.
Don't treat processes/genservers as instances.
\&gt; Does Erlang have a future with the advancements we are seeing in hardware? &amp;#x200B; Yes, the Erlang virtual machine uses all available cores and the platform is well suited to build distributed systems, see riak\_core, lasp, partisan &amp;#x200B; \&gt; Will focusing on this language allow me to transpose skills to other languages? &amp;#x200B; You already have experience with many languages with different properties, it seems you will be able to pick up other languages after erlang. Also, it's useful to learn languages from different paradigms, it helps you see the big picture and improve your skills even when using other languages. Your programming career will require you to learn and use many languages, don't worry about learning one or the other, it seems you want to learn it, so why don't you give it a try? &amp;#x200B; \&gt; Are Erlang engineers hobbyists that find themselves being offered a job using it? &amp;#x200B; There are companies using erlang, you can see them here: [https://erlang-companies.org/](https://erlang-companies.org/) those are not all, but many of them, you can get an idea of what kind of jobs you can get and maybe apply to them once you want. &amp;#x200B; &amp;#x200B;
- Does Erlang have a future with the advancements we are seeing in hardware? Yes. Specifically in the server space, where you get to handle more cores for free. On smaller and smaller mobile devices, there is potential (live code upgrades can be neat there), but more VM tweaking is needed as it is not economical energy-wise by default (busy-looping to be responsive eats CPU). There are various switches that can be used, and a standard VM with some info and libraries stripped out can fit in under 10mb of disk space. So not embedded, but can easily fit in rpi3s and other similar ARM devices. - Will focusing on this language allow me to transpose skills to other languages? Yes and no. What I learned the most in the last 10 years was not just programming language use, it's system design. The things Erlang teach you don't necessarily port over directly to other languages, but they port over to almost any other project. Principles of fault tolerance and isolation shown in Erlang are hard to even learn in other areas. Distributed systems principles are generally something the Erlang community is very comfortable with and the language makes good decisions about that from day one compared to almost any other environment out there. So while the Prolog-like syntax and lack of types means you may have a bit of a trickier time switching to Haskell or Rust since they structure programs differently than if you had picked something like OCaml, the skills related to system design you'll pick up will be absolutely worthwhile and transferable. - Are Erlang engineers hobbyists that find themselves being offered a job using it? Yes and no; it depends on where you are and what industry you work in. There is no strict "school of Erlang", but a lot of Erlang teams are spun up by regular businesses getting training from either books or a place like Erlang Solutions Ltd because they have a project to run. After a while they may stick with it and start hiring for more people. Pretty much any business out there that uses Erlang is ready to teach it to some extent. They may look for some background in functional programming skills or relevant problem domain, but generally will be ready to add more to them. The trick though is that while there are many Erlang devs, the distribution is sparse, and the same can be said of companies using it. Those that have the easier time staffing up either train locally, pay Bay Area money, or allow remote work. The latter category tends to fill up rapidly. Another avenue is to try and get Elixir jobs as well; most of the principles are similar, and although you may end up most likely working on a web app for a bit less money than you would with an infra-related Erlang job, it's a very decent entry point; what you learn in Elixir will generally carry well to Erlang (and the opposite is true -- learning both is better than learning either, and it's super easy to get the second one once you have the first)
In this article we see how some kind of HTTP requests/responses can lead to memory issues. We see then how to manage this issues using HTTPoison Async Requests to asynchronously download large files.
I don't get why you posted this here and not in /r/elixir
Great reply. I'd like to also add that there is a certain category of problems that would be unreasonable to be solved with OTP/BEAM due to the limitations of the platform. 
Hi, thanks for your comment! I posted also here since it's the same thing with Hackney {stream\_to, pid} in Erlang. I've chosen a simple download of an image because it's easy to see and describe. In general it obviously depends by the context. It works well with big CSVs (in the order of GBytes), processing them line by line. In this case there is a small problem with having a whole line in the same chunk, issue avoidable with same aggregation. Sure, when we have to process the complete payload as a whole, we can't process the stream using chunks... do you have any example in mind?
Like receiving a 300MiB JSON data dump (a real-world example, unfortunately).
Yeah, if we have 300mb JSON.. that goes anyway loaded into memory. It depends why we end with a 300mb JSON. At that point it looks more a data design issue to me. It obviously depends from the context: loading 300mb in a one off process could be ok... in other cases like having multiple parallel data importing processes... maybe not that good
Million thanks, fascinating material in your channel. Is this analogous to eval function in Python? Does it provide homoiconic /macro capabilities like lisp? It reminds me of this: [http://erlang.org/doc/man/erl\_eval.html](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=http%3A%2F%2Ferlang.org%2Fdoc%2Fman%2Ferl_eval.html&amp;event=comments) . Btw I coud not find ct\_expand in erlang libs in [erlang.org](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=http%3A%2F%2Ferlang.org%2F&amp;event=comments) , only here: [https://github.com/uwiger/parse\_trans/blob/5021be5b4dab748107be2339dee0054ad4903174/src/ct\_expand.erl ](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=https%3A%2F%2Fgithub.com%2Fuwiger%2Fparse_trans%2Fblob%2F5021be5b4dab748107be2339dee0054ad4903174%2Fsrc%2Fct_expand.erl&amp;event=comments)
It's not a standard part of Erlang, just someone's add-on. It is closer to a lisp macro than an eval
Probably not the pipe, at this point. But the Elixir core team has certainly made improvements to Erlang/Beam. Many of the standard library functions had to have their argument order changed from their Erlang equivalent in order to accommodate pipe syntax. For example, many of the Erlang "map" functions take the map as the last argument, which would make piping useless, to say the least. 
Use Jose Valim's, if you really want it pipe(Init, Funs) -&gt; lists:foldl(fun(F, State) -&gt; F(State) end, Init, Funs). pipe(Init, [fun(S) -&gt; set(S, 230) end, fun(S) -&gt; update(S) end, fun(S) -&gt; output(S), S end]). &gt; For example the pipe operator in Elixir is just brilliant for organizing code. With time you realize it's a toy, and makes error handling perversely difficult.
In general, adding new features to established programming languages is more pain than gain. Take the "parameterized modules" feature which was introduced many years ago and is now being removed due to lack of use. Doing these things needs to be done carefully with a long-term plan for maintenance and development. Oracle has been doing a good job with Java, but the Erlang/OTP team does not have that kind of resources. In the long run, the cost of writing and maintaining code has very little to do with new fancy language features, and so much more do to with "how to get people to work together efficiently". In other words, there is very little economic benefit of introducing new features, simply because that is not where the high costs of software lies. This of course also means that systems which are widely used in large production and/or legacy systems will be more difficult to evolve (see Java and C++) than smaller languages which have more freedom to change. 
In that specific example error handling may be difficult, but that's hardly true of pipes in general
As you start using them in more serious applications, and stop downvoting things you disagree with, you will find that actually yes, the reason almost every language that has a pipe stops using them pretty right away is that they are quite difficult to debug in general. Especially as compared to Erlang's existing, wonderfully well developed system.
This is awesome! :D
You should cross post to /r/Golang 
This is awesome. I'm an Erlang developer, But I won't use Go with Erlang.Because Go make concurrent complex. And most time I will use Erlang's nif to solve CPU cost operation. At the same time I prefer Rust to Go.
I like it, anything that makes integration easier can only be a good thing, there's a similar library written in Python called [Pyrlang](https://github.com/Pyrlang/Pyrlang) \- these things are quite fun to use and could work quite well for domain (libraries) specific work. 
Facebook is a nasty data-stealing monster.
LOL, I too agree...
Confused ember with erlang?
and there is a active /r/emberjs/ sub!
It's a little hard to offer clarification without more information, is there a particular place that talks about pattern matching that is unclear to you?
Are you familiar with switch statements?
Everything about :( I've been struggling to grasp the basic concept of it 
Sadly not :( I'm a big novice at programming
It works like the [peg fitting toy](http://farm5.static.flickr.com/4092/5032376885_4451ca267d.jpg) where you try to fit your peg (value) *from top to bottom* into holes (patterns). When it fits, it sits and you end matching. This is important as if you define less specific pattern first then it will not try to find “better match”, it will just stop there. 
That's fine. Basically, when writing a function, you can provide many versions of a function, with some of the parameters being given specific values for each version of a function. For example, you might have: add(X, 0) -&gt; X. Then, when calling a function, erlang will try every version of the function, in order, until one matches.
The basic concept is that you're comparing a value to multiple "patterns"(like the structure of the data). You expect a value to match one of those patterns, and you want to do different things depending on which one matches. The pattern can also bind names(variables) to part of the structure of the value, when it matches, which can be called destructuring.
Simply think it as capture the value from right to left, &amp;#x200B;
This is a bit overly broad. Pipes in Elixir are actually /sometimes/ easier to debug - depending on what your definition of debug is. ```elixir blah |&gt; something |&gt; something_else |&gt; something_finally ``` Taking the above example, one of the big things that happens in Elixir is this: ```elixir blah |&gt; IO.inspect |&gt; something |&gt; IO.inspect |&gt; something_else |&gt; IO.inspect |&gt; something_finally |&gt; IO.inspect ``` And suddenly you have debug information for each step of the pipeline, which is convenient for figuring out which step went wrong. Of course, the way some people /use/ pipes is forceful and messy, but pipes themselves are not inherently bad.
Your example is of when it makes no difference at all. It's also a trivial toy example. In more realistic real world settings, you'll find that this isn't how debugging is supposed to work in Erlang, because as it spreads over thousands of processes on dozens of nodes it quickly becomes impossible to sort. This approach completely defies the let it crash and the error handling goes in other process approach from Joe's thesis. When you learn Erlang, and do larger production scale projects, you'll realize why Elixir's attempt to stuff Ruby style debugging into this environment is a dead end . &gt; Of course, the way some people /use/ pipes is forceful and messy Such as your example
Along with [pattern matching](https://www.poeticoding.com/the-beauty-of-pattern-matching-in-elixir/), one of the coolest things in Erlang and Elixir is their concurrency implementation based on Actor model. In this article I introduce concurrency and show how we can start making our code concurrent in Elixir, using processes.
In Algol-derived languages you use statements such as if for control flow, i.e., branching, but, in Erlang, statements like if and case don't really branch the code, they're more like small functions that do something depending on certain conditions and then return a result to the caller. To achieve actual branching you have to write **multiple headers** to a single function, where each entry accepts input of various format. &amp;#x200B; A trivial example (a simple sum function in Python over lists or tuples): def sum(List): N = len(List) if N == 0: return None else: Res = 0 for element in List: Res += element return Res &amp;#x200B; The same example could be written in Erlang: %% define the function to only apply to lists sum(args) when erlang:is_list(args) -&gt; lists:foldl(fun(X,Acc) -&gt; Acc + X end, 0, args); %% everything else falls through sum(_) -&gt; undefined; &amp;#x200B; You could also re-write the Erlang example to use an if-statement, but in more complex pieces of code this quickly becomes infeasible or even impossible as Erlang really does not want you to use the if-statement for control flow. 
Honestly, it was just having some people around to help me out with the stuff that I had to do. I tried reading the books and tutorials but Erlang is very ghetto/niche, so finding actually useful resources was a struggle. That book "Erlang for concurrent programming" is probably the least helpful book I've ever tried to read, it's written like a reminder for someone who knows what's happening, if you're a novice it's too difficult and too light on the details at the same time. &amp;#x200B; I kinda have the same opinion for Learn me some Erlang. Equally awful book for more or less the same reasons plus the language in this is for children. I guess the author just wanted to write something so that he could tap himself on the back. &amp;#x200B; It worked well for me at the end, though, my job has very little Erlang in general as I'm mostly doing data analysis &amp; stuff like that. Best resource in paperback was "Introducing Erlang", it's a very simple and short book just enough to get you going with the syntax and a few of the most commonly used features of the language. That one I actually recommend. &amp;#x200B; &amp;#x200B;
Chat application should be process in realtime. In this scenario, Erlang is agile to adapting to **instant updates and hot fixes**. **Mnesia DB** handles the heavy-duty task of database management. Mnesia is a multiuser distributed DBMS which also happens to be the **default DB of ERLANG**. Mnesia helps achieve quicker request responses, thereby improving the overall efficiency. &amp;#x200B; PS: I am from [Mirrorfly](https://www.mirrorfly.com/), we are readily built solution using Erlang for web, Android &amp; iOS platforms.
Have a look at escript: http://erlang.org/doc/man/escript.html
You could simply run a function with the corresponding Erlang option, e.g. erl -run mod function -run init stop Ideally you would use ports though, then you don't have to restart the whole VM for every function. There might also exist a framework somewhere to interface Erlang with Java.
That sounds useful. Would you be willing to just break down that each part of your example represents, since I'm not entirely sure what is what? 
You can find more on that here: http://erlang.org/doc/man/erl.html With the -run option you can directly start a function after the VM is started. Mod is the name of the module, func is the function, and afterwards you can have some arguments. The second -run init stop will call the stop function of the init module, thus terminating the VM after the previous function is done. -run Mod [Func [Arg1, Arg2, ...]] 
Ah, I see! Thank you very much, will try this out! 
Messages are a fundamental part of concurrency in Erlang and Elixir. In this article I introduce how messaging between processes work. We play with simple examples to see how a process sends and receives messages.
this seems to be a bunch of minor, unimportant syntax differences that will confuse the elixir user once they need to move into the real language elixir is to erlang what coffeescript was to javascript - a bunch of ruby people refusing to let ruby go, then spending a decade trying to explain why they haven't missed the point, and holding up things like "well it's several characters less to do this thing" as language improvements
in particular, the way you "composed streams" 1. isn't composition, and 1. is wildly slow and unacceptable to the high parallelism machine
I don't know, I think "use" is quite nice. Structs as well. I really need to spend more time with Elixir, but the fact it's bringing a bunch of people in to the Erlang world, seems to be a net positive.
in trade for mis-teaching them constancy and strings, and other things of that ilk? it's a painful transition
Someone liked Elixir, and things happened.
As someone who works in both (but started with Elixir) it will not confuse people. There are some quirks that sometimes become irritating (like lambda calling), but that is minor problem as, TBH I do not call lambdas that often. I use them all the time, but I do not call them in my application code. Also Elixir’s macros are on completely different level when you compare them to the Erlang’s meta programming. So while there are some minor issues, I would restrain myself from stating that this is CoffeeScript in the Erlang world, it is more like Groovy/Kotlin in the JVM universe. 
Not only what the other commenter said, but in my opinion, Elixir is easier to start and more expressive (thanks to macros). So from the business perspective it is almost pure win (easier to find/train developers and development can be faster). 
I watch elixir programmers get tripped up by that stuff every day, but okay 
I agree with you but: Macros are much more of a secret weapon of power users than a selling point to newcomers. The real kicker is that Ruby and Python people aren't quite so scared to pick up Elixir even though the underlying semantics are effectively the same. Yes, Elixir might wrap a stateful genserver and call it an "agent" but really they're just getting tricked into writing Erlang through a very well developed DSL.
&gt; elixir is to erlang what coffeescript was to javascript It is incredible how people continue to spout complete nonsense even after plenty of opposite evidence. Proper Unicode support, protocols, the with construct, GenStage are all improvements from the top of my head that Elixir bring beyond the syntax level. But of course, after decades of telling others that syntax does not matter, the first criticism of Erlang developers towards Elixir is about syntax.
How is Elixir mis-teaching strings when it is exactly the same data-types as Erlang, the difference being in syntax?
&gt; It is incredible how people continue to spout complete nonsense even after plenty of opposite evidence fun thing: i've spoken both languages for almost ten years, one for almost 20, and i don't see any of your plenty of "opposite evidence" yet . &gt; Proper Unicode support Would you be more specific, please? . &gt; protocols aren't really much different than behaviours, but also, elixir is still struggling to use the behaviours from the rest of the language . &gt; the with construct this is your idea of a language improvement? ***really*** ? . &gt; GenStage is much less powerful than the things from OTP that it's trying to replace . &gt; But of course, after decades of telling others that syntax does not matter i'm not sure why you believe people say this. you seem to be doing all the talking about syntax here . &gt; the first criticism of Erlang developers towards Elixir is about syntax. i didn't say anything about syntax. you're just trying to ignore what i really said by cramming me incorrectly into some stereotype
by using the same scalars (not datatypes) as erlang but swapping around their notations. it's not a complicated comment. i'm having a pleasant conversation with someone else. given the acid in your tone elsewhere, i'm disinclined to want your participation here. incoming: "they're linked lists, that's a datatype" and some eye-rolling
Probably because Elixir is shiny and new, Erlang is ugly and old. &amp;#x200B; It's getting reaaaally difficult to land a good job in Erlang if you're not willing to do at least some Elixir. Before Elixir, it felt like screaming in the desert. Now it feels like screaming in the desert with ruby hipsters looking at you funny.
&gt; Would you be more specific, please? The String module which allows you to perform Unicode based operations on binaries since 2012, around 5 years before Erlang reworked their string module to work similar to Elixir's. And still in 2019, if you want to use Unicode characters in Erlang, you need to add magic comments if you want to avoid errors under certain situations. &gt; aren't really much different than behaviours, but also, elixir is still struggling to use the behaviours from the rest of the language Protocols are different entities to behaviours, not only in Elixir, but also in literature, and they provide different expressive power. Plus "Elixir is still struggling to use the behaviours from the rest of the language" doesn't make any sense. &gt; this is your idea of a significant language improvement? I didn't say it is significant but it is a useful feature, yes. Both Elixir and Erlang run on the same VM, you aren't going to find major changes, but a bunch of small improvements can provide an overall better experience to many developers. &gt; is much less powerful than the things from OTP that it's trying to replace GenStage it is not trying to replace any OTP behaviour as there is no equivalent behaviour in OTP. &gt; i didn't say anything about syntax. You literally commented on it being a bunch of "minor, unimportant syntaxes differences" and mentioned that Elixir is equivalent to coffeescript, where coffeescript is by definition only a syntactical wrapper around javascript, while Elixir does provide a standard library, tooling, a package manager, etc. It is totally fine to dislike Elixir and to find Erlang a better language but you are clearly mischaracterizing Elixir, either on purpose or due to lack of understanding.
This is very helpful. I thank you!!
A ha. Thank you for sharing these thoughts!
TBH I have never used Elixir `Agent` outside of testing and mocking. And most other Elixir developers I know do not use `Agent`s either. So for me this is convenience module for rare usage (TBH I do not know why this is in core, but can be useful from time to time). 
&gt; refusing to let ruby go Come on, the only common point between Ruby and Elixir are the def/end keywords.
&gt; Elixir's first release is not even seven years old, oh for. "it's eight years old and you've used it for almost ten!?!?!??!" Elixir's first full release was in January of 2011. That's eight and a half years. one, yes, eight and a half years gets called almost ten by some people. two, i didn't look the date up. three, it was available on irc long before its official release. looking at my old SVN repos, I've actually been using it more than ten years. four, frankly, I'm having a hard time deciding whether to read the rest of this, because it's some redditor in "prove them wrong" mode fortunately you sent me a hilarious rage mail explaining that you were blocking me, and appealing to me to still read what you said, so... . &gt; the unicode problem i said was important in erlang isn't real anymore oh pro tip: it wasn't real before elixir existed, either. all elixir did was take a community module and integrate it. you know, kind of like how node people used express for ages before the http module . &gt; erlang magic comments in situations i work on erlang in unicode every day. no, you don't. . &gt; &gt; protocols aren't much different &gt; &gt; yeah huh and no specifics oh . &gt; &gt; &gt; &gt; there's few major differences &gt; &gt; &gt; &gt; &gt; &gt; with &gt; &gt; &gt; &gt; with seems major to you? &gt; &gt; I DID NOT USE THE PRECISE WORD MAJOR but yes it's nice oh. odd how everyone gives niceties when i ask for major differences . &gt; Both Elixir and Erlang run on the same VM, you aren't going to find major changes Gradle, Clojure, and Scala roun on the JVM LFE runs on the EVM My point was that elixir didn't add anything important. You seem to be trying to explain why I'm correct, but in tones of teaching, and using arguments that don't hold water . &gt; GenStage oddly, their own manual page sees this differently, but okay . &gt; You literally commented on it being a bunch of "minor, unimportant syntaxes differences" No. I said the blog post was a bunch of minor, unimportant syntax differences. Not Elixir. It'd be nice if you would read more carefully before yelling at people. . &gt; and mentioned that Elixir is equivalent to coffeescript I said that it was like it, not equivalent to it. In the way that a DeLorean is like a commodore 64, in that they were underpowered in their day, are wildly impractical today for dozens of reasons, but also people still hold a personal love for them, seek them out as collectors' items, and maintain them far past their useful life. I see that you're trying to escalate me into saying things that I didn't say, by replacing words. How's that going for you? Like doesn't mean equivalent to. Like means shares some uncommon qualities. In this case, what I was referring to was that I felt this was a language by ruby people who refused to give up ruby, and wanted to learn another language without learning another language. I stand by that. . &gt; It is totally fine to dislike Elixir I don't dislike Elixir. I'm glad you're giving me permission to have emotions, though. Thank you for your kindness, controller. . &gt; you are clearly mischaracterizing Elixir, Another possibility is that you're seeing things in what I said that aren't actually there. I didn't characterize Elixir at all, so I feel that I cannot have mischaracterized it. That you claim that I dislike the language, and that in private you insisted that it "triggered" me, suggest that you're arguing with someone that lives in your imagination.
I'm not sure I've ever seen you write Elixir code.
&gt; Elixir's first full release was in January of 2011. That's eight and a half years. That's a lie. After looking at the git repo, it is clear the first **commit** was in [January 2011](https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b). The releases page lists the first release back only in [May 2012](https://github.com/elixir-lang/elixir/releases?after=v0.7.0). &gt; looking at my old SVN repos, I've actually been using it more than ten years. I double checked with the maintainers on IRC and I was reassured that Elixir did not exist before January 2011, in any shape, nor public or private. So this is another blatant lie. &gt; all elixir did was take a community module and integrate it Another lie. At the time, the Unicode libraries would all load the data into ETS on boot which would be a pain during development and quite slow at runtime. Elixir's approach of dynamically generating the module was novel in that it was at least an order of magnitude faster. I remember that shortly after its release there were direct ports of the Elixir implementation to Erlang. But I know you are going to claim that you have a SVN repository that generated Erlang Unicode modules, possibly before Erlang was even created, or maybe insist that having an efficient Unicode implementation is "not important". &gt; My point was that elixir didn't add anything important. You seem to be trying to explain why I'm correct Quite the opposite, there are many important improvements, which is why some of them are making it back to Erlang. At the end of the day, they add up to something significant. Seriously, I don't understand why you insist on lying when there is plenty of evidence otherwise. I will stop here because this is a tiring exercise.
You've also never seen me write c, c++, php, prolog, css, sql, x86 assembly, 680x0 assembly, arm assembly, thumb assembly, formulaone, ml, ocaml, perl, or any of a host of other things. I put a sticker over the spy cam you placed on me as a teenager. That thing you've been watching the whole time is actually a [Famous Drinking Bird](https://www.amazon.com/Drinking-Bird-4975-The-Famous-x/dp/B000JSGLBK?th=1).
&gt; That's a lie. &gt; (fumbling around about how the first public commit isn't the first release) &gt; So this is another blatant lie. &gt; Another lie. &gt; Seriously, I don't understand why you insist on lying (checks fingernails.) Melodramatic much?
But you did lie. Elixir has not existed for as long as you claim.
If you google "when was Elixir originally released," the table at the top says 2011, and the post two things down says "in January." No, I didn't lie. I quickly googled it and believed the results I got, because like I had already said, I didn't care that much and wasn't checking. This guy is getting wildly bent out of shape over a detail that is entirely irrelevant to what I originally said, in the hope of creating a reason to be angry. 
You said: &gt; it was available on irc long before its official release. &gt; &gt; looking at my old SVN repos, I've actually been using it more than ten years. Elixir has not existed for that long.
&gt; Melodramatic much? It is not melodrama. The whole point is that it makes no sense to discuss with someone who is just spouting bullshit. &gt; So, I guess I feel like there's not much purpose in continuing. On the positive side, you are not doubling down on your lies anymore, so I would consider that a win.
&gt; it was available on irc long before its official release. I believe that it was. Maybe I'm mistaken? I don't really know, or care. This is irrelevant to my point. I could swear that I remember Jose being an #erlang regular that used to talk to rvirding about lfe. But maybe that was someone else. That was a long time ago. It's also completely irrelevant to the point that I was making. I don't understand why you are enmountaining this molehill. . &gt; [You said:] looking at my old SVN repos, I've actually been using it more than ten years. I also said: &gt; Looks like the .exs I found in SVN is actually some game script instead. My mistake. shrugs This is *also* irrelevant to the point that I was making. Yes, I see you guys doing your very best to prove me wrong at niche concerns that aren't related to my point, that I keep saying I could be wrong about. That's nice. Be sure to say "liar" a lot. 
(checks watch) That's nice.
There's publically visible examples of all of those except for the assemblies, but not elixir ;)
I write lots of stuff there's nothing published for 
&gt; how can I stop feeling queasy any time I have large numbers of (erlang/elixir) processes doing I/O on the same file descriptor? If you are opening files in`raw` mode, then I don’t think it is safe, see the Erlang docs: http://erlang.org/doc/man/file.html#open-2 &gt; raw Allows faster access to a file, as no Erlang process is needed to handle the file. However, a file opened in this way has the following limitations: Only the Erlang process that opened the file can use it. A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (direct
Thank you for your response. I'm going to describe my understanding of the situation, and I would love to learn what I have wrong: &amp;#x200B; The elixir program gets compiled into an escript binary; when clone()/execve()ed, that binary inherits file descriptors opened by the shell (bash) that invoked it. escript "packages" (I'm sure there's a better term for this) the stdout into something that IO.puts/1 uses by default. I never open the file explicitly. I'm using poolboy ([https://github.com/devinus/poolboy](https://github.com/devinus/poolboy)) with many worker processes which each handle a directory, and queue encountered directories to be handled by further poolboy processes; to each poolboy process I've passed a function which the poolboy process calls invoking IO.puts/1 with the file name of each directory entry name encountered\[0\]. If IO.puts/1 were unable to access stdout, I would expect either a failure of each of my poolboy processes or no output at all, since I believe the poolboy processes get created after the open stdout descriptor is available from the very beginnin of execution. &amp;#x200B; \[0\] Apologies for posting elixir code to an erlang group, but the elixir has stayed the same, while an erlang update has changed the behavior. The future intent is that proc\_entry do something more elaborate(?) than print the file name, but before I get more ambitious: &amp;#x200B; `proc_entry = fn(name, _stat) -&gt;` `IO.puts("#{name}")` `true` `end` &amp;#x200B;
This is super cool! I really like how much thought you put into the type conversions. Some questions: 1. Can I call Erlang from the Lua script? 2. Can I pass functions from one language to another, return a Lua callable than can be called from Erlang? 3. Does it support co-recursion between Erlang and Lua? This is really cool, I'd really love to seem some examples.
Ah ok there’s special handling for stdout - all output goes via a group leader process. There’s some info [in the elixir docs](https://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders) and some more on [this Erlang users list post](http://erlang.org/pipermail/erlang-questions/2018-April/095179.html) 
I have in two projects which to my knowledge are still in production. If all you need is an ephemeral state store and ETS is overkill, Elixir agents actually are a shortcut to that.
[Just some unimportant guy that finds that Elixir improved some parts of Erlang and has ideas worth “backporting”](https://joearms.github.io/index.html#2013-05-31%20A%20week%20with%20Elixir). 
In summary: 1. Use the same string transclusions we've all been asking for since the 90s 1. The pipe operator 1. Fix the shell bug around functions 1. Tagged template literals 1. perl heredoc 1. The lisp macros that rvirding has wanted the whole time interestingly, you quoted the word backporting explicitly, which doesn't seem to be present in the article
PHP do not have pipe operator. Also PHP do not run on EVM, so I do not get that point at all. It seems that for some reason you despise Elixir in general, and you do not see, that it brought more popularity and developers to BEAM community. Heh, whatever. 
It's really boring watching elixir fans announce that I despise Elixir just because they can't say anything interesting about it 
Is there a youtube version, or some other version which can be watched at high speed?
Youtube URL: https://www.youtube.com/watch?v=xi-ixFPjNpc
https://www.reddit.com/r/erlang/comments/b5d350/video_and_slides_midair_airplane_repair/ejei9yp
Thanks!
I often can't connect from my ISP in Romania. When that happens I use a proxy in Frankfurt. Quite annoying 
There was a DNS issue, which should be resolved by now.
Still broken for me :/
Great talk: very informative and fun!
Is it still broken?
Nope works now
I've used agents in production applications cause I was lazy. Now you know one.
Just providing my experience. I did not pay enough attention to my work environment at first. It made things really hard. Learn rebar3. Apart from that, Erlang felt really simple, maybe poor. The language itself should not pose any major issue. 
Sigh, you again with false claims. And one last time: it is not about the individual things, but rather providing all of those as a feature set. That's the interesting part: choosing what is in the language (and what isn't). You are not required to find it interesting but there are plenty of people that do (including Joe). But sure, please continue projecting into everyone. 
Can you find something better to do, please, than resurrect five day old threads to be aggressive? Thanks.
I have never used it, but thought it would be fine to poke it with a stick. So .. I started a tftp daemon and passed the resulting pid to `tftp:info/`: &amp;#x200B; `1&gt; {ok, Daemon} = tftp:start([{port, 9999}]).` `{ok,&lt;0.85.0&gt;}` `2&gt; tftp:info(Daemon)` `2&gt; .` `{ok,[{type,daemon},` `{host,"127.0.0.1"},` `{port,9999},` `{local_port,9999},` `{port_policy,random},` `{udp,[{active,once},{reuseaddr,true},binary]},` `{use_tsize,false},` `{max_tsize,infinity},` `{max_conn,infinity},` `{rejected,[]},` `{timeout,undefined},` `{polite_ack,false},` `{debug,none},` `{parent_pid,&lt;0.81.0&gt;},` `{callback,[],` `{re_pattern,0,0,0,&lt;&lt;"ERCPG"...&gt;&gt;},` `tftp_file,[],undefined,undefined},` `{callback,[],` `{re_pattern,0,0,0,&lt;&lt;"ERCPG"...&gt;&gt;},` `tftp_binary,[],undefined,undefined},` `{n_conn,0}]}` Aha! There is the timeout param! Only ... NOPE. You can not reset that one. Anywhere. It gets rejected by the option parser as not a valid option. Ooooook. So a quick trip to RFC 2349 referenced in the tftp module docs and it seems that timeout is a tftp option. Oooh. And there is a tftp option mechanism in options, and \*that\* works: &amp;#x200B; `15&gt; tftp:change_config(Daemon, [{"timeout", "250"}]).` `ok` And looking in the tftp\_file implementation there is this: &amp;#x200B; `do_handle_options(Access, Filename, [{Key, Val} | T]) -&gt;` `case Key of` `"tsize" -&gt;` `case Access of` `read when Val =:= "0" -&gt;` `case file:read_file_info(Filename) of` `{ok, FI} -&gt;` `Tsize = integer_to_list(FI#file_info.size),` `[{Key, Tsize} | do_handle_options(Access, Filename, T)];` `{error, _} -&gt;` `do_handle_options(Access, Filename, T)` `end;` `_ -&gt;` `handle_integer(Access, Filename, Key, Val, T, 0, infinity)` `end;` `"blksize" -&gt;` `handle_integer(Access, Filename, Key, Val, T, 8, 65464);` `"timeout" -&gt;` `handle_integer(Access, Filename, Key, Val, T, 1, 255);` `_ -&gt;` `do_handle_options(Access, Filename, T)` `end;` &amp;#x200B; So it looks like it does handle this option there! I do not have a tftp client kicking around to test this, and I am now out of time to dig further, but maybe try this and see if it works? &amp;#x200B; And yes, the tftp docs are pretty sketchirific. :/
soooomething like this perhaps: &amp;#x200B; `Index = binary:longest_common_prefix([Id, Node]).` `IdByte = binary:at(Id, Index).` `NodeByte = binary:at(Node, Index).` `8*Index + (8 - trunc(math:log2(IdByte bxor NodeByte) + 1)).` longest\_common\_prefix gives the length of the common prefix. from there we can then get the next byte in each binary (if you do not know the sizes of the binaries, then you will want to do a size check first to make sure Index is not out of bournds...). then we get the first different bit between those bytes by binary xor'ing them and then asking for what log2 of that is and then add one for the ones-place in binary .. then minus that from the 8 bits in a byte ... then add the number of bits in the common prefix ... number of bits common! &amp;#x200B; not well tested (by which i mean: not tested at all! haha.. sorry :) ) but should hopefully be close. &amp;#x200B; really interested in seeing your kademlia implementation! do you have git repo link yet?
That's way nicer than my shitty solution, which involved converting everything to a lists and recursing through them. So thanks! No, sorry, no repo link yet, this is an academic work (bachelor thesis), so automatic plagiarism checks are a concern. But I'll make a note of your username and send you a link when that's no longer a concern (I'm thinking two months, probably). I'm planning to release it under GPL if it's decent enough to be a net positive for the world. The project itself is kind of like BitTorrent with an added layer of relational metadata, for use in distributed social media.
oh wow. Thank you very much. I now see what I did wrong, I was doing tftp:change_option(daemon, [{"timeout", "250"}])... So close! 
Nice project! Best of luck with it, and thanks in advance for droppong me a link :)
Why RPC at all? And what it has to do with Erlang?
Nice to see some Efene in the wild!
thanks :)
Does anyone know what happened? Just last month I watching him on a panel.
I am so fucking shocked
What a bummer. Great dude. Also - he looked as someone in good health.
RIP, Joe.
My name plaque on my cube at work has a quote from Joe: &gt;"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.” -- Joe Armstrong :(
This is shocking not only because you think of your heroes as immortal, but he had this energy of a dude who'd live past 120.
Sad news indeed :( One last time, ["Hello, Joe."](https://www.youtube.com/watch?v=uKfKtXYLG78)
According to a commenter on /r/programming he'd been suffering from lung fibrosis for some time, in January his lung capacity was down to 50% and by the end of the course it'd gotten bad enough lectures had to be cancelled: https://www.reddit.com/r/programming/comments/bfchzb/joe_armstrong_the_creator_of_erlang_has_passed/eldqd5n/?context=42
Sad news. He was an inspiring teacher. I'm happy I had the good fortune to meet him.
This got me too, he always appeared to be full of life; seemed sharp and energetic, It was quite a shock to imagine otherwise.
F
Have you tried uninstalling and then passing the `--build-from-source` option to `brew install`?
That's good idea, but when do I need to edit the file (edlin.erl)? If I use `brew install erlang --build-from-source` it downloads new sources and starts to compile it.
Why?
Recursion is basically asking a function to call itself. Each iteration of calling itself is like an iteration in a loop. Tail recursion is like a for loop. Each iteration of the loop is neatly contained, and the iteration finishes neatly at the end. In particular, it means that the function ends with either a solid answer, or a single call to a single function.
tail recursion might be easier to understand with some examples. &amp;#x200B; the factorial function is tail-recursive because the last step is just one recursive call. in pseudocode: \`\`\` factorial 0 = 1 factorial n = n \* (factorial (n - 1)) \`\`\` in this case, the last thing that gets computed before returning is just a call to the same \`factorial\` function with the value of n - 1 as its argument. whereas other recursive functions, like for example, this function that returns the \*n\*th fibonacci number, are not tail recursive: \`\`\` fibonacci 0 = 1 fibonacci 1 = 1 fibonacci n = (fibonacci (n - 1)) + (fibonacci (n - 2)) \`\`\` because instead of the last step being to just call itself with some argument, it has to call itself twice, and then perform some additional operation on the result. because the last step of the computation is actually a \`+\` operation instead of a recursive call, it's not tail-recursive.
I went digging through some old Erlang exercises I was working on back when I was trying to make sense of tail recursion, let me know if this helps: The task was to write a function (or series of functions) to test if a string was a palindrome. % First attempt. This is not tail-recursive. % is_palindrome([], []) -&gt; true; % is_palindrome([H1|T1], [H2|T2]) -&gt; % case H1 =:= H2 of % true -&gt; % is_palindrome(T1, T2); % false -&gt; % false % end. % Second attempt, this is tail recursive is_palindrome([], []) -&gt; true; is_palindrome([H|T1], [H|T2]) -&gt; is_palindrome(T1, T2); is_palindrome([_H1|_T1], [_H2|_T2]) -&gt; false. In the first example, I had buried the recursive call to is_palindrome(T1, T2) inside a case statement, and had not used it as the final instruction in the function. Both methods will work, and return the same answer, but the second version, while it was trickier to write, is the one that takes advantage of erlang's optimizations for tail recursive functions.
Both functions are tail recursive here, and I believe that both functions have tail call optimisation. If you implement some server loop with a receive clause and some code to handle the values received, you can still loop forever.
Not sure if it can help but to understand tail recursion you can imagine this code : for (i = 0; i &lt; length; i++) { do_something(i); } And a tail recursion version in Erlang : for(I, I, _DoSomething) -&gt; ok; for(I, Max, DoSomething) -&gt; DoSomething(I), for(I + 1, Max, DoSomething). But this is not really great code. The full module: -module(for). -export([for/3]). for(I, I, _DoSomething) -&gt; ok; for(I, Max, DoSomething) -&gt; DoSomething(I), for(I + 1, Max, DoSomething). And then a shell session: $ erl Eshell V10.1 (abort with ^G) 1&gt; c(for). {ok,for} 2&gt; for:for(0, 10, fun(I) -&gt; io:format("~p~n", [I]) end). 0 1 2 3 4 5 6 7 8 9 ok
Hmm, I must have received some incorrect advice when I was first trying to figure this out. Thanks for the clarification!
https://www.reddit.com/r/erlang/comments/bjyb7o/could_someone_explain_recursion_please/?utm_medium=android_app&amp;utm_source=share
&gt; Both methods will work, and return the same answer, but the second version, while it was trickier to write, is the one that takes advantage of erlang's optimizations for tail recursive functions. Note that [tail recursion isn't always faster](http://erlang.org/doc/efficiency_guide/myths.html#myth--tail-recursive-functions-are-much-faster-----than-recursive-functions). The last line could have been written ```is_palindrome(_,_) -&gt; false.```, incidentally. No performance impact, just less noise.
Because its not usable for me
I’m just curious for your use-case (where it’s unable). The absolutely easiest to disable I can think of is `TERM=dumb` (although `^G` likely won’t work).
"Faster" isn't the only concern all the time though. I've written functions that worked very well, but blew up the stack and crashed if you tried calling them with a large enough input number. A TCO version wouldn't do that. I've often wondered what potential DoS vectors lay in some of the functions we write.
Hi, It is tipical tail recursion. The clause where N=0 is the termination condition that outputs the final result. You have to go from initial number N to number 0: hence you in every pass decrease the number by 1
Wow...thank you for clarifying makes sense now
You're welcome. Feel free ask again in case of any doubts. Nevertheless, I recommend to look at https://learnyousomeerlang.com/content . It's a perfect material
This is where I got the example from, just something I was hoping you could clarify for me with regards to pattern matching. Is _ like a placeholder value?
_ means any value _Anything with underscore - means match against, but do not bind. But beware, if you have in pattern matching two same variables names they have to be the same: (_A, _A) matches only the case, where the two values are the same. (_A, _B) matches any values (_, _) matches also any values
thank you very much :)
got to meet him at EUC 2016 - this is heartbreaking
OK. Let me see if I can help. I made two diagrams for you. One is kind of confusing since it mixes function evaluation with message passing, the other one just shows messages. TL;DR: Your understanding is pretty accurate. The only flaw I would spot is that when "someone sends a stop", the server doesn't "send the atom 'ok'", the function that the server process is evaluating *returns* `ok` and since that function was completely evaluated, that process is terminated. So, the diagrams: ![Everything](https://www.websequencediagrams.com/cgi-bin/cdraw?lz=dGl0bGUgRXZlcnl0aGluZyAoRnVuY3Rpb24gY2FsbHMgJiBNZXNzYWdlcykKCm5vdGUgcmlnaHQgb2YgWW91CiAgICB5b3UgYXNrIHRoZSBzaGVsbAARBXRvIGV2YWx1YXRlIGV4YW1wbGUvMAplbmQgbm90ZQpZb3UtPgApBToAFwcoKQBRDwAYBgBNBiBzcGF3bnMAXgZlcnZlcgoAZgUtPj4qUzoADAcAKhh0aGF0IHJldHVybnMgUywgYSBwaWQKUy0AeQggUwCBVAZvdmVyIFM6AFoLIGJsb2NrcyBvbiByZWNlaXZlCmFjdGl2YXRlAC0IAIEOIWNsaWVudACBJQpDOgAMByhTAIFrBwBzBQCCNQUsAHkGAIEkCwCBJwUAgT0FJ3MgaWdub3JlZApDAIExCkMAgw8GbGVmAIIiEgCBawgnb2snIHRvIHlvdQCCLwctPllvdTpvawAvDgCBEQkgc2VuZHMgJ2hpADMFAIJqB0MtPlM6e21zZywgImhpIn0KZGUAgX0QAIB_CACDCgkgcHJpbnQAgzIGbQCEQwYKUy0-Uzpmd3JpdGUoIlMgZ290OiBoaSIAggEMAIJVMACBOQkAhQwFAIE3DnN0b3AAgTsMICAgIGFuZCBkaWVzAIUGCgCBWAVzdG9wAINyGQArBQCBZg1kZXN0cm95AAEJeSBDCgo&amp;s=modern-blue). ![Just Messages](https://www.websequencediagrams.com/cgi-bin/cdraw?lz=dGl0bGUgSnVzdCBNZXNzYWdlcwoKbm90ZSByaWdodCBvZiBzaGVsbDoAAQYgc3Bhd25zIHRoZSBzZXJ2ZXIKABoFLT4-KlM6AAwHKCkAPAZvdmVyIFM6ACILIGJsb2NrcyBvbiByZWNlaXZlCmFjdGl2YXRlIFMAUCdjbGllbnQAbQpDOgAMByhTAHEHbGVmAIE0BQARCSBzZW5kcyAnaGknIHRvAIExCEMtPlM6e21zZywgImhpIn0KZGUAfRAAQggAgVIJIHByaW50AIF6Bm0AgioGClMtPlM6ZndyaXRlKCJTIGdvdDogaGkiAIFJPACBOQkKICAgAIE2D3N0b3AAgTsMICAgIGFuZCBkaWVzCmVuZCBub3RlAIFXBnN0b3AAgnIZACsFAIFmDWRlc3Ryb3kAAQl5IEMKCg&amp;s=modern-blue)
I thought ASDF was a Lisp build tool. I'm confused.
It is, and I am, too.
I thoroughly recommend this tool. I’ve been using it for years, and it’s a great way to manage install versions across projects. I also use it inside alpine docker images for development. Works great with direnv too.
The first issue is that your helper method is generating 'improper lists' - if we expand out a call to `helperRepeat(3, 2)`, we get something like this: helperRepeat(3, 2) -&gt; [3|helperRepeat(3, 1)] --&gt; [3|[3|helperRepeat(3, 0)]] ---&gt; [3|[3|3]] If you look at the final representation, you'll see that the innermost value isn't a list with one element `3`, it's _just_ a 3. To fix this, we can change your `helperRepeat` method to this: helperRepeat(Val, 0) -&gt; [Val]; helperRepeat(Val, Repeat) -&gt; [Val|helperRepeat(Val,Repeat -1)]. Note that the final `Val` is now encapsulated in a list. When we re-run your repeat method, now we get this: 9&gt; foo:repeat([1, 2, 3], [0, 4, 1]). [[1],[2,2,2,2,2],[3,3]] So the lists are now proper. However, our output from `repeat` is still a list of lists. You can solve this by calling `lists:flatten` on the output: 10&gt; lists:flatten([[1],[2,2,2,2,2],[3,3]]). [1,2,2,2,2,2,3,3] or by using the `++` operator instead of the `|` operator, in which case [helperRepeat(X,Y)|repeat(Xt,Yt)]. becomes helperRepeat(X,Y) ++ repeat(Xt,Yt). Note that your call structure is such that you cannot benefit from tail call optimization - each recursive call in both `repeat` and `helperRepeat` will force the interpreter to push another stack frame, since your final operation is not a function call. There are some [excellent tutorials on this](https://learnyousomeerlang.com/recursion), and I would suggest you see what they have to say about it and the accumulator pattern, which is generally the way to solve this.
Excellent! Thank you for walking me through that! I got the result I was looking for. Thanks also for that resource, I was struggling to figure this out using the documentation.
Joe wrote a piece that can help you here https://joearms.github.io/published/2016-03-13-Calling-Elixir-From_Erlang.html I miss you Joe.
Think of Elixir as a superset of Erlang. You won’t loose out at all. I would say though that Erlang is more compact and has less magic than Elixir. It’s a good vehicle to get introduced to functional programming. I can’t recommend Armstrong’s book on Erlang more highly. OTOH Elixir has a fresher and more vibrant ecosystem. Learning Elixir means that you can use the Phoenix framework for instance. Why don’t you learn both? The languages are not very big and different under the covers.
Erlang (or my favourite Elixir) sounds like it could work well for your problem. It’s great for reliable network services. Getting top performance for CPU bound code is harder when you don’t have mutable data structures, but calling out to C (or rust / go) can be used to address hotspots. Most of the community is on the forum https://elixirforum.com or slack https://elixir-lang.slack.com/
Thanks for the input. So to address output I would need to run different programs, by example in C, on the fly. But I'm wondering about the performance of this action, because it will like to start many OS processes for each communication between ErlangVM and the C programs --- which are slower and heavyweigthed compare to the Erlang processes. Also, it may raise the problem of the hot code reloading, which in this case it's maybe not supported well.
Sounds like [port processes](http://erlang.org/doc/tutorial/c_port.html) could work for calling C plugin programs. Some [pooling](https://github.com/devinus/poolboy/blob/master/README.md) can be used to prevent spawning too many os processes.
Yes definitively port could work. How hot code replacement works for ports ? Is it possible or do I need to use port drivers ? Also, if a port is already open, does the Erlang process is smart and not open a new one by just sending him the message ?
This is a 40 minute talk from GOTO Chicago 2019 by author of 'Elixir In Action', Saša Jurić. I have pasted in the talk abstract below for a read before you dive into the talk: &amp;#x200B; Whether you're developing a small web site or a large-scale distributed system, Erlang and Elixir are great tools for building server-side systems. Both languages can help you start quickly and deal with highly complex problems at a large scale. This talk aims to explain what makes Erlang and Elixir suitable for such tasks. We'll look past the syntax and the ecosystem, focusing instead on the concurrency model of these languages. Combining a bit of high-level theory and a couple of demos, we'll examine some important properties of Erlang/Elixir concurrency, with a special emphasis on why these properties are very relevant when building highly available systems. The talk targets experienced backend developers, but no knowledge of Erlang or Elixir is required. You will walk away from the talk with a better understanding of what distinguishes Erlang and Elixir from the rest of the pack, and why these languages are very compelling choices to power your next software system.
The important concepts and semantics are all inherited by Elixir from relying on the Erlang virtual machine and ecosystem. But there are conceptual differences, or even just different ways of thinking about problem-solving in Elixir, otherwise it wouldn't have been worth creating a new language. The semantics of the VM and ecosystem are great and what gives Erlang it's concurrent/parallel/distributed processing power, but much of Erlang's actual *syntax* focuses on its sequential subset of the language, which is unfortunately very primitive. That superficial syntax is not as important as the rest of the underlying semantics, and so that's why there have been languages of various styles and paradigms put on top of the Erlang VM, such as Lisp-flavoured-Erlang (which brings Lisp homoiconicity), Gleam (which brings ML-like static typing), and of course Elixir which is inspired by Ruby yet very different. &amp;#x200B; Elixir's improvements mostly regard syntactic sugar and style, but also other concepts that won't contradict how the ecosystem fundamentally works. One example is protocols, which brings polymorphism to the ecosystem. In contrast, Erlang syntax had no way of supplying this, so that if different primitive types were involved, you would have to locally use "case", guards, or pattern matching to explicitly dispatch the intended code to run. And you would have to do this everywhere it is required, rather than defining this in one place. People mistakenly think OOP is required to have polymorphism, but that's not true. But Erlang's lack of it didn't help. Erlang also tends to rely on its "record" data structure for essential types, except records aren't real types at all! They don't even exist at run-time, they are just syntactic sugar that exists at compile-time. Erlang's rather inconsistent standard library and over-reliance on records can be frustrating. Elixir fixes all this by ditching records and instead relying on protocols and things that are usable at run-time, like maps and "structs" (which are another way Elixir helps with allowing user-defined types). &amp;#x200B; Elixir's pipe operator doesn't add new concepts, but it does bring the *concept* of functional programming and the *syntax* of functional programming closer together. Conceptually, a function takes input from the "top", transforms the data, then spits the result out the "bottom". So using multiple functions together is conceptually a chain of functions and should *look like a chain*. But the traditional historical syntax of calling functions forces the user to nest functions inside their parameters lists. So chaining looks more like nesting, which is confusing and hard to read. The pipe operator fixes that so there is no mental overhead translating visual nesting into semantic chaining. The *flow* of chaining functions looks like a chain. If a language is a functional language, then if functional programming (i.e. the most common thing you do) is made awkward, then the whole language will be awkward. Erlang tends to be awkward compared to Elixir in this respect. &amp;#x200B; There is even more to it than this, such as Elixir's more consistent standard library which includes a lot of patterns/solutions to common problems, and metaprogramming that uses code to generate code so that Elixir can be run at a higher level of abstraction than just functions and primitive types. Metaprogramming allows you to add your own syntactic sugar or new semantics. For example, this person added OOP on top of Elixir (mostly as a joke, so please don't use it since it's a bad idea!) [https://github.com/wojtekmach/oop](https://github.com/wojtekmach/oop)
Great video. I just discovered Erlang and it makes me appreciate it more thanks :)
in simplistic views, When hot swapping code, erlang actually have both versions in memory and runs the old version until your code calls a function with the full name (brain freeze here, what is it called) eg. MODULE:FUN(Args) at that time it calls the new code. so if the execution is in a fun of your old code it will continue to run until it changes the module
I'm general, when doing communication between processes, I would lean towards leveraging OTP. Process B should be a genserver (supervised) and process A should issue a gen_server:call to process B and get the result that way.
this. also in your second example \`Response\` would be \`action\` and non blocking as opposed to the first example.
If B is a genserver, two requests are coming concurrently, and if the first request calling B fails, the second will impacted? Or every call/cast are spawned process? In OTP, is there a system managed by the supervisor to replay when fails? (until X failures happens and send back error to the client)
If process B fails/crashes then any messages in it's mailbox will be lost. However, if you are using genserver:call you will receive a timeout error in the caller that did not receive a response (mag's that were still in mailbox). You can use this to determine if you should retry the call. Disclaimer: I am not an expert in OTP, just a fan. There may be more elegant ways to handle this. 😉
Thanks very much :) not problem. I'm starting to be fan also. But i'm wondering why it's not more famous and educated....
Even for ports? Erlang is keeping two versions?
There is no good answer. What are you trying to achive, why do you need two processes ?
Example it's a server handle request from client each connection is handle through a new process or is it a general connection handler process witj handle through message
Most erlang web servers handle each connexion with a single process, sometimes more.
So imagine a process handling a connection which relays on a business process. Is this process must be already created and receive calls(business process still running), or just spawn a new business process and get response (the business process will be killed after)
That depends if you need state. &amp;#x200B; If your business process needs to keep some state, and change this state after handling requests, it's best to start it at the application startup and then communicate with it with messages. &amp;#x200B; If you do not need state, you do not even have to spawn a business process just to kill it afterwards. Just execute the code in your request process.
Great thank you :) But if my business code crashes, maybe it is better to use task or process to be able to supervise it, without crash the connection process and be able to retry few time
Well you can juste use try/catch for that.
But it is not opposite with the "let ot crash" philosophy?
This philosophy applies to processes and supervision trees. If you know how to handle an error, handle it. But if you don't, then it will crash and it is not a big deal since your whole program will not be impacted by this failure, or will be able to recover. It really depends on what you want to do. Here you give little details on that.
for ports programs use the dirty schedulers. I guess it is when the port program finishes that the change is. it is usually a good idea to implement port programs that finishes in a timely fashion. otherwise you should probably not have them running within the vm.
Yes true.. Thanks for the details :)
I don't know for sure what he's referring to but I know our team didn't use distributed features of elixir very much because of the potential for split brain problems. They wouldn't have been impossible to fix, but at our scale it was much more efficient to just rely on a single database for locking and being the single source of truth in the system.
He does not explain what his issues are, so it is hard to address those. It does not help the veracity of his claim that he just basically says, "It's broken, trust me." \*shrug\* He is promoting swarm (which is a pretty nice library, fwiw), so he isn't coming into that completely neutral. As an aside: his justification for swarm being a dependency being obviously the right place for distribution makes absolutely zero sense. But that said, there are a few undesirable things with distribution in Erlang, and he is right that most if not all are implementation issues (and therefore fixable) rather than fundamental to the design. Ones I am aware of: * by default distribution is handled by a separate process (epmd). This is actually not necessary anymore, and it is easy to replace epmd (and even alter how it works) with a simple module in your own app. * there is still only a fully-connected mesh topology offered. That presents scaling issues, which are resolvable with alternative topologies with some routing of messages included. There is work to address this, but it does not seem near to being folded into the official beam+OTP distribution yet. * security is limited. not an issue if you are using distribution on a private network behind front-facing systems. but the cookie and not having tls by default is all a bit 'meh' .. it's unecessary overhead in a 'sealed' private network, but if you want to run this anywhere publicly routable, you'll want that. * the use of binary\_to\_term/term\_to\_binary for formatting on-the-wire messages is insanely suboptimal for a lot of common data structures in modern applications (though more than fine for small messages) due to its serialization format (at least now it does the serialization reasonably quickly ... now it just makes HUUUGE buffers for the wire, and requires them to all fit in memory ..) &amp;#x200B; That said ... distribution still works rather nicely, and all the above can be fixed under the covers without changing the way network-transparent message passing works from the perspective of the application code written on top of the BEAM.
I'm not too knowledgeable on the topic of distribution but Christopher Meiklejohn has done some real fascinating work on alternative methods of distributed programming using Erlang. He has a project called Partisan that he's been working on as part of his thesis and this year at code beam he showed some improvements he's made to it and compared it to standard Erlang distribution. https://youtu.be/KrwhOkiifQ8 Hope it helps.
From u/sasajuric himself: https://www.reddit.com/r/elixir/comments/bronlx/discover_what_makes_beam_languages_such_as_erlang/eohwr3r/
If you are using `rebar3` as your build tool, you can include the [rebar3_mix](https://github.com/tsloughter/rebar_mix) plugin to build Elixir dependencies. I don't know if there is something similar for erlang make. To actually call an Elixir function, you will need to use the following syntax. `'Elixir.Module':function(Arg)`. As a full example, lets call elixirs `String.trim/1` function. `'Elixir.String':trim(Str)`. Note that I have never actually used the `rebar3_mix` plugin.
I have done something similar (generate Erlang gen_statem from XML). It entirely depends on your need and the type of state machine. I ended up writing a function to handle my transitons, e.g.: statemachine(State, Event) -&gt; NewState). If you have a moore machine, you can then perform some action depending on the new state: statemachine(NewState) -&gt; action(). If you have a mealy machine, you can first generate a transition, then peform an action for the transition, and finally calculate the new state. The code generation is quite simple with python. I ended up using f-strings most of the time.
Maybe http://howistart.org/posts/erlang/1/ ?
[There are other options besides state_machine_cat](https://stonecypher.github.io/jssm-viz-demo/graph_explorer.html)
Thanks, I will try f-strings or [jinja templation](https://blog.kangz.net/posts/2016/08/31/code-generation-the-easier-way/).
There indeed are. But state\_machine\_cat seemed to be the simplest with good coverage. I was originally looking for a js-based canvass for building (mealy) state machines, with a drag-and-drop from palette, that would generate a json (or some other standard). Found Rappid, but was expensive.
Hey guys, i just released v1.0.0. Since the port runs outside of erlangs safety net, every bit of help is especially appreciated to make it as rock solid as it can be. I have no plans to add features/complexity from now on and will be concentrating on fixes. Thanks for reading, have a great day!
Can you talk a bit about what makes your project different from something like [luerl](https://github.com/rvirding/luerl)? Obviously yours runs outside of Erlang while Luerl runs inside the VM. But what other types of choices did you make that lead to this project?
I suppose he is a master of the Tango as well...
He must have been really ‘enthousiastic’ about it.
Lol yea that is bothering me too. The website owners are dutch. Is that a common translation mistake or something? The spelling mistakes riddling this website and the insane claims from their developers have me worried about trusting it with my money...
Since this is a scammy cryptocurrency project, I wouldn't be surprised if all of these people were completely fake.
/r/iamverysmart
&gt; scammy cryptocurrency project Ya think? When I try to navigate away from the about page (say by entering something in the navigation bar), it reloads the about page. How odd.
I've heard Dutch is similar to English in a lot of ways, so maybe it was a spellchecker-dictionary conflict? Yeah, it seems strange to master Erlang in a week, but not proofread your bio page: one of the main pages that gets you an offer. They must at least have a friend of a friend who is fluent in English enough to take a read. I'm pretty sure there are external proofreaders if you really need one. The most confusing part for me was the last person who basically just had 'I know maths' in stark contrast to the rest of the group.
It's a naturally developed but multiple times completely rewritten project for the joy of it and to facilitate some multiplayer game ideas i have. Luaport makes it possible to use [lua c modules](https://github.com/asciibeats/lua-protobuf). It is faster and becomes more viable with complexity of script. A logical next step would be to use luajit over vanilla lua, if you really want that edge. And it shouldn't be that hard to do.
SO many crypto related jobs using Erlang.
I know this supposed to be about the Erlang part but holy shit this is dangerous. "Investing" in bitcoin is already bad but derivatives on them is crazy. This is a derivative exchange put on by people who don't know the difference between an American Option vs European Option. From their FAQ: &gt;Are Options European style? &gt; European Vanilla Style. Exercise is automatic if they expire in the money. Cash settlement in &gt; the equivalent of bitcoin. That isn't correct. European Options can only be excised the day they are set to expire while American Options can be excised at any given time. If they are truly European Options then you can buy one expecting to be able to excise but not being able to. It could lead to massive losses.
Yea... math expert who controls user interface design?! You don't hire plumbers to entertain at your kid's birthday party...
con-currency using concurrency?
Well, while I know nothing about the company, the person mentioned did manage to find a stack smashing bug in the VM and reported it [https://bugs.erlang.org/browse/ERL-944](https://bugs.erlang.org/browse/ERL-944), so there's that.
That's not all that strange. A lot of mathematicians work outside of actual math jobs. Software development and project management are common. Studying math doesn't just teach you, well, math, but also an abstract way of thinking that is rather unique to mathematicians.
Check out elixir nerves
If you have hard real time requirements, you shouldn't go for any garbage collected language. Or anything non-deterministic. For example malloc; you dont know how long will it take or even it is gonna succeed so you probably should allocate everything you need before entering main loop as long as possible. Imagine you are in remote operation, doctor is cutting you via robot hand aand hand is just freeze because garbage collector or out of memory. 😂😂 But if you have soft real time requirements erlang will be just fine. It designed for highly concurrent, soft real time systems. It has per process gc so there is no big gc stop and also it guarantees context switch each bla bla instructions.
erlang would be good at orchestrating thousands of ev3-powered robots
i remember when it was time for coffeescript to die, they had all started explaining how to integrate with gradle
You think elixir is gonna die? Any reason for that?
True! Thanks
Looks interesting
A lot of us have been augmenting the beam with native code... just look at how many packages on hex.pm come with some. Rust brings some nice advantages over some other popular options and has really great support on the beam side thanks to libraries like rustler. This is absolutely no different to how much native code is used in libraries to accelerate python, btw.
Really hard to say anything without a link to code..
Things don't die for a reason. They die for lack of a reason. I didn't have a reason for it around dart, coffeescript, perl, php, kotlin, flex, groovy, etc either.
[https://github.com/ArtamonovAlex/BarOBeerChat](https://github.com/ArtamonovAlex/BarOBeerChat)
A link to a repo.. sorry, not going to dig through it :/ Here is how Elixir does it: https://github.com/elixir-lang/elixir/blob/v1.9.0/lib/elixir/lib/io/ansi.ex
Is it just me or does anyone else get "502 - Bad Gateway" from Medium?
cloudflare outage today
Ahhh 😊
Is it me or the whole point of the article was to claim that Elixir docs are better than Erlang docs? Low quality shitpost :) IIRC Joe's Erlang book goes very early on into the details about how operators behave.
Made a reddit account just to be able to upvote this. This is pun perfection!
Not sure about the future. Erlang &amp; Elixir popularity stats from StackOverflow [https://insights.stackoverflow.com/trends?tags=erlang%2Celixir%2Ctypescript%2Ckotlin](https://insights.stackoverflow.com/trends?tags=erlang%2Celixir%2Ctypescript%2Ckotlin)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [Manuel Rubio - PHP over Erlang: how and why? | Code BEAM STO 19](https://www.reddit.com/r/elixir/comments/cd1rq1/manuel_rubio_php_over_erlang_how_and_why_code/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Yeah.. no.
I’m calling the police
I would take Twig over EEX anyday, but not PHP directly ;) Funny experiment though.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Wish I could go, but it conflicts with Rosh Hashana
You can pattern match on a constant list prefix, but not a general pattern in the middle of the string. In your case I’d go for a [regex](http://erlang.org/doc/man/re.html#run-2)
You could also consume the list until you read the leading [, accumulate what characters exist until the terminating ]. That’s essentially what the re lib is doing for you, as an over-simplification on my part.
&gt;You can pattern match on a constant list prefix How?
You can’t, not with pattern matching alone. You probably want a regex. If the size of what is inside the brackets is always the same length though, you could do it though.
http://erlang.org/doc/reference_manual/expressions.html#string-prefix-in-patterns
then why not to do this: f(Str ++ "{fdsafds}" ++ Str2) -&gt; .. won't this work?
Try wrapping your `Terminator` options in a grouping: Terminator = (\n|\r\n|\r) I believe what's happening is when you combine the un-grouped version into your later compound clauses, the regex is getting misinterpreted.
Wow thanky you, this solve the issue a little bit, it allows 1 foo, but it returns an error for: *---\\nfoo\\nfoo\\n---* &amp;#x200B; `% src/standard_syntax_lexer.xrl` `Definitions.` `Terminator= (\n|\r\n|\r)` `MultilineStringDelimeter = (---)` `StringContent = (foo)` `MultilineStringContent = {StringContent}+{Terminator}` `MultilineString = {MultilineStringDelimeter}{Terminator}{MultilineStringContent}+{MultilineStringDelimeter}` `Rules.` `{MultilineString} : {token, {string, TokenChars}}.` `Erlang code.` &amp;#x200B; `'---\nfoo\n---'` `{:ok, [string: '---\nfoo\n---'], 3}` &amp;#x200B; `'---\nfoo\nfoo\n---'` `{:error, {1, :standard_syntax_lexer, {:illegal, '---\nfoo\nf'}}, 3}`
No. The beginning of the string must be a compile time constant. It’s helpful to see how Erlang strings are De-sugared to lists: the leading list elements must be known to match: [$p,$r,$e,$f,$i,$x | Str]
If you're moving on to the next step of trying to delete the delimiters, you can do that by running a function against TokenChars, but i believe you'll end up needing to redefine your matching patterns down in **Erlang code** to run a proper regex, which is a bummer. Instead, you might consider just using leex to do the tokenization part (as in, just use it to decide what delimiters and content look like), and then leave the interpretation of the ordering of those symbols up to yecc, the rules there can decide that content surrounded by delimiters is a multi-line string.
Hmm, I am really curios what is the best practice or 'industry standard' for a lexer: {multiline\_string, 'foo\\nbar'} or {delimeter, '---'}, {string, 'foo'}, {terminator, '\\n'}, {string, 'bar'}, {delimeter, '---'} &amp;#x200B; If I do it like the last, I can also add an escape character, so for input: '*''foo\\n\\'''\\bar'''* {delimeter, '---'}, {string, 'foo'}, {terminator, '\\n'},{escape\_character}, {delimeter, '---'},{string, 'bar'}, {delimeter, '---'} &amp;#x200B; And with yecc I can decide if the delimeter is part of the string, or not. &amp;#x200B; Would this be the proper approach?
Probably create a pool of ports and communicate with them through a GenServer that manages state. You could look at how Ecto adapters work and maybe something like [Piton](https://github.com/mendrugory/piton) that manages a pool of ports with backpressure.
I'm afraid I can't speak to industry standards, having just played around with the lexer/parser for comparatively trivial cases, but you might like to poke around the elixir source code for inspiration on how to handle "heredocs". As far as I can tell, they don't actually use leex for parsing, but they do use yeec for parsing. https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_tokenizer.erl#L937 https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_parser.yrl#L880
Thank you very much :) I will consider that.
Or is the unix socket is an alternative to communicate with port or through temporary files?
Please, if you want to post the same question on r/elixir as well as on r/erlang then use x-post feature, so the answerer can write answer in one place only.
Thanks I didn't know this feature