`ab` is notoriously bad at testing against erlang and elixir, please consider using `wrk`. 
Why is that?
Any chance you can summarize the findings?
It is an issue between Cowboy not sending the proper keep-alive header which is optional for HTTP 1.1 but not HTTP 1.0 and how Apache Benchmark reacts to this. I believe it forces Apache Benchmark to open more connections than it should, slowing everything down. Apache Benchmark is generally known for skewed measurements under high concurrency so `wrk` should give more faithful results.
Yes! I just posted the summary of the request per second throughput for each Language/Framework
It looks like that book may not be published by O'Reilly after all, it may be published by PragProg instead: https://pragprog.com/book/eserlang/the-erlang-runtime-system
Two projects of note here: https://github.com/epgsql/pgapp https://github.com/josephwecker/epgsql_pool
Yes.
This answer was definitely more than I expected, thank you so much! Allow me to collect a few more grains of knowledge from you, hopefully abstracting a bit more from Erlang itself and mostly focusing on the algorithm itself, please correct me wherever I'm wrong: Each microprocess is essentially like any other interpreted language, a structure containing a function pointer, a heap-emulated execution stack (and execution pointer). Erlang will pre-allocate a chunk of memory beforehand, and use that for both the stack and dynamic memory needs. Do you happen to know anything else of interest I should look for inside the source code? Internal organisation of the memory in the heap and how it's resized? Erlang will implement a Round-Robin scheduler, that will read Queued up microprocesses from the main process and execute them, until they are preempted by Erlang's own "counting unit" called reductions. Here is where I got some conflicting information from what I previously read, you mentioned the scheduler and execution are kept in a single core, and executed from there. I heard before that Erlang spawned multiple threads beforehand, so I am assuming each of these threads have it's own scheduler in isolation, instead of being kept in a global queue with a lock. If thats the case, do you happen to know how the processes are dispatched to each thread and how the queues between threads are kept balanced? In addition to all that, each process has it's own message queue, with it's own lock. And it will automatically hang for receiving messages. If my assumptions from the paragraph above are true, where does Erlang keep track of the process-thread relationship, for processes to find each other and message passing? Also another question: Traditionally, the OS will handle the low level IO, and preempt the thread until IO is complete. Does Erlang let the threads hang or does it do something to avoid OS preempting for IO, such as having a separate thread where processes will dispatch IO to? Again, thank you so much for this information. It's been a tough job to find decent documentation on this on the internet. Cheers.
This thread is pure gold. Thank you OP, thank you /u/kvavks !
I don't reckon this to be the right subreddit, but neat coincidence, I guess.
How did you run erlang and elixir solutions? How many cores you have, what VM flags you used? BTW, packing 8000 rows to JSON can be expensive, did you tried to use streaming JSON encoder? 
The heap grows linearly from beginning of the array towards the end. Simply said anything allocated on the heap is just placed there at heap_top pointer and pointer is increased - so that is very cheap to place something on Erlang process heap. When heap top meets the stack pointer, heap is considered full and minor or major GC is performed creating a new heap of possibly larger size with all relevant data moved there, the old heap is freed as a single block. A value on heap can be: * immediate (an integer, atom, or something similar simple which fits into an integer minus 2 bits) * cons (a pointer to 2 more words on heap, one contains head, and another contains tail for a list) * boxed (a pointer to 1+ more words on heap, this can be a tuple, float, binary, big integer, pids, port ids, funs, refs, exports, maps — all that sort of thing that doesn't fit into a single integer) * a header (anything else which should be considered an opaque block of data and garbage collected or moved as such) Not sure how this maps to your Lua VM concept, but anyway i had to explain :)
I ran all tests locally on my Mac Pro i7 16GB RAM. I realize the variance in compute may lead to inconsistent results. You're right about the JSON, which leads me to believe that may be a reason Python performed better than expected. What's a steaming JSON encoder?
In Elixir. The code get compile to Erlang Byte Code which run on top of BEAM virtual machine(where the user space scheduler take place). Similar to Scala/Julia code get compile to Java Byte Code; then run on top of JVM. In another words: Elixir/Erlang process scheduler are the same.
Thanks for the resource!
You can get somewhat close to Erlang share-nothing architecture if you run multiple LUA VM's in parallel, each able to run some "processes" or "fibers" or "lightweight threads", or even one thread is still not bad. And then provide a way for them to find each other's ids (a process registry that is visible to all LUA VMs at once) and to send "messages" to those ids (a C function that sees all LUA VMs and can push some value in their memory). Sending a message is as easy as copying a value to other process memory and notifying it where the data is (say appending to mailbox variable). This will basically be a form of interprocess communication between LUA VMs. Next step would be switching LUA VM between LUA contexts inside same LUA VM, like run for X msec then pause and take next in the queue. Not sure if that is possible, but probably it is so get digging! Combine this with sending to a "process" id, i.e. finding LUA VM that owns specific process, and finding its mailbox, and updating it. This is more tricky but looks like way towards your goal.
1. First make it run single thread. Mark places where locking makes sense. Plan for it ahead, then try multiple threads. 2. Sometimes it is a good idea to throw away last few commits and rewrite. Or throw away the branch and rewrite whole feature. Multiple rewrites make your code smooth and well thought through. Solving the problem first try with multiple threads is a bumpy road to fail :)
This question is so generic, that one can either write an awkward book in the comments or recommend an already written one. Read: - [Programming Erlang](https://pragprog.com/book/jaerlang2/programming-erlang) written by Joe himself, to get the basic understand what exactly Erlang is. - [Designing for Scalability with Erlang/OTP](http://shop.oreilly.com/product/0636920024149.do) written by Francesco Cesarini &amp; Steve Vinoski, to use Erlang and especially OTP to create distributed, fault-tolerant systems. 
You can manually set up how Erlang nodes connect together via the command-line flag `-connect_all false` when calling `erl`. From http://erlang.org/doc/reference_manual/distributed.html &gt;The nodes in a distributed Erlang system are loosely connected. The first time the name of another node is used, for example, if `spawn(Node,M,F,A)` or `net_adm:ping(Node)` is called, a connection attempt to that node is made. &gt;Connections are by default transitive. If a node A connects to node B, and node B has a connection to node C, then node A also tries to connect to node C. This feature can be turned off by using the command-line flag `-connect_all false`, see the erl(1) manual page in ERTS. Though I don't know how reliable Erlang is when not going across a local network. The likelihood for partitions is much higher. Also the security among internal node connections is basically nonexistent. If you're concerned about that (and you probably should be), you'll want to avoid using regular node connections. [LYSE has some stuff to say on this topic](http://learnyousomeerlang.com/distribunomicon)
indeed it does: {relx, [{release, { testRel, "0.1.0" }, [testRel, sasl]}, {sys_config, "./config/sys.config"}, {vm_args, "./config/vm.args"}, {dev_mode, true}, {include_erts, false}, {extended_start_script, true}] }.
Yeah, I keep thinking I really should just give up on windows development, but I don't have the hard drive space for a new partition at the moment, haha. Thanks for the help!
That does not appear to fix the problem for me, thanks
What's going on with spam on this sub?
Any plans to pick up where Greg Burd left off, and finish plugging this into Riak?
Yes, but that will take some time. I plan to write a mnesia_ex plugin first, as I would like to use lmdb as a mnesia backend and at the moment I'm also developing a wrapper for elixir that plays nice with elixir's enumerable and collectable protocols. Btw, thanks for this great library, but also for the accompanying documentation. Made developing this driver a fun experience!
i use emacs for development. I have been using emacs for over 20 years now, so I am pretty familiar with it. What are you trying to accomplish? 
Nothing really, as mentioned use it with RabbitMQ at work. But my main dev is more python, php and js. Just trying to wrap my head around erlang while playing with different ideas.
This. Reading LYSE is a project in itself. I would say feel free to SKIP the "Who Supervises the Supervisors?" and the "Building an Application With OTP" on your first reading. Some of those things won't really make sense until you have a few Erlang projects under your belt and start facing the problems that more advanced supervision can solve for you. P.S.: Oh, and expect LYSE to take around 6 months to get through.
some kind of pub/sub with tcp/http/mqtt interface is a good fit for erlang
I am an Erlang developer but I've also done some work in Elixir. Some nice advantages of Elixir include: * Polymorphism via protocols * Better metaprogramming with macros * Nicer standard library in which the order of arguments has been fixed to work better with pipelines * Speaking of which: pipelines! The pipe operator makes code so much easier to read and write. * Honorable mention goes to Elixir's "for" comprehension. Yes, Erlang has the similar list comprehension but I find the Elixir syntax to be much nicer. * Finally: tooling. Elixir provides a modern build/test/package/release tool chain that is a pleasure to work with.
I have written projects that use cowboy as a server. And I have used it to make APIs, and to serve javascript and html. https://github.com/BumblebeeBat/FlyingFox
Have you looked at [cowboy-swagger](https://github.com/inaka/cowboy-swagger) before? I want to use the yaml file that describes a current php project; to auto-generate erlang handlers. It uses trails, routing on top of cowboy. Then I will be able to convert the php functions I want to erlang.
Good idea
Did you already bind a value to Pid? Saying Pid isnt magical or anything. What is the actual bad match message? 
Broken link to et:phone_home page. Is it intended? ;)
It's probably just [Pierre](https://github.com/fenollp) messing up with erldocs :P - I changed the link.
[Erlang](https://twitter.com/erlang_budgie/status/769435371067224064). 
Glorious. I actually laughed. Thank you :)
Your file writing bottleneck is probably the operating system, and creating multiple files for the OS to handle may be where things are slowing down. If you're on a Linux system, try using strace with the -tt option to report system call times, and compare the results of running the two programs. If my bottleneck were disk i/o, I'd want different files on different disk drives. Maybe that's your bottleneck, or maybe the OS switching between those files is your bottleneck. You'll have to measure. If your network is faster than your file access (you'll need to measure) shard across different hosts (not virtual hosts, unless you know they're guests on otherwise idle physically different real hosts). Erlang has mechanisms to do that, but you do need to set things up; see Chapter 10 of Joe Armstrong's "Programming Erlang".
I'm a newbie to Erlang so maybe I'm totally wrong but... '--' operator [seems to be right-associative](http://erlang.org/doc/reference_manual/expressions.html#id85024) which means that the following happens with your expression: Step 1: [1,2] -- [2] results in [1] Step 2: [1,2,3] -- [1] (result of Step 1) results in [2,3] Specifying precedence with parentheses obviously changes the order of evaluation giving the result that you maybe were expecting? ([1,2,3] -- [1,2]) -- [2]. [3] edit: formatting
Yes, that makes sense. Hard drives are single threaded hardware. Multiple processes on the same hard drive can't make the hard drive concurrent with itself. thank you
Did you measure break duration? How long is it on your robot? Is it not negligible? If you use OTP for upgrade (if i remember the upgrade scenario right) - the new code is loaded, processes are given chance to upgrade state to new version, and then a long call (Mod:Fun(Args)) is made into the module which switches process to a new module version. Measure if this delay is negligible or come back with numbers :) My solution is alternative idea for the situation when upgrade is expensive (takes many milliseconds which you can't afford) - in this case you can control upgrade manually on a per-process basis. It would probably make sense to change module name on upgrade, so that you can load its code, and transfer ownership without risking all other modules with the same name upgrading.
It will remain at this level times number of processes running the same module. Upgrade will not lock your system, but rather in some sequential or parallel way processes will stop and continue one after one. There is no interruption in service in general. Again you can try it with say 100 same processes running same module, and then you perform the upgrade. At 20ms per upgrade it will take 20ms times 100 (2 sec) but not a solid 2 second interruption, rather 2 seconds of rolling upgrades one process after another, and keeping the service running meanwhile.
Have anybody looked into creating template cowboy handlers using a swagger yaml file? Basically creating a empty restful api of the swagger definition.
Well, sumo_db uses [Emysql](https://github.com/inaka/Emysql)… I don't know any other one.
Might be worth taking a look, but then again I'm a novice, so just hanging around in the sub.
Seems very expensive at ~£42.
Indeed, that's why I won't buy it without knowing what's in there.
http://spawnedshelter.com More specifically, on that list watch Robert Virding's talk entitled Hitchiker's Tour of the BEAM
in addition to the list on [spawnedshelter](http://spawnedshelter.com) check out the following video's * [Erlang engine tuning](https://www.youtube.com/playlist?list=PL9MhXsiBgon5QVFi3rQDZAlftwPCW8gLc) From Erik Stenman * [Understanding the Erlang Scheduler](https://youtu.be/tBAM_N9qPno) FromLukas Larsson * [Scheduling in the Erlang VM](https://youtu.be/_i0AscBx3vk) FromLukas Larsson * [Memory Allocators in the VM, Memory Management](https://youtu.be/YuPaX11vZyI) From Lukas Larsson * [The Erlang VM or How I Stopped Worrying &amp; Started Loving Parallel Prog.](https://youtu.be/ArRr4trTCjQ) From Erik Stenman * [Virtually Instructional](https://youtu.be/5T5pYVw5WtY) From Lennart Fridén * [Scalability of the Erlang Virtual Machine and its Term Storage](https://youtu.be/57PhGxzgCoM) From Kostis Sagonas * [Hitchhiker's Tour of the BEAM](https://youtu.be/owCu5rveBYI) From Robert Virding there is also a book on [The Erlang Runtime System](https://pragprog.com/book/eserlang/the-erlang-runtime-system) by Erik Stenman expected next year,
Can begin here http://beam-wisdoms.clau.se/ with easy to read part (ELI5 articles). I'm trying to keep those to be simple and short.
Brilliant resource. Thanks
If wx_object is a process (I can't check code right now) why can't you just wrap it into gen_server and plug it into your supervision tree? Erlang:link or Erlang:monitor may be enough.
Great treatment of so many topics, including: - separating state, supervisors and business processes - using the do_* - effective examples supervision trees - great diagramming 
maybe this helps? doesn't state time, but given service uptime it may be a nice number: http://stackoverflow.com/questions/8426897/erlangs-99-9999999-nine-nines-reliability#8427032
Yea, the issue is/was if they NPC's process gets restarted (by a supervisor), it'd have a different pid. I am currently storing attributes for the NPC into an ets table, so I could just have it write its pid to the ets table on initialization. Does that sound crazy?
Nope, makes perfect sense, though I personally avoid ets unless I have a compelling reason. It's not terrible to use ets, but it does introduce the constraint that reading those values can only be done on the same node. I don't like introducing constraints unless I see a clear benefit.
Ok, thanks. Would you suggest mnesia (with replication if necessary) to solve the problem you mentioned?
Interesting. I assumed (maybe because I'm new to erlang/functional programming) that storing large amounts of data in a process' state is a no-no. I suppose that probably is true, but my idea of "large" is probably way off. Thanks again! 
You can just use ETS managed by a gen_server. The real point I was making was around whether to allow other processes to read the ETS table directly. If all reads go through the gen_server then remote nodes can make the same calls without issue. If reads go directly to ets then they are limited to the same node. That said, "large" is pretty big. 10k keys in a map is nothing. 100k keys is probably fine. A little bit of this is some of my own preference in building minimally complicated systems. I'm very wary of implicit constraints and try to be very explicit about tradeoffs. 
I'd use {&lt;&lt;"name"&gt;&gt;,Ref,Pid} tuple to keep info on NPC and have name-&gt;tup, Pid-&gt;tup and Ref-&gt;tup mappings to bind all things together, with Ref being the primary identifier of NPC in the system. 1. Make gen_server implementing NPC (P1) 2. Use simple_one_for_one strategy supervisor (S1) to dynamically spawn P1 processes 3. Make gen_server P2 keeping name&lt;&gt;pid&lt;&gt;ref mappings, monitoring deaths of NPC and updating databases, etc and telling S1 to spawn new P1-s as necessary. 4. Use one_for_one supervisor (S2) supervising S1 and P2. 
+1. What [/u/Py7h0n](https://www.reddit.com/user/Py7h0n) described was basically what this article talks about: http://zxq9.com/archives/1311 I think it was posted here on /r/erlang before and I thought it was spot on.
(and is this the right place to ask?)
:(
Thanks for the info. How does erlang.mk compare to rebar3? I see the cowboy guys use erlang.mk... or I might be mistaking.
See: http://erlang.org/doc/man/gen_statem.html "event_timeout()" type: "Generates an event of event_type() timeout after this time (in milliseconds) unless another event arrives in which case this time-out is cancelled. Notice that a retried or inserted event counts like a new in this respect." So if you want timeout, I suggest you return timeout *again* at the end of your button cast.
Thank you. I guess I just got confused by the design document, as their example given then breaks the code lock since it gets stuck in the open state.
Yes, I am going through the doc now, and it is a bit confusing. You should file a bug in the future: https://bugs.erlang.org/secure/Dashboard.jspa
I was a bit hesitant to file it as a bug as it pertains to what is essentially a tutorial / I was unsure if it was just me, but I will do so in the future.
Agner Krarup Erlang was the first Knuth programmer? Also, how long until we have a language called Knuth?
hi there! why didn't you pick elixir instead, what advantages did erlang give for this role over elixir?
agree with you. but some (or rather many) of the things that involve developing an erlang application are outside the erlang/otp project, for example, relx, rebar3, logging, most http clients. For that I plan to create some "indexes" of topics pointing to the correct documentation for each.
Sounds good. Thanks for your hard work... 
Interestingly, the advice given ("you should also keep an eye on things like code coverage and branch coverage because it is possible that you have that one very strange corner case that will never be found this way") since all the branches and complete coverage can be obtained for the function mentioned. A better tool for this would be something like concolic testing with [CutEr](https://github.com/aggelgian/cuter) which, especially for functional pieces of code, can analyze and exhaustively verify your programs to find failures. For example, in the code: -module(fail). -export([is_very_large/1]). -spec is_very_large(number()) -&gt; boolean(). is_very_large(N) when N &gt; 196913 -&gt; true; is_very_large(N) when N &lt; 196913 -&gt; false. A CutEr run will reveal: $ cuter fail is_very_large '[1]' Compiling fail.erl ... OK Testing fail:is_very_large/1 ... ...x fail:is_very_large(196913) xxxxxx.xxx fail:is_very_large(196913.0) === Inputs That Lead to Runtime Errors === #1 fail:is_very_large(196913) #2 fail:is_very_large(196913.0) You will notice I actually had no tests to write to get this output. This kind of tool cannot necessarily replace the usefulness of quickchecking, specifically for larger integration tests, but will do wonders to make very interesting checks on smaller bits of functional code.
Problem is that the range of integers (or strings or floats) is more or less infinite so it reduces to the halting problem.
If you're dealing with a truly unbounded set then not even random generation will work. I've never come across a truly unbounded range working with code, however. Usually you are bounded by your representation, and domain-specific factors.
Strings are pretty close infinite, finding the corner case for which your code does something strange is pretty useful, 
I wish I read this 6 months ago.
I think gurus will hate this suggestion, but for those who "know a bit Java/C/Data structure/Algorithm", especially students who are still leaning, I find that the notion that there is no data in a module (and it only exists in the process at run-time) is pretty mind blowing. It's fairly basic, but you can't do anything in Erlang without firmly grasping that. Think about initializing a random number generator, the seed only exists in the process from which the function is called.
I thought I had a solution to this a while back by setting ERL_EPMD_ADDRESS=127.0.0.1. Right up until you try to run "attach" and it would just complain the node wasn't running.
Something small, yet annoying to me at least, the left nav as frames never really sat well w/ me. I seem to recall some divises give this offering a shape-shifting experience. It may be easier to respond to devises with a more straight-forward solution like : https://docs.djangoproject.com/en/1.10/ref/templates/builtins/ For me, the right nav is nicer. The content, above, the stuff most important, is positioned at 0,0 -- a much more natural location for reading. 
&gt; but those are more like key/value store Isn't that exactly what you need though? A name =&gt; pid lookup? Can you describe what else you need from this setup that's not provided by pg or gproc?
A few additional features would be desired. - a hierarchical directory structure (but I suppose gproc key/value can achieve that too) - federated service among a cluster of ds - security (some level of access control against pid discovery) - support search capability instead exact matching the key
Registry was just added to Elixir master this morning. http://elixir-lang.org/docs/master/elixir/Registry.html#content
https://github.com/trending/erlang Or for some smaller code bases by the main man himself https://github.com/joearms
Thank you, i'm just hesitant trusting "trending" projects, the product may be good but the code could be a mess.
THANKS!
In the same line, but with code related to protocols, too: http://github.com/inaka/serpents For protocol related stuff check the hdp modules 
&gt; security (some level of access control against pid discovery) This all just seems like the wrong problem/solution. There's no appreciable security or access control that can be implemented inside the Erlang runtime. It's really not intended to run un-trusted code.
I only come cross a few security topics in Erlang. Cookie may be one of them. I have to say its security is very primitive. I still believe this should be addressed by some common practice. On the other hand, I start to see the motivation to develop directory server may be not warranted.
&gt; I have to say its security is very primitive. Are there languages with better security inside the runtime? I mean, there's no security between objects/processes in the Python runtime, nor in the JVM. The whole point of security is to keep outside influences *on the outside*, not to segregate outside influences which somehow end up running code inside the language runtime. So yeah, Erlang provides security by not allowing external Bad Stuff to get inside, just like all other security setups. The idea of somehow trusting the Bad Stuff enough to run it inside your application, but also wanting to restrain it in some way?... I dunno man. It just sounds like we're looking in the wrong place. Not trying to be a prick, just curious to understand what a better system would look like, and if any existing systems actually behave like this.
I love Erlang and it is what powers Elixir, but your suspicions are correct. If you are going to be doing web apps then you will be tying one arm behind your back if you choose Erlang over Elixir. Right now Elixir has a larger community focus on the web and it is pulling in a lot of new developers to the ecosystem who are building the sort of infrastructure and tools that you will want and need for a modern web app. The benefit you have in going into Elixir is that you already know Erlang, so you will instantly recognize the patterns in use, you will be able to build your own low-level components when needed, and if you find that Elixir just does not 'click' with you the output of Elixir are beam components that you can still call from Erlang. 
👍
If you are going to develop normal web apps I recommend Elixir because of all the things said in this thread. However, if you need to deal with hugh spikes of traffic there are a lot of great libraries that help in that scenario that are coded in Erlang and not in Elixir. They can absolutely be used in Elixir, however having to swap from Erlang to Elixir all the time do introduce some thinking overhead. If I would write a new database or product like Riak, CouchDB or RabbitMQ I would definitely coded it in Erlang over Elixir. On the other hand Elixir has a way better stdlib, structs are way better in comparison to erlang records and polymorphism support is very useful thanks to protocols. Also, in some specific cases having macros instead of Erlang's parse transform are a big plus. However I do think that Erlang syntax is way easier to manage and more coherent than Elixir syntax. Elixir syntax is more common and Erlang syntax more strange, but once you learn Erlang syntax it is one of the simplest syntax in the world after Lisp and probably ML languages. Ruby/Elixir DSLs are lovely in some specific cases, but when overused it can become quite difficult to have all the syntax rules in your head. That is why when I try to understand some Elixir libraries I tend to get lost, however in Erlang almost all libraries code are really easy to read since they are "boring" (that for me is something good) Type of Erlang libraries I am talking about: - https://github.com/basho/riak_core - https://github.com/jlouis/safetyvalve - https://github.com/jlouis/fuse - https://github.com/ferd/dispcount - https://github.com/ferd/pobox 
Would love to hear more thoughts around how you felt working with wxwidgets! Would you use it for anything again?
I'd love to see more examples of these in each of the definitions
Amazing. Things the wise ones told us to avoid: wxwidgets, number crunching, process dictionaries, ets, textbook erlang concurrency routines (send, receive, etc.). Good to see someone playing around with forbidden fruit.
&gt; send, receive, etc I wouldn't avoid them entirely, but I would never use them in general business-logic programming. Send/Receive should really only be used as implementation details within libraries. If you're not building frameworks or libraries, then there are likely more thoughtful approaches to concurency.
Thanks for sharing. I'm in the process of learning erl as well and found some of the [nehe tutorials ported to erlang](https://github.com/asceth/nehe_erlang) useful. The `wx:demo` with `ex_gl` also show the easy of use. But I do find my GL context will crash on Windows with 2 screens and me moving the window between the screens a couple of times. And also found some other worrying crashes. `ex_gl` also "hang" on Mac OS X as you scroll the code, etc. So I'm wondering what is the opinion of the general state of erl and wx. I'm aware ubuntu does not want to pack wx with erl due to the state of wxWidgets. But for my little poc gl erl demo it seems sufficient at least, but will have a better opinion and some experience after December.
Not quite. Elixir is transformed into Erlang AST which is then compiled to byte code for the VM, and so shares Erlang's features much more closely than Scala and Java. So Elixir is like Erlang with slightly different syntax, some new features, an improved core library, and standard build tool, package manager, and testing library.
Like coffeescript or typescript to javascript
Your analogy was appropriate enough as they are compiled languages targeting the a VM. But the subtle differences are what's interesting!
But those are transpiled directly to JavaScript.
Superset: yes, more or less. Different syntax: yes, and with a few extras. The only things you'd miss from Erlang are what it replaces: syntax, build tool, etc. 
Thanks, got it up and wobbling in erlide. I'm interested in your `launcher` especially `escriptrun.pas` what is the goal behind it?
The ideas behind it are: * to hide the cmd window when you run then using double click on the explorer window * to show a nice icon and properties on the resulting exe file * to hide the parameters when launching a release **escriptrun.pas**: this one is the simplest one, main idea is to hide the cmd window. You can see this working, if you compile on windows using "emaker escript" and double click on the resulting releases/escript/enotepad.cmd (on a explorer window) you will see two windows opened, one for the cmd window and another for notepad itself, the cmd window could be hidden by adding a "-detached" parameter to escript but still it would appear momentarily everytime, this looks ugly. To see the exe working, you can make with "emaker escript exe", I include a precompiled binary for this, then you click on the resulting releases/escript/enotepad.exe and no ugly cmd window flashing. Also the same "enotepad" file could be run as escript on linux too, just chmod +x first, this is somewhat similar what rebar does, I think, but using an exe instead of a .cmd (there is also a "emaker escript rebar"). **erlrun.pas**: This one is mostly to hide the parameters to the erlang, "enotepad filename.txt" looks nicer than "bin\erl -enotepad file filename.txt", [erlrun.sh](https://github.com/aaronps/enotepad/blob/master/launcher/erlrun.sh) is the same for linux. These you can see if you compile with "emaker release reltool". why pascal and not c? well, a couple of points: The compiled binary with the C version adds a requirement for the vcruntime140.dll "Visual C++ Redistributable for Visual Studio 2015" which would need to be instaled on the target system, using freepascal with lazarus, no such requirementes and it has a nice gui to set the exe properties and the icon. The size of the resulting exe was 10k for the c version vs 80k for the pascal one, but the icon takes most of the space so it is not so important. Before making the pascal programs I expent a whole day trying to find a solution where I wouldn't need to use an external program to launch the erlang programs with "-detached" parameter. I searched through erl and escript source to try to find if they would read some configuration file automatically, like using the "-args_file FileName" to erl but some predefined file, but no, they doesn't.
&gt; why pascal and not c? Nope, I'm all for writing pascal code :D I just wondered where the exe came from(*was not aware it was checked into git*). Do you have any `vcl` knowledge; How would you compare `wxWidgets` and erlang against dev'ing with pascal which is suited for better windows development? I'm asking myself the same question trying to compare it to `Qt/C++`. I have not tried to hard to find any but some real life; non erl codebase; wxWidgets Erlang Codebase/Product would be nice. I also wonder why this feels like uncharted territory. 
So as it stands now wxErlang is broken. The only real world erlang GUI app I can find is Wings3D; and it seems like they use `wx` but there some `sdl` files hanging around. I also tried [kaos/QtErl](https://github.com/kaos/QtErl) and [krant/eqml](https://github.com/krant/eqml). With only eqml working. I wonder what daunting task it would be to try and write a [Qt port/interface/driver](http://erlang.org/doc/tutorial/introduction.html). ps. `vcl`/`lcl` is interchangeable to me like `.net`/`mono` is to others.
Looking forward to meet you all! See you guys on Thursday.
I love when Joe Armstrong talks about Alan Kay and OOP. Can't wait to watch this.
Is it down?
Yes it is: http://isup.me/toolbox.elixir.pm
I'd love to get more information on erlang opportunities!! But honestly, you should post them on /r/cscareeropportunities for neatness.
From the recruiter: ***** This is the description I got from the client. Hopefully they have Java experience as well he Erlang Software Engineer will have: • 5+ years developing software using a high-level language. • 1+ years developing Erlang software using OTP, EUnit or Common Test, and rebar3. • Preferably would have a working knowledge of the most common Erlang libraries including Ranch, Cowboy, or msgpack_rpc Regards, Giselle Cabansay gcabansay@crystalequation.com
Just another piece in the ongoing conversation about erlang testing. I wanted to share how I do CI with erlang
Thanks for sharing this!
I'd hope that, being a computer programming language, it's to be run on a computer. I'm just enquiring as to whether this code is idiomatic Erlang and whether it's written for the compiler or the reader in mind.
What makes you think I'm looking for any particular answer? 
You might be better using guards and matching instead of so many case statements?
I think the short answer is that for general purpose program, Erlang is slower than most JVM languages. Even when compiled using HIPE. I've never seen a benchmark claiming otherwise either.
You don't have to create threads. Java use pools of threads and multiplexes, and you can use the actor model just like erlang via Akka. I.e.: http://letitcrash.com/post/20397701710/50-million-messages-per-second-on-a-single
No one does that. They use thread pools. From the akka docs: &gt; There may be millions of actors within one such system, after all the mantra is to view them as abundant and they weigh in at an overhead of only roughly 300 bytes per instance. So i can create millions of them, not 10000. Basically you can do exactly what erlang does in java nowadays.
Both erlang and akka create light weight actors which handle messages concurrently on a shared pool of threads -- they have the exact same concurrency model. And if anything, Id wager that the backing thread pool in java is more advanced than the one in erlang. Then again perhaps erlang does works stealing, i dunno. EDIT: one thing that erlang does do, that akka cannot afaik, is guarantee that the context switching will happen with some specific maximum latency -- i think erlang does more dependable switching resulting in more predictable pauses between messages per actor. This is great but a very niche use case. But i thought id include it to be fair.
Amen, brother!
There was a lot of Erlang VM hackery to achieve WhatsApp's system.
With G1 collector its not managed as a monolithic heap anymore, at least not with regards to reclaiming memory. https://blog.oio.de/2016/08/30/the-g1-garbage-collector/
My observations of G1 are not that impressive over CMS; it's certainly not heap-per-actor
Depending on your tuning/breakdown of the heap per the G1 tunable parameters, I find it hard to believe that stop-the-world times under high memory pressure do not improve, especially with lots objects that dont die immediately and dont live forever. That being said i havent measured it. Even before G1, the akka team was posting benchmarks with 20, 30, even 50 million messages per second between about 100 actors. It's been shown to be highly performant for the general purpose use case.
No, it's unquestionably slower for straight line tasks. The common pattern is if you have a high CPU related performance computation you need to run, you farm out to worker processes written in other languages and use their results. So you'd use something like Java/Scala/Clojure for a PDF creator perhaps, then use that PDF elsewhere in the system. This technique is also a "pressure valve" for things that really only have a ruby interface, or a C interface, etc. The minority language fix. Say a company has a API you need to connect to, but only really puts out a gem (a ruby library) to talk to it. You can make a tiny ruby program to talk to it, spit something reasonable out, say in JSON, and then use a Erlang library to talk to your adapter app. The one caveat is *how* you tie these back together requires care. You want to make sure you don't accidentally block the BEAM process via the way you're connecting up. Erlang and Elixir are a great substitute for all the complex orchestration type tasks you often have to do using weird AWS tools, and more. They're okay, but not great at a lot of other tasks. They're below normal on straight line run speed. The prime performance benefits of Erlang (and Elixir, and LFE, all on the BEAM VM) are they give you very responsive handling (1-5 orders of magnitude less latency there than random languages) and can handle many many more threads than other platforms. This allows your code to be written far more modularly, and without error handling (as the system uses supervisors and thread restarts to substitute for what's often nasty untested code in other environments). One reason it's so responsive: it don't use stop-the-world garbage collecting or processor threads as the primary modus operandi. This means the day your app hits HN/Slashdot/CNN, is not a bad day for you (usually). BEAM based langs all also run well on embedded systems too.
I'm glad you have managed to confirm your biases by arguing with yourself (or whatever you're doing) here: https://www.techempower.com/benchmarks/
They aren't threads. 
Is erlang on there? I only see "Erl" on a few of the tests and it says "did not compete" next to it. As far as biases and arguing -- i have no idea what youre talking about but im not sure why youre here if you dont have any intention of actually discussing the topics. Dont be such a baby. 
FIRST one to answer my REAL question, which i was wrongly too afraid to ask, thank You
PS if you provide me with some simple Erlang source I will reproduce it fairly in scala and contrast on a nice Skylake system. 
Processes are semantically different in BEAM, but functionally close enough. There's no real in-VM analog. Actors are bolt-ons, in the JVM.
Sure I get the first class nature they have in Erl and I respect them as a very forward looking design choice. 
That's a lie right there.
Yes, they did have patches to the VM, but that won't make up the performance ground wrt Java ... there's too many guarantees provided by the VM. Immutability, isolated heaps, communication only through mailboxes (not through direct access to shared memory) etc have to necessarily cost you in performance. But like I said, the Erlang part is not in the data transfer path. 
And what do you recommend in order to keep bottlenecks away?
That is a big question, what you want to avoid is having 1 process that is in the critical path for everything. Keep an eye out for gen_servers with names as they can cause probelm
Performance can be incredibly predictable, even on that hardware. Erlang comes from a runtime environment far slower than any computer you're likely to have running still today. Erlang is great at soft real time. Another way to describe soft real time is "Predictable Performance". With caveats against things like Image Generation/repeated hashing that are very CPU intensive, it seems your app requirements may be satisfied well by Erlang (or Elixir). Staffing and interoperation with 3rd party SW will likely be the biggest challenges, not performance.
And as a follow-on, if you need to do CPU intensive operations, you can always write a NIF (Native Implemented Function) in C/C++ to do that work. 
Is eventual consistency okay? You could theoretically just take in a request, issue a fast response and let any processing work in the background. If not, I think you will still be able to handle new requests (in the thousands) quite handily, because you can continue to get actors quickly spun up, without having to worry a lot about bottlenecking new requests, so long as you aren't eating up all of the CPU on the box, or the actors aren't waiting on some shared, external resource like a SQL database lock. 
well, i am planning to get some 68k hardware from 1987, but that is another story ;)
Yes, but the language will need to - allow you to import/use the definitions you need to write the NIF (e.g. to construct datatypes like `enif_make_*`, `enif_make_badarg` et al) - export the correct ABI from the generated DSO that the BEAM VM wants to see at runtime when it loads your code - not have any other stuff that could get in the way (potential sources of issues could be e.g. a garbage collector or other background threads or somesuch, or an unusual ABI (I think go has a bunch of very custom stuff here? not sure if that goes for external ABIs as well)) In principle this kind of thing is possible with almost any language (e.g. could be done in python) but the amount of work you have to do will be pretty high in most languages other than C/C++. For instance you may need to first create a wrapper around all of the functions/definitions you need, you may need to write some C/C++ code to "unpin" stuff from the garbage-collector of your language (if any) and more work may be involved to export the final ABI interface that you need to expose from the DSO into the BEAM VM. It's definitely not possible with e.g. just "standard" javascript or python, you have to allow yourself to use (somewhat) implementation-specific primitives like the FFI or somesuch (which may not be available in all implementations, e.g. jython). And even then, writing some C/C++ wrapper code may be required after all.
Enif??? And how to check if i can export?
If you're talking about using Rust, there exists http://rustler.rustbridge.io/rustler/ for making NIFs in rust. 
Erlang's [database driver](https://github.com/denglf/erlang-db-driver/) appears to [support Informix](https://github.com/denglf/erlang-db-driver/tree/master/c_src/informix). Another approach is to use [ODBC](http://erlang.org/doc/man/odbc.html) which is supported out of the box in OTP. If both of these don't work for you, you could set up a [web API](http://www.ibm.com/support/knowledgecenter/SSGU8G_12.1.0/com.ibm.json.doc/ids_json_043.htm), access it over [HTTP](https://vimeo.com/59832641). Best of luck and I do hope you figure things out. 
Wait, WHAT?
Thanks.
No, not really. I don't think the supervisor style behavior is a good fit for Java because of shared memory practices. For example, when two threads share a hashmap, and one of them gets back an OutOfMemory error, what can you realistically assume about the state of the hashmap? For all you know, the hashmap was half-way through resizing and failed, leaving it in an inconsistent state. The entire process has to be ended and restarted. In erlang, there is far more isolation, and each side has its own restarting behavior. (Side note: There is an implementation of the VM for Java, called [Erjang](https://github.com/trifork/erjang), built on Kilim, my lightweight thread framework)
I would copy the release tar into the Docker image and then for the Docker entry point run the release in the foreground. 
Assuming you have a separate process doing each task, you have two obvious choices and one less obvious: 1. Make them all know each other. For example via registration of their names with `erlang:register`. So that you know there are 20 processes running, you can send `'stop'` to all processes with names `'worker1'`, `'worker2'`, ... `'worker20'` (using `erlang:whereis` to resolve the pids of them. 2. More flexible is to use a managing process, which will track all of the workers and do similar thing when it realizes that main task is done (controller process will receive some sort of message, like `'done'` from the deciding worker, and then will send `'stop'` to all other running processes. 3. Look into worker pools libraries, like poolboy, they solve the task of allocating worker processes for whatever you do. But i am not sure how they handle abrupt stopping. I assume you already know how to receive a message in your worker process and how to stop with it (by returning `{stop, ...}` in `gen_server:handle_info` or `handle_cast` P.S. you may find it useful to use LYSE the book as additional reference: http://learnyousomeerlang.com/content
From only trivial searching, it appears that nonstop os-a-like achieves HA by passing messages to a duplicate backup node. So, yes it seems that it is completely possible.
Actually, not only node, but also that node contains full replica of a process, with every step of every transaction copied to it, for an instant hot-standby
I guess that would depend on what one would call "a transaction", If one sent messages to the backup node to keep state managed nicely, or managed state only through something like ETS tables I think think that may be possible.
Is there a limit to granularity/recoverability?
Using [Termux](https://termux.com/), a terminal emulator app for Android, erlang can now be installed inside it by executing: apt update &amp;&amp; apt install erlang
This really comes down to what kind of recovery you'd want. If one designs a program in a method which a data pipeline goes through 'stages' of change, one could checkpoint/backup the data at each point then continue when a host becomes unavailable. This would still need to be managed by the programmer and is not built into erlang as a language. 
I dont think its too hard to do with erlang itself with its default message passing primitives. It would just be a matter of building a small library that checkpoints with some kind of finite state machine to manage availability. The exact configuration would likely depend on your data pipeline.
I haven't started season 3 yet, but this is one spoiler I'll allow.
It crashes directly when running `erl` directly without arguments? On which Android device is this? Could you link to erl_crash.dump? I just verified that it does not crash for me when launching on a Nexus 6p running Android 7.1.1.
The show is set in the late 80s, so both Oberon and Erlang would be cutting edge technologies (even though Erlang might not have be known outside Ericsson) at the time. I'm surprised C++ isn't on there.
Confused as well, is this a fuzzer?
According to Wikipedia, fuzzing is a subset of mutation testing, but it is not a fuzzer like quickcheck. It does not generate a lot of input for a single function. It makes small changes to a function source code and checks if tests are passing
Source code mutations? Do you mean like different versions of the source code?
What I did to understand that part was to read more (OTP Design Principles, the Reltool documentation) and create an *escript* to make the releases, I called it [emaker](https://github.com/aaronps/enotepad/blob/master/emaker.erl), it has a function called **release_systools** and another is **release_reltool**. It is good to know how things work, but now I think Rebar3 is in the process of being included in Erlang and makes things a lot simpler.
Not exactly, for example, if you have condition "greater than", it changes condition to "less than" and checks if tests are still passing. The main idea is to check for tests quality
basically everyone uses rebar3 
Distributed Erlang is not designed for untrusted users. Any node in the system should be assumed to have full access to everything in the entire system. I would recommend building something yourself, or possibly looking into using ejabberd or a related project to harness a protocol like XMPP for what you want to do.
Yep. The idea is that good tests protect against mutations in the code. If you can mutate the code without tests failing, then that's a bad sign. It's an alternative to things like code coverage.
Thank you for advice.
To keep a server/daemon process alive in Termux, pull down the Notification drawer and pinch expand the Termux notification to reveal an "Acquire wakelock" button which you can use. You can also take a wake lock using a command: termux-wake-lock (and release it with termux-wake-unlock). This is rather new, so run 'apt update &amp;&amp; apt upgrade' to get the command.
You should use Rebar3 since its both a a build tool and package management tool for Erlang. Check the official, documentation below. [Getting Started With Rebar3](https://www.rebar3.org/docs/getting-started)
I wrote a rebar3 plugin that aims at simplifying the relup process, give it a try sometime (https://github.com/lrascao/rebar3_appup_plugin)
Let it crash. checking_function() -&gt; case call_one() of {error, Reason} -&gt; {error, Reason}; {ok, Value} -&gt; case call_two(Value) of {error, Reason} -&gt; {error, Reason}; {ok, Second} -&gt; call_three(Second) end end. let_it_crash() -&gt; {ok, Value} = call_one(), {ok, Second} = call_two(Value), {ok, Result} = call_three(Second), Result. If you want exceptions to be thrown, assert that the values you receive are "OK" values, and Erlang will throw a badmatch exception if they're not. The two functions above behave identically if the three calls all succeed; `let_it_crash` will throw a badmatch error if any of them fail, where `checking_function` returns `{error, Reason}`. If at some point later up the chain you want to catch this error and handle it gracefully, just use: try let_it_crash() catch error:{badmatch,{error,Reason}} -&gt; handle_error(Reason) end
I'm not gonna reply in detail as a quick google search shows a decent amount of links. All I'll say is Elixir is just built right on top of Erlang/BEAM. You can call through to the base Erlang SDK from Elixir.
Whichever one you pick up and start writing code in.
Nope. They both compile down to BEAM instructions. Elixir taps in someway during the Erlang compile process. There are improvements in syntax for Elixir, but everything boils down to the same thing.
Yarp. In general reddit != Google but w/e. This is just a hard question regardless of which two languages you were asking between. Go, Erlang (Elixir), Java (Clojure, Scala), Python, C (#, ++), etc... etc....the list never ends and while I was typing this comment I'm someone just invented another language. I've got a coffee break and I feel like a bit of an arse. So prepare your anus for a more detailed reply. Incoming highly opinionated paragraph. What is the best programming language? The one you know. The one you can go be immediately productive in. If you don't know any languages, go look for the people. What is the rest of the world doing right now? Because that's where the libraries are. That's where the tutorials are. That's where the IRC rooms, email lists, and if you're a cool kid the discord or slack servers are going to be when you run into a problem you've never seen before. The people form a community. A strong community is what makes a language a good choice. Beyond that, what are you trying accomplish? Are you trying to build a Web Service? Are you trying to do an embedded system? I'm sure you've heard the mantra "Right tool for the right job". You'll have a much easier time using a table saw rather than a hand saw. Even if a language CAN do the job, it doesn't mean there isn't a better language for that job. You can write ANYTHING in C right? Well there you go. Use C. Done. .... .... Yeaaaaaa, ain't nobody got time for that. Elixir vs. Erlang? Elixir. Just go with that one. I struggle to come up with use cases that Vanilla Erlang does "better" than Elixir. BUT! If you DO run into something that Vanilla Erlang does better than Elixir, just write a Vanilla Erlang module. You can use it from Elixir with zero issues. It truly is just "that easy". It's kinda funny too because if you run into something that vanilla Erlang just sucks at also (see CPU Intensive math), drop down into C! NIFs to the rescue. Hope this helps. Truth be told if whatever you're trying to do doesn't NEED Erlang for some specific reason, I'm sorely tempted to say just use Java or one of its ilk (Personal preferences would be Scala [see Akka as well] or Clojure). But that's once again just my opinion. GL.
In a very general sense, Elixir makes the Erlang ecosystem accessible to web developers who want to make the same kind of applications and solve the same kinds of problems that they are working against now. It helps reduce the barrier of entry to an ecosystem that, by design, addresses scaling and performance concerns for getting your app to handle lots of connections. While I think Elixir engineers are focusing more and more on building distributed systems, that is currently more in tune with the notion of using Erlang. If anyone is holding out for switching to Erlang because of its syntax, then they probably aren't dealing with the kinds of problems that Erlang is good at helping. The Elixir community I think wraps that complexity up and positions the environment as more of a general purpose programming experience. 
"Boilerplate"?
There is no advantage of Erlanger over elixir. Elixir has all of Erlangs functionality and then some plus a better syntax. Also the Erlanger community has become toxic in the past couple of years.
So Elixir does not *require* writing modules in Erlang. I only wanted to stress that it was an option. If you needed to or wanted to for some reason, you could write pure Erlang modules and use them in an otherwise purely Elixir project. Sounds interesting though I'd be curious as to why you hate java. Sounds like you're intending to use Erlang as a coordinator/gateway into what is otherwise going to be a C variant driven program? Seems fine. I think a lot of people would say that's an area where Erlang excels. I don't feel comfortable enough in my knowledge of Elixir to try to argue in detail for it over pure Erlang. Elixir is theoretically a superset of the capabilities pure erlang has to offer. The taglines and the brief stints into Elixir I've taken leave me with this. Friendlier syntax, less boilerplate code, metaprogramming. Those would be my reasons why elixir &gt; pure erlang. Beyond that, I've got nothing. Interoperability with pure erlang modules also makes it seem not scary in the slightest. I don't think if you picked Elixir later on you'd be like "Oh damn, if only i'd just stuck with pure erlang!". The fine folks over at /r/elixir might have heaps more to say about all this though. 
Elixirs syntax is like ruby, erlangs is like prolog. It's a lot lower cognitive load programming in elixir vs erlang. I'm not going to go into details on the toxicity, just take it as one persons opinion. Spend 1 hour learning each and it will immediately be apparent which you prefer. But either one is better than just about every other language out there. I know a lot of languages and these two are the only ones that do concurrency right.
Verbose setup code that is repeated and required every time you do a certain something. The OTP has a fair amount of it.
Toxic can mean a variety of things. Unhelpful, harsh to newcomers, mean spirited, snide remarks, many things can contribute to making something or a group of people "Toxic". Better Syntax is kind of just all over the place tbh...I'd have to point you towards http://elixir-lang.org/getting-started/introduction.html :/ At a glance places of interest seem to be Sigils, Tasks, Agents, and Metaprogramming.
If you absolutely positively need Lisp style macros, dynamic dispatch, or Ruby-like syntax, Elixir is your best bet. Additionally, Elixir comes with its own version of the standard library, which means you get a more predictable API for a lot of things, while still being able to use all of Erlang's standard library. Also Elixir generally errs on the side of being friendly, so if you're coming from a high level language, Elixir might feel more approachable and less dense than Erlang. If on the other hand you want very terse syntax and configuration over convention, Erlang is a better choice. I am glad I started learning Erlang before Elixir if only because writing Erlang's infamous boilerplate forces you to think about what actually goes into say a genserver.
I still fail to see how it 'encourages' to pass all parameters as the last executed line of a function, looks like trying really hard to get tail call optimization in hopes of performance. I didn't continue reading after these lines because the author seems already decided what the title says and is just looking for more reasons to validate his claims. My take on the validate thing, I don't claim is better or worse, maybe not function, I just think it seems easy read and reason about it. %% returns 'user_is_valid' | 'user_not_valid' validate(DbConn, req#{body = RequestBody}) -&gt; case json:decode(RequestBody) of #login_request{username = UserName} = LoginRequest -&gt; validate_user(LoginRequest, db:find_user_by_name(DbConn, UserName)); _AnythingElse -&gt; user_not_valid end. find_user_by_name(DbConn, UserName) -&gt; case db:find_user(DbConn, UserName) of {ok, #user_details{} = UserDetails} -&gt; UserDetails; {error, _Reason} -&gt; notfound end. %% assume password was already hashed validate_user(#login_request{username = Name, password = Pass}, #user_details{name = Name, hashed_password = Pass}) -&gt; user_is_valid; validate_user(_, _) -&gt; user_not_valid. 
as long as it is not Java and is flexible enough, i do not care
Any specific reason not to use something like jiffy to encode and decode JSON with nifs? Was it just so you don't need to include it in more business code?
The title is a click-bait, sure. That doesn't invalidate the rest of the post though. Read the whole thing.
I did a series of benchmarks [here](https://lolware.net/2016/05/23/use-protobufs.html) where you can see Jiffy was a lot faster. That said, you're correct that it can be more work. Not just getting it to compile, but I found the syntax more tricky, I've often had to wrap a variable in [{A}] before handing it to Jiffy to avoid a badarg, where JSX often just takes it.
you have to be kidding me if you think these are boilerplate. it's like saying "public static void" in java is boilerplate
`-sname` are local names, all of them are in your localhost, the way erlang finds them is using another program (epmd) which starts automatically the first time you start a `node`.
after you start your node, you will see its name on the promp, it will be `(pong@something)1&gt;` and this is what you have to type in `tut17:start_ping(pong@something)`. You can get it also by using `node().` (erlang:node/0), and if you didn't start it with a name it will say `nonode@nohost`. 
That worked! I can't believe I missed that, thanks for the help.
How it works on high load ?
Seeing I am not a Ruby programmer I find the elixir syntax full of weirdness. It is the first language I have programmed in since Fortran (yes, I have been programming for that long) where line breaks are significant and getting them wrong can cause errors or weird behaviour. And however you look at the Erlang syntax is much simpler than Elixir's. And if you want real lisp style macros use lisp instead, try LFE https://github.com/rvirding/lfe.
A very interesting display of Erlang's concurrency at its best. Good job !
Here's a reasonably straightforward demonstration of WxWidgets: [enotepad: Clone of MS Notepad using Erlang](https://www.reddit.com/r/erlang/comments/5dri2d/enotepad_clone_of_ms_notepad_using_erlang) You'll likely just have to dig in and look through code that others have written, and the documentation itself, rather than expect to learn Wx from a tutorial, unfortunately. I don't think there's much out there.
Here are some online resources for wxerlang * [wxerlang workups](http://wxerlang.dougedmunds.com/) * [Getting Started with wxWidgets in Erlang](http://www.idiom.com/~turner/wxtut/wxwidgets.html) * [zxWidgets:-Library of metawidget wrappers for wxErlang.](https://github.com/zxq9/zxWidgets) * [wxErlang reference manual](http://erlang.org/doc/apps/wx/index.html)
Thanks a ton :) Have you written something in Erlang yourself? I'd be curious to learn about your experience with it.
You also don't have to use erlang to interface with wx, you can write C [modules/ports](https://nmuth.svbtle.com/some-informal-benchmarks-on-language-interop-with-elixir-ports) that are called from erlang (or better elixir) to directly control wx, which is what I might do one day.
argh.. how do I get a newline in the code block? zzz, markdown... 
Check out [this github search](https://github.com/search?utf8=%E2%9C%93&amp;q=filename%3Auser_default.erl+rr&amp;type=Code&amp;ref=searchresults) for examples of other user_default.erl files Also see [shell_default](http://erlang.org/doc/man/shell_default.html) which is where rr is defined. 
My advice would be to go with ports, much more safer and easier to work with than NIFs 
Awesome! Thanks.
Maybe a rebar3 port of this [erlang.mk plugin?](https://github.com/goertzenator/rust.mk). A bit niche for a beginner, but I thought I would through it out there.
I would "copy" a library. Like make an HTTP server then use `cowboy` for reference to see how they've approached some things. I've learned a lot this way. For example, a lot of libraries make use of `ets` in ways that I wouldn't have thought of
Try http://exercism.io/languages
A REST API server or client for whatever app you can think of. Like http://github.com/inaka/canillita A Homer Simpson bird emulator. Like https://howistart.org/posts/erlang
no... just... no... 
DotNet != Erlang DotNet == overweight Same case with M$ implementation of any kernel
This might not be a helpful reply...but I tried this like the other night and just gave up and used vagrant/vbox to spin up a dev VM. Works well enough for what I'm trying to do.
It helps knowing that others also gave up haha
Everything after "bootstrap.bat". Couldn't get the "rebar" and "rebar.cmd" files to work. Put it in both the system path and user path.
You should consider putting servers in UTC instead of some timezone. It'll save you a few headaches.
While this does work quite well in Elixir like the article claims, Elixir also has "structs" which work as a nice alternative to tuple-tagging a map or keyword list. The more "idiomatic" option would probably depend on the data structure.
set envs: ERL_CRASH_DUMP_BYTES=0 or set ERL_CRASH_DUMP=/tmp/erl_crash.dump
An article about erlang's syntax being a topic of concern for newcomers? How groundbreaking and unique! 
It's not just the syntax (which is the monumental part), but the tooling. Which is equally baroque, in appearance. Elixir was a baby step, but Pony has set a higher bar.
hey, that's me! :) thanks for submitting! I'm waiting until this merges https://github.com/erlang/otp/pull/1215 to push for this to be supported in the official docs. feedback welcome!
Never heard of Pony, the docs and articles are pretty horrific for it. Can you give it's quick sales pitch? Why would I choose it over Erlang or Elixir? What is it's relation to those two? What does it do better/worse/different? What other system/companies/tools use it?
Pony's characteristics - * The concept of reference types/[capabilities](https://tutorial.ponylang.org/capabilities/reference-capabilities.html) for an object (mutable, immutable, locally-immutable) * provably (memory) safe lockless concurrency * statically compiled * procedural at heart, but deals with immutable reference types by default * convenience-oriented design - division by zero results in zero and mutation can occur in conditional blocks: if x &gt; 1 then x-1 else x+y end * (generic) objects and classical inheritance. similar to javascript you can declare an object literal inline * Actor Object which has similar capabilities to an Erlang process While experience shows that restricting mutability reduces a class of bugs, I still find places where mutability would be useful to improve the simplicity and efficiency of some code. So Pony aims to allow both to coexist, while maintaining the provably threadsafe guarantees about performance, gc, and concurrency. https://www.youtube.com/watch?v=fNdnr1MUXp8 https://www.youtube.com/watch?v=_nDQ38v0fdU Even with the weird subtleties of *let*, *val*, *trn*, *iso*, *box* etc, it ends up being a mash of Erlang, Haskell, and still has the readability of Ruby. Once you decide you want to use the reference capabilities in more than just shortcuts, you can dive into a discussion about array traversal when you don't know what's inside but you want to handle it as something other than an immutable value... https://www.youtube.com/watch?v=Vq1vRfv-A6g This features such gems as - "If I replace this element in the array, I get a string iso hat."
The erlang tooling is fantastic in my experience, can you elaborate? Are you comparing to another environment which you found better? What was different? Unless we know what's missing, then we can't fix it. 
I hear this often where people compare 'x random thing' as being similar to erlang's 'actor model' but this isn't the point of what the erlang ecosystem provides around concurrency. If all erlang gave you was simply 'easy and safe single node concurrency' then you'd be fair to try and compare it with go or akka or whatever else, but it's not. Erlang gives you the ability to do this across many nodes _transparently_. No external session/object store. No internal synco/lock APIs or sticky sessions on loadies. No DB reserve locks. &lt;insert other pains here&gt;. The BEAM vm handles inter-node comms for you, and OTP is a battle hardened set of libs/interfaces for doing this stuff correctly and THIS is what makes it very good for distributed applications. I'm _ALWAYS_ on the lookout for alternatives, but if a given concurrency model scales only to a number of cores and we're all left to implement the things which erlang does for us for free (as is the case in go, scala, clojure etc etc), then the currently are no alternatives with which to compare... I'm not really sure I follow your logic on the issues around mutability, and I have no idea what 'mution can occur in conditionals' -- can you give us an example? :}
https://github.com/ponylang/ponyc/issues/350 The goal of Pony is to do multinode runtimes. &gt; If all erlang gave you was simply 'easy and safe single node concurrency' then you'd be fair to try and compare it with go or akka or whatever else, Again, Akka (and less so, Go) have prohibitively intricate knowledge investments. Business management (and developers) still rather ad-hoc than use these frameworks with such a high salary or time investment to onboard new talent. Even in california, you end up with a choice to not use these more often than not (we have one python guy who has done some hobbyist stuff with Akka but won't touch Erlang or Elixir). &gt; I have no idea what 'mutation can occur in conditionals' if x &gt; 1 then x-1 else x+y end The if block was the example. Those cases were changing the value of x (locally), when reached. All of this was an introduction into Pony. You asked for a pitch, as well. That's not what I have offered. I will continue to say that the Erlang syntax is unnecessarily miserable and Pony has proven the memory safety from immutability everywhere, is not necessary. This leads to more reasonable implementations of an mnesia equivalent and provide for obvious shortcuts, so immutability stops getting in the way...and superior string handling along the way, of course. If we ever see the multinode runtimes. 
Hey, It froze the whole tab after I typed "flow" in there. Are you using async callbacks, dude? EDIT: you actually are using async callbacks - OK, I'll just go kill myself
Soooo records? Records are literally a tuple with the name of the record as the first element.
The point is to prevent incorrect data, and yes it basically is a record 
I know what the point is. The fundamental thing is that you're recreating a less useful version of a record. Records have guard functions as well as tighter syntax for matching on specific fields in a record. 
I set it to the second option above last week and haven't seen any issues. Thanks!
Any erlang tutorials you can suggest, /u/get-finch ?
&gt; The Pony scheduler is not preemptive. This means that your actor has to yield control of the scheduler thread in order for another actor to execute. The normal way to do this is for your behavior to end. If your behavior doesn't end, you will continue to monopolize a scheduler thread and bad things will happen. The bar does not look like it was set very high. I mean, in comparison to how convenient writing concurrent programs in Erlang is.
I don't buy it. Am I supposed to *actually* believe people think Erlang's quirky Prolog roots are really worse than, say, reading and understanding [C++](https://github.com/actor-framework/actor-framework/blob/master/examples/curl/curl_fuse.cpp) (not hating on CAF, I just linked that example since it's in the domain of Erlang). 
Ah, since you brought up the tooling as well I thought you were talking about bars other than just the syntax. Pony does look like a language that will be very interesting to follow, especially that type system, but if multitasking is not preemptive I have a hard time seeing it compete with Erlang in the areas where Erlang is a natural fit. It feels like https://tutorial.ponylang.org is missing a chapter on concurrency, how would you implement something like a supervision tree? Erlang actually does have to be aggravatingly baroque, because people have been writing programs for it for 30 years, and the users will expect their programs to work even if Erlang is updated. I have very rarely seen anyone defend Erlang's syntax, merely trying to *explain* why it is the way it is. Also maybe explaining why they don't care that it's weird.
In Prolog you can omit the parentheses, too. I guess it's part of Erlang's legacy that it understands it, too. But probably it's not actively tested anymore in Erlang's unit tests if everything works using this syntax, because you are not supposed to use it. 
I mean, sure. Erlang was originally designed to run on hardware much less powerful than today's "IoT devices".
Is there any tutorials for the same, if you know of.Thanks
I'm drawing a blank, but I can imagine googling around would yield some stuff.
anyone with prebuilt pdf version?
&gt; r food security. Well sorry for opening you up to all this crap most people aren't all that interested in the internals of distributed systems, yet they are happy to use zookeeper for service discovery for their restful APIs and use a cd pipeline and call themselves experts in the field . PBFT is practical byzantine fault tolerance a paper by barbara liskov, 3PC means three phased commit this is how the blockchain is resilient against sybil attacks. DHT is Distributed Hash Table, which is what most P2P tech is based off of, Bittorrent uses Kademlia most people choose it (ipfs does), I prefer Chord so do Cassandra, Dynamo, Riak, etc. Well you can get this in ipfs or ethereum along with a host of other shit, anyways back to the point If you were to implement it yourself you could use a DHT and maybe use trackers of sorts to reduce the amount of lookups, and then have keys for everyone so even though everyones data is on other nodes, nobody can use other people's shit. Before you ask yes I've done it before, I've written shit like this from scratch in Scala. 
Chances are though, just like the people where I work you give no fucks about this crap and will just use Ethereum, or Hyperledger, which isn't a problem, I am just that dick, in the erlang subreddit though roughly 50 percent of the population are that dick.
My first non toy erlang project was a distributed kv store using pg2, and ets. Bonus points if use riak_core
I do like to understand as much as possible despite no formal education or a wealth of experience in the field of programming and technology. Food security is very much a distribution problem which I think I can learn a lot from the field of distributed programming. I did have a quick look at all the acronyms online to get a glimpse of what they were. I do appreciate you taking the time to explain it all :)
Is there a video of this talk somewhere?
[Malcolm Dowse - Erlang and First-Person Shooters in online games](https://vimeo.com/26307654) Found this but it never shows his slides.
Pattern matching is a fantastic feature of erlang. Pattern matching + gen_server is, for me, why I use erlang. http://learnyousomeerlang.com/content is a great tutorial for anyone interested
In what version of reality is anyone making a claim that Erlang is a secure language? Nice to have someone remind everyone of the weaknesses, but it has always had glaring holes that make denial of service trivial (epmd anyone?) and the all-or-nothing nature of access control granularity within Erlang processes makes it a non-starter for anyone who is truly paranoid.
It's called Erlang - not Securelang.... (we're werewolves not swear wolves). But seriously - yeah... distribution of erlang with trust has been an issue for me in the past too.
&gt;Since the design avoids many pitfalls other languages like C allow, certain aspects of security are avoided by design Definitely valid. &gt; Yes and no. If you start an Erlang node without distribution (no -sname or -name command line arguments) and/or filter distribution traffic with a firewall, most (if not all) of his points are moot Those sort of problems though assume that consumers of these products know about those facts. I'd say it's up there with MongoDB allowing unauthorised access by default - it's fine to say "you can secure it" with a firewall, but that's little comfort to the many hacked sites and leaked databases out there. Have a look around GitHub for calls to httpc and find me a single one that actually validates the SSL certificate. Again, it's a default you "can secure" that literally no one does.
&gt; I actually discussed that on the list, and was told it was "odd" to expect https connections to validate the cert. It told me a lot about the security approach. Do you have a deeplink to that? Also, Erlang is not the only one with problems regarding SSL/TLS clients (not just HTTPS, think IMAPS, etc.). It seems that while browsers improved a lot in this regard, client libraries hardly treat transport security as a priority. And while certificate validation is one (complex) thing, think also SSL/TLS versions, cipher suites, etc.
I'm loathe to link because it all started with a dumb issue on my part, but the thread starts here: http://erlang.org/pipermail/erlang-questions/2016-December/091223.html I would still say it's poorly documented. Here is what is said in current documentation: In mode verify_none the default behavior is to allow all x509-path validation errors I'm reading that to say "if I specify verify_none that is the behaviour", whereas what it is saying is "verify_none is the default behaviour". Note my thread tests this out on both leading libraries and neither of them verify nor describe how to do so in their documentation. In fact I just sank half an hour into actually trying to make a validation work and was completely unable to. Google only led me to.. posts on the list from people with the same exact issue. http://erlang.org/pipermail/erlang-questions/2014-July/080194.html Of course, the first reply to that question earlier in the thread is: are you sure you need to verify the certificate? .... I've never verified a cert
Holy sh-, that's... sad? Frustrating? There's not much benefit for using SSL/TLS if nothing's verified. I work as a pentester and that was something I didn't expect from Erlang and its community. An interesting contrast is Python, where one has to disable certificate validation explicitly and even then it raises a warning every time a socket if opened...
Stop projecting.
Before you ask yes, I know there is no CSP or STM in BEAM, I was giving a list of popular concurrency abstractions. 
For what it's worth, a lot of the community instead uses the Hackney library, which does validation by default.
With regards to to your last paragraph. This is something I keep asking but it's still too soon to tell. Blockchain on it's own doesn't offer much other than a transparent (or private?) distributed database as far as I can see at present. It's the whole of Blockchain and the surrounding technologies that interest me most. That being secure and private peer to peer communications and computation. As far as I can tell Aeternity has the most promising solution to date being based on Erlang and having a focus on scalability from the beginning. Though it is hard to tell what intentions lay behind the people building these technologies in general. From what I have seen the Ethereum team seem very focused on giving power back to the people. I think that on the road to a Utopia that currency will be the last thing to go. Accessibility to food, products, services, education etc is pretty much a solved problem in "modern" societies providing you have sufficient income + internet. By that I mean we don't need to own things or be in a certain place anymore. Can use Uber instead of owning a car, can study on Coursera instead of being physically at a university etc etc. The flip side of this is that there is a fine line between Utopia and Distopia I think. For example automated transport of people and distribution of food are both things that are shared between a utopian and distopian society.
it looks like there is a websockets plugin, but cowboy has websockets built in
Yes you are right, but for my current purpose i am not considering websockets , as it is a different protocol and it will take some more time to learn it and right now i am already learning Erlang and some other stuffs to get my work done. So, i think right now long polling is my only option to get it done and it will be good to know if i can do it with elli. And also I Don't want to use any xmpp server. Thank you. :)
I only have experience with cowboy, it's quite easy to make a http chunked response handler with it. Look for loop in cowboy docs.
As an example of my other comment, https://github.com/QuantumProductions/tunnel2/blob/master/table.erl#L15 there are 3 parameters that `gen_server` uses with synchronous messaging -- this is what I meant by a "consistent interface". First parameter is your arguments. second parameter is the PID sending the message (I ignore it with _), third parameter is state. I send messages to processes with `gen_server:call`, conveniently shortcutted with my "shortcuts" in `s.erl`: https://github.com/QuantumProductions/tunnel2/blob/master/s.erl so I might do `s:s(tablePID, {place, take, x, {1, 2}})` -- this sends a message to the table that player x is taking the square at position 1,2. See how all the parameters are wrapped up in the tuple on table.erl line #15 ^
Is chicagoboss still being update. I noticed that no code has been pushed for almost a year now.
Try n2o. (see example - https://github.com/synrc/n2o/tree/master/samples) 
cowboy always worked great for me: https://ninenines.eu/docs/en/cowboy/2.0/guide/ws_protocol/
I think Erlang is a great language and a nice platform, but at least when I first learned it, the benefits were very oversold. It takes a substantial amount of knowledge and expertise to properly leverage the novel features. To do anything really useful at scale you need to learn OTP, how the (fairly convoluted) config and deploy systems work, and lots of actor-model specific gotchas and caveats. Erlang isn't a magic bullet, you can still shoot yourself in the foot very easily. Things like "let it crash" and "9 9's of uptime" and "hot deploy" all sound really cool, but once you dig in and start dealing with it at a practical level, it's not so simple. For your use case, you're going to also need to learn ports and protocols to communicate between C and Erlang. Do you really know what features you *need* from Erlang to do what you want, and why they are the best or simplest alternatives? Using Erlang for this will be a great learning experience and fun, but if this is for something other than a learning/hobby project and your main goal is to get something up and running, you should probably try a simpler approach. 
You are correct in that Erlang is not ideal for calculations, however it is built for network communication. If you were to use Erlang for an MMO, I'd focus on using it's strengths in terms of communication, concurrency, etc. and leverage C or similar to deal with the actual logic. I'd suggest going to the Erlang web site and do some research. Also, there should be links for forums/chatrooms/etc. somewhere on there. They should be able to do a better job helping you than we can.
Thank you for the response! Yeah, I'm aware it's plenty a challenge to do on it's own, while I do believe that it can help in the long run, I largely just enjoy working with Erlang and want to improve. My understanding is that Erlang has the benefit of great scaling and quick routing primarily, in addition to it's fault tolerance (if designed accordingly). It is my goal to create sort of mobile zones in this game that will morph to equally share load instead of taking up certain amounts of in game space. Because of this I figured that easily re-routing players from zone to zone as they walk or as the servers shift may be a good feature. in addition I thought quick response time may help in creating a real time combat system.
Thanks! yeah, I actually have done a lot of research and practice, read through LearnYouSomeErlang several times (going on 4 or 5 in it's entirely, plus constantly referencing sections) and look at the documentation best I can for the last year and a half or so on and off (I have been fairly busy). I definitely should go to the forums, I have not really visited them. I just prefer reddit for most things personally, haha.
I get it. I just don't think too many people follow this subreddit, so going to the forums may be better.
Erlang: What if everything was a phone call?
What if everything was a process? 
C'mon. i admitted to it being pedantic! ;) 
No offence meant :)
Too bad there is no way to supervise these within rust itself.
Dear u/Erlang_Solutions, Please, hire me! =D
You might be in luck! We have a handful of open opportunities at the moment - check our careers page for details :)
Ohh yeah got it, that would be good. Maybe we could ask for/work on it? 
I'm still learning rust, we could always ask, but its going to be rough.
There isn't one ring. I'm not a fan of Phoenix, but it's far less offensive than STM.
How long have you been coding in Erlang for? I've recently started learning but haven't even written my first application; I've only recently started learning about OTP but it seems awesome.
I started learning Erlang 1.5-2 years ago and I've been making little projects on and off since. This project here I started last Friday and feels like I am making the most progress yet. I really appreciate the OTP concepts and think it has a lot of use for things I want to do, but it definitely can be confusing haha.
I've seen like 5% of your code (starting from top). Will get back to it later. 1) Instead of having explicit game_sup:stop, take a look into application:start and application:stop. They will handle your top level supervisor for you. 2) look into rebar3 :)
Thank you for the response! 1) The way I currently have it working is that I use the application module for living_world_server, the overall top level. below that I instantiate it all by hand. Should I be using application to start sub modules within the program like the game supervisor as well? 2) Yeah, I did actually, haha. I got it working once on my Linux machine, but for some reason it's caused me more problems than it's helped with. I know I'll have to move code over once I need to pull in dependencies for MySQL and such, I just don't want to fool with it. I have a history of the easy stuff tripping me up more than the complex concepts.
What if you tried adding Robert to the call?
As of OTP-20rc2, Erlang shell history will be stored on disk; the feature will be disabled by default, but possible to turn on through an OTP environment variable in the kernel app. No more need to install the erlang-history repo.
That's *so AWESOME!!*
Removed.
sounds pretty neat
I did. I thought the sessions on benchmarking and profiling were the best both in terms of presentation and usefulness.
Fear not - most, if not all, of the talks were recorded. They should be released in the next month :)
i did the following and it worked for me: * git clone https://github.com/kansi/nine9s.git * git checkout 0.1.0 * rebar3 release * git checkout 0.2.0 * cp apps/nine9s/src/nine9s.appup.src _build/default/lib/nine9s/ebin/nine9s.appup * rebar3 compile * rebar3 release * rebar3 relup -n nine9s -v "0.2.0" -u "0.1.0"
Got it working now, my issues were to set {dev_mode, false} in the rebar.config, as well as cleaning before recompiling the second version. :) Now from the minimal example to my real application...
Fuck! And now?
I just saw comments, happy to see people have atleast made the forks. Sad to see such a nice company go like this
Also: there are big commercial and governmental users who are continuing development, judging by the mailinglist. So I wouldn't write off Riak itself just yet. [edit: I know you aren't, I meant this is for /u/lenarc]
Good to know. I'll definitely dig to see how the community is reacting. I'm really liking Riak so far.
Indeed there are. I wouldn't be surprised if the death of basho ends up being a good thing for Riak. There are a few support and development providers rather than just one, for example. But more than that, in my opinion, Basho woefully neglected its existing customers the last 3 years in pursuit of hockey stick growth, developing new products. A market built around existing Riak deployments is good for Riak. We can fix the bugs, work on tech debt, and add the features the users want, not what sales/marketing say we need. I'm working on Riak (paid work!) still (I worked 6 years at Basho.) And plan to work on it as long as I can. This mailing list thread http://lists.basho.com/pipermail/riak-users_lists.basho.com/2017-May/019281.html was started by my colleague and shows some of the work we're doing. And has bet365 stating publicly that they will continue to work on Riak. I know of a few others. Tiot in Japan, Workday.
Erlang Solutions will also be at 'Betting on Sports' representing the work we do with our betting partners in Erlang and Elixir. Who else is going?
you can use a VirtualBox VM or the linux subsystem for windows to get a good linux env on windows, you could also try setting it up on windows and writing about your experience and we can try to make it better for you and the rest that may try it in the future. Feel free to contact me and I will help you to set it up. I'm mariano at this domain http://marianoguerra.org/
Thanks, which IDE can I then use the best on Windows ? 
you could try VS Code and install the erlang plugin.
I develop on the BEAM (Elixir) full time on windows and I don't have any real problems. Some NIF stuff can be a bit clunky to compile, but if you use mostly the stdlib and the most popular libraries you'll be just fine using pure windows 10 at least.
so this one : https://marketplace.visualstudio.com/items?itemName=pgourlain.erlang and not this one : https://marketplace.visualstudio.com/items?itemName=yuce.erlang-otp ?
erlang works fine on windows 
why not just use escript?
Sadly the writing has been on the wall for some time, with the number of people moving on from the original engineering team. Really hope that a good community of users get an alternative effort organised. Now to make sure I have a fork of everything I need from basho's github.
I'm not really aware of any non-trivial examples, perhaps the [OCaml LLVM tutorial](http://llvm.org/docs/tutorial/OCamlLangImpl1.html) comes reasonably close. Though I'd build things somewhat differently to how they describe there. Certainly Erlang examples are even fewer and now that I realise, which reddit I'm in I perhaps should revise my example. Do you have an application area that would be particularly helpful?
Good to know, where are they going to be made available? Youtube?
you can install both of 'em
Keynotes will be released this Friday :) We'll then be releasing the rest over the next two weeks - Wednesdays and Fridays :)
They'll be uploaded to the Erlang Solutions YouTube channel https://www.youtube.com/user/ErlangSolutions/ Enjoy!
Any application would have been helpful. I'm at some point where anything is a plus. Thank you for your reply, I'll have a look at your link
any thoughts?
That's a really cool tool, why does not exist a tool like this by default? I will try it on my laptop and check it!
Actually there is something similar: http://erlang.org/doc/apps/et/et_tutorial.html but with Gtk UI and, as far as I understand, only in-memory events storage. I wanted to have some tool that would store traces from several applications in one place, to allow to see events from different apps on one timeline. Of course it's not there yet, not in this demo.
Nice! Have you seen / played around with the Erlang Performance Lab? http://www.erlang.pl/ There are some GSoC projects ongoing and it's active development. Would be great to see a "gannt chart" style view for process lifespans in it, in line with what you have done here.
No, I haven't. Indeed an interesting project, thank you for a link!
Support for Riak is available commercially (we at Erlang Solutions are a support provider - and were a Riak reseller) and there is a decent-sized community that will step up and ensure Riak survives and evolves.
I would *really* like to see the enterprise features released as part of the open source version, particularly multi-cluster replication.
I just signed up to try that site and my lord are those execution times ridiculous. Running a 5 line Elixir program either hangs indefinitely or takes 5 minutes to complete.
Good job. Erlang needs more attention/love. Prolog next! 😜
I *love* the sound of this. I thought that BEAM had some limitations that would prevent much of Clojure from being ported. Looks like I was (mostly) wrong. What can I do to help move the project forward?
It is always useful for the code to get exercised in ways that the tests don’t cover. If you have some project you want to try to implement and the time to do it in Clojerl (with a mindset that things will fail), I think that would be helpful. There is still a lot of work to be done. Even though the most fundamental parts of Clojerl are functional and some of the original tests cases from clojure.test-clojure.* have been added, there are still plenty of bugs lurking and important features missing. You have a good point when you mention that some characteristics of the Erlang VM make it really hard or impossible to port some Clojure features. Off the top of my head here are some things that could be improved or that I’m not convinced how they are currently implemented (discussions around this topics are both helpful and interesting): - Protocol dispatch: when calling a protocol function, the current approach is to resolve if there is an implementation for the type of the target value and if there is, store that function in a cache. Initially the cache was an ETS table, then I thought about trying out storing this in the process dictionary, just to test how it compared in speed to using the ETS. It proved to be considerably faster (around 60% on average), but on the other hand each process running Clojerl code needs to keep its own local cache of protocol resolution. This also presents a problem when you want to redefine a type and the protocols it implements change, you either need to find a way to drop the cache in all processes or restart the Erlang VM and start from scratch (this is not such a bad thing as in the JVM since the startup times are not as long). - IEquiv: it is possible for Clojerl types to have metadata because they are just tagged Erlang tuples. This means that the Erlang equality operator can’t be used. Clojure’s approach is to calculate the value’s hash (that doesn’t include metadata) only once and then use the same value for all further equiv comparisons. We can’t do that in Erlang because we have no mutability, so the hash for each value is calculated every time it is needed. This can be quite expensive, particularly for collections. - Type Naming: most types that would have the "clojure.lang." prefix in Clojure JVM have the "clojerl." prefix, and there are some others that have the “clojerl.erlang.” prefix, which is weird. Some thinking regarding renaming and organization is needed there, I've been planning to do this for a while but I never get to it. - Type Representation: it would be nice to try an alternative representation for types. Each type is currently a tagged tuple. An alternative would be for them to be tagged maps, the Elixir approach (like it was mentioned recently here: https://github.com/jfacorro/clojerl/issues/262). - Atoms: they are implemented by keeping the value of each atom in an ETS table and doing the compare and swap (CAS) always through the same process. This means that reads are fine but updates to all atoms are serialized through this single process. This will probably be changed so that there is a pool of processes instead of a single one, but the actual problem here is that there is no garbage collection for the values in the ETS table that don’t get used anymore. One way of “solving” the problem is by making sure the user cleans up the atom once it’s not needed anymore, but this is going back to not having garbage collection. All this being said, the only reason why this crappy implementation of atoms exists, is because the implementation of clojure.pprint relied heavily on the use of refs, but atoms work just as well for that case and they are much easier to implement since their semantics are much simpler. - Agents &amp; Refs: it might be possible to implement refs through mnesia and agents through a pool of processes that handle the application of functions to values, but I’m not convinced this brings any real value when in the Erlang VM, since the way of building systems is very different. I don’t know how much Agent gets used in practice in Elixir though (see https://elixirforum.com/t/discussion-about-uses-for-agent-processes/4214), but it seems like Elixir’s agents are more close to Clojure’s atoms than Clojure's agents anyway. - Anonymous functions: are not really Erlang functions, an anonymous function with more than 1 arity doesn’t exist in Erlang. The trick is to create an Erlang fun that accepts a list and contains an internal case which dispatches to the corresponding body for the provided arity. What I don’t like about this is that Clojerl anonymous functions can’t really be used as Erlang functions (e.g. use them with lists:map/2). Then there’s all the missing features which are not trivial to implement, these are some of them: - Reducers - Transducers - Hierarchies - Transients 
1. I think the number is around 70 2. I don't think there's something in OTP, but you can check lasp http://lasp-lang.org/ ? what are you looking for specifically? maybe riak_ensemble works for you?
Thank you. I am looking at a variety of applications, from simple distributed processing (working off of stable snapshots of data) to a fault-tolerant linearizable data structure store, like Redis except with more built-in structures and commands. Some of it is also for teaching. I do have riak_ensemble in mind, and I have also looked at a couple of erlang Raft implementations. I was wondering about whether I could produce a replicated state machine implementation in plain Erlang/OTP. I suspect not, since epmd itself is not fault-tolerant (if it crashes and comes back up, it loses all its registrations)
I think you will get better answers if you ask in the erlanger slack channel https://erlanger.slack.com/
Man. Thanks for the thorough writeup! It sounds to me as if the biggest downside (for my general use case) is the IEquiv hash code re-computation. I'll let that percolate in the back of my head and see if any ideas surface. I may take it for a test drive soonish (probably building out a Cowboy web application of some kind).
The templates with `new` are distinct things. If you type `rebar3 new` you will see: app (built-in): Complete OTP Application structure. cmake (built-in): Standalone Makefile for building C/C++ in c_src escript (built-in): Complete escriptized application structure lib (built-in): Complete OTP Library application (no processes) structure plugin (built-in): Rebar3 plugin project structure release (built-in): OTP Release structure for executable programs When you call `rebar3 new release &lt;name&gt;`, you are telling rebar3 'please make me a new project that is a release named `&lt;name&gt;`.' If you want to just turn an existing OTP application to a release, You can just do as indicated in the [Releases](http://www.rebar3.org/docs/releases#section-getting-started) section of the documentation website: &gt; Add a relx section to your project's rebar.config: {relx, [{release, {&lt;release name&gt;, "0.0.1"}, [&lt;app&gt;]}, {release, {&lt;release name&gt;, "0.1.0"}, [&lt;app&gt;]}, {dev_mode, true}, {include_erts, false}, {extended_start_script, true}]}. Do note that Erlang's structure will require you to put `cowboy` in the `src/&lt;name&gt;.app.src` file's apps tuple along with `stdlib` and `kernel` to ensure cowboy is booted before your app.
Thanks. I did do a 'rebar3 new release'. I found this promising [gist](https://gist.github.com/flbuddymooreiv/ce1d7a47b12c27bf1616) that spells out each of the steps. Alas, that too fails with an error like this: exited: {bad_return, {{cowboy_hello_world_app,start,[normal,[]]}, {'EXIT', {undef, [{cowboy,start_http, [my_http_listener,100, I'm running mac os X, erlang 20 and I've tried it with the head version of cowboy as well as the version mentioned in the gist.
Same happened to me. I wanted to learn erlang and then I started implementing Rebar3 and cowboy it was a major turn off. I switched to Scala which also has functional capabilities and actors 
True. It is so absurdly simple in the golang world. A simple 'go build' compiles and creates a standalone executable. 
Incidentally, I found golang to be a giant piece of trouble to get working what with GOPATH and so on.
I followed the gist exactly, and needed to change the port from 2938 to 9999 to avoid requiring root. Otherwise it worked fine. The error you see is coming from not being able to find the call to `cowboy_hello_world_app:start/2` as a function call. The reasons for this can be any of the following: - there is no module by that name - there is a module by that name, but there is no function with that name - there are both a module and a function by that name, but the function is not exported (the arity must be correct) - the `cowboy_hello_world` application is not in the list of applications to include in the release (in the relx config) Does any one of these appear to be correct?
Actually now that I look at it, the error is in finding 'cowboy:start_http'. You should ensure that the call has enough arguments, and that the proper version of cowboy is checked out (the demo asks for a pre-release of cowboy 2). If the library version needed to be modified, call 'rebar3 upgrade cowboy' to get a new version into the lock file and fetched.
I find easier just to use elixir's mix even for erlang projects.
This! Elixir has had a focus on this kind of tooling for years and it shows. 
I removed _build and rel and started all over again. This time it worked. Ugh. I don't know what went wrong earlier. Also, as you noted, the problem was with cowboy:start_http, so it wasn't in my control, other than git versions; perhaps rebar.lock was the culprit. In any case, I tried replacing the start/2 of the gist with this one from the getting started guide, and got a similar error with cowboy:start_clear. start(_Type, _Args) -&gt; Dispatch = cowboy_router:compile([ {'_', [{"/", hello_handler, []}]} ]), {ok, _} = cowboy:start_clear(my_http_listener, [{port, 8080}], #{env =&gt; #{dispatch =&gt; Dispatch}} ), hello_erlang_sup:start_link(). Thanks for your help. 
Really? GOPATH is just the toplevel directory, like ERLROOT. Once you set it, all packages just go in there seamlessly. I have never had to look at it again. As I said in my original post, it is a mental model thing; clearly, tens of thousands of people have worked successfully with erlang (and golang), so it must be something that we got wrong as beginners. If it works fine initially, one tends not to think about it, but when it doesn't, it is hugely frustrating.
Did you use mix after having experience with other erlang tools? If so, it was incremental learning for you. I found mix to be just as unwieldy a ball of wax as rebar3. Just as with Erlang, I grokked the language in about a day and looked forward to working with it, but went back to Erlang precisely because I found mix to be this daunting mixture of conventions and recipes. The documentation for both rebar3 and mix is not really geared for a beginner trying it out by himself. That said, you guys are great, and I shouldn't really think I am by myself! 
Set 'other processes' to 'low' priority. Don't set any process to 'higher' priority or you will see some bad bad latency issues. 'Higher' and 'realtime' are basically reserved for internal use. This is my experience. If you want hard real time you are looking at the wrong tool.
I would like hard real time, but as I can't get it I would like the best performance for some processes as possible. What's the difference between setting some to high and leaving the rest at normal and leaving some at normal and setting the rest to low? Why do I get bad latency issues? I am interested in the reasons, not just the result.
Reason - 'higher' is basically reserved for some internal processes of BEAM. Design assumptions (implicit or explicit) break down if you introduce your own processes with 'higher' priority. I've experimented with this ~10 years ago, on old version of Erlang. It could have changed in the meantime. Go and check it yourself.
There are four levels of priority, where Max is reserved for the runtime system. But still it is recommended not to use priorities. Obviously someone has to know why, and I would like to know without having to try everything myself.
Just so we're clear, what is your definition of hard real time ?
Guaranteed deadlines. I do not need it for all processes, so it would help if some processes could be prioritized. Then the deadline may still not be guaranteed, but at least it is always executed next. And the behaviour could be considered somewhat more deterministic compared to no priorities, where I may have to wait until everything else is done to get some computation time.
I never liked rebar it makes it difficult to be aggressive with erlang POCs, in my opinion. Have a look at https://erlang.mk/
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/Erlang_Solutions [Is Riak dead? Enterprise and open source support announced](http://np.reddit.com/r/programming/comments/6t099l/is_riak_dead_enterprise_and_open_source_support/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
&gt; By calling the BIF process_flag(priority, Priority), where Priority can be set to the atom high, normal, or low, the behavior of the scheduler can be changed, giving processes with higher priority a precedence when being dispatched. Not only should you use this feature sparingly; in fact, you should not use it at all! As large parts of the Erlang runtime system are written in Erlang running at a normal priority, you will end up with deadlocks, starvation, and in extreme cases, a scheduler that gives low-priority processes more CPU time than its high-priority counterparts. With SMP, this behavior becomes even more non-deterministic. Endless flame wars and arguments regarding process and priorities have been fought on the Erlang-questions mailing list, deserving a whole chapter on the subject. We will limit ourselves to saying that under no circumstances should you use process priorities. A proper design of your concurrency model will ensure that your system is well balanced and deterministic, with no process starvation, deadlocks, or race conditions. You have been warned! [Erlang Programming: A Concurrent Approach to Software Development](https://books.google.co.jp/books?id=Qr_WuvfTSpEC&amp;pg=PA113&amp;lpg=PA113&amp;dq=erlang+process+priority&amp;source=bl&amp;ots=aNSEgywOGf&amp;sig=BBJu7GBrAzkCTSD_Zh42CGLubAY&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwisoevBtNTVAhUCVbwKHRsXCM0Q6AEIVzAG#v=onepage&amp;q=erlang%20process%20priority&amp;f=false) There are more details on the scheduler in [the BEAM book](https://happi.github.io/theBeamBook/#_process_queues). Most importantly, note that the scheduler will never run a normal priority process when it has a runnable high/max priority process. Low priority processes work differently: they still get scheduled when there are runnable normal priority processes, just a lot less often. So a high priority process can potentially be very dangerous (imagine a high priority process creating logs, with a logger running on normal priority for instance), while lowering other processes to low priority still requires care but is less likely to blow up the VM.
I always liked the idea of Riak, but hated the reality. There was far too much developer and operational overhead required. 
Riak is king! =] 
Hello /u/OnorioCatenacci! I am stopping by to tell you that you are a great person! Have a nice day!
Any livestream?
Not to mention the fact that Riak as a tool isn't a general purpose database at all. *Whatsoever*. Not even close. For a very narrow set of use-cases, it's great. For most developers regular SQL databases are totally fine and the cognitive overhead of an AP database just simply isn't worth it. 
شكرا
No livestream but all talks were recorded - videos to be released in the coming weeks on the Erlang Solutions YouTube channel. 
What is the point of this post? It's just search results. Mods please.
I agree. Why does this exist?
I'm confused as well. The post is misleading. It states that its not for healthcare but yet all I see is that it is.
If you are trying to say that Erlang shouldn't be used for healthcare would you mind providing your reason for why you feel that way?
I think he feels people say erlang isn't for healthcare and he's trying to prove that erlang is in fact fine for healthcare 
Removed.
That is very possible. Though its poorly worded so its hard to say without the OP updating us on it.
West Ham fan here, and I am glad our main sponsor is contributing to Open Source! 
Erm Bet365 not BetWay! 
Great news
Doh! 
perhaps Wings3d.
Thanks, looks pretty cool
Maybe CouchDB
Had no idea CouchDB was an Erlang project, thanks!
check out the [Trending Erlang projects](https://github.com/trending/erlang)
Don't forget about RabbitMQ as well.
One of the best teams around, they are very friendly and patient with contributors.
I didn't know that, but it makes me happy to hear that they are.
it's really useful for many people if you try to do things and blog your experience, what you did, how, what worked, what didn't work and what you found confusing along the way.
I was just impressed that they look for Erlang developer for healthcare app for few months.
Clickbait title but thankfully an actual point is made in the article
Nice, and they'll be open-sourcing __all__ of the basho code too!
I am fairly well versed in erlang, but right now I am trying to get used to it to the point where it's one of my primary languages. Assuming, you are trying to be as lightweight and minimalistic as possible, and not just using RIAK_ENSEMBLE or a ZAB or RAFT lib, it's relatively painless to write a TPC protocol, and avoiding leader election , and cluster size limits by using consistent hashing, and using gen_fsm. If distributed systems is your favorite area, just keep trying, I work a lot with Scala and Go, Go's problem is that you have a lot of boiler plate, and the code easily ends up heavily coupled, and bloated, Scala which I find more easy to write modular code than in erlang assuming you don't use Akka and you go for netty and or finagle, however the community as a whole does not show enough love to systems programmers, especially those who like making servers. 
There's a mic in front of his face yet the sound feed sounds like it was recorded on a phone from the other side of the room. 
Yep, hard to listen for those to whom English is non-native language.
This is good news. I was trying to play around with distributed apps based on riak_core and couldn't even find a way to run a simple demo. I tried OTP 17, 18, 19 and 20 as well as rebar and rebar3 with different templates but wasn't able to run it without crashing and producing a gibberish of strange error messages. I hope somebody is going to upgrade the repo so it works with OTP 20.
It returns the number of bits in the binary you give it, similarly to how `byte_size` works for bytes - `byte_size(x)` == `ceil(bit_size(x)/8)`. http://erlang.org/doc/man/erlang.html#bit_size-1
So the bitstring is, as I've gathered, a binary. But isn't the number of bits basically its length then? Does this function take a memory address, or the binary itself?
&gt; So the bitstring is, as I've gathered, a binary. It's the opposite. A "binary" in Erlang is a bitstring that happens to have a multiple of 8 bits. &gt; But isn't the number of bits basically its length then? You can call it length if you want, yes. &gt; Does this function take a memory address, or the binary itself? The binary itself. There is no such thing as a memory address or pointer in the Erlang language.
I see. So bit_size gives the number of bits needed to store all of the elements of the bitstring? So if there were, say, two integers: &lt;&lt;1, 2&gt;&gt;, bit_size would return 16? And this: &lt;&lt;"abc"/utf8&gt;&gt; would give 3 * 4 * 8 = 96? ...Sorry if I'm completely off-base here. And I can't get online IDE to work.
"abc" as UTF-8 takes 3 bytes, not 12 :)
Thanks! It will help me on my thesis
got it, thanks a bunch!
You're welcome and good luck.
* [ChatBus: build your first multi-user chat room app with Erlang/OTP](https://medium.com/@kansi/chatbus-build-your-first-multi-user-chat-room-app-with-erlang-otp-b55f72064901) * [Making a Chat App with Erlang, Rebar, Cowboy, and Bullet](http://marianoguerra.org/posts/making-a-chat-app-with-erlang-rebar-cowboy-and-bullet.html) * [Cowboy WebSocket Chat Tutorial](https://github.com/essen/chat_tutorial) * [ A tutorial about creating a basic web chat application with Cowboy](https://github.com/hcs42/cowboy_tutorial_webchat) * [An example of a simple WebSocket chat with cowboy.](https://github.com/Licenser/Cowboy-Chat) 
Much thanks. The #3 doesn't work, which is why I had posted..
probably because it was written for cowboy 1.x and the rebar.file pulls master
Thanks
I clicked on the link thinking it was related to Aphyr's [Jepsen](https://aphyr.com/tags/jepsen) series.
I've run a similar experiment with [fancyflow](https://github.com/ferd/fancyflow)
This is really cool. I'd like to see some of the Elixir specific tools pulled into OTP. Genstage is a good candidate I think. The younger upstart can teach us some things.
This is honestly something that's difficult to answer devoid of specifics. You'll need to provide actual examples of each of the scenarios.
Nice, but still awkward because of fatal inconsistency of Erlang standard library when order of arguments is concerned. That's why that tuple case in pipe is needed. 
Cool, and the `_` as an argument placeholder is much nicer than my solution.
Yeah, that's true.
Chatbus doesn't work for me unfortunately, dies immediately upon starting
Yeah, using an argument placeholder like `_` will be much nicer, like @mononcqc's fancyflow. (see above)
I'm pretty sure I've got about seven temp variables in a function somewhere that can go away now..
How does creating something that does something specific create complexity? Erlang is fairly well known for writing functions for just about everything. We use it in place of loop structures, if statements, error handling, etc. So probably not the right crowd to ask if functions add complexity. We believe they don't which is why we use functions for everything. We keep functions small, specific, easily understandable, and readable. All of that actually helps to keep the code itself simple and easily maintainable. If something needs to be changed, we know where or can find it easily and we know that it won't affect the remaining code as long as the function has the same arguments and returns. Systems increase in complexity when you cannot do those things easily and quickly, so people instead choose to just add on to the existing platforms to create some monstrosity of spaghetti code that has no real defined purpose.
will you pay them? https://news.ycombinator.com/item?id=15165507
I'm a beginner as well, and don't have a real answer, but I have to say that using Erlang to process any kind of binary data is fun, fortunately I have work-related stuff to experiment with.
One of my more serious first erlang projects was an IRC chatbot with some extra features. Can do networking, simple AI chatting, maybe some data mining... whatever pleases you. You should even be able to connect it to slack, as you so wish
Ha, something with Slack could be a great idea!
I do have access to a lot of audio files.. could be interesting thanks!
While still web based, I worked on a toy game server for simple board games over web sockets in cowboy. I was able to get some experience on working with supervisors, using process dictionaries, encoding data for messaging, and various persistence technologies like mnesia and postgres. It's not super unique, but it was an obtainable goal for me and I walked away having a lot more experience in Erlang than I had before. It doesn't matter how great the idea could be, if you're not writing code it's not doing you any good. Also, erlang handles things in such a different way that it can be very different from writing the same application in another language. Also, you can remove the HTTP interface on many service type applications and look at it as an opportunity to understand messaging (raw socket or bus) and other, more distributed approaches. Obviously that's not going to work for a blog, but maybe some kind of web-service. 
https://github.com/aaronps/enotepad for a idea. but this does border close to masochism for me. not strictly erlang but i'm using rabbitmq and pika/mqttwarn(py) to hook-up a bunch of services. Once the py pika consumers start to take a hit im going to try to write a erlang consumer, or that is the plan atleast. Otherwise I'm browsing through my O'Reilly books while I poke couchdb in my freetime. goodluck,
Want to share your board game code? Atm I have javascript client with basic asteroid functionality connecting to rabbitmq and using the websocket mqtt plugin to subscribe to queues and share state between the js games. Which sucks because all trust lies at the clients atm. The future idea is to have a consumer(erlang but most-likely pika) that will play the role of the game master to validate and correct client messages, so that the state stays fair across clients, etc.
RabbitMQ is a message queue. This means that you can use it to connect multiple pieces of software to a central broker (eg. RabbitMQ), which propagates messages to others that are interested in them. The messages could for example contain JSON messages in a certain format that you defined yourself. The point of this is to enable communication between different pieces of software via a general hub and protocol. Note: This is my view on message queues in general and might not be 100% true or complete. Afaik there a many different message queue implementations which might offer different features.
Problem are empty directories in /deps. If directory is present, it is assumed to be valid, so it is not clone'd from master repo (and as a result, Makefile is missing) If you delete the whole /deps tree (and add it to .gitignore), make works OK. It is good to .gitignore /ebin, /deps and /.erlang.mk to avoid problems.
So it's really similar to a regular queue? Parts of the system can add an item to the queue, and other parts can retrieve and process items?
Similar, but a message-queue uses a "pub/sub" model- one published message can reach many subscribers, and the MQ will also allow you to configure how messages get retried on failures, failover to other subscribers, and offer the potential for "guaranteed delivery" (the message WILL get delivered, eventually, even when subscribers are failing frequently).
There are a few alternatives, which you should be aware of: * **Redis**, which also provides message queue capabilities, but without "enterprise feature" of RabbitMQ, like routing, guarantees, timeouts etc. That's tradeoff for simplicity and probably for speed. Suitable for real-time messaging, where lost of messages considered "acceptable" and you cannot do much in your architecture. Uses "redis-protocol" * **zero-mq**, in theory fastest MQ, but that's a library (written in C), not a broker, and you have to write your own broker. You can write you own multi-threaded broker with might be super-fast for your specific cases. The most costly in development efforts terms. Uses zero-mq protocol + probably you have to develop your own protocol on top of it. * **Kafka** (I don't have real practice with it) is like Rabbit-MQ, but it is written in Java, less mature project. It can be suitable where you have "producer/consumer inequality", i.e. when messages are produced at greater rate then consumed, but "later" they might be "batch-consumed". Also Kafka declares a bit more messages availability / fail tolerance out of the box as messages are persisted to disks. You might not always need that; it is possible to have that in RabbitMQ. Uses it's own protocol. RabbitMQ uses more standard AMPQ protocol, and provides good set of features somewhere between those extremities. 
MQs are great for decoupling components / micro-services. You can write some clients in perl, in python, in java etc, and they can have either consumer or producer role and know nothing about the other side / role as soon as all they agree about message payload format (e.g. json with certain structure). Produces also usually follow "fire-and-forget" idiom. 
The rabbit and wolf simulation problem is a great way to get introduced to Erlang. https://github.com/afronski/wolves-and-rabbits-world-simulation Linked git repo has a good description of the problem and an implementation that you can reference.
To me the main things you get are protocol standardization, asynchronous processing, scalability and reliability. So - imagine a scenario where you are building a website. When a user signs up you need to: - send them an email - make an rpc call to your provisioning service to set them up - send the signup details to salesforce via their rest api for your sales team to upsell them Notice that all of those things are either things the user doesn't know or care about, or will not notice a delay in, and are also all things that could possibly fail. So if you try to do these things when the user submits their web form, they are going to wait there for some indeterminate amount of time and some of those things might fail in which case maybe the whole thing fails and you lose the signup or you get a partial completion. Instead you may want to do the minimum you need to return to them quickly and then queue a 'user signup' event to be processed later. But all three of those are handled by different services you say, we must make REST calls instead for interop because the notifications team uses Java, and the provisioning team uses Python and the Salesforce team uses...well we don't know we don't talk to them. That's where the standardization comes in - just about every language in existence has a library to consume AMQP, a standard format that rabbitmq implements. But what if rabbitmq is down you say. Then nothing happens at all and that's worse than a partial success. That's where it being in Erlang is nice, you get all kinds of nice HA things in rabbit with not much effort (on your part). And then - when your site gets featured on the front page of youtube, amazon, baidu and ebay and the Java guys are gloating that the Python guys can't keep up with the request level, it's okay - rabbit can handle a whole shitload of messages and keep them until you can get to them. Hope that helps.
It's more nuanced than that. RabbitMQ is a message broker. It's intended to sit between applications and route the messages produced to the interested consumers. I'd recommend reading through the tutorials linked below. Should give you a good look at the many design patterns that RabbitMQ enables. https://www.rabbitmq.com/tutorials/tutorial-one-python.html 
Just make sure you need a queue and not a protocol. 
Yeah, except that the two endpoints have no association. If you have applications on either end of the message queue that aren't always available you can use a queue from RabbitMQ that's designed to be high-performance and always online. 
That is brilliant thankyou. That’s exactly the kind of thing I want to be competent at doing
[removed]
Ah that’s interesting. I’ve had a small play with wx widgets in erlang but felt I should concentrate on the basics.. but on the flip side I feel like being able to throw up some windows and buttons would make me more inclined to write some code
Thanks, not sure why you were downvoted. Looking into similar but different tech always helps me understand, so I'll take a look at those too.
You've asked for "aa" as a 16 bit number. 97&lt;&lt;8 | 97&lt;&lt;0 = 97*256 + 97 = 24,929
Ahh. I see, that makes sense. Thanks.
Thank you!
I find it easier to think in hex. 'a' in hex is 0x61. So 'aa' would be 0x6161. Which if you convert to decimal is 24,929.
The real question is whether or not it would be a signed number if the first bit was set.
The signedness only depends on specification for that. &lt;&lt;X:8&gt;&gt; = &lt;&lt;128&gt;&gt;. &lt;&lt;X:8/unsigned&gt;&gt; = &lt;&lt;128&gt;&gt;. X =:= 128 &lt;&lt;Y:8/signed&gt;&gt; = &lt;&lt;128&gt;&gt;. Y =:= -128. By default is unsigned.
Another project worth checking out https://github.com/bjorng/wings &gt; flip side I feel like being able to throw up some windows and buttons Honestly I understand erlang had to give some kind of gui framework support for its internal tools. But wx widgets with all the generated c++ code does not feel right. Use the right tool for the job. For some windows and buttons and novel development env I would recommend https://www.lazarus-ide.org/ but now I'm punting object pascal on a erlang forum. Why object pascal? no static stdlib or qtlib needed. baseline production executable size of 2.5 MB; and on some benchmarks fpc3 kicks c compilers asses!
Don't drink the koolaid, you can use erlang very effectively as a stateless system just like many other languages. See Inaka's post on how they build services: http://inaka.net/blog/2016/09/06/erlang-rest-server-stack/
How can zeromq be the fastest solution when it's only a library and requires implementing a messaging server?
First, because it is **C-library**, hence you can implement you own message broker in C. In most of cases this would be crazy and error prone, and better use already made Rabbit-MQ as message broker. Second, because you can build **custom** broker, e.g. just copy message to all opened zeromq connections without any security / authorization, topics checks etc. This is what **redis** pub/sub model actually does.
Awesome!
Sounds cool!
I'm pretty sure no teacher worth their pay would assign someone to do matrix multiplication in Erlang. Maybe it's just me, but that doesn't seem like a homework problem. Maybe someone is just trying to do something that is not well suited for the Beam or Erlang.
I remember getting statistics homework in Prolog, so it doesn't sound far fetched to me.
When it runs `f4({N-1, M+1})` it's calling it with one less than the argument: `f4({5,0})` calls `f4({4,1})` and so on until `f4({0,5})` is called -- which matches the first term and bubbles back up.
Clickable link: http://www.codemesh.io/events/codemesh2017/workshops#thinking-concurrently-joe-armstrong
Can't miss out on this. Definitely going!
usually because telecos spend money on that kind of stuff. little incentive to open source, given the complexity/effort of implementing such protocols in a usable fashion.
Just a 5mn googling gave this http://laforge.gnumonks.org/projects/osmocom/
http://www.codemesh.io/events/codemesh2017/workshops#thinking-concurrently-joe-armstrong
i've read it, but i'm still none the wiser
How can I help you with that? ;)
Oh hi there! I am a beginner.. i just can't really parse this line.. `C when C &lt; 0.5 -&gt; C;` if C is not already bound before the case expression – which i think is what the post is about but i still can't read it after reading the article. Thanks
Let me see if I can help… Check this expression: case something() of {ok, A} -&gt; A; {error, B} -&gt; B end. If `something()` returns `{ok, 1}`, the expression above will return 1. If `something()` returns `{error, badarg}`, the expression above will return `badarg`. Variables are bound in case clause heads. Now, let's add guards to it: case something() of {ok, A} when A &gt;= 0 -&gt; {positive, A}; {ok, B} when B &lt; 0 -&gt; {negative, B}; {error, C} -&gt; C end. Now if `something()` returns `{ok, 1}`, the expression above will return `{positive, 1}`. If `something()` returns `{ok, -1}`, the expression returns `{negative, -1}`. If `something()` returns `{error, badarg}`, the expression above will return `badarg`. Again, variables are bound in case clause heads. And they can be used in guards. More info on [Learn You Some Erlang](http://learnyousomeerlang.com/syntax-in-functions#in-case-of) Hope this helps :) 
Oh i get it! That helps so much, really thanks for taking the time to explain it.
[removed]
Well, the natural thing is HTTP or web sockets. Cowboy supports that, though it's pretty low level. If you use Phoenix (http://phoenixframework.org/) then it's super easy. Or you could use GraphQL (https://github.com/shopgun/graphql-erlang or https://github.com/absinthe-graphql/absinthe), which is well supported in the JS world. 
Thanks a lot for answering! I'll look into Phoenix =) !
Cowboy's websockets implementation is fine - I've used it a bunch!
if you use clear erlang (not elixir) then you can try https://github.com/synrc/n2o
The real WTF is the author thinking the shell language and the compiled language are the same thing.
I think you may be replying to the wrong thread. Are you referring to [this story](https://medium.com/erlang-battleground/advanced-list-incomprehensions-6957863dfb4f), maybe? In that one, my expectations about having the same _language_ in both the shell and the compiler (actually: my expectations for both the shell and the compiler to parse _the same language_ in compatible ways) are more visible.
Aeternity refuses to pay me for the work I did. My physical safety was not secure while working for them, they allowed me to get hurt.
&gt;Send a string or JSON to the Backend from the Frontend This could just be a matter of the Fetch API on the front end. Referring to my own apps here: https://github.com/technion/erlvulnscan/blob/master/frontend/assets/erlvulnscan.tsx#L73 And standard Cowboy functions on the back: https://github.com/technion/erlvulnscan/blob/master/src/toppage_handler.erl 
MongoosePush is one of the highlights of the MongooseIM 2.1.0 release. You can use it with our XMPP platform, or as standalone component. This tutorial will walk you through setting it up and configuring it &amp; the client to work with it.
Hi! I am the tech lead of a new Erlang project at Motorola Solutions and I am looking for team members that can join me in Copenhagen. These are the characteristics we are looking for: - Ideally you have experience with a functional programming language (e.g. Erlang, Elixir, Haskell, Lisp or ML) - If you do not know Erlang/Elixir you are keen to learn - You can design a highly performant concurrent application and know the pitfalls of concurrent programming - You know an imperative programming language (e.g. Python, C, C++ or Java) - ​Strong ability and enthusiasm to learn new technologies in a short time
I've filled in most of it. But.. Do you really think people are going to fill in those "Social desirability" questions and then immediately answer "what company do you work at"?
Hi u/disclosure5, thank you for the feedback. The inclusion of social desirability is a technique to use a unrelated construct to validate single source biasness. In this case, the data is not used for any other analysis, or reporting. The personal details such as name, company name and email are optional, and participant can choose to skip. 
i just want to say this helped me so much all ready
My answers off-the-top-of-my-head: 1. You have to *benchmark*. I would bet that *file:consult/1* is faster than parsing XML, but you can't be sure until you benchmark it. 2. You can use *code:priv_dir(your_app)* to get to the proper path to your priv folder and navigate from there to wherever you want to place your config file (maybe just inside that same priv folder). 3. I'm not sure how it's done, but you should check [sync's code](https://github.com/rustyio/sync). It watches folders for changes just like you want to do.
What’s the best way to do benchmarking in Erlang? Just plugin a timer function?
&gt; Have Erlang simply get the contents for every connections. (Seem's like it would be bad performance wise) If the config isn't huge, it might be good enough. I'd try that first. Otherwise, just make a quick gen_server that watches the file using [fs](https://github.com/synrc/fs) and caches the config.
The approach smells a little bit, as you use "poll" model, instead of "notify-me". In "notify-me" approach, you'll need to introduce additional route "/admin/refresh_config", upon which you should re-read your config once.
&gt; smells a little bit What is wrong with a HTTP 304 Not Modified status code? &gt; you'll need to introduce additional route. introducing things on top of standards is what smells a little bit. Also for interest sake. If you are only doing the backend; and only give your frontend dev backbone; expect [a lot of polls](http://backbonejs.org/#Model-fetch).
It is correct to have `304` if cowboy returns file or something trivial like that. But it asks for "configuration change". Usually configuration update is not trivial thing, like re-establishing connections to databases etc. As it is not known, how often configuration is changed (once per day? once per request, once per second), it might be performance killer. &gt; expect a lot of polls. Might be better to notify client on any change, rather then allowing him to poll backend.
Are you in need of an application requiring NAT traversal? Want to see how a TURN and STUN server would handle it? Or maybe you just like to tinker with interesting technologies and experience setting them up first hand? If that’s the case, this tutorial is for you.
what's the real point of using binaries (the ones that look like &lt;&lt;"hello world"&gt;&gt;)? I had to look it up yesterday after already going through the joe armstrong book's section on it. I read it somehow facilitates faster operations on strings? Yeah just not so clear about it since I'm coming from python and never had to deal with such a structure. I see them everywhere in the cowboy server's handler return statements and wondered what's the deal with that. 
Binaries are both cache friendly and compact. Also they allow O(1) indexed access.
array efficiency vs linked list efficiency
that makes a lot of sense now
Coming from Ruby and Python.. i'm trying to learn Erlang, i've read a few books, started a few projects.. but i'm struggling with high-level application structure. I've learnt about gen_server, supervisors, etc. and i'm pretty comfortable with that side of thing. (This is a bit tricky to explain) But 'the architecture' of my app is basically some globally registered processes that message each other through hard coded 'names'. The processes are supervised, of course, but this 'structure' still makes me uncomfortable, and i don't know if i'm doing it right. In my head, it's like everything that needs to be message-able is a global Singleton, and that makes me anxious (without really knowing why, except it's the opposite of what i'm used to). Please excuse the ramble.. i'd say it's quite difficult to learn about high level application design. 
Should I learn Elixir or Erlang first?
Doesn’t matter, Elixir runs on top of Erlang VM in a nutshell. Heck you can use them both together. I picked Erlang first and haven’t looked back, but if Elixir is more your speed syntax wise go for it. You aren’t missing out on anything picking one over the other.
Elixir is probably easier to learn thanks to `mix`, the package ecosystem and documentation.
Also a wonderful tool for working with binary data (protocols etc). Check out http://erlang.org/doc/programming_examples/bit_syntax.html One of my favorite features. Similar to the struct package in Python. 
What you need to send a message is the target's pid. There are different ways to store or access the pid and the "correct" way depends on what you're doing. You can spawn a process and register the pid for retrieval in the future. You can hide the pid behind a gen_server (if you only start one with the same module name/registered name). You can return a pid when starting a gen_server pr spawn a process and keep a reference to the pid (in the state of another process or register it with something like gproc). Accessing the process by name is not much different from a using a module in another language. Especially if you hide it behind a gen_server and perform the lookup in there. Keeping track of a reference to a pid is also very natural in Erlang as most data structures are more or less immutable anyway. 
a lot of people have trouble using erlang after learning erlang. I encourage you to push escript a lot to keep familiarity with running programs, and then work your way up to running actual otp apps on full ERTS.
So I learned enough Erlang to be able to read some random script and understand what's going on but I haven't yet gotten to learning any major libraries or tools (mnesia, cowboy, etc). I'm looking around at the job market and see more positions available for elixir than for erlang, and that makes some sense since it's probably attracting all the ruby people. As someone who doesn't know ruby, but instead came from the python data stack, do you think I'd have better employment prospects (in the backend engineering category) if I were to continue my learning with Elixir from here on out, or stick with Erlang? I'm not sure how Elixir is used at companies - is it welcoming of people writing in both erlang and elixir, or do people just stick to one or another unless they're forced into using the other for whatever special libraries? For example, someone who writes functional scala will likely avoid coding in Java at all costs. 
&gt; meone who doesn't know ruby, but instead came from the python data stack, do you think I'd have better employment prospects (in the backend engineeri Why not learn both? Just start with Elixir if you honestly feel like you have a better shot. Again, Elixir at the end of the day is running on Erlang VM, so you you still have access to all the cool stuff Erlang has to offer including any deps you want to use that maybe written in Erlang. Erlang/Elixir (I can imagine) are used for these cases: - Push Notification Servers (Google, Apple) - Call of Duty (matchmaking) - XMPP Servers (chat) - BPX Systems (VOIP) - HTTP Servers (of course) - Facebook Chat - MMORPG (not sure what game(s)) - Wings 3D (surprisingly) You can use Erlang/Elixir anyway you want it too at the end of the day, the applications are almost endless. Hope that helps.
Don't drink too much kool-aid. Binaries can lead to memory leaks if used incorrectly or if your process/messaging model behaves in certain ways.
yeah I can see how companies say "Elixir/Erlang" instead of one or the other for the majority of the time. As far as I can tell from my very brief look at elixir code, it's as if the syntax is only lightly brushed up to modern styles and everything else is the same(?). I hear there's also better macro support, but after seeing Lisp macros, they can't be mindblowingly different. I suppose learning one after another is simple due to their strong similarities. 
I don't know the exact question(s), but a good walk through the available developer tools (e.g. redbug, recon, dialyzer, xref, elvis, eflame, typer, concuerror, cuter, observer, PropEr, wombat, erlang.pl, etc.) would be a great thing to have.
only if they are bigger than 64KB, isn't it ?
Yes.
Why don’t you write unit tests for it and learn some more Erlang? 
Part of the problem is that nobody really knows what he was asked in the interview, and "inverting" a binary tree doesn't really make sense (or could have many interpretations - including flipping it top-to-bottom and ending up with a graph instead). One comment: this clause: [N, [], []] -&gt; [N, [], []]; doesn't really buy you anything. It will optimize certain cases, but it also adds an additional test to run for every invocation. 
64 *bytes* https://github.com/erlang/otp/blob/754afa1d10e32d2e50d0a8b5ddf316037ba9d6fc/erts/emulator/beam/erl_binary.h#L167 https://github.com/erlang/otp/blob/edafd99aa0b808b79733dbe6ce3175b593c7b307/erts/emulator/beam/erl_bif_binary.c#L2780
sorry for the off-topic comment, but can you please increase the body text contrast on your site? TIA
Thanks for your feedback - we'll definitely look into it! 
Use https://webaim.org/resources/contrastchecker/ to find colors with enough contrast according to accessibility standards.
Is there a summary of what changed between 19 and 20? It's hard to get that from the article, since it describes the whole mechanism (it's incredibly helpful in that, but it would be great to get an outline of differences too).
This please.
Yes, very hard to read.
Yes, very hard to read.
Fascinating. I didn't realise anyone was using Cheney semi-space in production. 
Thank you, i appreciate your help. The bit i struggle with is if i have two servers in a supervision tree that should message each other, how should they discover each others pids? I find the supervision tree gets in the way.. i suspect i'm thinking about it wrong.
You could always subtract 48 from the ASCII value to get the digit.
Hmm not sure why I didn't think of that. Smart hack!
`Integer = 10382.` `Stringed = integer_to_list(Integer).` `[list_to_integer([Char]) || Char &lt;- Stringed].` 
wow that works but it's so weird
you want `io_lib:format`
Int modulo 10 to get rightmost digit, divide int by 10, repeat
Given the current rage in team registrations (we have 28 already 😱), we decided to extend the registration deadline one more day! You have until tomorrow to register your team at https://spawnfest.github.io/registration and win some awesome prizes!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [\[ANN\] Erlang 20.1 Is Now Available On Chocolatey NuGet](https://www.reddit.com/r/elixir/comments/7if9du/ann_erlang_201_is_now_available_on_chocolatey/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [Rebar 3 3.4.7 Now Available On Chocolatey NuGet](https://www.reddit.com/r/elixir/comments/7if9h8/rebar_3_347_now_available_on_chocolatey_nuget/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I'd assume that they mean that things like `[1, 2, 3, 4, 5]` and `{foo, 1, bar, 2}` would be literals. Anything that is fully known at compile time, and therefore doesn't have any runtime component to its definition, can safely be shared without any need to copy. But I don't know for sure.
see http://erlang.org/pipermail/erlang-questions/2017-October/093983.html or http://erlang.org/doc/reference_manual/data_types.html
[That's the gist of it](https://medium.com/@jlouis666/an-erlang-otp-20-0-optimization-efde8b20cba7). tldr: Literals are already treated specifically with off-heap storage (so a given literal used in several places is actually a single constant), however before OTP20 when *sending* the value between processes the literal would be copied and sent as a regular value. In OPT 20, the literal is not "downgraded" to a regular value anymore when sent, it will remain a "literal reference" if it does not leave the current node.
TLDR for TLDR: Literal is any complex value (not an integer or atom or local pid/port) which is fully known at compile time, and is stored in your module file and then loaded with it. Literals are immediately available to your code during execution (i.e. very cheap to access). So they changed rules of garbage collection and how it treats literals, sometimes they can be moved to the regular heap when a module is reloaded.
I can't remember which one but at one Erlang User Conference, Garret Smith did an impromptu talk about patterns in erlang and I think http://www.erlangpatterns.org/ was the result (or maybe he had it up before..) of the talk.
Okasaki. I read it and nothing changed. Patterns aren't all that important, in the balance
An interesting book is [7 concurrency models in 7 weeks](https://www.goodreads.com/book/show/18467564-seven-concurrency-models-in-seven-weeks). Not an in-depth dive into the field but a wide breath overview. 
This is the kinda thing you use limited options for rather than number imput. Looks nice otherwise though.
[removed]
probably take a look at the site. despite its title, what he put up are not software patterns, but rather scribbled notes for things that aren't really related to patterns, but are rather just topics he wanted to discuss [example](https://github.com/gar1t/erlang-patterns/edit/master/patterns/stats-sink.md)
https://www.humblebundle.com/books/be-a-coder-books Referral free link
It has one built in so why would you do that?
Isn't etcd written in erlang?
I think it's written in Go.
But why not build something else to show the same things? Maybe build a blockchain or something. Those seem to be popular these days. How about a container orchestration thing? 
Not OP but key-value stores are easy to understand so you can focus solely on the code. Trying to teach blockchain and Erlang just complicates things.
a key-value store is simple, people understand it, it can easily be implemented in Erlang in less than 50 lines of code and gets out of the way to focus on the things I wanted to show on the article, which is everything else. Readers can take the example remove the 50 lines and build something else. Something more complex would take more time to do, would require more explanation and would hide the other parts in a sea of explanations about the other thing.
A way to setup lasp in a cluster to play with the replication of the data and see how it moves between nodes. You can play with one node too, but the fun part is the distribution support so I made this. About what's the real life use case of lasp, here's a description from its website (https://lasp-lang.readme.io/docs/what-is-lasp): Lasp is about writing correct distributed programs. The goal of Lasp is to allow you to write a program once and know that it will behave the same whether it is executed on one computer or distributed across many.
I am working on this guide: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ 
It is as simple as `rebar3 as prod release tar` then use any tool to ship the tar ball to your production server. Unpack and have fun.
Wonderful, thank you
&gt;one can take care of the oven, while the *otter* cuts the lettuce Why is there suddenly an otter in the kitchen? Should say "other" :)
Should it though? An otter cutting my lettuce sounds perfectly in tune with the pedagogical angle in Learn You Some Erlang.
I think there is a simpler explanation: Concurrency : *a bunch of independent tasks that don't have to wait for each other and could potentially run at the same time*. This is usually a property of the algorithm or it's a language construct (like say an Erlang process). Parallelism: *a bunch of concurrent tasks are running at the same time*. This is usually a property of the runtime environment. Depending on number of CPU cores and concurrent tasks available to run, some of those tasks might run at the same time. Example: "Joe makes coffee" and "Robert makes tea". These are concurrent tasks. Without knowing anything specifics about where and when they are making coffee and tea they don't have to wait for each other, they are independent. Now imagine Joe and Robert are at the office and they have access to 2 kitchen one on 1st floor and another on the 2nd. At 9am they get to the office, Joe goes to kitchen on the 1st floor and starts making his coffee. Robert goes to the kitchen on the 2nd floor and starts making a pot of fancy Earl Gray tea. By 9:20 in the morning they both have their beverages and are ready to start the day. In this case those two concurrent tasks ran in parallel. And if it is not obvious yet, the kitchens are the CPU cores. In another scenario, Joe and Robert work in a smaller office which has only 1 kitchen. Even though in principle they should be able to make their beverages independently of each other, they have to share the one kitchen. So Joe arrives at the office ahead of Robert at 8:59am. He heads to the one kitchen and starts making his coffee. Robert gets there at 9 but the kitchen is busy. He has to wait till after 9:20 when it becomes available. In this case the tasks are still concurrent but they could not run in parallel. they to use the same office kitchen. Now their tasks might be concurrent, but because 
thanks for posting this explanation :)
Both are great! Erlang is probably better for correctness (amount of syntax traps is lower). Elixir is more expressive. As for community - Erlang has some very strong programmers among its users. Elixir community, in my opinion, is younger and less experienced.
I was in your position but didn't really like what I found in the Elixir community. Erlang community is more mature which makes it easier to work out how to do things "the right way"^TM than Elixir stuff I saw.
Learned Erlang first. Elixir was easy to understand and learn afterwards. Know people who learned Elixir first - they don’t understand Erlang.
I learned both, first Erlang for a few weeks then Elixir. With hindsight, it was the correct path. Better to learn some Erlang before Elixir. Everything about Elixir will make a TON more sense if you first use Erlang. 
If you're planning on learning a new language just for the fun of it, I would suggest that you just go ahead and pick whichever language seems more fun and can keep you curious for longer (although from my perspective Erlang and Elixir are both very capable of checking both of those boxes). For me, Elixir was easier to approach so I gravitated towards learning it first, but your mileage may vary. Eventually you will learn Erlang anyway, as the core concepts rely on it regardless of your choice for a first language to learn, and you will most likely find yourself occasionally using Erlang from within Elixir anyway if you were to use it long enough.
Thanks everyone, Erlang it is!! Any good recommendation for learning material??
It's more like a non java jvm language than coffeescript though, it doesn't transpile to erlang but runs on beam no?
Learn you some erlang for great good http://learnyousomeerlang.com
I learned Elixir first, but took the time to learn the principles of OTP. This is an absolute must. While you can learn and often treat Elixir like you would Ruby, you’ll be missing out on many of the underlying principles that make the Beam VM so great. You’re fine learning either first, but be disciplined and spend the time to dive deep into the language if you want to make the most of it.
It's important to remember that they are more similar than they are different — syntax differences, that's all. When you are learning one you are learning the other. With a few simple transformations memorised you could honestly learn Elixir from Erlang tutorials or Erlang from only Elixir tutorials. I'm exagerating a tiny little bit, but which ever you pick won't be wasted in any way if you later decide to switch because what you are actually learning applies to both, so really don't delay... just pick one and start coding
Elixir is the child of three languages: Erlang, Ruby, and Clojure. For you to understand Elixir fully, you need to grok a Clojure-like macro system, Ruby syntax, and the core semantics of Erlang. In my experience, taking that last step first and isolating the required Erlang learning really helps when you do pick up Elixir.
I started with Erlang, but I didn't really "get it" until I moved into Elixir. Whichever speaks to you first, use that to venture into the other.
It really isn't ruby at all (vaguely similar syntax, entirely different semantics) , nor is it welded onto anything in the way either the various JS languages or Java langs are. Those language try to bring a different paradigm, usually one less wild west in the case of JS or not so 90s-OOD in the case of Java. Elixir stays very true to the ideas of Erlang in OTP with a more modern (which is not the same as "better" or "worse") syntax and improvement like better module system, better tooling, and hygenic macros.
This. The Elixir community is indeed younger, wuich comes in part from a larger and more diverse community and in part from being a language that is more approachable for them. Lots of Erlang libs are used in Elixir, though, and the core concepts of the BEAM platform are to be found most plainly in Erlang. So it is a fine starting point if it's syntactical quirks don't put you off. As such I think there is real benefit to learning Erlang if diving into the ecosysten. That said, learning Elixir at some point is definitely worth it as there are some absolutely amazing libraries available for it (in addition to all the great Erlang ones) and the tooling is undeniably better. I wrote Erlang for a number of years before picking up Elixir, and I find it hard to go back to Erlang for projects due to the productivity difference, but the knowledge is really useful to have all the same.
If you didn't get what a difference between lib, app, release try out first two chapters of this book https://www.erlang-in-anger.com
Well, you don't **need** to do anything but Elixir's macro system is the foundation of a lot of very useful features of the language so understanding it - even if you never write a single macro - is highly recommended. But I agree it's an advanced topic and definitely not the first thing one should dive into when picking up Elixir.
Thanks. 
**Reported for referral link spam.** https://www.reddit.com/user/UnkindTabore/submitted/ https://www.reddit.com/user/fegertsa/overview/ https://www.reddit.com/user/trukirukia/submitted/ https://www.reddit.com/user/buyuksd/submitted/
Elixir was never about syntax or about providing a subset of Erlang, which was Coffeescript's primary goal. This talk can help highlight some goals: https://www.youtube.com/watch?v=V5fMQcSy3y8 Also Coffeescript fell by the wayside because JavaScript evolved drastically, which was much needed. I don't see Erlang drastically changing nor it has to. So I don't see how they are equivalent in goals nor how they will end-up in the same place.
okay. i stand by what i said
After 3 years of college, with C, Java, PHP, etc... I got hit with Prolog in the 4th year. It's a mindfuck. And I loved it.
Sounds like a good mash up for a college course though. 
I'm back to Python after a few months of Erlang, and I miss it so much...
Dunno verilog but I took Computer Engineering, not CS.
Then get back here bro
Computer engineering doesn't cover a HDL? How weird. Still that's good coverage. 
If you really want to blow your mind, try Racket, Pharo or assembly... 
I think i’ll skip assembly for now. I’ve never heard of the other two, i’ll take a look
Jesus stop posting fucking referral links you wankers.
Is this Erlang related? You might have better luck on SO: https://stackoverflow.com/questions/tagged/yacc
Leex is more simpler than flex/lex and don't give you an easy way to do this but probably you can write module (gen_server for example) that will store such information.
what I did with indented efene back in the day was to store the indentation as a token in the lexer (match blanks after one or more newlines) and then process it in a step before the parser to add indentation information and then pass it to the parser. no state needed.
Thank you! This is probably the easiest solution. A user in #erlang also suggested to store the current indentation in the process dictionary. This second solution feels more like magic, but maybe it is worth trying it if more complex tasks are needed.
Interesting, but the lack of regex support might be an issue :) Thank you tho!
On the other hand: Whoever will inherit all the technical debt you create by using Erlang will not love this lang. Guess it's good for job security though.
My english is not good enough to compremehend what «technical debt» is.
It more or less means that someone has "to pay" for 'wrong' technical decisions. I implied that using Erlang for a project just because it's a unique language is not a good decision, and the project would have problems in the future (small community makes it hard to expand the team, lack of quality developer tools makes the few developers not very efficient). But it seems you're just looking for languages to learn and not for some serious project, so never mind my comment.
Yes mostly. But i’ve heard that erlang is the go to language for large long running services, which is something i’ll keep in mind. And i am not learning and using it ‘because it is unique’
I don't have much experience in Erlang, mostly learning on my free time. So someone more experienced are more than welcome to correct me. 1. I like vim, easy to set up some Erlang plugins. I've also heard good things about emacs, which I've used a long time ago. I Haven't tried any other ide for Erlang, so not much more to 2. Not me. 3. Strings are slow, but they have binaries :) 4. Look up Erlang OTP that's what people are using. I know it has been used for the Chat of Facebook, what's up, servers for call of duty 4. I don't know if it is used for Telecom switches anymore, I assume so since the language were created for it. 5. I haven't tried clojure, but I assume so. 6. Look at hex.pm there you can filter on most downloads. I'm guessing cowboy and poolboy are among the ones with most downloads.
1: Emacs has a full-fledged Erlang plugin thing, don't know beyond that. Most IDEs or editors (or OSs disguised as editors ;p) at least have syntax plugins, though. 3: The ecosystem isn't as strong as it could be. Because the language isn't all that popular, libraries aren't often "battle-tested", and there's not a ton of them to begin with (though the OTP has almost everything you'd want anyway). 4: I've seen mention that Erlang is used in a few game servers, but yeah it's mainly telecom as well as online chat. League of Legends uses it for their chat servers, and Discord is based on it. 5: From what I've seen using Erlang from Elixir is mostly just by prefixing stuff with a colon, very simple. But I've never used Elixir so I'm not sure.
5. if you think elixir is Jruby then erlang is clojure. Java is more akin to C for BEAM.
These are my super-biased answers: 1. I like SublimeText and I don't really use any erlang-specific package/plugin with it. 2. Not me. 3. A big one: UI. There are some efforts being made with the goal of making the wx libraries more approachable, but beyond that, there is almost 0 effort put in UI development with Erlang. Even for web front-ends, there is nothing comparable to Phoenix. 4. Besides telco, Erlang is used for Real-Time Bidding (e.g. AdRoll), messaging (e.g. WhatsApp, MongooseIM, Discord), Social Apps (e.g. Whisper), and other companies (e.g. Klarna, RabbitMQ, VocaLink, Sqor, AlertLogic, etc.). 5. I don't know - since I don't know Clojure :P 6. Check [Hex.pm](https://hex.pm/packages). From there: cowboy (&amp; friends), hackney, metrics, poolboy (even when I keep asking people to try worker_pool :P), jsx, meck, recon, lager… From my [corner of the world](http://inaka.github.io), the most popular is apns4erl and sumo_db.
idk enough to answer all points so I'll just comment on the ones I know about 1) IDE doesn't matter, I've just been using Atom with some plugin/extension for syntax highlighting. 4) Erlang is used anywhere where soft-real-time apps can be used, for example chat servers, web servers, web applications, general backend tasks and task management, etc etc. just think Python minus the data science aspects, adding in a lot more scalability. 5) Interfacing with Erlang modules in Elixir is just swapping some small syntax (example here https://stackoverflow.com/questions/35283888/how-to-call-an-erlang-function-in-elixir) 6) https://github.com/drobakowski/awesome-erlang
I write both Elixir and Erlang, so my dev env is setup for that (meaning, I don't avoid Elixir tools, but select for them, as they are usually a superset of / support Erlang as a first-class thing): 1. I use VIM with Alchemist 2. https://github.com/JakeBecker/elixir-ls ... never tried it, as I don't use an editor that support LSP ... 3. Not as many libraries as one might hope, though with hex.pm (and if you don't exclude Elixir) that is getting miles better month by month. Raw computational applications aren't the fastest, but at work we route around that with bindings to native code. That said, it can be faster than one might expect if you are careful. See cowboy or https://elixirforum.com/t/announcing-jason-a-blazing-fast-json-parser-and-generator-in-pure-elixir/11030 4. Lots of payment processing companies use Erlang; huge usage in mobile gaming and online chat; online betting is a decent footprint; it is big in the jabber and message queue worlds; online betting (e.g. Bet365); if you count Elixir, it used in many more places including such "exotic" things embedded systems at Le Tote and SmartRent (as well as some factories that use it for automation of production lines!), as well as the more traditional use cases one would expect such as web services like Pintrest and Grindr .. lots of usage out there, far too many to list in a reddit comment :) 5. Better imo, because *both* are functional languages and *both* build on the exact same OTP concepts. Just call :module.function(args) to call into Erlang. Easy peasy. The only gotchas come around Erlang functions that return Erlang strings (chars in lists; in Elixir a "charlist") rather than an Elixir string (Erlang's binary). Easy to convert, but sometimes I get caught out when I forget what an Erlang function returns. Thankfully it becomes pretty much immediately obvious when running tests and the docs are great for tracking these things. 
I have not done much in erlang for quite some time now, so feel free to correct me. But here are some infos I remember: 1. Emacs. The elisp code/modes to work with erlang come already packaged with erlang. Which should already tell you what „the big guys use“ since like 20 years. 2. Do you mean if it would be worth it? Probably yes. EDTS https://github.com/tjarvstrand/edts is probably the most mature project if you want to implement that protocol. I remember EDTS to be the best solution for erlang. It just had everything I needet. It’s basically what Cider is to clojure or Omnisharp to C#. 3. I don‘t know your background. But the whole build/apps/beams system was kind of confusing at the beginning for me. Kerl (think nvm or pyenv for erlang) and the https://erlang.mk script helped me a lot at the beginning to not lose my mind. Btw: forget the strings discussion in erlang. In doubt you can fall back to NIFS in C. 6. This project may help you a bit discover some commonly used libraries: http://n2o.space https://github.com/synrc/n2o
Have dealt with binary stringsplicing. Here are some hints: * Resort to type reference: http://erlang.org/doc/reference_manual/data_types.html * Also this: http://erlang.org/doc/reference_manual/typespec.html * You likely want some reference on *gen_tcp*: http://erlang.org/doc/man/gen_tcp.html Other than that, I'd have to give extended thought. It is about 21:15 and likely tomorrow evening I might help out with stuff some more. I don't like giving full solutions, just hints.
Thanks for the input everyone. I'll try to get it figured out by the time the assignment is due, but if not I'm pretty much fine with what I have. I just wanted to play around with Erlang. I have the header setup for communicating with the C server, I just have to think a bit about the receiving side of things.
Actually why do not switch to plain ascii Text when communicating with the server instead of sending numbers? This should significantly simplify communication: no need worry about Byte order on the wire ...
For emacs, I use [edts](https://github.com/tjarvstrand/edts) and it works pretty well. Sometimes you need to finagle the .edts file to get the Erlang VM started in a buffer but it works great once running (esp paired with reloader or similar during dev). Other than that, I just have a 'before-save-hook to indent the file when saving. For 4, we use it in [kazoo](https://github.com/2600hz/kazoo) to control a telecom platform but use FreeSWITCH and Kamailio for the heavy lifting of the low-level telephony bits. We're going on 8 years with a minimal team (2 people basically for the first 4-5 years) and have found Erlang to be a great force-multiplier in terms of what individuals and a small team can get done.
Not only is parsing (relatively) expensive, it means you have no choice but to perform additional memory allocations (also expensive), while you can validate the received buffer (e.g. length and control bits) and then simply point variables of the correct datatypes into the correct locations. It also makes the code on the sending side more complex and slower as you have to translate numbers to strings. And really, these days you can just send PODs such as integers in the commonly used byte order (e.g. little-endian). The days of an unknowable-arrangement-of-systems-on-the-internet-with-big-endian-being-common-if-not-dominate are long over.
I can't say if this is spam or not, but it looks legit enough.
I'm interested in this from the US perspective as well.
This is the salary calculator I was using https://stackoverflow.com/jobs/salary The data is limited, but it might offer some understanding since you are in the US.
It would depend on your knowledge as a developer in general, and your experience with Erlang specifically. But your figure doesn't seem way off for Dublin (maybe slightly on the low side). I think our salaries are slightly on the high side though. Good luck :)
Somewhere 35-40000 SEK a month maybe for Stockholm junior dev maybe. So your estimate sounds reasonable as €1 = 10 SEK
Why would the language be relevant for salary?
I have used wxWidgets for quite some time on an experiment I'm doing as a side project. Kind of like it but it requires a bit effort to understand it enough to make good things with it. I recommend it and actually think there are not many more alternatives for such job in Erlang/Elixir.
I did this for [DitBustErl](https://github.com/silentsignal/DirBustErl) by creating a REST API with WebMachine and a simple frontend with Bootstrap. This way, the user can pick any browser and integration is much easier since you have a nice REST API, which is easy to consume from any other programming language. Decoupling has such nice benefits, including the opportunity for alternative GUIs, easier testing and automation, etc.
Looks great! Indeed a web-app plus an Erlang server that works with it can be an ideal solution too.
Thanks, I will try it out. It's disappointing how little progress has been done in Desktop Like GUIs since the web came along. Visual Basic had a better UI toolkit than most current tools have today, which is appalling, but true. Even QT / Xcode and Xamarin seem frozen in time, with GUI languages that were invented decades ago. Oh well, no point complaining, I am glad for wxWidgets! Thanks!
While this is mostly already done with things like ansible, i'd do my best to copy one of the architectures that suits what you need.
Join us for an evening discussing the Erlang Ecosystem and its use cases, just two days before the Code BEAM SF conference takes over the city! Registration and full agenda available here: http://ga.co/2FtRNxH Our experts: - Robert Virding Erlang Co-inventor, Principal Language Expert at Erlang Solutions, Erlang - Miriam Pena, Staff Engineer, AdRoll - Anna Neyzberg, Software Engineer, Carbon Five The programme includes two sessions: - Session 1: Introduction to the BEAM and the Erlang Ecosystem - Session 2: Erlang, some practical examples
I don't think so. A lot of it is about functional programming, and patterns which still apply. They also cover some stuff aboutthe BEAM vm in general which is also relevant. To put things in perspective, my focus was really Elixir, which is not covered by the book, and I still found it a relevant read.
it's still good I used it about 3 months ago
It is not an elixer book
Erlang 15 is semantically identical to Erlang 20, and although I haven't run it tests lately, I'd expect your worst case scenario is a library call with a deprecation warning. If that happens, Google the replacement. Honestly, certain trendy languages have ruined learning, with the whole "no point learning one version back where it was totally different" approach.
Well I was talking about Javascript, whilst hoping to avoid naming it in order to avoid someone defending it :p
I think there's a place for "permanent revolution" languages / frameworks, though I prefer not to have to use them. I just don't want permanent revolution to be the only choice, and for that to influence other more stable languages.
Yes but the two are closely related.
Germany might be hard to compare to Sweden in this regard. Germany is one of the European countries that still clings hardest to the "breadwinner" model (one family member provides for the family instead of two which is more common in Sweden). Countries leaning harder into the single breadwinner model tend to have higher salaries, because you will only have one of them instead of two. If you want to dig into this I'm sure there are many places to look, but the UK, the Netherlands and Gemany are outliers in Western Europe: http://ec.europa.eu/eurostat/statistics-explained/images/4/42/Gender_gap_for_average_hours_worked_in_main_job%2C_by_NUTS_level_2_region%2C_2014_%28¹%29_%28hours_per_week%2C_difference_between_the_average_hours_worked_by_men_and_the_average_hours_worked_by_women%29_RYB15.png If you have a few years work experience from previous jobs, I think that will make a larger difference in your salary, and if you're just starting Erlang, you're not really motivating a greater pay for that language specifically.
It's missing an updated part on build tools like rebar3, but it teaches you the standard tools to build releases, so it's not like it's outdated, it simply doesn't cover everything it could (it still covers *a lot*). I'd also suggest to take a look at the "User's guide" in the official docs, it teaches you some stuff more in depth and in a more concise way.
I respectfully disagree. Official docs can be intimidating, unless you've already learned Erlang.
I'm not sure if I haven't made that clear, but indeed it's not a book about Elixir. Nevertheless, both Elixir and Erlang run on the same VM and essentially work very similarly even though the semantics. My point was that wheter the book is actual or not about the language's semantics right now, it's still a very good book to learn about programming in general. Another example of such valuable book would be Little Schemer by Daniel Friedman and Matthias Felleisen. It's often cited as an excellent book for learning Erlang... even though all the examples are in LISP and Scheme.
Little schemer gets you thinking about the problem in the right way 
There are many differences between LFE and Kapok, such as, LFE syntax is more like Erlang while Kapok syntax is closer to Clojure; LFE is lisp-2 and Kapok is lisp-1; they have different Macro implementations; LFE has longer history and more tools; etc. Kapok could be taken as a rewritten version of Joxa, with some changes on the syntax and the effort to embrace the nice features/libraries going on recently in Elixir.
Got feedback from the Lisp Community that it's divisive to use "Modern" in title, I'm gonna delete this post.
I dunno, as a member of the Clojure community, I don't have any problems with your title. :)
it really is not. depending on how you built your runtime you might run into issues with crypto for example
the real question is why not LFE?!
I'm interested in using LFE, but have been put back because of the lack of activity. Currently I can only compile the project from the develop branch instead of master, and the documentation is pretty old. I feel like someone needs to take over the repo and get it back into shape. That being said, I do hope Kapok succeeds and stays relevant. The adoption of a language comes down to community, tooling and plugins.
The number of folks on alt-beam languages is miniscule. Starting over afresh isn't the solution with such a small ecosystem. I think Kapok is cool, but new shouldn't be a rallying point.
Oh yeah I completely agree. I would rather like to see LFE getting more development.
Kapok could be taken as a rewritten Joxa, which has many differences compared to LFE. I think Eric's post http://www.ericbmerritt.com/2012/02/21/differences-between-joxa-and-lfe.html will answer the question "why not LFE". I notice that both community of LFE and Joxa are kind of lack of activity. You know, I'm one member of the Joxa team in github. Because Eric doesn't have the time for Joxa, and I don't want to drag him down and force him to do things like design discussion, code review, etc. So I just create another project and do the rewrite, adding some features Eric may or may not like. Most importantly, If I screw up something, the blame is on me solely. ;-) It will be ideal if someone could design a programming language and do it as a full time job for living, just like José for Elixir. Otherwise, the main issue will be the lack of time. I could understand why it turned out to be kind of dormant in LFE.
I am not sure what it should be, but it should be something. 
It makes sense if you have a fixed mount of human resource, it's better to gather all of them to finish only one thing instead of two. But it's wrong to take it as a zero-sum game in terms of alt-beam languages. It's a open society and there are reasons why there are so many programming languages and dialects of Lisp: historical reason, personal favor, community, etc. In general, those guys who like scheme, are not exactly the same group of people like common lisp. So if we create different alternatives for different languages or dialects, more people will be gathered into the ecosystem. You can not blame Jose Valim for doing Elixir as a another beam languages. Elixir brings lots of interest and people from Ruby community to Erlang VM ecosystem.
Interesting. Why the distinction between atoms/keywords? Imho keywords do not bring anything interesting here, especially if you're aiming to be close to erlang/elixir. 
Both atoms and keywords are translated to Erlang atoms when used as datatypes. In the following cases, keywords is needed: 1. For keyword function arguments, following "&amp;key"(as what's in common lisp). It's different when the compiler translate a function call of (f #key #value) to a call to function "f" with two arguments which are atom "key" and atom "value". While the code (f :key #value) is translated to a function call to "f" with a keyword argument of the key "key" assigned to value "value". Keyword arguments are not supported in Erlang or Clojure. But I found it's convenient sometimes so that just give a try to add it. 2. For special forms like "ns". It's similar to Clojure to use keywords in special forms, and map keys for constant names, which makes the code look clearer IMHO. And atoms are used only as a datatype.
Only if you use it for the wrong reasons. I also find that Erlang code is the only thing I can read without ever needing comments or any kind of code documentation. It's apparent where everything comes from.
I'm using IntelliJ IDEA with Erlang plugins. As a plus I can also pop a terminal window open, start an erl shell, and compile and run small things directly without having to change the configuration each time I want to do something different. I have also managed to get it to step through code in a debugging way. For small things this works great. Unfortunately the software is intended to be deployed outside the scope of my laptop so I can't run our actual product here under the debugger. That said, Erlang isn't hard to debug since everything is an invariant, once set. So it's possible to attach to the running process and try stuff out on an attached erl console. Anyway, I also use BBEdit with Erlang plugin just for editing, because it has way better search/replace and other editing-specific tools, not just focused on IDE stuff. And I love that tool for absolutely everything - it does code markup for many different languages. But it does cost a little $. But if you're doing grown-up work, it's a nice grown-up tool to have.
Thanks! Cool.
I haven’t worked a lot with these modules, but they definitely handle the tcp/udp/tscp headers. They provide you with an”raw” tcp stream over which you send your data. You need to provide a higher level protocol/header if you are using any, but not the lower level tcp stuff. 
For the most part they're equivalent to using `socket()` and associated functions on *nix.
It's very interesting to see some NIF examples, as there aren't too many functional ones available online. Did you consider the issue of blocking in this implementation, or is the algorithm short enough so it doesn't really matter?
For this NIF, I did not add any sort of contingency for longer execution times. Using the benchmark data I gathered, it can calculate the distance between two 36 character UUIDs ~285,000 times a second on a relatively modern processor, or around 0.003 milliseconds per iteration, which ought to be an acceptable amount of time for the scheduler to be blind. Since the Levenshtein implementation used here is O(n*m) time complexity, I would expect that in order still return in under 1 ms, you ought to be able to run it over two inputs of size `sqrt((36^2/0.003) * 1.0)` ≈ 650 characters before it starts taking too long, though this number will vary by system. You bring up a good point though - I hadn't considered the effects of exceedingly large calculations on the scheduler. It looks like [enif_consume_timeslice](http://erlang.org/doc/man/erl_nif.html#enif_consume_timeslice) can be used indicate how much of the current slice has been consumed by the NIF; perhaps a good solution here would be to either continually call `consume_timeslice` as part of the outer loop and if the timeslice is expired then reschedule the remaining work using [enif_schedule_nif](http://erlang.org/doc/man/erl_nif.html#enif_schedule_nif). Alternately, it may be less overhead to simply check the size of the matrix at the beginning of NIF execution, and if it is above some threshold then reschedule the work on a CPU bound dirty scheduler using `enif_schedule_nif` again. I will play around with some of these options when I get the time and maybe write them up.
If anyone else is interested in some cool Nif code, here are some examples I've built/use a lot. Linux Joystick events https://github.com/connorRigby/joystick Open CV camera handling (wip) https://github.com/ConnorRigby/elixir_camera And of course some good ole arbitrary code execution https://github.com/ConnorRigby/elixir-ace
I also tried and wrote NIFs for ntru https://github.com/alisinabh/ntru_elixir The only part that i haven't fixed yet, is Makefiles for Windows, BSD and mac 
Followup: here is some information on making the NIF more scheduler-friendly without taking the easy way out and flagging it as a dirty NIF: https://rhye.org/post/native-scheduling-erlang/
I'm pretty sure that the only deprecated stuff is the random module, otherwise all the examples work fine.
I'd go with whatever is healthiest (most recent updates, good docs, issues being addressed).
The one written in the language I’m using. 
you want to show off your smartness? re-read my question.
you want to show off your smartness? re-read my question.
I don't think they can be identical - since interoperability does not necessarily mean they are idiomatic or easy to use in both cases. Example: What if erlang library returns record? It's possible to use it in elixir but in most cases it's better to write a simple wrapper anyway. For this reason and readability or future contribution... I prefer to pick up libraries written in the language I'll write my code. 
".. In what case, an Erlang developer..."
I don't write erlang code so just speaking elixir dev :) as you mentioned that too. I think one of big difference between erlang and elixir lib are string - elixir uses string (basically binary though) but erlang uses charlist. Also erlang uses own tuple convention since there is no struct - e.g. date time. You are making a pretty hypothetical question, basically :)
Erlang definitely. Erlang library can be easily used from both languages and build toolings. I doubt there is any library in Elixir which can be easily used from Erlang project. 
An Erlang developer will pick the Erlang one, because it doesn't depend on the elixir runtime.
interesting. can you elaborate? 
&gt; I doubt there is any library in Elixir which can be easily used from Erlang project. what's a difficulty in that?
ahahahahaha
and, what's better: charlist vs string, typle vs structs?
* I'm still not sure if rebar3 can properly work with Elixir projects. * Logger. No one ever use raw lager in elixir project, so LoggerLagerBackend should be configured in top-level project and Logger's compile time truncation params should be passwd somehow, etc. * Last, but most annoying - module names. No one ever bother to add atom-named module with pure erlang interface. This is all technical reasons, but there is one cultural - I highly doubt there is many people in Elixir community who bothers themself with all that Erlang interop. IMO, there is no such thing as Erlang for average Elixir developer, they just don't care, and it is hard after all. 
if a developer knows equally well Elixir and Erlang and wants to create a library, do you suggest that he creates it in Erlang? 
I have no answer for this question. There is ton of factors to outweight any suggestion anyways. After all making library logger- and build-system-agnostic is nearly unreal, so I don't really want to judge anyone. 
What is wrong with you?
Does the Elixir library use macros? If so I'll take the Erlang one thank you
I can build projects without having to install Elixir if they only have Erlang dependencies.
Is this online?
http://learnyousomeerlang.com I also liked Armstrong's book Programming Erlang (which is the one I read when I was learning). 
Learn you some erlang felt a little quick to me and kind of felt like it jumped around a lot. I'd also recommend the oreily erlang book
Also, the language in itself is really simple. Some might say poor. Just jump straight into it. The doc has a few flaws but you can just code and learn. Again, Armstrong's book. Meh, i don't like CS books.
Youtube has a bunch of nice videos. You can follow along with the speaker, setup your own erlang env and do the exercises with them. You'll make mistakes, learn from them, and move to the next lesson. I'd stop the video after viewing an example to type in the exercise and horse around with it. If you look around online you'll also find several free pdfs of books. The language hasn't changed much, so the older docs are fine for starting out.
Thursday 26 April 2018 1730 CEST / 1630 BST / 1130 EDT / 0830 PDT Communication is a complex topic, especially in the context of healthcare. Nowadays we can find multiple applications that use a variety of external services with different levels of control over them. In this session experts from Forward, and their partners at Miquido, will showcase how Forward develops its tool to support complex communications in a Healthcare environment. They will also explain why and how Forward migrated from a SAS messaging platform to a self-hosted XMPP protocol implementation and what are the downsides and benefits of both of those solutions. Top 3 take-aways: 1. Why common messaging applications are not always enough 2. Surprises while migrating from SAS messaging platform to XMPP 3. Pros and cons of SAS messaging and XMPP
Are you going to replicate the ticket giveaway/50% off as you did for Code Beam SFO? That would be awesome!
Im also trying to do this. Running into issues with the ./rebar3 compile
I believe Erlang-on-xen does it, so it must be possible.
Containers need only contain the application of interest and its direct dependencies like libraries. The kernel, in particular, is absent. There are no other processes than yours, not even init(1) from your app's perspective. If you shell into a container and see a bazillion files in /bin and /usr, it's only because whoever built the container based it off Debian, or Ubuntu, or Centos or whatever, and left all the unneeded stuff. You can also make your own Dockerfile and say "FROM scratch" and you get nada. Here's some more details. https://superuser.com/questions/889472/docker-containers-have-their-own-kernel-or-not
You might want to look into [Nerves](https://nerves-project.org/). Though it's geared toward Elixir, it should be possible to use it as a reference for doing something similar with plain Erlang. Executive summary: Nerves bundles together Elixir OTP apps with a minimal Linux environment (kernel, supporting libraries, and bare minimum `init`) to run those apps on the beefier "embedded" platforms (namely: Raspberry Pi, Beaglebone Black, Mindstorms, a generic emulated ARM VM, and regular x86). In your case, you'd probably just need to create a Docker image with the same supporting stuff as what Nerves bundles (minus the kernel, and possibly minus the `init` stuff) and you'd have yourself a more-or-less minimal BEAM environment (with Elixir likely thrown in, but that should also be possible to trim out if you don't want it; the important thing is whether or not BEAM runs). Behind the scenes, Nerves actually uses [Buildroot](https://buildroot.org/) to do most of the heavy lifting on the Linux side. Buildroot - like Nerves - is designed specifically for embedded Linux systems, but [it's possible to use it to build a Docker image](https://blog.docker.com/2013/06/create-light-weight-docker-containers-buildroot/).
These are all interesting articles, thanks for the info!
Heard rumors of marriage of [rtems](https://www.rtems.org/) and erlang. Might be worth investigating.
A typical erlang release is several megabytes, so the overhead of Alpine linux is quite small. To get an elixir app running, I needed bash, openssl and ncurses-libs packages installed [example](https://github.com/everydayhero/scout/blob/master/docker/Dockerfile#L33-L48)
It took me a while to figure out what this is, but this is very interesting. Thank you!
Page not found.
This reads like an auto-generated spam email...
lazy
4 little paragraphs and a sentence. This is some premium lazy-ass blogging.
This should be removed.
My buddy told me it was awesome and I would never doubt his word.
It was part of our Parallel and Distributed programming class (other part was Java) and we had an awesome erlang teacher (the one and only Joe Armstrong). Also Erlang seemed like such a great solution for many problems.
Holy shit I envy you, he's the ultimate guru for not only erlang but for FP overall.
My thesis project is still on hackage: it's called \[λPage\]\([http://hackage.haskell.org/package/hpage](http://hackage.haskell.org/package/hpage)\) and it involved a GUI… yes, in Haskell! I know. It also involved \*a lot\* of Property Based Testing. Way too much of it.
And also for starting lectures ranting about javascript and its.... well let's say inadequacies.
Why did you decide to post the same question about different languages to a bunch of different subReddits?
Well someone asked me this question today (why did you learn X), and I thought it was an interesting question - so I wanted to hear from other people who use some of my favorite programming languages :-)
Concurrency is easy
Not just erlangers. 
I learned it because my company uses it. I am still in the learning phase but I like the language so far. The barrier to entry is a tall order, but I work with really nice people so that helps a lot. Interestingly after working in erlang, my function composition in other languages came more naturally and everything just sort of clicked, I think exposure to the erlang way of doing things really made me a better developer in general. 
I came from a Python background so I really really really wanted to write concurrent/parallel programs easily. 
Hello Joe
I wish my professor was Joe Armstrong who starts lectures ranting about javascript
Because I was literally tired of being woken up at 3AM by the pager, and started looking for a platform known for fault tolerance. Despite my initial distaste for the syntax (which I think is fine now, after working with it for a while), I find the whole ecosystem to be an excellent way to get enough sleep :)
I for one am interested in what the little girl has to say.
Because I like \(and use\) those languages? \(Sorry, not sure I understand your question\).
It was aimed at the person who replied to you for asking such a benign question :)
Ah sorry - and thank you :-)
I've been hearing great things about Erlang from my coworkers for the last 5 years or so.
"The standard" chuckle!
oh ranting is easy. 50% of js dev do it too. 
Who doesn't;? except Torvalds.
i see no claims about a meltdown on their [status page](https://status.klarna.com/) why do you believe there was a meltdown?
A couple points. I think firstly fault tolerance is not the same as fault proof. Certainly if the whole datacenter was down for some reason, having a supervisor restart Erlang processes is not going to help. Another reason might be that I've heard that they are moving more and more away from Erlang and more towards Java (this information is a couple years old so take it with that in mind).
##r/programming --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
I meant fault tolerance, which is also the philosophy behind error ”handling” in Erlang as a whole (let it crash). But with that philosophy, certainly you would have a good strategy for recovery and rollbacks in case things go south... 4-5 days is just an insane amount of time for an incident like this.
Given that we don't know what happened we can't really blame this on Erlang or anything. Long downtimes are not uncommon, swish for companies was, last time I checked, still down and had been down for months by that time.
Well, I guess everything is relative ;)
The meltdown had nothing to do with Erlang or error in any code. The downtime was due to a necessary maintenance. I cannot comment on what the maintenance was for but it was all intentional, altough it had a really bad timing and could definitely have been prevented if the maintenance occured earlier. There was however an internet outage on top of that, which only further drove to higher volumes of calls/chats/website login requests and so on due to customer service agents not being able to answer inbound communications. Measurements to prevent this from happening again will definitely be taken. Source: I work at Klarna
Thank you for your answer, sounds like you had a sweaty few days... At least I’m glad to hear that is wasn’t related to Erlang.
I played around with it maybe five years ago or so. It wasn't very polished yet and kinda buggy, but it got me interested in Erlang and Elixir.
The ease of use of [Phoenix](http://phoenixframework.org/), the Elixir web framework, is much better than anything else. I would prefer to make a Phoenix app and call Erlang from it than use any of the Erlang web frameworks. It's very easy to integrate. Generate a Phoenix app and put your Erlang code in the "src" directory. Then call your Erlang code from Elixir.
Interesting! please name any sdn based systems powered by Erlang?
There are some goodies and takeaways from this project -- django templating in Erlang for one. Using raw calls to cowboy, with DTL will get you pretty far... CB is certainly going to cost you some time getting used to it and fending off bugs and areas not yet implemented. It's a shame Evan never went the distance with it and it never got to 1.0. Or, try Phoenix! N.B. Not sure if boss_db will work with any new version of OTP. Boss was using parametrized modules back in the day... those may be unsupported now.
I used it some years ago and found it much more digestible as similar frameworks in other languages. What turned me off in the long run is that you could not simply add a CB dep to your existing project and start it up. Or at least it was not as easy as I would have liked.
When planning 3.0.0 release of MongooseIM we’ve listened closely to the community and our customers’ demands. The result: inbox - an experimental feature highly requested by everyone using XMPP to build an app (thank you Forward for sponsoring it). Another game changer is the XML parser sure to boost your app beyond any speed limits.
LMGTFY.
It's not a question you dolt.
Sorry, I only saw the question for some reason, not the image. Thought you were trolling.
I like to give some context to why this could be important. The Empire State Building was finished (from tearing down the old bildings to moving in) in 11 months. Roughly 3400 people joined in this effort. This is a great engineering feat which has never been rivaled in our field of computer science. The issue that comes with scaling things is an old one (Galileo said, "Thus a small dog could probably carry on his back two or three dogs of his own size; but I believe that a horse could not carry even one of his own size."). Trees grow only a few hundred meters high, not kilometers because they'd break under their own weight because of the "weak" structural integrity. Our current standard of filesystems does not scale. I am running into more and more name\-clashing issues lately and it is evident that you cannot scale things up to let's say 3 million functions for a project, developed by thousands of engineers. Thoughts?
&gt; Our current standards of filesystems do not scale. they scale just fine
Allow me to rephrase "standards of filesystems" to "standards of naming."
yeah, they still scale just fine erlang has an explicit system to handle name clashes, naming systems are easy, et cetera
I strongly disagree. You only have to get two modules of the same name and you're in trouble! Joe's thoughts were quite on point.
&gt;-import("http://a.b.c/modname", [foo/2]). Regardless of what anyone does with naming conventions.. please no. Erlang has so far avoided this horrible Javascript approach of just pointing yourself at someone elses website for code.. I really want it to stay that way.
&gt; You only have to get two modules of the same name not only is this easily handled, but in almost 20 years of using erlang this has yet to be a problem for me a single time if you're going to deep think about the language, maybe ask people what their pain points are first for example, distribution is still a mess, and we still can't make standalone binaries
You never encountered two open source packages which shared same module names? Think another 50 years ahead and how one would deal with trillions of modules, developed by different people, at a different point in time.. Your latter point seems valid
&gt; You never encountered two open source packages which shared same module names? In erlang? No. And again, it wouldn't matter if I did, ***because the language has tools for this***. &gt; Think another 50 years ahead Oh, cut it out. The language is already 33 years old and you can't give a single, solitary example of this.
It should not be the http protocol, I agree with that.
What tools do you mean? I do not know of any. It might be that there is a solution out there and that I am looking for it was the reason for why this whole thread started, no?!
I went over your post again and you are right. Fear is now hiding even in my foresight.. It really is everywhere.. Nonetheless, I appreciate you taking the time out to reply here to a random teenager on the internet who has no business in meddling with the establishments. You have more experience in Erlang than me in life, know that my humility has suffered a terrible blow by my applying of Erlang in a PHP team, making me a king in the land of the blind, and that this repulsiveness (which I suspect this has inspired in you), is absolutely unwanted on my part. Know also, that if I do not see a tool which could help me work with two "world.erl" modules in one project, my humbleness will be dealt another blow and it may never recover. 
erlang has pretty good support for calling a function on another node, no? What's the problem they're trying to solve?
I think it boils down to helping large teams work well across time (reducing granularity of contributions by dissolving modules into functions, storing these in a database with a ton of metadata about each one, a unique content hash as key, visible information on patches showing decision trails on changes, and no need to "install" packages on machines but allowing importing via url). &gt;The basic idea is &gt; &gt;\- do away with modules &gt; &gt;\- all functions have unique distinct names &gt; &gt;\- all functions have (lots of) meta data &gt; &gt;\- all functions go into a global (searchable) Key\-value database &gt; &gt;\- we need letrec &gt; &gt;\- contribution to open source can be as simple as &gt; &gt;contributing a single function &gt; &gt;\- there are no "open source projects" \- only "the open source &gt; &gt;Key\-Value database of all functions" &gt; &gt;\- Content is peer reviewed [http://erlang.org/pipermail/erlang\-questions/2011\-May/058768.html](http://erlang.org/pipermail/erlang-questions/2011-May/058768.html)
um ... okay
did you expect a response after that other melodrama?
I didn't expect one, but for another reason
In hindsight I wish that I had written something more thoughtful. My lack of social skills clearly show and I've still got a lot to learn. I'm sorry.
it wasn't lack of social skills you intentionally got extremely sarcastic, because someone responded to your question with experience, politely, and you didn't like learning that you weren't agreed with
Will I get free passes to Berghain?
You will indeed - all the free passes you want!
Data storage on the blockchain is not feasible, unless you’re storing very little information. The guys working on IPFS and similar have explained this multiple times. You need central storage otherwise the costs explode. This company looks like another scam/people who don’t know what they’re doing. Best wishes.
Interesting! I am curious to know what you think about Filecoin then? As they rasied a hell of a lot of money and seem to really have something interesting set out?
Yeah, a lot of people have raised a lot of money and made big promises. Honest companies build products, scam companies make a nice website, pretend to work on the”project” for a certain time and then quit with the ICO money. Filecoin is another thing that cannot work.
Kuberneedy
Filecoin uses IPFS for the actual files and I believe so does STORJ. The blockchain is an extension/addition on top.
Hmm, I am going to bring this up the client I am working with and see what they say actually...you got me thinking!
Yeah I guess, but sometimes (and as I presume with Filecoin) the money is so large, it's kind of difficult for it to be a scam. Although I am aware they don't have a fully functioning product just yet lol. My client in Berlin have done it the other way around...built out a product which the founders have worked on themselves for the past 10months and then raised some okay funding for R&amp;D and engineering. I am no expert anyway - but I know that us here at Blockchain Works are really cautious about who we work with. Feel free to sign up and check the full JD and company details anyway and do a bit more deep diving yourself :)
&gt; the money is so large, it's kind of difficult for it to be a scam. Just looking at the amount money raised by many really obvious scams that part can't be right.
I'm not sure I understand. Is your client Arweave, and are you a recruiter? What part would you bring up, hoping for which kind of answer. I must admit I'm slightly confused.
Sorry yes, I thought that was obvious with the link to Functional Works above! I just meant I am curious to learn more about their platform, so was stating that I will ask them a few more questions about the points you've raised, that's all. Well I can understand the hesitation, irregardless of us here at Functional Works being pretty different to most out there! I am more than happy to jump on skype or something if there is interest and you want to run through a few things a little deeper? Feel free to ping me a direct message or something.
Sounds legit, thanks.
I love the illustrations :)
Thanks! They're from Scott Wlaschin's blog post [Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/)
It makes you to solve things in functional manner while not being Haskell. Overall, it gave me a great learning experience.
Datastorage on blockchain may not be feasible, but you could use it to store contract who has the responsibility to store you data. See sia: [https://sia.tech/](https://sia.tech/) Useful project, product works (although when I tried it \~6months ago it was minimal in terms of usefulness)
So what happens if they lose the data? They have to pay a couple of cents back?
Not actually pay back, they just won't get fully paid. Renter can't be scammed because money was put on the blockchain so it's not up to a user to decide if he will pay but rather consensus based on the performance on the host. Can't remember the details since it was a long time I researched that. Slightly irrelevant: Data is also redundantly uploaded to multiple hosts so you don't need to be afraid of somebody disappearing. Ps. Oh my cake day!
Happy cake day ))
Lists are a chain of items composed of a value and a pointer to anoter list. Yes it is implemented at the VM level. I do not see the problem with pointers to immutable data :)
I see, so it's implemented at the VM level. Then when the list changes, it becomes a new list of new/reused pointers?
It does not necessarily copy the whole list. For example if a new item.is added to the head of the list, the "new" list is just a pointer to the new item which is linked to the item that used to v be first, and the old list still just points to that ild first item. Similar when the first item (head) is popped off. There are lots of optimizations available for sharing references to data wheb data is immutable. It ia not just lista either, even trees have all sorts of fun attributes when immutable. There is an interesting and fairly large body of literatue on functional data structures which google makes easy to find :)
The list never changes. You just create new lists with its elements, use a sub-list or adding on top of the list by referencing a new list in a new variable. The lists.erl module is a collection of functions to work with erlang lists but does not contain the implementation of lists.
If you want to understand how to design data structures in a functional language then look at the books: https://mitpress.mit.edu/sites/default/files/sicp/index.html http://www.htdp.org In short, one of the ways to define linked list is through tuples: https://pastebin.com/3Ud94jnn But as already mentioned erlang list internals is written on C. 
Thank you!
Thank you!
Thank you!
https://scotthelme.co.uk/are-you-ready-for-the-symantec-distrust/ They should move to LetsEncrypt. Open source, free, easy.
I notified them of this problem 5 days ago ( https://twitter.com/minaguib/status/1009258068411076609 )
You can also get Erlang downloads from Erlang Solutions: [https://www.erlang-solutions.com/resources/download.html](https://www.erlang-solutions.com/resources/download.html)
As a Canadian, are you guys planning on recording this meet up? :) that talk sounds quite interesting!
weird
\~ Save the tuple calls! \~ With the latest release of Erlang (R21) tuple calls are opt-in. What that means is you have to use a compiler flag to make them usable. [https://www.reddit.com/r/erlang/comments/8y8ump/erlang\_tuple\_calls\_oop\_principles\_in\_a\_functional/](https://www.reddit.com/r/erlang/comments/8y8ump/erlang_tuple_calls_oop_principles_in_a_functional/)
It sounds like your client read a blog post and got excited, but erlang shouldn't actually be a requirement. If they weren't able to give you better direction on the whys and hows, thats a red flag. Are they going to pay you hourly to struggle through all this? There may be better ways to go about this like exporting batches from the mail server. 
Yup, I've thought about the red flag part but I got excited with the client as it's a new language a new challenge. Even if I don't take this job I would like to fulfill my eagerness as I develop at least something in Erlang even if that would be in my spare time. Anyway thanks for your reply, any suggestion to continue/start my learning curve? Like any posts in this subreddit or any other books? or I should be able to learn the basics from the sources which I've got? 
Well, I'm not sure how much time you have but I would recommend you to read [Erlang and OTP in Action](https://www.manning.com/books/erlang-and-otp-in-action). It is an intermediate level book. It shows how you can architect, build, release, monitor an OTP application(in the book the example is distributed cache server).
“Sophia as a smart contract language”... so they learnt nothing from ethereum, they want to replicate the solidity comedy. Good luck, take the ICO money and run ;)
Care to elaborate on Ethereum?
You don’t need to reinvent the wheel https://www.reddit.com/r/ethereum/comments/72096k/is_solidity_a_great_language_what_does_the/
aeternity is EVM/Solidity compatible!
Check out rebar3\_osv, a rebar plugin to turn an Erlang/OTP application into an OSv (Unikernel) image. See [https://github.com/OtoloNetworks/rebar3\_osv](https://github.com/OtoloNetworks/rebar3_osv)
[worker\_pool](https://hex.pm/packages/worker_pool) maintainer here, from the [x-inaka](http://github.com/inaka) community. Really happy to see your renewed interest in our library :) Just a tiny correction: `worker_pool` is not maintained by Erlang Solutions. It's actively maintained by the x-inaka community. Erlang Solutions provided some great contributions lately and we're super-thankful for those, though.
If XMPP is a requirement, you could build your entire application directly on top of ejabberd or mongooseim (a commercially supported fork of ejabberd focused in part on extensibility). Or you could use one of the xmpp clients and talk to an xmpp installation: https://hex.pm/packages?_utf8=✓&amp;search=xmpp&amp;sort=recent_downloads Or if xmpp is not a requirement and you just want a chat stream and wsbsockets are ok for you then you coupd build a Phoenix Framework app and use its Phoenix Presence features to relay updates via a chat channel to all connected users. It is quite scalable and if xmpp is not a requirement coupd be easiest for you and your users.
What's wrong with mnesia? Simple curiosity.
Nothing at all. In fact, it remains a possibility, I just don't know the specifics of how I would integrate this with other existing data storage. JSON of CouchDB seemed more conservative in that regard, although I would prefer to look at more Erlang code.
XMPP is not a requirement. This is just a kind of proof of concept-type of side project thing on which I'm brainstorming. I just read about ejabberd as good for chat backends. Although XMPP might be the wrong choice, if I end up needing message receipts (https://xmpp.org/extensions/xep-0184.html), which would be excellent for this. What I need to figure out first, I guess, is what kind of clients it will have. I need mobile devices to be able to use an application with a specific type of graphical UI, so I am unsure if this would be best achieved via browser. So I've tried weighing out something like NativeScript versus a native Android app. I need these applications to really just update certain data forms to a server within certain intervals, where, if an interval is missed, alarm signals are sent across all devices accessing the server. Anyway, thanks for the help. Lots of unknowns here for now.
Translating a record to json is super easy. 
Think it's better to stick with Mnesia? I'm open to various suggestions, just planning this. I have the UI planned out in sort of OOP terms, in which it will likely have to be implemented for mobile as either Java, JavaScript, or Kotlin or something. Otherwise I don't have many strict requirements. This is just a sort of personal project for now, etc. Server-side I am looking at Erlang, or Go or something that would be nice for handling concurrency. And partly I probably just think Erlang is interesting.
I feel like there should be a way to get the byte_size of an IO list without first turning it into a binary, but I have no idea how. This is a question that has been on my mind, but I noticed it in your code (in condor_packet:encode/2) and I couldn't give a better way of doing it.
Oh Ok, I didn't even consider that aspect of it. Doesn't gen_tcp take in IO Lists?
Returning iolist in send would be nice, even if initially it does flatten it to binary. Just for convince. Also it would be nice to also support line based protocols, like SMTP, irc, http, prometheus metrics, logs streaming, where new lines (with cr or without) are used to delimete packets, and to strip these whitaspace at the end before calling handle_packet. On the API side, ip address opt should allow listening on multiple ipv4/IPv6 addresses, and by default listen on ["::0"]. Also beyond init, I think first packet should be treated specially, or even before first packet, i.e. so behaviour can log connection attempt/establishment itself, increment external metrics, perform reverse DNS lookup, or do simple initial ACL check.
What is the size of the data? 
Not sure, but the individual entries wouldn't be large. It would just have multiple devices updating it 24/7. It would be handling health information, so security and reliability is a big concern.
Thanks for sharing your ideas. I will consider them for the next version of Condor.
How does this compare with [Ranch](https://github.com/ninenines/ranch)?
Hello Robert!
Hello Joe! 
For a moment I thought he had died! 
Hey, Findlaech, just a quick heads-up: **prefered** is actually spelled **preferred**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
Ok what is aeternity? I clicked three links and read the article and still have zero clue how erlang is related to blockchain.
Check out the Nerves Project.
Wireless sensor network
Thanks for the info.
[https://github.com/sinasamavati/condor/commit/b6a7afef18752a841e252fb0ac99cfebd94be60d](https://github.com/sinasamavati/condor/commit/b6a7afef18752a841e252fb0ac99cfebd94be60d) send\_and\_stop is added. Packet len is now limited to two bytes.
I too steered away from gen_event and went with gen_server for most activities one might use for event processing. I think gen_event was intended for incredibly lightweight usage. 
I'm afraid I must disappoint you there, still alive and kicking. And programming blockchains.
Simple, the aeternity system is implemented in erlang.
Props to you for taking your time to make this, but this is an awful shitpost so I unfortunately have to downvote it
Downvoting things is the cancer thats killing the world so I have to upvote it and would otherwise leave it be if it wasn’t my thing. 🤷‍♂️
What is a shitpost exactly?
1. I do not like PBKDF2 and I will always use `bcrypt` unless forced otherwise (NIST compliance). Maybe in near future Argon2 will jump from second to first choice. For now I still trust bcrypt more. 2. AES-CTR? Why no AEAD mode? In general why AES, which is known as a hard in implementation without CPU support. Instead I would suggest you to use ChaCha20-Poly1305 (not block, but AES-CTR is more stream than the block cipher). Nice idea, but for me there are some questionable choices about algorithm choices. 
no wonder people moved onto Elixir... no replies in a whole day, no libraries to speak of
Because inside a string, a backslash escapes the following character, and thus `\(` turns into `(` - but you actually need the backslash in the string for the regex to work! So you need to escape the backslash itself, by typing a double backslash: 3&gt; {match, Strings} = re:run("()", "(\\(\\))", [global, {capture, first, list}]). {match,[["()"]]} This gets clearer if you try printing each character in the string on its own line: 4&gt; lists:foreach(fun(C) -&gt; io:format("'~s'~n", [[C]]) end, "(\(\))"). '(' '(' ')' ')' ok 5&gt; lists:foreach(fun(C) -&gt; io:format("'~s'~n", [[C]]) end, "(\\(\\))"). '(' '\' '(' '\' ')' ')' ok 
So the issue is that I am not writing a regex per se. I am writing a string which will be parsed into a regex. That means I need to first follow the string rules for escaping and then follow the regex rules. Is that correct?
yep :)
Is a single process going to be running forever? What happens when that contract fails? What you're leaning towards here is in-memory replication which guarantees that a single process failing will never lose data that isn't available to another process, but... that's a really hard guarantee to accomplish. Remember: Erlang processes should crash early and crash often. Supervisors and similar recovery mechanisms will allow the process to restart and continue function, but where did the data go? Nowhere, unless someone persisted it.
Ohh, you got me wrong. I was talking about the immutable data structures which erlang uses likes singly linked list, tuples. The are also called [persisted data structures!](https://en.wikipedia.org/wiki/Persistent_data_structure). They have nothing to do with persisting it on db.
Ah, my misunderstanding. Persis*tent* as opposed to persis*ted*. Immutable data structures have a couple of advantages. First, in the case of tuples, it means *contents are identity*. A tuple with different contents isn't the same tuple. That's generally what tuples *mean*. Also, because tuples are immutable, their size is known at construction time (and often inferrable at compile time) which makes allocation fast and cheap. More generally, immutability simplifies the requirements for understanding the program. Inputs result in outputs, but the inputs don't actually change.
Even in a single-threaded application, there are benefits to immutability. While immutability increases your overall memory footprint and object allocation, *it simplifies reasoning about mutations*. Even though processes have their own memory space, mutations are happening asynchronously in response to messages. Depending on the sequence of messages, mutations could happen in different ways. Having immutable datastructures make it easier to reason about how the data changes. It also makes it easier for the Beam VM to understand how to allocate memory, because it knows at runtime (at the latest) exactly how much memory to allocate, and doesn't need to worry about fragmenting a structure across memory.
Mutations happen in an orderly fashion, certainly, but the actual *order* of mutations is unknown to the individual process at development time. If my process responds one way to message X, and a different way to message Y, receiving a series of messages XXY versus XYX may have different results on the internal state of my process.
I don't think this has much to do with immutable data structures. Final results will be same, if you guarantee changes in orderly fashion. 
Order absolutely matters. As a simple illustration- `5 * 3 + 1` is wildly different from `5 * 1 + 3`. While immutable data structures don't mean your processes aren't stateful, what it does mean is that each received message has a very clear, side-effect-free impact on the process's state. Again, it's not so much about the *behavior* as it is about *how you can think about the behavior*. Immutable data structures offer advantages for reasoning about the behavior of an application.
I am not saying order doesn't matter. What I meant was mutable data structures can handle the same if there was no concurrent access. 
Could you point to information where it says that message passing copies whole list when sending a message? I tried to find it and I couldn’t find any. 
It can, but it still introduces hard to reason behaviours, like with immutable data types you can always be sure that: foo(X); X = X. For any `X`. With mutability you cannot make such assumptions. For me it is big thing to be able to reason about my data in sane way. 
Ya I posted on stackoverflow, and got the same answer.
https://stackoverflow.com/questions/3406425/does-erlang-always-copy-messages-between-processes-on-the-same-node
THX
There could be value with immutable data structures for compilation optimizations. Obviously there are plenty of compilers for different languages that do so on top of mutability, so this argument may be going nowhere.
Is this an advert for a conference talk? I couldn’t find any relevant technical detail and the title seems very clickbaity in retrospect.
Yes, your are right, no technical inside :'(
Awesome! Congratulations on launching! You've accomplished more than most. The link "explore API documentation" on the front page gives me a 404.
Hi, Thank you for your kind words. Strange that I missed to check that link. It has been fixed now :-)
Where’s the code? 
What was it?
An erlang operating system (massively fault tolerant), microkernel + multikernel. I've watched the keynote from last year. [https://www.youtube.com/watch?v=8OyRFbf6MDk](https://www.youtube.com/watch?v=8OyRFbf6MDk)
Sounds cool thanks!
Based on what I found on GitHub ([https://github.com/samcamwilliams/hydros-site](https://github.com/samcamwilliams/hydros-site)), leading to [https://github.com/samcamwilliams](https://github.com/samcamwilliams) I'm guessing [https://www.arweave.org](https://www.arweave.org) is what happened
Yeah I've found the same also, but seems like a dead end :/
Yeah I mean I think he lost interest and moved on to focus on arweave 
Wrong place dude!
I get a not found error, got a mirror?
All these videos are very informative. Thank you for making them
Thank you for watching them, please subscribe and I would be very thankful if you could tweet or share them on facebook
Will that meeting be lived on another platform ? I just want to watch, thanks
Yep Erlang has List and Binary to store strings, we called them bitstring and string. So in Erlang, we have to manipulate these type of string in 2 different ways, right?
Thanks :)
Strings are my one of my only complaints with Erlang 
Thank you so much !
r/lostredditors
Not 100% sure, but I think [cowlib](https://hex.pm/packages/cowlib) might be what you're looking for.
Cowboy is good. Probably now only reliable choice.
To be fair, parsing HTTP messages is easy in Erlang. Alternatively, just copy the patterns from cowboy. 
Can't really beat cowboy for REST handlers: [https://ninenines.eu/docs/en/cowboy/2.6/guide/rest\_flowcharts/](https://ninenines.eu/docs/en/cowboy/2.6/guide/rest_flowcharts/) &amp;#x200B; Best designed flow I've ever seen in any library.
other people already mentioned Cowboy [https://ninenines.eu/docs/](https://ninenines.eu/docs/) so I will recommend [https://github.com/elli-lib/elli](https://github.com/elli-lib/elli)
Is that a competitive salary in Europe? Seems super low.
Is this a learning project or are you making a product? The answer with vary depending on what you're trying to achieve :)
It is a learning project, to understand distributed systems, and I think such a simple project would help understanding it :)
**Gnutella** Gnutella (possibly by analogy with the GNU Project) is a large peer-to-peer network. It was the first decentralized peer-to-peer network of its kind, leading to other, later networks adopting the model. It celebrated a decade of existence on March 14, 2010, and has a user base in the millions for peer-to-peer file sharing. In June 2005, Gnutella's population was 1.81 million computers increasing to over three million nodes by January 2006. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/erlang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
There's such thing as a Registry where you can register PIDs. There's also an ETS table that can be used to store global state.
Ah yes. ETS looks like exactly what I would need. Thanks I'll read more into that
I like inets httpd server because it is built in, so less dependencies for my clients to care about. And once proper options are passed performance is as good as other Erlamg servers (i.e. `{nodelay, true}`), despite http parsing done in Erlang, and not using C parser built-in into gen_tcp. Afaik it doesn't support sendfile as other Erlang Servers, so sending static big files will be less efficient in httpd. Some json library is useful to have too. For client I can't really recommend inets httpc too much. One of the reasons being not handling redirects transparently (but you could write some wrapper to do that) and no very efficient and easy handling of cookies. Again it isn't a big issue in majority of cases. You can build good clients with it. I made oath2 client for Google Cloud with it without that much issues. Otherwise ibrowse is nice library. It is also useful when you need socks5 support, i.e. using strange proxies or Tor. Inets client and server doesn't support pipelining or http/2 or spdy or quic or websockets. But really unless you know you really needed it, there is no need to care about iy. I think if you do not have experience with inets, start with inets anyway, to know what is standard in Erlang. It gets a lot of undeserved hate. Where in fact both client and server have good code, otp principles, code upgrades, logging, custom modules, authentication, support for Apache style per directory configs, etc. etc. And all behaviours are pluggable and can be removed for higher performance. 
Erlang as a language has no notion of strings. There are many io libraries that will happily receive list or binary or iolist (recursively nested lists of lists and binaries, implicitly concatenated, for easy building of strings and fast output / prepend / append).
There are two methods in Erlang. Spawning a process that will be managing table of connections. It can be registered locally or globally (in a cluster) with well known name (atom), and all users can use this atom to find it. Or spawn it once and pass it's Pid (or list of Pids in replicated scenarios) around to all processes that need it. Second is using ETS table which is per node. You can store Pids or connections there by key, do iterations, etc.
Well, I'm all for the more erlangish way. The data would be small, storing a few values next to the PID that may be used to uniquely identity the websocket, even with maybe several thousand connections I wouldn't imagine this going past 100Mb, and there'll be relatively little state updates, since these are long running socket connections where lots of data can go back and forth over them. So perhaps it's not the perfect solution. As far as I can tell, registering a process is effectively allowing it to be looked up via an atom. But if I have a user ID, eg 12345, how can I use that to a) register the process, so that b) I can lookup that process again when I receive some data for 12345? &amp;#x200B;
This looks interesting, is the name of the process group my user\_id? I don't understand the docs here (haha shows my level). It specifies the data type as \`name() = any()\`? Does that mean the name can be anything, like a tuple or a record? I saw \[this\]([https://pdincau.wordpress.com/2012/01/12/a-survival-guide-on-pg2-erlang-module/](https://pdincau.wordpress.com/2012/01/12/a-survival-guide-on-pg2-erlang-module/)) blog which seems to use atoms to create the groups. If that's the case I can't quite see how it can be used to access a connection process by user ID, what am I missing? Thanks, much appreciated. &amp;#x200B;
That sounds like a reasonable approach, I guess then my question is how does this top level process manage the connections? Wrapping my not-so-pure javascript brain into it, I'm envisioning some list variable which is accessible to all the functions in the process, but I feel like I'm way off the mark there for Erlang.
Yes, the `any()` type means any term. This is a good reference for typespecs: http://erlang.org/doc/reference_manual/typespec.html So it can be an atom, it could be a map ... in this case, you don't want to use atoms, though, as you would end up creating a new atom for every group (e.g. user_id) and they are limited (by default, to a little over a million). A bitstring is safer and should be sufficient. The way Phoenix does this is it lets you name your process groups ("channels", as they call them) with strings, so you might make "userid:&lt;id&gt;" channels and then you can easily send data to those sockets (processes registered with that channel). If a socket handler process registers (or, "subscribes") to another channel it also gets messages sent to that channel .. so you could have an "all" broadcast lobby-style group, or group chats with names that multiple handlers register as being part of ("subscribes") and thereby can get messages sent to them from there.. For a bit more abstraction, you could also look at the (syn)[https://hex.pm/packages/syn] library which makes it a bit more straight-forward to send messages around, but otherwise is very similar. It is very nice to use, though it means another dependency for your app (usually not a big deal). At work we use syn a fair amount, but also Phoenix's PubSub in our Elixir code... both work like champs .. Have fun exploring Erlang! :)
&gt; 50-100ms I got 13µs round-trip latencies with OCaml on one machine and 114µs door-to-door latencies with a distributed fault tolerant system in F# on .NET. So, for any decent language, I don't think the runtime is the bottleneck but, rather, the network layer. Latencies on contended ethernet are orders of magnitude longer than that. 
very nice. This is based on the https://aws.amazon.com/blogs/compute/introducing-the-c-lambda-runtime/ I think
Close, but not quite. AWS added support for arbitrary runtimes, so this isn't tied directly to the C++ runtime. Alert Logic put together a runtime and all the tooling for it.
This is super cool, but I wonder: does anything stay running or are you paying a penalty for VM startup on each run?
Runtime starts in a container, which is recycled if it's not used for some undocumented period of time (I've seen containers recycled after 10 mins of inactivity). VM is started only once when container is provisioned (cold start). Start time depends on a mode in which erlang is started (embedded or interactive mode) and resources available to the container. Here are numbers for [erllambda sam example](https://github.com/alertlogic/erllambda_sam_example): &amp;#x200B; Cold start + execution time: Init Duration: **849.31** ms Duration: **52.19** ms Billed Duration: 1000 ms Memory Size: 512 MB Max Memory Used: 83 MB &amp;#x200B; Execution time on already started container: Duration: **66.99** ms Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 83 MB
Thanks for measuring the numbers. I've heard that (just anecdotally) that the cold startup was in the range 100-300ms but never measured it myself. I'm curious if the numbers I heard were wrong or it's due to the size of the package. I ran the hello world example provided by Alert Logic and I got: Cold: Init Duration: **834.09 ms** Duration: **3.35 ms** Billed Duration: 900 ms Memory Size: 512 MB Max Memory Used: 89 MB Warm: 1. Duration: **30.30 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 M 2. Duration: **2.87 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 3. Duration: **2.67 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 4. Duration: **28.81 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB 5. Duration: **14.97 ms** Billed Duration: 100 ms Memory Size: 512 MB Max Memory Used: 89 MB So it looks like the startup penalty is the roughly the same. There's quite a bit of variation in the warm runtimes though.
I'm in SF. Seems absurdly low but maybe that's just spanish wages. You won't get an elixir Dev in sf for under 120k. 
What's your project structure like? I suspect it would be less work to move to rebar3 than to add dependency support to your makefile
Hey thanks for your help! It looks like this: config/config.json //some config for our run.sh ebin/*.beam src/*.erl Makefile run.sh web/ .. all the html, css, js [github](https://github.com/Skatinger/CDCProject) I made it public in case you want to look at it on github. And I'm well aware it's pure spaghetti. More of a trial and error approach than actual development process. Refactoring comes last.
There's not much there, I would have a go using rebar3 for at least the compilation :)
This is the article which made me try to embed it directly: [codeproject.com/websockets](https://www.codeproject.com/Articles/1131438/Handling-Websocket-Connections-in-Erlang-Applicati). Maybe you see a way I could apply this. I wouldn't mind using rebar, but it would be nice to not need to restructure everything.
Alright then, I'll give it a shot. Thank you very much! Now go get some eye-bleach :'D
You can continue to load the beam files and run a function manually if you want :)
Please check that the syntax is correct. It looks like the 'case' is missing. Also, use "ok/error" tuples instead of exceptions.
what do you mean with case? and is this the right approach?
rebar is working nicely, I can compile everything with it and my run.sh works as well. Actually, it's even cleaner than before. Sadly however, cowboy is not as easy to use as I thought. If I include the cowboy application in my myapplication.app.src the application does execute without error, but I don't receive any output, and it halts too quicky. I assume it fails but doesn't print any error as any print statement in the start-method won't be printed to console either. When I don't include cowboy in the app.src file, the crash dump states bad_return for cowboy, start_clear. So cowboy is missing. I am really stuck on how I could make this work. Steps I took so far: *add rebar, edit rebar.config to include cowboy as a dependency: {deps, [ { cowboy, ".*", {git, "https://github.com/extend/cowboy.git", {tag, "1.0.3"}} } ]}. *adapt my project starting structure by adding the application files: cdcproject.app.src {application, cdcproject, [ {description, ""}, {vsn, "1"}, {modules, ['cdcproject_app', 'cdcprojet_sup', 'ws_h']}, {registered, []}, {applications, [ kernel, stdlib, cowboy ]}, {mod, { cdcproject_app, []}}, {env, []} ]}. startmethod: % start cowboy server Dispatch = cowboy_router:compile([ {'_', [ % index, websocket and sources (js), emtpy atm {"/", cowboy_static, {priv_file, websocket, "index.html"}}, {"/websocket", ws_h, []}, {"/static/[...]", cowboy_static, {priv_dir, websocket, "static"}} ]} ]), {ok, _} = cowboy:start_clear(http, [{port, 8080}], #{ env =&gt; #{dispatch =&gt; Dispatch} }), % start websocket supervisor websocket_sup:start_link(), % start my part of the app cdcproject_sup:start_link(). For my start-script I use the line: erl -pa ebin ../deps/*/ebin -eval "application:start(cdcproject)" -eval "init:stop()" inside my ebin folder. As required by rebar cowboy is in myproject/deps/*/ebin and compiled as well. If I got this right erlang will load missing code modules upon call looking in the paths given by -pa. I cannot see why this would not work. Am I forced to do a release for this to work? I got the impression that this goes a bit deeper into large application standards than necessary for a small project with a websocket. I really don't expect to work out the issue, but if you can quickly spot something that might be wrong or know about some common mistakes I'd be very happy. I've come too far to give up now :) 
If you just want to boot all the applications you can just run `rebar3 shell`, it will handle loading the beam files and starting the deps listed in your `app.src` file. You're supposed to use a release but for a toy project it's perhaps not needed.
Sadly I tried this already. When I include the cowlib in the app.src deps it doesn't generate any output. I'll have a go at creating a release. Thank you anyway :)
What do you mean by it doesn't generate any output?
No output meaning that my run.sh or any other way starting the application just opens the erlang shell, and after a few seconds closes again. It does not even print the io:format that I placed right at the beginning of the start method. Ours of trying confused my language. I include cowboy and use cowboy. Cowlib itself is used by cowboy if I got that right. Also ranch is used, but this is already a dependency of cowboy itself, so I should not have to include it myself.
Assuming that the first code snippet starts successfully, you should try creating 
&gt; The problems all occurred, simultaneously we believe, on Thursday December 6. An issue with certain nodes in core network equipment resulted in network disturbances for “a limited number of customers in multiple countries” using two specific software versions of the SGSN–MME (Serving GPRS Support Node – Mobility Management Entity). An initial root cause analysis indicates that the main issue was an expired certificate in the software versions installed with these customers. A complete and comprehensive root cause analysis is still in progress. &gt; &gt; ... &gt; &gt; More detail on the situation as provided by Softbank. It announced that its LTE services of “SoftBank,” “Y!mobile,” Fixed Line Services called “Ouchi-no-Denwa” and a part of “SoftBank Air” services were not available for its use for over four hours on Thursday, “due to our network outage caused by Ericsson-made software errors related to its packet switches” covering its customers nationwide. A good reminder that no matter how well a language handles errors and how carefully you plan for failure, it's still possible to be felled by something as simple as an expired certificate. For an overview of Erlang's use on the SGSN-MME, check out [this presentation](https://www.youtube.com/watch?v=HyiSYHfESX4) at Erlang User Conference 2012. Slides from the presentation can be found [here](http://www.erlang-factory.com/upload/presentations/597/sgsn.pdf).
Thanks for coming back at me! The first snippet does execute successfully. I can also just start my small simulation with master:start() inside the app.erl snippet when I remove cowboy. Could I just spawn s new process starting in my master? I am unsure what you are trying ro say with creating. Creating what exactly?
I am so sorry, I was typing it on my mobile and seems like I accidentally posted only a portion of the reply. What I meant to say was that use the start/0 function in master.erl to start the desired applications.. for e.g.: ```erlang start() -&gt; DataDir = dms_utils:priv_path(dms, "mnesia"), application:load(mnesia), application:set_env(mnesia, dir, DataDir), mnesia:create_schema([node()]), application:start(mnesia), {ok, _} = application:ensure_all_started(cowboy), ok = application:start(?MODULE). ``` In your case, you will start the main application, and then the simulation. Simulation need not be a part of the main application supervision tree.
I don't use amnesia if I got it right I don't have to (got no DB or anything like that). I read that it's possible to write several smaller applications and then start them side by side. In my thought process I thought I could use cowboy like I would use an import in another language. In your example this seems not to be the case. My master.erl currently looks something like this: -module(master). start(Some Args) -&gt; spawn(simulation part), spawn(simulation second part), time:sleep(some time i set for the simulation to run), AllPids ! {stop}. So my master is not actually a proper application with start/2 and stop/0 but rather just a very basic erlang file which allows me to start several processes handling the simulation at once (I think such a clutter of modules is just called a library?). Now to use application:start(master) I would have to make it a separate application right? (containing a master.app.src and a master_app.erl). Then I would create a application which has cowboy and my own simulation as dependencies? My current folder structure is like this: myProject/ /deps /cowboy /ebin /src myproject.app.src myproject_app.erl myproject_sup.erl master.erl other_simulation_modules.erl This does not allow me to use application:start(master). However, following your example it looks like you start the dependencies first, and as they are started you start ?MODULE, which in this case would be the file itself? Does this mean I can then append my master:start(args) without making it an application on itself? Also in your example I cannot see how you would set the routes for the cowboy server. Is that done within the cowboy dependency? I am really confused on how the structure is supposed to look like. If you got any resources that might explain coupling of apps in detail that would be of great help as well. Looking at your example I'm under the impression that something like this would be correct: myProject/ /deps /cowboy /ebin /apps /simulation /master.app.src /master_app.erl /other_simualation_files.er cowboy_router /cowboy.app.src /cowboy_app.erl /src myproject.app.src myproject_app.erl myproject_sup.erl Like this I could do something like this in my myproject_app.erl: start() -&gt; application:ensure_all_started(cowboy), ok = application:start(simulation). Forgive me if I don't try all ideas right away, as there is so much that can be done wrong and so little possibilities to make it work. I have already seen about 10 ways to not do it :')
Your current project structure is fine. Keep it like what it is right now. &gt; So my master is not actually a proper application with start/2 and stop/0 but rather just a very basic erlang file which allows me to start several processes handling the simulation at once That is correct. &gt; Now to use application:start(master) I would have to make it a separate application right? (containing a master.app.src and a master_app.erl). Not really. You can straight forward call the start/0 of master if you start erl this way: erl -pa /dms/deps/*/ebin /dms/ebin -s master I ship using docker so I dont have to deal with erlang releases, and can execute the above command and get a running erlang application.
I started my app with the same command as you before using cowboy. I'll try to add cowboy to master with the structure in your example to then start it with this command again. However the question remains on how I can set routes for my cowboy router. Can I do that as well inside my master? If I got it all right it will look something like this in my master.erl: start(Whatever Args) -&gt; % start cowboy part of my app Dispatch = cowboy_router:compile([ {'_', [ {"/websocket", websocket_handler, []}, {"/", cowboy_static, {priv_file, cdcproject, "index.html"}} ]} ]), {ok, _} = cowboy:start_clear(my_http_listener, [{port, 8080}], #{env =&gt; #{dispatch =&gt; Dispatch}} ), application:ensure_all_started(cowboy), % start the simulation part as before spawn(simulation part), spawn(simulation second part), time:sleep(some time i set for the simulation to run), AllPids ! {stop}. Using this structure I no longer use anything like _app.src or _app.erl to start my app but only *erl -pa /myProject/deps/*/ebin /myProject/ebin -s master*. I used to deploy with rebar but struggled to achieve my goal and then decided to change to erlang.mk because it's used in most tutorials. Thank you for your help, really appreciated. I was on the brink of giving up, especially as errors are crypting and mostly just something like "badarg" for some library function. 
I recommend that you start all cowboy dependencies in master:start/0 using: &gt; application:ensure_all_started(cowboy) You must compile cowboy routers and start cowboy in myproject_app.erl first before starting your supervisors.
Oooh I get it! Thank you! I'll try as soon as I'm home :D
I am SOO happy! It finally works! I could never have done it without your help :D Just gotta figure out on how to implement a websocket and sending messages to it :') But this is hopefully well described in several tutorials. Now for anyone reading this in the future, I have done it the following way now: I got my own file master.erl which has a method start. Now using rebar I get all dependencies and compile them with *rebar compile*. Once this is done, i can start my project with a small script which only contains the following: erl -pa ebin deps/**/ebin -eval "master:start()." To start the actual cowboy server you need your "myproject_app.erl file aso documented above to dispatch the cowboy server. One issue I encountered here is that cowboy did not start its dependencies on its own. I had to start them by myself in my master:start() like so: application:start(crypto), application:start(cowlib), application:start(ranch), application:start(cowlib), application:start(myproject), % my simulation start stuff Hope this helps someone else as well. And thanks again to /u/fileagodotcom !
Glad to know that it is working fine. Don't give up on Erlang. It is too good to let go off once you overcome the initial hiccups. 👍
Webmachine ? [https://github.com/webmachine/webmachine/wiki](https://github.com/webmachine/webmachine/wiki) Not just an HTTP Library, but not really a Web Framework either..
persistent\_term !!! No more mochiglobal.
When would this be used? How is it different from defining a module function with a fixed return value?
Updating configuration on the fly for example. &gt;Some examples are suitable uses for persistent terms are: &gt; &gt;\- Storing of configuration data that must be easily accessible by all processes. &gt; &gt;\- Storing of references for NIF resources. &gt; &gt;\- Storing of references for efficient counters. &gt; &gt;\- Storing an atom to indicate a logging level or whether debugging is turned on. &amp;#x200B;
Didn't give up and ended up with a quite nice (result)[https://imgur.com/a/es8SYwZ]!
cool! thanks!
Oh, this post is just in time :) My 2018 was start with Erlang and after this text I see Im on the right (but long shot) way with .erl 
As I mentioned in the corresponding ["Show HN" post on Hacker News](https://news.ycombinator.com/item?id=18798933), this is in a very early stage of development, but it's technically in a working state (at least in the sense that it can run OTPCL scripts; there's a lot left on my TODO list before it's ready for a 1.0.0-release primetime). Some specifically-missing things: * Docs and tests are woefully incomplete * There's no way to define functions from within an OTPCL script (no equivalent to Tcl's `proc` or Erlang's `fun` or anything of the sort) * No REPL yet (you'll have to fire up `rebar3 shell` and pass stuff into `otpcl:parse/1` by hand) * No built-in support for reading/parsing/evaluating actual files (but nothing stopping you from doing that yourself :) ) * No compiler; everything is evaluated at runtime * Standard library in general is pretty barren (but does have `set`, `if`/`unless`, `incr`/`decr`, and `print`, so at least there's *something*). Feedback is welcome. I don't have high expectations of something for which I hand-wrote the lexer, parser, and interpreter, though :)
Very cool! I'm interested to see how this progresses.
Thanks! I'm hoping that once the remaining "hard" parts are done (namely: the REPL, compiler, and a useful stdlib), all sorts of stuff will fall into place for a beta and eventual stable release.
Hi guys! In this article I introduce Elixir Streams as a powerful and elegant way to process large CSV files. I compare the greedy and the lazy approach with some memory and cpu benchmarking. As always. if you have any question or feedback, please leave a comment in the article's comments section .
Whatever you like more. In the end you can use both at the same time. 
Sounds great,but how
I do not know how to handle Elixir code in Rebar3, but Mix will automatically handle everything that matches `src/*.{erl,yrl,xrl}` and compile it with proper compiler (Erlang, Yecc, and Leex respectively), and everything that matches `lib/*.ex` will be compiled using Elixir compiler. So in fact if you use Mix then you can use both without anything extra. 
To be honest neither of both. If you knew Elixir/Erlang you wouldn't ask this question. If you have a stack you are familiar with, use that. Otherwise if you are new to start out with software development, I recommend you python. If for whichever reason you want to try functional programming, go with Elixir.
It doesn’t. It helps with Elixir web application development, but not in general Elixir app development. In web applications development it helps by providing abstract layer that simplifies building REST APIs and socket connections. You can work provide that without Phoenix though, by using Plug or even Cowboy directly. But in the end what Phoenix is is abstraction that helps with building such services. 
thanks &amp;#x200B;
Phoenix, specifically their channels (conveniences around websockets and other two-way communication protocols), and presence (knowing who else is logged in).
In this article we see how to solve an issue we faced in the previous article, scaling horizontally the Phoenix Chat app. We'll see how to integrate the PubSub Redis adapter to our chat app, and make it distributed. For any feedback or question, please post a comment here or at the bottom of the article :D
Nice write up. The problem I see here is SPF (Single point failure) on Redis.
I agree with you and this is actually the case. We could have different redis nodes, or event better we could use beam distributed messaging and PG2. The reason why I started describing Redis pubsub, is because it's easier to setup on kubernetes. My idea is to publish a second part where I'll talk about clustering the chat servers using purely elixir nodes, and make them work on kubernetes.
That's been the standard banner since forever? [Here from the official docs](http://erlang.org/doc/man/shell.html#example): strider 1&gt; erl Erlang (BEAM) emulator version 5.3 [hipe] [threads:0] Eshell V5.3 (abort with ^G) 1&gt; Str = "abcd". "abcd"
Learn you a Haskell for Great Good! Functional Programming for Scala The Joy of Clojure &amp;#x200B; Scala is the most versatile in making money, but if you just want to learn, then Haskell is the best tool to explore this sector. You will have a hard time learning if you don't use a language, you will basically be reading math papers...sorry I fell asleep thinking about that, and I'm a math major. &amp;#x200B; If you want to be a phreaking crazy man then Erlang with OTP If you want to be an amazing front end devloper? Elm Elm is probably the easiest language to learn with the best balance between being useful in industry and teaching you a lot about a purely functional language. The language is a Javascript transpiler and you will never look at web development the same again. Are you curious? Go for it bud. Do you think you can use this in industry? maybe if you ever find yourself in NASA or Jane Street. &amp;#x200B; Honorable mentions O'caml -&gt; this language's compiler was adopted by Jane Street and it is the main language they use for all of their financial business logic. It is a very "safe" language in terms of transporting and manipulating data. Elixir-&gt;easy to setup and lets you write code easier. Erlang is safe as well, given the following rule, once you write a variable say, cashIn = passedParameter; this combination or "binding" can NEVER occur again. You could assign passedParameter to another variable but cashIn's job will forever stay as a passedParameter assignment. However, Erlang is almost impossible to setup unless you are good with linux, it took me about an hour to get the repl running, then you need to point it towards an LLVM to "compile" the language. A good resource could be [codewars.com](https://codewars.com) and choosing Haskell or O'caml in a Kata. Cheers!
is there any resource for Elixir?
[The Little Schemer](https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992) is a great place to get some practice with functional programming and recursion. I actually worked through the first 5 chapters [using Erlang instead of Scheme](https://gist.github.com/jared/f87eced03f150bfb84aedca80887df67), and only had to make minor changes for the examples to work.
the pragmatic programmer has a book but then I found this: https://pragmaticstudio.com/elixir $65 and seems like a great product to approach this project. The OTP is important for communicating and Erlang used to be the only language that could use it; however, I am guessing they have opened it up to Elixir? The important thing to know is that Elixir was written in Erlang...I think. Therefore, some of the problems that you can find from Erlang forums could help with Elixir development. DO NOT go to Phoenix before you have learned Elixir. I know nothing of the language, but it is not like python where you can learn the heavy tools in Django and then stack overflow the glue logic. Phoenix framework is extremely dependent upon knowledge of Elixir. The course for $89 is basically the future of web development; however, it is almost way too early to wrap your mind around that stack...notice I said "almost". Learn these tools, but if you don't have a "normal" stack don't put too much time or thought into these projects. Managers and Senior coders won't be able to read your github, but I would definitely make the project they give in that course. Books are good, but Elixir is such a wierd language, it is popular enough to be recognized, but noone wants to use it based upon the lack of resources that come with it. If you work on these tools by 2025 you will be one rich man. Trust the stranger on the internet haha...
Hey, knickerBockerJones, just a quick heads-up: **wierd** is actually spelled **weird**. You can remember it by **e before i**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Honestly, just take the language you're best at, and rewrite something functionally (no loops, use map; no side effects; pass state in and return it) You can go for one of these books, and they'll tell you their spin on functional programming. If you get a Haskell book you'll be told everything has to be in a monad, which just about nothing has, for example. Erlang isn't actually a functional language, though, even though it does offer functional language tools; it also offers the process dictionary and mutable datastructures and sockets and all sorts of things that some FP people will think aren't pure and others won't. But you already know what map does. You already know what fold does. It's just a question of using them until they're intuitive, and a book won't give you that. Take an app and re-write it.
Is Docker an option? If so then you can treat single node Erlang applications like any other language.
We are running Erlang on Docker in Kubernetes in AWS. Just make it a docker container and you are good to go. :)
Take a look at EDeliver: https://github.com/edeliver/edeliver I don’t use it myself though. I use my company’s in-house tool, which is not open source.
Hey everyone! In this article we see how to cluster Phoenix Chat nodes, using distributed Elixir. We see how pg2 works and inspect how Phoenix efficiently broadcasts the messages in a distributed chat app.
nice thanks, I thought docker/kubernetes wasn't an option as from what I understand Erlang has OTP that manages the multiple nodes running on bare metal. I am a bit confused. So multiple Erlang processes are actually spawned into the same docker container? OTP does not manage hot code reloading? As it's happening thru docker/kubernetes
Don't let Docker distract you too much. Docker is great, and you can incorporate that into your setup, but that's a different topic, really. I highly recommend you check out [https://learnyousomeerlang.com](https://learnyousomeerlang.com). Specifically, [creating releases](https://learnyousomeerlang.com/release-is-the-word), which is just the prerequisite knowledge for the chapter on [code hot-loading](https://learnyousomeerlang.com/relups) and release updates that you're really after. It is rather involved, so depending on your Erlang background I recommend you take your time to soak up all the detail. The [whole book](https://learnyousomeerlang.com/content) is great, though. Once you get to the chapter of [distribunomicon](https://learnyousomeerlang.com/distribunomicon), for example, you could start thinking about whether or if Docker/k8s fits into your picture, but that's more about managing infrastructure.
That's a wrap on applications for our [**Code BEAM SF**](https://twitter.com/hashtag/CodeBEAMSF?src=hash) [**diversity**](https://twitter.com/hashtag/diversity?src=hash) scheme! &amp;#x200B; Next step: Code BEAM SF partners Travis Foundation and Diversity Tickets will review all applications and award places to those who would most benefit from them. The Code BEAM SF team be in touch with all applicants by 08 Feb! 📷
In this video we are going to see how to cluster Elixir and Phoenix nodes with libcluster, locally and on Kubernetes using Docker containers. 
You’ve got the what outlined, but why? I’m curious what this buys you that native Erlang clustering does not?
hi, I started with the books, they are good (at least for my way of learning). &amp;#x200B; otherwise [http://spawnedshelter.com/](http://spawnedshelter.com/) has a lot of resources.
This might be another good resource: [https://howistart.org/posts/erlang/1/index.html](https://howistart.org/posts/erlang/1/index.html)
Thanks will look into it
I mostly prefer videos/tutorial but don't mind books also. Will look into the resource. Thanks
Just unsolicited advice... IMO learning Erlang is the easy part. Groking OTP for me was the tricky part. Once you understand the primitives of the language, I would dig in to not just the how of OTP, but the why. Learn you some Erlang is good. I found the published books to be dodgy for my learning style.
Thank you so much for such a detailed help.
this video series is a nice intro: https://www.youtube.com/playlist?list=PLR812eVbehlwEArT3Bv3UfcM9wR3AEZb5
Learn you some Erlang is _fantastic_. Easily one of the best programming books I've read.
I did the prolog 99 problem list. Then I learned OTP. Then I wrote a poker server. Then I was ready.
Don't treat processes/genservers as instances.
\&gt; Does Erlang have a future with the advancements we are seeing in hardware? &amp;#x200B; Yes, the Erlang virtual machine uses all available cores and the platform is well suited to build distributed systems, see riak\_core, lasp, partisan &amp;#x200B; \&gt; Will focusing on this language allow me to transpose skills to other languages? &amp;#x200B; You already have experience with many languages with different properties, it seems you will be able to pick up other languages after erlang. Also, it's useful to learn languages from different paradigms, it helps you see the big picture and improve your skills even when using other languages. Your programming career will require you to learn and use many languages, don't worry about learning one or the other, it seems you want to learn it, so why don't you give it a try? &amp;#x200B; \&gt; Are Erlang engineers hobbyists that find themselves being offered a job using it? &amp;#x200B; There are companies using erlang, you can see them here: [https://erlang-companies.org/](https://erlang-companies.org/) those are not all, but many of them, you can get an idea of what kind of jobs you can get and maybe apply to them once you want. &amp;#x200B; &amp;#x200B;
- Does Erlang have a future with the advancements we are seeing in hardware? Yes. Specifically in the server space, where you get to handle more cores for free. On smaller and smaller mobile devices, there is potential (live code upgrades can be neat there), but more VM tweaking is needed as it is not economical energy-wise by default (busy-looping to be responsive eats CPU). There are various switches that can be used, and a standard VM with some info and libraries stripped out can fit in under 10mb of disk space. So not embedded, but can easily fit in rpi3s and other similar ARM devices. - Will focusing on this language allow me to transpose skills to other languages? Yes and no. What I learned the most in the last 10 years was not just programming language use, it's system design. The things Erlang teach you don't necessarily port over directly to other languages, but they port over to almost any other project. Principles of fault tolerance and isolation shown in Erlang are hard to even learn in other areas. Distributed systems principles are generally something the Erlang community is very comfortable with and the language makes good decisions about that from day one compared to almost any other environment out there. So while the Prolog-like syntax and lack of types means you may have a bit of a trickier time switching to Haskell or Rust since they structure programs differently than if you had picked something like OCaml, the skills related to system design you'll pick up will be absolutely worthwhile and transferable. - Are Erlang engineers hobbyists that find themselves being offered a job using it? Yes and no; it depends on where you are and what industry you work in. There is no strict "school of Erlang", but a lot of Erlang teams are spun up by regular businesses getting training from either books or a place like Erlang Solutions Ltd because they have a project to run. After a while they may stick with it and start hiring for more people. Pretty much any business out there that uses Erlang is ready to teach it to some extent. They may look for some background in functional programming skills or relevant problem domain, but generally will be ready to add more to them. The trick though is that while there are many Erlang devs, the distribution is sparse, and the same can be said of companies using it. Those that have the easier time staffing up either train locally, pay Bay Area money, or allow remote work. The latter category tends to fill up rapidly. Another avenue is to try and get Elixir jobs as well; most of the principles are similar, and although you may end up most likely working on a web app for a bit less money than you would with an infra-related Erlang job, it's a very decent entry point; what you learn in Elixir will generally carry well to Erlang (and the opposite is true -- learning both is better than learning either, and it's super easy to get the second one once you have the first)
In this article we see how some kind of HTTP requests/responses can lead to memory issues. We see then how to manage this issues using HTTPoison Async Requests to asynchronously download large files.
I don't get why you posted this here and not in /r/elixir
Great reply. I'd like to also add that there is a certain category of problems that would be unreasonable to be solved with OTP/BEAM due to the limitations of the platform. 
Hi, thanks for your comment! I posted also here since it's the same thing with Hackney {stream\_to, pid} in Erlang. I've chosen a simple download of an image because it's easy to see and describe. In general it obviously depends by the context. It works well with big CSVs (in the order of GBytes), processing them line by line. In this case there is a small problem with having a whole line in the same chunk, issue avoidable with same aggregation. Sure, when we have to process the complete payload as a whole, we can't process the stream using chunks... do you have any example in mind?
Like receiving a 300MiB JSON data dump (a real-world example, unfortunately).
Yeah, if we have 300mb JSON.. that goes anyway loaded into memory. It depends why we end with a 300mb JSON. At that point it looks more a data design issue to me. It obviously depends from the context: loading 300mb in a one off process could be ok... in other cases like having multiple parallel data importing processes... maybe not that good
Million thanks, fascinating material in your channel. Is this analogous to eval function in Python? Does it provide homoiconic /macro capabilities like lisp? It reminds me of this: [http://erlang.org/doc/man/erl\_eval.html](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=http%3A%2F%2Ferlang.org%2Fdoc%2Fman%2Ferl_eval.html&amp;event=comments) . Btw I coud not find ct\_expand in erlang libs in [erlang.org](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=http%3A%2F%2Ferlang.org%2F&amp;event=comments) , only here: [https://github.com/uwiger/parse\_trans/blob/5021be5b4dab748107be2339dee0054ad4903174/src/ct\_expand.erl ](https://www.youtube.com/redirect?redir_token=8nDrByNx2In01B59ipj4FlEsn8J8MTU1MDI3NTU1NEAxNTUwMTg5MTU0&amp;stzid=Ugx0DZ_poR1D702AADZ4AaABAg&amp;q=https%3A%2F%2Fgithub.com%2Fuwiger%2Fparse_trans%2Fblob%2F5021be5b4dab748107be2339dee0054ad4903174%2Fsrc%2Fct_expand.erl&amp;event=comments)
It's not a standard part of Erlang, just someone's add-on. It is closer to a lisp macro than an eval
Probably not the pipe, at this point. But the Elixir core team has certainly made improvements to Erlang/Beam. Many of the standard library functions had to have their argument order changed from their Erlang equivalent in order to accommodate pipe syntax. For example, many of the Erlang "map" functions take the map as the last argument, which would make piping useless, to say the least. 
Use Jose Valim's, if you really want it pipe(Init, Funs) -&gt; lists:foldl(fun(F, State) -&gt; F(State) end, Init, Funs). pipe(Init, [fun(S) -&gt; set(S, 230) end, fun(S) -&gt; update(S) end, fun(S) -&gt; output(S), S end]). &gt; For example the pipe operator in Elixir is just brilliant for organizing code. With time you realize it's a toy, and makes error handling perversely difficult.
In general, adding new features to established programming languages is more pain than gain. Take the "parameterized modules" feature which was introduced many years ago and is now being removed due to lack of use. Doing these things needs to be done carefully with a long-term plan for maintenance and development. Oracle has been doing a good job with Java, but the Erlang/OTP team does not have that kind of resources. In the long run, the cost of writing and maintaining code has very little to do with new fancy language features, and so much more do to with "how to get people to work together efficiently". In other words, there is very little economic benefit of introducing new features, simply because that is not where the high costs of software lies. This of course also means that systems which are widely used in large production and/or legacy systems will be more difficult to evolve (see Java and C++) than smaller languages which have more freedom to change. 
In that specific example error handling may be difficult, but that's hardly true of pipes in general
As you start using them in more serious applications, and stop downvoting things you disagree with, you will find that actually yes, the reason almost every language that has a pipe stops using them pretty right away is that they are quite difficult to debug in general. Especially as compared to Erlang's existing, wonderfully well developed system.
This is awesome! :D
You should cross post to /r/Golang 
This is awesome. I'm an Erlang developer, But I won't use Go with Erlang.Because Go make concurrent complex. And most time I will use Erlang's nif to solve CPU cost operation. At the same time I prefer Rust to Go.
I like it, anything that makes integration easier can only be a good thing, there's a similar library written in Python called [Pyrlang](https://github.com/Pyrlang/Pyrlang) \- these things are quite fun to use and could work quite well for domain (libraries) specific work. 
Facebook is a nasty data-stealing monster.
LOL, I too agree...
Confused ember with erlang?
and there is a active /r/emberjs/ sub!
It's a little hard to offer clarification without more information, is there a particular place that talks about pattern matching that is unclear to you?
Are you familiar with switch statements?
Everything about :( I've been struggling to grasp the basic concept of it 
Sadly not :( I'm a big novice at programming
It works like the [peg fitting toy](http://farm5.static.flickr.com/4092/5032376885_4451ca267d.jpg) where you try to fit your peg (value) *from top to bottom* into holes (patterns). When it fits, it sits and you end matching. This is important as if you define less specific pattern first then it will not try to find “better match”, it will just stop there. 
That's fine. Basically, when writing a function, you can provide many versions of a function, with some of the parameters being given specific values for each version of a function. For example, you might have: add(X, 0) -&gt; X. Then, when calling a function, erlang will try every version of the function, in order, until one matches.
The basic concept is that you're comparing a value to multiple "patterns"(like the structure of the data). You expect a value to match one of those patterns, and you want to do different things depending on which one matches. The pattern can also bind names(variables) to part of the structure of the value, when it matches, which can be called destructuring.
Simply think it as capture the value from right to left, &amp;#x200B;
This is a bit overly broad. Pipes in Elixir are actually /sometimes/ easier to debug - depending on what your definition of debug is. ```elixir blah |&gt; something |&gt; something_else |&gt; something_finally ``` Taking the above example, one of the big things that happens in Elixir is this: ```elixir blah |&gt; IO.inspect |&gt; something |&gt; IO.inspect |&gt; something_else |&gt; IO.inspect |&gt; something_finally |&gt; IO.inspect ``` And suddenly you have debug information for each step of the pipeline, which is convenient for figuring out which step went wrong. Of course, the way some people /use/ pipes is forceful and messy, but pipes themselves are not inherently bad.
Your example is of when it makes no difference at all. It's also a trivial toy example. In more realistic real world settings, you'll find that this isn't how debugging is supposed to work in Erlang, because as it spreads over thousands of processes on dozens of nodes it quickly becomes impossible to sort. This approach completely defies the let it crash and the error handling goes in other process approach from Joe's thesis. When you learn Erlang, and do larger production scale projects, you'll realize why Elixir's attempt to stuff Ruby style debugging into this environment is a dead end . &gt; Of course, the way some people /use/ pipes is forceful and messy Such as your example
Along with [pattern matching](https://www.poeticoding.com/the-beauty-of-pattern-matching-in-elixir/), one of the coolest things in Erlang and Elixir is their concurrency implementation based on Actor model. In this article I introduce concurrency and show how we can start making our code concurrent in Elixir, using processes.
In Algol-derived languages you use statements such as if for control flow, i.e., branching, but, in Erlang, statements like if and case don't really branch the code, they're more like small functions that do something depending on certain conditions and then return a result to the caller. To achieve actual branching you have to write **multiple headers** to a single function, where each entry accepts input of various format. &amp;#x200B; A trivial example (a simple sum function in Python over lists or tuples): def sum(List): N = len(List) if N == 0: return None else: Res = 0 for element in List: Res += element return Res &amp;#x200B; The same example could be written in Erlang: %% define the function to only apply to lists sum(args) when erlang:is_list(args) -&gt; lists:foldl(fun(X,Acc) -&gt; Acc + X end, 0, args); %% everything else falls through sum(_) -&gt; undefined; &amp;#x200B; You could also re-write the Erlang example to use an if-statement, but in more complex pieces of code this quickly becomes infeasible or even impossible as Erlang really does not want you to use the if-statement for control flow. 
Honestly, it was just having some people around to help me out with the stuff that I had to do. I tried reading the books and tutorials but Erlang is very ghetto/niche, so finding actually useful resources was a struggle. That book "Erlang for concurrent programming" is probably the least helpful book I've ever tried to read, it's written like a reminder for someone who knows what's happening, if you're a novice it's too difficult and too light on the details at the same time. &amp;#x200B; I kinda have the same opinion for Learn me some Erlang. Equally awful book for more or less the same reasons plus the language in this is for children. I guess the author just wanted to write something so that he could tap himself on the back. &amp;#x200B; It worked well for me at the end, though, my job has very little Erlang in general as I'm mostly doing data analysis &amp; stuff like that. Best resource in paperback was "Introducing Erlang", it's a very simple and short book just enough to get you going with the syntax and a few of the most commonly used features of the language. That one I actually recommend. &amp;#x200B; &amp;#x200B;
Chat application should be process in realtime. In this scenario, Erlang is agile to adapting to **instant updates and hot fixes**. **Mnesia DB** handles the heavy-duty task of database management. Mnesia is a multiuser distributed DBMS which also happens to be the **default DB of ERLANG**. Mnesia helps achieve quicker request responses, thereby improving the overall efficiency. &amp;#x200B; PS: I am from [Mirrorfly](https://www.mirrorfly.com/), we are readily built solution using Erlang for web, Android &amp; iOS platforms.
Have a look at escript: http://erlang.org/doc/man/escript.html
You could simply run a function with the corresponding Erlang option, e.g. erl -run mod function -run init stop Ideally you would use ports though, then you don't have to restart the whole VM for every function. There might also exist a framework somewhere to interface Erlang with Java.
That sounds useful. Would you be willing to just break down that each part of your example represents, since I'm not entirely sure what is what? 
You can find more on that here: http://erlang.org/doc/man/erl.html With the -run option you can directly start a function after the VM is started. Mod is the name of the module, func is the function, and afterwards you can have some arguments. The second -run init stop will call the stop function of the init module, thus terminating the VM after the previous function is done. -run Mod [Func [Arg1, Arg2, ...]] 
Ah, I see! Thank you very much, will try this out! 
Messages are a fundamental part of concurrency in Erlang and Elixir. In this article I introduce how messaging between processes work. We play with simple examples to see how a process sends and receives messages.
this seems to be a bunch of minor, unimportant syntax differences that will confuse the elixir user once they need to move into the real language elixir is to erlang what coffeescript was to javascript - a bunch of ruby people refusing to let ruby go, then spending a decade trying to explain why they haven't missed the point, and holding up things like "well it's several characters less to do this thing" as language improvements
in particular, the way you "composed streams" 1. isn't composition, and 1. is wildly slow and unacceptable to the high parallelism machine
I don't know, I think "use" is quite nice. Structs as well. I really need to spend more time with Elixir, but the fact it's bringing a bunch of people in to the Erlang world, seems to be a net positive.
in trade for mis-teaching them constancy and strings, and other things of that ilk? it's a painful transition