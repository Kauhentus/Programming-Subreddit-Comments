Thank you. Rust is certainly an inspiration :)
What's the price going to be? I'd like to start working on the purse-holders at work :)
Maybe this spares someone a search: http://www.elixirconf.eu/
In this part we’ll do a step further, making both keys and values persistent. Taking inspiration from the Bitcask design, we will see how to enhance our implementation and to recover the Index in the case of a failure.
Hi everyone. I've just published a new part of the series. Please comment in the reddit post if you have any question. [https://www.reddit.com/r/elixir/comments/a32hqb/build\_a\_simple\_persistent\_keyvalue\_store\_in/](https://www.reddit.com/r/elixir/comments/a32hqb/build_a_simple_persistent_keyvalue_store_in/) &amp;#x200B;
Very interesting project. Suppose I am developing a chat application, would PushEx be a good fit? How would I structure my architecture using it? Also, to "push" to PushEx, can be done only with HTTP API? Does it expose a native Elixir function or message api? Would that be more performant? 
Thanks for the great questions. I would not suggest PushEx for a chat application because you would most likely need 2-way communication from client -&gt; server. PushEx doesn't seek to fill in this role because it is highly application specific. Instead, I would recommend using Phoenix channels directly. The push is triggered via HTTP currently. I would be open to adding more, of course, if the need presents itself in the community. I am exposing this over HTTP solely because that is how I have historically triggered push events to my servers + third party servers.
Thanks for the answers and for contributing this cool library to the Elixir community :)
I am actually less confident about PushEx after reading this reply. It seems PushEx is built on top of Phoenix, on both server and client, so why would I choose to use PushEx, which is a whole new dependency, instead of following the practices you have outlined here in my code? Have those improvements been reported to the Phoenix team? 
I think it's a great idea to take these practices and apply them in your code. PushEx is really for people that want a push microservice w/o worrying about the details of it. There are some instances of these improvements being reported to the Phoenix team. An example of this is a PR made last night to try to get around the empty handle\_diff that PushEx does. Another PR is on the JS side to handle channel reconnection more quickly if the socket disconnect. Some of these problems are application specific and not things that should be handled in Phoenix. An example of this is "should you use Presence to track server side channel connections to know whether you need to broadcast a given message across your system?" or "How should you instrument a server like this?" The base is Phoenix, frontend and backend. Phoenix is phenomenal and copying the code that PushEx gives you will give you a solid server to work with and make changes to.
Thanks for the reply. I will look for those PRs. Can you please expand on this? &gt; "should you use Presence to track server side channel connections to know whether you need to broadcast a given message across your system?" I am not sure what you mean.
PushEx uses Presence to know if "someone is listening" so it doesn't broadcast potentially large payloads across the cluster. How to handle that is still ambiguous. I'm discussing now that maybe Phoenix.Tracker should be used over Presence and will look into making that change.
I have a feeling someone just read DDIA.
You are feeling right (I'm saying that in the part-1) ;) Fantastic book! It makes much easier to understand database design papers. 
I thought presence updates are always broadcast locally and if nobody is listening on that particular node then it is a no-op? Other than that, you can't solve the "someone is listening" for a cluster without introducing coordination, such as majority votes, that locks subscriptions whenever broadcasts are made. Otherwise, a subscription can always be made on node A right before node B sends the broadcast.
The challenge here is getting no process to listen. If you use Presence and want to achieve this, I've seen interception no op as a solution. This ends up still broadcasting. I have a load test in PushEx (same script roughly as the 2 million one) which exposed this as a hot spot. It is possible to change the topic, although you would need to make sure the track does this appropriately and I'm not the biggest fan of this solution. The solution Chris gave me after discussing with him is to use Phoenix tracker directly with an empty handle diff. I'm going to explore this option and document it in the Phoenix project if it is simple and effective.
What is the use case for tracking processes but getting nobody to listen? That definitely sounds out of the scope for presence, so it is a bit harsh to put this on Phoenix. Do you want to keep a count of active connections or something? Phoenix.Tracker could be better but it is still overkill because you would still track metadata for each process while you only care about a number. What I would do in this case is to have a process that monitors things locally (via Process.monitor) and then broadcasts its local counter from time to time. 
PushEx uses presence to not broadcast (distributed operation) plus will be enabled in the near future to track frontend metadata such as info about the user. This is a great use case as people could leverage their push server to get info about connections. The number is tracked using something different, as you mentioned, and is not distributed. The reason I had put this on Phoenix is that the docs in presence frame it as a "Provides Presence tracking to processes and channels." I also cannot find a spot in the docs where it says presence is for listeners exclusively. I discussed with Chris that direct tracker usage is probably desired. I believe that the docs should be updated to indicate this and will look to do so. I initially followed this forum post to get to this conclusion https://elixirforum.com/t/phoenix-presence-presence-diff-messages/1893/5
Would you classify MUMPS as dynamic/weak in that classification?
He provided this video on slack when asked and said I can post it here. The quality isn't best, but I think it's great! [https://www.pscp.tv/w/1ynJOOeLbLlJR](https://www.pscp.tv/w/1ynJOOeLbLlJR)
Not sure for Erlang but I think they also SIGSTOP-a-like the container processes when there is no requests in progress - ie processes get paused with docker pause and resumed when next request comes (I may be mistaken, but I think this was the observable effect I got when I tried to abuse the lambdas a little). So this doesn't allow for background processing within lambdas, can't say how it may affect such a connection; maybe it will allow for connection to get estabilished, but then it may timeout often. Hard to say.
I didn't say background processing, I said that processes could exist and maintain state. They obviously won't allow any way to use CPU when the request is complete because this would be free cycles that people could exploit.
Great post! I’m a beginner with Elixir and think that these are great. Keep it up! 
Thanks a lot :-) Do you think that a hands-on screencast on this would help and would be useful?
I think both ways have pros and cons. Give it a shot! Please continue to include the graphics (such as how the lookup works into the map) in the screencast though.
[removed]
[removed]
Thanks for the tips, you mean graphics like these [https://www.poeticoding.com/content/images/2018/11/logkv-appending-values-index.png](https://www.poeticoding.com/content/images/2018/11/logkv-appending-values-index.png) ??
Yes exactly! Those were very helpful to understand what the lookups are actually doing 
Awesome, thanks!
Check out [https://hexdocs.pm/elixir/Stream.html#zip/1](https://hexdocs.pm/elixir/Stream.html#zip/1) (or the Enum variant).
You can do it with zip or with simple pattern matching ``` def triple_trouble(x, y, z) do triple_trouble(String.to_charlist(x), String.to_charlist(y), String.to_charlist(z),[]) end defp triple_trouble([], [], [], acc) do acc |&gt; Enum.reverse |&gt; List.to_string end defp triple_trouble([head1 | tail1], [head2 | tail2], [head3 | tail3], acc) do triple_trouble(tail1, tail2, tail3, [head3, head2, head1 | acc]) end ```
A quick, relatively clean solution for you: ``` defmodule Codewars.WeirdString do def triple_trouble(one, two, three) do [one, two, three] |&gt; Enum.map(&amp;String.graphemes/1) |&gt; Enum.zip |&gt; Enum.map(&amp;Tuple.to_list/1) |&gt; IO.iodata_to_binary end end ```
Thank you everybody, I took a little from everyone's approach. And come up with this solution: ``` def triple_trouble(one, two, three) do list = [one, two, three] [first, second, third] = Enum.map(list, &amp;String.graphemes/1) Enum.zip([first, second, third]) |&gt; Enum.map(&amp;Tuple.to_list/1) |&gt; List.flatten |&gt; Enum.join end ```
Thank you, I didn't know about zip.
Thank you, I was wondering how I can do that with pattern matching.
Thank you, the final solution is close to yours. When I saw about zip I immediately started to hack in iex. But I took Tuple.to_list function from you.
``` defmodule Codewars.WeirdString do def triple_trouble(one, two, three) do do_triple_trouble(one, two, three, []) end defp do_triple_trouble("", "", "", acc) do acc |&gt; Enum.reverse |&gt; :erlang.iolist_to_binary() end defp do_triple_trouble(&lt;&lt;l1&gt;&gt; &lt;&gt; r1, &lt;&lt;l2&gt;&gt; &lt;&gt; r2, &lt;&lt;l3&gt;&gt; &lt;&gt; r3, acc) do do_triple_trouble(r1, r2, r3, [ l3, l2, l1 | acc]) end end ```
I’m not familiar enough with MUMPS to say. But if you want a more general way of looking at things, the primary characteristic of static typing is early binding; so, variables hold to type information. Conversely, dynamic languages are late binding so values end up holding the type information. Typing strength primarily has to do with automatic type coercion and how type conversion works. Weakly typed languages have a lot of automatic coercion, Perl being the best/worst exaple of this, it’ll try to figure out and carry out conversions for you...often silentry. Even if they’re crazy things like automatically converting a string to an integer, because it looks like the string is representing an integer, and then add that to another integer because maybe that’s what you had in mind. On the other hand, strong typing like most Lisps require explicit conversion for everything except, maybe, not when “up converting” a smaller sized integer to a larger one...maybe. Lastly, weaker typing systems, say like C, make it very easy to do a conversion that might be flat out rejected by another language. Even C++, stronger typing than C, breaks the absurdly powerful C cast into three more reasonable ones (static, dynamic, reinterpret).
I was having an issue. Since the `Writer` module opens the file for writing, it clears the file, so persisting doesn't really work. If in the Writer you change your init so that `fd` is just the file path, and instead of `IO.binwrite` you use `File.write(fd, data, [:append])`, I got it to work and persist between initializations. Were you having this issue too?
Thanks, I need to bookmark and read everything I can find on property testing.
yes you are right, without opening the file with \`:append\` option the file is truncated. The main reason why I didn't do it is because engines like bitcask do not re-open in write mode a logfile once closed (closed for any reason, failure or because too big). What they do is to open another one, having multiple files for reading and just one single active file for writing. The reason is mainly because when the file is closed for a fault, it could have corrupted data at the tail which can be avoided just starting a new file. The other reason is because this kind of engines use to have multiple files (segments). Splitting them they can in background merge the old segments in one single segment removing old key/value (compaction). But if you want to just experiment with it, what you did work perfectly! Did you also post a comment about this in the blog post? I've just seen an email with a comment similar to this but unfortunately it was removed by the author. 
&gt; Did you also post a comment about this in the blog post? Yeah, I posted it here so I figured I'd just keep it one place instead of having two conversations. Anyway, thanks again for the post, really interesting.
Thanks :-)
I vaguely remember reading about charlists behaving in unexpected ways sometimes and graphemes being the preferred way to split a string into characters. Does anybody remember the reason? Or am I misremembering there being an issue at all? 
`defmodule Codewars.WeirdString do` `def triple_trouble(one, two, three) do` `do_triple_trouble(one, two, three)` `end` `defp do_triple_trouble(one, two, three, acc \\ "")` `defp do_triple_trouble("", "", "", acc), do: acc` `defp do_triple_trouble(&lt;&lt;f::binary-1, rest1::binary&gt;&gt;,` `&lt;&lt;s::binary-1, rest2::binary&gt;&gt;,` `&lt;&lt;t::binary-1, rest3::binary&gt;&gt;,` `acc) do` `do_triple_trouble(rest1, rest2, rest3, acc &lt;&gt; f &lt;&gt; s &lt;&gt; t)` `end` `end` &amp;#x200B;
Whelp, guess it's a YouTube life for me.
```elixir defmodule Codewars.WeirdString do def triple_trouble(one, two, three) do triple_trouble(one,two,three,"") end def triple_trouble(&lt;&lt;c_one::binary-size(1), ""::binary&gt;&gt;, &lt;&lt;c_two::binary-size(1), ""::binary&gt;&gt;, &lt;&lt;c_three::binary-size(1), ""::binary&gt;&gt;, acc), do: acc &lt;&gt; c_one &lt;&gt; c_two &lt;&gt; c_three def triple_trouble(&lt;&lt;c_one::binary-size(1), rest_one::binary&gt;&gt;, &lt;&lt;c_two::binary-size(1), rest_two::binary&gt;&gt;, &lt;&lt;c_three::binary-size(1), rest_three::binary&gt;&gt;, acc), do: triple_trouble(rest_one, rest_two, rest_three, acc &lt;&gt; c_one &lt;&gt; c_two &lt;&gt; c_three) end ```
I'm developing an Ecto adapter so these post series are very welcome. Thanks!
I thought that the CAP theorem has largely been moved on from in distributed systems thinking.
Here's my solution: nothing fancy as others solutiions XD defmodule Codewars.WeirdString do def triple_trouble(one, two, three) do combine(one, two, three, "") end defp combine("", "", "", acc) do acc end defp combine(one, two, three, acc) do {a1,a2} = String.next_grapheme(one) {b1,b2} = String.next_grapheme(two) {c1,c2} = String.next_grapheme(three) combine(a2, b2, c2, acc &lt;&gt; a1 &lt;&gt; b1 &lt;&gt; c1) end end 
It is a provable result, in truth it is kind of the simplest case of a more complex problem in terms o latency etc
Super cool stuff. Going to have a look at it tonight!
Ah, there is no repo yet??
soon™
Wow!
In this article, [Running Elixir in Docker Containers 1](https://www.poeticoding.com/running-elixir-in-docker-containers/), I explain how to use Docker to run a development Elixir environment and to run multiple Elixir Nodes over a Docker bridge network. Any question or feedback is highly appreciated! Alvise
Nice, sort of like turbolinks, but taken to another level. I'll have to check it out.
Same idea as https://github.com/grych/drab I used it and it's like black magic to me. Phoenix.LiveView is going to be amazing. Also I hate front-end stack/programming with fiery passion, so I'm excited.
Thank you! Looking forward to the next post!
This is amazing, can't wait to test it out! 
How much is it practical? What is someone is developing a Facebook style chat and notification system? I think the chatbox will be erased and re-created with every new page visit and it will be heavy on the server.
as any tech, don't use it for everything, just use it for the right project/problem.
We've come full circle to X11 and mainframes 🤦‍♂️
Honestly guys frontend developed with js, especially with typescript, is a lot more maintainable
[removed]
It was interesting that they're introducing some very constrained in-place mutations, perhaps a step towards the Clojure model.
&lt;citation needed&gt; :) Typescript is awesome, but from experience across dozens of projects, JS front-ends are inherently less maintainable. Pick any aspect, from tooling, library churn, back-end &lt;=&gt; front-end integration, encoding, etc. It all has a maintainability cost. Most professional front-end engineers readily admit this, but the price is rightfully justified by what client code allows you to accomplish. LiveView aims to give you an alternative for a slice of what you'd traditionally be required to make the maintainability and complexity tradeoff with JS.
Also https://gitlab.com/dgmcguire/texas exists
Why so expensive? :(
I think that sort of application is ideal for it. There's no use for offline, and content updates are small and at a low rate. There may be some additional HTML to load for the initial page, but after that, it's basically the same. Every JS client getting live updates has a websocket connection open to the server down which it is receiving JSON. For LiveView you'll have a websocket connection down which you're receiving pieces of HTML, approx equivalent size.
Very nice article. Thanks for sharing!
After more than a decade developing in multiple languages (always using local installed versions and interpreters) I still don't get it.. Why should I use Docker for local development of projects using the same languages, databases &amp; services I always use and already have installed? I can use `asdf` to install multiple languages in different versions, keep things simple and don't have to erase, start, stop, mount and all those necessary steps when using Docker. This is an honest question, I'm not bashing on Docker, I just don't see the benefit yet. Could someone enlighten me? 
Sometime I use docker for development, sometimes not. Most of the times I use it when I want to reproduce exactly the environment (and architecture) I’m working on, which is extremely helpful when, for example, you have everything in your company’s computer and you then have to work from another computer. In matter of minutes you have everything working. If it’s a medium/small elixir app with no particular dependencies, maybe installing elixir directly it’s faster and easier. But when you start having multiple services working together in a microservices environment, something like elixir + python (with machine learning tools dependencies) + kafka, with each one having its own env vars etc.. it can start easily to be really complicated to be able to consistently recreate the environment and architecture. I absolutely don’t want to say that’s always the way to go (for production maybe it’s another story), but in the case of dependencies and to simulate architectures locally, I think that docker is really a great tool :-)
Thanks for the thoughtful response.. Another question: normally I see the docker images being based on a main service or language (like the elixir image in your post).. What happens when you need two or more languages equally important, like Elixir and Python? If your answer is "use the elixir image then install Python using RUN commands", then why use the elixir image at all and not a generic Linux image and install each language separately? 
Why you need python and elixir in the same image? In general each single image should run one single service. In the case of language images like python and elixir, if you have one service in python and one in elixir these can be (and should be) in two different containers (maybe talking to each other). In the case of Phoenix for example, I use one node image to compile the assets and elixir image to run Phoenix itself. I would compare Images with software packages and containers with processes.
&gt; Why should I use Docker for local development of projects using the same languages, databases &amp; services I always use and already have installed? Is your development environment running Ubuntu 18.04 (or whatever OS you use in production) with the exact versions of postgres, redis, etc.? Also how do you deal with app A wanting postgres 9.4 but app B wants postgres 11.0? What does your development workflow look like exactly in that case? What happens if you want other people to use your code who aren't running your exact dev set up? With Docker is super simple. All I have to do is run 1 command and Docker will spin everything up in its own isolated environment. My programming language and all its dependent services are separate between all projects. This works just the same on Windows, MacOS or any supported OS. Then when it comes to production, I take the same exact set up and run it in production and it'll run exactly the same way. The only thing that changes is minor configuration. There's no "I hope apt works!" or "I hope my dependencies finish building". There's no guesswork because by the time you run it in production, the thing you're running is already built. That's only the basic advantages. There's also supporting tools around Docker that make things easier for moving around code between environments, such as leveraging Docker registries. You might want to read this post I wrote a while back on comparing setting up a Python development environment with and without Docker. It applies exactly the same to Elixir. https://nickjanetakis.com/blog/setting-up-a-python-development-environment-with-and-without-docker
&gt; For production I would definitively go with alpine, which is much lighter. But, for development, the main one brings many more tools.. Is it possible to use one container for development and another for production? (I'm just learning)
What is the compatible version of Elixir for OTP 21.2?
I really wanna try this out. I only dabbled in elixir so far, because I usually do frontend work. 
Any version that supports OTP 21: https://hexdocs.pm/elixir/compatibility-and-deprecations.html#compatibility-between-elixir-and-erlang-otp
Good question. The short answer is yes, absolutely. Can you please write this comment in below in the article so the discussion can be seen by all readers? thx
I know you're asking about Elixir, but I see from your other thread that you're exploring multiple languages. Go has a bunch of text UI libraries, oddly enough. I don't know Go, I just stumbled onto this recently. Some of them look really great and I wish they were a bit more universal. Here's a link to a big list of them: https://appliedgo.net/tui/
Can you give an example of this and what it means? 
I appreciate all of the Elixir / functional programmer referrals everyone has sent! We have hired 1 of the 3 openings that we have available. Our company pays referral bonuses too so make sure you reference that when sending!
I'm working on [https://www.workflowci.com](https://www.workflowci.com) – IFTTT for developers. My first project built with Elixir (plus GraphQL and React)
Advancing some open source work for my newly opened business primarily using elixir/erlang. This month a lot of work being done regarding search indexes. Writing an elixir lib to make distributed sphinx search deployments easy
Wow, that is an excellent article. Glad to see DSC giving elixir some love. 
What would be a good use case for this new feature?
Thank you!
Global shared mutable state. *barf*
Might this work for multi-page apps that have different urls? Or best used for interactivity on a single page? For instance there might be a list of items at /items and then a detail page of an item at a path of /items/111. Would live view work in the transition to a new page?
Configuration would be a good fit. Also good if you have a large amount of immutable data that needs to be referenced. It’s expensive to send that across processes. This would be a good fit
Python is my current daily driver for my personal programming projects. The reason I'm specifically interested in Elixir as my next language to branch out into is because a free software project I want to contribute is in Elixir (and not Go or another language). However, of the projects listed in the article you linked, `jroimartin/gocui`, `VladimirMarkelov/clui`, and `rivo/tview` seem to be the ones most suited to my needs.
Glad it could point you in the right direction. My experience with Elixir has been that most people either use it for APIs and/or web servers - I don't think it has a lot of interest for general scripting usage. I'm not surprised there's no packages for it. Definitely let us know if you build anything awesome!
Great post! I hope you write plenty more :)
Just curious - What would be the benefit of this lib as opposed to just using a partial in the layouts use. Not an SEO expert help understand.
Awesome! By the way do you know if Ruby on Rails has something like that?
This library helps you dynamically change your header tag anywhere. You can also change your header by layout but that would be a repeatible task
will make a follow up video for that one ;)
semver.org
I guess this means that my trail project for Elixir will be something other than a TUI for editing one of my DBs. Bid euchre is a nice way to explore a language, so maybe I'll go that direction.
Are you using headless browser? More details would be interesting
Fresh and nice looking front-end in browser, where our crawl-specialist will write rules for the crawler and the parser (the rules for fetching specific data from the html). He's not a programmer, so we are writing a simple DSL for him where he can type simple commands, and Elixir macros will auto generate an Elixir Module where we will run the html through and get the data we want in a standardized way.
Possibly, it's good thing for admin part of app.
I would hope that this would only be to satisfy the few corner cases of algorithms that benefit greatly from mutability (such as quicksort) where a fast functional implementation is not known
Just to add to what the other guy said. When there is a dockerfile at the root of a project, you just go docker build and it's done. You don't have to care whether it is centos or debian. You don't have to deal with opening ports in iptables or firewalld or creating systemd or init scripts or any other user level systems that might complicate things. It is just the core app with no extras and it will always work, every time. For the next ten years this built container will continue to work on the first try just like it did when it was first developed. When you deal with a base linux image and then install things, you have to tediously provision it. Ansible or chef or something, each of which continue to evolve with new versions. And then the distro gets updated or its repository is no longer updated. And now you have to have a migration plan to get the application off that machine and onto another which requires more testing, but no one has touched it in years. And since it is a docker container, you can place it on any service. AWS or Google cloud or digital ocean or pivotal cloud. It will work everywhere the same as it would on your desktop. In addition they slot well into any kubernetes or docker swarm installation where again, they just work. The only negative I've been able to find related to elixir is that hot upgrades are just not reasonable. That's due to elixir, honestly and I wouldn't be surprised to find that gets fixed sometime in the next few years as more and more people continue to adopt containerization.
That's a great response! Thanks 😊
I doubt they included it speculatively. My guess, without looking at the code base changes, is that it was added to support the fast persistent term storage feature.
def get_challenge_by_id(id) do Challenge |&gt; Repo.get(id) end This code is so small. Why exactly does it need jts own function?
You may not want to expose ecto and repo concerns outside of the boundary. Should the Phoenix controller code know how to make the query? 
I've got a drop-in Docker Compose setup for Elixir development: https://github.com/dogweather/phoenix-docker-compose
So the only reason is to be able to switch away from Ecto easily? 
The reason is separation of concerns. The controller should only be concerned with highest level of abstraction that will allow it to make a decision about the fate of the conn. The controller should not know or care _how_ the `Challenge` was retrieved only that it was successful or not so it can send the correct response.
Or as an example, you might want to add some caching layer later
[https://aviabird.com](https://aviabird.com) Creator and maintainers of [https://github.com/aviabird/gringotts](https://github.com/aviabird/gringotts) and [github.com/aviabird/snitch](https://github.com/aviabird/snitch) (now known as Aviacommerce [https://www.aviacommerce.org](https://www.aviacommerce.org))
The big problem, IIRC, is that Elixir doesn't work with escript. So CLIs become hugely cumbersome because all the knowledge is built around using beastly erlang releases.
Take it down a notch, dude.
Ah cool. So for example if you want to log all inserts or something, it is easy to achieve as well. Thanks for the example!
OMG OPEN-SOURCE IT ALREADY! ;)
In this article I show how to build an Elixir application to get realtime updates from the coinbase websocket feed, handling crashes and disconnections. Any question or feedback is highly appreciated! Alvise 
Great article! About what frequency do trades occur approximately? It looked like from the video it was just a handful per second at max. Was that just that moment or have you seen it spike to hundreds or thousands of trades per second?
thanks and good question. It really depends by the time of the day, which product you subscribe to and how many products you follow. In that example, downloading only trades ("matches" channel) for just BTC-USD I was getting around 2 trades per second, pretty low. It was also 10pm GMT. If you want to have traffic you can subscribe to different products like ["BTC-USD", "ETH-USD", "LTC-USD", "BCH-USD", "BTC-EUR", "ETH-EUR", "LTC-EUR" "BTC-GBP", "ETH-GBP", "LTC-GBP"]. In around 20-30 trades per second. If you move from the "matches" channel, to the "full" channel, with all the level2 events (each single bid/ask in the order book), you can get hundreds events per second. At this point you'll have to implement other handle_msg/2 functions to filter the new types of messages.
I've modified quickly the Coinbase.Client module to make it subscribe to the full channel and counting the number of "events" per second. The state is a map where the module updates the counts for each second. [https://gist.github.com/alvises/c275004b878f22eda2b6f78cfbe2ce4a](https://gist.github.com/alvises/c275004b878f22eda2b6f78cfbe2ce4a) It's then possibile to easily reach &gt; 500 events per second. iex(1)&gt; {:ok, pid} = Coinbase.Client.start_link ["BTC-USD", "ETH-USD", "LTC-USD", "BCH-USD", "BTC-EUR","ETH-EUR", "LTC-EUR", "BTC-GBP", "ETH-GBP", "LTC-GBP"] connected! {:ok, #PID&lt;0.175.0&gt;} iex(2)&gt; :sys.get_state pid %{ {2018, 12, 19, 19, 50, 1} =&gt; 413, {2018, 12, 19, 19, 50, 2} =&gt; 530, {2018, 12, 19, 19, 50, 3} =&gt; 651, {2018, 12, 19, 19, 50, 4} =&gt; 527, {2018, 12, 19, 19, 50, 5} =&gt; 534, {2018, 12, 19, 19, 50, 6} =&gt; 197 }
That sounds much more plausable, why's the video show events happening so slow? 
No mention of the Elixir Dialyzer formatter available in the recent RCs and an explicit pin for `0.5.1`? The RCs make the error messages legible and include explain flags for the warnings. 
I wouldn’t consider elixir as my first programming language. Even thought language itself is great, community is awesome, ecosystem isn’t mature enough. You’ll have to write most of the stuff when you can use libraries. Also understand that growth potential doesn’t equal to actual language adoption. Look at Java, python, ruby even JS with its wired quarks, they still hold their own. This doesn’t mean elixir is bad language, I myself enjoy it but it’s still new kid in today’s fast changing world. 
 Javascript no question, literally hands down. Anyone who disagrees isn't a web developer. Javascript is a must know language. If you are serious about learning web dev, stop doing what you're doing and learn javascript. 
As much as I hate JS, this is true.
Inshallah wasm will save us
If you're looking to get a job as a programmer it might be worth starting with a language that has more work out there, such as Python or Javascript. If you're just looking to learn and have fun Elixir is a fine choice.
I wouldn't agree with this. Elixir has been around for a good few years and there are a lot of packages out there - I haven't felt the lack like I used to with Rust for instance. This I helped by the fact that the Beam and Elixir ecosystem is incredibly mature, and those modules are just as easy to use in Elixir.
Elixir is pretty much specialized language. At the basic level you can write something common, like simple scripts or even web-apps, but for unlocking a real power of that language you have to understand how Elixir works under the hood. From my experience (7y Ruby/Rails dev, 1y Elixir/Phoenix dev) I have to admit that Elixir is very differ from another languages due to functional paradigm and Erlang virtual machine (BEAM) principles. Some things will be easier, some things will be harder, some things just almost impossible for Elixir. I personally recommend to start with Ruby/Rails as first language, if you're gonna dive into webdev. But okay, what if you still wanna try to start w/Elixir? Start from Erlang first. Not a joke. Elixir largely is a syntax sugar over Erlang. Deep into Erlang internals: how memory model works, how schedulers works, how garbage collector works and so on. Play with all that. After that you can move to Elixir. Good start: [https://elixir-lang.org/getting-started/introduction.html](https://elixir-lang.org/getting-started/introduction.html) [https://elixir-lang.org/docs.html](https://elixir-lang.org/docs.html) And after some smoking and playing with Elixir you can finally go to Phoenix. Sadly, I can't recommend good books, just because I have enough experience to learn new languages just by reading official docs. But you can look for them on official site: [https://elixir-lang.org/learning.html#books](https://elixir-lang.org/learning.html#books) GL. If you have any questions, feel free to ask, I will reply asap.
&gt; If you are serious about learning web dev, stop doing what you're doing and learn javascript. Gonna disagree with this last part. For a few reasons: It's gonna be a while before he's employable, so might as well start out with a language that encourages good coding practices, establishes the value of immutability *by force*, and otherwise has a good, clean interface. JavaScript is a rat's nest. Get him started with that and he'll spend more time trying to figure out which "flavor" of JavaScript to learn than actually coding. Not to mention the clusterfuck that is the build tools. Nightmare for any beginner and not worth it to start with. You *can* create dynamic websites *without* JavaScript. You *can't* create them with *just* JavaScript. (Okay, network-isolated apps like games, maybe, but anything that needs to communicate with a back end needs... a back end. Which, hopefully, will be written in a coherent language, not JS/Node. I'll wait for the downvotes.) Once he's got some good stuff under his belt, learning JavaScript will come fairly easily, since you can adopt most programming paradigms in it. And he won't be prototyping everything and throwing mutable variables around everywhere, which should be a *last* resort, not a *first* resort, and what JavaScript naturally pushes from the get go. I know someone will say "well just use typescript or purescript or whatever", but he won't have the "don't mutate data!!" guardrails everywhere, like he would with Elixir. Personally, I think Elixir is a *fantastic* first web language to learn, and Phoenix isn't loaded with magic, so he'll get a good idea of one of the *better* ways to program, rather than the **holy hell mess** that is JavaScript right now. My two cents...
You conflate Ecmascript with the JavaScript package world. A beginner should ignore that world for months. Build a website with no tools. Moreover, learning an object oriented backend language will grant more career capital than an underground functional language. It comes down to goals. Do you want to make money? Or is this a hobby? If it’s a hobby then do whatever you please. If you want to earn money then learn JavaScript, and learn it well.
Absolutely no offense intended, but per your own words, you're a professional developer of only 1.5 years and you're still learning JavaScript. I don't think you're necessarily qualified to make assessments such as these. I'm not going to graybeard you, but I've been a professional developer for over 25 years, so I am inclined to trust my own advice over yours. What you or anyone else takes from it is up to you all. I will address your points: I completely understand what you mean about ECMA vs JavaScript packaging. The problem is that it's easy to quickly fall from ECMA to Babel-y stuff/etc. It's like a drug: starts with "oh, jQuery can help me write sightly less boilerplate" and quickly evolves to finding the "next best thing". (Cue Admiral Akbar.) Regarding career capital, there is *more* value in learning how to program *well*, with fewer hard to find bugs, than object oriented alone, itself. In fact, if you want to look towards long term capital, it makes a lot more sense to start by learning a functional language than an object oriented one, as the trend is very much headed towards functional, especially once us greybeards die off. The JavaScript culture *does not make learning how to program well easy. Full stop.* That's not even debatable. You're absolutely right that Elixir is somewhat underground. The mechanism that underlines it as best practices, however, is well established and extremely solid. I think you might be young enough to still think that learning one language that is not necessarily financially useful means that it is a net cost in one's career. That is not correct. The transition from Elixir to JavaScript or Ruby or Python is a small leap. But you have guards within Elixir that encourages programming *well*. Later on, he could use those learned traits to adopt Scala or Clojure or C# or Java or *whatever*. JavaScript developers are a dime a dozen. As such, most get into it because it's easy, it's in demand, and you can get by for a while before burnout hits and the next kid takes your place. Backend, especially by adopting the trending (albeit old) functional paradigm, is a move that will enrich not only your skills as a developer, but also pave a path to your future career. *Anybody* can be a JavaScript developer. *Not* everybody can be a *good* developer. Start with learning how to program well, *then* follow the money... It *probably* won't be JavaScript in 10 years...
I agree. When I said I'm still learning JavaScript it was to make a point that you should never stop learning. 
&gt; you should never stop learning. That is the *best* advice *anyone* could *ever* give!!
I think Elixir is amazing. I spent over a year playing with it, though, while I was still at a Ruby job ([relevant code repo here](https://github.com/pmarreck/elixir-snippets)) I honestly don’t think I would have appreciated Elixir (nor surmounted its conceptual learning curves) unless I had been disillusioned by other languages such as Ruby (a language which is STILL far superior to many others!)
So everyone here is focused on technical advice on what languages and why and otherwise bikeshedding. So, I'll give some advice from a learning success stand point. Sit down and think about something you would enjoy building and have that firm project idea and then incrementally work towards accruing the knowledge to build that idea. Just keep banging away at it. When I was new, which was a long time ago now, I wanted to build a game. I was using a platform called BYOND and they have a simplified language known as Dream. I had their editor open on one side of my screen and their language docs open on the other. I basically just kept reading and trying things out until I got my first real thing to work which If I remember was like a variable light source as the player approached or something. That took me a while and then I wanted a projectile, that took another long while of just reading the docs looking at examples and failing. Eventually it takes less time to add things that you want to that project because you have this previous body of knowledge you build up while failing and adding other things. I think it took me something like 4 or 5 months to build that original game and then I maintained it for another year or so. From there I moved into C++ and then Java then Python and JS then Ruby. With many frameworks and different projects in between. Now Elixir and Julia would be my two pet languages and my strongest language is Python. Hands down having a project in mind you really want to build and would enjoy I have seen as a bigger driving success behind new developers learning. Otherwise there is so much information that analysis paralysis sets in. Start with a narrow goal, hit that and repeat after a lot of narrow goals you'll find you have a large body of useful knowledge and can start tackling larger problems.
Ruby is a great first programming language — that’s basically what it was made for. It has a great community, and will give you a solid foundation of best practices. And tbf, if doesn’t really matter what your first is — you’ll end up learning at least 1 more, and maybe 3-4 more, in your first few years. 
I valued this conversation, particularly Darcy's input. Thanks to each of you though. So a little background on me. I'm 35 and also believe in the idea of never stop learning. I've been working at a Help Desk for the last couple years and was considering the ways I might progress up or out from that role, career-wise. The path I've chosen is working toward the CCNA. Before all this, my only experience in the tech world was using Unix in the military, over a decade ago, to decrypt foreign enemy telecom signal data. My money path goals right now are networking. Programming in more of a hobby in its current state, but maybe it'll help me find a network engineering path 5 to 10 years down the road. Who knows. I chose Elixir for the simplicity of writing, for the immutability, and for the current strength of the frameworks and the community. It's not a popular language per se, but it's one with character and seemed like one that might have a future, at least a long enough future for me to learn it without the community falling apart. That said, I'm not so uneducated that I would believe one language is sufficient for most jobs, and I realize languages come and go based on popularity, strength of code, degree of integration in current systems, the size of the community and quantity of documentation, and innumerable other reasons. I figured, though, Elixir would give me a simpler starting point and then, if I enjoyed it, I could expand beyond it. Learn some new principles and so on in the next language. I'm assuming that JavaScript may come at some point, but I was fairly certain it didn't have to come first. Even then, as Darcy stated, maybe it'll fall out of favor at some point. Still be integrated almost everywhere, but who knows, maybe WebAssembly may gain a strong lead on JS and everyone will start shifting over. We don't know. But because it's more of a hobby right now, I just wanted to start with something that looked fun, might give me a few easy victories while learning it, and teach me some good coding techniques in a functional, process-oriented language.
It doesn't matter where you start, as long as you start. When you reach a high level in programming, you can pick up any language, anywhere and do anything with it - in no time at all. Just start putting those hours in and challenge yourself. If you find Elixir fun and exciting, go for it. Take it and run a million miles.
I want to get started building a site for my wife. She's into genealogy and family history and we'd like to have a site like FindAGrave, but wiki-style, that'll eventually see traffic and allow end users to modify displayed data. I'm currently doing the HTML and CSS research and I'm sure knowledgeable folks would be able to build a working website entirely with HTML and CSS, but I'd like to put it in an Elixir Phoenix framework. Do you have any recommendations on how to make this work? And how I should start and host the site at the beginning? Any other pointers? Thanks!
I'd qualify that comment a bit, and please let us not compare versus JS - there are NPM packages for doing 1+1, that ecosystem is beyond silly. I would take a good look at your environment and coverage in Erlang/Elixir (Erlang has a ton of stuff). It's pretty easy to pull in C code, too. Also, I think we've gotten too library-dependent; writing some code is often better than pulling in a library. In short - YMMV. Check where you'll be active, and whether library coverage matches your needs. But don't be scared to write a bit of code yourself; IMO the advantages of Elixir overall offset the one or two libraries that you'll find missing. (and I never look at what's big/popular, otherwise I'd be coding in PHP and be extremely unhappy because of that ;)) 
My tenure is only ten years but my $0.02 is in with /u/DarcyFitz That is, Elixir first, HTML—&gt;CSS at some point, JS if you need it and/or feel bored with Elixir, and above all else, &gt; never stop learning 👌🎅🏼
Although this is /r/elixir, OP asks a more general and very common question that I’ve answered in far too much depth. Shameless plug and also clickbait alert ;) [This is what programming language you should learn](http://luchenlabs.com/words/programming).
Hey OP, here is a resource for someone looking to learn how to code with elixir as their first language : [Ryan Biggs - joy of elixir](https://joyofelixir.com/) I used a similar resource when I was learning to program (Chris Pines ruby tutorials) whilst doing some front end stuff via free code camp. I think the path you've set for yourself is totally workable! After you've got a bunch of basics down you could move onto the book [functional programming with elixir](https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir) I followed a pretty similar path to you and I'm entering my second job using elixir professionally in a few weeks, happy to answer any more questions you have
Thanks! I've been doing the HTML and CSS stuff on freecodecamp. I like how it's set up as challenges and builds on the last lesson. I think that's a brilliant formula. I also stopped by the library and picked up an HTML5 and CSS3 for dummies book. I appreciate the sentiment. It's nice hearing about other folks who've done similar things. I'd originally considered Ruby as my first language, but wanted something a little more unique, not-so mainstream, but still with enough resources to be used for everything I needed it for. 
I might get some bad feedback for this but... JavaScript is a mess, it's not a good place to start. Elixir is great, but when you add OTP and Phoenix then there is a LOT to learn, especially for a newbie, and also not that many jobs today. For someone new who also wants to eventually get paid I'd suggest two other options: Python or Salesforce. Salesforce is not just programming, but can open many different doors. If you want to learn just programming then start with Python, or possibly Ruby. Move on to other things afterwards. But whatever you choose you'll find you need to learn many different skills, and adjunct technologies, so be prepared for a long learning curve. 
Virtually all of of the books in pragprog.com are great. 
With HTML and CSS, your website will only be static, meaning that users will only be able to look and read, but not interact with it in any way. We use the Phoenix framework at work for building our websites. We have the front end with HTML, CSS, and Javascript, and then the server code in Elixir. But with Phoenix framework, you can also use Elixir inside the HTML files (which is on the front end), which can seriously reduce the amount of HTML you need to write. Phoenix does a lot of the work for you when making websites. But maybe WordPress would be better for your purposes? It's very user friendly, point and click kind of thing. You'd need to write code still, but a lot of things are simplified. There are tons of WordPress tutorials out there, so check them out.
Roflmao, kid
I don't want to be tied to WordPress though. And I'd prefer the challenge. You can't learn all the work it takes if you're not doing all the work. :P
Fair enough. Good luck with whatever you decide to choose!
The rule, of course, is to only take the value from the ```html``` variable that was specified in the test, and not anywhere else (like hard coding the ```product_price``` function to return ```1234```.
Can I binary pattern match lol?
How is html being passed to product_price/0 in your test? I suggest your question is flawed as written. product_price is not defined so a warning will tell you that it is being interpreted as product_price() 
The task was to implement the product_price function so that the test would pass. The test description makes sense in the project we're building, but we don't write our real tests like this.
As long as the test passes without any modifications to the test :)
Hmm, you’re on your own I’m afraid. I don’t want to work on that code. 
What’s the point of using a macro in this case? I’m not trying to be rude I just find it hard believe it was initially macro until the comment about the function arity. If the test makes sense for this private project, why not generalize it more when sharing it as potential interview question? So if I understand correctly, this interview question is intended for junior elixir devs who can write unnecessary macros? This looks more like a test for regex knowledge to me. I feel like we need more clarity because a regex name capture would be a viable solution and is part of the standard library. 
It's for a DSL language we're building for one of our projects. The end user will write simple commands like this, and the macro will expand to take care of fetching the necessary information from the html that we're crawling on the web. You don't need regex or anything like that to implement this test. It's just to see if you understand macros, and see the thought processes of the junior devs who are already hired and work on this project.
It's surprisingly few lines of code.
Fair enough, I feel like that should be clarified in your post. Asking Reddit to “solve” a test with your private dsl without mentioning it doesn’t make sense. Unless you just wanted people to ask so you could mention it. I tend to lean towards the suggestion in the community to avoid writing custom DSL’s and I’m not sure I’d consider writing macros a junior skill. But I guess that depends. I stand by the fact this can be solved with the standard library. Over-complication is like a disease these days. To each his own. 
Fair enough, I feel like that should be clarified in your post. Asking Reddit to “solve” a test with your private dsl without mentioning it doesn’t make sense. Unless you just wanted people to ask so you could mention it. I tend to lean towards the suggestion in the community to avoid writing custom DSL’s and I’m not sure I’d consider writing macros a junior skill. But I guess that depends. I stand by the fact this can be solved with the standard library. Over-complication is like a disease these days. To each his own. 
I understand what you mean. But we realized early on that trying to solve this without macros would become too bloated and overly complicated. This is the first scenario we have come across where macros actually help to simplify things, and keep the amount of moving parts down to a minimum. It's once in a blue moon. You'd understand too if you'd read the requirement specs. So we're using this opportunity to teach our team about Elixir macros in a context where it makes sense. Back to the task. I don't share the opinion that you need to know the context of where it came from, to solve it. The implementation is just a few lines of code. If you know macros, you should be able to solve it. If you don't, it hopefully sparks curiosity as to how this is possible to do in Elixir, and how one would go about implementing something like this. 
How is that even possible if you are not passing the `html` value to the `product_price` function? The way you wrote this demands it be modified to make any sense.
defmacro product_price, do: 1234
Hardcodinf product price to 1234 is exactly whar you should do for TDD
``` defmodule Dsl do defmacro product_price do quote do binding(:html) |&gt; extract_price() end end defp extract_price(nil), do: nil defp extract_price(html), do: ... end ``` Right?
So what you are 'testing' junior developers for--which seems to be a moving target in this discussion--would be, based on this iteration of the problem description, a willingness to solve a functional parsing problem with an unhygienic macro?
Thanks for pushing me in the right direction with this answer. ``` ExUnit.start() defmodule RedditSolution do defmacro product_binding do quote do if result = Keyword.get(binding(), :html) do [[answer]] = Regex.scan(~r/\d+/, result) String.to_integer(answer) else :false end end end end defmodule RedditTest do use ExUnit.Case require RedditSolution test "getter and setter" do html = """ &lt;p class='price'&gt;227&lt;/p&gt; """ result = RedditSolution.product_binding assert result == 227 end end ``` I got a passing test but I'm sure there a more simpler way for this. 
I would rather not. Like I said this would not pass review on my team. Testing whether your junior devs can decode your obfuscated code make you a terrible person. How about teaching them to write readable, maintainable, explicit code devoid of magic so I don’t have to retrain them? You are clever and that is antithetical to readable and maintainable code. The guy who inherits your code, if in fact you plan to write macros instead of functions when a function will do the job, will curse you and probably rewrite it all. 
Some recommended beginner resources: * Everything on the [main website](https://elixir-lang.org/getting-started/introduction.html) * [Elixir School](https://elixirschool.com/en/) * [Programming Elixir](https://pragprog.com/book/elixir/programming-elixir) * [Elixir In Action](https://www.manning.com/books/elixir-in-action-second-edition) * [Elixir For Programmers](https://codestool.coding-gnome.com/courses/elixir-for-programmers) Homework Exercises: https://exercism.io/tracks/elixir
(codemy)[https://www.codemy.net/posts] I found this one on reddit the other day.
I just published a package. It's an api client for football-data.org https://hex.pm/packages/ex_football
The pragmatic studio elixir course is fantastic. [https://pragmaticstudio.com/courses/elixir](https://pragmaticstudio.com/courses/elixir) Not sure if you would need to know any other programming before though, I suspect it would be ok, you can watch some of the sample videos and see if it feels out of your depth. If you want to get into web development it also gives you a great understanding of how HTTP, phoenix and web development work in general by developing a web server as you go.
nice thread! I just started learning in the last week or so, so these are great resources for me (and anybody else learning) 
I'll take a look! Thanks!
It definitely is worth the price, it assumes you are new to Elixir but they move pretty fast so if you are completely new to programming it might be a bit of work. I would say in about 20 years of programming though it is the best instructional material I have ever seen. It's a fantastic course.
I'm okay with work. I'll pause/rewind for videos and reread for literature if I'm not getting it. Google search for the things I'm just not understanding. I like following the lead and learning along the way.
Also remember that you can ask your questions in our Slack space. 
This is great advice. Anecdotally from teaching a lot of new developers to write Elixir, exercism may not be the greatest first step. It does a great job of getting you onto the nooks and crannies of a language. However the questions may be daunting in terms of required cs knowledge depending on your level of initial knowledge. I recommend trying it but don't be discouraged if it feels like a lot. It is perfectly fine to leave them and come back later. They do have a lot of value.
Alchemist camp on YouTube
How do I access that? 
I'm working on a small website/app that for browsing elixir docs and code snippets. I've just published a very early version at [https://www.elixirbuddy.com](https://www.elixirbuddy.com) \- right now it searches through modules and functions.
Yeah. Exercism is good at comparing other's solutions. The exercises in Programming Elixir are probably a better start. Also helpful are some [koans exercises](https://github.com/elixirkoans/elixir-koans) for syntax learning.
https://elixir-slackin.herokuapp.com/
What channels do I join for elixir, phoenix and programming related stuff? 
`beginner`, `phoenix` and `general` is a good start
Or on https://alchemist.camp
I'd highly doubt it, but feel free to try.
Can you elaborate? I know Elchemy's still young.
Checkout the options in vm.args. I think you have to start beam with `+Bc`. BUT. The beam swallows Ctrl C. There is no was to capture it from Elixir. I've been wanting to pull request a fix for this into OTP but haven't got around to it. If you're interested, it's in the C code of the `shell` module.
Sorry for double post but check out a hex package called `muontrap`. We use it in Nerves and it might be what you are looking for
Sadly, this doesn't help. Docker is too much for it. Thanks for bothering!
No Erlang VM interop is a big deal
Thanks for this and we're as well! What I'm not getting is what exactly happens when I `ctrl-c` out of app? Logically, imo, it should sigterm the process. But it seems like it's not, as sigterm is properly handled in Supervisor scenarios. And, as a really bad (but probably working) solution, maybe wrapping the escript generated app with bash(or python) file that can handle the `ctrl-c` call and manually pass sigterm to the elixir maybe worth a try? And if so - can I simply catch the sigterm inside my current process instead of going through the whole supervisor -&gt; child hassle?
A statically typed language for the Erlang VM :) https://github.com/lpil/gleam
I'm the author of Gleam. Happy to answer questions :)
Both feature straightforward Erlang/Elixir interop. 
It is not possible to catch it even with the new `os:set_signal/2` in latest Erlang/OTP?
Is there an elixir compiler that allows mix to compile gleem if I wanted to use it for only a certain module or modules?
Then what does lacking Erlang VM interop mean?
This is pretty much how programming goes: thing does not work right, get frustrated, figure out how to fix thing, feel great, move to the next thing, repeat forever. I find it interesting that you picked Elixir for your first language. Why did you pick Elixir?
That's great. Keep at it! I've been a professional programmer for about 6 years now. I just wanted to say get used to the whole trial and error thing. You're always going to get to a point where something breaks or doesn't work and you just have to keep at it until you get it. Then you learn from it so next time you have a better idea of what it might be, or be able to help someone else having the same problem. I'm pretty new to Elixir/Phoenix as well. Even though I'm experienced with other languages and technologies, I too hit many snags getting my first real Elixir/Phoenix project off the ground. It's just the nature of learning new things.
From everything I've read on dynamically typed, functional languages, it seem they tended, in many ways, to have the most versatility. That, and the simplified syntax of Elixir. My first option was Ruby until I read deeper in Elixir. It's a hobby for me to pick up a language. I'd like to build websites for my wife's interests and projects at some point, and possibly some business ventures of my own, and wanted to learn something that'll be versatile and fun. I know that learning Elixir isn't the end of it. If/when I make it through, I'll probably still want to learn some JS, along with HTML and CSS. I might even want to learn an OOP language at some point, to round myself out a little. But until then I'll just keep on trucking through the Elixir stuff.
I'll try to have a look these days. How much time do you reckon it would cost someone?
What's cool about JavaScript, is that you can use it as an OOP language *and* a functional language. Most tutorials out there tend to treat JS as an OOP language and the code examples reflect that. So you might end up learning how to use an OOP language just by picking up JS.
I totally recommend reading this book: https://leanpub.com/elixir-elm-tutorial It's fresh. I purchased it myself when it wasn't updated yet. I emailed the author and we got to talking. Totally cool dude. He said the update is almost ready, like 70%. But I decided to proceed with the old version of the book anyway, later on he pointed me to the draft of the update and I followed the update. I had some frustration with putting phoenix on Heroku but I got it through when the update came online. Can't recommend this book enough. The book is inexpensive which is a big plus. Another plus is that the author is updating the book which is really important. Big + to you for starting with Elixir right away.
Not yet, but there will be. Being able to add Gleam incrementally to an existing mix or rebar3 project is a priority.
I think puppet_pals mistakenly thought they did not have interop.
That's actually a major downside to JS as a first language. When there's so many things you are trying to work out how to do, it's best that there's only one 'correct' way to write code - simplifies a major thing.
I guess two per month is more than enough. 
Jose Valim recently talked about the difficulty of adding type checks to the compiler. What allowed you to do so that Elixir choose to do differently? Do you disallow multiple return types like Elixir/Erlang can do?
Elchemy creator here. Glad you're interested. Happy to answer any questions Regarding the side-effects - there is no \*official\* elchemy way of doing side effects, because we felt like all of the solutions had too many trade-offs: Traditional Elm way sacrifices the readability and drastically changes the way you'd have to structure your app. Erlang/Elixir way on the other hand would sacrifice the declarativity of the code - or at least the separation of the side effects at least. Take this as an example: ``` let a = someEffectfulFunction 10 b = someEffectfulFunction 20 in 0 ``` In this example do we execute `a` and `b`? If we do then in what order? (let..in doesn't enforce the variables to be in a top-down order). Because of that it's not obvious how to solve the representation of the side-effects There's a plan of doing algebraic effects but it seems it's too much effort both on the implementation as well as the paradigmatic side However, the freedom of the interop in Elchemy allows you to implement side effects in any way you'd like. The only caveat being - it's your own implementation and not the *officially supported* one
I'll take a look! Thanks!
The problem with adding a strong static type system to Elixir is that it would dramatic restrict the language, many valid programs would no longer compile, which would be a painful developer experience. I think a good approach here is to use gradual typing as languages such as Typescript and Python do, enabling developers to adopt as much or as little static typing as they want. The gradualizer project is a good stab at this for Erlang and I'm very interested in where it goes. Personally I'm interested in going all-out with strong static typing, which is why I'm creating a new language rather then augmenting an existing one. It's semantically very similar to Erlang or Elixir, but trades flexibility for compile time guarantees. The current type system supports returning multiple types by wrapping the values in an enum (aka an ADT) in a style similar to ML influenced languages such as Haskell, Rust, OCaml, Elm, etc
Have you considered adding an IO type with a monadic interface to sequence the effects in the correct order? Similar to how Haskell does to get around their laziness problem.
Yes. That's essentially what I mean by the "Elm way". IO Monad and Task/Cmd concepts are not that far apart and after all of the experimentation it looks like this is the way we will eventually go with
Thanks! So would you recommend Elchemy in production?
That's true, it's a strength for advanced programmers, but a weakness for beginners.
Thanks for open sourcing. Looks like a good interface and it's definitely of use to me
I'm unclear how you can decode JSON without the entire document. You can certainly decode inner parts of it, but imagine the pathological case of something along the lines of: { foos: [ 1, 2, ..., 1000000000000000 ] } There's nothing I can do until I get to the end of that super long list. 
The advantage of this is that it streams the data while decoding - meaning it does not have to load the entire JSON and its decoded value into memory. &amp;#x200B; While it's fast, you won't use this just to get small JSON documents decoded faster.
The post details a situation in which a binary contains multiple JSON objects
Right, and that wasn't my confusion. My confusion is that until you read the very last line of the input, the "inner" parts are not valid JSON. There's no way of escaping holding the entire document in memory before decoding, as decoding is done on the entire document. 
Nope, not really. But I wouldn't recommend Elm for production either. Elchemy, however, is designed on purpose to be able to be removed from a project with a minimal time and effort cost. It can be removed and the generated Elixir files easily used without Elchemy. The code is readable so it can be modified by hand afterwards as well
Right but if the next key after `foos` was `bar` and all you needed was access to `bar`, you could just specify that in your JSON path and allow the parser to skip all those tokens and only create objects in memory for the `bar` key, rather than creating the `foos` and then immediately garbage collecting `foos`. This isn't something everyone will need to do but when you need it, it will be really valuable.
If the input contains multiple documents then you can stream each document as they are parsed.
I see -- what are the roadblocks then? 
&gt; we needed to be able to parse multi-GB data without holding the whole file in memory I am new to elixir. &gt;&gt; Jaxon.decode(binary) When this is done, doesn't its in RAM at this point ?
&gt; But I wouldn't recommend Elm for production either. How come?
PAPYRUS?
Not even tribal coloring this time. Absolute madman. 
In the [Real-time Market-Data Updates with Elixir](https://www.poeticoding.com/realtime-market-data-updates-with-elixir/) article, we have seen how to build a Coinbase WebSocket client and receive real-time trades. In the comments of the article, a reader asked how many trades we receive per second. In general, the rate of trades depends on the product and the time of day. In this article we start to see how to aggregate these trades in real-time, using the GenServer behaviour. We'll build an aggregation process that groups and count the trades.
And here is part 2: [http://www.matthewsecrist.net//building-a-basic-http-server-with-elixir-p2/](http://www.matthewsecrist.net//building-a-basic-http-server-with-elixir-p2/) &amp;#x200B; Its my first attempt at writing a tutorial, so I would love some feedback!
Hey, nice articles. Quality examples you put in there. Just curious, and quite nit-picky, is there any reason you chose to represent the todo state as a List rather than a Map keyed by id? It seems like that would have simplified all of your `Server` methods significantly. Either way, thanks for putting this together :)
Honestly, I didn't even really think about doing it that way, Definitely makes more sense - I'll look into updating it in the future. Thanks!
My comment isn’t intended to take away from the time and effort you’ve put in... Maybe this is me being a bit grumpy, but I figured from the title that this would be lower level. You seem to be just using plug? My point being that Its actually a tutorial about using plug, not doing anything with sockets or parsing http requests, etc.. which is what I thought it would be.
It's prefect when two million browsers calculate there own diffs. And it's awful, when your one server is doing this...
what will be the distinction between whistle and liveview ? Is it for the same use case(s)?
Thanks for the feedback. I was more of aiming on how to get a GenServer to interact with plug and cowboy. Looking around, it seems most articles like this are using plug and cowboy as well, so maybe doing one like you stated would be a good idea. I’ll look into it and if I decide to post something, I’ll let you know!
I’m pretty into this, very cool. It’s super unconventional so you’ll likely see a few sharp reactions but I wouldn’t sweat it too much, this is great stuff. Have you thought about lifecycle methods? Is there a way to have small stateless bits of views (components)? Would importing components be as simple as calling the view function of another module?
Each Elm version is aggressively backwards incompatible. This year we're experiencing yet another huge game-changer (0.19). And as far as previous changes were mostly due to changes of fundamentals Elm is built on (f.i 0.17) this time the change seems to be quite obviously focused on debilitating extending of the language (we're basically back to a dependency white list) It made a lot of people angry and rightfully so. Many developers convinced their companies to move to Elm but the version changes force them to scrap **huge** parts of their codebase and at the same time discouraging companies from using Elm in production. Which I've got to say is a pity. Unless we see Elm 1.0 at some point or see an "Elm revolution" it seems that elm core team will never allow Elm to exit a stage of "not ready yet" language 
haha, you lucky bastard having a functional programming language as your first one, you may build some unique perspective on programming without bias from all those non-functional languages.
How does it compare to Elixir in Action
I haven't seen enough of LiveView to know the full scope of it, but both projects cover roughly the same use cases. There are differences in the how we go about it though, a few are: * Different API, Whistle is heavily influenced by Elm * With Whistle, you can mount any number of programs anywhere in the page, just like React. I believe LiveView works like a Phoenix View from what I have seen so far * Whistle diffs the DOM in the server and sends patches to the client, instead of sending the DOM and then using morphdom in the client * Whistle doesn't depend on Phoenix, it works on its own, although it can also work alongside Phoenix * The way component state and session state are handled is also different. Most of this will change in a few months, as I want to build Whistle to do much more than just render components.
Thanks! You can achieve small stateless components by making plain functions that return a VDOM structure, so you can split and organize your components however you want, and share them.
I don't think its that big of an issue and it depends on your use case, but yeah, this is early days, still need to test and prove the concept can work at scale.
Thanks for the details. Great work!
Oh my god, guys, stop. I can't watch them all, I don't have that much time. An they are too good to miss ;(
I haven't read Elixir in Action. But looking at the content of tables the difference is Elixir and Elm is more about Phoenix and Elm tied together.
Thanks this was a nice demo of how some simple concepts can be powerful together. 
Thanks, it’s just me though
Keep going man.. these are wonderful!
I just put the finishing touches and pushed a state machine library: &amp;#x200B; [https://hexdocs.pm/statex/Statex.html](https://hexdocs.pm/statex/Statex.html)
Nice work on your journey so far. You will have no regrets learning this stuff. You'll probably get multiple good answers but mine would be: 1 - Build a simple chat app with a room and multiple users (creating chat rooms and distributed caches etc.. to learn a language may seem strange but its easy in OTP in terms of amount of code so there's lots of examples) 2 - Use distillery to create a build and deploy manually somewhere like AWS. Learn about vm.args and the .config file for syncing nodes. Getting the channels to work across machines is pretty simple but has some setup gotchas 3 - Use the newly revamped dynamic supervisor to create something. Maybe a user session cache? 4 - Build anything but do so as a separate app and add it to your phoenix sites supervision tree
For #4 doesn’t Elixir and Phoenix operate best under a more monolithic structure? I’m also very new
Erlang has a huge breadth, so there are many things that you can learn. You could look at building an app backed by ets, dive into supervision and building out process trees, build an app which can work with multiple nodes working as a whole (With typical apps, you scale things horizontally by spinning up multiple servers which work independently, However in some distributed apps you'll store data related to clients in memory e.g. ets building a truly distributed system in which each node is aware of all the other nodes isn't very straightforward and will teach you a ton about how to build performant apps.
it can be monolithic in the traditional sense, but what makes Elixir different compared to other languages is you can build micro-service style apps and let the supervision tree handle keeping them alive. then you can deploy it as if it's one single app, and you get some of the benefits of both monolith AND micro-service. don't go overboard though, so far I've basically not added any new apps to my Phoenix server (lol except open source libraries)
+1 to this. Learning distributed Erlang is the fun part. 
Yea lines up with what I imagined, makes sense. Thanks
I've been evaluating the code for use in one of my projects but I had to fork and right tests to satisfy my sanity. I like the lib overall.
Elixir can even cure cancer
Probably not :( though that would be nice 
This is kinda dumb
What costs more energy - a fraction of a CPU in a datacenter that's already churning away, or days/weeks/months of supporting a developer, their commute, keeping them warm/cold, feeding them, etc.?
Maybe not curing or cancer, but there was that talk at ElixirConf about the guy who made a device for his wife to help manage her diabetes using Elixir with Nerves. That was pretty awesome.
Username checks out
Reddit cliché noticed: Username checks out Phrase noticed: 2815 times.
Well if they work remotely then the commute goes away, which certainly reduces their carbon usage. Also, one could argue that Elixir projects require less developers to maintain, so another efficiency boost. If you want to be nit picky I’m here all day :D
I’m running a Pleroma instance on Digital Ocean, I’m always astonished at how little CPU power it uses
Multiplayer browser game! &amp;#x200B; [https://github.com/hassanshaikley/stabby-flies](https://github.com/hassanshaikley/stabby-flies) &amp;#x200B; [https://meaty-spiffy-hermitcrab.gigalixirapp.com/](https://meaty-spiffy-hermitcrab.gigalixirapp.com/) &amp;#x200B; : )
what kurtome said. Also read this. I don't follow this religiously but it should be a good read for you https://pragdave.me/blog/2017/07/13/decoupling-interface-and-implementation-in-elixir.html 
It's very similar to: [https://blog.lelonek.me/minimal-elixir-http2-server-64188d0c1f3a](https://blog.lelonek.me/minimal-elixir-http2-server-64188d0c1f3a)
This sub is flooded by posts like this by OP. Legit going to make me unsub because of this spam. Like I totally get promoting your content but this spamming at this point
Reddit cliché noticed: Reddit cliché noticed Phrase noticed 25 times. ^I'm ^a ^bot, ^beep ^duh. ^Message ^me ^if ^you ^want ^to, ^I'll ^tell ^the ^code ^monkeys
It'll never use less than natively running code like from haskell, rust, D or even Go
Google “elixir tcp example”. Click the first link,
TCP is typically handled handled by the the network interface card (NIC). The NIC typically handles the assembly and disassembly of TCP frames. To communicate to the NIC in a user space program (such as beam/elixer/erlang) one must execute a system call to the linux kernel and create an AF\_INET socket. The kernel then maps a small bit of kernel memory into your running environment, allowing you to send data to the socket. In elixir, this socket opening is handled by :gen\_tcp [https://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html](https://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html)
`:gen_tcp` is definitely the way to go for a basic TCP server. If you need more features like connection pools and whatnot, check out Ranch: [https://github.com/ninenines/ranch](https://github.com/ninenines/ranch)
Specifically you want to look into Ranch’s listeners and [protocols](https://ninenines.eu/docs/en/ranch/1.7/guide/protocols/). I’m using this approach (gen_statem and all) for a multiplayer game server, and it works a treat.
Learn more always make you better
Learning anything about programming will probably make you a better programmer. I think both React and Elixir sort of use FP in one way, which is making it easy to understand code without like **really** understanding it. Imperative code usually requires you follow everything and know all implications of lines. Functional programming can be a lot more declarative, so even if you don't know *how* something is done, you'll know *that* it's done. This makes the code a lot more readable, but I wouldn't say that simply using it makes you that much of a better programmer. A disclaimer that I don't know Elixir that well, but at least using Ruby doesn't make you a better programmer. It's intended to be used by people who want to be able to get stuff done without understanding a lot. Effectively, the authors of libraries have used FP and metaprogramming to create a really nice DSL. If you want to learn FP to learn how to be a better programmer, I'd go with Lisp or Haskell. &gt; seem like Reactjs has a good mix of imperative + functional, would make a good pattern for a future language There are a lot of languages like this, actually, including but not limited to JavaScript. ReasonML, Elm, and Haskell are all very close to the ideas represented by React, though they don't usually rely on imperative constructs. Some languages that are well-known for using both imperative and functional very often: Rust, JavaScript, F#.
React has nothing. JavaScript has functional programming capabilities.
'Better programmer' is very subjective so that's hard to say. Learning FP concepts, in any language, gives you more options on how to think of solving problems, so in that sense it makes you 'stronger' as a programmer because you'll have a more versatile understanding of what you can (and can't) do in your solutions. IMO.
I don't understand what this has to do with Elixir. Looks like a functional wrapper for Python.
&gt;Coconut is a functional programming language that compiles to Python I feel the exact opposite about this that I did about Efene.
Yes I think it does, if your fundamentals in another paradigm are rock solid and even more if you have some experience maintaining mid-size to large application... The reason is simply because you can better understand trade off, pitfalls and qualities of both paradigms. Even better you can ask and look answers to pragmatic questions (refactoring, maintenance, design ...)
Compared to OOP, FP enforces immutability, declarative style, and it encourages modularity and unit testing, which I'd say are all objectively good things. Even if you return to more OO languages like JavaScript, you can still use these habits to write better code.
Not much more other than pattern matching and pipes
yeah, it's really not "Python + Elixir" at all.
By definition, learning more about programming and computer science will make you a better programmer. But yes, I think so. It has helped me a lot, at least. 
yeah 
My perspective is that say that 95% of programmers learn imperative languages first. You see some differences between Java and Python, maybe you go lower level with C or what not. You could use these language for years and still keep getting better at writing idiomatic code, making the architecture clean etc. You still make progress as a developer. Then you discover functional programming, and as you learn its principles, new pathways open up in your brain that is used to imperative programming. While you learn this new tool, pieces pop into place. At some point you realise you don't really need to use a functional language to apply some of the FP principles to stuff you know and use on a daily basis. This doesn't mean you need to throw monads all around your Python web app, still just looking at how FP programmers decompose problems makes your brain tick in a different way. So, does learning a FP language make you a better programmer? Sure, but there's nothing special about FP with that regard. As a craftsman, the more tools you know, the better you are at what you're doing. &amp;#x200B;
is this necessary ?
This! You can tell if an OO coder has experience with FP, if they don't mutate objects mindlessly, they do grok recursion, _etc_. Being able to write OO in a "functional style" is yet another tool to reach for from your toolbox, so yes... FP will make you a better coder. 
Fascinated when I encountered the phrase "Functional Programming" in reference to Redux my first question was "Isn't all programming functional?" then I began researching it and got genuinely curious and motivated to study it more. Now about 2 years into it I can confirm it has made me a better programmer and engineer. &amp;#x200B; When I started learning I was really in the weeds with OOP and wanted to abstract, generalize, and use all those fancy OOP patterns everywhere it made sense. The problem is whenever you create a custom class in most languages, it's incompatible with everything else. Even in JS if I extend an array class it's often treated as a separate thing. So you often have to write more classes to make two classes talk to each other. &amp;#x200B; In addition to those layers of abstraction for OOP I think there's no upper limit to the complexity you can achieve and the vocabulary to describe OOP systems. Getters, setters, public, private, accessors, attributes, methods, virtual properties, constructor overrides, generics, magic methods, over loading, dependency injections, super, child, inheritance, the list goes on I'm sure. &amp;#x200B; With functional programming I find it has a pretty fixed amount of concepts that make up the methodology: &amp;#x200B; \- Immutability \- Pure Functions \- Referential Transparency \- Composition \- Higher Order Functions \- Core Data Types \- Functors \- Monads \- Point Free \- Map, Filter, Reduce functions &amp;#x200B; I'm sure I'm missing a couple but those make up majority of what I've encountered in functional programming so far and definitely help you move quite far. &amp;#x200B; What's great about learning those is that they all build on each other where as a lot of those OOP concepts are kind of parallel to each other where you can learn one without knowing the other. &amp;#x200B; There's two major camps that functional programming falls into. Admittedly these are my own terms so someone should correct me if there's better words: &amp;#x200B; Practical Functional Programming - Languages like Elixir and Clojure fall into this camp. They leverage dynamic types and focus on creating pipelines of functions to transform data. &amp;#x200B; Academic Functional Programming - Languages like Elm, F#, OCaml or Haskell fall into this camp. They emphasize type theory and other mathematic principles to leverage monads, or data types that represent computation builders to do most of the work. For instance the Array type in JS is a monad, it can be mapped to an array of other values, packed, and unpacked in itself. &amp;#x200B; In so far I don't strongly feel one camp is better than another, I've just noticed that functional programming languages tend to lean to one side more than the other. While I've chosen to focus on Clojure and Elixir for now, I'm also interested in learning and hearing about Haskell and Elm. &amp;#x200B; As far as improving as a programmer and engineer I've learned how to reduce complexity in the work I produce by composing larger systems from smaller functions that have very specific jobs, often aimed at expressing a domain-specific goal with pure functions as much as possible. This means fewer surprises for other programmers and stronger testability because testing something like \`add(1, 2)\` is much easier than testing something like \`this.router.handleRoute(window.location)\`. &amp;#x200B; Instead of trying to make more complex data types like I did when strictly using OOP., I find myself mostly leaning on core types. Elixir is a great example, it has many functions and modules that know how to operate on lists but none operate on the class we call \`Bid\` at work. Those functions and data types are part of core Elixir and are well tested and documented. &amp;#x200B; My favorite thing about FP is how universal those principles are, I can apply them to Elixir, Clojure, Python, Ruby, PHP, JS, and I'm sure even more languages out there. Transitioning between functional programming languages feels like it has become easier too. &amp;#x200B; I've found myself able to move faster with FP languages as well, I'm able to read the source of major libraries in languages like Clojure and make contributions despite only having about a year of experience with it. I've been using JS for like a decade at this point where there's many libraries I can barely make heads or tails of. It's not that they're bad, it's just more difficult for me to understand the intention of the code are and find room for improvements at achieving those goals. Much of what's out there is very side-effect driven and organized in larger chunks of business logic. For instance at work our Bid class has methods like accept which updates db state of several models, sends several emails to clients and partners, and populates another dependent model representing proposal data. It feels like a lot but I'm unsure what I'm unsure what the real goal is. &amp;#x200B; Lastly, I like how you can model real-world domains in FP. It feels more intuitive to me and I think is easier to explain to other people outside of the tech industry. [https://pragprog.com/book/swdddf/domain-modeling-made-functional](https://pragprog.com/book/swdddf/domain-modeling-made-functional) is a great book on that topic and raises a good point that OOP does miss the mark in a lot of places, especially when you inevitably need classes like BidManager or PageFactory that don't really map to anything in the domain. &amp;#x200B; I hope this is helpful to someone, I know it's a lot but I've been wanting to share these thoughts for a while on the subject. :D 
Is it really functional ? If all python is valid in this lang that means OO features work also.
Thanks for this. Great read!
I kind of feel ruined by functional programming. Every time I end up in Python or a similar language, I feel frustrated that I can't write what I want to write.
Many small time make big time
Hey, thanks! Glad you've been enjoying it.
Many sucky time make good time
Lots of information. Please, please publish this properly. 
Since you can't use Timex you'd need to do that manually. To format the month, yeah, just use a map with the number and month's names. For the formatting you can simply do: ```elixir iex(12)&gt; date = NaiveDateTime.utc_now() ~N[2019-01-04 17:28:48.762368] iex(13)&gt; Enum.join([date.day, date.month, date.year], " ") "4 1 2019" ``` 
Why won't a library work for you? Time and date handling is the perfect example of code you should never write yourself as there are too many ways to get it wrong. Timex is the library for this sort of thing, but not every library ought to be in the core set of modules ... given that libraries get bundled in to your app, it is not a deployment issue, either.
you idiot? you came here to persuade me? the question says "no libraries". whatever the reason - it doesn't matter for you. 
re-read my question
? I said you’d need to do that manually as you said. I just provided a little example. 
No, I asked a question, and further explained why I would ask. You asked what the standard way is, if there is lne, and that happens to be "use Timex"... BTW, you will generally find the Elixir community to be an open and kind one. Calling people idiots is unlikely to get you very far there ... Cheers...
&gt; No, I asked a question, and further explained why I would ask. you're not to ask the questions. you're to give answers. if you don't know one - fuck off
thx
Presence of OO features doesn't mean the language can't be functional. It's not an either/or thing. F# and Scala support both functional and OO features.
I've been slowly slapping together some libraries I wrote nearly a year ago for an application I want. Goal is to be able to take a post from a recipe blog, extract the recipe and display it in a consistent format. &amp;#x200B; So far I've written a [microdata parser](https://github.com/bees/midal/) and a [crappy wrapper](https://github.com/bees/ipt_wrapper) for a crf toolkit (attempts to extract name, quantity and unit information). I've just written a thin-slice POC and it works but it's incredibly brittle, I'm going to need to spend a bit of time building a pipeline that massages data into a consistent schema since it varies wildly from blog to blog. This is my "Learn Elixir" project so feedback/critique is very welcome.
wow. &amp;#x200B; May your tail call optimizations fail in subtle yet spectacular ways. 
What do you want to focus on? The phoenix book helps you make an app from a really straightforward perspective. If you know elm already then yeah, learning how to configure webpack ( 1.4 ) or brunch ( &lt; 1.3 ) isn't too bad. My personal recommendation would be to follow a guide that has a deploy to your destination easily. [like this](https://www.icicletech.com/blog/elixir-phoenix-deployment-on-heroku) I would pick one thing to focus on and go from there. "One thing" would be something like: * deployment to end state * frontend tooling ( if any ) * learning elixir * learning ecto * learning phoenix Each of these areas have quite a bit of depth. However getting started with the phoenix book goes over what is easier to focus on to get going. 
Elixir and Phoenix really aren't doing that much for your front-end so to speak. They should be rendering a template view of html/css/js page and with data for you. The more powerful aspects of the front end are in the html/css/js. What are you trying to do? Elixir and Phoenix don't have the maturity of the Rails ecosystem yet, but are much more powerful in other ways. 
Run it on Heroku for deployment... that will make life easiest while learning. Ecto for DB (ERM) Front-End could be React, Elm or good old Jquery depending on the complexity of the website. If you're starting out learning, keep it simple silly (KISS), tackle one chunk at a time. 
I'm also interested with elixir (mostly Erlang to be honest) but since I'm already into ruby it's well came.. If you want to do web stuffs as mentioned, you must "master" the whole "web" ecosystem, at least HTML/CSS and the related HTTP stuffs (I mean knowing what's happening under the hood with request, sessions, cookies etc...) It won't hurt.. Then about programming _per se_, because you want doing web stuffs, you will not have the choice and should learn programming in JavaScript too (besides learning programming in elixir). And it happens that "modern" JavaScript is better at handling functional code (which would be familiar to you). However, I rather recommend you to go into more mature ecosystem. I would say rails because it's easy to start and compared to elixir (I mean ruby) it can be easier while being close in syntax so you will lose nothing. Rails has also good integration with different front end configurations. But you could also go fully with JavaScript and try ME*N stacks - _the * being any Front end framework like Angular (MEAN) or React (MERN)_ - I recommend Vue though. Express being the JavaScript backend. So, without forgetting that you should probably also learn some database systems... SQL is almost mandatory unless you really stick with Mongo (M from above stack). Once all that stuff become familiar, you can always switch back to elixir/phoenix and it will be easier with some gained experience. My 2 cents.. 
New programmer, struggling. &gt; I know I want to learn Elixir as my first language, and use it for web development, as much as I can, back and front end. Why? Elixir is a great language but it's not hat well suited for the kind of web development you're likely to be wanting to do to learn as a beginner. It'd be a bit like me saying I want to learn to use a drill as a the first tool when learning woodworking, and that I've heard a chopping board is a good place to start. Drills are great, but you don't need them to build chopping boards. &gt; I understand that it's likely that my judgement is just being clouded by all the information I'm taking in... Nope, one language isn't sufficient. That's one of the main reasons why we have multiple languages. It's also why we don't see people building critical safety systems to fly planes or control power plants in JavaScript, and why people aren't writing websites in C or Java. &gt; I'd like to start building web pages now, even if they're novice. Then go learn HTML. Spend a few days on it. Style it with CSS. Don't bother with any JS or any libraries as you just want the basics. Once you've got a handle on that, start writing elixir using Phoenix. It's well documented and will give you a great entry into writing backend code in Elixir. So, now you've got a backend server written in Elixir, and you know how to write a static webpage in HTML. Now you can combine those things and use Elixir and Phoenix's views and templates to write code that writes HTML. This is shipped down the wire to the user, and you've got a web app built using Elixir.
tow!
u/kazzaru does this on a lots subreddits. He begs for help in his ridiculous problems, then harasses everyone that tries to help him.
If visualizing your work is the thing that makes you be able to stick with learning, learn Typescript/JS and React. IMO the modern frontend stack is way overused, a lot of applications don't actually need the whiz and bang. Rendering HTML on the server by banging together Elixir and SQL (or Ruby on Rails, still very productive) is super effective at solving actual problems. It's also worth noting that from my perspective the market is flooded with junior front-end devs that don't know SQL or don't understand REST/GraphQL/etc. Since you are likely learning for monetary reasons, it's worth considering. All that being said, if visualizing your success makes you happy and fulfilled, go for the frontend, the modern React stack is very powerful for building interactive applications.
While a bit "pointed" of a comment on your part, it's also just that; to the point. I appreciate your input and your recommendations are logical. I'm still not decided quite yet on how I'll proceed from here, but I'll be considering your comment as of that process. Thanks again!
I appreciate your thoughts. But as a correction to your assumption, I'm not in it for the money. I'm in it (at least at this time) for the enjoyment of learning. But I'd like to be able to see what I'm doing at work. I'm sure I'll want to learn JS at some point, but also from everything I've read, that's a very deep rabbit hole I'd be getting into, and I'm not quite ready for that. I believe there are other languages I can use to do similar effects without the complexities of JS. Elm is an example of a language I'm considering. But again, I do appreciate your thoughts. :)
I appreciate your thoughts, but I'm interested in learning a functional language first. Ruby was certainly at the top of my list when I first came to the realization that I wanted to learn a language, particularly for web dev, but I've since refined my language search to wanting to learn a functional language as my first. That's why Elixir was the original winner. Now I might be considering Elm. Starting there and learning to build Elm on top of Elixir, later on though of course. Get the front end down, and then work backward, is what I'm thinking. I don't mind putting in the effort to learn, and having it be a little difficult because lack of maturity, or a slightly "lacking" ecosystem. A challenge keeps it interesting. But I think my beginning efforts probably will lead me elsewhere from Elixir for a while. Thanks again though!
You're not wrong, it is a lot to put in your head, but there are a bunch of tutorials you can struggle through and get actual interactive apps working, way more React ones than Elm ones. Ultimately Elm compiles to JS and generates HTML (usually), which is styled via CSS. I think focusing on visual stuff would be good for you, but you're gonna need to learn the web stack regardless if you're going to be using a browser. There are some other types of visual development but I think they're probably more complex than the frontend to get going; frontend is well-lubricated for newbies, which is why the market is flooded as I mentioned. And good on you for doing it for the enjoyment, have fun!
Check out https://gigalixir.com.
I highly recommend learning Python or Ruby first so you can understand the concept of programming. It is hard to learn a new language without knowing the concepts of programming in general and Elixir is somewhat difficult to read in understanding those concepts. On the flip side Python (and Ruby but it's on the decline) is the easiest way to read and understand code and you have a huge community and tons of resources to latch to. Once you get grounded, you can swing back over to Elixir. 
\&gt; But how do you reconcile the feeling that one language doesn't seem to be sufficient for everything you'd like to do? You don't. That's a life of a web developer. No matter how many hours upon hours you sink in, they'll always be something else out there. A new technology, a new methodology. Oh you learn front end and backend? What about UX? What if you need to make some visualization... you know d3? Oh wait, do you know enough devops? Oh ok you know all of that... you know how to version control it with Git? Oh wait... do you know the best editor for making all that code? Ok ok wait but.. how about mobile? Damn gotta learn Swift... but what about React Native? Oh wait, maybe Flutter? \&gt; My problem is that I like to learn by doing. Yup, and welcome again, to the problem we all have. The best way to learn is by doing... which is why, when companies are looking for people, they specifically ask how many years of experience you have working with a particular technology. You learn by doing, by finding stuff to build that you're passionate about... part of the problem there, is finding stuff to be passionate about, or that you would find really fun to make. Ask around for ideas, and really meditate &amp; think on it. Once you find that thing, then you have something to drive your learning (same as work experience). Also: join [exercism.io](https://exercism.io) \&gt; But as it stands, it seems like I need more than Elixir to start the projects I want to start. Elaborate. Can't really help without you elaborating further. The reality, is you can't do a website top to bottom, without learning multiple things. There IS no way to get around that. The real answer though, is... to not do it top to bottom. So for me, I first started with css... most css guides will teach you enough html to get started.... so I had my index.html file, making divs, buttons, and styling them. Then I learned much more about html... cool, now I have a wider language of html, that's semantic, that I'm styling. Then I learned photoshop.... cool, now I can add images to my index.html file and css. Then I learned a bit of php and server stuff... cool, now I have an apache server running, serving my index.html file. Then I learned jQuery... cool, now I can do dynamic stuff with this index.html file... and then from there, I worked on stuff that interested me. At the time, it was customizing my [myspace.com](https://myspace.com), and following tutorials that had me creating sites from a design (here's how you make this 2 column thing, etc). Then eventually I got a job, and they needed help maintaining their eccommerce presence on ebay... cool.. and then I went from there. That's how it works. But yeah web development takes a lot of self drive, and there ultimately needs to be an ability from you, to get passionate about something, and figure out baby steps to get there. That's a skill necessary for web development in general, if you ever get to a place where you're doing this professional anyways. Pick a point to start at, and just start. If you absolutely cannot think of anything, make a todo app, make a portfolio site, make a hangman game, make some "choose your adventure game" CLI game, make some interface that hits an api for you... it really doesn't matter, but the longer you don't pick something, the longer you will spin your wheels and get bogged down by the overwhelmingness that is web development. Pick something and start.
Why a functional language? From what I’m reading it seems like you’re clinging to buzzwords (no offense) without the experience to understand what’s happening under the hood that makes the languages work the way they do. Elixir is a fairly difficult and confusing language to learn and the issue of a lacking ecosystem is a big, big deal. JavaScript, python, and ruby are much more welcoming and have lots of resources online whereas with elixir you might get stuck on something that is fully impossible for you to solve given what’s available to you. 
My mind already operates as a functional system. Multiple cogs making up the whole machine. Everything I do and plan in my life are multiple functions, put in the proper series to make things work. It's not just a buzz word if that's how one already thinks. Thanks for your input though. 
I get where you’re coming from but what I’m trying to say is that all languages have functions. Understanding how things are stored differently in the computers memory and the kinds of issues a language like elixir can both prevent and cause if you’re not careful should be a major factor in choosing to learn it or not. That is the difference between a language that’s procedural and truly functional. Anyways, you’ll learn the most by diving in and trying it out! Good luck to you 
Thanks for the replies everyone!
yes, so what?
I have deployed a few apps and do all my deployments on Digital Ocean using Dokku. Like a lighter free Heroku and just as easy. [https://gist.github.com/col/a509ee4b73cecb347c97](https://gist.github.com/col/a509ee4b73cecb347c97)
# Really?
If this is your first app I’d suggest keeping things simple and not using any front end code and waiting to deploy until you have something you want to release to the public. You can build sophisticated apps with nothing but Phoenix running on your local computer. 
If I may suggest something a little different, perhaps reduce the scope of what you are trying to learn. Make a web page with html. Learn to program an arduino. Keep doing small things and before you know it you’ll have the skills to tackle a web stack. And don’t be too worried about choosing the right language or stack to learn. They’re all built on a common set of ideas. Even OO and functional language share a lot of ideas. 
I was just warning everyone here to never help you. I suggest that the mods ban you from the subreddit for abusive behavior that clearly violates the rules of all the subs you post in. 
Elixir is a bit daunting for a first language because most content on learning Elixir is geared towards people who already know how to program. Also, as you've stated, it's not really the right tool for front end development. At this point in time, front end is Javascript/HTML/CSS. If you want to learn full stack and create things you are proud of, there's no getting around learning these. I've seen you mention you like functional programming; Javascript can be used as a functional language. You can also use Javascript on the full stack, with a Node back end, a MongoDB database, and a regular JS/HTML/CSS front end. Maybe not something you want to hear, but you will learn faster, struggle less, and get results more quickly by learning web development this way. You can also look at the Ruby ecosystem, but I'm not as much of a fan of that because there's a lot of "magic" hiding how programming works from you, although Ruby is a cleaner and better designed language. As others have mentioned, Python for you backend is a great way to learn. It requires you to set up all of your configurations yourself, so it's good for learning. Still, I think just getting a bare bones http-server from Node, serve some static HTML pages yourself, and boom you have a website in like 5 minutes.
&gt; I was just warning everyone here to never help you Idiot? Who am I?
Gigalixir is probably the easiest to get set up with as it's designed directly for this. I chose Google Cloud for my company due to the whole ecosystem. App Engine Flex supports elixir, and Cloud SQL does Postgres. Wasn't too bad to get going.
Genstage consumers have state, you can use this to store the records that didn't fit into the last update. Then just include them in the next update, rinse and repeat.
&gt; How do you reconcile the feeling that one language doesn't seem to be sufficient for everything you'd like to do? I was reading through your post and this is what jumped out at me. My advice would be that there's no language that is sufficient for everything you'd like to do. They all have strengths and weaknesses, and it depends on your project as to which language you choose. Anyone who tells you to select the same language for everything is being a little naive, IMO. &gt; It seems weak for front end work Well, that depends on what you mean. If you're talking browser land itself, then of course, because browsers can't run Elixir and you're going to be stuck with JS for a while - that's true of any language, basically. If you mean things like server rendered templates, or that type of thing, then I'm pretty sure there's plenty around (definitely in Phoenix, I think). Since you said it would be for your first language, I'd recommend you get a decent handle of HTML and possible (browser) JavaScript if you intend on doing frontend work first. &gt; I'd like to start building web pages now, even if they're novice. So do it! Think about what you want to build, and start building it. Since you're learning, you're going to hit issues. Cross those bridges when you get to them in a use case that makes sense to you. As you said, you only have a feeling that Elixir is weak in front end. The only way to find that out is to try and build something :p 
Kinesis streams accept 1 MiB/sec per shard. You have to pay for each shard but you can increase the number of shares up to 500 I believe. It looks like you want the end result for everything to be in the stream (but you've left out what is consuming this stream). Kinesis Firehose can do 1MB aggregations like you'd like, and the end result can be in a bucket or other locations, you just have to deal with potential for slow down responses, same as the stream. If you don't want to use any of that and prefer to use genstage I think you're on the right track. 
The problem is that as soon as you reference the Repo or a particular Ecto query from the controller action, you’re just coupling it right back together again. I would prefer either making a new function, or limiting the surface area of the options that you pass to the getter function - e.g. just have an atom that you can specify for a particular preload, and actually implement the query entirely in the context as private functions.
Good feed back, I will see if I cant elaborate that idea better in a update to the post. 
No need to justify it or change anything - that's just my personal opinion. I think your idea is sound, just my approach would be different.
No I agree, and thank you. I had not really even thought about till you said something. The issue I struggle with now is how do I abstract away the repo module in my context without without making my api overly complex or too ridged. 
Similar to how your Repo has reusable functions in it, your context could, as well. Treat the preloads as a sort of "black box" such that the consumer of your context doesn't really have to know how they are formed, just that they can be used. So, in your context: def tags_preload do :tags end def approved_comments_preload do {:comments, {Comment |&gt; Repo.approved() |&gt; Repo.order_by_oldest(), :user}} end def get_post!(slug, options \\ []) do preload = Keyword.get(options, :preload, []) #... end Then in your controller: post = Social.get_post!(slug, preload: [Social.tags_preload, Social.approved_comments_preload])
One nice thing about preloading in Ecto is that you can preload separately from initially loading the data. This is because, to my knowledge, the preloading is done by extracting IDs and not from joins. Does this change the approach at all? If I can separate the preload from the fetch, I could make these distinct functions and call them only when I need to.
So this was my first thought too but my initial thought about that was the fact its returns something that can only be understood in the context felt similar to the initial issue. I guess I was just overthinking it, this is better in that it wraps the underlining api of the repo. 
I'm not really sure if that changes the approach since the preload is already composable and that its really relative to where you are calling your context from in that its then you know if you need this preloaded or that. 
after rereading I think you mean to say the same that was expressed by [Schrockwell](https://www.reddit.com/user/Schrockwell)
One difference is that I'm proposing separating the concern of preload from the concern of fetching data. It may be easier to express a variety of scenarios this way.
Having a hard time conceptualizing this. Do you have an example? 
Sure. I didn't compile this or anything, it serves mainly as an example of what I'm referring to: defmodule Social do def get_post!(slug), do: Repo.get_by(Post, slug: slug) def preload_posts(posts, :full_comments) do Repo.preload( posts, [ :tags, comments: {Comment, :user} ] ) end def preload_posts(posts, :approved_comments) do Repo.preload( posts, [ :tags, comments: {Comment |&gt; Repo.approved() |&gt; Repo.order_by_oldest(), :user} ] ) end end With this approach, you could have a `get_posts!` function which returns a list of posts and then are preloaded the same as others. You can write complex queries to retrieve the posts and not need to worry about placing your preload clause in it.
You can do both preloading with separate queries and via joins: https://hexdocs.pm/ecto/Ecto.Query.html
Oh nice. I haven't used that before but it looks useful given you can build the query up. I've been bitten by the "includes" concept in rails which will either join or separate query load depending on situation. I like Ecto approach to it seeing it supports both but it has to be explicit
Great points on what's missing: authentication and umbrellas!
Eish. Big omissions. 
We now have support for Elixir with phoenix at [https://www.openode.io](https://www.openode.io) to get started quickly. Basically you generate a Dockerfile template with one command (openode template) and then one command to deploy. Any feedback welcome!
I tried your steps for doing deployment via DO and Dokku, but I was having issues with newer versions of Phoenix (with webpack) and Elixir. Have you tried it with Phoenix 1.4 or Elixir 1.7?
I searched too, didn't find a silver bullet
I don’t have a complete guide, but: https://github.com/matthewoden/gunshotsorfireworks.com?files=1 Here’s a project I deployed to elastic beanstalk. Mostly tells people “those were not gunshots you heard.” Feel free to steal wildly from config files. http://matthewoden.com/setting-up-ssl-on-elastic-beanstalk/ Here’s a blog post I wrote on setting up ssl on elastic beanstalk, which might help. 
I like how by the time these books come out, the language has evolved to where the material is no longer best practices
We run our production phoenix app on beanstalk, PM me and I can probably give you a hand.
Sanitize in what way? Just stop additional commands from being executed (e.g. If `user_uploaded_file = "; echo hi"`), or stop wildcards (and other bash syntax, or are there certain illegal characters the program you're using cannot handle? Firstly porcelain is basically a generic interface, so I think it more likely depends on the driver and what it'll be doing exactly. The standard driver is just using ports though, but if you use something like their Goon driver then you'll need to take a look at the Goon source code. From your example however, why are you intending on using porcelain? You could just as easily use something like `System.cmd`. Porcelain is handy when you don't want to work with ports yourself, or you're communication with a program that has different termination (that isn't possible to do with ports), reason why they have the Goon driver (so porcelain talks to Goon and Goon talks to your target application IIRC). Anyway as far sanitization is concerned I believe the only function that **won't** prevent multiple commands from being run is `:os.cmd`, so if you ever plan on using that, only ever use trusted input with it. Ports, `System.cmd`, will not allow that. As far as wildcards, ports will allow wildcards (they'll be interpreted as you would expect by the shell), whereas `System.cmd` will pass the literal character (so it won't be interpreted as a wildcard). Lastly program specific illegal characters, I'm not aware of any that provide functionality. Now as far as your intended usage, as I mentioned I don't actually see why you'd need porcelain. You're just using exec (won't be maintaining an open port), and all inputs are being passed as arguments (if you were piping something to its stdin then it'd make sense). So you're better off just using `System.cmd`, which is the most secure option. Now I'd still recommend taking the precaution and creating your own file paths and using those, instead of the users path. Since there's technically 2 things you need to watch, first if any bugs make it into elixir that would cause `System.cmd` to not function the same way, and second if there's any bugs in your some_external_program that may not be able to handle the provided file paths correctly (buffer overflows, maybe it passes them to shell commands itself, or just any other application faults). 
Thank you very much for your comment. I was using Porcelain because it was the first library that popped up when using google. I'll take your suggestion and look into `System.cmd.`
I see, well the other functions mentioned are all standard elixir or Erlang functions. Porcelain is just a library to make your life easier once you start using ports (which doesn't look like you'll need for this). But as mentioned I'd still recommend not passing the user input directly to `System.cmd` as there's still potential for other exploits that may be possible in that flow. And thanks so much for the gold :D
What has changed that the material would be no longer best practices? I can only think about supervision child specifications?
Looks great, lovely UI and fast too!
if it's doing phoenix isn't 1.4 coming out some time this year? Also ecto 3.0 finalized api, not sure about sql API but the SQL api have moved to ecto_sql (this is assuming they're using ecto).
As you first start programming (especially web) you have a pretty huge hill to climb. To have any chance and creating something for the web you will need to understand and start learning HTML, CSS, JS (for static sites) and then some other backend language(s) for dynamic sites. That is a lot to tackle but many people do do it. Just persist over the curve. &amp;#x200B; It does not get better from there, those 4 or 5 pretty complex things just listed above very quickly start to grow to 50,100,500 different highly technical concerns as you start going deeper on your journey. If you do not enjoy learning (reading, exploring and doing) you may want to save yourself a lot of pain. &amp;#x200B; If you want to get into programming and limit the initial learning load, pick a language and just focus on learning the language -- stick within executions that can be made inside of that language and don't require other languages or understanding. &amp;#x200B; &amp;#x200B;
Thanks for offering your help! Do you have any experience with travis and phoenix testing in a docker container?
I don't, we actually use CircleCI run all of our tests.
Is it not the case that the language itself has stabilized even more strongly? I seem to recall, maybe a year ago, Jose expressing joy that large feature changes *are no longer necessary*. Unless of course that has already changed ;)
Do you run a docker container to test in circle ci?
We don't, we deploy with Docker though. So we'll build a docker container and pass that to Beanstalk to run.
Seriously, I love this part about Elixir. The recent changes are just date/time other than that just bug fixes and tooling (logs). Other languages such as Rust is such huge changes on top already complex languages. Erlang and Elixir are beautifully small but does a lot of amazing things. 
Thank you! I use ETS and nothing more. Parsed docs are stored in memory and I never hit the DB. 
The last few elixir books I've read were already outdated maybe a year later Not speaking specifically to this book but elixir books in general ;)
&gt; What are some good projects to familiarize yourself with Elixir? I was doing some leetcode easy problems which I am not sure is even a good way to learn elixir and its strengths. Problems are a good place to start getting familiar with the language. I suggest trying to implement some of them with the helper functions elixir's standard library provides (like those in Enum) as well as without those. When you're comfortable with the latter, if you find you're writing a lot of code with if/for/cond etc. try having a go at moving a lot of that logic into your function parameters. Once you're comfortable with writing code in some different ways, you could move on to learning about macros, or you could start on some little projects (could be some simple web apps or maybe you have some library ideas) so you can get comfortable applying it/and using some libraries. Whenever you feel comfortable with the rest you should move on to experimenting with concurrency and OTP. &gt; I mean is a List in Elixir already a Linked List? Yep it is. You could always still implement your own using other types as just a way of building up familiarity with them. But in a real world use case you'd typically just use a list. 
Something that Elixir is getting some usage for outside of web would be IoT/embedded through the Nerves project, which is suggest checking out at least at the surface level. My route for becoming proficient was to rewrite a Django web app using Phoenix, which naturally lead me to many of the cool parts of Elixir and Phoenix as I replicated functionality. Browsing the Elixir forums for help and guidance lead me to a lot of useful information while trying to get things moved over. This is my first “Functional” language as well, so accomplishing what I wanted to do the Elixir way wasn’t immediately obvious. After I got the gist of implementation, I moved on to learning metaprogramming because I had yet to have any experience with AST macros before. It’s hard to suggest project ideas because I naturally just stumble upon things I want to do, but I almost exclusively do web related projects. Perhaps an application that scrapes some sort of interesting data from the web, processes it and stores it in a database, and then presents it in a user interface? That’ll get you some time with Ecto, Phoenix and possibly something like GenStage.
https://github.com/h4cc/awesome-elixir would be where you would start to look around the projects. One project I keep referred to when writing Phoenix is this https://github.com/thechangelog/changelog.com
I'm exactly in the same situation.. Except I didn't start yet to dive into elixir..
I'm really enjoying GenServer and how it provides some solutions we didn't have as easy access to in Rails. Here's a sample quick project that I think touches a few things we didn't have in Rails * Make a phoenix app * Have a supervised worker spun up at app start which hits an api periodically and fetches some data. (Quotes or Jokes would be a good candidate) * Have a page that on load takes the most recent API data, and then gets pushed new data when the genserver gets a new joke. Do all of the data via channels. * Add some UI widget that can adjust the API call frequency, and send those frequency changes down via a phoenix channel. * Write in some kinda time bomb to your process so it crashes, have it recover with the last known joke rather than initializing empty. I think a simple little app like this helps touch on a bunch of awesome language and framework features Elixir and Phoenix offer.
Check this project. It was funded in Kickstarter to be an example of how to create applications in Phoenix. It's development was even recorded by the guys from dailydrip. https://github.com/dailydrip/firestorm Although elixir is not only for web, it shines there. I suggest you to start developing small web applications to familiarize with elixir concepts and after a while try to build a distributed application using the otp stuff.
What I am wondering is what you mean by outdated. Elixir is backwards compatible, so everything should still work? The language did not have major changes either besides one or two. Or is it about libraries/frameworks?
I'm doing a web app project... so yeah. I mean that's the only reason why I chose Elixir in the first place. When I choose to learn a language I choose a project base on its strength... I recall a while back I dabble in Erlang and doing numerical intensive stuff is a no no. Project Euler creating prime and finding prime number took forever.
Are you searching for projects to looks at and learn from or project ideas to implement as a learning exercise? A good learning project might be to implement a very small online game. For example Tic-Tac-Toe or Rock, Paper, Scissors. 
If you want to do exercises, try exercism.io. It would help to already know another programming language first (anything, really). Even if you get stuck, there are solutions that people have posted on the web. While I couldn't build a reasonable program that did something interesting, it was good to build up basic skills. Think of it like practicing scales as a way to learn to play the piano, or morning exercises. Do 1-2 a day (hopefully, 30 minutes to an hour) and spend the remaining time doing whatever you do to study.
&gt; What are some good projects to familiarize yourself with Elixir? Basic functional programming (recursion, pattern matching), macros, any distributed application (Chat or Message Queue are good ones) &gt; I mean is a List in Elixir already a Linked List? More or less. It's an immutable, persistent list as opposed to your standard C list: https://en.wikipedia.org/wiki/Persistent_data_structure#Linked_lists &gt; I was also thinking of taking the academic approach and try to create things like Linked Lists and Binary Trees Functional programming is excellent for tree processing but it takes some mind warping to understand. I would throw this in the "basic functional programming" list I made above. Worth doing some baby examples of different traversals &gt; I have a good foundation for Ruby on Rails This will help with picking up Phoenix. Elixir is (obviously) much more like Erlang than Ruby once you get past the syntactic sugar. It's worth understanding Erlang in-depth if you want to really get Elixir &gt; is Elixir all about the web? Are there any cool applications outside of the web? No, Erlang was designed for distributed systems and it is excellent at it. That doesn't necessarily mean the web, and Erlang was originally used in telecommunications (many different hardware phones needing to communicate reliably somehow). IoT is another big distributed systems problem; Nerves is pretty popular for that As a side note, it's worth talking about what Elixir is not. I think Elixir is a poor choice for scripting. I would even go as far to say it's a poor choice for anything that does not required distributed messaging (if you're doing anything on a single machine - even with requirements for high concurrency - there are lots of other fine languages that are simpler and have better tooling). But if you're doing anything with messaging between multiple machines Elixir is a champ
System.cmd
I think there's also :os.cmd which is an erlang function that runs the shell, if you need pipes, etc. Note that it takes a charlist.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_transhap] [A Good Elixir Project?](https://www.reddit.com/r/u_transhap/comments/ae9c0e/a_good_elixir_project/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I sound very much like you. I went 100% ALL IN by building a massively ambitious project (which required millions of requests per minute). It ended up great, and it was one of the most fun experiences I've had. I also read/watched the same materials you did and didn't really "get it". Honestly you just have to try pattern matching for awhile and it will click. The hardest thing for me was transforming data... like lets say you want to print out a little table to the console using - and = ascii marks to print borders. Well, you cant do that easily because its not immutable, so you have to use tons of map/reduce/iterate functions that collect and transform rather than modify. This can be very tedious when youre trying to update some key inside a nested list/map... it took me sometimes like 5 hours to do something that would take me 30-60 seconds in ruby. In the end it was all worth it because it taught me how to think entirely differently about things. Functional programming is very cool, and the 'painful period' is actually quite fun. Skip quizzes and little stupid projects, just build something cool that you need. IMO i still dont think phoenix is better than rails for the web portion, nothing will beat the simplicity of rails. I actually built a hybrid app with a rails interface and and an elixir backend API that would access the same database.
Can someone ban this fool? This spam is ridiculous. We get it. You have videos. Link to your channel once, tell people what it's about, and then hope they like it. Spamming your content doesn't build a fanbase.
It’s all good. I’m using Ubuntu 14.04.
Seems like a nice contribution to open source but this isn't much elixir. Elixir is more than just syntax. You need the BEAM VM. Other wise the actor model doesn't make much sense unless you enjoy Scala's gimped actor model... 
Are channels some part of Phoenix? 
Yes! The hex docs provide a pretty good intro to them: https://hexdocs.pm/phoenix/channels.html I've only prototyped out some ideas, but I think they provide a great tool to build real time UI experiences.
Also we need a speaker for our next month's 2/20/19 meetup so if you are in the area and interested please reach out!
I'll go to that. Looking forward to it.
If you build web applications, this is a great OSS project. Sometimes I find the easiest way to learn is building out a real application and doing code exercises in between. [https://github.com/thechangelog/changelog.com](https://github.com/thechangelog/changelog.com)
Feel free to take a look at this project built on top of the Phoenix framework. Has been super helpful in levelling up my skills! [https://github.com/thechangelog/changelog.com](https://github.com/thechangelog/changelog.com)
F yeah, McCleary, hope to see you there.
 Hi elixir coders! In this article I introduce Elixir Streams as a powerful and elegant way to process large CSV files. I compare the greedy and the lazy approach with some memory and cpu benchmarking. As always. if you have any question or feedback, please leave a comment in the article's comments section .
As I read [Functional Web Development with Elixir, OTP, and Phoenix](https://www.reddit.com/r/elixir/comments/adj14v/functional_web_development_with_elixir_otp_and/) I'm beginning to lose the rose-tinted glasses. Elixir comes bundled with a ton of functionality, and the final code can be quite expressive, but I'm finding other aspects quite cumbersome. Especially the need to persist a reference to an instance of a module as the first parameter for most of its methods. Although it removes the ambiguity of `this` in the OO-world, it's very repetitive especially if you consistently perform runtime type checking.
Thanks for this, very interesting. How does performance compare to use of SSIS packages?
For SSIS packages do you mean Microsoft SQL Server Integration Services?
Ah great. I live in London! Where is it hosted?
Yes, in a previous project we used SSIS to process csv files requiring some row by row validation and with a volume of millions of rows at quite some speed. Compared with a previous approach of using c#/.net code. Could even better results be obtained using elixir streams? Your post has also led me to read up on genstage too.
I'm sorry but I don't know SSIS. There are many platforms to process CSVs and each one has it's pros and cons. Elixir Streams are more a language tool/paradigm rather than a platform to process CSV. If the validation process and strings manipulation is cpu intensive, elixir/erlang is good but not fast as c/go or rust. If you need to parallelise the processing of your csv, you can also take a look at [genstage](https://github.com/elixir-lang/gen_stage.git) and [flow](https://github.com/plataformatec/flow.git). Did you try Spark ?
Thanks that's really helpful. We didn't try spark, SSIS did give us what we needed in the end after a painful development! Could you master the overall processing in elixir and call a rust module for the more cpu intensive aspects? This is all academic as I am attempting to learn elixir, appreciate your insights. Those links were very helpful too.
With [Erlang NIFs](http://erlang.org/doc/tutorial/nif.html) you can load C code and run your C functions in Erlang. How many rows do you have? 1-10M or hundreds of million? What kind of validation do you have? Try to split these CSVs if you can, so you can leverage multiple cores and multiple machines. This is what we do in my team with huge exchange csv we process everyday. We split them per product and per day before starting sampling them. We use python for that, but more because it's the standard in the industry (with a bunch of great machine learning libraries we use) and I couldn't impose elixir to my team ;) 
Thanks. This project is in the distant past for me. But it's a real life example I understand where I wanted to better grasp how elixir might have impacted it. I work as an analyst so my technical insight only goes so far, trying to learn elixir as my first programming language as it has really captured my imagination :)
a nice! Analyst in finance? Data Analyst? 
Systems and process analyst, specialise in integrations, so APIs and batch processes. Do everything from process mapping, system selection, API design and support, data modelling etc. So most things apart from actual coding really! Lately I'm getting drawn to go more technical rather than more business. Mainly due to interests in cryptocurrency and functional programming. Elixir and functional programming just seems to fit better in an Agile world where software is built in increments, designed in them, released in them and unit tested etc. Also where cloud and scaling are so important. You have to work hard to do all this with OOP whereas functional seems like the last piece of the puzzle for the whole software delivery paradigm. That's how I see it at the moment anyway 😊👍
I wouldn't say elixir is necessarily bad for scripting. I wrote a stress test suite in elixir and streamdata was really helpful as are mix tasks and the built-in docstrings.
Here are a couple projects that agree with you: https://nerves-project.org/ https://github.com/bitwalker/exprotobuf
Yeah, I should backup what I mean with more details. In particular, I think the BEAM is poor at integrating with the external OS. For example, working with external OS processes is a lot tougher in Elixir than it is in other languages. So if you wanted to do something like automate Docker or some other CLI tool via Elixir then you might run into some gotchas I also feel like the BEAM does a whole lot more than you need when it comes to scripting. As a language, Elixir is great for scripting but the runtime is clearly meant for production. I like to think of the BEAM as solving similar problems to Kubernetes
Cool. Haven't heard about nerves before..Thanks. Any book recommendation?
LOL, I started off as an embedded Linux dev and now I try to work in elixir as much as possible too :) I would look into the ecosystem more than just elixir. Beam and OTP are really cool for clustering lightweight devices. Elixir is just a new language that runs on top of them but Erlang has the same functionality (and might be more C like???). Elixir is way different from C because it's purely functional and has this weird (read: awesome) way of calling functions. You have multiple functions with the same name but different parameters. You then just call the function and pass the appropriate parameters. Elixir figures out the right function and off you go. I love it because it lets you create functions that are super simple and don't have much if any branching in them (the language handles the branching for you). Anyway, I think you'll really like Elixir, Beam and the OTP. Good luck!
if you have done a lot of bash for gluing things like: ls -1 | grep -v do_not_want | awk '{ print "cp "$1" " $1".bak" } | bash you will realize that you have been doing functional programming the entire time. When I got started that helped it click for me.
I would start by going through all the getting started sections in the right column of this page: https://elixir-lang.org/getting-started/introduction.html I still spend a lot of time in the main Elixir documentation page, which does a great job documenting the standard library: https://hexdocs.pm/elixir/Kernel.html This learning page has links to a lot of good books and other resources: https://elixir-lang.org/learning.html 
Thank you
Cool. Yes, i haven't seen functional programming yet
I'm also a former C embedded programmer and I also wanted to switch to elixir (and OTP). But since I had some ruby knowledge gained along the road, I first went into web development with rails.. Currently I work with rails but after some of the projects I'm currently involved in I really want to jump into elixir..
My first approach to the language was: https://elixirschool.com/en/ Very cool to start with :). Good luck! It is a beautiful language
I can't recommend the Pragmatic Studio Elixir course highly enough. It is the best training material I have ever had the pleasure of using in 20 years of software development. It takes you through learning Elixir by writing a web server which also happens to work much the same way as the Phoenix framework so you are kind of learning that at the same time. [https://pragmaticstudio.com/courses/elixir](https://pragmaticstudio.com/courses/elixir). &amp;#x200B;
Perfectly fine to learn elixir however if you’re still looking to do work in embedded Linux and device drivers learning Rust might be a good choice. It’s specifically built to work on embedded systems but it feels a bit more like a higher level language than C.
"Elixir in Action" is excellent for learning OTP (which is really the secret sauce). I also liked Dave Thomas's book for relearning basic functional programming
You can try to start from Erlang/OTP it has simpler syntax but a lot of people find it's syntax ugly. If you choose this path it will be common to start from this book: [https://learnyousomeerlang.com](https://learnyousomeerlang.com). If you become confident in Erlang/OTP it will be easy for you to switch to Elixir and also you will get a better understanding of Elixir itself. Anyway, I also recommend you to look at this book: [https://www.erlang-in-anger.com](https://www.erlang-in-anger.com). Whatever language you choose it will help you in a production environment.
As someone with a C/C++ background... You'll love it. If you've ever used or implemented a message passing architecture, then Elixir is all of the good parts. Plus, you can still drop into low-level languages when performance really matters.
I’d recommend either Programming Elixir from pragprog or Elixir in Action from Manning. IMO Programming Elixir is great at introducing functional programming and Elixir in Action is great at explaining how async works in Elixir/Erlang. That sounds like a super specific topic probably but it’s a pretty big part of what makes Elixir so it’s worth really spending some time to understand.
You are in for a wild ride lol But I’m the type of guy who read Dave Thomas’s Elixir book cover to cover in one sitting because I became obsessed with how amazing it is
Thanks. I did look at Rust and Go before Elixir. More I dug deeper it seems Go is ideal for cloud native programming. I came across some project where kernel was written in Go. But I am not confident on Go for embedded systems. Atleast the community doesn't focus on those. And Rust is too young IMO. I will wait for few years for the rust ecosystem to evolve and settle down.
&gt; Erlang has the same functionality (and might be more C like???). In what way? If you're talking about syntax, hell no. It's base on Prolog. Elixir syntax is base on Ruby so it's more closer to C.
Sounds pretty reasonable. I’m a huge go fan but the lack of simple things like a slice.map method often drives me crazy. I’d love to see go 2 with some kind is strictly side effect free function type and a few very minimal functions like .map accessible through the standard libraries.
Check out my videos at [Alchemist Camp](https://alchemist.camp/episodes). They start from the beginning and you should be feeling pretty comfortable by #12 or so. All the basic ones are free.
Nerves is a good project for imbedded devices. Not sure what you were doing with C. Also, not to steer away from elixir but another language that is possibly filling C programming use cases is Rust. Which is a fully functional language. Back to elixir, Ive used it on the raspberry pi for controlling gpio pins. Very pretty language. But I get the idea elixir was created more for concurrent webapps and web services. Anyone correct me if Im wrong. The nerves project is still developing. So that is a very promising future for the IOT world and elixir. 
Elixir is super interesting for embedded programming. As hardware has become more powerful, the definition of embedded programming has changed from being "resource constrained" to being more about the creation of reliable remotely-manageable systems. People sometimes ask if Elixir is suitable for embedded systems, and the answer is that Erlang was explicitly designed for this 30+ years ago. A telephone switch is an embedded system which combines application logic, interfaces to dedicated hardware and a system to manage updates to the system and support it in production. With your C background, there are interesting things that you can do to interface with hardware. IoT and robots and IoT are interesting now, e.g. digital I/O, analog I/O, motor control. The low level stuff is basically the same, but now we have better tools to manage the whole system. Nerves is a new take on embedded systems. Instead of using flaky shell scripts to bring up a system, we run an Erlang VM as /init and use it to configure the system using Linux kernel interfaces. It reduces the total system complexity, making it easier to create and manage. This kind of thing is also very interesting for modern cloud "appliances", which have a lot of similarity to the requirements of You might like this presentation I did for the LA Elixir user group: https://www.cogini.com/blog/elixir-and-embedded-programming-presentation/
Hey everyone, I've been making some videos guiding beginners through [Exercism](https://exercism.io) problems in Elixir. These are mainly targeted at beginners and what I'm trying to do is show how you can approach the problems in a functional programming language, but specifically Elixir. Feedback is very welcome. I'd like to move into making more general Elixir tutorials where I actually show how to build things.
I would second the KISS idea here as well. Not sure that you need a front end framework for your first project unless your first Elixir project is a real-time application. How about just the default stack that you get out of the box with Phoenix: Elixir/Phoenix + Postgres? Also, not sure how familiar you are with Elm, but I've built a production real time chat with it and despite being generally impressed with it, I'm not sure I would recommend it to someone else. It's true that once you've built your app with Elm IT WILL NEVER BREAK, but getting things done in it can be really slow. If you're a beginner with Elixir AND Elm, I'd recommend not using them together for your first project because you may never finish it. I recommend using [asdf version manager](https://github.com/asdf-vm/asdf) to manage your Erlang, Elixir and JS versions.
[removed]
150% disagree. I work with a product which is basically "automate CLI functions".
It's great to see how fast it becomes stable... _I wonder if 2.0 will bring some "breakages".._
That is the whole point of 2.0, until then it will always be 1.x. There is already list of things to be removed in 2.0. 
I would discourage people to use this style; the community at large seems to be discovering that application configuration is problematic at best, and this is a good example. First of all, you dissociate code - your test and mocks and the very fact that these mocks are used for all tests is spread out over your codebase; second, you hardwire a single set of mocks for all your tests, which is often not what you want. Last but not least, to a lot of developers this whole compile-time/run-time dichotomy of how Mix generates an OTP application config is confusing and thus this style is error-prone. &amp;#x200B; It is much cleaner to just pass in the mock as an argument to the function you're testing. It is not that much more typing, and keeps everything in one place; usually, if this style gets problematic, it indicates that you are having larger issues around your design. 
For the record: it's a very short list. So Elixir 2.0 will be quite a while out :-). I really love it how Jose and friends aren't succumbing to the temptation to start tinkering with the language. As an ex-Smalltalker, I can appreciate the concept of a small language with lots of libraries. 
That was fast since the first release candidate. Only 21 days. 
pacman -S elixir
plz, where can i see it?
[Table of depreciations](https://hexdocs.pm/elixir/compatibility-and-deprecations.html#table-of-deprecations) in documentation. 
I just updated via brew today and then check my elixir version was surprise it was at v1.8. Nice. 
Are you savvy with Ubuntu? Cheaplinux boxes you could ssh into. I think I literally paid $100 for like 2 years. 
I don’t fully understand what this thing is but https://www.membraneframework.org/
It's at our offices in Aldgate East! Gower's Walk...
fantastic! Thanks!
I'm currently using [ex-portmidi](https://github.com/lucidstack/ex-portmidi) to generate scores of MIDI events routed toward either Mac instruments (e.g. stuff hosted in Logic Pro Audio or Renoise) or an iPad (see https://www.youtube.com/watch?v=WIf1P7n3Eqk). You can find early bits of my work with `ex-portmidi` here, in case it helps: https://github.com/thbar/demo-elixir-reloading-music 
You can’t make me!
Use asdf and you can choose which version of OTP as well as which version of Elixir :D
No thanks. We already have Slack, IRC, and Elixir Forum. Do we really need to create a FB group? 
I dunno... obviously I'm biased, but more than half the screencasts they list are out-dated to the point that the code within them won't compile! In contrast they never added mine (which has over 100 episodes, all of which work on current versions of Elixir). Whatever their "curation" method is, I'm a bit skeptical of their claim to be "A curated list of amazingly awesome Elixir libraries, resources, and shiny things".
How about a minimal Slack clone? That would seem to me to be Phoenix's answer to the Rails Twitter clone. Building up to that, you could make a minimal markdown converter with regex, clone basic Unix command line utilities, make a non-web app to fetch and log weather statistics, etc...
This one wasn't too bad. The focus wasn't the front-end, so recent Phoenix changes don't really impact it.
Sorry,i agree
Please can you share the slack,IRC and elixir forum link,i don't know those community are exist
Good luck friend
On the right side of https://elixir-lang.org are links to the official IRC and the community Slack, Discord, and forum.
Thanks you friend
No problem, glad to see you joined Slack. Welcome!
I'm working to build a realtime, collaborative Kanban tool, MIT-licensed. That is, a virtual wall of post-it notes which is super useful for a range of different purposes (brainstorming, running a meeting, simple task tracking..) I originally built Lucidboard 4 years or so ago in Node and Angular 1.x, and while I'm ashamed of what I did, many folks at my workplace still use the tool on a daily basis, despite its litany of issues! The rebuild of Lucidboard is moving right along and I'm trying to build a community of folks around the project, inside or outside my company. My plan is to begin trying to work in Phoenix.LiveView as soon as the initial code is dropped. I want this project to follow all the idioms &amp; best practices and ultimately illustrate how amazing Elixir is to work with! :) If you're interested, please do check out a copy and jump in our chat. (See the top of the readme.) We have a pretty decent, docker-based dev environment. Feedback welcome! [https://github.com/djthread/lucidboard](https://github.com/djthread/lucidboard) &amp;#x200B;
odbc?
Ill give it a try. The doc just says MYSQL. But same manufacturer as ms access. Worth a try. Thanks!
Cool, let us know if it worked \^\^ 
I think u/CerealkillerNOM is correct - that's probably the only option. There is the Erlang ODBC driver, if you want to go a little lower level: http://erlang.org/doc/man/odbc.html Enquiring minds want to know, why are wanting to connect to MSAccess from Elixir? Not judging, just curious.
Hi All, we have 1 position remaining for this role. Please let me know if you, or anyone in your network may be interested. We pay a $500 referral bonus if they are hired by one of our clients. Thanks, Dana (danafaradie@optomi.com)
I currently use MS Access at my work (well the older workforce does) for reports. I am trying to automate the input process into tables that currently requires alot of time which is done manually. The reports are already setup in access that print pdfs. To save time (and to learn elixir at the same time) I am automating the front end process. Eventually I plan to build a webapp that will replace the whole process. But for the time being, its easier to just connect to the current ms access db. 
Hey, equineranch, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I currently use MS Access at my work (well the older workforce does) for reports. I am trying to automate the input process into tables that currently requires alot of time which is done manually. The reports are already setup in access that print pdfs. To save time (and to learn elixir at the same time) I am automating the front end process. Eventually I plan to build a webapp that will replace the whole process. But for the time being, its easier to just connect to the current ms access db. 
Hey, equineranch, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
can i down vote the grammar police bot?
Personally I’m not sure Elixir is very well suited for raw audio work: the performance just isn’t there and dropping into C or C++ cancels out too many benefits of the OTP ecosystem (i.e. a crash in the native code would bring down the entire VM). I’m looking into Rust which has similar pattern matching and functional programming capabilities but also performance and safety guarantees. Having said that, Membrane does look like a cool project if you can live with the above limitations. 
I agree, but that indeed was not what I asked :) You are implicitly assuming only real-time audio processing. Python for example isn't suited for real-time as well, yet scipy has one of the largest signal processing stdlibs ... 
Maybe to make it more clear where my thoughts go: The Elixir piping syntax is almost ideal for constructing an audio DSL. it's quite equivalent to what I'm currently doing in Max/MSP, PureData and the like, and since functional is quite obviously all about "data processing" I thought that the *language* (not necessarily the platform) were a good fit.
Please do
I've been working on a cross-platform audio api for elixir right now all you can do is get some metadata on audio files and record audio into elixir. &amp;#x200B; It's located here [https://github.com/QuantamHD/heavy](https://github.com/QuantamHD/heavy)
Yep--I think ODBC is your only option
Look forward to seeing you there! Let us know if you need any further assistance. 
Change this stupid bot to just PM the person.
It says you can reply ‘delete’ to get rid of the message, but personally I think that bot should be banned.
It won't solve your problem directly, but if you want to have snippets of someone trying to target another MS database (SQLServer) with ODBC, you can find that here: \- [https://tech.findmypast.com/sql-server-in-elixir-connection/](https://tech.findmypast.com/sql-server-in-elixir-connection/) \- [https://github.com/findmypast-oss/mssqlex](https://github.com/findmypast-oss/mssqlex) \- [https://github.com/findmypast-oss/mssql\_ecto](https://github.com/findmypast-oss/mssql_ecto) Maybe it will provide you with some useful inspiration!
This article is mainly focused on DevOps. I show how to create a High-Availability Kubernetes cluster on AWS with Kops and deploy a Phoenix Chat application. I hope this can be useful to the Elixir community. I could be interesting to experiment and discuss, in future articles, the deployment and update of distributed stateful elixir apps on a Kubernetes cluster. Please let me know what you think. For any question or feedback, please leave a comment :D
Erlang VM and OTP
It's awesome. Built on erlang Concurrency is a main selling point. Functional language Immutability is nice. Pattern matching is awesome. It's fast. Scales well Distributed Fault tolerant (Supervision trees) Syntax is nice and readable Community is smart and welcoming Standard library is complete Portable Tooling is very well thought out (i.e. distillery) Phoenix is great, especially how easy setting up websockets with channels. ...and many more.. With all these features, in my opinion it makes elixir the go to for a backend. Sasa Juric does a great job explaining more in depth why elixir is a great choice for almost any project. [https://www.youtube.com/watch?v=pO4\_Wlq8JeI&amp;t=0s](https://www.youtube.com/watch?v=pO4_Wlq8JeI&amp;t=0s) &amp;#x200B;
Indeed this is cool 
It will improve the way you code in other languages (in addition to what's already been said).
You will become happy
Wait till you figure out you can actually move the cursor around using [IO.Ansi](https://hexdocs.pm/elixir/IO.ANSI.html)
One thing more, try to use `iolist` instead of building binary, for Big outputs it can improve things. As for CSV parsing have you tried [`xsv`](https://github.com/BurntSushi/xsv)?
I'm currently in the same boat. I'm writing my own lightweight Ecto-like wrapper around xandra.
I went through all 4 parts of your 1.4 phoenix it's pretty legit. Thanks man.
concurrency and parallelism
Great👍
That’s my plan for my next post :) I probably should have teased it a little in this one. I may get into ex_ncurses a little bit too.
Great advice! I haven’t looked into iolists much but I’ll do that before I write the next post. As far as xsv I have and it’s awesome. I love the easy joining and splitting it allows you to do and it’s so fast. It and html5ever are two of the primary reasons I’ve been considering investing time in learning rust
Maybe it's not that it can do "more" but if you're mind agree with *functional* programming so it can also bring some advantages here _(though, there are other languages oriented in functional programming)_
I feel it's less what the language can do per se, although that isn't to say there isn't some nice features about the language. But more so what the entire ecosystem provides. You get a lot of mature tooling, concurrency and distribution built in, designed around being fault tolerant and recoverable, a lot of flexibility to customise parts of that ecosystem if you need (implementing your own node, distribution carrier, service discovery), a very consistent and predictable VM, etc. So it's less about the language itself and more about everything else it provides you. Because of this there are certain applications where it makes a lot of sense to use Elixir, while in others it's not very appropriate. 
a = 1 1 = a
Get hired at my place of work ;-)
This only one reason enough for me to dive into elixir...
Do you use elixir there?
Big advantage over PHP (I'm coming from PHP): in PHP, when I wanted to run some code periodically, I had to use Cron. So I had to configure crontab when installing my app. My colleagues are programming in Ruby, and they often uses Sidekiq (with Redis) for such things. &amp;#x200B; With Elixir you can omit all of those tools (cron, Sidekiq, Redis), you can write same functionality using Erlang processes. All of code will be in one place.
As you saying its not depth its breadth... Thank you
Sounds great, As you have used php and know about rudy do you think elixir is best than those?
A lot of companies porting their old Ruby on Rails applications to Elixir and Phoenix. At least where I live (Scandinavia). Recruiters chase me all the time on LinkedIn.
Wow, 3 years of elixir and Phoenix.... Please if you got time. Tell me about how did you learn elixir and Phoenix and how was the programming experience with elixir. And have more couple of questions if got time I'm waiting to ask you Thank you
I don't personally, but my team and some other teams do. We have open roles for people in the European timezones. 
I’ve been using Elixir and Phoenix now for the past 6 months. Although hard at first coming from a object oriented language, I’m totally in love with elixir now. I struggled the first 3 weeks but after that it has been a breeze. Pattern matching, parallel task and the pipe operator are my favorite parts of it.
I had around 1.5 years experience with programming from university (mostly C#, ruby and JavaScript) before I signed my work contract two weeks after I finished my education. I read and worked through Elixir and Phoenix tutorials and guides for a month, and then I began working on a real Elixir/Phoenix project. And then 9 months later I got to port their old Ruby on Rails projects to Elixir/Phoenix, which was very difficult, but very educational and enhanced my programming skills to the next level. Since then I've just continued to work on several Elixir and Phoenix projects, but mostly back-end Elixir stuff. Elixir is by far the best programming language I've come across. It's so easy to learn and fast to become productive with. It looks very neat too. It's beautiful and easy to look at.
My take: &amp;#x200B; \- concurrency and parallelism: other languages can do this too (Go, for example) \- functional, pattern matching: other languages can do this too &amp;#x200B; So these are nice to have, but not unique selling points. &amp;#x200B; \- error handling: with Elixir you can build systems that will recover gracefully from errors (both expected and unexpected) and will keep on running. This is accomplished with supervision (a concept unique to OTP as far as I can see) \- BEAM is an "operating system": as /u/Harry19911 already mentioned, you don't need Redis, RabbitMQ, whatever, because you can build all this functionality to run in your VM. So if you want to cut down on external dependencies, Elixir is great for that. \- reduce the centrality of your database. This is somewhat related to the first point, but we are very very accustomed to writing our applications "around" our database. If you want to explore another way, try writing a chat server (or any application) first WITHOUT a database, and then incorporating the database after. You might be surprised at how this changes your architecture and the performance of your application, and it might change how you think about databases as well.
Great story,Thank you for your time...
What resources you uses to learn elixir?
Thanks
Of course, it is better than PHP and Ruby and also Node.JS. Unfortunately it's not so popular.
A bit late to the show, here is a list of all the open source Phoenix projects on Github I could find: [https://github.com/happycodrz/phoenix-apps](https://github.com/happycodrz/phoenix-apps) &amp;#x200B; It includes basic metrics, like star count, number of commits, the date of the most recent commit. That should help you to quickly gauge actitivity and popularity. Hope this helps :) 
Maybe in future, Developers show less interest in Functional programming
The understanding of the documentation on [hex](https://hex.pm) is really important. I started with the basic phoenix application. Which for me was hard, because i needed to understand elixir and phoenix and [ecto](https://hexdocs.pm/ecto/Ecto.html) at the same time. I really struggled with routing etc. so i would suggests make some programs with elixir first, to get a feel with the syntax. After that create your first phoenix app. There is a great [guide](https://hexdocs.pm/phoenix/up_and_running.html) in the phoenix docs. Walks you through every part of it. It also guides you through the use of ecto. Last if you cannot find your question online. Google how they do it the ruby way. 
Thumbs up
Oh, interesting. I didn't know about the Discord!
BEAM, check this: [https://www.youtube.com/watch?v=pO4\_Wlq8JeI&amp;t=0s](https://www.youtube.com/watch?v=pO4_Wlq8JeI&amp;t=0s)
I've seen somewhere that although it has parallelism, it is not so good at it, could you explain that to me in comparison to other language?
More often than not, trying to find if one language is "better" than another is a fool's errand. They all (mostly) have their uses. Just like JavaScript is an annoying language by default, but it's also the only thing you can write that will execute on every web browser in existence. Typescript can help with that, but also adds a layer of compiling and features to learn. Elixir's definitely newer than those languages and handles concurrency better, but I'm sure those languages do things better than elixir too. It's usually best to ask if the language you're looking at is better *for your specific application*.
I wanna build a communication app thats why i choose elixir,i doubt of my choose...
Then it depends on your target. If you wan the app to work on phones you'll need at least another language for the actual app (Java, JavaScript, kotlin, swift, etc) since elixir/erlang can't run on a phone. JavaScript might be the easiest because you can leverage Phoenix to integrate the front to the backend (and they can both deal with sockets, which are nice for messaging). If you wanted to only use one language then as far as I'm aware, JavaScript (or flavors there of) is your option. If you want, I have a GitHub project that's a boilerplate for an Elixir application with a Cyclejs frontend (everything is functional reactive): [Hello, world](https://github.com/Delioth/cycle-phoenix-hello-world). It probably needs dependency upgrades, but it's a starting point that I like using.
Thanks
The pipe operator is an excellent language feature as well foo(bar(baz(x))) vs x |&gt; baz() |&gt; bar() |&gt; foo() 
Was it worth changing argument order for hundreds of functions in the standard library from the otherwise established standard in functional languages though? I would argue maybe not.
It says Scala developer, not Elixir. Or am i missing something &amp;#x200B;
and in London, not Stockholm)
Thank you for the timely post! Just last week I was trying to figure out how to block calls to a GenServer process until after it had done all its data loading and parsing, and I knew that doing it all in the init was a no-no. It's amazing how I've never seen `handle_continue/2` mentioned until now.
Can I find this library somewhere? I don't see any link to a repository.
You are not, i've had a royal c\*\*k up :)
You almost catfished me. So they will sponsor from anywhere?!
My apols - forgive me? Yep anywhere. Last year they had new starters from within all around Europe, Colombia, Brazil, Russia. The list goes on!
huh? &amp;#x200B;
Consider Erlang's list.map/2. The arguments are `(fun, list)`. In elixir, this is reversed, to `Enum.map(list, fun)` The main reason for this change, as I understand it (please correct me if wrong, because I wasn't in the room), is to accommodate the pipe operator.
I'm always curious why people use Docker in an Elixir stack. How are you using it?
Ah I see. I don't have insight into why those are different although, if it is to accommodate a pipe operator I think it's worth it. Elixir compiles to the beam so I don't think the final code running is any different. 
&gt; Login or register to see the full job description! Yeah, no.
Hey phughes- do you have a better suggestion as to how we do it? We always welcome constructive criticism 
Yes, it all compiles down to the same bytecode eventually.
I'd like to be able to read the job posting without signing up for an account. Even better than that would be the ability to apply for the job without signing up for an account.
Process streams of data amazingly. Say you have a big pipeline of things you need to do like... 1. crawl websites 2. find images 3. process images (maybe convert to black and white or resize) 4. upload images to s3 each of these 4 steps take different amounts of time. In another programming language it might be hard to set up a series of background jobs which are highly optimized and parallel. With elixir, you can set up a simple GenStage which uses back-pressure (it means consumers ask for demand when they're ready rather than producers 'giving' demand). Now imagine you have 4 circles, one circle representing each step above. Now imagine millions of dots flowing between these four circles in a linear fashion. This is the standard "limited" approach. Now imagine adding multiple circles for any steps which are slower. Now you can change the bottleneck at each step, and the entire system automatically handles all the 'asking' and demand portion of it. You dont need to code any of that. You can also make an extremely parallelized very performant system incredibly easily. 
Yeah sure man, hopefully I can shed a little light. They use docker to build and test Elixir applications. But they don’t use docker in production. For that they use releases. Hope that helps 👍
Ah well, you have to create the account to apply for the position as everything is done through the platform from beginning to end. This is just one of the many ways we’re trying to make the whole process much smoother for you and for the client. So essentially what happens is when you apply for the role, the client can see your platform profile which includes your CV, location, github and personal links (if you decide to add them) and then using the platform they can decide whether to proceed or not. They also have their own client dashboard with all the information of who has applied, all the data analytics of how their job posting is doing etc. Similarly you will have your own personal dashboard with recommended jobs matched to your skill set, what jobs you’ve applied to amongst many other things. I hope that makes sense as to why people create profiles on the platform, let me know if you have any other questions!
Thank you. This is great!
tbf, it is relatively new ... about 7 months or so?
Why don't you post the whole job description here? Or use multiple job posting sites (indeed, dice, monster, craiglist, angel.co, linkedin, hackernews, etc...). Hacker news have a monthly who's hiring.
yep, prior to that it was common to send a message to self() to tell the process to do data loading etc. handle_continue fixes a race condition where it was possible for a process to receive messages from other processes prior to messages sent to itself in init()
For what it's worth, you can still pipe from the other direction. A couple of examples, Haskell has the `$` operator and FSharp has the `&lt;|` operator. So `x |&gt; foo() |&gt; bar() |&gt; baz()` == `baz $ bar $ foo $ x` == `baz &lt;| bar &lt;| foo &lt;| x`. I guess it just came down to preference.
backed! 
oh yeah, i wrangled with that issue in past ... was ugly and error prone, so mostly i avoided that pattern whenever i could .. been using handle_continue since it became avail and never looked back :)
Hey there. You’ll find that all job posting sites that you’ve listed give you a description but it is very vague and you don’t actually get the name of the company or any specific details, and you have to wait for a recruiter to call you and speak to you for half an hour before deciding whether or not you’re worthy of him doing you the favour of revealing the company name. By registering on the Functional Works platform you will find out all the specific information including the company name and a detailed description of the company + salary + benefits etc. So actually it’s miles more transparent than the traditional way that other recruiters do posting on the mediums you mentioned, which is exactly what we want. We want to revolutionise the recruitment industry and by being transparent and making all the information accessible to you without having to wait for a recruiter to contact you and decide whether or not to reveal the information, we hope that it’s a big step beyond the traditional outdated way of doing it! As I said before, registering is so that you can create your own profile and get in touch with the clients and they can get in touch back, all via one medium. I realise I was rambling a bit, it’s quite tough to explain it all on reddit 😂 let me know if you want to chat about it further. Like I said it’s always great to get constructive criticism and see how we can evolve the platform :)
Awesome...
Could you explain more about your education process and what you think makes it better? Just saying it's better won't help as much.
Do you have a link for the Spanish version of the books?
Can't we just use gettext and a couple of macros ? ;-) 
https://books.altenwald.com/
I think it's not better, it's different. If you didn't understand Elixir using the usual books maybe my approach is better for you. I tried to explain Elixir in the way I think I could understand it better by myself so, it's worth to read just in case you didn't understand something in the way the other books are explaining that to you. And I'm explaining OTP, build releases, hot-upgrading, ... that's not easy to find in other Elixir books.
hahaha... good one! and I wish it, of course I wish it could be as easy as that :-)
no worries :)
Well a lot of those job posting sites are actually vague with their descriptions without giving you the company name and details either. You'll normally have to wait for the recruiter to contact you and decide whether or not to reveal the company name. Whereas with us you can log in within a couple of seconds using your Github and have full access to all the company name, details, benefits, salary etc etc without having to speak to anyone, so we like to think that it's a big step beyond the traditional outdated way of doing it. As I said, the reason for logging in is you will have your own profile that you use to search and apply directly to clients, and so that they can then get in touch with you via your platform profile, making it much easier for both sides. Hope that helps :) Always happy to chat about it further over an email or call if you'd like!!
Check out [ElixirSchool](https://elixirschool.com). We want your suggestions and feedback on the guides, Happy coding in elixir! 
Since you know JavaScript, I recommend you NodeJS.
You might want to take a look at both [the Phoenix framework](https://phoenixframework.org/) and [Ecto](https://hexdocs.pm/ecto/getting-started.html#content).
I would recommend learning SQL, not at an advanced level, just a good foundation will be enough for most occasions. &amp;#x200B; Also if you are not limited to Elixir and want to learn for web development using an MVC framework (Phoenix, Rails, etc) I recommend the [The Ruby on Rails Tutorial](https://www.railstutorial.org/)
BEAM there, done that
BEAM me up Jose!
‘E licks ‘er Actually, wait... no, don’t use that. That’s not okay at all. 
Yeah... we won't be using that. A* for effort though!
Thanks! 
Dude, where is my BEAMer?
BEAM Soda
I want to make sure I understand. So I don't have to setup a crontab to run my code in elixir. I can spawn a process within my code?
Exercism has an [Elixir track](https://exercism.io/tracks/elixir), though if you're limited to one week you may want to try the un-mentored track since feedback can take time.
I meant mainly I was going to dedicate all my time to learning elixir rather than messing with other things such as my current python projects. I am dedicating all my time to elixir.
That makes sense. I'm still scarred from my days trying to cross compile Linux so I always match my dev hardware to production hardware so that I have binary compatibility. Thanks!
Yes
Ok that is awesome! I'm in.
BEAM Theater The number of the BEAM BEAM shakalaka
To BEAM or not to BEAM
Phoenix.
BEAMoning the state of the world
Nice!
Ah then I would definitely recommend the mentored track on Exercism, I've found the code reviews to be very helpful in learning the syntax and following best practices
Give more requirements. 
I started an open-source project about bringing P&amp;P rpg via chat to life, but got bored as I was alone onto it and especially because I had to do a front-end If you are interested I could motivate myself to revive it, it had the basics of a chat
I would **not** suggest (in case you were thinking about it) redoing one of your previous projects to compare the two. Elixir projects don't fit the same mold as a python project would, and tackling it by trying to simply translate one language to another will end up in a horrid mess. An Elixir project will fundamentally change the architecture of the way the problem is solved, and that's what you need to learn in order to understand the benefits of Elixir.
I did this and am currently refactoring the architecture and it's just how I learn! I don't necessarily think it's a bad strategy. 
\+1
This was the best course I've taken for Elixir: https://pragmaticstudio.com/elixir It doesn't bother you with bullshit like here's an int, here's a string. It's just here's what Elixir and here's why it should make your pipi tingly.
Wrong sub
How has nobody said "Room/3" yet?
To build a chat app like spectrum which elixir framework will be useful
I love [Elixir for Programmers](https://codestool.coding-gnome.com/courses/elixir-for-programmers). We're encouraging everybody at work to take it. It's a very good course.
One BEAM, one dream
agreed, I'm pretty deep into creating a decently large Pheonix app, and I'm just recently doing everything "the elixir/pheonix" way. i just clean up the old code as i come across it, Elixir is pretty forgiving, probably fewer gotchas than any web stack I've ever used before
RESPECT
This comment is underrated.
I’m the SUPERVISOR!
In the interviews I've done, we pair program on a contrived example to refactor. I look for how a dev uses pattern matching and recursion for control flow. I'm also looking to see if devs understand how BEAM / OTP work by building some basic GenServers and Supervision Trees.
Also highly recommend this course as well!
Learn mostly how to use Phoenix framework would help me to achieve competent skills for an interview? 
Here’s a bunch that I’ve been asked or would ask a candidate: Tip: it’s more important that you can show you are enthusiastic and eager to learn then to know all the answers. Good luck! Basic functional programming: map, filter, reduce. What is a higher order function? Explain tail recursion vs body recursion and the runtime implications. Laziness and streams vs lists. When to choose each? Describe the difference between Agent, Task and G How do you maintain state in an elixir app? SQL Database vs mnesia vs ETS vs processes? What are the trade-offs? What do you like the least about Elixir? What do you wish you could add to the language? How do you debug a highly concurrent system? How do you know when the system is failing? When would you use a doctest vs a unit test? What is important to document in application and library packages? What is dialyzer? What are it’s limitations? How would you introduce elixir into an existing system? What is OTP? Name an interesting module from OTP that doesn’t have a wrapper in the Elixir standard library. What are the gotchas when using Erlang libraries from Elixir? What are the different supervision strategies? When would you use each one? Is supervision good for handling retries? What is an umbrella project? Why would I use it vs a single project with directories? Does elixir clustering make distributed computing easy? What can go wrong in a clustered environment? What are the libraries that Phoenix build on top of? When might you not use Phoenix and instead use Plug/Cowboy or something else? 
Yeah! Seriously, there are so few gotchas and things just work. It's pretty awesome!
Can you talk about why you want to go with elixir? If I were you with a foundation in javascript, I would be looking at node and express as my first steps into the backend. I love elixir, I don't want misrepresent that, but the path from where you are to elixir as your backend, benefits from learning backend concepts that are language agnostic, and I feel that it is easier achieved in a language you are already familiar with. Particularly because elixir has fairly unique design concepts to it, not just using functional design, but with OTP, and distributed system design. So beyond elixir, to be full stack, you need data store concepts, which these days is IMO a minimum of understanding elastic search, redis, some flavor of nosql, as well as a common flavor of SQL. (to be a fully qualified master level developer, again imo) But to get to a useful level quickly, learning postgresql's sql. As well as understanding all the column types, and how and when to use them, that will give you the most fastest, imo.
Thanks friend
This is a nice boil-down of the key documentation: https://play.google.com/store/apps/details?id=com.thanhdo.tutorial.ElixirTutorial
Channeling Chris’s responses on the topic from pervious releases: “it will be out when it’s ready.”
I will say I'm a little surprised that, as a presumably open source project, it's not been opened up as an alpha project to let people poke at it. Then again, I can see some reasons one might choose this route too. Just letting my excitement get the better of me, I think. :-) 
Yes I think they're leaving it closed source until they are solid on their design architecture. Opening it up too early can mean they'll have to create a migration plan for any breaking changes. If they leave it closed they don't have to do that.
Take a look at [ElixirSchool](https://elixirschool.com/). We would like to hear your thoughts and suggestions as you power your way through the learning experience!
If I recall, development on LiveView slowed while they focused on phx 1.4. Last I heard, they planned to get back into more regular work on LiveView after 1.4 was announced.
I hope they spend the time on it to make sure the interfaces, test-ability, foundation is safe to build on. There's clearly a lot of demand and interest - it'll be much harder to make changes after the fact. 
Yeah, like it or not as soon as you open the gates (even if it is listed as alpha) people start to treat the api as stable. It is much easier to stay closed till you are happy with at least the core api before handing it out.
I am guessing an official timeline would be announced at [LONESTAR Elixir Conference](https://lonestarelixir.com/2019/#keynotes)
Wow
Can I make a suggestion? Quit being a whiny bitch. Just my 2c. 
Do you work for Microsoft?
 defmodule Parallel do def pmap(collection, func) do collection |&gt; Enum.map(&amp;(Task.async(fn -&gt; func.(&amp;1) end))) |&gt; Enum.map(&amp;Task.await/1) end end result = Parallel.pmap 1..1000, &amp;(&amp;1 * &amp;1) Boom, you just kicked off 1000 processes that run in parallel. Not quite as easy to do in other languages..
Awesome site,love it Thanks friend 
Let's be fool and hope for a release then!
Let's not rush them, stuff always takes longer we think :) My biggest question is how well it actually work in the wild... i.e. what's the upper bound of latency between browser and server can we accept and still have a good user experience with liveview?
You seem to have beef against microsoft and rich women. The expensive hotels is at least a reasonable argument to change places. This isn't how you sell an idea. It makes you look like an angry incel/red pill person. 
Elixir school is good, but IMO reading over doesn't make you learn much. I highly recommend the elixir course from Pragmatic Studio, one of the best courses I've ever done, check it out!
I would say jump straight in and start tinkering. Getting up and running on Elixir is so quick. Tips: 1. TDD. Elixir is one of the best languages to do TDD in and its an awesome way to learn as well, especially when you start looking at tests as your first port of call with any new library. Well written tests with good coverage also serves as extremely valuable documentation. 2. Go through Phoenix’s code. It is an incredible primer on how a proper Functional development flow should look and the codebase is really well put together (no, I am not involved with Phoenix in any way) 3. Pick one of the many open source libraries and contribute! There are few better ways to learn and get valuable feedback than peer review from an open source community (grow a thick skin though!) 4. And lastly, attend meetups and elixir conferences, even if you do it via a webcast!
A recent episode of [elixir talk](https://m.soundcloud.com/elixirtalk/episode-135-feat-chris-hildebrand-migrating-an-elixir-app-off-kubernetes) mentioned a measurable latency penalty running elixir on k8s vs ec2 behind an ELB. Did you see higher latency in the chat app running on k8s?
Please share the link
Thanks
I mean googling "Pragmatic Studio Elixir" gives you that, but sure. https://pragmaticstudio.com/elixir
https://codestool.coding-gnome.com/courses/elixir-for-programmers is a great resource 
We always welcome feedback. Any thoughts on what could be better? Elixir School is largely a community effort at this stage. Whether it’s feedback or contributions themselves, both are welcomed!
Was hoping to see tests, but &gt; What’s not covered as part of this rewrite: Mostly tests. I started writing the tests but I became impatient writing all the tests. Going through railsturor it constantly teaches, trying to fossilizy into your brain that Red-Green approach. Anyway, thank you for your work!
I found interesting to do exercises on https://exercism.io/ Also take a look at how Jose Valim solves puzzles from Advert of Code writing tests and explaining every piece of code! https://www.twitch.tv/collections/YDM6eKu6bhV1Nw
I've definitely got a 'beef' against Microsoft - I worked with its products for years. The point about 'incel/red pill person' made me think. Am I resentful that I can't get rich women? I imagine dating [Jennifer Aniston](https://www.imdb.com/name/nm0000098/). What would attract me about her, apart from her great acting talent? Not her wealth. It would be fun to borrow one of her Ferraris, but that isn't the main thing I'm attracted to about her. Women are more likely to be attracted by fame &amp; wealth in men than men are likely to be attracted by those things in women.
Take a look at Drab Live? It's fairly similar and available now
Don't take me wrong, I really like it/appreciate what you guys are doing! But I just think actually hands on will ingrain in my brains better. Maybe have like some exercise sections that allow people to try? (I haven't reached the end of Elixir School, IDK if it's already a thing).
A quick hex search gave me this library. [https://github.com/mikowitz/graphvix](https://github.com/mikowitz/graphvix) 
Old but might be useful: https://wtfleming.github.io/2016/01/28/geospatial-app-elixir-postgis-phoenix/ Also: https://github.com/ktec/particles
From examples OP gave, this probably isn't what they're looking for (though I can see the confusion). This library is for working with Graphviz (DOT files), so if you want to represent literal graphs (a collection of nodes) and you're happy using Graphviz to generate your output, then this is fine. But if you're interested in more broad diagrams and charts, or you want much more control over what Graphviz supports, than this is the wrong thing. On a side note if this is actually what you want, I've used this library before (although didn't realise 1.0 was released), it works well for small to medium size graphs, but when you need to generate really big graphs it just couldn't handle it (but that might've changed now, I'll have to update my project). Although Graphviz isn't great for huge graphs anyway, as it'll often struggle generating an output from a very large/complicated DOT file. 
ah interesting. Thx for letting me know. I didn't measure the latency, but I'll listen to the podcast to understand the problem they had.
Perhaps take a look at [Grafana](https://grafana.com/). It will hook up to lots of data sources and makes it easy to build graphs. 
Sure buddy.
Thanks a lot :-)
Will there be any broadcast of it?
We are still working to get the equipment needed for live streaming but it will be recorded hopefully not too long after. 
Hi gang, I wrote this short article as I was refactoring some of my \`with\` expressions into this style. Hopefully some of you find it useful :)
As someone moving from Euby to Elixir this example really hit home. I too have been trying to avoid “ugly” looking patterns in pattern matching but this seems incredibly powerful. Thanks for sharing!
I prefer doing it this way: with {:ok, val} &lt;- func\_1(), {:ok, val2} &lt;- func\_2() do stuff(val2) else {:error, :descriptor1, str} -&gt; handle\_error1() {:error, :descriptor2, str} -&gt; handle\_error2() end If I have to wrap a standard function inside of an injector that injects the descriptor, I do it. One of these days I might make a utility function that makes that easier, but I haven't had a need yet. Sometimes my pattern looks like this: with {:ok, params!} &lt;- func\_1(params!), {:ok, params!} &lt;- func\_2(params!), {:ok, params!} &lt;- func\_3(params!) do stuff(params!) else {:error, :descriptor1, str} -&gt; handle\_error1() {:error, :descriptor2, str} -&gt; handle\_error2() end params! is a map that gets values tacked on; I put a bang on the end of params to remind myself that it's getting mutated as it goes along.
I really like the idea of the bang for bringing attention to the mutated value! Everyone will have their preferences, and I found that wrapping the function inside of another function for injecting the descriptor was an extra level of indirection that, over time, started to feel unnecessary. Either approach is a lot better than than no descriptor at all though.
yeah preferences are preferences! Either semantic is fine, I think as long as you're consistent across a codebase. Re: bang sigil for opt-in mutable variables, I implemented as a credo lint, (NB it doesn't cover this specific case, since overwriting in sub-scope is not covered by the credo lint anyways) https://github.com/rrrene/credo/pull/618
TL;DR: just the first. Functions are identified by name and arity (number of arguments). So those are effectively different clauses for the same function. Which means just one annotation is needed. Similar for `@doc`, `@deprecated` and other stuff.
Ah, cool. Thanks!
The Erlang VM (on which Elixir runs) was designed to support millions of tiny, isolated processes, which you can spread across multiple computers and have them all communicate. The main motivation was for error handling: if something goes wrong in one tiny process, or if one computer dies completely, the system can keep running. "Notify process X if process Y dies" is a core feature of the VM, and on top of that, various tools like "supervision trees" are built. Creating a process in the Erlang VM is "no big deal" in the same way that creating an object in an OO language is "no big deal" - while you could theoretically create too many if you tried, you generally don't have to think about it. As it turns out, having lots of tiny, isolated processes makes it easy to run them all in parallel. Processes are forced to take turns on the CPU if they run long, so if one process is doing IO or some heavy computation, it won't keep others from making progress. You could say that the Erlang VM supports both non-blocking IO and non-blocking computation. The above is a short summary that [I've written more about in a blog post](https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis). All this means that "spawn a process" is the standard way to solve a lot of problems. So if you need to handle 1,000 incoming web requests, you spawn 1,000 processes. If you need to run a task once every five minutes, you spawn a process that sleeps 5 minutes, does the thing, and repeats. If you want to run all your tests concurrently, you spawn a process per test. If you want a simple in-memory key-value store, you spawn a process to hold and update that data. You can reach for other tools (cron, redis, etc) if they suit your needs better, but you don't always have to. On top of Erlang, Elixir adds a bunch of nice tools and abstractions.
I think you'd be better off with a gradual on-ramp. The way I learned web development was basically by building an informational site. My "baby steps" were like: 1) Make basic HTML pages with no CSS or JS. Copy and paste common things like menus between files. 2) Add some CSS and simple JavaScript to improve the pages' look and interactions (eg drop-down menus) 3) Start using PHP so that I can `include 'menu.php'` instead of copypasta 4) Start using things like loops and variables and functions and classes in PHP 5) Add a database and logins so the site can have content that gets added / updated through an admin tool 6) Now that I understand the "whole stack", start learning a better language than PHP At each step along the way, I had useful, exciting, fun results. I heartily endorse Elixir as a back-end language, but I think a gradual progression like this would serve you better if you're starting out.
Thanks
Usually when you have multiple clauses like this, you write one function head and add @doc, @impl etc to it. Then write all the bodies.
Haha no, but we've had a lot of "This room," "That room," "The other room." 
I like the idea of denoting unsafe variables, but isn't ! used for functions that raise?
This requires that all your funcs return a rigid hopefully unique return value, forcing you to go to their definitions to figure out which one could return a specific error. You'll be wrapping functions all day to make then conform to your calling convention. You also lose the flexibility of handling classes of errors slightly differently by not doing it the way the OP suggested. with {:http_related, res1} &lt;- {:http_related, http_fetch_1()}, {:http_related, res2} &lt;- {:http_related, http_fetch_2()}, {:combined, combined} &lt;- {:combined, combine(res1, res2)}, stuff(res1, res2, combined) else {:http_related, error} -&gt; error |&gt; handle_http_error() {:combine, error} -&gt; error |&gt; handle_combine_error() end 
I have my own custom error type in dialyzer.
Only one you may want to add multiple of is `@spec`. 
Agreed. Exactly what I had to do. I didn't lose faith. Just had to analyze my situation and make the tough decision to take some steps back. I realized I needed to start with a better foundation. Currently working on HTML and CSS. Then I'll be working with Elm, since it compiles to JS. And then keep progressing "backward" in steps, Elixir/Phoenix. Then maybe a C-style language. JS will happen at some point, but I want to learn full stack before moving to the whole JS can of worms. But yeah, moving backward from HTML/CSS, building on previous knowledge of front end development. Thanks for your reassuring comment! :)
You could always use D3.js + JavaScript in an Elixir on [Phoenix](https://phoenixframework.org) web application. You could try your hand at OpenGL via [Core Scenic library](https://github.com/boydm/scenic).
Small nitpick, but why match the first element of the tuple in the with block? You are already 100% certain what the first element is, so something like this seems less repetitive and more concise: with {_, {:success, res1}} &lt;- {:http_related, http_fetch_1()}, {_, {:success, res2}} &lt;- {:http_related, http_fetch_2()}, {_, {:worked, combined}} &lt;- {:combined, combine(res1, res2)}, stuff(res1, res2, combined) else {:http_related, error} -&gt; error |&gt; handle_http_error() {:combine, error} -&gt; error |&gt; handle_combine_error() end
Thanks for writing and releasing this btw. I stumbled across it about a year ago and modified it to also do crypto quotes while upgrading it to elixir 1.whatever and Pheonix 1.3. Was a great learning exercise.
That's great! Glad it was helpful. Do you have a link to the updated report? Would love to check it out!
Why? Only that it didn't occur to me when I wrote the comment. I agree it is much cleaner.
NP. :) I would add that although "modern JS" is a can of worms, doing some very simple hand-rolled JavaScript would be a good experience before jumping into all the abstractions of Elm. Eg, here's some JavaScript I once wrote to ensure that only one `&lt;audio&gt;` element on the page would be playing at any given time. function onlyPlayOneIn(container) { container.addEventListener("play", function(event) { audio_elements = container.getElementsByTagName("audio") for(i=0; i &lt; audio_elements.length; i++) { audio_element = audio_elements[i]; if (audio_element !== event.target) { audio_element.pause(); } } }, true); } document.addEventListener("DOMContentLoaded", function() { onlyPlayOneIn(document.body); }); That was the only JavaScript on the page, included via a `&lt;script&gt;` tag. You don't have to learn a framework and a build tool and a typed language to do little useful things with JavaScript.
Huh! I presumed that a later one would overwrite the former. TIL.
Because OP is not the hiring company. They represent the job tracking site. If you're still interested I suggest: "https://duckduckgo.com/?q=elixir+stockholm+sportsbook&amp;t=osx&amp;ia=web" where you'll find the "vague" descriptions other companies are using happen to be exactly the same as the one OP posted.
In this article we see how to solve an issue we faced in the previous article, scaling horizontally the Phoenix Chat app. We'll see how to integrate the PubSub Redis adapter to our chat app, and make it distributed.
Gotcha. Just making sure I wasn't missing something
Nice! I like having the redis spelled out. Why didn't you cluster the nodes and use the beam clustering for the channel communications?
Thanks! I was writing a post with both redis and beam but I preferred to split it so I could focus better on both (since I wanted to show how to do beam clustering on Kubernetes using libcluster). With redis is a bit easier when deploying a phoenix app with containers and something like kubernetes. You just need to configure each single phoenix container to point to redis, and that is it. The obvious advantage of using Elixir/Erlang nodes communication and PG2 is that we get rid of the redis component, so we have less to maintain in our cluster.... but with docker swarm, kubernetes is just a bit trickier (libcluster helps a lot!!)
Sure. I just fired it up to ensure it still works. [](https://github.com/cohawk/ticker_umbrella) Looks like I blew out your git history when I converted it into an umbrella app, so it wouldn’t be easily mergeable. I’d say ignore the elixir_1.6 branch - appears I was adding some gamification that I never finished up. Thanks again!
Yeah. With k8s deployments I havent tackled the beam node clustering yet. I was curious how you were going to solve it. I like the way you chose to abstract it. 
Awesome. Your blog is really nice, keep it up!
Maybe gnuplot work for you? Take a look at this http://teamon.eu/2016/measuring-visualizing-genstage-flow-with-gnuplot/
I should be able to write something about it for mid next week :) I have tested [libcluster](https://github.com/bitwalker/libcluster) along with [horde](https://github.com/derekkraan/horde) and to me they are a THE way to deploy an elixir distributed app with Kubenetes.
Thanks a lot! :D
Sweet looking forward to it. Let me know if you want a tester
It would be great! Can you please PM your email so we can stay in touch?
you could also do something like this, for an even cleaner experience: with {_, {:success, res1}} &lt;- http_fetch_1() |&gt; tag_http, {_, {:success, res2}} &lt;- http_fetch_2() |&gt; tag_http, {_, {:ok, combined}} &lt;- combine(res1, res2) |&gt; tag_combine, stuff(res1, res2, combined) else {:http_related, error} -&gt; error |&gt; handle_http_error() {:combine, error} -&gt; error |&gt; handle_combine_error() end 
yes, but in this case it's for a variable. Canonical Elixir style says that function calls should have parens, so there should not be much confusion.
&gt; This problem is often solved using an external component, like Redis, which helps to broadcast the messages to all the nodes in the cluster. With Elixir is also possible to get rid of this component, purely relying on the communication between Elixir nodes (we will see this in the next article). Looking forward to it. I want to remove moving parts when I can. And this feature is what brang be to elixir in the first place. 
Everyone should know that the redis pubsub adaptor was made for using in Heroku. I can't see a reason to use it outside of that context as it introduces more complexity and fragility with no gain.
Thanks! Nice ☂️ addition!
Thx for your comment! I didn’t know that it was developed with Heroku in mind, good to know! I agree with you that having a external component, like redis, for pubsub ads just something more we have to maintain. I use PG2 and beam clustering in Kubernetes BUT ... on a k8s cluster I think that a redis pubsub is simpler to setup
Beam clustering is best if you can run your system on less than 50-100 nodes. Others have scaled past that by not using pg2 and clustering in other ways. However, for the purposes of the article it should probably be mentioned that using the redis adapter is not the recommended way unless you have good reasoning behind it. Using redis in production is an operational pain point for other languages, so being able to drop it is a reason to switch for some.
Same thing as every day: Try to take over the world!
I am currently working on a open-source P&amp;P RPG related chat which is written in Elixir phoenix for the back-end and React redux for the front-end. Any help (being issues, pull requests or advices) is appreciated, since I'm still learning Elixir (and I **** love it) [Back-end](https://github.com/Shenrak/GORProject-API) [Front-end](https://github.com/Shenrak/GORProject) Feel free to participate ! Any contribution is appreciated :)
I'm working on a new web analytics tool. So far super happy I decided to go with Elixir/Phoenix for this project, I got the MVP done very quickly. Next I'm switching gears to marketing, design and copywriting but I also have some really cool features planned that I cannot wait to start coding :) Just launched the beta yesterday, check it out: [https://plausible.io/](https://plausible.io/)
Could you expand a little on what you're after?
Edited description
I'm sure you would do just fine with Elixir, but it all depends on what your (or your team's) skillsets may be. It may be that the Java ecosystem has more tooling available in your particular enterprise setting. As Elixir has a relatively young ecosystem, the availability of libraries might be an issue. All that said, I wrote Java for years and I am really glad I picked Elixir instead (web service + lots of background processing). I've supplemented some missing Elixir libraries with some Golang micro(nano?)services that typically sit between my Elixir services and relay between different protocols.
I'm building my own shell / a suite of command line applications from scratch. Been a really interesting exercise - especially since I decided to avoid using the ncurses NIF and just patch what I need in from BASH directly. &amp;#x200B; Other than that, looking into building a media manager for my fileserver - essentially so I know what movies I currently have along with resolution, bitrate, file-size etc. Should help when I find new content and have to sift through 1000+ titles some of which have multiple versions (this isn't even counting the hundred or so full seasons of tv I also have archived from my bluray collection haha).
He just uses Golang - don't worry about it ;)
We should do it in NH or Vermont - pull a full-on Dribbble why don't we? &amp;#x200B; I'd suggest Boston - but we also have a rich bitch in &lt;insert luxury car purchased by employed SO here&gt; problem haha &amp;#x200B; In case the downvotes flood in - my neighbor is a female entrepreneur who owns a G-wagon... We share the frustration with housewives scraping up the alley with luxury vehicles they can't drive. 
&gt; It makes you look like an angry incel/red pill person. &amp;#x200B; IMO - this makes me want to believe you're head is stuck in an equally "dumb internet world"
Was expecting a tech talk about elixir from uber by some cool person. &amp;#x200B; Found wholesome AF reddit interaction. &amp;#x200B; P E A C E 
I've actually just embarked on a side project that involves writing a custom shell / cli app in elixir! Any pointers / thoughts you'd maybe want to bounce back and forth would be super appreciated!
Our largest Elixir app at Podium was first put into production 2 years ago today, so one of our early engineers wrote a post about the experience. I'd love to know if any of you disagree with anything he wrote, or if there's anything else you would like to know about our usage. With 110 Elixir apps and 80 engineers writing Elixir full-time, we've been told we're probably the biggest Elixir team in the world, and we'd like to start sharing our experience with others.
For sure! Are you using `escript`? You may already know about this, but without any other context my main advice would be to make heavy use of `OptionParser`. I didn't know about it the first time I created a CLI tool and had to write a ton of boilerplate with `IO.get`, and so using `OptionParser` will save a ton of time.
Yup, doing all the above. Would be very curious to see your boilerplate IO.get though. If I understand what you mean - I think I've done something similar just by writing functions that use system calls to the current bash session.
Actually looking back at my code I was remembering wrong. It was just a matter of parsing the arguments correctly so I wasn't actually using `IO.get` but I was having to read the arguments in order and make sure that flags actually had arguments and stuff. It looks like I changed the code to use `OptionParser` before initializing the git repo though so I can't really find the code. You can check out that app here: [https://github.com/dnsbty/big\_text](https://github.com/dnsbty/big_text)
I believe it is probably a matter of perspective? As far as I know the embedded devices landscape is mostly C/C++, so Nerves may be seen an improvement since the device integration is in C/C++ but the application layer can be done in Elixir. But allowing the device integration to also be moved to Rust or safer languages would be even better.
Yep, I understand why a lot of embedded code is still c/c++. Another potential step forward would be to somehow get buildroot to use a formally verified or partially verified c compiler somewhere along the way?
Cool thx! Yeah, one of the bigger challenges initially was encapsulating key-bindings to the current cli app being used in my elixir shell. Fortunately I came up with what seems to be a relatively elegant way to parse options both in parent and child processes in my shell (although they're not really processes at all the way they're currently implemented).
Is your code public? I’d love to see what you’re working on
I’m going to make it public when I get back from work, it’s very rudimentary for the time being, but I’d be excited to get feed back from someone.
This is a pretty rave review, good to hear from a personal standpoint of Elixir being the next language I want to devote a lot of time to. Also great to share with my CTO as we decide what language to choose for future projects.
When we first started with Elixir because we didn’t have a CTO to convince. Luckily Elixir has a lot of upside that will help with the convincing. If nothing else you can bring up the financial side of it. Maybe this article will help: https://www.netguru.com/blog/save-money-using-elixir-benefits-of-the-technology
RESPECT
iex --werl -S mix
Hello, Connor here, Nerves Core team member. Couple things i'd like to address here: &amp;#x200B; &gt;I find it hard to believe that Nerves is nearly as robust as it's claimed to be I've been building \_and\_ selling a Nerves device in production for over two years now with no Nerves related issues whatsoever. There are other companies using Nerves in production for a long time as well. Rose Point, Smart Rent, FarmBot, LeTote are all ones that are known in the community, but there are more being used in less public sectors. Schneider Electric, and Very Consulting have also been using Nerves. &amp;#x200B; &gt;looking through some of the most commonly used elixir libs for Nerves Care to elaborate on this? The only NIFs i know of that folks use often are * ElixirCircuits - Recently written as NIF for performance reasons. Use this in production, can confirm stable. * SQLite3 Ecto adapter - I maintain this library personally as well as use it in production. Can also confirm stable as a rock. &gt;Nerves they nearly all seem to be c-based NIFs. This is just not really true. There are zero NIFs in the Nerves core library set. We do use \`Ports\` for a couple things like low level Network interfacing, hardware device interfacing etc. &amp;#x200B; Another thing i want to address is that NIFs are not at all \_unstable\_ by nature. A well written NIF has zero negative consequences if tested, and maintained which most of Nerves core projects are. That said i do write a lot of NIFs both personally and professionally in production and can confirm that with half a mind of what you actually want to accomplish, you won't do any harm. &amp;#x200B; &gt;Really too bad that buildroot support for Rust isn't quite there yet There are \_some\_ hangups on the Buildroot front for Rust, but it's not really their place to maintain an ever changing compiler. Buildroot depends on people to submit patches, maintenance etc to the source. Frank Hunleth (the Nerves Co-Creator) actually does a ton of maintenance for Erlang in Buildroot. &amp;#x200B; This gets into a good point: Most of the core parts of Nerves only exist because of a pre-existing need for them. Things like networking, distribution, hardware access, etc. These features are developed usually privately by the companies who use Nerves such as SmartRent, FarmBot, etc. They are then contributed upstream to Nerves and Buildroot. With that said, non of the companies that build/sponsor Nerves \_need\_ Rust support. Most of us just take existing C code that has been in production for \_MANY\_ years and add it to an Erlang Port and call it a day. &amp;#x200B; I personally have a few use cases for Rust in the coming year, and I would like to work on getting first class support for Rustler. I've proof-of-concepted it before, and i know more or less what is required, but i have not personally had free time to do it. &amp;#x200B;
Thanks for the info! Full disclosure - I’m not the most well traveled in Nerves. Love the project and the work you guys do.
Keep it up! And I can’t remember, but it was likely something similar, but in a time far, far ago.
Thanks friend 
Elixir is a relatively stable language given the design consideration not to make large changes to the core after 1.0 because of this many packages that don't seem actively maintained ... just don't have issues so they're still good to go from what I've noticed. You also have to realize because of the nature of elixir and the more the design of the language with features like GenServer, Spawn, and the higher level implementations of those like Task that you don't need libraries for things like asynchronous jobs because they are already first class citizens in elixir. [https://hexdocs.pm/elixir/Task.html](https://hexdocs.pm/elixir/Task.html) at a rudimentary level these are what you would be used to as jobs. I would read up on the internals to understand how they are different from jobs, but they will accomplish what you want. [https://github.com/ueberauth/guardian](https://github.com/ueberauth/guardian) for your auth - but honestly with [https://hexdocs.pm/plug/readme.html](https://hexdocs.pm/plug/readme.html) (which is how phoenix does it's routing and connections) it was easy to build my own auth plug with JWTS in like 20 lines of code. You'll find as you get more used to the language that you don't need to reach for a library every time you need to do something because a lot of the time the language features make it stupidly simple to implement the feature your self or better yet are already implemented in the core of the language itself. Don't misunderstand me though reinventing the wheel every time is not necessary but the language has powerful abstractions and stability that don't make it a bad option versus adding another dependency. It requires some thought on trade offs and manageability but both can be valid paths. &amp;#x200B;
&gt; We had to put very strict code review and testing policies around our Rails app because people kept breaking it, and while that’s not all Rails’ fault, our Elixir apps have just never had the same kind of problems. Are there certain practices that you think have helped, such as using type specs / dialyzer?
Thanks for posting this. I think I will delve into elixir after reading this. 
&gt; One of the biggest issues I see developers face is forgetting that a list is not an array Did they not come from a traditional computer science background? I'm just curious since it's been a while since I graduate but we had to take data structure and such for CS degree. Also javascript have array. I understand that everything is boil down to object but there is "array" built into the language. They also have class inheritance now and many people just ignore prototype inheritance. 
Good to hear! Feel free to reach out if you need help figuring anything out
Trevor(the engineer who wrote the article) might have more to add but here’s my thoughts. While we use the dialyzer and I personally think it’s great, the biggest difference is probably the slight nudges Elixir gives you toward writing good code. For we spent a fair amount of time hunting down N+1 queries in our Rails app because ActiveRecord can make it fairly difficult to see at quick glance where a query is terminating. Because Ecto only hits the database through `Repo` functions, were typically more thoughtful of the number of times we actually hit the database in Elixir. The speed of the test suite is also a big factor. With rspec we’re looking at 2 minutes to run our ruby test suite with four threads in parallel, and around 6 without the threads. In Elixir a test suite with the same number of tests runs in about 25 seconds. Even when specifying a single test, ExUnit outperforms rspec because of the time it takes to load all our Ruby code. Because of that we’re happier to write more tests, and run them over and over as we make them the best they can be. *TL;DR It’s not a feature of the language so much as the implicit nudges to write code the right way*
Was there a structured approach to training the team?
Thank you for your input. I should clarify that I have used Elixir already and like the language, I agree that it's powerful and easy to add your own stuff. Although I think background jobs are a bit different than Tasks. For instance, you have a backup in case something broke down. I know that it's easy to write your own code, but with well-maintained packages are just easy to build your application with. If I had to write logic for every case it would take much more time, which I don't have. Additionally, many times it's a community effort, thus there are a lot of edge cases covert that I wouldn't know probably.
I think Trevor meant they specifically don’t realize they’re working with a list rather than an array in Elixir. In most languages the typical `[]` syntax refers to an array (including JavaScript which is the language most of our developers have previously used the most), and so they use it without realizing that in Elixir that syntax belongs to lists. This is especially common as we like to hire junior developers from non-traditional backgrounds who are self taught or coming from bootcamps, so they may have never had a formal data structures class.
I think Trevor meant they specifically don’t realize they’re working with a list rather than an array in Elixir. In most languages the typical `[]` syntax refers to an array (including JavaScript which is the language most of our developers have previously used the most), and so they use it without realizing that in Elixir that syntax belongs to lists. This is especially common as we like to hire junior developers from non-traditional backgrounds who are self taught or coming from bootcamps, so they may have never had a formal data structures class.
Great question! It really depends on the developer. Some have no problem jumping right in to an established Elixir codebase and getting their hands dirty. Others will go through the guides on elixir-lang.org or read through many of the great books (we have several licenses to Safari Books Online). I personally used Programming Phoenix to understand the basics of Elixir while also wrapping my head around how Phoenix works. The only truly structured thing we do is an hour-long Elixir training every Thursday. We usually keep it to fairly beginner topics, with more advanced ones every now and then. We also do “nerd lunches” every Tuesday where one of the engineers will present on a topic of their choosing. Sometimes it’s Elixir, but it can also be another part of our stack like React or Postgres. If anyone has ideas for how to improve our training structure, we would be very open to suggestions.
This is shell, not terminal emulator. 
Last time I was on Windows I used cmder (http://cmder.net).
From teams that are very happy with a technology decision, what I'm most interested to hear are the downsides. Whether that's technical or non-technical (e.g. recruiting), hearing those and understanding them, and knowing they are outweighrsd by the positives is always useful.
something something genserver and pipes
I always like to do a fibbonacci number generator. I really enjoyed it in elixir because of pattern matching in the method definitions. 
See this for why Tasks can be an almost 1 to 1 replacement for Jobs [https://blog.danielberkompas.com/2016/04/05/background-jobs-in-phoenix/](https://blog.danielberkompas.com/2016/04/05/background-jobs-in-phoenix/) including retry functionality if they break down. 
Great question! Going into it we knew that we wouldn’t be recruiting developers who already know Elixir, but that wasn’t really something we cared about. Previously our stack was Ruby and AngularJS, but Podium was still recruiting developers from other backgrounds with the idea that they would be able to learn on the job. That’s exactly how it’s worked for us. We’re confident in our ability to train developers to write good Elixir. For smaller companies, that might be too costly, but we’ve found that developer productivity after learning Elixir makes it worth it. One of the main trade offs like Trevor mentioned is the need to more fully understand the data structures being used. Because the `[]` is typically used to create an array in other languages, we have to make sure developers know it’s a linked list for performance purposes. We like to hire junior developers and train them on the job, but many of them come from boot camps or are self-taught, and have never had a formal data structures class, so that takes more time to explain. The main issue I’ve seen though is just that sometimes we fail to recognize Elixir’s limitations. One of the earlier apps we built would retrieve structured data from websites, and so we were using Floki for parsing the HTML DOM of those sites. We were running about 20 retrievals per second and everything seemed great. We deploy our services using ECS though and we noticed that a lot of our EC2 instances were maxing the CPUs. We traced it back to that app and realized that while Elixir is awesome at IO bound problems, it’s not great for CPU intensive ones. Luckily there are ways to use C or Rust for the CPU-bound operations (like html5ever) so we can get around those limitations. It’s just a matter of recognizing when we need to do that.
Is the Podium team going to be at Code BEAM SF? Would love to pick your brains about this!
Thanks for the detailed answer. Your points are interesting, and I suppose the list thing is a feature of teaching elixir as someone's first proper functional programming language. I had done some tinkering in other functional languages where the list performance implications were the same. Haskell particularly makes a big thing of it. Something to bear in mind if we grow our team!
A little more DIY but Digital Ocean is the best pricing out of the cloud providers and not sure what your user base looks like but it will scale with you for quite some time. They support classic instance behind load balancers, containers behind load balancers and kubernetes type deployments. I'm not a dev ops expert myself but I just recently did that and dockerizing the Phoenix app wasn't too bad, I found the harder thing was getting a good CI/CD pipeline going with near seamless deploys, but that just seems to be an issue everywhere as I really haven't seen a team nail that yet in my experience. They are hands down by price great though if that's the main concern and your cool figuringg some stuff out.
google kubernetes engine is about as painless as you can get.
I understand your point very well and I agree that there is a time and a place for using packages vs your own implementation. Still, said packages would speed up development at the beginning immensely. And I haven't received any packages recommendation, which seems that ecosystem is not even small, but very small compared to other languages, it worries me a bit. I still don't see how Tasks can be the replacement for jobs - when you use Sidekiq. Sidekiq gives you web panel, you can kill, retry jobs from said panel. Tasks don't offer that. Correct me if I am wrong, but if you use docker, wouldn't that kill all the running Tasks during restart? If I was to use many packages, it wouldn't be because of lazy design, but because I have time constraints and reinventing the wheel just doesn't look like something I want to do while building saas by myself.
So true for the cluster. Not for making elixir a docker image though heh
Yeah I'd say this is about it. I forgot to mention tests in the article, but that's a big one. If it's not a pain to run the test suite, you tend to write more tests. Also besides the little nudges here and there, I think just that fact that everything's a lot more explicit in Elixir helps. You don't have to worry that some other process will modify your object, or that when you save it it's going to run a bunch of callbacks. With our own Rails code, there are a lot of side effects to functions that you wouldn't know about unless you're really good at rails or have worked in that particular app for years. Which is why we only let a small handful of people do code reviews, because they usually know those weird side effects.
Distillery can help to package it up for deployment. [https://hexdocs.pm/distillery/guides/phoenix\_walkthrough.html](https://hexdocs.pm/distillery/guides/phoenix_walkthrough.html) You could try to package and release in a docker container. This can then be translated up into most container hosting services. [https://robots.thoughtbot.com/deploying-elixir-to-aws-elastic-beanstalk-with-docker](https://robots.thoughtbot.com/deploying-elixir-to-aws-elastic-beanstalk-with-docker) Elixir supports hot-reloading of modules, but has some downsides with consistency that might not always be the best option.
We haven't really discussed Code BEAM yet. I was at Lonestar ElixirConf last February and we always send several engineers to ElixirConf in September so we'll definitely be there. We're still talking about the other conferences we want to go to each year and I'll make sure to bring up Code BEAM SF.
I guess it depends. If you're in GCP you can use Cloud Build which (to me) was pretty straightforward. I was able to come up with a multi-stage build like this steps: - name: 'bitwalker/alpine-elixir:1.6.0' dir: '.' id: 'get-hex' env: - MIX_ENV=prod args: ['mix', 'local.hex', '--force'] - name: 'bitwalker/alpine-elixir:1.6.0' dir: '.' waitFor: ['get-hex'] id: 'get-rebar' env: - MIX_ENV=prod args: ['mix', 'local.rebar', '--force'] - name: 'bitwalker/alpine-elixir:1.6.0' dir: '.' waitFor: ['get-rebar'] id: 'get-deps' env: - MIX_ENV=prod args: - mix - "deps.get" - name: 'bitwalker/alpine-elixir:1.6.0' dir: '.' waitFor: ['get-deps'] id: 'init-release' env: - MIX_ENV=prod args: - mix - "release.init" - name: 'bitwalker/alpine-elixir:1.6.0' dir: '.' waitFor: ['init-release'] id: 'create-release' env: - MIX_ENV=prod args: - mix - "release" - name: 'gcr.io/cloud-builders/docker' dir: '.' waitFor: ['create-release'] args: ['build', '-t', 'gcr.io/${PROJECT_ID}/foo:${BRANCH_NAME}', '.'] images: [ 'gcr.io/${PROJECT_ID}/foo:${BRANCH_NAME}', ] and the Dockerfile was FROM bitwalker/alpine-elixir:1.6.0 RUN apk add --no-cache bash RUN mkdir -p /foo WORKDIR /foo COPY ./_build/prod/rel/foo/releases/*/foo.tar.gz . RUN tar xzf foo.tar.gz ENTRYPOINT ["./bin/foo"] CMD ["foreground"] Using distillery. I'll concede that environment variables and config/module attributes was a massive pain point so I ended up using runtime lookup of envvars.
A lot of our developers have come from dev bootcamps, which don't always have data structures courses. And even those of us with CS degrees have tended to forget that Elixir's `[]` is a linked list, at least initially, since most of us have javascript or ruby backgrounds. It's just a thing that takes a little time to remember but good code reviews can really help. These days my problem is that I forget I don't have to treat javascript arrays as linked lists 😂 I don't think I ever had to consider the Big O of a function from the time I graduated until I started working in Elixir.
Sure, that wasn't meant to be an accusation of you, apologies if that came off that way. So with tasks and the distributed nature of elixir you could link to a process on another node and have supervisor code that manages the connection to that node on another container up the container restarting. http://engineering.pivotal.io/post/how-to-set-up-an-elixir-cluster-on-amazon-ec2/ Now you have a truly distributed system with proper architecture to manage nodes in bad health. Infact, https://github.com/koudelka/honeydewhttps://github.com/koudelka/honeydew Does something just like that for its jobs queue library. I hadn't recommended it just yet because I wanted to flesh out what you needed first. Sometimes its just a junior dev who needs a little guidance, doing something simple and the overhead is unneeded but you seem like you are a dev who knows what they want and have thought it through.
I currently enjoy our setup at https://appdoctor.io We use codeship for the build process. This builds the tar file. At the end of that build process the tar is sent to a digital ocean space(like DO's s3). We then have a separate script that either takes that tar and deploys it to a digital ocean server or runs a hot update on an existing server. If you have any questions feel free to pm because it was a lot of trial and error to get the build process right.
Ya, absolutely, my reference was to the distillery configuration. I like your solution to the gcp cloud build. I use jenkins with k8s but I might look into using your pattern for some of it. You should do a write up with a hello world sometime!
At the time that we started using Elixir we were still pretty small, we had probably like 8 engineers. And since we were adopting Elixir kind of slowly, and just with new, small apps, everyone just kind of picked it up at their own pace. So by the time we were heavy into Elixir, we just helped each new engineer learn it as they came on. Besides some Elixir lunch meetups, and the weekly trainings Dennis mentioned, there hasn't been much structure to it. I think most of the learning (that isn't self-directed) comes from pair programming, code reviews, and just asking more senior engineers questions. I think that has been pretty powerful, since we have a culture here where you don't have to be afraid about interrupting somebody to ask a question. That individual might not be as 100% productive as they would've been, but the one asking the question can now be more productive, and it helps the company as a whole.
I can't claim any of these libraries are some kind of "community standard", but these are what we use every day in our production Elixir application. \----------------------------------- Monitoring/Metrics: [AppSignal](https://appsignal.com) Authentication: [Guardian](https://github.com/ueberauth/guardian) Permissions: [Canary](https://github.com/cpjk/canary) / [Canada](https://github.com/jarednorman/canada) Background Jobs: [Exq](https://github.com/akira/exq) &gt;/rant &gt; &gt;You'll see all kinds of articles out there claiming that you don't really need any extra packages/tools to handle background job processing in Elixir/OTP and you can just use what's built in. This may be true if you are doing very quick running jobs that don't need retries and don't sit in a queue very long, but..... &gt; &gt;I would argue that the only way you can get away with that is if you are doing hot code reloading for deployments or you don't care about long running jobs surviving across deployments, neither of which are very common scenarios. &gt; &gt;**As soon as you need your job queue or long running jobs to be able to persist across deployments, you're looking at some kind of durable job queue.** &gt; &gt;Now, could you write your own durable job queue using only the built in Elixir/OTP tools? Yeah, I guess, but I'd argue your time (especially in a startup environment) is better spent elsewhere. This goes double if you are just starting out with Elixir/OTP. Writing something like that is not trivial and there are a ton of edge cases where you can get tripped up. How well do you understand processes? GenServers? Mnesia? Global registries? What happens to process state in your cluster during a deployment? Have you figured how how to handle a global registry during a deployment? Go figure all that out, then you can come back and write your job queue. &gt; &gt;Or.....spin up a redis instance, add Exq to your project, and be done with it. &gt; &gt;The same goes for caching, only more so. Unless you really understand what happens to the state stored in your processes across your cluster during deployments or, god forbid, a net split within your cluster, I'd highly recommend using existing, off the shelf tools to handle this stuff. &gt; &gt;I know this is pretty heretical to say within the Elixir community, but tools like redis, memcached, zookeeper, et. al. have been around for a while and exist for a reason. This stuff is really hard to get right!!!! &gt; &gt;We spent a lot of time (way, way too much) within our company trying to follow the "Elixir way" and write all of this stuff only in Elixir and fought really hard against brining in third party tools and services. The truth of the matter is, that time would have been better used focused on building out our actual product. &gt; &gt;If your company is chock full of experienced Elixir/Erlang developers who can write GenServers in their sleep and solve hard distributed computing problems for fun in their spare time, then hell yeah, go for it (and please open source that shit). Otherwise, don't beat yourself up over this stuff. Grab something off the shelf, get it running, and move on. &gt; &gt;/rant over &amp;#x200B; &amp;#x200B;
Crawler, using Elixir and python, Erlport for calling python. Elixir manages the queue and puts the data back to db, python does the actual crawling. Please tell your thoughts. 
I use digitial ocean as well, because it’s so easy to set up and cheap. For the pipeline I use distillery and edeliver. I don’t bother with docker, I just set the build and deploy servers to be the same in edeliver. To me, this is the best balance of cost, customization, and ease of use. 
I use digitial ocean as well, because it’s so easy to set up and cheap. For the pipeline I use distillery and edeliver. I don’t bother with docker, I just set the build and deploy servers to be the same in edeliver (to ensure the app runs on the same Erlang VM). To me, this is the best balance of cost, customization, and ease of use. 
Hey, thanks. I agree a lot with your rant and it's the same thing I've noticed. Do you use exq\_ui? I first used exq and than moved to verk, which seemed to be in a better condition. If you don't mind, how long have you been using Elixir in production? Are you happy with it?
I recently migrated from GCP kubernetes engine to Heroku. There's a slight drop in performance, but the massive reduction in complexity was well worth it for our tiny team. Developer time is very expensive. Paying a bit more money to Heroku is far cheaper than paying developers to manage infrastructure when they could be developing features, or at least it was for our particular situation :)
If you're looking for a Heroku like experience but on AWS or DO, I've liked using Nanobox in the past. They abstract away your deployment process so it's just a simple CLI command, `nanobox deploy`. https://docs.nanobox.io/workflow/deploy-code/ They handle dockerizing your code so it runs the same in Dev as it does in Prod. Here's my boxfile.yml which is all you need to get it running: https://github.com/mgwidmann/slack_coder/blob/master/boxfile.yml Here's there Phoenix setup guide: https://guides.nanobox.io/elixir/phoenix/
I wrote a hex package to help deploy Phoenix apps to Kubernetes: https://github.com/cschiewek/mandrag
https://gigalixir.com/ - I’ve not run a production app here yet, but my prototyping has been promising. 
Gigalixir has your back
Hey, for example sidekiq -&gt; quantum nokogiri -&gt; floki for scraping - &gt; httpoison &amp;#x200B; which gems u are interesting?
I understand you have a startup, why do you have such difficulties. Just use multiple servers to DigitalOcean and deploy through edeliver/distillery. When you're big, then you should think about something else
I want to start service for scraping which will suggest proxy automatically No need to think about the proxy search algorithm etc
I'm using GitLab to build a Docker image during CI, which gets pushed to their container registery. The production setup is running on Digital Ocean (provisioned with Terraform and Ansible), where I'm just running a basic Docker setup (no compose or Kubernetes). I'm using Watchtower (https://github.com/v2tec/watchtower) for automatic deployments, it just watches the docker registry for new images and automatically pulls them. It doesn't support rollbacks or health checks though so it's a bit dangerous. If I was to do this again I would use Kubernetes, but this was before DO offered it as a managed service (and I didn't want to run my own cluster). I know that Docker doesn't get much love from purists, but in my case it works really well. I don't need the VM to stay up while new code is deployed, and other code (non Elixir) is using Docker too, so it makes sense to be consistent. Kubernetes will be complicated if you don't have any experience with it or Docker, but it seems that's the way everything is going, so if you want to learn some dev ops it's going to be worthwhile to learn. 
I du this as well and even wrote a blog post a while back om how I use circle CI for deploys: https://mintcore.se/blog/2018/11/elixir-and-continuous-delivery-with-circle-ci
Why do u use python, its so slowly
Speed is not an issue, rather maintenance is. Working with existing libraries in Elixir was a pain in the ass so. That's why. 
Example? For me speed and parallel request is issue
Using erlport you can run python process in parallel and have communications between them. http://erlport.org/docs/python.html#send-messages-from-python-to-erlang Further, if you are crawling any website you can't take all their traffic, i.e you need to have wait time between consecutive requests. In our app we have it at 8 sec. How ever if it is not a third party website you are crawling the there is no need for a wait time. Then there isn't any point in using python. 
I'm not really using a lot of packages, but here are the ones I'm using in my current project: \* bamboo - for sending emails \* ex\_machina - factory/testing library \* geocoder - name says it all \* guardian - authentication \* arc\_ecto - uploads/attachments \* geo\_postgis - PostGIS features &amp;#x200B;
The mobile version of your site could use some padding. All the text is right against the edge
Generally it’s good enough to have experience in ruby or Erlang 
oh great, i come from perl and python w/ some few info of haskell but language barrier shouldn't be a hinder right? We are not on assembly anymore..
Think of job requirements as wish lists. They're what the employer wants but they don't always get someone that checks all the boxes. There's no harm in applying. The worst thing that'll happen is that you don't hear back from them. 
I starting working with elixir with background in python, js, a bit of clojure introduction and C. My employer did not require elixir expertise, we learn it everyday. It's been fun so far, after a little time I was developing nice features. So, just take your time, read the docs and create stuff. 
In any language u need a experience, at least 1-2 year, its not enough just to know the syntax. I got experience just doing own projects or writing any scripts 
Elixir is a relatively young language, so most companies don’t expect to hire people with a lot of experience in the language. If you have experience with web development in general, you will be fine. We find it normally takes people a few weeks to get up to speed, particularly if someone experienced is around to help. Go ahead and apply at https://www.cogini.com/careers/ :-)
My guess is that when transitioning to a new technology it pays to have at least a few "experts" in it to guide and teach newcomers. Where I work - SumUp that's what we try to do. We have 4-5 experienced erlang devs, have acknowledged exactly what you are saying, and aim to hire otherwise experienced people and give them the opportunity to learn erlang/elixir. 
Honestly, if you're a good engineer and you're willing to learn new things, that's much more important to a company than already having the experience. Unfortunately, not all companies will see it that way. But you'll find the one who does. 
Ditto this at my job
I've been in a high tech city working in IT for 20 years. Finding this type of company is like looking for a needle in a haystack. I'm not convinced they even exist. I believe there are individual managers who know this but even then their candidates get filtered by HR first.
I believe that companies that are using elixir in production are going to be those companies. Using elixir is still seen as a risky decision by a lot of managers since its relatively new. So any company that's hiring devs is going to already have an open mind. Related, this depends heavily on the size of company. The smaller the company, the more willing they might be to give you the freedom to develop as you see fit. For instance, you'll have much better luck if there is no HR department to be filtered out by. Granted, there's differences in programmer culture all around the world, and while everything I've said absolutely applies for where I am, other parts of the world could be completely different. That said, I do believe that the attitudes I've outlined above can be found anywhere, it's just a matter of how difficult those people are to find. 
Isn't env vars config problem solved now that we have distillery 2 and mix config provider?
Yes very possibly. I’ve been out of the elixir game for a bit and when I did this was still distillery v1.
There is even a post on this sub about it posted just yesterday, worth to take a look at if you've been out for a while but still intersted in it :) 
Makes sense. How would you go about seeking a company with this open minded culture? Not specifically limited to Elixir. Any insight?
Personally I've found that it's almost always going to be a SaaS product, not a consultancy. The requirements for consultants are different in a way that doesn't really encourage experimentation. From there, I'd begin reaching out to your local developer community, because chances are one of them works at a place like that, and another couple have an idea to start a company like that. Startups are a great place to work if you want to work with new, cutting edge stuff. Not having legacy code to maintain and manage frees you from always needing to ask, "okay, but what's interop like?" every time you evaluate a new language or tool. My current company, I was the first employee, it was just the CEO, CTO, and a few advisors related to the domain. Made it really easy to bend their ears when I could plop down a ruby version and an elixir version I made in the same amount of time, and we could all see the elixir version was superior. Insert your tool of choice though, I've found that as long as you're not suggesting something worse than what's already on the table you've got a much better shot when you're trying to convince the decision makers directly, and not you convincing your manager who needs to convince his boss who has to convince the CEO. 
I've been working as a C2C for consultant companies who contract out my work to large established corporations. And you are right... there is no encouraged experimentation. No no no. In fact, I had to build things in secrecy and present working solutions before they would accept anything new... even a new approach to an old problem using established frameworks. Thanks. There aren't as many startups in my area but there are probably some. I've always avoided them after the chaos of the DotCom bust of early 2000s.
I am a hiring manager, for entry-level/junior positions I don't expect people to know my tools at all. I don't work in a place that uses elixir though, we are ruby mostly. So, it may be that junior elixir positions do not exist, or at least are hard to come by.
&gt; Think of job requirements as wish lists. Only a poorly written job listing is like this. A well written one, and this is something I try to do personally, separates what I require, from what I would like, from what is "bonus points".
And you will tell me that if someone checks all "nice to have"s and will be missing one of the essentials you wouldn't consider that person?
I second this
In a well written job description, i think it'd take a truly unique individual to accomplish that. In which case I would talk to them because unique paths to skill tend to come from people with unique passion. Generally, or always as far as I'm aware, my nice to haves super-set my required skills. So ticking off every nice to have means having the required skills as well. Addendum: I put a lot of time into making my job postings honest about needs, and not listing things as needed for my own ego.
For sure, a startup is not the place to be if you need consistency. It's inherently going to be more risky than an established company. Personally I'm at a stage where that suits me, but I have plenty of friends who for one reason or another need the consistency and ridigity of a corporate environment. But those environments aren't going to allow you the freedom to use the kinds of cutting edge stuff you might otherwise want to use. 
just a follow up: this looks like an interesting little library: [https://github.com/StareIntoTheBeard/waverider](https://github.com/StareIntoTheBeard/waverider)
When will Whistle be available to the public?
Well, it is available: [whistle] (https://github.com/boudra/whistle)
[SICP](https://web.mit.edu/alexmv/6.037/sicp.pdf) is a good place to start.
This one is good. Author use javascript library rambda. But I think this shouldn't be a problem. https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/ 
Thanks, all that pops up with a Google search is a Reddit thread and this chat app.
One thing I noticed in the test app is that the back button is wonky. Seems like the route doesn't get updated immediately when you hit the back button.
Even if spawning an OS process was super cheap, the issue is everything you would need to load into that process in order to make it useful. For example, imagine if for every single OS process you had to load Elixir standard library and your dependencies to do something. So while Erlang VM processes and OS processes share nothing from the user perspective, in the actual implementation, Erlang VM processes actually share a lot: code in memory, literals, async threads, etc, which allows them to bypass this load time. You just don't have to care about it because it is not managed by you. OS processes could leverage copy on write and other stuff but that still wouldn't help on other areas, such as ETS and the mentioned async threads.
Yeah, it makes a round trip to the server, that is why. I have some ideas on how to optimize this though.
Is it really just the round trip to the server? Seems to take about a minute it to work.
Ah, maybe we're seeing different things then. A bit of delay should be expected but if it takes ages something is definitely wrong, I'll investigate! thanks
A statically typed language for the Erlang VM: [Gleam](https://github.com/lpil/gleam)
I don't even necessarily expect/require that from seniors. If you're well-versed in design skills, you show you can competently code, and have experience in some languages under your belt, you should be fine in a new language soon enough; especially one that has a gentle learning curve like Elixir. I mean, \_I\_ didn't know Elixir when I applied for my current job which wasn't relevant because nobody heard of it; now it's our main language :-)
Trigger-word for me so excuse the rant. OO versus Functional is not a real thing. The original OO programming language (Smalltalk) took a ton of inspiration from Lisp, resulting in stuff like even an if statement working just because of higher order functions. Ruby is called an OO language but borrowed tons of stuff from Smalltalk so has tons of functional constructs (like collection iteration taking function arguments); Python ditto, and it smells like Java is finally seeing the light, too. So don't be scared to cross the "chasm", because it's more like a plank about a foot-wide budding forest brook. The biggest differences: you will have more emphasis on organising your code about what it does than what it operates on (the latter being "this" or "self"). No inheritance to use nor abuse. And that's pretty much all... The biggest similarities: things like "DRY" and "SRP" are universal. Dependency injection is still a good tool, but you typically inject a module (just a bunch of functions) instead of a class/object. Encapsulation is still important - don't share and operate on naked maps everywhere, pull the trickier operations on structured data out. Don't overuse any magic the language offers (in Elixir, Macros) - readability is more important than terseness, and the two aren't always correlated. Regular "how do I write good code?" stuff. Interesting tidbit: In Elixir processes are very close to the original objects - Alan Kay once remarked that he should have called it "Message Oriented" as encapsulation and message passing are the core concepts of OO, not classes and objects; they are never used for code organization though, just for run-time "organization" ("should this functionality run asynchronously with other code?", stuff like that). Don't get hung up to the details. And SICP is a very good book, worth working through regardless of the labels people attach to them; it'll make you a better coder. 
Well Erlang Vm uses it’s own pre emptive scheduler, OS uses and needs more complex schedulers. You probably don’t want vlc media player to have same priority as memory paging routines. 
Thanks sir :-)
Practice.
They do: threads. But they are complex to use reliably and efficiently even in common cases. This is something the BEAM addresses. Still, things like hardware memory and instruction protection requires more seperation between threads of execution (bad hw design leading to things like meltdown/spectre aside), and so OS's tend not to just spawn everything as a thread. The difference between a thread and a process on an OS like Linux is very little in terms of performance and memory usage, but it is not entirely free to spawn and context switch to a process compared to a thread.
... and sleep well. :)
- Think in data transformation: your main way of doing things becomes "data in -&gt; data out" - Keep pure functions separated from side effects - If you need state, keep it as contained as possible (in Elixir, GenServers and friends should have a defined interface and never leak)
I also came from Java to Elixir. It is really all about sticking to the key concept that Functions don't \*change\* anything (i.e. they don't have side effects). They take parameters and return values. Any time your function is changing something, it should raise a warning flag for review. There are obviously legitimate places that do this, such as hitting an external API or storing things in a database, but if you are changing state in your own elixir code \*inside\* a function, it could probably be refactored. GenServers are a great example of this. handle\_call and handle\_cast take values and return values. They don't change state themselves, they just take and return.
You mainly just have to do it. I watched 10 tutorials and it never fully 'clicked' even though I understood it conceptually. It wasn't until I actually needed to transform a real piece of data where I just sat there for several hours trying to do something simple, and then it was like OOOOHHHHH
Building a GraphQL API with Google OAuth (or trying to at least)
It's kind of a more mathematical way of thinking.. or logic based. You'll develop instincts about when you've written something bad and contain it to go back to it later.. mainly because you can't 'prove' in your head that a function does it's intended purpose and is robust and clear. Practice practice practice and get used to thinking in pattern matching. Oh and keep in mind you'll probably write a smaller amount of higher quality code on average that gets right to the point.. so yes get lots of sleep and make sure to get quality programming time. &amp;#x200B; Programming in Prolog is probably the best way I can think of to practice concepts but that's going too far.. making something useful to you in elixir is good enough.
Atoms are used as mere identifiers for module names, function names, hashmap/dict keys, ok/error tuples ; whenever you have to name or qualify something.
From my understanding. It represent itself, :ok It doesn't contain anything like a variable other then itself is the value. The only example I've seen that made clear to me is that :ok is a universal expectation in Elixir of everything is correct and :error is crap happen. Ruby have symbol which is the same as atom iirc. The value is the same no matter the context or whoever program different code or something. 
Try solving problem that requires loop in OOP and do it only in recursion. Think about closure, higher order function, anon function, named function, and scoping within function context. If you're function is huge then you're doing it wrong. Majority of your functions should be small and composable that does one thing. Think about unix command and the pipe operator as an example. dave thomas programming elixir book talk about this and reiterator it. But it get lost because reader is trying to learn the language and these nugget of wisdom is something is learn through experiences. 
Atoms are items in an enum that stretches to infinity. In Java if a thing can be read I don't want to use the string red to describe it I would use some constant call it red in the sign at the number one or something. If I had several colors, instead of constance I would start to use an enum. this way other programmers know that it's not supposed to be a string that you can capitalize or do other operations too. It's a signifier. It supposed to mean something in and of itself. Also, at compile time it gets converted to a number so it doesn't take up as much space as a string or even an integer. Constants and enums are good programming practice. Elixir has an infinite one available for free. 
Thank you,and do sleep really matters learning FP?
I build a library which can make github markdown with nested markdown file all in one pdf file, if you need this, you can try: [git2pdf](https://github.com/madawei2699/git2pdf)
Been working on the final push for putting pushex up in production at my work. Ran into some other projects and had put it on the backburner. With that, I'm also working on some distributed state management that has been fun. Incoming blog post soon?
I'll preface this by saying that I am not an experienced erlang/elixir developer even if I've dabbled, but from lurking/reading/watching/planning to get started I believe I have some insight. I'd say that fault-tolerance, high availability, monitoring and network handling are at the core of erlang/elixir, especially the first parts. Erlang was, famously, invented in order to handle phone switches and similar, where massive amounts of calls needed to be handled in a stable and scalable manner. I'll let someone else answer the part about state machines, I want to say that it's pretty well-suited but unsure. It has a very nice handling of asynchronous operstions imo. As for ease of learning, YMMV. Elixir is imo erlang with extra bits, esp. in this regard, which means that it is a functional language at it's core. This may pose as a threshold when coming from C/C++. Lots and lots of recursion, pure functions, piping things, pattern matching, and generally just shifting you mindset. I like it, but it's different from how I wrote e. g. PHP and Java way back. Elixir has a clean, Ruby-like syntax which is nice, and I'd say that the language itself is very simple, but re-framing your mindset is more of a challenge, if that makes sense. String handling is improved in Elixir vs. Erlang, I'm not sure how it works performance wise, but regex- and string handling is pretty nicely implemented imo. The ideal use-casewould be to isolate small parts of your application and rewrite them in Elixir to see how they hold up and then go from there. 
&gt;Good string handling. I'll probably want to write hundreds of different regexes to parse the text-based protocols we use. Have a look at parser combinators before you get to that... &amp;#x200B;
I think it would be a very good fit. I have a few ideas, if you want to give me a shout I think I can help you, You can set a time to talk to me here [https://calendly.com/zkessin/elixir](https://calendly.com/zkessin/elixir) &amp;#x200B; The only issue I see here might be Windows XP support * Long running services. Our software typically runs in warehouses isolated from the internet for years on end. I recently did an upgrade on a site that had been running with just a handful of interruptions in the last 15 years... Yes, very much so * Communication on multiple TCP sockets using multiple homespun protocols. Up to 30 clients, all needing to have input/output handled, buffered to disk, timed and logged. Pretty simple * Good string handling. I'll probably want to write hundreds of different regexes to parse the text-based protocols we use. Context free grammars and regexps will help you here * It should ideally be *really* easy to implement state machines. It's really hard to take a big, complex piece of C++ and split it up into multiple parts, where we wait for a state change to run the second part. Previous programmers on our C++ codebase have given up and simply put in sleep() loops all over the place, causing stalls on critical paths. Easy * Binary data handling, preferably something like Pythons struct package. Check out pattern matching on bits * Low skill ceiling. We've got a lot of programmers who are used to C, C++, Python and C#. * Tool support. Specifically tools which inspect the system as it is running, debuggers and IDE:s. See Erlang in Anger * Windows service support. All our software run as Windows services. We expect it to be backwards compatible to at least Windows XP (we dropped our NT4 support just a couple of years ago). This might be a problem. * Fault tolerance in the face of outside issues. Our software is installed by the customer on servers that we don't control. We'd like to be able to detect memory crunches caused by other misbehaving apps and log them *before* we crash. Other potential issues are network latency, antivirus scans messing with file access. Easy to do &amp;#x200B; &amp;#x200B;
&gt; * Long running services. &gt; * Communication on multiple TCP sockets using multiple homespun protocols &gt; * Fault tolerance The Erlang VM was designed for this, so this is a perfect fit. &gt; Good string handling. I'll probably want to write hundreds of different regexes to parse the text-based protocols we use. Elixir/Erlang developers tend to avoid regular expressions thanks to pattern matching. Regular expressions in Elixir/Erlang likely won't be as fast as in C/C++/Ruby/Python/etc. But there are projects like [NimbleParsec](https://github.com/plataformatec/nimble_parsec) which allows you to compose grammars, which should be more maintainable than regexes and is going to be very efficient. &gt; State machines Erlang ships with a very complete behaviour for state machines: http://erlang.org/doc/man/gen_statem.html &gt; Binary data handling Matching on binaries and packets in Erlang is pure joy and the syntax is available in Elixir too. Here is how would you parse an ipv4 packet in Elixir: &lt;&lt; version :: 4, ihl :: 4, # Internet Header Length _dscp :: 6, # Differentiated Services Code Point _ecn :: 2, # Explicit Congestion Notification _total_length :: binary-size(2), # Includes IP Header and payload (16 bits) _identification :: binary-size(2), # 16 bits _flags :: 3, _fragment_offset :: 13, ttl :: 8, # Time To Live protocol :: 8, _header_checksum :: binary-size(2), # 16 bits src_ip_address :: binary-size(4), # 32 bits dest_ip_address :: binary-size(4), # 32 bits rest :: binary &gt;&gt; = packet It feels like a direct translation from the specification to code. &gt; Low skill ceiling Hard to say. We do see developers coming from Python and C# who enjoy Elixir. C and C++ are less common. I guess you won't know until you try it. &gt; Tool support Tool support is getting better with projects like VS Code but most likely inferior to what you get in C/C++/C#. &gt; Windows support You can deploy and install your Erlang/Elixir system as Windows services, no problem here. I am not sure if it can go back to Windows XP but most likely yes. 
&gt;Pretty simple &gt; &gt;Good string handling. I'll probably want to write hundreds of different regexes to parse the text-based protocols we use. &gt; &gt;Context free grammars and regexps will help you here &amp;#x200B; I'd strongly recommend the use of [nimble\_parsec](https://github.com/plataformatec/nimble_parsec) if you're looking for a performant, easy to use context free grammar - the only other parser library I've seen, remotely as easy to use - is Python's pyparsing module (introduction [here](https://www.accelebrate.com/blog/pyparseltongue-parsing-text-with-pyparsing/)). Elixir string and byte matching/handling (unicode in particular) is probably the best I've seen on any platform (ex Perl developer here). &amp;#x200B;
Maybe posting this on r/elixir is a blasphemy, but here it goes :) Golang could be a good fit as well. It has a great backing, good IDE support, it's pretty popular and has a big community. It's easier to adapt in your company for sure, since it's very C-like, where Elixir requires to shift your mentality. It should do great for most of your requirements except for fault tolerance. Elixir gives you a first-party support to help you with that (ofc that doesn't mean you get that for free).
I second all of the replies in the post above.
This is a good point. I was oversimplifying. Thanks for the clarification.
While Go could be a good fit I think it'd be more because a team works well with Go, rather than it fitting well here. Erlang was explicitly designed for a lot of the requirements listed above, while Go was designed for Google's environment (i.e. not long lived, batch processing oriented, HA done at the container orchestration level, etc)
Yeah I agree, and parsing is not nearly as nice.
It seems like Elixir is a good fit for your functional requirements. The seasoned C++ devs will appreciate many parts of the functional and how erlang/elixir does VM's, state machines, and compartmentalization of modules in a project. They may become a little frustrated in trying to do a 1-for-1 translation from legacy code in the areas of data structures and objects initially. There may be an opportunity for you to even use it outside of Windows on embedded systems, like the Raspberry Pi and the Nerves Project depending on your use case. I think the thing that you'll love (and your programmers) the most is the out-of-the box testing capabilities of Elixir. In our experience testing large projects (aka umbrella projects) or individual components has led to rock solid applications. It has been rare to see an issue crop up in production that doesn't show up in the test-suite (e.g. that use case was not covered or there was no code coverage). &amp;#x200B; &gt;Long running services. Our software typically runs in warehouses isolated from the internet for years on end. I recently did an upgrade on a site that had been running with just a handful of interruptions in the last 15 years... YES - I've seen rock-solid repeatable performance in similar situations. The best part is not having to worry about memory handling like in C++. One thing that I've noted in the Elixir community is that packages don't need to be maintained as much as in other communities (or updated unless for a reason....). If it ran and passed tests then, it almost always runs now. &gt;Communication on multiple TCP sockets using multiple homespun protocols. Up to 30 clients, all needing to have input/output handled, buffered to disk, timed and logged. YES - [GenServer](https://hexdocs.pm/elixir/GenServer.html), Supervisors and Agents will handle many of process management for managing different clients in any customized or specialty way. ([https://robots.thoughtbot.com/playing-with-sockets-and-processes-in-elixir](https://robots.thoughtbot.com/playing-with-sockets-and-processes-in-elixir)) &gt;Good string handling. I'll probably want to write hundreds of different regexes to parse the text-based protocols we use. YES - Elixir pattern matching and method guards may feel like a godly for this kind of purpose. &gt;It should ideally be *really* easy to implement state machines. It's really hard to take a big, complex piece of C++ and split it up into multiple parts, where we wait for a state change to run the second part. Previous programmers on our C++ codebase have given up and simply put in sleep() loops all over the place, causing stalls on critical paths. YES - Implement your own statemachines using GenServer, or use a package like [Machinery](https://github.com/joaomdmoura/machinery) or [FSM](https://github.com/sasa1977/fsm). Either way, &gt;Binary data handling, preferably something like Pythons struct package. YES - Out of the box &gt;Low skill ceiling. We've got a lot of programmers who are used to C, C++, Python and C#. YMMV - Yes, it is easy to learn if you want to learn it. As with all things, it will take time to learn in a new language and environment. There are different tools (VS CODE), methodologies, and practices to learn. It is unfair for to take any seasoned developer and ask them to become productive in a new language without a reasonable period of learning. &gt;Tool support. Specifically tools which inspect the system as it is running, debuggers and IDE:s. VS Code - The plugins are getting better and better.. &gt;Windows service support. All our software run as Windows services. We expect it to be backwards compatible to at least Windows XP (we dropped our NT4 support just a couple of years ago). YES to windows services, Windows XP might be an issue. &gt;Fault tolerance in the face of outside issues. Our software is installed by the customer on servers that we don't control. We'd like to be able to detect memory crunches caused by other misbehaving apps and log them *before* we crash. Other potential issues are network latency, antivirus scans messing with file access. YES
I posted a similar comment on r/linux the other day and got completely flamed. Funny how cultures are different
[removed]
Ubuntu WSL. I'm just so used to bash vs cmd or powershell.
Could be a warranted response to a large volume of low-effort posts.
Thanks for the encouragement. I have done just that: https://eccentric-j.com/blog/3-functional-programming-experience.html
You posted "what this person said" to someone who replied "Yes to everything" to another comment. I'd say there's a difference in the scenario.
when combined with keto and alchohol I kid. But of course I think being in a good state helps with any programming. However with FP it just trends a little closer than class based to consistency and avoiding hacks.. being able to write short clean code is more common
I'm not really sure I understand the way you're using tuples in your examples, but to answer your general question, yes I would recommend using structs whenever you have some complex maps the you want to have a documented and clearly defined structure. Keep in mind that structs always contain all keys, so you can't pattern match on whether the key exists. Typespecs are also a good idea if possible, but mostly useful if you're doing static code analysis with something like credo.
in my professional life i use structs and typespecs all the time. they may sometimes seem like overkill for small toy apps or even larger things that are written once and then thrown away, but when you have to keep making changes to a growing system over months and years they really help a lot. 
Godspeed OP. This sounds like an intense undertaking, regardless of which language you choose. :)
You mean dialyzer, not credo.
It looks like your pattern is very similar to Erlang's \[Records\]([http://erlang.org/doc/reference\_manual/records.html](http://erlang.org/doc/reference_manual/records.html)). Best practice in Elixir is to use Structs, not Records. Generally the only time I use a tuple is for \`{:ok, record} | {:error message}\`, or for building a Keyword list. In my professional experience, Structs make it easy to extend (add some new data in the middle of a pipeline usually), and they make it easy to understand what data you've got. If I'm debugging something and the function I'm in just has \`result\` as a parameter, that just means I have to go read a lot more code to figure out what kind of result that is.
I've increasingly used Typespecs and Structs more as I've used Elixir. Helps avoid coding errors when you have Dialyzer running. Functional programming, especially Elixir, prefers highly declarative/specified expression - you'll find that using Typespecs will help you break out of imperative habits.
I really like using typespecs as a form of documentation. They make it more clear how things are meant to work. Structs have been useful across abstractions. Inside the same abstraction (such as handling GenServer state) I tend to use tuples or maps
Just wanted to add that while reading binaries in Elixir is awesome, writing is... Not so much. Couldn't remember where I saw something about this rn, but if I do find it again I'll link
yes, thanks
Injecting url state and managing the browser history stack should be first order functionality in a library like this, it is far to easy to build ui that effectively change the state of display so that any user would expect the browser history(back) to function seamlessly. Without this type of concept working really well you are stuck with relegating such a library to make inline dom swaps of interstitial content. I would think you really need a generalized take on history stack against "route" like content changes vs inpage/partial changes. 
Atoms are symbols in lisp. They are like strings and can be used for comparison but are faster than strings. 
If the data in question has a specific meaning in the problem domain then I always use a struct. Eg. User, Project, Event, Translation, etc. You can leverage structs and pattern matching in Elixir to extremely clear and concise code. I use other datatypes quite often but I tend to reserve them for function returns or manipulating a subset of data. &amp;#x200B; I use typespecs the majority of the time when writing code professionally and quite often when working on my on projects. The [ElixirLS Extension](https://github.com/JakeBecker/vscode-elixir-ls) for VSCode automatically recommends typespecs. The defaults are pretty broad but it only takes a minute to update the generated spec to use the proper types.
It depends entirely on the flow of the application and whether or not I actually *need* a struct. I am weary - as all elixir devs should be - that a struct can often be likened to an abstract class in an OO mindset, and in that context it is corroding the benefits of a functional language. That said, structs have immense benefits when it comes to pattern matching and speed. José has written an awesome response detailing when to use structs and records here: https://groups.google.com/forum/m/#!msg/elixir-lang-talk/6kn7J2XnFg8/I5poTNCEHwAJ Then your second question. Yes. Use Typespecs, you’ll thank yourself when you go back to the code a few months/years later. 
&gt; How many of you use Elixir typespecs and types to document your code? Does it help I do. I make sure I use them on all public functions, and will use them on some private functions where the expected usage might be a little unclear. And the more explicit the spec, the better. For me it's basically crucial, as a form of necessary documentation. If I'm working on my own codebase and I don't remember how the function works exactly, I just refer to its spec and I can immediately see (compare that to having to read through the code). If it's someone else's codebase then I feel it's even more important as it helps tell me what he correct behaviour of this function is (is the fact the function returns a certain result a bug as it might appear or was it actually intended?, etc.), and vice versa (so others can see the intention of the code I've contributed to the project). Many times I'll actually write out the spec first (especially if the logic is quite complex or I'm dealing with much more complicated data structures), as I find it much easier to go from spec to implementation than I do the implementation alone. I make a lot fewer mistakes when I do this than when I don't. Lastly the fact I can just run the dialyzer and it can now do an even better job at finding mistakes is just an added plus. &gt; In my code I use a lot of tuples like &gt; {:type1, "some data"} Tagged tuples are a convenient strategy though I wouldn't use them for documentation/static typing (that's what typespecs/docs are for), but anywhere you need runtime reflection/inspection then they're a great choice. Now they are very similar to structs in that way. When I'd opt for a struct instead is if the access is more efficient when the collection is a map instead of a tuple, if they have a standard structure, if I'll be making use of them often, will I be defining new types at runtime (this could go either way), do I want the protection of runtime errors at creation (if there's some incorrect usage, e.g. missing required fields), and lastly what kind of interface do I want (if I would like to use a keyword list, then it might make more sense to opt for the tagged tuple). If I just have some simple code where I just need a quick solution to give me some way of identifying data (say in my else clause in a with expression), then that's where I'd definitely use a tagged tuple over a struct (it takes more effort to add a struct and here there isn't really a benefit). Either way if you'll have a public interface that uses tagged tuples or structs, you'll still want typespecs defining how that data looks. 
Reason why there's very few entry level opportunities with elixir is simply because it's such a young language. Very few places that are using elixir would have started off as elixir shops. Many of the places will have their pre-existing technology stack and are adopting elixir, either by using it for new projects or porting projects over to it. Due to this (at least in the transitioning stage) it will likely mean the team will be very experienced in their pre-existing stack, but might be a little green when it comes to elixir (there will probably be some in the team that are taking the lead/might have a lot of experience with it). So because of this transitioning phase, it really doesn't make much sense for the company to bring on entry level devs (who need a lot of training and support themselves, something the team might not even be able to provide at this point) for this new language, at least not yet. If the company is looking to bring on some entry level devs, it will most likely be in their old stack (but may incorporate some elixir). Typically you'll need to wait until he company and team becomes more familiar and confident with the new tech, before you see them bringing on entry level devs specifically in that tech. Now this also answers why most elixir job posting are asking for experience. If they are in this transitional phase, they'll be looking for some experts (at least those with more expertise than the team) that can help make that transition as smooth as possible. Now I take it you're someone that would be looking for an entry level position? The best course of action for you (if you want to make use of elixir ok the job) is find companies that do currently use it, look at all of those that have a mature elixir codebase and see if they have any entry level/jr positions. Otherwise for the rest, find out what the company had previously used and see if they're offering any unrelated entry level/jr positions (and just make it known that you're learning elixir too). 
How is that? It's the same syntax
Well you got me with those sharigans.
Why are you using Poison decode as atoms even for incoming messages [u/BilalBudhani](https://www.reddit.com/user/BilalBudhani)? The article also suggest using Regex, which I would say should be a discouraged approach as there are better ways.
\`def handle\_event(message = %{type: "message"}, slack, state) \` this is the method which is handling incoming messages. It doesn't use Poison, \`\`\` #3 use regex to match input and reply with appropriate response. SlackCommands.reply(message, slack) \`\`\` We are using regex to find the right keywords and respond appropriately. Are you suggesting using parsers like \`leex\` and \`yacc\` instead ? I learnt about them later and will use them to replace regex code in future. 
I currently work on phoenix project for automatic-translation of localization files for different frameworks - LangTool. Main feature - user selects file with localization strings for his framework (Ruby on Rails, Django, Phoenix, Android, iOs, .NET, anything), chooses destination language and LangTool will modify file for chosen language. I builded it previously with RoR, but right now - making it with Phoenix. Source code on github - [LangTool](https://github.com/kortirso/langtool)
This topic is near and dear to my heart. Thanks!
I had a lot of fun with this code. I'm always blown away by how easy RPC is across a cluster and how that leads to pure BEAM solutions. As always, free for any questions here.
Hey everyone! In this article we see how to cluster Phoenix Chat nodes, using distributed Elixir. We see how pg2 works and inspect how Phoenix efficiently broadcasts the messages in a distributed chat app. &amp;#x200B; As always, please let me know any question or feedback you have in mind :)
Did you try riak core?
I did not. From a first glance it looks a bit complex for my needs but I am curious about it
I started on Ruby, and I had a similar question about symbols. They are not garbage collected, as others have mentioned. They're useful when you are able to trace down \*all\* of them. Do not arbitrarily convert strings to atoms, especially strings that come from user input. The purpose is that it's an identifier.
I use them constantly. I've noticed the compiler catches a lot more errors when I'm using structs than when I'm not and so it ends up just saving me time. Also I find myself locating a lot of utility functions in my structs to create or modify those structs in intelligent ways, so I might as well do it from the beginning. As for typespecs, I don't use those as much. I never feel the need to use dialyzer or exdoc and so I just end spending a lot of time writing them without getting any benefit. That said if I am making a library for other users, I will go ahead and try to do it as much as I can.
Is the data sharded between the different nodes, or do all nodes contain the whole data set?
All nodes contain the whole data set. I chose this for my solution because I will only have ~50k cache entries which will be about 2-5MB of data. This makes it so that if a node crashes, I don't lose any data (it is already replicated around the cluster).
Not sure about what I'm going to say, and maybe that was a controversial question, but I think it's called a replicated cache (all replicas are the same) and not a distributed cache (entries are sharded, possibly several times to avoid data loss). Actually I think cachex supports sharding: [https://hexdocs.pm/cachex/distributed-caches.html#content](https://hexdocs.pm/cachex/distributed-caches.html#content) Also, have you considered mnesia and if it didn't fit your needs, why? I've been thinking for a long time that there's a real need for a Mnesia library that would handle auto join and repair (such as what is done by [https://github.com/jr0senblum/jc/blob/master/src/jc\_cluster.erl](https://github.com/jr0senblum/jc/blob/master/src/jc_cluster.erl) but in a reusable fashion). Finally, there's another cache that I've come across which seems quite good (haven't tested): Nebulex ([https://github.com/cabol/nebulex](https://github.com/cabol/nebulex))
The name seems fair. I'd hazard a guess that a replicated cache is a distributed cache (square vs rectangle). I looked at mnesia but it was pretty complex to get working and is very manual for many things. I've heard that mnesia would solve this problem, but it just looked tricky. Would love to see a modern write up on this if you've been looking for a topic... Nebulex looks great. I didn't see the option for replication which made me not use it. I went with cachex as the base due to how well utilized and solid it looked.
...my coworker built this and I refined it.
Legit. ... receive do {:get, pid} -&gt; send(pid, {:get_res, val}) |&gt;IO.inspect(label: "13") core(val) ... &amp;#x200B;
Hi guys, I was experimenting with `handle_continue` and wanted to make some race conditions to prove that it would fix them. This post is about one which I think is pretty common: sending messages to a process by `name` (and not `pid`). You can play around with all of the examples, which are linked from the blogpost.
And how do you use it?
I have a similar snippet without the pipe, use it very frequently, good tip
Just learn them at the same time
Postgresql, if you don't already know SQL. You need to know SQL. After that, GraphQL is pretty easy.
If you are focusing on an elixir stack, learn Ecto and then GraphQL
Add it to your user snippets, type ins, hit tab, and an io.inspect appears. I use line numbers because if I'm doing a multiline io.inspect, each can have their own ID and I can remove them very easily in batch.
They're some sources making the distinction ([https://stackoverflow.com/questions/8582836/ehcache-replicated-vs-distributed-cache-configuration](https://stackoverflow.com/questions/8582836/ehcache-replicated-vs-distributed-cache-configuration), [http://infinispan.org/docs/stable/faqs/faqs.html#what\_is\_the\_difference\_between\_a\_replicated\_cache\_and\_a\_distributed\_cache](http://infinispan.org/docs/stable/faqs/faqs.html#what_is_the_difference_between_a_replicated_cache_and_a_distributed_cache), etc) but I agree a replicated cache is a distributed cache with nb\_shards = 1 I guess. I've been looking closely at Mnesia indeed. As far as I know there's no plan to change the current API. The current Mnesia API provides with in-memory, disc and hybrid storage. It's replicated, not distributed and your tables will be limited by the size of your memory (except for the disc-only storage, but you seldom wanna use it). Regarding the CAP theroem, it's neither AP nor CP: when a netsplit occurs, it either stops working or you'll have 2 separated islands that will continue working concurrently. When joining again, the default is that you have to manually handle the situation. The most common scenario is to kill one island (typically the tiniest one) and rebuild it from the largest one. Totally fine for a cache, not fine for other scenarios (when data loss is not acceptable). One can also use a custom re-join function ([https://github.com/uwiger/unsplit](https://github.com/uwiger/unsplit)) but that's complicated. So yeah the main difficulty with Mnesia is its difficulty. It's rock solid, but one has to deeply understand its inner working. I've been thinking about writing a wrapper-library for Mnesia handling: * auto-join of nodes * auto-re-join with the following policies: kill smallest island (ok for caches), union (ok for tokens with an expiration date) and intersection * easy and auto configuration, for instance you could configure "For table \`:my\_table\` I want memory copies on 80% (and no less than 2) of the nodes, and disc copies on 3 nodes (preferably node3, node10 and node11)" * expiration/pruning routines That said, as soon as you start making a distributed system [you \_need\_ to deal with netsplit](https://aphyr.com/posts/288-the-network-is-reliable). How does your library behave when a netsplit occurs? If you have one or two days off, I'd suggest reading the old but gold Jepsen articles: [https://aphyr.com/tags/jepsen](https://aphyr.com/tags/jepsen)
https://elixirforum.com/t/self-hosted-hex-repo/12279/3
Understood. Thanks 
Cool, very nice!
Indeed, how can one learn a web stack like phoenix, without learning a data storage query language?
Postgres. Postgres. Postgres. I cannot emphasize enough the importance of getting skilled in relational modeling and SQL. It will remain after GraphQL is replaced/superseded by whatever data access behavior replaces it.
It depends on what your goals are. If it's to get a job doing this, try searching for "postgres" vs. "graphql" on a job search engine, and compare how many hits you get. ;-)
This is really good stuff. But I already told you that after your talk on it on last wednesday's meetup ;) Would love to see more like this :)
https://elixir-lang.org/getting-started/io-and-the-file-system.html https://hexdocs.pm/elixir/File.html
Good stuff. Thanks for sharing!!
Yes, love it :) Gonna use the error codes in a txt file trick
Here you go: [https://hexdocs.pm/x509/readme.html](https://hexdocs.pm/x509/readme.html)
Thanks for the read. Just discovered that &gt;Function bodies support rescue, catch, after, and else as [Kernel.SpecialForms.try/1](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1) does. [https://hexdocs.pm/elixir/Kernel.html#def/2-rescue-catch-after-else](https://hexdocs.pm/elixir/Kernel.html#def/2-rescue-catch-after-else)
Those are very cool examples! I Wonder why Canada needs a macro. For me `can? user, :read, post` is more readable than `can? user, read(post)`. Macro is pretty straightforward, but I wouldn't introduce even a simple abstraction just for exchanging a colon for parentheses.
Nice! Had the pleasure of being there in person, great talk. I'm definitely going to use that postgrex pattern in the future. 
Nice collection. One cool thing you can do with @enforce_keys is use the module attribute in your defstruct. This avoids double typing the enforced keys. Also, you can ++ [] to add keys that aren't enforced.
TIL. That's amazing! 
A spent a good couple minutes looking at that catch. I’d never seen that until now. Very cool. 
There have been old models for this, like the one in the old sunos. Here's a whitepaper about the structure: https://www.usenix.org/legacy/publications/library/proceedings/sa92/eykholt.pdf IIRC the main issue was that it didn't deliver the performance the people expected. 
&gt; atom aren't garbage collected in BEAM VM. Do not abuse them. This one's important. thanks!
Nice! &amp;#x200B; I learnt Elixir from the same course, Stephen Grider is great, Curious where you're hosting everything since you're not charging for your product?
how did you learn Phoenix 1.4 stuff from that course? I had the impression it didn't even cover 1.3's Contexts also is there a reason why you have both `poison` and `jason` dependencies?
Just on a Digital Ocean droplet for now. If it gets some traction we can add some features to monetize it with I'm thinking but for now just wanted to get it out there.
Nice one - did you dockerise everything before deploying out of interest?
Yeah it covers 1.3 as he says 1.3 is a lot easier to grasp. I'm not sure how it's easier or harder. Maybe contexts? All the basic stuff translates pretty well though and from a high level it was still super helpful. I still need to figure out the context stuff fully. I mostly just did the upgrade and fixed what it told me to. Don't totally remember why on the deps. I think Jason was recommended in the upgrade path to Phoenix 1.4 but then Ueberauth liked Poison or something. Or maybe I just forgot to pull out Poison. &amp;#x200B;
Nope, one less thing to learn. Will get to that if I need to.
Yep I just forgot to pull it out. Fixed.
That's a wrap on applications for our **Code BEAM SF** **diversity** scheme! &amp;#x200B; Next step: Code BEAM SF partners Travis Foundation and Diversity Tickets will review all applications and award places to those who would most benefit from them. The Code BEAM SF team be in touch with all applicants by 08 Feb! 
both
Congrats on tackling a new skillset! I'm not sure how confident I'd be tackling elixir the first go around but I've found what little I've done with it great and sometimes frustrating (since it's a paradigm shift from some other languages imo)
The only thing of all these things that has not changed much in decades is SQL and there is a very good reason for that. Learn SQL. Specifically, learn to understand how inner join, outer join, left join, right join work... those are the hardest parts IMHO. Everything else is pretty trivial.
&gt; Atoms are items in an enum that stretches to infinity. Technically there's a cap of 1048576 but you can raise it I believe.
I create a messenger bot to notify me League of Legend game schedule and deploy it to Heroku. [Source code in github](https://github.com/pearl2201/LOL-Schedule-Bot) &amp;#x200B; 
A Medium clone, but without limit for reading any articles.
I think the vast majority of folks use React. I’ve heard of people exploring Elm but I don’t know anyone using it for business.
* Front end: Vue.js, or, more specifically, Nuxt * API layer: GraphQL via the awesome Absinthe library * Back end: Phoenix This is currently the best stack I know for applications that require complex interaction. Once Phoenix Live View is released, I will consider that for the 80% of uses cases that only require a sprinkling of interactivity. I tried going down the React rabbit hole of JSX, HOCs, Sagas, and just really didn't enjoy the way everything fit together. I did not feel productive. Vue, in contrast, feels much less "pure" and more pragmatic in its approach to structuring components. Nuxt adds another layer on top of that, providing reasonable defaults for entire applications and awesome tooling and features around that. There's a bit of weird syntax and Vue can do A LOT, but the docs are really good and complete, and both the core team and community are always improving the tools.
I'm using Elm.
I concur! Except I dont use Nuxt. Vue as the JS framework and Tailwind for css. Amazing combo
Ah yeah, +1 for Tailwind as well. Though I wish it supported the utility classes in component CSS.
I've built a production real time chat application for a client with Elixir/Phoenix/GraphQL for the API and Elm for the web client. Elm is pretty amazing, but even after months of working with it, it's still a total mindfuck and your productivity doesn't feel as high as something like React or Vue. That said, Elm never breaks in production, which was insane. The other thing to consider is that most junior devs might struggle to get their head around Elm, so you might be killing your team's ability to get anything done depending on how many juniors you have around. In general I try to avoid JS as much as possible, but I think I'd choose Vue for future front-end heavy applications. Live View looks really promising too. Having stuff render on the server just makes everything so much easier to reason about and test. NEVER doubt the wisdom of the Elixir/Phoenix core team 💪💪💪
&gt; I try to avoid JS as much as possible Why? front-end frameworks have some of the largest dev communities in development, so why would you avoid that? Yes, server-side rendering has it's place, but SPAs are made for a reason.
I've been using reasonml as of late.
No qualms with any of the big front end frameworks, I just find that dealing with JS in general results in lots of decision fatigue. There's just too to much to choose from and changes too frequently. Everything from package manager to packages to which language you want to write (coffee, typescript, vanilla, ES6, JSX, etc) to which asset pipeline to which promise library to which style guide, ad nauseum. This might be a symptom of just because JS is so hugely popular, but I just find I'm more productive if I avoid it whenever I can. Languages (and their frameworks) like Ruby and Elixir tend to have "a way to do things" and I have just found it like a breath of fresh air to outsource a lot of decisions to the language and framework architects.
Currently at work our app is vue on the frontend and increasingly more elixir on the backend. Keeping an eye on Phoenix live view though 
It is super rare that I have the luxury of avoiding a front-end framework or compilation tool. I welcome the idea of the "headless" application tho and appreciate the separation between the backend logic and the front-end tooling. I find that back-end frameworks often "get it wrong" on the front-end and introduce just as much complexity by interweaving html markup with their own template markup language and subsequent controller-issued variable markup. The benefit of JS is that it's cross platform, so I can take my JS skills to any platform and not be tied to whatever the platform is restricting me to.
\+1 Feel the same. Vue.js is a great frontend.
I'm not doing anything for netsplits, but that is because the cache doesn't need to be 100% accurate across the cluster...I just don't want an influx of requests coming in on reboot or the same request happening again and again. This is, of course, a very particular use case which is why I wouldn't turn this into a library. However, the purpose is to discuss looking at requirements rather than picking a library off the shelf that may do way more than necessary.
Ember, both personally and professionally. It doesn't get the buzz the others do, but it's totally awesome. Their commitment to stability has been a huge boon for our team of small developers.
\+1 for Vue.js and GraphQL! Found less of a learning curve with Vue compared to React
I think SPAs are way overblown, and their (supposed) primary advantage is often counterbalanced by the UI deficiencies and glitches they introduce.
So you think GMail should be server-side rendered?
I don't use GMail so I can't say for sure. I think YouTube could benefit from some server-side rendering, as it tends to glitch every once in a while when I change the channel.
You just described my favorite stack. Vue is definitely my first choice of JS frameworks.
In my experience many back-end frameworks, especially Rails do a great job. Not only that, but you can bring Turbolinks and StimulusJS over to other back-end frameworks like Phoenix and they work just as well. For 95% of projects, that approach will work fine and be more productive than a full-blown front-end framework. For the others, you can adopt Vue, React oe Elm as needed.
Gmail was written in GWT (Java) because Google, especially at that time, hated JS. Even now, most of Inbox is written in Java and a lot more is driven from the back-end than you might guess.
Hm, thanks for bringing that to my attention
Good article, I was reading [Functional Web Development with Elixir, OTP, and Phoenix](https://pragprog.com/book/lhelph/functional-web-development-with-elixir-otp-and-phoenix) and the example `GenServer` created in the walkthrough mentions the race condition introduced by the "trick" of sending an `:init` message to self, but it doesn't discuss solutions. `handle_continue` seems like the simplest approach (though to the author's credit, I don't think this was available when the book was written).
Give a shot to [Hyperapp](https://github.com/jorgebucaran/hyperapp)! It's philosophy is more like in Elm, but you work with JavaScript and you can create components with JSX as in React.
We use React
+1
+1 to Ember; knowing I can upgrade and not have a ton of addons break is great.
I like SPAs myself, but Google more than has the manpower and competency to deal with the UI deficiencies and glitches he's calling attention to.
just learning phoenix at the moment, but if i ever make an app i'll use [bucklescript-tea](https://github.com/OvermindDL1/bucklescript-tea) because the dev is a phoenix user and has [docs up](http://blog.overminddl1.com/posts/setting-up-bucklescript-with-phoenix/) on how to integrate the two. they're also very friendly and responsive on github. i currently like [ocaml-vdom](https://github.com/LexiFi/ocaml-vdom) (based on `js_of_ocaml`) for front-end stuff, and bucklescript shouldn't be too much of a leap (the main disadvantage is you don't get automatic access to existing ocaml libraries any more, but bucklescript has a pretty strong ecosystem).
We're using elm with phoenix 
Glad somebody appreciated me burning karma to be helpful! Not sure why the other people on the thread are so hostile, though…
React or Vue, mostly because those are what others tend to know most. I've used elm and others, but it doesn't do any good if you're the only one on a team who knows it. You take a big productivity hit using something that everyone has to get up to speed on and maintain moving forward. Personal project wise, I haven't found one to be better than another. So it really just boils down to personal preference. Whatever has better documentation. Front end is also agnostic to whatever the back end is designed in. Whether the API layer is elixir, Java, .net, etc is irrelevant since most of the time UX design doesn't concern themselves with how the data gets there, just that it's there.
Right, it became available in OTP 21 (from work done by the Elixir core team I believe). If you are running on a version that supports it, I don't think there is a reason not to use it.
Also working through the same course. He's phenomenal at explaining the meaning behind his code. Also grabbed his Flutter course, which I've only skimmed so far but seems just as good. 
&gt; lots of decision fatigue All the decisions you name are one-time deals for the most part. And it's not the worst thing to hire people that are highly proficient with the front end so you can focus on the back end, and then you have a highly responsive and flexible app and everyone is happy. 
Sometimes! First load sucks. Then when you reload the page, and takes forever to load I wish it was just rendering the inbox. If you open compose or an email in a new window or tab and it has to load the whole app, I wish it was just rendered server side. You could do 90% of gmail functionality just as fast, and occasionally 10x as fast if you rendered server side, and had a smattering of ajax. 
We used Vue with Nuxt for a real-time chat app, and graphql as the API layer.
Can you elaborate on your dev setup, build process and debugging vis-a-vis JS ?
Have you tried out Apollo with React? Heard it's really good support for GraphQL
I personally run it in basic html mode so yeah, I kinda do. It still sends and receives emails. 
Doesn't elixir use that much memory because it grabs it and keeps it in the BEAM pool for reuse later on?
Nice post! How was node run? Was it a single process? If not it would be intresting to see results when the node is run on all cores.
Aka [Clusters](https://nodejs.org/api/cluster.html).
There are no RAM analysis/graph, it's a CPU one. But it's really interesting how it goes up to nearly 100% CPU and still handles all the request withouth performance issues, I wonder if incrementing even more the benchmark it will perform equally.
If you want to delegate the clustering to a process, and you probably use somekind of supervisor process, like pm2 you can just run your single core nodejs app with a single command: pm2 start app.js -i max That automatically checks available cores and spins up more processes to utilize them all.
It is not about only prformance benchmarks when choosing new platform. You should count as well codebase maintanance costs in long term. Developer Experience (DX). Costs to rump up new team members into existing codebase. I think Go did a great job in this space.
It's possible the schedulers are spending time busy waiting, so CPU utilization would look high while scheduler utilization is moderate. https://gist.github.com/eiri/a87459acc05ea152d632
I agree, this does seem possible.
Pedantic side-note, but elixir is using @body to write the response, whereas the go handler assigns a string constant to a local bar, and casts that to []byte. I wonder if using a global var/const would result in measurable difference. 
I'm finishing a [retrospective slack bot](https://retrochat.xyz?utm_source=reddit&amp;utm_campaign=elixir) written in Elixir. Beta will be probably open soon. Small project, but learnt a lot. Really liking Elixir and Phoenix so far. Soon I'm going to work on another SaaS and also gonna use Elixir. Feels much better than rails. Also semi related to Elixir - started a [dev blog](https://wrestlerman.me?utm_source=reddit&amp;utm_campaign=elixir) where I'm gonna soon post some Elixir related content. :) I also want to contribute to some packages, but haven't found anything suitable for my skills. Probably sooner or later gonna spot something worth contributing to.
Not yet but I’ve been meaning to! There appears to be good Vue support for Apollo as well. I’ve just been using the Apollo-fetch client which has been fine, but I can see a future where an app gets too big or complex for it. 
This is interesting. What mechanism does the OS have for "pushing back" against the BEAM if it's using too many CPU cycles just waiting, and another process needs the CPU?
None - the purpose of the busy wait is exactly to prevent the OS from putting a scheduler to sleep for a short time, to reduce the wake-up latency in case some new work comes in. The mechanism can be tuned or disabled on the VM side with the +swbt option.
Cool, I'm not aware of Apollo support for Vue! For now I'm keeping my eyes on Pragmatic Studio's new upcoming course! https://pragmaticstudio.com/courses/unpacked-full-stack-graphql-with-absinthe-phoenix-react This just looks super exciting
The Elixir code uses sleep ... everywhere I've read that is something you should not do. Maybe that is the CPU issue? &amp;#x200B;
The compiler is still bucklescript. Reason is just a more familiar syntax and has a few little niceties like 'pipe first' . I haven't used it seriously, but the out of the box setup you get (see docs: https://reasonml.github.io/reason-react/docs/en/installation) sorts out webpack and automatic build watching. VSCode works well, and Console.log has always been my approach to debugging anyway.
If you use Reason-react (which is basically the same language as bucklescript-tea) then you can get something similar to the Elm Architecture, but with more flexibility - the stateful components are all action-&gt;reducer, and if you put your app state at the top of the component tree you've basically got Elm.
When you use the bucklescript compiler (alongside the Belt standard library) you get a few nice things to make Reason do JS things. Logging to console for debugging is still available (with Js.log) and you even get the debugger keyword with `%bs.debugger`. As for why reason syntax over ocaml syntax? The projects I've used it on all use react and the docs for reasonreact were in Reason. The only downside I've faced with ReasonML (and the surrounding tooling like Bucklescript and Ocaml) is that the docs are everywhere. In Elixir were spoiled by a centralized documentation site. Whereas Reason has its documentation site, bucklescript has its, ocaml has its, and each library has its own as well. I'm actually pretty interested in taking on that problem with the solution that Elixir has and providing documentation for everything, but Reason doesn't have built-in doc tooling like our `@doc` and `@moduledoc` tags to make it easy to parse ast-wise.
In this video we are going to see how to cluster Elixir and Phoenix nodes with libcluster, locally and on Kubernetes using Docker containers. 
Do you have numbers for that? I would bet that there is confirmation bias here. 
Why is it not recommended?
Not exactly sure why but if you check the docs it basically says don’t use it. 
This month I released a library to assist with full text search indexing. It allows you to deploy using a very fast &amp; stable indexer using only elixir to configure and release it. &amp;#x200B; [https://github.com/praxis-of-nines/khafra-search](https://github.com/praxis-of-nines/khafra-search)
What I gathered from that is all three are fast enough for anything I expect to do so I might as well use Elixir since it's the nicest language of the three.