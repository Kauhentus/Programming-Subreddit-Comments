If you look at [the docs](https://hexdocs.pm/ecto/Ecto.Schema.html#timestamps/1), you can put your own method to generate these in the `:autogenerate` option on the schema method.
I fucking love this! My team in Europe uses a similar tool called Prettier for javascript. It makes us much more productive
Thanks!
**TLDW?** There is no description on YouTube and the tile doesn't tell much either... Could someone give a short summery? 
It's basically a demonstration of what makes Elixir awesome, and why you should use it when building "software systems". It starts off explaining what the BEAM is and why it's great, and then goes on to demo how production bugs can quickly and easily be debugged with an iex shell. If you have the time, I recommend watching it. Even if you're familiar with Elixir, it's an inspiring talk.
Not OP but seen it. Discusses architectural features and advantages of the Erlang VM for fault tolerance and concurrency. 
I'm doing it. [Here's my repo](https://github.com/pcorey/advent_of_code_2017/) with solutions for days 1 through 6 so far.
Great find. The Outline has gone a long way in just a year, and has relied on Elixir since day one. It's a good example of learning an exciting language and sticking with it. The payoff seems to be good.
i don't want to generate **both** of them, I want only one
You can avoid re-parsing string by calling with new `URI` struct: e.g. `parse(%{uri | path: “/“})` 
But using that method you can introduce the new behavior on updated at, and just recreate behavior on inserted at.
I need a) not to touch "inserted_at" at all b) nil by default in "updated_at"
Thanks! https://github.com/davydog187 on github if you did want to follow
Not a direct copy of functionality, but what I needed to further investigte an Elixir answer to a problem I solved in Python in a different manner.
FYI, `chunk` / `chunk_every` is a really simple way to handle pagination of queries
I have a specific use case, and its great to hear about others :-) 
I agree, that is a little odd. 
I think it's important to remember that in an immutable language things like tuples are stored contiguously, and that lists require a full copy on any operation other than prepending an element (which is constant time). The VM does make some optimizations so the list copy is shallow, not a full deep copy, but on large input it will be noticeably slower if you've done something like that.
[Per the docs](https://hexdocs.pm/elixir/Enum.html#chunk_every/4), leftover chunks shorter than `count` are always appended to the end of the resulting list. I think what's happening is the last chunk of `'IJK'` is considered leftover because the function can't step ahead 4 items in the remaining list since there are only 3 items left. Regardless, this is probably not intended behavior and might be a candidate for [an issue](https://github.com/elixir-lang/elixir/issues).
Great find. Can you please open up a bug report on the [issues tracker](github.com/elixir-lang/elixir/issues)? I think line 18 is correct and line 17 is wrong. But it is probably worth getting extra eyes on it before making a decision.
Some tips: 1. You are using Stream and Enum but you can probably use Stream all the way. In particular, you don't need to call `Enum.to_list` before calling `list_to_indexed_map`, as you can pass the stream to it. You can also replace all Enum operations in `list_to_indexed_map` by their Stream equivalents. 2. However, note Stream is not necessarily faster than Enum. It will really depend on the dataset. 3. Instead of `Map.fetch!` with a rescue, prefer `Map.fetch` with pattern matching 4. Your counting will likely be much faster if you implement it recursively, something like: def count(arr, ip, count) do case Map.fetch(arr, ip) do {:ok, jump} -&gt; diff = if jump &gt;= 3, do: -1, else: 1 count(%{arr | ip =&gt; jump + diff}, ip + jump, count + 1) :error -&gt; count end end Then instead of parse+count you call `|&gt; Day5.count(0, 0)` or something similar (I didn't try it out).
[Reported](https://github.com/elixir-lang/elixir/issues/7096). 
ah cool... nice to see the cross pollination :) hope you find time to explore more!
I am a cotributor on the site [RosettaCode.org](http://rosettacode.org/wiki/Rosetta_Code). It is a great site for comparing different languages code for solving the same problems. 
You can select which columns you want. So for your use case you'd want something like this: In your migration: timestamps(updated_at: false) # don't include the updated_at column timestamps(inserted_at: false, null: true) # don't include the inserted_at column, and allow the columns it does created (updated_at) to be nullable Then in your schema: timestamps(updated_at: false) # don't handle the updated_at field timestamps(inserted_at: false, autogenerate: { __MODULE__, :nullify, [] }) # don't handle the inserted_at field, and change the autogenerator for the fields it does apply to (updated_at) to use your __MODULE__.nullify/0 function which will return nil And make a nullify function which returns `nil`. 
re-read my question --&gt; updated_at - nil by default, inserted_at - don't touch at all.
That does what you're asking for. It'll use the default implementation for inserted_at, while overriding the implementation of updated_at with our nullify function (making it nil by default). 
On writing your first package in elixir. I'd love to get suggestions to improve it
but why then does it touch "inserted_at" at all?
but why then does it touch "inserted_at" at all?
Because that's the way they've designed the API. It's not actually doing anything with `inserted_at`, it's just letting Ecto use its default implementation for it, and making sure our custom implementation isn't going to be applied to `inserted_at`. The arguments being passed to the timestamp function are a keyword list of options, which tell the timestamp macro what code to generate for us. 
ok, thanks, I'll try that.
I’ll be honest. While I think more resources are good I don’t think encouraging people to push low quality packages to hex is. There’s already a heap of abandoned packages or packages solely parking names. We should be encouraging people NOT to push to hex unless there’s a really value to the package. Using your custom module directly from GitHub is easy enough to not require it being on hex.
Yeah good point! Which is why I merely linked to the hex doc for publishing the package, should I remove that?
Just updated the post with a note on when to publish and when not to. Thanks for the input!
I'm in the process of writing a swagger -&gt; Plug code autogenerator mix task. Would you find this useful? Would you be interested in helping?
A few other things to consider: + You're handling only the the successful case, what happens when the API returns a non-200? The code will break unless the error message return includes a "value" key. + If you look at using pattern matching you could clean up your code even further. It'll also be more "Elixir-y" defmodule Norris do def random do "https://api.chucknorris.io/jokes/random" |&gt; Tesla.get() |&gt; response() end defp response(%{body: body, status: status}) when status != 200, do: {:error, body} defp response(%{body: body, status: 200}) do %{"value" =&gt; joke} = Poison.decode!(body) joke end end 
You're right, but this was just a getting started type of guide, if you take a look at the Github repo, I've considered an error case
I am looking at the repo at this moment and I do not see where you're handling errors. Perhaps you haven't pushed your changes? defmodule Norris do def random do "https://api.chucknorris.io/jokes/random" |&gt; Tesla.get() |&gt; response() end def random! do case random() do {:ok, joke} -&gt; joke {:error, reason} -&gt; raise reason end end defp response(%{body: body, status: status}) when status != 200, do: {:error, body} defp response(%{body: body}) do %{"value" =&gt; joke} = Poison.decode!(body) {:ok, joke} end end 
u/faraaz1998 I saw the changes you pushed but you're still not handling non-200 requests from the server, just JSON decoding errors. I think it's more likely the API experiences an error versus them sending invalid JSON. I updated my refactor to include your new features, relying on pattern matching more will save you a fair number of lines and make the code more legible defmodule Norris do def categories do "https://api.chucknorris.io/jokes/categories" |&gt; Tesla.get() |&gt; category_response() end def joke(category), do: joke_request("https://api.chucknorris.io/jokes/random?category=#{category}") def random, do: joke_request("https://api.chucknorris.io/jokes/random") def random! do case random() do {:ok, joke} -&gt; joke {:error, reason} -&gt; raise reason end end defp joke_request(url) do url |&gt; Tesla.get() |&gt; joke_response() end defp category_response(%{body: body, status: status}) when status != 200, do: {:error, body} defp category_response(%{body: body}), do: Poison.decode!(body) defp joke_response(%{body: body, status: status}) when status != 200, do: {:error, body} defp joke_response(%{body: body}) do %{"value" =&gt; joke} = Poison.decode!(body) {:ok, joke} end end 
Thanks!
do you think that a mix task package to generate plug interfaces from swagger (instead of using plug to generate a swaggerdoc) would be useful?
So I'll be "that guy". What's obviously missing is... tests :)
My main question is why would you? As a learning program, ok, but for general use it makes no sense as Erlang wasn't designed for batch processing.
https://en.wikipedia.org/wiki/Batch_processing
**Batch processing** Batch processing is the execution of a series of jobs in a program on a computer without manual intervention (non-interactive). Strictly speaking, it is a processing mode: the execution of a series of programs each on a set or "batch" of inputs, rather than a single input (which would instead be a custom job). However, this distinction has largely been lost, and the series of steps in a batch process are often called a "job" or "batch job". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
In order to “run the simulator and give commands to the robot,” perhaps?
Anyway, that functionality exists in Erlang/Elixir and it would be great to know how to use that. You can think of Interactive Elixir (iex) for example. You run it, you give commands and those commands are being executed.
Let's sidestep your use of "batch processing" for a bit. It is hugely useful in projects - you can reuse your code to do one-off things, like data migration, setting up an initial test database, etcetera. Furthermore, it might often be useful to have both a CLI and an (HTTP) API to your system, cronjobs, "operator" stuff, and so on. How useful it is is hugely situational, but it certainly worth having this tool in your toolbox. 
I mean that it is good to know capabilities of your tools, but part of being good programmer is knowledge when use some tools and not being attached to one “silver bullet”. Of course that Erlang has nice features, but in most cases these features are unneeded for CLI tools. Sometimes these features can even be harmful, like silently handling errors by restarting process, which is great when processing data in client/server manner (as if request fails it can be repeated), but when processing data in most cases you want to fail as soon as possible. I am not saying that such failure handling is impossible in Erlang, because it is obviously possible, but Erlang wasn’t created for such purposes. Also Erlang VM isn’t the best when it comes to startup times, which is no problem for client/server applications as these aren’t started often, but most CLI tools is meant to be ran often in the pipelines or by external tools. &gt; Furthermore, it might often be useful to have both a CLI and an (HTTP) API to your system, cronjobs, "operator" stuff, and so on. So if you have some remote access API then it would be perfectly fine to have CLI app written in something which has less dependencies and/or runtime penalties. 
Yes, there's an open issue in the swagger_codegen repo to generate a phoenix/ plug stub from swagger. I'm hoping to work on it soon. (https://github.com/swagger-api/swagger-codegen/issues/7104) I personally find it easiest to keep the documentation up to date when it is generated from annotations in code, but a swagger-first workflow is totally valid. 
[JSON-API Query Builder](https://github.com/mbuhot/json_api_query_builder) builds Ecto queries from JSON-API requests. I'd love to have something like this for graphql, where the entire request is mapped onto a single Ecto query rather than the interleaved loading/resolving style that most frameworks encourage.
I'll be pushing my mix task library up this week or so. Would you be interested in looking over it? I'm kind of new at elixir so I'd love comments.
It’s useful for operations. I’ve made small elixir tools to reproduce issues, perform migrations, and generate reports. Python or Ruby would work too, but it’s nice to keep the codebase in a single language, especially when working with larger teams with various backgrounds.
Awesome! I'd be happy to take a look. Somewhat related, this package (https://github.com/CrowdHailer/raxx_api_blueprint) does routing in the raxx web framework using API blueprint instead of code. It would be cool to have a swagger/plug equivalent.
helloWorldVariable = func1 |&gt; func2
wow. im stupid *facepalm*
Naww just learning :) 
We have all been there
Well, let's agree to disagree (I disagree with pretty much all of your points but I'm a couple of decades too old to dive into a point-by-point argument on reddit ;-))
A few examples var = func1() |&gt; func2() Multi line use indentation to distinguish from long pipe chains var = func1() |&gt; func2() |&gt; func3() 
I know that feeling well, its what makes the learning so fun
it really does lol. im a polyglot when it comes to programming languages, so its funny when i don't know something or do something that stupid for something that is simple.
We recently watched this talk about BEAM at work and it's really good, very interesting https://youtu.be/pO4_Wlq8JeI
Yeah, I checked that one out recently too. I found it rather intermediate, nothing I hadn't known before hand, but interesting none the less. If you're interested in learning more about how BEAM/ERTS works under the hood. I would *really* recommend the Beam Book GitHub [here](https://github.com/happi/theBeamBook) and PDF [here](https://happi.github.io/theBeamBook/) or [here](https://exote.ch/~aseigo/beam-book/beam-book-2017-04-08.pdf)
This amazing post at the Discord blog: "How Discord Scaled Elixir to 5,000,000 Concurrent Users" https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b
Thanks, looks interesting, I'll check it out.
I’ll pitch my online course where you learn how to build a real-time Messenger clone with Phoenix :) https://www.ludu.co/course/discover-elixir-phoenix
Love the self promotion, but my post *specifically* asks for *advanced* material. The first section of your course is how to install Elixir. Sure seems to fix the "advanced" ticket to me!
The advanced topics come in later in the course, but I see how that might not be what you’re looking for. Sorry for being unclear.
Adopting Elixir is really great for getting an Elixir app production ready, among other topics: https://pragprog.com/book/tvmelixir/adopting-elixir
I'm curious what the advanced topics are. Looks like the later sections cover "channels and web sockets" and "sending messages". I'm not knocking the course, I could be great, but it looks incredibly introductory. It looks like a video version of Programming Phoenix(an introductory book). I'm curious if you truly believe this is an advanced course, or you just figured you'd plug it here.
Awesome. I didn't realize there was a new Elixir book out. Have you read it? How advanced is it? Every book I've read so far seems to go from zero to a basic/intermediate understanding of OTP. I'm looking for the next step after that. Does this book have a lot of advanced stuff, or just a bit? What's the percent split between basic/intro/intermediate Elixir, and advanced stuff? If I'd read every other Elixir book, how much of this would be new to me? 
Try doing exercises in exercism.io It is by far the best confidence booster.
The problem is that there's no advanced content yet, being Elixir so young and in the hype phase at the moment, where most Elixir devs are enthusiasts but not yet gurus. Elixir is young, but Erlang is old and battle tested, what we need is a book on OTP patterns, articles on the architecture of big Erlang production apps, that are mostly applicable 1-to-1 to Elixir. It seems that a lot of knowledge is lost in the Erlang mailing list. Any suggestion?
I read "designing for scalability with erlang/otp" and found it to be somewhat interesting. Of the ~500 pages, I would say ~150 were new and advanced stuff (mostly on performance tweaks and distribution), and the other ~350 really seemed like filler/review of any other Erlang book. But the chapters on distribution and hot code reloading were interesting. Those are two features everyone brings up when talking about what's great with Erlang/Elixir, but it's also something I *never* actually see people use. "Erlang/Elixir is great, you can run it on tons of distributes nodes, and upgrade your system without taking down!", "Oh wow, how do you do that?", "Don't know, i've never done it myself". Even after reading those chapters, I don't think i'm anymore likely to need to build a massively distributed, or non-stop system, but still good principles to know none the less.
It has the best collections of “make ready for production” I’ve seen anywhere in regards to elixir apps. I think it was worth the price of the book just for that stuff.
Thanks for sharing!
Here are a couple videos I've watched [Eliminating Single Process Bottlenecks with ETS](https://www.youtube.com/watch?v=XrkY9WRY8p0) Erlang/Elixir encourages architecture that can lead to processes being bottlenecks. This is by design because it makes concurrent programming easier to reason about. This talk suggests some solutions to remove bottlenecks and increase throughput by using ETS [What NOT to do when building large scale systems in Erlang](https://www.youtube.com/watch?v=EBQKlyaM7bY) bet365 engineer pointing out some pitfalls. One of the takeaways I got from it, which overlaps with the first video I linked, is using ETS as a message queue to relieve process bottlenecking. 
This talk is really good. Definitely in my top 10.
I don't think distributed erlang is intended for IoT devices with unreliable network connectivity. Each node connects to every other node. Designing for Scalability with Erlang/OTP has some good material on distributed architectures towards the end.
Well the mesh network itself wouldn’t be beholden to this process, but the erlang app would be a peer on the network and spin up threads for each new arrival, and use them to pass data and commands. 
Not OP - do you mind elaborating a little bit why you think elixir is a good fit? Interop with existing elixir code and using a language you like seem the main draws for me. I love elixir, but I'd think a language like Go is better suited for CLIs
Well, these are the main draws. If I can reuse my code in a CLI utility, I don't think I should be redoing it just because my code resides in a language that people see as not being fit to run a CLI. I think Elixir is a fine match, especially in "controlled environments" (where you can pre-install the Erlang runtime so you can just distribute escripts - statically linked binaries _just_ like Go, but without the need for cross-compilation). As I said, it's hugely situational - one of the aspects is code reuse and staying with a language you know; another aspect is ignoring all the FUD around "elixir is not fit for CLIs", I think tools like `mix` and `hex` prove that the language is fine in that area.
Have you used Joi for Javascript? That one is the best I've used. Yours looks good for elixir . If you need ideas check out the Joi docs.
I haven't heard of it. Thanks for the tip!
Please check out the pricing of Auth0. It seems to get really really expensive! 
What about [Process.send_after](https://hexdocs.pm/elixir/Process.html#send_after/4)
I think OP confusing concurrent with parallel. There is no guarantees that specific processes will do in parallel in different cores just concurrently iirc. 
This is what I use and it probably couldn't get any simpler.
An easier to use Devise would be nice. Authentication is required for any app that has users. At this point there are lots of features that users expect. Coherence was a decent attempt but fell pretty short because of no social media login.
Yeah, I forget where I read it but one of the main brains behind elixir is quoted saying he doesn’t want devise brought to elixir because “different paradigms require different solutions” or something close to that
I mean something that combines features like * Invite to register * Confirmation email * Password reset * Remember me check box * Social media login I feel like every web framework should provide this out of the box like Django with the option of not using it if you don't want to. Authentication/authorization is basically boilerplate at this point.
I wish there was a decent low-level bitcoin library like https://github.com/bitcoinjs/bitcoinjs-lib or https://github.com/btcsuite/btcutil. Seems like the cryptography has not been implemented in erlang/elixir/NIFs...
Example: https://stackoverflow.com/questions/32085258/how-can-i-schedule-code-to-run-every-few-hours-in-elixir-or-phoenix-framework/32097971#32097971
On mobile so I don't have a link, but I would kill for a good Lavaplayer-like library in Elixir. 
I cannot upvote it enough
Good point. I assumed that when using ‘async: true’ in ExUnit, test cases run in separate processes. These processes would be devided on Erlang schedulers, one scheduler per core. Do you know if my assumption is right? Would love to know! But indeed there is no guarantee that they are running parallel. 
Found this in the ExUnit source code https://github.com/elixir-lang/elixir/blob/master/lib/ex_unit/lib/ex_unit/case.ex#L18 &gt; `:async` - configure this specific test case to run in parallel with other test cases. 
A problem with this example is that it's going to have significant schedule-drift over time. The "do the work" step may have a large (or variable) duration, and even the call into `handle_info` isn't guaranteed to occur exactly two hours after `send_after` was called. So it's really a "two hours plus delta" schedule, and those deltas can add up quickly. At the least you could call `schedule_work()` as the *first* action in `handle_info`, so that you're not waiting for the task to complete before rescheduling. But really, a `cron` style approach will negate the drift problem much more effectively. Have another process that reviews a set of "cron" rules every minute. If the 2-hour rule for this job is triggered during the current loop, then send a `:work` message to the worker process; send any other messages; and then sleep until the top of the next minute. This way, you have only one process (the scheduler) that's trying to maintain sync with the clock, and you've isolated all that complexity from your worker tasks (just like `cron` does). 
I couldn't agree more. The less authentication code I have to write for an application the better. That said, I'd rather just have really good packages for all my frameworks than have them add auth to the core framework itself. I'm really happy with how auth works in Ruby/Rails. Not included in the framework, but there's a standard package.
core.logic from Clojure. I know there's a microKanren for Elixir, but an extended miniKanren would be nice.
I know nothing about core.logic. What 
core.logic is Clojure's bid at implementing miniKanren but with a few extra features. I'd love for Elixir to have that solid a foundation for relational programming. In other words, Elixir flavored Prolog.
Erlog?
Yeah, but it would be nice with a DSL instead of a full language.
How about ueberauth and guardian? Those seems to fit the bill.
A production ready AMQP 1.0 client.
join-monster 
Hey, sorry the late reply. Well, I haven’t actually read through all that many Elixir/OTP books, but this does cover a broad range of more advanced topics, giving you some great practical knowledge, and then leave you informed enough to go in more depth on particular areas yourself if needed. Until I put it into practice more it will be hard to say whether it gave out the right amount or not, but the authors seem very considered.
Check out coherence: https://github.com/smpallen99/coherence
Building https://TossBounty.com, crowdfunding for open source projects, focusing on making it easy for the maintainer to spin up their campaign as well as connecting users with Repos that are important to them. This is done by aggregating data from a users github account (reactions, stars, comments) with Tentacat. Also I’m looking for a job in Elixir. 
How do you know how long to sleep (I get enough time to get to the next min)?
To wait until the top of the next minute, :timer.sleep(1000 * (60 - Time.utc_now.second)) might be accurate enough for your needs. You could factor in the `.microsecond` part of `utc_now` if you wanted a more precise wakeup call.
Wow thanks!
JWTs are really not a good solution for web authentication and authorization for a bunch of reasons. 
In all the big rails projects I worked on, devise was always causing the most trouble with maintenance. It's great for hackathons and prototypes, but I would avoid it like the plague for any application that should live a bit longer.
I'm not sure ETS alone is a good session store - it's just single node. You'd probably need some distributed cache built on top of ETS (and there are at least a couple).
Sure, I had that experience even with small one off projects. But I think my primary complaint is still valid. It feels bad to write code to implement probably the most commonly required functionality. Which currently relegates Phoenix to being useful exclusively for APIs with the caveat of having an app layer that sits in front of it to provide user auth. At least that’s my opinion, which might be a little harsh because the thought of having to write boilerplate makes my skin crawl. And I consider user auth to be boilerplate.
Dang. This I've not heard of yet. Would you please give a short summary why? I assumed JWT would be the way to go based on Google searches for Auth in phoenix...
&gt; Would you please give a short summary why? Replay attacks for one.
Math and science. Interfaces to GDAL, pandas etc.
How hard is it to write a similar service in elixir
I feel like you could write a Phoenix app with uberauth and JWTs. But you can also just use uberauth on each horizontal node (your Phoenix app) and keep all the sessions in a sort of GenServer or redis 
Would a simple problem to the drift be to start whatever work you are doing in a separate process instead? That way the "scheduler" can get straight back?
Didn't actually know about send_after till a colleague told me about it after reading this :) I feel if I already have a GenServer I would use send_after, otherwise I think this gives a cleaner module with the Task abstraction. If someone knows technical differences between these two or real life examples of pros/cons I'd love to hear about them
Sure, that could help to minimize drift. If correcting drift really matters in your application, then eventually you'll want to check the system clock and adjust your local schedule. But if drift isn't a huge deal, then maybe syncing the schedule is kind of excessive. I think your suggestion is a pretty good compromise: you're minimizing the amount of work in the scheduler thread, so it's not going to drift by a huge amount every iteration. There's no one right answer here. I think we just need to know about our options are, and what the tradeoffs are, and then make the best choice for our needs.
Erlang is terrible for math/science and/or data science you want to do with your panda (data frame). You chose the wrong language to do numerical intensive stuff. 
For someone who's giving his first go at writing a web application, can you provide some advice on what to do/what not to do? Just trying to avoid massive headaches for myself later. Or maybe even random advice apart from auth. :)
As someone who has used pandas for years, I think having it in elixir would be good. You can handle data very easily with it, not considering heavy numerical operations, it's just amazing for tabled data manipulation. 
I've been doing a bit of research on this, and from what I gather, this Replay attack happens because once you set the JWT, the server has no way of invalidating it until the JWT itself expires. I guess this means if someone got your jwt token, there'd be no way to prevent that user from logging in without invalidating everyone's tokens by changing the secret used to generate them. Is that about right? 
Newspaper, the python scraper lib comes to my mind but since I can call python functions from Elixir via Erlport I'm not complaining.
great explanation! waiting for coming articles, well done
What's the right language? Python? Everybody uses python because it has interfaces to C libs. Why can't somebody write the interface for Elixir? 
you mean litecoin?
My app is showing a 160% gain for elixir today 
I think you're in the wrong sub, friend.
I believe you're looking for http://phoenixframework.org/
If a framework was a car, this would be a great engine with chassis, however I need a battletested kit car 
I would be interested in the membership stats for /r/elixir For example, how many /r/elixir members also sub /r/bitcoin and stuff like that. I bet it is pretty high. 
What exactly is missing?
Phoenix ticks everything on his list except built-in authentication. Although afaik Ruby on Rails doesn't have that either, unless they added it since I stopped using it.
True. There are lots of pre-rolled auth solutions on https://hex.pm too
If Pinterest, Bleacher Report, and Discord don't count as battle tested, I'm not sure what does.
Rails has [has_secure_password](http://api.rubyonrails.org/v5.0/classes/ActiveModel/SecurePassword/ClassMethods.html) that allows you to make a very basic authentication. Don't think if Phoenix has anything like that.
If we're using a car analogy... Rails is like a Toyota Corolla. Easy to get into, reliable, familiar, everybody drives it. Phoenix is like a Tesla Model 3. Everybody seems to like it but nobody knows what it can do or seen it anywhere yet.
In any case, thank you, I will get started with Phoenix and make my way from there 👍
I assume Elixir is also a cryptocurrency, but this subreddit is about Elixir, the programming language.
One of the best resources for learning Phoenix 1.3 and above.
It certainly does not have the install base of Rails yet, which is absolutely expected at this point ... but there is more and more usage of it. I certainly wouldn't put it into the new/speculative category anymore, but the early adopter phase. We are using it in production where I work, and it was the web dev people's first experience with Elixir let alone Phoenix. Was really impressed how they were almost instantly productive .. 
rabbitmq-erlang-client https://www.rabbitmq.com/erlang-client-user-guide.html#amqp-client-app
If Phoenix doesn't meet your needs then the answer is: there is none. Phoenix is by far the most mature, battle-tested and complete web framework in the Elixir world.
ok so I pushed a very early version: https://github.com/rstorsauce/Exaggerate.git
Phoenix might not offer all of the features you desire, however this is more by design. Since its creation, there's been a push to not make Phoenix your app, but rather some convenient pieces you'll likely wish to use in your app. Which is quite different to most other web frameworks. For the lifetime of your application this is actually very beneficial, as you're free to move parts outside of your app into another app, or removes components Phoenix provides with other replacements, etc. Phoenix is also built on top of very battle tested foundations (Erlang VM and OTP). 
I'm talking about Ruby &amp; Rails there but I'm building up on theoretical base that I've learned from using Elixir. In a sense I think it's touching the topic of Elixir as I'm making a stage for bringing more Functional approach to Object oriented programming. If anyone feels that this article should not be in /r/elixir please let me know I'll delete it 
Interesting read. Out of curiosity, why put those functions inside UserBuilder and not just into User directly? User.new() | &gt; User.set_as_admin() seems perfectly clear to me.
Either way works equally well. If you had complex builder logic with lots of private functions specific to the builder, you might want to extract it out into its own module.
I guess the logic is that if you have a whole bunch of builder functions, then putting them in their own module would keep both modules cleaner, but I would agree that if there's just a couple, then I would keep them in the main module. Unlike OOP, which module a function lives in doesn't really change much about it. It's mostly a way of organizing (with some exceptions).
You're a moron, and you really don't know what you're talking about. The VM that Phoenix runs on it more battle tested than all the other frameworks you mentioned, combined. There's nothing on your list that Phoenix can't do (except "built-in auth", which like Rails, Phoenix uses an external library). You come on here, and ask about the most basic and google-able question about Elixir, and then don't like the answer? Elixir is a young language, if you want a plethora of tools/tuts/pre-built/built-in code, then go to Wordpress. That being said, there's nothing you need done that Phoenix can't do, and do better than the other tools you mentioned.
&gt; nobody knows what it can do or seen it anywhere yet. Except we know exactly what it can do, and have seen it quite a bit. Elixir has been out for over 3 years, and Phoenix for over 2 years. It's more like a model S. It's been out a while, and it kicks ass.
I saw this in the Elixir Radar newsletter, but I don't think it's been mentioned here on Reddit. Thought I'd post.
Concurrency is the opposite of currency... /s
D3.js
do you know what phoenix version its aiming at? 1.3?
Wow this is really messy. Unreadable really. Any resources I can use to accurately show you my code?
Is there a table of contents anywhere?
SQLAlchemy (Core)
&gt; This guide covers an Erlang client for RabbitMQ (AMQP 0-9-1). ActiveMQ and others use the 1.0 protocol which is completely different to the 0.9 protocol supported by the rabbit client.
Nice! I got the first star :) I'll try it out and see what the generated code looks like.
Nice! I'll try it out and take a look at the generated code. 
Here you go: http://www.phoenixforrailsdevelopers.com/downloads/sample.pdf
Preferably a github repository or a gist
seems okay, any reviews yet?
Totally agree on this. I'm thinking about spinning up a quick library that lets Elixir supervise Julia. Julia's great pairing for elixir because it's a HLL that's super fast if you do it right, built with distributed primitives that are "numerical computation optimized distributed primitives" in the same way that erlang has "service deployment optimized distributed primitives", julia has a nice macro system that feels an awful lot like elixir's and a worker paradigm that should be fairly compatible. I'm thinking an interface that includes a default supervision strategy and a julia() macro which takes the AST inside, takes from a julia worker process pool (or spins up a new one if necessary), and transmits the function call inside into the desired julia process.
I'm being naive but it seems shitty to deny people access to your website/application because of their country of origin when fail2ban, OSSEC, etc are available
[Enum.into/3](https://hexdocs.pm/elixir/Enum.html#into/3). `Enum.into/2` is useful in and of itself because you often have to make data structures translate to other data structures, say KeywordList into map. But say you wanna do some stuff to your input before you put it into your eventual data structure, you could do a `Enum.map/2` into `Enum.into/2` or just use `Enum.into/3` and do it in a single pass! ``` foos = [a: :foo, b: bar] Enum.into(foos, %{}, fn {key, value} -&gt; new_key = key |&gt; Atom.to_string() |&gt; String.upcase() {new_key, value} ) # %{"A" =&gt; :foo, "B" =&gt; :bar} ``` 
I wasn't aware of Enum.into/3, thanks for this - I can already think of something that I should refactor to use this off the top of my head
Right at the beginning of the article it states &gt; Mitigation steps should be done at the web server level first and foremost. But sometimes that isn’t available to you — say if you’re hosted on Heroku.
Yup! The article the author linked after that quote discusses the same strategy (banning the Chinese ip range) rather than practices that would harden you against intrusive behavior coming from any ip. I'm guessing the disclaimer is talking about how it's good practice to have attack mitigation layer separate from your application.
honestly it's kind of annoying that you have to do it that way.
wouldnt it make more sense to pipe into a variable? instead of setting the variable equal to a bunch of piped functions?
yes, but then the parser would have to know if the last term was a variable or a function, which is not a trivial to figure out in elixir since a bare keyword can be a function with an empty call. maybe if you had the -&gt; operator at the end to distinguish between the two outcomes? I also wish that &lt;- was a universal "matching" operator, = was reserved for assignment to a new variable and recovered in function headers as a default value (you would match in a function using &lt;- much like a "with" directive) and I also wish that instead of @spec you could have typespecs in headers (see header syntax for julialang for beautiful headers)
yeah, i think it would be easily possible match the assignment possible. i dont care if its a pipe or some kind of arrow. but i am starting to love the hell out of this language.
erlang doesn't really have a native array type. (python lists are at least a fake array - fake as in they' arrays of pointers). So something like pandas would be inappropriate for Elixir.
Check Enum.map_join/3 too if you haven't seen that one! Similar concept.
Interestingly, in the "other interesting language with pipes", julia, you have to do it like this: var = value |&gt; func1 |&gt; func2 |&gt; func3 and also piping doesn't desugar partial applications, piping strictly maps function variables. On the other hand there is a broadcast pipe (.|&gt;) which takes the pipe and turns it into a mapped operation.
It's hard not to love the language.
i wish there were more resources on YouTube. im trying to get a good grasp on processes and sending/receiving messages , but everything just goes straight to web development.
It's analogous to Ruby's `inject` or `each_with_object` `%w[a b c].each_with_object({}) do {|(e, i), h| h[i] = e.to_s.upcase}`
Most web frameworks need a pagination plugin, but with [Enum.chunk/4](https://hexdocs.pm/elixir/Enum.html#chunk_every/4), that essentially takes care of pagination in one built-in function. That was pretty awesome when I first used it.
Got to say that :rpc.call/4 is my favourite function, however that's Erlang, if we are talking about Elixir and Elixir only I'm gonna have to say Node.spawn_link/2. It's incredibly useful for both debugging and spreading applications over separate nodes.
Pagination plugins usually work on the database layer, so they only fetch the displayed results. With the chunk approach you would have to fetch all results from the database and then paginate them in Elixir which would most certainly have a huge impact on performance.
What do you like about SQLAlchemy that Ecto doesn't provide?
yup. Stream.chunk_by, chunk_while, and chunk_every would be better for that use case.
i just got it and am most of the way through it (page 180ish). it's decent, but kinda light. I think the phoenix book is a bit better. the rails comparisons are cool, but this doesn't touch on channels at all. but it does use contexts + 1.3, which the phoenix book isn't updated for yet. decent read, but not for $40 imo, more like $20
Wouldn't be easier just to downcase it on the way in?
The problem with down casing is that you lose information in the process, with this solution you do not loose that data.
Encrypt your emails and names, people. 
What for?
Leaving personally identifiable information unencrypted is irresponsible and puts your employer at risk for public outrage if your DB gets leaked (depending on company this is a when not if) by rogue employees, malicious actors, dev machine being stolen and data sold, or any number of possible ways that your data can be exfiltrated. See Equifax recently, along with the myriad other leaks. Protect your PII. Libraries like Cloak in Elixir can help with this.
If you need to insert them separately, then cookbook has to be fisrt and recipe has to reference it by id (cookbook_id) or struct with id (cookbook). What you do is exactly opposite, inserting recipe first and referencing struct by id. 
Well, I think that second approach makes the most sense since I want to query for a cookbook and then get an array of all their recipes. But I’m not sure how to insert a struct either
If you want to add new recipe on request, then you should use changeset. If you already queried cookbook, then Ecto Changeset has put_assoc function to associate changeset with loaded record (struct). 
Can't help you with that, but just FYI: if you want people on the internet to help you, it helps if you give concrete examples. What do you do when you say "I try to migrate these". Who tells you how that "it can't insert a struct"? Where do you expect the json output to come from? Good luck!
Read the hex docs on Ecto.Changeset. [https://hexdocs.pm/ecto/Ecto.Changeset.html](https://hexdocs.pm/ecto/Ecto.Changeset.html) You most likely should be using cast_assoc/3 to insert all the records at once. There’s an example in the docs for addresses which can be translated to your idea of recipes to cookbooks.
I didn't think about this problem before in terms of "losing information". What's the advantage of preserving the information that somebody entered their email as "JOHN@example.com"? Other than, anecdotal, "you're a terrible person and I hate you"?
Interesting! Do you mean reversible encryption? Which has the advantages when your database gets leaked, but the attacker doesn't have access to your application code and secret key.
That's what I always did before. This time I wanted to try something new. The downside of downcasing on the way in is that you have to remember about it every time you accept input - in your registration form, login form, password reset form, when filtering the user list by email.
I do. Passwords get bcrypted or Argon or whatever you're using. Emails, first names, addresses and whatever you consider PII get encrypted with AES-256 or similar. Then you can do hmacs of the unencrypted values for things like search (login, looking up user by email). It adds overhead but it's good to deal with early before it's a giant pain to add later. 
Google does this, as an example. If I go to certain pages in Google, it will show my email as aFooBarBAZb. 
You would have to remember to lower when queuing by email too. 
We did something very similar to this for our systems integration platform, which I had originally written in Python. It was already queue based, built around Celery and RabbitMQ. I moved on to management, and hired a developer (whom I'll call J) to take over work on the platform. We knew the handwriting was on the wall as we looked at projections of our future transaction load. J had a background in Go, but discovered Elixir in the middle of scoping out a Go replacement. I gave J the go ahead to explore an Elixir solution, because I was excited at what the Erlang/OTP/Genserver ecosystem could do for us, as well as the proven stability of the platform. It was fairly trivial to set up separate queuing system in Elixir. This allowed us to migrate integration modules one-at-a-time to the new platform, with the old Python framework passing off requests it no longer handled to Elixir. It took us about a year to fully transition, and we couldn't be happier with the result. The only challenge now is finding one or two more Elixir developers, since the amount of integration work we have planned has grown substantially.
That sounds really interesting, have you written about the experience at all? I'd love to read it
When I registered on Reddit I have use Hauleth, and that is my prefferable way of show-biznesu my nick there. However it would be handy to be able to login using any combination of cases while logging in, also it would be nice if there would be no possibility to create account “hauleth”. Other reason is that I believe that citext has some advantages when it comes to normal and trigram indexing. 
Seconded. 
What were the perks of moving from your previous stack to elixir?
This looks promising. Are there any plans do allow custom decoders? Currently with poison I have a custom implementation that only converts whitelisted keys into atoms.
I would have a hard time trusting a data validation library written under the effects of skooma...
[removed]
Love the name you decided on! Generally looks really good
Is there impure elixir?
well something like jiffy is written in C
I assume it’s instead of being implemented in Erlang
This is great! Looking forward to rust NICs :) Maybe I could help with the use of Rustler :P
Is improved performance the primary goal of Jason? Could the performance improvements be ported to Poison? I already have JSX and Poison as transitive dependencies in my project, I'd love to not add a 3rd JSON encoder :)
This was intended as opposed to "C library with bindings in Elixir"
I prefer to have a separate library handling the conversions - something like ecto, vex or saul. I don't like the poison approach since it hides that there's another pass over the data - it's in no way faster than mapping over the results you get from decoding.
It would require completely rewriting poison, I don't think it's ok to send a PR ripping out the entire project and replacing with something else and expect the owner of the project to later maintain it. 
One of my biggest gripes with Poison is that there is no changelog, so it is not clear if it is safe to upgrade (both as an end user and as a library author). Thank you /u/michalmuskala for adding one to this project!
There's a good chance that `CSV.decode/2` returns either `{:ok, data}` or `{:error, reason}`, so you will need to rework your insert functions to check the tuple first. def store_users({:ok, row}) do changeset = User.changeset(%User{}, row) Repo.insert!(changeset) end def store_users(_row) do # do nothing, as this would be an error end Note that a similar pattern will have to be followed for the other 2 store functions.
Fair enough. I could leverage a changeset to accomplish my current behavior.
Start the container with the command `sleep 99999`, and then use `docker exec -it [name] /bin/bash` to start a shell in the container.
Thank you. I've used this library in my project. Is the difference between Jason and Poison only about performance boost? ---------- update ----- I've found the answer at https://hexdocs.pm/jason/readme.html#differences-to-poison. Documentation is very good.
You can also connect a remote console to a running VM. I am not sure the Docker side of it, we normally deploy Erlang releases to VMs or dedicated servers. In that case, we log into the server and run env MIX_ENV=prod RELEASE_MUTABLE_DIR=/var/tmp/foo /opt/foo/current/bin/foo remote_console Something similar should work, assuming you get things like the cookie set up right. 
Thank you. My project contains several different project. For example, rails, phoenix, and others. Using docker-compose to let them run together. It seems difficult to run phoenix server itself from command line.
Thank you. My project contains several different project. For example, rails, phoenix, and others. Using docker-compose to let them run together. It seems difficult to run phoenix server itself from command line.
thanks alot!
Generally speaking, the "Erlang way" is to run the application from a release, headless. Erlang started as a way to build embedded systems for telecom applications, so it is well supported. Trying to run a program from the command line is something you would normally do interactively, not in production. A release packages up the Erlang VM with your application and all of its dependencies into a tarball. You can then deploy that as a unit, and it also supports things like hot code updates. The release has a script that starts it, and the whole thing is launched and supervised by the OS init system (we use a systemd unit). It runs headless, and you can connect to it via a remote console. Building releases is straightforward with distillery: https://hexdocs.pm/distillery/getting-started.html So if you take the approach of building your release, then packaging it in the Docker image, things may work better. This may be helpful: https://github.com/erlang/docker-erlang
Thank you very much for your perfect reply! And, the link you added at the end is a good resource. Merry Christmas!
reading the little elixir and otp guidebook so are genservers, in a basic sense, just intended to tidy up or standardize the writing of functions intended for spawning?
thanks I was considering buying it, but the price really blocked me...
Just launched https://www.enso.ooo last week. Currently working on user's feedback and mostly just fixing bugs. I'm thinking of setting up proper CI, because I am currently deploying using local edeliver -&gt; production and I had some issues on flaky connections while traveling. 
If you don't mind me asking, how did you handle billing integration?
Comeonin. 
Using Stripe's checkout js. Simplified flow is as follows: - client authenticates using stripes checkout and gets the user token - call API with token, create a stripe user and subscription using one of the libraries for stripe, update our records - have a webhook controller that handles trial &amp; subscription endings, subscription changes... Any specifics you care about?
You're welcome! You can also always insert an `IO.inspect/1` into a pipeline to see exactly what you're working with, as it prints what's given to the console and then returns it.
You're really close. The function you're missing is `List.flatten/1`, which will take any nested lists of lists and put all the elements into one flat list. defp includes_json(users) do users |&gt; Enum.map(&amp;include_json(&amp;1)) |&gt; List.flatten() end Also, protip, a shorthand for `&amp;some_function(&amp;1)` is just `&amp;some_function/1` - the arguments are implied for you.
OpenAPI -&gt; plug generator. It's still very much in the early phases (also I'm an elixir n00b) https://github.com/rstorsauce/exaggerate
Magic I think is bad right? The special sauce is the BEAM underneath the genserver
IO.inspect, hands down the most important function that I use
praise `defguard`, great addition.
Nice! Have been using the formatted for a while now and I look forward to the day it’s used by everyone!
I'm wondering how else it differs from using a macro (aside from working like a function rather than having to return an AST, and providing greater clarity)? 
Great question, this is the PR that implements it https://github.com/elixir-lang/elixir/pull/5857/files and it's actually implemented as a macro.
Just wanted to say what a great name. Love the reference. :)
Host at Google and they block them for you
THIS IS ELIXIR OUR LIBRARIES SHOULD BE ALCOHOL REFERENCES
Clearly it should be called Cachaça.
Yeah, but MoneyShot would sound so vulgar.
The TL:DR is, if you implement the macro wrong (as in, using stuff forbidden in guard clauses), you will only find out when using the macro in your guard declaration. `defguard` validates the guard code early, when defining it.
i thought they should be alchemy references
This book is really great on DDD in a functional language https://pragprog.com/book/swdddf/domain-modeling-made-functional
I've found the Phoenix Contexts guide stellar in improving my understanding of how Phoenix nudges you into DDD ways of organizing your application: https://hexdocs.pm/phoenix/contexts.html#content An interesting library for event-sourced CQRS architectures for when you get a good feel of Elixir and Phoenix: https://github.com/commanded/commanded you can find a lot of relevant resources from the links in the readme. 
This looks interesting, but my only worry is the examples show working with CC info server side so you would have to worry about all kinds of PCI compliance stuff. I didn’t look too closely at the code, but it really ought to work with a card token so you could let Stripe or Braintree or whatever processor handle the actual compliance stuff for you.
There's a lot that won't be applicable since F# is an ML language, so all the chapters that rely on the type system for modeling won't be very useful.
On the other hand I am wondering when would `defmacrop` and `defguardp` be useable. 
Based on the table of contents, it seems that book would be aimed at people with not a lot of programming experience. Me personally I would recommend Programming Elixir, which also happens to be more comprehensive. Elixir in Action is also pretty good, although slightly out of date in that some of the code snippets will yield deprecation warnings, but ultimately easily fixable. There's also https://elixirschool.com/en which isn't bad at all and free to boot, so can't complain there. Either way, I'd also recommend going through the guides on the official website https://elixir-lang.org/getting-started/introduction.html which are fairly comprehensive and should give you a decent survey.
You can also try [this](http://elixir-lang.github.io/learning.html) resources. In my opinion they’re great for the start.
Thank you for your replies. But I think I didn't explain myself correctly, english is not my first language sorry guys. What I mean is I'm not looking for a book to teach me syntax of the language, I would rather like to have a book that would teach me the concepts of functional programming and everything I need to know to be a good functional developer. In the ruby world I could spend hours with all the cool ruby books around and still know just the ruby language, while after reading books like POODR I improved my OO skills. 
That book will definitely teach you functional style of programming, but at a relatively superficial level. Elixir is kind of unique when it comes to functional languages because it's dynamically typed. Most people think of ML family of functional languages when they think of functional programming. Languages like Haskell, Ocaml, F#, Idris, all of which are statically typed. There's some common ground between these languages and Elixir, but BEAM (the erlang virtual machine/runtime environment) is quite unique and programming for it requires a different approach, which doesn't seem to be mentioned in the book you linked. Again, I highly encourage you to take a look at the guides I linked in my other post so you can better understand and make a more informed decision.
yes, working on a library https://github.com/aviabird/gringotts yes, working on a production app for warehouse
Thank you again for your reply. So if I understand correctly you're telling me that Elixir is so different from other functional languages that the skills I will learn would not be applicable to other functional languages? Except maybe Erlang which is sharing BEAM and OTP with Elixir? Ok, I will stop looking for more abstract texts on functional programming and will focus more on learning the details of BEAM and OTP, thank you again for your kind advise.
Forked hex.pm as an on-prem repo, rewriting the authorization/ownership to delegate to github personal access tokens. I ended up dropping a good chunk of services, but using the existing hex.pm repo was easier than rewriting up a docs/repo/ui from scratch. 
Yes. Genservers, genevents, genstage, tasks, agents and supervisors are all supposed to provide tidy abstractions for the more common uses of message passing and OTP. Genservers are just a single abstraction, and are meant to be a very generic tool. So I can see why something so generic might not be world-shattering. But it really does solve a lot. Out of the box, you get callbacks for live code updates, process termination, process start/restart, intended messages/uncaught messages, and in elixir, default callback implementations. I certainly don’t want to rewrite all that every time I need a something running in a new process.
I'm working on a brainfuck (esolang) interpreter for codewars. It's been the first problem that has got me dipping *hard* into structs and protocols. I have working solutions, but I'm not happy with them yet. All of this to say that as soon as I am convinced I have the code equivalent of Sterling silver on my hands, I'll press submit and the first solution will be a single 20 byte line that does a bitmask into a generator, derives pi to the nth digit, and runs the brainfuck program flawlessly. But I'll still have learned more about protocols so whatever to that guy.
You can use macros in functions normally, and you can use guards in pattern matches in things like `case`, `for`, `with`, `match?`, funs, and maybe a few other places.
Thanks a lot!
This is great!
Do you plan to integrate Paypal in the near future? I know, PP is pretty lame but the reality is, a lot of people use it.
Ok, last time I have checked I couldn't use macros within their own module. It seems that it works now.
You can't use macros within the module context they are defined in. IE, right under `defmodule`. You usually get bit with that one early when you try to use defmacrop :/
This may sound weird but for me the easiest way for me to wrap my head around functional design was to pick up a book that brought some functional ideas into my day job OO language(javascript). The book I picked up(https://www.amazon.com/gp/product/1617292826) made the switch to a functional language much easier. After reading it it changed how I programmed day to day with javascript and eventual was the reason I reached out to learn elixir because of how much functional design matched up with how I think.
I still prefer having functions that check for whether user_id of user is nill and return a tuple. This way I can have specific error messages. In the posted case you don't know if user_id was not given or if the user simply doesn't exist. This may not always be necessary but I find it to be the better pattern.
This is my first library so I'm pretty keen to hear what everyone thinks
The implementation of `put` looks like it converts a struct to a map to a keyword list, then finally back to a struct. It should be possible to just `Map.merge` the params into the struct.
What if you write it like this: def call(conn, _options) do with {:get_session, {:ok, user_id}} &lt;- {:get_session, get_session(conn, :user_id)}, {:get, {:ok, user}} &lt;- {:get, Repo.get(User, user_id)} do assign(conn, :current_user, user) else {:get, {:error, nil} -&gt; conn |&gt; Controller.put_flash(:error, "User doesn't exist.") |&gt; Controller.redirect(to: "/register/new") |&gt; halt {:get, {:error, _} -&gt; conn |&gt; Controller.put_flash(:error, "User doesn't exist.") |&gt; Controller.redirect(to: "/register/new") |&gt; halt {:get_session, {:error, _} -&gt; conn |&gt; Controller.put_flash(:error, "You have to sign in to access this page.") |&gt; Controller.redirect(to: "/sign_in_links/new") |&gt; halt end end
Yeah. Too bad you gotta create wrapper functions for most things. 
Can't you abstract most of them anyway?
I like functions that return {:ok, result}, {:error, error}, too. However, in this case specific error messages were not important and creating these wrapper functions felt like an unnecessary overhead.
One question: Why passing provider directly to `Gringotts.purchase/5` instead of using separate module in Ecto manner?
Writing my first Elixir app, a Phoenix-based RSS reader. 
One interesting thing in elixir is that processes are used to store state (maybe even a simple Agent implementation as example) and so processes tend to spring up instead of objects. These processes communicate via message passing. I've heard from authors like Metz that message passing is the "true" OOP way, and so I find it interesting that Erlang and processes allow this oop like concept to shine even more than a language like Ruby! Not super applicable info, but I still find it fascinating each time I think about it.
yes, we are following active merchant gem, so will be adding paypal two soon. By the end of march we are targeting ~56 gateways. 
Thanks, this is really interesting thought. Really makes sense 
Hey thanks for the feedback. Yea i see that could be a reasonable optimisation. I've just fixed that now
Hey all, Whenever I write OTP applications I constantly find myself using submodules to separate my server logic, state management logic, and exposed API. When I added a new parameter to a function I had to add it in 3 locations: __MODULE__.Client, __MODULE__.Server.handle_call/cast, and __MODULE__.Impl. To remedy this I created GenClient - a metaprogramming library to create the Client and Server code based on the Implementation code. Please let me know what you think!
I've only written one genserver before, but this looks like it might be nice to abstract a lot of functionality. Any known shortcomings?
Not that I've come across so far - I've been refactoring the backend of a game I wrote to use this instead and the process has been pretty seamless.
Got another one for ya :) The hooks are implemented by checking which functions are exported from the module at runtime. Ideally this should be implemented by defining a `behaviour` for ExConstructable, with stub implementations for the callbacks inside the macro. Allow the user to override them with defoverridable. The benefits are two-fold, it removes the overhead of invoking the hook, since it's all handled at compilation time, and it allows the user to use the `@impl ExConstructable` attribute to ensure there are no typos :)
Passing the lists of calls and casts to using feels a bit awkward compared to th [exactor](https://github.com/sasa1977/exactor/) style of `defcall` / `defcast`. Is it possible to include docs for the Client module?
Ah yes, was just looking at that today! Looks far more useful than what I did. I'll get around to that as well soon
&gt; it removes the overhead of invoking the hook Ah just thought about it and caller_functions = caller_module.__info__(:functions) module = if Keyword.has_key?(caller_functions, method) do does not look like constant time at all! I knew there must have been a better way when i wrote that...
I totally agree with this, I'll definitely look into this. Explicitly passing the calls and casts is definitely my least favorite part of the library so far and was next on my list of things to change up.
I have to say, I'm not a big fan of similar solutions. I'm sure it will save a bit of time when writing the code, but I'm also sure it will cause a lot of confusion and problems when actually using it - primarily because the functions appear out of nowhere in the module it will be hard to find them when debugging. 
Absolutely excellent if you don't want your readers to know what the hell is going on in runtime. Macros are hell, stay away!!!
Thanks Josh Adams for putting out this survey again this year. Really looking forward to seeing the results of it.
This is a super valid point that I totally agree with
Finally a survey I'd *like* to fill out!
Just completed an early version of an JSONSchema -&gt; Elixir module code generator. https://github.com/rstorsauce/Exonerate
This is the first release, nothing fancy, but I thought I'd share it with ya'll :)
A slack bot framework inspired by Plug :) https://github.com/mattbaker/ex-bot
I've been working on screencasts that teach Elixir this month. I know there are already a few options out there, so I'm differentiating it in a few ways... Most sites I've seen... * focus videos on specific language features or bits of syntax * offer a small percentage of videos for free and only on their own site * offer small quantities of heavily edited video that moves at a fast pace [Alchemist Camp](https://alchemist.camp)... * focuses on projects and teaches language features only as needed * puts multiple free videos per week onto YouTube * shares the process of building the site itself * aims for reddit-like information and link density instead of episode "cards" It's not for everyone, but I really hope it's useful for people with learning styles like mine!
Nice TLD!
Hey everyone! I know there are already a few Elixir screencasts out there, so I'll just lay out my motivation for creating this one and some of the differences here: Most sites I've seen... * focus videos on specific language features or bits of syntax * offer a small percentage of videos for free and only on their own site * offer small quantities of heavily edited video that moves at a fast pace Alchemist Camp... * focuses on projects and teaches language features only as needed * puts multiple free videos per week onto YouTube * shares the process of building the site itself * aims for reddit-like information and link density instead of beautiful but pagination-inducing episode "cards" It's not for everyone, but I really hope it's useful for people with learning styles like mine! 
Using fb / google oath does it too :/
I went over exactly this same question when writing a simple app to fetch and log YouTube channel and Alexa ranking stats. I looked at all those options, especially Erlcron but eventually decided the drift was so tiny it didn't matter. If it did, I think I'd just use `DateTime.utc_now` to calculate the span of time given to `Process.send_after`.
Going by the titles it seems cool. might be a good resource to actually get to learning Elixir. Provided you've got a nice voice and a decent production value ;) Cool that you're using Nanobox, it's a semi-recent development favorite for me.
My voice is beautifully powerful sonorous, and yet soulful. But if you want production values, you should probably find a different channel. I'm recording from a $500 laptop and cheap mic. 
This is GOLD, thank you! 
All learning resources are welcome and appreciated. 
I was working on reviving an old elixir project that clones the gameplay of generals.io. I'm happy with the way that the server structure turned out, and it was a fun websocket / game modeling problem. https://github.com/sb8244/generals I think it's served it's purpose for my learning so I probably won't invest anymore time into it.
I'm a huge swagger fan. When do you foresee using this project? My approach with swagger has to been documenting an existing API via swagger so that the backend already exists. One thing I want to build is an elixir -&gt; swagger documentation format. I've done this in Ruby which we use at my employer, but itching for elixir as well. The main objective being that the documentation is tied to functionality, so you can't use a param or get a response field unless it's documented.
Why not just use `:timer.send_interval` or `:timer.apply_interval` ? Sometimes it pays to check the erlang std library :) http://erlang.org/doc/man/timer.html
I think this package is best used at the beginning of a new project. (I need to fix the mix swagger.update task). If you write out your swaggerfile, because most of the boilerplate code like input validation, error code checking, etc, will be correctly generated you don't have to worry about developer error for menial tasks.
I'm the author of the Commanded CQRS/ES library and its companion EventStore[1] library for persisting domain events to a PostgreSQL database. If you're interested in building a domain-driven design Phoenix app then you might like the book I'm writing on the subject "Building Conduit: Applying CQRS/ES to an Elixir and Phoenix web app"[2]. It's completely free to read online, there's an open source example Phoenix 1.3 web app that is built step-by-step in the book[3]. [1] https://github.com/commanded/eventstore [2] https://leanpub.com/buildingconduit/ [3] https://github.com/slashdotdash/conduit
Can you give some examples of something that erlang can but elixir cannot represent in syntax?
Nice package! A couple of suggestions: The ETS store is bottlenecked by a GenServer, you can create the ETS table in protected mode to allow reads from the client API functions without having to go through a `GenServer.call` The debug mode should ideally use Logger instead of `IO.puts`. The logging level can then be configurable to output at trace/debug/info levels.
Right now, I'm just working on exercism.io exercises. Only a few exercises in so far ([profile link](exercism.io/joshua-mcintosh)), and while I'm trying to make them syntactically elixir-ish, I'd say they don't yet have much elixir or erlang-specific functionality or flair. Now that we are in 2018 I'm trying to establish a base understanding of elixir and sharpen my programming skills, thus the exercise route versus a project. I'll look at the wiki here for more learning resources, but I'm always looking for advice and direction and particularly while picking things up. Any suggestions are welcome!
True, I did think of that, but then I have to put all my code in a quote block. I think the real solution is to put this sort of configuration info in the proper config script (ie a map of module name to queue name, table name, etc) and then reference it via Application.get_env
As my profile should make clear, I'm an elixir advocate. However [the best book I've ever seen for learning FP](https://www.goodreads.com/book/show/13541678-functional-programming-in-scala) uses scala. Don't be fooled though. It teaches FP itself and will make you a better developer in Haskell, Elixir, Elm or many other related languages. Realm of Racket is also excellent and a bit more on the fun end, though not quite as intense.
Agreed the Scala book is really good for learning FP. 
It has been a while but I think [this talk on NIFs in the latest Elixirconf](https://www.youtube.com/watch?list=PLqj39LCvnOWZMVugtyKlHMF1o2zPNntFL&amp;v=FYQcn9zcZVA) includes benchmarks.
That depends heavily on what the code is actually doing. I don't think you can devise a general benchmark for this - only see examples of particular cases. One such example could be JSON parsing. I recently wrote a library Jason that uses pure elixir and benchmarked it against the Erlang jiffy library that uses NIFs. The gist is that Jason is usually twice as slow as the native implementation at both decoding and encoding. At the same time this difference closes up as the concurrency of the system increases - Elixir code is more stable. On the other hand when the Elixir code is compiled with HiPE (an ahead-of-time native compiler for Erlang), Jason can outperform jiffy by about 30%. Full results in different setups can be found here: https://gist.github.com/michalmuskala/29112611873bdb2bd7d87e3351aa639a NIFs require a lot of care to write so that properties of the VM (in particular pre-emptiveness) can be preserved. I would avoid them unless you measured some part of code is a performance issue and which can't be solved within Elixir.
Agreed.
I think the real problem I'm having is that what I'm trying to do is really more of a Ruby-ism that just doesn't work in Elixir. &amp;nbsp; I want to basically partially define a module B and ensure that the module that includes my module (A) fills in the missing bits, but that I can still reference. Like, if I could define that my module has a callback but then make reference to that callback in some functions I'm providing to the including module.
I love everything about SQLAlchemy - but in particular the design decision to make SQLAlchemy Core and then build the ORM on top of that. Personally, I'm not a big fan of ORMs. SQL is already a DSL for the database that I know well, so trying to understand the idiosyncrasies of an ORM seems to make the problem harder for me. To that end, I think SQLAlchemy does a great job of providing choices between an extremely thin layer (e.g. practically driver-level, but with more conveniences, and with the ability to easily port across multiple drivers) on top of the database, to the middle-level of actually defining the whole schema in SQLAlchemy Core, to the high-level of doing the entire declarative ORM. To me composing queries with the Core makes a lot of sense and it's easy to mix in hand-written SQL. One of the key conveniences is being to basically do this with any database I want: engine = sqlalchemy.create_engine('postgres://localhost/database') result = engine.query(text("select * from blah where x = :my_variable", my_variable="hello")) ... While this is almost engine-level, you can layer in SQLAlchemy Core elements as needed and use the conveniences it provides. I haven't played with Ecto too much because when I look at the documentation, it feels like I'm going to have to learn the library so that I can learn how to do something I already know how to do, and build my whole schema in Elixir. Not sure where I would begin to try to use it to connect to existing DBs (which is, for me, a very common use case). Ecto may solve all these problems but it seems to be a much heavier layer than what I would be looking for from what I know. I would be thrilled to be wrong though! :-)
You can definitely do mixin style modules in elixir. As you mentioned in a previous comment, it requires putting all the mixed-in code in the quote block. `defoverridable` and `super` even allow optional overrides and calling back into the "base" module.
I love the adoption of docker within the elixir community. Is there a reason you didn't do `REPLACE_OS_VARS` for the config values ? Are you going to post how you chose to solve the ecto initialization / migrations? Right now I get torn between super lightweight alpine, and a docker image that has the source included and auto running `mix ecto.create &amp;&amp; mix ecto.migrate` then running the foreground
`REPLACE_OS_VARS` was just needed when I had to have an integer variable with vm.args. Otherwise it's interpolated to a String. We had to do some interesting stuff to run migrations and we're thinking of writing some follow-up blog posts. I'll share them here once we get them published. 
I though this would be opinions on Elixir rather than a summary of a few features of Elixir ("musings").
I'm not exactly sure why your function call led to the error you got but you want to add a guard clause to your function and don't do the [h | t] thing. The guard clause you want to use is "where is_list(themes)"
"when" not "where" I added the guard and it worked. Not sure why it failed before o.o but I guess this is good enough them. Thanks. By the way, what is the difference between what I tried initially and a guard clause? 
Right, I get that. It just doesn't feel right defining a ton of functions inside of a quote block. It makes me think that there's a better solution that I just don't know yet.
the pattern [H|T] will not match the pattern [], so you were probably passing it en empty list, or an entirely different term. 
Thank you for the labels. I love IO.inspect but this feature alone is awesome.
Is there any reason why you would want to do that? That's now what GET is for and as described here https://hexdocs.pm/plug/Plug.Parsers.html - the request body is not parsed for HTTP GET.
If you really need to accept json, you can probably uri encode it and put it in the querystring.
As others have mentioned, you’d have to parse the JSON yourself since it would all be inside a single query parameter since there’s not a body allowed by the HTTP specification. Some client libraries (like in JavaScript) will actually let you send up a JSON in your GET request and they do that by sending it up as individual query string parameters (Note: arrays are supported by appending [] to the field name). You can also do this yourself and Plug would transform it for you in the objects you’d expect when JSON is sent in. Here’s an example: /search?q=searchterm&amp;config[value]=1&amp;config[value]=2 Will result in params becoming %{“q” =&gt; “searchterm”, “config” =&gt; [%{“value” =&gt; “1”}, %{“value” =&gt; “2”}]} I suspect that’s what you’re actually looking for
While searching through some trademarks I found http://tmsearch.uspto.gov/bin/showfield?f=doc&amp;state=4805:5ug9zp.2.3 registered on December 15th, 2017 - will this affect the Elixir Programming Community?
I don't think so. Elixir has first use and I wouldn't say they actually conflict. Although I can't find Elixir in there.
That is not what GET is for, don't do that. It would never pass code review.
This subreddit is for the programming language Elixir, not the cryptocurrency. :-)
Limited params can be passed as part of the url query string. If you need to send a body that's a POST or PUT. This is not an elixir thing. This is an HTTP thing.
Yea first use in a public domain has precedence. I wouldn't worry about it but also IANAL!
Worth to mention that there are 3 different Elixir trademarks: - Elixir - elixir - ELIXIR
Interesting, so do you think this will harm the community or are we ok?
I do not think so. Even if, I don’t quite give a damn as on my side of Atlantic this will not be a problem. 
The short explanation is that you can only pipe to function calls, not to functions. Omitting `.()` would be ambiguous in some cases: def foo() example = fn x -&gt; x * x end 2 |&gt; example |&gt; IO.inspect end defp example(x), do: x + x Does this call the anonymous or the named function?
Well, you've got a point, but let's not forget about the fact that there's a similar case with variables - you can have a variable named `example` and when you call a function like `IO.inspect(example)`, Elixir doesn't warn you and it just assumes that you meant the variable, not the private function `example`. Isn't that ambiguous as well? IMO, a compiler warning should appear in such cases.
TIL... :) 
I believe your argument doesn't apply here - this warning appears if there's no `foo` variable in the scope when that line of code was evaluated, so it was expanded to `foo()`. I was talking about a case where there's both a `foo` function and variable available in the same scope, but /u/mbuhot explained that it's not really ambiguous since functions should be passed as captures.
Really like the app and idea, man. Good work! I have a few questions for you more in regards to the business side of things, if you don’t mind answering. Are you running this project solo? What’s your marketing plan? Lastly, how’s business? 
Yup, you figured it out. If you run the exs file with `mix run --no-halt` you will get the expected behavior.
There are a couple of structural differences, but one significant _utility_ difference is that the keys in a `map` must be *unique*. This is not the case for keyword lists. Additionally, since keyword lists are just regular linked lists containing tuples as elements, they are *ordered* unlike the keys/values in a `map`.
Outside of mix you can do `elixir --no-halt path/to/file.exs`.
TIL!
I have a small 2-endpoint api that was originally written in Node. It is not that complicated for an API, but it ticks several boxes of things I need to do that help evaluate how much I like a language. (stream parsing xml, parsing json, making external http requests, parsing text output using regex, storing data in redis, and more) When learning new languages I tend to reimplement this api in each new language. I have done so (in order) using Rust, Go, and Elixir. I am no expert in any of those languages so take the following opinions with a grain of salt. I prefer Elixir over Go. + \+ Vendoring is so much simpler with Mix. Go has nothing that compares. Go's workspace and monorepo culture is annoying. + \+ In Elixir things tended to just work. Go's conventions can feel like a footgun until you have them memorized (due to making mistakes and wasting time trying to figure out the compiler error messages) + \+ Elixir's error messages are much more helpful - \- Go has a much better deployment story due to the ease of cross-compilation and only declaring a binary. I recently came across nanobox which took away most of the deployment effort for Elixir though. So this point for Go doesnt matter to me as much. + \+ Idiomatic Elixir seems to be easier to read. Go favors short variable names and a few other things that are not my preference. One benefit Go has in this category is `gofmt` so you don't have to bikeshed over linting. That is about all I can think of right now. I hope it helps a bit. Hopefully someone more experienced can chime in and offer you a bit more info.
&gt; One benefit Go has in this category is gofmt so you don't have to bikeshed over linting. Next version of Elixir will have a formatter so that should make things more even. Also as far as releasing, having only a single binary is definitely nice. Having said that distillery + docker makes things pretty easy as well so I would say that's mostly moot. The advantage probably comes into play for things like CLI utilities and distributing those among the team.
This subreddit is for a programming language that is called "Elixir". It is not what you are looking for. 
Elixir for servers, go for clients.
I think I need this app if you end up releasing it.
Thanks for such a comprehensive answer! The reason for asking this question is a bit complicated. *Background* Back at 2015 I had to choose a new tech stack (with some fellows) that would work seamlessly on all platforms. I was writing C# since it’s beta (2001) and before that, some C++ and Delphi and such (like many of us) but the story of .NET on Linux was not that strong and promising (is it now?). So we made a decision matrix, with weighted parameters like being easy to start with, native code (helps with deployment and preventing casual piracy), preferably no VM, community, availability of libraries, toolchain and such. The evaluated tech set were .NET, Java,, Node.js, Elixir, Python and Go. A big portion of our work was about AVL (Automatic Vehicle Locationing) systems. But we wanted a capable tech stack that could do other things too. In short, Go won. *Reevaluating Go* Most systems today involve a web app part - website or mobile app. If Go was a proper choice for web development, after nine years, there would be one reliable one by now. I’m not a fan of _just use the standard library_. There are a plethora of concerns when developing a website and not everybody is a Guru of web development. Especially when it comes to security concerns, it sounds like a joke to not use a well established, well maintained and reliable framework. We will continue using Go. There are aspects of it that are irreplaceable like generating cross platform native code, gofmt, fast compilation, godoc to name a few. But it sounds as if we could achieve more, if we hadn’t to evaluate so many different packages for every task to see _if_ it provides what we need and is dependable. And to be honest community habits about pragmatic practices, are not the most constructive ones (IMO). It is getting more and more clear that Go is meant to replace C++ in some systems. Using it for app development is not the most _happy_ experience that one could go through. Crunching data is not clean and practices that use reflection or interfaces (with getters and setters) are considered sacrilege. There will be no _language level_ facilities (generics, named arguments, sum types, …); ever. So the _human compiler_ side should be very aware and skillful and despite the stated goal of “being small enough to fit in one’s head”, it raises cognitive load to an unmanageable level especially if you don’t have a big pile of money for adding new _human compilers_ to compensate for that. And one needs a positive communication channel with the community. Go community is awesomely! Awesomely helpful people and awesomely not helpful people; but no middle ground. *Why Thinking about Elixir* First because it is a bit familiar to me. I have an acceptable command of the language and OTP and done some brown field projects in it (some Telegram Bots and Phoenix). Second, the Functional Programming paradigm make things more observable. And immutability provides nice guaranties that removes a whole class of concerns. Third, despite my paranoia of (doing anything big in a) dynamically typed languages, IMO (not proven) I am trading type safety for data safety which when combined with pattern matching, makes things far cleaner inside the body of a function. And multi clause functions, are a nice way of modeling logic. *Why Asking The Question* To learn about real world examples. I had not used Elixir for long. I have a good feeling about it, but it’s not enough. I still love Go (not specifically the language, and the language matters) and will use it for many things. But the story of web development with Go, at this time of 2018, still is not a nice one. 
Did the move of part of a Go API to Elixir to learn the language. In the end, found the Go code way simpler then the Elixir. 
I'm not really sure if what I am about to say is really going to help answer your question here as you are looking for a project that started in one language and moved to another. With that said, I worked on an RTB (Real Time Bidder) project a couple years ago. For those of you not familiar with AdTech, when you go to a website that has advertisements, the website load some JavaScript from an ad exchange, which will send a message to all of the bidders. On average, from the time the auction has started, the exchange will want a response in no more than 100ms. So after latency, we required our bidder to respond within 70ms. The original RTB system was written in C# and I was hired as part of a team to replace the C# bidder. At the time, we settled on two languages to test. So I wrote a prototype in Haskell and someone else on the team wrote a prototype in Go. Unfortunately for me, we ended up going with Go for what seemed like political reasons (my measurements were that the Haskell version was ~20x faster than the Go version). This was also before the GC improvments in I think Go 1.3. I would be interested in running another benchmark since the improvements. So off we went building this application in Go. We essentially broke out the work into two applications. The first one received the request from the exchanges, converted the data into a common data structure and then added some of our own data on top of it. For the sake of this story, we will call this one the collector. It was then sent to the processes that did the actual work of deciding which ad (if any) we wanted to show the user. And we will call this one the agent. The setup was fairly simple. We had some HTTP endpoints in the collector, one for each exchange so that we could convert the data. Then it would send out that new data structure to some number of servers running the agent through a raw TCP socket. The agents were clustered together so that each agent only knew about a subset of all of the campaigns that we were running. We also had the ability to make sure tht each campaign was on 1 or more agents for the sake of redundency. This gave us a nice little topology of 1 collector to N agents, and we could replicate this setup to a bunch of different servers to handle the load. Now for the actual reason I am writing this. As I mentioned, the applications were written in Go. I'm not sure if it was because of the teams unfamiliarity with Go, or maybe the language just didn't "mesh" well with the way we worked, but we ran into a number of problems. I will only go over a couple here. ### No Generics For anyone that does not know what this means or why it may be a problem. I had to write the exact same function multiple times for different types. And I truly mean the same function. The function body was literally the same thing. The only thing different about it was the function head specifying different types. This was rather painful for us. ### Node Communication This was a smaller problem, I admit. But the fact remains there is not a straight forward way to communicate with other applications in Go aside from HTTP or creating your own TCP / UDP socket. And for anyone that has not done work on a raw socket, you basically have to keep guessing how big the request is and read it in chunks until there is nothing left to read. I suppose we could have mitigated this a little bit by sending the content size. 
Once you have a some experience, Okasaki's Purely Functional Data Structures is a great book on how to design algorithms and data structures in a functional setting. It uses languages from the ML family, not elixir, though.
Easier. Maybe it's because Go fits better my mental model of programming or i'm just using it for so long. So, take my words with a grain of salt. The concurrency is easier and simpler. In Go you don't rely on a framework like OTP to do concurrency, everything is built in and it's all you need. Select, channels, context and the race detector makes all the difference. Timeout, rate limit, cancelations, distributing tasks among goroutines, etc.. everything is built using the same operators. I'm talking about the concurrency on the same machine, i know Elixir can do it on a cluster of machines. Tooling is just amazing. Really, gomt, golint, gometalinter, delve, just to name a few. If you don't program in Go yet, just download the vscode and use the vscode-go extension, take a look and you will see. Not just the tooling to help the development, but the tooling to debug the code, trace, profile and optimize. Other thing is, once you stop fighting with the language and accept it's patterns, mostly error handling, package design and the use of interfaces, you became quite productive with it and the code starts to fit better. This gonna make the tests and the code reuse easier and better. In the end, i think everything can be resumed in the focus of the simplicity of the language. It's the best language for everything, hell no, but i can't think in anything better to network services. I'm not saying that Elixir is a bad language, far from it, it's amazing. But today, i think Go still leading the way to build network services. 
Check https://github.com/ueberauth/ueberauth and https://github.com/ueberauth/ueberauth_example.
Can you provide details about what didn't work or errors? It may be configuration of the database as mentioned in the article comments. Uberauth and Guardian are well known solutions for this so may be worth pursuing as mentioned here. The example you link is likely not far off
I like: https://github.com/riverrun/phauxth
You don't rely on a framework in Elixir either to do concurrency, it's built-in, because *OTP* **IS** *Erlang* (and by extension *Elixir*). If you didn't even realize that, then I'm not quite sure we can trust that you actually did what you claim to have... You don't need a race detector in an immutable language. One less thing to worry about.
This is anecdotal and possibly biased but I've met many more people who were happy going from Go to Elixir than the other way around
Very interesting! Even being twice as slow is impressive when you factor in the ease of concurrency and future maintenance.
I would add that Map is a relatively recent addition to Elixir (via Erlang) and for a time, keyword lists were the only way to go
In Go we have a package called context, it's used mostly to propagate the intention to cancel something. So, whenever a HTTP request is made, if something get wrong, the context can be canceled and all the inner operations get canceled at the same time and the error return all the way up to the caller. Don't know how or if this is possible with Elixir/Plug. Other thing that i got problem, but this is not a limitation of Elixir, it's a limitation of Plug as far as i know. How do you implement a timeout middleware that return a json response to the client and prevent a further write when the request finish? Because the immutability, when a plug return the connection to the next plug, it lose the control over it, so, if the timeout middleware write a reponse, the next plug can still write. I didn't found a way to solve this without a modification on every render call. Dynamic configuration is also something that i found very hard. Or i use module attributes (@) to set the configuration i need in a given phoenix controller, but this is set at compile time, so i can't change it later or i need to do function calls to return the configuration from another module, which should not be the fastest thing. This is some problems that i got with Elixir. Maybe the problem is that i don't know the language/ecosystem enough.
A single binary is great for IOT stuff. Nerves is making some progress there (very slowly) but they support such a limited set of hardware.
Yeah, you definitely want to minimise the amount of code in the quote block. Maybe take inspiration from `Ecto.Repo`? It defines little stubs in your module that then call back into the Ecto library where the real implementations are. 
Sorry, forgot to say that i don't have much experience with Elixir. Most of what i know from Elixir i learned during the port of a Go application. About the race detector, yes, you don't need it in a immutable language, my intention was only to demonstrate that even with a imperative language, it's safe and easy to do concurrent code with the right tools.
Load testing? Tsung in combination with Prometheus exporter. 
Anectdotal: I built an API wrapper in Go. Nice, clean, small - or so I thought. Rewrote it in Elixir and because of all of Elixir's sexy features like pattern matching and ETS, I had an even smaller, less cognitively loading codebase. That's the day I went all-in with Elixir and dropped Go like a hot potato.
Thanks! Lack of generics and the way one has to handle errors goes from evangelizing "I love this" to being frustrated (Confession: I've done my share of evangelizing every bit of Go and walked that path). Go is a simple language that pushes the cognitive load level to an unbearable state. In other languages there are far more blogs/resources on "how to do" things than "how to use the language" and after nine years of Go, we still see this pattern. Go is not a simple language (IMHO) if you are to master it. The things that I have to keep in mind when coding, is far more than things I have to keep in mind in (say) C#. For example when a channel is nil, it would be ignored in a select statement. Just some days ago I discovered that even if the channel is nil, the arguments to that case statement will be evaluated, then the channel will get checked for if it's nil or not. And the best answer you get is "it's in the spec" and they tell the truth. It's only I never had to read the spec this much in any other language.
On node communication, while not a built-in package, NATS Server served me well and I like it very much. It provides a simple pub/sub and pub/queue-sub pattern with official clients in many programming languages. And the server can be embedded! So deploying a service can be much easier, so as some tasks such as service discovery.
Prometheus can export a bunch of BEAM VM metrics if that helps. 
&gt; In Go we have a package called context, it's used mostly to propagate the intention to cancel something. So, whenever a HTTP request is made, if something get wrong, the context can be canceled and all the inner operations get canceled at the same time and the error return all the way up to the caller. Don't know how or if this is possible with Elixir/Plug. Pretty trivially, just throw an exception and the request will die (with an appropriate status code to the browser based on the type of exception, which you can override). If something can handle it then they will, otherwise it will end up killing up the chain until it hits a supervisor. Any linked processes or monitors will be notified of the bad death as well (so things like database queries will be canceled as well if any are pending). &gt; Other thing that i got problem, but this is not a limitation of Elixir, it's a limitation of Plug as far as i know. How do you implement a timeout middleware that return a json response to the client and prevent a further write when the request finish? Because the immutability, when a plug return the connection to the next plug, it lose the control over it, so, if the timeout middleware write a reponse, the next plug can still write. I didn't found a way to solve this without a modification on every render call. A monitor and side process is perfectly what this is for. Also plugs can register callbacks to a couple of stages and respond at those times as well. &gt; Dynamic configuration is also something that i found very hard. Or i use module attributes (@) to set the configuration i need in a given phoenix controller, but this is set at compile time, so i can't change it later or i need to do function calls to return the configuration from another module, which should not be the fastest thing. Just change your module attributes to be a call into, say, `Application.get_env(...)` instead. Getting a value from an application environment is *FAST* and you can update it as you wish system-wide. For process specific variables you can use the process dictionary as well. &gt; This is some problems that i got with Elixir. Maybe the problem is that i don't know the language/ecosystem enough. These are all solved issues yeah. If you have questions, don't hesitate to ask on the forums (or on reddit I guess, though many of the most knowledgeable people don't really frequent here). :-)
Hard to help in this case without seeing most the code but as a potential hint; double check your router.ex very carefully against the tutorial you were reading. A hacky quick way in your controller to also inspect the connection object to see what made it in, use `IO.inspect conn` and check your console. Sounds like your very close. Always a lot of moving parts in auth though
Thanks for answering. Best of luck
Not a bad recommendation, I'll check out the source. Thanks!
I am working on a comprehensive howto: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ It's still a work of in progress, but it is pretty far along and should help. My goal is to make a template (https://github.com/cogini/elixir-deploy-template) which puts all the pieces together. That means open sourcing a lot of the components that we are using in our projects, which is taking some time. Feel free to ask me if you have any questions. 
**If I were**
Why don't you say "United America's States" then? Base58Check **of Bitcoin** in Pure Elixir 
Love your posts, keep ‘em coming! u/tippr $1.00
u/petecorey, you've received `0.00040541 BCH ($1 USD)`! *** [^^How to use](https://np.reddit.com/r/tippr/wiki/index) ^^| [^^What is Bitcoin Cash?](https://learnbitcoin.cash/) ^^| [^^Who accepts it?](https://acceptbitcoin.cash) ^^| ^^Powered ^^by ^^[Rocketr](https://rocketr.net) ^^| ^^r/tippr ^(Bitcoin Cash is what Bitcoin should be. Ask about it on r/btc)
Use distillery, when you create your release it generates a .tar.gz with all the files you need along with bash scripts to launch it in 3 different modes. The release packages up the runtime so you don't need any external dependencies. You just need to build it in the same environment you'll be running on, ie ubuntu.
im not nearly as knowledgeable about phoenix, but i remember you have to run 2 commands, one is the brunch build command and then the other is `mix phx.digest`, before you do the distillery commands. If you've done that and assets still don't show up then i have no idea. edit: just found this https://github.com/bitwalker/distillery/blob/master/docs/Phoenix%20Walkthrough.md
I'm using a simple bash-script to help me deploy (https://gist.github.com/mintcore/e59f2c3851b5ce23e6d1a0c00da3851c) It is somewhat dependent on the `mix app.version` (which you can get from https://mintcore.se/blog/2017/11/getting-elixir-app-version-from-command-line) task and that it's set up as a service which have the upgrade method (I'm not sure whether that comes as standard or from distillery)
Anyone have any expirience with one of that platforms?
This worked for me: ocean.com/community/tutorials/how-to-automate-elixir-phoenix-deployment-with-distillery-and-edeliver-on-ubuntu-16-04
Thanks! Indeed, you gave me a good hint. I was confused why subject_for_token was indeed receiving the resource but I was not able to reach it. Anyhow, I think the best approach is to start over again and double check against the example's source code to see what I'm missing.
There’s Rabbitt MQ on Windows. Not Elixir per se but definitely BEAM. I know a few places using Elixir for prod work on Windows but I am not sure I am free to discuss it.
(not an Elixir Guru) Seems it should be `[h|t]` (lowercase, as described in other comments). Also since those parts are not being used, maybe it would be better to declare it as `[_h|_t]` so those will be ignored (starting with underdash).
Thanks!
Bitcoin and Elixir are 2 of my favorite things. It would be awesome to have an Elixir Bitcoin node!
that's the one I was using it worked somewhat, but gave me so many different problems at many corners. The sheer complexity of it was ridiculous, very hard to duplicate for a future project without reading it carefully again. Missing any single step is basically dooming the whole process and I've been at that tutorial for hours. I ended up just writing my own shell script based on the deployment guide at the phoenix docs page. 
There are some things you could do: 1. Streams are not going to be faster unless you are under memory pressure. Plus you are leveraging function composition, laziness and all of that in the Elixir one and not in the Ruby one. You should do an IO.gets and then reduce over IO.stream (similar to Ruby) 2. Remember the string module works at the character level in Elixir but not in Ruby. For a trie, you probably care about the bytes only. Plus you should leverage pattern matching more. Instead of `split_at`, do `&lt;&lt;first_char, rest::binary&gt;&gt; = word` and use the first_char (an integer) as key. Using integers as keys should speed up the Ruby code too 3. Use mix profile.fprof to profile You still may not be able to match Ruby's performance because Ruby is mutable. Elixir being immutable means operations like building the trie above on a hot path will be slower. One other idea altogether is to use a flat map instead of nested ones. So indexing "hack" means you have `%{"h" =&gt; 1, "ha" =&gt; 1, "hac" =&gt; 1, ...}`. While it uses more memory, it can be built using ETS in Elixir (a mutable storage).
Why wouldn’t you just keep the contacts in a list and then use recursion / Enum.filer to find contacts with the proper prefix using String.starts_with? Granted, I’m looking at this on mobile but it seems way over engineered. 
Just viewed your talk, thanks, it was very good!
&gt; Just change your module attributes to be a call into, say, Application.get_env(...) instead. Getting a value from an application environment is FAST and you can update it as you wish system-wide. For process specific variables you can use the process dictionary as well. Didn't know that. Actually, just readed a post of dependency injection from Valim that explain that. &gt; These are all solved issues yeah. If you have questions, don't hesitate to ask on the forums (or on reddit I guess, though many of the most knowledgeable people don't really frequent here). :-) I post at the forum and usually you answer my questions, thanks! 
Maybe you could have passed the timestamp in the functions that are using the timestamp() function directly? This way you can force any time in your tests. Maybe this involves too much refactoring...
I think that the comment about running brunch build and mix phx.digest is correct. In my experience, you have to make sure these static files exist BEFORE producing the release...as it compiles them into the release.
In this case, brunch's work is done and won't be on your production machine. What does your prod.exs block look like for your web endpoint setup? This will generally have something like cache_static_manifest: "priv/static/cache_manifest.json" which should exist on the production machine. 
That was actually my first attempt. On the sample input it took over a minute to complete. Moving to trie structure reduced it to less than 5 seconds. Using e456123789's suggestion to store keys as binaries reduced another second so runtime is now just a little less than 4 seconds. Ruby's version BTW finishes on the same input in 2 seconds
 config :game, MyApp.Endpoint, http: [port: 4000], url: [host: "my-ip-address-obscuring-for-reddit", port: 80], cache_static_manifest: "priv/static/cache_manifest.json", code_reloader: false # Do not print debug messages in production config :logger, level: :info config :phoenix, :serve_endpoints, true import_config "prod.secret.exs" Yeah I see the cahce_manifest.json file produced in the build location on my remote machine. 
OH I figured it out. Thanks a bunch for hinting at other files. I did notice at prod.exs I should have added server: true Furthermore there was some weird npm install script in the .deliver/config file longstoryshort I got it. 
If you moved to a flat map, take a look [at the :ets module then](http://erlang.org/doc/man/ets.html). It works like a table and it is mutable. It should provide similar performance to Ruby. What you want is to store tuples of two elements, the first element is the key, such as "h", "ha", etc and the second is the number of occurrences: iex&gt; table = :ets.new(:trie, [:set]) iex&gt; :ets.insert(table, {"hac", 1}) true iex&gt; :ets.lookup(table, "hac") [{"hac", 1}] The above API should be enough to get a working implementation. All you have to do is to pass the table around. What is more interesting though is that you can rely on operations such as update_counter to atomically update a key or add a new entry if such does not exist: # (table, key, {tuple_position_starting_at_1, increment}, default) iex&gt; :ets.update_counter(table, "hello", {2, 1}, {"hello", 0}) The table was also designed with concurrency in mind. So if you were building the index from files and similar, you should be able to build it concurrently.
If you miss the deal, Udemy frequently has sales. Some they advertise more than others (like the current sale is advertised). Look for Udemy coupons, and you can frequently get any course for $10.
not commenting about their content but those udemy sales are more a marketing ploy than a real sale since they often reset at the end of the sale period with a similar markdown.
In related news: the fluxcapacitor: https://idea.popcount.org/2013-07-19-how-to-sleep-a-million-years/
Have you looked at the Mox library? It would allow you to run the tests concurrently. https://github.com/plataformatec/mox
Ruby/Rails dev here, is this worth it for an experienced programmer wanting to branch out?
Do you already know functional programming(FP)? If not I wholeheartedly recommend the 'Programming Elixir' book by Dave Thomas. And if videos are more your thing than this one is free and I found it a great intro to Elixir [link](https://www.codeschool.com/courses/try-elixir).
Did they ever sell anything for more than a 10? Neverending promo.
Postgresql doesn't support array foreign keys. You need a many-to-many relationship. They're supported by Ecto, so you should be able to use them similarly to one-to-many relationships.
But how would a many-to-many relationship be any different? Wouldn't it still be an array of foreign keys but now in two places?
Says it was last updates 2/2016.
I am reading this: https://hexdocs.pm/ecto/Ecto.Schema.html and have changed my schema to have this: many_to_many :recipes_id, Recipe, join_through: "cookbooks_recipes" Which compiled fine, but still doesn't allow multiple keys so I'm still not sure what you mean by postgres can't do it but ecto can. Are you suggesting I go to another database system?
It's not an array in the *database*, it's another table where 1 row will link a cookbook to a recipe, but you can link the same cookbook to many recipes by just using more rows. It may expose itself as a list in Elixir, though. It's just that the list is backed by a table.
I don't think RPC should be the first answer to application inter-dependencies. What about simply using messages? I feel like the reason you'd opt for RPC in an example like this, is if you didn't start out with the intention of making them distinct services (however you could and probably should add an extra layer to it to expose the functionality you wish through messages rather than use RPC for it). Exposing HTTP interfaces to services can be good for talking with the outside world. However another potential solution (if you also have control over the non-elixir service you wish to talk to) is to build a simple elixir service to talk to your other language. So your system of services treats it as an elixir service (doesn't know any different), and then your elixir service can just talk to the internal service through IPC. Another option could be to actually implement the distribution protocol so the other language service actually becomes a node that can talk to the other Erlang VM nodes. 
No this is the case with any relational database that I know of. I’m on mobile so I may not have this exactly right, but you should gen your cookbook with no references. The reference should be in your recipe. Then you simply add a belongs_to to your recipe schema and a has_many to your cookbook schema. 
I gave this a shot out of curiosity. I found this solution to benchmark within a couple hundred milliseconds of ruby with larger inputs (&gt;100,000 lines). Some things that came up: * Used ETS * Avoided string operations, assumed 1 char == 1 byte * Avoided operations that would allocate a new data structure if I thought I could help it I'm sure I probably missed stuff, but the tests passed and it got pretty close! Plus it was fun :) All this said, Ruby is still faster, and arguably the better candidate for this kind of problem. I don't think I'd reach for Elixir as my first instinct. defmodule Trie do @table :trie def run() do :ets.new(@table, [:set, :protected, :named_table]) IO.read(:stdio, :line) |&gt; String.trim() |&gt; String.to_integer() |&gt; read_commands end def read_commands(0), do: nil def read_commands(count) do IO.read(:stdio, :line) |&gt; String.trim() |&gt; interpret_command() read_commands(count - 1) end def interpret_command(&lt;&lt;"add ", word::binary&gt;&gt;) do word |&gt; bin_reverse |&gt; insert_fragments end def interpret_command(&lt;&lt;"find ", word::binary&gt;&gt;) do :ets.lookup(@table, word |&gt; bin_reverse) |&gt; case do [] -&gt; 0 [{_, count}] -&gt; count end |&gt; IO.puts() end def insert_fragments(&lt;&lt;&gt;&gt;), do: nil def insert_fragments(&lt;&lt;_::size(8), rest::binary&gt;&gt; = frame) do :ets.update_counter(@table, frame, 1, {1, 0}) insert_fragments(rest) end def bin_reverse(binary) do binary |&gt; :binary.bin_to_list() |&gt; Enum.reverse() |&gt; :binary.list_to_bin() end end Trie.run()
I like to push evaluating the current time to the boundary of the system. Eg you can create a simple `plug` module to store it in `Conn.assigns`, then pass it as an explicit parameter from there. One issue with mocking `current_time` is that the code under test will all see a consistent value of time even if `current_time` is called multiple times during execution, which might mask subtle bugs.
I'm using Metrix with Librato and liking it pretty well. Its pretty easy to instrument the important stuff that way, and spitting it out to your logs is dead simple. I had a tough time getting exometer and friends to work, which was probably my fault somehow but Metrix seemed like a good fit. 
100% - the refactoring that it would take is absolutely worth it. It is infinitely easier to test 'foo(:os.system_time(:millisecond))...' than ' foo do timestamp = :os.system_time(:millisecond) ...'
It sounds like you're about to start one ;)
About a month ago I created a post asking for feedback on the MVP of this library. This is the result of all the feedback, thanks everyone!
Skooma is dangerous. 
I’m went with Heroku, had zero problems. 
[removed]
&gt; Skooma was developed to be used to describe and validate the incoming and outgoing data structures from a REST API I've been doing this with ecto schemas in several of my projects. In your opinion why should I use this over ecto?
Great question. I wanted a library that was quick, simple and had great error messaging. While I found that ecto would get the job done, I didn't like it's API. Writing and validating schemas was more laborious than I thought it needed to be. Furthermore, I don't use DBs on a lot of my elixir apps, and requiring ecto just for data validation felt wrong.
That is not active at all. 
Is this a reference I don’t understand or a comment on the quality/functionality of the code?
Skooma is a drug in the Elder Scrolls series of games
I wrote a short tutorial for Guardian 1.0-beta (and I think the 1.0 release was very similar): https://medium.com/@tylerpachal/session-authentication-example-for-phoenix-1-3-using-guardian-1-0-beta-a228c78478e6
Why are you using a GenServer?
Clearly you're buying the wrong Skooma...
I had started with a GenServer, but I don't think i'll have any more complexity than simple state management, so I might be moving that to use an Agent. That being said, I wanted the process supervised so it can be restarted on crashes. GenServer is definitely more verbose compared to an Agent, but at the end Agent is an abstraction over GenServer, and felt comfortable with the GenServer.
I think you should add [restart: :permanent] to the options right? Pretty sure that as of now if you kill IdGen.Server it just dies - could be missing something here though.
I'm very new to elixir but hopefully this helps: on mobile and syntax is probably all wrong but it should point you there at least. Don't repeat the generators. Check the migration file then use mix ecto.reset to restart your database and re do all the migrations. In your migration for create recipe you should have something like add cookbook_id: references(cookbook) Then in your recipe schema you have belongs_to: Myapp.Project.Cookbook Now on the cookbook schema you add has_many: recipe, Myapp.Project.Recipe Your relationship is now defined. Context don't really get in the way when you are defining your schema from my experience. Just when you want to interract with them With no context you would say Myapp.Cookbook.get_cookbook(Id) If you have them in a context you would say Myapp.Context.get_cookbook(id) Or Myapp.Context.get_recipe(id)
&gt; https://medium.com/@tylerpachal/session-authentication-example-for-phoenix-1-3-using-guardian-1-0-beta-a228c78478e6 Really man? Thanks! I used this some days ago. Finally, I did what I said, throw everything and start it over. First, I followed this tutorial. Then, when everything was working, I did Ueberauth's Google auth. By the way, I'm suspecting the problem was no declaring the realm. I thought in Guardian 1.0 wasn't needed the "Bearer" realm declaration, but it solved my problems :/
Does anyone have an opinion on Ace vs Cowboy? Cowboy has worked well for my team so far for these kinds of projects so far.
Thanks for the feedback! Some others complained of the text size, so I've increased it a bit.
Its more of a Plug vs Ace IMO since Ace seems to be at the same DSL level as Plug is as best I can tell. It doesn't look like Ace runs on Cowboy, which is kind of a big mistake in my opinion. I'm not sure I see any benefit to a "Plug like DSL" (Ace) that implements its own underlying server (which is riskier than using Cowboy). Whats Plug missing or doing wrong (or Cowboy) that requires a new project to correct it?
I thought Ace is the server and Raxx is the API layer you code against. I also agree that cowboy/plug already works well and has huge community momentum thanks to Phoenix, I just can't see Ace/Raxx ever used in commercial environments.
Added Elixir support to Dependabot today - would love some beta testers if anyone wants to give it a try! It's totally free for open source and personal accounts, and always will be :-)
I'm surprised they didn't mention the best thing about Ecto is the fact you can write [composable queries](https://blog.drewolson.org/composable-queries-ecto/)
Because AR can do that, too: users = User.where(id: User.where(email: 'foo@example.org')) users = users.where(foo: 'bar') 
You mean like this? Yes this is fine. ``` users = User.where(id: User.where(email: 'foo@example.org')).where(foo: 'bar') ```
I'm not sure what you are asking. You can chain multiple method calls if that is your question: User.where(email: 'foo@example.org').where(id: [1,2,3]).join(:posts) Each method call returns a new query object. You can also do something like this: users_with_email = User.where(email: 'foo@example.org') subset = users_with_email.where(id: [1,2,3]) puts users_with_email.all.map(&amp;:firstname).join(", ") puts subset.all.map(&amp;:firstname).join(", ") You could also do this: users = User.where(email: 'foo@example.org') my_users = users.where(id: [1,2,3]).where(users) The latter generates two queries, though.
code formatter! Nice! 
defguard seems nice as it eliminates the need for a macro.
Seems a bit more concise, though I'm not really sure what the benefit is. defguard is_drinking_age(age) when age &gt;= 21 defmacro is_drinking_age(age) do quote bind_quoted: binding() do age &gt;= 21 end end I should go read the PR.
One of the benefits is that it makes the intention clear. Sure, you could use @doc to explain the macro but "defguard" tells you exactly what it is for. There probably isn't any technical benefit, however.
DynamicSupervisor is a good call. :simple_one_for_one always seemed a bit out of place.
so what? I'm doing pretty well using Elixir 1.4
I love the improved error messages in 1.5 that tell you why none of the patterns in your functions matched. Worth the update just for that. I was hoping the StreamData library would make it into 1.6, but looks like it will be another 6 months.
In the same sense that there's no technical benefit to `defp`. I can think of at least a few times I've wanted to use a guard cause for something moderately complex but ended up not because inlining the whole check would've been too noisy.
Personally I wouldn't worry about it that much. Elixir is open source, people can always install the latest any time they want. But you could always do a last release based on 1.5, branch off and do a release for 1.6 and say going forward you'll be supporting 1.6.
You heard it here first guys. Wrap up Elixir development, this guy's doing just fine on 1.4!
"Connection have data, if you have credentials"
Also worth noting for Mac users that homebrew now has Elixir 1.6.0 as well.
features, features, features, features, features, features, more features, ................ 
I guess I don't need a faster compiler either. Why wait 8 seconds for my code to compile if it can compile in 10s?
Hey, I set it up yesterday and so far so good! The only thing I have come up against so far is the dep version in the mix.exs file doesn't get bumped up with the lock file. Maybe I'm doing something stupid?
In your mix.exs file you specify the lowest version of elixir your code works with. If you'd like to start using `defgaurd` in your project, you'd have to bump that to `1.6`. You can do this if you'd like, but I'd suggest a major version bump of your library and if you need to add any new features you may want to consider backporting them to the `1.5` or less branch if your users need it. If that doesn't sound like too much work (or is something you want to do), then go for it. However, if you'd prefer to wait until more people are using it then you may be able to forgo the backporting. If you don't want to use any new (runtime) features from `1.6`, you're free to upgrade the project itself as long as you don't bump the mix.exs elixir version (and release a new package).
1. A reasonable apprehension, but I'm not sure why a container would be restarted/redeployed any more than BEAM or a physical server/vps would be restarted. 2. I use kubernetes + docker at my job. If you're worried about the data stored in memory then consider blue-green deployment. Kubernetes supports rolling upgrades which might be what you want, but I'm not sure if they deploy the new container and immediately trash the old one, vs removing the old one from the load balancer but allowing it to complete requests.
Whomever is supporting Homebrew should post an announcement when they update. I only post an announcement to insure that people are aware I've updated the package.
If you use k8s, you should know that the docker images are restarted every time there is new code deployed. A physical server or VPS should be restarted much less frequently in a typical deployment setup. You can configure the rolling update of a deployment in how it behaves in that situation. The following config will tell k8s to only use one container, but allow that limit to go up to 2 when performing an update. ``` spec: replicas: 1 strategy: type: RollingUpdate rollingUpdate: maxSurge: 2 ```
Wouldn't that also happen on a server when you have new code to deploy? I mean just because I commit something doesn't mean I want it out on prod right away. In my mind, new container (without code changes) is equivalent to rebooting BEAM on a physical server.
1. I don't know if that is really a big issue to worry about unless you are handling data that can absolutely not be recreated.. In that case you may want to rethink the strategy. I have https://loggb.in running all state in memory in a genserver and it has been fine for going on 5 months. But again you really should not have anything in memory that can't be easily recreated..because bad state is often what causes crashes in the first place. 
My definition of a stateful app is one that contains state in memory and it would get lost when the process dies. In other set ups, such as using Rails + Redis + Sidekiq, you would store the state of your background tasks in Redis, not Rails, so when you push a new Rails app version, Redis remains up, and your state doesn't get hosed. It also opens up ways for you to have 1 Redis DB store the state for many instances of your application. Then you could write out your Redis DB to disk on whatever schedule you deem necessary for your app. There was very little to think about from the developer's POV since Sidekiq did most of the logic related to queuing up the data, retries, etc.. You just write Ruby code and Sidekiq does all of the heavy lifting with Redis. I guess I'm just trying to get that type of work flow without needing Redis, and hopefully without having to write a lot of really "library specific" code (in the sense that, I want to use a library that does it, not create the library to do it). 
i use elixir with dockerized distillery releases at work. i don't think it has nearly as many benefits with a BEAM server as it does with other popular application architectures that have more off-the-shelf components like redis, postgres, etc. the benefit of using it at my work really don't have anything to do with docker or the BEAM, it just allows the same infrastructure / operations department to support deployments in many different languages the same way. if i were only shipping BEAM apps, i don't think i would go with a docker-based solution.
1. Why is your container restarting? with the Beam it shouldn't be restarting ever really. ( more on this below ) 2. I use kubernetes. I've used swarm, meso, and a few others. k8s is the best and even docker is going to it. additional ( warning, this will be a case for docker ): A lot of Elixir community comes from the rails/physical server world it seems like. Stand up a server bring up erlang and it just stays up bulletproof for years. Hot code reloading is awesome. However I think before deciding if you are using docker for something or not, you should really figure out your target. Are you trying to deploy to a Raspberry pi? Have a physical server you need to be hosted on that doesn't support docker or is an older version of linux? Cool beans, docker probably shouldn't be on your radar. Supporting kernel patches and installing docker then needs to become a part of your support pattern. You want to have a package that is delivered to customers that run x,y,z that is on a private network with no internet connectivity? rpm/deb might be better But lets say you want to deploy a web app, that you want to have people to be able to easily integrate with you in a consistent pattern. o Docker fits great. You create images that can be delivered to the people you are integrating with. ( docker compose, postgres,redis etc ) Now when you go to deploy you get to deploy the same version you've already been integrating with the entire time. The same exact image. For me this is invaluable. With k8s you can then have it setup as a deployment and x amount of replicas. Meaning you can specify the node count. Which then means you can also do rolling updates. Which then means you have solved the hot code reloading paradigm without it needing to be a part of the beam VM. ( this point can be argued for other dev ops pattern besides docker ) Lets say you want to setup a SSL terminated nginx proxy in front of your services so you can LB between them? It's handled at the k8s layer pointing to your docker services. Lets say you don't want to have to worry about the security side of the hosts, patching etc. Setup a pattern to delete the nodes and allow them to auto heal / upgrade. Want to have a custom access point locked down by a client ssl cert? Use nginx instead of baking it into elixir. You can set it up. You can even setup an ingress controller to split up requests and proxy properly so that, again, elixir is just focused on service side. TLDR: Docker is awesome but it's not for some situations. 
I mean, you can define it however you want to, but that doesn't mean everybody else does. BEAM allows you to keep state in active processes within your application. That's stateful. You still need to write that state to persistent storage, whether you use Redis for that or something else. BEAM isn't magic, and you still have to obey the laws of physics.
1) I think you're onto something here, but I don't think it's related to BEAM vs Container restart. For one, there should be no reason that your container must restart unless certain conditions are met (health checks). More importantly, though, is that Elixir behaves the same way WRT process crashing in standalone as in Docker. Here, for example, a process crash would be picked up by the application supervisor and restart. A full erlang VM crash would be restarted as the process that Docker was mounted to crashed. A VM crash in your standalone install will need to be restarted by something else as well. I do think that you raise an important point here, though, which is that DETS will not work correctly without persistent disk, which is typically NOT mounted (but could be) to Docker. So you can get persistent disk, but by default don't have it, and you can't have it in PaaS like Heroku. There is nothing stopping you from using ETS though, because it's fully memory based. 2) Hot code reloading is definitely possible in Docker shipped apps, but you're fighting 2 different paradigms. The erlang paradigm is "hot code reload" and the docker paradigm is "cattle vs pets". "Your application should be restartable to a healthy state because a good app can do that" might be a Docker way of thought. I've come to accept that I probably don't need hot reloading for my use cases. As such, I just re-deploy containers in a rolling fashion on deploy. The code ships without downtime (what I care about specifically).
Thanks for the feedback! On the rebase comment not getting removed, that sounds like a straight-up bug. If you comment on the PR with `@dependabot` in the comment somewhere then I'll take a look into it. On updating the mix.exs as well as the mix.lock, at the moment we only update the mix.exs if the new version is outside of the range you'd previously specified. Would you rather we updated the mix.exs version too? Different languages have different conventions on this one, so super keen to hear feedback. (This mainly happens on bumps like ~&gt; 1.2.1 going to ~&gt; 1.2.3, for example.)
https://hexdocs.pm/elixir/v1.6/Port.html Look up using a port. I have used this before and is pretty easy to do. No experience but there is this too: http://pyrlang.readthedocs.io/en/latest/
OH! Cool. I knew ports existed for erlang/elixir -&gt; other program, but I didn't know such software existed for python -&gt; erlang. I'm surprised this exists, looks like exactly the type of project I was looking for, but more complicated than just a rest api. I'll look into it more. 
Of course there’s always rebuilding the python application in Elixir... 
That'd be nice but the point is for learning Django 
The updating of the mix file isn't really a major issue, just something that I have been used to with greenkeeper and the way we use fixed version in our js apps. The only reason it popped out at me is the dependabot PR was for updating a dep from 1.0.0-beta.1 to 1.0.1 and in this case updating the mix.exs file would almost always be desirable.
I already built a phoenix personal project
it is effectively equivalent, just like with rails/sidekiq your "jobs" are only as safe as your redis log to disk configuration. In that case your jobs will be lost in the case that your redis servicegoes down unless they have been written to the store/log. In this way, you will also need to define some "to disk" or backing store for your data in elixir if you want the same types of guarantees as you have with rails/sidekiq and redis. Running in a container, vm, or physical hardware really does not change the fact that storing data in memory should be treated as temporary and non stable storage (if your goal is to persist and retain data between application cycles/os boots etc). .
I had it out in December for Bootstrap 4 beta. There were some changes for the final Bootstrap that I needed to implement. Mostly checkboxes and radio buttons are rendered differently so I had to rebuild that. Good news that there's `form.checkboxes` now that can render list of checkboxes (something that doesn't come with Phoenix out of the box). Give it a try if you got Phoenix app that needs pretty looking forms. Feedback on the code would be awesome too as I'm still learning (Map doesn't retain insertion order like in Ruby!)
&gt; One thing I want to build is an elixir -&gt; swagger documentation format. You might like [open_api_spex](https://github.com/mbuhot/open_api_spex#cast-params). It will cast your params to a struct/map based on swagger annotations in code. 
One aspect of GenServer that doesn't get enough attention in the tutorials is the ability to reply to a `GenServer.call` after the `handle_call` callback has completed, even from another process. That allows you to present a synchronous API to callers, but handle all the requests asynchronously inside the GenServer. 
There are various ways to achieve that. First you can have one application act like a proxy to the second (as described in various places, e.g. [here](https://elixirforum.com/t/migrating-from-rails-to-elixir-bit-by-bit/8568/3)): * Phoenix in front: https://blog.fourk.io/replace-your-production-api-with-elixir-today-4426a890364213 * Rails (or Django) in front: https://littlelines.com/blog/2016/09/27/using-phoenix-with-a-legagy-rails-app This can help: https://github.com/poteto/terraform Another option is to use background jobs in a polyglot fashion, where the part creating the jobs &amp; using their results is in a different tech from the one used in your workers. For that you can check out Faktory (https://github.com/contribsys/faktory), where someone created a Python worker (https://github.com/contribsys/faktory/wiki/Related-Projects). Note that you could also use [exq](https://github.com/akira/exq#using-alongside-sidekiq--resque) for something in that area too. I personally love polyglot workers &amp; apps, they have a lot of great things to bring (it's not uncommon to see Rails apps in the front, fast &amp; easy to create with a tons of gems, then Elixir workers in the background). I've also used workers to handle Windows-only processing (things involving .Net or Sharepoint for instance), with a Rails ubuntu front-end. Hope this helps!
Thanks for the link here! It looks like you're the author: I would say that there's promise here, but Swagger is not a natural format for humans to author code in. Having a DSL that converts to Swagger and fuels your system would probably help out with a more natural interface
This should be the default IMO.
Does this solve the lack of `scopes` in Ecto?
This kinda depends on what you are trying to do in the back end. Do you want Django to serve the HTML and JSON API with Elixir doing the back end work? You may want a queueing system [like RabbitMQ](https://www.rabbitmq.com/). Have Django put things in the queue and Elixir read from it. Also, everyone and thier cat has a [Redis](https://redis.io/) based queuing system. You may find some that are compatible between languages. But, generally, I'd stay away from doing this. If you're just learning, then that's alright. But mixing like this would be a good deal more difficult to manage in a production setting. One more thing, I see that you are trying to learn Django. I'd recommend fully diving into it's ecosystem instead of trying to work Elixir in like this. Investigate each ecosystem and learn from them. Both have different opinions and I think it would be most beneficial to see from both sides before trying to mix and match.
Why would it?
Yeah… that's just some kind of information bubble
Looks nice so far. What's the use case that drove you to start working on it? 
Thanks :) The use case that drove me into working on this is that with every pet project I find myself starting with Elixir, I'm spending some time in moving `docker-compose` files around, I've been using `docker-compose` for testing (sanity + integration) in most of my projects, I find it really easy to just start Postgres + Redis + my app. I want in the end to reach to a state where I have `docker.exs` config/profile and with that I can just start testing. I envision a `mix` plugin that's using this library (I thought about writing it as well) where you could just do something like; ``` mix docker.compose.up ``` Maybe I'll get to it at some stage as well. I also want to think about getting predefined `docker-compose` definitions and being able to expose API for this library, so I could just keep definitions and start using them easily.
From an end result perspective, what's the difference then just having the `docker-compose.yml` file and doing `docker-compose up` ? For some of the projects I put mix tasks that wrap the db clearing as well. 
 I think you are in the wrong sub... this is about the programming language, NOT the crypto coin.
I speak about the language
Ok, sorry. It sounded exactly like in the crypto subs 😊
I feel ya. I currently use docker as the CI/CD side, so postgres/redis are already up before the scripts get executed. Could be nice for build nodes that aren't natively docker. You might even want to consider adding in a generator to generate a build script that uses distillery with sane defaults
See the first issue I've added yesterday (งツ)ว One thing more I like to see is easier revision control to the compose setup.
Elixir is already the present for a lot of people. It's amazing the amount you can already do with it and do efficiently. Some of the larger companies such as google have been releasing tooling for it so potentially it could hit critical mass to go more mainstream than it is. I'd say as it's a functional language and slightly higher iq solution than many of it's competitive solutions.. it may never be huge but it will never have to be to be successful. It's possible too that since it's syntax and sugar are some of the best in the functional world that it will be somewhat of a gateway and be of enough immediate use to get more adherants than I currently predict. But I've got tons done in side projects in 2017 and am only ramping up more for 2018 plus have successfully started using it at work. I'm far from alone in that and I think any ground it gains at the very least it won't be giving it up.
This is great news! I don't personally use Google App Engine but more attention to Elixir is always a good thing!
Had a go with the sample app. It was straightforward, which was great, but takes quite a while to deploy. Also happy that this is available in Australia
Googe Cloud offferings have been getting more appealing due to Firebase, so this is good news.
Do you have a blog where you talk about the side projects? I actually just pushed a trivially simple side-project-tracking side project :D As for the growth, I love Elixir but I also fear that it will be hamstrung by same mistakes Ruby made back in the mid 2000s when it was seen as a legitimate and nearly equal challenger to Python.
Elixir/Erlang is underutilized as a distributed computing solution. Given all of the hype and frustration around cryptocurrencies that can handle only 5 or 10 transactions per seconds, expect an explosion in interest and investment in Elixir as the market matures.
[GCP](https://cloud.google.com/products/) is waaaay more than App Engine.
Not precisely.. I've started writing on smileys.pub (my first side project) but haven't really advertised any of it because I'm finding my writing style needs more practice to get all my thoughts out properly and it gives me more testing on it besides. But I'd be happy to have my side project writing on my side project on your side projects side project project. And I know what you mean about early Ruby; a lot of the hype and over promising did I think give off a smell to many talented developers (probably undeserved). I'm not sure if Elixir has that though, both because the community doesn't overstate anything so far, and it's backed by the BEAM which is not new and has gone under-hyped and under-utilized for decades. I'd also say that Ruby had a positive impact on many other communities. I know PHP was impatced out of it and I'm sure it Python frameworks direction as well
My single biggest concern that reminds me of Ruby is the terrible Windows support. Authors regularly write wrappers for NIFs that break cross-platform compatibility without even thinking about it. Worse, some tools like Gigalixir simply detect and reject Windows users *even though its code is all written in Python*. It's incredibly hostile to the 90% or so of newcomers on Windows machines to expect them to install a VM or buy a $1,000+ Macbook. Ruby did this a decade ago whereas Python projects are generally cross-platform from the get go.
interesting.. didn't know that about gigalixir. Never thought of that as I've done everything on linux so far. I haven't actually read any extensively writing about the elixir experience on windows. At work it would be a necessary datapoint for sure. Windows is primary for 50% of people at work (though they all have VM's) so I suppose it at least affects adoptation there
If only I could use Elixir on Cloud Functions
If I want to develop for Windows, (which I sometimes do at work), I use .NET. I'm interested in Elixir and Erlang partially because it is mostly native to Linux and it's ilk. The very fact that I can use Nerves and do something awesome on the Pi or develop massive distributed server apps is the nifty thing about this platform. You don't need a MacBook. I use a older laptop, a surplus desktop and a couple of RaspPIs, all running Linux. And there's nothing wrong with VMs, containers or OS-less Zen machines. 90% of our corporate infrastructure is VMs. Even Microsoft is developing for Linux, it's not rocket-surgery. 
It depends on what you're trying to get out of static typing. There are two major reasons to select between a statically-typed language and a dynamically-typed one: 1. Catching more logic errors at compile time rather than run time 1. Generating more efficient code because the compiler has more information about the data being worked on To my understanding, typespecs are intended to address problem 1 but not problem 2. Typespecs, properly applied and rigorously tested, should be able to catch all of the same kinds of errors that one would catch at compile time in most other statically-typed languages. For example, trying to hand an integer to a function expecting a string. Whether or not it will catch all of the same errors that a specific language's type system would is highly dependent on the language, the compiler toolchain, the rigorousness of the type system, etc. I would expect Haskell to be able to have better compile-time checking than Elixir's typespects. I would expect most C/C++ code to have slightly worse compile-time type checking. If you're looking for faster generated code, I don't believe that typespecs are going to do anything for you. To my understanding, the code generated with and without typespecs is identical. So, whether typespecs are "good enough" depends on your needs.
yeah I think you're right, I'll just dive into the django system and use what's availabe. Currently just trying to learn it because I see a lot of companies asking for django devs. I'll probably stumble upon redis on the way there. The queuing system is a good idea! I haven't used one yet but I figure I'll have to eventually. 
Behaviours and typespecs are certainly valuable. Even if the success typing system allows some bugs to slip through, they serve as a machine checked documentation for future devs :)
An IoT command and control server w/VerneMQ. 
I just launched a really basic side project, for [https://statwatch.me](logging your audience stats]. I hoping to finish migrating my primary site from a custom Cowboy server to Phoenix by the end of the month.
Some of the first Ruby programs I wrote were on Windows. I switched to Python on Windows, and then .NET not because Ruby had poor Windows support, but because Python was better, but because it had more libraries and was faster. (.NET because of corporate needs, but I still use Python in my data tool-kit as needed,) Linux isn't a burden or that hard to be competent in, it's easier to learn than git or PowerShell, and easier to setup and manage than Windows nowadays. And being Windows admin and developer for years, as well as a early Linux adapter, I find a lot of users and developer don't have more than a surface knowledge of Windows and you really just need the basics for Linux. With VMs, cheap computers and oodles of learning resources, Linux is fairly easy to learn, you don't have to be a grey beard or an elite hacker. I work with Windows full time, but I can get a Linux machine fully loaded, patched and configured just as fast. And Elixir and Erlang on Windows is like F# or .NET on Linux, it works, but you aren't in the ideal environment in the long run. I fought that battle with a few other languages, but decided it was cheap enough not to tilt with wind mills. And it's not a barrier to adoption. Elixir and Erlang aren't beginner languages. As a growing developer you have to learn more one language, you also need to learn more utilities, more math, more algorithms and more than one OS. 
Interesting to me! i would love a job at Grindr
Building an ECS (entity-component-system) framework.
You can pass a few options into the phx.new command to remove the bloat for API only projects. Namely: —no-brunch —no-html This blog post goes into a few more details about how to strip more out of a base install based on your requirements. http://cloudless.studio/articles/45-bootstrapping-api-project-with-phoenix-1-3 Note: it’s not my blog. Phoenix, in my opinion, can be a great tool for API only projects.
If you're coming from a Ruby background, Phoenix is not bloated in the way Rails is. Most of Phoenix is just a thin layer on top of Plug. It's perfectly fine for APIs, and you can cut it down more with the generator options.
This is a subreddit for the Elixir programming language, not the crypto coin.
By free help do you mean the large community behind it ? Is there a Phoenix reddit? :)
I would start with Phoenix. Then I would use JWT with joken for oauth. As for what to write the API in ? Json/rest? Phoenix is great for that. However I am a fan of graphql and highly recommend absinthe. 
Generally the community we have here and on Slack is it, but the rest of the help is in the form of helpers for relating ecto objects to crud actions, a smart folder structure, etc.
[ExMetra](https://github.com/jhartwell/ExMetra), which is a library for interacting with Chicago's Metra REST API. Started it this month and am slowly adding more features and playing with macros as well (by adding a query language of sorts)
Working on an APRS-IS app to allow ham radio operators to interact with/easily write apps that interact with the APRS protocol. Send messages to your buddy’s radio. Get messages when you turn your radio on, etc. 
They are pretty good, and if you use them smartly they will catch a lot of bugs. However they are not perfect and will not catch everything. In addition dialyzer errors are often horrible. 
Keep in mind that communication between nodes is unencrypted by default. I would recommend not doing this unless you are sure about what you data may be exposing
[numberstream.io](https://numberstream.io), a small side project. It's just a beginning but I am having a lot of fun with elixir/phoenix.
ExPress, a CMS alternative to wordpress
I've started to learn Elixir and Phoneix and blogging about it. Some of you may have seen me here because am submitting links to my posts here. At the moment as a working project, I've chosen the Chat Application. Not a unique app, but it should help me to cover a lot of different topics. If you are interested, you can it here http://whatdidilearn.info/
Or just put bastion in front of everything and connect via SSH tunnel. 
I like how the rails console does it. Puts long lists into a less view, for which you can inspect or backout of. Would be nice to see something similar.
My impression of Dialyzer after playing with it a bit is that it is (at least relative to the Elixir ecosystem) *extremely* unpolished (the signal/noise ratio is low) and could probably use a total rewrite in Elixir that comes with Elixir-style friendly warning messages.
Jepp, Phoenix is the way to go. I did 2 projects with it and it works great. Right now I'm using it to build a websocket only pubsub api for my own blog (which therefore not exists yet). There is sooo much useful bundled with it. Definitely worth a shot! ;) 
I use typespecs and guards (such as `is_integer`, `is_atom`…) to have some compile-time (dialyzer) and runtime (function clauses) type guarantees.
Working through https://leanpub.com/buildingconduit. It's only 30% complete, but it's really helping me figure out a work-flow for developing event sourced applications. The abstract concepts of CQRS/Event-Sourcing aren't that hard, but having a step-by-step resource for what questions to ask at what step in a development work-flow is something I've been having trouble finding for Elixir event-sourcing.
I had the same experience and coming from the nodejs world one of the first things I built was an auth package. This time around I got to learn from that and make something hopefully better.
https://github.com/jpiepkow/accesspass An opinionated full authentication solution. Spent quite a bit of time on the hex docs now writing tests.
Fair points. I did mention it was very opinionated in the beginning of the post. This is just my flavor of how to handle authentication that may be of use to some people that want to get something rolling quickly. Especially being basically plug and play with Phoenix. But in no way do I think this package is right for everyone...more just sharing what I use in my projects.
All done. Thanks for the reminder.
Read your entire elixir blog while I was learning this past holiday. Hoping to post my own project here soon :) 
I'm pleased to hear that. I hope you find it useful. Good luck with your project =)
Hi again, another quick question. We just added dependabot onto a slightly older project and we didn't get PR's for some of the outdated deps. It looks to only affect deps going from a 0.x to a 1.x update. So for example we have {:guardian, "~&gt; 0.14.4"} specified and were expecting a PR to guardian 1.0
If anyone has any questions or comments, let me know and I’m happy to reply here.
If you enjoyed Command-Query separation (CQS), you'll love Command Query Responsibility Segregation (CQRS) [1]. [1] https://github.com/commanded/commanded
Looks like an interesting book. Are you talking about [event bus](https://github.com/otobus/event_bus) in the book? It'd be a good topic if you have a section on libraries.
Telegram bot for cryptocurrency's 
Phoenix/Postgres-powered event store (and associated consumer services)
Hi, saw you linking to my post. Glad you found it useful, your article makes for a nice addition. I'll link to it for people who want to do more with http2
Because I think that phoenix (and plug) are too complicated. I have been working on raxx. https://github.com/crowdhailer/raxx Been working of it for 18 months and it has some production deployments. For websocket endpoints and some API's. It has less of an ecosystem to plug but it is very simple. p.s. The complexity in plug/phoenix is less in using them and more in their implementation. There are a lot of macros to understand when you dive into it
Yeah, I found you post really useful, and used it with another example repo to learn how to set things up. I had in fat imagined my article as adding onto yours, which is why I wanted to give you credit. I really appreciated your post.
The main problem I have with these curated results is I wonder if the person who put the list seriously went through the entire material, or just found a book, wrote a quick summary, and moved on. And for the material that is referenced, I wonder if the author ever used the book in a course with actual students (most books aren't, to my knowledge, written this way).
Have you seen the EventStore[1] Elixir library that uses PostgreSQL for persistence? You could potentially use that as the basis to provide a Phoenix service on top. [1] https://github.com/commanded/eventstore
I have, but I have a simplified model and can build the things I need in roughly the same amount of time it would take to integrate with Commanded/EventStore. Furthermore, control over the components and design is valuable to me as I’d like to be able to swap out certain things (e.g. Postgres) later on and that will require small, simple, portable interfaces.
Looking over the post history of the submitter, it's definitely the "quick summary" route. This is just blogspam.
Please send me a pull request to include your new libraries in the Awesome Elixir and CQRS[1] list I'm curating when you're ready to publicise to the community. [1] https://github.com/slashdotdash/awesome-elixir-cqrs
I would try using a list for the deck: [4, 4, 4, 4, 4, 4, 4, 4, 4, 16] `put_elem` will always copy the tuple. A `for` as an argument to`Enum.sum` is a bad idea, as it O(2n) performant. Use `Enum.reduce(deck, fn (card, acc) -&gt; ... end)`. Optimizing `Outcomes.partitions/2` to be tail recursive would also help. 
You can have concurrency on one thread, but not parallelism. With concurrency nothing actually runs at the same time.
Thanks! I'll take a look at your suggestions.
I'm pretty sure these are all just affiliate links with copy-pasted text from the udemy pages. It's total spam and I'm really curious how many of these upvotes are legitimate.
I have not personally read this book however just recently there was a book released that deals with this [topic](https://pragprog.com/book/wwgraphql/craft-graphql-apis-in-elixir-with-absinthe).
Parallel is the literal simultaneous execution of tasks. Concurrency is an abstract model that may involve parallel execution. When you write two processes in Elixir that run independently but join at some point, that's concurrency. They may be running only one at a time, or they may both be running until the sync point. This is also true for threads in many other languages. Like in C and C++ back in the single core days, we used threading to create concurrent designs. We did not use it to get true parallel execution because it was, on those machines, impossible. We later benefited from the shift to multicore CPUs by getting parallelism (if you'd correctly designed your code to avoid things like race conditions and such). On the other hand, the task execution on a GPU or with SIMD instructions is parallel. Many simultaneous computations. There isn't necessarily any concurrency in the design, it's just that the computational model there allows us to execute a set of instructions on a block of data all at the same literal time.
I almost picked this up last night but wanted to hold off for some more reviews. PragProg is a great imprint so I have high confidence.
Sure, I over dramatized for the sake of the point. :-)
I'm working on various Phoenix apps and I just published my first Hex package (hopefully first of many) https://hex.pm/packages/find_type
I just went through about half the book a few days ago and then I got busy with work and didn't finish it yet. But so far it seems good and it's a pretty easy read. I recommend it. My way of learning this was that I created my own app and pretty much started working my way through the book adding to my app in similar ways to what the book's example does. This works really well but it's also slightly frustrating because you're used to `mix phx.gen.json ...` generating a whole CRUD for you, and as you're building your little toy app with the book it feels like you're spending a *eternity* just on the equivalent of a traditional "index" action. It feels like you've gone through half the book before it even starts talking about creating/updating records.
Ok so how many of these "mount the local file system" articles do we need? This does nothing but explain the obvious and rehash the official docs
The value that was assigned to list1 can never change (the [3, 2, 1] list), but what variable list1 points to CAN change. So when you assign [2, 1, 0] to list1, a new list [2, 1, 0] is created and assigned to list1, but the old one remains untouched in memory and thus can be used to construct the [4, 3, 2, 1] list.
Thanks for the clarification. That makes sense.
To easy it for you, the syntax `[3, 2, 1]` is equivalent to `[3 | [2 | [1 | []]]]`. Fun fact you can have something like `[2 | 1]` which is called improper list (root of the list isn’t empty list). 
what about on the client? Imo a more robust solution is to (outlined here: https://elixirforum.com/t/proper-way-to-close-channel-from-the-server-side/10955 ) : in your service code `MyApp.Endpoint.broadcast("topic", "end_session", %{})` Then in the channel push an end session message to the client and terminate on the server by returning a :stop ` def handle_info("end_session", _params, socket) do Logger.debug("Ending session...") push socket, "end_session", %{} {:stop, :normal, socket} end` on the client: ` channel.on("end_session", payload =&gt; { console.log("terminating session") channel.leave() }) channel.onClose( () =&gt; console.log("channel has been closed") ) `
I replaced the Enum.sum with an Enum.reduce and got better performance. I'm not sure why, but replacing the range 0..9 with the explicit [0,1,2,3,4,5,6,7,8,9] also improved the performance. It's still about 5x slower than I expected. But, really, this is a case where I believe an array is the superior solution, so Elixir may just be the wrong tool for this particular task. https://github.com/octonion/puzzles/blob/master/blackjack/elixir/outcomes2.ex
Looks like this code is reliant on the client receiving the disconnection message and handling it correctly? That unfortunately leaves the information leak open as the user could theoretically block such a message.
See here: https://elixirforum.com/t/closing-a-socket-when-user-is-removed-from-system/6118/3
This kind of library doesn't exist in the current eco-system but it seems possible to call some python (pyephem) from elixir: https://hackernoon.com/calling-python-from-elixir-erlport-vs-thrift-be75073b6536
Elixir isn’t good solution for CPU heavy computing. It is rather for IO heavy computing, where processes are short lived tasks. In your case I would make server in Python that would be connected to Elixir application which would handle IO, caching, etc. and your old application would handle heavy computing as it is doing now. 
I’ve got some calculations in my satelliteEx library. It’s not specifically a generic library for these calculations but it may have something you can use. https://github.com/Matt-Hornsby/satelliteEx
Thanks a lot! One function won't cut it, sadly (because of date conversions and such), but I think that's the way I'll go. 
Too bad. I really would like to have some kind of list to work on. Some kind of ladder, which i can climb. I can write my first Programms in Elixir but as usual I am not able to get everything and my coding feels wonky. 
It looks like you wrote a lowercase I instead of an uppercase I. This has happened 6129 times on Reddit since the launch of this bot.
Thanks a lot for that, I really appreciate it! 
You're writing procedural/mutable code in a functional/immutable language. I for example, in thousands of lines of Elixir code, have never once had to use `elem` and especially `put_elem`. You have to stop thinking in terms of arrays and start thinking in terms of lists with heads (the first element) and tails (the rest of the elements) and write functions that process things that way.
you mean the tail of the list isnt an empty list...
List has many tails and only one root. And yes, it can happen that the tail of the (non empty) list will not be the list. 
This doesn’t make any sense. A linked list has only one root and one tail. An improper list is when that tail is a term other than the empty list. Normal list: `[1 | [2 | [3 | []]]` Improper list: `[1 | [2 | 3]]`
I think it doesn’t hurt to have one more post explaining this topic. A few days ago, I had the same problem and knowing this blog post would have helped me save some time.
OK so I tried to cover this with some kind of test and then rewrite into something functional and only succeeded in making it slower... I know there must be a way to update the Nth element of a list without re-navigating the whole list (which would make it take the same time or be faster) but I ran out of time, here's my work so far: https://gist.github.com/pmarreck/29e2179ccc1d47e74518d5ce5a3937bb
Hey everyone, my goal for February is to write a blog post every day. I figure that doing it on a non-leap year is a good idea. The ideas are varied, but cross technical and human side of Elixir development.
The question is not clear for me. Do you have experience with HTML, CSS and a bit of Javascript? Because that's all you need to achieve something like that.
If you know a little html and css this course may help you with structuring your layout https://scrimba.com/g/gR8PTE
Including dialzyer’s plt generation was another pain point since it takes so long. Thanks for the update!
I would start by going to https://www.freecodecamp.org/ and taking their free HTML / CSS courses. Click "Map" in their nav menu to see what you'll learn.
This is a good introduction to HTML and CSS: https://www.amazon.com/HTML-CSS-Design-Build-Websites/dp/1118008189/ref=mt_paperback
Slowly but surely working on creating a course hosting platform using Phoenix. I'm learning Elixir / Phoenix along the way from ground 0, but have prior development experience.
I am working on a big blog post on best practices for deploying apps: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ Generally speaking, it's best to use the VM config process (`Application.get_env/3`), as you should be using Erlang releases to deploy. If you have something like a listen port, then ENV vars are ok, but only for simple strings. Using [Conform](https://hexdocs.pm/conform/getting-started.html) is a good way to handle more complex config from env or local config files. 
Well, I mean, with phoenix you can easily render a list of data. How would be possible to render a grid?
My practice has been to store anything that’s not sensitive info within your config files to pull with Application.get... but if it’s any sensitive credentials just store it in your environment variables with Docker/K8s or something similar!
This is not true. Config is evaluated when mix is started. So when you're running with mix, config is evaluated before any application is started, but it is done at runtime not compile-time. In releases, since there's no more mix around, the config is basically "frozen" in the form that was present when you run `mix release` (since that's the last time when mix started). You can override that by using custom `sys.config` files or, as pointed out, the `REPLACE_OS_VARS` mechanism.
I wonder if it would have been helpful to have a Day 0 where you introduce yourself, your experience in software developments (years knowing this language or that), and the goals of the blog itself (maybe simply motivating yourself to keep learning and being a diary of sorts). For example, being a relative newbie to Elixir, I'd say your level is way to advanced for me. There are things, as a mature developer, that you take for granted (say, in the first blog, being able to control the version of Elixir you run, where a newbie would pick one and stick with that--undoubtedly, this is driven by something that has occurred while working with other languages where it's good practice to do that).
I don't access them directly. I map them to config items in the `prod.secret.exs`and then read them in from `System.get_env` as you stated. And yes you're exactly correct. Anything that is useful in development as well gets thrown into general config (as well as `staging.exs` and `dev.exs`) and it all gets read in from ENV vars so no sensitive info is ever kept in plaintext.
Cool, thanks.
Great feedback. I'm curious about your comment on say, controlling the version of elixir you run on. Why is this type of thing out of control for a newbie? What sort of things would you be looking for, as a newbie? I'm curious if material like https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html is considered too advanced for newbie or not? I can definitely address that in a "how I got started with Elixir" type of post.
Well, for a newbie, they just want to start coding, right? In an ideal world, the language would be fixed, and I wouldn't have to think about which version I'm working with, because that opens up another can of worms, like "Which version should I use?". For some languages, until you hit some advanced features (or semi-advanced), those features don't affect you much. For example, I mostly program in Java. After 1.5 (where generics, foreach loops, etc are introduced), the only other "feature" I care that much about is not having to specify the type of a generic when assigning to a variable, i.e. List&lt;String&gt; list = new ArrayList&lt;&gt;(); All the other features aren't so relevant (for example, those used to coding Java 1.5 but haven't particularly added to their skill set are probably not super keen to moving to lambdas). About the only other advance in Java I would care about is maybe using the new Date class. In any case, if I pick, say Java 1.7, I can, for the most part, not care what version Java is on. Or I can wholescale change it to Java 1.9 because Java tends to be pretty good about backwards compatibility when it comes to programming. I recall looking at Python's virtualenv. If you look at any tutorial on Python, it probably won't mention this unless you decide to do some web stuff, then it does funky stuff that you wonder, why do I have to care about this? I'm not saying people don't have to care, just that people wish it didn't matter. Maybe if get to doing cloud development for everything, we'll just specify which version we want, and then it will spin up a workspace isolated from everything else, so we don't have to think having one directory in our laptop be in one version and another directory in another version. Perhaps I'm just being silly.
Some have already mentioned env vars, and that is what we are using at work as well for production configuration that needs to be per-node / configurable at runtime. At startup we read in the env_vars and put them into app config with Application.put_env so that we don't see the env vars elsewhere in the code base, and we use REPLACE_OS_VARS for changes to vm.args. This is necessary since we run our applications in clusters, so there is per-node configuration in addition to wanting some things to just be more flexible than release-compile-time values. Though, for some values, that's also fine. It works well, and if you are using something like Docker and/or etcd then it becomes pretty trivial to get these envvars around. Someone has already mentioned Conform, and it has a number of advantages. Namely: env vars are just strings at the end of the day. Complex data structures are pretty much a no-go unless you pull hacks like passing in json objects and parsing them (ugh). Even simple things like dates or IP addresses require validation in the env var approach because they are, at the end of the day, just strings. Lists or maps? Yeah .. no. So quite limiting. Conform does address these issues, and even adds some documentation and type checking. However, if you want to change those values you're pretty much going to have to restart your application with either solution. That's not optimal. I really rather like the idea of etcd, or even better zookeeper, though the latter is more complex than I'd like in a configuration solution. They provide a coordinated way to define and deliver configuration, and most importantly change and watch for changes on those values. I don't like their authentication models one bit, however; they are stuck in the UNIX TTY mindset, though zookeeper does better there offering the option for things like kereberos over sasl (though sasl leaves so much to be desired as well). So, better, but certainly not near perfect. They also mean deploying either a java or go application .. meh. I would love a simpler, Elixir-native solution that provides something similar (though better than :) etcd/zookeeper, which can be embedded for easy usage (either for simple single-node deploys ala heroku, or for self-hosting configuration within a (possibly dynamic) cluster) or run as a separate service. While what we are currently using with envvars is sufficient for the moment, I know it won't be in the long term as our clusters continue to grow. So I somehow fear that unless someone gets their first, we'll end up having to do something eventually. For now .. envvars. :)
I don't think you're being silly...I think we just have different views. I don't think I'd instruct a person who wanted to professionally do elixir to not control their version or care about it. However, I would suggest brew install elixir for anyone who just wants to try the language, with the caveat that they have a path forward before they start trying to really develop on elixir. The elixir docs to a better job at introducing new programmers to elixir than I could in a blog. However, things like "what to expect" and "what material to start with" is something I can provide.
I'm working on a blog post daily this month, as a personal goal. However, I'm working with my team at work to get 2 different elixir services stood up. For my blog, the technical content I'm most excited for is going over how to build a distributed choke point.
I realize this is an Elixir centric post but in Ruby/Rails please don’t use `ENV[name]`. If that variable doesn’t exist it will return `nil` which is probably not what is intended. Instead use `ENV.fetch` which throws an `IndexException` unless you explicitly provide a default value or block. It may be longer but it’s more explicit and will not silently continue and blow things up later.
With tools like [direnv](https://direnv.net/) around, anything truly secret gets shoved in a .envrc, and anything I wouldn't really care about losing goes in plain configs
The way everyone else told you to. This question has nothing to do with Elixir or Phoenix, but general web development (HTML and CSS). That is where this work is done.
"CSS Grid" might be the one where you should look into. Here is my favourite presentation about CSS grid, its really easy to understand: https://www.youtube.com/watch?v=7kVeCqQCxlk
JQuery's Masonry library worked for me finally! But thanks
&gt; Even then bug in NIF library will take whole VM down. That is, of course, true about any exectuable that binds into native C functions. However, it is not true that this is a hard line "must" with the BEAM. You can run code in a slave node and supervise that, so while the slave node may crash, the main VM won't. The return values of calls are returned to the caller in the main VM. We use this where I work to run 'unsafe' (read: possibly crashy) C++ / CUDA code without it taking down the VM. Here is a quick gist: https://gist.github.com/aseigo/c62191e8bbdbcaa1f76dc1aad6bec540 Note that that doesn't work nicely with releases deployed with tools like edeliver due to some unfortunate assumptions in the erlang slave module. I have an Elixir port of that module specifically for this use case (so it isn't as general purpose as the erlang slave module; for instance, it doesn't have a relay mode). Was very little effort to get working ... &gt; lso Python is becoming de facto standard in the physics, so it will be much &gt; easier to find someone who knows Python when it will come to extend &gt; such functionality instead of finding physician who know Elixir You are correct that more physicists know Python than Elixir, I don't agree with this conclusion on two points: a) Python got to that point by providing bindings. That's it. Same for things like TensorFlow, which have a not-very-pleasant-to-use-directly C API designed for bindings, and then nice bindings into languages like Python. For the Elixir community, having similar bindings would be fantastic and would allow Elixir to be used in those contexts. b) If you are going to have physicists on your team, (as opposed to hoping some random physicist puts a library out that you can re-use), Elixir is a small ask. Many already know more than one language as it is. The Elixir community would do well to get past this "not for computation" rubbish. It is far more appropriate for computation than e.g. node or ruby are, and no less appropriate than python with the big caveat that python already has oodles of bindings.
Build badge says failing .. the code of conduct is longer than their docs. Great project, needs to lower the bar to getting onboard.
It's a replacement for the BEAM's included clustering system that connects nodes together. Partisan provides a way for nodes to find each other and then connect up so they can pass messages, just as distributed Erlang does, but with better scalability and flexibility. Distributed Erlang creates a full mesh, and requires add-ons like libcluster to automate joining/parting clusters. From the docs on lasp-lang.org: "Partisan is the technology that provides Lasp's scalable cluster membership. Partisan bypasses the use of Distributed Erlang for manual connection management via TCP, and has several pluggable backends for different deployment scenarios." What I'm not entirely fond of is that it has its own message passing as well. Would be far nicer if inter-process message passing could be hooked into this rather than having to use partisan_peer_service:forward_message(NodeName, RemotePidOrRegisteredName, Message). More here: https://lasp-lang.readme.io/docs/overview
The code of conduct is standard, but they really do need docs.
Could use a “this is how it’s different than distributed erlang and why it scales better” section... Looks like it also uses a gossip protocol so where’s the improved performance or scalability?
This piece needs to be at the top of the readme allows applications to perform up to 13.5x better or scale to clusters of thousands of nodes over the general-purpose runtime distribution layer.
There's a great community at https://elixirforum.com as well.
Shameless plug, but it's relevant! [DeferredConfig](https://hex.pm/packages/deferred_config) is a super-simple approach that lets you defer config to runtime, so that (for instance) you won't have config woes when you start making releases and your `System.env()` calls now need to be moved out of config and into the app startup lifecycle. You just make one call, to `DeferredConfig.populate(:my_app)` at app `start/2`, and it will do a replacing walk of your config for patterns that it recognizes, like 'system tuples' and more general 'module, function' tuples. [Some examples and context/issues to consider in its docs](https://hexdocs.pm/deferred_config/readme.html). 
I'd recommend setting up a config service based on `Phoenix.Tracker` (from phoenix_pubsub, does not require Phoenix at all) for the config you want to keep track of; it's very approachable when, as in this case, you'd probably prefer your config service to run on every node. There are, of course, abstractions built on that already (service, dht, etc), but I'd recommend just using Phoenix.Tracker directly as getting a feel for building practical crdt-based services has such a massive payoff.
Not sure what you mean ... what community disaster are you thinking of?
[The shitstorm that resulted from this](https://bugs.ruby-lang.org/issues/12004)
Direnv is awesome! Thanks for the link.
Authenticating by email is a better approach than some people realize. If a site allows password reset via email alone that is equivalent to email auth anyway.
Hi, I'm new to Phoenix but rolling my own password less authentication was the next thing I was going to do, so your library came at a very good time. Nice one! But I have a question. Why aren't you use Phoenix.Token to generate the tokens?
Yes, I totally agree. I think this should be the standard for any site that doesn't store something important like payment details. And of course everyone should have 2-factor authentication on their email account.
Agreed. I built a system that used passwordless auth (which I rolled myself with Phoenix tokens) in Elixir/Phoenix last year, and I fell in love with it. As you said, if a website allows a "forgot your password" workflow, they already support passwordless auth, just in a clunky, roundabout way.
Sorry to tell you that if you use the short version of child spec `{module, arg}`, the `start_link/1` of that module always gets called, and `arg` is passed to the parameter of `start_link/1` **as is**, so you can't use `{Task, [KVServer, :accept, [4040]]}` because the supervisor will call `Task.start_link([KVServer, :accept, [4040]])` (pay attention to the outermost brackets), and that will raise `badarg`. If you want the supervisor to call `start_link` of other arity, or even other function, you have to use a map as the spec. For example ``` def start(_type, _args) do children = [ %{ type: :worker, # optional, defaults to `:worker`, the other value is `:supervisor` id: Task, # optional, defaults to the module given by the `start` key (see below) start: {Task, :start_link, [KVServer, :accept, [4040]]}, # required, a module-function-args tuple restart: :permanent, # optional, defaults to `:permanent` shutdown: 5000, # optional, defaults to 5000 for worker, and :infinity to supervisor } ] opts = [strategy: :one_for_one, name: KVServer.Supervisor] Supervisor.start_link(children, opts) end ``` You can find the full documentation on [https://hexdocs.pm/elixir/Supervisor.html#module-child-specification](https://hexdocs.pm/elixir/Supervisor.html#module-child-specification)
Thank you for your answer - i had another person also pointing me towards the supervisor documentation. Your code example was super helpful already, but on top of that i also saw the `Supervisor.child_spec/2` function (see [here-ish](https://hexdocs.pm/elixir/Supervisor.html#module-child_spec-1)). It allows one to slightly modify existing childspecs. In the end my child definition would look something like this: ``` children = [ Supervisor.child_spec(Task, start: {Task, :start_link, [KVServer, :accept, [4040]]}) ] ```
It looks great. I was going to roll my own passwordless authentication for a side project but I'm going to use Veil instead
Child specs are just maps so you can build them up yourself, too. The function you found is a convenient wrapper to do that.
Should elaborate a little more on the github readme. Sounds interesting 
The hex docs go pretty in detail but perhaps I will ass a short summary to the github.
I think it depends on how much prior experience you have with web apps and how well you deal with conflict. I'm in the same boat as you and I started by spending a little bit of time glancing https://elixir-lang.org/getting-started/introduction.html. Not in depth reading, but just skimming and jumping around on topics that look either completely foreign to me, or in need of review. Then I just got a hello world Phoenix app up and running and started writing my app. I haven't gotten to the data layer yet, but with very little friction I have a bunch of custom routes, templates and views using various patterns taken from Phoenix's docs. My thought process is, being able to see the web app take form is motivating, and I need to learn how to do the front-end aspect of a Phoenix app no matter what. Next up is to start reviewing user authentication packages and get a handle on ecto (going to read the docs and look at as many examples as I can). I just wish the Programming Phoenix 1.3 book was already out but Amazon says April 25th 2018. That is the only book I think I'd read. Mainly because it's written by the creators of Elixir / Phoenix, so it should be filled with a bunch of best practices.
I really enjoyed the Little Elixir and OTP guide book by Benjamin Tan Wei Hao. As an entry point its great because it shows what's special about elixir. https://www.amazon.com/Little-Elixir-OTP-Guidebook/dp/1633430111 However, if you are coming from rails world and just want to dive into making a phoenix app, that could be a n easier approach. Ive been building a recipe website over past month or so and it's taught me a lot too. I'm using almost none of the OTP stuff I learned to make Phoenix apps btw.
I read one of the recommended books. I felt that it gave me a better overall understanding than what I could get anywhere on the internet
If you like screencasts I've been working on https://elixircasts.io
Let's say you did not understand a whole field (chemestry for example). Quora and google makes you search, search, post messages and wait a long time for a reply to give you a short text. Quora and google makes you read a ton of things. All by yourself. At the end of the week you did only a little bit of progress. This is long, lonely and painful. This program makes you call immediatly with skilled HUMANS. You just sit, relax and enjoy talking to them and will be dedicated to you to make you master the field. isn't it right ?
Fleet Management System. Previously written in Django, started moving it piece by piece to Phoenix. So far the progress is like, i) Moved in the front-end app (previously written in create react app and served separately, into the asset pipeline, it was surprisingly straight-forward) ii) I had to keep the Django auth, so the authentication database is there, Guardian knows about it now. iii) Refactored a major portion of the backend API (REST; sans Reporting).
What if I need to login on a computer where I don’t have access to my email?
The difference is going to be in the foundations and not in the framework/packages. My suggestion: get Programming Phoenix (or something similar) to get acquainted with Ecto and Plug. Use Elixir in Action to learn more about Elixir and OTP. Programming Elixir is also a great book but my colleagues preferred the pace in Elixir in Action.
Most companies are still in the 'learning' phase with elixir/phoenix and including it in their tech stack. A lot of companies are looking for ruby/rails devs first, with a willingness to learn.
Cool. I think I'll email some companies re: if such an arrangement (train first) would be possible if I pass their hiring process. When I read Elixir before I tried to make my Ruby code look like it hehe. How does the front-end play into this? Should I consider Phoenix apps to be a lot like traditional Rails, or are they more like API backends?
Thank you. When you say foundations, do you mean like coding in a functional style, or like the foundations of web development/programming in general? (I'm guessing both hehe.) Also am I naive to think that we can't marry object-oriented/functional styles? Something like instead of maintaining state, just create a new instance of the object (ex: `employee.change_salary(50)`) just create a new `Employee` with a different salary.
Whoa, it's like Railscasts but for Elixir? Hehe. What programs/microphone do you use for recording?
I meant the functional foundation. I assume you already have the web foundation because of your Ruby/Rails experience... that just carries over to Phoenix. Regarding OO/FP, that works at a basic level, but it is just scratching the surface. Pattern matching, protocols, Ecto schemas/changesets add more depth to it. I would say it is ultimately simpler than OO but you need to get acquainted with it regardless.
I am looking for an Elixir developer, and I will be satisfied with a skilled developer willing to learn Elixir.
The token is stored in a cookie yes, although this is all handled by Phoenix rather than Veil. Phoenix includes built in defences against CSRF attacks, but it's not something that my library adds to at all.
Hi, I'm the founder of Gigalixir. I agree that it really sucks we don't support Windows at the moment. It was a tough decision for us to detect and reject Windows, but we did it because many of the commands don't work on Windows despite being written in Python. For example, gigalixir observer needs to set up ssh tunnels, modify iptables or pfctl rules, check used ports, etc. Also, almost all commands use netrc for authentication and that doesn't work great on Windows. We definitely plan to add Windows support one day, but just not sure when.
Thanks you!
This is awesome man. I just have a few things to do but I'll be taking a few weeks to learn Elixir. Currently reading all your entries :)
Another interesting question (I think): regarding the pool of Elixir/Phoenix devs - will this market be "flooded"/saturated with ex-Ruby/Rails devs converting to Elixir, or there still will be a place for "others", such as e.g. C++ devs willing to jump in?
Unless, you know, they have implemented password reset it in a sane way which requires more than simply "something you may or may not legitimately have access to" as they key to the castle. So yeah, I guess if the bar for security is inches off the ground to begin with, you may as we ll make it just a lil lower. 
I appreciate it. Don't be a stranger on elixir slack if you need anything.
You can achieve a much smaller image using distillery releases from a vanilla alpine base image.
Learn OTP. Without OTP you'll be developer doing Ruby with Elixir syntax. 
 is not only a new language, but it's also very different than the current mainstream ones, because it’s based on another paradigm: not “object-oriented” but ”functional” instead. This means you’ll need to write code in much different way that before. As Jose Valim say: “It looks like Ruby, but it’s not Ruby at all”. The documentation it's ok but very limited, so I would recommend going straight to the books. Luckily there are already several great books published. This is my *ordered* recommended list of books you should read to learn Elixir. *1st. [Learn Functional Programming with Elixir (by Ulisses Almeida)](https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir)* This first book is a great introduction of both Elixir and the functional paradigm. While does not covers all of what Elixir can do, it gives you enough base knowledge to start and not be surprised by the weird/awesome parts of the language (like the fact that “=” is now pattern matching, not assignment and the consequences of that). *2nd. [Programming Phoenix (by Chris McCord)](https://pragprog.com/book/phoenix/programming-phoenix)* Eager to do web programming in Elixir? This book will introduce you to the Phoenix Framework (http://phoenixframework.org), by its creator himself. If you’re not in hurry you might want to just skim it and return to it later. Sadly, this book it’s about Phoenix 1.0, and currently the framework it’s in a trasition period. The new Phoenix 1.3 make some changes, specially to the structure of a new project and the philosophy behind it. But don’t worry, the new version mantains (almost) backwards compatibility, so you can still use the commands and code from the book without problem. The [new book](https://pragprog.com/book/phoenix13/programming-phoenix-1-3) is due in June if you really want to wait for it. *3rd. [What’s new in Ecto 2.1 (by the Plataformatec team)](http://blog.plataformatec.com.br/wp-content/uploads/2016/12/whats-new-in-ecto-2-0-1.pdf)* What’s this? A changelog? Not really… ok, maybe, but is also a book about the de-facto ORM (actually, just “RM”) of the Elixir ecosystem and one of the biggest component of Phoenix. The changes in this second version of Ecto are so big — Phoenix 1.3 has changed as well because of it — that this book paint an almost complete picture of what Ecto can do. Is not an introduction though, you should first read either its [documentation](https://hexdocs.pm/ecto/Ecto.html) or the chapter about in the Phoenix book. *4th. [Programming Elixir ≥ 1.6 (by Dave Thomas)](https://pragprog.com/book/elixir16/programming-elixir-1-6)* Last, but not least, this is a in-deep and wide introduction to Elixir. From the basis to the most advanced concepts like OTP and macros. When you get ready to *really* know the language, this’ll be the book for you. If the name of the author sounds familiar, it might be because he co-authored the amazing “The Pragmatic Programmer” and many Ruby books… He also runs The Pragmatic Bookshelf publishing company.
Another question: I'm still new enough to Elixir where I'm still in the common package discovery phase. Can you please explain why you chose Swoosh over Bamboo? I only because I've seen Bamboo mentioned a bit more on Phoenix's site and it seems popular in some open source projects I've been looking at.
Something like this? :) https://github.com/felix-d/dockelixir/blob/master/chat/Dockerfile
It’s a very young language but growing all the time. I decided to really try it out about a year ago and I’ll never go back to Node, Laravel, etc. Beautiful language that is very easy to follow. Compiles to Erlang so you get a rock solid base with incredible uptime and concurrency. Testing is a first class citizen and already built in. Ecto is a great ORM. Combine with OTP and ETS and you have all the data layers you will ever need. Phoenix framework makes writing Rest APIs very easy especially concerning websockets. I’d write more but that’s about my typing limit on mobile. Keep at it you’ll grow to love it. 
I was a big fan of how fast I could build applications with Ruby on Rails but it can be a lot of work to make a ROR project into a scalable solution and can be bug prone so you have to write lots of tests. Elixir with Phoenix is just as fast to develop with and scales like nobody's business. Also, it is functional so writing tests is a lot easier and since it is compiled you catch a lot of errors at compile time rather than at runtime. It has a lot of really cool features, but one in particular is the ability to do hot upgrades...there is a video floating around out there on the internet somewhere...where a guy is flying a drone which is running Elixir software and he pushes up new code to the drone and it keeps flying without any issue all while hot swapping to the new code.
Because Erlang is a god-tier language, and Elixir runs on the erlang vm with nice syntax (I was about to say nicer, but I also like erlang syntax a lot). It eliminates the need for a lot of common third party tools like redis, separate tooling to run asyc code, software supervision tools, clustering tools, software monitoring tools, and perhaps even message broker tools. All of this is built into something called OTP which comes with erlang, and also with elixir. Also really really nice pattern matching, and the functional programming aspect is great too. Although it's not as strongly typed as say Scala, it's tons better than something like Python. Elixir/Erlang has dialyzer which is a tool to help with finding bugs early, also elixir typespecs are very handy (you can add types to certain parts of your code for extra security). 
Mix is such a beautiful build tool. Simple, light and just an all around pleasure to use. Hex is a great package manager. Easy to document code and generate documentation. Pattern matching is so very powerful and eliminates a lot of icky conditional code. Just to name a few that *haven't* been named. 
Nice 👍 do you get better caching by separating the node stage from the distillery stage? Or is it just for modularity?
Can you share why they are transitioning off Scala? 
I really like how BEAM (the Erlang virtual machine) is designed to power long-running fault-tolerant scalable software systems. I've elaborated in more details in [this talk](https://www.youtube.com/watch?v=pO4_Wlq8JeI). There are many other great properties, such as OTP, functional programming, additional Elixir features and tooling, the ecosystem, and so on, but I personally feel that BEAM is the thing which really sets apart Erlang, Elixir, LFE, and other BEAM facing languages, from the rest.
To me, elixir is a pleasant syntax that allowed me to use the BEAM (the Erlang VM) and OTP (Open Telecom Platform).
The end image will not contain the source nor the artifacts used to built the container this way, only the final build. The first two stages are only used to build the final image.
Honestly I didn’t put much thought into it. Swoosh was the first one I came across and seemed to work for me so I went with it. Haven’t used Bamboo but I expect it works equally well. If anyone is better acquainted with the pros and cons then I’d be open to their input.
IO is Erlang/Elixir's forte, not computation so I don't see Elixir gaining traction in the crypto domain.
Thanks. Yep, both use `render_existing`. It's interesting to see how different the usability is between both set ups, even while using the same underlying Phoenix features. I wonder if Ryan's `yield` function will ever make its way into Phoenix officially because it does seem like maybe it's as good as it gets for doing this type of thing with Phoenix? Or at the very least, it definitely would have saved me hours of tinkering around if something like that example were included in the docs.
`render_existing` is definitely the answer to this question and we have have docs here with examples: https://github.com/phoenixframework/phoenix/blob/8acf61aeb6f11fd81fa1681bf12621bd3781f079/lib/phoenix/view.ex#L203-L251 If the docs could have been improved to save you time with your issue, please let me know. 
Thanks for the reply Chris. From an newcomer's perspective, there's 2 concerns with the current docs: 1. If I navigate to the Views or Templates section of the docs, `render_existing` is not mentioned in either section. It's also not something that came up in any Google searches. 2. The example included in the docs you linked uses the "create many individual templates" approach which immediately makes you think there might be another way to do it because that's going to quickly get out of hand with the use case described in my above post. It would be awesome if there were a little section added to the Templates section that just covered an example use case and demonstrates using `render_existing` and a custom helper function to do what Ryan did in his blog post (creating a `yield` helper). It now doubles as a concrete example for a very popular use case and touches on view helpers too.
To be clear, a "template" in your writeup is just a function, so you don't need to create a bunch of eex files, only define `render` functions in the view modules that want to populate this data. In this case I don't see what `yield` buys other than indirection or familiarity with Rails :)
It's not my write up btw. It's something I managed to find Googling. Here's my Elixir beginner's thought process: **Ryan's yield approach** * I only need to define some function once in a layout helper and it even lets me set a default. * Using it feels natural in the app.html.eex file, such as `&lt;%= yield("title", assigns, "My App") %&gt;`. * When it comes down to populating its value, it's as close to the templates as possible (views). I still don't know the "real" purpose of a view, but it's looking to be some way to control rendering output, whether or not they are from templates is up to you (the app developer). **Your doc's approach** I don't even know where to begin to accomplish my goal without making a bunch of individual extra eex files for each page. Would you be willing to provide a gist or an example showing how all of this comes together using your method, where I'm not stuck creating a lot of eex files?
I like scala too, but I have to acknowledge that elixir is a very well designed language. I'm not sure I've ever been as productive in a language as I have been in elixir lately, throwing together reasonable projects with ease. It has enough of a compilation phase to catch obvious errors which makes it a ton easier to debug than other dynamic languages. Concurrency out of the box is stellar. And while I certainly wouldn't use it for hardware drivers or games, even its speed is pretty decent. Good enough to throw together ad hoc scripts to calculate metrics and so forth. It's standard library is exactly right. The code looks great and is easy to modify. The code reloading while I'm developing is just so useful. If I were to start a business I think there's a high likelihood I would commit to elixir as a primary language.
&gt; Maybe I'm missing a bigger point about mobile development... It should consume data agnostically from an API of some sort. Most people would implement something that is a RESTful HTTP API, I think. Then phoenix/elixir is just an implementation choice to build your API. You could do it in anything and it'd all be the same to the mobile app.
Most reasons for why I really like Elixir come directly from Erlang, OTP and the BEAM. It's just an amazing platform to build distributed systems. Language wise I'm not such a fan of Elixir, as I'd rather have a statically typed ML language on the BEAM. But Elixir makes up for the (IMHO) language deficits in tooling and community.
Elixir also compiles to bytecode, and also requires a VM to be installed on the host (or bundled with a release) to run, so they're similar in that regard. There are a few reasons why I'd choose Elixir over Scala for a new project - learning curve, faster edit/test cycles, enforced immutability, consistent idioms, and many other reasons listed in this thread. But to transition from Scala to Elixir sounds like there was some problems encountered with Scala which I'm curious to hear about.
Watch this keynote, it is one of my favorites, it captures just one of the reasons you are looking for: https://youtu.be/5hDVftaPQwY
If I were to take a guess, it would have to do with Scala's slow compile times (maybe?). Scala's type system is nice at times, and it provides a lot of neat stuff like implicit conversions but a lot of that need stuff really bogs down the language's speed and makes the language almost overwhelming at times. Not to mention - No out-of-the-box concurrency model - Types can get *really* messy - You're going to be using some Java libraries along with Scala libraries at the same time for bigger projects, there's no real way to avoid it (even though the idea of Scala is to be more powerful Java) - There's a *"standard"* way of doing some things in Scala, but not really If anything they could be switching because of *all* the caveats of Scala. Not that Scala is bad, but right now it's not all that cracked up sometimes. 
There was an excellent Clojure conference talk a few years ago about a gentleman who made furniture with hand tools. Bench saws, chisels, the works. If I'm remembering the thesis of the talk appropriately, his view was that by having small reliable tools, the combination of all of them would allow him to produce higher quality furniture than anything that comes off of a machine. He also felt that not having rapidly spinning metal ready to cut his arm off, but that's not particularly relevant for this point. A tertiary impact is doing this kind of furniture building, one eventually creates a workbench that allows the builder to more easily do the jobs they need to, after learning what things they need. A proper workbench would have conveniently placed clamps, e.g. to hold boards of various shapes and sizes, because it's built generally to aid the work in the future. Though he spoke of Clojure, the same things are true with Elixir, and many languages with Lisp-style macros and functional flavors. You have a small core of very strong utilities that allow you, in combination with each other, to create really complex machines with very few building blocks. For the workbench analogy, macros allow you to express your solutions in the language of your problem, by hiding unnecessary syntax where it doesn't need to be. It really feels like a language that is built by craftsmen to do proper build craft. One where very seasoned developers sanded down the corners properly across the board and built a very forward thinking tool that's a pleasure to use. Where I feel Elixir stands out from Lisps in particular is accessibility to new developers. The Ruby looking syntax is VERY easy to read, even if you're unfamiliar with Ruby, and the explicit nature of the language means that someone coming into a code base has very little if any magic to conceptualize. Don't know what something does? Just find the place where it's defined and read the code, or check the HexDocs. At the same time, that syntax is superficial and the underlying methodology is highly derived from that of Erlang (with a little Lisp, without being a full blown Lisp), which is itself an extremely mature platform with decades of development under its belt. Elixir is also defined for the most part within itself (using macros, generally), which means that you can just read the code and figure out what's happening (see e.g. `kernel.ex`). I love this property of languages, and it shows you cannot be held captive by Jose and the core team refusing to add your favorite feature. You can make it appear seamlessly alongside language constructs like `if`and `defmodule`. See Guy Steele's famous Growing A Language talk. Tooling wise, Elixir is very modern with good build tools, package managers, etc. and a smaller (though often extremely high quality), but growing and improving library scene. There are some gotchas around releases, and how to deploy in e.g. Docker in production, though they're working on making these easier. As far as type systems go, Dialyzer is the one in use by Erlang. The error messages are awful and Erlang-ey though there is work being done to fix this. It's often good, but it is one-sided errored so it can miss things. There are ways to program to make it more easily able to determine things, but you have to get a feel for the tool to really get a good sense of that. The supervision model is really an excellent way of reasoning about complex software, and although as with any system there are gotchas (see Erlang in Anger), it allows you to get really reliable software with very easy to predict latency numbers. Finally we get to performance. Thinking futurewise, we can expand number of cores way more easily than we can speed of a single core, and we can way more easily just get more machines. The supervision model allows you to map your solution very well to your topology, if your problem is the right use case for that kind of thing. It's very fast on single machines (I sometimes get responses with a unit of microseconds), and the Erlang VM has very strong primitives for reasoning about your network topology at a high level and predicting failure at development time. This is awesome because it means your software can be easily adapted to changing demands. Finally it's just a pleasure to work with. I love hacking on things with it, and code golfing is a dream. Refactoring is cut/pasting often and changing a few call sites to point to the new place. The community is awesome, the core team of the language and its more famous tools are all really open to contributions from newcomers and veterans alike. I really love Elixir and I'm happy I chose to learn it, and am thankful I get to use it in my day job.
Here's my perspective as someone that's only been professionally developing for ~3 years as a Python / Django + JS / React &amp; 7 months using Phoenix -- The first thing I noticed coming from Python / JavaScript ecosystem is the amount of thoughtfulness the core developers have towards developer UX -- Right out of the box, you're given a toolchain for: 1. Dependency Management via Mix. It just Works. library that you just forked onto github? Works. Just want to install the latest version? yes ma'am. You don't realize how good a tool is until you've used other ones that don't _always_ work. won't name names here :D 2. Code generation via Mix (Coming from the Django world, this was a mind-blowing thing, I know the rails framework does this too). For example mix command: mix phx.gen.json Accounts User users name:string email:string Will generate your controllers, schema, context layer, tests, and helper documentation to push you in the right direction for how to do things the *sane* way. As someone writing REST API's this has saved me countless developer hours. 3. Pattern Matching, a feature of Elixir: I found that pattern matching has allowed me to write very precise definitions for when things should and shouldn't happen. For example, it's very easy to write something like: "run this function if the user is authenticated, and who's permission level is of admin, otherwise this function here will catch everything else and throw an exception". Coming from an imperative language background, it's really changed the way I think about composing behavior. 4. Like others have mentioned: Supervisors, OTP / GenServer / GenStage, ETS. Right now, it probably sounds like a bunch of tech-fancy-wizardry -- but these are abstractions that programmers much smarter than most of us have devised to make our lives much simpler to reason about difficult problems -- I swear this isn't all koolaid! Lastly, the Elixir community, especially on slack has been great. I've asked plenty of beginner questions on slack and have had Chris McCord himself help me out. Just a good feeling to know that the core developers of the language are willing to help little nubbies like me out :)
Fully agree! I've come over from Rails like many others and even after two days I know I'll be sticking around for a long time. Add to the above the great benefits you receive by embracing functional programming, and I really don't think you can go wrong.
Incredible! Gonna need that video!
&gt; It eliminates the need for a lot of common third party tools like redis, separate tooling to run asyc code, software supervision tools, clustering tools, software monitoring tools, and perhaps even message broker tools. All of this is built into something called OTP which comes with erlang, and also with elixir. This is one of the hardest aspects of Elixir/Erlang/OTP for me to grasp. I just cannot accept how it makes all these other fancy technologies obsolete. I'll still research plenty about the limitations of native OTP abilities vs more dedicated options (RabbitMQ for e.g.), but it seems like you get a tonne for free out of the box.
An amazing app? Nope.. I'm working on my first boring business-oriented application (Kube/Elixir/Phoenix) to help me escape the clutches of contracting so I can work on my own stuff full-time. Moving over from Rails and having lots of fun!
The JVM is an amazing piece of engineering. In many many ways better than BEAM. (Yes, BEAM does some things that JVM does not) Complain about the Java language all you want, I'm not going to argument too much.
Erm, thanks! But you sure it was me you saw in HN? Because i) I am an HN shy person, and ii) If I have to say something about anything JS, it won't be pleasant, and you'd remember me with anger ;)
Hmm.. maybe not. It was someone who converted a Fleet Management System from Django to React and Phoenix haha helluva coincidence if it isn't you!
[removed]
There aren't many Elixir jobs out there, so I wouldn't recommend picking up the language with the intention of finding work. As for how to get an Elixir job. Most places I'd assume would be transitioning over to Elixir/may not even be using Elixir exclusively. So aside from knowing Elixir (and OTP), you'll probably need to be familiar with whatever their original stack is. As for myself, I've had no luck with any Elixir jobs. Not that there was a massive pool to apply to anyway. But I got rejected (not even an interview) from all the ones I did apply to. Funnily enough I heard from some of them that they were starting to become desperate for Elixir devs, and were willing to hire people who were keen to learn the language. But rejected again when I applied to them again lol. So yeh I'm not really sure what's required to qualify for a job in Elixir, other than the general assumptions. But since the sample size was so small it could've also been simply not meeting organisational wide requirements, or some other skillset desired, rather than not having enough experience in Elixir. 
Wow. I'm using React (Mobx State Tree) alright. You're right on the coincidence part, helluva coincidence indeed! Anyways, I'm thinking about writing about it, maybe on how to make a small subset?
Regarding OOP like code. Yes, you could pass in the current state, and some value and return the new state. I wouldn't consider that code very OOP-like however. Another option if you want a shared single reference to the same state is to use a process that manages its state, and any actions send messages to that process to update its internal state accordingly. 
As a complete docker and postgres noob I've spent some hours today trying to achieve this to no avail. And your solution works perfectly! Thank you! 
Any comments for "Functional Web Development with Elixir, OTP, and Phoenix" by Lance Halvorsen? Just started reading it, seems quite interesting. For someone with FP background and Erlang familiarity.
&gt; This is a little confusing because technically we could have wrapped the user controllers, views and templates into the accounts/ namespace but we didn't. I think, in the context of being a tutorial, it made sense to introduce the generator without the `--web` option first, to help understand the basic generator behavior. If there is only one way for end-users to modify the underlying User model via the web, you don't even have to namespace the controller, necessarily. Otherwise, you certainly could have used the `--web` option in the first case and ended up with `hello_web/controllers/accounts/user_controller.ex`. &gt; Should we always wrap all web related resources and pages into the context's folder as a best practice? I don't think this is a hard-and-fast rule, by any means. If you follow that pattern to its logical conclusion, every controller action becomes a super-thin layer - basically a one-line call from the web layer down into your application. Structuring the shape of your underlying application just to conform to the user's endpoints is doable and may be helpful for locating the relevant files, but you will find it to be constraining, resulting in a lot of repetitive setup code that could have been done ahead of time, in the controller or Plug pipeline (e.g. fetching and authorizing the current user). &gt; Also when it comes to defining route "as" paths, should you use the context name or not? For example would you use accounts_session_new or session_new? Routes are a web concern, not an application concern. So, if your controllers are namespaced, use the namespaced route helpers. In the end, modules are just bags of functions. Module namespacing is more of a convenience and a mental model, and as your application grows, that model may shift! Renaming and moving modules is pretty easy, so don't be afraid to "stick it somewhere" with the ability to move it later.
So, funny you should mention that, I actually use that exact folder structuring. I just skip generators entirely and in `my_app_web.ex` changed the injected view module helper so that `Phoenix.View` could find the templates at compile-time use Phoenix.View, root: "lib/rhr_web/#{ Regex.replace( ~r/View$/, __MODULE__ |&gt; Module.split() |&gt; Enum.slice(1..-1) |&gt; Enum.join("."), "" ) |&gt; Macro.underscore() }/templates", path: "", namespace: RHRWeb
Thanks for sharing that. And for clarity, do you then have a user/ folder inside of your templates using the above example? I think part of the value of using a framework is sticking to conventions, so I have to wonder if we're going down a bad path to do it this way long term since it's against the grain. But honestly, I care more about productivity and being happy, and having to do those 7 steps just to change a context name makes me unhappy. At the same time, having 35 controllers sitting in 1 folder also makes me unhappy, so something needs to be done in the short term.
No, I just have the `.eex` files directly under `templates/` since it's already nested under the controller. [Like this.](https://imgur.com/uFA5QEE) &gt; I think part of the value of using a framework is sticking to conventions, so I have to wonder if we're going down a bad path to do it this way long term since it's against the grain. That's a fair point. Take solace in the fact that the above change is at least *explicit* - it's a documented option that can only be overridden in one place, not some monkey-patched behavior that changes the whole application behind your back.
Ah I see, so you went as far as making "user" its own folder using the above example, so accounts/user/user_controller.ex instead of accounts/user_controller.ex. Yep, that's true about it being documented. I wonder if Chris or Jose have any plans to revisit the default _web folder directories, especially in relation to contexts.
Yeah, I've found that singular names everywhere works pretty well. It really helps locating code when you have non-standard pluralizations (like country -&gt; countries, or child -&gt; children). In this case, since the controllers are for a user managing their own account, the singular especially made sense (thinking of it like MyAccount).
of course RabbitMQ run on erlang to start off with.
Haven’t read it, but it looks good and it covers Phoenix 1.3 so it could be even a better introduction to it than the Phoenix book
As far as I understand by reading the “What’s new in Ecto 2.1”, the contexts are intended to be a way to deal with the problems of fat models. When in Python or Ruby you would use Mixin classes to separate some model fields and related business logic, in Elixir you can use contexts for that.
Yes, but the generators and official documentation on contexts have conflicting information when it comes to namespacing things in the _web folder. That's where the confusion lies.
Don’t build anything custom with GenServers for this. Phoenix already has the concept of a session, which is already doing exactly what you want it to. You can read more about it here: http://phoenixframework.org/blog/sessions
Is it ok that I still use the request id to name each GenServer?, I changed what I previously had for the sessions approach, thanks.
Mentions addict but if you are looking for an alternative that is just as easy to use please check out my library AccessPass and let me know what you think https://github.com/jpiepkow/accesspass
That is also pretty cool, I like it! 
Wow I'm surprised it works. [The docs](https://hexdocs.pm/elixir/GenServer.html#module-name-registration) suggest that GenServer names should be atoms when registering locally, but can be other terms when using `global` or via-tuples. TIL
The example stores the user_id in the session. Isn't it preferable to store an opaque session token, and associate it with a user_id in the database? That way a user can see and expire all their sessions from an admin page or when they change their password. 
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[Functional puzzles (Javascript, Elixir, Clojure)](https://www.reddit.com/r/Clojure/comments/7ym2d2/functional_puzzles_javascript_elixir_clojure/)|/r/Clojure|/u/orestis|2018-02-19 19:38:07|1| |[Functional puzzles (Javascript, Elixir, Clojure)](https://www.reddit.com/r/programming/comments/7ylvn3/functional_puzzles_javascript_elixir_clojure/)|/r/programming|/u/orestis|2018-02-19 18:54:42|0| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=orestis)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=elixir) Now you can remove the comment by replying delete! (op only) 
this looks interesting, I might give it a try. My experience, coming from rails / django is that phoenix lacks of good user management libraries for both API / traditional website.
Nono, the ID is a string but I’m using the Registry module using via tuples. 
I think their are a couple good library in elixir like addict or ueberauth. Just none of them were quite right for what I wanted/needed.
I just wish for something like Devise for rails
No, you should not use the Request ID. It is in _no_ way related to the actual session or user. It's effectively a random UUID that is relevant to that single request _only_. As I said before, I don't believe you need to be using GenServers at all. You're overcomplicating keeping session state
Nice! Thanks!!!
I'm still new to elixir and functional programming, but I'm curious if it's not slightly better to do: defmodule Santa do def santa(instructions) do instructions |&gt; String.codepoints |&gt; Enum.reduce(fn("(", acc) -&gt; 1 + acc (")", acc) -&gt; 1 + acc (x, acc) -&gt; acc end) end end 
Interesting idea. I think I’d rather be explicit in the two-stage computation, but I don’t have a better argument other than “it feels better”. 
Mox is per process. Once you do a HTTP request, you are using another process. You probably just need to call `setup :set_mox_from_context` and make sure your tests are not async. The docs have more information: https://hexdocs.pm/mox/Mox.html#module-multi-process-collaboration
aha. that's very confusing =( I basically solved it by redoing the mock as an module wrapping an on-the-fly generated agent (defined in test-helper) and setting the tests to be async...
You're right.
What's this have to do with Elixir?
Really great article, clean and to the point. Thank you!
As I've mentioned in the article there is a room for improvement. That could be one of those improvements. The authentication topic is quite broad and probably cannot be covered by a single article. 
I've mentioned "Addict" only as an example, I'm pretty sure there are more than one libraries. I wanted to show how does it work inside instead of using any particular library. I think it is also important to understand the internals. I will take a look at your library =)
Thanks very much! Small typo: the "s" was left off the end of the URL link to seeds.exs
Quite true! I thought about, but I opted to show the list destructuring syntax instead. I believe that people new to Elixir will be even more confused when seeing the binary syntax destructuring, but have no data to back it up.
I think it would be harder to explain what "codepoint" is than explaining binary pattern matching to total newbie.
Without the redirect and trackers... https://www.erlang-solutions.com/blog/fips-for-erlang-elixir-systems.html
After installing piHole there's a lot of links that take me nowhere these days.
In case anyone else has shitty eyes like me: .blog-page p { font-size: 16px; color: black; font-weight: 400; } makes it a lot more legible
**Reported for referral link spam across multiple accounts.** https://www.reddit.com/user/UnkindTaborp/submitted/ https://www.reddit.com/user/UnkindTabora/submitted/ https://www.reddit.com/user/UnkindTaboro/submitted/ https://www.reddit.com/user/unkindtabori/submitted/ https://www.reddit.com/user/unkindtabors/submitted/ https://www.reddit.com/user/UnkindTabory/submitted/ https://www.reddit.com/user/UnkindTabore/submitted/ https://www.reddit.com/user/fegertsa/submitted/ https://www.reddit.com/user/trukirukia/submitted/ https://www.reddit.com/user/buyuksd/submitted/ https://twitter.com/nerd2techdeals/ name changed to https://twitter.com/techdealsandmor https://twitter.com/give2emsome name changed to https://twitter.com/give3emsome https://twitter.com/GeekDailyDeal
Sweet, thanks!
Actually all of them were great. Sarah Grays closing keynote was so good. Emma Cunningham's opening keynote was very interesting. Loved the part about linguistics in there. Will Ockleman's ant foraging was an awesome way to showcase OTP behaviors. Andrew Hao and Geoffrey lessel were very interesting. I don't think there was a boring talk. I don't use ecto so that one was less pertinent to me but they are all worth a view. 
1 thing that I might suggest is keeping the count of the lists in a module attribute so it is executed at compile time. Right now, the Enum.count is going to be O(N) on the fairly large lists. 
I'm glad I'm not the only one that gets annoyed by this.
Yup, I went back to this post and the `'hello'` is different from `"hello"` has burned me like 3 times. :)
That's a good idea and quite useful to have. I will be happy to have a PR or something I can do later.
Find more here - https://hackr.io/tutorials/learn-elixir 
I've been reading the code of `Raxx.Static` and `Raxx.MethodOverride` and I'm having a hard time figuring out how middlewares are supposed to work with Raxx. It seems like there's a bunch of macros and so far it's going over my head. Can someone point me to a good primer on the macro stuff used for middlewares (I think it works with `defoverridable`). I'd also like to understand how a request will "flow" through the middlewares to finally hit a handler.
&gt; Plug is not idiomatic Elixir I'd rather see some side-by-side comparisons of where a particular task was accomplished with less code/more clarity in Raxx than Plug. The complaints I see about Plug are that you can't transform a response as easily as you can a request, leading to the asymmetric API, and that since send_resp is a side effect, you can't always be sure that a response was actually sent - leading to runtime errors. 
There is no way to middleware are "supposed" to work. `defoverridable` is just a tool that will allow you to wrap functionality of a function. It's used by most behaviours https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/gen_server.ex#L647 I'm sure patterns will emerge but it has been a deliberate choice not to enforce a pattern so far due to the variety of concerns when handling streaming.
How is that idomatic Elixir: defmodule MyApp do use Raxx.Server def handle_request(_request, _state) do response(:ok) end end The call of `response` takes neither `_request` nor `_state`; hence it must refer to some unnamed state, which presumably depends on the `_request`. Does `response` actually write the response to the socket? That would make it difficult to test. Or does `response` create a result object which the caller of `handle_request` interprets accordingly? In that case I'm wondering why a function call is necessary and a simple `:ok` insufficient. Further, what are the contents of `_state`? How is different from what is available in `_request`? The post says, each requests gets its own `Raxx.Server` (how can that be efficient?), so where does `_state` come from? As a last note, I would have liked to see an answer to the question raised in the subtitle.
[removed]
Site is not working.
This is one of my favorite features of Elixir. If anyone wants to see a real-world example, my [zipper_list](https://github.com/bbugh/zipper_list/blob/master/lib/zipper_list.ex) library uses it extensively. Here's an example: https://github.com/bbugh/zipper_list/blob/master/lib/zipper_list.ex#L199
This might be useful https://stackoverflow.com/questions/97508/what-libraries-can-i-use-to-build-a-gui-with-erlang Minus the java stuff. 
It would be interesting to use Elixir perhaps. But you might consider trying F# for this since it already has really excellent support for desktop UIs including native Mac bindings (Xamarin.Mac), GTK bindings for Linux (GTK#), WPF on Windows. There is also Xamarin.Forms, which began as a cross-platform toolkit for iOS/Android/Windows Phone but it has expanded to support Xamarin.Mac and GTK#. I've used it quite a lot for mobile but have not yet used it for desktop. IMO it is one of the best designed UI toolkits for cross-platform development because it makes it very easy to get down into the platform-specific APIs, while most cross-platform UI toolkits try to hide you from that layer so you're stuck using their least common denominator APIs. You can also build things with F# in an Elm architecture (what F# devs are now calling Elmish). Here's a small library for using Xamarin.Forms using Elmish: https://github.com/dsyme/Elmish.XamarinForms 
Does anybody who writes Java enjoy writing it, or are they just doing it for a pay check? One of the things that attracts me to Elixir is that Jose seems like a down earth guy who started something because has a passion for what he is doing. Could you say the same about the people who work with JAVA on daily basis?
I enjoy being productive. I'm not a fan of being too tricky. I like my code to be complex only when the problem domain is complex. Java is simple to the point of being plodding a lot of the time, and it's certainly suffers from many historical tradeoffs (e.g. primitive types ). I consider java trusty tool, but certainly not sexy. In the last 2 years or so the ecosystem is starting to see some acceleration in terms of useful new features (co-routines in VM, value types) being worked on, but again the historical stuff and emphasis on backwards compatibility will mean those may not be graceful. Regardless, my point was only that separating the JVM from the java language is important. The JVM has gobs of languages that run on it: https://en.wikipedia.org/wiki/List_of_JVM_languages 
Here is one: * Raxx.Logger: https://github.com/CrowdHailer/raxx/blob/master/lib/raxx/logger.ex * Plug.Logger: https://github.com/elixir-plug/plug/blob/master/lib/plug/logger.ex Honestly, the Raxx one doesn't feel like idiomatic Elixir at all. It is abusing `super` to mirror something like inheritance chains, it uses the process dictionary, and it overly relies on macros. And what would happen if a module that uses Raxx.Logger implements its own handle_data and forgets to call super? Would Raxx.Logger stop working?! At least I can write plugs as simple and straight-forward functions. I value the ability to compose software much higher than I value the purity aspect of things.
I’m using it as a windows service in one product. It’s not the ideal platform but does the trick. For GUI you’ll end up with wx I think or serve HTML/JS to a browser. It depends on the app. 
It looks like Raxx expresses middlewares with mixins (hence the use of super) vs plugs function pipelines. Given that a Raxx server module implements multiple callbacks it seems like a reasonable approach. [method_override](https://github.com/CrowdHailer/raxx_method_override/blob/master/lib/raxx/method_override.ex#L101-L117) looks fairly simple, although [the plug version](https://github.com/elixir-plug/plug/blob/master/lib/plug/method_override.ex) is simpler still. The key difference looks like Raxx encourages thinking in terms of (possibly stateful) servers, not a chain of (possibly side-effecting) functions. If Raxx can provide a unified model for simple Request/Response, ServerSentEvents and WebSockets then it could be an improvement over the Plug + Phoenix Channels model.
Request/response are stateless, WebSockets are not. Trying to make them all live under the same abstraction means one of them will feel awkward. In this case, the request/response lifecycle. Most of my code is under a request/response lifecycle, I have no interest in compromising the design of those under the premise of better WebSocket/SSE compatibility. I would say the best approach would be Plug pipelines but with an option to upgrade to something stateful like Websockets dynamically. 
Can you please check now? I am able to access it.
the future
I am not sure I follow. There is nothing is common between matching on struct members values and matching on struct type.
"Quick answer to this one. No." - I see, thanks. You use a before compile callback to guarantee you always invoke it. "the purity is what makes reasoning about the whole unit, and testing it, easy for me" - Doesn't Raxx middleware use the process dictionary to pass state between callbacks? Isn't that impure? I think reducing side-effects is great but the process dictionary, before compile and defoverridable are all side-effects too. Reasoning how plugs compose is simpler because they are function calls at runtime instead of code injection at compile time.
Just got Distillery releases working for my service, next stop is automated beta deployment when pushing to master on GitLab.
I've been working on my first real Elixir project, [Midal,](https://github.com/bees/midal) a [microdata](https://www.w3.org/TR/microdata/) parser. Elixir is my first functional programming language and this felt like a problem that could be solved well with the tools a functional language gives you. I am certain I'm doing things in code that are weird/hard to read. If any of y'all have time review the code I'd love to hear your thoughts. You don't have to be nice - just give me something actionable :)
I've been working on a game where players buy and sell certain commodities and compete for a high score within a limited time. The game engine is a simple Elixir app, and I'm working on the Phoenix interface now. Obviously I'm using channels, so I can expand into multiplayer soon. I write in Ruby/JavaScript at work, so it's a real pleasure to have a fun side project in Elixir. 
That sounds really cool. Please if you ever make the code public link to it I'd really like to see how you've done it as I'm planing on doing something similar in the near future but as a text based roguelike. 
A chat app similar to discord. I'm hoping to finish it around May. 
I'm learning some elm by creating a frontend to an absinthe-graphql/phoenix app
Doing exercism problems - been meaning to write something real in Elixir for some time but have no idea what :|
I like the idea of generating some elm types from the GraphQL schema. [graphqelm](https://github.com/dillonkearns/graphqelm) looks like it supports code generation, and has a [subscriptions example](https://github.com/dillonkearns/graphqelm/blob/master/examples/src/Subscription.elm).
If Raxx makes it cumbersome to write pure middleware then it doesn't help me write pure code. If the only way to compose software in Raxx is by injecting a module that *mutates* my own module and permanently changes it, then it is not idiomatic nor pure. And because of how Raxx middleware is designed, I cannot test them in isolation either. I need to define a fake module they are injected into. And once I add logging to my module, I can no longer test it without side-effects either. On the other side, with Plug, I can define each plug in isolation and test in isolation without having a understanding of the whole context. As you said, Elixir is a pragmatic language, but when you say that Raxx is more idiomatic because of side-effects, then you are throwing away Elixir pragmatic's perspective in favor of a vague goal. Instead of productive discussions about the pros and cons of each library, you get pedantic discussions about the usage of Elixir idioms.
Keep up the good work.
I'm very new to Elixir - so take what I say with a grain of salt. I don't think it's fair to say OTP makes Redis obsolete, but at least the ways Redis gets used in Rails servers is not necessary in an OTP world. If you use Redis to implement message passing between processes then it makes sense that a language with built-in message passing would eliminate such a dependency.
True. I'm only a couple weeks in myself, but am beginning to understand the power of OTP and what it does/doesn't render obsolete. I thought at first I could skip on workers backed by Redis, but if I want durability, then I can't -- as you say, built-in messaging is what OTP provides, not persistence.
Even then it's only message passing within OTP. I'm sure many people use Redis to communicate between their web app and a separate service written in a different language than your web app.
So much nicer than with Rails.
I'm not an expert on Ecto by any means, but can it be that it doesn't know how to handle empty changesets? Maybe you can fix this specific error by filtering out changesets that are empty.
Does your database support JSON fields? If so using an embed_schema instead of an has_many association would make more sense in your use case. Especially since you delete_all and insert every time on every update.
Link to the repo: https://github.com/jpiepkow/accesspass And hex docs: https://hexdocs.pm/access_pass/introduction.html
Make a new folder for Plugs in your web directory at the same level as your controllers and put it in a new module there. Phoenix will auto-import the code and you should be able to call it in Router just fine.
That's how I store my plugs too :), I used to store them in controllers folder before and then I rearranged those.
Do the PragmaticStudio Elixir course. This was a game changer for me understanding the OTP side of things. In the course you build an HTTP server which works as a great example. Here’s a 20% off coupon they released: https://elixirforum.com/t/developing-with-elixir-pragmatic-studio/4429 Not affiliated but did the course and loved it. 
Watch this channel https://www.youtube.com/channel/UCp01DFl8kp-239gW289C0ew a couple of times. They are short and to the point. 
Only covers the basics, but this post made quite a lot click for me when starting out http://dantswain.herokuapp.com/blog/2015/01/06/storing-state-in-elixir-with-processes/
Get really irritated that you can't store dynamic state in Elixir and then scramble to learn processes, agents and genservers as a tool to get around it. The details will come as a side effect of this.
I'm about half way through this course and I can vouch for the quality albeit I haven't started the portion on OTP yet.
No, I don't believe they had any training at Lonestar Elixirconf last year, although I could be wrong.
Really good job! Keep up!
One monit change. I wouldn’t use raw `#{user.id}` in query but rather pass it as a parameter via `$1` and setting proper value in third parameter of `stream` call. 
I did it as well and it helped me a lot. The only downside for me is that if you want to go back to certain parts after the first pass the video format is a bit of a chore.
You're right, last year Lonestar had no training. This year was the first year. However, Elixirconf (the main conference) did have training.
Because they refactor the code so heavily? Or what do you mean? 
It's a bit tedious to go back to check again something in videos instead of scanning a book / article you have read earlier.
They did have a Nerves training this year at Lonestar, though 
Wut
Great writeup btw!
So what compilation issues were they having that they needed a full rebuild before every deployment?
Exadmin. Adminium on heroku
Ah thank goodness. This was my last pain point with the language. What he's doing there is exactly what I wanted to see.
I would use [Grav](https://getgrav.org).
Why does it need to be elixir? PHP pretty much has the market cornered on CMSs, and most solutions you find elsewhere won't have nearly the community supporting them that the big PHP ones do. If for some reason you need to build your own CMS, though, elixir would be a good choice.
I attended this year. I'm currently sitting in on a talk in Denver Eilxir Daze. My thoughts on Lonestar. 1. Turnout: This was great. While I did not attend last year's, it seemed that there were a good number of people. If I had to guess I would say around or over 300. Lots of friendly, smart folks and good conversations. 2. Talks: There was a theme of distributed systems -- which being an area of focus for me - was quite enjoyable. 3. Location: Meh. I live in Austin. The location on Anderson (lots of good furniture consignment though) is nothing special and I feel it makes post show socializing harder as you're not within walking distance of anything remotely interesting. 4. Training: I participated in the nerves training. I thought it was good and it did jumpstart me into nerves -- I do wish it was more hands on code wise, however. Not sure what else to include. Feel free to ask.
Will this address the need to have a Docker container for releases on other architectures? That is a problem I would like solved.
u/tacticiankerala is you could ask for some specifics I'd be happy to look over it for you. It's hard to know where you need improvement without having worked together.
How does this differ from the half dozen other solutions out there?
I just wrote a blog post which (I think) might serve as a good example: https://www.reddit.com/r/elixir/comments/81ip1i/using_genserver_in_a_production_phoenix/ (You do need some logic of how it works to understand the implementation) Good luck! :)
Sure it shares some similarities with other libraries but I believe it is the only one that offers this combination 1.token based(short lived access token, long live refresh) 2.revokable without the need to hit a database. 3.fast because it's based on ets as compared to storing access in a database. 4. Does not contain forms for login so mainly based on client API separation. 5. Opaque tokens that are really just keys for stored data
Pretty impressive
Was going to ask the same thing. 
I'm curious about the claim that Heroku limits you to 50 connections per dyno—I think they mean that the *backlog* is limited to 50 connections per dyno, but I've never run into this limit with an elixir app—it handles connections as fast as Heroku can hand them over. 
Hey! Thank you! I’m glad you enjoyed.... regarding libcluster, nope. I used a singleton paradigm to guarantee there would be only one manager running in the entire cluster. It would be interesting though to allow that to run freely and maybe control through something like libcluster
Why make another clone chat just copying code from dozens of others? You could've shown how to handle presence, disconnects or whatever. I just don't understand why bother
This is *concurrent* connections we're talking about, i.e. if you're using Phoenix Channels. We've not personally run into this issue yet, but it is documented by Heroku here: https://devcenter.heroku.com/articles/http-routing#request-concurrency
I'm using an app as an example. In order to implement the things you mention I need to implement that behavior at first. I cannot build a second floor by avoiding first. Also to cover all the possible topics would be too much for a single article. So I'm planning to cover them in the next articles. The third thing is worth to mention. I write about what did I learn. And I hope someone might find that interesting and learn something as well. If I can reach at least couple of people, that is already great. I'm sorry.
Seconded, this looks very promising. 
How much Elixir do you know?
I work with Elixir on the job everyday.
Good to hear. How is the Denver event?
Smaller. Much more social. Super fun. Venue was Ophelia's which is a bar/music venue. Fun and different. 
Man.. Keep doing what your doing. What you share is going to be valuable to someone. Don't be sorry.
Phoenix is actually not “heavy”. It is composed by a lot of plugs, meaning that you can use only the parts you need of phoenix to make it work. First you need a Phoenix Endponit, and from there you start building what you need. Also using plug you will end up writing more code which phoenix provides. Saying this, I think Plug can be your go to, or look at github for sinatra like repos. P.S. If you find something interesting, please share it
You have maru which seems to be more focused on APIs https://github.com/elixir-maru/maru
What kind of app are you trying to build? For the most part you can get pretty far with just cowboy, plug, and ecto. Although if you were needing all those 3, I'd probably just use Phoenix anyway. Another option if you don't need everything Phoenix has to offer, is you can often leave those parts out entirely. There are some other web frameworks available, but I'm not sure what kind of state they're in or how they really compare to Phoenix in this regard. Though I'd imagine they'd be somewhat similar, if you really don't need all that functionality, you probably don't need a web framework. 
Cast should also validate format, so you don't shove garbage into your DB. 
I’ve been meaning to check out Raxx: https://github.com/CrowdHailer/raxx
&gt; I'm looking for simpler and lighter ones that are actually used by others. Is this driven by some design requirement? What does "lighter" mean? In my experience, starting out with a minimalistic web framework will inevitably lead to re-creating all the tools that come for free with Phoenix - think about routing, content types, templates, middleware, persistence. `mix phx.new --no-brunch --no-ecto --no-html my_app`. It's about as minimal as you can get, and you'll instantly be productive.
To expand what OP said, the cast/1 function should make sure the tuple is 4 numbers between 0 and 255 (in case of v4) or 6 numbers between 0 and 65535 (in case of v6), but since the value comes from Plug we can expect to be a valid IP tuple, so it's not really necessary.
I really like this approach since it allows you to test compliance on a database level plus in doesn't give you root access to the database. But I haven't seen anything that uses it in Elixir. But I don't think this approach should be hard to implement.
How would you implement this ? I was thinking to initiate a process with an Ecto database connection parameters generated from the credentials given by the user but not sure how to do it, I'm still a beginner in Elixir :)
Side note: there are a lot of common ways to write the name of that database, but `PostGreSQL` isn't one of them. Usually spelled `PostgreSQL` or just `Postgre` and there is no official pronunciation. 
`Postgre`?! Oi vey. The original product name was Postgres. When SQL replaced POSTQUEL it got renamed to PostgreSQL. Postgre is a nonsensical name that I see occasionally, but have never heard or seen from people involved in the project. Postgres or PostgreSQL. source: used to be tangentially involved with the postgresql project many years ago.
&gt; Is this driven by some design requirement? by whatever &gt; What does "lighter" mean? Look at a dictionary 
&gt; There are some other web frameworks available, but I'm not sure what kind of state they're in or how they really compare to Phoenix in this regard. then what's your comment here for?
&gt; Phoenix is actually not “heavy”. I'm not asking what it is
You ask for help and then respond in a most hostile and ungracious manner. His point is pretty solid. Plug is lighter. There is your answer. His warning that your boilerplate will make it not worth your while is also good info. If you wish to provide actual details as to what you’re building, the advice won’t be shaped as strongly. But you didn’t, which is why there is confusion. Do you want to scale your http connections more than Phoenix does? Perhaps you can check out Discord’s blog posts about how they scale. 
Hey everyone! Reviving my blog and put together a little post on how to still take advantage of Phoenix generators, even when using data types not supported by the generators. My case was PostGIS Point types. Anyways, I'm welcome to feedback both stylistically and technically. Hope it's useful!
What's your actual use case though. I didn't want to list out a bunch of libraries if they don't fit your actual needs. 
I think the easiest to being with is doing something like: https://www.postgresql.org/docs/8.1/static/sql-set-session-authorization.html The possible problems with using connection based approaches has to do with polling and if you or the adapter is doing that. It's possible to pass options to Ecto.Repo functions so I would look into that and if that works. I don't see any filtering which would hinder you: https://github.com/elixir-ecto/ecto/blob/e366b71f15593a8decd3733349c44599a4e12a91/lib/ecto/adapters/postgres/connection.ex https://github.com/elixir-ecto/postgrex/blob/master/lib/postgrex.ex
Bingo! For help! How did you help me to answer my question? Where did I ask someone to give me advice of whether or not I should do what I asked for in the first place?
&gt; What kind of app are you trying to build? that's none of your business
&gt; If you generally want specific help, you'll need to give more information. if you don't know what to answer -- don't answer
Postgres connections are expensive to establish, so you pretty much always want to use a connection pool to avoid that cost. So you can't just reconnect with the individual user role for each request, you have to use a role with higher permissions and switch the active role at each request. This approach is interesting if you want to use row-level security inside Postgres, but otherwise it removes the major advantage of DB-level permissions again because you have to switch roles inside the database. If performance and latency doesn't matter at all, and you can skip the connection pool, this would probably be a reasonable idea.
Don't be a dick
I'd suggest having the clients play over WebRTC, rather than passing through your server. It'll use fewer resources and be simpler to implement. In that case, your server just works as a coordinator. You can prevent cheating by having both players report the game's outcome. 
For my Phoenix &amp; Absinthe app, I wrote a middleware called Gatekeeper. I've thought about extracting it into a hex package. It works by passing a GateKeeper struct through the request, performs all checks at the beginning and caches that data for the resolver.
Well I am not yet able to figure out how I would have the basic structure going for a multiplayer game. Like how would the channels communicate with each other or their behavior on terminating and stuff.
try this [course](https://pragmaticstudio.com/unpacked-bingo). it's Elixir + Phoenix + Elm but you can apply the lesson of the Elm parts to React.
https://github.com/h4cc/awesome-elixir#frameworks Here is a list of web frameworks. I've read and heard good things about Sugar and Trot particularly. Also, if you're going to be quite rude when asking others for help I'd advise you stick to using google as that will give you the exact answers you want and you can be as rude as you like.
Seems this can help! https://medium.com/@stanbright/elixir-phoenix-partials-1df87c5eaea0 I think the word you are looking for is "partials" Cheers!
Hey! Thanks for the offered help. Elixir version: 1.5.2 https://github.com/Gurp1272/bar_stool.git Note: I have never used github. I'm not 100% sure I know what I'm doing. It is to my understanding you can clone my directory with that git repository I just gave you. I hope this is the case. If I am doing something wrong or you need anything else please message me.... THANKS
So the version of `hound` you're using (0.5.8) was written in a [craaaaaazy old version of elixir](https://github.com/HashNuke/hound/commit/a9b59793222cf6a3d8720642394d882d13e0fef5#diff-6023be6004fce4718dad3dafb576d258R7) - 0.13.0. I'd say the code that's failing to compile is just not valid in modern elixir. If you really want to continue down this path, I'd suggest starting the tutorial again, and using more recent versions of the packages it suggests. Packages can be found on [hex.pm](https://hex.pm/). When you search a package and select it, it will provide you with a value to put into your `mix.exs` file; for [`hound`](https://hex.pm/packages/hound), it's `{:hound, "~&gt; 1.0"}`. If you go down this path, it's very likely that the code provided in the tutorial will be invalid in places, and you'll have to search the docs for equivalent functions. [hexdocs.pm](https://hexdocs.pm/) will be your best friend here! You can access the docs for the [elixir standard library](https://hexdocs.pm/elixir/Kernel.html) there, as well as any package you find on hex.pm. [`hound`](https://hexdocs.pm/hound/readme.html), for example. Honestly, I'd suggest you just find yourself a newer tutorial! If you don't mind a bit of reading, and you haven't read it yet, I can't recommend the [official Getting Started Guide](https://elixir-lang.org/getting-started/introduction.html) enough. If you want to just practice a bit of elixir, you can't go past [exercism.io](http://exercism.io/languages/elixir/about). If you want something more project-y, just find yourself a similar tutorial, written in 2017+, or get yourself a copy of the excellent book _Elixir in Action_, by Saša Jurić (I'm not affiliated with the author or anything; it's just, IMO, the best book there is on elixir). Definitely, 100% keep trying to learn, though. Programming is an incredibly fulfilling skill to pick up. If you get stuck, come back here, or hit the [elixir forum](https://elixirforum.com/), where you'll very likely find help (often from José Valim, the creator of the language), or feel free to DM me. As far as git goes, it's an excellent tool for keeping track of the work you do. I suggest trying to commit your code when you feel like you've done a _chunk_ that you can describe in a sentence. Don't worry about all the extra stuff with branches and pull requests and whatnot until you get used to committing and pushing to github repos.
Don't be a cock
&gt; Also, if you're going who asked you to give advice?
Partials is exactly the opposite thing.
Hahahaha, this is awesome. April 1st is coming up, right? Wonder if I can figure out how to stream to the office PA.
Hahahaha, this is awesome. April 1st is coming up, right? Wonder if I can figure out how to stream to the office PA.
Sounds like a job for Nerves! 
You should understand the difference between programming language and framework. Elixir does not have layouts, blocks of anything similar. And Ruby doesn’t have layouts and blocks also. 
Just want to point out that you don't need Phoenix to mount an absinthe API; the [absinthe_plug](https://hex.pm/packages/absinthe_plug) package allows you to add a schema to a regular [Plug.Router](https://hexdocs.pm/plug/Plug.Router.html).
You should eat less and study more.
I'd take a look at https://hexdocs.pm/phoenix/Phoenix.View.html#render_existing/3. With this approach, I believe, you could create various contents (`header` in your example) simply by making a function `def render("header.html", …` or the same template in that particular controller's directory.
Somebody pointed me to this comment and I would like to clarify the macro part is not quite true. Plugs are just functions that receive conn+opts and returns a conn. The contract is extremely simple. Building a pipeline of plugs is as simple as this: with %{halted: false} = conn &lt;- plug1(conn, ...opts), %{halted: false} = conn &lt;- plug2(conn, ...opts), %{halted: false} = conn &lt;- plug3(conn, ...opts), do: conn You can compose multiple plugs without any compile time behaviour. They can be developed and tested in isolation. However, there are macros in the Plug library, such as Plug.Builder and Plug.Router. But those are conveniences and not part of the Plug contract. The contract itself is very straight-forward. On the other hand, it seems Raxx implements all middleware at compile-time, so I assume you will end-up with more macro/compile-time behaviour.
The reason you can't have `content_for` work like in Rails-land is that EEx templates are actually just functions, and due to immutability you can't modify the context in which the template runs - you can only return a value. So, you have to either: (a) render the content ahead of time as a string or iolist, and pass it in to the template as an assign like `&lt;%= @my_content %&gt;`, or (b) extract the content into a partial and lazily render it as a child of the template using `render`
If using Phoenix, `render_existing` replaces the need for `content_for` in rails, so this is definitely the way to go
You work on sundays?
Why you gotta ruin my dreams, bro?
Ecto changesets are pretty nice for this.
There's always next year.
I am going through this course right now, and while it is helpful, I don't know if it will help OP unless OP already has some knowledge of Elixir / Phoenix.
lol you fucking prick, go away and don't come back
a few small things: * use .exs for things meant to be run as a script, and put the invocation at the bottom * are you going to do part 2 for these? your solutions are pretty clean, but mine were dirtier mostly because of part 2.
thanks for feedback. yes, I'm gonna do part 2 too, though just noticed, that there's appear second part after you submit answer:)
cool! i look forward to seeing more.
mol, you fucking cock, go away and don't come back 
There might be something useful for you here: https://github.com/mischov/meeseeks/issues/31
Binary garbage collection works differently than most other things in BEAM. Binary processing can easily end up creating lots of temporary binary strings (due to the nature of immutable binaries). Long story short, you will probably need a strategic `:erlang.garbage_collect()`. Here’s some background reading that might help. [Erlang Binary Garbage Collection: a love / hate relationship](http://blog.bugsense.com/post/74179424069/erlang-binary-garbage-collection-a-lovehate) [Erlang Efficiency Guide: Constructing and Matching Binaries](http://erlang.org/doc/efficiency_guide/binaryhandling.html) 
&gt; https://github.com/mischov/meeseeks/issues/31 That's a great reference, thank you!
Most of elixir seems to be written in erlang. Erlang is written mostly in C. C was originally written in something even lower, but now is capable of compiling itself, so no one needs to go lower than that. It is amazing how much code is involved with every little thing a computer does.
If you're curious how computer actually work, and what a programming language actually is, you should check out http://nand2tetris.org/
&gt; Most of elixir seems to be written in erlang Most of Elixir is written on Elixir. Only the compiler is written in Erlang and the so-called special forms.
Frameworks are like themed recipe books, e.g. for Japanese or Italian food, with many recipes in them, each one containing instructions for a robot cook(or plenty of them) to make some food. You still need to write some instructions to complete the commands. Libraries are like more specific book or tools, like "Knife techniques", containing stuff like how to cut fishes and tomatoes quickly. Programming Languages are the instructions themselves. Humans write those in human language, and they get converted to robot language by "compilers" or "interpreters", which then the robot takes it and executes to the T. Programming is mostly difficult because robots can't understand anything big by themselves, you can't tell them "cut a tomato in half" as they don't know what cut, tomato and half mean. You have to: * provide the tools, or make other robots provide them, then * give the instructions for them to pick the knife (and they don't know what pick means), * give some more instructions for them to recognize what tomatoes are (which itself is one of the most difficult problems in computer science, this is why we borrow libraries from recognition specialists). * Holding up the tomato probably requires a different set of libraries than picking the knife; then * the cut itself, requires instructions for arm position and movement. The "in half" parameter would tell the robot to move the knife to a specific position, based on the tomato size and format. Do any of these 1 inch wrong, and you'll have some expensive robot fingers cut off (which why you use fail-safes, and more libraries). It's turtles all the way down.
Yep. A high level programming language like C or Elixir will compile down to assembly (or be interpreted). Assembly is just a library for dealing with the circuits in a processor. So at the end, it's all just abstractions to make it easier to push current around.
Did you try to implement distribution via anything like pg2 (done this) or distributing the ETS tables yourself (haven't done this)? I'm curious if mnesia introduces a lot more overhead (for developer knowledge and code) for the use case.
After working with elixir for a while what do you feel are it’s limitations? I love the syntax of the language but I still fail to see what is going to make it stay around for longer than a couple years
I had considered distributed ETS originally but decided against going that route because I would be rebuilding much of what Mnesia offers out the box. Also I do not thing I could go the pg2 route(correct me if I am wrong) but because it is serialized so would not scale as a cache. Regardless of all that the hope for this library is that it does not really matter the underlying codebase as you don't really need to know about it. 
 All the above you mentioned are techniques for deployment, not languages. What type of code is running inside of your containers? Erlang excels at functional programming. There are several huge upshots, one is data immutability, Threading issues do not exist in Erlang. Faulty or incorrect data causes a process restart, and not a segfault. The cost of an error on erlang is a supervisor restarting a process. Super low effort. What happens when an error happens in your container? Or a threading issue in your c program? You restart the whole thing? That’s a super heavy handed approach. Now erlang is not the right language for lots of applications, what kind of application do you want to build? 
To add to what everyone else mentioned, the actor mode really is a joy to program when it comes to concurrent/parallel programming. Comparatively the mental overhead for doing CSP programming can be pretty high.
I don't have much more to add other than I just want to address a potential misconception. Elixir/Erlang are better for more than just backend application. I work on a project called Nerves which deploys an OTP/Elixir app to embedded Linux systems such as raspberry pi for example. This may just not be a use case for OP, but other readers may be interested.
DSL for finite state machines. Very similar to this one: [fsm](https://github.com/sasa1977/fsm) but with [GenStateMachine](https://hexdocs.pm/gen_state_machine/GenStateMachine.html) running under the hood.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/sasa1977/fsm) - Previous text "fsm" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Thanks!
Forgive me for ignoring the complete technical nature of your question but Elixir is fun. It is what I like to program and think in. And its still pretty cutting edge in the distributed data structure field. The gorgeous syntax and performant nature of the functional programming stuff is amazing to me personally.
If hot code loading is all you need, you definitely don't need Erlang or Elixir. However, you might prefer it. Even though a lot of container orchestration tools can emulate BEAM tricks at the application level, what happens when you need it at the VM level? I know microservices are all the rage, but they have the unfortunate quality of forcing you to consider things like fault tolerance and process isolation yourself rather than letting your VM handle it for you.
If you really want to go back in time to see why the concepts in this language are powerful go back to the early 70's with Prolog. While many languages iterated, trying to get it right from experience, functional languages tended to be specialized in purpose and founded from solid mathematic principles and proofs. Prolog syntax inspired Erlang and it makes use of the same sensibilities. This made the complex concepts of making concurrency reliable and scalable to program very natural. Go programmers for example may think concurrency is their ally but they merely adopted it. Erlang was born in it, molded by it. And now it turns out that old telecom reliability and scale is wanted in your average web project. Elixir gives you alll that as a next major step in that ecosystem. It's not about whether you can do something, it's how easily and what your projects will look like years down the road. The failure rate is incredibly low for that minority that adopts the stack because it encourages fewer mistakes and sensible scaling of code base. Even if it only makes you slightly more reliable and flexible than you otherwise would be, users notice. The problem space is farely wide for the BEAM and in and outside of work so it's a worthwhile added potency and concept as far as I'm concerned.
&gt; Threading issues do not exist in Erlang. Careful there. You can't actually get rid of "threading issues". At least not without getting some other kind of issue in trade. In Erlang, message passing and immutability have been pre-selected as the solution to "threading issues". This eliminates some kinds of problem and leaves you with other kinds of problem. Specifically, in exchange for threading issues, you now have distributed computing issues. Which are a bigger problem in general. That being said, Erlang does a pretty good job at giving you the tools to handle those problems, but the minute your system has concurrent execution things got irreversibly way more complicated.
Don't forget how it's promoted with the 99.9999999% reliability, yet almost nobody has reliability problems with anything else either. I have perl processes that have been running for years. And then there a lot of people promoting how fast it is, yet it's one of the slowest languages out there. It does preemptive multitasking, it's never going to be fast. I think some of the ways its being "sold" are wrong and very confusing. But I've decided to move forward with elixir for these reasons. 1. Its very fast with IO. (This is was one of erlangs requirements when being created). Which is what backends do the most of anyway. Ports make it possible to offload to a much faster language if necessary. Because a server side web app is almost all IO elixir seems fast. 2. Its a higher level language than golang, so you'll get things done faster, wont have 5 times as much code to debug. "Go" is short for "Go write some boilerplate" 3. Its high level like javascript, but you don't have to think about concurrency all of the time, like you do with horrible promises. 4. Its productive like ruby, but its explicit. With ruby you never quite know what's going on, there's so much runtime magic. Because of immutability and muggleness you can focus in on a block of code and not have to think much about its surroundings. 5. Phoenix, elixir, and ecto together is probably one of the most polished programming environments I've ever used. Rails is polished, but its performance is a trainwreck. Server side javascript is simply a dumpster fire.
So, I don't think hot code reloading is generally enough of a reason on its own to pick Elixir, and that there are far better reasons, but it is important to understand a fundamental difference between the container approach and Elixir's: Containers are treated in practice as inherently stateless. This allows one to tear down one container and replace it with a newer version . Elixir applications are allowed to be stateful. This is a fundamental difference that allows different approaches to be taken. For example to attain statelessness, container type applications will externalize their state. This creates more complex applications that are inherently slower than they need to be. It doesn't end at state, either. The idea of containers using traditional network socket connections to cluster, leading to complex systems of protocols that do not reflect the internal state / format of data while in flight, is another departure. Instead of non native API bridging and external state coordination, Elixir apps can decide to natively cluster efficiently. This is how e.g. Phoenix pubsub scales out effortlessly. So I think you are making some category errors in your comps, which is fair enough of you are still getting familiar with the tech. All THAT said, there are still other, perhaps better even, reasons for picking Elixir. Some have already noted a few of these.... 
 Now you are doing it. &gt; It really depends on the task at hand. If it doesn't require (many) mutations then there's no reason you can't get close to C performance, especially if you compile with HiPE. For example, /u/michalmuskala's json parser gets better performance than jiffy, which uses C, when compiled with HiPE. That's not really a fair comparison because data has to be passed to the nif, which creates a bottleneck. So that comparison has nothing to do with c vs erlang, but c-nif vs erlang. HiPE is nowhere near mainstream and probably will never be, I've been hearing about it for a decade... so any day now. It probably saw some easy optimizations and took them in that case. &gt; &gt; But ultimately, it's not the language to choose for computationally intensive tasks, but I don't think it's fair to say it's one of the slowest languages. I would say it lags a little behind Java and Go in terms of overall raw performance. I consider that a good tradeoff for the rest of what it offers. Lags a little behind Java and Go for raw performance? Hotspot is a beast, and it benefits from static typing, and Go is compiled and depending on architecture usually fairly well optimized. They might compare to erlang with pumping IO, which can only be so fast, but for anything else, erlang has scripting level performance, as should be expected.
&gt; HiPE is nowhere near mainstream Huh, isn't it just enabled by default everywhere? Definitely is enabled in official FreeBSD packages: ``` $ iex Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] ```
I think that means its available if you want to use it. I don't know if erlangs %99.999999999 reliability is guaranteed when using HiPe compiled parts. Here are some HiPe vs Java benchmark results, its not very impressive, and I don't think it ever will be, just because of the nature of BEAM, as I understand it. https://benchmarksgame.alioth.debian.org/u64q/erlang.html
Nerves is the shit! I haven't touched it in a while, how's the wireless module these days?
I maintain it and just gave it a ton of updates last week. It's getting a pretty major update once nerves core 1.0 is out
&gt; Specifically, in exchange for threading issues, you now have distributed computing issues. You will only get distributed computing issues if you are using distribution. But then, you will get those issues regardless of the language. You can still have deadlocks and starvation with Erlang/Elixir too. PS: not disagreeing, just clarifying.
Theres a really good video of [WebRTC and Phoenix](https://www.reddit.com/r/elixir/comments/5s2ipt/elixirconf_2016_webrtc_and_phoenix_when_%CE%BC_seconds/). But if you want to go with [Presence](https://hexdocs.pm/phoenix/Phoenix.Presence.html), you can have each user connect to a named channel, which has its own GenServer process attached to it. From there, you can use the calls made to the channel, like a router, to make requests to your GenServer and update/mutate/read state from that.
Erlang processes simulate distribution. Not being distributed has two benefits: - Your wire can't get unplugged, so you can ignore partitions. - You can share mutable state in shared memory, and thus have one single source of truth without a formal protocol beyond "use locks". On the BEAM, you start by giving up that second thing and committing to dealing with that part of distributed programming for every program.
I think you're more right than you realize. Erlang processes are *logically* distributed, which is the only thing that counts for CAP theory partition-tolerance. To clarify, you can actually experience *logical* partitions in the BEAM, at least in ways that are still CAP-relevant. In a VM with a stop-the-world GC (say, the JVM), you can have a network partition caused by GC. And for almost all systems actually out there, the definition of available is that it responds before the timeout takes effect. If you hit a JVM-powered database and it's busy and doesn't respond, your network between the two is logically partitioned. The core bits of erlang/elixir surface this concept pretty nicely when every receive statement with a timeout, but when you use OTP, a timeout is just an argument and defaults to 5s or so, and so a partition between 2 processes is lurking right under most GenServer calls. Asking if the process is alive isn't going to be enough to guarantee that the response from the other process is available (ie, the processes can be partitioned in the VM). To go back to the JVM example above, just because you can ping the node, and just because you may know (for some reason) the process on the other node is alive doesn't guarantee partition-tolerance between nodes. This usually happens with 1 very very busy process bottleneck on an overloaded system generally, but it's not worth littering the entire codebase with paranoid guards against this. Though it is worth thinking about backpressure in systems that will be expected to fully load a VM.
Eh, you can still use ETS, named processes and other local information without having to think about the complexities of the system if it was truly running distributed - where none of this would be directly available. Plus avoiding shared memory is also a requirement for fault-tolerance. If two processes share state, when one of those processes crash, you have no guarantee it didn't leave the state corrupted. So even if we didn't have distribution at all, we would still be promoting the second bullet because it plays an important role on building robust systems. Again, I agree that processes simulate distribution, but many of the design decisions behind processes are also requirements of other aspects of building Erlang systems. So I don't think the distribution aspect is generally constraining developers. The only aspect that maybe could be drastically different if we did not have distribution would be how we handle timeouts but I am not particularly sure there are better approaches. That would be something interesting to learn about. 
You’re obviously familiar with Elixir and functional process design so asserting that we cant get rid of every singleton bottleneck reader/writer process once inside the “distributed” flow of data i think Flow, GenStage, and some form of LASP, Presence or other aggregate root or CRDT data type (bluewater features for elixir all the way..) pretty much solve most of the distribution problems for the next 10 years or so. Many size cores with millions of actor processes on bigger edge pipes.
I'm variably familiar those technologies, and all of them present large tradeoffs (LASP has some of the most straightforward/robust tradeoffs, and I helped with the development of presence), and they really are not a way to make distribution of your program transparent, and there's some strategies around coordinated state that might be useful for local node shared state that might work like ets, but are not doable without nifs.
I am using Distillery. But I can't really ship ERTS with my release as my current setup is.
Include ERTS in your releases and you will be able to upgrade Erlang in production without drama. We have apps that have done that for years, going from 17 to 18 to 19 to 20. Erlang updates pretty frequently, more often than the stable packages that come with the OS. You can use the packages from Erlang Solutions, but it's better to build your own using a tool like ASDF. Then you can have multiple versions of Erlang and Elixir installed at one time, allowing you to test a different version from what you are running in production, then deploy it when you are ready. See this guide for details: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ 
For one project we are in the process of migrating dozens of dedicated servers from CentOS 6 to CentOS 7. We have found that it works fine to build on CentOS 6 and deploy the release to 6 and 7. If you are having problems, you are probably better off making a build box that's the same as prod. You may also be able to make a static build of Erlang with e.g. openssl included. One reason we do it this way is that we mainly develop on macOS, so we have to have a separate build box anyway. You can combine it with a CI system to generate the builds as well. 
This post is a little old now, but Boyd Multerer is working on an OpenGL driven GUI framework. It's supposed to be ready pretty soon. I've seen it in person and it is fast and looks really nice to work with. On the other hand you can do your ui code in C++ or C using QT framework, and communicate with it via a port or Nif or other mechanism, but this can be a pain. The issue with shipping a "cross platform app" is that the app will require installation of Erlang, or the app will require shipping with ERTS. This is a problem for cross platform due to linked binaries,cross compilation etc. 
You could build it in a Docker container that's identical to your production environment
I've been following CrowdHailer and his progress on Raxx for a while now. It's an interesting project and I thought this was an interesting overview.
wew. A self-hostable or open source discord alternative would be amazing. Even a chat+voice app that has dedicated voice channels is sorely missing from the likes of mattermost/matrix/rocketchat
Thanks Onorio! I want to let everyone know there is a bug when using Elixir 1.6 with Erlang 20.3, we are shipping Elixir 1.6.4 today or tomorrow.
I want to add elixirschool.com. Great resource.
Oh--glad you mentioned it! I will try to get 1.6.4 done quickly!
1.6.4 is posted to Chocolatey NuGet. I'm not sure how long approval will take but it should be available later today at the latest. Just wanted to let you know!
https://www.youtube.com/channel/UCOy-_b9bqjokoWX9Hg5ZgUg/videos
Hot reloading is not rolling restarts. If you have 3 servers all having long running (people connected for hours at a time you can change code modules without disconnecting a single person or routing new connections to the other servers whilst waiting for all the clients of one server to disconnect. Rolling restarts would either have to wait for people to disconnect (fine for short lived http connections for a web server but something like a telecoms system or even online game server would suffer badly) or kill people’s connections. I presume like other orchestrators the rolling restart stops sending incoming requests to an app which is due to restart, waits for existing connections to finish up and then updates and restarts. How would that work if the average connection duration was 20 minutes? (Instead of a second or so for a http request?) TL;DR - hot reloading and rolling restarts seem similar but if the average connection lasts 20 minutes (eg game servers instead of http servers) a rolling restart of 3 servers would take about an hour...) hot reloading lets an instance carry on serving whilst its updates (the app never stops)
great ! what are the benefits of it?
Anyone got a recommendation for top 3?
We use straight Plug in a few places (where we don't need templating, ecto, channels, etc) and it works fine
I would not focus on learning Phoenix. If you know Rails then you should be able to pickup Phoenix easy enough and I don't think it's worth your time. You should focus on learning OTP and working with actors. That is where Elixir really blossoms. If you are only working in single-threaded web requests you're missing the best parts of Elixir and the BEAM
Thanks for sharing this. If you want a link to the slides you can find them here http://crowdhailer.me/2018-03-02/raxx-refined-web-development/
Prefer module and import it there. Because you might end up with a lot of dead code that way. Those are macros that expand in compile time
[removed]
How would that help not end up with dead code?
When you define code inside the `quote`, you will have those functions being defined over and over again on every module that you `use` that functionality. If you use N times, you end-up with N definition, and each of them may or may not be used. When you define in a separate module and import it, the function is defined once and use multiple times throughout our application.
&gt; When you define code inside the quote, you will have those functions being defined over and over again on every module that you use that functionality. If you use N times, you end-up with N definition, and each of them may or may not be used. I don't think that's expensive at all. I'll be copy-pasted. 1Kb of additional space. is that it? from this respective, defining a module won't be completely free either.
Also harder to debug, especially in terms of stacktraces, increases compilation time, makes testing harder (you cannot unit test without defining it in a fake module before), etc. There is probably good reason to trust the Phoenix team if they say something is bad practice. But hey, it is still your call.
I wrote this post as an intro to a library that I might be spinning my wheels on. Here's a link to the bare bones docs: https://hexdocs.pm/moonsugar/0.1.2/api-reference.html#content 
it'll compile for 5 days?
thanks for sharing! Have you used the OK module? I find it very handy for pipelining ok/error producers ...
I actually really like with, but I wish it wasn't so finicky. It seems like I always make a mistake and the error message makes it very difficult to debug.
Not 5 days, but if you start editing web.ex directly in your workflow, it can make compilation times for the project slower. Later in a large project, if you have a few dozen controllers/views/etc, editing web.ex might make take recompile times up to a minute.
No problem! I have tried the OK module, I really like the ~&gt; macro that it provides, it is similar in use to my chain function, but results in cleaner code. Moonsugar's goal though is a bit different. I see it as a library that provides consistent utility functions over a range of data types, not just OK. Also, I made a point to avoid macros as much as possible. I think this makes it more likely to be used. It also helps folks unfamiliar with the library to still get the gist of what's going on. 
Working on a book on full stack development with elixir/Phoenix as the backend and react and redux on the front end
Yes, saw that your lib has a wider scope which is nice, particularly things like maybe types. I don't think the macro thing is a big issue, though, and makes for rather nice language integration.
how much slower?
"up to a minute or two" --&gt; do you mean "more"? how did you measure?
These aren’t attributes in Ruby sense. These are more similar to C `#defines` (these are evaluated compile time instead of runtime), so you need to think what you really need. 
Maybe just like this? ```elixir defmodule M1 do def var1, do: 123 def var2, do: 456 end ```
I started using `with` with parens and it is much clearer to me and I fall less into error messages traps: with( ... ) do ... end The formatter also supports it in the latest version.
One valid use is to compute a value at compile time and expose it through exported functions in the module for runtime code. I did that a lot when working with the language.
Finicky with formatting? Before I started using the formatter (all hail the formatter), I found myself doing this quite a bit to improve readability: with \ {:ok, foo} &lt;- bar() {:ok, baz} &lt;- oof(foo) do baz end Unfortunately the formatter clobbers that and insists on inline formatting (all hail the formatter). :(
Okay, nice article overall. Although I'd like to point that: `&amp;` is only used in function capture syntax, that is when you're using a lambda. Syntactic sugar is nice but useless and confusing in that case. --- &gt;Wowowo! What is all this “@bot_name” and “use Stuff.Bot”. By now consider this a #worksOnMyMachine, Telex needs all this and we need Telex.Bot to handle messages :D Adding smileys and hashtags is not a good way to hide the fact that the reader/beginner didn't get what you just did. Take the time to explain, not in depth but at least what it means. --- All in all, It was a nice read. Thanks :)
I put together a summary of the talks along with my favourites here: http://underthehood.meltwater.com/blog/2018/03/21/lonestar-elixirconf-2018/
I also think using the $ prefix in function naming will cause confusion to many readers. `function_name/arity` is the way to name a function in plain text, I think it would be worth it to correct the many references in your article.
Use parens around the args, as I just posted above! The formatter keeps the parens in latest version.
Thank you! Just changed the way functions are named :D
Just changed the function naming and the paragraph you quoted, hope it looks better now ;)
Teaching is a great way to learn :) Writing blog posts will definitely help you understand things you use. Well done :)
Please elaborate on what you need elaboration on.. Dude, we're not getting paid to help you. Why are you acting like a jerk?
cock, you came here to tell me that you're not willing to help me and the way I should behave?
I know the formatter is new so hopefully this isn't heresy yet.. but I've stopped using the formatter in my code. I feel like it just uglifies everything.
&gt; it'll take it 5 days to compile? Yes. Yes I did. Look at the way to replied to "asonge". Do you think that's respectful?
I would expect you to be extremely familiar with OTP. Mix is just a build tool even if it is a damn fine one. As for Phoenix, it's really not that hard to pick up once you're familiar with Elixir, but without OTP knowledge, it's easy to structure your app wrong or otherwise misstep. I think I can narrow down my list of recommended reading to two: 1. [Elixir in Action](https://www.manning.com/books/elixir-in-action) 2. [Functional Web Development with Elixir, OTP, and Phoenix](https://pragprog.com/book/lhelph/functional-web-development-with-elixir-otp-and-phoenix) The former gets you started with Elixir and OTP. The latter teaches you how to apply what you've learned if webdev is the direction you wanna continue in.
x86_64 &gt;&gt;&gt;&gt;&gt; elixir but nice try (ayy blin)
A 2nd on OTP being of prime importance. :) Aside from that, perhaps the most useful thing you can do is to learn the ecosystem. Elixirforum.com is a great place to be, get familiar with hex.pm, the YouTube channels that carry conference talks ... they all contain the breadcrumbs to continue to progress. Also don't be afraid to use Erlang libraries in your projects, and be familiar with how that works in practice (:module.fun rather that Module.fun; functions that take charlists rather that bit strings; where if you have to implement an Erlang behaviour or similar you put it in src/ instead of lib/ ... things like that). There are so many fantastic libraries written in Erlang that are invaluable to many Elixir projects .. Hope you have lots of fun in your explorations! It's a great language and community ...
My experience has been that you can be productive by just learning Plug, Ecto and Phoenix initially, maybe also a job queueing system like Exq. The cowboy web server is already spawning a separate process for each request, and the Ecto Repo is managing a pool of DB connection processes. There's plenty of OTP stuff happening in your app - but you don't need to be writing it yourself straight away. Once your confident writing sequential elixir, you can take on OTP, distributed erlang, advanced macro metaprogramming, but it's the functional basics that are most important. 
Thanks man. Loved the Clif notes version of these and which ones you digged. Much Appreciated 
I freakin’ love Randy. 
Yes I did. But there's no option for elixir. So I don't know how it helps. I used --js-completer.
Yes. Even after that, it doesn't work.
Damn it pragpub, why not letting us buy the Phoenix and Ecto book coming out in June.
That's what I said!
Depends on what I'm hiring you for. We're at this stage of growth in Elixir such that finding local candidates with substantial direct experience is still difficult in most markets, but finding people who want to learn Elixir is relatively easy. So primarily I'd look for some demonstrated desire in that along with substantial web development experience in something else. I don't want to teach you HTML, CSS, JS, etc. I don't mind teaching you a new syntax and some functional programming concepts in the first few months of a shift like that. If I'm hiring you to act as a team lead or in a position that requires more experience and I'm able to FIND you, either locally or because I'm able to hire remote, then I concur with respect to OTP—I'd want you to be pretty familiar with things like GenServers, supervision trees, message passing techniques (which is more abstract than just what we do in BEAM applications) and testing with ExUnit. I don't think I'd expect you to be an expert's expert. But well-versed enough that my more junior engineers would be able to learn from you, and you'd catch glaring problems in a code review. In terms of learning, what I recommend is a quick readthrough of Dave Thomas's Programming Elixir, followed by Sasa Juric's Elixir In Action, which I found to be a great help in learning OTP when I started out in Elixir. Probably follow that up with Lance Halvorsen's Functional Web Development with Elixir, OTP, and Phoenix. Then, just write a lot of code....
https://gist.github.com/ConnorRigby/576b971be5bfbdd4fa4c0c3380b31fd1 I wrote the perfect code. It magically defines any function you try to write
Why are these threads always posted much later in the month rather than on the first? Always struck me as odd.
Using plug via phoenix or straight cowboy gives you one process per upload, done ;)
I want to learn Elixir, so I am working on a YouTube chat room web app, where multiple users can view the same video. Play, pause etc. should be synchronized among them. I thought using web sockets and Phoenix would be perfect for this app, as there can potentially be many rooms with lots of chat messages. Most of the work so far has been done on the frontend, but I am looking forward to more work on the backend. To learn Elixir I took the PragDave video course and I am now reading the MEAP version of Elixir in Action.
The Elixir Radar newsletter has a long list of jobs: http://plataformatec.com.br/elixir-radar/jobs
The market is small but growing, however there is also a shortage of experienced developers so it is a great time to learn. 
Trying to get Phoenix running on a local unix socket, proxied by nginx. If I can get it working, I'd like to perform a zero downtime deployment simply by updating the `current_release` symlink, and reloading the nginx config. After digging through plug, cowboy, ranch and kernel erlang, I believe I've confirmed that `:file.sendfile` doesn't work with a socket connected from a unix domain :/ Had to port my test app to C just to confirm it was possible at all :D 
Make your own. I don’t think your efforts here won’t pay off long-term. I haven’t run into any people complaining about Elixir/Phoenix dev