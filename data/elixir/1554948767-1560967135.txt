The definition of "most loved" that stackoverflow uses is pretty important: &gt; % of developers who are developing with the language or technology and have expressed interest in continuing to develop with it
&gt; In the case of the article (hashing files), security is not needed Why? It is often nice side effect to not only check integrity, but also more or less safety of the file. &gt; so we can use MD5 which is fast. Why you say they shouldn't be used in production? Because on new CPUs SHA-1 and SHA-256 will be much faster due to [Intel SHA Extensions](https://en.wikipedia.org/wiki/Intel_SHA_extensions), and on older devices [Blake2 will be faster and safer](https://blake2.net). So as you see there is absolutely no reason to use MD5 for anything other than legacy.
&gt;SHA-256 will be much faster due to [Intel SHA Extensions](https://en.wikipedia.org/wiki/Intel_SHA_extensions), Ah interesting, Didn't know! I'm rewriting the examples using sha-256 :D Do you have a twitter account I can quote in the update? I did some benchmark using md5, sha1, sha256 using the erlang `:crypto.hash` and still sha1 seems to be faster (my CPU is a intel i7 .. 6700K I think) sha1 424.43 K md5 389.63 K - 1.09x slower +0.21 μs sha256 229.74 K - 1.85x slower +2.00 μs
Handle is the same as here. And SHA-256 instructions are newer, so not all CPUs have those (or your OpenSSL is compiled without them). It seems that if your OpenSSL will support Blake2 then you will be able to use those in `crypto` module as well (which seem to be undocumented feature, as well as support for RIPEMD160).
I've just updated the article examples using SHA-256 since, as [Hauleth](https://www.reddit.com/user/Hauleth) said \&gt; Because on new CPUs SHA-1 and SHA-256 will be much faster due to [Intel SHA Extensions](https://en.wikipedia.org/wiki/Intel_SHA_extensions) ... \&gt; ... there is absolutely no reason to use MD5 for anything other than legacy.
**Intel SHA extensions** Intel SHA Extensions are set of extensions to the x86 instruction set architecture which support hardware acceleration of Secure Hash Algorithm (SHA) family. Introduced on Intel Goldmont microarchitecture. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
For a nice ML, I'd opt for OCaml over Rust, unless you're doing things that have really have tight memory constraints. OCaml is much closer to Elixir than Rust, in that it's also a functional-first language that is biased against mutability.
just a warning - IIRC (please check me on that) ironically Intel SHA Extensions are \*not\* currently supported on most purchaseable intel machines (they are active on some weird chip called the Geode? and next year's server-class machines), but you might be able to get them on similar processor intrinsics on AMD x86s.
sorry, it's the Goldmont Architecture that supports it, so unless your Intel machine is in a car or something it won't be there. Ryzen has it, though.
ah thx. So, just looking at the numbers of the benchmark sha256 is slower than md5, but sha1 is faster. Maybe that sha1 on my computer some instruction on my i7 CPU?
As much as I would love this to confirm my biases, in the past this survey has been heavily, heavily weighted to web developers which leads to absurdities like Javascript being the most used language for 'data science' or some garbage like that.
\&gt; that you should **never** use MD5 in production code 100% depends on the requirements. If your needs take into account collision attacks and other attack vectors that are in play today there are still cases where MD5 can be used in production. For anything that depends on the cryptographically secure promises that MD5 was known to make and are now completely broken, of course, MD5 is no longer viable.
No, there is still no reason to use MD5 (except when you need backward compatibility with some legacy system) as this is slower, less safe, and deprecated algorithm. So give me any reason (except compatibility) when you would use MD5 and using SHA would be worse choice.
That said those are also some of the coolest features of the language, from my experience getting excited learning some of those more advanced features really moved me to have more focus on learning the basics. Sometimes the exciting bits make it easier to put in the effort for the basic bits.
SHA what? SHA-0/1? SHA2-256? 512? SHA3? MD5 is faster and less cpu intensive for some types of work as long as you understand how it is "broken". Blanket statements like "less safe" is just silly. It is "less safe" when you make reliances on the broken promises for a given need. There are many usages for a hash that do not require reliances on those factors. From my perspective a person that makes blanket claims against suitability against an open set problem space is just as dangerous doing any type of crypto work as one who does not know what MD5 attacks mean and what assurances they reduce (or completely break). Especially when you toss out SHA2 as a reasonable choice if you \_do\_ need the advantages of crytographic secure hash that MD5 does not afford you. You do realize that sha2 is broken in other more subtle ways today? LEA attacks are a thing. At the end of the day, what is suitable for a given need depends on ALL of the details not general hand wavy guidance. &amp;#x200B; If by speed you are talking about the SHA extensions on some CPU's -- I suggest you look at that in detail. Out of the SHA extensions you find in the wild against intel and AMD, most of the extensions are targeted only for SHA-1 (which if you consider MD% unsuitable for a given need you should also consider SHA-1 unsuitable). There are some extensions targeted for SHA265 but those have tradeoffs and falter on sustained usage (as specifically intel SHA 256 extensions in sustained use cause thermal throttling just as bad as AVX512) -- for hard hit systems you actually produce better thru-put over time not using the extensions.
Oh I totally agree! Just op was asking about the more practical route to being effective in Elixir.
&gt; MD5 is faster and less cpu intensive for some types of work Sorry, but everybody is telling that, and have anybody [tried to prove me wrong](http://bench.cr.yp.to/results-hash.html)? &gt; You do realize that sha2 is broken in other more subtle ways today? LEA attacks are a thing. Which applies to all hash functions that are based on Merkle-Damgard construction, which include MD5. So you still suggest using weaker function just because of "speed" (which isn't true anyway) which is also broken in the same way? &gt; If by speed you are talking about the SHA extensions on some CPU's Even without these extensions, on many new CPUs MD5 is slower than SHA-256, check out SUPERCOP benchmarks that I have linked above. And if speed is what you really need, the go with Blake2, which is faster on most CPUs and is safer than MD5. --- So yes, I done my lesson and I know what I am talking about. Have you?
If you want to help turn this collaborative writing app into a crowdsolving site let me know. I have a little Elixir and front end experience. I know CSS/JS, and have a roadmap for the site. Currently stuck because of a language version issue: https://github.com/Microflow/how-can-we-fix/issues/1
&gt; Which applies to all hash functions that are based on Merkle-Damgard construction, which include MD5. So you still suggest using weaker function just because of "speed" (which isn't true anyway) which is also broken in the same way? No I am saying there are times where you DO NOT CARE based on the details of usage. you,however, are proposing that md5 is broken for ALL usage (it seems pulling in your own thoughts of constraints) but then suggesting a simularly broken replacement. Anyways I am done with this -- there is no reason to argue against a cargo cult member. The devil is in the details, in CS no general guidance can be applied without regard to the details.
you idiot?
&gt; rsync or many other similar protocols are broken by nature and use of md5 That is included in "legacy systems" I have mentioned, and it often isn't needed/feasible to change them, I am saying about **new** symbols systems. And yes I still think that this is pointless to use MD5 as it has nothing that other functions wouldn't improve: - you need speed and do not care about security - use SHA-1 or Blake2, it will be faster - you need security and care about speed - use SHA-256 or Blake2 - you need security and speed is irrelevant - use SHA-3 - you need preliminary check that is absurdly fast and do not need crypto part at all - SipHash, FNV, MurmurHash Again MD5 should be left **only** for legacy stuff, in **new** there is no point in using this function (unless there are **very** specific situations, like embedded CPUs that cannot be upgraded and need to check integrity and SipHash is not enough).
yeah so I just saw the benchmarks that hauleth posted and they confirm what I know about the AMD intrinsics. But yeah, don't use MD5 in prod unless it's for legacy. EVEN if you don't need security, SHA256 has longer legs, if not now, because nobody ever got fired for buying intel, soon (about a year out, don't ask me how I know)
&gt; Note that at this point we’re fighting the OS and other running apps for the cores, so actual run time can vary a lot. Another factor that will affect the time for the elixir code is also the VMs own scheduler. That’s why doing a 1:1 comparison between it and other languages isn’t exactly equal.
The document is here. However, it is only Japanese. I'm sorry. [https://qiita.com/sym\_num/items/0b53f38cb213da79c251](https://qiita.com/sym_num/items/0b53f38cb213da79c251)
I started an Elixir job 2 months ago so I'm still very new to the language but I've so far made a bot that'll inform me when my local football team is playing (so I know they'll be travel disruptions in the area) and I've started a larger phoenix app: a job board with some features I think they're all missing that I'd want in a job board - gonna hook up stripe this afternoon. &amp;#x200B; Need to then style it up, add a few edge case validations and work out how to get people to post jobs on it...
I’ve been writing code for ~20 years now and I can say Erlang/Elixir combo is above average in the amount of effort you have to put in learning it and in the amount of information you have to keep in mind, mostly because of the vast OTP library
Really clean little project. Love the use of pattern matching to describe the base vocabulary of the language. The code does look a little repetitive, you could speed it up with some compile-time code generation maybe?
Thank you very much. I was concerned that many pattern matching of interpret/6. I will devise.
Its one of those things I often have to remind myself to do, coming from other languages. All that said, I was particularly impressed with the little state machine you wrote for handling the stack. Was elegant and quite simple
Thank you very much. I am honored.
That metric also skews towards languages that happen to pay better. I might get paid like a king but hate every minute of it and still want to keep doing it.
Given I wrote this, I was really confused when I saw it was submitted by "self"!
Elixir can definitely run in AWS! However, there are certain products that are a better fit for running the BEAM (the erlang vm) than others. For example, EC2 or ECS would be good choices. This is because these products can run your code 24/7. An AWS product that isn’t the best fit would be Lambda. Lambda are short running “one off” code executions. This definitely contrasts the BEAM which excels at running long-lived stateful processes. However, I think you can run elixir scripts on lambda if you do want to use this product. Other options are with a simpler setup could be heroku or gigalixir (which uses aws behind the scenes IIRC)
Nice article.
Depends on the kinds of projects. I'm using EC2 / RDS / S3 for an elixir project right now. The infrastructure can be very helpful for avoiding having to deal too much with some security options and settings and file storage etc. If your question is more about help with specific job hunting; I wouldn't count on this approach in combination. Elixir jobs are still relatively rare in many regions and serverless is gaining ground but I wouldn't call it super prominent. I don't think you can expect to see someone asking for both together or come up with a compelling use-case in whichever position you take. You can definitely introduce elixir in an AWS world on the job though and it will take if you have just a couple of the right coworkers and problem to solve. I was in a company that transitioned 100% almost to AWS but had no erlang/elixir development and I introduced elixir with Flow to solve some largish data processing jobs and then it led to interest from another team to learn from what I built to develop a load tester for new libraries (because when I ran my program from my laptop without throttling it I crashed the DNS service of the entire cluster taking down unrelated services). That would have been a good project for someone newer to elixir because production infra didnt have to be run continuously. So note that if you need to deploy something high availability that production services rely on continuously, elixir is obviously great for that but you have to take into account experience running production erlang/beam. If you want to start gaining that experience you can build a simple service or web site in elixir, use distillery to create builds and manually upload and release them on AWS. You can create an account there and bring up free tier EC2 instances on the cheap and deploy to your hearts content. You can then use some of the guides out there to try and cluster two EC2 instances together and make your program distributed over the network (it's fairly easy on EC2 and you can even DM me on issues). So in summary I think it's a fast and inexpensive way to learn about the BEAM and that yes you can use it effectively enough in AWS to be useful for many organizations.
Well I'm in an area where I've seen Elixir jobs... it's mostly the fact that I don't have experience with it. Not only that, but I want to start my own site with Elixir potentially one day. I just want to bias jobs that may be even slightly working with technologies that could help me in an Elixir stack.
I wouldn't worry about independently learning AWS unless you're looking to enter into a devops job. If you have interest later you can likely ask your employer to shadow engineers who work on your infrastructure.
I think you would get more "mileage" by learning some of the devops fundamentals before going down the AWS rabbit-hole. &amp;#x200B; Granted, there are some AWS technologies that it's important to know, specifically EC2 (running servers) and S3 (storing stuff). That would not be time wasted.
All it takes is dedication. I’m actually completely new to backend development and i recently completed a hackathon project in Elixir. It’s really quick and easy to onboard people because the documentation of the main libraries is incredible. (ExDoc and Hex.pm are cool) Just take the time to learn the fundamentals by reading some of the literature posted. Immerse yourself into functional programming and perhaps it might give you insights into other programming styles.
Oh man... thank you so much. While coding my ongoing side project, a while back, I was trying to get the emoji flags for each country in my database. I found out emoji for them isn't in any sort of logical order and tried to see if there are any library for it. Thank you so much for this, it will be useful for me on my side project.
I'm so happy to hear that! My goal was for it to be useful for at least one person other than myself, job done :D
Thank you, I learn something new.
Hi! Nice library! I wanted to give you one general code style. Usually the file names match the module name, for example, your module `Flagmojis` would be in the file `lib/flagmojis.ex`, and the module `Flagmojis.Flag` would be in `lib/flagmojis/flag.ex` Of course, it's just a convention, but I think that it makes much more easy to maintain the code and add new features. You can read more about it [here](https://github.com/christopheradams/elixir_style_guide#underscored-filenames)
Great! Thank you, I’ll make a small refactor
Can I give a fun suggestion? You don't need to store the emojis. You can instead generate them on the fly. Emojis are often composed of multiple unicode codepoints. In the case of flags, they are composed of regional indicator symbols based on the alpha-2 code. For example, Iceland's alpha-2 is `IS`. Its flag 🇮🇸 is composed of the corresponding RIS: 🇮 and 🇸 The ISO standards state that an alpha-2 code is strictly composed of 2 characters, each being an upper case letter between A and Z. That's a codepoint in the 65..90 range. Luckily the RIS codepoints are also sequential, in the 127462..127487 range. You can therefore convert an alpha-2 code to a flag emoji: alpha2 |&gt; String.to_charlist() |&gt; Enum.map(&amp; &amp;1 + 127397) |&gt; to_string()
If I understand you right, then you don't need to be learning AWS at all. Rather focus on the backend and system administration in general. If a certain company uses AWS you can learn \*on the job\* how to add a new AWS service and chances are this might not be your job at all (if it's complicated AWS deployment). Especially with Elixir I don't see the reason to go serverless. You might want to use object storage (Amazon S3 or Digital Ocean Spaces) alongside the regular Amazon EC2/Digital Ocean Droplets which is easy to setup. Maybe managed database (also straightforward)... If you want to be stronger in Linux and systems learn the basics that are transferrable across providers. What if you never end up using AWS? You might find my upcoming book [vpsformakers.com](https://vpsformakers.com) interesting for this. I demonstrate the deployment on Python and Ruby, but since I took a lot of interest in Elixir lately, I might do an update with deploying Elixir too.
Really neat trick 😁
It won't win any awards for responsiveness but still surprisingly playable. Nice work. One minor non-technical suggestion: "**WASD** or **↑←↓→"** Don't mention **W S ↑ ↓** since they don't do anything **:)**
Closest book Lance Halvorsen Functional Web Development with Elixir, OTP, and Phoenix: Rethink the Modern Web App
Thanks man... will fix the instructions asap (: Unfortunately, drawing on the DOM with this frequency does not allow for fast, responsive rendering. Plus you need a discrete GPU and possibly have battery saver disabled in order to experience some degree of smoothness while you play. I noticed that periodically some major garbace collection kicks in, ruining pretty much the experience for several frames. I don't really know if it's something that can be fixed
We were discussing something similar with my colleague. He argued that people are coming to Elixir, learning the syntax, and getting bored before they see the real power of OTP. We could use a book that describes ”actor design patterns”. How to make rate limiters, circuit breakers, watchdogs, process pools, active TCP sockets, NERVES hardware interruptions as incoming messages, monitors, and a plethora of other useful actor/message interaction.
I’ve been saying this for years... even back when I was just doing Erlang. I’d even love to write it, but I’m not sure I could find time without finding a reason to get really dedicated to it :/
I don't see a reason why we couldn't work on this as a group as well. Something like [Learn Go With Tests](https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/maps) except instead of learning the language around the context of TDD, you learn everything revolving around a series of concurrent mix umbrella apps
I think the book should still be a beginner book. But, as you suspect, a lot of OTP could be taught with a minimal knowledge of the language syntax and abilities. For example, "Hello World" should be a genserver that you pass "hi" to and it responds back. Then when you send "goodbye" it crashes and we learn how to handle restarts via the supervisor. Boom first chapter.
This looks good, but it would be better if you built many OTP apps rather than just one throughout the whole book. I don't know if that is a personal taste thing, but I would rather build a new OTP app every single chapter to increase my confidence and muscle memory of working with the tools.
It’s really cool to see people adopt my language of choice and it’s also nice to see them contribute to open source. Thank you so much. 👍
this would be a cool project for this sub
Did you tried coc.nvim for language server support?
Great! Small tip: all of your functions in your `Flagmojis` module iterate through the entire list when it needs something. Some of them, like `Flagmojis.countries()` could just be computed and stored in the module itself: `@countries @all_data |&gt; Enum.reduce([], &amp;([&amp;1.name | &amp;2])) |&gt; Enum.sort()` `def countries(), do: @countries` That would reduce the complexity of the call from `O(2n log n)` to `O(1)`. Others, like `by_country_name/1`, are still `O(n)` because it has to iterate through the entire list. I would consider storing them in a [MapSet](https://hexdocs.pm/elixir/MapSet.html); accessing items there is `O(1)`, since it's backed by a simple map.
Sounds like you need to start a side career as a writer! I think Manning does work-in-progress books where you can start writing and people get early access to provide feedback.
First issue here: https://github.com/Microflow/how-can-we-fix/issues/1
JEG and Bruce Tate are about to release [a new book (in beta)](https://twitter.com/redrapids/status/1115593634802470912) that might be worth checking out for you. [Here's the Amazon link.](https://www.amazon.com/Designing-Elixir-Systems-OTP-Self-healing/dp/1680506617)
Have you looked at "The Little Elixir &amp; OTP Guidebook" ?
If performance of something this simple is a factor I would perhaps think NIFs would be a better fit for the task but this is a nice alternative to have in the toolbox anyway. Really interesting read, thanks!
Well if you are OK with doing something in Erlang then I just started an interesting project on using Type Specs for input validation [https://github.com/zkessin/type\_tools](https://github.com/zkessin/type_tools)
I have reviewed it, but it has very important disadvantages for me: - it requires external dependency - Node.js - it used (still uses?) additional configuration format (JSON) - it is "intrusive species" within Vim; what I mean is that it tries to "know better" and make everything for user, for example it provide it's own completion mechanism (wich is autotriggered by default) instead of being "good citizen" and providing support for omnicompletion/user completion; and as I do not use any auto completion plugin but instead rely on built-in Vim completion systems this is very no go for me So if coc.nvim works for you, then ok, but I prefer to have more control about such big functionality like LSP.
Here’s a couple of ideas that I wish I had some free time for :) Add a UI to [ecto_job](https://github.com/mbuhot/ecto_job) using Phoenix LiveView to show the status of the job queue and provide an easy way to re-queue failed jobs. Modify/fork [open_api_spex](https://github.com/open-api-spex/open_api_spex) to use `@doc` module attributes to specify the swagger operation metadata for Phoenix actions or Plugs. Taking inspiration from [rolodex](https://github.com/Frameio/rolodex/blob/develop/README.md)
Considering Elixir's strengths, there are surprisingly few chat servers written with it. [https://github.com/search?o=desc&amp;q=language%3Aelixir+xmpp&amp;s=stars&amp;type=Repositories](https://github.com/search?o=desc&amp;q=language%3Aelixir+xmpp&amp;s=stars&amp;type=Repositories) [https://github.com/search?o=desc&amp;q=language%3Aelixir+irc&amp;s=stars&amp;type=Repositories](https://github.com/search?o=desc&amp;q=language%3Aelixir+irc&amp;s=stars&amp;type=Repositories) [https://github.com/search?o=desc&amp;q=language%3Aelixir+matrix&amp;s=stars&amp;type=Repositories](https://github.com/search?o=desc&amp;q=language%3Aelixir+matrix&amp;s=stars&amp;type=Repositories) [https://github.com/search?o=desc&amp;q=language%3Aelixir+webrtc&amp;s=stars&amp;type=Repositories](https://github.com/search?o=desc&amp;q=language%3Aelixir+webrtc&amp;s=stars&amp;type=Repositories) &amp;#x200B; I'd contribute to one of those projects.
I already have code for supporting `@doc` attributes in open_api_spex if you want.
This is cool. So are you trying to just implement a structured definition for parameter validation?
That's pretty cool! It played well for me. I know the team doesn't necessarily suggest this as a primary use case for liveview, but the fact it works so well on a game like this is a testament to it's capability and I think it's within the realm of what liveview can use used for. It makes using liveview for realtime dashboards, paginations, widgets, etc seem like a walk the park. &amp;#x200B; All these little games being made with liveview remind of a few years back when online "break session" desktop games were popular.
yes, at least for now, probably add in other features later
Good to have some words backing to what I felt when working with Elixir. I found myself doing TDD all of the time with Elixir because it's so frictionless.
Thanks. I did try to use [https://github.com/prabirshrestha/vim-lsp](https://github.com/prabirshrestha/vim-lsp) some months ago but find more comfortable with coc.nvim. Was using with Java indeed but didn't find to work so well.
Yeah that would be great.
I've been doing the 2018 Advent of Code in Elixir and one thing I really noticed was how easy and frictionless testing is in Elixir. For the particular problem I was working on, I tried hacking up a solution and after banging my head for a while, I decided to re-do the problem and writing tests along the way. This should have been my approach initially because Elixir makes it so easy to test!
I appreciate the effort put into this article. However, I'd like to point out that almost any modern language has similar tools for unit testing, and the article doesn't really point out why elixir _excels_ in this particular area.
Collaborative text editor here focused on solving local issues. Once I fix a couple of bugs I want to improve the design. https://github.com/Microflow/how-can-we-fix https://github.com/Microflow/how-can-we-fix/issues/1
The type system looks cool, but the syntax makes me cry :'-(
I would love to see a typed language on BEAM but as far as I know, it is really hard to do so because of functions such as this one: def convert_back_and_forth(string), do: String.to_atom(string) def convert_back_and_forth(atom), do: "#{atom}" The type of that function is `string -&gt; atom | atom -&gt; string` and there is a lot of functions like that in BEAM. Non of the statically types languages I know allows something like that because it makes type inference impossibly slow. So there are three options: * do not have type inference (which is a poor experience because you need to write types *everywhere*) * lose information by transforming that type to `string | atom -&gt; string | atom` which is even worse because now you want to call that function with only atoms `string = convert_back_and_forth(:atom)` and the type checker will force you to add an unnecesary check if that string isn't an atom * or you may decide to not type Erlang functions at all so that you call your language from Erlang but not the other way round I need to check Gleam more closely because I am still not sure which approach did the creators take or if they've found a fourth option.
Syntax doesn't matter, especially with a fast formatter :)
Gleam will take the route that most soundly typed languages take and will not permit overloaded functions like this one. If this was permitted inference becomes an undecidable problem, as you've said :)
Consider posting this over on /r/Rust seeing as the compiler appears to be implemented with it.
Thanks :)
Thanks for clarifying. If there is that strangely typed function from my example, it will become `string | atom -&gt; string | atom`. Gleam should be beautiful to describe the business logic of the application, and then the web interface and other parts could be in Elixir. Thanks for your work guys!
TypeScript handles such cases. You can overload function with different arguments and return types.
_Disclaimer: I haven't formed an opinion on your language or syntax, strictly replying to this comment ..._ --- Unless we can upload your interpreter to our brains, **syntax matters**.
I'm glad to know the project is moving forward. That's exciting!!!
You may highlight the link to GitHub repo a little bit more and maybe put it closer to the beginning of the blog post, so it would be easier to star the repo.
What specifically about the syntax didn't sit right with you? Personally I thought it looked really readable
To me, it looks like a nice hybrid of Rust and ML.
who made it?
This is a talk about Erlang not Elixir.
This looks indeed very promising! Love the syntax you’re going for. Very elegant. And big ups on calling for a friendly and inclusive community. One question: is the function capture functionality similar to partial application?
I really wanted to use Timber for a few projects that used Ruby (without Rails). I sent several support emails asking how to get hooked up, since their docs for Ruby weren't working as expected. They kept saying plain Ruby, but I think they meant Rails. I never received a response. I think their platform looks really great, but just wanted folks to be aware that their customer support wasn't up to par for me. In the end, we couldn't get things hooked up, so we gave up. I'm sure you'll be fine if you are using Phoenix, since it's a better-known-quantity than wild west Ruby without Rails, but I wanted to share my experience. Do any of you other fine folks currently use it? What has your experience been? I imagine it's really great if it hooks up as expected.
I used to work in a coworking space with them in Brooklyn, and they have a tiny team. Given the quality and capabilities that f their product, I was super impressed. I’ve used it on a Rails and Elixir project, and it was great. I’ve never tried with plain ruby though, butI could see that diverging from Rails focused docs. Might be worth reaching out to someone specific there.
Sure, but getting a syntax that is understandable isn't hard. Going from understandable to "beautiful" is just personal taste. &amp;#x200B; Today I have received multiple messages saying that Gleam's syntax is hideous, and multiple messages saying that it's delightful. This isn't a battle you can win, so move on. It doesn't matter :)
In some ways yes. It achieves much the same result as partial application does in ML languages, but it is more explicit as you have to specify where the argument will go. If used with the pipe operator the compiler will erase all the intermediate anonymous functions so that there is no overhead to its use.
It is a problem for inference, this is one of the reasons why typescript requires annotations in many places and why it is unsound by default. Gleam is sound by default and requires no annotations.
I did!
I'm glad you mentioned this, it caused me to take a look at the docs to see if they've changed since January, and they certainly have. It's now clear and sensible to set up without rails, and has explicit sections separating Rails and Ruby.
This looks like a great book to level up your Elixir system design. There's 6 chapters currently and price seems pretty reasonable for it.
That’s brilliant if it could be used to handle side effects in the way that partial application can be.
Is there any coupon code ?
Hmm, it seems like you are saying that [multiple dispatch](https://en.wikipedia.org/wiki/Multiple_dispatch) (function overload one of its form) cannot be efficiently implemented with typed language. So instead of letting the computer do the dispatching job the burden put on human, and instead of short and compact expressions like `is_empty(list) is_empty(map)` people have to write `List.is_empty(list) Map.is_empty(map)`.
**Multiple dispatch** Multiple dispatch or multimethods is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time (dynamic) type or, in the more general case some other attribute, of more than one of its arguments. This is a generalization of single-dispatch polymorphism where a function or method call is dynamically dispatched based on the actual derived type of the object on which the method has been called. Multiple dispatch routes the dynamic dispatch to the implementing function or method using the combined characteristics of one or more arguments. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If you're already a customer of pragprog, usually there's a coupon code at the end of a book ;)
Elixir does have this, see protocols :) &amp;#x200B; Gleam does not have this currently though research is being done into an OCaml style implicits system which would enable it.
Can anyone point in the direction of the Elixir wallet management team please
No, it doesn't have it. Elixir has something with limited capabilities called **protocols.** As for the true multi-dispatch - you can't define two methods \`is\_empty(list)\` in module \`my\_list.ex\` and \`is\_empty(map)\` in \`my\_map.ex\` and then **import both simultaneously** in your \`app.ex\` and use like \`is\_empty(whatewer)\`. And here's the answer from the elixir issues itself [https://github.com/elixir-lang/elixir/issues/192](https://github.com/elixir-lang/elixir/issues/192)
Check out elixir forum. there is a coupon code there for 35% off.
Bought it thanks a lot :)
Gotcha :) Thanks a lot :)
r/elixirtoken/ ?
I done something that I think can’t be changed but want to ask the question anyway This was question I needed to ask Good morning sir, I was wondering if you could help me please. I recently bought some Elixir via coinswitch, and then the following day I bought Pundix, but I put the Elixir address that coinswitch used to send to me as the recipient address for the pundix, I know they may sound a little crazy but I believe the pundix I bought are now sitting in the Elixir wallet (owner I believe may be Elixir) what I’m looking for is a contact for the Elixir wallet email or twitter #. Thanks in advance James Geraghty
What's the limitation with protocols? The behaviour you've described is achievable with them today.
I done something that I think can’t be changed but want to ask the question anyway This was question I needed to ask Good morning sir, I was wondering if you could help me please. I recently bought some Elixir via coinswitch, and then the following day I bought Pundix, but I put the Elixir address that coinswitch used to send to me as the recipient address for the pundix, I know they may sound a little crazy but I believe the pundix I bought are now sitting in the Elixir wallet (owner I believe may be Elixir) what I’m looking for is a contact for the Elixir wallet email or twitter #. Thanks in advance James Geraghty
Wrong elixir, this sub is about the programming language.
Uh, James old boy, this is still the wrong subreddit. We don't know squat about your shitcoin; you want /r/elixirtoken
Here's a sneak peek of /r/elixirtoken using the [top posts](https://np.reddit.com/r/elixirtoken/top/?sort=top&amp;t=all) of all time! \#1: [2,000 upvotes and I'll donate 10,000 ELIX](https://np.reddit.com/r/elixirtoken/comments/7qap65/2000_upvotes_and_ill_donate_10000_elix/) \#2: [If this gets 2k upvotes by the 25th, I'll give away 10k ELIX](https://np.reddit.com/r/elixirtoken/comments/7kbvnz/if_this_gets_2k_upvotes_by_the_25th_ill_give_away/) \#3: [If this gets 1k up votes, I'll donate 1k elixir](https://np.reddit.com/r/elixirtoken/comments/7h9afy/if_this_gets_1k_up_votes_ill_donate_1k_elixir/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
It can happen
I mean, sure, it _can_ happen, but you'll make it much more likely to happen by posting your question in the subreddit that's dedicated to this particular separate-fools-from-their-money scheme, instead of in the comments of a random and unrelated post in a completely unrelated subreddit
Thanks for you kind advise. Have a great day.
Hello everyone, I've just published a tutorial that could be interesting to beginners and more confident developers . There is plenty of detail here you can find useful. In this step-by-step tutorial we see in depth how to build a Phoenix app from scratch, letting users upload their files using a multipart form. We learn how to easily run PostgreSQL with Docker, to receive uploads using Plug, and how to use Ecto to store upload details into the database. &amp;#x200B; As always any kind of feedback and question is more than welcome! 💜 &amp;#x200B; Alvise
Room/1, Room/2, Room/3
Haha we rejected a suggestion that's remarkably similar to that already! 😂 https://twitter.com/CodeBEAMio/status/1118534228906586113
You can now buy the beta ebook for this [https://pragprog.com/book/jgotp/designing-elixir-systems-with-otp](https://pragprog.com/book/jgotp/designing-elixir-systems-with-otp)
Waw, this is awesome!!! :D
I'm writing an RSS reader, and trying to carve out some time to help with the [`jsonapi`](https://github.com/jeregrine/jsonapi/) library. It's definitely the hard way to learn Elixir, but it's rewarding.
Well good luck to you but I'm useless there.
Too complicated and this feature is not a first class citizen for the language? I don't want to write protocol for every new function. No way to override stdlib functions (although not sure about it, maybe it's possible)? So nobody actually uses it the way multi-functions supposed to be used and instead write verbose \`Enum.map\`. They say language has a feature if it's easy and efficient to use. Otherwise you may say that Java always had lambdas (as anonymous classes). But in reality no - Java didn't had lambdas, nobody in the right mind would use anonymous classes as lambdas are used in JS or Ruby or other languages. And the same with Elixir protocols, it does something, but not quite the same what multiple-dispatch does.
Is the result of this tutorial something that can be safely run in production? &amp;#x200B; I ask because the hardest part about learning how to make sites/apps is finding tutorials that go all the way without taking some insecure shortcuts.
It depends what you mean by *safely* and what app you need to build and what you need to protect. This tutorial shows how to quickly build something that works and you can start with. Safety can be also based from the layers of authentication, authorisation or encryption you put on top of this. But again, it really depends what *safety* means in your case. Do you need to handle uploads in a phoenix/elixir production app? If yes, can you please tell me a bit more?
This teaching things in a "not suitable for production" way is a major pet peeve of mine. It amounts to someone showing how to do something cool on the telly and then saying "don't try this at home". &amp;#x200B; If I spend 2-3 weeks going through a book or video course then I want the very next thing I do to be "turning one of my ideas into a thing", not spending several more weeks figuring out how to actually do things in a production way (testing, security, deploying, ...). &amp;#x200B; These days I am shifting more and more to just making things in whatever has great books/tutorials available instead of what I think looks like really interesting technology just because it is too frustrating for a hobby project to not have anything to show after a month or two. Basically, if there is great teaching material available then I will use a language/framework even if I don't particularly like it just to get something working before I get bored and give up. &amp;#x200B; So far the best tutorials/books I have found is: \- Fullstack React ([https://www.fullstackreact.com/](https://www.fullstackreact.com/)) \- Rails Tutorial ([https://www.railstutorial.org/](https://www.railstutorial.org/)) I really wish there was something like those for elm, elixir and crystal as I am super interested in tinkering with them.
I don't currently have an elixir app, but I am trying to figure out how to build this thing that I have an idea (and need) for. I guess my actual problem is learning how to build a server based web app. I have bookmarked the tutorial as something to come back to when I have figured out how to do user auth. &amp;#x200B; The Idea: Automatic pipeline for stock photos 1. Upload a huge collection of photos 2. Group similar photos (the result of getting carried away and being a bit too enthusiastic with the shutter button) 3. Select the sharpest (least blur) in each group (preferably the one where the subject is sharpest) 4. Tag the images 5. Name the images 6. Process "Enhance!!!" the images 7. Submit images to stock photo sites &amp;#x200B; ( 2, 3, 4 ) - I have this stuff working in a bunch of jupyter notebooks. ( 5 ) - Can probably be built out of "4" easily enough. ( 6 ) - Photo Lemur would be just about ideal for this and they have a cloud service coming along. &amp;#x200B; &amp;#x200B; ( If anyone beats me to making this idea then cool, send me a msg, but it must do more than just step 1 and 7 )
{room, _, _} = {1, 2, 3} {_, room, _} = {1, 2, 3} {_, _, room} = {1, 2, 3}
This is gonna be helpful, thanks!
I am improving. I would appreciate your advice. The Document is here. The explanation is only Japanese .I'm sorry. [https://qiita.com/sym\_num/items/6517bba0b3f18bc34f14](https://qiita.com/sym_num/items/6517bba0b3f18bc34f14)
You just completed my today task Thank you Thank you
Lovelace, Ellis, Turing
Having to write \`Enum.map\` isn't related to protocols, that's just because it's not imported by default. Thanks for the further explanation, I see what you mean :)
This is super interesting for me, because I'm trying to also make content for people just starting out with web development. I think Phoenix can make the like really easy for you. The web development with this framework is amazingly easy and forces you to follow some specific design patterns. The best way to fully understand the stack is reading the book written by the creator of Phoenix: [https://pragprog.com/book/phoenix14/programming-phoenix-1-4](https://pragprog.com/book/phoenix14/programming-phoenix-1-4) !
Elixir will not do well in this kind of computation. Rust has been a good go-to for these kinds of things for the Elixir community. A project called Rustler makes it easier to add Rust into your Elixir project. And the Benchee project will be better for getting benchmark times than your approach. Overall, math in the Erlang VM is abstracted to be the same as any other function call. Because this is actually a native operation for the CPU this means a lot of overhead per operation. Also I didn't check but if you misuse the linked list data structure Elixir uses that can significantly slow things down as well.
Done the survey and signed up for the newsletter. &amp;#x200B; Thanks for the book recommendation, I will have to check it out.
thanks a lot! :D
Seems like a good project for learning Elixir. I'm learning, too, and look forward to reading through your code more thoroughly.
I am interested in Rustler. Thank you.
Thank you very much. I am honored.
Probably not what you’re looking for but cool story anyway. I needed to verify signatures of RSA public/private keys when porting an old app that used them for verifying customer messages (on prem software). Turns out Erlang has the public_key module that does that very thing. Docs and interop were a bit funky but no external deps and I’m off to the races. Few weeks later I need to generate some of those very same certs to give out to clients. Just used ports to call out to OpenSSL and bam! Nailed it! OTP has all sorts of hidden goodies like that. I’m hoping to part of the Erlang ecosystem foundations efforts on documentation can make some of the core OTP libraries more easily accessible.
As it was said earlier - just read OTP docs and you will see a lot of useful stuff, ex.: - system monitoring tools (CPU, disk, and memory utilisation) - alert handler - arrays - queues - graphs - OpenGL - wxWidgets - leex/yecc - ssh server/client - ftp
I'm still deeply uncomfortable with LiveView. To me it feels like a return to the days of X11, thin clients, and mainframes, but in an all around more cumbersome architecture.
Would it be completely incorrect to think of this as PJAX over Websockets?
Maybe those ideas weren’t bad. I don’t know too much about the issues x11 devs had to face, but maybe the concept behind it was sounds, just the tech ecosystem wasn’t mature enough to properly foster said concepts.
X11 arguably worked better than any demo of LiveView I've seen. It ran just fine over fairly slow connections, to thin clients that had barely more processing power than your average HD display does. The problem is this is a movement that seems almost counter to the benefits gained from BEAM. Beam makes distribution easy, so you can spread work out as far and wide as possible. LiveView does the exact opposite, it couples what is by far the largest pool of computing power to a single or small number of servers, effectively throwing away all the computing power the distributed cluster provides. ---- More simply put, if you have a million users, and they connect to your system, do you want a cluster of a million nodes able to do much of the processing they require on their own, or do you want to route everything through a single node that has to manage everything?
Hey, thanks for your work, I'm leaning towards Elixir those days for our work and your repositories help us see a progress curve.
&gt; More simply put, if you have a million users, and they connect to your system, do you want a cluster of a million nodes able to do much of the processing they require on their own If I am having a million users, I am not using LiveView. But if I am building software that is going to be used inside my company or by tens of thousands (or even hundreds of thousands of people if it is spread throughout a month), then I would rather use LiveView and improve the maintenance and usability of my application than deal with the complexity of pushing all of that logic to the front-end. &gt; or do you want to route everything through a single node that has to manage everything? It doesn't have to be a single node. And this is a conversation completely orthogonal to the BEAM. If the clients were actually running BEAM or if we could use BEAM abstractions or if we could use BEAM languages, then I would absolutely have no issue writing said code to run in the client. But alas, our choices on the front-end are still limited and I am glad to see a different approach.
In a way, yes. But keep in mind you are also getting stateful connections, server pushes and the error recovery mechanisms too.
I guess it will depends on the project. It's rendering diff html serverside, so in a way it will replace many api/json calls.
I'm glad if it helped.
The main issue with X11 (as I see it) is that the communication had to be standardised, which meant that the protocol grew and grew in complexity. It ended up with an enormous amount of obsolete cruft from a different generation of technology, and couldn't adapt to modern requirements. In this case, both ends of the link (server side and client side JS) are controlled and can move in step so there's no compatibility issue. Fundamentally the web always *was* a thin client, with a server doing all the work, providing a visual description and letting the browser just render. We've moved away from that recently with SPAs, but not always for good reasons. LiveView gives us the option of returning to that mode of operation - where its beneficial - but still being able to provide the interaction behaviours users now expect.
DM me. I'll buy it for you
I just made some more research recently. Happy to present you the list of cool **websites built with Elixir/Phoenix**! Have you heard about some more examples? [Financial Times, bet365 and other top websites built with Elixir/Phoenix](https://prograils.com/posts/top-websites-built-with-elixir-phoenix?utm_source=reddit&amp;utm_medium=referral&amp;utm_campaign=elixir-websites-2)
We're not entirely in Elixir but have significant use of it for microservices at SalesLoft. We ship at least 10 apps on it which are critical to various features of the app, including several backbone type services. We have Ruby legacy monolith which I don't foresee going anywhere as the amount of code is quite large.
I spoke to him on Twitter when I bought mine, he said it was already on discount, used to cost 60 dollars
I agree with this sentiment. There are 2 additional considerations I'd like to throw in. The first is, it's not necessarily about how many user an application has but how many *concurrent* users an application experiences. Obviously the correlation between users and concurrent users is related but depending on the application its probably not linear. Even if you have 100,000 active members, how many of the are actually online at the same time? Sounds like a a good use for phoenix presence. The second point I consider is inline with what you mentioned about the software maintenance and dealing with complexity. Because liveview uses the same template language and is elixir all the way through, it makes it extremely easy convert a page to and from liveview. For the paranoid, IF your app grows beyond the system limits and scaling is not an option it would take minimal effort to go back to a standard pageview.
Using the 2 together would make for a really smooth user experience.
Elixir powers our new backend: [Daivergent](http://daivergent.com/). Specifically, we're using Commanded and Phoenix to deliver multiple event sourced web applications and backend services.
Hey guys, wrote a little post on how to use Citext for email/usernames. All feedback is welcome. Hope it's useful!
At [Fotomat](https://onfotomat.com) we run all our back-end services on Elixir. Our two main services are built on Phoenix.
Are you in Atlanta? I’ll take you to lunch if you are to pick your brain about Elixir
Spartan.com
not really html diff, if you look inside the code it uses some of the same optimizations the template engine uses to handle those very fast template renders in pheonix/elixir. The static parts of the html are just items in an immutable list while the values are zipped into the static items. The additional optimization they have done here is to only send the changed state data/variables over the line server/client side + ensuring the changeset to dom is a minimal set (dom diffing client side). &amp;#x200B; It really does seem very reasonable for certain sets of updates as long as you respect the main constraints: &amp;#x200B; * always connected OR acceptable lack of updates while disconnected (offline obviously does not work in this paradigm). * Accept that the additional load/requirements of always connected clients. &amp;#x200B; From a few playtests I have done with it so far it seems like the performance is \_very\_ reasonable. I did boot up a group of 30 EC2 instances running browserless docker with 20 chromium clients each against a pretty heavy test (100+ items being updated very frequently on a page) and was able to see \_very\_ fast results on the clients as well as no real usage on a tiny EC2 instance running the app. Doing something like this with a simple rails app with websockets and just brodcasting static json would have killed a much larger server. &amp;#x200B; My net so far is that I can see the place for this -- however it is obviously \_not\_ the only tool in your kit. just my 2 cents.
Recorrido.com has some parts in elixir, and some in ruby
&gt; not really html diff, if you look inside the code it uses some of the same optimizations the template engine uses to handle those very fast template renders in pheonix/elixir. To further clarify: it does an extra optimization which is to send those "dumb strings" only the first time. The client then keeps a copy of it and assembles full content on every render. Then we also track changes, so we do have two optimisations on top of regular template rendering.
It's not accurate to say the the FT if built with Elixir, it's predominantly Javascript and PHP. If you check their job ads there is no mention of Elixir, it is a very small part of their tech stack.
Bet365 doesn’t use elixir and Phoenix - they only use erlang in production
Did you consider storing the files in the database directly? Postgres stores files in a performant way (TOAST).
The creator of Erlang has left us.
Your spirit and legacy are never gone.
He was such a fantastic and approachable person. Hung out with him a couple of times at the mariners in SF and he was always so congenial. Such a loss RIP 🙏
What a legend. RIP Joe.
RIP, dear Joe.
Too bad he won’t spawn a new joe_server after letting it crash. RIP.
RIP, Joe.
RIP Joe. Always an inspiration.
really breaks my heart, rest in peace joe
Extremely sad news. RIP Joe.
Rest in peace.
RIP
RIP Joe, His contributions to the community are immeasurable.
erl -heart ...
Damn, RIP :(
This is devastating. RIP Joe Armstrong.
Goodbye Joe
No one really close to me has died so far and this is the first since my grandfather 30 years ago that has affected me in any real way. I didn't know him. But I learned Erlang (what, 10 years ago now?) from Programming Erlang, which I can see from where I sit here on my living room couch, tucked between Learning GNU Emacs and the edge of the bookshelf. It changed the course of my career and my understanding of how you could design programs. Object-oriented programming had left me cold and doubtful, and Erlang immediately captivated me with its functional but pragmatic approach. Since then, I've never stopped trying to write Erlang in every language. It doesn't hurt that, over the years, reading Joe's various public opinions and brainstorms and musings revealed a wry and unpretentious character who wasn't afraid to smirk in the face of popular wisdom but never came off self-righteous about it. How much of the last 10 years have I spent in silent contemplations of the implications of his ideas? Yet he never knew I existed. What a powerful reach. How strange.
Wow, I feel like I was _just_ reading his posts on Twitter. 😞
Just checking whether is the course worth it for someone who has been using Elixir for about 1+ year? Has been sitting on the fence for this course.
RIP Joe
In his honour make sure you watch his "The mess we're in" talk on Strange Loop if you haven't already. It's a classic &amp;#x200B; [https://youtu.be/lKXe3HUG2l4](https://youtu.be/lKXe3HUG2l4)
R.I.P.
I can DM you the topics covered if you want. In the course he builds a hangman web game. and it is targeted towards beginners.
That’s so sad to hear! I had him as a teacher at Stockholm’s university for one course and he inspired the whole class to want to be Erlang programmers! He was a great teacher and a even greater person. R.I.P
In the documentation it's written that: *Since* ***Individual*** *uses* *:global* *module, there is a common problem with* [*cluster splits*](https://en.wikipedia.org/wiki/Network_partition)*. In this case, each part of previous stable cluster will have it's own process, thus this process stops to be singleton. In current implementation,* ***Individual*** *does not resolve this problems for you, you should resolve them by yourself.* Couldn't you use the same strategy as [https://github.com/arjan/singleton](https://github.com/arjan/singleton) to automate it?
**Network partition** A network partition refers to network decomposition into relatively independent subnets for their separate optimization as well as network split due to the failure of network devices. In both cases the partition-tolerant behavior of subnets is expected. This means that even after the network is partitioned into multiple sub-systems, it still works correctly. For example, in a network with multiple subnets where nodes A and B are located in one subnet and nodes C and D are in another, a partition occurs if the network switch device between the two subnets fails. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The keyword here is \*\*cluster splits\*\*. It’s the situation when for example cluster of 10 nodes splits on 2 clusters with 5 nodes in each. Of course each half of a previous cluster knows nothing about another part - it thinks that it just died. In general, you need third-party sources of truth to deal with this situations. (Someone who sees the situation in general). &amp;#x200B; And [https://github.com/arjan/singleton](https://github.com/arjan/singleton) does nothing with it. Both packages only resolve situations, when the cluster is solid, but some nodes are adding or removing from it.
 [Goodbye Joe](https://ferd.ca/goodbye-joe.html)
If you give up when things become too difficult, you are giving up too fast. That struggle you feel is just your brain trying to protect you from feeling failure, but it is necessary to push through that to really learn anything complex. I can't emphasize this enough. Learn to embrace that struggling feeling and reframe it as your brain changing to adapt to a way of thinking it has never felt before.
Daniel Azuma gave a really great talk about using Elixir in Docker last year at ElixirConf. https://youtu.be/nLApFANtkHs
Actually I didn't. But it seems interesting. Never tried TOAST, have you ever used it in production? I usually prefer to avoid to use db for files/large blob and maybe use AWS S3 or some other cloud storage (which at the end are cheap). The DBs I deal with are in cloud machines replicated over multiple availability zones and the traffic between zones is charged (aws in my case).. so many times I opted for S3. can you please tell me a bit more about toast and how it deal with replication? really interested! :D
I've found "use" macros really destroy readability. I have no idea where something is coming from, and it can be multilayered. A macro for a new function, like implementing "when", is a nice idea. Using them to import a bunch of stuff and using functions from those imports is very confusing. To add to that, some things are seemingly globally available -- like HTTPoison in my phoenix-based project. I never imported it, it's just there and usable. I don't think I've encountered something like this before, coming from haskell/python/typescript/clojurescript land.
Looks like it's pretty much standard Elixir/Phoenix project, but with very chaotic code organization. Some things are organized (like plugs), some is not (like models). Maybe that's the reason.
https://github.com/lukego/blog/issues/32
I dunno, I find angular codebases to be "basically impossible to deconstruct"
Truly sad news. A warm, witty, inspiring, mischievous man.
&gt; I have no idea where something is coming from, and it can be multilayered. I like using `__ENV__.functions |&gt; Keyword.keys` after "using" something when I need to figure which modules have been imported. If you like using IDEs, they show from where the imports come from too. &gt; To add to that, some things are seemingly globally available -- like HTTPoison in my phoenix-based project. I never imported it, it's just there and usable. Once you add a dependency, its modules are always available. It is not like Python/Clojure/Haskell where things have to be explicitly imported before.
Hi all, I've been following the news about Phoenix LiveView with some interest. As a new Elixir developer with a distaste for JavaScript, I found the premise to be quite interesting. Here's an example application which renders some user submitted Markdown using Phoenix LiveView. You can find the code for the application here: https://github.com/nickdichev/markdown-live I'm not sure if I'll keep developing it, I might add some small features in the near future. However, I want to finish up some work on my remote syslog library and release that first!
I haven't had much of a problem, I find they are generally much more well organized than any java spring project I've ever worked on (for example)
That's a great application of live view. Any blog posts that really got you kick-started on it?
Thanks for looking! I started by following [Dennis Beatty's blog post](https://dennisbeatty.com/2019/03/19/how-to-create-a-counter-with-phoenix-live-view.html) which gave me a basic understanding for how LiveView works and how to get up and running with it. The programming model is really simple! I was also using [Chris McCord's example repo](https://github.com/chrismccord/phoenix_live_view_example) along the way when I got stuck on some things!
Awesome. Thanks for the links - that's super helpful. I've done a bunch of rxjs for client side, but would definitely prefer to explore the full elixir route.
Thanks for the tip, that looks pretty handy. Is there a reason it does globally available dependencies? I'm not too learned with its choices (maybe erlang does the same thing?)
Yeah, at least Elixir has immutable data. Ruby for example is much harder for this reason too.
yea immutable data really lends itself to making things easier for future readers. Especially when you start pipelining, things are fairly clear. With other languages often the hardest thing to figure out is how the data is changing both externally and internally. Looks like the organization of this specific project is bad, but I wouldn't say most are like this
Modules from deps will be loaded on startup, that's why they always be available in global namespace. Same thing for Erlang. I guess, you can look at [https://hexdocs.pm/elixir/Code.html](https://hexdocs.pm/elixir/Code.html), maybe that will be useful, if you're looking for on-demand library loading. I'm not sure tho.
Good look, I was thinking it was inherited from erlang since it's odd behavior. I'm not looking for anything tricky, just understanding better why dependencies are global and you've helped in that, so thank you.
I was always too intimidated to contribute to existing open source Java and .NET code bases because I couldn’t understand the code. Not so with elixir. After a couple of years with elixir I have been able to get patches into the std library and many open source projects whenever I encountered bugs. Just browsing the /deps directory to understand how things like Phoenix work was so nice compared to other languages.
R.I.P joe
I'm writing a Headless CMS call Akeph, [https://gitlab.com/amacgregor/akeph\_cms](https://gitlab.com/amacgregor/akeph_cms) more than anything to scratch my own each and practice some elixir skills, one interesting approach I'm taking is around the use of Context and how I'm trying to follow the guidelines stablished here [http://devonestes.herokuapp.com/a-proposal-for-context-rules](http://devonestes.herokuapp.com/a-proposal-for-context-rules)
Something like this would be so helpful for new Elixirers https://www.youtube.com/watch?v=FEFETKhhq8w Like walk through the Phoenix library and explain how things work and fit together.
Looks like the link is dead.
Still working fine for me, what are you seeing?
"This site can’t be reached. **schneider.dev** refused to connect."
Hmm, strange. It's just static HTML hosted on Netlify so there's not a whole lot that can go wrong. Maybe some sort of transient DNS issue?
Link's fine with me. Thanks op, btw, I like the introductory sentence : &gt; If you’re anything like me, at least 3 or 4 of the keywords in the title of this article fall under the category of “things I’ve been wanting to play with but haven’t gotten around to it yet.
&gt;To add to that, some things are seemingly globally available -- like HTTPoison in my phoenix-based project. I never imported it, it's just there and usable. To clarify, modules do not need to be imported in Elixir. All modules from your application and its dependencies will always be in scope.
&gt;In general, you need third-party sources of truth to deal with this situations. This isn't true. There are multiple approaches to tackling this problem within a cluster. The one that to me seems more immediately suitable to your library is quorum based elections.
Do you have to have the size of the cluster known in advance to make quorum based elections work in net split? If I had 2 clusters of 5 nodes couldn't they each come to quorum for their own leader?
Honestly I think a lot of people just make too much use of convenience features that come at the cost of readability. Some of that I think the language encourages too much, and some is developers being in love with reducing lines of code. For instance: * Dropping brackets when calling a function and passing in a list. Convenient but now items look like individual function arguments. * Using macros in general. There are times where they're necessary but mostly they're just going to confuse people. * Using language shorthand in general (in any language) is like trying to show your friend how a program works but you only use hotkeys. Hard to follow if you don't already have them memorized. * There are often a few syntactical ways to do the same thing in elixir, which makes for variety in styles and opens up avenues for confusion due to unfamiliarity with that style. E.g. using When a lot vs the usual conditionals. * Importing is used way too heavily imo, aliasing is so much more readable and barely any extra characters. Some cases call for it but most don't. As usual, it's up to devs not to write confusing code.
Is it a remote or on-site job?
&gt;Using macros in general. There are times where they're necessary but mostly they're just going to confuse people. For example, "use genserver" is necessary for most projects. But every thing that you use like this requires the developer to understand it in their mental mondel. Realistically, in order to be an effective Elixir developer, you need to carry around in your head an understanding of 5-10 common macros like genserver, agent, genstage, etc.
If you have 10 nodes then 6 is the size of your quorum majority, not 5. The equation is \`truncate(num\_nodes / 2) + 1\`. Typically odd numbers are used because it's more efficient in that you can survive an extra node loss without having to use a larger quorum.
Definitely agree. The problem is that every time a developer adds a new one, that's extra knowledge the next person has to sort out and then retain the entire time. Best left for the edges of the language that need it (ecto, genservers, etc) than for some extra convenience on an average project.
Thanks, makes sense. One challenge I'd have with this is autoscaled number of nodes in kubernetes. I would either have to reinject the env containing the number of nodes or use the k8s API to get that info.
From my experience these kinds of systems tend to have a static number of nodes. I'm afraid I don't know how it's handled when the cluster sizes changes frequently :(
No worries. I think you're right that it would be very common to have a static number of nodes. Our Elixir nodes are pretty small (1vCPU credits, but still parallel + 1GB RAM), so we do a bit of autoscaling. I know that k8s has an API which allows for inspection of the cluster (used in https://github.com/bitwalker/libcluster/blob/master/lib/strategy/kubernetes.ex). This could be used to provide dynamic information in a system that truly needs it. I'd sooner just set it static and slightly over-provision and not deal with the hassle.
Hi, this is on site.
Perhaps `promo_code_id` needs to be added to the field list for the changeset
Why client side rendering for an app like this? Could be a good addition to the post. Also, check out dataloader! Ben Wilson's Absinthe book covers it well and it makes it much easier to avoid n + 1 query problems.
The reason why Elixir excels at TDD is that it enforces immutability and testing pure functions is straight-forward.
I see, and it's a good point. However, and being the devil's advocate here, you can also get this with other modern tools (not enforce, though).
Having issues with Ecto Associations? No way!
On the `recipes` schema, you have the incorrect association set up. The "belongs to" should always be on the schema with the foreign key defined on it. ``` has_one :promo_code, PromoCode ```
I am working on a Home Automation System called Drew. It is in early stage but I can control my ZWave roller shutters and create basic scenario. It is deployed on a Raspberry Pi3 via nerves. https://github.com/laibulle/drew
I was recently redeploying an old Elixir app of mine and needed to set up edeliver from scratch again. &amp;#x200B; Instead of just running the commands on the digital ocean droplet I deployed to I instead created this Dockerfile to make edeliver enabled images with your ssh key preloaded.
I went over deploying from a docker container in Gitlab CI/CD here: https://youtu.be/-mm44ADU3kc Works well for me, YMMV.
Maybe this [article](https://coletiv.com/blog/many-to-many-relationships-with-ecto/) about ecto associations might help, it is mostly focused on many to many relationships but still could have hints on the way *put\_assoc* works.
I find it much easier than mature ruby and or rails projects. immutable data and function piping makes deep diving through logic very easy (an editor with fzf + ag integration or built in deep project searching ++). Ruby on the other hand can take dozens of painful steps to figure out where all of the inheritance/injection or mutations occur because they often are not "ordered". One thing that can derail this for me in elixir apps is nonconventional organization of the source though -- which i guess is to be expected on a "newer" language where idioms are still kind of in flux.
There are a few things you can do. First of all you can just run it in its own elixir process, that may or may not be fast enough. If it is not you can use a NIF with a dirty scheduler, or a port to call out to code in C or some other language. Be aware that what appears fast under light load in terms of C code may do really badly under heavy load.
How complicated would you say it is, to learn Elixir when I only ever programmed in Java, Python, etc?
Does anyone now how many chapters are already available?
Learning Elixir is so much fun, that it feels like a short period. But, it will take some time figuring it out everything it has to offer.
Elixir is pretty much about data routing, I mean if you have a ton of data producers and consumers, like chat users or web clients which make a lot of requests running simultaneously, Elixir is might be good call. From the other hand, if you have relatively low number of events and/or CPU-heavy processing for each of them, better look for another language. All solutions you have, like NIFs, dirty schedulers, ports — all of them is kinda crutch. I mean, it will be trade-off between potential speed up and loosing reliability and convenience. Another possible solution is to build service using maybe MQ bus and workers on Go or Java or Python, and move all hard work from lightweight Elixir frontend.
the basics are pretty easy, the concurrency model takes some getting used to, but it is not hard. Feel free to message me zach@elixirtraining.org
First, don't assume you need to use another language. Prototype it and see how it performs in Elixir, you might be surprised. Using all Go will make things more difficult for all the common place things you need to do. While making something fast might be a bit easier. Instead, I would recommend building an Elixir project using the Rustler elixir package to call a Rust library. Using C or something else is extremely dangerous, so you need static typing and as much concurrency protection as you can get to avoid crashing the VM, which Rust provides well. But don't do any of this until you've prototyped it in Elixir. At the very least you'll be able to use it as a baseline to justify the complexity of utilizing another language to the project.
It really depends on what the task is. For raw numeric stuff, it’s probably not worth it. However for certain text/binary processing problems elixir can be _very_ fast. There’s also the question of “how fast does it really need to be?” Will this really be the bottleneck of your application? For a pretty big array of applications, network or disk io are much more time consuming and elixir will make optimizing that a joy. I once built an application that ran thousands of Kalman filters. This involves a little bit of linear algebra and for sure something built on a good numerics package would have executed that particular bit of the problem much more quickly, but it didn’t matter because that was by far not the bottleneck in the system. On the other hand, elixir made it a breeze to reason about a system operating on thousands of events concurrently.
You'd definitely need to tell us what you mean when you say CPU heavy, because what you mean by that may not mean what people trying to answer your question mean by that. When people say Elixir isn't good for CPU heavy stuff they generally mean the kind of thing you'd generally only do in like C/C++, like video transcoding. Go is faster than Elixir at some tasks but they're very much in the same order of magnitude, performance probably isn't a real reason one would pick Go over Elixir in the way that it would be a reason to pick C over Elixir.
Why is C "extremely dangerous" compared to Rust?
Elixir is fairly slow for single-threaded tasks. All BEAM langs are. But with NIFs or calling out to other commands, thats not really a problem. An app I'm working in has a simple [Nim](https://nim-lang.org/) program that handles a particularly complex but single-threaded task. Elixir spins up a new Task whenever the program would be invoked, calls it, and when it receives a response, sends some emails and does some other things. The Nim program is substantially faster than a native elixir implementation. If you have existing C libs, or can expose a C-style interface, NIFs are even better: https://andrealeopardi.com/posts/using-c-from-elixir-with-nifs/
Use Rust and the rustler package. It’s dead easy to overload your elixir functions with native binary replacements.
It’s not hugely different than JS, Ruby or python. There are traps: - functional, you recurse instead of iterate - concurrency is hard, even in Elixir. You can still get race conditions easily if you don’t manage the interactions carefully. - declarative syntax instead of imperative. You can and will have 10 functions in the same module with exactly the same name but matching based on the argument patterns (ie one matches a number and another matches a string, similar in concept to css.
As others have said, unless you’re absolutely sure this particular thing will be a bottleneck, don’t sweat it. Premature optimization is the root of all evil.
* A multiplayer browser game in Phoenix. Simple adventure game based on Phoenix channels - trying to create a main engine and a few different sub-games that can use it. * Contributing to ExDoc - I've recently contributed ExDoc autocomplete and keyboard shortcuts. Now exploring some extra features/ideas. ;)
Building something from scratch for the next three weeks. I didn't yet choose what to do. My goals are testing LiveView and some UX/UI stuff.
Hey I'm sorry, I did not see your message until now. However, I've done a full survey that you had sent to me by email. Cheers, Mat.
Next week I'm doing a live coding session with a colleague to introduce ruby developers in the company to Elixir and LiveView.
Still chugging along on [enigma](http://github.com/archseer/enigma), a rust based erlang VM. Currently working on a regex implementation (it's one of the prerequisites for the logger to work -- need [SASL reports](http://erlang.org/doc/apps/sasl/error_logging.html) for debugging).
&gt; Looks like it's pretty much standard Elixir/Phoenix project, but with very chaotic code organization. Hey mate, can you give an example of how to improve that codebase? If it's not too much work? https://git.pleroma.social/pleroma/pleroma
[Hound](https://github.com/HashNuke/hound) may do what you want.
I'd start with that steps: * Cleanup `lib/pleroma` dir by moving all but main module into appropriate dirs, like schemas, services like `mime` or `formatter`. * Cleanup some modules by breaking it into files, one module — one file (like `gopher/service.ex`). * Rename and rearrange some dirs. I like Rails-style code organisation, when you almost always know where to find code you need. Speaking of pleroma, it's will be better to move all service-like modules into service dir. After that I'd have sat down and thought about `web` directory.
I was curious myself. That's why I figured out, maybe I will see how it's implemented in another language, for example in Python. [https://github.com/python/cpython/blob/3.7/Lib/webbrowser.py](https://github.com/python/cpython/blob/3.7/Lib/webbrowser.py) I found this. Turns out, they do it using shell. In Linux/(probably in macOS too) systems, you can do it: \`System.cmd("google-chrome", \["[google.com](https://google.com)"\]\` or \`System.cmd("firefox", \["[google.com](https://google.com)"\])\`
On osx, I'd recommend using `System.cmd("open", ["https://google.com"])` to open google.com with the default browser.
A webassembly runtime for BEAM languages! Basic demo: [http://hansihe.com/wasm\_proto2/](http://hansihe.com/wasm_proto2/) Project is called [Whirl](https://github.com/eirproject/whirl) and is based on my longer running [Eir](https://github.com/eirproject/eir) project. It works by compiling Core Erlang (which pretty much any BEAM language can be compiled to) to Eir, where optimizations/transformations are done, then lowering to LLVM IR, and finally compiling to WebAssembly. I'll be holding a talk about the work behind it at Code BEAM STO. ([Talk page](https://codesync.global/speaker/hans-elias-b-josephsen/#389eir-infrastructure-for-working-with-beam-code)
I found a reference in the postgres wiki https://wiki.postgresql.org/wiki/BinaryFilesInDB tl;dr it depends on your usecase, file sizes etc. I know is that storing a lot of files in the DB is problematic with MySQL. Queries without an index are getting very slow. Because every row including the blob is loaded into memory (https://stackoverflow.com/questions/9511476/speed-of-mysql-query-on-tables-containing-blob-depends-on-filesystem-cache). This may also apply to other SQL servers. Unfortunately I have never used cloud services so I can not say anything about that. If you find out something important to notice it would be nice if you could share it with me.
Still learning Elixir &amp; Erlang, converting more &amp; more internal small tools &amp; apps to decide if that will be our language for the next years. Almost sure of it, six months in.
I'm new to Elixir and still evaluating things. I'm wondering how this stack compares to just using a REST API as far as a solo dev experience. There were a few comments on the Hacker news post on this article about absinthe/graphql adding a lot of overhead unless you have a larger team. It seems like most of the tooling for Phoenix is based around using absinthe graphql. It just seems like a lot of layers. Does it actually make the solo dev experience better than a more basic setup? Hopefully that's not too generic, I mostly just do frontend stuff right now and had been trying to compare Phoenix and django for solo projects.
Why grey text on an off white background, with a skinny font? My eyes hurt from trying to read that.
hey, thanks for the feedback, sorry about that! I might look into changing it then. It's a wordpress blog without pro features, so the ways in which I can customize it are sadly fairly limited apart from switching themes. &amp;#x200B; I contemplated moving to jekyll/gatsby before but didn't want to lose comments + my history (I've had this blog for I think almost 8 years).
Firefox' reader mode is your friend
I finally finished up enough of an agile retrospective site built on Elixir with heavy usage of Phoenix channels to release a beta. I had previously built a similar site on Node and wanted to learn Elixir better while reducing variables by building a product I was already familiar with. It’s available at https://usemirror.io.
I completely agree! It's kind of like how the ease of writing a DSL was a killer feature for Ruby. It lead to things like a nice router syntax in Rails and convenient testing syntax. Regularly using these or other DSLs is almost inevitable, but feeling obligated to write your own DSL for every app would be a failure mode.
Have you installed pow.cx previously? It took over `.dev` (back before .dev was a TLD)
yes! i did install it recently and just deleted it along with its .pow folder!! :o
&gt;schneider.dev/blog/e... Awesome. Got pow off with \`curl get.pow.cx/uninstall.sh | sh\` and now I can access the link. Thanks! :)
Yeah, that's a good comparison (although I feel like writing Ruby DSL's is easier but I've done Ruby for way longer :)). I feel like it's with most new things, there's a hype and you use it everywhere and for everything (while we're at Ruby, think Metaprogramming and rails's dynamic finder methods) then you realize wait that's not always a good idea and roll back some of that. You learn when to and when not to use something.
You may not need GenServers and Supervision Trees, but you will use it somehow. Process A launch process B, linked to A — simple, primitive supervision tree. Process with receive loop and state inside that loop — simple, primitive GenServer. So it's just a matter of name. It would be more correct to say that 'you may not need to make bottlenecks with no reason'. GenServer is good, well-tested pattern, but you have to use it right. Same for supervision.
thank you :)
Thanks a lot for the references
This was it - thank you!
*We can even use the concatenation operator in a method signature, to see if a string is pre- of* ***suffixed*** *with a certain string.* It doesn't work for suffixes ;)
The singleton library uses the following stratagem as far as I remember: 1. Try to start a GenServer with a predetermined name and setting to global registration 2. If it works : :ok 3. If it fails, it is because there's already another GenServer started with that name in the cluster. Therefore: 1. Start watching the pid of the GenServer that succesfully started with that name (monitor) 2. When receiving a message saying that that pid is down, go to step 1. This uses the global naming feature of ERTS, and it's in my opinion very elegant. Not sure why it wouldn't work in your case?
If you have 2 computers in cluster, and loose the connection between them, everybody think that he is only one.
Ouch, thanks for pointing that out haha
The only way to do this is to write a for loop, looping 1 through the maximum prefix length you'd like to handle and the beam will try all those lengths until it matches one. Basically generating 1 through (for example) 100 where 4 below would be your `n`. def match(&lt; s :: binary-size(4) &gt; &lt;&gt; "foo")
In example 4 you pointed out that you could return is_admin, but I don’t think what you did is not only a better illustration, it is a better practice too. Whether you meant to or not, you’ve controlled for the possibility that the is_admin key is not present or that the value is a string, number, or null. In your code only the exact right thing will work which seems like the best course if you’re talking about admin privilege
Finally got it! So in a nutshell you need an external oracle to know whether there is another island temporarily disconnect from the current island in the cluster, or the current island is the whole cluster (or the other island is dead). What are the uses cases? Genuinely interested.
I am not sure if there a built-in way. If the `/:locale` is always the first part of the url, you could try checking if the locale is a path parameter and that it sits at the beginning of the url. If so, you replace it. Something like this: locale = conn.path_params["locale"] if locale &amp;&amp; String.starts_with?(current_path(conn), "/#{locale}/") do String.replace(current_path(conn), "/#{locale}/", "/#{new_locale}/", global: false) else "/#{new_locale}" end
Is there a playlist of all the ElixirConf EU videos? Have they been released yet?
There’s this playlist with all the talks, but the only public one is the keynote linked in OP. https://www.youtube.com/playlist?list=PLvL2NEhYV4ZtoiQC735NjHyPJUS_nmrxy
Oh i use to watch his conference videos and loved them all requescat in pace.
Too bad, would love to see other talks.
I agree. Working on a simple internal service for work in Phoenix which is simple. Boring is great! I don’t like pager duty.
Awesome! Glad you got it fixed!
All of them are private videos except one :(
Slides here: [http://s3.amazonaws.com/erlang-conferences-production/media/files/000/000/897/original/Tian\_Chen\_-\_Release\_\_deploy\_\_monitor\_and\_upgrade\_elixir\_services\_in\_real\_world.pdf?1524579824](http://s3.amazonaws.com/erlang-conferences-production/media/files/000/000/897/original/Tian_Chen_-_Release__deploy__monitor_and_upgrade_elixir_services_in_real_world.pdf?1524579824)
Development speed for Phoenix framework is comparable with Rails development speed, and significantly bigger then development speed for Go's stack. It mostly comes from the fact, that Phoenix is a framework, specially created for fast web development, while Go's http - is no more than standard library (which means no batteries). &amp;#x200B; Phoenix is developed and maintained by stakeholders, that has proven expertise in fast and robust web development (firstly in Rails), and thus the framework is mostly brings solutions for common tasks out of the box.
You confirmed my initial idea as I didn't find an idiomatic way to do it ! Thx ! :)
Having recently worked on projects in both Go and Elixir, I've tended to use Go for pure API backends as I love the simplicity of both writing the code and how easy it is to deploy, but Elixir and specifically Phoenix for anything where I know I'm going to have to build some HTML/JS/CSS frontend, because Phoenix does just give you a bunch of great tools and conventions for working with that stuff. If your project does have HTML/JS/CSS to manage I think you'll probably be faster with Phoenix as with Go (particularly if you are sticking with standard library like tools) you'll have to decide on **everything** for yourself: how to manage database state, how to organise your code, what templating system to use - heck you could spend a day just looking at alternative HTTP muxes. However there is a project called [Buffalo](https://gobuffalo.io/en) that does try to give you that "batteries" included experience but for Go developers. I haven't used it yet but it does give you that strong set of tools and opinions that you get with Rails or Phoenix, i.e. it has a required folder structure, a recommended tool for interacting with the database, a recommended template library, etc. etc. Might be worth looking at if you know Go already.
Unless you mention the requirements you have for the web projects, you'll just get general opinions which might not hold for your use cases. If you want the best development speed: determine the requirements, then pick the technology which best supports those requirements. For instance, if you pick Phoenix but you need to connect to an Oracle database (which Ecto doesn't support yet as far as I know), you're on your own. Depending on what you want to do a framework might even be complete overkill and only slow you down.
I'm new to elixir but experienced backend developer (python and c#). As far as I know Rails, much like Django in python ecosystem, it sacrifices performance over implementation speed and organization of code. With Phoenix it's the same? I mean, I know Elixir is extremely fast, but is Phoenix framework slower than a other framework with less resources (something like Sinatra in ruby ecosystem)? Or is elixir fast enough to make Phoenix give all this functionalities who save us time o during development and also being extremely fast?
Phoenix have next to none performance penalty above cowboy/plug's, And even that is what you'll want anyway, no matter the language - e.g. XSS protection
In comparison with Rails, which uses **reflection** for simplifying the development process, Phoenix utilizes **macros** mechanism. What’s the difference? The time when your abstractions becomes a real code. For reflection this time is **runtime**, which means that DSL converts into straight code for every request. For macros it’s **compile time**, which means that your code builds once - and then works fast. Thus the abstractions in Phoenix are more or less zero-cost.
I think they're just staggering the release, so it's good to bookmark the link now!
For last few weeks I was building an app connecting LUIS NLP API with Facebook messenger and (fake for now) business API, making this into a question-answering not demo. This was my first time with NLP APIs, so it was pretty exciting.
Plug only isn't half bad for API... I dragged my junior kicking and screaming out of Django flask - I had him write an API server that coordinates output to a client from an arbitrary number of GPU worker nodes, 45 lines of code, and he was like, "oh. I get it."
Great tutorial, I followed it all the way through!
Waited for that "readNameSet greater than 10" bug for a while, reported it too, started losing my faith in the Elixir support 😉
Without (hopefully) starting a holy war, can someone sell me on IntelliJ for Elixir dev vs. something like, say, VSCode?
Actually, aside from Jest, I can't think of other languages with the quality of Elixir's test tooling. They all have some issues: - Test runner is slow - Failure reports show too little info (e.g. hiding most of the stack trace) or too much (e.g. printing out entire contents of mismatching values in default text colour instead of red/green coloured diffs) - Other visual noise in the output e.g. printing out the names of all the passed tests–I don't care when tests passed ExUnit gets all or most of this right.
“If you do not have any real need for supporting high-loads with millions of requests processed by your app, then Elixir is not a tool you should bother using.” Why?
Especially with (elixir_ls)[https://github.com/JakeBecker/elixir-ls] it's pretty good.
Last time I tried, I found IntelliJ Elixir had a better debugging experience. For typical edit/test scenarios I like VSCode with ElixirLS and the incremental dialyzer support.
Do you ever have the language server stop providing code completion and function info drop-down? Seems to happen a good bit to be and only solution is to disable, reload, then enable again.
Yeah, that's happens sometimes. usually I have witnessed that after waking up from sleep mode. However for me, it works just by relaunching VS Code =)
Techempower benchmarks firstly need to be taken in context and even then with a big a pinch of salt. So the biggest flaw with this particular benchmark is that it is comparing frameworks using a full ORM vs those using raw SQL, which obviously is a pretty useless comparison when so much of the workload is those 20 SQL queries. Which is why if you look at the ORM column (second from right) there are a lot more 'raw' results in the top half of the table and a lot more 'full' in the bottom half. And on that note, Flask is a fine example of that, the only Flask results that are "faster" (about 10 positions above Phoenix) are the two that use raw sql, the fastest Flask result that actually uses a full ORM is down in position 274. Which shows what a difference it makes, then even beyond that it is not simply ORM vs raw, different ORM's have different design priorities so some place more priority on features rather than performance. Then you have another problem in that some of the benchmarks are using the same connection for each query, others are making a new connection each time (if I remember correctly Phoenix is the latter), so again you aren't comparing like with like, you would need every benchmark written in the same way, either all use a new connection or all use the same connection. And so on, like is each framework using the fastest JSON library that can, etc...
I use it because I also use IntellIJ for developing in Javascript/Typescript, and Rider for .NET Core. I use to use PHPStorm when I did PHP, and am just use to it now. If this didn't exist, I would probably use VSCode or similar. I really like IntelliJ Elixir DX.
&gt; (if I remember correctly Phoenix is the latter) This is both wrong and very false: 1. Phoenix do not have anything to do with the DB. It is just wrapper over Plug to provide support for websockets and nicer API for creating REST applications. So it has nothing to do with DB. Ecto is the DB layer most commonly used with the Phoenix, but this isn't the only one that is available. 2. Ecto is using connection pooling, so it neither use the same connection for all queries nor it creates new connection for each query. It uses connection pool, which mean that the Ecto starts some connections during application launch (by default 10, but in production you probably should bump that number) and uses them for queries, so with pool of size 10 you can have 10 simultaneous queries. Establishing new connection for each query would be too slow to be feasible. &gt; even using the same database (some using MySql, some Mongo, others Postgres) This is only part of the problem, as the rest is that not only DB is important, but the configuration is important as well. It is known that the MongoDB can be absurdly fast, but then there is almost no guarantee that you will be able to read that data back, and with proper configuration it became slower than PostgreSQL. Another thing is how the infrastructure for testing looks like? Does the DB is ran on the same machine? All testing happens on the localhost or maybe there is connection from the external machine?
Heck, it is even run in the [development mode](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Elixir/phoenix/phoenix.dockerfile#L13) with `phoenix_live_reload` enabled. Nothing strange that it is so slow, as it need to traverse whole FS for changes each time there is HTTP request.
&gt; Phoenix do not have anything to do with the DB... Erm, I know Ecto is the DB layer, but that goes without saying, just like it does for most of the frameworks here who use DB layers not part of the actual framework, hence I did not say it. &gt; Ecto is using connection pooling... I probably didn't put it very well, in part because I didn't want to write an essay. But what I was referring to was how in Ecto for instance it looks up the connection from the pool on each of those 20 requests, so you get the overhead from that lookup each time. Where as on some other languages they use the same single connection for all 20 requests which is obviously more performant. It is explained better here - https://elixirforum.com/t/is-ecto-slower-than-rails-activerecords/10572/33 .
hmm, that's interesting thanks - I haven't looked at using Plug directly. In my Elixir journey I'm still pretty much in the "just use Phoenix without too deep an understanding of what is going on under the hood" camp, but learning more is on my (enormous) list of things to try and understand a bit better
I rewrote some *highly* optimized activerecord based code in Elixir. Even my naive "ruby in elixir" version was faster. Once I made it idiomatic Elixir code, there wasn't even room for comparison, the Elixir version was WAY faster.
If you've ever used Sinatra, it's "basically Sinatra"
I recommend *The Little Elixir and The OTP Guidebook.* :)
Nice lineup
Maybe because it reads like it could have been written by someone that has never even opened up an editor or developed an app in elixir. I feel like I could write a similar article on haskel even though I have never used it.
We made the same experience when moving away from Ruby on Rails to Elixir and Phoenix.
Cowboy isn't very performant. Somebody was able to get almost ~3x performance increase here https://elixirforum.com/t/300k-requests-per-second-webserver-in-elixir-otp21-2-10-cores/18823 Another thing that could help speed up ecto in the DB benchmarks is to use the Postgresql extended protocol.
If you prefer video courses, check out [Alchemist Camp](https://alchemist.camp/).
Now everyone on the bus thinks that I find Nazi videos funny. Thanks!
You can filter the results to reduce some of these inconsistencies * Remove all raw queries: Phoenix **80/171** * Remove all raw queries, and only Postgres: Phoenix **31/56** * Remove all but Full ORM, and only Postgres: Phoenix **23/45** * etc And this is only for that particular benchmark OP linked (multiple queries).
Lol
this is so good. the hemorrhoid line
This is now in my top 10 funniest youtubes of all time.
I love the part where Hitler says Haskell land at the same time the text says Haskell land
Just tell them straight: "I'm not a fascist! I just hate functional programmers and think they should be rounded up and..."
Awesome! Anything you wish I had made clearer or that you'd like to see me focus on in a future tutorial?
I didn’t have any issues with the tutorial, everything came together great. I would really love a tutorial covering nested forms and associations (would be pretty Ecto focused). Would be pretty cool if a follow on tutorial afterwards then got that working with live view. Great work and I can’t wait for the next one!
I decided to break the monotony of my full time JavaScript work by learning erlang. Then ill learn elixir, and then Phoenix. Sound like a good plan?
After seven years of JavaScript, mostly server-side, I’ve just started with Elixir. I miss a few things, but it’s SUCH a relief to have a strong standard library and a stable build chain. Maybe learn Erlang _after_ Elixir and the Phoenix&gt;Ecto or Phoenix&gt;Absinthe&gt;Ecto stacks. That said, you might well find an early excuse to read through some Erlang if you drill down on any large package for long enough.
"Programming Elixir 1.6" by Dave Thomas book that can be had for free if you have an edu account is just amazing. I have covered around 66% of the book doing all examples and problems and I have started really enjoying functional programming in Elixir.
I learned Elixir then Phoenix. Just having done that, I can read Erlang code. If you start with Erlang, I expect it will give you a greater appreciation for Elixir because of what it brings that you would be missing in Erlang. There is no disadvantage to starting with Elixir. In fact, I've heard of JS people jumping right into LiveView (at least playing with it). LiveView is a new Phoenix library that lets you build responsive web pages (like React/Vue/Ember) but without having to write Javascript. You can watch a presentation about it here: https://www.youtube.com/watch?v=8xJzHq8ru0M
I can't stop laughing, you made a really great video!
You know it's done by a person on mostly his free time for free?
Heil haskell :)))))
In the last 6 months using Elixir, the plugin never did name suggestions correctly due to this error and only was showing plugin errors and did syntax coloring (thanks for that!). Every time I have to either go to Elixir docs or jump to the module in question. Would donate for the good stuff though, /u/KronicDeth feel free to add a tiny periodic reminder to donate, montly or one time donations, Patreon maybe.
Integer or incremental Id's can make it easier to guess a record id and thus easier to exploit. If you're wanting to avoid someone with malicious intent accessing records they're not supposed to, then a binary / UUID type key is a good idea. If you're transferring or referencing records between separate systems having a uniquely generated id can prevent key conflicts which is more likely to occur if both systems are using incremental integer ids. It's an unlikely scenario, and painful when it actually happens, but still very easy to mitigate by using binary/UUIDs instead.
The behavior of :id is dependent on the adapter in use. The main difference between :id and :integer would be the possibilty to use :autogenerate, most vasta you’d use them with primary keys. You can read a bit more about the types in the [original proposal on GitHub](https://github.com/elixir-ecto/ecto/issues/624)
So far I got great feedback on r/programming so I added a link
While kind of true your advice seems in the camp of "security by obscurity" which can become a false sense of security. Anyway the question wasn't about UUIDs at all...
You're right, I misread the question. Plus I should've mentioned that it's not an excuse for not having proper authentication and authorization anyway.
The document is here. It is only Japanese. I'm sorry. [https://qiita.com/sym\_num/items/e33099305b739094e70d](https://qiita.com/sym_num/items/e33099305b739094e70d)
why? Doesn't seem appropriate for what the language is good at
I feel the possibility of parallel processing. Matrix calculations are often used in DL. Elixir can easily write parallel processing.
The current implementation makes very little use of parallelism. I will replace it with parallel computation of matrix products by batch processing.
GPUizing matrix math might have better returns — dunno.
Efficiency is not the only reason to write in a specific language — expressiveness counts. Given the functional nature of Elixir, it might turn out to be much more suited to data analytic code than, say, Python which does neither OOP nor functional styles very well. I do most of my analytic coding in R because its functional approach is a much better at expressing math and statistics than Python, despite being the slowest (and among the strangest) language I've ever touched.
Dr. Yamazaki is researching using GPU with Elixir. It is called Hastega. When this is completed, it seems to be about 80 times faster than the current situation. I look forward to Hastega.
It might be obvious, but here you looked library code through? Also, you might use benchee in a specific way: go to "deps" folder and instrument the library by hand. It might be unhandy to recompile ferrous each tune by hand, but it might help.
I have been looking and tweaking the library code, but it’s hard to know what process is taking up so much CPU
Yes, exactly. I think Elixir can do well in this space if explored properly by the right people. Sure, the heavy calculations need to be NIFs, but while it's a big part of the performance profile it's just a small part of everything else that needs to be written. IFF python delegates to C for that same stuff anyhow.
OP mentions Hastega in another thread. [These guys presented at Lonestar Elixir and had a fun presentation](https://www.youtube.com/watch?v=lypqlGlK1So) As a community, we shouldn't discourage people from trying _different_ things in Elixir. In this regard I'll always accept **Because.** as a valid answer to *But why?*
Vim is a tool, EMACS is a way of life, IMO.
I’m a long time vim user and I’d recommend you learn Spacemacs. Reason being you get the best of everything.
There are a number of tools you can use to understand what a process is up to. A process with a growing message queue with reductions and memory increasing smells like an overloaded process. The simplest thing you can do to understand where the process is spending time is to just attach a remote shell to the process and call Process.info(pid, :current_stacktrace) a few times. This is a simple way to get a sense for what’s going on, is the process always in the same code, is it stuck in a loop endlessly allocating memory, or is it doing work but failing to keep up? Take enough samples and you can get an idea of hot spots. Next steps if that doesn’t reveal an obvious hotspot would be to utilize one of the built in profilers or tracers. Read the manuals carefully before using profiling / tracing on a node serving real traffic, they can be disruptive. Built-in you should have eprof and fprof available, eprof is pretty easy to get going. {:ok, _} = :eprof.start() :eprof.start_profiling([pid]) # wait a bit :eprof.stop_profiling() :eprof.analyze() :eprof.stop() Eprof will then give you a breakdown of all the calls that happened between start and stop, how much time was spent, how many calls, average time per call. Fprof is a similar setup process, in my experience fprof slows everything to a halt while it generates a massive amount of data, it’s not suitable for running on live systems, though ymmv. The :dbg module and the trace and trace_pattern BIFs would be your next stop as they can provide even more information about what’s going on. In a different direction, make sure to check the issues on the library and the documentation, this bottleneck might already be known / a workaround or sharding setup might already be available. Also opening an issue might be helpful, “I’m doing X, I see process Y that’s part of the library behave Z way” maybe the library author / maintainer might have an intuition of why the slowdown is occurring. It may also be possible to just use the library in a different way, set up one instance per scheduler and introduce some user-space sharding to take advantage of BEAMs easy to use parallelism. Without additional context though it’s hard to know if that would be possible in your particular situation. And if the process is truly leaking memory then setting it up shards won’t help, although you could potentially tune the spawn_opts or create a sweeper process that just calls :erlang.garbage_collect/1 on the troubled process on same interval.
\+ you can learn whole ecosystems of new languages while you wait for it to boot.
UUID's are not security through obscurity. UUID's have a very valid property where they are non sequential, unique and by their nature "costly to guess and or enumerate without additional knowledge". Incremented int ids have properties where they are simple, but also have properties that they are highly discoverable (it is very easy to brute force scan a given set). &amp;#x200B; There is a big difference between utilizing properties of implementations to your advantage and hoping that something being undocumented or opaque in implementation provides additional security.
I never said such thing. I commented the the comment above which I recommend you to read first.
Ecto has a right join. Would be something like this: `from(u in User, right_join: p in assoc(u, :profile_fields) where:` [`u.id`](https://u.id) `==^123) |&gt; Repo.all()` Or the other format: `from(u in User)` `|&gt; join(:right, [u], p in assoc(u, :profile_fields))` `|&gt; where([u,_p],` [`u.id`](https://u.id) `==^123)` `|&gt; Repo.all()`
I was trying to use the right join, but it is not available to preloads due to this line https://github.com/elixir-ecto/ecto/blob/306d5498924eddd015d292a8130c5d59176001ac/lib/ecto/query/planner.ex#L702. I notice your sample code doesn't use the preload function, is it not necessary?
Maybe you could blame the line which added this error. Maybe there’s a PR with more context into why it’s necessary.
Sorry about that was typing on my phone and forgot to add the preloads. I edited my original comment to have preloads. I just tested a right join using the first method above and it worked for me. If you are still having issues with it, why not use a left join. That seems more appropriate since you won't really have null user fields, but will have null profile fields (as in a user could sign up but not have configured any profile fields...is my guess). So you should be able to use a left join in this case.
Can the dynamic profile fields be a map (or json) stored in a single column with the rest of the profile? It may complicate queries involving those fields, but would more easily allow storage and loading of that data.
Hmm, I'll have to paste the code in here I was trying once I get home. My situation is a little different to the one you have illustrated though. I have profiles, profile_answers and profile_fields. I will be looking up a profile by its ID and then doing a left join onto profile_answers as there are potentially no answers in a new profile and then doing a right join from there onto the profile_fields as again there are potentially no answers and I want to show all of the fields regardless of being answered or not. I want to load the profile and preload the answers and fields. Does that make sense?
Wouldn't that mean duplicating all of the fields for every profile? It sounds like that would be a bit of a pain to add new ones and do updates to them?
[https://github.com/code-corps/stripity\_stripe](https://github.com/code-corps/stripity_stripe)
Ok, here's the code I am trying to use: Profile |&gt; where([u], u.id == ^id) |&gt; join(:left, [p], a in assoc(p, :profile_answers)) |&gt; join(:right, [p, a], f in ProfileField) |&gt; preload([p, a, f], [profile_answers: {a, profile_field: f}]) |&gt; Repo.all()
I was gonna suggest the above as well. Ecto has functions for working with a JSON/JSONB column in your postgres database. The syntax is slightly different for working with those columns but it is actually pretty easy. You can just fetch all the data from that column and as someone updates a field just map merge it with the entire payload of profile fields when you fetched it...would look something like this, which would be easy to iterate over and then update the entire map in a single go %{profile\_field\_key\_1: profile\_field\_answer\_1, profile\_field\_key\_2: profile\_field\_answer\_2, ...}
Hmmm...the structuring seems a little funny. Since the profile fields are dynamic (sounds like people can make up and add whatever field they want I would have Profiles has many profile fields and profile fields has an id, a label and a value. And that would be it. Then you would only need the left join and be done. If the profile fields are selected for each profile from a predetermined list of fields, like you created Name, Birthday and Favorite Color and you wanted to ensure people were only using these particular fields...but profiles could have many profile fields and many profile fields belongs to many profiles.....in that case you have a classic many to many relationship which has a specific way of structuring the data in the database where you typically have a join at table that sits between profiles and profile fields. Then you can use a joins\_through in the schema (aka model). The one weird part is you have values attached to the fields. So the Profile table would be (id, whatever, whatever), Profile Fields table (id, field\_label), ProfileProfileFields join table (id, profile\_id, profile\_field\_id). Normally only the interesting part is where to put the value of the field....because the profile fields table in this case is just your list of available fields and the join table just says which profile has which fields. I guess you could do another join table off of the profile fields table and then a profile fields values table...but that seems like a code smell...you could put it in the existing ProfileProfileFields join table as another column...but then that would be a little messy since the join\_through almost makes that table seem invisible...so that make not be a good solution. I think your best case is to do what another redditor mentioned and just do an unstructured JSON/JSONB column on the profiles table which is supported by ecto and you can even apply indexes and what not, its pretty solid. But it would be easy to manage, just fetch it as just another field on the profile and it would just be a map of key value pairs of labels and values for each profile field. And you could just map merge with updated values and then just write over the whole column. Would be much easier than all the garbage I mentioned above haha.
THANK YOU! Using eprof, I managed to find which function was taking the most time for execute - it kept growing in time. Found out it was because a string kept appending itsself onto itsself which kept taking more and more memory each function call.
Your middle paragraph is describing exactly what I have. I'm just trying to wrestle ecto into understanding it. profile_answers is my join table between profile_fields and profiles. The plan is to have a fixed set of profile_fields which can be modified in the future
No Also no
If you're interested in a good use case for elixir, I recommend looking into DNI, decoupled neural interfaces, it's basically asynchronous distributed training of layers in a neural model, it would be ideal IMO for the layer coordinator to be in elixir, since it's basically the actor model.
Yea typically the join table only has the IDs/primary keys of the two things you joining. In ecto just use the joins_through to describe the relationship in the model/schema and then that join table is basically invisible and you can just left join the table on the other side of the join table and pretend the join table isn't even there...ecto does it's magic and it looks like you are just joining the two tables together without the join table. Looks up a joins_through example relationship for ecto and should be able to find some examples. If not let me know and I can dig into some of my old code on my computer and see how I did it.
On official elixir web site u can find a plenty of books and video courses. [Here](https://elixir-lang.org/learning.html).
I'm still working on \[Gleam\]([https://github.com/lpil/gleam](https://github.com/lpil/gleam)), a statically typed language for the Erlang VM. The language has just hit v0.1, exciting times. It's wonderful to see 2 other Rust projects in here this month :)
This is very exciting! How does GC work with Whirl? I heard that WA doesn't expose the browser's GC so you'd likely be bringing your own?
Hi everyone! I'm sharing my first Elixir blog post! This post is the first of a series which covers an implementation of the Huffman algorithm in Elixir. The Huffman algorithm can be use to compress or decompress text. In the first post in the series you should learn what the Huffman algorithm is and understand the data structures used to implement it. You can find the complete source for the program [here](https://github.com/nickdichev/huffman-elixir) along with unit tests, typespecs, and a decent amount of comments! Please feel free to share any feedback you have! Thanks for looking.
Thank you. Please let me know the reference page about it.
Thank you for many reply. I also added backpropagation in batch processing. I'm experimenting with my own parallel operation matrix module.
Yep, that's right. In webassembly you have a fully linear address space, much like in real hardware. Luckily the fact that you can't have cycles in terms makes a really simple GC implementation possible, and I have a simple and fully functional GC implemented in Whirl.
Wonderful! Are you supporting processes? Do you attempt to determine the type of terms in order to produce more efficient code, or do you box terms in some fashion so their type can be inspected at runtime? (Or something else?) I quite like the idea of WASM as a sort of "run anywhere" universal format. Do you think this is a good goal? I presume it'd be a lot slower than compiling to native (at least in terms of boot times if we're starting V8)
Yep, processes are implemented and supported, but that demo is pretty much a vertical slice demo. In that demo everything has a term representation similar to the BEAM. I don't do any type inference or specialization yet, my focus has been on making something work so far. However, this stuff is definitely on the roadmap for the backing project, Eir. Possible, but the scope of Whirl is meant to be a POC for running BEAM languages in the browser.
Without looking, what are you using for user authNZ?
Please see similar project : https://www.aviacommerce.org/
long time (20 yrs) vim user, recently "converted" to emacs (via spacemacs, now using doom-emacs) here. I recently started learning elixir, and found that emacs has excellent support for elixir (alchemist.el, also lsp-elixir) It is quite likely vim also has similar support. BTW, what is your current editor of choice. I assume you already use it for your elixir projects. Are you unhappy with your current editor/IDE ? What made you decide to pickup one of these two ? (Neither are "easy") You may want to stick to that if you are unfamiliar with BOTH vim and emacs. (Just a suggestion)
We are also working on similar project: [Avia](https://github.com/aviacommerce/avia)
A lot of work went into this release, so here is a summary of the highlights.
Good stuff!
Great job sir.
Awesome work! Thanks for contributing to the community in such a big way!
Thank you! Much appreciated!
Nice, thanks. That sounds like you should most likely only use them with non-composite primary keys which you want to autoincrement/generate.
Looks good. I wish Elixir had a strong type system. I hope it becomes popular. PureScript is another one I’m following closely.
Elixir is written in itself, with only the first couple versions being written in Erlang, as far as I am aware.
how is that possible?
First, create Elixir compiler in Erlang. Then slowly replace the code base with Elixir (by using Elixir compiler made in Erlang).
https://en.wikipedia.org/wiki/Bootstrapping_(compilers)
thanks for the link. I understand now
Not entirely common for dynamic languages: believe Ruby nor Python default interpreters are written in C. I recall Matz once saying something to the effect of it helps him to write OOP logic in a language that isn't so OO.
Thank you. Have you seen the Purerl project? I know a company that uses it in production now. :) [https://github.com/purerl/purescript](https://github.com/purerl/purescript)
Nope, most of elixir "compiler" remains written in Erlang - parser, special forms, macro interpreter, bytecode emitter, etc.
Literally everything in src is erlang code. The only Elixir code is in the lib folder.
I've have explored video chat technology for a month, and one of the best solutions out there for video in the server side is [Janus Gateway](https://github.com/meetecho/janus-gateway) from Meetecho. They use the WebRTC technology to handle the video and audio, and it is on the server side. &amp;#x200B; You can find some demo examples [here](https://janus.conf.meetecho.com/demos.html), and [here](https://www.youtube.com/watch?v=-n5IlXBOaBE) you can find a presentation from Anil Wadghule about Building videochat with Elixir and Phoenix. He created a module to interact with Janus Gateway server. &amp;#x200B; About the second thing, detect nudity and blur it out, I can't help you with, but you can probably place that question in the [janus google groups](https://groups.google.com/forum/#!forum/meetecho-janus), they are very responsive and might help you there.
This isn't entirely accurate. The core of the Elixir compiler is written in Erlang. It is enough to compile simple Elixir programs and is used to compile the full compiler and standard library.
This is possible but isn't how the Elixir compiler works. The part of the compiler that actually does the compilation continues to be written in Erlang.
I agree, this does seem possible.
In case you've not seen, other comments have pointed out that this one isn't accurate. The Elixir compiler is written in Erlang, not Elixir. The tooling and libraries are written in Elixir though.
Good catch, thanks. Interestingly, it looks like some very early versions are written in Elixir directly (v0.5.0), but by v1.0.0 they had moved to writing the compiler in Erlang and it has stayed that way ever since.
It's fun to read the early Elixir code. It's pretty wild that it used to have objects and inheritance.
There is some literal bootstrapping of \`Kernel\` at the top of the file: [https://github.com/elixir-lang/elixir/blob/01175743b7b9462be3b207753d4a500fed215ee7/lib/elixir/lib/kernel.ex#L1-L7](https://github.com/elixir-lang/elixir/blob/01175743b7b9462be3b207753d4a500fed215ee7/lib/elixir/lib/kernel.ex#L1-L7). It loads stub versions of the \`defmacro\` defined in Erlang, so that it can define \`defmacro\` using \`defmacro defmacro\`: [https://github.com/elixir-lang/elixir/blob/01175743b7b9462be3b207753d4a500fed215ee7/lib/elixir/lib/kernel.ex#L4133-L4135](https://github.com/elixir-lang/elixir/blob/01175743b7b9462be3b207753d4a500fed215ee7/lib/elixir/lib/kernel.ex#L4133-L4135)
Looks nice, thanks for opening it! If you consider writing more posts would be interesting to see how it's compared with Rails [solidus.io](https://solidus.io) or magento.
You’ll need to figure out whatever the [Not Hotdog](https://itunes.apple.com/us/app/not-hotdog/id1212457521?mt=8) guys are using. But seriously, they used [TensorFlow on-device](https://medium.com/@timanglade/how-hbos-silicon-valley-built-not-hotdog-with-mobile-tensorflow-keras-react-native-ef03260747f3) to achieve it. This approach will be 1000% easier than trying to analyze the streams server-side. The serve bandwidth and processing power required would be immense and expensive.
Thanks! I've come to the conclusion that it only makes sense to do the analysis client-side and just provide a communication channel between connected users that tells a client when to blur their incoming feed. I'll check them out. Thanks.
You beat me to the Not Hotdog comment
Love your project but I have my reservations about using rust futures (or futures in general)
I love you both
Nice listen. José is always so well-spoken.
I setup elixir-ls separately + Language Client neovim &gt; let g:LanguageClient\_serverCommands = { &gt; &gt;\\ 'elixir': \['elixir-ls'\], &gt; &gt;\\ } &amp;#x200B; This seems like a way more flexibile solution :|.
 IO.puts("Hello! 👋")
I'm going through this right now and so far it's the most clear of them all. The concept I had a problem with was what on earth the /n means after a function's name. 😅 This was the only book to explain that it was the number of arguments. Somehow that made me laugh and stick with it.
Hello
"Hello" |&gt; IO.puts()
\`:"Elixir.Hello"\` # ;)
darkness my old friend
Could we make enterprise software that can compete with java/JS based software?
I think that's the eventuality of it. However there are pros and cons to each. For example if you needed offline capabilities, there is no way to escape JS for the moment. So it really depends on your needs. Also, what you see here is really just some JS trickery that Phoenix adds a nice abstraction layer over top of.
I thought LiveView was still missing pushState so no routes were possible.
I believe it is being worked on [here](https://github.com/phoenixframework/phoenix_live_view/issues/174)
&gt; Sorting the results. Performing this work whenever a new result comes in means I always need to send the entire result set over the wire. Perhaps this could be improved; This is an incorrect conclusion. You have to **render** all results (which means you need to fetch them all), but when they haven't changed live view will send just the diff over the wire. I'd be curious how an infinite scrolling solution would work.
I enjoyed the elixir meetup today. ;-)
Do you like Elixir
Pipe operator and pattern matching
Me to!
Pattern matching in multiple function heads
Overloading on steroids is basically what this is. It's fucking glorious. I tried to write some recursive functions in Java the other day and basically broke my PC in frustration.
I agree, Java is a really bad language. I’m learning to pattern match in a book called Programming Elixir by Dave Thomas, have you ever read that?
I’m learning to do that right now! I’m reading a book called Programming Elixir by Dave Thomas. Have you read that book?
Being able to write OTP apps without having to use Erlang. I like Erlang, but like the syntax of Elixir more.
The |&gt; (pipe) operator and Flow is amazing. And pattern matching is on a level beyond any other language.
When a list changes, the whole list is sent over AFAIK. The correct solution is to sent to send the list delta but that is not yet implemented I understand.
Honestly the community here is pretty small. The official Elixir Forum is awesome. I’ve had questions answered there super quickly with help on how to figure things out on my own and really learn
Not as of the last live view presentation IIRC.
How expressive and intelligible it is, every program is like reading a nice book
That is probably THE book that anybody using Elixir has been reading
[elixirforum.com](https://elixirforum.com) is a better resource, by far. Not trying to crap on anyone here, but elixirforum is the official community and is frequented by the Elixir core team.
|&gt; IO.inspect(label: "&lt;line #&gt;") My team has this as a vscode snippet. You can multicursor and watch data flow through huge segments of your code and immediately identify bugs. Obviously, this only works because elixir IO is atomic.
Not to mention its stronger culture of code readability, and documentation.
With only a basic understanding of the language I can look at large "real" Phoenix applications that does a ton of things I don't know about, but eventually figure most things out by just looking at the source code.
Not to mention it's an extremely helpful and welcoming community for anyone from programming beginner to elixir beginner to industry erlang specialist. I wasn't coding when Ruby/Rails took off in the late 10's, but someone once mentioned that elixirforum.com feels like that felt in its boom days.
My top three features of Elixir: - OTP and the concurrency model (process/actor model) - Encourages documentation as first-class citizen - Functional programming (immutability, pattern matching, referential transparency, …) Also, this was asked some time ago on elixirforum too, and there are many and great answers: [link](https://elixirforum.com/t/what-are-your-top-three-features-of-elixir-erlang/20569)
Sure, LiveView sends a diff. I'm not sure what you think is incorrect - when results haven't changed there presumably is *no* diff, but when results do change, I am first sorting the entire list, and then each item (even those which are already rendered) is sent over the socket. You can easily confirm this by looking at the messages coming across the socket: the length of the \`dynamics\` list matches the number of results. Regardless, like I say in the text you quoted, perhaps this could be improved. I believe handling of collections is being looked at by the LiveView team.
It’s so easy to write code that is test-able.
I know it's pretty trivial for you more seasoned Elixir users, but I really love doctests. The idea that your documentation and code examples can be an executable acceptance test is really elegant and clever.
？？
I mean, Java isn't all bad. It's just that some languages do things better than other languages. I haven't read that book because I've mostly just learned elixir by just coding and reading the docs. But I hear it's a great book.
Yes, Chris McCord mentioned in the ElixirConf EU keynote of future plans to add append/prepend for large collection.
* pattern matcing * pipe operator * @doc, @moduledoc, @spec
The reason for that is that each of these calls is treated differently by the VM. When you call function via `Kernel.elem` then it is “remote call” which mean few things: - it is late binding, so `Kernel` can be non-existent during compilation or load of the module, it need to be present when calling the function - lookup for the function is done on each call, which mean that when you hot-reload code, then the caller will pick up updated function definition With `import`ed functions it works like defining local private function for each function exported from the `Kernel` (or any other module, which mean that it will not do late binding and you lost all information about module which contain such function.
wow. I never thought about it in this way with all the late binding and hot reloading stuffs. &amp;#x200B; You explained it nicely.
I have finished 50%. 5 stars. must read
I worked on a side project at work about 6 months ago. It was decently sized and used by my company each week. I open sourced the source code today and wrote about some of the interesting patterns I used in it.
I am curious. How long did the MNIST training take?
Ah. It's in the docs. 6 minutes at 52% CPU usage. Just had to translate with google translate.
It might help to mention somewhere near the start wtf OKR is. Otherwise an interesting read.
Better resource when you know what you are looking for? Sure. For getting started learning, I really don't see how it even comes close.
Functional but pragmatic (compared to Haskell or Idris), focused (compared to Scala), stable (compared to Elm) and on a proven mature foundation (BEAM) Really nice community full of people who are more friendly, helpful and knowledgeable on average than that of any other language I've engaged in
😂 thanks great point. You hear something all the time and it blends into the mind really well. I'll make a note of that.
Thanks! I’m glad to be part of this community!
Hi all, I've linked the second part of my blog series. In this part we build upon the data structures implemented in the previous post to compress input text using the Huffman algorithm. Elixir provides some nice features such as binary pattern matching, iolists, and recursion which make implementing the Huffman algorithm a breeze! You can find the complete source with comments, typespecs, and unit tests on my [Github](https://github.com/nickdichev/huffman-elixir). Let me know if you have any feedback!
The main one is to adhere to the code of conduct: [https://github.com/elixir-lang/elixir/blob/master/CODE\_OF\_CONDUCT.md](https://github.com/elixir-lang/elixir/blob/master/CODE_OF_CONDUCT.md) Otherwise just have fun :)
the author mentioned it in the end/footnotes, but the right fix here would have been to switch to Kinesis Firehose.
It wouldn't give them the ability to respond to each API event individually though.
Awesome write up! Thanks! I keep finding myself reaching for Sinatra when I want a small endpoint, even though I really want to dive in to Elixir. This might be the simple setup that gets me going
First rule of the Elixir community is never talk about the Elixir community
Rad! Yeah, the concepts are very similar between Plug and Rack. I've found that it's helpful to start at a "lower level" with web apps in elixir than jumping into something like Phoenix (which is still a valid route to take).
Over the past two years I worked on Ada, a personal assistant built with Elixir, Nerves and Pimoroni's ScrollBot. I’d love if you let me know what you think! See https://cloud8421.github.io/ada/readme.html, source available at https://github.com/cloud8421/ada https://i.imgur.com/penMPZk.jpg
"right" answer ... this is not a math test. There are many reasons there could be other, better even, answers depending on the circumstances. The author actually notes a few in the article, in fact. It is certainly an answer, and in this sort of situation it may even be a really good one. But thinking there are right answers is a little narrow. Wrong answers, certainly, but rarely universally right ones
I think it’s partially tongue in cheek, at least if he’s using the phrase in the sense I think. My team will frequently talk about the “right fix” for a given situation, in conversations where everyone is understood to know that everything you’ve said here is true :) Rolls off the tongue easier than “the most obvious, expedient, effective option offering a high lifetime value per unit effort and low risk from unknown factors, even though there may well be, and probably are, more optimal solutions that are unorthodox or otherwise not immediately evident” I think it’s a fine jargon, as long as we don’t start thinking it means other answers are “wrong”.
I am in the camp who believes language matters; that it can, and does, cause unintentional bias. It is not so much that other answers are considered "wrong" by saying one solution is right, but that the proclaimed "right" answer is good enough by default that others do not need consideration. And so other answers are missed, people disingage, and awareness of inherent tradeoffs ate lost. IME, teams who too freely use terms like ".. the right fix .." in situations where there isn't one tend to miss opportunities, understand their own technology less, and have less participation in the team than those who use langauge of greater curiosity. (There are, of course, "correct fixes" / "right answers" in more trivial situations ...)
I think we’re secretly agreeing. For argument’s sake, where do you draw the line against “trivial”? That’s about where I draw it on degenerate language ;)
A trivial case might be when an array is accessed out of bounds... very few ways to fix that, and often a more or less clearly correct one.
Oh I did not know, I’m sorry if I wasn’t supposed to talk about that
Love your idea!
I just released the alpha version of the Phoenix Starter Pack. It is meant to kick start development of a Phoenix based product for people who don't want to spend time with the usual bits and pieces needed for every project. &amp;#x200B; You can see it here: [https://](https://elixir-lang.org/)www.mizzo.dev
If you feel brave you can check out Nix package manager which offers all that and more.
Just switched to this. Love.
For any real project I'd use Phoenix, but this is a great way to learn! I got a lot out of doing something similar, except I was building my own minimal subset of Plug on top of Cowboy.
Not to be confused with Lisp's ASDF?
Very much prone to be confused with Lisp's ASDF, I reckon, given they do effectively the same thing.
This isn't a package manager as far as I can tell. It's a toolchain manager. If it were a package manager, the equivalent in JS would be npm and in Ruby it would be gems, not nvm and rvm.
Patterns and Pipes
You're totally right. It's more accurate to call it a version manager. (or toolchain manager).
I've read somewhere it only plays well with NixOS. Or this info is false?
No, I use it wit macOS and works pretty well.
you prefer it over brew? Why?
- Homebrew is dangerous as it changes ownership of `/usr/local`. - Homebrew allows only one version of the software installed at the time, with different versions it can become quite unpleasant. - Nix allows me to have “per directory” programs and version then separately. - Nix has IMHO simpler package definition format. - Nix allow me to easily build package with different dependencies, for example in one project I can build package using Erlang+OpenSSL1.0 and in another one I can use OpenSSL1.1 and there will be no conflict. - I can create package to be used by other developers. For example you can write backend, and the front end guy do not need to know how to setup Erlang, etc. Instead they just add new Nix channel (which can be just git repo) and then add backend as a development dependency. And many other small niceties like that. Also this allows me to configure not only projects, but whole system at once: fonts, keyboard settings, user accounts, daemons, etc.
That sounds really cool. I am Linuxist (running Ubuntu on a Macbook pro). I like stable Debian based systems but for some packages I like to use bleeding age. I use ppas (like for elixir) and some I install manually in \~/.local. So I was looking for another package manager, distribution independent that performs user-installs for up-to-date software. I wanted to try brew for linux, but now I think I'm going to try nix. &amp;#x200B; Thanks Haulteh
I use it. It is fine.
What's the best way to get productive with Nix? I've attempted to learn it several times now but never managed to get there. What's the best guide/docs?
Official ones and Nix pills. I am not any authority there as I am still learning, but these two sources are the ones I used the most.
This is why I'm not sure Nix is a good alternative to asdf. Nix seems to take a long time and a lot of effort to learn, while asdf can be learnt in 2 minutes.
On the one hand - yes, but on the other you do not need to edit `shell.nix`/`default.nix` that often and `direnv` provide seamless integration, so in the end newcomers do not need to learn anything.
Fantastic, that sounds great! How do I use those things? :)
Define your derivation in `shell.nix` then [add `use nix` to `.envrc`](https://direnv.net/#man/direnv-stdlib.1).
Thanks for the article! Do you guys have any plans to switch to the new built in mix release?
(Eric here) I don't think we will? I am a fan of config providers and we use them as part of this deployment. Since you can built a single release and configure it with a known config file. If this is included in the built in \`mix release\` then we might.
Really enjoyed this talk. Great explanations of the different components, options, and trade-offs to building something like this. I wonder what sort of optimizations could be made for an Event Store specific distributed database opposed to an entity/KV/relational type.
Ok, thanks for the feedback!
I'd love to know when a JIT compiler is planned for the BEAM.
I'm happy for you that you'd love.
Optimized collections are on the roadmap, so there will be a better story for append/prepend, and potentially sorting. Sorting is more difficult because we'll need to expose a way for the DOM to sort it, likely via an attribute, but not much harder once we have optimized collections in place.
Welcome! In addition to the CoC – don't be a jerk :) , don't be afraid to ask questions, and dive in! Elixir slack and IRC are great places for quick access to help, as well as elixirforum.com. Welcome Aboard!
Hey guys, in this article I start from what built in [Step-by-Step Tutorial to Build a Phoenix App that Supports User Upload](https://www.poeticoding.com/step-by-step-tutorial-to-build-a-phoenix-app-that-supports-user-uploads/). We see how to integrate ImageMagick and the Mogrify wrapper, in the last article Phoenix app, to create thumbnails for image and PDF files. I hope you find it useful!
I believe there is a similar concept in releases.
Ah, cool then. What we're doing should be pretty portable to the new 1.9 releases.
Another great post, as always. You are always putting out great content. Thank you!
What's difference between this and httpoison
A year or so ago I switched to running all projects in Docker. It's easy to Dockerize most applications and then you'll always have the exact language versions you want and related system dependencies. The only downside I've been able to find is less smooth language server integration with editors, but that can be worked around. Overall, completely happy with it as a solution and I much prefer it to using toolchain/version managers like this.
Every time I see his name pop up I can't help but think of the Wendy's guy. So, that's what the author looks like in my head.
Unlike httpoison, mint is processless and it was created by elixir team but not an official elixir project. There's an excellent write-up here: https://elixir-lang.org/blog/2019/02/25/mint-a-new-http-library-for-elixir/
Thanks!
Thank you! I'm glad you like it 😊
Thanks for this - it is incredibly well written and very useful for a beginner!
We've gotten a lot of interest in this topic, so we'll be running our Monday Twitch stream on it, Eric will show how he deploys Grapevine with Distillery and Docker. Catch it Monday Noon EDT at [https://www.twitch.tv/smartlogictv](https://www.twitch.tv/smartlogictv) if you're interested!
That's not really enough information for a beginner to get started. Could you share a brief guide?
I will start. I contributed pascalCase option for ja\_serializer\[0\] and also fixed one issue I found with links generation. Originally, I wanted to use jsonapi\[1\] for everything, but I realized that ja\_serializer is more flexible for the view part. In the end, they can be combined to work together just fine. Maybe one day jsonapi improves the flexibility and this would not be necessary, we shall see. \[0\] [https://github.com/vt-elixir/ja\_serializer](https://github.com/vt-elixir/ja_serializer) \[1\] [https://github.com/jeregrine/jsonapi](https://github.com/jeregrine/jsonapi)
Wrote a small glossary web app for internal use where I work as a way to address our needs for such a thing, but mostly so I could spend a day learning liveview with a practical example. Picked up my RPG campaign "living world" sideproject again. .. and at work continue to hack on our distributed spatial data project. So, a bit of this, a bit of that :)
What’s a fellow do?
Experimenting with mnesia. Haven't found a good guide for deploying an mnesia app with disc_copies... No `record_info`... It needs some love.
Lifetime membership in ErlEF.org, elected by 2/3 votes, same voting rights as the paying member, honorable mentions if a fellow goes inactive.
It's more about recognition for what they have already done rather than what they are doing now. It's basically a lifetime member status in the EEF.
I am writing a book/series of articles about OTP design decisions in different Elixir libraries. I believe it is easier to learn stuff by analysing examples than working out the design from principles, and there are no better examples than widely popular libraries :) I am not sure how I am going to publish it, though. PragProg decided it is a little too advanced and they have other OTP titles in the line. I'll try some other publishers or go with self-publishing :)
I am building a small analytics suite at [https://freelytics.net](https://freelytics.net) . It is open source at [https://github.com/b-m-f/freelytics](https://github.com/b-m-f/freelytics) and free to use. The idea is to make the data available to anyone. Just recently switched to Elixir from Golang on the API side and accompanied this with a blog post at [https://maximilianehlers.com/moving-the-freelytics-api-from-golang-to-elixir/](https://maximilianehlers.com/moving-the-freelytics-api-from-golang-to-elixir/) . I believe that using Elixir is perfect for this kind of project. The next big thing for me to add is thorough testing, to enable people to jump in to the project with more confidence :)
I am building a small analytics tool at [https://freelytics.net](https://freelytics.net) . It is open source at [https://github.com/b-m-f/freelytics](https://github.com/b-m-f/freelytics) and free to use. The idea is to make the data available to anyone.Just recently switched to Elixir from Golang on the API side and accompanied this with a blog post at [https://maximilianehlers.com/moving-the-freelytics-api-from-golang-to-elixir/](https://maximilianehlers.com/moving-the-freelytics-api-from-golang-to-elixir/) . I believe that using Elixir is perfect for this kind of project, due to the type of requests that are going to come in, and the possible amount of them. The next big thing for me to add is thorough testing, to enable people to jump in to the project with more confidence :)
Thank you! 😃
If you haven't found it yet, the [Official Elixir Forum](http://elixirforum.com/) is extremely friendly and active. Nothing against this subreddit, but that forum is significantly more active.
 Not exactly sure how the packaging would work but this sounds like a job for escripts: https://elixirschool.com/en/lessons/advanced/escripts/
Starting to work on a Bullet Journal CLI application, and still going through the Programming Phoenix &gt;= 1.4 book
Well this is officially my new favorite one-liner. sudo sed -i "s/peer$/md5/" /etc/postgresql/*/main/pg_hba.conf
Thank you. Hope you are not joking, but if you are I'm glad, too.
Not joking at all! Every time I set up Postgres I forget about this and end up googling where the setting is.
docker
To level-set, for the average developer who matches any of the following descriptions, I **do not** consider Nix a like-for-like alternative to ASDF or Homebrew, however positively I feel about it today. It is much more capable and the learning curve is much higher as a result. (I'm trying to phrase these to indicate that my perception of these positions is not that they are wrong, but that they are pragmatic or reflect different priorities/experiences than I have, which is **totally fine**.) Nix may not be worth your attention, not right now, if: * You are *entirely* content with ASDF today * You are *entirely* content with Homebrew today * You largely stick to one development language and one major version thereof (i.e. "I always target Rust stable", and TBH `rustup` is very very good, even with Mozilla's Nix overlay in the picture) * You have relatively few native dependencies outside of your programming language's own package toolchain * You have not ever faced problems with stale project/dependencies or version-compatibility matrices, and do not anticipate this changing, such as if you have a small number of projects kept regularly maintained * You do not want to learn another functional language just for software configuration, delivery, packaging and related problem domains * You want to standardize on support tools that are commonly used by coworkers or project collaborators, and are easy to socialize/teach * You would hope to be able to use it productively in a few minutes to an hour * You want a really closely-integrated experience in your chosen programming language, and it's not one of the ones specifically highlighted in the [language support part of the manual](https://nixos.org/nixpkgs/manual/#chap-language-support) - BEAM languages are kind of in the middle tier for Nix integration quality, Haskell or Python is probably highest * You wouldn't expect to advocate for its use outside of your developer workstation - it can be kind of lonely within a larger organization using other stuff, and the effort-to-reward ratio is pretty lackluster with that limited scope * You would feel disappointed with high quality but incomplete documentation that may eventually devolve into RTFS situations On the flip side, I feel like Nix gives me goddamn superpowers sometimes. I especially like [home-manager](https://github.com/rycee/home-manager), migrating away from `rcm`. I manage a surprising amount of machine content and configuration with it, more almost every day, and I have exactly one horror story about losing time or progress to it since 2017. I'm happy to share that upon request. It was long enough ago that the details are starting to fuzz, though. Here's some other Nix-related content/discussion I've participated in and found valuable in one way or another: * [Another Reddit thread where I wall-of-texted like I just have, about migrating from Homebrew to Nix](https://www.reddit.com/r/Nix/comments/bdyfe4/migrating_from_homebrew_to_nix/) * [A forum thread about ASDF vs Nix](https://elixirforum.com/t/nix-vs-asdf-for-elixir-version-management/15973) * [An outline for a talk I gave at work that year about Nix/NixOS](https://gist.github.com/shanesveller/071cd919ea3fd8a6cd150ef815a1a5ae) Finally, I am extremely happy to evangelize and pair/educate/share samples if you see me online as @shanesveller on the Elixir Slack/ElixirForum/Twitter, here, whatever. I won't nag or judge you for any reason, I just want to offer my experience as a resource if you are interested in checking it out. Just be prepared for the possibility, that, if you make it over the hump, you'll start to be underwhelmed by most other solutions that it can replace. (I still think pretty highly of Mix and Cargo, though.)
Why?
thanks m checking it out 😊
Excellent content! Love this kind of systematic analysis and solution. I'm sharing this on /r/programming
Awesome article, thanks for sharing!
We set up docker in our company, hoping it would make initial deployment easier. Well, it is faster to set up a new server now, but for deployment nothing beats “mix edeliver update”.
can I get the link for elixir slack ? please
can I get the link for elixir slack ? please
What's the story of crashes in NIFs? I heard it brings down the whole supervision tree
What's the story of crashes in NIFs? I heard it brings down the whole supervision tree
What's the story of crashes in NIFs? I heard it brings down the whole supervision tree
Agreed!
Great read.
The OTP team announced at CodeBEAM STO a couple days ago that development on the JIT is ongoing, and it will be open sourced this year.
Oh awesome news! Thanks!
One person elected post-mortem which seems a little bit strange as Bylaws state that: &gt; Fellowship does not continue during any extension of life by non-natural means, such as zombification or vampirism.
These languages make an excellent combination. Rustler is a great project as well. I tried this with some structs just for fun and it worked perfectly.
Yeah, Rustler is great. I use it in [Meeseeks](https://github.com/mischov/meeseeks) (via [Meeseeks_Html5ever](https://github.com/mischov/meeseeks_html5ever)) to offload HTML5 and XML parsing to Rust, and Rustler makes the process really straightforward. The whole Rustler team does a great job.
Hi all, I've shared the final post in a series of blog posts describing the implementation of the Huffman algorithm in Elixir. This post covers the changes necessary to implement decompression! The "heavy lifting" of the decompression algorithm was made so simple with pattern matching! You can find the full source code with comments, type specs, and unit tests on [Github](https://github.com/nickdichev/huffman-elixir). Let me know if you have any feedback!
better.
This is my next article. AWS ECS + RDS + ...
Another trick is to have in your home a directory, let's say \~/global\_mix with a mix.exs containing all the packages you wish to have installed globally. Given that package :recon is in that mix file and you've invoked \`mix deps.get\` you can then load it in other apps using: &amp;#x200B; iex -pa \~/global\_mix/\_build/dev/lib/recon/ebin -S mix It should be quite easy to create a shell function to load all the packages of your global\_mix using the above pattern.
Just wanted to say thanks for this write up
One thing I really like about the Elixir community is it doesn't really need 'rules'. All the people I've met at conferences or chatted with through online communities have been on average much nicer than anywhere else. That goes in both ways - from not being jerks in general, to not pushing manipulative dogmatic politics like I've seen for example in the Rust circles or more recently making a lot of noise in Python.
Last I checked, Joe wasn't a zombie or vampire.
Nice read
Thanks!
I enjoyed your post, I'll be reading through the source and links. Much appreciated!
I started to love elixir..
Trivago? 😂
For the arm chair elixir enthusiast, can you explain what this does and why its made your life easier?
Aren't you just looking for mix compile &amp;&amp; mix
yeah probably `mix compile; clean; mix` works too
mix tasks don't trigger recompile automatically when running after code changes, so if you forget to recompile, you can wind up confused about if you're running the current mix task or the old mix task. If your mix task is somewhat long running, there can be frustration =D
I'd rather not clear the console personally but that's preference I suppose. But this is better because you're cleaning the build when you use your command, which will mean the task takes a lot more time to run.
note that the alias is `mix!`... you're not supposed to use it in general, just when developing the task, so I'm not particularly concerned about run times.
Yes I often use mix tasks too and just prepend with the `mix compile &amp;&amp;` when I'm working on one. You can always run `mix clean` manually when needed.
Visa sponsor?
probably not a good idea, as then when you move your code to a different computer that does not have that package or has a different version then it could break.
&gt; if we compare 2 merkle trees, we can tell whether the two trees are identical just by comparing the top nodes That only confirms whether the two trees **claim** to be identical. If both top (root) nodes are not identical then the trees are not identical. But if they are identical and you had not build the two trees yourself, then you may want to wholly re-verify one or both of the trees from the leafmost nodes back to the root before asserting that the two trees are identical.
That answer should be part of the original post :)
Booking.com.
Thanks for your feedback. You're correct. But I am comfortable leaving this out of the scope of this blog post.
`alias mix\!="mix do compile, "`
Definitely Trivago. The description was copied from their site: [https://company.trivago.com/jobs/r0001641/](https://company.trivago.com/jobs/r0001641/)
Any agency which requires you to register an account with them just to see basic details about the opening doesn't say much for me. Apply directly at Trivago if you're interested.
You have two options here. First is just getting the call stack at any point by using `caller` \- [https://apidock.com/ruby/Kernel/caller](https://apidock.com/ruby/Kernel/caller) Also, if you raise an exception, it will include `backtrace`, which returns an array similar to what is returned by `caller` \- [https://ruby-doc.org/core-2.5.2/Exception.html#method-i-backtrace](https://ruby-doc.org/core-2.5.2/Exception.html#method-i-backtrace)
Completely rewriting my comment because I thought I was on the Ruby subreddit. Elixir exceptions, I believe, include the stack trace, and can be accessed by using: [https://hexdocs.pm/elixir/Kernel.SpecialForms.html#\_\_STACKTRACE\_\_/0](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0) &amp;#x200B; From the GitHub issue, it states: To solve this, we propose introduction of a new pseudo-variable __STACKTRACE__ that would be available inside catch and rescue and would return the stack trace of the exception being currently handled. They also note you can get the current stack trace by running `Process.info(self(), :current_stacktrace)` if you're not in a rescue. [https://github.com/elixir-lang/elixir/issues/7097](https://github.com/elixir-lang/elixir/issues/7097) &amp;#x200B; And of course you can format it: [https://hexdocs.pm/elixir/Exception.html#format\_stacktrace/1](https://hexdocs.pm/elixir/Exception.html#format_stacktrace/1)
Super helpful, thank you!
I was considering digging into the generated Phoenix files. Thank you for doing this. Would you mind doing the next step of minimum Phoenix to *mix phx.new*?
Neat post. I like the presentation of Literate Commits.
Thanks, that's an awesome idea.
Trying to figure out a small project to build on my own as a way to get practice in Elixir. I never developed software in a functional paradigm and I believe this should be a skill to master. This week I started with basic interactive tutorials and now I expect to find interesting and particular cases to get functional development into practice.
Yeah I as soon as I saw it was available I grabbed a copy! I was expecting to get Programming Phoenix but it appears the release date got pushed back to September 2019.
Side note: you should add .DS_Store to your personal global gitignore file so you don't have to litter all your repositories with it.
I bought this on MEAP as well. I'd already gotten well acquainted with Phoenix before it came out, but I usually buy all the Elixir books from my favorite publishers since [teach it](https://youtu.be/G3JRv2dHU9A). I would recommend this book for the impatient. When I was learning, I first went through Programming Elixir and then Programming Phoenix (both from Pragmatic Bookshelf). Phoenix in action teaches you just enough Elixir in the first few chapters that it works for a programmer who's totally new to Elixir. It's a great way to get up to speed quickly and get an app built. If you go that route and like the experience building with Phoenix, then a good followup step would be either Programming Elixir or Elixir in Action (from Manning). Elixir in Action goes into considerably more depth in building concurrent systems (processes, GenServers, ,OTP, fault-tolerance, etc).
i hope u will write another part of it. This is cool
Meanwhile Programming Phoenix has been in 'beta' for what, 2+ years now? Really regretting that pre-purchase.
This is a 40 minute talk from GOTO Chicago 2019 buy author of 'Elixir In Action', Saša Juric. I have pasted in the talk abstract below for a read before you dive into the talk: &amp;#x200B; Whether you're developing a small web site or a large-scale distributed system, Erlang and Elixir are great tools for building server-side systems. Both languages can help you start quickly and deal with highly complex problems at a large scale. This talk aims to explain what makes Erlang and Elixir suitable for such tasks. We'll look past the syntax and the ecosystem, focusing instead on the concurrency model of these languages. Combining a bit of high-level theory and a couple of demos, we'll examine some important properties of Erlang/Elixir concurrency, with a special emphasis on why these properties are very relevant when building highly available systems. The talk targets experienced backend developers, but no knowledge of Erlang or Elixir is required. You will walk away from the talk with a better understanding of what distinguishes Erlang and Elixir from the rest of the pack, and why these languages are very compelling choices to power your next software system.
Might be a silly question, but does it try to recompile the project on save?
Programming Phoenix (1.3) was published three years ago. Programming Phoenix 1.4 has been in beta for exactly one year. Currently scheduled to be out in August, but it's nearly finished and very much useful :)
TIL, thanks!
Thanks for the mini-review! I'm glad you found it useful.
very impressive talk. consider posting this on /r/programming if you haven’t already. i’ll be buying that book soon if it’s still on sale. also, i wish every tech talk was done at this pace. not a second wasted. i’m new to BEAM and i’m curious about the limitations of distributed processes the speaker alluded to? i’m guessing it’s not something that every distributed system will face but for some limited needs?
I haven't checked this out yet, but it came across my feed one or two days ago: https://www.phoenix-tutorial.com/read
Doesnt look to be finished yet but thanks
Wow, I must say that's pretty solid introduction to the beam and Elixir in such a short period of time.
I've been going through the Programming Phoenix 1.4 beta the past few months. Could any of you compare the style of this book to Programming Phoenix?
Love Osa, he hosts the Elixir Meetup here in Atlanta.
I also bought 1.4 beta, but don't regret. It already had a lot of stuff in it when I bought it. Plus, since it's official book it supports the framework too.
wow amazing talk
Phoenix in Action or Programming Phoenix, probably.
You still need .DS_Store in the repo .gitignore if there’s even a small chance that someone will collaborate with you.
That looks cool!
Thanks!
Happy to learn you enjoyed the talk :-) I think that the code from the talk is expired (give it a try though), but the book is offered on a 50% discount every 1-2 months. You can subscribe to the ["deal of the day" notifications](https://www.manning.com/dotd), or otherwise follow [Manning](https://twitter.com/ManningBooks) on Twitter. When it comes to distributed BEAM, I feel that there are a couple of shortcomings. First, in my opinion distributed BEAM is mostly intended to run on a network which is fast and more reliable (such as local network). While in theory it can also work on a less reliable/slower network (e.g. geographically dispersed machines connected via Internet), in practice you might experience more frequent netsplits which could cause various problems, such as worse performance or less consistency. Another issue, which should be fixed in Erlang/OTP 22, is the fact that sending large messages via distributed BEAM might also cause netsplits. Prior to OTP 22, people usually solved this by using a side-mechanism (e.g. HTTP requests) to send large messages. Finally, I've seen various reports that the practical size limit of a BEAM cluster is in the range of 50-100 nodes. The reason for this is that BEAM cluster establishes a fully connected mesh (each node maintains a TCP connection to all other nodes), so at some size this starts to cause problems. As far as I know, the OTP team is working to improve this, but as of OTP 22 it is still not done. Most importantly, I feel that the ecosystem is lacking easy-to-use, reliable, thoroughly tested, higher-level abstractions. There are various initiatives/explorations available, such as [swarm](https://github.com/bitwalker/swarm), [hoarde](https://github.com/derekkraan/horde), or [lasp/partisan](https://lasp-lang.readme.io/), but I'm currently not convinced that any of these is mature enough to be used in production. That said, I think I saw a few mentions of people using some of these libs in production, so take my statement with a grain of salt :-)
Kudos again! And thanks for the detailed response – it all makes sense that BEAM was not originally meant for such large and potentially poorly connected (distance or otherwise) nodes. I notice you didn't mention the [Nerves](https://nerves-project.org) project in your list of higher-level abstractions, but I'll assume you would lump it with the other efforts you did mention.
You mean erlang/otp 22 ?
The libraries mentioned above are related to higher-level support for distributed systems. AFAIK Nerves is first and foremost about bringing a BEAM-powered system to embedded devices, so that's why I didn't include it in the list. I didn't really follow the development of Nerves, so I have no idea if Nerves is at all concerned with distributed BEAM.
Amazing presentation &amp; demo! I was looking around for a second / hobby language and this presentation sealed the deal :).
Got it. They used to say something like they wanted to be an IoT OS. I’ll look into it more. You’ve been very helpful.
Yes, you are absolutely right
Like you, I've gone through that tutorial a long time ago, I have not come across anything for Phoenix that is that thorough.
Very cool! Congrats! Hopefully you have a second rpi so that you can play around with [Nerves](https://nerves-project.org)!
why not spacemacs/emacs/vim like a real man though ? Nice setup !
Don’t give up, go through the book and use iex on the command line first. Or use VS code plugins for iex. If you don’t understand something go back to book or use h(function_name).
Good it's my setup too i use to have intellij with elixir plugin but i got problems with utf8 variable names.
Very cool! Enjoy!
Nice rig.
Thanks
Me and vim:. https://youtu.be/fv-pFFaJnAY
I have an emergency Pi zero W that I carry in my wallet with a minimal working config (i can always find a usb + power supply, tv/monitor and keyboard/mouse if needed). &amp;#x200B; I would not want to be working with vscode on that cpu for any period of time -- VIM ftw.
Which problem are you trying to solve?
problem 18.
I don't quite see why you're using `Agent` in your solution here, since you have no real reason to store the state in a separate process. The problem you're trying to solve doesn't require building up a tree structure like this, either; you can easily use the list notation to find the answer for that question. However, since that doesn't answer *your* question, here's what you can do, roughly, using recursion or an `Enum.reduce` operation: 1. Reverse the list you have so you get `[[8, 5, 9, 3], [2, 4, 6], [7, 4], [3]]` 2. Get the first list and turn it into a `Tree`, ie `[%Tree{value: 8}, ..., %Tree{value: 3}]`. Use that as the accumulator of your recursive function. 3. For each further list in the initial list, build another tree with the value, and add the trees from the accumulator where appropriate for `:left` and `:right`. Call the recursive function with the list of trees you just built in the accumulator. Basically, you'll want a setup roughly like this ("roughly" because this may not be 100% correct; I can't test it at the moment, but I'm sure you can see what's going on): def build_tree(values, acc \\ nil) def build_tree([], acc), do: acc # Here is the first iteration, where we need to make the initial trees. def build_tree([current_list | rest], nil) do tree_list = Enum.map(current_list, fn val -&gt; %Tree{value: val} end) build_tree(rest, tree_list) end # Here, we build up the trees with the trees we previously built. def build_tree([current_list|rest], acc) do # Harder stuff here end There's even more ways to make this more idiomatic elixir, but those will come with practice and preference.
Spoiler alert, but if it is useful, here is an example solution: http://rosettacode.org/wiki/Maximum_triangle_path_sum#Elixir
`def f(%MapSet{} = m)`
Not an asnwer how to build a tree, but I think more elixirish way would be the other way I think you list representation is good enough to find the path. Since every child node except leaves has common child - your tree is redundant. Just a recursion over your list should be enough to find so called max_path. It might look like this defp find_max_path([], _, path), do: path defp find_max_path([head | rest ], current_index, path) do child1 = {current_index, Enum.at(head, current_index)} child2 = {current_index+1, Enum.at(head, current_index+1)} {adj_index, adj_val} = Enum.reduce([child1, child2], fn ({_max_index, max_val}, {_current_index, val} = current) when val &gt; max_val -&gt; current (max, _current) -&gt; max end) |&gt; IO.inspect() find_max_path(rest, adj_index, [adj_val | path]) end and call this on your list def max_path_sum([[root_val] | rest]) do max_path = find_max_path(rest, 0, [root_val]) Enum.sum(max_path) end max_path_sum([[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]) By the way, do you guys think it would be better to recurse on the `slice` of the next row from the current_index and pattern match on first two elements? would it be faster that accessing the middle of the list via `Enum.at/2` ?
`chunk` has been replaced by `chunk_every` btw
I think I get the idea of what you are saying. So basically I should use a forest of trees and then merge them in a bottom up way until I only have one tree. I am aware of the way of doing the problem without trees but was reading through a book called Algorithms A Functional Programming Approach. After reading the question, I thought it would be a fun exercise to try to solve it using a tree. The use of Agent to store the tree is unnecessary and I'll remove it. Thank you for your help. I really appreciate it.
Thanks. This is a better way than how I did it.
While Programming Phoenix 1.4 is mostly about building Phoenix application "the Phoenix way" with some explanation how to separate units into contexts which was introduced since 1.3. So it's more about Phoenix. Phoenix in Action, on the contrary, is more about Elixir application with Phoenix as a web-layer. Since the main project you build during the second part of the book is Umbrella project where you first create an elixir application with ecto and then just add separate Phoenix as a separate application under umbrella with `--no-ecto`.. no contexts etc.. I think Dave Thomas (@pragdave) would preffer the second way to teach. Even though both books shows you how to test (in the last parts of the books), I think the Elixir community misses books/tutorial with TDD-first approach like Michael Hartl's (Ruby on Rails Tutorial)[https://www.railstutorial.org/book]
That matches on type but not content, right? What about something like: &amp;#x200B; def in(%MapSet{key}, key), do: true def in(_, _), do: false (only an example; my goal isn't to replicate \`member?\`)
`def in(%MapSet{key: k}), do: k`?
Just binding a variable to the value at a particular key, or checking for the presence of one, should work the same as it would in a map or struct.
Thanks for providing another another implementation. This was more more of an exercise to try to create an explicit tree in a functional language rather than just to solve the problem. I am new to functional programming so I am grateful to seeing the use of fold to solve it.
If you inspect one you'll see what properties it has. You could check if the module has some defguards for this kind of situation too... then use them in your `when` guard.
You could time their execution using `:timer.tc/1`
You should benchmark both methods (outside of iex) to check! But you should try another way as well. Using an iolist is an efficient way to build output. An iolist is an improper list which stores binaries (and other types) of data. Building them is efficient, since you don’t take the penalty of list concatenation. Evaluation is fast since you only take the penalty of copying binaries once, instead of for each time you need to build output. Here’s a good resource on iolist: https://www.bignerdranch.com/blog/elixir-and-io-lists-part-1-building-output-efficiently/
https://imgur.com/gallery/8VXX7AT
neovim for the win win.
I was bored and did it for you :P [https://gist.github.com/trbngr/4859a01fe1ef87056f65540289d75ab4](https://gist.github.com/trbngr/4859a01fe1ef87056f65540289d75ab4) Name ips average deviation median 99th % function head matching [IO List] 186.26 5.37 ms ±10.11% 5.25 ms 7.02 ms function head matching 150.36 6.65 ms ±6.86% 6.54 ms 8.32 ms conversion 80.01 12.50 ms ±14.63% 12.09 ms 17.73 ms Comparison: function head matching [IO List] 186.26 function head matching 150.36 - 1.24x slower +1.28 ms conversion 80.01 - 2.33x slower +7.13 ms
Have seen this talk on some other subreddit. I guess I'm using elixir for most my hobby-stuff from now on...
The first style is much less readable. You repeat the recursive call over and over again. I would gladly sacrifice the performance of pattern matching to the readability of the second solution. You can still get the best of both worlds: def numeral(num) when num &gt;= 1000, do: {1000, "M"} def numeral(num) when num &gt;= 900, do: {900, "M"} ... def numerals(num), do: numerals_rec(num, \[\]) def numerals_rec(0, acc) do acc |&gt; Enum.reverse |&gt; IO.iodata_to_binary #you can skip that if you accept IO data as output end def numerals_rec(num, acc) do {matched_integer, letter} = numeral(num) numerals_rec(num - matched_integer, [letter | acc]) end Recursive function needs an accumulator for tail call optimisation. That has still some repetition because you need to repeat the number in both guard and output of `numeral`. You can get rid of that problem with a macro. [ {1000, "M"}, {900, "CM"}, { 500, "D"}, {400, "CD"}, { 100, "C"}, { 90, "XC"}, { 50, "L"}, { 40, "XL"}, { 10, "X"}, { 9, "IX"}, { 5, "V"}, { 4, "IV"}, { 1, "I"} ] |&gt; Enum.each(fn {integer, letter} -&gt; def numerla(num) when num &gt;= unquote(integer), do: {unquote(integer), unquote(letter)} end) That last part with macros might be an overkill xD, but it combines the performance of pattern matching with the readability of your second solution.
Perhaps veering a bit far into pedantics here, but iolists are not necessarily improper, the two concepts are orthogonal. In fact, I'm not sure if functions dealing with iolists even handle improper lists. Improper lists are list whose last element is not `[] `, and you have to build them explicitly with the cons operator because they're not really a commonly used feature. In Erlang it'd look something like `[a | b] ` rather than the typical `[a, b] `. The caveat is that my background is in Erlang - I'd like to think that this works the same in Elixir but I could be wrong!
I'm learning Elixir too. Could you explain this part please? ``` Enum.find(&amp;(elem(&amp;1, 0) &lt;= num)) ``` I'm confused by the `&amp;` parts and the `&lt;=` inverse arrow
It is a shortcut for `fn arg1 -&gt; elem(arg1, O) &lt;= num end`. The left arrow is just "inferior or equal to". So this just find the first item in the list where the 0th element of the tuple is less or equal than num.
I make http://btc-listener.gq using phoenix/elixir. Right now it run on twisted/python.
Working on a touchscreen map for a region's visitor center​. Phoenix backend with leaflet.js main screen. Wrote 2 libraries while doing so. * [GeoTurf](https://github.com/JonGretar/GeoTurf) - A spatial analisys tool. * [Fixate](https://github.com/JonGretar/Fixate) - Fixture support for tests.
The biggest rule is to not be a jerk. I absolutely hate it when people get all high and mighty about the programming environment they love at the moment. It's a preference thing not a "best" thing.
This was extremely interesting and I would definitely read this style of blog post about any of the sidequests in phoenix or other tech you wanted to explore.
Thank you very much for your reply. I went through Sasa's Elixir in Action book and am about to finish Programming Phoenix (at least what's been released thus far). PIA is going through refactoring your application to use an umbrella structure, so I am getting exposure to that concept. This does sound beneficial because PIA assumes that you're fairly familiar with Elixir concepts so it can really teach you Phoenix. &amp;#x200B; I might purchase this, although it's tough to continue to go through books, this will be my 3rd but I do feel like I get a much more fundamental understand of the language and frameworks than some of the video courses that have been put out.
You cannot do that as internal representation of `MapSet` is hidden. Maybe in future there will be guard for that, but right now there is no such possibility.
Did you forget to link the repo?
You could get the source code of elixir as an elixir logo poster made up on https://commits.io/
Thank you for the suggestion! I will check this out!
You will find a lot more people on [https://elixirforum.com/](https://elixirforum.com/)
Wow, this guy is living the dream. Gets to use Elixir at work and has a thoughtful wife. &amp;#x200B; On a serious note, you could get him tickets to ElixirConf: [https://elixirconf.com/2019](https://elixirconf.com/2019). But note he will need to travel to Colorado for it. Also, it's possible his workplace will pay or reimburse him for it, so you might want to sneakily check if that's the case, otherwise no point in paying out of pocket for it.
ElixirConf this year is a very family friendly resort. So if an option, it can also be a good stay for the whole family.
Thank you! I will check that out too!
Just write a couple of lines that you want it to say and me (elixir Dev) or anyone on elixirforum will be happy to make some working code out of it.
He’s had a couple jobs that he hasn’t loved, didn’t want to be a “code monkey” as he put it. So when he was searching for a new job, I just told him wait until he found one that allowed him to use elixir So he’d be happier. He found a great semi-start up and mega bonus is that he gets to work from home. As far as your suggestions goes, that would be AMAZING if his company covered it. Unfortunately we are trying to keep spending down so we can hopefully move into a bigger house in the next year. I’m thinking since it’s a start up it’s probably not in the budget. But this gives me a great idea for future fathers days!! So thanks!!
Ugh I really wish it was! I have never been to Colorado and would really love to go. Hopefully in future years it will be in the books for us!
So I can recommend a few books if he doesn't already have them a d you want something lighter on cost. Elixir in Action by Sas̄a Jurić is an excellent general Elixir book, my favorite personally. Programming Elixir by Dave Thomas is probably the most popular and considered the de facto standard book by most in the community. Then if he is interested in web development there is: Programming Phoenix by Chris McCord, the most popular book in this area. A recently released, and one I haven't read is Phoenix in Action by Geoffrey Lessel.
Oh almost forgot, a book about selling using Elixir to management or other people. I haven't read this one but I've heard good things. Adopting Elixir: From Concept to Production by Ben Marx, Bruce Tate, and Jose Valim
This is super cute. Are you looking for something pre-made or something that you make/have made? I could help write a code snippet for you if you’d like.
That's a great talk title
 dads_name: [ is_awesome: true, kids: [ kid1_name: [ loves_dad: true, eats_broccolli: false, loves_minecraft: true ], kid2_name: [ loves_dad: true, causes_trouble: true, tidies_room: false ] ] Something like that would look cool on a card or a mug. Might be a bit schmaltzy to put it on a shirt or poster though.
I thought the same thing, hard to come up with something for someone you don’t know. &gt; iex&gt; dad = %DadsName{} |&gt; get_married() |&gt; get_kids(1) &gt; ...&gt; fathers_day(dad) &gt; %DadStats{status: :awesome}
I didn’t know this. This is just awesome! Thanks.
You can even use elixir to build one yourself: http://www.petecorey.com/blog/2017/02/13/build-your-own-code-poster-with-elixir/
T-shirt with the text "process_spawner" on it
Yep, sorry
LMAO
Being a dad is being a Supervisor, huh children = [ # The Stack is a child started via Stack.start_link([:hello]) %{ id: Stack, start: {Stack, :start_link, [[:hello]]} } ] # Now we start the supervisor with the children and a strategy {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one) # After started, we can query the supervisor for information Supervisor.count_children(pid) #=&gt; %{active: 1, specs: 1, supervisors: 0,
Thank you for these recommendations! I’ll sneak through what he already has and see if I can add another to his collection.
Thank you so much for the offer! I’ve actually got some really nice ideas from everyone here and over at the elixir forum website. Everyone has been so nice!!
I keep meaning to get into nerves, but haven't done it yet. Right now I use my pi for stream monitoring. I need to think of a good nerves project
I see you're using `cond` everywhere. I'd recommend seeing if you can replace some occurrences with `case` or pattern matching. Your day suffix function is a great example
I noticed that you get config values from environment variables. I'm trying to do something similar when I deploy my elixir docker umbrella app to Digital Ocean. How do you inject these environment variables at runtime?
You can both set them in your Dockerfile (if you use Docker) or running your mix project: `FOO=BAR VAR=BAZ iex -S mix` Same when you're running your compiled program, just prepend your variables to the startup script :)
As another example of a refactor: def nth_prime(num) do cond do num == 1 -&gt; 2 num == 2 -&gt; 3 true -&gt; find_prime(nth_prime(num - 1) + 2) end end could become def nth_prime(1), do: 2 def nth_prime(2), do: 3 def nth_prime(num) do find_prime(nth_prime(num - 1) + 2) end
yeah I don't want to store env vars in a file that is checked into git(Dockerfile is checked-in). Also, \`docker-compose up -d\` is the typical way I boot the app so I do not directly call the binary from the command-line. &amp;#x200B; However, your suggestion did lead me to a possible solution. &amp;#x200B; [https://docs.docker.com/engine/swarm/secrets/](https://docs.docker.com/engine/swarm/secrets/)
I think in this case I'd prefer using `cond do ... end` for the cases of `num != 0` and a separate function head for `num == 0`: defmodule Roman do def numerals(0), do: "" def numerals(num) do cond do num &gt;= 1000 -&gt; ["M", numerals(num - 1000)] num &gt;= 900 -&gt; ["CM", numerals(num - 900)] num &gt;= 500 -&gt; ["D", numerals(num - 500)] # other cases... end end end I also like the iolist option over string interpolation. Lots of I/O functions in Erlang and Elixir land can handle iolists, so if you're going to e.g. print out the result with `IO.puts` or send it as a response with Phoenix, you don't even need to convert to a binary first, you can directly send the iolist.
I'd hasten a guess that just about everyone here is a fan in one way or another.
I guess so, the community is really nice
Thanks, I plan to release the next video soon!
Wow I didn't know about that! Thank you so much!
That's absolutely true, thank you so much!
yeah it seems you can't add secrets without swarm, UNLESS you are using docker-compose 3+ &amp;#x200B; another option is add \`env\_file:\` to your docker-compose.yml service. for some reason though I'm having trouble getting that working.
Are you maybe looking for https://hexdocs.pm/mix/Mix.Tasks.Archive.Install.html? That's how `mix phx.new` works for example, which can be used anywhere on your filesystem.
Seriously?! The book is only $25. They regularly offer discount codes that bring the pricing even lower. Don't take advantage of their lack of DRM, just buy the book so the authors get paid for their hard work.
we are working on our July Meetup, its a workshop. Elixir OTP for beginners [https://twitter.com/elixir\_pune/status/1132690734006407168](https://twitter.com/elixir_pune/status/1132690734006407168)
You can always use Elixir Forum discount...
It is worth the price.
I'm curious what runtime impact this has. As it's applied throughout a large application I can imagine it to start to have some noticeable effect if the data types being checked get large. Static typing systems check the top level type which infers the nested types are also a match (and it's at compile time). No such guarantee can be made here so the full nested types must be checked when the majority of the time it is (or should) be successful. This seems like a trade of overall system performance (not sure how much though or if it will realistically effect anyone) for the error cases to help it fail faster. My question is how much faster and is it worth that penalty to save time debugugging by stopping the cascading error earlier on. I like the creativity though and welcome further exploration in this area. Keep up the good work, thanks for your contribution!
Depends on checked type and OTP version. OTP 22 gained new optimisations regarding type checks in private functions within single module. This can reduce performance penalty in some cases.
Good to know. I would still like to see some benchmarks though.
Validating every function input and output in a tight loop would certainly kill any hope for performance. The use cases which motivated the library were 1. check that what comes after `binary_to_term/2` corresponds to a particular type, 2. check that a parsed and processed JSON file corresponds to a particular type, and 3. unit tests where we check e.g. a state of a GenServer after retrieving it with `:sys.get_state` Cases 1 and 2 don't happen to often in our system and for case 3 we don't care about performance. So it's mostly a sanity check or something that helps during active development or while debugging a remote application.
Yeah the blog post needs to make these use cases explicit.
good luck! lol
It’s probably a good deal for those for whom moving to Malaysia is an upgrade. Nobody from SF is going to find the compensation attractive, of course.
Unfortunately there is no full equivalent tutorial neither books that would provide whole project with Red-Green-Refactoring TDD approach.
I have realized it now. No biggy, I hope my prior Rails knowledge will help me in getting up to speed in Phoenix. The only thing I am worried about is implementing a production grade Authentication and authorization as something like devise is not present in the Phoenix community. The way Michael Hartl dedicated so many chapters in his book on getting the authentication right is truly admirable.
Well there is [Ueberauth](https://github.com/ueberauth/ueberauth) and [guardian](https://github.com/ueberauth/guardian) and plenty of tutorials are available [e.g.](http://blog.nathansplace.co.uk/2018/ueberauth-and-guardian) Plus both books Programming Phoenix and Phoenix in Action have parts where they build auth system
Thanks for directing me to these libraries. Special thanks to the link - thats exactly what my learning goal is - to build an API in Phoenix and secure it with decent Authentication.
Is there a advantage in using Intelli J Elixir over Vscode?
Not looking to start a religious debate but I strongly prefer Jetbrains IDEs as they seem to be more stable and have more features. In general it comes down to personal preference and the maturity of the plugin driving things like intellisense and the like. I’m also a huge fan of this elixir plugin since it really works well, so thank you OP for creating and maintaining it &lt;3
a lot more people, probably including your husband. be careful. =)
I'll give it a try, I'm guessing that using the console it's much better in this ide
Interesting, many thanks. Can you expand on what's included / why? I see some postgres / ecto modules in there. I'm very new to developing on elixir.
which IDE do you use for elixir plugin, I use webstorm for work but it is considered light IDE regarding elixir plugin.
I use IntelliJ. People claim that all the different editors are just plugins, but my experience has been that things are much more stable with the platform things were designed to use (in this case IntelliJ, not webstorm). Running 2 IDEs at the same time can be a pain though, and I’ve had good luck getting the web bits (Vue components, eslint, etc) running in IntelliJ.
Thanks, I was sticking with vscode because IntelliJ is massive IDE, I mean kinda bloated and not meant for Elixir but the thing is I'm used to jetbrains ecosystem even with vscode jetbrains hotkey extension I'm not used to vscode. going to give the plugin another try.
IIRC, none of the Jetbrains products can support the Language Server Protocol..
The market seems to be a bit tight for Elixir jobs at the moment, but it wasn’t 6 months ago so it may open up again. May I ask where you’re located?
I hear ya. Most elixir jobs I have seen are senior + many years of experience. If you didn’t start elixir 4 years ago you’re behind. BUT it does take time. More and more jobs are popping up and I suspect a lot of established companies are using it internally. Which is a good way to work with it, introduce it at work. Heroku is company that uses Phoenix but you’d never know unless you are in the dashboard inspecting network requests. You got to start somewhere and sometimes it’s a risk. But it’s not a waste of time. It’s helped me code better in php and ruby. Learning elixir doesn’t mean you can’t apply some aspects to other domain. Stay motivated.
IntelliJ is a full blown IDE Vscode is more of a text editor
How many years of experience you have? What's your background? I see a new job for Elixir almost every day (on places like the Elixir Slack group), many are remote even. I believe this trend will continue although it will never match Node.js. I got an Elixir contract based on my Ruby skills and interest in Elixir which - in my opinion - should be normal for a niche tech. It's even remote. Unless you plan to use Elixir for your own projects too, don't stress it. Wait for the right opportunity. \&gt; but I got rejected because the job requires Elixir experience I would be very unhappy about a company that puts me through a test knowing that they won't hire me based on something that is clear upfront.
If you have the time/money, you should head to Colorado for ElixirConf in August. I have been the last few years and it is an excellent way to meet people and get more involved in the community. There are lots of folks there who also don't do Elixir full time; they range from hobbyists to people looking to land their first Elixir job like yourself. If you are in Europe there is also an ElixirConf EU, but the 2019 conference has already come and gone. Another good resource is to join the Elixir community on Slack over at [http://elixir-lang.slack.com/](http://elixir-lang.slack.com/), there is a dedicated job channel with a slow but steady trickle of job postings. Some of them are remote.
You can make web games with Elixir. :)
A couple thoughts about the usage: 1. It would be easier to use your library if the functions were the same as those in the existing `Map` module. For example, your `MapStr.get!/2` function works the same as the `Map.get/2` function (no `!` character). The `!` is usually means that an error will be raised when something goes wrong, like with `Map.fetch!/2`. 2. The naming of the module has me a little confused about what it is supposed to do. From the name I thought it was just for maps, but it also works for lists. However it doesn't work for keyword lists. Maybe you already thought about this because keyword lists have to have atom keys. But it might be handy to add some examples of "things that don't work" to the readme. 3. Adding module docs and function docs will be nice if you ever publish this on hex. 4. As you noted in your readme, adding tests would be good. This would probably be a fun time for you to learn about property based testing as well. 5. I was able to raise an error by providing some bad input, not sure if this is intentional or not. If it is, you could potentially return a more helpful error: ``` iex(12)&gt; StrMap.get!(m, "a..b") ** (BadMapError) expected a map, got: nil (elixir) lib/map.ex:437: Map.get(nil, "b", nil) iex:43: StrMap.get_element/2 ``` 6. It is not possible to get a value who's key contains a `.`: ``` iex(12)&gt; map = %{"a" =&gt; %{"1.0" =&gt; :foobar}} # Works doing regular access %{"a" =&gt; %{"1.0" =&gt; :foobar}} iex(13)&gt; map["a"]["1.0"] :foobar # Does not work here iex(14)&gt; StrMap.get!(map, "a.1\.0") ** (BadMapError) expected a map, got: nil (elixir) lib/map.ex:437: Map.get(nil, "0", nil) iex:43: StrMap.get_element/2 ``` 7. Lastly, there are functions that are part of the `Kernel` module that do similar things to this already. They don't support the array functionality that your module has though. Here is an example (there are other function like `put_in`): ``` iex(22)&gt; Kernel.get_in(m, ["a", "b"]) %{"c" =&gt; 1} ```
CTO of a company where the primary backend language is elixir here. So far, most of the devs we've hired didn't have professional elixir experience. It's certainly a plus for us if you do have professional experience (or any experience in elixir, frankly), but it's definitely not a hard requirement. Good devs can learn it, particularly with someone to help them out. I would assume most shops would believe similarly considering the talent pool is fairly small (as you'd expect from something this niche). I'd certainly take a good, seasoned dev with no professional elixir experience but an interest in it over a mediocre dev with elixir experience any day.
Try here https://elixirjobs.net/
TLDR; You might need to question if missing jobs is the only source of your demotivation. Here is my story. I've been learning elixir for 2 years now while working with it on my own side project. I was never demotivated by a fact that in these 2 years we have had probably no jobs with Elixir at all here in 1.5 million Prague (Czech Republic) that can be considered a sort of a tech hub (I hope). Just as you mentioned, I also was excited by something new, functional and running on OTP platform. I was coming from MS/.NET eco-system and was totally fed up with it after 15 years. I needed something new and Erlang/Elixir dynamics totally bought me in. Also I've been following the iOS developer path for the last 8 years with Objective C followed by Swift. Over time, I've become quite unsure if Elixir is right for me and my server side tasks. My main problem with it is its entropy. As a lonely wolf on my side project, I found it too brittle to surround everything with so many tests. While Elixir is genial in project and tests organisation, its missing type system appeared to be more and more of a problem to me. I started to spend more time in weighting alternatives: Go, Clojure... At some moment I ran into Rust and unexpectedly it answered most of my longings. It's been only a month now that I'm into Rust, but I've been able to re-write the Elixir/Phoenix part of the project that I've been writing for 3 months of the full time equivalent. Back to being able to write typed tests and having compiler help on types, this is a rediscovered joy! I know that a few Elixir/Phoenix guys would grin at OTP -&gt; rust Actix, Phoenix -&gt; actix-web, Ecto -&gt; diesel mapping that I came at in my re-work. But for me this is it. Elixir and Swift are representatives of the most modern languages and approaches to coding for me. And then Rust takes these and mixes them in a way that really excites, imho. And Rust is still evolving! So my answer to your "I wanted any advice on how to keep yourself motivated and optimistic." is to look around, Elixir might not be the only ultimate road to a coding happiness. P.S. Both Elixir and Rust have about zero chances of finding job here (Prague, Czech Republic).
Tell me more!
He was referring having it difficult to maintain passion, but games can be made with Elixir, Phoenix is incredibly well suited for web game development. Erlang specifically powers many very profitable web games... specific names I won't mention because it's a competitive space and I don't want to invite too much competition on my friends, but if you have interesting questions I will answer what I can. But you can imagine any kind of turn based multiplayer game which exists can be made with Elixir. It being especially useful for many people playing together in lobbies at once.
&gt;*I mean I’m web developer, I’m not developing games or working on robotics, so is hard to maintain passionate state for web development* &amp;#x200B; Maybe you should try to focus on things you are passionate about instead. If games or robots float your boat, then maybe you can find opportunities there (or elsewhere if those are only examples).
Check out [Elixir Companies - Hiring](http://elixir-companies.com/en/browse?type=hiring). Also, the choice of a language should probably be a more personal one, if you learn it and enjoy it, you will find a job at some point for sure.
Where can I find the said Elixir Slack group please ? Im also looking for Elixir jobs.
I motivate myself to code by doing something fun or useful for me. Last time I was on a Hackathon called "Be Healthy" and made a Raspberry Pi + Nerves powered proximity sensor that I attach to my laptop screen. It detects how far I am from the screen and warns me to improve my posture. It was fun to do something at least a little bit connected to robotics. I am thinking now about making a game based on a board game I own or custom budgeting tool (even though there is a gazillion of existing ones :P)
Low wages and selective employers would generally indicate a surplus in the given class of labor relative to demand. Also HR departments generally deal with technology in a black and white fashion if they arent given better guidance by management. They simply can't judge how skill A can translate into a job using skill B, so some of them compensate by being overly specific. Just apply anyways, how much time does it really take out of your day.
[This is the only slack channel I know about](https://elixir-lang.slack.com)
&gt; How many years of experience you have? What's your background? I have 5 years of development experience, my background is mostly full stack React/Nodejs and a year using Vuejs/Ruby. &gt;Unless you plan to use Elixir for your own projects too, don't stress it. Wait for the right opportunity. Yeah, I think that is the right option, I know that my feelings are temporary and all comments here are really encouraging. &gt;I would be very unhappy about a company that puts me through a test knowing that they won't hire me based on something that is clear upfront. Tell me about it, but I think the whole process is automated because an hour later when I applied I received an email with hyperlink to the test where I had to fill out my name and email, I think they only looked into my CV after I passed the test and not before, a way to filter a candidate.
Oh, I'm from Egypt, but spent most of my career working remotely, though that is a contributing factor, many of Elixir jobs are US remote only, Europe didn't start picking up Elixir yet well there is but nothing compared to the US.
I would apply for jobs that aren't asking for elixir experience but with your expertise ( React/Nodejs ). Then slowly introduce Elixir into your new job if you find any niche projects. Build on that momentum. This is kinda what was happening in some dev shops back when Ruby on Rails was just getting started from my discussions with devs at conferences. Elixir needs non-elixir devs to evangelize the tech in their development teams.
Thanks for an inspiring story, I actually will spend some time to reflect. I have been developing using Nodejs for a long time, but I started to dislike javascript development ecosystem as a whole. At first, it was fun, you had dozen framework with dozen ORM packages with dozen different way to structure and build your project so you can pick and choose whatever you like. these things I liked became my main grievance, packages start to be abandoned or outdated, most of the times some crucial package update breaks the build and their documentation is outdated or incomplete. taking over another node project is hell not because the code is bad but because they use totally different project structure and convection, the worst one I worked on was that there were 4 different promise library used in a single page. Not to mention JS fatigue in general, while I know you don't have to follow every new shiny tech, the project manager and the clients don't see it that way. that why I wanted to learn programming language where it ecosystem have some kind of convention and standards to follow. that where Elixir came back to the picture, actually it was choice between Go and Elixir but I choose Elixir for being FP.
Money isn't my top priority right now, as my current salary is good enough. but I kinda bored and my current job and want something new to work on and I really started to dislike Node development ecosystem.
&gt; I am thinking now about making a game based on a board game I own Thanks! as boardgame enthusiast that never crossed my mind, all my focus was on Web development in general. I mean I don't have to develop an entire game, I can make a helper tool to speed up game setup/gameplay.
You guys need more elixir devs?
We’re not actively hiring right now, but we’re opportunistic if the right candidate comes along. Feel free to dm if you’re interested. Not sure what the rules are about recruiting on this sub.
Yeah, that’s a trickier scenario. You may want to look for. Place that does node and elixir, and try to move into it sideways.
It's interesting because I just watched Aaron Patterson's (tenderlove) RailsConf keynote and he talked about how he wanted to do Rails and took like a 25% paycut to get his first Rails job. Obviously not everyone is in a position to follow their joy but basically every tech starts with a smaller community of enthusiasts. Maybe look for opportunities to introduce Elixir into a current job where it's a good fit or (and you might have to use your own time to do this), do a POC of something in Elixir and present it. This is how I introduced Python in a previous job (and, at that time, Perl looked like it was a great bet for the job market). Or -- keep gaining experience or doing your own projects and when the market catches up to Elixir's awesome you'll be better placed to take advantage. The worst case is that you get to code a bunch of Elixir, which is still pretty, pretty, pretty good.
 Hey everyone, in the previous articles we’ve seen how to build a small Phoenix app that processes user uploads, creating thumbnails for images and PDFs. The problem with the current app is that nothing is shown during the upload, which is maybe ok while testing the app in localhost (the upload was fast also with big files). But in the real world an upload could last minutes.. or even hours. So in this part we focus on the front-end and see how to use JavaScript to upload a file while animating a progress bar. At first we see how to add jQuery to our Phoenix app and using it in our JavaScript files. We then see how to use jQuery to upload a file and listen to progress events to update an HTML5 progress bar.
&gt; While Elixir is genial in project and tests organisation, its missing type system appeared to be more and more of a problem to me. Have you looked into dialyzer?
I believe it's this one: https://elixir-slackin.herokuapp.com/
Yes, I meant this one.
I was adding type information to modules just to be able to see myself what my “types” are. I think that all of the books I read, “Elixir in action” by Sasa Juric, “Programming Elixir” and “Programming Phoenix” mentioned dialyzer as something one might need at some point, though I never grasped how to integrate it in my development workflow with VS Code. Thus it stayed as “type annotations” for myself. Are there some pointers for how to integrate dialyzer into development workflow? E.g. with VS Code? Anyway this is something you need to take an extra effort to maintain in sync with your modules as they evolve?
&gt;I have 5 years of development experience That sounds as it should be enough. I also had other things going for me (like formal education, a famous previous employer, ...) so I don't want to sound as only Ruby got me the job, but I can say that I was in a position of hiring people before and I would certainly not disqualify you for this. Most companies have broken hiring processes unfortunately.
&gt;It detects how far I am from the screen and warns me to improve my posture. Hah, also needs this one!
I'm from Chile. The most language program used here is PHP, because is cheap (Senior PHP programmer for US$1k per month) . Then comes the financial segment, using Java or .NET, like banks, and yet they need COBOL programmers. Projects with Ruby are really rare (Some startup use it, then die or change architecture and language), and my case, I work for 3 projects with RoR, one of them, working as freelance. Now I working on a Elixir API project, learning on the way, reading "Functional Programming with Elixir" and surpraised with all this new horizon.
I'm working on a statically typed language for the Erlang VM, it's called [Gleam](https://github.com/lpil/gleam) :)
Is this podcast about Elixir or Kubernetes?
Agreed. There are specific talks this year addressing the concern about the Elixir Dev scene. Hopefully it will move more companies to Elixir and to taking on non-Elixir devs to build their Elixir dev team: [https://elixirconf.com/2019/speakers/40](https://elixirconf.com/2019/speakers/40) [https://elixirconf.com/2019/speakers/49](https://elixirconf.com/2019/speakers/49)
I work for this agency, hi. The value in having an account is so you can get access to all the jobs in your specific field in one place. There may be 10 other companies using Elixir that you'd like to know about as well as Trivago. We use a GitHub integration to fuel the matching, therefore having an account makes the platform work for you. If we just created a job scraper with no user data then you'd have a very terrible job board 'indeed', ahem.
I've heard the excuses before. Doesn't change anything
Hi, I worked in the recruitment industry for over a decade. I can assure you that my clients paid me 30-40% fees for my work, often outbidding each other. That's because I found them the outstanding candidates, pre-vetted, pre-closed, a perfect company fit. The candidates got guaranteed interviews, jumping ahead of the 1000 deep CV pile, they got constant coaching, interview prep, interviewer background, company culture insights, aggressive offer negotiation, and an ongoing confidant... for free. I think they liked knowing I was highly financially incentivised to get them what they wanted. When you have a great experience, you'll know it.
Dialyzer is a static analyzer that checks your type annotations. I'm mostly happy with dynamic types, so I haven't used it much personally, but conceptually it should provide most of the safety benefits of strict typing to whatever extent your code includes type annotations. It looks like there's even some IDE support. * https://github.com/jeremyjh/dialyxir * https://github.com/JakeBecker/elixir-ls
My first question is "why"? Recursion is very common in any functional language and replacing it with reduce is, generally, working against the grain. And re: your last point of "I think recursion in general can be rewritten in `reduce`", it's worth noting that there's a whole class of recursive functions that strictly cannot be replaced with loops. They're less common to see in the day-to-day, but they do exist.
Also, reduce is implemented by recursion under the hood anyway
 In this case the "accumulator" is the partially applied function that at each step gets more and more "applied" -- in reverse order of arguments. The curry function will build up a list and then once the function is fully applied it will reverse that list and apply it to the uncurried function
Definitely check out elixir-last for vs code. It uses dialyzer to detect errors with your type specs and even suggests typespecs inline with functions that are missing typespecs!
I would imagine you would put the tests at the module boundery or the like when data is coming in from outside
This really is none of my business, but I hope they compensated you for the time you spent on this. This is a huge project for a coding challenge, imo
Unfortunately they didn't and as far as I know the companies in my country don't compensate for the challenges. And I spent three weeks in this project, since I had to learn the language.
I have 2 questions: - why not ETF? It is simple and straightforward format that can be easily parsed in any language (I have written parser in Rust and I am working on other languages) - if you want structured data, then why not ASN.1?
yeesh, which country is this? also: rejoice you know a new language and perhaps picked up some new techniques. use that to your future advantage :)
not the author, but: protobufs are very efficienyt in terms of serializing, sending, and deserializing, and there are great libs for just about every language already out there.
Brazil. Yes, I wanted to learn Elixir but was still focusing in RoR.
I just gave it a cursory glance and it does seem like you accomplished a lot here. The big thing I first noticed is that you put a lot of logic in the `router.ex`. I would much prefer to have a very simple router that only has the job of routing to a particular controller (following the MVC pattern of frameworks like Rails and Phoenix). Any particular reason you decided not to use Phoenix? No issue with not using it, but when you're starting out, it might be nice to see how it sets up the router and controllers. &amp;#x200B; There are a few minor code style things that I noticed as well: \`case account.admin == true do\` for example ([https://github.com/emerayo/challenge/blob/master/lib/challenge/router.ex#L108](https://github.com/emerayo/challenge/blob/master/lib/challenge/router.ex#L108)) . You don't need the \`== true\` in the case statement as you pattern match on that below\`. &amp;#x200B; Lastly, I would recommend running the formatter \`mix format\` as well to make the code a bit more 'standardized'. Personally, I think doing something like that adds a bit of polish that is nice to have when you're interviewing. Best of luck and good work overall!
The specification of the challenge didn't say anything about Phoenix, so I assumed it should be done without it. I agree with the router having too much logic, I did see some examples where the router did route to a controller but tried to keep it simple as a first try. I used Credo and Codacy for code style. Next time I'll use the `format` too. Thanks a lot for the feedback.
I second the opinion of simplifying the router otherwise I think this is fairly well done and I do like the fact you generated API documentation, built out authentication and wrote tests as well. I wish you luck in finding a job it seems like with the effort you put it most teams would be lucky to have you.
Vscode remote really takes this setup to the next level of utility. Great write up
I'll make this change in the router to use controllers. Thanks for the kind words.
The distinction between build-time and run-time configuration has been one of the most confusing parts of releases for me. Really nice to see improvement in this area!
Sorry I haven't been very active on Reddit (or anywhere else either really) this last month, but that's a great idea! I actually was going to give a talk on that at LoneStar ElixirConf a couple years ago, but morphed it more to talk about custom primary keys and upserts. I'm going to be pretty busy for the next couple months (I'm getting married in July), but I'll see if I can make that happen here pretty soon.
As well as ASN.1 as almost all languages supports TLS certificates which are encoded as ASN.1 (in DER encoding).
Congratulations! I’ll keep checking back at your website, and creating some projects of my own :)
I'm sorry. I did not notice.
This is huge! Finally a convenient way to use ElixirLS in a docker environment, been waiting for this forever!
so all those posts i've seen in the 'New' section dated from over a year ago, are actually new?
They are not new. They were caught in the spam filter when they were originally posted and were never processed by a moderator until now.
You can invite me, I'll remove obvious spam that doesn't get past the filters.
I rewritten the document in English. We use the Time module to measure execution time. There is an example in readme.txt. https://medium.com/@kenichisasagawa/deep-learning-with-elixir-78a62a61e6bd
A few of Python's bigger ML libs use protobufs for communication in production through gRPC and from the example in the article this looks like it was created for the purpose of communicating with python for the purpose of facilitating ML. If I had to guess the author was familiar with them from that aspect and chose to keep things consistent when doing this implementation. Though I feel like this question is kind of a matter of personal taste on your end its like why not XML instead of ASN.1 or ETF it is incredibly well structured, probably better supported than either of them and every language I've written in has incredible support for it. I'm not seriously asking that question of course. The point I'm making is there are trade-offs between every type of serialization format for a given task.
I'm on Reddit fairly extensively during... well... every day (US Eastern timezone) and have been here for nearly a decade (sad, I know). I've moderated a few niche subreddits, but definitely wouldn't mind helping out with some moderator queue cleanup and replying to mod messages.
I am able to mod. I’ve moderated other programming communities in the past. Plus I manage a team of elixir developers right now so technically I am already a mod in a way.
I thought this project failed?
For fun I tried it just to see what would happen (I normally use Vim) and it worked, but any time I edit a file in the remote container VSCode instance it would take 6 or 7 seconds for the remote container to pick up the change on disk. Where as without using remote containers, I can see the change immediately (less than 1 second) using regular Docker Compose and a regular code editor. I have a standard Docker volume set up in my `docker-compose.yml` file to mount `.:/app`. Did you experience this issue too?
I can’t summarize experience in concrete, but it definitely feels that remote tools work with lags now - and with editing files, and with running commands in remote terminal. I’m not sure, why it’s working like that, but probably it will be faster after release.
I'd be happy to help out as well. I'm invested in the Elixir community and on here pretty regularly during afternoons and evenings (East Asia).
Just so you guys know, the biggest Elixir Language discord server has some of the actual developers of discord itself on it!
Right. So for clarity, editing the file in the editor itself is pretty much instant. Even the language server responds back with context correct autocomplete pretty quickly (about 1 second to get tooltips and things like that). But if you edit a file, goto the browser and hit reload, it hangs for 5+ seconds and then eventually reloads with the changes. Is that the behavior you're seeing too?
Although I'm not willing to mod here, I appreciate your honesty. This isn't the worst sub in the world but there is a need to filter some posts. I hope you find some sane volunteers
I am new to Elixir but doing several side projects with Elixir. I visit this sub frequently and could help with moderating. Although I have never been a mod before.
Which BEAM version have you been using? Could you also test Elli server as well?
One thing to consider regarding CPU usage is that the BEAM will try to keep the CPU "hot" by running idle work when it has no work to perform. This could be why the CPU usage is so high. It's important to look at the BEAM scheduler utilization stats if determining how much CPU is actually being used for real work.
The cowboy-static results are the most surprising to me.
Sounds like a good one to try: &gt; If robustness and performance is more important than general purpose features, then elli might be for you. https://github.com/elli-lib/elli Also I like when software repos use "this might be for you" type of explanations.
Thank you so much!
As far as I understand only pros of using VSCode remote is not to have elixir =&gt; ElixirLS installed locally? I don't really get it, why would I want to connect to container to edit code if I have already setup the service volume as `.:workspace`.. so I can use git, mix, npm... locally and still run application through container's environment. Again, while I see advantages of running app through containers, and potential use of it for deployment. I really don't understand why I should consider VSCode remote for local development. I will appreciate any response.
Yes, you are right. The point is that you should have nothing installed on tour host machine. If the speed of the solution would be the same as for the host, it should be the only suitable way for development: you can bootstrap development process on every host in seconds. Imagine the situation: your new freelancer need to fix css layouting for one of the eex templates. He uses Windows host and has no idea what Elixir is. This will be his first and last task. Do you want to spend a whole day helping him install development environment? Compare this with: git pull -&gt; open in vscode-&gt; mix phx.server -&gt; code change -&gt; git commit push -&gt; goodbye
Experience requirement for what is basically a niche language... Brave demand.
Thank you for the response. Would not it work with the following steps: 1) git pull 2) docker exec -it -w /workspace app_name /bin/bash 3) mix phx.server 4) (on your host) code change in any editor 5) git commit push Or am I wrong? P.S. I really liked your step by step explanation in the article =) Will be happy to see similar step by step article about deploying to production using containers.
I believe reduce is turing complete so you certainly can
Have you tried using other benchmarking tools as well? Almost every other benchmarking tool I use besides `ab` provides better results across the board.
Hi u/emerayo, &amp;#x200B; First of all, nice work. When I give assignment/challenge to someone, I expect a working solution with assumptions documented. Bonus points for test cases and documentation, which you did. &amp;#x200B; I did have something - in /v1/transfer, you are just updating the balance of origin account and not the destination account. Also, when you do multiple update/insert queries that require atomicity, you should use transactions. &amp;#x200B; Imagine a scenario where you transfer some amount, let's say X from account A to account B. &amp;#x200B; You write the following logic: &gt;A = A - X &gt; &gt;B = B + X If an error occurs after statement 1, A will lose amount X and B will not gain amount X. &amp;#x200B; That's why it is advised to use transactions (SQL database feature): [https://hexdocs.pm/ecto/Ecto.Repo.html#c:transaction/2](https://hexdocs.pm/ecto/Ecto.Repo.html#c:transaction/2) [https://www.postgresql.org/docs/11/tutorial-transactions.html](https://www.postgresql.org/docs/11/tutorial-transactions.html) &amp;#x200B; Which will rollback the state in case of errors. &amp;#x200B; Also, as some other people have already pointed out that you should keep the logic separate from the router. &amp;#x200B; Otherwise, great job.
You are probably mistaking it with the Elixir token/cryptocurrency/yada-yada project.
Oh, that's true. Should have payed more attention in the transfer. Thanks for the feedback and the explanation.
Do you know, I realised this a couple of days after and felt rather silly - downvotes were well earned. On the plus side I read through this sub and found it cool how much people are into this specific elixir project
Also with this release it's possible to try release without relying on master elixir. Just like the hexpm team is doing. [http://blog.plataformatec.com.br/2019/05/updating-hex-pm-to-use-elixir-releases/](http://blog.plataformatec.com.br/2019/05/updating-hex-pm-to-use-elixir-releases/)
Nice. I can no longer live without Elixir so keep it up!
Using \[put-niche-language-name-here\] plugin on any Jetbrains IDE always tends to be kinda hacky, it generally consists in simple syntaxic coloration just to say "Yeah yeah I know this hipster thing exists, but I'm a damn' Java IDE dude.". Meaning you won't having fancy voodoo Jetbrains magic while using Julia on RubyMine, or Elixir on IntelliJ. My advice: just save your electricity bill and close IntelliJ to use some simpler text editor (Sublime, VSC, Atom, Vi, Emacs, etc.)
Yes, you are right. The only difference is one more level of automation - development tools are also automatically bootstrapped in VScode variant
&gt; Cowboy isn't very performant. Then why does Heroku choose [put Cowboy in front](https://github.com/heroku/cowboyku) of their entire site as a router?
Why did instagram build their site with python?
We're a **tiny** community. We don't need more moderators or really any moderation sans extreme spam or unrelated submissions.
&gt; Another important change related to configuration is that mix new will no longer generate a config/config.exs file. Great!
All very good to hear, I've been struggling with distillery releases on multiple fonts so maybe this will make my life easier, especially once adoption and thus documentation and examples increases
Releases is still a subset of distillery. Is not meant to be a 100% replacement in features. But it does the basics. I think it's gonna be good for a quick start on deployment.
It's a very different situation compared with Rails or Django. The performance cost of using Phoenix vs just using Plug or even building straight up from Cowboy (which I did for the original version of my site) is negligible. The current site, running on Phoenix is actually a bit faster on the same hardware due to more optimized templating.
Kevin Systrom used to work at Google and he knew Python and Django. Django was a very common choice for their internal apps in the late 2009s. I suspect he chose a not-so-performant but productive, high level language because he had no idea if or how quickly it would succeed and he wanted to optimize for productivity. 99% of the time that's the right choice and while they had some scaling pain, it worked out fine. In contrast, Heroku's choice at the router layer depends a great deal on performance characteristics and from day one, they've had a stronger technical team than Instagram's was in its early days, so they haven't had the same set of tradeoffs.
&gt; In contrast, Heroku's choice at the router layer depends a great deal on performance characteristics and from day one, they've had a stronger technical team than Instagram's was in its early days, so they haven't had the same set of tradeoffs. Your argument isn't very convincing. Phoenix with Cowboy seems to consistently perform at about ~3% to ~10% of the top performing http servers, and the large discrepancy is not because of Phoenix. Clearly if Heroku chose it, it's not because of performance.
The fact that you've boiled "performance" down to a single number leads me to believe convincing isn't on the table. Cowboy isn't breaking records in benchmarks, but it does have performance characteristics that are suitable, and have been used for very high loads. In my own experience, Cowboy webservers can, more often than not, handle more traffic than Nginx, which in turn is significantly faster than Node, which is an adequate web server for many massive systems, including Uber's dispatcher long after they'd scaled out across the world. If you're running Facebook-levels of traffic or have unusual networking demands, then yeah, you're probably going to want your infrastructure handled by something lower level. For 99.9% of companies, Cowboy isn't going to be a problem.
Hello everyone, &amp;#x200B; Just an update on the moderator situation: I've received a surprising amount of messages from people volunteering to be moderators, somewhere north of 50. I honestly wasn't expecting so many people to volunteer for such a (relatively) small community. Obviously, that many moderators would be way overkill, so I'm going to have to go through all these messages and pick people based on time zone distribution, prior experience moderating (whether on Reddit or other kinds of communities), level of experience with Elixir, etc. This'll probably take some time. I'll post another subreddit update once it's done.
It's not necessarily about how long the moderation queue is. It's as much about getting things done in a timely fashion. Having a few more people is helpful in that regard. I am only one person in the CE(S)T time zone and I have quite limited time to check Reddit these days.
I think Elixir releases have everything that distillery does, except for hot code swapping? Which is reasonable, one rarely needs hot code swapping at the VM level in production anyway.
I’ve always wanted an excuse to use rustler somehow. Cool piece of tech. Not to be rude, or discount the engineering efforts here, but I never saw the point of the memberlist in giant rooms on discord. You can’t actually keep track of anyone and I don’t know 99.9% of the people on the list. It should just be the mods imho. Great work either way, cool to see discord constantly pushing the limits of erlang.
How well does it handle the abuse? Also have you had to use it yet?
Good lord that looks complex
I wonder if it's not even overengineered?
It increases job stability x10 as well
Look a glance. First reaction was, what the fuck? Phoenix + React + Puppeteer + GraphQL in Ruby on Rails?
Thank you for the comment! Right, it looks complicated. In our case, we came up with the solution because: * Ruby on Rails is **historically** used in a 7-year-old application. We need to have an API to support multiple API consumers with different requirements (website, mobile apps, 3rd party developers) – GraphQL makes sense. * We **like** using React and wanted to reuse already built React components. Puppeteer is the cost for that to render the content faster. However, it adds very little overhead and doesn't require an infrastructure – pre-rendering happens on a CI server in a few seconds. * Elixir with ETS replaced the page requests instead of Ruby on Rails with Redis to further improve **scalability** for Universe events such as [The International 2019 Dota 2 Tournament](https://www.universe.com/events/the-international-2019-dota-2-tournament-shanghai-tickets-seattle-5VP62W).
No, yeah, this solution does sound like it makes sense for the requirements. And the article seemed well thought-out and thorough (although I admit I only skimmed it). You must have a lot of smart people to figure all that out and set it up. I'm curious how long did it take to develop?
I love Elixir because of the small nuggets I pick up over time. The realization that "if you can send a message, you can test it" was pretty powerful when combined with the fact that Elixir can run lots of mini "programs" independently (processes). It's not rocket science, just the basics applied to everyday development.
Good question! It took approximately 2-3 months for just 1 full-time developers to iterate multiple times and build everything as a new project: new Phoenix app, new React app, pre-rendering, performance improvements, location detection, etc. There was also another part-time developer involved in improving: search API with Elasticsearch, setting up queues, tracking, etc.
You can check the book elixir in action. Throughout the book it shows an example to develop an elixir application using supervisors.
The Udemy courses by Stephen Grider are great and they'll teacher you elixir and phoenix. They do cost about 10-12 bucks depending on the time and the sale he has going on. I've never seen them not be on sale, though. That said, they're worth the money if you can swing it. He explains absolutely everything he does and you really come away with a strong understanding. I do suggest you kick the playback speed up to 1.25x. My only complaint about his courses is that he talks really, really slow.
The Udemy courses by Stephen Grider are great and they'll teacher you elixir and phoenix. They do cost about 10-12 bucks depending on the time and the sale he has going on. I've never seen them not be on sale, though. That said, they're worth the money if you can swing it. He explains absolutely everything he does and you really come away with a strong understanding. I do suggest you kick the playback speed up to 1.25x. My only complaint about his courses is that he talks really, really slow.
That's basically the [focus of my YouYube channel](https://www.youtube.com/playlist?list=PLFhQVxlaKQEnOuhDZ5p8jB9U-GHM9U8VM)
If you just want to cut to the chase, I recommend looking at some real world applications that are open source. 2 projects that come to mind are https://github.com/thechangelog/changelog.com and https://github.com/hexpm/hexpm. Then just pick out what you want into your own project.
I agree with this too. It's far too easy to stick with guided tutorials for too long. I prefer to learn something small, use what I know to try to build something, learn a bit more, build more, learn, build, learn, build… in a tight loop. Doing too big of a block of study up front is slower.
Looks great! Subbed. Thanks!
I also like videos too. I watched a number of yours on Youtube. Videos for me are either great for ensuring I learn something hyper specific (like how to implement pagination on an Ecto resource) and immediately implement it into my app, but sometimes it's also nice to hang back and just passively watch a video hoping to take away a nugget or 2. In the 2nd case the video almost acts like a safety net to where you know if you go back to it later the end result is some type of working code (hopefully). Have you ever considered open sourcing your site by the way? In my opinion the real value is the content, not the platform.
I really enjoyed this episode, thanks!
I'm a fan of the Dave Thomas course: https://pragdave.me/
Elixir for Programmers is an awesome course
hey, we are developers like you. A group named ElixirEcho We gather on google hangouts, share screen, open the changelog repository and dive into the code. We discuss what might be happening in particular module/code. If someone has thoughts or something to add, he/she speaks out. We keep changing the presenter as people show interest. We are not the experts, but we are learning. At the end, you are not left empty handed. We conducted such sessions twice. Every session was planned for an hour, but it lasted more than 2-3 hours and we had to stop discussion(it was late midnight) and disappoint people. Tentatively, we planned this for every alternate Wednesday/Thursday. This is Remote so anyone can join. If you find this interesting, plz do join us. Find ElixirEcho on Telegram. Again, we are not experts but we are growing together helping each others.
that is amazing thanks for the invite, would love to join in. :-)
I haven't seen this site before. I truly appreciate seeing such a large Elixir application be open-source. Going to give this a listen soon!
Mate, I remember answering a similar question about OCaml the other day, and you posted that as well. Your enthusiasm is commendable but I hope you are sticking to just one (be it elixir or ocaml) till you get comfortable with it. In my xp learning multiple PLs at once only leads to confusion and I end up not learning either of them well.
I am doing a project in one every week for the next few months and then will shortlist around 3-4 that I would like to go deeper into.
Thanks for the kind words! I'm a big believer in the idea of moving the "free line" outwards over time as a content publisher (even a tiny solo one like me!) builds a larger library. Open sourcing the site itself is a bit, tough. For one thing, I am working on making the platform more differentiated over time, as I'm able. The other thing is there are easter eggs that some users have enjoyed quite a bit, and any kind of open sourcing would kind of put an end to that!
Hmm, I think compiling with elixirc should include the debug info. I’m making this conclusion since the only flag I see for elixirc related to the debug info is to disable it: https://github.com/elixir-lang/elixir/blob/master/bin/elixirc Did you build the dialyzer PLTs? Although, I think it could be nicer to start a new mix project, add dialiyxir and put your solution for each exercise in a sub directory of lib!
Great article, thanks.
Thanks!
Which time zone?
It literally changes everything, do you not login to Amazon to make an order? How can we process people's job applications, or pull your GitHub info, or your messages or dashboard or history or saved info.... It's like trying to use LinkedIn without logging in.
To stick with your highly disingenuous analogy, how successful do you think Amazon would be if you needed to create an account and log in just to look at products? Not to place an order, just to see if they even have anything worth buying to begin with? How long would Github have survived if you needed to sign in every time you looked for projects, browsed code, downloaded a public repo or installed something over package managers like npm leveraging Github hosting?
Indian Time Zone. (UTC+5:30)
- [Part 0](https://blog.nootch.net/post/event-sourcing-with-elixir/) - [Part 1](https://blog.nootch.net/post/event-sourcing-with-elixir-part-1/) - [Part 2](https://blog.nootch.net/post/event-sourcing-with-elixir-part-2/) - [Part 3](https://blog.nootch.net/post/event-sourcing-with-elixir-part-3/) - [Part 4](https://blog.nootch.net/post/event-sourcing-with-elixir-part-4/) - [Part 5](https://blog.nootch.net/post/event-sourcing-with-elixir-part-5/) - [Part 6](https://blog.nootch.net/post/event-sourcing-with-elixir-part-6/) - [Part 7](https://blog.nootch.net/post/event-sourcing-with-elixir-part-7/)
Hey, thanks for all your work with Commanded!
Nice username, I used to own dotdash-dashdot.com
Would you say your series of blog posts qualify as a miniature Phoenix and Elixir tutorial? I read through 0 and 1 which gave me that impression.
Awesome!
Function names (but not variable names!) can end in question marks. It’s just a naming convention to indicate a function returns a boolean value.
Trailing question mark indicates the function returns a boolean. A trailing bang signifies a function or macro where in the case of a failure it will raise an exception ``` Many functions come in pairs, such as File.read/1 and File.read!/1. File.read/1 will return a success or failure tuple, whereas File.read!/1 will return a plain value or else raise an exception: ``` Keep in mind these are just naming conventions
Bang means that function can raise an error Question means that function returns Boolean response. These marks are not special symbols, either last symbol of function name. This mean you can not use while writing your own functions.
The question mark indicates that the function returns a boolean value, so you can read your code like a real English sentence.
Thanks guys!
It's a convention inherited from ruby. (Brief answer given the many answers below)
To complete the other answers, the documentation has a comprehensive page on all the various naming conventions [https://hexdocs.pm/elixir/naming-conventions.html#content](https://hexdocs.pm/elixir/naming-conventions.html#content)
Variables can use trailing question marks and bangs just fine.
Oh yeah... I was thinking of Ruby.
Some developers in other languages describe their methods with isValid() or similar notations. valid? Is short and clear imo. is it valid? Yes or No
What happens if you leave the hyphen out of the regex?
I get the same result.
\W will match anything that is not alphanumeric or an underscore. What do you want to split on?
Not sure why you have that \\W in there, but maybe this helps: &amp;#x200B; `iex&gt; String.split("one-two_tree four", ~r/[\s_]/u)` `["one-two", "tree", "four"]`
I added the full code in an edit of the post. As an example, I want it to not split the word "co-operative" into \["co", "operative"\].
But what do you want to split it on? If it is blank spaces and underscores then use the code /u/kioopi posted.
I need to split the string on all characters that are not alphanumeric or a hyphen. I think this will only split on white-spaces and the underscore character. It wouldn't work for something with a comma or another punctuation mark.
I want to split on all non-alphanumeric or hyphen characters. This would only split on white-spaces and the underscore character.
`iex&gt; String.split("a-b_c d,e?f.g", ~r/(?!-)[\W_]/u)` `["a-b", "c", "d", "e", "f", "g"]`
Thank you! I got all the tests to pass now.
I typically use ? For variable names if they are booleans and ! For variable names if they are going to be rebound in the function body (either directly rebound or as a result of using a with block, for example)
Practicing here is helpful because it gives you a lot of supplemental information about the regex syntax. Once you work it out there, bring it into Elixir. https://regexr.com
Thanks. I especially like the cheatsheet. Bookmarked it in my browser.
If I'm not mistaken, some functions use `!` to signal they change the underlying object instead of returning a new object.
When combining alot of ecto multi are there any gotchas to be aware of? Like, can there be any issues if things are similarily named?
Elixir does not have objects, it’s functional language. You are confused with Ruby
*facepalm* I'm sorry. I just saw the question and didn't realize this was the Elixir subreddit, not Ruby.
This site is my savior
~r/[^\w\-]|_/ will work too. The caret at the beginning of the brackets negates everything inside the brackets.
Hi, Add the adapter part inside of the repo itself in the use Ecto.Repo part. Not in the config.
Thanks! worked! Change made: defmodule MyApp.Repo do use Ecto.Repo, otp\_app: :my\_app, adapter: Ecto.Adapters.Postgres end
Stephen Grider is AMAZING. I've seen tons and tons of different courses... he's one of the few instructors who "gets it" in terms of his teaching method. After I finished an algorithm course with him, and was basically unsatisfied with every other resource and explanation, I bought all of his other courses, including the Phoenix / Elixir one. Going to go through it right now!
That full time developer sounds like a beast
Can you point me towards the algorithm course by him? Would love to take it.
Sure: [https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/](https://www.udemy.com/coding-interview-bootcamp-algorithms-and-data-structure/) The one thing I'd say here though, is that this uses Javascript. As a frontend developer, it was the easiest and only thing that was able to quickly teach me a lot of the things I got asked on interviews, and helped me get a job.
Thanks for this. I learned some new stuff about things like deferred loading js. I believe your caching/cdn/ci layer is way too complex, why is puppet there, aws lambdas, gcp, oh my. It could be cleaned up a lot but that is the usual course of development, giant experiment bag, then you slowly unload it once you found what works. Phoenix has no purpose in this stack IMO, you could just use a simple webserver, depending how performance conscious (maximizing cpu) you are (since your serving GraphQL requests off lambdas), guessing price is not a factor, so using pheonix at its 4x\~ feature bloat performance degradation compared to a vanilla 'hello world' web server is ok. Any yea why not use SSR off the lambdas? Heh, HTTP/2.0, I would follow up, "HTTP/3.0 is a new version of the HTTP network protocol..", if your maximizing these 1% conversions due to load time, I would skip HTTP/2.0 and go straight to HTTP/3.0, HTTP/3.0 uses UDP so it gives the ideal roaming mobile experience. Considering Google cracked down on non-mobile friendly sites. On HTTP/2.0 imagine your user sitting in a car, placing a purchase, they hit BUY, and... it says "reconnecting.. please wait"; the user switched a cell tower and all their HTTP/2.0 TCP connections got killed. While with HTTP/3.0, they bit BUY, and.. slight 100ms lag due to packet loss of tower switch.. purchase successful! Congratulations +1% conversion rate.
This does not mention edeliver, but does mention the same `:enoent` for `:erl_tar` issue. [https://github.com/bitwalker/exrm/issues/238](https://github.com/bitwalker/exrm/issues/238) I would, however, recommend using Distillery. It has been well maintained and is the easiest path for building Elixir releases IMO. [https://github.com/bitwalker/distillery](https://github.com/bitwalker/distillery)
Hey! Thanks for the reply, I will see if there is something about permissions getting in the way. About using distillery, as I understand edeliver is using distillery to build the package, correct me if I am wrong please.
Maybe this article is of some use: http://blog.plataformatec.com.br/2019/05/updating-hex-pm-to-use-elixir-releases/ With their docker file: https://github.com/hexpm/hexpm/blob/master/Dockerfile
Apart from the \`name\` that must unique, there's nothing that prevents you from chaining multiple multis. &amp;#x200B; From the top of my head I have one use case with 7 operations and I have no issues.
It looks like the release you're trying to upgrade isn't there. Anytime you see `enoent` in an error code, it means "the file or directory doesn't exist". Try building and deploying a full release. Then you can use it as a base for upgrades.
Yes. Edeliver uses Distillery to build releases.
I choose Elixir because i really want a better sleep at night 🤣
The first build and deployment goes fine.. it is only when running the upgrade command that I get the error, I am able to see the tar file where the new release is going to be, but it never gets unpacked .
The banking point is out of the blue. Simply being a functional language is not the only argument for banking usage. Elixir would make for a great auxiliary tool there, but I don’t see it a CBS contender. I’d love to see real examples, not “it’s functional” argument.
Yeah, "functional programming" has become a very hand wavy term recently. "Why is this thing better than that thing?" Well, that one uses OOP while _this_ one uses 👋🌈✨ functional programming✨🌈👋!
One useful feature for banking is that there is no max integer or integer overflows.
Yes, and if all hell breaks loose while you're sleeping, there's so many great tools and utilities to help figure out what went wrong in the least amount of time possible. That's one of the main reasons I chose Elixir / Phoenix for an upcoming project I'm working on.
I'd say this is precisely why languages like COBOL, Fortran, and Ada are still widely used. One potential problem is that it can be hard to get new programmers for those languages though. But yeah, the tooling around/in the Elixir and Erlang ecosystems are quite nice.
My bank account is always having those issues.
Is have a bank account that uses unsigned integers
Yea, it’s not as likely to be a problem with individual account balances, but overflows could easily happen during various calculations.
Worth mentioning that `:array` is defined as tuple of tuples.
Hi there :) Thank you! I was honestly ignorant of the fact that `:array` existed or maybe I forgot... I think I've never seen it used. Woopsie. I added it and somewhat interestingly it seems to [perform far worse](https://gist.github.com/PragTob/f937029439e4b16de5809c666546ef15) than the "pure" tuples. If you're interested [1d implementation](https://github.com/PragTob/elixir_boards_benchmark/blob/master/lib/board/array1d.ex) [2D implementation](https://github.com/PragTob/elixir_boards_benchmark/blob/master/lib/board/array2d.ex) I'll update the blog post and friends some time after breakfast (there's sadly a minimal manual process involved in stripping the table of links etc).
This is awesome. Thank you for the analysis!
Updated the blog post with this info :) Thanks for pointing it out again, I learned something :)
This is so cool !
Why use hex? Just use your own private git repository. That can be hosted anywhere.
I remember reading similar blog posts about Ruby 10-12 years ago. (Not judging. I'm just reminiscing.)
I'm actually wondering if a I should learn elixir/phoenix stack as main tech. I'm Cs student ^^
The guys at Jane Street Capital have a similar talk regarding their use of OCaml. Non-standard tech stacks attract passionate computer scientists who go out of their way to learn. If you're hiring for JavaScript, your net catches everyone from a seasoned veteran to the kid who took an online class.
I’m not OP, but versioning. With a git repo you have to point at a specific ref. This gets to be a pain when you have shared private libraries and you patch bugs. I’m not saying that makes it worth the price/effort, but it can be a big benefit in a medium-to-large organization.
Back when Paul Graham, et al sold Viaweb to Yahoo (mid-late 90s?) for $50M, they (not so publicly) touted Lisp as being their secret weapon because they were tremendously successful at iterating and cranking out new application functionality faster than their competitors. I was deep into Lisp when I first heard about PG and his early work with YCombinator and his hacking on the Arc language. The idea that you could hire better programmers to work for you if you focused on some(even at the time) non-mainstream languages/software/platforms was being discussed and I was paying close attention to the conversations. We were working on some simulation software into which we built a scheme interpreter and wrote scheme bindings which allowed us to use the software in ways we never imagined. Or, at least built functionality in a timeframe we never thought possible. It wasn’t until we added more details to our job reqs that we started seeing consistently more talented developers for interviews. The implication here is that programmers who choose to use these non-mainstream tools may tend to care more about their craft than some guy who just went and bought a Java book to learn database programming. I distinctively recall reading Paul Graham stating that it is for this reason that Python programmers were smarter than Java programmers.
Depends on your definition of "main tech". If you do more in Elixir than other languages, that's totally cool. If you just do Elixir, that's probably a bad thing. You don't want to have all your eggs in one basket, especially if there aren't many companies hiring in that basket. Plus it would be silly to use Elixir for everything - it's awesome, but it's not the best solution for everything, and being familiar with multiple approaches is a key part of software development.
&gt; In a recent talk I said something that upset a lot of people: that you could get smarter programmers to work on a Python project than you could to work on a Java project. I didn't mean by this that Java programmers are dumb. I meant that Python programmers are smart. It's a lot of work to learn a new programming language. And people don't learn Python because it will get them a job; they learn it because they genuinely like to program and aren't satisfied with the languages they already know. Which makes them exactly the kind of programmers companies should want to hire. Hence what, for lack of a better name, I'll call the Python paradox: if a company chooses to write its software in a comparatively esoteric language, they'll be able to hire better programmers, because they'll attract only those who cared enough to learn it. From http://www.paulgraham.com/pypar.html
don't have a main tech. learn them all!
But you still get to tag them with semantic versioning which still works?
8 years ago I was working with a company that had exactly this idea, but with pure Erlang. I agree if you can find the developers they are usually smarter than average, but it was a lot harder to find Erlang developers compared to Ruby developers at the time.
In our team we have the same issues and still using git for private packages. But not so long ago I started to build minimal, easy to deploy and focusing on private teams hex.pm replacement — https://github.com/artemeff/hex_mini. You can try it, but there's still some unfinished work until 1.0.0, more info in Projects section on GitHub.
It's hard to say based on this, but it sounds like it could be a permissions issue. I'd check which user is doing the deploy and the ownership and permissions of the directory.
The major problem I'm seeing with using Git is that Hex seems to be unable to do dependency resolution on Git &amp;#x200B; See [https://elixirforum.com/t/self-hosted-hex-repo/12279/6](https://elixirforum.com/t/self-hosted-hex-repo/12279/6)
That actually looks really interesting, I'm going to check this out when I get home. Hopefully I can contribute something useful!
TBH I think that there should be official repo with recipes for GitHub Workflows.
I have learnt C mostly. I pretty fluent in python and ruby. And my first FP approach was woth Ocaml that i love. I just want to be more specialised in FP in general and elixir is cool.
Pokemon style yeahhhh Ocaml f# scala clojure and elixir yeahhhh
Yes, this.
Last I knew, semantic versioning didn’t work with git dependencies. You can’t say ‘{:my_lib, github: “my_company/my_lib”, “~&gt;1.0.0”}’. It doesn’t know how to turn “~&gt;1.0.0” into “get the git tag with the highest version that satisfies this semver constraint”. With git does you have to specify a ref (a SHA or a tag usually) and that’s just a static string. Unless that has changed, which would be awesome.
Ah yes you're right, I thought with 'ref' you had meant just the SHA
This one is https://pragmaticstudio.com/elixir but it's not free and does not include Phoenix.
It mentions that the release is packages for the same OS and version it's on - so if I'm developing on OSX, I cannot deploy to Linux?
Hi! Thanks for the input and sorry for the late reply. I assumed as much as well, but I still got the error. In the end I just went with setting up projects using the mix CLI and then used the dialyxir package.
Hi! Thanks for the input and sorry for the late reply. I assumed as much as well, but I still got the error. In the end I just went with setting up projects using the mix CLI and then used the dialyxir package.
Good work on making something and sharing it with the world. The best advice I can give you is keep going, I have a lot of (hopefully) constructive feedback for your project, but didn’t want this important point to get lost. I provide the fellow feedback in hopes that it will help you along and not to tear down your efforts, the best way to learn is by building things, so keep building! Took a look at your project and I had a hard time from your post here / the readme there understanding what exactly what this project is, after reading the code I *think* it’s a development tool that is meant to be used interactively to manage a change log (where the change log is one markdown file per release). It does not seem to be something you sprinkle around your code that automatically generates a change log (something like the [Documentation Metadata](https://hexdocs.pm/elixir/writing-documentation.html#documentation-metadata) for example `@doc since:`). Clarifying that in the readme would probably help people understand the primary use-case, and maybe throwing in the rationale / user-story. The first thing I thought after reading the code was, “Why? What problem does this solve? How is this better than just editing the files directly?” Make the value proposition clearer, is this tool meant to enforce consistency, reduce toil, or just a toy to enjoy elixir with. Compare and contrast the problems of directly editing the change logs to the ‘better way’ your project provides. From a technical viewpoint there are some other things to consider. The standard library ships with a capable [Version module](https://hexdocs.pm/elixir/Version.html) that you may wish to use instead of rolling your own string parser. The library isn’t needed in production, so restricting the dependency to `only: dev` might be a good idea in the readme. The code for the most part seems reasonable but error conditions are going to crash out in weird ways, take this code for instance. ``` @doc """ create a new release with a specified version """ @spec create(version) :: atom() | {:error, :bad_version} def create(version) do init() VersionFormatter.format_version(version) |&gt; Writer.create() end ``` If `VersionFormatter.format_version/1` returns `{:error, :bad_version}` this just explodes with `FunctionClauseError` because `Writer.create/1` has a guard that won’t match. The code has lots of happy path programming, you may want to apply the [with construct](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1) here and generally. ``` @doc """ create a new release with a specified version """ @spec create(version) :: atom() | {:error, :bad_version} def create(version) do init() with version when is_bitstring(version) &lt;- VersionFormatter.format_version(version) do: Writer.create(version) end end ``` If the `VersionFormatter` returns anything that isn’t a bitstring it will not call `Writer.create/1` and instead return that error (which is what the spec claims will happen). (This also shows why `{:ok, value}` / `{:error, error}` are normally used because it’s easier to match on `{:ok, version}` than to rely on a guard, fwiw). Cheers and congrats on an early release, open sourcing can be rewarding but also stressful, good luck with your project.
Thanks for the feedback, I'm going to try to implement all your suggestions in my next release :)
🌝
😊
&gt; Finally, I've seen various reports that the practical size limit of a BEAM cluster is in the range of 50-100 nodes. Btw, this was proved to be false in a research paper (here is a link [to a presentation based on it](https://speakerdeck.com/amirghaffari/investigating-the-scalability-limits-of-distributed-erlang)). I will mention the paper results from memory so I may misremember a couple things, but one of the conclusions was that Distributed Erlang could comfortably scale to 300 nodes. The "50 nodes" limitation are actually about global operations (via the `global` module) which require cluster consistency, especially register/unregister. If you are not using global dynamically and mostly for static process lookups, you should be fine. Another potential gotcha is the `rpc` module in Erlang. Because it is a single process, if you have multiple nodes sending messages via the `rpc` module, it may become a bottleneck. But if you are sending messages using the language primitives, you can get quite far. Especially with the improvements in latest OTP releases. And even if you say 300 nodes is not enough, you can use `hidden` notes to establish your own topology. But this is admittedly going very astray from the common usage.
Nice article! I think though your initial example could be fully written with `live_link` and it should actually be simpler. The address bar example is a nice showcase for `live_redirect` (but please don't actually do it :D).
Official repos by whom?
Under `elixir-lang` GitHub organization. It could be even the repo by the OP, just moved under the org.
Hi! Thank you :) Yes, writing it with `live_link` I could avoid to handle the show event directly. The reason why I've used `live_redirect` is because I wanted to show in a more clearer the logic part of event+URL changing via pushState