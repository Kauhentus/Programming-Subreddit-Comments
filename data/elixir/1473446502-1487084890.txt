Does anyone have a recipe for getting a fresh Phoenix Framework install passing dialyxir? As it is the noise of the framework prevents me from using it on most projects... That said we check for typespecs as part of code review and I use dialyxir on anything non-phoenix-based
Thank you! 
That would be a media type that would tell the client to render what it receives as markdown. https://tools.ietf.org/html/rfc7763
I think if there's any way to hide or resolve those issues generated by a brand new Phoenix project we should do that. Has anyone looked into any of them to see if they're legitimate issues?
TypeSpecs are a very powerful mechanism, for a dynamically typed language. You can annotate your functions, hence providing a short overview of what the function takes, and what's its result. It's a big plus for those who'll read your code, and it integrates well with `Dialyzer` and`ExDoc`! On the other hand, keep in mind that those aren't actual Type signatures with an enforced type system behind. No or little type verifications will be made at compile-time and most of the resulting errors will be met during execution time. You can't really compare them to F#, Elm or Haskell's type signatures and type system. **EDIT:** You can however use the function guards (`is_binary`, `is_list`, `is_integer`, etc) to enforce the type of your function's arguments when your program is running. And maybe the compiler will help you as well.
RemindMe! 3 hours
How about sponsorship??
I've just finished reading the Programming Phoenix book and am working on creating a basic web-app admin panel for managing users in said app (since it's something I've done before it should be a lot easier).
Results?
I second this. I'm much too lazy to do this myself.
Sorry for not providing results. I've tested on MacBook Pro (2.7 GHz i5). 1) When n &lt;= 1_000_000 Go is 3-5 times faster than Elixir. 2) Elixir has more stable execution time (about 10% difference between runs). 3) When n = 10_000_000 Elixir is 30% faster. As I understand process in elixir is much more complicated than goroutine. That's make results even more interesting. What results have you expected to see?
Does this mean any function call could automatically be made on a different server, or do you have to specify which calls can be made cross server? Thanks for the info. 
Go 1.7?
Go 1.6. Elixir 1.3.2.
You should try Go 1.7.1. SSA backend in Go led to 10% - 30% faster code.
&gt; On the other hand, keep in mind that those aren't actual Type signatures with an enforced type system behind. No or little type verifications will be made at compile-time and most of the resulting errors will be met during execution time. I kind of expected that. And knowing how helpful I find types in other languages this is a big downside on my book. When you say they are not enforced at compile time, do you mean that the compiler does nothing but `Dialyzer` (if someone runs it) will report issues? How expensive is running it? Is it something that can be run at every compilation? 
With Erlang's distributed nodes you can call any code on any node connected. You have arbitrary code execution, as they call it in InfoSec. You can send code to the remote host to execute, or you can call code it has already loaded. This opens the door for greater possibilities around co-ordinating minion workers with a single master, the master is able to do anything it wants with the minions connected to it.
http://stackoverflow.com/questions/30037914/elixir-lists-interpreted-as-char-lists
These are my average results after three runs with value of n on Windows 10, Core i7-3770 3.4GHz and 32GB RAM. n = 10000 Elixir (1.3.2): 15,3333ms with max variance of 1ms. Go (1.7.1): 6,6676ms with max variance of 1,0007ms. n = 100000 Elixir (1.3.2): 161,3333ms with max variance of 16ms. Go (1.7.1): 66,3332ms with max variance of 3,9975ms. n = 262000 Elixir (1.3.2): 422ms with max variance of 32ms. Go (1.7.1): 176,6664ms with max variance of 5,0015ms. Maximum value I could use for Elixir is 262107, higher than that and I get following error. (SystemLimitError) a system limit has been reached :erlang.spawn(Chain, :counter, [#PID&lt;0.70.8&gt;]) chain.exs:12: anonymous fn/2 in Chain.create_processes/1 (elixir) lib/enum.ex:1628: anonymous fn/3 in Enum.reduce/3 (elixir) lib/range.ex:92: Enumerable.Range.reduce/5 (elixir) lib/enum.ex:1627: Enum.reduce/3 chain.exs:25: Chain.run/1 (stdlib) erl_eval.erl:670: :erl_eval.do_apply/6 Meanwhile maximum value for Go is somewhere between 3800000 - 3900000 before Go starts producing odd output to the console, probably running out of memory. Found a solution to Elixir's process limitation [here](https://groups.google.com/d/msg/elixir-lang-talk/No1Qq0huj_E/3Zsr6cCil_oJ). n = 3800000 Elixir (1.3.2): 5500ms with max variance of 172ms. (values are in milliseconds) Go (1.7.1): 23,9660s with max variance of 9,9140s. (values are in seconds) I was able to take Elixir to 10000000 (completed in 15266ms), at 50000000 it crashed and also caused other processes to crash. I think Elixir/Erlang could use more graceful crash in case it runs out of memory, at the very least it shouldn't take other processes with it.
&gt; it shouldn't take out other processes with it This would be the linux kernel oom killer not elixir/erlang. This is expected system behaviour
We get this question a lot in /r/elixir. I think we should put the explanation in the sidebar. 
What is faster by the way? Go or Elixir?
Awesome. Can't wait for the videos, but at least I can get started going through the slides :). 
According to this article, the common thread between most of these new languages are speed, performance, and safety. And while they are technically general-purpose languages, they achieve their goals best by sticking to their specific applications (e.g. Elm for UI). I wonder when we'll see another language that has a giant accompanying framework, Ã  la Java and .NET?
I wish people would just read Dave Thomas' short Elixir book before repeatedly asking this question. It's right in one of the first few chapters. There's even a way to turn it off per IEX session if you don't like that (admittedly possibly surprising) behavior.
For one, most of these languages are just transpiled to something else. Elm-&gt;JS, Elixir-&gt;BEAM, Kotlin-&gt;Java bytecode. So, in a sense, they can already leverage the currently existing, large ecosystems. In that regard, you don't really get speed/performance advantages unless you are currently targeting a slower/different run time. But, I think the features of any accompanying framework would be a result of how much the creators/owners of the language want to capture and keep developers in their ecosystems. Go has a very nice standard library that is very robust, and I think that follows my thoughts there to some extent. I think you really need to be a big company looking to get some serious market share for those frameworks to be present. Just my thoughts.
I haven't heard much about Nim. It seems like Rust has a lot more visibility, and therefore, will probably grow a bigger community (plus the Mozilla stewardship doesn't hurt). What would be the elevator pitch for Nim? Does it have a strong community?
Wow. Get over yourself.
Try it with crystal. I bet it's faster than go.
I'm not super into it myself, but Nim seems to be aiming at somewhat the same space as Go: Simple and easy to use, strong/static typing (as procedural languages go), compiles to a single, statically-linked executable for portability. It has made some questionable design decisions though. For example, identifiers are case-insensitive and ignore underscores. So "a_record" and "areCord" are the same identifier, which... Isn't great.
Started on a little NLP library, starting first with implementing some stemmers.
Thanks for this. this is something I've done a lot with Node.js so It makes for a good reference as I'm learning Elixir
Really cool link! I'm happy to see cowboy/plug supports https. Nginx might be better in a lot of situations but when you just want to host one bot on say a PI the cowboy way sounds better.
It depends on the number of nodes you want to monitor, and a few other factors. Email to: general at erlang-solutions dot com and ask, someone will get back to you with all the details. Also I'm pretty sure you can get a trial run :)
Over the last few weeks, I've been working on an http/2 client in Elixir called [River](https://github.com/peburrows/river). It's still a massive work in progress, but once I have a working http/2 implementation, the next project on my list is a gRPC implementation on top of it. Some of my other open source libraries would be well-served by using gRPC, so it's a matter of scratching my own itch.
I agree, any idea what would be a better way to describe this library? Dynamic, maybe? I'm not sure that immediately makes me think about server pushing state syncs either. Realtime comes to mind, too. I'm not terribly worried about the wording as long as there is enough material to accurately convey what this lib is trying to do, though so maybe it doesn't matter.
Dynamic is definitely better. `Responsive` is heavily connected to the idea of web sites that work at all browser sizes, so the title threw me off as well. 
Like others said, please use "dynamic" :)
huehuehue - haha no actually I was doing some coffee and hacking around with jay the guy who wrote ratchet and I told him I needed a name that had "ex" in it...he just spit out "texas" so I shrugged and said that honestly that's probably as relevant as any crap I could have come up with.
yeah, but how?
Enjoy testing your Rest Api with Exkorpion!
where is hierarchy?
Below a post to learn how to test your Maru Applications with Exkorpion http://www.wesovilabs.com/elixir/2016/09/13/Maru_application_with_exkorpion/
I'm asking: how can a parent layout render a child one? your solution is wrong. parent layout can't render a child one. what if there're no child layouts? what if there're 20 of them, which one should the base layout render?
If any function doesn't know how to do _xyz_, how can it ever do _xyz_? You're saying that layout1 can't know about layout2, but somehow layout2 is supposed to get rendered inside of it? Exactly what _does_ know about layout2? If nothing knows about layout2 you're never going to be able to render it.
why would it need to know xyz? it's a protocol, a skelleton, a child function should know how to do xyz.
Creating the Permanent Lookup Table (PLT) for the first time is a very expensive operation. I don't run Dialyzer at every compilation, because it's also quite expensive, not as much as the PLT creation though. The good thing is that it takes *all* of your CPUs to run. It usually takes up to 2 minutes on my i5 laptop, and while it can be quite helpful, I prefer adding guards to my function heads and @typespecs for the humans (and ExDoc)
I thought eex didn't do inheritance?
I posted the solution in your previous thread, which you deleted. You can't accomplish this the way you are thinking about it. Because of the way templates are implemented in Elixir (they're just functions that are evaluated like any other view helper), you can't specify the *parent* layout for a particular template, only the layout for its children. A template is just a function. A template can't "wrap" itself in a layout because the parent layout is calling *it*. Here's a very basic example of what's really going on: def layout1(content) do """ &lt;html&gt; &lt;body&gt; #{layout2(content)} &lt;/body&gt; &lt;/html&gt; """ end def layout2(content) do """ &lt;div class="container"&gt; #{layout3(content)} &lt;/div&gt; """ end def layout3(content) do """ &lt;div class="row"&gt; #{content} &lt;/div&gt; """ end So, in your case, it would be: # layouts/base.html.eex &lt;body&gt; &lt;div id="base_layout.html"&gt; &lt;!-- some content --&gt; &lt;%= render(@view_module, @view_template, Map.put(assigns, :layout, "child_layout5.html") %&gt; &lt;!-- some content --&gt; &lt;/div&gt; &lt;/body&gt; # layouts/child_layout5.html.eex &lt;div id="child_layout5.html"&gt; &lt;!-- some content --&gt; &lt;%= render(@view_module, @view_template, assigns) %&gt; &lt;/div&gt;
This was my question as well. I filled out the questions form, but I hate doing that - I always feel like the company will spam me forever once I become "a lead". A general pricing page with the option to inquire for a custom solution would have been ideal.
Sure, you could always get it to pass. But this is why test cases are useful here. If the stub returns a unique string A for id 1 and a unique string B for id 2 and something else needs to parse those strings to return X and Y, then you can only expect to get X if and only if the customer with id 1 went through and Y if and only if the customer with id 2 went through. The downside is you need to "know" that you will be calling the stub inside the adapter. This approach is discussed nicely here https://www.infoq.com/presentations/mock-fsharp-tdd - especially from the TDD point of view. But you're right, there are occasions where it is important to know if something has been called. In that case, it would be more appropriate to use a mock. But mocks can be misused. A good illustration of this is from Mark Seemann's blog http://blog.ploeh.dk/2013/10/23/mocks-for-commands-stubs-for-queries/ The point of Stubr is to make a real distinction between the two - especially when you consider some of the disadvantages of a fully fledged mocking framework (not async, redefining modules, etc...). 
Fair enough. The queries vs. commands distinction really drives it home. I certainly have seen (and probably produced) enough brittle tests to be wary of overusing mocks. &gt; 
I saw on twitter they're hoping to have them up by the end of September. 
Sorry mate, think you have the wrong subreddit. Though, if you ever need high concurrency along with fault tolerance for soft-realtime systems, you have come to the right place. Cheers!
Hope this thread is tail call optimized... :|
~~I think this is really the only way to do it like you want.~~ ~~You could try a different architecture if you feel like it might be a better fit. Maybe keep all the `handle_in` callbacks in the channel file, but just defer to a service module that has the actual business logic, keeping the channel "skinny". Or, break it up into two separate channels.~~ EDIT: Here's how you should do it: namespace your events according to the resource they're acting on, then you can defer to each module by pattern matching on the event string. defmodule App.RoomChannel do use Phoenix.Channel def handle_in("message:" &lt;&gt; _action = event, params, socket) do App.RoomChannel.Messages.handle_in(event, params, socket) end def handle_in("post:" &lt;&gt; _action = event, params, socket) do App.RoomChannel.Posts.handle_in(event, params, socket) end end So, in your example, the "message_new" event becomes "message:new". You don't have to use colons as the separator, but it's a convention that Phoenix suggests for topics, so you can apply it to events as well. Then you can ditch the macros on your sub-modules and just have them be plain function calls. Much cleaner.
There we go. Now it's optimized. https://www.reddit.com/r/elixir/comments/53b040/does_anyone_know_when_are_the_videos_from_elixir
"nope" &lt;&gt; https://redd.it/53b040
Got my first PR rejected on ex_doc =D https://github.com/elixir-lang/ex_doc/pull/600
In comparison with Ruby, in Elixir meta programming has no perfomance overhead. So, if it has at leas any sense - you can refactor your code to macroses without loosing any speed. You use macroses to generate your code - just to make some things smaller in code, or to make some beautiful interfaces to your code. Also, almost all Elixir features are made with macroses, so when you just start to use them - it's hard to stop) Try to read special _Metaprogramming_Elixir_ book to get familiar with usecases and train a bit.
See also https://github.com/jcabotc/channels
It is the behaviour implementing the API needed by mix to work with application dependencies from e.g. git repositories. As a behaviour, on its own it really does not do much. Nearly all the actual magic is in Mix.SCM.Path and Mix.SCM.Git. So why is it public? So you can extend mix .. which is how hex does it. It provides a Hex.SCM as part of its mix integration. Neat, no? :)
A macro is something you might expect to use when you need to create something more like a keyword (think defmodule or defp or case). It's useful when defining a Domain Specific Language. The rule of thumb is, don't use a macro. And if you need a macro, still don't use one. When you absolutely cannot get it to work without a macro, sacrifice a goat and think about it some more. Only then are you allowed to write a macro.
I understand what's going on with the quote/unquote but I think I'm just trying to find good examples of when you can differentiate between "Ok this should be a macro" like I mentioned in the difference from the book in my OP.
â¤ï¸ðððð
A macro is a compile-time function that receives an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) with any arguments, and is expected to return a (probably modified) AST. (It takes code, and returns code.) The compiler then takes that AST and inserts it into the rest of the AST from the rest of the page, then it compiles the page. Now here's where I get a tiny bit hazy and maybe someone can clarify- "unquote" substitutes a run-time value for a name (usually an argument passed to the macro) instead of making a reference to the name in the AST, and "quote" gives you the AST for arbitrary Elixir code. So using "quote" allows you to return an AST without having to write the actual AST (you can just use Elixir code, in other words), and using "unquote" inside that "quote" block allows you to use runtime values in the macro code. [More on quote and unquote.](http://elixir-lang.org/getting-started/meta/quote-and-unquote.html) People compare "unquote" to string interpolation (the value is inserted at runtime), except it's AST interpolation (the runtime value is used). This explanation should illuminate it for you :)
It's not a rebuttal, it's merely insufficient
I already knew this, and yet I feel like I just learned it thanks to how clearly JosÃ© just stated it. Hot damn.
This seems familiar... 
I think matching on function parameters is more idiomatic than using `case`, and `case` is more idiomatic than `if` or `cond`. That doesn't mean you should never use `if` or `cond` - but don't use them when you can pattern match instead.
Your code is correct, pattern matching with guard clauses over conditionals is idiomatic elixir. 
Hey guys, This is the source code for my new website - [Authentic Pixels](https://www.authenticpixels.com). This project has been a great learning experience for me. Coming from Ruby on Rails, there are a lot of things that are done differently in Elixir/Phoenix and building this app has helped me understand the "Elixir way" of doing things. I have added the demo link &amp; some screenshots in the README file. I also plan to write a more detailed blog post about my experience with Phoenix shortly. Do share your thoughts and critiques. 
Sorry for the irrelevant question but how does this work? defp check_guess(a, b, g) when a &gt; g do _..d = b So far I know that _ is used in pattern matching for a value not used. In the OP code I don't even see it being catched. So where does it come from?
Thanks! Actually what I found was that in order to do scoping, it doesn't really matter if you nest controllers inside subfolders or not. Unlike Rails, you can have it all in the root controllers directory. Only thing that we need to keep in mind is the namespacing of the controller. e.g: defmodule Shop.Admin.PostController do ... end I think putting it inside sub folders is just a way for us to organize and understand our code.
I come from a Python background which does imports very differently to Elixir (it's much more explicit about the path, e.g. import ...lib.sub.my_lib would go three directories up and then follow that path.) Given this I wanted to arrange groups of code (what at a user level might be called a module e.g. blog, shop, etc) into folders which you've done with your admin section. My solution was to half-namespace by prefixing the name with the area name rather than using a second dot which I didn't realise will work (food for thought next time!). I like your solution much better than mine.
Yeah, coming from Python and also Rails, it takes a while to realize Elixir does not care about your directory structure at all. It doesn't matter if at runtime or during compilation, Elixir will find the module you are referencing for you.
Hi Rafert. The details are here https://medium.com/software-sandwich/elixir-video-user-profile-service-for-the-olympics-application-teardown-56ac3e103d1a#.qn00776rr
Thanks
Thanks
Excuse me, can you clarify? What do you mean you don't see it being caught? What are you asking, exactly? EDIT: I'm gonna take a crack at guessing what you're asking. b is being passed into the function as a range, i.e. 1..1000 representing all numbers from 1 to 1000. I could write c..d = b. What that does is set c to the lower bound of b, and d to the upper bound of b. In the case of b = 1..1000, c would equal 1, and d would equal 1000. I don't need to know c in that function, so it would just be a useless variable. Rather than write it then, I'm just using _ to ignore it, as I just need d. Because I am pattern matching the range in the form of n..m, i need to also use a range, i.e. c..d (or in this case _..d), to match it. If you look at the third function, I'm doing the exact same thing except I don't care about the upper function, instead the lower one. So I'm using c.._ to ignore the upper bound in order to capture the value of the lower bound.
I see. I forgot that it's not variable assignment but pattern matching. Need to see a lot of code until I fully grasp it. Thank you. I thought that the _ character was used only in function definitions and couldn't understand what it was doing there.
They aren't up yet, but when they are, they will be [here](http://confreaks.tv/events/elixirconf2016) (confreaks handled recording)
Now that I have gotten used to this style, I love it. It is easy to logically follow, and results in quite a bit of logic code reduction inside the actual function definitions.
Really? They must of turned it off
Does this make https://github.com/appcues/exsentry obsolete?
I've been working on ExTrello! Wrapper for the Trello API: https://github.com/ChrisYammine/ex_trello Just published 1.0.0 so that's pretty cool :)
This is the officially supported library. Exsentry is fine but with the new sentry lib we promise support.
Hi, I'm working on an Elixir implement of gRPC. I have finished the code for basic client and server. https://github.com/tony612/grpc-elixir
Definitely check out the Elixir Fountain podcast if you haven't already. http://elixirfountain.com/
Elixir Forum has a running link list https://elixirforum.com/t/elixir-blog-posts/150
Depends if they want to talk to me I suppose. I've joined anyway, thanks for the link.
They're very friendly and it's very active
[Elixir Weekly](https://elixirweekly.net/) has you covered.
[Elixir Digest](http://elixirdigest.net/) is a weekly newsletter with top 5 links from Elixir community. Each day one link to read.
I'm biased, but the thoughtbot blog has an elixir tag you can follow via RSS if you'd like: https://robots.thoughtbot.com/tags/elixir
I do these every year. Here are 2014 and 2015: - http://blog.elixirsips.com/2014/09/12/elixir-users-survey-2014/ - http://blog.elixirsips.com/2015/12/21/elixir-users-survey-2015/ I'd love it if you'd share it around with other elixir users you know :) The more data we have, the more data the core team and the library authors will have. This isn't in any way an official thing, but I think I have a decent track record of doing a bunch of work to gather and collate this data and share it with interested parties :) **plug:** https://www.dailydrip.com is my full-time thing now, making elixir and elm screencasts, if that's your cup'o. I'm also still updating ElixirSips, but with DailyDrip I have full control of the platform and a chance to make this into something bigger.
That looks good, thank you!
Very useful, thank you.
Marvellous, I'll subscribe to that.
this is pretty neat 
I have written some stuff: http://benjamintan.io/blog/tags/elixir/
I've been looking forward to these. Anyone have any recommendations on some of the best talks at the conference?
According to the docs for [Supervisor.Spec](http://elixir-lang.org/docs/stable/elixir/Supervisor.Spec.html#supervisor/3), the only current difference is the value passed for the `:shutdown` option. A supervised child defined with the `worker` spec is given 5000ms to shutdown before being killed; the `supervisor` spec sets a timeout of `:infinity`, allowing as much time as necessary for the child to shutdown - including shutting down its own supervised children.
These are used as hints for hot upgrades. During upgrades, the release handler is recursively walking the tree starting from the top-level process. When it encounters a supervisor, it uses `which_children` to get its children and walk deeper. Thus, if you mark a supervisor as a worker, the release handler won't ask it about its children, and will ignore that part of the supervision tree. If you mark a worker as a supervisor, it will ask it about children which will probably cause the worker to crash.
tbh, I found the Nerves talk very boring. Not necessarily in content, but the speaking wasn't engaging at all. I did like the selling food with elixir talk.
I was at the conference and I kept hearing from people that they really liked the selling food with elixir talk. I still have to watch it though. Jose's talk on GenStage is great because of how well he explains how it works and why it works the way it does.
You will be hard-pressed to find a negative. Math speed, maybe, but if you're coming from those languages then it's actually faster. (JVM based langs however are the fastest.) https://robots.thoughtbot.com/building-a-phoenix-json-api
There are some cons, many of which revolve around the language being young. Advanced tooling/editor support, large company backing, large ecosystem of libraries. It has the Erlang support for libraries though, which helps. First-class support in cloud service providers is also lacking. From a language perspective, it's certainly not as performant as compiled languages or for computation heavy tasks - but if you're coming from Ruby then you're well aware of those limitations. Speaking without much experience, I would imagine that it's also not great for IoT applications, as the VM is pretty hefty compared to compiled source, or even the JVM which has been heavily optimized to work on restricted hardware.
People use a variety of text editors but [spacemacs](http://spacemacs.org/) seems to be pretty popular. However, sublime, vim, atom vcode all have good elixir support.
what's said about brunch in my question?
"The language (syntax) even in elixir, really gets in the way and it doesn't need to" Such as? "Most of the tutorials spend an inordinate amount of time repeating the same basic concepts" That is true of most tutorials for any language / framework out there. One needs to start somewhere. This is complicated for Elixir since it is also often introducing FP to people at the same time as it is a newer language. In the last year I have noticed more and more complex tutorials, however, which is normal for a language as it matures: the basics are covered, the day-to-day work gets covered, then advanced topics are covered as time goes on. That said, there are not nearly as many complex bits in Elixir or Erlang to cover compared to most other languages I've had the pleasure (or lack thereof) to use. One reason for this in Elixir is consistency and a focus on a single programming paradigm (e.g. it isn't a bad mash-up of OO and procedural mucking about with a sprinkling of FP ideas mixed together with piss poor module support .. something which could describe a suprising number of languages). So C++, Java, Javascript, etc all have easy to find "this is tricky!" tutorials and explanations out there on the web. They need them. Elixir/Erlang is one of the languages I've used which are really rather elegant and focused, in contrast to many of the other popular choices out there. So I honestly expect that as a wider variety of topics and concepts get covered over time, it is unlikely to have the equivalent of "a million crazy ways to use templates", "careful with them strings, Charlie!", or "you won't believe what these variables are equivalent to due to the insane magical morphing powers of the language" tutorials. Or at least, I hope Elixir keeps in mind preventing the need for them. "The VM is primitive." Have you looked through the VM? Primitive is not a word I would use for it. It makes quite purposeful design choices that limit things like how fast one can crunch numbers 'natively' in the VM (though a set of NIFs would fix that; but then you could also just use a language good at that). This is because Erlang/Elixir knows what it wants to be, and strives to be good at that without any shame. Which is why it pretty much blows everything else out of the water at what it is good at. "It's inefficient for many common problems" And most languages / frameworks are inefficient for what Erlang/Elixir is stellar at. Design choices. Have you tried parsing binary protocols with Erlang or Elixir? Compare that to what you get in C, Java, Ruby, ..? "it's a minefield you get to discover" What minefield is this? Serious question, because every performance gotcha I've come across in the last ~3 years of using BEAM languages was very well documented. I'm curious what you ran into, because now I'm wondering what I haven't tried yet ;) "Unlike the JVM, you can easily spread work across machines which is a game changer, but that's not just because the VM is amazing." Actually, it is because the VM is amazing, in the context of distributed and durable applications. The one non-amazing part in this area that I am aware of is the cluster setup which wants to setup a fully connected network (sets limits on scaling beyond 100+ nodes) and assumes full trust between nodes (i.e. it externalizes cluster security). Otherwise, getting to what it can do for distributed applications or robustness is precisely down to a rather amazing bunch of software engineering in the VM (also OTP, but that's best viewed as a huge ball of boilerplate built on the base capabilities of the VM. "It's a feature baked into the language with VM support." Immutable data is part of the language, not the VM? *raises an eyebrow* That's one of a dozen VM-driven features one could offer. Processes is probably the most obvious one (the garbage collector is built to them, e.g.), but there are so many aspects of the capabilities that are baked into the VM .. .. which are also the design decisions that limit it for utility in e.g. scientific computing.
RE: IoT, it really all depends on your application. It often makes a lot of sense to use a higher-level language like Elixir, if power usage is not a big concern. Elixir is also great for embedded because of its resilience and ease of matching/composing binaries
Yes, there is a lot to improve when it comes to deployment and in retrieving, storing and making sense of all the data the VM produces.
A couple of people have already mentioned it, but the biggest downside I've run into is computational speed for heavy math. I unfortunately had to rule it out for a web game server I was making since the game engine needed to handle some simple 2d physics stuff, and elixir is just too slow at that. For other tasks, however, it can be very performant.
Would you give any advice to somebody who is building side project that would eventually be deployed in production? 
because I'm not using it, are you able to read?
We did almost exactly this at my company, and we built it in rails. We looked at elixir and I was really hoping that would be the decision, but in the end the team decided to go with Ruby since there was more experience there. In hindsight, some of us wish we had chosen elixir. In particular, we added a feature to aggregate and combine multiple requests, but for now it performs them sequentially. It would be trivial in elixir to do everything in parallel, but in Ruby it isn't as straightforward. Elixir is perfect for your use case. The important thing is concurrency and throughput. Akka is conceptually similar to Elixir's concurrency model, but has to fit it into the JVM. The BEAM is much more purpose-built for that type of concurrency. Incidentally, you might consider looking at GraphQL as an alternative to a gateway API. Context: I am mainly a front-end developer, but have been really interested in Elixir lately.
&gt; Phoenix should be able to handle your traffic with ease. 1500 req/min is nothing Well it's not the traffic that I am worried about, it's the fact that the actual work is all blocking IO. I haven't found a detailed breakdown of how phoenix works with elixir's concurrency model but from what I can tell it sounds like it just deals with it automatically. That is, if a controller blocks on every request for 2 seconds or something while calling other http services, elixir is smart enough to deal with it and not block other requests. Would love to find some more details about how that works though. 
If the actual work is blocking IO than distributing the work on different servers is one of the best ways to go. Elixir is built for distribution and is a native beam feature. And yes I believe Phoenix creates different "processes" for each request so if one request takes 2 seconds it won't block other requests.
My understanding is that Phoenix uses cowboy (erlang library) it's webserver for HTTP requests and that cowboy opens up a new BEAM process for each requests. I'm not sure if there's a thread pool or anything like you'd expect with Ruby webservers. But something to note is that a BEAM process is much, much lighter than an OS process and it's not uncommon to have thousands or millions of BEAM processes running without hitting any sort of performance bottleneck. Elixir allows you to reduce any blocking IO by taking full advantage of it's concurrency primitives and OTP.
Also, noting some of the responses as demonstrative proof, fanboys are some of the only feedback you will get when encountering issues. There's this rush to try to trivialize or re-frame problems as "not-really-a-problem", looking to troll over a multitude of issues. Even Armstrong is guilty of this, poo-pooing the importance of syntax [although...](https://www.youtube.com/watch?v=3MvKLOecT1I) every sample by anyone anywhere results in the same issues being brought to the forefront. The overly-defensive-hipsters is who you will hear from most, who are a vocal minority found among niche and functional language communities like Haskell, Scala, and clearly Elixir. I think it hobbles language adoption, but that's what seems to happen for many communities. Elixir is an Erlang wrapper, insofar as the Elixir VM is the (Erlang) BEAM, which is made to interpret Erlang. Elixir doesn't stray too far from that, since it has to be interpreted the same. The number of tutorials that go into topics like Project management are dwarfed by the number who go over how tail recursion works...basically the vast majority of tutorials (and now books) don't add a lot of value. They just rehash the same basics. Good luck past that point. The [build tools](http://www.slideshare.net/digikrit/erlang-build-tools-62724834) ([this](https://github.com/h4cc/awesome-elixir) isn't a comprehensive list either) alone should give you an idea of what "tooling" you get to choose from. What gets maintained two years from now? Spin the wheel and hope for the best. Primitive instrumentation in the form of the erlang debugger/process monitor, which could use a lot of UX love. [Something](https://github.com/koudelka/visualixir) for viewing processes, which is a bit prettier. BEAM vs JVM is not a competition. The BEAM got [multicore support](http://kth.diva-portal.org/smash/get/diva2:392243/FULLTEXT01.pdf) up to about 20 a couple years ago, but it has been a major series of victories to stop it from bleeding memory and get (limited) SMP support. On any unflattering micro benchmark, the VM is to blame for the slowness. The transparent message passing is a VM feature, which the JVM could learn from...all JVM "messages" (via serialized string or hessian binary or whatever) are immutable after hitting a network, so I don't see why anyone would mention immutability as particularly innovative for addressing networked JVMs.
&gt; Also, noting some of the responses as demonstrative proof, fanboys are some of the only feedback you will get when encountering issues. Of course you would dismiss criticisms to your post as being a fanboy. Your initial comment was vague at best, at least your reply does a much better job in expanding some of your points, so we can move the conversation forward. &gt; Elixir is an Erlang wrapper, insofar as the Elixir VM is the (Erlang) BEAM, which is made to interpret Erlang. Elixir doesn't stray too far from that, since it has to be interpreted the same. There is no such thing as the Elixir VM. It is all the Erlang VM. However, from the Erlang language to the VM bytecode, there are multiple steps and intermediate representations, including another language called [Core Erlang](https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf). However, Elixir does not wrap Erlang, although it shares many of the compiler passes (both compile to Core Erlang). So your comment that Elixir is an Erlang wrapper is not only wrong technically but also semantically as there are semantic differences between them. Do they share most of the semantics and primitives though? Yes, they do. Is Elixir a wrapper though? Something that is on top of the Erlang language? Surely not. &gt; The build tools (this isn't a comprehensive list either) alone should give you an idea of what "tooling" you get to choose from. What gets maintained two years from now? Spin the wheel and hope for the best. The two links above are talking about two different kinds of build tools. The first are *required* for compiling Elixir or Erlang software and the second are build tools that you could use generally, some for compiling react projects, others if you need to write build tasks, etc. The answer to your question is clear for Elixir: Mix will be maintained from two years for now. One of the differences between Elixir and Erlang was exactly to solve the build tool problem by making Mix part of the standard library. Erlang, on the other hand, has had some churn regarding build tools in the last years. Rebar is being replaced by Rebar3. Erlang.mk is a makefile though, you don't need to install anything, and I have never seen anyone using Emakefile. It seems things are converging towards Rebar3, it has been officially blessed by the OTP team, the team that developers Erlang, but I agree with you there is a question mark on what will be there in 2 years from the Erlang side of things. To be clear, I am not dismissing your comment regarding build tools. The fact that presentation exists is a proof there is a confusion at least from the Erlang side of things. I am just personally hoping it is one of those times things get worse before they get better. And, once again, hardly a problem specific to Erlang/Elixir: https://en.wikipedia.org/wiki/List_of_build_automation_software (which is a very incomplete list). &gt; Primitive instrumentation in the form of the erlang debugger/process monitor, which could use a lot of UX love. Something for viewing processes, which is a bit prettier. Sorry but I will still have to disagree on this one: * Erlang ships with both visual (GUI) and command line debuggers (and more): http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/ * Observer gives you introspection into your system: http://www.akitaonrails.com/2015/11/22/observing-processes-in-elixir-the-little-elixir-otp-guidebook * Observer can also be used to connect to remote nodes: http://blog.plataformatec.com.br/2016/05/tracing-and-observing-your-remote-node/ * Another tool for tracing processes and nodes: http://blog.plataformatec.com.br/2016/04/how-to-trace-elixir-nodes-with-erlyberly/ Besides the VM ships with [micro accounting](http://erlang.org/doc/man/msacc.html), [tracing](http://erlang.org/doc/man/erlang.html#trace-3), [d-trace](http://erlang.org/doc/apps/runtime_tools/DTRACE.html), [multiple profilers](http://erlang.org/doc/efficiency_guide/profiling.html) and more. Some of those are [still being actively worked on](https://www.youtube.com/watch?v=aPpzjfLAGV8) and you can find multiple talks on the tools above. Therefore it would help if you could give more specific use cases or more specific reference points. But compared to my previous backgrounds, Erlang/Elixir provide more and better tools when it comes to instrumentation. My criticism on this area is that, if I want to constantly monitor and instrument a service, I need to do part of the work on storing and visualizing the data instead of having something plug and play. That's improving, there are solutions like Wombat OAM, and many tutorials on setting up your own stack (some better packaged than others), two examples: * https://www.erlang-solutions.com/products/wombat-oam.html * https://medium.com/@mschae/measuring-your-phoenix-app-d63a77b13bda &gt; The BEAM got multicore support up to about 20 a couple years ago, but it has been a major series of victories to stop it from bleeding memory and get (limited) SMP support. On any unflattering micro benchmark, the VM is to blame for the slowness. Sorry... but that's more vague criticism? "On any unflattering micro benchmark, the VM is to blame for the slowness". Well, obviously. The VM is the one running your code, it will be the one to blame on benchmarks (that and a compiler that does not optimize well). "Limited SMP support"? In which regards? Maximum number of cores? Load balancing? Communication between cores? CPU cache usage? Again, I am not claiming the VM is flawless but your criticism is vague and as such, I cannot tell: Does it affect me? Does it affect the use cases the VM is known for? Does it affect the OP given the background he/she has come from? Is it getting better? Is it getting worse? This is a technical discussion. If you are vague, you will be pressed for more information. I have tried to provide as many links and information as possible on the areas I disagree with. I will gladly look for more information in case something is not clear and I hope you will do the same instead of dismissing feedback as a fanboy.
&gt; Asshat, did you replace it by something? If so, by what? Nice to meet you, I'm John. Reread my question. 
yes, hard, but you try to.
&gt; In other words, quoting exactly what was asked above, "if brunch is not building the assets, how can you possibly expect them to show up in production?" by including them manually in a page one by one and by copying them to priv/static. it's awfully obvious.
From what you've said in your post I would say go with Brunch. It comes with phoenix and it will work out of the box for your needs. No configuration needed.
Yeah I've considered GraphQL. I think it's neat, the problem in our case is that our microservice api's are solidly REST based and power a lot of our internal usage, as well as integrations with our partners (which tend to be large organizations who are far from the cutting edge of development). GraphQL is something I'd love to play with, I think internally it would be very helpful as many parts of our system often need custom composed data like it could provide. For our external api, however, at least for the time being the api gateway is going to better serve our partners needs. 
A toy project might be simple. Now try adding runtime configuration, automatic deployment, ability to build releases on a different OS, ability to do hot code upgrades, setup database migrations - preferably in a way that doesn't leave the application broken if a migration fails. Edeliver does solve some of those things, but it's still not quite there for me. It took me way too long to figure these things out and while a Ruby server environment might be harder to set up initially, configuration and deployment are pretty much solved problems.
The only other thing I would add, is that it's pretty straightforward to swap between them. A current project I have been working on for the last 8 months, started with Brunch -&gt; Webpack -&gt; Gulp -&gt; Back to Webpack again. You are probably best not overcomplicating things with Webpack until you need its features.
Please stop calling this newsletter Awesome Elixir **Weekly**. I have been a subscriber for some time and it has always been called "Awesome Elixir Newsletter". Your website even states this name as of now when I click on the link. You are the second person within the last 2 weeks to try to name a newsletter to something close to [ElixirWeekly](https://elixirweekly.net) (2nd largest Elixir newsletter behind Elixir Radar, curated by [me](https://github.com/rrrene/)). *Edit:* I am sorry if this comes off as harsh, but I honestly think that this is not good citizenship. Renaming your publication to something akin to a more popular name is shady and not very community oriented. Please reconsider your position on this.
Just because you've already learned deploys in ruby, don't confuse that as it being more simple.
You are not listening, and he is not alone in this problem. We ran into the same thing: cannot build on a Mac and deploy on Linux; complex deployments regularly fail for no apparent reason using exrm; configuration, which should be simple, is not; many manual steps that exrm leaves undone.
&gt; The difference is that elixir does have the ability NOT to ship source. It does, but in practice you will still have maintain a compatible build server or a container. So you have to setup an Elixir environment anyway. &gt; So what are these "complex intermittent failures" and have you filed an issue on github and how in the world have you never hit issues with rubys deploys. Funny you would say that, because I reported a bug with hot code upgrades in Distillery just a day ago. And who is claiming that either of us haven't faced any problems with ruby deployments? &gt; but you two seem to be suggesting ruby deploys are dead simple Now you're just making things up. I'm suggesting that Elixir deploys are not easy and explained why that is. The fact that this is the most upvoted issue in this thread confirms that this is a problem that people have. &gt; That's not the case in elixir...you can literally deploy a hugely successful scalable application (whatsapp anyone?) using absolutely nothing outside the erlang ecosystem... I'm sure you can tell me all about it, from your experience of deploying "one toy app using exrm".
Learning Erlang concepts is necessary for Elixir, but Erlang syntax... not so much. Erlang's syntax, based on Prolog, is going to be a steep learning curve if you only have experience with C-based languages (grandchildren of Algol) like PHP, Ruby, and Go. But that's not the brain-stretching part: the more difficult part will be learning the functional-based concepts used in Elixir versus the procedural and object-oriented concepts used in PHP, Ruby, and C. In my experience, asking developers to learn both Erlang syntax and functional concepts simultaneously is stressful: I think it's easier to approach Elixir with it's Rubyesque syntax and learn the functional concepts as you explore. Eventually, though, you'll want to know Erlang, too. 
Erlang the language is pretty small and not very difficult to learn. With that said what you really want to be focusing on is OTP. OTP is what makes developing apps for any of the BEAM languages interesting and powerful. IMHO once you understand OTP you won't have any real issues switching between Erlang/Elixir
It helps to have at least some background knowledge about the "Erlangy" way of doing things. I personally only started learning Elixir (coming from a Ruby - and before that, Perl - background) after having read through ["Learn You Some Erlang For Great Good!"](http://learnyousomeerlang.com/), which did a great job of getting me comfortable with functional/declarative programming and with OTP, even if I rarely (if ever) deal a whole lot with Erlang (the language) itself.
I've been working with elixir for a year now, and find I can pretty much read erlang source without any difficulty. If I had to write it, I'd have some trouble, but I don't, because elixir.
As you learn Elixir you will become familiar with Erlang.
Yeah I read that and it's pretty much my plan, except instead of utilizing the 404 handler I plan to instead have all the existing api routes have corresponding endpoints in the gateway app. This will set us up for moving authentication, caching, transforming responses, etc in the gateway in the future and also feels less ugly than having a global handler in a 404 view. 
Write an agent for sync messages from netease.im to elasticsearch: https://github.com/repong/nim-agent This is a side project in my company. Our main language is go. I've learned much from writing this small project, especially in deploy. Many thanks to elixir-lang.slack.com. Additional, I recommend https://www.meetup.com/Elixir-Shanghai/ to `alchemists` in Shanghai. 
After building a release your mix.exs file is no longer available. See http://blog.plataformatec.com.br/2016/04/running-migration-in-an-exrm-release/ for an example of running migrations from a release. Seeding the DB should be similar.
I suppose I should have clarified, "modern high-level languages" lol
Message app is probably the best for concurrency.
maybe message queues, job queues, website scraping, game simulation.
https://github.com/poteto/terraform may also be of use...
This has come up before, see the following thread: https://www.reddit.com/r/elixir/comments/48ke69/any_reason_why_elixirphoenix_did_so_badly_in/ Hint: the ~170,000 errors didn't particularly help...
No widely used multi-methods / polymorphism (protocols are not the same, because they are very rarely used). 
Very cool! Is it possible to stub a module that defines a behaviour without any implementation? Having a convenient way to create stub implementations for behaviours might encourage more explicit contracts as described in http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/ 
This almost seems like a troll to me...
Thanks! Adding an option for behaviors is the next thing on the roadmap. I'm probably going to get stubr raise an error if it does not implement the behavior, which will just be a simple check on the call backs.
Stubr has an auto stub option that will differ to the original functionality if you haven't subbed out a particular function, or if you haven't provided a matching pattern on the function arguments. There is an example on the github repo for stubr.
TIL of code wars. Neat!
Yes, thank you. Sorry for the bad link. 
That was supposed to be a :-(
TCP acceptor pool is very nice to learn concurrency and you can peak at how ranch is implemented.
yeah, but how can I actually run the seeds within a task?
Have a link for "syn package"? Edit - I was able to find it here: http://www.ostinelli.net/an-evaluation-of-erlang-global-process-registries-meet-syn/
also, if you're looking at syn, take a look at https://github.com/bitwalker/swarm - seems interesting
Glad to see you're posting again... I always found your posts to be really helpful.
Thanks /u/karmajunkie! I hope to keep up a weekly pace again. Thanks for reading. 
I wouldn't say GenEvent is being phased out. I'd say the use of GenEvent for stream processing is phased out. GenEvent itself still has a multitude of uses. I don't foresee, for example, Logger moving to GenStage any time soon. GenEvent for steam processing is not a traditional use case in Erlang. In fact, GenEvent and :gen_event are not fully compatible because of the modifications that were made to enable stream processing. That path has been largely declared to be insufficient, prompting the introduction of GenStage.
where should I put that file with ":release_tasks"? in the 'lib' directory?
Yes, put it under /lib to ensure it is included in the compiled release binaries.
&gt; Code.require_file why not eval_file?
in this `rel/my_app/bin/my_app command release_tasks migrate` what should be used instead of 'command'?
At the danger of being overcritical here, posts like these are not particularly helpful. They solve the simplest of problems by essentially rehashing docs which already exist. Tackling a more complicated problem or running a tutorial series digging a bit deeper would provide far more benefit to the majority of developers out there. 
This. Plus every tutorial builds a blog. In the end whoever follows many tutorials just gets really good at building blogs.
You can use put_layout function of Controller module , s. https://hexdocs.pm/phoenix/Phoenix.Controller.html#put_layout/2 but it needs a conn struct so you'd have to do it somewhere before the view. One Option is to set it in Controller method, more general - in Controller Module (as Plug) or in Router (in pipeline) #Controller method render conn, "some_page1.html", layout: {MyApp.LayoutView, "my_layout.html"} # Controller Plug plug :put_layout, "my_layout.html" # Router pipeline :my_layout do plug :put_layout, {MyApp.LayoutView, "my_layout.html"} end ... scope "/my_scope", MyApp do pipe_through [:browser, :my_layout] ... some routes ... end 
I need to achieve that only in the view!!!! 
~~well your view is a module that is basically a collection of functions none of which has to do with layout, so as far as I can tell you'd have to move your logic upwards :)~~ take a look at the assigns param: :layout - tells Phoenix to wrap the rendered result in the given layout. Templates can be rendered within other templates using the :layout option. :layout accepts a tuple of the form {LayoutModule, "template.extension"}. Phoenix.View.render(YourApp.SomeView, "some_page1.html", layout: {MyLayoutModule, "my_layout.html"}) might do the trick
it's in assigns def render("index.html", %{conn: conn}) do IO.inspect(conn) "Hello world" end
What you're trying to do isn't going to work in phoenix. The layout is rendered first, and then the view. You're probably used to Rails which does it the opposite way. As /u/yurk0t said, you can specify it when you call render, depending upon where you're calling it from (his example would be how you would call it outside of a controller). The `conn` should be available as `@conn` in the top level view, other views you render I believe will need to pass it along.
He's coming at it from a different angle than the other beginners guides. There might be tips and tricks that he drops that are useful to people starting. The intro to PostgreSQL shell is useful to me, for example. 
The instructions aren't even compl
I'm working on an IRC daemon in Elixir with Juliano (omnibs) during his batch at Recurse, https://github.com/omnibs/exirc Definitely not fully functional yet (and recently renamed from exirc to exircd) but welcome feedback/thoughts/etc!
License?
Thanks, I'm going to have a good look at using this! One question - after a quick look I can't see how this would/could give an organisation its own subdomain - I can just see a /tenant/tenant_name format - can apartmentex do subdomains? Do you know of anything like this that can do role based permissions too or a package that does and could work with apartmentex, so for example a customer creates a tenancy for their organisation and becomes admin by default and create/invite other users/members?
Explain what ICNDB is on the Readme of your project. is this some sort of joke generator?
License?
You only need one controller. Phoenix can do content negotiation returning HTML or JSON based on accept header. Just use `render(conn, :index, data)` from the controller and Phoenix will use "index.html" or "index.json" as needed. See https://hexdocs.pm/phoenix/Phoenix.Controller.html#render/3
how about authentication -- api key header -- in case of json? and maybe some additional stuff.
Create a plug that runs in your API pipeline and validates the API key against your DB. If successful it can store a user_id in the conn assigns. If auth fails, the plug can set conn.status to 401 and send an error response.
`plug :accepts, ["json"]` in your API pipeline will set a value in the conn used by the controller to choose the appropriate template. See https://hexdocs.pm/phoenix/Phoenix.Controller.html#accepts/2
how about a single action which accepts/returns json only if all other actions accept/return html?
Looks similar to one of my favorite Rails gems. Nice work!
Elixir Koans...for now
thx. how can I check if a request is ajax?
each request can be spawned off as an independent process each of which are concurrent. Try a Proof Of Concept with a sleep(2) per process and try out a benchmark to see if it works well for your use case. WhatsApp runs 1 process per customer (or so the abstraction), since if processing a message for 1 person fails, it wont fail the rest of the cluster. Joe Armstrong - inventor of Erlang talks about how BEAM is different compared to other languages. Also an important note to observe is that Akka was inspired from Erlang. https://soundcloud.com/elixirfountain/elixir-fountain-2016-01-08-joe-armstrong
 ["Admin": "admin", "User": "user"] This is actually a keyword list. It's a list of 2-element tuples. It's syntactic sugar for: [{:Admin, "admin"}, {:User, "user"}] Note that the keys are *atoms*, not strings. To create that using Enum.map, you want to return a tuple from your enumerator function, of the form `{key, value}`. More info here: http://elixir-lang.org/getting-started/keywords-and-maps.html
I'm new to ecosystem myself but I believe guardian doesn't handle authentication. It expects the resource passed to it to be already authenticated. I use a combination of guardian and ueberauth with the Google strategy to allow oauth from Google. They also have a simple username password strategy. I don't know how lightweight they are compared to other options but it works well for me.
&gt; web: MIX_ENV=prod PORT=$PORT mix phoenix.server Any support for Exrm releases?
I use comeonin to manage the password hashing / validation.
&gt; the cookie that gets sent to hold the session data that's not data. it's session id stored in a cookie. data is stored on a server. isn't it?
I think you can do it either way. Edit: You can do it either way: &gt; Phoenix gets its session functionality from Plug. Plug ships with two forms of session storage out of the box - cookies, and Erlang Term Storage (ETS). But think about it like this. When you no longer have the session id, how will you retrieve the data?
You can pass `:max_age` to the [session plug](https://hexdocs.pm/plug/Plug.Session.html). Plug.Session, max_age: 120
&gt; When you no longer have the session id, guess what? it's lost. because it's a session -- temporary storage. what else would you expect?
It's the number of seconds you want the cookie to live.
it's already been known to me. re-read my question.
yeah, but it how it's done in other libraries or in other circumstances? or won't it significantly hurt the performance if that's a not standard way? 
if you can't help -- don't help.
Would alias solve your problem? http://elixir-lang.org/getting-started/alias-require-and-import.html#alias
tnx
I'm working on a JavaScript benchmarking webapp. Like, jsperf.
Ecto queries are composable. That means you can build up your query a step at a time, adding clauses as needed. See https://blog.drewolson.org/composable-queries-ecto/ for some examples.
The most prominent reason I would choose Postgres over mnesia for any critical application is due to the documentation and support network available for Postgres. Orders of magnitude more people use and understand SQL compared to mnesia, and you're much more likely to find solutions to issues easier. That's not to say *never use mnesia*, but I personally would only use mnesia when Postgres isn't an option.
nice!
Sounds about right.
Can you clarify? Do you mean something like OOP? Elixir is definitely not that. From where I'm standing protocols look like they do dynamic dispatch just fine. What am I missing?
just released https://hex.pm/packages/ueberauth_twitch_tv . It's a ueberauth strategy for Twitch.tv
This is how I use Mnesia* - as a distributed in-memory (ram-copies only) key-value store with some nice extra features like secondary indexes and transactions. *: Although I'm not running anything in production yet...
Thanks for this code. I have a question though, filters |&gt; Enum.reduce baseQuery, fn ([name, value], query) -&gt; from c in query, where: (c.name == ^name and c.value == ^value) Will this not join with an AND instead of an OR? eg: I was under the impression that this will result in the following code - from s in query, where: (c.name == "plan" and c.value == "pro"), where: (c.name == "medium" and c.value == "mobile")
Thanks for sharing the link. It is very helpful.
We completely threw out the conventional layout and so far have been loving it. The goal was to approximate something like a rails engine where there are multiple subsystems each with their own router, controllers, views and business logic. There's a top level router that forwards on to the different subsystems. We didn't go all the way to an umbrella app, because I couldn't figure out how to achieve it without giving each app its own endpoint running on separate ports. 
No controllers? Are the requests just handled by pipeline plugs?
For the specific case of pagination database queries, use scrivener: https://github.com/drewolson/scrivener_ecto As for working with in-memory data, probably load it into an ets table.
Yes in my case it's handled by http://absinthe-graphql.org/
Why would separate ports be a dealbreaker? Those are internal ports and a reverse proxy will map it nicely to your external port, regardless of the amount of apps. 
I mean did you have to do anything special to tell phoenix where the files are or does mix automatically compile all files and the only important thing is the name of the class?
Correct, like I mentioned, I'm not sure how to OR the clauses, but I found this on [stackoverflow](http://stackoverflow.com/questions/35009501/composing-an-ecto-query-with-multiple-columns-in-a-where-clause-joined-by-or)
This is great. Thanks. I've been meaning to get a website up for a game that I'm building and since I'll be working with React/Redux soon I also wanted to use it with Phoenix. Now I have an example to look at!
It looks like since it relies on a `git push` to trigger the deployment, you'd probably have to push to each server and have the deployment be rolled out in parallel. Or just do one at a time.
I wrote hex packages for solving similar requirement: https://hex.pm/packages/ex_sieve , but solution looks ugly for me, because in guts it uses Code.eval_quoted/1 for build Ecto.Query object. If someone know how do it better, please let me know.
You also can use field function https://hexdocs.pm/ecto/Ecto.Query.API.html#field/2 for dynamic fields name.
Looks awesome, but Docker is the way forward for me - it's made my life so much simpler deploying containers. 
You can test it out with https://github.com/wojtekmach/acme_bank
Thanks for the link! 
Here is my problem. I don't want all the views in one directory. I want to have one directory for every controller and all the views for the controller to be in the same directory as the controller so everything is in one place. Example web âââ home â âââ home_controller.ex â âââ home_view.ex â âââ index.html.ex âââ login â âââ login_controller.ex â âââ login_view.ex â âââ index.html.eex â âââ forgot_password.html.eex .... 
Not sure if I would find that setup useful but it's doable I think though you should test it out in a new Phoenix project. **** UNTESTED CODE AHEAD **** Remove the following from `web.ex` (in `def view`) use Phoenix.View, root: "web/templates" Add this to your `home_view.ex` use Phoenix.View, root: "web/home" And the same to your `login_view.ex` use Phoenix.View, root: "web/login" Lastly your controllers and views would get names like (though not necessary) App.Web.Home.HomeController App.Web.Home.HomeView 
I haven't heard of elixir-webdriver before. I personally use hound or [wallaby](https://github.com/keathley/wallaby) because both support [concurrent browser testing of Phoenix applications](https://github.com/phoenixframework/phoenix_ecto#concurrent-browser-tests).
Nice! Good luck. This was my first Phoenix app in a while so I'm sure there are a handful of anti-patterns, but hopefully it's helpful to you regardless.
Elixir protocols is a limited and almost never used feature. While theoretically it may do dynamic dispatch, practically it's almost never used. Had Elixir have true dynamic dispatch we wouldn't have being forced to remember all those `xxx_size` methods: ``` map_size(map) tuple_size(tuple) ... ``` Instead there would be just one `size` methods dynamically dispatching different data types.
Hm, that's interesting. I'm just starting elixir and am in the learning phase so I haven't been exposed to real-world usage. Protocols sound like a good idea, lifted straight out of clojure. Are they less powerful here? I wonder what is the reason for their rare usage.
awesome!
Looks like the body of the response is binary. Could be gzipped or an image, hard to tell with the snip you posted. Try using IO.inspect(body) and it should dump out something for you to poke out. Cheers, Ben
Hey Everyone! I do a lot of work with Test Automation and I decided to try and test the waters with Elixir using [White Bread](https://github.com/meadsteve/white-bread) and [Hound](https://github.com/HashNuke/hound). Here is what I came up with!
This is really great! I'm very impressed with how far elixir is come in such a short time. I used to do automation testing as well with Ruby+Cucumber+Watir. I wonder if I could reimplement the framework I built before in elixir!
Awesome!! We use Postmark on our Rails app, and now that we're migrating it over to Phoenix this will be one less thing I have to worry about.
It's silly to speculate without seeing your benchmark code. If you want real answers you'll have to share the two examples of what you consider equivalent stacks.
&gt;What's your benchmark tool and settings? wrk -t 4 -c 50 -d30s --timeout 2000 &gt;I think you might want to add something that blocks a response, for example a database call. I might do that. I was thinking of a full round trip where I query postgres, get a recordset and then turn it to json. &gt;With ruby you'd take a phone call, wait five minutes, reply to the caller and then talk to the next person. Not with Jruby and not with ruby using eventmachine. Having said that I am comparing jruby as it's significantly faster than ruby once it's warmed up. &gt;but you get the picture, the performance benefit comes into play when you have blocking operations. I'll try that next. I was going to use the Sequel gem for ruby I suppose that means I should use raw postgrex rather than Ecto right? BTW: in this simple benchmark Go and Crystal blow both Jruby and Elixir out of the water. 
That's quite different from results myself and others have seen in this past. See [here](https://github.com/mroth/phoenix-showdown/blob/master/RESULTS_v3.md) and [here](https://gist.github.com/omnibs/e5e72b31e6bd25caf39a) for an idea of what you should expect. If you can post your application code on GitHub, versions and include the snippets you are using to start the server and benchmark, it would help us find why there is such a difference in results. And yes, Cowboy will be faster than Plug, since Plug is a very thin wrapper around Cowboy. I don't expect the difference to be considerable though.
Yea, the memory usage is no surprise either. It is on a VM and each process has it's own private memory. Which in another aspect is a benefit in that a crash in one process doesn't corrupt shared memory and allows for isolated crashes.
&gt; heavily inspired by shopify/dashing It looks exactly the same. Awesome!
how do you use docker with phoenix during deployment, do you have a tutorial or link to describe this even coarsely?
The same way as any other Docker container :)
The term virtual machine means two different things when talking about a programming VM and an operating system VM. Programming VMs virtualise just the process and memory space and rely on no special CPU features to do so. Operating system VMs virtualise all the system hardware and require special CPU features to support that.
Got that. Thank you.
Ignore the two answers. You should learn first, then use a dependency. You get the result as a list of records? Then use Kernel.length/1 Or take a look at the Enum module, which provides you with helper functions (filters, maps, etc). Kernel.Length is a BIF. Read more about BIFs on Erlang sites (BIFs are really fast!) 
Writing my thesis regarding the coding statistics service [codestats.net](https://codestats.net/), this week I will be writing benchmarks for it to see how performant it is compared to other stacks (it's a Phoenix project).
Thanks, this was definitely the answer I was looking for. The example I provided was just a motivating example, not a specific problem I'm trying to solve.
Even if simple, might be beautifully useful :3 
Working on a full-stack Phoenix app called [loose leaf](https://www.loose-leaf.io). It's just a side project of mine that I'm building on my free time.
First, forget every concept you learned from Ruby and OO. Because if you try to map the previous knowledge to this type of concurrency, you'll make your programs slower.
I hadn't seen `cafex` when I started using Kafka and Elixir back in August. If it helps, I've written a bit with the [KafkaEx](https://github.com/kafkaex/kafka_ex) library: [kafkamon](https://github.com/avvo/kafkamon) which reads Avro-encoded kafka messages and websockets them to the browser for debugging, and [KafkaImpl](https://github.com/avvo/kafka_impl) a wrapper around `KafkaEx` to mock it out in test.
Both of my projects are: * https://github.com/Nicd/code-stats * https://bitbucket.org/vincit/mebe (this is older and I was a total beginner when I started it so it's kind of iffy at places :P)
There's a struct type named TodoList. This matches when the function is called with two arguments. The first argument must be a TodoList type of struct. The second argument can be anything. This causes four variables to be bound: * variable `entries` is bound to the value with the key `:entries` in the first argument * variable `auto_id` is bound to the value with the key `:auto_id` in the first argument * variable `todo_list` is bound to the whole first argument * variable `entry` is bound to the second argument The syntax for these matches can be a little confusing. Notably: * In a parameter, the `... = todo_list` construct captures a more complex match. * This can be seen when... * you want to match both inside and outside of a structure: e.g. `func({_, _, val, _} = thing)` to grab whatever is in `val` and the whole tuple into `thing` * you want to match a previously bound variable `v` inside but still save the whole tuple into `thing` e.g. `func({_, _, ^val, _} = thing)` * you want to do some sort of weird, purely structural match e.g. `func(%UserInfo{username: u} = user_info, u)` to match a function called with a user-info that has a matching user name, saving it in `user_info` So, yeah, I hope that helps. Let me close with an example that's closer to what you're seeing here: def func(%TodoList{entries: ents, auto_id: id) = todo_list, entry) do IO.inspect({ents, id, todo_list, entry}) end func(%TodoList{entries: 1, auto_id: 2}, 3) ...which would print out something like: {1, 2, %TodoList{entries: 1, auto_id: 2, ...}, 3}
Clear like crystal now. Thank you. Between you and /u/KagatoLNX, things are much clearer now
My [side project](https://www.authenticpixels.com) is built using Phoenix framework. - [https://github.com/authentic-pixels/ex-shop](https://github.com/authentic-pixels/ex-shop)
Yep, that's the blog post I found when I googled for Elixir reverse proxy before posting here. The solution looked a bit hackish to me - I thought with something like proxying being right there in Elixir/Erlang's sweet spot, there'd be something more battle-tested and "official" available for this task. Looks like the answer is "not (yet)" at this time.
Check out www.mooder.com Seems alot of similarities in what we're doing. (:
Is this still happening for you? 
This is exactly what I was going to mention. Additionally, if you're trying to achieve the affect where the `GenServer` stops after `n` ticks (like the process does in his example) you can use the server's state to track the tick count and have a special `handle_info` and `terminate` callback to stop the server and do any required clean up.
Wouldn't it make more sense to put spawn_link behind some kind of facade that can be swapped out for testing, rather than relying on sending multiple messages just to confirm spawn was called multiple times? See http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/
I think since this was an introductory article it was just done that way to show assert_received. 
Maybe a worker pool is what you need? https://github.com/thestonefox/elixir_poolboy_example
That would work, assuming I needed all of the workers to be identical. I should have been a little more specific. Each worker will be _slightly_ different. I'm trying to play around with https://github.com/BlakeWilliams/Elixir-Slack and each bot takes a different token. (can Poolboy still do that and I just skimmed over it?)
Working on a little CLI tool parse Kindle's "My Clippings.txt" and output the result as HTML. Nothing big, but fun :) https://github.com/domnikl/kindle-clippings
I try to avoid piping a variable if it's just one level. I.e. c = f(a, b) rather than c = a |&gt; f(b) 
I'll take a note on this ty
I think he means stuff like b = a |&gt; f1() |&gt; f2() |&gt; ... rather than b = a |&gt; f1() |&gt; f2() |&gt; ... I think first way is clearer than putting as much on one line as possible, though. 
Because I prefer it like that. 
Now I see. You're right. I've made some updates. Now I'm using Enum.flat_map. Take a look if you have time
Read this section of the Supervisor docs: http://elixir-lang.org/docs/stable/elixir/Supervisor.html#module-simple-one-for-one TL;DR: Use `:simple_one_for_one` and `start_child/2`
Nice improvement! I'd go one step further and take the anonymous function out of flat_map and move it to a named function: defp render_bookmarks([], _level), do: "" defp render_bookmarks(bookmarks, level) do bookmarks |&gt; Stream.flat_map(&amp;render_bookmark(&amp;1, level) |&gt; Enum.join("\n\n") end defp render_bookmark(%{ "type" =&gt; "folder", "name" =&gt; name, "children" =&gt; children }, level) do [ render_header(name, level), render_bookmarks(children, level + 1) ] end defp render_bookmark(%{ "name" =&gt; name, "url" =&gt; url }, _level) do ["* [#{name}](#{url})"] end 
In fact it's better to read. Thanks for your tips!
It's my first Elixir project: https://github.com/zan-kusterle/Liquio
Plug?
I second the recommendation that Stephen is an superb and thorough teacher. I've taken 3 of his previous courses and all are terrific, making me a subject matter expert at my company. I expect the same quality out of this as well.
&gt;It seems to me that Rumbl.InfoSys.Supervisor is throwing all the options away, not using them for anything. So when `start_child/2` is called, its usually in the format `(supervisor, [options])` where `options` needs to be a list. `opts` is already set to `[backend, query, query_ref, self(), limit]` so that requirement is met. This http://elixir-lang.org/docs/stable/elixir/Supervisor.html#module-module-based-supervisors all the way down to the "Summary" section explains this pretty well (not to be dismissive, just that's a much better analysis of what's going on here)
So 10_000 loc is a large project now? This is a joke right?
Just did a quick look and the only thing I could see was a lack of piping. For instance: current_user = Guardian.Plug.current_resource(conn) current_user = Repo.preload(current_user, :todolistitems) could be better written as current_user = conn |&gt; Guardian.Plug.current_resource |&gt; Repo.preload(:todolistitems) A better example a bit lower def update(conn, %{"id" =&gt; id, "todolistitem" =&gt; todolistitem_params}) do current_user = Guardian.Plug.current_resource(conn) todolistitem = assoc(current_user, :todolistitems) |&gt; Repo.get(id) changeset = Todolistitem.changeset(todolistitem, todolistitem_params) case Repo.update(changeset) do {:ok, _todolistitem} -&gt; json(conn, %{flash_type: "info", flash_message: "Item updated successfully.", state: true}) {:error, _changeset} -&gt; json(conn, %{flash_type: "danger", flash_message: "Item failed to update.", state: false}) end end You use a lot of temporary variables. Try this instead def update(conn, %{"id" =&gt; id, "todolistitem" =&gt; todolistitem_params}) do result = conn |&gt; Guardian.Plug.current_resource |&gt; assoc(:todolistitems) |&gt; Repo.get(id) |&gt; Todolistitem.changeset(todolistitem_params) |&gt; Repo.update case result do {:ok, _todolistitem} -&gt; json(conn, %{flash_type: "info", flash_message: "Item updated successfully.", state: true}) {:error, _changeset} -&gt; json(conn, %{flash_type: "danger", flash_message: "Item failed to update.", state: false}) end end At least that's what I'd do.
Great thank you so much. I will implement that now. Piping is still new to me and I'm not sure when it should be used.
I love that the header image is showing some PHP Wordpress code. :D
I'm currently almost done with [Programming Phoenix](https://pragprog.com/book/phoenix/programming-phoenix) and would recommend it. 
&gt; Plug? Plug. http://www.brianstorti.com/getting-started-with-plug-elixir/
Example of using test driven development to build a simple REST API using Phoenix. There's a second part on [using mocks for tests](https://medium.com/@lasseebert/mocks-in-elixir-7204f8cc9d0f#.bxh6aa7ll).
Totally agree. Now if I can just make the time to work in side projects so I can use it. Finding an internship for elixir seems impossible and it's far to new for my classes to use so I can't work in it full time.
This is a total circlejerk, but I totally agree. When I was writing elixir I felt like I was really having fun the whole time. Mix+hex is absolutely great, conventions are done right.
The calendar types still aren't quite sorted yet. I still have to use a third party package to construct a DateTime? At least Ecto 2.1 is deprecating its DateTime types in favour of the standard library types. 
Migrated my production node.js to Phoenix and Elixir, cut out "microservices" and no plan to do any microservice, never been happier.
Welcome to the circle!
Funnest language I've used for sure. Just so easy to get things done and easy to refactor. I don't find myself annoyed by some language inefficiency that keeps cropping up over and over. Feels tasteful.
A one for one will work fine for you. If you have a fixed number of workers don't over complicate it, just put them all in there with there individual tokens they need.
Imho Haskell is a better language if you want something that's just works. If it compiles it works. Its the most beautiful language in my opinion. Elixir has a much better community and is really built great for web services. Elixir seems great if you are coming from java, c#, ruby, php. But once you have used Haskell you'll think it's super unsafe. But the community will make your life easier than Haskells. 
As somebody who dabbles lightly in Elixir once in a while I will say this. It's a nice language, maybe better than most other languages. The community is also very nice and helpful and the tooling is very good but... I don't like the error messages, they don't always tell me what's wrong or where I should go to look to fix them. I think it's a bit too verbose and in my mind unnecessarily so. I think Erlang syntax is more terse and surprisingly elegant although I have my issues with that as well. I think speed is good but I have ran benchmarks for web serving with jruby and it's not that much faster. The startup time is faster for sure but once the JVM warms up it rockets. To be fair it wasn't a rails vs phoenix full stack test but a simple rack vs plug test. Rails just doesn't optimize well will jruby for some reason. I have also dabbled with go and didn't really care for it that much, in my opinion Crystal is a much better language than go. Crystal is also a possible competitor to elixir as their concurrency story is pretty good and the runtime is super fast. These days I am alternating dabbling with elixir and crystal, elixir is more mature of course and has a richer ecosystem but crystal is quite fun.
Use the [`with` keyword from Elixir 1.3](http://elixir-lang.org/docs/v1.3/elixir/Kernel.SpecialForms.html#with/1) to practice "railway programming". The code example that demonstrates this approach is given below. def process_checkout(order) do with {:ok, order} &lt;- update_order(order), {:ok, order} &lt;- capture_payment(order), {:ok, order} &lt;- send_notification_email(order), {:ok, order} &lt;- update_stock_levels(order) do {:ok, order} else {:error, reason} -&gt; handle_error(reason) end end
Seems like some syntactic sugar could be added to make it look a little more elegant and less repetitive.
Interesting, it never occurred to me to pipe something to **case**.
Alright will look into that. Thanks.
Same here. Had the react courses before and didn't even know what elixir really was. I received an email from Stephen via Udemy, explaining what this new course is about. I quickly searched for the elixir programming language and enrolled in the course. I'm at the end of section 2 now and Stephen shows again what an awesome teacher he is + the elixir programming language is really cool!
http://erlang.org/doc/apps/percept/egd_ug.html might be useful if the generated image is simple enough.
Thanks, @vagara. I'm already using elixir-tmbundle, and it works fine. However, it doesn't support autocomplete. I'm going to try Atom now...
I'm curious how one would use NOTIFY with ecto myself....
I use atom and the atom-elixir package IIRC has autocomplete with click to function and docs all built in. I thought the same was available for sublime as it's all based on the emacs plugin already mentioned. I believe the IntelliJ plugin is the same, so they should all have the same features.
&gt; IIRC? :)
This is a thorough and concise introduction to Elixir. I'm going to share this with anyone who seems interested in the language.
In the end, mix runs elixir which runs erl. Take a look at https://github.com/elixir-lang/elixir/blob/master/bin/elixir You can build the things you want to include and pass them in via the path (-pa or -pz). You don't necessarily need mix, but once you're off the beaten path you're going to have to learn a bit more about how elixir and mix work under the hood.
Might you need to `use GenServer`?
I think the canonical example using pattern matching is even better... fizzbuzz = fn (0, 0, _) -&gt; "FizzBuzz" (0, _, _) -&gt; "Fizz" (_, 0, _) -&gt; "Buzz" (_, _, a) -&gt; a end fb = fn n -&gt; fizzbuzz.(rem(n, 3), rem(n, 5), n) end 
I like the Stream version: fizz_stream = Stream.cycle(["", "", "fizz"]) buzz_stream = Stream.cycle(["", "", "", "", "buzz"]) Stream.zip(fizz_stream, buzz_stream) |&gt; Stream.with_index(1) |&gt; Enum. map(fn {{"", ""}, x} -&gt; x {{f,b}, _} -&gt; f &lt;&gt; b end) No mod/rem operation needed. 
I'm not an elixir expert, just someone who follows the language (so take my opinion with a grain of salt). I personally think that the OPs example is the cleanest
This. The pattern matching version is a cute demonstration of what you can do with pattern matching, but there is no clear relationship between the required output and the implementation. OP's is understandable even if you don't know Elixir.
My problem with this answer is that, while an interesting demo of pattern matching based on input, it is both hard to extend further ("Now add a case for every 12th item..") and hard to read as the logic (done with pattern matching) is separate from the decision (the fb function) meaning you have to read the latter to understand the former .. and they are in two different places. This would be fine if the fizzbuzz function was somehow generic, but it really is not: it is tied to the exact form of inputs. One might also quibble that it is also less elegant as fizzbuzz is not a function over the integers, but a response to the messages generated by the separate function fb which is.
Nice demo, but suffers from the same issues imho as "canonical" version above. As for no mod/rem operation needed: it's there, it's just encoded in the instruction execution order. You can see this clearly since to explain how that code works, you will end up referencing the length of the two cycles.
Good point. I like that separation.
...and I think, it may reach "Top 20" in 2017 or 2018 :)
What is the advantage to this library over [mdef](https://github.com/pragdave/mdef)?
`mdef` seems to be target towards creating multi head functions easily. This is really targeted at storing lookup data. For instance http status messages.
Yes. I have Elixir in production and it is good. And like you, I feel like it's a result of so many decisions having been made right. I like that most people are mentioning mix, tests, pipes, docs and doctests, etc. None of those are all that Elixir-specific -- however, they **are** a reflection of Jose's general good taste, and they're all great. "Jose's good taste" sometimes feels like half of the value prop of Elixir to me, tbh. And as an aside, if you want to stand on the shoulders of giants, there's probably not a better abstraction to add to your language than macros. "Language with macros built on Beam VM" absolutely seems like a cheat code in hindsight. :) Doing that really let Jose focus on things that matter.
But you said [in this thread](https://www.reddit.com/r/elixir/comments/5bl47p/defmap_is_a_utility_which_allows_you_to_embed_a/d9pcu5x/) that it does create multiple function heads. So are these just two different approaches to the same problem or is there some use case that this covers and mdef does not that I am missing?
It does. The use cases for these are a bit different. For instance, mdef adds syntactic sugar to make multiple heads easy and have whatever code inside these function definitions. However, defmap's only purpose is to serve as an embedded map/lookup module. So, you give it a map and it compiles it to a bunch of function heads (one for each key). So, defmap has a very narrow scope in that sense.
That'd be great. I'd like to find a job writing elixir around then. I've been learning how to wrangle OTP now so around 2018 I'll be pretty damn comfortable with it!
I submitted some updates to the [shopify](https://github.com/Boulevard/shopify) library, to support writing shopify apps in Elixir.
Is RethinkDB still alive? Has there been an announcement since their last blog post?
Ruby is surprisingly fast when you are using the built in stuff. I ran some benchmarks of rack vs plug on jruby vs elixir and they were about the same requests per second. Maybe that's because I don't know elixir very well yet but I was just basically going by the docs.
[ExVCR](https://github.com/parroty/exvcr) is an HTTP request/response recorder for Elixir. It supports rapid test-driven development when accessing external web services. For the [Strava API wrapper](https://github.com/slashdotdash/strava) I authored, the execution time for the test suite reduced by a factor of ten when using ExVCR's recorded fixture data. From 44 seconds down to 4 seconds. 
I don't like how syntax heavy this site is.
Just watched a couple of preview vids. Looks excellent. I wish I'd found this course 8 months ago. 
Using Jruby is kinda cheating since the JVM is impressively fast when compared to anything short of c/++ and doesn't really have much to do with ruby's performance more the jvm's performance.
So, I saw this the other day and after looking at your implementation thought: could it be done with limited state in the server, and without communicating with the server (a bottleneck) on each ping? After all, as the number of processes (objects! :) in the ring grows, the wors ethe performance will be. But if each item in the ring kept its own state .... During a conference presentation today (*cough*) I found some time to implement this: https://exote.ch/~aseigo/ping_ring.ex It's a, or so I hope, interesting variant on what you did. I may try to tackle some of the open issues there, particularly: how best to ensure that should any given item in the ring crash (or be killed), that the ring remains in working order. That is (at least to me? :) an interesting problem given the distributed state ... will think on it!
This was written to be used by [Swarm](https://github.com/bitwalker/swarm) which is by the same author. &gt; Swarm is a global distributed registry, offering a feature set similar to that of gproc, but architected to handle dynamic node membership and large volumes of process registrations being created/removed in short time windows. It is a replacement for global and gproc. As according to its author, Paul Schoenfelder, global is not very flexible, and both of them require leader election. If you require a large number of dynamic node membership and registrations, there are potential deadlocks/timeouts during leadership contention.
Meet the new Ruby. I think we need one or two successful big projects, something like Basecamp, build on top of Elixir, and we will be watching the Elixir ecosystem skyrocketing.
code **UDEMY1175** gets the price down to $12! 
See also [a _functional_ FizzBuzz (no modulus or division) in Elixir](https://gist.github.com/sunaku/ea8c5818010308c86f16) as well as [the original version in Haskell](https://pragprog.com/magazines/2012-08/thinking-functionally-with-haskell).
Registry is local-only, so it doesn't compare to any of those. :)
Ruby is MRI Jruby doesn't even support all of Ruby
What part of ruby doesn't it support?
https://github.com/jruby/jruby/wiki/DifferencesBetweenMriAndJruby 
This looks like a much fancier version of something a built a week or two ago to cluster my nodes on AWS. I used [ex_aws](https://github.com/CargoSense/ex_aws) to query for EC2 instances with a particular tag, then [Node.connect/1](http://elixir-lang.org/docs/stable/elixir/Node.html#connect/1) to them.
Not that big of a deal. 
You submit this garbage "blog" post where you're just listing links from this very same sub â half of which you yourself submitted previously. And didn't even change the title. Oh okay, there's "original content" in the blogpost: the ads you've put in. Title | Previous submission | By ---|---|--- Elixir School | Elixir School [6 days ago](https://www.reddit.com/r/elixir/comments/5b8zdg/elixir_school/) | **/u/stanislavb** Elixir vs Ruby: File I/O performance (Ruby kind of wins?) | Elixir vs Ruby: File I/O performance (Ruby kind of wins?) [6 days ago](https://www.reddit.com/r/elixir/comments/5bm11c/elixir_vs_ruby_file_io_performance_ruby_kind_of/) | **/u/stanislavb** Railway programming in Elixir using `with` | Railway programming in Elixir using `with` [7 days ago](https://www.reddit.com/r/elixir/comments/5b2pzv/railway_programming_in_elixir_using_with/) | /u/_slashdotdash Elixir School - GenStage | Elixir School - GenStage [2 days ago](https://www.reddit.com/r/elixir/comments/5c0yib/elixir_school_genstage/) | /u/theenergyturtle Heap automates away the annoying parts of user analytics. No manual event tracking. | n/a: it's an advertisement | Sending Email via SMTP with Elixir and Phoenix | Sending Email via SMTP with Elixir and Phoenix [1 day ago](https://www.reddit.com/r/elixir/comments/5c2xqx/sending_email_via_smtp_with_elixir_and_phoenix/) | **/u/stanislavb** Elixir is pointed out as one of the three fast-growing languages for November (from #86 to #64) | Elixir is pointed out as one of the three fast-growing languages for November (from #86 to #64) [4 days ago](https://www.reddit.com/r/elixir/comments/5bm29a/elixir_is_pointed_out_as_one_of_the_three/) | **/u/stanislavb** Live-coding FizzBuzz in Elixir Lightning Talk| I'm just starting on the language, but damn this is an elegant FizzBuzz. [4 days ago](https://www.reddit.com/r/elixir/comments/5bj28j/im_just_starting_on_the_language_but_damn_this_is/) | /u/tolas Elixir Module Attributes - 'How To' blog post | Elixir Module Attributes - 'How To' blog post [3 days ago](https://www.reddit.com/r/elixir/comments/5btpvk/elixir_module_attributes_how_to_blog_post/) | /u/andradinu Elixir goes from "Assess" to "Trial" in the latest Thoughtworks' Technology Radar | Elixir goes from "Assess" to "Trial" in the latest Thoughtworks' Technology Radar [3 days ago](https://www.reddit.com/r/elixir/comments/5bql8y/elixir_goes_from_assess_to_trial_in_the_latest/) | /u/i_like_green_peas HTTP unit tests using ExVCR | HTTP unit tests using ExVCR [3 days ago](https://www.reddit.com/r/elixir/comments/5bsjiz/http_unit_tests_using_exvcr/) | /u/_slashdotdash Looking for a job? Join Honeypot and let companies apply to you... | n/a: it's an advertisement | And you're doing the same thing across different programming subs. * [In /r/java](https://www.reddit.com/r/java/comments/5cdlah/awesome_java_weekly_issue_26/) * [In /r/python](https://www.reddit.com/r/Python/comments/5cdl5b/awesome_python_weekly_issue_26/) * Here in /r/elixir 
If you're using Phoenix you can add them to config/prod.secret.exs and just copy that over to your server some how. Or use Environment variables using something like System.get_env("MY_VARIABLE") or use something like Conform https://hex.pm/packages/conform if you're building erlang releases with something like Distillery or Exrm 
Some more links for you http://blog.plataformatec.com.br/2016/05/how-to-config-environment-variables-with-elixir-and-exrm/ and http://blog.plataformatec.com.br/2016/06/deploying-elixir-applications-with-edeliver/ https://hex.pm/packages/distillery
Also worth mentioning the #deployment channel over on the elixir-lang slack https://elixir-slackin.herokuapp.com/ is pretty helpful.
Seems like deep_merge is a utility function that just about every project reimplements eventually. I also have some code that could use a deep_reduce and probably deep_map and deep_filter.
You are correct. There are still use cases that need a durable queue of jobs. (There are sidekiq implementations in Elixir).
yeah that is probably the most common reason and perfectly valid. Problem is it always also bugs people in development as test runs/server startup are slow... you can change some options to tweak it but it's never quite CRuby.
I like env variables makes it easy to deploy to a staging and a prod using the same configuration file but with some different settings.
It's not just an in memory store tho. It's having important things like queue priority, retries, rate limiting, recurring scheduled tasks and most importantly being able to survive a VM death and not lose data. Just about all of those things are essential in a "real" web application.
Yeah they are not all dependent on Redis but you would still want to run them in an isolated process to survive death. 75%+ of them seem to depend on Redis or another third party back-end, and some of the Elixir specific ones don't have functionality that's kind of a necessity in a real project. Did you have any specific one in mind that didn't depend on a third party back-end but still has all of eqx's features?
Unfortunately, the legend for "Source Code" appears to be incorrect.
File.ls
Which wraps :file.list_dir http://erlang.org/doc/man/file.html#list_dir-1
This is only kind-of true. It depends how you deploy and run your app and probably only works if you are running the app in production using mix. Mix configs gets created at compile time so if you are compiling and deploying on the same server that's fine. If you're compiling and trying to run on a server (using exrm or distillery for example) without mix then that won't work. In those cases something like [conform](https://github.com/bitwalker/conform) can be used. That also solves the secret stuff at the same time since the valid values are only on the servers where the app is run.
This month, and since the turn of the year really, I've found Elixir and proceeded to build my game's backend with. I apologize for the lack of reference, since I still haven't shipped. The game needs the usual game requirements of lobby, rooms, game sessions, chatting, and matchmaking. While my experienced friend hardly built an MVP with all those features in 2 months using C++, I did it within 3 weeks, without prior Elixir knowledge. This is a testimony for the platform, since I'm not really specially talented. I proceed to implement more cool features, when I am not working on the client code. Features like daily rewards, social login, and in app purchase processing just to name a few.
The post is doing it wrong. If you want to maximize Elixir performance in that case, you don't use Stream. That gets you laziness but not concurrency. If you want both laziness and concurrency, you use Flow. The example was "embarrassingly parallel", yet no concurrency/parallelism was utilized, which completely ignores the strength of Elixir and the Erlang VM. Here's an article with an example of using Flow versus Stream: https://github.com/BrianDGLS/elixir-dna-parser
No problem. Happy to help.
http://elixir-lang.org/docs/master/elixir/Map.html#take/2
Don't think blank? and present? is available in Ruby, isn't it a Rails thing?
I think you are right. Then, how about coming from Rails and moving to Phoenix? Is there something similar?
Thanks, it makes sense. I think you are right, and it is more appropriate to use something idiomatic for Elixir. e.g. pattern matching.
The answer is, you don't end up needing things like that due to pattern-matching and just generally being more specific about what you're checking for, which reduces bugs anyway
[Here was my version which took advantage of pattern matching to only do 1 rem calculation.](https://github.com/pmarreck/elixir-snippets/blob/master/fizzbuzz.exs) Your example uses guards, technically, not pattern-matching per se.
Started thinking about this last night, that's how I was going to go about it unless someone has a better idea.
That's the answer he wants but not the answer he deserves.
++, not to mention does not recreate blank? which would count `" "` and any variation of an all whitespace variable content as true. 
thanks for the suggestions, I will explore a little bit!
Thank you. I figured this was obvious but I am so used to OO languages I was looking in the wrong place in the docs.
Great writeup. Sounds like the conference was really nice!
No you don't. Most major libraries have a jruby equivalent.
Distributed database - Mnesia. It'snot SQL db, but more like Bercley DB or LevelDB - language included, and the main feature of it is sharding - you can simply horizontally scale you app on any number of nodes without writing any additional code. Something like redis replication. Nowadays, teams that came from Rail use Postgres SQL throw mapper with name Ecto, which is conventionally included in Phoenix, and don't use Mnesia. But you can still put yourself into such a challenge - Mnesia is a part of LYME stack, and you probably will be succeeded. And the end, I could say that you need nothing out of Erlang to build full featured web app - OTP has Db, KV storage for caching named ETS, web server called Yaws, zero cost horizontal scaling, MQ brockers and simple communication with other apps and languages. But quality is a question. And you should find developers to implement that - it can be very hard
Yes exactly! Thank you. This image is just extremely powerful and it peaked my interest. I am already familiar with elixir and phoenix and have used them to write a few toy projects. But didn't know the extent of how powerful these tools are.
Great explanation. You just simply convinced me to study ETS further and experiment with it.
Truth be told I didn't read the method - just saw it floating around.
Hi, &gt; So, could erlang/elixir really replace most of the stack that, for example, rails or other frameworks require? I'll enter a mini rant here, because I don't believe there's a simple answer for this. A TL;DR would be "yes, but" :-) First of all, as the author of EiA I'll take this opportunity to point out that that table is a true story. I was working on those two things side-by-side, and we needed to reach out for a lot of techs to overcome the limitations of our primary tech (Ruby/Rails) and make our system deal with the continuous load increase. In the end, I'd argue that the system A is not implemented in Ruby anymore. Rather, it's implemented in a *nix OS, using a mixture of various languages and components for different tasks. At the same time, with Erlang I had a lot of options at my disposal directly in my main tech, and that kept the system simpler. It was written in a single language, developed as a single project, ran in production as a single OS process. IMO there are some huge wins here, because this simplifies my day-to-day tasks such as development, operations, maintenance, debugging, ... Once I actually realized the difference between these two systems, I completely fell for Erlang and never looked back :-) All this being said, it still makes sense to reach out for other techs. It's not that we never do that, but rather that there's less need to do it, especially in simpler scenarios. For example, if your system is simple, and the load is not very huge, you don't need nginx in front of some pool of OS processes/threads. You can go quite far with Phoenix or any other Erlang based web server/framework. This is what I do for [my blog](http://theerlangelist.com/), which is implemented with Elixir and Phoenix, and it doesn't use nginx or any other reverse proxy. It's a single project, runs as a single OS process, and serves my needs just fine. However, for performance or other reasons it might make sense to delegate some tasks to nginx, such as serving of static files, or terminating SSL. So it's not that we never use nginx, but rather that we can start much simpler, and add the additional tech when it brings some benefits. In contrast, in many scripting languages you need to reach out for e.g. nginx, redis, and some external job runner (such as sidekiq) very early in the game, even for the simplest of cases. These other techs are then used to work around some fundamental deficiencies of the primary technology, such as lack of proper concurrency, or no support for statefulness. In other words, there's less to no options here. You want to be multicore, maybe manage some in-memory cache, run some background/periodic jobs? Say hello to nginx, redis, sidekiq, cron, and such :-) Now, it's also worth pointing out that some cases in Erlang, although possible, might become much harder to solve if you want to run a distributed system and manage some cluster-wide state. While there are some great libraries that can help you here (most notably riak_core and riak_ensemble), using them is not straightforward, so people still end up choosing something else (e.g. redis), to share some state in a cluster. I think there's definitely a lot of room for improvement in this area and I have a feeling Erlang could take us very far. For example, I think a lot of functionality provided by Kubernetes could be done in Erlang in a simpler way. However, doing it properly today is far from easy. Database is one case where I frequently step outside of Erlang almost immediately. While Erlang's Mnesia is very interesting and has some compelling features, making it work properly requires some effort, especially in a distributed setting. Mnesia also has some limitations, and is a bit esoteric, so I usually go for a dedicated 3rd party product, such as PostgreSQL, almost immediately. So at the end of the day, we still reach for other products and mix different techs. However, we reach for those things when they simplify our life, and not because our main tech gives us no options. Consequently, compared to many other popular techs of today, in simple cases we can get simpler solutions with Erlang. This is IMO even more true when adding Elixir/Phoenix into the mix. At the same time, given that we can still interact with other products, and even manage pieces of code written in other languages from Erlang, in the worst case scenario Erlang/Elixir/Phoenix solution should be roughly as complex as the equivalent in other languages. What's frequently the only option in other techs, is in Erlang just the most complex option :-) HTH
Mnesia (the "distributed database" in question) probably won't be a suitable replacement for a traditional RDBMS like MySQL or PostgreSQL unless you really know what you're doing. Mnesia's great, but it ain't for everyone. It's quite handy as a caching layer, though. However, there are databases like CouchDB and Riak that are written in Erlang and would thus be in keeping with the "Erlang replaces the whole web stack" idea. These (like Mnesia) are "NoSQL" databases, so expect the semantics around data access/manipulation to be a bit alien coming from SQL, but they're both quite capable and used in production both inside and outside the Erlang ecosystem.
To add a thought to this: There are great reasons to use these external tools: they're normally very, very good at what they do, and by using an external systemâin particular external databasesâit becomes easy for other applications and services to tap into that system. In Ruby land, though, you don't normally reach for these tools because you need a tool great at something, but because Ruby sucks at that task. A great example for this is background job processing and redis. &gt; *Redis supports data structures such as strings*, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions... I'd be surprised if half of Rails developers realize the capabilities of redis. Most Rails apps I know don't need anything but those first 7 words for their background jobs. They use redis because redis is easy to set up, and Ruby doesn't offer a safe way to store data inside another globally accessible Ruby process. This sort of stuff is trivial on the BEAM. Between its unique process framework, and the OTP tools built on top of them, Elixir and Erlang simply offer a much richer and more capable standard library, and Ruby has some language-level weakness that developers mitigate by bringing in external tools far sooner. However, Elixir and Erlang are still just general-purpose programming languages, and can't replace the power of specific-purpose tools. The main difference is you can go shopping for them when you need their specific strengths, rather than to supplement a language weakness.
A lot of the info in the community is for approaches like edeliver, essentially going all-in on Beam -- often in situations where you have a fixed set of nodes whose addresses you know already. Makes total sense given, how much the Beam can get out of a few machines, etc. However, for projects with quick turnaround, I found myself deploying to a few different container orchestration setups (ECS, Kubernetes), and connecting containers didn't always have such a great story. If anyone needs help with this sort of thing, feel free to PM me if I'm not on elixir-lang slack.
Phoenix is slower than sinatra + puma + sequel? That's not good.
why is nodejs is faster then phoenix?
Any issues clustering across multiple AZs / regions? 
Multi-az should be fine I think in that scenario, because vpcs can span azs. Multi-region is a bigger issue almost regardless of cloud. It'd get tricky, NOT for Elixir reasons, but for basic networking reasons (or better said, amazon network reasons). You can set things up to work between VPCs, though I think the process is very manual (ie, divide up address space between them, add vpn node in each, route traffic for address ranges of other vpc to the vpn node who will forward it across the gateway). But ^^^ is a bit of a yak shave. Like, if a VPN node dies, or the VPN software on it needs restarted. So now we're writing code purely to put hair on our chests. Honestly, if multi-region was important to me, I'd look into a platform that supports it. Since I'm already deploying containerized to kubernetes, I'd probably look into k8s Federation a bit more.
The best way is to create a [controller plug](http://www.phoenixframework.org/docs/understanding-plug) that will automatically set the assign for you, and then you don't have to include it manually in each action. It's flexible because then you can easily configure which actions you want it to run on: plug :set_my_thing when action in [:index, :show] Then in your footer template, check for the existence of `@conn.assigns[:my_thing]` and render the thing if it exists. 
but then I'll have to include it in each controller!
You'd make it a part of the pipeline in your routes. pipeline :thing_setter do plug :set_my_thing end scope "/jawn", MyApp do pipe_through :browser pipe_through :thing_setter resources "/stuff", StuffController, [:index, :show] end 
I'd appreciate it if people took a look at it because I want to ask Slack to use it for code snippets. Thanks!
I've tried using turbolinks with .net applications a few times, and I always struggle to find a good pattern for page-specific javascript. Any tips on how I might go about executing a block of javascript only when a specific page loads? 
Testing for an attribute on `&lt;body data-page="&lt;%= controller_name %&gt;"&gt;` would also work.
Thanks for all the info! 
in case someone decides to try turbolinks with Phoenix, here's a plug to help with integration https://hex.pm/packages/turbolinks_plug For now only takes care of redirects (just like ruby gem does).
Phoenix did very well on Data Updates test. Correct me if I'm wrong, but I would think that the nature of the Data Updates test vs. the Fortunes test points to the issue being in some aspect of HTML generation, no?
&gt; equivalent Aye, so you lose a lot of libraries.
This is the approach I've seen most frequently. It works well enough, I was just curious if there was a better approach. Thanks!
You should probably PR to the [CodeMirror repo](https://github.com/codemirror/CodeMirror) then!
Awesome write-up. Is broadcast used for websockets? I didn't see anything in the front-end snippet responsible for making a WS connection or HTTP request.
It's confusing how you use pipe. I don't think you should pipe to functions not taking any parameters. Also does the function4 take 2 parameters or 1? As for your question, if you use pipe only when it's needed, I think it looks better without parents.
A couple of the style guides online recommend using parentheses event for zero-arity functions or one-arity functions in a pipeline. https://github.com/lexmag/elixir-style-guide/blob/master/README.md#syntax String.strip(input) |&gt; decode() However the team I work with never uses parens when there are no args. 
The popular [Elixir style guide](https://github.com/levionessa/elixir_style_guide) recommends using bare variables in the first part of a function chain and does not use parentheses for one-arity functions. input |&gt; String.strip |&gt; decode 
Only had a look at the readme and the tests so far, but it looks like a nice api, and I'll def have a go with it when I inevitably need to do categories again. Only suggestion I'd make is to move the link to the postgres CTE docs to the top of the readme, I would've googled it before I got to the link in the options section.
As somebody else mentioned, the style guide prefers brackets, for clarity. ~~Saying that, the advent of Elixir 1.4 will pretty much make any debate meaningless: all function calls with no brackets will emit warnings at compile time. Libraries are already adapting to this, so I suggest you start adopting the brackets convention from now! :)~~ Edit: I TAKE IT AAALL BACK! See JosÃ©'s answer just here ðð»
Aahh crap, I misremembered! Thank you for clarifying, JosÃ©, that sounds way more forgiving than what I said! :D
This is really cool. Is your goal to make these libraries suitable for production use?
Yes, that's definitely my aim. The web app I'm building that uses these libraries is helping to drive features and uncover bugs. I'm also collecting feedback, suggestions and ideas from people interested in CQRS to help shape the public API. 
so I don't need to provide a path to my rsa key, do I?
If you keep them in `~/.ssh`, you don't.
I'm planning to create a PR that adds a link to the mode, but CodeMirror isn't accepting new modes into their repo.
Cool -- thanks for clarifying :)
Thanks -- I just wanted to use DNS, which is a popular approach, but there wasn't Elixir support for that yet. So I originally only supported DNS and List. When I refactored it to support stateful providers I added UDP as the test case, because I needed to write some UDP stuff anyway. I took the opportunity to apply some of [this stuff](http://dbeck.github.io/Scalesmall-W5-UDP-Multicast-Mixed-With-TCP/), like using `active: N` mode, and I decided just for fun to make a provider that wouldn't die under any level of load; I tested by just hammering with `nc udpport &lt; flood_o_random_data` and ensuring that the cluster was unaffected. (libcluster's approach is better on the probably more useful metric of: if flood o data happens on the broadcast for some reason, the only downside is that discovery operations may be interrupted during that spike, but the upside is that those conditions shouldn't affect your app otherwise, even a little bit. Whereas mine makes a good-faith effort to discard/cut through the noise and maintains discovery, but at a CPU/scheduling cost that, when pegged with random data, was like 25% I think? :)
I think you're asking for a basic CRUD of an "address" item? I don't imagine anyone has done a library for something this trivial. If you follow any Phoenix/ecto tutorials, you can just replace whatever they're storing (ex. a To-do list item) with the desired schema of your address row. (first_name, last_name, address_1, city, etc)
Well, there's a lot of problem with addresses, it's not the same for every country etc. Look at this https://github.com/commerceguys/addressing (sorry for linking PHP but I come from the PHP world) as an example.
OK, so the intention is only to clarify when an expression on its own could be either a zero arity function or a local variable without needing to read the surrounding code. Pipelines are exempt because it's never ambiguous - you can't pipe into a variable. Makes sense I suppose - though personally I don't like the visual inconsistency of empty parens everywhere except in pipelines. I just never use empty parens keeping functions short so it is obvious what the local variables are. As always the important thing is to pick a style guide and ideally use credo / dogma to enforce consistency on your projects. 
Which problem are you trying to solve? The link you posted shows what many would consider to be a base schema for addresses which is trivial to implement in elixir/ecto. Are you concerned with presentation of addresses? Verification of addresses? something else? I am not sure that there will ever be something for elixir/phoenix that matches the feature of that library -- it seems like a kitchen sink of all of those concerns is not how something would be structured here. 
Storage and presentation -- probably on Google Maps. Of course, I could just store a common superset of address fields but the main problem here is that the structure of an address is different from country to country.
I suggest then using something like postgres or mongo and storing the "excess" fields that don't all fit into common columns well into an embedded schema. Hes right though, its not likely something like that will ever exist as its basically a single schema file and not really big enough of a problem domain to warrant a whole project. Given your level of knowledge with Elixir/Phoenix/Ecto, I'd suggest taking a more agile approach. Implement the address types you know you will NEED to support and then build upon it once you've got some solid functionality in your application. I'm doubting addresses are the core functionality of your app...
From the little benchmarking I have done `Enum.random` seems pretty darn efficient! I tried your suggestion though and it barely changed anything to overall runtime, sadly :( I'm sure that this is something about the size of the string. As Elixir uses recursion the string is copied in memory over and over again. But that said, I assume that using Lists would solve that (I assume we only copy the references to links) but it doesn't seem to run faster either.
Here's one solution: defmodule Genetic do def generate(length) do power = 8 max = :math.pow(2, power) |&gt; trunc iterations = trunc(length / 8) + 1 Stream.repeatedly(fn -&gt; :rand.uniform(max) - 1 end) |&gt; Stream.take(iterations) |&gt; Enum.reduce(&lt;&lt;&gt;&gt;, fn byte, acc -&gt; acc &lt;&gt; &lt;&lt;byte&gt;&gt; end) end end binary = Genetic.generate(99_999_999) IO.puts("Length: #{bit_size(binary)} bits") # =&gt; Length: 100000000 bits While you're right `&lt;&lt;48&gt;&gt;` is the binary representation of the string "0", but it also takes up 8 bits. With Elixir, you can easily work at the bit level, so instead you're working with `&lt;&lt;0::size(1)&gt;&gt;` and `&lt;&lt;1::size(1)&gt;`. In this case I've created a binary that is slightly larger than the requested length (binaries have to be made up of bytes, so the bit length is always going to be a multiple of 8, so I just rounded up to be safe). I generate it one byte (8 bits) at a time, then simply concatenate all the bytes together using `Enum.reduce`. I use `Stream` for lazy evaluation, since we don't want to be iterating over it every step of the process.
Couldn't you use a linked list, efficiently pushing values onto the tail, and convert it to a binary at the end?
Phoenix looks a lot like rails, especially for rails developers, because elixir looks like ruby and phoenix uses the MVC pattern. Also, the creators of elixir and phoenix came from ruby and rails. You can't help but feel the strong similarity between phoenix and rails. Having said that, the differences are subtle. I think the Changelog source code is a pretty good example of how an elixir/phoenix app should be written.
I tried that. And it still takes a while with really large number. Which makes sense. Since each element is still a full string!
That's excellent! It's pretty extreme but it definitely gets the job done, fast! Thank you!
[Here](https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-1) is a tutorial about a trello clone built with phoenix. If you follow the github link (found in the tutorial) the code has also many PR's not described in the tutorial. [Here](https://github.com/authentic-pixels/ex-shop) is a webshop built with phoenix I would love to see more links to code of websites built with phoenix. 
awesome! thank you for sharing this. 
1.4 already :) 
That is a great table
The author, Stephen Grider, has a good track record on Udemy so this course is likely to be a good choice if you're looking to learn Phoenix/Elixir. There's already a brief discussion about this course on Reddit here: [https://www.reddit.com/r/elixir/comments/5ae9gj/the_complete_elixir_and_phoenix_bootcamp_udemy/](https://www.reddit.com/r/elixir/comments/5ae9gj/the_complete_elixir_and_phoenix_bootcamp_udemy/) BTW you can save a bit extra and get the course for 80% Off ($10) via my site here: [http://best-course-online.com/reviews/udemy-the-complete-elixir-and-phoenix-bootcamp-coupon/](http://best-course-online.com/reviews/udemy-the-complete-elixir-and-phoenix-bootcamp-coupon/) I hope that helps! 
For those that missed this deal and still want to get a deal on this course you can go to the course on Udemy via: [http://best-course-online.com/reviews/udemy-the-complete-elixir-and-phoenix-bootcamp-coupon/](http://best-course-online.com/reviews/udemy-the-complete-elixir-and-phoenix-bootcamp-coupon/) I keep the site updated with the best deals for Udemy courses. Currently: Most courses $10, including this one. I hope that helps!
I bought it and I am almost finishing the Elixir part. It is great so far. Not too complicated, but nice introductions to stuff I've seen until now. But I read lots of books and followed Elixir Sips before so I'm not a total beginner. I also really like Stephen's other courses. I have almost all of them and basically learned all my React and React Native from him. I just don't think this is a truly "Complete" course, as in covering everything important. It is more an introduction to Elixir, without OTP (so far) and even without the more powerful concurrency stuff. The book Elixir in Action, for example, seems to go much more in depth, but it can be harder for total beginners to understand pattern matching and function arity. 
Correct. All structs are maps, so you can provide a pattern that matches a map and it will also match a struct that has those keys.
i'm working through it (on the ecto chapter right now). It's a really solid introduction, and should be followed up with other in-depth books/tutorials. I got it for $10, and imo it's incredibly good value at that price. 
I'm in the middle of it right now. I've finished the elixir section and I'm some ways into the phoenix section. I'd definitely recommend it, especially at the current sale prices, which are phenomenally good value. I wouldn't call it complete because there's quite a bit of depth to elixir that it just wouldn't be reasonable to get into all of it in one course. Specifically I haven't seen anything about OTP yet, supervisors, a few other things that make it Elixir especially powerful. What it does do well is organize what you should learn to be able to use both elixir and phoenix in general, and then teach that in a clear and reasonably concise manner. It's really helped me stop diving down rabbit holes and get me to a point where I'm comfortable writing in elixir rather than my old go-to stack. As an instructor, he's quite good at recording, speaking, etc. so it's definitely not frustrating to listen to and watch.
Watched it, had a bit of experience already, but at 1.5x speed, it was pretty good. Not complete yet, so I expect there is still some things down the road. 
Do I need to signup/RSVP to see the recordings? I won't be able to make it live, but recording would be nice.
As far as I know, using `escript.build` is the closest you're going to get and will still require the Erlang VM on the user's system to run.
If you are sharing an Elixir script (.exs) you need both Elixir and Erlang runtimes installed on the host system. Also, if you are distributing an escript you need to have at least Erlang runtime installed on the host system (Elixir will be embedded in the escript archive). There is no way around it. If you are distributing an OTP application you can generate a release with distillery that can include the Erlang runtime in the same tarball but you'll need to generate a release per OS you want to ship a release.
I've used this pattern for years, with a lot of success. No reason it wouldn't work with Turbolinks: http://jerodsanto.net/2012/02/a-simple-pattern-to-namespace-and-selectively-execute-certain-bits-of-javascript-depending-on-which-rails-controller-and-action-are-active/
Just finished it yesterday and bought it on the 6th. Before buying this I worked through Programming Phoenix until I felt like I couldn't keep up learning a framework AND a language at the same time. So then I bought Programming Elixir and worked through a bit of that until I started stalling on the more advanced parts. Not having had much previous experience with elixir, or programming in general I really appreciated the time Stephen took to explain things in detail and not just punch out lines of code. A lot of times with tutorials I feel like I get a type of "technical debt" built up throughout the course of small subtle details that I don't fully comprehend that eventually those build up and make the higher level stuff very difficult to understand. I didn't feel like that at all really with this course the topics just flowed and the level of detail in the explanations plus the diagrams made this a very easy course to follow along with and actually learn from.
Thank you for your answer
I don't have specific information about Erlang/Elixir telnet libraries, but I have done quite a bit of this kind of automation over the years. The telnet protocol is mostly text, but with a few wrinkles. You are probably better off using a client library than writing raw sockets. Some Googling turned up https://github.com/hejin1026/telnet and http://erlang.org/doc/man/ct_telnet.html (maybe useful as a reference). Once you have a connection, it depends on what you want to do with it. Interactive programs can be tricky to automate, e.g. you might want to wait for a login prompt, then send a password. If you have a slow connection, you might need to wait a while for the login prompt to show up fully, or timeout if it has been too long. And you might need to deal with terminal escape sequences (set the target side to use as dumb a terminal as possible). There are various libraries to do this, e.g. the granddaddy, "expect", and newer libraries in various languages. And there are "scriptable" clients like kermit. So you might find that it's easier to write a client library in another language and call it from Elixir using a port. Having said that, Erlang/Elixir would be great for this kind of thing, Google and you may find a good example. 
I'm building a full stack application in phoenix for work. Personally I'm working on a [functional programming library](https://github.com/aleandros/sky)
Thanks!
`elixir my_file.exs`
Any word on how well erlport performs? I'd seen it before but could've sworn it was under the guise of "don't use this in production because it's slow." I'd be ecstatic if that wasn't the case since my switch to elixir at work is predicated on some GIS stuff that is already implemented via Ruby and too much work to port to a NIF in C.
What about an [NIF in Rust](https://github.com/hansihe/Rustler)? :D 
That's awesome! I've enjoyed checking in on farmbot but had no idea you were using elixir. Extra cool!
It's been interesting getting into Kitto. Part of the reason for it was because of work but also I hadn't gotten to work with React or WebPack before. I still don't think I really like WebPack very much, but it seems to be what the JS gods have chosen as the new asset builder... All that said, you shouldn't need to restart the server when you're changing assets. WebPack will rebuild and push your changes to the client.
What about when recompiling a job or similar? Also, do you plan to add some basic tests to the default generated project?
This seems like an awesome idea of how to make money out of Open Source. 
Thanks! I spent a long time trying to plan out this model and am really excited to make it succeed. I've been an open source zealot for 18 years now and really think there remain a lot of business models to be tried. I'm going to try to get the word out about it a lot more on Monday. Figure Thanksgiving might not be the best day to push marketing stuff :)
Still a young project inspired by the work of many. This is as much a thought experiment as project intended to help others. Contributions, feedback and criticism is more than welcome!
Nice article. What do you think about the third described approach - "The Wormhole", are you using it / would you use it in your app?
Adding tests to the default generated project is something we should probably do. I have to admin though, I've never written a single test for dashboards I've created with Dashing in the past.
Good job. Flames seem like a helpful "gem". I've added it to awesome elixir so that others can find it, too https://elixir.libhunt.com/categories/1961-errors-and-exception-handling
Trying to find the motivation to actually program.
I really wish javascript would get this. Heres the proposal https://github.com/mindeavor/es-pipeline-operator One can dream...
Took a quick wack at it. Would reaction some refactoring of the chemical_reaction/2 (checmial_reaction(x, y) function to return a tuple with `{:success, result}` or `{:fail, result}. # sorts, get all possible sets, and start off the round of reaction defp chemical_reaction(x, y, z) do sort_ingrs([x, y, z]) |&gt; permutations_for |&gt; chemical_reaction end # if all possible sets have been tried, return all three chemicals defp chemical_reaction([{chem1, chem2, chem3} | []]), do: [chem1, chem2, chem3] # try first set, if successful, return the reaction of result, else try the next set defp chemical_reaction([{chem1, chem2, chem3} | rest]) do case chemical_reaction(chem1, chem2) do {:success, result} -&gt; chemical_reaction(result, chem3) {:fail, _} -&gt; chemical_reaction(rest) end end # all permutations of chemicals defp permutations_for(a, b, c) do [ {a, b, c}, {a, c, b}, {b, c, a} ] end
Article author here. Thanks for your comments. Wormhole is a callback wrapper that guarantees that all errors will be caught and returned in {:error, reason} form. Which can be quite convenient, especially for novice Elixir user. At RenderedText, we are using it in production code.
Position only matters when you pattern match on lists, which of course makes since when you're using a list as an array of values, but it makes destructing keyword lists (which by convention are used to pass options parameters) counterintuitive. When pattern matching on maps, order doesn't matter at all.
&gt; When pattern matching on maps, order doesn't matter at all. That's awesome! What about structs? I assume order doesn't matter there, as well, since they're really maps underneath?
Yup! Same rules apply when matching on structs. You can even match a struct as a map, as long as you don't care about the type of the struct being passed in but only the content of it.
I have this : def cr2(ingrs) do ingrs |&gt; sort_ingrs |&gt; cr2([], []) end # Try to react the first ingredient of the remaining ingredients in list # with the second def cr2([a, b|rest], discarded, top_discarded) do case chem(a, b) do # if it reacts, try again with this one on top and any other ingredient # back into the mix [ab] -&gt; all_again = sort_ingrs([ab|rest] ++ discarded ++ top_discarded) cr2(all_again, [], []) # if it does not react, try with the first and the third _ -&gt; cr2([a|rest], [b|discarded], top_discarded) end end # If the first (left) ingredient has no reaction with anyone else, put it in # top_discarded and try to match other ingredients (put back the discarded # into the pool) def cr2([single], discarded, top_discarded) do cr2(discarded, [], [single|top_discarded]) end # Nothing reacted with anything def cr2([], discarded, top_discarded) do sort_ingrs(discarded ++ top_discarded) end Not sure if it's clearer, but it allow for arbitrary length lists of ingredients.
yeah it used to be a ruby app but we switched to Elixir about three months ago
Thats correct. It does not matter for structs. I think the biggest difference is that destructing optionally produces `undefined` when the data is not there. With Elixir, it will instead execute the next (or whichever matches) function so you can control the flow of data. Heres an example: # In elixir, if a user is passed in, it will destructure the id field # otherwise it assumes the id itself was passed in def find(%User{id: id}), do: find(id) def find(id), do: Repo.get(User, id) // Whereas in javascript you'd have to handle that case in a single // function, checking for undefined function find({id}){ // Since the field could possibly not have an id, this is potentially // undefined. Now we have to look at the first argument and // assume its the type we were expecting. If it is not we crash with // a bizzare message whereas Elixir is more strict when we want it db.users.find(id || arguments[0].id); }
Thanks!! I believe the API is not very consistent yet, but I hope that improves with use and/or complaints.
I built a new C# channel client based on Reactive Extensions. https://github.com/bratsche/kastchei This started out mostly because I was trying to learn Reactive Extensions better and Phoenix channels seemed like a really good use case for them. I've been using this client for a personal project which is a Xamarin mobile app with an Elixir/Phoenix server. I've got Presence almost working, but not quite so I didn't push code for that yet. I'm not using Presence in my mobile app (at least not yet) so it wasn't a priority for me.
I wrote this library: https://github.com/johnhamelink/postie You can use it to normalise and parse address data. Is that useful for you?
Here is a question though. Lets say the api can have deeply nested json objects [Example](https://dev.twitch.tv/docs/api/v3/games/). Would/should I create a struct for each level of nesting? Maybe im missing something but it seems like right now i'd need to defmodule for each level. If i were to do this should i have a folder that only contains structs? would it be in bad taste to have many modules defined in one file? I know this a lot of questions but I am trying to create this in the most idiomatic and maintainable way possible. Thanks again for your input!
&gt; Here is a question though. Lets say the api can have deeply nested json objects Example. Would/should I create a struct for each level of nesting? Maybe im missing something but it seems like right now i'd need to defmodule for each level. Yes, I'd create a struct for each data type you're parsing. So in your example, you'd have a `Game` struct, and then its members `box` and `logo` could each be an `Image` struct. I think something like this should work out of the box (untested â you might have to defimpl a custom Poison.Decoder for Game to get this level of nesting properly decoded): top_games = Poison.decode!(json_string, as: %{"top" =&gt; [%{"game" =&gt; %Game{box: %Image{}, logo: %Image{}}}]}) &gt; If i were to do this should i have a folder that only contains structs? would it be in bad taste to have many modules defined in one file? This is totally up to you. Since everything is compiled together regardless of where it's located in your project, every module is accessible to every other module, so the directory structure does not technically matter. That being said, the convention I have seen is to have one module/struct defined per .ex file, where the directory path matches the namespace of the module. For example, if you had a module Twitch.API.Game, its module would be defined in `lib/twitch/api/game.ex`. And maybe you find that only Games have images in that format; then you could have Twitch.API.Game.Image, located at `lib/twitch/api/game/image.ex`. Again, this is just a convention and is not enforced by the compiler.
I haven't used Elixir in practice, but my feeling is that it's in part due to how much can be comfortably achieved with just Elixir itself. Something along the lines of this: http://i.imgur.com/yNQhQTe.png. Admittedly that's just my guess as a curious observer.
**because I don't want to have to call put_layout(false) from each action of all of my controllers.** plug :put_layout, false still has to be called in each controller.
We're running an umbrella with three Phoenix apps (and a dozen other Elixir apps) to handle various parts of a large-scale multi-tenanted retail business - a replacement for a Rails-based monolith. We've been in production for around six months now - and I imagine our use cases are rather similar. Most of the limitations we ran in to during initial implementation were our own - it's been hard shedding some of the poor practices Rails trained in to us. Once we embraced a more functional programming mindset and stopped trying to recreate ActiveRecord and Active Support the codebase became rather easy to extend and maintain. So far as positives - there has been a lot of incredible thought put in to the framework and a lot of the libraries surrounding it. You'll see the core team involved in a wide array of projects and StackOverflow posts helping people see the vision for the framework. We are very excited for some of the things we've seen (such as GraphQL) on the horizon. And, personally, Elixir forced me to start writing better code again. Probably the least developed area in the Elixir ecosystem is thinking around deployment - that is an ongoing struggle for us (though distillery and conform made things a lot more reasonable) - but our environment is probably wildly complex compared to most. Most of the libraries we would have wanted existed when we started (https://github.com/h4cc/awesome-elixir) but were maybe less mature than we would have liked a year ago... and many of the tutorials available are for edge-case needs (unless by LMS you meant "giant chat platform"). That said - the community is strong - and much like what we saw in the early days of Rails and Django the rate of maturation is exponentially growing. We had a great experience with our first Phoenix app... and for the foreseeable future it will be my go-to framework for new projects. tl;dr; yes.
I'm going deeper down the Elixir rabbit hole and have decided to start documenting my adventures in a series of screencasts at [elixircasts.io](http://elixircasts.io)
I'd love to see some docs regarding the failure states of the jobs. What happens when a job raises an error, or doesn't terminate before it is scheduled to run again? For durability / retries, could I run a single instance of cronex on a clock node, and schedule jobs to run on multiple worker nodes using Exq? 
Personally I'd use a behaviour or protocol to make the dependency interface explicit, so you have something documented when it's injected.
It would be your ex file with MyApp.SharedView defined. http://www.phoenixframework.org/docs/views
are you an idiot? I only need no layout when an error occurs and thus when I'm rendering ErrorView.
If the point - just in syntax, and all other is better, then in Rails - Rails gonna die) In fact, Phoenix has big amount of shit itself, but I think, that Elixir language is nice enough to learn. And NEVER LEARN ELIXIR FROM THE POINT OF RUBY, they are TOTALY different, only some key words are the same.
Wow. This was great. I thought it was a troll video, but after minute 4 it hits you: the love child of DJ Khalid and Turtle from entourage is really doing a language review. Best line: "functional programming, I understand it, but at the same time... I don't". Then he explains why it's a language for nerds. And it's tough to slog through the video of him making no points, but there some real gems to be had. 10/10 if this was a troll
Thanks !
Thanks for sharing. Cronex looks like a promising project and it seems it's under active development. Personally, I am using "quantum" at the moment and meets all my needs. Btw, there is [a short comparison of Cronex and Quantum here](https://elixir.libhunt.com/project/quantum-elixir/vs/cronex) 
Looks nice ! Reminds of ruby toolbox.
http://elixir-lang.org/docs/stable/elixir/Enum.html#max/1
so you suggest raising Enum.EmptyError on empty list thanks :)
Great advice, thanks!
I have used the convention to prefix an undescore to a private function name because I've seen this method in "Programming Elixir" book but if this is not widely used I'll switch back to names without undescore prefix. Thanks :)
Some people also advocate using do_max for all of your private functions. Im not a huge fan of having the same function name for the public and private versions (I like how you did it basically).
Good point!
I love that one of his arguments is "the syntax is just annoying"... "List.fold... wtf is fold?!" Also love that it ends at 8
This is horribly unwelcome behavior, especially from someone seeking help. I'll answer here, only for posterity, and not for your sake: To get what you want, you can define a function and import it to all controllers with a single line in web.ex controller block: def render_not_found(conn) do conn |&gt; put_status(404) |&gt; put_layout(false) |&gt; put_view(MyApp.ErrorView) |&gt; render(:"404") end 
Very nice post. Been working in Elixir for the last few months and didn't know some of these
In Elixir we have used both conventions `do_max` and `_max` and we have moved away from both. We are now currently trying to either: use a function with the same name but different arity (which you mentioned you didn't like) or by giving it a explicit name instead `do_max` or `_max`. In the example above, I would probably call it `max_with_acc/2`.
thank you, I appreciate that
Great video! Would love to see more like this!
This is a poorly controlled test and doesn't represent a "real world" use case. Loading all threads on a single system with both the server and client processes is going to produce nonsense results everywhere - the system is constantly context switching between the two, damaging performance, and these context switches are different "weights" depending on the laguage / environment, which means the noise in each result is different, and thus non-removable from the final result. You'd be best to run the test again using two machines: one machine runs `wrk` talking to the other (the server). The results are probably off for *all* languages used, not just Elixir! Good experimentation controls for as many things as possible, which is why doing these benchmarks is tricky. The context switch needed just to unload the Erlang VM when the CPU needs to perform calls required by the `wrk` command is huge in and of itself, which might be why the Elixir numbers look "bad" in particular. Try again with a "cleaner" setup, like pinning threads to CPU cores :D Edit: wording
Pretty sure we have the same problem mentioned [here](https://www.reddit.com/r/elixir/comments/5fn3qq/why_elixir_performs_so_bad_here/dalpv8v/) - stop doing poorly controlled tests. Actually run the clients on a separate client machine. You're polluting your data **everywhere** by forcing the server machine to do unnecessary context switches which are not representative of "real world" use: https://www.reddit.com/r/elixir/comments/5fn3qq/why_elixir_performs_so_bad_here/dalpv8v/
Agreed, not a valid test environment. Spotlight Indexer could have started while the elixir test was running. Whats a better way to perform these tests? execute the servers with the time utility and measure the cycles?
While there is definitely more happening here than the cost of context switching, at the end of the day you are measuring how fast a particular runtime can perform one particular action, which in this case is to sit on top of an acceptor loop and write static strings to the socket. The majority of the work is IO bound, which means anything you add beyond that, will cost you. Here are some examples: * Plug will always read basic request information like the request method and host - for a dynamic server, this is true for 99% of the cases, but it is needless work in this benchmark. If Plug was not doing this, Cowboy would just skip to the next request in the socket (which would be faster) * Cowboy will start a supervised process for every connection. That's what we want to do in practice, so we have each request in isolation, although that also sums up to be unnecessary cost in the benchmark above. You would squeeze better performance if you kept all connections under the process accepting requests and juggle everything there * The Erlang VM keeps a pool of schedulers that preempts your processes and an IO thread pool. This gives it the ability to do IO work without blocking any of the cores while scheduling your processes. However, because this benchmark is IO centric, having a single thread doing all the work would be faster, but that's not actually how we want to write your systems For example, a benchmark that mixtures IO and CPU work would put Ruby on a harder spot because even with 8 forked instances, when one instance is doing IO work, it cannot be doing CPU work, while Elixir would be able to juggle it according to the last bullet above. At the end of day you need to ask: what is this benchmarking measuring and how much of it can be extrapolated to your use cases. So when someone says this is not representative of the real world is because the answer to the second question is "very little". Here are more interesting use cases: * If you really need to serve static content, it would be more interesting to measure those being sent from files (which is what 99.99% of the servers do in practice) * Benchmarks where dynamic content is generated, such as JSON encoding, or template rendering (or even a random text) * Benchmarks where a database query is performed I would find the cases above more interesting because it is more inline with scenarios we are supposed to see in practice and therefore would be worth improving/optimizing.
FWIW, Elixir Radar has a jobs board too: http://plataformatec.com.br/elixir-radar/jobs :)
Many good suggestions have shown up already. You will want to control for observer effects, core affinity, and context switching to get a clearer picture, generally. Finding out how often cache misses and context switches happen could also be informative.
The Phoenix app until recently was completely broken. Techempower seems to be automating their benchmarks in a continuous system now, so iterating and hand-tuning everything should be a lot easier.
Also, i wrote a program that only appends to lists and it performs poorly, increasingly so over time. Tisk tisk elixir
Do you have the code?
**Also I want to be able to set layout false in my ErrorView, because I don't want to have to call put_layout(false) from each action of all of my controllers.**
No, that was just a joke. Elixir runs through all items of a list while appending to it and is not recommended to do for performance. Appreciate the offer to take a look though
[deleted] ^^^^^^^^^^^^^^^^0.8621 &gt; [What is this?](https://pastebin.com/64GuVi2F/46231)
You could convert the headers into a map then do pattern matching on the map. Ie: header_map = for x &lt;- resp.headers, into: %{} case header_map do %{"Content-Type" =&gt; "text/html"} -&gt; :juhuuu _ -&gt; :boohoo end 
The processes you spawn and communicate with are running concurrently and they don't get to their print instruction by the time the program finishes running. When you define another module, it just happens you give more time for the first process to print something. But the second process is printing by luck. It may print or not. If you run it with the `--no-halt` option, such as `elixir --no-halt path/to/file.ex`, Elixir won't halt as soon as it finishes the file, so you will always see the printed results (hit Ctrl+C twice to abort). One other approach is to have the calculator processes reply to you after they print and then you exit only after you get their replies.
Use IOLists
I like this idea. Just curious: is there any advantage of using the comprehension vs using [Enum.into/2](http://elixir-lang.org/docs/stable/elixir/Enum.html#into/2)? header_map = resp.headers |&gt; Enum.into(%{})
Signals are worthless if they are meaningless in context. Your car sinking in the river is a signal but is meaningless when used to determine the suitability of your car for long distance street travel. Looking at the code and structure of that benchmark there is very little if anything that represents any meaningful data points to a real application's behavior or performance. You may as well be choosing your framework on rand(). 
Thank you! I am in the process of making a follow-up video. Hoping to get it out within the week
really glad you found it useful
For what its worth I have been working on a project as I teach myself programming that now uses spring + postgres back end and a reactjs front end. The project is pretty lame - I have tried to make a "clone" (lol that makes me cringe to type!) of facebook basically with user authentication using oauth, creating a profile and making posts, a "wall" that shows only "public pages" and your friends posts, sharing posts using email (wanted to learn how the heck that works LOL), maps integration for funsies on "public pages", trying to figure out how to do a feed, etc. I have been learning a lot especially SQL (I enjoy doing those "complex queries" problems online :D) and API design. Now I am trying to learn how to use git - I wish I had spent time learning that before because it would have been so much easier with versioning! I think it will be fun to try and rebuild what I have so far :D 
Hey! Thanks a lot for the reply - much appreciated. You have cleared up my initial confusion about what phoenix really is. I find one thing that is cool about Elixir is the immutability which is new/different for me. Also thanks for the note on the git and other stuff. Its insane there is so much to learn out there and I wish I had known about computers and stuff long time ago so I could have done this stuff. Thanks for the slack as well. I've never used slack before but I will sign up for it when I get home. On a side note, you mentioned linux. Is ubuntu a good place to start? The installation instructions seem pretty straightforward but I hope I don't delete my data or something accidentally. Otherwise, do you think it is worth saving money and buying a used macbook since a lot of the videos I am watching have people using macbooks. 
Glad I could help. Immutability is a part of most functional languages. Java is part of the "imperative" and "object orientated" languages which revolve around mutation of state. Each have their own pros and cons. I personally use Mint which is almost identical to Ubuntu and on my web-server I use Debian (of which Ubuntu is a descendent). If you want to try it out you can always run it off a live USB and depending on the computer, you can just get a 2nd hard drive and install it on that without having any danger of losing anything on your first drive. That said, I would strongly suggest having backups of things because at some stage something will go wrong. In my case I applied a patch (incorrectly obviously) and had to reformat the server. Thankfully I had a backup!
I think /u/Teifion already did a great job giving you an overview of elixir and phoenix. As I always find it interesting and remarkable when someone coming from a completely different field tries to improve his life by learning how to program, here are my 2 cents on elixir in your situation. First, it never hurts to get experience in one more language, one more technology. It helps you to understand the advantages and shortcomings of the things you already know and will learn in the future. Also, many concepts you learn in one language can make you a better programmer in any other programming language. Second, elixir has a beautiful standard library and you can literally feel how much though has been put into it (while good parts have been inherited from erlang of cause â credit where credit is due). It is refreshing to read through the guides and explanations at the beginning of the modules to learn about the way problems that where inherently hard in other languages and systems are solved in elixir. I can understand why people say that elixir inspired them to become better programmers. Regardless of whether one is coding for a job or for private pleasure, elixir may be a solid choice. Finally, there is your desire to obtain an entry programming job rather sooner than later. For that, I am not certain that elixir is a good choice for you. What I mean is: There are so many programming Jobs in Java where you have an ultra-strong ecosystem, tools and a lot of knowledge present inside the companies. It is probably really easy to find a position where you receive a lot of guidance and where you can start with small tasks to learn more about the environment, the development process and the language itself. From my point of view, companies that are currently using or adopting elixir do that using smaller, more agile teams that have a high degree of specialization, education and possibly experience in the subject. It may therefore be harder to find a entry level position (learning from great people would be very advantageous of course, but as I said, it may be harder to find such a job). This does not mean that I want to discourage you from learning elixir. The opposite is true, the more you know, the better. But IMHO it may not be the best idea to specialize in elixir vs. some more widely used language.
Nice, this is so short that one does not even need a temporary variable if it's only for that one case statement
Im having a hard time taking this guy seriously when hes confusing Elm with Elixir/Erlang(in his followup video). anyway most of his beef is about it being a functional programming language, and its hard to learn/understand. Then the other argument he gives is bullshit due to he didnt even try to understand the language itself. Basically using OO mindset to learn FP, and raging for not being OO. Then making fun of other people trying to learn the languange. his 8th and last argument (the video title is 10 Reasons why you should not learn Elixir : Phoenix : Elm) is no jobs. thats it. give me back my 10 minutes of life!! 
I am building Metriculator (https://www.metriculator.com) with Elixir &amp; Phoenix framework. Metriculator helps online business run NPS (Net Promoter Score) surveys directly on their website. The survey experience can be seen in action on the home page. Here is a link to the demo dashboard - [https://www.metriculator.com/demo](https://www.metriculator.com/demo) It has been a challenging exercise with lots of new learnings (especially struggled with few topics like creating rolling SQL queries to generate charts, composing "OR" queries with Ecto ). I will be doing a public launch soon. However, if anyone is interested in trying out the beta, drop me a PM or shoot me an email at team[at]metriculator.com. 
Correction to this article: edeliver can use either exrm or distillery for building releases. Edeliver is really just a wrapper around a release manager that takes care of the deployment by using [Deliver](https://github.com/gerhard/deliver), a deployment tool written in bash.
It also grabs STDERR (if `ruby` spits out a nonzero return code), but yeah, you ain't wrong. It's deliberately simplistic, and to a fault. Export is definitely the better idea for anything in the real world. In its defense, though: * It is indeed functional * It's only 21 lines long at the moment (excluding `mix.exs`) * It doesn't require anything special on the Ruby side It might be worth covering if only as a demonstration of running external programs and dealing with their output. I looked at Erlectricity at the time that I wrote Rubix, but it seemed to be defunct. I guess there's no need to fix it if it ain't broke.
This is epic. From now I will rate languages and frameworks by number of jobs posted to Indeed and if it's worf it.
this seems like hammering a square peg in a round hole to me.. I'm a former ruby dev and I don't see what the benefit of this is here? I have left it behind in exchange for Elixir + React/Node and I can't for the life of me see where I would ever use something like this.. Cool either way though. We just released Exque for RabbitMQ that I think would be much better suited for this. https://github.com/localvore-today/exque https://github.com/emque/emque-producing
can't take mr. flat brim seriously.. he should stick to flipping burgers.
this looks really nice and you can defiantly tell its built w/ elixir/phoenix.. so fast. good luck on your project.
they're down right amazing.. i was a long time rails developer since Rails 2.. We built 1 application with Elixir as the API and Node/ReactJS as the front end and will never go back to doing it any other way. Separating front end and backend feels very natural in the work flow of large applications.
A DSL for creating conversation based UI for chat bots. I'm also playing with running Elixir on AWS lambda.
i picture this guy sitting at work working on wordpress sites... he has barely a jr. web understanding of javascript, if even that. He calls integers, "numbers." been a dev for 20 years and never once have I heard someone refer to an int as a number. Not to mention his tab in the first video is him searching for a "javascript compiler" lol I think his biggest fault was posting this here.. great you hate elixir because you're to stupid to get it. That's fine, make a video for your 30 people who watches his videos.. Then proves himself a bigot by calling people homophobic slurs in his comments until he disabled them. Guy is a grade a fucking moron and whoever hired him is an idiot.
In general, I use tagged tuples or structs for this sort of thing. So for tagged tuples you'd use `{:column, :a}`, `{:row, 1}`, and `{:attack, {:column, :a}, {:row, 1}}`. This lets you destructure like `{:attack, {:column, column}, {:row, row}} = attack`. In this particular case, I'd use a struct to hold this data, which would look like `%Attack{column: :a, row: 1}` and can also be destructured. This isn't a direct translation of ADTs in Haskell (or other languages), but it's probably the closest idiomatic translation. 
This confirms my suspicions, thanks!
Sometimes you want to run a bunch of local nodes during development to test distributed behaviors easily. Or maybe you need to have two nodes configured completely differently or (god forbid) running different versions of the codebase. These are more edge cases than actual benefits though.
Thanks for responding! I think nesting tuples of atoms is a good way to go about this. Haskell doesn't have atoms so it's a little hard to visualize, but I spent another hour working on it right after I made this post looking into how to make and use structs. I ended up with: defmodule Attack do defstruct column: nil, row: nil end attack1 = %Attack{column: :a, row: 1} Though actually originally had 'a' and '1' as strings. But using them as atoms should be all that's necessary I think. Hopefully this expands into what I need to accomplish for the rest of this project. It's going to be a lot of nesting. Since Attack destructures into a tagged tuple, I should be able to use it in a different struct, right? Such as: defmodule Turn do defstruct attack: nil, reaction: nil end #attack1 defined above #attack1 represented as {:column, :a}, {:row, 1} turn1 = %Turn{attack: attack1, reaction: :missed} I think as long as I can make structures out of structures I should be able to do work with this kind of implementation.
I don't think there is much difference in running multiple epmds or sharing the one on the system, tbh. And here is a really interesting article on replacing epmd entirely which opens all manner of possibilities. https://www.erlang-solutions.com/blog/erlang-and-elixir-distribution-without-epmd.html
Thank you! I'll spend more time on audio quality for the next one
I used this technique in production to separate two parts of the system, so I don't need to restart everything on deploy. I wasn't using hot-code swapping, so basically I went down the "microservices" road to improve the system's uptime. More specifically, one part of the system established a long-running TCP connection to the external 3rd party data provider, then accepted XML messages, decoded them and pushed the structured data forward. I extracted this part into a separate node local to the rest of the system which did something meaningful with parsed messages. The TCP/parsing part of the code was fairly simple, so after a few bugfixes and optimizations I didn't practically touch it, unlike the rest of the system which continuously evolved. Therefore, this split allowed me to do frequent deploys without the need to restart the connection, which would incur some penalty and cause some annoyance for a couple of thousand of connected end-users. Another example I can think of is if you run custom NIFs or linked-in drivers (i.e. C powered code that runs directly in the VM). In these cases, all the fault-tolerance benefits of Erlang are lost, so for example a segfault in your C code will crash the complete VM. This is why I personally think NIFs are the last option to be explored. But if all other options fail you, and you choose to use NIF, you could consider extracting the NIF and some (minimal) amount of related Elixir/Erlang code around it into a separate node, which would reduce the damage if there's some bug. I'm not saying it needs to be done this way, but it's certainly an interesting option, depending on how much you trust your C code :-)
Nice
Deploy with docker, but don't put background jobs in a durable queue? Sounds like in-progress jobs are going to be dropped when app is deployed. Are there ways to avoid this without bringing in a durable job queue?
This looks really good. Mind if I ask some questions? * Love the design - did you do this yourself or get it outsourced? * What packages are you using? * Have you taken any different approaches from the standard phoenix application (e.g. umbrella apps etc.)?
Thanks! * I did the design myself. I am using Bootstrap's grid system as a starting point. * Major packages being used are - comeonin (hashing), timex (excellent time/date library), bamboo (emails), quantum, exq (regular jobs), hound (integration testing), csv (download CSV files). I have implemented pagination myself, but I might switch to scrivener later. * Hmm, not really. I think it is just a standard phoenix application. I am not using umbrella apps. I am, however, making good use of scopes - 'admin', 'app', 'blog', 'api', 'widget' etc.
You can see it at /u/SupercoolNameinator. However it got banned from askreddit so I just shut it down.
Erlang newbie here, are there alternative packages I can compare to this one?
I'm working on an open food distribution system. Like Open Food Network, but with other design choices. I really wanted to fix/help contribute to OFN but have personally deemed it unfixable (because of technology/design choices, at least with my skills/resources) so seemed like a nice project to take on in elixir/phoenix/emberjs. I'm doing something a little less ambitious and more minimalistic.
Thanks! Hmm, not sure if there is a name for this design style. To be honest, I didn't think of using any particular style when I started the design. I just kept iterating on the basic bootstrap styles till I was happy with the result. This might seem like a shameless plug, but I have published a free bootstrap template for startup websites. You can take a look at it here - [https://www.authenticpixels.com/product/startkit-responsive-startup-business-template](https://www.authenticpixels.com/product/startkit-responsive-startup-business-template).
I am not sure what's going on in those benchmarks but something is not quite right. For example Crystal in my experience is super fact. An order of magnitude faster than Elixir, Python, Ruby etc but in those benchmarks it's slow. 
This is great. I've been thinking of doing an Elixir-Reddit-Troll bot for awhile, so thanks for the inspiration.
I don't know if django is necessarily more performant, but the django implementation contains several optimizations that take advantage of certain python features. I don't know enough about ruby or rails to compare, though.
What are the "errors and problems"?
Do you maybe know if code reload will work for lib directory?
code reloading already works for lib
Ugh, well, I had it work, at least once... but having trouble reproducing now... probably something stupid but would like to make some kind of abstraction/library to take away the pain of working with this and getting super confusing/useless error messages... ideally could add to ExCrypto (https://github.com/ntrepid8/ex_crypto) which seems to handle some similar stuff, but not currently quite what I need...
I really don't mean to be rude and I hope I'm not, but how did you write websites in PHP if views are a problem?
A friend developed this one, it might help you https://github.com/api-hogs/ecto-oracle
Thanks
The day Unity3D gets .net4.5 I'll be very happy to check this out!
I have always been part of a team. I have always wrote the back-end. In some MVC PHP applications, that meant libraries used by the higher levels of the MVC architecture. In non-MVC applications, it meant writing the API the Javascript or phone apps had to call.
Yeah I just saw that they have a beta editor with 4.6 since October. I'm pretty damn excited about it. There's been many libraries I couldn't use due to the .net limitations.
A todo application. Add categories to organize your todo list. Add users to assign lists or tasks to. (FYI I have no experience with Elixir.)
Hey I real like your posts, but i had a problem. Cause you only show examples with premitive Typs and I think Hashes will be more interisting. 
Great post! Fun to see real data from the field. Question: dropping requests would certainly be a bummer. Would it be simple to spin up a few more copies of collectors to handle them?
It depends on how the pushes are being sent to the push collectors. If the pushes are being all generated and served locally on the same server (there's only one PushCollector instance per server), then they probably don't have a way to divvy up those pushes to offload the work onto other servers. You could send the pushes to servers via a partitioning scheme ([something like this](http://www.elixirfbp.org/2016/08/genstage-example-no-3-dispatching.html)) and spin up extra servers when there's high load, but I'm not sure it would even be worth it. The entire duration of that spike is ~3 minutes.
I don't get why Rails did this (and glad Phoenix didn't). The "correct" `PATCH` syntax adds little to no value to a large majority of applications. If a user did send two "change email" changes in such a short timeframe to cause a race condition, it wouldn't really matter which one won. Additionally, making the client format the data differently between POST/PUT and PATCH is an unnecessary workload to put on the client using the API.
This would be a great usecase for [Erlang on Xen](http://erlangonxen.org/).
You sort of got it. Basically, on chat message our API partitions and sends push requests to our three push servers. The push servers receive them over tcp through a custom cowboy protocol. The push servers then buffer those requests as messages that might be potentially sent. If the messages should be sent (e.g. they haven't seen them on the desktop, etc.), the push server releases the push requests to the GenStage system described in the article. This is all on the same box as separate Erlang processes. A bit more is going on, but that's the gist of it.
Awesome! However... &gt; I'm looking for project ideas that while useful, would serve to introduce me to what makes Elixir powerful in the real world. Any ideas about what I can do in this to-do application that would make that happen? I mean, otherwise, I'm just using Elixir and Phoenix like Ruby on Rails and Jango and Symfony and countless other frameworks I'm familiar with, as opposed to exploring what makes Elixir and Phoenix different than PHP/Ruby/Python/etc and their frameworks. I am assuming that any object-oriented language I know, paired with their best or most popular framework, can do crud. However, there are things that only Elixir (or maybe other functional languages as well) are best at in the context of a web application or API. Of course, these are assumptions and I stand to be corrected.
Ah. I see what you mean now. I guess my problem is that I have no idea how distributed systems are typically built from the inside out, so I'm looking for an explicit feature that would make it required to have a distributed functionality in the application. In other words, I don't understand why a to-do application (where you can just add/edit/remove/delete tasks) would be distributed. I know you can think of a million reasons, but I'm essentially asking you guys who have much more experience with this to give me one of those reasons so that I can go and try to implement it. One of those features that, when implemented, would make you have a reason to deviate from the usual CRUD mindset that to-do applications usually come with. Does that make sense?
As I see it, `Enum.reduce(push_requests, state, &amp;do_send/2)` will open `length(push_requests)` connections simultaneously. Is there any way of compressing that into a single bulk request (or at least chunk it into groups of 10/25 or 50)? We found that to be even faster / less draining when it comes to throughput. One of the use cases here is comparable to persisting metrics to an ElasticSearch cluster.
The Pusher is passed `fcm_conn_pid` in its initializer and stores it in its process state, and `do_send/2` uses that connection for each notification push, so it's still only one connection. And it looks like the connection responses are handled asynchronously, with `handle_response` popping it off the `pending_requests` when the response comes in, so there's no IO bottleneck there.
Yeah agreed, bulk uploads would be the way to go, but the API you're interfacing with has to support it. I'm guessing that since Google's Firebase messaging is built on XMPP â a messaging protocol â that one message == one push.
Any processing pipeline or API consuming tool (since that's what you'll probably use Elixir for). Say downloading a bunch of text files and doing some map-reduce style work on them like parsing information from them and compiling it for some stats or something.
Add distributed systems then! Create another application that manages scheduled maintenance jobs against todo. Cron App lets ToDo App know when to * Send email reminders to complete tasks * Move stagnant tasks to a higher priority * Start different maintenance tasks. Create another application to manage notifications and emails to users. 
The docker images are based off ubuntu. Alpine is briefly mentioned in the article. Also saying switch from ruby to elixir if you want a smaller docker image, is more than a trivial task for step 4. Make your docker deployment fast by rewriting your whole application in a new language.
Maybe about 75% of the backend services are written in Elixir. I don't think there's really a trend yet. Our last service that we introduced into production was written in go. The one before that was written in Elixir. There is some talk of re-writing one particular service from Elixir into something that might be more performant for the service's task.
I put the precompile as one of the last steps, after anything bundle related. Anytime the Gemfile.lock changes and there are changes to the gems, all of the gems are treated as a changeset and are large. So I could get away with ~30MB changesets for many deploys, but as soon as I change the gems, that is a separate changeset that is bulky. You have to consider that docker files are processed top to bottom. If something near the top changes, everything below will be considered to have changed. Keep anything that changes most frequently as close to the bottom as possible. That will significantly change the changeset sizes for deploys.
Maybe you should be addressing the problem from the fault-tolerance perspective or reliability if you want. You'll need at least two computers, right? I guess a Ruby or a Java application would have two separate monolithic applications, glued together with nginx and sticky sessions. Or whatever. It's wrong :) Imagine a shared TODO list from two entities. One (a process) of them starts building a note, invites the other one and sends him an message (GenServer cast). But you made a REST call towards server 1, and I did towards server 2. How are we going to communicate? If we have a beam cluster, we can send each other messages informing us of changes to the note. PS (Maybe a note is also a process with many children processes (one of them could be GenEvent and each entity working on that note could subscribe to changes and get notified). You just wrote a distributed system. You don't care where those processes live.
I will try to answer but please don't take it as an authoritative answer from the .NET side. I have no practical experience with TPL besides reading about it in all sorts of places. When it comes to schedulers, load balancing, thread pools from TPL, you don't have any of those concerns in Elixir (for better or worse). We spawn processes and the VM knows how to schedule them, perform work stealing, etc. While Elixir also provides low level primitives for process communication, we also provide high level ones, such as the Task module (which actually has its name inspired from .NET/TPL). The Task module in Elixir provides conveniences for async computations, functions to check for task termination, helpers to manage collections of tasks, etc. You can read more about it [in its docs](elixir-lang.org/docs/master/elixir/Task.html). Regarding TPL's Dataflow and GenStage/Flow, there are similarities as well but the two main differences are in how different stages communicate and how they implement back-pressure. As far as I know, in Dataflow communication is done with blocks, such as a shared buffer, and in GenStage it is done by exchanging messages between stages. As consequence, when it comes to back-pressure, Dataflow will block the producers if the buffer is full. On the other hand, a producer in GenStage is not meant to send data unless the consumer explicitly asks for it. A shared buffer is useful because it requires less data copying. The latter is useful when interacting with external sources so you know exactly how much data to ask for. I am pretty sure you can emulate one pattern from the other. For example, a Dataflow producer could ask an external source only the amount of items that fits the buffer. It is also possible to write a GenStage producer that blocks when the consumer has not asked for anything. If I would attempt a TL;DR, I would say they are quite similar although they focus on the strengths and primitives of their respective platforms. 
I'm not very familiar with DataFlow, but another area of .NET that has some similarities is Reactive Extensions, or Rx. It allows for generic streams to be manipulated using LINQ in a push-based model (where the push is happening on the IObserver&lt;T&gt; side), and the receiver side (IObservable&lt;T&gt;) can apply back-pressure if necessary, for example with the Buffer operator. But with GenStage/Flow you are handling back-pressure by asking for data when you're ready, so it's a pull-based approach instead of a push-based approach. There is another thing in .NET Rx 3.0 called IAsyncEnumerable&lt;T&gt; (it was previously in a different package called Interactive Extensions, or Ix, but it's now part of Rx 3.x). IAsyncEnumerable&lt;T&gt; allows for asynchronous pull-based streams, like GenStage/Flow do. Other than that, the interesting thing about both Rx and GenStage/Flow is how they are both composable. In Rx you may create an observable and filter it, transform it, skip over certain elements, repeat the stream, combine streams in various ways, etc. Elixir Flow seems to do those types of things as well. Then Rx also lets you deal with threading so that you can observe-on or subscribe-on particular threads. While Flow lets us do some things across different Erlang processes (like map-reduce), it doesn't really make sense to try to have specific control over which process is handling a task the way it makes sense in C#/F# with a thread. --- Edit (and shameless plug): If anyone is interested, this is still a work-in-progress but I've been writing an Rx-based channel client for Phoenix projects. https://github.com/bratsche/kastchei
Oh, good call on bringing up Rx. If you go back to the early Elixir talks, before GenStage, our first inspiration was exactly something like Rx. We had Enum (eager), we had Stream (lazy) and the next obvious step was asynchrony. The "trouble" with asynchrony in Elixir is that you need processes and when you add processes, you already start venturing it concurrency, supervision and parallelism. So at the end we skipped the whole asynchrony API and jumped straight into GenStage/Flow. 
&gt; Oh, good call on bringing up Rx. If you go back to the early Elixir talks, before GenStage, our first inspiration was exactly something like Rx. I thought about trying to put together a talk on Rx and GenStage/Flow for Lonestar Elixir Conf, but I don't feel expert enough in either yet and I didn't expect to have time. But maybe for a future Elixir Conf I'll try this, because there are obviously some interesting parallels here. &gt; The "trouble" with asynchrony in Elixir is that you need processes and when you add processes, you already start venturing it concurrency, supervision and parallelism. So at the end we skipped the whole asynchrony API and jumped straight into GenStage/Flow. The way I kind of think of it (and please correct me if I'm wrong), in Elixir your processes already "know" what code to run because you've given it to them when you spawned. You can spawn a process to run any function, but you don't take a PID and say, "Run this function on this process". And that's a lot of what we're doing with Rx concurrency, in my experience. For example, I might have some observable that represents messages arriving from my Phoenix channel and they may be arriving on any particular thread in my threadpool, at this point I don't care which one, but when I subscribe to the messages (which is like the Rx equivalent of a callback event) then I might explicitly need to subscribe on the UI thread so I can update the UI. channel.Join() .MatchOn&lt;ChatMessage&gt;("ok") .SubscribeOn(RxApp.MainThreadScheduler) .Subscribe(x =&gt; UpdateChatView(x));
I've never used Rails in anger, but I have used Django professionally for many years. What is interesting about the json benchmark is: they both scale relatively linearly as the cores increase except that Phoenix shows no improvement from 64 to 128 cores then does show the improvement you'd expect at 256 while Django stops linear increases at 64 to 128 and regresses from 128 to 256. Rails gets effectively zero improvement from 8-256 on any platform. Now - that's not strictly a property of Django because it runs in a wsgi container that it going to be handling the actual connections but it might indicate Python has better config or gunicorn is better. you can see that the python is fiddling with its concurrency settings in the setup(and disabling the access log): workers = multiprocessing.cpu_count() * 3 the Django benchmark also uses ujson to do the serialization, which is not the default Django or the Python stdlib serializer, but "an ultra-fast JSON encoder and decoder written in C with Python bindings" (which I think is fine -- good for Python for having such libraries available, but I don't know how compatible it is with Django's built in JSON serializer and I suspect most Django projects don't swap out the json serializer (nor return hard-coded dicts) Django latency is 4x worse on average the variance is massive (phoenix goes in a range from 1.4-19ms in best to worst, compare to Django 18-700ms spread in best to worst). Rails is off the charts bad. I didn't look at the multiple-query ones but Python has high quality drivers for mysql and postgres implemented in C which probably helps.
Jose thanks for all the work, you're truly a leader in this community.
Or use schema-less queries: http://blog.plataformatec.com.br/2016/05/ectos-insert_all-and-schemaless-queries/
Got the same idea some time ago but I did it using electron :D https://github.com/Grafikart/SubtitleMe
It would be fun to use OTP to find subtitles for an entire season concurrently :) I'm a bit curious, is subscene giving you better results than OpenSubtitles API ? (Discovered Floki thanks to your code :))
I use Ecto a lot with raw sql queries for complicated stuff (sometimes the Ecto query syntax just gets in the way), works great.
I was thinking "concurrency would be really neat" as well! 
Ah, fair enough. Thanks for the explanation! I guess they don't want Elixir to automatically mean Phoenix, as what (generally) happened with Ruby.
How would you recover and retry particular documents in a failure scenario? I'd imagine with hundreds of thousands of documents needed to be downloaded via S3, there will be a handful of errors along the way. Heck, HTTP request errors alone would likely be in the dozens. The pipeline you've constructed seems pretty ideal. How would a particular `download` step, for instance, log errors and retry itself? 
If you're intrigued by Elm and Phoenix playing nicely, maybe check out our Kickstarter to build an open-source Phoenix+Elm-based forum system - http://firestormforum.org :D
I don't see the Elixir.
Awesome! Yeah, it's not in the README.
Have you thought about using SQL itself?
Love reading your posts. Loved reading your book. Sad I don't have the opportunity to work in Elixir professionally anymore. Two out of three ain't bad. ð
You probably shouldn't be using any sort of seeding data on a server. That being said you could probably do mix run on your seeds.exs file but with an environment variable for prod for instance or just change your config to match the database on your server.
So far it's working for me. I did this for CircleCI. I [opened an issue](https://github.com/jeremyjh/dialyxir/issues/60#issuecomment-268266712), and it looks like he's going to add it back as a command line switch, which should work for your case, as well. 
Thanks for the links, I will look into them.
awesome! shows what I know!
A web app for cyclists (riders and their clubs) who use Strava. Used to host informal [Strava segment challenges](https://segmentchallenge.com/) between club members. It's built in Elixir following a CQRS/ES architecture using a few of my own libraries ([commanded](https://hex.pm/packages/commanded) and [eventstore](https://hex.pm/packages/eventstore)). With Phoenix for the web front-end. I also built some of the input forms using Elm. 
I really like this series. Keep it up!
But other way is not possible unless to add certain keys specific to struct. All structs are maps but they have a key called _struct_. You have to take care of that if you want to match struct = map
I'm building a CI service measuring the quality of packages of various platforms (hex, rubygems, clojars, ..) based on a set of rules. Using Phoenix.
in my own time: just built an websocket-y backend for a [codenames clone](https://codenamed.herokuapp.com/public/clues) with phoenix. My first time playing with phoenix's websockets interface, and i have nothing but good things to say. It is so much simpler *and* so much more robust than similar experiences in node, ruby, and go. at work: in the planning stages for an elixir service writing and reading data to dynamoDB. We've written a few smaller projects at elixir, but nothing at scale -- and I'm super excited to see how elixir is going to handle 15-20 million events/day. 
cool! I write a fair amount of elm for work, happy to provide code review / advice!
Great contents as always Sasa. I really agree with the concluding point about the confidence we can have when working with Elixir, and Elixir making sense as a control plane. I've never refactored as confidently as I do in beamland. The other day I wrote a significant extension in Rust, and moved it from a NIF to a Port because it fit the problem better -- I have a hard time thinking of software I wouldn't like to write in Elixir, if it comes right down to it. And like the other commenter: thanks for EIA. The chapter on 'isolating error effects' (or something like that) is the chapter I tell experienced engineers to start on.
Nice work. Thanks for sharing. I'm sure this will helpful to some people as live video is becoming more and more popular. 
Hey, thanks for the feedback, and very happy to hear you liked the book :-) I absolutely agree that Elixir &amp; Erlang (coupled with Phoenix where needed) are a great fit for any kind of a backend system, regardless of problem domain, scale, or complexity. For such problems, the question is not "Why Elixir", but "Why not Elixir". I would need some very strong reasons to choose something else. For everything else (e.g. CLI tools or desktop apps), Elixir/Erlang might not be the best fit, and I'd likely consider something else.
You can do it a couple ways. As you suggested, load comments through the controller and template. Then handle creating comments and new comments via the channel. Also you could load empty list in the controller, then when the front end opens/joins the channel you could send some initial state. Either in the join or sending an :after_join message that sends state to the front end. 
I'm working on finding a job for the new year that will enable me to write more elixir - it's proving difficult!
I'm building a discord bot with elixir. 
Thanks for the reply. Is there a community standard yet? 
I don't think there is or will be. Both have benefits. I think loading the empty list and then handling everything via channels/JS is probably more common. It keeps your view logic/templates all in one place which is nice. It also means more front end/JS which I don't like as much, but it has its benefits for sure. Is there something in particular you are trying to achieve or worried about? 
Ok, either way is fine really. I've done both. I think I prefer to handle everything via Channel/JS. The issue otherwise is that I load stuff on the controller, then create a template and render the models. Then I have to sort of copy that template in the JS for appending new items. You also have to be careful of race conditions. For example: 1. User 1 requests page (load last 10 items, and render page) 2. Send response to User 3. User 2 adds a post (Post 11 is created) 4. Post 11 is broadcast to all users on channel (only User 2) 5. User 1 loads response, and runs JS, and connects to socket. 6. User 2 adds another post (Post 12 is created) 7. Post 12 is broadcast to all users on channel (User 1 and User 2) You can see that User 1 will not get Post 11. Maybe it's not an issue really here, and won't cause any issues, but what if a user replies to Post 11, and User 1 get's that reply, it could cause some issues. Anyway, it's just one of the other reasons why I find doing the Controller/Template -&gt; Response -&gt; Connect to Socket -&gt; Live Updates method to be more tricky than Empty Response -&gt; Connect to Socket -&gt; Load State -&gt; Live Updates method.
Hrm ok then. Guess that's two experienced BEAM devs against and none for, so I guess it's time for another big refactor. Thanks, I appreciate the input.
[removed]
Out of interest, why Sugar? Is it updated?
Because I happen to like it better than Phoenix, and generally always have. Phoenix has a lot more bells and whistles, but it's also big. Sugar is roughly to Phoenix as Sinatra (or maybe Padrino) is to Rails, and that stoked my interest in helping to improve and maintain some healthy competition in the world of Elixir web frameworks. Having observed the Ruby community's unhealthy dependence on Rails, the idea of hopefully working to prevent that sort of thing in the Elixir community was rather appealing and continues to be. "Updated" depends on perspective. It's by no means as active as Phoenix (seeing as how it's much smaller than Phoenix, both in terms of userbase and in the sense that I'm only one of two or three people with commit and Hex access). It still works perfectly fine with modern Elixir versions, though, and development - while slow - is still chugging along.
Thanks for the reply. :) I did not mean to imply anything bad about Sugar, I have just never tried it myself.
I'm building a SaaS application with Elixir, and in the process, I submitted my first package to hex: https://hex.pm/packages/ex_clearbit . It's a long way from perfect, but I'm glad I finally got something out there.
&gt; there's only so much free time Ain't that the truth :)
typo? "looking for looking for"
Fixed, thanks!
To be a bit more fair to Phoenix, I'd say: Sugar is Sinatra, Phoenix is Merb without the takeover. I will agree that Phoenix' support for traditional web framework concerns is less interesting: boilerplate for database-backed models, boilerplate for frontend, boilerplate for plug/routing, etc. But really, it's apples to oranges, because most of the value prop in Phoenix is in features that are multi-node: 1. Not phoenix, but its beautiful child, `phoenix_pubsub`, for scalable pubsub (as opposed to 'that bottlenecked pg2 abomination we hand-rolled') with the added wonderful bonus of Phoenix.Tracker now for CRDTs. 2. Phoenix, for Channels (with many transports, including efficient ones for mobile) and Presence (a user-centered Phoenix.Tracker). So I use Phoenix for (1), but then it almost always makes sense for me to add (2) when it comes time to expose the otp app.
"Who out here is buying books to learn programming?" "No loops what the fuck is a fold yo" "You aint building the next whatsapp or netflix, you don't need to learn this bullshit" Hahahaha, this is just hilarious.
TL;DR this author is extremely biased and doesn't explain all his points very well and if he better explained his thoughts this might of been a better watch. It was really hard to watch mostly because of his attitude and the way he chose to speak and form his sentences. He prepared slides, but didn't do much else as far as preparation or editing. Besides that. Most of his points were missing a big "why". He mentions the language doesn't have OO nor classical for loops, but he doesn't mention why that's a bad thing. He mentions that the language is different "what is a fold?", but doesn't say why the different syntax is bad. Yet he praises ruby, which has a very different syntax even though it has traditional OO and for loops. I wish he actually mentioned why these things are bad so we could better understand why he's publishing these opinions, but until he does clarify the why then it remains just an opinion and almost nothing of this videos actually contains any factual information. The charts he presented were interesting. Erlang has been around forever and hasn't been super popular, but jobs do exist and honestly I feel like good Erlang developers are a lot more knowledgeable than the equivalent JS developers just due to the difference in paradigms . Elixir recently passed Erlang in terms of search results, but that could be because Erlang supports really good local documentation with their standard distribution (why would you really need to do google searches?). Comparing Erlang/Elixir to JS isn't really fair either since JS is (basically) a necessity to learn these days and no one really knows how to use it thus you'll end up Googling how to do everything. 
Haha! Really funny :) But I didn't get points about Phoenix and Elm!
mh... He never says at any point that he's being satirical - why shouldn't we take him seriously? Maybe I missed it - but I do think he's serious... which is probably equally funny. If I did miss it feel free to throw a phonebook at me and point it out :P
Like I said (or intended to say, perhaps), Phoenix does indeed have a lot of bells and whistles. It has a big scope in terms of being an all-inclusive platform, and there's definitely a place for that in the Elixir world. That doesn't make the idea of a "One True Framework" any less alarming, though. Things like `Phoenix.PubSub` could and should be their own standalone projects existing on their own merit; there's nothing inherently "Phoenixy" about wrapping `pg2` intelligently, so why keep `PubSub` in the `Phoenix` namespace? I guess I'm probably just bikeshedding over nothing. Thankfully, the realm of Elixir web development seems to be centered around Plug in general rather than around Phoenix specifically; as long as that remains the case, there will always be room for some friendly coexistence, cooperation, and perhaps even competition. :)
I don't think this is satire. The day before he posted this video: https://www.youtube.com/watch?v=w4xnqqfS2tc
Seems the like count and comments have been disabled on both the old and new videos. The comments were pretty bad on the previous one.
I would expect that considering how misinformed the videos are. 
Describing highly technical points on why he is so against those points may require some kind of intelligence he doesn't have, that's why I said that and that's how he transmit his message in video. That doesn't mean his whole self! I think you went a little overboard implying that, since you don't know "jack shit" about my whole self. ;) That doesn't mean that I disagree with what he is saying tho ;)
is this the "It's not worf it" guy?
Good on you, OP. I'm happy every time I hear about someone not needing Redis because their platform has a whole big thing of ways to store data already.
Check the :ets module. It's a nice way to hold state as well. It (an :ets table) cannot act as a worker though; It's not an actor like the GenServer.
Thanks, I tried that out initially for a project but for my use case `:queue` makes more sense.
Also, "Don't waste your time with elixir ... Mess around with C#; C# is cool."
That is my end goal, is that open source? Are you using a library or writing your own? Would appreciate a repo link if you have it
It looks like the site is down. Here is a [cached copy](http://webcache.googleusercontent.com/search?q=cache:http://theerlangelist.com/article/reducing_maximum_latency)
I don't need any of those features for my use-case and only used Redis as a glorified queue.
`__after_compile__/2` runs after elixir has compiled the AST into BEAM bytecode, so it doesn't care about the return value of that function, the module has already been finalized. Have you tried `@before_compile` and `__before_compile__/1`? Can you give us a bit more of a high-level idea of what you're trying to do? There might be another way to go about it.
Neither did he
Here's what I was thinking (I chopped out some bits for brevity): defmodule BasicElements do defmacro __using__(_env) do quote do import unquote(__MODULE__) @before_compile unquote(__MODULE__) Module.register_attribute(__MODULE__, :scenes, accumulate: true) end end defmacro __before_compile__(_env) do quote do def scenes, do: @scenes end end defmacro scene(title, _description, do: _block) do quote do @scenes unquote(title) end end end defmodule GameMacros do use BasicElements scene ASimpleScene, "There's nothing here", do: nil scene AnotherScene, "There's something here", do: nil scene YetAnotherScene, "There's also something here", do: nil end GameMacros.scenes |&gt; Enum.reverse |&gt; IO.inspect # =&gt; [ASimpleScene, AnotherScene, YetAnotherScene]
A few quick notes since I've been working with `arc` a lot recently: 1. You can easily connect arc with an Ecto model if you want to, for instance, allow users to upload a photo and store a `Photo` object in the database. [arc_ecto](https://github.com/stavro/arc_ecto) is a great library by the same author. 2. For testing locally, you should try running https://github.com/jubos/fake-s3. This way you can test without pushing images to AWS. 2. If you decide to do thumb-nailing, be weary of using ImageMagick (the default conversion for `arc`). ImageMagick is pretty greedy and a small number of simultaneous uploads can easily take down your server. You may want to use a service like [Thumbor](https://github.com/thumbor/thumbor) instead.
If you want to upload directly from the browser or app, you can create a single-use upload URL on the server and provide it to the client to perform the upload on their end. This is cool because it's generally faster and requires less bandwidth on the server side. Here's an implementation I came up with: https://gist.github.com/johnhamelink/a3ff4bff68f04900da11947cb54d94fd
TIL thanks for the insight.
Same here.
Travis
I'm using Travis for my Elixir problems at work and home and I'm pretty happy with it overall.
Gitlab CI is so good, I used to use Jenkins on a personal linux box but now I just do everything in gitlab.
CouchDB exposes a REST interface. Libraries for interacting with CouchDB are simply RESTful clients tuned to the abstractions of that specific interface. Some of the libraries (I haven't looked) may use a lower level and better performing protocol, instead of HTTP, which may be a worthwhile consideration.
We've been using Semaphore and it's pretty good
That's what I was thinking. So the verdict is I don't really need a dedicated client for CouchDB unless I want to use some lower level transport than HTTP?
Are you in Berlin?
Ja!
Well, if things aren't *working*, that's definitely a problem.
I assumed the HTTP API was the only way, but then [this](https://wiki.apache.org/couchdb/Related_Projects#Clients) claimed that Couchbeam uses Erlang messages, instead of HTTP, as its transport. But that doesn't look like it's true judging by the bits of the Couchbeam source I've looked at. So I'm confused to say the least.
[removed]
-migrations -Environment management (dev, prod, etc) -not writing your own sql injection prevention code
&gt; moebius That does look really nice! 
It would be more convenient to use the same thing for migrations but you do have a point in that I can use third party migrations including ones from ruby. 
&gt;I suppose you can still use Postgrex if you want. If I were a developer and I joined a project with a bunch of raw SQL instead of Ecto queries without a clear good reason, I'd be really annoyed. I don't know. I like SQL and I think it's more expressive, concise and easier to understand than a lot of the DSLs people try to wrap around it. 
I've made, and am iterating on, [a spy library](https://github.com/Gwash3189/spyanator). It adheres to the idea of _mocks as a noun_. Learned a lot and happy to receive critiques. 
I really recommend giving Ecto a try. It might not be what you're used to, but it has benefits all it's own, and doesn't tend to have the constraints that most ORMs and DSLs have.
Changesets are super nice. 
I went back through the Phoenix API I'm currently working on to find some things that I find Ecto particularly useful for. These may be a bit random, but it gives you an idea of some real world use. ### Encrypted Fields There is some data that I store in an encrypted format (3rd party API tokens I use on behalf of a user). Rather than cluttering up my code with encryption/decryption calls, I can create a custom [`EncryptedField` type](https://gist.github.com/jclem/b8e0547cfed23413856b0ce3a4f618ae), and use it in a schema: defmodule API.GitHubToken do use API.Web, :model schema "github_tokens" do field :token, API.EncryptedField end end Now, the `token` value of that struct will be transparently encrypted/decrypted for me. ### Embedded Records I represent documents in my API which have many blocks, representing lines of text and media objects inserted by a user. I don't want a separate blocks table, but I do want them individually validated. My document schema looks like this: schema "documents" do embeds_many :blocks, API.Block, on_replace: :delete end So that when a user posts a document with a "blocks" attribute, I can validate each block and assign a UUID by using `cast_embed/2`: def changeset(struct, params \\ %{}) do struct |&gt; cast(params, []) |&gt; cast_embed(:blocks) end My `API.Block` has its own validations that are called. In fact, blocks can contain more blocks inside of them, so they have their own `cast_embed(:blocks)` in their `changeset/2` function. Ecto properly recurses when casting new blocks to persist to the database and when loading existing ones in a query result. ### Composable Queries I was part way through writing an example, but [this post](https://blog.drewolson.org/composable-queries-ecto/) covers it better. ### Functional Style, Readability In general, I also find the paradigm shift from functional to declarative programming to be frustrating, at least now that I'm very comfortable with Ecto. I could technically do this with string concatenation, I guess, but I'd much rather write and read a module that reads as well as this does: defmodule DocumentService do def published(query) do query |&gt; where(published: true) end def unpublished(query) do query |&gt; where(published: false) end def filter(query, filter) do filter |&gt; Enum.reduce(query, &amp;do_filter/2) end defp do_filter({"author_id", author_id}, query) do query |&gt; where(author_id: ^author_id) end defp do_filter({"tagged_with", tag}, query) do query |&gt; where([d], ^tag in d.tags) end defp do_filter(_, query), do: query end
&gt; execute ("select * from blah where x=$1",'blah ) I'd say this looks a lot nicer: from Blah as b, where: x == ^blah It uses prepared statements under the hood, but it looks as nice as the injection-vulnerable version. It gets really good with long queries like this: from Blah as b, where: a == ^a and b == ^b and c == ^c and d == ^d vs execute("select * from blah where a=$1 and b=$2 and c=$3 and d=$4", a, b, c, d) 
The GenServer is serialising access to the cache - basically reducing this app to single-threaded performance. Moving the ETS lookup to the client API side of the cache module should remove the bottleneck for the common case of a cache hit, only waiting on the result of a GenServer call to update the cache on a miss.
I'll give it a try but I use some advanced postgres things like this DO LANGUAGE plpgsql $$ DECLARE counter INTEGER = 1; BEGIN WHILE counter &gt; 0 LOOP SELECT INTO counter some_batch_function(); END LOOP; END$$; or this SELECT COUNT(*) FROM DBLINK(connection_str, some_query) AS t(id INTEGER) INTO row_count; 
You're never starting the Registry. The supervisor learns about children using what is returned by the `init/1` function. Calling `supervise` in the middle of the function without returning its result is useless. You should merge the `story_module.scenes` workers with the `Registey` supervisor into one list and call `supervise` once at the end of the function. edit: I should note that the Registry should be the first item in the list since it will need to be started before the workers.
[removed]
He seemed to be confused that Elixir and Elm are two separate languages. Not sure he was being satirical since his points were basically summed up by "I don't like it", without any reason as to why.
They _should_ be workers though. You're just applying the naming in the wrong place.
Ah ha! I get it. Thank you. 
Under "Why Elixir", Goliath links to analytics and ChicagoBoss links to Goliath, fyi
TL;DR - if you don't want to use Ecto, just use Postgrex and you should be fine. You don't *need* Ecto. Everything Ecto does could be done with Postgrex (the adapter for Postgres). For example, Postgrex ships with connection pooling out of the box, you just need to add a pool such as poolboy or sbroker as dependency and configure Postgrex to use it. And while Postgrex doesn't provide migrations out of the box but you can likely build a tool in a hundred lines of code or less. Some misconceptions about Ecto worth clarifying though: 1. As others have said: Ecto is not an ORM per-se but it does provide the "relational mapping" features. 2. While I am personally OK with writing SELECTs by hand, it can be tedious to write INSERTs and UPDATEs depending on the data. For example, you may want to generate different INSERT commands depending on the amount of data sent through the form. If you are handling HTML forms, you need to be able to cast the string "13" into the number 13. Changesets take care of casting, filtering and validating data. Even if you want to write the INSERT queries by hand, you can still use changesets to do the casting work for you, and then extract the changes out so you manually insert them to the database. 3. Speaking about validation, you said "I am in general dubious about validating in the middle tier". And you are absolutely correct. Ecto promotes validations being added at the database and make it relatively straight-forward to convert those into user-facing errors. I covered those topics in the Ecto 2.0 ebook, so those interested can find more information there (or just ask): http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0
FWIW, I hate the `:simple_one_for_one` supervisor and it leads to a lot of confusion. We plan to include DynamicSupervisor in Elixir v1.5 which works exactly as `:simple_one_for_one` except the name is more obvious. :)
I was working on that and just fixed it. Sorry about that.
So if I use Ecto how much overhead does it add to my app? 
Lambda can have undetermined latency which can be an issue if it's processing user requests as opposed to background tasks. Elixir will be very responsive at any scale but requires you maintain the virtual servers it runs on. Lambda still requires you write the function code but that is JS so you may want to try using Lambda first and if that doesn't suit your system you can look at migrating critical functions to Elixir. 
Link from docs to bitbucket repo is 404: https://bitbucket.org/idahogray/Modbus-Elixir Looks like bitbucket URLs are case sensitive?
We are using Jenkins to do CI, However the build happens inside a simple docker container. We have a custom image which incudes elixir/hex/rebar and node.js at https://hub.docker.com/r/minhajuddin/elixir_nodejs/
I don't think it is pedantic. There is big enough distinction between a class and module to justify correcting the usage.
Not only is it not pedantic, it's important. If you don't clarify something as fundamental as the fact that there is no notion of classes in Erlang and Elixir, a lot of people coming from Ruby (or other OO languages) will spend much longer being confused before getting the hang of FP.
Is it necessary to give non password sudo access for the user running gatling? Doesn't feel very safe.
I was wondering if there a way to work around it, but i guess not. Anyway, thank you for the article. I will definitely try out gatling for deployment of my first phoenix project.
Do you have your source code someplace so we can do a comparison?
this is really helpful insight, thank you. I have noticed Lambda's list of 'gotchas', even outside of its latency, is as about as long as its list of features--e.g., using Python's `scipy`/`numpy` required compiling everything on an Amazon Linux EC2. I don't have users yet &amp; have no exp. w/ servers under load, but 100 seems like a pretty low limit. I have to admit, though, that the no-server thing is a big draw for me--but this is mainly b/c i have no experience maintaining a server. Given your experience, **can you opine on the maintenance overhead (in terms of hours and ulcers) of a small-medium elixir server vs. the time spent w/ the config spaghetti that comes w/ AWS Lambda?** I do use the Serverless project that you mentioned, and it's a blessing, but with super low-overhead projects like [Zeit's Now](https://zeit.co/now) (which can run Dockers w/ a single command, &amp; it looks like [a dockerized elixir server is a fine approach](https://www.reddit.com/r/elixir/comments/4e64lz/what_are_relixir_s_recommendations_on_integrating/)), Lambda still feels a lot slower to up-and-running. I set up a Kubernetes cluster last month &amp; felt like it was easier to sort-out than Lambda sometimes feels. 
ah unfortunately no--in generally though the backend stuff is pretty straightforward. most of my server needs are handled by my backend-as-a-service (email, auth, database read/write, etc.). Most of my back end needs fall into a few categories: * interacting with APIs not suitable for client-side code (ie, to hide api keys, etc.) * stuff that's too computationally intensive to put client side for fear of hurting ux--eg some functions w/ larger arrays that might take too long on older client hardware/mobile * image manipulations--[perceptual hashing](https://github.com/JohannesBuchner/imagehash) stuff mostly 
How do you set up staging and dev environments?
Fixed, thanks!
By and large, the answer is "you don't". If you need persistence guarantees for you data, use a method that keeps things written to disk. No in-memory store is going to be resilient to server restarts - if you need that, you need to write to disk. The reason people keep talking about holding state in OTP processes is that OTP/the BEAM are very good at keeping processes running and isolating faults - if you design things right, your server will likely crash a lot less than if you tried similar things in other languages. That said, if you need guaranteed persistence, use a database - nobody is ever going to recommend keeping your Users table in an OTP process.
[removed]
With a bit of configuration, it should be possible to write backend agnostic client APIs and publish them to hex, without forcing a particular backend on the user?
Yeah, will be interesting to see how things play out.
&gt; I don't see that comment in the repo any more, was it removed? It must have been. After rok3 posted this I looked and I also saw that comment, but now I don't see it. However I can still find the commit: https://github.com/zhongwencool/maxwell/commit/f7ff0637e3d1a454f05664f7415f0210b2ace07d But that's no longer in the commit history of the master branch (and there are no other branches) so I guess the author force-pushed to the repo to undo it.
A case study describing how I built a web app following a Command Query Responsibility Segregation and event sourcing (CQRS/ES) pattern. In Elixir using the Phoenix Framework. It uses two open-source Elixir libraries I've authored to provide the building blocks for such applications: - [EventStore](https://github.com/slashdotdash/eventstore) - A CQRS event store that uses PostgreSQL (v9.5 or later) as the underlying storage engine. - [Commanded](https://github.com/slashdotdash/commanded) - Provides support for command registration and dispatch; hosting and delegation to aggregate roots; event handling; and long running process managers. It's an unorthodox approach to building Phoenix web apps. The article details why you might consider applying it.
I'm new to Elixir but am writing a Web app for a client that I may end up taking over full time using elixir and phoenix. I'm also writing a mix task to create ecto models from existing databases. I know there is at least one project that does it but I feel like it is a good learning experience 
Possibly silly question, since you built and maintain the ruby library for CQRS also, are they compatible? and, could/would this be a good way to have a hybrid ruby/phoenix system, where each issues commands this way, without knowledge or concern of which language is currently handling them? I've been debating ways to gradually transition a monolith rails app towards phoenix, and just curious if this is a candidate to experiment with/if you have any thoughts on the suitability.
Hooray! Really looking forward to swapping in the Registry where I was previously using Syn. Also, here's to hoping Phoenix 1.3 is hot on the heels of this release. I expect Phoenix PubSub will also be leveraging the Registry.
No, the Ruby and Elixir libraries are not compatible. However, commands and events are a good way of integrating systems. Assuming you can use a compatible serialization format (e.g. JSON) for both systems. Then you can integrate by exchanging these messages. The Ruby system could send commands to the Phoenix app. To be notified of state changes it subscribes to the domain events published by the Elixir app. 
`faraday` _shudders_ Main problem of these "meta HTTP" clients is that they have to nail the API perfectly. Faraday feels like the "lowest denominator library" for HTTP, and I feel icky using middlewares for what should be basic features (like cookie handling) - nowadays I mostly just use httpclient directly when in Ruby. Still useful for library authors like people suggested here, I guess. Avoids having a metric fuckton of HTTP clients on your lockfile.
Thanks so much for this guide. I have recently been going down the CQRS/Event Sourcing rabbit hole myself, so this is very well timed. How do you handle normal day to day stuff like commands throwing exceptions, retries/timeouts, and data migrations? Cheers, Ben 
Ohhhh ok, tricky! That's super helpful
&gt; commands throwing exceptions By preventing invalid commands from reaching the domain model as much as possible. Having a task-based UI ensures only relevant operations are shown to the user. Dispatched commands are validated by using a validation middleware before reaching the aggregate. Any validation errors are returned back to the client. Using an Elixir GenServer for each aggregate root instance means that access is serialised. Messages are sent to the process' mailbox and are processed serially, one by one. That helps with commands sent to the same aggregate concurrently. I also wrote a [command auditing middleware](https://github.com/slashdotdash/commanded-audit-middleware) that records every dispatched command to a database. It includes whether the command was successfully handled, or any error. I use that to monitor errors, timeouts, and execution duration. &gt; retries/timeouts OTP supervisors are used throughout, including for all event handlers. When a process dies, it gets restarted. For an event handler, it will resume receiving events from the last ack'd event. There's an open issue in the Commanded GitHub repo to improve the retrying. I want to allow configurable retry strategies to be used ([#20](https://github.com/slashdotdash/commanded/issues/20)). &gt; data migrations Migrating the write model containing production domain events is difficult. You really need to think carefully about the domain model before you build it. Try to get the events and their structure well defined. There's a research paper describing four potential strategies to migrate events: [The Dark Side of Event Sourcing - Managing Data Conversion](http://files.movereem.nl/2017saner-eventsourcing.pdf). For the read model, to make a change I can modify the database schema and/or the projector. Then I reset the affected projection's last seen event back to the origin. Once the updated projection is deployed and the app starts, the projector will receive every event from the beginning of time. It rebuilds its read model from scratch. Typically a projection writes to a single table. Hope that helps you out.
Been learning Elixir over the past week or two and this has been my "it's magic and I don't like magic" as it's added mental overhead for ease of brevity. It's a trade off I can understand but it does add complexity. Though it could be argued that in any language that allows you to import * everything has the same problem tracking stuff back to its origin. In Clojure (my go to) it's more standard to alias namespaces and I really like that for the most part Elixir user favor the same. It just seems like it could easily be abused. Is there a way in iex to list all functions in the module?
What do you mean by "touching `feature_state`"? Can you provide an example of a code that fails?
You can also do `IO.inspect &amp;assign/3` and that's going to print the full reference. Hopefully editors have support for that too.
This *is* the code that fails, or at least the majority of it. The top snippet is inside of a test, and it's the test that fails, like so: test "Checking a feature's state'" do defmodule Test do use Features feature :door, :N, "an exit to the north" do Features.setup do set_state(:state, :closed) end action :examine do state = get_state(:state) #I could also just try and reference var!(feature_state) directly #the error is the same case state do :closed -&gt; reply({:see, "It's closed."}) #this could set var!(action_reply) directly, and that also works :open -&gt; reply({:see, "It's open."}) end end end end state = Test.init_features(%{}) %{:state =&gt; :closed} = Map.get(state, {:features, :door, :N}) {:reply, {:see, "It's closed."}, next} = Test.handle_call({:door, :N, :examine}, self(), state) end But the failure is a compilation error- specifically, it's the expansion of the `get_state` macro that fails. It's interesting to note that the `init_features` call *also* interacts with the `var!(feature_state)`, and that one works fine. Actually, the obvious difference is that I'm *setting* the value in all the other versions, whereas I'm *getting* the value in `get_state`. Is that perhaps the root problem? Can you only *assign* to unhygenic variables?
Much appreciated. [Branch var_issue](https://github.com/RemyPorter/AlchemicalFiction/tree/var_issue) has the specific case. It should just run with a `mix test`. Specifically in [this file](https://github.com/RemyPorter/AlchemicalFiction/blob/var_issue/test/macro_test.exs), very last case.
Yes, you are correct. If using a module is defining functions, then those now belong to your module. The `use mod` is still lexical but if the defined function has no documentation or no information, then you do need to check the source. I believe in almost all cases such is done in Phoenix the defined functions are properly documented but I do agree that's not true for all projects.
You are unquoting the block twice. :) The first time it doesn't have the variable previously set: https://github.com/RemyPorter/AlchemicalFiction/blob/var_issue/lib/features.ex#L71
It would be a cool tooling idea to be able to follow the dependency tree of what's being brought in. Granted I've only been playing around for a week or two. BTW I really enjoyed myself. I'm a big Clojure guy and I doubted I'd be that impressed by any new languages but I've really enjoyed what you've built.
Jesus, when on Earth did *that* happen. Thank you. I knew I must have been doing something dumb, but I was hoping it was more creatively dumb than this.
Hm, I think you may be right. I guess I was misinterpreting "decentralized" as meaning it could be clustered together but with no single point of failure, and that by being "local" all the lookups/inserts/updates would stay local and not branch out to other nodes. I guess I don't understand what "decentralized" really means in this context. He claims &gt; Decentralized because there is no single entity responsible for managing the registry but isn't the Registry GenServer a single entity? I'm missing something here.
No, I haven't had any problems with Syn at all. In fact it works quite well. I was just aiming to remove a dependency, but /u/SulfurousAsh is right then I'll stick with Syn of course.
Well if it's an internal project and upgrading to 1.4 isn't too heavy an ops cost, it's not gonna hurt, especially if you're going to need to segregate local and global registration at some point, but if it ain't broke, don't fix it, I reckon. If it's a shared project on the other hand, switching is gonna be a breaking change for a lot of users who might be stuck on &lt; 1.4.
Not a bad idea, especially if you want to [create a mock for testing](http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/). I'm not familiar with syn's API, but if it happens to be the same as Registry, you could also inject the module you want to use as an argument, or set it as an env variable (all described in that excellent article linked above).
I see. Cool. The naming of the start_link function is what threw me off.
Off on a tangent here, but I have to agree with trying to avoid this (and a lot of the other meta-programming constructs in Elixir). Been trying to dig through some of the Phoenix source and other low-level Elixir libraries and it's really, really tough to follow at times. With response to OP though, I just dig through the various `__using__` functions until I find something that looks right. Not great but it doesn't usually take too much time
I would create a single event handler to push the relevant events to Elasticsearch for indexing. An "ElasticSearchIndexer" which handles each `PostCreated` event. It sends the text content of the post from the event to Elasticsearch. Handlers are configured to run inside an Elixir supervisor. They are started with the application and restart on error. You could also configure multiple instances of these event handlers. Then you distribute the blogs amongst the handlers (e.g. using a hash keyed on blog id). So have 10 handlers for 1,000 blogs; each handler will index articles from 100 blogs. Drop me an email (ben@10consulting.com) if you'd like to share ideas. I'd like to hear about the approach you're taking. I had a pull request submitted today on the Commanded project to add support for Greg Young's [event store](https://geteventstore.com). That should broaden the appeal of the library.
Thanks for the notice. It has provoked some interesting debate around using CQRS/ES.
It will be much simpler if you will normalize your data: [ %{ id: 1, text: "hello1", children: [1,2] },%{ id: 2, text: "hello2", children: [] },%{ id: 3, text: "hello3", children: [] } ] 
For a practical and quick and dirty solution use one editor of atom, emacs. They have elixir plugins that provide shortcuts for resolving function definitions. For example in my atom I use &lt;Alt&gt;+&lt;Down&gt; in a function to take me to it's definition. It doesn't have a 100% success rate and it fails particularly with macros. Still it helps a lot. I would also be interested in a more straightforward way of doing this but it seems there is not.
What are those children? IDs? Right now I have a ancestry of ID. So if a comment is a reply to Comment with ID 2, which was a reply to Comment with ID of 1, the comment 3 will have ancestry of "1.2."
[removed]
Kind of new to elixir and erlang but I've been using Ruby and Scala for a while so I found them easy but enlightening. So basically I am in the process of figuring out the design of a message broker that can be clustered. For data replication I am thinking a gossip protocol which I am worried about chattiness, Raft, RIAKS paxos lib, or riaks chord implementation. I kind of need advice on a better alternative to managing state I wrote something similar in scala/akka where I set up gen_server like actors per topic/queue, and then just used a fuck load of futures. Which I kind of view as a bottleneck.
Honestly I see a pretty similar trend with Elixir and Pheonix as Ruby with Rails despite not having much experience with it. Honestly IMO this is just because you have a bunch of ruby devs swarm over, and pheonix pretty much enables them to keep doing what they are doing. Like literally pheonix is as good as play in a dynamic language that feels rubyish but isn't. Which pisses me off because the vast majority of elixir devs aren't all that proficient in distributed systems. Even though you have all these great erlang projects to inspire you, you have better tools than people on the JVM do, the end result which is disapointing is the average elixir dev &lt; Scala guy using Akka or Finagle or shit Netty in terms of distributed systems.
I definitely am :) AOP in and of itself is a bit heavy theory-wise, though. I guess it just depends on the implementation.
love the dragon book icon
:) It is my avatar for github I guess
have you gone through Elixer Koans?
I have not. I picked up as I went through books and the Elixir/Erlang docs. I will take a look at that site though
How does it compare to gproc? 
There is a link for benchmarks on the announcement of the 1.4 release here - http://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/ 
what happens if the server dies?
Or if the request is served by a different server than it was created on?
Thanks for the hint â I didn't know about this. I will take a closer look, this looks interesting!
On mobile it's often less clicks since you don't have to type your super long hard to remember password on a phone, and you'll get a push notification with new email.
I looked at this recently, and found that I really preferred using elixir's native `with`, and handling the roll back on failure in the `else` block. 
How does it compare to other process registries, feature-wise?
Just to expand on this, to execute a shell command natively with Elixir, here's an example: `System.cmd("uname", [])`
I'm building an open source realtime social news app to teach people how to develop modern reactive SPAs with full stack technologies such as Phoenix, Vue, Vue Router and Vuex, you can know more about it [here!](https://github.com/Angarsk8/Loopa-News)... I'm also trying to find a job that allows me to write as much Elixir, Erlang and ES2015 as I can. 
Thanks! Yes, I'm thinking of doing a video/post series explaining how to develop this app from scratch
Also - is there an Elixer meetup in your area? If you are near Minneapolis, I would recommend the next one.
That is a good question. I'm in the Chicago area so I would assume there would be
I was just going to start on the same thing myself :(
[removed]
Do it anyways!
Do it and add more features to it
Thank you very much for your very quick answer!
Maybe the fact that I do too helps :)
True! I even read somewhere that :os.cmd should be avoided when possible, but in cases where I'm just trying to run a quick shell command, a single Erlang char list is quicker to type out than a command and a list of args for it. In cases where I am actually running shell commands within the application, I def stick to using System.cmd
The Phoenix/Elixir bootcamp on Udemy has a very solid explanation of all the individual steps of building a phoenix webapp. 
Does it need to be a screencast? What about the free [Phoenix Framework Guides](http://www.phoenixframework.org/docs/overview) or the book [Programming Phoenix](https://www.amazon.com/Programming-Phoenix-Productive-Reliable-Fast/dp/1680501453/)? I get that some people enjoy screencasts, but personally for the basics I would much rather have the guides or the book because they're much easier to re-visit.
[removed]
Yes use Phoenix. You won't need a database if you are using a 3rd party api to store the photos.
Why would you have multiple responses? Can't you just ask the api for the next ten photos?
Nice, I might be needing exactly this in the near future. Thanks!
If I remember correctly, :os.cmd/1 serializes everything through a single port that is effectively running bash. This means you can write commands that do `foo &amp;&amp; bar`, which you can't with `System.cmd/2`, but you should not rely on it if you are running many commands concurrently. That's to say using it in IEx should be just fine.â¢
One thing we found using a views with ecto is that you need a good way to drop and recreate them when migrations on the underlying tables need to be run. To do this we moved the view SQL into separate date stamped files, and wrote some helpers to drop and create views given a name and version.
Going to build a yelp web app for a language. I can't go to details because if I manage to finish it I'd like other people not to know my reddit account lol. I'd like to try GraphQL out but that would be later on when I managed get get a mvp app out.
saw this on twitter https://github.com/elixir-ecto/ecto/issues/1805
Pretty much the same stack for me as well as the same short term goal(job). :-)
This is awesome; a solid implemtnation of an opinionated decision. 
I'm confused by your explanation... `&amp;String.length/1` is perfectly valid form as a mapping function for `Enum.map/2`. Try: `iex&gt; ["a", "bc", "def", "ghij"] |&gt; Enum.map(&amp;String.length/1) |&gt; Enum.max`
To expand on /u/hellomika, this is a work around no? (edit: well a work around as in the language doesn't support module being first class like other languages). Base on what you've stated, and it makes sense, module aren't first class. Function are first class in Elixir. So `&amp;` wrap a module into a first class primitive, a function.
Thanks for the further insight Jose! :) That definitely makes sense. P.S. At risk of sounding like a suck up, I just want to express my immense gratitude and appreciation for all of the work and you and the community has done around what is now my favorite programming language by far. 
cool thanks. is it a good idea to just wrap that anonymous function in a a defined function? or would you do the checking a different way?
A few pointers: * you could use [atoms](http://elixir-lang.org/getting-started/basic-types.html#atoms): `:rock`, `:paper`, `:scissors` * with a list of possible actions: `[:rock, :paper, :scissors]`, you can use [`Enum.random/1`](https://hexdocs.pm/elixir/Enum.html#random/1) to pick a random action * you could use pattern matching in named functions: `def determine_outcome(:paper, :rock)` * you could use [guard clauses](http://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses): `def determine_outcome(player_move, computer_move) when player_move == computer_move, do: :draw` * use [attributes](http://elixir-lang.org/getting-started/module-attributes.html#as-constants) so you don't have to repeat some things: `@outcomes %{win: "You Win!", loss: "You Lose!", draw: "It's a draw!"}` Have fun! :)
I actually did this separately and then came back and noticed hellomika covered what I had in mind. FWIW, here's the code: defmodule RockPaperScissors do @choices [:rock, :paper, :scissors] def play(choice) when is_binary(choice) do String.to_existing_atom(choice) |&gt; play() end def play(choice), do: play(choice, Enum.random(@choices)) def play(player, computer) do IO.puts "You chose #{player}" IO.puts "Computer chose #{computer}" get_outcome(player, computer) |&gt; message_for_outcome() |&gt; IO.puts end def get_outcome(:rock, :scissors), do: :win def get_outcome(:paper, :rock), do: :win def get_outcome(:scissors, :paper), do: :win def get_outcome(:rock, :paper), do: :lose def get_outcome(:paper, :scissors), do: :lose def get_outcome(:scissors, :rock), do: :lose def get_outcome(choice, choice), do: :draw def message_for_outcome(:win), do: "You Win!" def message_for_outcome(:lose), do: "You Lose!" def message_for_outcome(:draw), do: "It's a draw!" end RockPaperScissors.play("rock")
thanks, i'm going to include all of this stuff. really like the guard clause idea.
Perhaps consider separating the game logic from the I/O. Instead of printing to the console and not returning anything, your `play` function could return a game result (something like `:win` or `:lose`), and then you can deal with printing the result to the console outside or in another function. 
What is the bot's planned purpose? I am unfamiliar with discord bots.
It just make using chat channels much more convenient. 
Thereâs already a Slack in the sidebar.
You might struggle to get users when competing against Slack and IRC.
Yeah, I'm aware. I personally use Discord, and didn't see any server already. Anyone is free to join this, not trying to start some alternative. 
Because many people in one place is better than a few people in many places. 
Totally agree. I began learning Elixir two days ago and I'm impressed by the level of the docs. And also by doctests :D Loving the language so far :)
Check exercism if you like this kind of things ;)
I've been toying with Elixir over the last several months and have created a Stock Ticker OTP app. I wanted to create a non-trivial app which had separate OTP + Phoenix + React apps to get a feel for how things fit together. Let me know what you think!
http://elixirsips.com is a great resource, as is going through the elixir track at http://exercism.io Edit: also http://elixirkoans.io/
For me, this was a very useful and in depth introduction to Elixir and Phoenix: https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial/
Currently working on elixir back end service app. Moving everything from Node.js to Elixir :)
Worth saying that Elixir Sips is now Daily Drip and is pretty awesome https://www.dailydrip.com/topics/elixir
I'm getting a 504 trying to access.
It's the same people. They moved from Elixir Sips to Daily Drip when they expanded into non-elixir content. 
For things like URLs, there's an easy answer for releases that's honestly not as widely known as it should be: run your release with `REPLACE_OS_VARS=true` set (or `RELX_REPLACE_OS_VARS` for exrm or relx). You can define a prod.exs config like config :myapp, twitter_url: "${TWITTER_URL}" And then run your release like $ REPLACE_OS_VARS=true \ TWITTER_URL=blahblah \ rel/myapp/bin/myapp console And hey presto! If that's good enough for your use case, and you don't mind having prod.exs be release-only, then you're good. [More info](https://github.com/mrluc/deferred_config#when-should-i-replace_os_vars)
Core observation/conclusion seems pretty spot on.
Thanks for putting this together, I was fighting with this a couple days ago and this is cleaner. 
Did you figure out the `mix new` command? You can find that and others by typing `mix help new`
A real-world example of [building a computational parallel pipeline using Flow](https://10consulting.com/2017/01/20/building-product-recommendations-using-elixir-gen-stage-flow/). Crowdsourcing product mentions, applying sentiment analysis, and scoring to rank products. Used to build the [Start learning Elixir](https://startlearningelixir.com/) recommendation website. Step-by-step guide to building, visualising and optimising a pipeline built with the new [Flow](https://github.com/elixir-lang/flow) library.
Forgot to talk about `help` ... thanks :) I did figure out the `mix new` command, one of the first things I did ;)
I'm particularly saddened by the deprecation of parenthesis-less 0-arity functions, because it makes it impossible to use my [favorite refactoring technique](http://www.virtuouscode.com/2012/10/01/barewords). I understand the motive, but I prefer the ambiguity in this case because it allows you to move code assigned to a variable into its own function without changing consequent code... Â¯\\\_(ã)\_\/Â¯
&gt; Does anyone have experience building a full application in E+P? How is the code dev and maintenance experience? Nope. But mix set up very nicely very opinionated layout. If you want a couple of clicks iirc you can do Heroku but it'll cost you. It seems like you need sys admin or dev ops or some kind of backend guy... &gt;__&gt;
Good questions! The variable warning and proposed alternatives have been discussed in multiple other places, so I will give a digest: your suggestion of only warning if there is an actual conflict would be more confusing because it means changes in a file will cause warnings elsewhere. Imagine for example you use the `utc_today` variable in some functions and then you introduce `utc_today/0`. Now you need to go back to all unrelated places and fix it. Even worse, maybe `utc_today` is a perfectly fine variable name, but now you are forced to pick something else because of a new function. Plus, when changing existing code, how will you know if there is a zero arity function in the current module? Sure, the ambiguity is easy to spot in a quick IEx session, but when writing software, comprised of multiple modules, having a straight-forward seems to be better. About `Enum.uniq`, we changed it to make it consistent with everything else in Enum. All functions that allow you to customise how the operation works with anonymous functions end with `_by`, for example: `max_by`, `min_by`, `group_by`, `sort_by`, etc. And why do we use the `_by`? Because some functions already have the second arity version taken, such as `sort/2`. I will comment that in the original issue linked by u/Hueho. We should have done that since the beginning. 
If we reversed, you would never know if `utc_today` is a variable or a function call without analysing the surrounding context. The change in Elixir v1.4 is so that `utc_today` is always a variable and `utc_today()` is always a function call. It doesn't matter the context. If we don't need to keep the context in our heads, it is less things we have to juggle when writing software. 
Thank you for the nice words!
Could this be helpful? https://medium.com/@sugarpirate/rise-from-the-ashes-incremental-apis-with-phoenix-b08cd66bd142
Looks very relevant, thank you :) I need to up my Phoenix skills a bit before I can clearly see how it all fits together but that definitely gives me something to work on. 
Thanks for the response and clarifications. The rationale for the variable/function ambiguity warning makes sense, even if I don't personally agree with it (it ultimately ain't that big of a deal anyway). `Enum.sort/2` actually seems to support my point, though. Like `Enum.uniq/2`, it sorts *by* the function passed as a second argument (the docs actually use that wording). `Enum.sort_by/3`, on the other hand, has an entirely different semantic meaning ("sort this Enumerable by comparing it after having mapped its elements by this function (and optionally using this other function for the actual sort)"). Then again, maybe I just have a weird interpretation of "consistency"...
That's a good point. I agree, to some extent it's a trade-off between flexibility during authoring code, and one form of understandability during reading it. Many would argue since you read code much more than you write it, go with the parens... However, most of the time I find a different, more important form of understandability is *improved* with bareword identifiers in Elixir. &gt; I need to look at the method arguments, attributes defined at the class level, modules, global monkey patching, etc In Ruby code, I'm inclined to agree. In Elixir, there are only two vectors for identifiers: a variable or a function call. &gt; Something that may execute some action, like a function, is quite different from a value stored in a variable. In Ruby code, again, I agree. In Ruby I use parens more and more because functions can do some dangerous stuff, and I have to differentiate that from all the other purer vectors for barewords. In Elixir, you can be more confident the function isn't going to do something crazy to affect current scope, whereas in Ruby this is a core idiom (see *has_many*, etc). In fact, since the bareword function call doesn't have any parameters, *the only real application* of it is to furnish data to the caller, since it has nothing to transmute. In this sense, *it's functionally identical to a variable within the current scope*. &gt; The change is about making this distinction visually explicit. When you look at the code, you know exactly what it is. Currently, when you look at a bareword, you know exactly what it is: a container for data, no matter the source, and you operate on it exactly the same. &gt; To me that's one example that makes software "readable" but not "understandable". Personally, I believe that, when reading code for understanding, differentiating between 0-arity functions and variables introduces more cognitive overhead than it removes. On first read, all you care about is that it's just raw data. When time comes to find where the data comes from, you **do** have to figure out if the bareword represents a variable or function call. But that's easy in Elixir. A variable bareword could come from parameters, or be locally assigned. If you're trying to understand where data comes from in some code, but don't know what the parameters to the current scope are, you're not really trying to understand it. On the other hand, pattern matching, pipelines, and small pure functions tend to promote local variables into parameters. I rarely destructure to create local variables more than twice in a scope; if I do I treat it as a code smell. A function call bareword could be local, or a remote call hidden under an import. If local, normally the function will be nearby its usage, since its only real purpose it to furnish data where used. So the only hard-to-understand opportunity for 'spooky action at a distance' barewords in Elixir, IMO, is an imported, 0-arity, remote function used as a bareword. **TL;DR:** I would rather have the compiler warn in that edge case that I used an imported, 0-arity, remote function as a bareword over being forced to care, when reading some code, where data behind a bareword comes from. Barewords can only ever be pure data containers in Elixir. If you're just inspecting a snippet you don't want to think about where the bareword data came from. When you start to look at the immediate scope containing the snippet, the point of origin is easily deducedâespecially when you prefer small scopes and many functions. This optimizes for *understanding* what the code is doing, rather than *understanding* where all parts of the code come from, through syntactic polymorphism. Of course, I don't have any right to kvetch about this--I failed to weigh in on the elixir-lang-core threads about this because I forget to re-subscribe when I changed my email address a few months back. :)
If `Enum.uniq/2` was equivalent to `Enum.sort/2`, the second argument would be a function that receives two arguments and returns if they are equal or not. That's not what `Enum.uniq_by/2` does though. For `uniq_by/2`, the second argument is a function that receives a single argument and returns a value that is used to compute uniqueness. Similar to `Enum.sort_by/2`, which also receives a single argument and returns a value which is used for sorting.
I used [Guardian](https://github.com/ueberauth/guardian) and [comeonin](https://github.com/riverrun/comeonin) for user management. In terms of deployment we used heroku as we don't really have a dev ops team. [Distillery](https://github.com/bitwalker/distillery) is the popular option for release packaging. But that's all I know about deploying. 
Yeah. I used Convox to deploy to AWS on a project for a university sports team over the summer. Convox is a slick realization of the 'Docker Compose + Docker Swarm + Self-hosted Heroku' dream, and I enjoyed it a lot. (I never used their dashboard/CI offering; just their CLI client for the setup/devops, and local pre-commit hooks for tests). I can highly recommend convox if AWS is an option for you. Otherwise, I work a good deal with Kubernetes but can't in good faith say it has as good of dev UX as Convox; k8s has to wear too many hats to optimize the experience the way Convox does.
I haven't had any issues using HTTPoison, which wraps hackney with a thin Elixir interface. I like to create API client modules, but don't use the HTTPoison base mixin - it was easier to understand just calling into HTTPoison. Use Poison to deserialise the response body, then maybe use an embedded Ecto schema to convert a bare Map into a struct you can work with. 
&gt; Alternately, I'd keep sort/2 as-is and rename sort_by to sort_map (to be consistent with filter_map; rearranging the second and third arguments for one of those two would also be warranted for maximum consistency). Except it is not a `sort_map/2` as the value returned by the anonymous function is not the value returned in the result. The value is only kept internally, which is a big contrast to `filter_map/2`. 
&gt; Basically: the only time the new warning should pop up ought to be the following situation: &gt; foo is undefined &gt; foo/0 is defined &gt; The programmer uses foo instead of foo() This still has a similar issue to the one we discussed, it is very contextual, which makes it hard for the programmer to know when they should use `foo()` or `foo`. It also does not help when reading the code, as the programmer needs to go through the same rules you have written above to figure out what `foo` means. Simpler rules is better than complex rules. And as Matz said, the "principle of least astonishment" is very personal, as it depends on your past experiences, so it may apply to your case, but I think the changes have been considered largely positive.
Thank you for the link. It is mentioned in the blog post linked previously but I'm glad to hear more people are aware of it. It feels like it might be best for more controlled api endpoints as it feels like you have to manually call the fallback endpoint yourself. I was hoping for something more transparent that would just fall through to Django by passing on the HTTP request exactly as it is. Still, good to know, thanks!
Right now I'm talking about even when a programmer *does* already embrace `foo()` v. `foo`. As it stands, *even if I totally meant for `foo` to be a variable*, if neither `foo` nor `foo()` are defined, Elixir goes off on a tangent about casting to a function and then throws an error about the missing function rather than about the missing variable, whereas (IMO) any reasonable interpretation of the principle of least astonishment would warrant Elixir's error to be for the missing variable. The rules in my above comment, in other words, are not for the programmer. They're for the compiler in order to be consistent with the rationale you've given for the deprecation in the first place. If `foo` is meant to be treated as a variable, then the error should regard the missing variable, *not* the missing function that could hypothetically be inferred if it existed. If and only if there's actually a function with that name and zero arity should there be a warning, since that's the only place where the ambiguity clearly happens and a warning actually makes sense. Basically: yes, `foo` can be interpreted as a function call or a variable by the programmer, but if the case of both `foo` and `foo/0` being defined involves assuming `foo` as a variable and not producing a warning, then so should the case of *neither* `foo` nor `foo/0`, and the undefined thing causing the subsequent error should be the variable, not the function. Anything different is inconsistent.
&gt; Right now I'm talking about even when a programmer does already embrace foo() v. foo. As it stands, even if I totally meant for foo to be a variable, if neither foo nor foo() are defined, Elixir goes off on a tangent about casting to a function and then throws an error about the missing function rather than about the missing variable, whereas (IMO) any reasonable interpretation of the principle of least astonishment would warrant Elixir's error to be for the missing variable. I see. That's only temporary until the warning becomes an error. Then we will be effectively able to error by saying the variable does not exist. Today, however, because the variable lookup and function lookup happen at very distinct stages, our only option is to convert to a function lookup and then error on the missing function.
HTTPoison uses Hackney, so you're getting the same thing only with a smoother Elixir experience.
Gotcha. As a stopgap for now, would it be feasible to hold off on reporting the warning until it's confirmed that `foo()` is valid? For example (approximate; I highly doubt this even compiles, let alone actually works): expand({Name, Meta, Kind} = Var, #{vars := Vars} = E) when is_atom(Name), is_atom(Kind) -&gt; case lists:member({Name, var_kind(Meta, Kind)}, Vars) of true -&gt; {Var, E}; false -&gt; case lists:keyfind(var, 1, Meta) of {var, true} -&gt; compile_error(Meta, ?m(E, file), "expected variable \"~ts\"~ts to expand to an existing variable " "or be part of a match", [Name, elixir_scope:context_info(Kind)]); _ -&gt; case catch(expand({Name, Meta, []}, E)) of {'EXIT','Elixir.CompileError',_} -&gt; compile_error(Meta, ?m(E, file), "undefined variable ~ts", [Name]); FunResult -&gt; Message = io_lib:format("variable \"~ts\" does not exist and has been expanded to \"~ts()\"," " please use parentheses to remove the ambiguity or verify that the variable name is correct", [Name, Name]), elixir_errors:warn(?line(Meta), ?m(E, file), Message), FunResult end end end; I normally hate using `catch` for this sort of thing (I prefer pattern matching and letting things fail), and I haven't the slightest idea if this sort of capturing is a reasonable thing to do in the compiler (since I ain't nearly as well-versed in its internals as you are), but short of rewriting the whole expansion process, something like this seems viable. You'd obviously want to be more specific in terms of pattern-matching the successful result (as well as the failure result, presumably; again: this ain't exactly my wheelhouse), but it's a start maybe? I see what you mean, though. Very distinct stages indeed.
It doesn't work because for local functions we need to compile the whole module to figure out if the function exists or not and expansion is only lexical. :( I mean, we could make it work if we put quite some work, but it would couple different part of the compilers that we would need to change.
Bummer. Oh well. Thanks for being so responsive and explanatory about all this.
I started trying to do this with terraform as a baseline, and I got it to proxy to rails, but I forget where I got to exactly, this is what I started though if anyone wants to work on it: https://github.com/bglusman/reverse_proxy I was thinking about trying to make a very general kind of solution for this sort of approach, but didn't get very far before being either distracted or discouraged, or both, I forget exactly :-)
Elixir 1.4 gives you some new `Task` functions to make it even easier: Try using `async_stream` :) def fizzbuzz(first, last) do first..last |&gt; Task.async_stream(&amp;calculate/1) |&gt; Enum.each(&amp;print/1) end 
I had to do something similar a while back and but it was just a rest api. I created https://github.com/nicksanders/exdjango which allowed authentication to work for both.
Just to note, Ecto isn't an ORM . It's changesets isn't some black magic, but a simple data type that coalesces changes and errors. It's Repo is more of a wrapper around the database that takes care of pooling, transactions, etc. The data it returns is "pure data" but in a clearly defined struct. Honestly, Ecto is really nice and I think it fits most people's use cases wonderfully.
I didn't say that Ecto is an ORM. There is nothing about ecto, but the adapter that uses its connection. It's just another method to interact with databases.
True, sorry think I sounded harsh. Just meant to clarify that Ecto isn't (for the most part) the things you listed your avoiding.
 config :defql, connection: [ adapter: Defql.Adapter.Ecto.Postgres, repo: Taped.Repo ] I can only have one globally configured repo?
Cool! This reminds me of https://github.com/krisajenkins/yesql. Would you consider your project a port of it?
Yes, you can use it with configured ecto repo or as a stand-alone connection.
They company I work for has 4 production Elixir+Phoenix apps in place (and 3 more in staging right now waiting for our off-season). We've been working on a couple of them for about 1.5 years. I like the language and maintenance is fine. The upgrade cycle isn't too short and they do a good job of deprecation warnings before breaking things. Anecdotal evidence: people transitioning from Rails say there's no reason to do rails because Phoenix is just as productive and has much better performance. Maybe .NET people will have a different opinion? User and role management are not difficult, it's just that you use a couple of libraries and glue them together. My preferred choices: Guardian for authorization, comeonin for password hashing for user creation and authentication, and then potentially something like Canada if you need more complex role-based authorization schemes. There are a number of ways you can deploy: 1. Heroku: easy, low touch, high cost 2. Amazon EC2: Distillery and Edeliver for building and deploying to a static sets of instances. Good choice if you need to cluster your Phoenix apps. 3. Amazon ECS with Docker: Use docker to build and deploy images. Really good for scaling because you can auto-scale containers and underlying instances based on usage. My company currently does 2 &amp; 3 above. I've used Heroku before and it's fine, it just has all the limitations that heroku has...
This is very interesting! Going to give it a go!
Shouldn't it be "Elixir on Phoenix?"
The title on the article was edited but I can't update the title here.
As far as I understand, Credo only finds exact copy-paste. Duplex ignores changed variable names to see the duplicate structure.
A front-end build system since I got fed up with JS ones. I thought, why not just build the front-end with Mix? So I'm writing one and seeing if it turns out into anything useful. It's working ok currently, but I want to add builtin watch capabilities so that I can make it simpler to use. Basically you write your build steps as Mix tasks. If you need another task as a dependency, call it at the start of your task (there's a helper to call multiple in parallel). The tasks themselves invoke the build tools (Babel, Rollup, node-sass, etc.) on the command line. Instead of streaming files to the next task, they are written to a temp folder which is used as input for the next task (so for example `web/static/js -&gt; .tmp/transpiled/js -&gt; .tmp/bundled/js -&gt; priv/static/js`) â I'm still on the fence if this is a good thing or not. I'm currently using it in my blog engine and it looks like this (`apprunner.exs` and `utils.ex` would eventually be their own library): https://bitbucket.org/vincit/mebe/src/6e589dd5a98243bcb20e84eeee39a338bc690600/lib/mix/tasks/?at=master It's still quite verbose, but when I get the custom watch thing implemented the JS bundle and CSS compile tasks should be simplified a lot.
No, it's currently a private repo. I plan to open source it when it is ready though.
I also think it excludes those who were never Ruby on Rails developers. I come from a Python, PHP, JavaScript background and am now picking up Elixir and Phoenix. 
Thank you for responding, I'm willing to wait for it to go open source. 
Rereading the phoenix book and getting addicted in exercises in exercism
What does "Rails-like" mean to you, as someone who hasn't worked with it? I'm curious.
It doesn't mean anything to me. I was drawn to Elixir for reasons that have nothing to do with Rails.
I've started a project that helps writing this with feature files: http://github.com/cabbage-ex/cabbage
[removed]
If you really want to remove the keywords from `opts`, you could do something like: def init(opts) do {[some_optional_arg, another_optional_arg], opts} = multi_pop(opts, :some_optional_arg) |&gt; multi_pop(:another_optional_arg) end def multi_pop({others, opts}, keyword) do {result, new_opts} = Keyword.pop(opts, keyword) {Enum.reverse([result | others]), new_opts} end def multi_pop(opts, keyword) do {result, new_opts} = Keyword.pop(opts, keyword) {[result], new_opts} end Or if you don't care about removing the keywords from opts use `Keyword.get/3`.
Nice. I'm actually using unity but any of extra info is appreciated.
Just read through the source and this is really awesome. I've created two interpreters in Elixir, one being a Lisp dialect written entirely by hand and a language with a more C-like syntax using `Leex` and `Yacc`. I really like your struct and protocol model that you use here. Each node is a struct, (makes the function heads inside of the `eval` module explicit and easy to read) easy to debug and produce better error messages because each node type implements a method to produce a string and the ability the spit out object types. (Object protocol) Some people might call it over engineered but I like the way everything is organized. I definitely take a lighter, messier approach. Definitely going to try implementing my next interpreter in a similar style. If you or anyone else is curious here are my two interpreters (Both are pretty incomplete, for the record. Just little experiments here and there!) [July](https://github.com/Rob-bie/July) [July-LISP](https://github.com/Rob-bie/July-LISP)
Thank you very much! To be fair, most of the basic structure is taken from the original implementation in Go, but I had a lot of fun trying to translate it into idiomatic Elixir code. Thank you for the links to your two interpreters, I will definitely check them out!
[removed]
I noticed a couple of places in the code where a list was being built up by concatenating a single value to the end: evaluated ++ [value] Perhaps a more idiomatic style would be to construct these by prepending to the head of the list, then reversing it once all elements have been produced. Or better yet, see if the recursion scheme can't be expressed with standard library functions like Enum.flat_map_reduce.
You have selects in both `final_query` and `group_query`. Combine the three queries at the bottom into a single query and it should work.
 sub_query = from sq in Rumbl.Nestoria, distinct: sq.lister_url, select: [sq.place_name, sq.price, sq.price_type, sq.listing_type, sq.lister_url], where: fragment("cast(to_char(?, 'YYYYMMDD') AS INTEGER) &gt;= (SELECT cast(to_char(max(inserted_at), 'YYYYMMDD') AS INTEGER) - 1 FROM nestoria)", sq.inserted_at), where: sq.bedroom_number == 1 group_query = from mq in subquery(sub_query), join: ug in Rumbl.Underground, where: ug.station_name_slug == mq.place_name, select: [ug.station_name_slug, mq.place_name, count(mq.place_name), fragment("Avg(CASE WHEN ? = 'weekly' THEN price * ( 31 / 7 ) ELSE price END) AS avg_monthly_price ", mq.price_type)], group_by: [mq.place_name], order_by: mq.place_name gives me this error: SELECT u1."station_name_slug", s0."place_name", count(s0."place_name"), Avg(CASE WHEN s0."price_type" = 'weekly' THEN price * ( 31 / 7 ) ELSE price END) AS avg_monthly_price FROM (SELECT DISTINCT ON (n0."lister_url") n0."place_name", n0."price", n0."price_type", n0."listing_type", n0."lister_url" FROM "nestoria" AS n0 WHERE (cast(to_char(n0."inserted_at", 'YYYYMMDD') AS INTEGER) &gt;= (SELECT cast(to_char(max(inserted_at), 'YYYYMMDD') AS INTEGER) - 1 FROM nestoria)) AND (n0."bedroom_number" = 1)) AS s0 INNER JOIN "underground" AS u1 ON TRUE WHERE (u1."station_name_slug" = s0."place_name") GROUP BY s0."place_name" ORDER BY s0."place_name" [] ** (Postgrex.Error) ERROR (grouping_error): column "u1.station_name_slug" must appear in the GROUP BY clause or be used in an aggregate function (ecto) lib/ecto/adapters/sql.ex:429: Ecto.Adapters.SQL.execute_and_cache/7 (ecto) lib/ecto/repo/queryable.ex:127: Ecto.Repo.Queryable.execute/5 (ecto) lib/ecto/repo/queryable.ex:40: Ecto.Repo.Queryable.all/4 test/quick_ecto_test.exs:24: (module) (elixir) lib/code.ex:363: Code.require_file/2 (mix) lib/mix/tasks/run.ex:71: Mix.Tasks.Run.run/1 (mix) lib/mix/task.ex:296: Mix.Task.run_task/3 (mix) lib/mix/cli.ex:58: Mix.CLI.run_task/2 (elixir) lib/code.ex:363: Code.require_file/2 The join needs to occur **after** the group by. I'm just not sure how to implement this in ecto.
The error from postgres stems from the fact that you select non-aggregated fields in the `group_query`. You don't do that in your original query from the question. 
A WebRTC based app. 
If I see correctly, `mg.place_name` is the same as `ug.station_name_slug`, so you don't need to select it anyway. 
I was trying to simplify the SQL. Assume I have to make the join at that point.
I use a GenServer 90% of the time rather than an Agent because of previous Erlang exposure (Agents are an Elixir abstraction) and I often have a scenario just complex enough to extend past the scope of the Agent API. But obviously your situation will differ. If you just need some place to store some state and nothing else - you could start with an Agent if you're not fluent in the GenServer callback handlers. It will not be difficult to convert it to a GenServer later.
Ah, so I would have to use their VM platform, not their App platform?
It has been requested, but doesn't have many votes: https://feedback.azure.com/forums/169385-web-apps-formerly-websites/suggestions/8986354-support-elixir-in-azure-webapps Also, this post is about getting Go up and running, which involves downloading the Go runtime: http://www.wadewegner.com/2015/01/creating-a-go-site-extension-and-resource-template-for-azure/
Try azure container services as they got out of beta with the new docker 1.13 release.
At some point there was a proposal to add the pipe operator to JavaScript and I really hope it happens. I don't have a ton of Elixir experience but that's a feature that I wish for in my day-to-day development. 
To be honest, I did not now the latter syntax was possible. I might change it into this one, looks much more readable :)
There's a Monetized package that has support for currencies. I think it uses Decimal under the hood. If you're not using Monetized then yes you should probably use Decimal. Floats are a Bad Idea(TM)
I'm not a fan of this notion either. When you're developing an applications in Rails, effectively Rails is your application. While that is not true for Phoenix, you're still developing an OTP application. While Phoenix provides you with some nice libraries to simplify certain tasks, you can still easily pick and choose what you want from it, or integrate it into a much larger application. 
Indeed - it's a common misconception. I mean, you CAN develop a monolithic Rails like app with Phoenix, but it's not a great idea - and not one that people coming to Phoenix from Rails should be encouraged to do..
Glad you like it :)
Please don't use `Float` for actual arithmetic. iex(1)&gt; 0.1 + 0.2 0.30000000000000004
This was already posted 5 months ago: https://www.reddit.com/r/elixir/comments/4wna8i/show_relixir_magnetissimo_web_application_that/
That's not idiomatic Elixir code. That's Ruby code translated into Elixir. Any code that relies heavily in binary processing should be using binary pattern matching, which is a wonderful first-class feature that is exclusive to Erlang/Elixir (afaik). If by idiomatic code it means we should only use pipes and neglect important features in the language, then I don't want to write this kind of idiomatic code. :) Also, Elixir is not a JIT compiled language but it does provide opt-in compilation to native. Finally notice that in the Elixir version you are building a final list with all results and you are not doing so in the Ruby one. I would recommend changing the Ruby one to use `(1..1000000).map` for a more apt comparison or not returning the value of the comprehension in the Elixir one. &gt; not sure how to run a compiled BEAM file without recompiling it again You first compile it: elixirc vowels.ex And then run elixir in the same directory with an expression to evaluate: elixir -e Vowels.find_vowels 
Here is an implementation using pattern matching and recursion, which are fundamental Elixir concepts: defmodule Vowels do @vowels 'aeiouAEIOU' def find_vowels() do for _ &lt;- 1..1_000_000 do find_vowels("HelloWorld", "", "") end :ok end defp find_vowels(&lt;&lt;vowel&gt;&gt; &lt;&gt; rest, vowels, consonants) when vowel in @vowels do find_vowels(rest, vowels &lt;&gt; &lt;&lt;vowel&gt;&gt;, consonants) end defp find_vowels(&lt;&lt;consonant&gt;&gt; &lt;&gt; rest, vowels, consonants) do find_vowels(rest, vowels, consonants &lt;&gt; &lt;&lt;consonant&gt;&gt;) end defp find_vowels(&lt;&lt;&gt;&gt;, vowels, consonants) do vowels &lt;&gt; consonants end end It runs in: $ time elixir -e "Vowels.find_vowels" real 0m1.626s user 0m1.568s sys 0m0.074s And by simply adding `@compile :native` right after `defmodule Vowels`, it runs in: $ time elixir -e "Vowels.find_vowels" real 0m0.926s user 0m0.868s sys 0m0.080s 
does Decimal use Float under the hood?
Wow. I'm new to Elixir and that is really impressive code!
You can do it another way, but if you're looking for the most "elixir" way of doing it, you've already got it. If in doubt, use pattern matching. It's efficient, easy to reason about, and it helps you crash early.
&gt; I definitely want to use all first class features that make sense, I'm just not aware of binary pattern matching details and how this example can be solved by them. I'll try to read up, though. I'm mostly familiar with Elixir by using the Phoenix framework which is by design similar to Ruby on Rails. That's not exactly true, and you're unfortunately doing yourself a disservice by following that line of thinking. Phoenix is only trying to be a collection of potentially useful libraries to help you with your task (though you're free to pick or choose or extend whatever you want; this is not so much the case in Rails), where Rails is your application (your application is typically entirely built within Rails), Phoenix however is not, rather OTP is still your application and you're just integrating some Phoenix components with your application. For a simple website this won't make too much difference (possibly only if you're spinning up some other supervisors), but for much larger applications where you're building many different OTP services, then understanding that you're not working inside Phoenix is crucial. So definitely focus more on learning and being comfortable on the Elixir side. As it will make it a lot easier for you to develop your applications. 
All decimal-type packages I know of for any language use fixed point number representations, so if it had to build on something else, it would build on integers. I don't see how you could make a precise abstraction using imprecise components.
Yes, I kept it ASCII only on purpose given the problem description. You can however easily change the code above to `&lt;&lt;vowel::utf8&gt;&gt;` and `&lt;&lt;consonant::utf8&gt;&gt;` if you want to match on Unicode characters.
I forgot about this whole arc. I must've come down with Changnesia.
Sometimes my forgetfulness makes me very Changry.
I was thinking that that by default ExDoc should probably constrain images' max-width with CSS (and if it doesn't maybe that'd be an ExDoc issue), so w/your extension it might 'just work' if someone had svgbob.
Serious q: How are people using Ecto? I haven't found a way to fit it into a project yet.
Do you have a database in your project? :) 
You could probably do that with an inline style, setting the `:markdown_processor` to a markdown library you've either modified to include the inline style or could be customised to include it. I think that would be the simplest approach if you only wanted to customise the style of images. But if you wanted to do more complicated styling I think then you'll be looking at providing your own assets (see `mix help docs`), and having your custom CSS. Though I'm not entirely sure. 
[removed]
Programming Phoenix is worth buying and takes you through building a Phoenix app from start to finish.
It's just a database wrapper. It handles making database queries (the whole getting things from the database) and presents them nicely. Makes persisting things easy. https://hexdocs.pm/ecto/getting-started.html
When working with files, it is important to know the encoding the file is written in. If the file is UTF-8 encoded, which is the most likely scenario and what Elixir supports by default, then you need to remember that what you see **is not** what you get, as someone may have accidentally introduced invisible characters, such as [zero-width whitespace](http://www.fileformat.info/info/unicode/char/200B/index.htm). Luckily, in your debugging session you seem to have spotted the issue, which is a character with codepoint 65279. Googling this codepoint leads [to this page](http://www.fileformat.info/info/unicode/char/feff/index.htm) which reveals this is the so-called [byte order mark](https://en.wikipedia.org/wiki/Byte_order_mark). You have two options here: remove the character from the csv directly (as BOM is not necessary for UTF-8 files) or trim it from each row before processing it using something such as `String.trim_prefix(string, &lt;&lt;0xfeff::utf8&gt;&gt;, "")`. Also note that Elixir master added an option called `:trim_bom`to `File.stream!`, which be helpful in exactly such scenarios. Finally, the reason why conversion to atom fails is because atoms currently support only latin 1 characters, which BOM isn't.
Not OP but damn your explanation is so good. idk why but as I was reading your post it flowed so well in my head.
Thanks for the reply Jose. I figured it was something like that. Thanks for telling me about those methods, I will look into those. I may just also String.replace the whole file once, as it's not dynamic data.
You just need to do it once then and at the beginning of the file using `trim_prefix`. BOM is not supposed to appear anywhere else.
For those of you who don't know, putting binary data in your database is generally a bad idea because it increases the load significantly. The database is likely already going to be the bottleneck in most apps so adding additional load will likely bring it to it's knees quickly.
What should I do? Just curious? I am actually mostly interested in sending pictures over channels to users in a chat?
That depends on how your application works. Are you allowed to have images in between messages in a single message? If not, you can just store the image(s) on S3 using something like [arc](https://github.com/stavro/arc) (I have not used this project). Then just send the image URL with the message and have the client construct whatever it needs to on its end. If you do, you could do some sort of pseudo templating system such as Hey! Check this out {{MyImage1}} I thought of you when I saw this! Obviously you would need to escape the input incase of using the `{{...}}` syntax. Still using something like arc in order to store the images and again have the client store the images on S3 or something. Another option if you can have images in the middle of your messages would be to "cut" up the message into multiple parts so that the image is at either the start or end of a message. Just make sure to store the order in which the different "messages" should be constructed on the client side.
In my personal time: started to blog about my experience with elixir. http://raorao.ghost.io if you're interested. Also trying to answer as many questions on the elixir slack as I can -- want to give back to the community. At work: building a ETL pipeline between MySQL and DynamoDB using GenStage. The API has been more difficult than I'd like, although im getting the hang of it. the elixir technique of using synchronous abstractions to represent async systems (like GenStage) is a mixed bag, IMO. I like writing elixir because of the async stuff, and find that I want to be handling it myself.
[removed]
This is a great series of videos. Thank you!
Also, might be worth putting the why and the pros/cons at the TOP of the article :)
How does adding binary data to a database increase the load? I have done it several times and I quite frankly prefer it compared to having image data stored on some other storage. Being able to rebuild the image cache from the database is nice and it's not like I serve the image data in the database to clients anyways.
If I had to pick one of the 3 I'd go with the case statement. You could also use an inline `if/else` if a &gt; b, do: :ok, else: :error if a &gt; b, do: :ok, else: :error
I am new to Phoenix and Elixir. We have avoided using nested forms in the past but for our most recent application it seemed like the right way to go. I decided to do a little write up because there is not too much documentation about this subject. I originally had a much longer and more verbose blog post that went into detail on how to dynamically add items to the form but I decided it was too long and boring. I am curious if anyone else here has been working with nested forms, and what their experience has been like?
Out of curiosity, I wonder how a no-op "port" would behave (in-memory echo process), and how a write-to-disk-and read again "port" (out-of-memory FS proceess) would behave, to sort of fence these results.
I haven't written much Elixir before-- why not just use a fold? It seems more concise and familiar to me: List.foldl( to_charlist(str), {[], []}, fn(elem, {vowels, consonants}) -&gt; if elem in @vowels do {[elem | vowels], consonants} else {vowels, [elem | consonants]} end end )
I hate being that guy, but you had several errors in your post. * In the `Todo.List` module, you use the word `list` instead of `use`. * At the very end of the post for the `edit` and `update` functions, you use `List = ...`. Elixir does not allow for the first letter in a variable to be uppercase. * You thank "Jose", but his name is "JosÃ©". Admittedly, I am not entirely sure how much he cares about this, but I figured I would just let you know. * All of the code blocks are indented too much, aside from the first line of each block. * You might want to think about having some default padding to the elements of your code blocks instead of having it pushed directly to the left side of the container. I'm sure the right side is having the same problem. As a side note I had some kind of popup (subscribe?) and once I hit the no button, I was scrolled to the top of the page despite being in the middle. This was just from a brief read of the post.
My preference is to pattern match everywhere I can. If I have a condition that needs to be used then create functions that deal with them. In your example, albeit trivial, you can do something like: ``` def split str, skip_empty_parts: true, do: ... def split str, do: ... ``` Each function should really have one purpose, if your function does more than one thing then it could probably be broken out into more.
Thanks for taking a look at it. I am making the changes now.
[removed]
The validation can not be done in the function header (neither pattern matching, nor using a `when` clause). It has to be done in a separate function.
Another option is that you have a passthrough function. For example: def my_func(a, b) do do_my_func( a |&gt; validate_a, b |&gt; validate_b) end def do_my_func(:err, :err) do #not so happy end def do_my_func(a, b) do #happy end As you see there are many ways to implement what you want to do. None of them absolutely wrong.
BTW, bare branching is something to avoid, stylistically speaking. It's better to structure your program using pattern matching.
Just came across this over on [elixir forum](https://elixirforum.com/t/testing-named-agents-or-any-named-process/3420/9) I had always assumed that async ExUnit tests within the same file ran concurrently. But TIL that it is only test cases (files) that are run concurrently, the tests within each are run serially. 
For the fucks sake please run that article through a spell checker.
I have been really happy with Stephen Girder's course on Udemy. [ Elixir/Phoenix bootcamp](https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial/) 
I love all of his courses. This is a great intro. I would move onto the Programming Elixir / Programming Phoenix books afterwards for more indepth stuff. 
This. For all languages. Really annoying. 
exercism.io + Docs + a project. I bet you won't finish those books anyway.
I like it as it focuses on OTP a lot sooner, so I wouldn't say that it's appropriate to learn from the start.
[removed]
Wow, that's extremely neat; I'd avoided IO lists for some things bacause I'd assumed what the parent comment outlined, that recursing over lists looking for non-ASCII characters would lead to fairly wordy, difficult to maintain code, but that makes things a helluva lot easier.
You want to avoid the conversion from binary to list. The goal of using the recursive format is exactly to be able to traverse the binary without copying or building other data structures.
I blogged about this a month or 2 ago: https://kroltech.com/2016/12/08/how-im-learning-elixir-phoenix/ Before you can get your hands dirty you need to at least understand the language, its syntax and nuance, the many libraries and tools available, etc. ð Programming Elixir 1.3: Functional |&gt; Concurrent |&gt; Pragmatic |&gt; Fun By Dave Thomas This is a fantastic book, and of the 4 that I list, by far the single most important and the one that gets my recommendation. The authorâs approach is great, the practice exercises provided work really well to give you a better understanding and comfort level with the language (to the point that youâve learned so far throughout the book) and are just the right level of challenging to not be frustrating. Elixir in Action By SaÅ¡a JuriÄ This is the 2nd book I read on Elixir. It is also a really good book and goes into great detail about the language and its syntax. I got a little more than halfway through before I switched to Programming Elixir 1.3 (above) and found that more things âclickedâ and I worked through at a first pace with the latter book. That being said this is still a very good book on Elixir. Introducing Elixir: Getting Started in Functional Programming By Simon St. Laurent This is actually a really small book so its a great way to quickly get up to speed on the language and syntax. I canât say its the most exhaustive book, but for what it does it does pretty well. That is to say, it gets you up to speed pretty quickly. Still, this is 3rd on my list of recommendations. Step 2 â Practice, practice, practice! Now that youâve got a good solid grasp of the language syntax and fundamentals, its time to go through the paces and really start to challenge yourself. Trust me, with any new language this is going to be the most painful part. Youâre going to get stumped, youâre going to feel stupid, and itâs going to generally suck at first. Thats very common and understandable â you just need to stick with it and you will get better every day! Do the practice exercises that are included with whichever book you decide to read. These are provided for a reason â and generally the author provides them in such a way that they gently introduce you to the concepts that were just covered so youâre not bogged down with trying to figure out too much at any give time. Practice sites: Exercism.io â Elixir; Codewars; Rosetta Code More Reading â Phoenix: Programming Phoenix: Productive |&gt; Reliable |&gt; Fast By Chris McCord This is a fantastic book that very specifically covers Phoenix. This book is a must read if youâre planning on doing web development using Elixir. Of course read this book after youâve read at least one of the books from the list above. Videos / Online Training: If books are not your thing, there is a ton of material available online in the form of videos and screencasts specifically dedicated to learning Elixir and/or Phoenix: Udemy â The Complete Elixir and Phoenix Bootcamp (make sure you wait for one of their sales!); Daily Drip â Learn Elixir Quickly; LearnElixir.tv; Elixir Sips Step 3 â Meet other Elixir devs Make sure you get out there and find a local Meetup for Elixir so you can start chatting up other developers that are experienced or just getting started like you! If you canât find a local meetup specifically for Elixir, see if there is one for Erlang and if there's not â time to start a new Meetup group! ð¤ Step 4 â Just build something! Equipped with this new found skill of Elixir its time to put yourself to task and actually just build something. Anything! Take a simple pet project (or 2, or 3) youâve done in the past and rewrite it using Elixir (and Phoenix)! Find an existing open source project built using Elixir and study its source â contribute even! (edits: formatting)
Fancy seeing you on my second favorite subreddit. Shadilay, brother. 
For anyone who's keen to start learning Elixir, you'll have a great intro from the following two books: - [The Little Elixir &amp; OTP Guidebook](https://startlearningelixir.com/r/the-little-elixir-and-otp-guidebook) - [Elixir in Action](https://startlearningelixir.com/r/elixir-in-action) Once you're comfortable with Elixir, then take a look at [Designing for Scalability with Erlang/OTP](https://startlearningelixir.com/r/designing-for-scalability-with-erlang-and-otp) for more in-depth guidance. [Programming Phoenix](https://startlearningelixir.com/r/programming-phoenix) is a good option to learn the Phoenix web framework.
You could clone the git repo of the package and then run "iex -S mix" in the root of the repo.
Started working on a new app to help food banks/pantry programs manage their supplies and distributions to hungry folks. Code and details on volunteering for anyone interested are here: https://github.com/MasbiaSoupKitchenNetwork/open_pantry/blob/master/README.md#learn-more
I've used Elixir, but have minimal Erlang exposure. The concepts directly translate, even if the code examples require additional time to decipher. I think it's worth the investment to learn the fundamentals behind OTP. 
Yes-- the `to_charlist` was my concession to not knowing the proper way to traverse a binary in Elixir :). The other response to my comment solved this issue, to my understanding, by using `Enum.reduce` instead of `List.fold`. If my understanding is incorrect and `Enum.reduce` still does not avoid the conversion to a list, I wonder-- is there really not a way to `fold` over a binary string?
I meant if you can point us to a discussion where either Valim or Hex maintainers stated that they won't support global package installation.
I don't know if something like that even exists. A quick search on Google brought me to [this SO answer from Jose](http://stackoverflow.com/a/33568506) 
I know what STM means and I also know for sure that there is no such thing in BEAM. STM imply shared memory, BEAM has none of it; ets doesn't count, it has locks built-in. Wikipedia mentions mnesia as STM implementation, but it is questionable IMO. Also Phoenix does not use mnesia anyway. 
[removed]
WRT `String.split`: Ah, I see. I wasn't sure what that was for. The manual pattern matching approach is just doing a list traversal manually, rather than handling it through a higher-order function. You could even adapt the above code to be fold-like. All you'd have to do is switch out the consonant and vowel accumulating logic for a call to a function passed in as a parameter.
Was interested in Erlang, got tired of the hacky ways of Python and jumped into Elixir just as it reached 1.0
I wanted a language that could modify it's own AST. I was originally looking at Nemerle, which targets the .NET framework, but somebody on hacker news said elixir could do the same. I had a chance to do a greenfield project and chose elixir and have fallen in love with it.
I discovered phoenix first and was intrigued by the language behind it. I discovered a new way to program (first functional programming language for me) and chose to dig a bit deeper. Being able to manage processes / supervisors opened new possibilities for my web apps.
Messed around with haskell, clojure, scala, then i discovered Phoenix which looked extremely promising. Something about Elixir made a lot of sense, and processes and OTP grabbed my interest in a major way.
Loved the syntax (with all those little conveniences and great power it gives me). Had mind blown by the OTP. Tried it just to test it out and got hooked. Haven't completely switched to Elixir at work though, tricked some friends and colleagues into checking it out, all of whom equally impressed for the same reason as I. :)
Very similar story for me but I jumped a fair bit later (I want to say 1.3). I'd previously tried Haskell and none of it worked for me (I understood the functional principles just fine, it really helped with Elixir!) but at a talk I attended in Cardiff an engineer said Erlang was really good for them. I looked into it and found out about Elixir, compared the two for web development and decided on Elixir.
basically this! ^
Good to see how Elixir gets more traction and I hope future articles would be more in depth. This was basically "it served them good. Bye" 
Curious, what didn't work for you with Haskell?
Cool, thanks for your answer. I've written some stuff in Haskell but never tried any of the web frameworks (yet). I agree, some of the tutorials seem to have an assumption that you should just know everything. Smart people aren't always good at explaining things. Totally agree with you regarding the type system. Some of the nice things about Haskell make me look at other languages like "wtf were they thinking?". 
Correct, by "list traversal" I just meant "pattern match out the head if the list is not empty and recurse."
Off topic, but that picture is one of the most distracting offices I've seen.
have been building a user manager https://github.com/Alezrik/user_manager and writing an elixir blog in spare time https://excavationofimagination.wordpress.com/
Also a webinar with Ben and Dave: https://www.erlang-solutions.com/resources/webinars.html#18-months-of-elixir-in-production-at-2nd-largest-sport-website-in-the-world-26
I wonder if they're developers though as they have screens of different sporting events. My bet is that they're a bunch of forum trolls hired to drive traffic.
The post on HackerNews: https://news.ycombinator.com/item?id=13606139
This is definitely something I'll wanna keep an eye on!
This sounds really interesting, are the users being managed here normal webapp users for a Phoenix app or something totally unrelated/much higher scale? Or is it mostly an excuse to play with GenStage? edit: Oh, looking at blog now, probably some of the answers there, clearly not just started to play with GenStage since you discovered that after starting :-)
There is a bit of an extra ingredient when it comes to CLI apps. You'll need to add an escript option to your project method in the mix file. [This article](http://asquera.de/blog/2015-04-10/writing-a-commandline-app-in-elixir/) provides the setup basics of being able to pass in options. It terms of figuring out the OTP part, leave that part for last. Start by making a module for each [Computation] and get it working first without worrying about speed and robustness. This being elixir, if your concerns are sufficiently separated, speeding things up and making things more reliable later won't affect your application structure. Does your app need to hold state and wait for input 2 after computation 1 is done? If not where does input 2 come from? Best of luck on your project
Thanks for the reply omg, are you the one with the youtube videos on OTP, if you are, THANK YOU MATE. You are amazing. I am aware of how to make the app into a command line tool using escript. I haven't gotten to that part yet cuz I'm still working on computation 4. I am however almost done with comp1, comp2 and comp3. The inputs 1 &amp; 2 are coming from some user (a config file or a parameter being passed). The computations go in order, I cannot do 2 before 1 is done, 3 before 2 is done and so on. The inputs of the computations depend on the outputs coming from the ones above them. For comp3, I am spawning a task which does the computation in the background but for comp4, I'm kind of stuck at the moment. I'm unable to figure out how to wait for comp3 to finish it's task while monitoring it in a separate process which gives me back an {:ok, result}, once the monitor gives me that result, I can feed it on to comp4 and go from there. I don't know if I was able to explain my problem better. I'll update with another diagram soon. Edit: [Here's an updated workflow](http://imgur.com/a/xKeQf) Thanks!
Yeah that's me :) When you start a task you can use `await` to wait for it to finish before doing anything else. You can also pass the task reference to another method and wait for it for finish there. When you start a task with `Task.async` you are starting a new process. Could you expand on how it is being monitored and what would you like to pass to computation4? I wrote a pretty verbose module showing examples of waiting for tasks to finish and passing tasks as arguments to different methods. I hope it helps Run TaskTester.all_computations defmodule TaskTester do def all_computations do task1 = start_computation1() IO.puts "\nDoing other things while task 1 runs\n" # wait for task1 to finish here {:ok, result_of_task1} = Task.await(task1) IO.puts "computation1 results:" IO.inspect result_of_task1 IO.puts "\n" input2 = "input for task 2" task2 = start_computation2(input2) IO.puts "Doing other things while task 2 runs\n" # passing task2 and another input to task 3 input3 = "input for task 3" {:ok, result_of_task3} = start_computation3(task2, input3) IO.puts "All done." IO.inspect result_of_task3 end defp start_computation1 do task = Task.async(fn -&gt; IO.puts "starting the first computation" :timer.sleep(2000) IO.puts "finished the first computation\n" # This is what the task responds with. {:ok, "result of the first computation"} end) task end defp start_computation2(some_needed_input) do task = Task.async(fn -&gt; IO.puts "starting the second computation with input: #{some_needed_input}" :timer.sleep(2000) IO.puts "finished the second computation\n" # This is what the task responds with. {:ok, "result of the second computation"} end) task end # Notice that the unfinished task2 is passed in as an argument. defp start_computation3(task2, some_needed_input) do IO.puts "waiting for task 2 to finish" {:ok, result_of_task2} = Task.await(task2) task = Task.async(fn -&gt; IO.puts "starting the third computation with input: #{some_needed_input}" :timer.sleep(2000) IO.puts "finished the third computation\n" # This is what the task responds with. {:ok, "result of the third computation"} end) Task.await(task) end end 
No front-end framework is being used. I am using jQuery just because it is needed for Bootstrap (tabs &amp; alerts).
In addition to the tools mentioned above, you should checkout Hashrocket's [gatling](https://github.com/hashrocket/gatling).
There was an [article posted on here a few days ago](https://medium.com/mint-digital/elixir-deployments-on-aws-ee787aa02a9d#.d69zd5ccm). Hope this helps.
+1 for distillery and edeliver
edeliver &amp; Digital Ocean
It's just the way they implemented the inspect protocol. https://github.com/elixir-ecto/ecto/blob/master/lib/ecto/date_time.ex
I've been having great success deploying automatically to Heroku via Semaphore CI
Heroku can't do OTP distributed apps natively, so you either just have to not do replication or not use things like Syn and the default PubSub backend.
i've had a phoenix app going for a while that predates distillery and edeliver, i'm from a ruby background so i picked capistrano and exrm. there are probably better options out there now, but FWIW my builds and deployments are still working perfectly, so i've had little inclination to change from what works. I also use digital ocean as my hosting provider. their plans are cheap and i like having the greater measure of control compared to something like heroku.
But firstly you need a frontend which will provide Authorization header with a token otherwise request will be rejected. https://hassox.github.io/elixir/guardian/2015/06/30/api-authentication-with-guardian.html 
Currently going through the Elixir and Phoenix bootcamp on Udemy as my first Elixir experience. I think it's great!
Eh I'm not a fan. I feel like they completely just dropped https://elixirsips.com as a cash grab and are moving on to the next site.
Thanks for the writeup! I wanted to attend but could not due on a previous engagement. Critiques for future works: 1. Less time about glasses. If this was another Sub, I'd love to hear your story, however, I'm here to read about Elixir. 1. Less time about difficulty finding the venue. Again, another Sub, I'd love to hear your story about how hard Austin can be to navigate, but for this, I only want to read about Elixir. 1. More names, less of "The guy". Less of a critque, but I'm going to be to be "That guy" for a minute: The "the guy that wrote Phoenix" is **Chris McCord**, not "Justin McCoord", nor "Chris McCoord". Take your time. This isn't a heavy traffic Sub, nobody's going to "beat you to it". :-)
I second this, it's a great intro to Elixir and Phoenix.
Thanks again for sharing!
Yes, that's the one 
To be more specific on the talks. * **Justin Schneck keynote** Schneck is a co-author on nerves which is an Elixir library for embedded platforms. My original thought was this seems surprising for a functional language to be used in embedded space, but I guess Erlang was used in telephony, so maybe not so strange? Schneck seems like an enthusiastic guy so that's good. This was, alas, when I went to get my glasses fixed, so I missed half the talk. * **Andrew Selder** This was kind of a DIY talk. The guy wanted to do some Elixir (his company doesn't use it currently), and so he created a board with LEDs that lit up to display the status of builds and such. The goals was to figure out how to introduce Elixir. He felt that such a board would interest developers (since it was visual in nature). He said he had to teach himself hardware to do this (and Elixir and nerves). I was kinda impressed how much he taught himself, and felt like not everyone could do this (when some people struggle just with programming, to then figure out hardware setup seems daunting). Someone asked him if TSA felt his equipment (which he brought with him) was something dangerous, but since he lives in San Francisco, the claim is many techies carry equipment like this, so it didn't raise any eyebrows. * **Ricardo Echavarria** A developer from Mexico (Chihuahua, in particular). He was an entertaining speaker, talking about how he set up a web server on a Raspberry Pi (or several of them). I didn't catch all the details. Alas, my thoughts ran to Trump and the wall, and such, but was also impressed how international programming is. * **James Gray/Paul Dawson** James pointed out that he once watched a juggler who did a routine that should have been considered amazing, but people thought it was meh. Once the routine was performed with glow in the dark clubs, the audience better understood what was happening, and were more amazed. Gray was hoping the same would happen with a game he and Dawson had written. I must admit I didn't fully appreciate it, even afterwards. It had something to do with how to persist the data more effortlessly? * **Bryan Joseph** wrote an Elixir to Javascript compiler. I wrote about this in my post, so I'll skip this. * **Geoffrey Lessel** gave a talk that was more for intermediate developers as he showed how to play with Ecto without having to use Phoenix. He did some live coding. There were some basics I picked up from talking to folks nearby. People suggested reading "Elixir in Action" for a decent intro book on the subject. Also, that one *should* learn OTP rather than just learning Elixir as an alternative to Ruby (I'm guessing this is the distributed Erlang part of Elixir). The guy from Erlang Solutions was wondering whether Elixir would make it big or not. He felt that Erlang was more established in Europe and maybe Elixir might work out better (except that Erlang folks, he felt, were language snobs and might not like Elixir for that reason). I have to say "the guy" because frankly I didn't memorize everyone's names. Along the lines of selling Elixir to others, some felt that building out APIs would be the easiest way to accomplish this. Also, that non functional programmers liked the pattern matching and missed it when they had to return to their OO languages. I mentioned a few years ago, when I went to Railsconf or Rubyconf, that there was no discussion of pushing Ruby into universities where it might become more popular. Someone could, say, create content for a programming languages course (say, 4 weeks worth of material) for functional languages and delve a little into the Erlang aspects of Elixir. If a few universities did this, it might help improve the recognition of the language.
&gt; As I understand, using pattern matching without guard could allow compiler optimize the code so that I could call function with O(logN) Instinctively, I would agree with you, but as I timed the different implementations I've found that this is not the case, not always at least. First of all I had to increase the number of iterations to get more precision out of running time (one million of iterations is completed in less than half a second on my laptop). I tried with 10 millions and it looks like Elixir (at least version 1.4) can do some optimisation behind the curtains, because the running time using a guard clause or unrolling the pattern matching functions, is literally the same. For *unrolling* I mean doing something like this defp find_vowels("A" &lt;&gt; rest, vowels, consonants) do find_vowels(rest, ["A" | vowels], consonants) end defp find_vowels("E" &lt;&gt; rest, vowels, consonants) do find_vowels(rest, ["E" | vowels], consonants) end # or (it runs at the same speed) defp find_vowels(&lt;&lt;97&gt;&gt; &lt;&gt; rest, vowels, consonants) do find_vowels(rest, [&lt;&lt;97&gt;&gt; | vowels], consonants) end # etc. etc. I ran each one of them 10 times # guard clause 10 millions iterations 0:02.48 0:02.50 0:02.48 0:02.46 0:02.44 0:02.47 0:02.45 0:02.46 0:02.44 0:02.50 # unrolled pattern matches 0:02.50 0:02.52 0:02.60 0:02.40 0:02.45 0:02.52 0:02.52 0:02.57 0:02.70 0:02.45 When generating the functions through meta programming, you added an `quote do` indirection level too much You just need to generated the function with the unquoted characters 'aeiouAEIOU' |&gt; Enum.each(fn ch -&gt; defp find_vowels(&lt;&lt;unquote(ch)&gt;&gt; &lt;&gt; rest, vowels, consonants) do find_vowels(rest, [unquote(ch) | vowels], consonants) end end) running this implementation 10 times 0:02.47 0:02.54 0:02.47 0:02.38 0:02.36 0:02.62 0:02.80 0:02.59 0:02.51 0:02.52 no surprises here. These are absolutely no scientific benchmarks, I just measured the running time with `gtime`, but it looks like there is no significant difference in performance in Elixir 1.4 and if I need to pick one implementation, the one with the guard clause is the more compact and easy to understand and maintain. I would like to hear from someone with deeper knowledge of the Elixir compiler internals, which I am not, and if you got the same results. If I have time I'll try with some older Elixir version. BTW, thanks.
I'd argue point 2. I do want to know if the venue is a pain in the ass to get to or not to help inform whether I want to go to this or not.
I really liked this article - I feel like you've made a number of points clear here that I've been having trouble making myself to other developers. Kudos.
Several links on topic I have saved: https://medium.com/mint-digital/elixir-deployments-on-aws-ee787aa02a9d#.y889wb1bp http://engineering.pivotal.io/post/how-to-set-up-an-elixir-cluster-on-amazon-ec2/ https://medium.com/@jeffweiss/continuous-delivery-with-elixir-part-1-introduction-826ae5ddb569#.gpug305kw http://teamon.eu/2017/setting-up-elixir-cluster-using-docker-and-rancher/ http://jeremybellows.com/blog/How-to-Create-a-Minimal-Phoenix-Elixir-Server-Docker-Image
The venue was fine, just not what I've seen before. Since it was in a mall-like area, there was plenty of parking. It was a little confusing to navigate initially, but once there, it worked out well. I think some other conference centers (say, the one in Portland) may not really have parking (I walked there or took a train).
Thank you! No more trouble using observer thru Docker anymore :) 