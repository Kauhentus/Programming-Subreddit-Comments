Indeed: https://hexdocs.pm/elixir/Process.html#sleep/1 The implementation (timer wheel) is very efficient though, so it’s not going to hurt CPU usage or anything. The doc is just discouraging bad design. In Erlang a process should not sleep waiting for another process, it should instead wait for a message, or use a monitor.
Actually, I think you can use it for everything, but it is particularly awesome, for any kind of concurrent/parallel computing, since it runs on awesome Erlang VM (BEAM). If you look, it is used for distributed/fault tolerant/highly available systems. I guess WhatsApp/Discord is (at least) partly written in Elixir/Erlang.
Pretty much everything. I am using it both to build web dashboards with Phoenix and to build a huge array of event sourced applications. It's one of the most productive languages I've ever worked with.
In addition to the other answers, there’s the Nerves Project for embedded software, which is popular in the community. I haven’t personally used it, but it opens up different use cases. https://github.com/nerves-project
I use it everyday for work. We have a few servers written with it, including a Graphql API using Absinthe. Some of the servers are processing background jobs and running as Genservers (think chron jobs but with state). An awesome feature that I was using last night was building a bunch of complex database queries and was able to build compostable queries that were dynamically put together using function pattern matching (like method overloading but on steroids). It seems wonky at first glance...but once you realize how to look at problems differently , you realize the power. Since it's a functional language (actually functional unlike languages that do bother object oriented and functional) you are forced to write functional code which is much easier to test and it runs really fast because when a function is done running and it has to garbage collect, elixir doesn't need to check and see if anywhere else in the code is sharing particular variables before garbage collecting them....it knows all the variables are locally scoped to that function so it doesn't waste time verifying it is safe to destroy. It's not uncommon to see microsecond response times in the console. I know some people who use it for embedded software with a library called Nerves. There is also a good effort to build native desktop applications with it using a library called Scenic. I was a big Ruby on Rails / NodeJS guy before....I loved the simplicity of ROR and the speed from NodeJS leveraging an event loop for async IO and how easy it was to setup websockets. With elixir coupled with Phoenix, you get the nice convention over configuration like ROR but you also can handle concurrency like nobody's business, while building servers incredibly fast. Easily one of the most productive languages/frameworks out there. 
For me right now, phoenix is by far the "killer" elixir use case. Coming from a Clojure zealot, I've never had a better web dev experience.
already posted. can you please remove it so we can have just one thread about this article?
I think it's ideal for a startup that needs to move quickly and which isn't in the traditional web app sweet spot for Rails. Compared to Node, Phoenix should get you both better productivity and considerably better performance.
I build an API server for a mobile app using Elixir. It's not something that Elixir is necessarily better suited for than Ruby or Node, but I choose it primarily because I just like the language better. I'm using Phoenix and it is definitely a little more verbose than if I were writing in Rails, but even after spending years writing Ruby/Rails I just find Elixir code easier to read and understand.
I feel that way too after studying it, I'm actually soon to start a new API backend for a service I might take this up!
Learning a new language is not hard, but definately hard to get others on a team involved if they're not used to working with so many different tools.
Please elaborate, I'm on the fence between the two for a web project :)
I also experimented around with using Phoenix Channels to communicate between the mobile app and server. But I haven't tried putting that into production so I don't really know how well it works on a mobile network. It seems like an interesting idea to me to have live-updating data in my app for pages in general though, not just for typical use cases like messaging.
I have just recently came across Kafka, I believe that's one instance of event sourcing model? Just wondering how does that fit into Elixir, and what kind of apps are great fit for event sourcing (so I could maybe dip my toes at it for a beginner project), thanks!
So, "better" is subjective for one, and honestly there are still *lots* of cases where I would go with Clojure now. Buuuutttt.... The main pros for me with Clojure right now are as follows: 1. Elixir's repl is nice and very useful/usable but lisps shit on every other languages repl by default 1. I can write the entire thing front to back in the same language in the same project, there is no separation between front and back 1. I find lisps more intuitive, easier to understand, and easier to write than elixir. Elixir isn't particularly complicated, but it has a LOT of syntax. 1. paredit/parinfer/lispy/whatever there is no better way to write code and nothing can change my mind As for elixir and phoenix: 1. Phoenix's MVC solution is much bulkier than the frameworks I've used in clojure, it's a lot bigger and more complicated and there are way more moving parts and extra dependencies involved and such, etc. If that isn't a problem, sometimes the structure is helpful. Sometimes we need a screwdriver, sometimes we need a workshop. Phoenix is a workshop. 1. Erlang, otp, nuff said 1. Less people will reject a project's language choice `(if (it (doesn't (look (like (this))))))`, which is sad, but the truth. ^(their loss tbh) 1. Really though, the biggest thing, all the parts of the project fit together like puzzle pieces that tell you exactly where they go. Lisps are much more abstract and less structured. Ultimately, I still find clojure in general to be a better writing experience, but the projects lack enforced structure (which can be a pro or con) and are purposefully generally minimalist. Phoenix is one of the few pieces of software I'll go full Stan over, and it says a lot considering the strength of my personal preferences. TLDR: I enjoy writing Clojure more, but that said, it's not infinitely supreme.
I still really love ruby, and use it for a ton of smaller projects, but I've gotten to the point where any time I'd want more application structure or formality around a project, I'd use elixir. The only thing I've found ruby is better than elixir in is some obscure data-structure assembly things (where mutability and object-orientation are beneficial) such as particular types of trees, and small scripts that don't really need any formal structure and performance isn't the #1 priority. For most anything web facing, Elixir is just perfect. Need to read data from a serial port and send it to a database? Easy as pie, just use nerves serial library and tie it to Ecto. Need to build a simple CRUD app? Phoenix has you covered. Want to build a chat app? Pretty easy with a mix of Phoenix, Websockets, and pure OTP. Elixir makes the hard things in other languages easy, and whats hard in elixir is usually very hard in other languages.
If you like Lisps, you might be interested in [LFE](http://lfe.io/) You can intermix LFE and Elixir files in the same application, without any real compromise
If only this language took off instead, I'd be in webdev heaven.
You can still use it! Any elixir module/function is shoved in the `Elixir` namespace: https://joearms.github.io/published/2016-03-13-Calling-Elixir-From_Erlang.html https://github.com/wojtekmach/hello_beam
Angular. Fite me.
I work at a fully elixir startup. We use it for a HR platform that deals with hiring, terminations, payments and lot more. As the guys said for everything. We use conduit to deals with messages from rabbit mq, Tesla, etc. 
I'm still very new to the concepts admittedly but I think a good indicator that event sourcing is "a good fit" when you have a lifecycle where historical data would be important. The thing I learned that resonated the most for me would be that events should capture intent. You can of course use it to build CRUD stuff also. You just may care way less about your events in that case and they would be C R U and D. Re: Kafka I am not familiar, sorry. Were using EventStore. Something maybe cool to check out: there is an elixir event sourcing framework which can integrate with EventStore or even use postgres. https://github.com/commanded/commanded 
Thanks for the article! This is a good example of writing a custom Plug in general.
I grew up on scheme, and the parentheses make reading other people's code an experience with a higher gunning fog index.
Cool thanks man, that's helpful. Will check it out!
So like medium before they tried to monetize it. 😛
I work work both react and elm on the frontend. Though my preferred choice is elm. 
I don't think Medium's way to monetize is the only one possible. They got wrong by raising so much VC money that they have to become a billion-dollar company. 
Oh wow, had no idea they had that kind of expected valuation. Makes sense why they'd just suddenly switch to trying to monetise that way. But yeh I agree I don't think it's the best approach to take. How are you planning to monetize yours?
That where I am at. I have it clear in my head that I am not looking for investment, nor for a huge valuation, just want it to sustain itself, pay server bills. Said that, I think something like Reddit's model is awesome, but with some differences: authors could "withdraw" the money they get paid by readers (we only retain a %). Also a subscription for people that want some extra tools (but not exclusive content). 
Cool stuff. What does this offer over using EEx directly? It's unclear from the article.
I am also not immediately seeing the value add here, It seems like this is just another framework pulling in dependancies like Phoenix would do. It seems weird that the author is trying to sell the concept of just another web framework by saying it is meant to help plug only builds (is that not all web frameworks based on plug?)
exactly, this is the feature that allows BEAM to ensure it is available to handle BEAM scheduler needs without an OS sleep wake cycle. As far as I know the only reason you would really need to tune this is if beam was not the only deployment/service on such a machine. 
Yep, in this case it makes sense to use sleep though.
I don't care what your preference is. I care WHY it is your preference. There's pros and cons to each. Right tool for right job.. Just because you like Elm, doesn't mean you should use it on each project.
Wow! Thank you! I've been using custom module for the same purpose defmodule Parallel do def pmap(collection, func) do collection |&gt; Enum.map(&amp;Task.async(fn -&gt; func.(&amp;1) end)) |&gt; Enum.map(&amp;Task.await/1) end end Parallel.pmap(1..100, &amp;Process.process/1)
I contracted a friend to write me a front end in react with a hand rolled state manager. Nearly everything is functional. I hate JavaScript, but if need be I can intervene and push code to add features easily, painlessly, and without breaking things. My junior loves it.
Having used React, Elm, Vue, and a little Reason I’d have to agree that Elm is hands down the most interesting and fun to use but I’m a lot more productive in Vue.
It's just personal preference though, I just find the developer experience better overall (catches more problems than I can catch with flow, compiler gives great error messages, can fit with GraphQL quite well as I'm able to enforce I'm covering all the types my API returns, and I just find it more fun to develop with). Downsides are the language has a much smaller ecosystem so there's not as many libraries (though considering the state of JS, that might not actually be such a bad thing), and due to TEA there is a lot of boilerplate though you can employ some different techniques to help alleviate some of that. I tend to opt for react more if I'm working with others (if they don't know elm), as I've found some people have difficulty picking it up. Or if I'm doing a mobile (react native) and web app (react), so I can share a lot of the codebase between the two (obviously none of the actual rendering, but the APIs, helper utilities, and even some business logic can be reused). &gt; Just because you like Elm, doesn't mean you should use it on each project. Right... I'm not sure what I said to suggest that?
Great talk, thank you
I assume the point is so you can handle messages in between `handle_continue`s? But if so then can you get a message after init? Often there are cases where you need more setup and you want to continue setting up but want to ensure you're not going to receive any message prior to finishing that setup. Using a send to self accomplishes this because you can put a message in your own mailbox prior to registration of any name meaning your process is undiscoverable and so therefore cannot receive a message. Does handle continue do this as well.or how would you handle that?
I think the handle_continue will run before any events are processed. I think that sending yourself a message can result in a race condition as I am not 100% sure where that process name is assigned. In addition this makes what you are doing explicit. 
Glad you enjoyed!
It will happen right immediately after init finished. &gt; Returning {:ok, state, {:continue, continue}} is similar to {:ok, state} except that immediately after entering the loop the handle_continue/2 callback will be invoked with the value continue as first argument. [`GenServer.init/1`](https://hexdocs.pm/elixir/GenServer.html#c:init/1) docs.
The point is to do work asynchronously _after_ returning from `init` (thus no longer blocking the supervisor) or _after_ returning a value in a `handle_call` (thus no longer blocking the caller). In that sense, it servers the same purpose as using a send to self. However, there are two advantages to using `handle_continue` over sending yourself a message. - The naming convention makes what you are doing explicit (as pointed out by /u/get-finch). As an added benefit, the use of a standard api makes it easier for other programmers to understand your code. - `handle_continue` is called _immediately_ after `handle_call`, `handle_cast`or `init` returns. It is not implemented using a message to self ([relevant code](https://github.com/erlang/otp/blob/master/lib/stdlib/src/gen_server.erl#L387)) and it is therefore not vulnerable to race conditions. This is especially important when `:continue` is returned from a `handle_call`. Besides this, I'm not a 100% sure if a process name is only registered after `init` returns (at the very least `init` [removes the name](https://github.com/erlang/otp/blob/master/lib/stdlib/src/gen_server.erl#L356) if initialization fails)
Hello guys! I'm relatively new to Elixir and have been learning it (primarily Ruby dev), I had a simple question the other day which prompted this article: Why does Elixir use linked lists under the hood and not array, like Ruby? Do give feedback on what can be improved!
So then if you return a continue followed by another continue in the `handle_continue`, that would also run immediately or would you be able to handle other messages in between? Basically, does this block the process while handle continues are executed?
It probably does, at that point you might be better off putting your work into a 2nd process 
I don’t have any feedback regarding improving, but I did enjoy the read. Thanks!
As long as you keep on returning `{..., {:continue, arg}}` it will indeed not process any messages and thus block.
A couple of things \- It automatically uses EExHTML to give safe templates. \- A standard structure for handling layouts and file names, i.e. \`use Raxx.View\` has a default (overridable) location for the template. Helpful to introduce some conventions consistency across the codebase
Not all frameworks are based, need to be based on plug. Raxx isn't. My preference would be to use Raxx and Raxx.Kit, this was more to demonstrate the freedom to use it with plug
Is that not all webframeworks based on plug? Does not imply that all web frameworks are based on plug.
I didnt fully understand this part: &gt; Recursive structure Did you notice that linked lists are recursive by definition? For example, A -&gt; B -&gt; C -&gt; D is a linked list, but so is B -&gt; C -&gt; D, C -&gt; D and so on 
Another way to say this is that linked lists are _inductive_ data structures. Just as the natural numbers are either zero or the successor of a natural number, a linked list is either null or the cons of a linked list. This also means that you can reason about linked lists using inductive reasoning. You can use this to prove that, e.g., `length xs + length ys = length (xs ++ ys)` (where `++` is list concatenation).
Thanks. I needed to read your other article as well to understand.
The only thing I'd add is that technically the last element of a list is an empty list. So in your example it would be [A -&gt; [B -&gt; [C -&gt; [D -&gt; []]]]]
Not necessarily true. &gt; ...technically the last element of a ***proper*** list is an empty list.
Aren't Elixir's list actually Conses, and not just plain linked lists?
Until you encounter an Erlang iolist which might not have a proper empty list terminator :)
About the performance and garbage collection, this post from Bartosz is awesome: [Functional data structures in C++](https://bartoszmilewski-com.cdn.ampproject.org/v/s/bartoszmilewski.com/2013/11/13/functional-data-structures-in-c-lists/amp/?amp_js_v=a2&amp;amp_gsa=1&amp;usqp=mq331AQCCAE%3D) Also, the mytical Okasaki's book "Purely Functional Data Structures" ([and his paper with the same name](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf)) If you are interested on functional data structures and want to learn more about them, you can see much more named (and defined) in this [incredible list](https://cstheory.stackexchange.com/a/1550)
Yeah agreed, was just curious.
Surprised he didn't mention [bors-ng](https://bors.tech). It's pretty widely used by a bunch of OSS projects (being freely available helps), and it's pretty good where I work.
Thanks man appreciate that :D
I think you missed an important point, which is where I thought your 3rd point was going but it did not. These properties exist the way they do in order to maintain the principal of least surprise. Even in sequential programs we can pass data in and unknowingly have it mutated, which breaks in weird and unpredictable ways. The data passed in is never altered, because it's immutable. However these changes bring about some problems, we can't easily know the index of an element without traversing it, we cannot jump to a specific element in the list, we cannot append to the list (without great performance cost). These shiny new properties brought about some new problems... Tail recursion helps (paired with pattern matching) to alter the way we write the code than we would with arrays. We prepend to arrays and loop using functions instead of for loops. This keeps our immutability properties at the cost of writing code in a different way, which is a good trade given that the class of problems we eliminated are some of the most difficult to debug. A small price to pay for a big effect.
Ah yes, great points there, however, I did not want to talk about Big O in this article as that's a huge topic on its own hence why the intentional left out (I did mention it at the end of my article)
Yeah AFAIK they are cons, but I was under the impression that they're the same thing? Hah I could be wrong, could you elaborate a little more on that?
Cool these are incredible resources, thanks man! 
https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node28.html does a better job than I ever could
&gt; bors-ng I had not heard of it. I will take a look
Can you show an example? I guess I'm confused because I've seen these "not properly terminated" linked-lists in lisp and have no idea construct one in Erlang. To clarify, I assume that "not properly terminated" would mean when I take the Tail of a list, the Tail itself is not a list.
It's not a "pure elixir" library (it uses erlang's efirebirdsql library) but having idiomatic wrappers are always great! Anyway, the library seems to be still in early stages, so maybe it's a good opensource project to contribute if someone are looking for it :)
&gt; To clarify, I assume that "not properly terminated" would mean when I take the Tail of a list, the Tail itself is not a list. Correct. iex&gt; IO.puts ["io works with " | "improper lists too"] io works with improper lists too :ok iex&gt; tl ["io works with " | "improper lists too"] "improper lists too" 
Erlang (and thus Elixir) do indeed build lists out of pairs. `[a | b]` generates a pair with `a` as the head and `b` as the tail. `[a, b]` is equivalent to `[a | [b | []]]`. However, people don't use stuff like `[a | b]` in practice since it makes far more sense to use a tuple `{a, b}`.
Thank you! Yes, so I can do the same in erlang `[1|2]`. I had never tried it, but it's so obvious in retrospect. 
why don’t you try it and see what you think? i have no idea what he’s talking about to be honest 
you're aware that Elixir is syntax sugar for Erlang? It's kinda weird to want to try it but not like the syntax )
Elixir is a lot more explicit than ruby. TBH it only resembles ruby in a superficial way. It is fundamentally closer to erlang than ruby. 
In most cases I'd say elixir tends to be more explicit. There are a view global methods from the language itself but otherwise you'd have to write out the full \`Enum.map(\[1,2,3\], fn (number) -&gt; number \* 2 end)\` for example (unless you import the function from the Enum module). &amp;#x200B; Variables could be confused with functions but a few versions ago the compiler will raise a warning, telling you to use parenthesis on methods for explicitness. The formatter you can run via \`mix format\` will automatically do that for you as well. &amp;#x200B; Macros could lead to a lot of confusion but that would apply to most languages I suppose, but you can hurt yourself with every tool if you don't know how to use it :) &amp;#x200B; Why don't you take a look at some real world code examples and see for yourself?
Elixir does not have global variables, there is no ambiguity between invoking functions and variables, no monkey patching, etc. They are two completely distinct languages.
haha. 1) Ruby is awesome. It was, is and will be awesome. Everything can be traced down and understood. It’s one of the most expressive programming languages I have ever used. 2) Elixir only resembles Ruby superficially. It’s a completely different beast. Totally different. If you only spend a few hours one day figuring out what Erlang is, what the OTP is and how Elixir is build on top of it you’re already a better developer. 
Ruby is object oriented, and elixir is functional. They are very different languages. They only look superficially the same.
Hmmm, optional parenthesis in zero-arity function calls? Fortunately, it's depricated.
I've used Ruby, and I understand your complaints. It didn't turn me away from it, but there were irritations along the lines you mention. I wouldn't choose Elixir for the syntax. It's (subjectively) better than Ruby, but the real strength is in the BEAM VM. If you just want to serve a web page, just about any language will do. If you want to build a highly-concurrent, highly-available system, then Elixir can't be beat.
Right, I am glad most of the more questionable features (optional parens in zero arity, imperative assignments, tuple calls, etc) have been deprecated or fully removed early on.
Thanks for sharing.
In this article we see how some kind of HTTP requests/responses can lead to memory issues. We see then how to manage this issues using HTTPoison Async Requests to asynchronously download large files.
Same, it's a functional language, maybe he means Jose Valim's work on ruby and conflated the 2 languages improperly. I would brush up on some erlang though, makes using macros easier. 
Can confirm what most of people said. Elixir is much more readable, check out some libraries on github. While browsing ruby libraries on github is a disaster. There are macros, though. They aren't like meta programming in Ruby, but you need some time to get used to them. I think what makes it so "similar" to Ruby is def/end keywords, which in most of programming languages are replaced by braces. Seriously, why do I like Elixir so much? Because it's so readable and still the code is really short.
I learned Ruby, via Rails, \~ 8 years ago. Still my go-to language due to familiarity with the humongous gem library ecosystem &amp; Rails' full-stack friendliness. Ruby has a widespread stigma for not being especially fast. It's true, but 90% of the time I don't need the performance, or the lags are from something outside my control. I spent two weeks learning Elixir basics in December and really like it. I just need to find a killer reason to jump into it further.
Yes the syntox of elixir is ugly, but that is just the syntax, it is not important.
Shitty optinal parentheses are the only inconvenience here, you will always know where a function is defined. Unless you use Phoenix and its macro madness.
I've never had that problem with Elixir - the language similarities between elixir and ruby are purely incidental. A good example of that is the lack of the 'class' construct from Ruby - all the OO-isms fall away which removes an entire level of ruby-obfuscation.
I think by globals you mean methods that are not namespaced? Those are available via mixins (Modules) or inheritance. Think of the former like elixir aliases. An IDE can help you track down where methods are defined, for example `puts` is defined on the Kernel module which is mixed into the Object class from which all classes descend.
Barewords are popular in both Ruby and Python, and possible in Elixir but the linter auto fixes it now to a proper function call. They're fine in Ruby (I work in a large codebase and would say that barewords make for cleaner refactoring), but I can understand being thrown off by them if not used to them. Fortunately, if you don't like them you don't need to use them.
I write ruby and elixir daily for work. It took almost no time to view them in a different light. Outside of the syntax similarities its a completely different beast. It's also fairly explicit which is one of my favorite things. I really enjoy writing elixir (it re-kindled my joy for writing code). Give it a real shot. It's a pleasure to work with. 
As always great post and great blog!
Thanks a lot :-)
&gt; Barewords are popular in [...] Python Can you clarify that? Python doesn't invoke functions without parenthesis. (There are things like decorators that invoke functions without parenthesis; maybe that's what you're referring to.)
Thanks. I misremembered. Perl shares barewords with Ruby and is one of the few languages that does. Given Ruby history from Perl, that could actually explain it. Is also less meaningful since python is much more prevelant than Perl. My bad.
&gt; there is no ambiguity between invoking functions and variables This isn't true, the syntax for a variable and calling a zero arity function is ambiguous.
It's a little more than just sugar- the Elixir language has features that Erlang does not (homoiconic macros, protocols, structs, nested modules) and Erlang has features Elixir does not (text preprocessor macros, parse transforms, record sugar). They are very similar though
I'm happy to hear this, but do you happen to have a source? I haven't noticed any warnings in my projects.
I ported over this really small library from ruby: [https://github.com/ghbutton/coupon-code](https://github.com/ghbutton/coupon-code)
Macros in elixir are lexically scoped, which is a godsend. Strange things can happen, but it's not hard to find what's up (and subsequently the documentation) and they happen only in a tightly controlled area.
Didn't know michael jackson was a react guy :P
But it does emit a non-skippable warning, forcing you toadd parens, and the behaviour will be removed in future versions altogether.
I am not sure about warnings without trying it, but consider using the built in formatter. I use it to format my code on save, and i feel like it makes live a lot easier if you don’t have to worry about formatting conventions. The formatter will always put parentheses on zero story functions, so there is that :)
I think the best comparison would be to Java and JVM languages (e.g. Scala). Where Erlang is Java and Elixir is like Scala. Just like the Java language was never the real reason people used it *(I mean just look at it)*, it was the JVM that was the real powerhouse, the Java language was just the initial language that ran on the JVM. When you built and run a Java program, you don’t get some Java that then gets interpreted line-by-line (like Python/Ruby), you run JVM bytecode that Java was compiler down to. Then after some time, people started thinking the JVM is pretty kickass, but thought Java itself was kinda sucked to work with, or they didn’t want to go down the enterprise OOP rabbit hole and instead wanted to be able to use a functional paradigm (or maybe just not have to have 50 character class names), but still wanted all the awesome things the JVM offered (portability, GC, years of proven production use), thus languages like Scala were born. And because the language designers were smart, and didn’t want to just throw away thousands of existing libraries, they crafted a way that will allow you to use existing Java libraries in Scala (sound familiar?). And this works not because Scala is compiled into Java and then the whole thing is run as a Java program, but because both are compiled into directly into JVM bytecode, the JVM doesn’t even know that some code was written in Scala and some in Java. And, you can pretty much take the above but swap Java for Erlang, JVM for BEAM, and Scala for Elixir. José realized what an incredible piece of technology the BEAM is, and how powerful these OTP concepts can be, however they were hidden away by the fairly obscure (ugly) syntax of Erlang, thus Elixir was born, offering a more pleasant syntax and modern language features (a — good — package manager with mix, data polymorphism constructs with protocols, custom data structures with structs) but still leveraging the real powerhouse of BEAM and OTP, and because it compiles to BEAM byte code it also has the ability to use all the Erlang libraries (this also works the other way around too — you can even use mix in an Erlang project). Elixir is it’s own independent language, just like Scala/Kotlin/Groovy are their own. This is unlike languages like TypeScript/Elm, which actually compile into JavaScript, and that JS is what is run, thus making those languages limited by what JS can offer and how clever they can be with how that JS is written by the compiler. I know when I first discovered elixir, and I know a few others also had this misconception, that Elixir was like TS in that it was compile into Erlang code that was then run, rather than directly into bytecode.
The compiler will give warnings too. The only time it won't is if there's no possibility for confusion. e.g. It includes the module `Foo.bar`, whereas `bar` by itself will give a warning as `bar` could be a variable the only way to know is to look at the rest of the code. 
It is the same function, but instead you name the template .text.eex instead of .html.eex.
&gt; that Elixir was like TS in that it was compile into Erlang code that was then run, rather than directly into bytecode. Actually that was more correct. Elixir compiles into Erlang abstract form, which is the AST the Erlang compiler produces after parsing a source file. After this it goes through the Erlang compiler as per usual. This is effectively compiling to Erlang, only not using the textual representation of the syntax. It does not compile directly to bytecode, or the low level "core Erlang" IR, which is somewhat different to Erlang and is what other BEAM languages compile to (LFE, Alpaca, Luerl, etc).
Hello there! I am a bot raising awareness of Alpacas Here is an Alpaca Fact: Alpacas do not pull up plants by the roots as cattle do. This keeps the soil intact and decreases erosion. ______ | [Info](https://github.com/soham96/AlpacaBot/blob/master/README.md)| [Code](https://github.com/soham96/AlpacaBot)| [Feedback](http://np.reddit.com/message/compose/?to=JustAnAlpacaBot&amp;subject=Feedback)| [Contribute Fact](http://np.reddit.com/message/compose/?to=JustAnAlpacaBot&amp;subject=Fact) ____ If you liked this fact, consider donating [here](https://github.com/soham96/AlpacaBot/blob/master/README.md)
Syntactic sugar would mean that Elixir compiles to Erlang before going to Erlang, much like Objective-C parsed to C before being compiled in it’s infancy. This is not true AFAIK It’s more like Scala or Kotlin being able to be compiled to the JVM just like Java and being able to share code because they compile to the same bytecode.
If the ruby code you looked at was full of global variables it was terrible ruby code. You can litter almost any language with globals though.
I build a library for converting Thrift to GraphQL: https://github.com/sambou/thrift_ql_ex
Elixir is great for highly concurrent connections. How you send the file over a socket depends on what the client needs to do with it. HTTP supports range requests, so you can easily stream portions of a file to support seeking in your (audio?) client. One way to do it would be with Phoenix PubSub. &amp;#x200B; You'll definitely want to stick with Postgrex and Ecto for database access.
Ok, thanks! I'll probably come back here (or StackOverflow lol) needing some help with that socket/pubsub stuff eventually, but definitely looks like what I need in the docs. And I meant to ask if you prefer one specifically of Postgrex or Ecto? Are there any significant differences in usage or performance?
Range requests will enable the user to play at any given point of the file. But if you want to be able to downgrade the quality you may want to do something like HLS, which is just serving those small http files after your encoder generates them for you.
You use Postgrex *with* Ecto. Postgrex is the driver Ecto will use to access PostgreSQL. 
Oh alright, thanks for clearing that up!
You can look at the Membrane framework. I personally don’t have experience with it, but it looks like it can do what you want. https://www.membraneframework.org
Interesting, this does seem like it specializes in audio streaming and whatnot. It looks like I'd still need Phoenix to serve to the web though in addition to Membrane for managing the audio streams, right?
Depending on your end goal, Membrane may be a bit overkill, at least at first. If your just going to be playing audio files in the browser, you can just have Phoenix serve the file. Then if you want to get fancier and not serve the whole file at once, you can switch to streaming the file over a websocket through phoenix, unfortunately playing that stream in the browser gets a bit trickier as you’ll have to familiarize yourself with the WebAudio API (which is actually really cool), however the WebAudio API is fairly low level, but fortunately there’s a [NPM package called web audio stream](https://github.com/audiojs/web-audio-stream/blob/master/readme.md#stream-api) that provides some abstractions around it to make that process a little easier. Membrane is really cool though, and you could definitely use it to stream audio over a websocket, but so can `File.stream!/3` (you’ll have to base64 encode either before and or with `Stream.map` and decode the chunks in the browser). Membrane would be great if you had to process the audio beforehand (convert the file type, stitch multiple audio files together, etc.)
I hadn't heard of HLS before, but I think it's a bit above my needs so I'll probably stick with sockets. Thanks!
Yeah, Membrane does look like it has a lot more functionality than I need, so I'll start with just Phoenix and add it later if necessary. And thanks for all the info about WebAudio stuff, I didn't know I'd need all that on frontend! Using something like WebRTC instead of Sockets wouldn't make sense in this case, right (because it isn't P2P or bi-directional)?
The way rails requires helpers and all sorts of other things automagically is what makes it *feel* like global variables every where. The code I’m looking at is very standard rails code
Outside of the extension to add syntax highlighting, the only one that I’d say is an absolute must install is [ElixirLS](https://marketplace.visualstudio.com/items?itemName=JakeBecker.elixir-ls), which is the fairly new Elixir Language Server. With that you’ll get close to IDE level functionality, as it will provide autocomplete, documentation lookup, formatting with mix format, debugger support, among several other goodies. I also feel I need to note how good ElixirLS is, I like to dabble in various languages so I’ve tried a bunch of other languages servers, and most were fairly good, but the autocomplete would be kinda slow/not great, especially compared to the TypeScript LS which is so good that it a) got me to download a Microsoft app willingly for the first time in years, and b) immediately made me convert from VIM to VSCode after I swore off all other editors for a few years after getting annoyed with Atom. ElixirLS is the first language server I’ve used that has come close to TypeScript’s. And it’s also pretty new, so it’s likely going to get even better. I haven’t really felt I needed any other extensions outside of that, as well as there aren’t really that many available anyway. The only other one that might be worth installing is [ElixirLinter](https://marketplace.visualstudio.com/items?itemName=iampeterbanjo.elixirlinter) if you use Credo, which will give you the warnings/errors in the editor like the ESLint or Rubocop extensions.
You might want to look at the Discord engineering blog [https://blog.discordapp.com/tagged/engineering](https://blog.discordapp.com/tagged/engineering). They cover a lot of how they architect the service and the tech they use which includes a lot of Elixir and covers what parts of audio streaming you might want to use Elixir for as well as the parts where other tools are more appropriate.
Thanks! This article was pretty informative https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b
someone has been lucky using intellij idea?...by the documentation seems to be quite complete and intellij is probably the best IDE that exists (really my productivity increases exponentially when I use it, even above emacs) but unfortunately at least for me it doesn't work, I only get syntax coloring but not autocompleted nor jumpt to code...and that I have configured correctly the sdks
Honestly elixir Ls makes vim work really well for go to defy and autocomplete
Same here... :(
Wow cool, have you tried out the other one, Elixir VSCode? That's the one I've been using, not sure how it compares
Thank you, I didn't know about ElixirLinter. Pretty useful! 
No. &amp;#x200B; You can do it in Elixir/Erlang, but since you already have the code it makes more sense to just update the code to use more of the c++11 tools. You also have the developers to do that already. With Erlang/Elixir you're gonna get stuck for years trying to learn how to do the same stuff that you're already doing in C++ as they aren't "low ceiling" languages. 
It works great for receiving, processing, and passing along of perishable data. So, something like a fairly fast server might be a correct use case for Elixir, or perhaps something like "a stream processor" of discrete data sent over a protocol that have to be pruned and pre-processed before being sent to a second engine that analyses and stores the final results in a database. Stuff like that works quite well with Elixir especially if you want to use symmetric multiprocessing without any effort. In the meantime, I'd ignore words like "distributed", "fault tolerant", "high availability", etc., they're just buzz words, in practice this is true in only very specific cases. &amp;#x200B; Beyond these use cases you start hitting problems due to a lack of tools, databases, etc., so you might end up forced to reinvent the wheel all the time, in which case you might not even bother with the language. 
There's also google app engine. https://cloud.google.com/elixir/ 
You have to take a look to gigalixir: [https://gigalixir.com/](https://gigalixir.com/)
if it's just an elixir script, you could easily just run it via cron on some cheap shared host, or even on your local machine.
Second this, the owner is very cool too. I worked with him on a difficult project.
Would aws lambdas work for your needs? https://hexdocs.pm/aws_lambda_elixir_runtime/readme.html
If its just a script maybe put it in the instances crontab?
digital ocean is a pretty good idea. I use Linode, which offers basically the same thing. Also, I'm using python, but i'm doing something similar. If you go for the VPS option(what digital ocean and linode are), my only pro tip is gonna be to install screen. you'll ssh into the box, run screen, and then run 'iex -S mix. using screen, will allow you to disconnect from the ssh connection, and then reconnect to your iex program. Which may not be something you really need. But I recommend screen. I use it, because i also have my python script print data to the console, and to be able to read that console, I have to use screen, to reconnect to the terminal session, that started my script, or that data is lost to me.
If I ssh into a compute engine shell - do I just run \`elixir --detatched -S mix run --no-halt\` and it'll continue running even if I shut the ssh window?
Heroku free dynos good for it.
Heroku. It removes most of the hosting overheads, there’s a free tier, it’s been extremely reliable for all of my projects. 
Cron
I have used DigitalOcean like you said and it runs amazingly fast on the $5 a month droplet. I used tmux to persist the terminal session after closing it.
Second this. Timed lambdas ftw. Azure/GCP have timed functions as well, but I know with AWS you can "bring your own runtime" now, so that's neat!
That data case is very interesting. Is there any examples online you know of? Of how processing data through it is better or more maluable than another language?
Digital ocean + edeliver to remotely deploy your project, it works perfectly and cost almost nothing to host it there!
Yes. I've only played with google app engine a little bit to be honest but I remember it running tmux inside the terminal you launch from within the browser. That means that any process you run will stay as a session once you shut down the ssh terminal.
We use it together with Erlang at the company I’m working at, Elixir is less idiosyncratic and slightly more modern looking. It’s used to create mobile network software that has to accept large amounts of individual data packets/requests and process them according to some rules. At the same time, the latencies tend to be very high so the products aren’t used for true “real-time” systems. I’m not sure anything like this is available on the Internet, the products are usually tailor made for specific customers... and contain confidential data. On a more simple level, I’d say you can try to create a simple server that can scale easily without having to think too much about parallelism and other stuff. This fits well with Elixir. The supervisor thingy can be very useful. Beyond that I wouldn’t get too much excited about Elixir and Erlang, they’re very ghetto. I often have to analyze some parts of the data with various statistical and computations methods, Elixir as well as Erlang don’t work **at all** for this use case, so I use c,c++, and python for that. There’s also nothing for ML, data science, and you know in general to data visualization, we often have problems working with external databases as most of them don’t have clients for Elixir or even Erlang, so you have to go around dealing with http stuff, or write your own client. Another problem is actually the vm on top of which all processes run in Elixir, it doesn’t interface well with foreign code, there are ways to go around it but honestly compared to Python it’s a massive pain in the butt. Then if you want to build GUI stuff, good luck with that. Text processing, regular expressions, are also a pain. General math stuff in general is also nonexistent. To conclude, Elixir is great for data processing where you can split it in small chunks and work on them from there asynchronously, it’s also easy to implement data exchange protocols. But beyond that things can get very difficult if you want to use it for more general stuff. Sry for the overly long reply. 
Tmux! Tmux! 
I use screen, to reconnect to my tmux session. 
Don't be sorry that's great info thank you!
Nightly forced reboots are a no-no for many Elixir projects
Agreed, but this is just a script. 
I would vastly prefer a writeup of all of this content.
I agree. I find the videoization of content a disappointing trend. Videos are good for many things, but this is not one of them
Everything you would ever want to know can be found in the [pipe operator documentation](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2). I also don't think this needs to be a video. No offense to the OP, but a lot of these videos could be replaced by a link to the docs.
In general, you'd write input |&gt; function1() |&gt; function2() |&gt; function3() |&gt; function4() instead of function1(input) |&gt; function2() ... The first is recommended by [credo](https://github.com/rrrene/credo), and is also the preferred way according to [the docs](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2).
Good point.
The pipe forward operator is by far the greatest thing to happen to a functional language
[removed]
Monitor the queue time for each query, we use Prometheus for that with https://github.com/deadtrickster/prometheus-ecto If the queue times are high increase the pool size. Also if possible, upgrade to the latest db_connection that uses a better looking technique
I'm using [vim-elixir](https://github.com/elixir-editors/vim-elixir) for syntax highlighting and have the following autocomds set to format my code on save: autocmd BufWritePost *.exs silent :!mix format % autocmd BufWritePost *.ex silent :!mix format % I've got [neomake](https://github.com/neomake/neomake) set up with credo to provide some linting. I use [vim-test](https://github.com/janko/vim-test) to run my tests in context. Finally, I'm using the aweseome [alchemist](https://github.com/slashmili/alchemist.vim) plugin to provide code-completion (along with [deoplete](https://github.com/Shougo/deoplete.nvim)), documentation lookup and jump-to definitions. 
`vim-elixir` as Vim currently do not have built in support for Vim, and that is it. `vim-lsp` is handful as well, but TBH it isn’t “must-have” as built in Vim features are good enough go 99% of my usecases. 
I use vim-ale with with elixir language server. This blog post was useful in setting it all up https://www.mitchellhanberg.com/post/2018/10/18/how-to-use-elixir-ls-with-vim/
In addition to vim-elixir and vim-test, I'm using [TabNine](https://tabnine.com/) for autocompletion and it's pretty amazing. It'll get whole lines correct with just a few typed characters. I tried to get it working with the Elixir language server but didn't have much luck. I'm guessing the semantic completion is really good.
Spacemacs in evil-mode.
You should definitely monitor the VM extensively. Inside: Erlang memory (total, processes, ets, binary, atom, atom\_used), erlang system info (port\_count, process\_count, atom\_count), erlang statistics (run\_queue). Outside: CPU, memory,... Everything else is application specific: Maybe you're interested in plotting latency, length of parsing,... 
Came here for this comment
82.35, obviously
I've found alchemist.vim to provide some nice "IDE" like features. https://github.com/slashmili/alchemist.vim
Plugins: - [vim-elixir](https://github.com/elixir-editors/vim-elixir): Syntax highlighting, filetype detection, and indentation. - [alchemist](https://github.com/slashmili/alchemist.vim): IDE like features. - [vim-textobj-elixir](https://github.com/andyl/vim-textobj-elixir): To treat a `do ... end` block as a text object. - [vim-mix-format](https://github.com/mhinz/vim-mix-format): Trigger mix format with a vim command. The latter two are not really needed, but can be handy. I also use ALE and YouCompleteMe, but I would not recommend installing them only for elixir; instead, just find out how you can get elixir to work with your current linter / autocomplete setup. Some handy settings: - `iabbrev &lt;buffer&gt; pp \|&gt;`: Typing `pp` will insert a pipe operator. I find this handy since the pipe operator is a bit awkward to type. - `setlocal spell`: Elixir's syntax highlighting is clever enough to only spellcheck comments, so it's nice to enable this. - `setlocal formatprg=mix\ format\ -`: Handy if you often use vim's built in format. If you don't select a big enough region your indentation might get ruined though. - `call add(g:gutentags_project_info, {'type': 'elixir', 'file': 'mix.exs'})` if you use gutentags, this will automatically create tags when you're in a mix project. Some handy keybinds (require the terminal feature introduced in vim 8.1): - `map &lt;LocalLeader&gt;s :terminal ++close iex -S mix&lt;CR&gt;` Run `iex -S mix` in the terminal. Note this will close the terminal after `iex` terminates. So if there is an error in your program the window will dissappear right away. Remove the `++close` if you don't want this behaviour. - `map &lt;LocalLeader&gt;S :terminal ++close iex&lt;CR&gt;` Start `iex` in the terminal. - `map &lt;LocalLeader&gt;t :terminal ++noclose ++rows=20 mix test&lt;CR&gt;` Run `mis test` in a terminal. Finally, if you like to use conceal to replace some operators with unicode replacements, these can be handy: syntax match elixirCustomOperators "&lt;-" conceal cchar=← syntax match elixirCustomOperators "-&gt;" conceal cchar=→ syntax match elixirCustomOperators "==" conceal cchar=≡ syntax match elixirCustomOperators "!=" conceal cchar=≠ syntax match elixirCustomOperators "&lt;=" conceal cchar=≤ syntax match elixirCustomOperators "&gt;=" conceal cchar=≥ highlight link elixirCustomOperators Operator highlight! link Conceal Operator 
I generally have used this Instruments config to monitor the BEAM: [https://stephenbussey.com/2018/09/24/elixir-probes-replacing-elixometer.html](https://stephenbussey.com/2018/09/24/elixir-probes-replacing-elixometer.html) &amp;#x200B; For scraping specifically, I think you'd want to look at: run queue, memory (binary vs processes vs total), process count. 
I'm using [https://github.com/neoclide/coc.nvim](https://github.com/neoclide/coc.nvim) for language server support and the [https://github.com/JakeBecker/elixir-ls](https://github.com/JakeBecker/elixir-ls) language server. Also [https://github.com/elixir-lang/vim-elixir](https://github.com/elixir-lang/vim-elixir) for syntax.
Open source contributions. Look for bugs reported in hex packages you like, or just in popular hex packages. Submit PRs to fix those bugs. You'll want to point interviewers to these PRs. They'll look at how well you communicate with the maintainers as well as the quality of the PRs (tests, consistency with the rest of the code base, etc...). Don't stress about making perfect PRs in the beginning. If your first isn't great then learn from the feedback, fix it, and repeat. Just be sure to be respectful of the maintainers' time. &amp;#x200B; You could also do a side project. I wouldn't recommend it because your lack of production experience would almost certainly show. Open source gives you an opportunity to contribute to code that runs in production for a lot of companies, with ample code review and feedback from the maintainers. 
I normally don't recommend elixir to beginners because it's a smaller job pool and smaller candidate pool so there's less opportunity to make mistakes in the interview process. Also, comparing to other techs, I see way less junior roles. I usually recommend Javascript which has tons of job openings (frontend and backend) or something that is popular where you live if it's harder for you to relocate (like PHP and Java, usually). With that being said, I would look for full-stack roles and prepare for that, doing a full project with HTML+CSS+JS+Backend+Database deployed somewhere like heroku. Having a solid project from end-to-end open sourced stands out event among non-juniors. Like /u/davidkovsky mentioned, open source contributions are also good, but it actually may take longer than a stand-alone project and be less educational for someone that has a little bit less familiar with the ecosystem.
As one redditor said, Elixir is a pretty niche language....so most companies adopting newer languages is typically smaller companies which have more flexibility (since they typically aren't supporting tons of legacy code), which they can't afford to train junior talent and instead lean on a handful of more senior developers. There are a few decent sized companies which may be accepting more junior applicants....checkout Toyota Connected and Weed Maps. You can also checkout [https://elixir-companies.com/hiring](https://elixir-companies.com/hiring) or a few other sites which list elixir jobs like, [http://plataformatec.com.br/elixir-radar/jobs](http://plataformatec.com.br/elixir-radar/jobs). If you don't have luck landing an Elixir job, I would try learning some Ruby on Rails (which has a similar syntax, although a different programming paradigm), since it is more widely used and has lots of job opportunities for junior developers. Also, many of the Ruby on Rails shops are dabbling with Elixir for some of their services so you might find yourself in a good position at a Ruby on Rails shop where you could help lead the Elixir charge. 
* vim-ale (with elixir-ls) + to use built-in fixers to mix format * vim-elixir for syntax highlight * for testing -- my own simple plugin ([https://habamax.github.io/2018/12/13/vim-meets-elixir-mix-test.html](https://habamax.github.io/2018/12/13/vim-meets-elixir-mix-test.html)), because why not? :)
Open-source contributions are going to be your best shot at developing some kind of portfolio. Having some demonstrable experience actually working on Elixir projects (whether independently or contributing to existing projects) goes a long way in convincing a prospective employer that you do indeed have some understanding of how Elixir development works. Combine that with non-Elixir-related experience working as part of a team (e.g. in class projects and such) and you've got a good angle to hopefully bootstrap yourself into a junior role (open-source contributions certainly help here, too, if you're contributing meaningfully to existing projects). If you haven't already, I'd look into learning at least the basics of plain old Erlang as well, and trying your hand at some pure-Erlang projects to get familiar with it. Sure, you might not need to ever touch Erlang, but it's useful (and attractive to employers) to be comfortable with doing so as the need arises (e.g. if you need to tinker directly in the realm of Cowboy or some other Erlang dependency of an Elixir project/application). It'll also give you a good foundation for how exactly Elixir improves upon Erlang, and how they both fit into the broader OTP ecosystem.
Ok this is not /r/cscareerquestions but I don't get how you interview a recent graduate and then point lack of experience as feedback ? What are you expecting ? Moreover when it's for a niche language ... And you even went beyond what would have been expected of you by learning a lot of the language beforehand. You have the right attitude to succeed in this industry.
Wish I could go, but I have a conflict 
doesn't high demand imply that the available tickets should have been booked by now?
&gt; It's high demand. Just not *that* high. I kid. But I get what you mean.
Well, obviusly. That's marketing terms for "we aren't selling enough tickets and we are freaking out" :) Strange though. I've been to the one in Barcelona and it was good and well organized IMO.
One of the reasons I fell with Elixir is pattern matching and how it can be extensively used all over the code. In this video we see pattern matching with tuples, lists and maps, a bit of control flow and recursion.
it’s one of the hottest things about this language once you grok it and I am entirely OK with other languages copying this feature because I think it reduces bugs and leads to more concise code
I absolutely agree with you. In my team we also use python (mainly for machine learning) and when I'm coding with python (or javascript) I really miss pattern matching! Some other languages, like Scala, have pattern matching but not so well designed like in Elixir
I never miss anything more than pattern matching, i dont get to write elixir in my dayjob, but lets hope someday it will change.
Do you have the time to write some Elixir/Phoenix apps for your own?
Not necessarily. Conference organizers have some fixed costs and costs based on the amount of attendees. For example, a venue has a fixed cost based on a minimal amount of seats and if you want more seats, you have to pay more. The tricky thing is that you usually have a deadline to communicate how many seats you want. Catering sometimes work in the same way. So if you are actually selling a lot of tickets and you have covered the fixed costs, you may want to keep the tickets cheaper for longer to aim for that venue extension and have more people at the event. Another alternative is that this is part of their marketing plan because they have noticed from past events that extending the early bird deadline pushes people to buy the tickets before it is too late.
I think the key is a fundamental redefinition of the = as “match” instead of “assign”, which pretty much everything else (such as argument pattern matching and destructuring) derives from. As freebie you also get an “anywhere assert” that will bail the process if some intermediate state verification fails... and since process respawn is essentially costless, you only have to code the happy paths... it’s really amazing how all these VM features work together (thanks to the work done in Erlang) and with Elixir introducing “real” macros, it’s just awesome. The binary pattern-match syntax is also awesome, makes parsing headers/files/streams trivial... TCO lets you write cleaner, more beautiful recursive loop-style code without worrying about blowing a stack... what is not to love about this language? The only quirks I’ve found (IMHO) with Elixir’s implementation is the necessity of the “pin” operator (which makes sense once you understand the problem of matching plus name rebinding, it’s basically a “don’t rebind this, just try to match on its existing value” operator) and the complete lack of a native integer-power infix operator (nor the ability to make one... only certain operators can be redefined as custom infix or unary operators but \*\* is not one of them, not sure why... I suppose you could do something weird with one of the handful of other overridable ones but...)
Yes, I agree. Pattern matching leads to cleaner code and we get rid of almost all "if-else" syntax! I think I'm going to do a small episode about pattern matching in binaries.. which is pretty awesome! 
Nothing serious. Mostly i do web stuff with python/typescript so i tend to avoid phoenix. I have done some vanilla elixir and im more keen on OTP and learning about the Beam itself, as thats were the true power comes from. 
The cool think about Phoenix in web development is the scalability you can get. With Django or Rails it's pretty hard to scale horizontally without spawning multiple processes/servers and load balancing the traffic across these servers. 
Thats correct. However scale (like whatsapp scale) is something i never have had a need for. Few people do. In fact a flask app run by gunicorn scales good enough for my needs. The beauty of elang is the failure model, and its fantastic! Its so polished over the years and the actor model is the best in the business. When you combine that with the goodies the language gives you you are set!
Don't forget that there's [`Kernel.match?/2`](https://hexdocs.pm/elixir/Kernel.html#match?/2) for when you _only_ want to match and never assign. Very useful in test cases
I guess you have encode the credentials in the headers: `def process_request_headers(headers) do` `credentials = "username:password" |&gt; Base.encode64()` `[{"Content-Type", "application/json"}, {"Authorization", "Basic #{credentials}"} | headers ]` `end`
That also fails :/ &amp;#x200B;
Yes! Super useful for filtering with pattern matching and Enum.filter
i'm not who you asked but the main thing holding me back from phoenix is how little documentation and guidance there is on the (not-so) recent Contexts stuff. there isn't a book that covers it and the phoenix docs only skim the surface. that coupled with my unfortunately novice-level experience with databases makes phoenix much more intimidating than any other web framework
Its not beginner friendly, but the docs are great imho
Which web framework do you prefer?
Aren't you hitting a proxy issue? [https://github.com/benoitc/hackney#proxy-a-connection](https://github.com/benoitc/hackney#proxy-a-connection)
Learning it myself after Ruby for 4 years. Don’t allow the comments here to discourage you. Follow your interests and use dead-ends as encouragement to focus/work harder. Eventually you’ll land. Elixir is tough, but not impossible. It’s catching on, so make time to keep focusing. Keep your head up!!! 
Nothing like Ruby. The getting-started doc will prove it to you in an hour.
This just sounds like a regular MVC app to me. I'm no developer, but my first experience with a .NET MVC app resulted in a feeling very similar to what you're describing. A sort of, "wtf is going on here? Where is this being called from? what's loading that module? Why is everything split into a thousand pieces?" Fortunately for everyone, Phoenix's documentation is g really nice. Even a peasant like me can read it and still learn something.
im a crypto trillionaire, gotta pump those numbers up
I'd say, regardless of the language you'll be choosing, it depends on the operations you're actually going to do. Also keep in mind that making a lot of different services into a monolith could impact the performance of the rest, depending on what it is. For example, having a worker doing heavy tasks on a server will most likely impact the web servers performance as it would take most of the resources. You could get away with something like a kubernetes cluster where different elixir apps comunicate through, which is not tied to a single set of resources, and you can scale a bit easier if needed. 
You would use tuples, as they provide constant access.
You could build your list as a binary tree. This would give you O(log n) binary search, but random access and inserts would not be O(1). The best solution depends on how your access and insert patterns are.
Yeah tuples do give us a constant access but generally it is advised not to use tuples as a large collections of elements right ?
As in the implementation where the child nodes are in 2i and 2i+1 locations ?
You might want to check out the source for the gb_tree module. It’s a self balancing binary search tree.
Sure. Thanks a lot.
I was, and you were right. The issue was to unset my proxy settings. Thanks for the hint man! 
Your data structure would need to be a tree instead of a list: [https://en.wikipedia.org/wiki/Binary\_search\_tree](https://en.wikipedia.org/wiki/Binary_search_tree). This has some trade-offs though, since accessing e.g. the first element or inserting elements is a lot slower than in a native List. The tree structure could be implemented by having every node be a tuple: \`{left, value, right}\` where left and right are child nodes. There is an article here that describes how the author implemented a binary search tree in elixir: [https://medium.com/@sashaafm/developing-an-algorithm-and-data-structures-collection-in-elixir-part-ii-binary-search-tree-8c18e2294dee](https://medium.com/@sashaafm/developing-an-algorithm-and-data-structures-collection-in-elixir-part-ii-binary-search-tree-8c18e2294dee) &amp;#x200B;
**Binary search tree** In computer science, binary search trees (BST), sometimes called ordered or sorted binary trees, are a particular type of container: data structures that store "items" (such as numbers, names etc.) in memory. They allow fast lookup, addition and removal of items, and can be used to implement either dynamic sets of items, or lookup tables that allow finding an item by its key (e.g., finding the phone number of a person by name). Binary search trees keep their keys in sorted order, so that lookup and other operations can use the principle of binary search: when looking for a key in a tree (or a place to insert a new key), they traverse the tree from root to leaf, making comparisons to keys stored in the nodes of the tree and deciding, on the basis of the comparison, to continue searching in the left or right subtrees. On average, this means that each comparison allows the operations to skip about half of the tree, so that each lookup, insertion or deletion takes time proportional to the logarithm of the number of items stored in the tree. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If the code is reasonable, one server sounds fine. Your biggest issue is likely to come from database contention / table locks. But a single Elixir app can handle tens of thousands of concurrent sessions on a box without blinking.
Thanks a lot for the info.
What comes to my mind first is generation of pdf files, registrations, file downloads, document creations etc But what I really meant, that I should have specified, is how much Physical Hardware power I'd need, like how many processors and their frequencies I see that people say Elixir can handle a lot of heavy stuff without a sweat drop, but the only physical examples I have are from Pinterest, which some articles said they had 150 servers and now they have 5 after migrating to Elixir 
I should have specified before, but I meant in physical hardware power, see the other answer here 
The only real way to find out is writing parts of your application and benchmarking it to see how much hardware is required. If you want to have dedicated hardware, you can rent servers from a cloud provider with comparable hardware and run benchmarks there before you make a purchasing decision.
Got it, thanks
It looks like we won't have a booth or anything, but we're going to be sending two engineers to Code BEAM SF. If you want I could have them reach out to you while you're there.
I know this post is only for demonstration purposes, but I really feel that regexes are the wrong tool for the job. Matching the regex probably takes longer than the rest of the code combined, and adding some logic that triggers when you see a “.” shouldn’t be too hard the way that the code is structured.
*Wooo* It's your **4th Cakeday** get-finch! ^(hug)
In most cases parser generator will be faster and simpler than regex. 
Where are you located? We're hiring junior developers: [https://hire.withgoogle.com/public/jobs/contractsimplycom](https://hire.withgoogle.com/public/jobs/contractsimplycom)
Well this is more than just an elixir question. If you need reliable services, you probably want to have multiple servers running. I personally recommend a load balancer, then 2-3 instances of your application. If you are using AWS or Google Cloud, etc...you can start with larger instances and always scale down if you see that your peek cpu utilization rates are low. But I would say that you would be more than safe probably with small sized instances since not all 700k residents will be using the websites at once. But I'm just guessing, you'll have to see what the CPU utilization actually is. 
Well, I'd be confident that my laptop could probably do it. A 4-core, 2 GHZ anything would probably be fine.
Im on my mobile but something like: Repo.preload(query, [childkey: [grandchildkey: [ :greatgrandchild]]])
Or joins and update the structure in the select
If you go the join route make sure you understand the different types. Null values can mess with your head
Absolutely
Recently started working on a Project Management System with Elixir/Phoenix. I intend to focus on simplicity mostly along with a chat-first workflow. And autotagging system based on cards, owners and chat messages. I am still a few commits old but intend to work on it in my free time. Will update the goals and objectives in README soon :) [https://github.com/code-shoily/karma-werks-core](https://github.com/code-shoily/karma-werks-core) (It's got nothing yet)
Good for him for being as successful as he is, but he sounds a little delusional about this coin. Interesting fellow
Nice article! Elixir’s Flow module is also useful for these sorts of things. https://github.com/plataformatec/flow/blob/master/README.md
Thanks @zer01! Flow looks interesting, do you have any opinions about Flow vs Task?
Thanks for the article! I have a question though. In last example you showed how concurrency hurt the performance. But my question is why? As, as far as I understand it, Task spawns a separate process for each calculation, so it should take time as much as the longest of the calculation instead of sum of the calculation. Is it the sole hassle of creating a process and then stopping it that results in a worse performance?
Yeah, I would say that the increase in time is mostly due to all the extra operations required compared to a simple `Enum.map`: * Spawn new processes * Await results from all processes * Merge the results with `Enum.into` That's a lot of extra work, and if the processing task is very fast, this extra work is very significant. In the case of the HTTP requests, the overhead due to all those tasks is still there, but is tiny compared to the time it takes to make a HTTP request. Great question by the way, I will update the article to give a short discussion on this. Thanks a lot!
I believe the two solve different problems. Flow is a much higher level of abstraction than Task. You already know what Task is and how to use it - Flow, on the other hand, is geared towards processing pipelines of data, with the option of concurrency. I’d wager that Flow uses Tasks for much of its concurrent work. 
Thanks, this is a really good answer.
Flow uses GenStage in order to have parallel computation with backpressure
Any concurrent operation has overhead associated with managing the concurrency. In serial operation, there is no management. Since in this case the management becomes more time consuming that the operation itself, you spend a large chunk of time just doing management and a small chunk of time doing actual work. Without concurrency it's 100% of one core doing work. You should only use async_stream when a send/receive and/or spawn of a process is negligent in time to each individual operation. In the case of math operations, this is something CPUs are highly optimized for (even though the BEAM is not). Feel free to check the time something takes with `:timer.tc/1` to find out how it compares with those things.
It does from what I understand, but it also attempts to mask/mirror the protocol of things like the `Enum` library, so in a lot of cases you you can convert your synchronous operations to performant async ops by replacing Enum with Flow (at least that's my understanding). It would in theory make your synchronous code exactly as readable as your first example, but parallelize it under the hood. TL;DR - I don't have enough good things to say about Flow or GenStage, or really any of the other projects in that vein. They really seem to understand the problem domain and solve it in a way that's sensical and awesome!
So you're right in that there *is* overhead with spawning processes, but I'm not sure your estimation of scale is accurate. I've never had a situation where I've had to consider the overhead of processes, because the workloads I expect Elixir to deliver aren't CPU bound. If you're doing CPU intensive things, erlang/elixir is probably not the way to go, but for network IO or the other stuff Erlang is suited for, spinning up and maintaining processes is basically negligible from a performance standpoint. If you ever run into a situation where you can't process messages fast enough you can use a technique called load shedding to basically drop messages using the excellent `:pobox` library (https://github.com/ferd/pobox). Good for network buffers where clients may not read fast enough as a "poor man's" backpressure mechanism. 
FYI, here's the talk Abstract Web developers have typically been presented with a choice between performance or a productive development environment. With Phoenix, developers can have both while enjoying a wonderful set of abstractions for working with thenew web, making streaming data to browsers, native mobile application or embedded clients a breeze. Finally, we will see how Phoenix leverages the Elixir language and the Erlang VM for writing maintainable and scalable code.
You can join and pipe into a preload, and if you’ve satisfied everything called for by the preload, it will not generate &gt; 1 query and will populate the resulting data structure in the same conventional way. Really just depends on how much of that nested data you want to use, it’s probably overkill if you just need one or few columns out of many.
Beginner question: Does this lead to the same result as pattern matching with the pin operator?
In some cases yes, but it is "safer" in some ways, as it will _never_ assign. I may be wrong, but I believe there are some cases when pinning would lead to different behavior than the simple `match?/2` would
Very new at this so maybe a lot wrong but it works pretty well I think... [https://github.com/Logflare/logflare](https://github.com/Logflare/logflare) We have one endpoint to take in logs but a plug is doing all the checking of api keys and some other things. We have an authenticated endpoint to post logs to but then also a public endpoint for the Cloudflare app which take the Cloudflare hooks and checks the token from them. That deals with the JSON we get from the hook, alters it a bit (depending) and sends it back. &amp;#x200B; The logs one we have a view for but doesn't really do anything. The Cloudflare hooks we just respond with send\_resp and set the response code and accept and it's simple and works you just have to the json encoding yourself. &amp;#x200B;
This is so useful
The code that the 'mix phx.gen.json' produces does some great stuff using 'with' and the fallback controller. I'm sure you've seen it, but if you haven't it's worth looking to see exactly what's going on.
`Task.async` is linked to the current process. `Task.start` however is not. That should work
This should be done with Task.Supervisor so that it gets started up under a supervisor which will ensure it executes. Linking it with Task.start_link or spawn_link is unreliable because the calling process (to which it gets linked) may exit anytime after, say for example if the next request crashes. If that happens it will crash your background task when nothing was wrong with it. In general you should avoid using spawn and friends and just use the Task, Agent and GenServer models to run your processes unless you are doing something really specific and you know what you're doing.
Excited for this being my first European tech conference 🤘 Moved to Munich from Denver last month. 
Yeah and it gets even more amazing once you start spreading out the load across several nodes. Love it!
One of our engineers Chris Freeze has something he's been working on for this: https://github.com/cjfreeze/power_control We have a blog post that is ready for publication about it. I think it is supposed to come out this week.
I made this post a while ago thinking I'd be working on this project in Elixir. https://old.reddit.com/r/elixir/comments/aqm7y2/would_elixir_be_a_good_choice_for_an/ I've been struggling with Phoenix for the past few days though and I'm seriously considering switching to Go. Why are there so many goddamn auto-generated files? Someone help please, there really aren't that many resources online. 
I'm in the process of learning Elixir (3rd week). It's not easy coming from javascript and php, but I really like the challenge. Sounds like you could benefit from learning Elixir a bit better and the jump into Phoenix. This book is great, it helped me quite a lot: [Programming Elixir 1.6](https://pragprog.com/book/elixir16/programming-elixir-1-6) , also I'm doing this course in parallel: [Developing With Elixir/OTP](https://pragmaticstudio.com/courses/elixir) ... excellent material with hands on practice. I guess the next step would be: [Multi-player Bingo with Elixir Phoenix Vue Elm](https://pragmaticstudio.com/courses/unpacked-multi-player-bingo-with-elixir-phoenix-vue-elm) ... Don't give up, you can alway learn Go later :D If you like you can PM me and I can share my materials.
Cowboy 2 uses one process per request, so in that case, the process/task would likely crash soon after. Task.Supervisor is definitely the way to go.
I'm working on a statically typed language for the Erlang VM, it's called [Gleam](https://github.com/lpil/gleam) There's a thread to chat about the language on the [Elixir forum](https://elixirforum.com/t/gleam-a-statically-typed-language-for-the-erlang-vm/20349/16)
I hear that, there's a lot of convention and boilerplate with Phoenix. Have you considered using Plug without Phoenix? Or Raxx? Both would be a much closer experience to Flask, Express, etc.
I've started to learn Phoenix! It's quite neat. I'm already thinking about the possibilities of having a truly multi-process platform. Also I've made a [somewhat conceptual](https://codereview.stackexchange.com/questions/214140/storing-temporary-data-in-ets-for-example-using-ets-in-a-web-wizard) thing, and I'm not sure if it's good or stupid...
I believe Phoenix was conceptualised based on Rails. Rails is all about conventions, which I really dislike. Thank you for the library suggestions!
I built a METAR map to display weather conditions at nearby airports with LEDs hidden behind an aeronautical map. Album: https://imgur.com/a/z6Rmb7u Source: https://github.com/schrockwell/metar_map 
Wow, this looks awesome. 👌
thanks for that, it will be very useful
Aw man, just saw another post about doing this and wanted to build one. That one used esp8266 boards, which I have a bunch of, but then you get to work with logic level shifters and stuff. Wish it was easier to get pi zeroes. 
I am in the process of building an elixir app that connects to a ham radio KISS modem(tnc) and speaks the ax.25 protocol to allow hams to interact with packet radio and APRS in a more modern way. I feel like im slowly rebuilding direwolf in elixir by accident, but it’s been a lot of fun and I’ve learned a ton in the process. The binary pattern matching in elixir is so beautiful for protocol work. I just love it. 
Interesting! I havn't done Elixir on RPi before. Can you share some insights on that? Is there any difference from developing for use on typical PCs?
I see you tried to use an arduino. Did you switch to the pi so you could use elixir? Looking at your README, you install python gpio tools. How do you use python with your elixir app? Do you have a python script that uses your elixir app as an api? I couldn't figure it out skimming your repo.
I think I was originally going to try controlling the LEDs with the Arduino, but never ended up even trying it. Too much effort to integrate WiFi and the relatively code to control it how I wanted. I merely installed the python tools for the `pinout` utility for my own sanity. :)
No difference at all! The Pi 3 3+ has four cores, versus one core for the Pi Zero, and it does compile and run appreciably faster with more cores, but other than that it’s just a plain old install. I thought about going the Nerves route, but it wasn’t worth the extra effort for a one-off project like this. I like the flexibility to SSH in and tweak and upgrade it easily.
So the Pi only outputs 3.3V on its GPIO, and the LEDs require 5V levels, so I did [this great hack](https://hackaday.com/2017/01/20/cheating-at-5v-ws2812-control-to-use-a-3-3v-data-line/) to get the data signal down to the appropriate level - no level shifter required! You do lose a “sacrificial” pixel in this technique, but I had enough extra LEDs anyway.
So you're able to control the LED's directly from elixir?
Yup, via [blinkchain](https://github.com/GregMefford/blinkchain), which actually uses [this library](https://github.com/jgarff/rpi_ws281x) behind the scenes
I'm not an expert in either rails or Phoenix, but my general feeling has been that the major similarity between the two is that they both are based on the MVC pattern. Aside from that, I've found that Phoenix tries to make everything that is happening as explicit as possible, whereas Rails favors convention and "magic". Things have changed a bit since this was written, but I think it still provides a good insight into some of the differences in approach: [https://dockyard.com/blog/2015/11/18/phoenix-is-not-rails](https://dockyard.com/blog/2015/11/18/phoenix-is-not-rails)
Awesome. Thanks for the info. Will definitely try it out.
I've been experimenting with Phoenix lately. It really does seem to be a bit more explicit than Rails. I like Rails. But I've used it on and off for several years now(all tiny toy projects, I'm far from an expert), and the "magic" of Rails is hard sometimes. Like Rails does a lot for you. Which can make you productive. But, I've got no idea what certain things do, and the "magic", makes it hard to get in there and tweak stuff. &amp;#x200B; You can also do so much stuff in a line of code or two, that trying to sit and use my programming logic skills isn't even helpful. I just have to read through docs and tutorials, until I find the one liner I need. I can't just figure out what code I need.
Oh alright, I'll try check out Plug and Raxx. Thanks for the suggestion!
Awesome, thanks! I found the PDF, so I'll look over it.
Yeah, I don't have much experience with Rails/Ruby so it's all pretty different.
This is the one I've been waiting for. Thanks for posting!
It's up: https://dockyard.com/blog/2019/02/25/powercontrol-improve-the-performance-of-your-nerves-device
This makes me very happy :) Having an HTTP client from the core team makes a lot of sense. I hope they add a simple implementation of collection pooling too :D
Might want to read the last paragraph.
I'm excited to see that the CA was extracted out. Working with erlang certificate store proved to be very difficult (to the point of just disabling SSL validation on dev). 
I got too excited before reading the whole article. I am sure someone in the community will build a connection pool based helper for this :)
It's so great to see this client released! Big ups to Andrea and Eric for making it happen. I wrote a client that wraps Mint in a higher-level interface. Connection pooling and one-off connections are supported out of the box. I call it Mojito. https://github.com/appcues/mojito Check it out, I'd love any feedback!
Your wish is my command :) https://hexdocs.pm/mojito/Mojito.html
Please add some tracing! One of the reasons I jumped to Go for an aspect of my system is because I needed decent tracing. None of the libraries I tried in Elixir gave me anything reliable. Really hoping this library is built upon to offer something similar to Go's `http` package in the standard lib.
Clever name.
This article made me want to understand more my CPU and it's capabilities, something that I've always wondered about but never really had the time to sit down and study it, I guess now is the time ^^ , thanks
I was checking out the source code and the authors have added an implementation of connection pooling in the architecture doc: https://hexdocs.pm/mint/architecture.html#content
It by default it uses PG2 by default indeed and with that if a node dies the messages are lost indeed. But you could also use Redis where you can configure this to be much safer. &amp;#x200B; Haven't tested that, will surely give it a try sometime to see if I can build a test case around that.
Note this is the same article from 2017, and just a few days ago a couple Discord engineers on HN commented that it needed an update: https://news.ycombinator.com/item?id=19238221
I don't see anything with respect to how this works across multiple machines, is this just a batch processing version of Flow?
Awesome. I didn't expect to see Rust here. It's insane. I'd planned to learn Elixir or Rust in the next spare time period I'll have... It seems that it will be more Elixir **and** Rust...
I would probably say, stick to elixir until absolutely necessary that you need native code, then go for it.
[https://elixircasts.io/json-api-with-phoenix-1.4](https://elixircasts.io/json-api-with-phoenix-1.4)
Likewise! Elixir is very easy to learn imo, but Rust has been a whole different beast, definitely the most unique programming language I’ve tried to learn.
Isn't 5,000,000 concurrent users not really impressive now though?
So the strategy then is forcing you to look at the README to ensure it's correct and "signing off" by changing the version. Simple and effective; nice one! In general I try to Dockerize my apps so the install instructions can just be `docker-compose up --build`, but a README is still a valuable complement especially for HOWTOs on common tasks for new developers.
An Elixir to eñErlang code transformer at AST level: https://github.com/jxub/doppelganger Rigjt now, squashing some `defstruct`-related bugs and improving the usage ergonomics. The goal is to have it integrated in the major editors and just click right on the file and "transform to Erlang". It would be similar to the Jetbrains Java to Kotlin converter. 
I don’t know how this library works, but since the data source is external, multiple machines can just pull data from the processing queue individually.
The account was suspended so there's about a 100% chance this is spam.
As with most languages, the greatness or awfulness of it depend a fair bit on the developer using it. Some languages give you ample rope to hang yourself whereas others have fairly strict rules to keep things in order. I think of a spectrum like JavaScript to C#. Many issues with Ruby are down to common practices that propagated/were cargo-culted in the Ruby community. Fortunately things like monkey patching and `method_missing` are finally being considered bad practices. One of the most...disappointing attitudes in the Ruby world is "ruby is so readable that it's self-documenting so you don't need to write comments or document code and you shouldn't because they're clutter." This sort of mentality leads to unmaintainable messes. And over/misuse of inheritance so a developer new to the project has no idea how things work unless they start reading stack traces. So far the most encouraging thing about Elixir has been the community attitude on documentation, explicit over implicit, and a host of other things that lead me to have a lot of faith in the future of Elixir. And of course it's just awesome in general.
inheritance in Ruby? I thought it was well known that you should favor composition over inheritance (even in languages like c/c++/c#, java).
Simon Zelazny from Grindr did a great presentation at ElixirConf2017 in Bellevue on a similar topic that I really enjoyed: https://www.youtube.com/watch?v=bodV9Tk_kpQ
I'm relatively new to Elixir and Phoenix too, but out of the gate there are only two packages I'd install if I were you: * [Credo](https://hex.pm/packages/credo) — static code analysis * [Sobelow](https://hex.pm/packages/sobelow) — security analysis for Phoenix
depending on how complex this is you may get away with plug+hackney or plug + new mint library. phoenix is also great but may be a bit heavy for this purpose 
I've heard that a couple of times, but I don't really get what people mean. Heavy in what sense? Performance, memory usage, code complexity? In theory, yes, you're pulling in a large-ish dependency, but there's no actual downside to that apart from a slightly longer time to compile your deps. And in practice, for any end point you're going to pull in lost of the things phoenix does, like an http server, JSON parser etc.. You're saving a small weight with Phoenix itself, but then you don't get all the help and convenience that phoenix gives you.
Phoenix includes PubSub, Presence, Views, Templates, Context, and its own opinions of how you should structure your application. If you're building a small JSON API why do you need all of that? You can accomplish it with Plug.Router, in less code, and in a format that most folks who come behind you can grok in a quick glance. Heavy in the sense that it includes numerous things you don't need for a simple JSON API. If you can accomplish the same application in &lt; 10 files and a few hundred lines of code, why use Phoenix which will generate far more than that?
phoenix is built using plug. so it’s not a this or that. it’s simplicity of the code and smaller footprint 
Are you trying to build a reverse proxy? I would just use the new mint package as others have mentioned and just use Plug to build a reverse proxy. If it is not a reverse proxy you could use Phoenix.
Yes that is a lot of stufd, but what actual effect does that unnecessary code have? Memory usage? Speed? Startup time? Maintenance burden? The latter I could maybe see, except that actually all of the dependency bumping is done for you by phoenix, so to me it's simpler. I take your point about flexibility, except that Phoenix is a convention that people are more likely to understand than whatever roll-your-own you invent for yourself.
Not a reverse proxy to start. I was thinking phoenix and maybe other packages I'm not aware of. This will have a use UI to setup "bins" or endpoints, also to make it easy to replay a data to another endpoint.
&gt;I was thinking phoenix and maybe other packages I'm not aware of. This will have a use UI to setup "bins" or endpoints, also to make it easy to replay a data to another endpoint. &amp;#x200B;
For something of that kind, I'd definitely use Phoenix and Mint or HTTPoison for an HTTP client.
I didn't know about credo . I just tried it out with a new Elixir project and its awesome!
I don't have real experience with anything but rails, but I've actually spent the last week and a half looking at other web frameworks(fully featured like Rails, and minimal like Flask/Sinatra), and for what I want to do. Elixir, with Phoenix, seems to be the best option for me. Because it's a bit more mature than some of the Go/Rust alternatives, and seems to be a bit more explicit in it's code than Rails is. So I'm just commenting to say another internet nerd is in a similar situation to you, and seems to have ended up at a similar conclusion.
I think you'll find the ecosystem is plenty mature in that erlang has been around for ages and using erlang libs from elixir is painless
Would you say that Elixir is easy to manage even when you deploy to multiple nodes? I'd hate to get comfortable with Elixir on one server but have it collapse when I need to spin up multiple servers.
I see a few recommendations for using mint. As a new user, use httpoison and save mint for when you need more fine grained control over your http library. Mint is not meant to be an easy tool to use, but rather a more basic tool with more contt
We have almost the same tech stack (ruby) as you described at my work, and we are using elixir for Websocket delivery in a multi node setup. One thing elixir gets you that the others do not is when you need to scale horizontally phoenix Websockets will deliver message to a client no matter which server in the cluster sends the message and what server the client is connected to right out of the box. 
I use to be a Node.js advocate and did a lot of Node development. But in recent years I am all about Elixir. I have done some Ruby on Rails as well as Go and would still recommend Elixir. There are less mature libraries but it's partly because a lot of the stuff is already baked into the language (or Erlang). It is going to be harder to find Elixir developers but if you hire smart and passionate people they will be willing to learn. We use it for all of our services and wouldn't have it any other way. It keeps our server costs super low and attracts really passionate and smart talent. I highly recommend it.
That's really interesting! Could you tell me a little more about your websocket setup? When in Rails, how do you ask Elixir to send a message to connected clients? Is is a Redis pub-sub situation or similar?
I appreciate in input! Since you have Node experience, what would you say is the biggest thing you miss now that you use Elixir?
A lot of Phoenix is about horizontal scalability and concurrency over multiple servers/clusters.
Elixir is awesome and its easy to pickup its not like u have to search for elixir devs only. Just any ROR dev will learn in 5 6 days.
Distributed systems are basically elixir's bread and butter
We have a lot of different services that need to deliver messages via Websockets so built an elixir service that's sole purpose in life is delivering Websocket messages for the rest of our tech stack. The elixir project connects to Kafka and for every service that wants to deliver a message it produces a message on it's own Kafka topic for every user and the elixir service routes it to the correct user.
I'm a long time Ruby/rails dev who's got about 2.5 years of production elixir experience over multiple projects, greenfield and otherwise and I honestly don't want to work in anything else for the near term. For Rails guys, it should be relatively straightforward to pick up, as well. I'd recommend getting familiar with the data types, followed by recursion patterns and pattern matching/flow mechanisms to pick up the language, then maybe OTP and metaprogramming to get deeper knowledge. Compared to node and rails, I think you'll find elixir performs quite favorably and for cheaper, even on one node. The ecosystem is quite active and mature, thanks to its compatibility with Erlang. The concurrency patterns are easier to understand than either of the former and you often don't need external dependencies like sidekiq for background processing or handling state storage for jobs. Rust is fascinating but seems like overkill for most web projects I'd want to throw at it and with a steeper learning curve. Hope this helps!
Great to know! One more question, how is the data encoded? Is it just a JSON payload or is it something more tricky? I was thinking protobufs, but I may as well ask since it seems you've already solved this problem!
Node have a very large ecosystem which is not there in elixir, this is the only thing i miss a bit about elixir otherwise in terms of performance, code writing n other terms i don't miss node now, I'm using elixir from last 3 years in production servers.
That's basically the entire backbone of OTP and by proxy elixir... that's definitely not going to be a problem.
I have been working with elixir at work for a year now. Initially my team's was hesitant because of perceived lack of "stable" libraries in elixir. A year down the line I can say those fears were unfounded. But you may want to pose this question in r/programming or a more general subreddit. Or ask people who have built the similar stuff in other languages. For instance while starting out this project we wrote a prototype of the app in go and elixir just to benchmark. Go was faster. But I am glad we didn't go that route. 
I'll agree with you for the most part. I've had a little trouble finding libraries. Needed a library to decrypt pgp files. There was one but it required compiling something else with go. Other than that it's been great. Erlang documentation is kind of difficult to read in my opinion. My only complaint about using erlang libraries.
I used node extensively for the past 3 year - and still do, I've learned Go and used lightly in the past couple months, and I'm currently learning elixir. IMHO - Use nodes the service is small, and just sends requests and responses, because a) JS is easy to learn, but hard to master. If you're building something big, you'll probably shoot yourself in the leg if you're not experienced enough, and b) single threaded, anything more than creating variable will be a bottleneck - Go is incredibly easy to learn, incredibly fast, and was built with concurrency in mind. Use it if you have many short lived tasks that you want to execute concurrently (for example a function that makes some calculations and "return" the result) or because you want to get your service up quickly - Elixir is functional. That means it has the benefits of FP, but has a steeper learning curve if you're not familiar with the concepts. It's also built with concurrency in mind, and - unlike Go - process/threads supervision in mind. Use it if you have time to learn, and your service have long live concurrent processes that must be reliable and fault tolerant (for example a service for chatrooms, where every chat room is in it's own process, and must be up all the time for a very long period) 
Oh, and I know nothing about Rust except that it's dominating system languages domain. While Go was originally built for that, it was widely used in back end services
I've found that most libraries I've needed were already baked into the core of OTP or had stable and active Elixir libraries. I did find one that didn't exists, so I made it as my first Elixir project. As an experienced Ruby developer it wasn't hard to figure out how to make it happen. Now I don't worry about the library thing, especially since I try to avoid dependency creep in general.
Credo is indeed awesome. I have it setup to run automatically after my tests run (if the tests passed). The author of credo also made a documentation analysis tool which is quite nice: [inch_ex](https://github.com/rrrene/inch_ex). I use these with [mix_test_watch](https://github.com/lpil/mix-test.watch) which automatically runs all my tests and credo every time I save a file in the project. This keeps the feedback cycle really short, and encourages me to write tests the perform well.
+1 for using the right tool for the job. Depending on the use case, I'd even advocate not using a library at all and just using `httpc` built into OTP. When building a REST client library for example, I've been a big fan of [Tesla](https://github.com/teamon/tesla) for its plug-based design approach and being http adapter library agnostic which helps you prevent a situation where you're needing multiple HTTP clients to satisfy dependencies. (It's easy to end up having to install both hackney and ibrowse...)
I personally think this is a moot, because anything can be "multiple node'd" these days with auto scaling. I think the better question is, how does it perform under a multiple node deployment. The answer is, very well, but you won't need to for the same reason. Because of the beam VM/gen server pattern you don't see servers go down or fall over. You scale nodes out of an emotional / risk factor, not a performant factor.
Downsides of elixir are diminishing as time goes on. However your question really has to lend it self to the problem being solved and the resources you have. For example, if you need to do machine learning as an input for something, it might make more sense to integrate with tensor flow with python. If you are needing to scrape websites once a night and push the results to a searchable index, lambda and node might be better. Excluding specifics like, maturity of a specific field / need for a mature domain specific library. Then you run into things like finding devs. I don't mean good devs, but devs. If you are developing an app that needs to be up in a month or two and won't be updated ever, and short lived and you have a great background in XYZ. It doesn't really make sense to do something different. However, even if you have to hire devs, writing impractical code in elixir can be negligible. So having more junior developers under guidance can go a surprisingly long way. I didn't see many people commenting about actual downsides, so I tried to give you a good perspective. 
I'd say overall the libraries are of higher quality than Ruby and Node. The packaging system is great as well.
If you use edeliver(deploy directly on a VM) or docker/kubernetes to take more of a container approach managing multiple nodes is cake.
The bit about the maturity of packages is totally true. Of course all the big ticket items are there but as you know the devil is in the details. Lots of advanced bits of e.g AWS communication or authenticaton or a legacy SOAP interface are not or barely supported (these are all real world experiences of mine). But the good news is all of these problems are surmountable with the help of Elixir’s fantastic, second to none community. So if you are willing to work through these issues and set expectations accordingly you will have a great time with Elixir. If you expect a smooth ride with lots of options you are not going to like it. 
Good developers will work in any language, and as many will attest, if you use a less used language, you get fewer, but stronger candidates. The people who will apply are more likely senior devs with a few languages under their belt already, and are hungry for a challenge. Go is great, and your product will certainly work wonderfully if you invest in all the go-isms. But it is strictly imperative (not a negative, just a design choice). Node is fine, but I also find many node devs bring bad JS practice with them because they think they're "full stack". Maybe your Node devs are great and it won't be problem though. IDK much about Rust, but Rust feels like overkill to me for most applications.
&gt;but hard to find good Node devs that aren't already employed That problem would apply to a lot of great devs regardless of language. You typically don't find an unemployed good dev, you poach an employed one.
\&gt; The downsides of Elixir seem to me that devs are harder to find People say this all the time, and it's true. But in my experience it's more important to find \*good developers\*. Good developers who are willing to learn a new language are all you really need. Elixir isn't a particularly difficult language to learn.
Finding a strong Go/Node/Rust dev is no different than finding a strong Elixir dev. This is because finding a strong dev, period, isn't an easy task. Elixir is a very forgiving language and inexperience on the team won't hinder you as long as your hire strong developers. The BleacherReport team stated exactly this sentiment after 18 months in production. I don't think this is true of Node, which will leave many gotchas for you to step on, and I don't believe this is true of Go and Rust because expressing exactly what you want isn't always going to be straight forward and often leads to sacrifices for the sake of time. My advice, find strong developers in any language and learn together. The more experience you can bring to the team is only bonuses. I also don't believe the ecosystem to be in an immature state as some have mentioned, it's pretty well on par with the rails community IMO in terms of availability of packages.
Not sure what was said here because it was deleted but you should not use protobufs unless you're talking to another language (and this is kind of discouraged). Erlang/Elixir has built in distribution primitives which allow you to talk to subsystems on the same machine in the same way you'd talk to a subsystem on another (Erlang/Elixir) machine.
I would advocate for Go if with websockets you also had a CPU intensive workload. For I/O heavy workloads, and given that apparently you and your team are into functional programming, Elixir is a solid choice.
We began the move from Ruby on Rails to Elixir/Phoenix about 3 years ago. Haven’t looked back, it has been easier to scale up and our analytics tells us it has an average response time that is 10x better latency even for our fastest ruby routes. We primarily moved to it originally to leverage GenStage and Phoenix Sockets. After building a couple new products in it, we became fully invested and then began the iterative process of slowly moving over things when we could. Any new features were then designed with elixir instead of ruby. Some things I noted over the years * RoR apps have terrible boot times as they grow, elixir apps can hit reload avoiding boot times entirely. * Scaling ruby apps can be painful, I found this to be the exact opposite in elixir, it made it easy. * Handling sockets works out of the box with Phoenix and the provided JavaScript Frontend library can integrate easily with any SPAs you may need to support. * Ecto is far superior to ActiveRecord and allows me to perform more performant queries without having to drop into raw SQL (battling ARL is not fun) * Ecto lets me create schemas and light models with validations very easily, ones that I can reuse and make portable. * Multi app support means you can be monolithic without having to think about the finer details. * Dealing with asynchronous and/or concurrent activity is a breeze via Tasks, GenStage, Flow, Sagas and more in elixir.
It depends what they do. In this case each user is connected to multiple rooms that needs update in soft real time.
Couldn’t agree more. Learning Elixir &amp; Phoenix myself. Here’s [a list of some companies](https://elixir-companies.com) now using it.
Sure, but you do have to realize that deploying elixir to multiple nodes can be about the same as deploying multiple Ruby apps. You'll just also have the option to mesh your nodes together so they communicate in a much more fine grained mesh, but distributed OTP is a large topic and just because distributed is easiest in erlang or elixir, that doesn't mean it's easy relative to other topics
Interesting. I have a side project which use Redis with the "RPOPLPUSH pattern" as a queue and have a homemade genserver pulling items from it. I tried using genstage but as my data is not continuous I've never completed the implementation with storing the demand of consumers etc. Maybe Broadway will feel more accessible for my use case.
&gt; why wouldn't you use Elixir over Node, Go, or Rust? Do you need to spawn and manage a bunch of OS processes (e.g. are you shelling out/your code is basically doing scripting)? The BEAM uses preemptive interrupts. This means your threads get roughly the same amount of scheduled time. You may not want this Erlang is mature but it is difficult to understand at times. I'm not sure it's any harder than the other languages you mentioned though Are you planning to run Kubernetes or any container orchestration? I feel like the BEAM solves many of the same problems as Kubernetes (although we ran them together) I loved working in Elixir. It did get a little frustrating when I had to go outside of the Elixir/Erlang bubble but inside the bubble it is wonderful. So much is already done for you
I was looking for advice on how to best tell Elixir to send a message to all clients from Rails. Protobufs seemed like a good option to encode the payload from Rails, but JSON is probably just fine
I mean if you come to r/elixir to ask this - maybe not the best idea. However given that you have a willing to learn dev team, Elixir might be the best choice. I'd say the better question would be : what would be a better choice, which entirely depends on what do you want to use Elixir for ? \- If you want to do just another static / basic website without real time, maybe stick with familiar language because of the familiarity. \- If you want to do some language specific task, like say containment / crypto then use Golang, machine learning then use Python. Language and framework familiarity might help you there. .etc. The list could goes on depends on the requirement of you project. Maybe based your choice from that. 
That's fair. My initial thought was that Elixir users could best tell me what they missed about other languages, but I see that people seem to love it! I'll end up asking elsewhere as well for more rounded feedback
functional style (hindley milner) static typing - but looks like your alternatives don't include that either. &amp;#x200B; good thing about elixir is what it lack - immutability, objects - makes things simple to understand.
Yeah I would stick with simple json unless you have good reason to deviate.
How come `python3-gpiozero` is a dependency (as noted in the README)?
Because the `pinout` is really useful - mostly for my own sanity. :)
Sorry I only just noticed the redundancy of my own comment!
there are marginal pro's and heavy cons to using protobufs to talk to a browser. JSON is basically native JS so there's no deserialization, which negates a lot of the performance gains you get with protobufs I would suggest letting elixir handle all websocket connections and if they need something from ruby, make it a service that you talk to over some API - depending on the performance needs protobufs might make sense here, but I'd start with an http API and gauge the performance from there. Adding protobufs to your stack is much more complex than sticking with your standard http APIs elixir is much better at handling websockets than your typical ruby websocket setup. Channels in phoenix is the best websocket abstraction in general webdev ecosystems right now - it competes (if not beats) with go in terms of runtime efficiency and wins handily in the amount of code you'll need to support those websockets further, since websockets are stateful connections it's extremely difficult to distribute out messages when you have multiple nodes in something like ruby/node - with phoenix it's built into channels - you just have to connect your elixir nodes and every node will automagically know how to push messages out no matter if the connection exists on the same node or a meshed node
Did you end up writing something about it? I've failed to be able to use swarm to restart a process while moving the state to the new server and I'm looking into integrating horde with libcluster
Same for my reply - same response. We're nothing if not predictable.
I agree with you and I'm just guessing what was in the deleted comment, but the approach you're talking about seems very similar what AnyCable does. (https://anycable.io). Maybe it's worth to check out to get some ideas. 
If you can work with job-style async communication then you can use a sidekiq compatible worker system like https://github.com/akira/exq or https://github.com/sorentwo/kiq
Yeah as a new user I wouldn't recommend using mint directly as it aimed at more niche use-cases. Although you could look into using mojito which is based on top of mint and is meant to be easier to use for common use-cases.
Could you recommend some learning resources that you found helpful? I saw a course on Udemy and was thinking about diving in. 
I just started learning this beautiful languague to make a API personal project and discover the new possibilities :)
Hey! Could you summarize differences between Gleam and Alpaca?
Certainly! Gleam and Alpaca have similar type systems, both quite heavily inspired by ML languages such as Elm and OCaml. Gleam's unions are always tagged, while Alpaca support untagged unions (though this may be removed due to problems arising from Alpaca's FFI with Erlang). Alpaca has an OCaml inspired syntax, while Gleam's syntax is more inspired by Rust and Elixir. Alpaca's compiler is written in Erlang, while Gleam's compiler is written in Rust. This makes Gleam's compiler faster but more difficult to install (at least until I have build pre-compiled binaries for people to download). Alpaca has a system for typing ad-hoc processes and message passing, though it is limited and currently not expressive enough to implement abstractions such as Supervisor. Alpaca and Gleam both have FFI that allows users to import functions form Erlang/Elixir/etc and annotate them with a type, though Alpaca's FFI may do some runtime type checking to catch incorrect types. Gleam is currently under active development, Alpaca's development has been slow this last year. Gleam has a standard library in development, Alpaca does not. Gleam has a first class module system, Alpaca does not though may in future. Gleam currently does not have atom literals, Alpaca has atom literals.
Hello there! I am a bot raising awareness of Alpacas Here is an Alpaca Fact: The Spanish Conquest almost wiped out 90% of the fine alpacas being bred by ancient cultures. ______ | [Info](https://github.com/soham96/AlpacaBot/blob/master/README.md)| [Code](https://github.com/soham96/AlpacaBot)| [Feedback](http://np.reddit.com/message/compose/?to=JustAnAlpacaBot&amp;subject=Feedback)| [Contribute Fact](http://np.reddit.com/message/compose/?to=JustAnAlpacaBot&amp;subject=Fact) ____ If you liked this fact, consider donating [here](https://github.com/soham96/AlpacaBot/blob/master/README.md)
Hi! You find the article+video on how to make a cluster with libcluster [Connecting Elixir Nodes with libcluster, locally and on Kubernetes](https://www.poeticoding.com/connecting-elixir-nodes-with-libcluster-locally-and-on-kubernetes/) and maybe you could be interested in [Distributed Phoenix Chat with PubSub PG2 adapter](https://www.poeticoding.com/distributed-phoenix-chat-with-pubsub-pg2-adapter/) Regarding moving the state with horde, maybe this could be helpful [Update distributed stateful elixir apps in kubernetes](https://elixirforum.com/t/update-distributed-stateful-elixir-apps-in-kubernetes/19644/16) I’m still experimenting on this. I’ll write something on my blog soon. Subscribe to the newsletter! :-)
Yeah I saw the first article, that's how I've setup libcluster :) Thanks for that! Now I"m still struggling to get swarm or horde to work, I don't like that with horde I've to do the handoff basically manually and still it doesn't handle non-graceful nodes shutdown. Swarm on the other hand doesn't seems to restart the process automatically if the process is shutdown due a node gracefully shutdown, I've looked into this [https://github.com/bitwalker/swarm/pull/83](https://github.com/bitwalker/swarm/pull/83) but doesn't seem to be enough. I thought that after years of talking about global processes and distributed things it would be easier to have a simple process restarted/moved between nodes &amp;#x200B; I've just subscribed btw :)
I highly recommend the Stephen Grider course on udemy. I also recommend Programming Phoenix (book) by Chris McCord. They are both helping me a ton!
Here are \[a few more\]([https://medium.com/quick-code/the-best-tutorials-to-learn-elixir-for-beginners-3d805ebfe5d3](https://medium.com/quick-code/the-best-tutorials-to-learn-elixir-for-beginners-3d805ebfe5d3))
Other than my own [100+ videos](https://alchemist.camp/episodes), I'd suggest two books: 1. Either Programming Elixir, by Dave Thomas or Elixir in Action by Saša Jurić 2. Programming Phoenix by Chris McCord If you want a paid course, Dave Thomas's Elixir for Programmers is very high quality. I do **not** recommend the Udemy course. It's very long, outdated and TBH I think the author was trying to repurpose some of his extremely high quality work on JS courses to a new market. It's smart on a business level, but I've had more than one subscriber tell me how painful they found the Udemy course (even though they were fans of his JS courses).
That medium post skips the very best resources (e.g. the books the rest of us have mentioned), skips any free resources at all and lists only paid courses for which they have affiliate links.
You don't really need too many packages for that. I'd use Phoenix, just because it provides so much and at so little performance difference vs just using Plug, and I'd use HTTPoison and either Poison or Jason for JSON parsing. If it's of use to you, I built [a project](https://alchemist.camp/tagged/StatWatch) with a lot of the same building blocks last year and screencasted the whole thing.
Yea, it’s merely a medium post
&gt; Heavy in what sense? Performance, memory usage, code complexity? None of the above. I [built the first version of my website off of bare Cowboy server](https://www.youtube.com/playlist?list=PLFhQVxlaKQEn5pqhwqdxItvv80ZnoLqMA), and later rebuilt it in Phoenix. I stress tested the site before and after and there was a less than 0.5% difference in the max number of simultaneous users, time to render, or any other performance metric I examined. The application code was simpler and easier for others to understand in the Phoenix version, too. This is **not** an analogous situation to what you have in Ruby land with a real performance trade-off between using Rails or just Rack.
I agree completely, especially on the point about other people being able to understand your project organization right away. That is among my very favorite experiences coming to Rails in 2015 after years of working on a various Node projects built according to a kaleidoscope of differing opinionated application structures.
Ciao! Thanks for subscribing :D So, I tell you what I have tried so far: 1) locally I use the gossip strategy. Using kubernetes I've used the Kubernetes.DNS strategy 2) I've used horde with Horde.Supervisor and Horde.Registry. https://github.com/derekkraan/horde/blob/master/test/registry_test.exs#L32 Now, the cool thing about Hord.Registry is that you can save metadata (state). This metadata is replicated to other nodes using CRDTs. It's like a replicated agent. 3) My test app had a function that when called stashed the states of a node into the Registry metadata. 4) Now, when I want to update the code I spawn one new node with the new version (or docker image in case of kubernetes). This new node, once connected to the cluster, will get the state replicated to its local Horde.Registry. They I terminate the old nodes. This was just for fun, it worked and it's nice to experiment state replication over a distributed cluster **BUT** it's really too fragile! As many pointed out in the elixirforum, ephemeral state should be used for temporary things. If we can't loose the state, this state has to be stored somewhere, like on a database. And I think I do agree with this. So, if we want to still play with distributed states and updates, I maybe would try to simply use something like redis to temporarily freeze and stash a node state during an update. We can then create a shutdown function which stops the node to accept new connections, saves the state into redis and kill the node. Going against all the containers patterns, I actually prefer the idea of using the container as a virtual machine and update the code keeping the container alive. This seems to be what gigalixir does. The reality, and my personal experience, is that Kubernetes is keen to restart containers, especially if we put resources limits. I think there is a lot to experiment on this and I think it also depends on we need to do with the distributed app. Let's stay connected on twitter and let me know if you do some tests on this (and vice versa). My twitter is @alvisesus 
You still need to implement a GenStage producer to use Broadway, so you should probably look into that.
FYI, here's the talk Abstract There are so many choices today for building fast backends. The difficult part is that nearly all of them are great when it comes to building the applications of yesterday. But what about tomorrow? Come learn why Elixir not only gives you the performance that your ideas demand but can enable you to go so much further and open a new world of possibilities for your company.
Assuming elixir/erlang is appropriate from a technical standpoint (maybe it's not? you'd need to share some more details with us). The only drawbacks then are related to the smaller ecosystem and it being a young language, while it's certainly mature (Erlang being much older than all of the aforementioned languages), it's just never received the same kind of popularity that some of those other languages have or as widespread use in some of the similar applications. Because of this there's usually a few issues. The first as you brought up is finding talent (this is actually compounded given elixir is so recent; although an Erlang developer picking up elixir is much easier than someone completely foreign to the ecosystem trying to pick it up), this honestly can't be stressed enough, there's a good chance (depending on location and how the work is done, e.g. remote or onsite) that you might not find any elixir developers. So I think for any company that's considering elixir, serious consideration should be given whether they have the means (time and resources) to put into training up non-elixir/erlang developers. While the ecosystem might be quite mature, it is often lacking in third party libraries. Many services, or other common utilities just don't currently have an elixir or Erlang library. This is also due to the number of developers, as languages with my devs, means higher chance of those devs facing similar problems to you and so possibly sharing that work. One rebuttal to this however, is that the Erlang VM does have numerous ways of communicating with non-Erlang code (NIFs, ports, system commands, networking protocols, even implementing the distribution protocol by an external app, etc.), so you often will have a number of options if you do want to leverage some other work. Less support available. While this is actually one point I think the community excels on (given its size), it still remains that because it is much smaller, there's a higher chance that less people may have come across the same issue or solved the problem you're facing. This also should be factored into not just what you may experience but also what impact it might have on new developers you're training up. Elixir hasn't really passed the longevity test yet. While Erlang certainly has, elixir is still too new. What would happen if the entire core team decided to abandon it tomorrow? Now what's in elixir's favour if such a thing were to happen (😭), is that the community isn't that small and there's numerous companies with quite a lot invested in it, so chances are there will be others that pick up that responsibility. However this is still a concern with any newer technology. On the plus side if it ever were to happen (where elixir was dead), the plan of action at least wouldn't be too bad. You'd just begin making efforts to transition your codebase to Erlang. Where you probably will face this issue is with third party libraries, for the less popular ones you can find that the only ones to pick from have all been abandon (the dreaded "is this project still alive?" issue can be found in them), while that's not to say you won't find that in other more popular languages, the difference being that you'll still likely find one that is still maintained, or has been picked up by others in the community. At the end of the day, as long as elixir meets your technical needs and you're able to invest the time into transitioning developers, then you should be more than fine. If you don't meet either of those requirements however, I'd be hesitant adopting it. 
I discovered Flow last week and have been gushing about it to anyone who will listen. I’m using it to assemble language corpora by running various filters and transforms on the Common Crawl dataset, so that I can use them for training domain-specific language models for ASR and chatbot purposes. So far I’ve been able to assemble 500M words of beginner-level Chinese and 5M words of two-speaker English conversation, all on my local workstation. I’m still in awe at how little work it took compared to something like Spark or Apache Beam. Is there anyone working on deploying Flow to a cluster with distributed erlang? That would be a total game changer. 
All these are awesome, thanks for the wealth of resources... Im also reading 'Learn you some Erlang for good' and it seems to be ok so far.
Props for the Terminator reference.
You're gonna be hard pressed to get people here to talk you out of Elixir, lol.
I bought Phoenix/Elixir with Vue/Elm and Developing with Elixir back when they were on sale. The quality is really good. Each video/episode explains why we’re doing certain changes and how it fits into the overall application architecture. I think even at full price it’s worth it.
I bought the video course of Pragmatic Dave: Elixir for Programmers. The content is really great and extensive - but I found out that I am learning much slower using videos than with text books, maybe that's the case for you, too.
I also bought the Developing with Elixir course. It's very high quality. To learn Tasks and GenServers, you actually build each of them from scratch. Doing it this way, I have a much better understanding of processes and links now. They're top-notch teachers.
[Programming Phoenix](https://pragprog.com/book/phoenix14/programming-phoenix-1-4) is somewhat comparable, albeit not free.
Did you checkout F# first?
Why, this is actually a problem only of this library you're using. Consider stdlib, specifically, `Enum` module. Every function there takes a collection as a first parameter and yields the result: ``` list = [1, 2, 3] Enum.map list, &amp;(&amp;1 +1) ``` You can rewrite this as following: ``` list = [1, 2, 3] list |&gt; Enum.map &amp;(&amp;1 + 1) ``` Which resembles OOP - you take a collection and call a method on it. But there is a bit of a difference - the data is separated from logic as much as possible, because the latter is defined outside of data definition. I think, the fact that OOP ties data to logic so strongly is one of its major flaws. And the fact that this library you're using tries to mimic OOP is either its problem or you're using or understand it wrong.
You’re mistaking a number of common traits for purely OOP features. You’re also throwing false claims. There are objects in Haskell, for example. A language with immutability as its core principle. They are just rarely used, as they aren’t force fed to developer. Envelope access to functions is not an OOP feature. C and JavaScript come to mind immediately. Structs and functions that operate on said structs is something older than OOP. You could say that OOP is an evolution of that, but evolution doesn’t mean replacement. External API is not an indication of internal implementation. Hell, OOP demands it, so saying “OO-like API” is self-contradictory. “Syntactic sugar” you mention is missing this point too. All in all, OOP is not _the_ programming. It’s just one of the ways of doing it. Elixir is designed to work with data and actors, that’s all.
Thanks for your response, but I think you’re missing the point entirely. This is not about Tentacat taking the `client` as a second parameter. And I am familiar with `Enum` and the pipe operator. It’s rather about convenience and less typing. Yes, I know I can pipe through `Enum.map`, but how many times can you write `Enum.map` or `String.capitalize` before wondering whether that’s necessary? Like I said, this is about making OOP feasible in a functional world. Why should I not be able to call `”string”.capitalize` directly? There doesn’t seem to be a fundamental disconnect between object orientation and FP/immutability to me. The only problem is that “normal” OOP has mutable state, and we want to avoid that. But like I said, that can be easily remedied by introducing the convention that each method that wants to modify state has to return a modified copy of the object and leave the original instance alone. I’m saying throwing OOP out of the language for the sake of immutability seems a bit like throwing the baby out with the bathwater. Especially if the language then goes to great lengths to appear “as if” it had some semblance of OOP, but rather than implement it nicely, it’s all kinds of awkward. 
Modules in Elixir just represent namespaces for functions, which work on certain types. Coming back to your example of `String.capitalize "string"` - if you want to drop `String`, just import the module, just like you would do in Java. The language does not throw away OOP, it just introduces another way to manage your data and logic.
Also, to clarify what I meant, giving example with pipes: Calling methods on objects in OOP is basically the same as if you call a function, which takes an object as a first parameter with name `this` and which has access to its private fields. So, any method from e.g. `Enum` module are methods of some abstract `Enum` type, except there is no such type in Elixir and its functions work on any collection. You might want to familiarise yourself with Haskell's typeclasses, because most of functional languages follow this pattern at some point.
You can' t call `"string".capitalize` because string is not an object. It's a functional language so you pass values to functions and get new value back. You also import function explicitly. iex&gt; name = "bob" "bob" iex&gt; String.capitalize(name) "Bob" # name is not mutated! iex&gt; name "bob" The explicitness is nice. But if you really want to save the keystrokes you can import functions like so. iex&gt; import String, only: [capitalize: 1] String iex&gt; name = "bob" |&gt; capitalize "Bob" &amp;#x200B;
*Programming Phoenix* by Chris McCord or *Phoenix in Action* by Geoffrey Lessel are probably the best two to start with. Both cover a lot, but not all of what the Rails Tutorial does, and of course cover things that aren't applicable to Rails (like Channels). I think Phoenix in Action is probably a bit easier for newbies, so I'd read that one first if you're going to do both.
I’m still struggling with functional ideas myself, coming from an OOP background, but you seem to have onboarded some of the _proposed_ benefits of OOP as _actual_ ones... maybe you need to walk that back a bit? For instance in what way is this: String(“something”).capitalize() Fundamentally better — much less involves less typing — than this; String.capitalize(“something”) Ok, so a language that uses a modicum of type inference can allow you to write just `”something”.capitalize()` and yes that is shorter, but realistically that benefit only applies to primitive classes that have a first class literal declaration syntax. In the general case there’s no such advantage and calling `module.class().method()` isn’t considerably different — much less conceptually better — than calling `module.function(module.class()` and leaving the class very lightweight. After all a bound method on a class is really just a function that always curries the class instance itself as the first argument.
Yes, I get that (Python makes this very explicit by requiring you to declare the `self` parameter for each method). But it still seems rather awkward to type `Map.get(map, key)` instead of `map.get(key)`. The system *knows* it’s a map (if it weren’t, I couldn’t call `Map.get` on it). But why go through the awkwardness of always making that explicit every time?
Thank you for the reply. Do you know of any other web based tutorial that shows how to build a simple application step by step?
Thank you for the reply. As I asked the other commenter do you know of any web based tutorials showing simple applications?
In oop functions and data live together in an object and the object mutates when data transforms. In fp functions are separate from data to encourage immutable data. FP might not be as convenient as OOP but it makes things easier to reason about, bugs are simpler to track down. In a non trivial codebase I would be much more comfortable grokking a FP based system than a traditional OO one with inheritance, mutability etc
I wish we'd stop using the terms sane and insane when we mean sensible and complicated.
Would you suggest the Phoenix course for someone who's done just the Elixir course of theirs?
Yes I am like 80% through and they're amazing teachers, go for it!
&gt; There's also rudimentary ideas of inheritance (protocols, importing modules and overriding some of their functions). Protocols and imports are not related to inheritance. And I mean this literally, as in the computer science literature. Protocols provide open ad-hoc polymorphism and imports are lexical, which provides different expressive power compared to inheritance. Overrides can resemble inheritance but there is no sharing between entities. If you do "use Parent" in Elixir, Parent and Child does not share any definitions, which is often what leads to the bad coupling in inheritance. As /u/Slotos said, you are conflating what is OOP and what is FP. That's somewhat understandable, because there is not a unique definition of what those things are, but many of the things you are referring to being OOP, are not OOP specific traits. The only characteristic in your post that is largely attributed to OOP is the "object.method" syntax that implicitly pass "object" to the method as an argument. You are right, "object.method" can be seen as more convenient than "Module.method(object)" but you also have to understand that in a dynamic language (which Elixir is), "object.method" is a very vague construct. You have no idea what method will be actually invoked without executing the code, which is when you know which object you have. In Elixir, "Module.method(object)" makes everything more explicit because you always know what is being called. That makes code more readable, easier to understand and maintain in the long term (if Elixir was a static language, then "object.method" could be determined by type system, so that would balance things a bit, but Elixir isn't statically typed). From a computer science perspective, "object.method" is polymorphic, which is where the complexity comes from since "object" can have many shapes and "Module.method(object)" is monomorphic. Elixir prefers monomorphic calls and if you want to polymorphism, then you have to explicitly opt-in with protocols. 
The system know it is a map, but the *developer does not*. Imagine you see this code: object.method(foo) What `method` in the codebase is being invoked? You don't know that until you actually execute code. In Elixir, you would write: SomeModule.method(object, foo) As the developer, it is now immediately clear what is being invoked and I can easily check what is the SomeModule.method implementation. Even with the import feature in Elixir: import SomeModule # ... many line of code later ... method(object, foo) It is possible to know, at compile time, what `method` actually is. So the trait you are referring to is not about immutability, it is simply about code clarity. There are other ways you could achieve this clarity (such as by also using a type system) but you have to understand that "object.method(foo)" in a dynamic language is a polymorphic call and all polymorphic calls are dependent on runtime behaviour, which make the code less clear.
To be brutally honest, I haven't finished the course yet - stopped in the beginning (around 20% done). Just as their Elixir course, it's been awesome so far. It's funny this topic was created just around the time I need to build something like what they are building in their course. So if you are still on the fence, I'll go through the course today / tomorrow and update this post.
It's funny you mentioned that course - I need to build something very similar to what they are building in the course. I actually didn't have time to finish the actual course (only went through \~ 20% of it). I'll go through it today / tomorrow and, if you are still on the fence, update this post with my thoughts about it.
The udemy course is pretty good. Goes through a few different projects. Getting more in depth as it goes
Nice writeup! I've been writing ES systems for around 8 years and `commanded` is so nice to use. It's such a time saver.
You're conflating a lot of thing that are clearly different. A method is different from a function. A method is a function belong to an object. There's a reason why you can do `obj.method` vs elixir `Module.function(record)`. The biggest is you can do .method on things because in Elixir they're not object hence you have to do `|&gt;` pipping. &gt; Tentacat.Client.new That's not an object that's the module and function itself. You're conflating instances of an object with function and module. Instances of object hold state where as module having collection of functions doesn't hold state. You can hold state in Elixir via accumulator. &gt; And even in the case where a method call on the object would change the data, it could still be done in immutable fashion, I have yet to see an OOP language that does this. An instance of a class is an object with their own state. What you're saying is not what OOP does in general nor I believe is OOP. &gt; So I guess what I'm asking is, why does Elixir see OOP and immutability as completely divergent, but then goes to great lengths to have something like it, except with a bunch of nasty bits sticking out everywhere? With all due respect, your understanding of OOP and functional paradigm is lacking. You're assuming things are the same when they're not. Perhaps a PLT (programming language theory) book will help you or just more experiences.
You said nothing that hasn’t already been said and you’re misunderstanding my post in a fundamental way. /r/IAmVerySmart is [this way](/r/IAmVerySmart).
&gt; You said nothing that hasn’t already been said and you’re misunderstanding my post in a fundamental way. /r/IAmVerySmart is this way. If this was the case then there wouldn't be other post talking about your misunderstanding between method and function. I've added context to object instantiation and programming language example like Ruby. If you see this as some kind of attack on you then it wasn't my intention. Plus this is my official reddit account with my real full name. I have no reason for it. If didn't appreciate the answer then so be it. I'll leave the discussion as is. 
Which one are you referring to? This one [https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial/](https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial/) ?
Read through the answers so far. Someone pointed out that “something”.capitalize() doesn’t work because “something” isn’t an object. It’s helpful to note that it’s because “something” is just UTF-8 binary in memory. In fact Erlang doesn’t have string type just binary data and functions to operate on binary data. See binary pattern matching. This is great because the data has no memory overhead of having behavior attached to it. Some history around the problems Erlang was designed for help shed light on certain design decisions. For example everything is based on failure isolation. Immutable data allows share nothing concurrency and process independent GC. No loops and only recursion allows the vm to interrupt execution so scheduling is fair and one bad process can’t bring down the system. I know that’s tangential to the question at hand but the historical take really makes it easy to see why things are they way they are. So when it comes to syntax I think it was a manifestation/reflection of how they think about solving problems rather than them surveying the field for preference. To them this was the most ergonomic thing and I agree. 
Thank you all! I went ahead and bought it withe the vue and elm addition. So far I am happy. 
I’m sorry but you didn’t say anything that wasn’t already said by others in a less condescending way (as in “go read a book if you don’t get it”). Again, this has nothing to do with wanting full OO (inheritance, etc.) but just a more convenient way to avoid typing things that I *know* the compiler already knows (and the developer, too). If I have a struct, and I know what type it is, then it would just seem more straightforward to be able to call a function on it, as long as it is defined in the same module and takes said struct as its first argument. That doesn’t seem to add any extra confusion, or make it difficult to guess where that function is coming from. If there is a technical reason for why that’s not possible, I’d like to hear it, but otherwise we’re just talking philosophy when the goal should be having a language that practical *and* pleasant to use. 
Correct me if I’m wrong, but AFAIK modules in Elixir ARE in fact open and functions can be added to them later, which would make monkey-patching possible. 
How do you prefer to handle your communications all the way back to the client? All the CQRS articles I read seem to avoid the topic like the plague.
Coming to Elixir from Rails, I was missing [Rails' encrypted credentials](https://www.engineyard.com/blog/rails-encrypted-credentials-on-rails-5.2). After seeing that there was no package for this (that I could find), I decided to give it a go! I'm open to suggestions and code reviews. Otherwise, let me know what you think!
What do you mean? Maybe I can tackle that during my series' run.
This is great. I'll def give this a try.
That's fair, I suppose this would typically come last. Let me see if I can pick out an example using a few pieces from the article (simplified a few pieces in the middle): * Client A issues an "add product to order" command * Order service receives the command, processes it * Order service raises a "product added to order" event * Read side re-calculates the full price of the order (totals, subtotals, taxes, etc) * Client retrieves these new values for their order &lt;-- What's your preferred method for getting that information back to the client at some arbitrary point in the future (I'm assuming the system would be eventually consistent, since it typically would be)? And ensuring that the information doesn't accidentally go to every client? I know a handful of techniques, but truthfully, I'm not overly thrilled with any of them. Was just curious what you would suggest.
If I understand you correctly, I tend to use the "optimistic UI" kind of pattern. With `commanded`, you can return events to the client, before all event handlers, by setting some config. ``` config :commanded, event_store_adapter: Commanded.EventStore.Adapters.EventStore, include_execution_result: true ``` UI get's events as a response and reacts accordingly. 
I've done that before - it's a decent amount of work, but for some of the slower processes it feel nice for the clients at least. I guess the issue I run into with optimistic updates is when you get to something overly complex. Let me extend my example in the other post a little further -- let's say the order service in the example has some really weird taxation logic to be applied when purchases are made from certain countries. In order to show that tax information optimistically (assuming you needed it accurately at that point, anyways - that may not actually be the case, I suppose), you'd have to have the client know that business logic as well as the backend services. On the other hand, maybe that's why some websites I see say order totals are just estimations until the final step, haha. I suppose that just enforces that you should pick the right tool where applicable, and maybe it wouldn't be applicable in that case. Websockets tend to be what I reach for, but then you run into scenarios where the client is accidentally disconnected right as the event fires, and needing to keep track of generated correlation ids throughout the entire system (assuming you're using eventual consistency / microservices), and it just gets complicated really fast. Or that's how it feels, anyways. 
I'm no expert :) and I'm having difficulty understanding your example. The "read side re-calculates the full price" bit particularly. In my perception (using the Commanded library as an example), this would be: * Client A issues an "add product to order" command * Order aggregate with that order ID is looked up or hydrated from the event store or a new one is created, then receives the command, updates its state and issues the "product added to order" event * Projector updates read model based on that event's payload * Command dispatch finishes, we can choose to have strong consistency and wait for all projections to run before moving on to the next command * on the client side, we're routed to the order page (assuming this is a good practice after adding something to an order) * we run a query on the current order for the user, get its new state and display it Am I making sense? Not sure if I'll cover this on my series since it's just a headless API that is being built, but I'm interested in more stuff to cover in the future and maybe this kind of interaction is it.
IMHO, those rules belong in the domain. Not in projections. If we agree on that, those values will be calculated (and should be because costs should be recorded at the time, not calculated when you dump to DB) and will be part of the event. Push the event back to the client. But yeah. As far as optimistic UI, I would not even try it without a client-side state library that can deal with it. Relay/Apollo/etc...
Yeah, that seems reasonable. So I guess the system technically has two points it can read from, that way -- listening for / responding to events directly, as well as reading the final read projections further down the line? Do you typically handle deciding which events are sent to both client consumers / server consumers on a 1 to 1 basis, to know which events should end up on a path back to clients and which events should stay internal? I suppose that likely depends on the application...
Initial suggestions after a skim while on mobile: - Include a TLDR that prevents the need to go read Rails docs for when someone would reach for this if they don’t come from Rails - Talk about the security/threat model of this approach and what additional mitigation/protection steps are recommended to reduce attack vectors - Talk about the criteria you used for selecting ExCrypto as the implementation for the heavy lifting, and what kind of vetting/auditing you did before making a selection. - Talk about why you as an individual maintainer can safely be trusted with the code that reads and writes sensitive data, beyond “the code is open source, go read it” - Provide a compare/contrast with other approaches, especially Distillery 2’s Config Providers which have a natural feature overlap here TL;DR - proactively demonstrate that you and this project are trustworthy, thoughtful and research-based. Secrets management is, honestly, something that most people shouldn’t DIY, so you have your work cut out for you to show that this library would be a responsible choice to use. If you were to ignore everything else I wrote, this is my most important feedback so far: - Make sure you append your private key file path to .gitignore in the setup - Make sure this approach works flawlessly with Distillery releases or you’ll be conflicting with the deployment technique used by the overwhelming majority of Elixir-based teams - Do some diligence to ensure that AES is the ideal choice here, and that ExCrypto is the best implementation of that ideal choice on the BEAM - it doesn’t seem to be part of any common libraries and none of the contributors are familiar faces, which doesn’t inspire trust
I have run into that before. Where I didn't care for certain events to be "public". This is very much an application specific scenario. What I ended up doing was putting a simple flag and the event and filter those out before spitting them back to the client. Inelegant, but functional. ;)
Yeah, that makes sense. I suppose my concern (and my experience, this does happen every _once_ in a while) is when you route the client to the order page before the command is handled by the server (event bus is backed up, etc), so you end up loading the old state. E.g. customer adds product to order, shows up on the order page, and the product isn't there. Of course, ideally you'd never let your servers get that far behind. :) And I know you can do some client-side optimistic updates in some cases, but I've seen my fair share of weird crap, haha. And it sounds like there are other ways around it -- such as choosing to have strong consistency. I suppose CQRS doesn't _have_ to be eventually consistent, but I'm not sure I'd be willing to drop that either. Not for this, anyways. If you do choose strong consistency, do the earlier command handlers need to know how many services down the pipeline (so to speak) will be receiving and handling the events that get raised? And that's fair enough. Dealing with this stuff is easily my least favorite part of CQRS. All of the fully server-side parts of it are quite interesting, especially when you know what sorts of read model projections you need ahead of time. But the client communication side of CQRS tends to rub me the wrong way. I'm sort of on the lookout for a nicer way to handle it than I currently know. I suspect it's all just a tradeoff, though -- some pieces get easier, some pieces get harder (like everything else in programming). 
Hey, if it works... :)
Another feature of `commanded` is that you can designate handlers to be strongly consistent. In my current project I need just this. This cool thing is that you can configure handlers to be strongly consistent, but if when you dispatch a command without saying you want it to strongly consistent, the request will be treated as eventually consistent. But tell the router to dispatch with strong consistency, it will. Very nice. :insert-borat-gif:
Interesting, I'll check it out. Thanks!
Thanks for the feedback! I'm just finishing removing ExCrypto entirely and instead using the underlying Erlang functions. I'll also be adding some of your recommendations to the README shortly enough. As for your point &gt; Talk about why you as an individual maintainer can safely be trusted with the code that reads and writes sensitive data, beyond “the code is open source, go read it” I'm not sure there's anything I can say that's convincing. People lie on the internet and there's nothing that I, as an individual, can do to prove that I'm to be trusted. Instead, I'd like to change the README to include a section empowering others to read the important parts of the code. The functions are simple and, in my opinion, easy to follow. Yes, this is totally an "it's OS, go read it" answer, but what else could I do to prove my trust since I'm not backed by any entity?
That is helpful, but lots of languages have lightweight and immutable string types, and such strings are the gateway drug to OOP precisely because they’re _so_ ergonomic. It just makes intuitive sense to combine the state with behavior with an immutable string, since what else can any of those behaviors act on but a string, and what else can any of those behaviors return but a new string? In Python — my home language — for instance every bound method of the **str** type is conceptually a pure function attached to immutable data. If it manipulates the contents of the **str** it returns a new **str**, and so all the benefits you describe above are true of it, but you don’t have to import a **str** module to use them. That _feels_ more ergonomic to someone as a gateway example of _good_ OOP, as it does result in less repetition and conveniently packaged behaviors tightly bound to a particular kind of data within the namespace of that kind of data. The compromises and costs of that aren’t immediate apparent until you start to think about why there are multiple “string” types in Python and how all those methods are essentially duplicated into each of those types, and also notice that the user’s own classes won’t have the same ergonomics because all user-defines types are mutable by default. Over time it becomes more and more clear that there’s something rotten in the state of OOP, but once you’ve taken aboard that “natural” feeling of strings being associated with all the behaviors specific to strings it’s hard to let it go and feels very awkward to try and treat that familiar object as _just_ a lump of binary data.
Yes, that's the one 
I've read a lot, but unfortunately they seem to be mostly from 2016 and 2017. It's like everyone rushed to make tutorials before the language was that stable and then stopped. Either that or the newer, better tutorials just don't get the google juice.
Nice, I might certainly use it in future:)
&gt; If you do choose strong consistency, do the earlier command handlers need to know how many services down the pipeline (so to speak) will be receiving and handling the events that get raised? I don't think so, that would be a bit more complex. Commanded has a lot of tradeoffs for simplicity. Here are the docs https://github.com/commanded/commanded/blob/master/guides/Commands.md#command-dispatch-consistency-guarantee and the Gitter.im chat room has a bunch of useful info too, and the author (Ben Smith) is there all the time. 
You are wrong. Modules in Elixir are not open and there is no monkey-patching.
I was actually thinking of python while typing my answer. Also my daily driver at work. Mixed string types in 2.7 has been an ever present source of frustration. Since we’re talking about strings you might find this interesting. https://www.bignerdranch.com/blog/unicode-and-utf-8-explained/
Thanks for that link, really interesting article and a good rabbit hole to go down. Yeah, 2 made some very bad decisions about strings very early on, and only 3 could make that better. And for the most part it has made it better, though now it feels a bit more bloated than it needs to be and I’ve become so disenchanted with OOP that I’ve started leaning on namedtuple and enum, both of which work but neither of which is actually the lightweight, simple structure that it feels like it should be. Still looking for the unicorn language!
I’d be careful with names tuples. In 3 they introduced data classes which is closer to what you want. That or the attr library. They have a good breakdown on why named tuples probably aren’t what you’re looking for. The unicorn language is alluring but I’d caution a bit against that mentality. Take it with a grain of salt because in many ways elixir is a unicorn for me and I’m very susceptible to that drive too. But I’ve found that being too focused on it can make working with other tools miserable because all you can think of is how much you with you were using the other thing. Double edge sword for sure 
Back of the envelope math of 309 words of memory per process on a 64 bit machine is 2.47gb if you want to use Phoenix’s model of a process per connection. I suppose there’s a way to only have references to the sockets and share those with fewer processes but that seems to defeat the point.
The Go project linked doesn't use a goroutine per connection either. I'd be curious how a single process using the [new socket NIF API](http://blog.erlang.org/cd/docs/master/erts-10.2.4/doc/html/socket.html) in Erlang/OTP-22 would fare.
Been using namedtuple for years, and much of what they list as deficiencies I’ve grown to see as advantages, especially immutability by design and natural tuple unpacking, and they’re _much_ lighter weight than the “regular, well-behaved classes” in **attrs** and **dataclasses**. The `frozen=True` argument in both of those really just pretends to be immutable, although at least **attrs** let’s you set `__slots__`. I appreciate what they’re doing, but for a large amount of what I’m doing they take up way too much space providing functionality not required... though I’ll agree namedtuple isn’t for everyone. And yeah the unicorn doesn’t really exist... but hey, neither does the grail, and I’m gonna quest for it anyhow, just as soon as I can stop by Antioch and stock up on hand grenades.
I'm glad you found something that works for you. I tend to agree with you on the benefits but I wouldn't use them with my current team. For them it would go against their ergonomics. Watch out for rabbits friend lol
I like Go a lot. More than Elixir. I’m just more used to it. But the stability of Elixir and the actor model makes me want to use it for my next project. In production, I’m using Asp.Net Core with C#. I work at a Microsoft shop. They recently posted how well they do on benchmarks. It’s really laughable. I can always scale a couple more servers. My bottle neck is network speed and database access. I expect that good programming practice is what you need. And who really cares if Elixir is 1st, 2nd, or 5th on the list. It’s among the fastest. You’ll only need to worry once you hit Discord usage. 
It doesn’t matter how much memory will OTP-22 use for socket as 309 words is for process only, without any other things. 
I think dmor was suggesting having one process holding all the connections.
This is a brief write up about a library I wrote recently to simulate locking. It's not particularly complex, but serves as a nice little reference as to what you can do with the OTP tools you already have access to! 
Update: skimmed through the Phoenix course. As expected, very high quality of content. So yeah, would definitely recommend.
Why? 
A couple comments: It doesn't seem like there's any way to pass a timeout to `acquire`/`attempt`/`execute`. Seems like that'd be a useful thing to have. I don't think it's a good idea to allow nested calls to `acquire`/`release` from the same process unless doing so has semantics similar to a recursive mutex. The way these functions work currently, something like this code: ```elixir def do_work() do :sleeplocks.acquire(:my_lock) # do some stuff here... do_more_work() # some other stuff here... :sleeplocks.release(:my_lock) end def do_more_work() do :sleeplocks.acquire(:my_lock) # perhaps some code that's used in multiple places :sleeplocks.release(:my_lock) end ``` Would not do what you'd expect it to. Personally, though, I'd just throw if a process tries to do a nested `acquire`, or a `release` when it doesn't hold the lock. Recursive locks are usually a code smell.
Timeouts are difficult, because (afaik) the way it works in a `call` is just how long it waits for the response. If you did a `acquire` with a timeout, the timeout would just stop the caller waiting - it wouldn't stop the message from taking up a slot at some point in future. The nested calls are basically just a side effect, I haven't yet decided on exactly how to deal with it. Exceptions make sense, but when being realistic, it shouldn't really ever happen (in a well designed codebase, at least).
Sorry for the late reply, what I've tried so far instead is to use swarm + libcluster to easily have a process migrated from an host to another on shutdown/scaling. However it doesn't seem to be that easy, I've asked about it in the forum [https://elixirforum.com/t/genserver-isnt-restarted-on-graceful-shutdown/20523](https://elixirforum.com/t/genserver-isnt-restarted-on-graceful-shutdown/20523) In the meantime I've also found that doing that wasn't even something that obvious: \- [https://github.com/bitwalker/swarm/issues/117](https://github.com/bitwalker/swarm/issues/117) \- [https://github.com/bitwalker/swarm/pull/83](https://github.com/bitwalker/swarm/pull/83) As you can see from my comments it's not working as expected or I'm doing something wrong (probably the latter) I haven't played with horde much, I've read the getting started but I didn't like the fact that I had to create my own state merger etc, swarm seemed more simple if it was actually working as in the example
I think it's a good experiment to think about. Plus, I think Go is the only real competitor with Elixir in terms of language which supports concurrency, so this is a healthy competition to think about. 
Hi, shameless plug with a library I wrote and supports timeout : [https://hexdocs.pm/mutex/readme.html](https://hexdocs.pm/mutex/readme.html) As for nested calls, they will indeed timeout.
I haven't used swarm yet. I'll give it a try this week, and I let you know :)
Off topic, but I love the overlap between the Clojure and Elixir communities, my two favorite languages by far.
[The Road to 2 Million Websocket Connections in Phoenix](https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections) used a machine with 15GB of RAM. I'm not sure if it could be done with fewer resources, but I wonder what the tradeoffs are for the Go implementation. Efficiency in the BEAM is [mainly in service of its primary goal of fault-tolerance](https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis). If one process crashes unexpectedly, the others should continue. By the same logic, if one process is CPU-intensive or IO-blocked, the others should keep making progress smoothly. And if processes are good for isolating errors and performance issues, they should be cheap enough that we can run a lot of them at once. So if some of the processes handling websockets in Phoenix started calculating fibonacci or dividing by zero, I'd expect the others to hardly notice. How would the Go implementation handle this? 
This is a really good question, and I think it gets to the heart of OOP that no one so far has addressed: it's less about \`object.message\` as \_syntax\_ and more about \`object.message\` as execution. In that respect, both Erlang and Elixir share a lot with more classical OO languages, like Smalltalk and Ruby. The syntax it uses is not the same though, and while that might feel awkward at first, it makes sense later when you think about encapsulation. \`BEAM\` languages have access to a highly concurrent runtime, which takes the "single threaded" \`my\_object.foo(bar)\`-style message sends of Ruby, for example, and turns them into \_concurrent\_ message sends like \`[MyActor.foo](https://MyActor.foo)(bar)\` where \`MyActor\` is an \[Agent\]([https://hexdocs.pm/elixir/Agent.html](https://hexdocs.pm/elixir/Agent.html)) (or a lower-level \`GenServer\`.) \`MyActor\` hides its internal state, yet also manages it in an immutable/functional way. You could do this in a syntactically-typical language like Ruby (JEG2 did it in one of \[his ICFP\]([https://github.com/JEG2?utf8=%E2%9C%93&amp;tab=repositories&amp;q=icfp&amp;type=&amp;language=](https://github.com/JEG2?utf8=%E2%9C%93&amp;tab=repositories&amp;q=icfp&amp;type=&amp;language=)) submissions, not sure which) but it's not natural. Actors and their ilk are very natural in Elixir and Erlang, even though each are functional. I'd recommend reading \[this JEG2 post\]([https://blog.noredink.com/post/142689001488/the-most-object-oriented-language](https://blog.noredink.com/post/142689001488/the-most-object-oriented-language)) and maybe listening to Joe Armstrong talk about Erlang being "the most OO" language, and I'd also recommend reading/watching Gary Bernhardt's \[Functional Core, Imperative Shell\]([https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)) which might help clarify any remaining confusion. And personally, I think APIs like \`Foo.Bar.new\` are strange in Elixir. Maybe it's my Ruby experience, but \`new\` really suggests an object to me. I know it's in the \[standard library\]([https://hexdocs.pm/elixir/search.html?q=new](https://hexdocs.pm/elixir/search.html?q=new)) and I need to let my connotations go, but still, right now, feels weird. ;-)
I love these kinds of articles. It dives into the guts of the language in ways that help people learn what’s going on under the covers. The one criticism is that the tldr rules at the top don’t make it clear that the focus of the advice is on performance. If you place value on non-functional concerns such as readability, correctness, maintainability, comprehension of the solution, etc... the list doesn’t account for or explore those things. 
The tidbit and link about disassembling elixir to erlang is wonderful, _TIL_.
Huh. Def / else works but gives a warning.
Nice article
Good luck :) let me know what you'll get!
Thanks for this point, i'll count on it in next articles!
It's quite strange. May be problem not in def/else? Did you try for ex. build the benchmarking project? It seems to be built without warnings.
Rust presents a much more typesafe and linksafe system. Elixir continues the Erlang tradition of supporting late linking and zero-downtime updates with hot upgrades. (Someone correct me if I'm wrong!) I believe, though, that there's an entire class of apps that don't need these features. There are three reasons: 1) zero-downtime upgrades are now commoditized and widely available orthogonally from the programming language. For example, on Heroku you can just check a box and you get rolling upgrades. 2) We've now also commoditized the clean server configuration with containers like Docker. These things didn't exist 20 years ago when Erlang and BEAM developed. And so, they have their own mechanisms for handling this. 3) Finally, there are a billion web and non-web apps developed with the standard scheme of coding changes, running tests and letting compilers and linters give feedback, and then re-deploying. ##1 and 2 above make this lightning fast and transparent. So, personally, when I work on a Phoenix or Rails app, I work in the simple paradigm of build a simple black-box app. At compile or link time, all the modules I intend to work with should already be available to the linker. But we don't **need** to use the late-linking features ... so why is this a problem? I.e., when working on a Phoenix app, I can just edit, commit and deploy like any other app. The problem I found (and why you might want to avoid Elixir) is that the developer pays a price for the unused dynamic feature. One small example: in Phoenix, there is no compiler or linker warning for a misspelled, malfunctioning route. The reason is that routes are *stringly typed* so that the app can be compiled without the referred-to module being present. (!) I.e., you could design your Phoenix app to hot-plug the controllers at run-time. It happens that for my apps, this is just not technologically appropriate. The second reason for simple symbol (i.e., stringly) route specs is avoidance of compiler work. I see it as unfortunate that perceived compiler slowness has such a strong architectural influence on frameworks. It turns out there's a very common idiom in Erlang (and thus Elixir) of passing data as uncheckable-at-compile-time triads of strings or symbols. tldr; if you value determinism and tool assistance more than late linking and other dynamic behaviors, then Rust will definitely be more for you. On the other hand, Elixir/Phoenix is a big improvement in programmer experience over Ruby/Rails. 
I think it depends. What do mean by *node*? What kind of app are you deploying? I see two kinds of online applications in this context. Maybe I'm just being myopic, but: 1. Standard web apps. E.g., a web server on a service like Heroku or AWS EC2, and you want to be able to scale it up by just spinning up more servers. 2. More interesting, unique, something else apps. E.g., streaming or massively parallel social, gaming, chatting, etc. For #1, Elixir/Phoenix is just as easy as any other server-side language+framework. I manage my Phoenix/Heroku production app just like my Rails apps. But it runs orders of magnitude faster with a fraction of the RAM usage. For #2, that's where the OTP story comes in.
This is an experiment I did a couple of years ago, which I recently found and wrote a quick blog post for.
I only glanced at this, but is the issue I mentioned above not valid? If the timeout is hit, how do you invalidate the lock? As far as I know the timeout only refers to how long you wait for a reply, it does not mean that your message will not be processed. If you call `await` and it does indeed time out, won't you end up with a lock held by a process that is never going to release it?
How does it compare to some of the more recently built parsers? The extra features would be great if it were also faster.
Go isn't the only competitor, there are Clojure and Scala. 
If the timeout makes the process crash, the mutex will automayically release the lock. But If you catch the timeout and do not release, sure, that is a problem. But you know what you are doing then.
Which parsers are you referring to?
Jason and Poison are the most used today I believe
thanks for reposting it! On medium I just crosspost. [The original article is here, on poeticoding.com](https://www.poeticoding.com/connecting-elixir-nodes-with-libcluster-locally-and-on-kubernetes/). &amp;#x200B; If you want to stay updated and be notified on new articles about Elixir and software architectures, [you can subscribe to the poeticoding.com mailing list](https://poeticoding.us19.list-manage.com/subscribe?u=7248ef4d8af185afbbb995cd4&amp;id=b6dcedacc5). Thanks :D
José just gave a keynote that covered Broadway at Lonestar Elixir. OP's question was one of the points José covered, and your answer was exactly how he answered it!
You basically implemented a genserver using Task which is a wrapper around genserver, this is 200 IQ.
[me_irl](https://imgflip.com/i/2v9w8u)
For real though, any advice on flipping this over to use Genservers? The thing that's tripping me up is how to replace `receive` with the callbacks.
If you didn't want to go through a bunch of trouble to try and force redix_pubsub to use genserver callbacks, you could just set up a bunch of `handle_info` callbacks in your genserver. That's where any non call/cast messages end up.
It’s very easy: use handle_info def handle_info(tuple_from_redis, state) do {:noreply, new_state} end
So does that mean receive do &lt;pattern&gt; -&gt; &lt;action&gt; end is the same as def handle_info(&lt;pattern&gt;) do &lt;action&gt; end So, `handle_info` will automatically run when receiving a message from redix? 
So does that mean receive do &lt;pattern&gt; -&gt; &lt;action&gt; end is the same as def handle_info(&lt;pattern&gt;) do &lt;action&gt; end ? So, `handle_info` will automatically run when receiving a message from redix? 
Yea, it'll run when it receives any message that matches the pattern. If you look at the `use GenServer` macro, it actually has a catch-all handle_info because it's a required callback for the genserver behaviour.
Thanks - I'll try that! So would I remove the `Task.start_link` in favour of some Genserver init code?
That clarifies a lot! I'll take a go at it. Thanks!
If you want to get fancy, you could just fork redix_pubsub and add an optional callback argument to the API and then do a PR, sounds like a useful feature to have.
A lot of people have tried to answer your questions, though I think I might be able to explain why your suggestions wouldn't work on Elixir from another point of view, hopefully it'll help. On one comment you say: &gt; But it still seems rather awkward to type Map.get(map, key) instead of map.get(key). Consider `map.get(key)` in an OOP language — I'll use C++ because it's one of the lowest level OOP languages: `map` isn't a just a piece of data containing the map, it's a struct containing both the data and what's called a `vtable`, a list of functions that can be applied to that piece of data. That's how the compiler can resolve that call into what basically is a `Map.get(map, key)` call you'd run in Elixir. In Elixir, and most functional languages, all values are dumb. There's no vtable attached to them, it's just a handful of bytes in memory. You can't call any function on them. OOP is a just paradigm but isn't the only one or the best one. It's just a different way of organising code. Elixir isn't OOP, data doesn't have any behaviour attached to it, so if you want to do something with it you pass it to a `function`, hence why it's a functional language. Functions are the only way to transform data. Speaking of transforming data, you have this snippet in your post: with client = Tentacat.Client.new(...) do client.do_this end What does `client.do_this`? Elixir is, apart from functional, immutable. This `do_this` method to be useful needs to.. do something, change some state, affect the system in some way. As mutability is impossible, that suggested syntax does not make sense. The point of immutable languages is that you can't change any piece of data, just transform it. You change the state of client by applying the `do_this` function, creating a new client or whatever is the result of that transformation. client = Tentacat.Client.new(...) client = client.do_this A good mantra to keep in mind when moving from the OOP world to the functional one, is that in OOP you *tell the system what to do*, whereas on a functional language you tell it how to *transform the data*. It's not an easy paradigm shift when you start, and trying to fit OOP concepts in a functional language is setting yourself up for failure. But it's much easier than it seems, and many people, me included, think it's a much better way to program and handle complexity, albeit not as performant as what can be achieved with an imperative language. Let me share a comment of mine on this general idea of functional vs imperative from when Elixir finally clicked for me: https://news.ycombinator.com/item?id=10836690 Hope this helps!
I think I refactored it successfully - would you mind telling me if this looks approximately correct? defmodule WebsocketFront.SocketSubscriber do use GenServer require Logger @channel "elixir_redis_consumer" def start_link(opts \\ []) do GenServer.start_link(__MODULE__, opts) end @impl true def init(args) do {:ok, pubsub} = Redix.PubSub.start_link() {:ok, _ref} = Redix.PubSub.subscribe(pubsub, @channel, self()) {:ok, args} end @impl true def handle_info({:redix_pubsub, _pubsub, _ref, :message, %{payload: message}}, state) do Logger.debug("Received message: #{inspect(message)}") {:noreply, state} end @impl true def handle_info(_, state) do {:noreply, state} end end I'm still calling it the same way within `application.ex` like: def start(_type, _args) do import Supervisor.Spec, warn: false children = [ SocketSubscriber, # ... ] opts = [strategy: :one_for_one, name: WebsocketFront.Supervisor] Supervisor.start_link(children, opts) end
1. Code readability 2. Code Docs 3. Typespecs + dynamic typing 4. Phoenix - lightweight MVCish framework 5. Ecto - really nice ORM(A database wrapper and language integrated query for Elixir - to be exact) 6. concurrently run tests - WOW that speed... 7. Error handling 8. Code readability - I guess I've mentioned it already... 9. Speed - compared to Ruby/Python/alike 10. Mix 11. Immutable data 12. JS for backend? LOLS 13. Golang generics, errror handling, bla bla. You are gonna write code for a month before you have CRUD controller ready :p Imo with these features Elixir is a beast to build your next startup with :p
OTP
Hey, thanks for your answer, and for providing another perspective on this. I do understand how Elixir is different from OO languages, and I can see how doing away with dynamic method lookup or vtables probably helps keep things fast and simple. However, that’s not what I’m after. I suppose those vtables are necessary due to inheritance, as each object, depending on its class hierarchy, might resolve methods somewhat differently (due to overloading etc.). In this case, I’m purely looking for some syntactic sugar for something that already works. Taking the Tentacat example... what `Tentacat.Client.new` returns is a struct. Which is really just a map, but with a hidden `__struct__` key whose value is... the module that defines it. So let’s say I want to call some methods on it that are defined in the module. This is where the example starts breaking, because `Tentacat.Client` only defines `new`, but let’s say there were other methods. Currently I’d have to write `Tentacat.Client.func(client, ...)`. But what’s stop me from writing a macro to takes `client.func(...)` and translates it to `client.__struct__.func(client, ...)`? Do function calls have to be resolved at compile time? If so, that would probably stop me, because that would be a dynamic lookup at runtime. But what if the type was fixed (i.e. the value of `client.__struct__` is known at compile time), such as within the hypothetical `with` block)? Couldn’t that be resolved statically? If so, I feel like that would provide some nice syntactic sugar without throwing overboard any of the other principles that make Elixir what it is. 
This one should work at least.
Hey, thanks for your answer. You raise some very interesting points, including the fact that the only "real" objects in Elixir are processes (as those are able to retain state). I've really just started scratching on the surface of all of that, and it's both fascinating and somewhat... unusual. However, that's not quite what I'm after in my original post. Perhaps [this](https://www.reddit.com/r/elixir/comments/awel06/oop_in_elixir/ehv907m) does a better job at explaining it. I did however read the article you linked and I certainly learned something. However I had trouble finding the Joe Armstrong talk you refer to (there are too many of him on Youtube). Would you have a link for that?
Looks like it should work, you could probably get rid of the handle_info(_, state) as `use GenServer` provides one already
Supervising the processes. That's what elixir/erlang can do out of the box, and Go doesn't. But elixir has a steeper learning curve if you're not familiar with FP. I'd strongly recommend learning both languages - start with one until you're fluent, and then learn the other.
I'm writing an Elixir wrapper for the [You Need A Budget API](https://api.youneedabudget.com/) in order to learn how to create an Elixir module. Curiously, even thought the API server is apparently written in Elixir (or Erlang, the server identifies itself as Cowboy), they do not provide an Elixir adapter. No Github yet, it's still in the experimental stage. Trying to figure how to best design the API. Suggestions are welcome.
Besides what everyone else already said I want to add in my experience with Elixir. For me elixir also brings together a coherent ecosystem consisting of mix, friendly developers and great learning resources/talks. I rarely had the experience of just installing it and making small toy examples in an incredible short time but with mix and some nice introductory articles I got a really nice feel of the language. And bless the fast compile times! Available learning resources are kept up to date and luckily are aimed for people who don't know nothing about OTP and Erlang, making it perfect for people with 1 or more languages already under their belt, albeit many refer to Ruby/Ruby on Rails/ActiveRecord, but I shrug those moments off. So Elixir might not have fancy manual memory management or a fancy type system, but I'll be damned if using it isn't smooth, fast and stable. 
Nice. This post shows both bottlenecks in hardened Elixir libraries and the Linux kernel. TIL that there is contention on accept() calls at scale.
Don't take my word for it - listen to the development process of creator of Ruby on Rails : [https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis](https://dockyard.com/blog/2018/07/18/all-for-reliability-reflections-on-the-erlang-thesis) &amp;#x200B; However, regarding your needs : \&gt; I'm far from a professional web developer. Then please, use anything you can. Being a good web developer is being good at core technologies of the Web : SQL, HTML/CSS/JS, TCP, unix / devops. During my time working as a full stack developer I see those skills are much more crucial to your success rather than language. Programming languages are only your tool, much like how an artist using pen, pencil or oil. Understanding on how to use them to create a good image is much needed knowledge than language understanding. 
The Erlang source code for gen_server is really straightforward, so I think having a quick look should make things much clearer. A gen_server is at its core a process that calls receive in an infinite loop: loop(Parent, Name, State, Mod, infinity, HibernateAfterTimeout, Debug) -&gt; receive Msg -&gt; decode_msg(Msg, Parent, Name, State, Mod, infinity, HibernateAfterTimeout, Debug, false) after HibernateAfterTimeout -&gt; loop(Parent, Name, State, Mod, hibernate, HibernateAfterTimeout, Debug) end; https://github.com/erlang/otp/blob/master/lib/stdlib/src/gen_server.erl#L402 On every message, it calls decode_msg, which checks if the message is a system message, exit signal, etc. and calls the appropriate handler. For "info" (non-tagged) messages, that handler is the handle_info exported by your module: handle_msg(Msg, Parent, Name, State, Mod, HibernateAfterTimeout) -&gt; Reply = try_dispatch(Msg, Mod, State), handle_common_reply(Reply, Parent, Name, undefined, Msg, Mod, HibernateAfterTimeout, State). https://github.com/erlang/otp/blob/master/lib/stdlib/src/gen_server.erl#L710 try_dispatch(Info, Mod, State) -&gt; try_dispatch(Mod, handle_info, Info, State). try_dispatch(Mod, Func, Msg, State) -&gt; try {ok, Mod:Func(Msg, State)} catch https://github.com/erlang/otp/blob/master/lib/stdlib/src/gen_server.erl#L632 That's it!
Wow, that _really_ clears it up! Thanks for the information!
One of the coolest things in Erlang and Elixir is their concurrency implementation based on Actor model. In this article I introduce concurrency and show how we can start making our code concurrent in Elixir, using processes.
[I removed the Chocolatey completely](https://chocolatey.org/docs/uninstallation) by deleting the folder and path variables, and the Elixir binary install. I then reinstalled the Binary. 
You do realize that talk topics have to catch the attention of people, right?
Very succinctly written, cheers. Look forward to the follow up.
thank you :D
Thank you, indeed it was cool to read (coming from ruby) I'm planning to try elixir from a while now.. However I don't get the difference between concurrency and parallelism (the quotes you gave sounds to have the same meaning, but I'm not a native English speaker, though)
Hey everyone! Our [last post](https://www.reddit.com/r/elixir/comments/ajh9e0/two_years_of_elixir_at_podium_thoughts/) was pretty well received, so I wanted to share our latest one. As we're developing patterns for writing Elixir at Podium, we want to share our experience with the community so that it will hopefully benefit others as well. If you have any questions, feel free to ask here or in comments on Medium.
Hi! Thanks a lot for your comment! If you are planning to give to elixir and phoenix a try, subscribe to the mailing list of my blog so you will be updated when I publish new articles about elixir :) This month I should write a specific article about concurrency and parallelism. But in short, consider an old computer with just one CPU. My first computer was a Compaq 486... and it was concurrent. It was dealing with multiple application and multiple devices (mouse, keyboard, display) at the same time. With one CPU (or core), the illusion is that everything is happening in parallel, but the CPU is switching very fast between different tasks. When you have a CPU with multiple cores (like many computers, servers and mobile phones nowadays), you can run multiple processes in parallel. One process is processed by a core, another process is processed by the second core. 
So if parallelism is about running things *actually* at the same time and concurrency is about dealing with multiple things if it's not even at the same time.. So all of our existing apps are actually already concurrent, no? For example I manage users, send mails, dealing with database etc... Maybe I should wait for your articles to get the subtleties of these differences...
i found this article helpful in explaining the difference between concurrency and parallelism: [http://nathanmlong.com/2017/06/concurrency-vs-paralellism/](http://nathanmlong.com/2017/06/concurrency-vs-paralellism/)
The operating system is concurrent. It **may** execute these things in parallel; for sure not everything is in parallel since the number of processes of apps we run is far greater than the number of cores. But you got the idea.. They same happens at the application level. Do you develop with ruby on rails?
nice one!
I felt there were already a number of answers to your original post, which is why I didn't try to answer it directly. Even your reply to the linked reply seemingly conflates methods and functions. You say "let's say I want to call some methods on it" (it being a \`struct\`) and the simple answer is: there's no such thing as a method on a pure data structure in functional languages. It's not an issue of syntax but of semantics. If Elixir allowed you to write \`map.get(key)\` then it would immediately "messy up" the language in several (already mentioned) respects. I found the Joe Armstrong interview I was thinking of: [https://www.infoq.com/interviews/johnson-armstrong-oop](https://www.infoq.com/interviews/johnson-armstrong-oop) Alan Kay's quote that Joe references is why I responded like I did: "The notion of object oriented programming is completely misunderstood. It's not about objects and classes, it's all about messages." With more experience using the semantics of a functional language, that'll likely clear up any issues you have with the syntax of the language. &amp;#x200B; &amp;#x200B;
Yeah, apologies for the incorrect wording. You are right, there are no "methods" in Elixir. What I meant to refer to were functions that "act like" methods (as in, a function that is defined in the same module as the struct it operates on, and takes said struct as its first argument). Thanks for looking up the link BTW. I'll check it out. Always happy to learn something.
Too bad the article didn't go into what that means. Perhaps you could go into details on that in a follow-up?
Thanks the other article (with burritos) also gave some hints.. It's Indeed somehow connected, but concurrency is really about doing things "at the same time".. With enough resources it will be even parallel, but without enough resources it still will be concurrent. Yes I'm currently involved on Rails projects, but I impatient to have enough spare time to take a look at elixir and phoenix (I already have some materials waiting for me :)
Nice. Is this comparable to Sinatra Vs Rails?
It's less about resources and more about capabilities. Memory access is one of the biggest reasons that parallelism can be difficult to achieve, even with good hardware. It is expensive to share data across multiple execution contexts in parallel, because the data can change at literally any time. One of the ways that Erlang/Elixir achieves parallelism is by having an immutable data model along with per-process stack/heaps. This means that processes don't need to coordinate access to pointed memory.
Remindme!
**Defaulted to one day.** I will be messaging you on [**2019-03-08 05:31:44 UTC**](http://www.wolframalpha.com/input/?i=2019-03-08 05:31:44 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/elixir/comments/ay85rw/using_nonid_foreign_key_in_ecto/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/elixir/comments/ay85rw/using_nonid_foreign_key_in_ecto/]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Pure \`Plug\` is more or less comparable to \`Sinatra\`. But here also \`websockets\` are presented, them are much easier to use inside ErlangVM then in single threaded Ruby servers
They can do that without being offensive to people with disabilities.
Hi! Yes, I'm going to spread different aspects across multiple articles. Can you please tell me what you expect to read? A deeper explanation about concurrency vs parallelism, or just concurrency with messages etc? &amp;#x200B; In further articles I'll dig into messages, parallelism, tasks, etc.
Since you're writing a REST client library, check out [tesla](https://github.com/teamon/tesla). I've found it to be the most intuitive way to write client libraries. I especially like how it can easily parallelise operations.
Thanks. It would also be good to add a little description to lightning talks, what it will be about.
WABI SABI! This was a fun conf.
&gt; Erlang processes are not threads. They are not even OS processes. Erlang processes are lighter than threads, they have a really small memory footprint and the context switching is much faster. Just wanted to point out this common misconception. They are threads. http://erlang.org/doc/getting_started/conc_prog.html &gt; One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a process. 
No Chris McCord keynote? :(
Just use a pen.
Supposedly Chris McCord's talk wasn't able to be recorded.
**threads of execution**, to me seems more a way of saying "tasks". Joe Armstrong: &gt; Erlang processes are emulated in the Erlang VM, like Green threads reason why they are much lighter (and faster in context switching) than classic user level threads 
They're implemented using green threads. The only reason why they're not consider threads is because they share nothing hence "process" instead of thread. Even the official documented I link stated it as thread. The next paragraph of the doc is: &gt; (Aside: the term "process" is usually used when the threads of execution share no data with each other and the term "thread" when they share data in some way. Threads of execution in Erlang share no data, that is why they are called processes). It is crazy to think programmer would do away with what the hardware people baked in, threads, for software implementation. I don't want to be presumption but I trust the doc over stack overflow and repoint to my original statement that this is a common misconception that Erlang process is some magical thing. 
Since I'm comparing erlang/elixir with ruby and python threads, they are different not only because they don't share memory but how they are scheduled. They are "threads", but not OS threads. Try to allocate a million of threads in Ruby MRI or Python..
To make it more explicit I've amended saying "they are not OS threads". Thanks to pointing this out.
Question: is it ever okay for two categories to have *the same identical name*, but *different IDs*? Is it okay to have (id, category\_name) of (1, 'Foo') and (2, 'Foo') duplicating 'Foo' in the same table? If so, then articles can be split into the two different 'Foo' categories, some for ID 1 and some for ID 2. Is that what you really want? &amp;#x200B; If the name of a category is it's identity, then the key should just be the name of the category. I don't use Ecto, but it seems to say you can define @primary\_key with {field\_name, type, options} to set the category name as the primary key. But since often code that relies on ORMs expect a single column (usually an integer "id") to always be around, it's likely you'd want to retain the integer "id" column but also define the category name as an alternate key (e.g. UNIQUE NOT NULL in SQL constraints). But Ecto documentation doesn't seem to point to an obvious way to do this, which is strange for something so fundamental to database design. It might be in there somewhere, but the fact that it's so obscure doesn't bode well. Also, if you reference (i.e. foreign key) to the category name, then you'll need to be sure to decide whether or not you want it to cascade updates if the name changes or if you want to cascade deletes. Again, the docs don't point to an obvious way to control these things. &amp;#x200B; See, this is why I hate ORMs or "database abstraction layers". This could have all just been done in plain SQL and been done with it. The way ORMs (and Ecto, if it's not an "ORM") handle constructing databases outright discourages proper design. They discourage learning proper database design and data-oriented thinking. It's rarely okay to just slap an auto-incremented integer "id" column on each table and think it's sufficient, since thoughtful defining of real keys is vital. But if you want to do more than just an "id", you have to constantly fight the ORM's insufficient API. &amp;#x200B;
You can easily create a unique constraint on any column you want in a migration: [https://hexdocs.pm/ecto\_sql/Ecto.Migration.html#unique\_index/3](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#unique_index/3) &amp;#x200B; The issue here is also that OP didn't change the default column type when defining the reference: [https://hexdocs.pm/ecto\_sql/Ecto.Migration.html#references/2](https://hexdocs.pm/ecto_sql/Ecto.Migration.html#references/2) &amp;#x200B; If the above migration code is changed to: defmodule MyApp.Repo.Migrations.CreateArticle do use Ecto.Migration def change do create table(:articles) do add :category, references(:categories, column: :name, type: :string) I believe everything will be fine. The error is very clear, this is a type mismatch and the tool is provided for overriding the default.
Thanks! Actually I just found that myself, after spending about a day or so with HTTPoison and getting a proof-of-concept going using `HTTPoison.Base`. What I like about Tesla is that it's similar to Ruby's Faraday gem, which I am a big fan of. Gave it a try yesterday and I was able to implement the same features in 1/10th of the time and with 1/3rd of the code. Definitely will be using that again in the future. The problem I have now is how to best return API results. Should I just return plain maps / lists of maps? Should I use string keys or atom keys? Or should I build custom structs and deserialize into those? (The latter is tricky with Tesla and easier to achieve with HTTPoison, BTW). Generally, I figure maps should be fine, but with this API, there are some weirdnesses that I'd ideally like to solve in the library instead of letting the user deal with it. Namely, each `Budget` has a `DateFormat` and a `CurrencyFormat` attached to it, which governs how dates and currency values are to be interpreted. I would like to provide some convenience methods that will parse those formats and apply them to the values returned by the API. In an object-oriented language, I would define custom accessors on my models, but in Elixir, that doesn't work. What's the best way to solve this in a functional manner?
Great! Concurrency is definitely an interesting topic in Elixir, and I'd love to learn more about it. FWIW, my background so far is mainly from reading "Programming Phoenix" by Chris McCord. He goes into some detail on `GenServer` and Supervisors, but even after working through those chapters, I still don't feel super confident about my understanding of it. Also, I think it would be very interesting to compare Elixir's approach to concurrency with other languages. For instance, it seems to me that using `spawn` in Elixir is somewhat similar to scheduling a callback in JavaScript using [`process.nextTick()`](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/). In your article, you've used `spawn` only to print something, is it possible to have that return a value, too? Or does that require a different approach? Finally, you didn't explain at all what the Actor model is about and how Elixir implements it. The book I mentioned doesn't say anything about Actors, so I'd love to read something that explains that in more detail. Thanks for your work, and I look forward to reading your next post.
It looks like José's talk is up now. I remember he specifically mentioned recording it.
I have heard in the past, though I couldn't find anything on it when I looked, but that Scala took an OO-mixed-with-FP approach and it was "messy". I don't know that many people that write Scala, but it's worth looking into it. I doubt it'll directly apply, but could shed some light. A friend of mine posted this in our Slack just this afternoon: &gt; You don’t send messages because you have objects, you have objects because you send messages. &gt; - Sandi Metz, Practical Object-Oriented Design in Ruby: An Agile Primer I think you're on to something with the OO-via-type-system over OO-via-isolation/messages/polymorphism. I think that's a good way to phrase it. You can get some/all of these in typical OO languages like Ruby, it just won't particularly be clean or convenient.
You are correct. Since Scala runs on the JVM and is interoperable with regular Java code, it has to be able to interface with its type system, which includes OO and inheritance. Scala has some neat abstractions on top of that, such as shortcuts for creating singleton objects and "case" classes, but underneath the hood it's all compiled down to JVM byte code. Alas, the JVM is also the biggest reason why I didn't continue to learn it. I'm not a big fan of the ecosystem (and especially not Oracle's stewardship of it). Also, the Scala build tool is based on Maven, which is (IMO) the software equivalent of cancer. As for Ruby, as much as I love the language, but if it had decent-enough tools to deal with concurrency, I suspect that Elixir would have never been created. José was a core contributor to Rails before creating Elixir, and the lack of decent solution for concurrent programming was his main reason to switch to Erlang.
I'm not too familiar with the JVM, but how do you explain Clojure's "FP-only" interop? I think interop can be done without having to support OO (Kotlin falls into this FP JVM lang bucket too)
I'm even less familiar with Clojure than I am with Scala, but Clojure does provide a special syntax for interacting with Java classes and objects. They've got a [detailed explanation on their site](https://www.clojure.org/reference/java_interop). As for Scala, my search turned up [this (rather dated) document](http://www.codecommit.com/blog/java/interop-between-java-and-scala). TL;DR: interacting with Java objects *from* the other language is pretty straightforward, calling Scala/Clojure code from Java is a bit more tricky.
Wow thank you for sharing this! I'm excited to watch it as Advent of Code is generally a negative discussion in the context of Elixir.
Why's it a negative discussion?
In addition to this wisdom, stay open-minded, broaden yourself, explore multiple technologies and grow to understand the concept of using the right tool for the task at-hand. Some context: In my case, I’ve often heard much criticism of using Ruby, an OOP language, in a functional way. When it boils down to solutions, businesses want a solution. Many times, that solution might arrive in a non-traditional way. Stay open to that and you will stay on the bleeding edge.
Nice! Another podcast to add alongside elixir mix, elixir talk and elixir outlaws.
It's great how José explains how to solve the quizzes in different ways! Even the day1 is super interesting, he touches point like streams vs enum, process dictionaries, lists and mapsets..
With concurrency, a group of processes all do work and complete together within a given time frame, with parallel, the processes are all doing work at the same time. Parallelism can be used during concurrency iirc. 
FYI, here's the bio for those that want to read it before watching the talk: &amp;#x200B; Design is an important part of Software Development, and plays a key role in creating extendible maintainable solutions. There are many design principles traditionally associated with Object Oriented programming, yet in recent years languages such as Elixir have tempted many developers away from traditional OO languages. In the talk we will explore the OO design principles known as "SOLID", and apply them to an Elixir case study. We will discuss whether these principles are useful in the functional world, or whether functional languages need a set of design principles of their own. After attending this talk you will have a practical understanding of some design principles that can be applied to Elixir and the use cases they can help solve.
These pros are also in the order I think of their importance. Readability and excellent documentation being first-class design decisions I'd say are the two most critical factors to onboarding new programmers to an existing project. Whether an open source side project or a big business app, speed to onboard new programmers is so critical to scalable growth. Having only spent a few months with Elixir I feel like at most intermediate with my competence, but I've been able to open PRs to open source libraries already because the code is so easy to read, understand, trace, and modify. All that other stuff is bloody aces too though. The speed and load capability make me straight up giddy. I'm all about squeezing every bit of output from a given constrained resource. 
With respect to returning a value, this is handled by passing a message back to the parent. IE: ``` parent = self() spawn(fn -&gt; IO.puts "this is from the new process" send(parent, "hello") end) receive do message -&gt; IO.puts "Incoming message: #{message}" end ``` Task.async and Task.await provide a sort of promise like API but the underlying mechanics are completely different from a promise architecture.
I'm not sure this is what he meant, but usually it is because these code challenges use a lot of mutation heavy algorithms that can be a challenge to implement efficiently in a language that is mostly about immutability.
This isn't really a Elixir/Phoenix specific question but more a general API design question. From my experience, you want to abstract away the domain specific stuff as much as possible and put a rest layer on top of it. For example, let's say you want to create a user....and in order to create a user, they need an entry in a users table, then need an entry in the accounts table to map the user to a specific account, then call a 3rd party API and register the user there, etc.. As a consumer of the API...I shouldn't need to know that in order to create a user, I need to create entries in multiple tables, the user needs an account with a 3rd party provider, etc.. As a consumer...I just want to send a POST request to /users with a payload of user information and then all the magic happens within that API endpoint. Unless there is a very specific business requirement that requires you to expose that lower level logic, I think it is a bad idea. 
That's exactly what I meant
Do you have an example of "can be a bit dramatic"? I can't recall ever seeing anything about someones wife who divorced their brother and is now sleeping with their doctor's best friend's wife's sister. But maybe you're not referring to soap opera drama? &amp;#x200B; For me, there is always a lot of good discussion about technical solutions to problems that people run in to. I honestly don't think I've ever seen anyone call anyone else out for being technically incompetent. It just feels like a great community of smart people who have good technical discussions.
&gt;soap opera drama No not soap opera drama. Maybe dramatic is the wrong word. &amp;#x200B; For example the "[Have you moved away from elixir](https://elixirforum.com/t/have-you-moved-away-from-elixir-if-so-why/20302)" discussion is a wild ride. &amp;#x200B; &gt;there is always a lot of good discussion about technical solutions to problems that people run in to &amp;#x200B; Just to be clear I do think it's a positive place and I regularly find solutions there! &amp;#x200B;
Think of the domain contexts and such as your app. Maybe you have a user's context that handles creating and managing accounts, and a posts context for creating and managing posts. Now think of the rest API itself as just a thin, well defined interface to interact with those domains. It can use as little or as much of the contexts as needed. I like thinking of the rest API as almost a separate app talking to your core app(s). If your project were a house, the rest API is the walkway leading up to the house. It defines how you get there and how you leave, but it's not the house itself. And thinking of it this way opens up other ways to interact with your app that you may not have been in the right mindset to consider. For instance in this case, writing server side rendered templates could be added on and plugged in if you wanted. Or another elixir app could interact with your contexts directly.
The occasional threads turn into a bit of a rampage but overall it's probably just due to the forum format and a small group that kind of comes across as SJW'ish. As long as one isn't the sensitive sort it doesn't really get in the way much and a lot of those folks that get into it like that make amazing contributions elsewhere. &amp;#x200B; There are a few other interesting camps and you'll see them if you ask certain questions. There's the ruby folks that are heavy in the web dev type of convo's. There's the erlangers/functional programmers that get into the heavy concurrency related stuff and there's also a bunch of low level systems sorts that can answer insanely deep or difficult questions there. And there's the nerves crew of which more than a few lurk around there and they will answer anything to do with embedded devices and such. It's actually a pretty big mix of different people tech background wise. Elixir scratches an itch for a pretty wide range of people. &amp;#x200B;
&gt;small group that kind of comes across as SJW'ish. Yeah I can see that. Maybe the correct words are sensitive/defensive. &amp;#x200B; I think your reply is excellent and puts everything in perspective. Thanks. &amp;#x200B;
I stopped visiting because the admin(s) heavily moderate in favor of companies that advertise job openings. I had a bad experience interviewing with one of the companies that advertised on there, so I posted a summary of the experience, and it was removed. Similarly, I called out another one who was being very dodgy about how much elixir was part of their codebase and refused to answer how much time would be spent working with elixir, also removed. Overall wouldn't recommend.
Interesting. Actually one of the things that was very alarming was in a thread the person running the forum openly stated he had modified a persons post without telling him. He also called this person out publicly and made it sound way worse than it was. Why? Because someone had a typo and wrote the word "overlord". This was deemed "offensive". I find altering an OP's comment silently without bringing up the issue to them, in private, and asking them to make the adjustment absurd. I get the feeling the moderators cannot be trusted either. Who knows what has been edited or removed without anyone knowing. I also noticed he likes to close and delist discussions. There was a thread about how an author of a similar library to live view expressed his concerns. I believe it was locked because it was uncomfortable and didn't push his narrative. What other resources/channels do you recommend?
Elixir forums moderators are just horrid. Turned me off of the community entirely.
Kind of why I posted this. I've been getting turned off because of the forum. I really enjoy elixir and writing phoenix apps. I would really like to find other channels (outside of slack) to stay engaged. &amp;#x200B; Did your experience turn you off of Elixir as a whole or just the forum? This is a concern of mine. I would love to see elixir grow more mainstream and I don't want a small group of people to push newcomers away. It does feel like the same group of people are always posting, so maybe it's more of an echo chamber than a forum (but maybe that's all forums are...). 
Just got back from the Lonestar Elixir Conf and met at lot of the core contributors to Elixir and Phoenix and they were all super nice and more than willing to chat. The forum is hit or miss. Lots of good info on there but then there is a little of drama as you might call it because I think the language and frameworks are still really young so I think a lot of people are trying to put their in their 2 cents in hopes of steering community decisions in the directions they see fit. But that is pretty rare and it seems like everyone just wants the best and means well. 
I don't think *most* users have problem with the moderators, and I don't think we should forget that the people who *do* have problems are going to be more likely to be vocal on the topic. The forum has a good deal of high quality content from people who know what they're talking about and it's a valuable resource for the whole Elixir community. I'll often google for something and have a useful result pop up from the forum. I'm not involved at all with the management or moderation of the forum, I'm just responding as somebody who uses Elixir professionally and appreciates the value the forum provides the community.
I find value in it. But I do think the way it's run is concerning. Most of the people on there are helpful. Outside of the "stack overflow" style solution threads it's a bit of a turnoff. 
thats me!
Good points. I do believe the core team is excellent. As a developer who has been sold on Elixir the forum "misses" don't bother me too much. But sending newcomers there concerns me. &amp;#x200B; Example: I was at a meetup and I was pushing a nodejs dev on using elixir/phoenix. I kid you not the next day there is post right there on the forum "Do we even need phoenix". I think if that dev ended up on the forum the next day he'd think I was stupid. If he read the thread he'd think the community is at odds. 
I don't think it is a big deal to see a post like "Do we even need phoenix". Coming from a javascript background myself...that title would have been "Didn't like this framework so I made a new one" haha. But the truth is, you don't need phoenix for every project and I am assuming if there isn't one already, you will see a project like Sintra for Rails emerge where it is basically a stripped down version of Phoenix. Don't get me wrong, I love Phoenix and use it 9 times of 10 when building a server...but there are cases where you don't need it or may be overkill. The one thing I do love about the community...it seems to be that there aren't a million different frameworks solving the same problem. In Node, I can't even count how many MVC frameworks there are. It is nice knowing there are only a handful of options and therefore the projects get targets support instead of spreading resources thin (dev wise) between too many open source projects trying to accomplish the same thing. 
&gt; Did your experience turn you off of Elixir as a whole or just the forum? This is a concern of mine. I would love to see elixir grow more mainstream and I don't want a small group of people to push newcomers away. It turned me off of the community. I don't know many people who would let a forum push them away from a language - not by itself. bigger issues for that issue are ecosystem and adoption. I don't know if its changed but 9 months ago after following it for years I still wasn't seeing the adoption increase. New comers are (or were) pushed away by the lack of training materials. Without seeing the adoption and very few projects ever really needing Elixir's sweet spot massive concurrency needs I decided to put it on the back burner. I still do a lot of OOP but when I reach for FP its to a language I think has a future. I might be wrong but I think it has passed the window where it s going to get mass adoption. 
&gt;The one thing I do love about the community...it seems to be that there aren't a million different frameworks solving the same problem. Me too. Again, great points!
&gt; very few projects ever really needing Elixir's sweet spot massive concurrency needs I decided to put it on the back burner Of course you are welcome to evaluate Elixir in any way you want but concurrency is likely the least important reason why I personally enjoy working with Elixir every day. Pattern matching and immutability makes my code clearer, using Phoenix means I need to worry about performance way later than usual, the tooling is great, etc.
&gt;I might be wrong but I think it has passed the window where it s going to get mass adoption I don't know, I am definitely not putting all my eggs in the elixir basket but I have invested a lot into it. Go took a lot of attention and a lot of people are using jumping to python. I feel the payoff will be big for elixir but it's hard to tell, I've never experienced a language from a young age. It's all new to me. &amp;#x200B; &gt;bigger issues for that issue are ecosystem and adoption Yeah I can see this. In the end we all need to get paid. If there are no jobs its hard justify. I have high hopes and the number good libraries in the ecosystem is high today. But it still lacks a lot of "official" sdks and public business adoption. &amp;#x200B; &gt;It turned me off of the community. I don't know many people who would let a forum push them away from a language - not by itself. True. Good point. &amp;#x200B;
\&gt; I don't know, I am definitely not putting all my eggs in the elixir basket but I have invested a lot into it. Go took a lot of attention and a lot of people are using jumping to python. I feel the payoff will be big for elixir but it's hard to tell, I've never experienced a language from a young age. It's all new to me. Heres the thing . If a language gels with you and makes you productive - never make anyone turn you off it. I code ruby ,JS and C# and I am looking at Dart (which previous to flutter had no shot any wide adoption) and crystal ( an even younger language but in fairness so much like ruby it hasn't been much of commitment to learn). By the time you have messed with a language for a few months you should look to do a decent project in it. something of your own A few of those that actually have a use to you makes almost any language worth it. I would NOt recommend Elixir for a first language but as one of many not a thing wrong with it. My ecosystem comment has a lot to do with what you are building or want to build. If you are finding what you need - thats all there is who the rip then cares if its generally small For employment and not personal projects and growth though. the numbers don;t lie. You should have something else to put food on the table. Unless its your project thats a start up Elixir is a tough up hill climb. &amp;#x200B;
Are there any good geospatial focused developers using Elixir?
Nice notes. I still have to find the time to watch the videos.
We may potentially just be seeing one side of the coin too. We don't know how good or bad the forum would be if there would be less moderation. I have seen some threads that I am glad they were closed/moderated early on because they were created with the purpose to rile up the community (such as putting Elixir and Erlang developers against each other or against certain projects). &gt; There was a thread about how an author of a similar library to live view expressed his concerns. I believe I know which thread you are talking about and it was not the author of the library (Drab?) but a user of it? It involves some of the same people as the overlord discussion. &gt; What other resources/channels do you recommend? Reddit, slack, irc, elixir radar newsletter (if you want to just consume and not get involved).
Great talk and I learned a lot from it!! Is it really right to substitute class for module? Could you have argued class should be substituted with functions? I'm a total novice so sorry if it's a dumb question.
I watched a similar talk by her on implementing SOLID principle on Elixir. Just wondering has anyone tried it out and what's your experience?
What error are you seeing and what is the stacktrace? Can you please provide complete error messages? A supervisor should not crash because a child takes too long. The task timeouts happen in the client, so that shouldn't bring the supervisor down either. What could happen though is that the supervisor is triggering max restarts. Seeing the error messages will help debug the problem.
I bet OP is starting the Task processes in the init callback instead of letting the supervisor start them. If you do this then the supervisor won't be supervising the process, but will be linked to it, so a crash will take down the supervisor as well. OP, post your supervisor code.
I added a github gist: [https://gist.github.com/faebser/912ba4b38a3ab5755886458542cb2a3f](https://gist.github.com/faebser/912ba4b38a3ab5755886458542cb2a3f) The code is not complete, I removed some of the surrounding code to simplify the functions. Also this is not a phoenix application but part of a escript that is run from the command line. That is also the reason why I use a dynamic supervisor.
Right, so here you're starting the Task.Supervisor, which will be linked to the current process. In that same process, you're creating some Task processes, but when they die, the process dies with them. When the process dies, the Task supervisor dies with it (because it is linked). A second problem is that this recursive function will just stop processing anything when the first timeout error comes along. So there is no effective supervision happening here, and no failure tolerance. It seems to me that genstage would be a good fit.
hm, okay. But this being a escript how would I start a supervisor that is not linked to the current process? &gt;A second problem is that this recursive function will just stop processing anything when the first timeout error comes along. So there is no effective supervision happening here, and no failure tolerance. Sorry, I don't understand this. Is it not that as soon as one of the tasks for the stream dies it gets restarted by the supervisor and the Enum.into blocks until the newly spawned task is finished? &amp;#x200B;
Just found out about leex and yecc! Decided that I am going to write a distributed spreadsheets app using [lasp](https://github.com/lasp-lang/lasp). But first I thought it'd be more fun to write a parser for [OpenFormula](https://docs.oasis-open.org/office/v1.2/OpenDocument-v1.2-part2.html), so I'm building [Iridium](https://github.com/mpope9/Iridium). Kinda interesting, basically like flex and bison for erlang. Have quite a ways to go, but I'm excited!
When Elixirforum.com first launched I was super stoked. I spend a few hours compiling a bunch of great Elixir/Phoenix resources and created a thread listing them in a clean categorized list. It was a hit, so much so that the admin re-appropriated ownership of the thread to one of his minions.
Wow. That’s pretty ridiculous. Maybe share it here?
That's a pretty big thread, so didn't get through it. But what were you referring to as drama? Did you mean opinionated discussions? If so that's something that pretty much happens in all tech spaces, I don't really see a problem with it until it gets out of hand and starts getting quite personal (or away from the technical discussion). 
Yup you have to create different repo config for the databases. You have to define them in your app config. [Like this](https://stackoverflow.com/a/47327155/6417884)
Nice link. It may be a bit obvious but I figure I'd point it out for op. These repo processes are normally placed in a supervisor but you could create them when you wanted them. I'm not sure if there's an advantage in doing that as you can probably control connections separate from the process, but may be helpful depending on the situation and goals.
Yup, you didn't understand my question.
Yup, you didn't understand my question. 
&gt;could create them when you wanted them. how?
Perhaps you could explain what exactly you want ?
Start a supervisor to build your own supervision tree. The first child would be the task supervisor, the second child would be a process (likely a genserver) that runs `download_thumbs_files`.
It doesn't matter, implement what design you think makes sense for your API. 
Meh. This was back in 2016. I'm sure most of what I had compiled is no longer being maintained or compatible with the latest version of Phoenix.
Ability to connect to a database using connection info that is provided at runtime, e.g. through a user input. It’s right there in the post.
You'd have to start up the Ecto process tree for the new database manually by using DynamicSupervisor as it's parent. You'd also have to compile a new Repo module and insert the config using the Application module. It may take a moment for all this to complete so I wouldn't do it too frequently. If you can control the rate at which this process occurs or otherwise know it will be infrequent, that would be good.
I dunno if this will help you or not, but I found it much easier to install Elixir on Ubuntu for Windows’ WSL (Windows Subsystem for Linux).
Ecto.Repo can take urls dynamically in its [init/2](https://hexdocs.pm/ecto/Ecto.Repo.html#c:init/2), explained here: https://hexdocs.pm/ecto/Ecto.Repo.html#module-urls Maybe that will help?
Don't know if this answers your question, but Elixir has the ability to associate a struct with a module. A common pattern I use is to make most functions in the module take the module's struct as a first argument, which is at least superficially similar to the way python takes self as the first argument, though of course in elixir there won't be mutation (usually I emit the mutated struct as a result of the function)
If the number of databases is predetermined, then by far the simplest way is to create N repositories, and have each of dropdown option map to one of those. If the database themselves are dynamic, then Ecto does not quite support the use case. There was a discussion about "Ecto dynamic repos" in the issues and you have to do some manual assembling on top of that but it is borderline hacky/non-hacky. If that doesn't work, then your best option is to start connections directly with Postgrex/Mariaex and do raw SQL queries. 
he really show us the elixir way to solve this, gave *me* *a* *lot* of inspiration
Can you elaborate the situations where we would need multiple processes holding a lock ? Not able to wrap my head around it.
What is wrong with using EEx?
Ooooooooh
So you want to compile a new version for every machine that needs a new config v
No, mostly because there are things that cannot be configured when VM is already running. Also as it was already mentioned, compiling project for each configuration independently would be waste of the resources and needless complication. 
You should post about it in the subreddit.
Learning Elixir and Phoenix - tracking progress and learnings on sizlets - [https://sizlets.com/skillets/39452025-0a8b-441b-ab9f-417b79f0c635](https://sizlets.com/skillets/39452025-0a8b-441b-ab9f-417b79f0c635) 
What kind of configuration are you talking about? If it's anything to do with the server or how the VM is initialised, then you usually cannot avoid it. If it's configuring applications, then it depends on the applications. Some applications will only have optional configuration and can be passed all that configuration through functions parameters instead, others allow for configuration changes during runtime, others only use the configuration at startup (so would need to restart those applications for the new config to take affect), while others use the configuration at compile time. So depending on how they're designed, will affect whether you need a config or not, and how you can do that. If it's anything you're building from scratch/control, then you can design those applications so they do not need configuration. Why are you wanting to avoid configurations? Do you have a problem with maintaining that configuration? Or are you wanting to avoid restarting the VM itself?
Thanks for the considered reply. I guess what I was talking about was something like a quotation engine. If you need to add a new quote calculation for a company you usually provide an XML upload or a GUI tool to allow this without needing to do a full release of your platform. This avoids downtime and/or release and test costs which can be significant even for a small change in a traditionally coded platform. The approach may also limit flexibility in what quote steps you could create and have upfront build costs for the mechanism. I'm wondering if a platform built in elixir could operate a model where new quotations are directly coded and released, enabling greater flexibility but with much reduced downtime, test and deployment costs due to ability to live release and atomicity of the changes to modules/functions.
Sure you can do it that way in elixir if you wanted. Just having the ability to do hot upgrades isn't always as simple as add some new code and the system will work without any data loss, to prevent data loss you might also need to update any of the live data in the system so it can still work with the changes you've made to the code (luckily if you follow OTP you can do exactly this). Now I disagree that simply because you're taking advantage of hot upgrades you're able to achieve: &gt; reduced downtime, test and deployment costs More often than not I'd actually say it's the opposite. The alternative you're suggesting there's already a prebuilt system and then they're just updating some config file. After they've designed and tested the system, assuming they've tested all the conditions, then they can be sure that simply making some changes to the config won't break anything. I'd also imagine it to be much faster changing a config too. Whereas if it's code, well depending on the change, that might be a new thing to test, you might've introduced bugs into the old code, and the time spent coding it out likely takes longer than it would working with a configuration that you've specifically designed to do just this. And as far as costs the other thing to consider is who is making the changes. If it has to be done in code, well now you're limiting it to only your engineers. Whereas if it's a GUI tool, you could probably get or train some lower cost employee to do that. But I will agree you do now have that additional flexibility. As your config is limited by the amount of functionality you've designed to support, while a code change can effectively do whatever you want. However the two don't need to be exclusive of the other, you could build a configurable system and any time you need some functionality that isn't supported, you can do a hot code upgrade. Now regarding hot code upgrades, they aren't necessarily the best solution for any code changes. They're simply one tool. Some other options you have could be storing the state somewhere, then redeploying the project and initialising with that state. Or if you want to avoid downtime, if you have at least 2 nodes established you could design it so you instruct the node you wish to take down to no longer accept new connections, and to pass all existing connections and state it manages over to the other node. Once that node has finished doing that, you can safely redeploy that node without worrying about dropping any connections. Anyway not trying to say you shouldn't go about it the way you're thinking, as maybe that is the right approach for your needs. But these are some other things to consider. Either way all of this is doable in elixir so you have a lot of options at your disposal. 
I'm just learning and it was a thought I wanted to explore. Thanks so much for giving me some insight on it that I can run with 👍
Are you recommending EEx?
I got some great feedback on \[my last post\]([https://www.reddit.com/r/elixir/comments/agmiz0/cool\_clis\_in\_elixir\_with\_iowrite2/](https://www.reddit.com/r/elixir/comments/agmiz0/cool_clis_in_elixir_with_iowrite2/)), so I'm hoping I can get the same last time. &amp;#x200B; If you have any questions or thoughts about how I can improve, please let me know here or \[on Twitter\](https://twitter.com/dnsbty)
I'm super excited to work through this later. Scenic looked really cool, but I haven't had the time to really play with it. This might be a good excuse to make it happen.
Yes, why not?
I may soon need to do that. Should anyone have a piece of code that'd be great :)
Hey thank you! I really liked your post! It is very informative :)
Good to hear! Was there anything in particular that you liked about it? Or anything you think I could have done better?
Messages are a fundamental part of concurrency in Elixir. In this article I introduce how messaging between processes work. We play with simple examples to see how a process sends and receives messages. 
Best Elixir blog out there.
thank you :D
very good and clear explanation, thanks!
Take a Look at Riak Core. I am actually thinking about putting together some course where about that, but it is not on the top of my list yet
I did a demo of using libcluster with kubernetes, it worked pretty well and was easy to setup. I have the example repo on GitHub as well but it’s years old now so ymmv. At this point though I’m not sure BEAM and k8s are fit for each other though. They’re basically two technologies trying to solve the same problem, except k8s is built for containers and is a bit more stack agnostic. Currently the clustering stuff in BEAM is designed to talk to other nodes like they’re in the same rack/on the same switch, and depending on your workload you may notice this more. That being said I believe Ericsson is working on modernizing the clustering communication so it’s not as gossipy and can scale to thousands of “nodes”. I believe that work has been in progress for a few years though.
Are you an software architect ... doing import &amp; export ?
it's not released yet, but you can use it since it's now a public repo :)
I've been waiting for this!
Correction: not released. Only made public. ty u/onelesd. 
Hey, I've been playing with Elixir for a few months and decided to write some small "guide" for those who want to learn Elixir. There is a lot of resources and the ecosystem is quite big, so it could be a bit overwhelming for the beginners (just like it was a bit for me). I really recommend to just dive in and start coding. It's a joy to program in Elixir and I hope that more people get to know it :)
Nice! I also got a lot of value from Programming Elixir, and Elixir in Action books when getting started.
Yes, thankyou very much for sharing, you've obviously gone to some effort to prepare this post and it's much appreciated by us Elixir noobs. I've also read some of your other posts and you explain the scope of things very well! 
There goes my weekend.
thank you for the write-up! just a heads-up, this is how the site is looking for me on tablet resolution https://i.ibb.co/2ZLSDnd/Screenshot-2019-03-14-20-39-31-171-org-mozilla-firefox.png the sidebar is taking half of the screen
Really excited about this!
You can use libcluster, maybe together with swarm ([https://github.com/bitwalker/swarm](https://github.com/bitwalker/swarm)), to make a cluster with K8s. It's pretty easy to setup. Also you can take a look at [https://lasp-lang.readme.io/](https://lasp-lang.readme.io/) :) 
Both peerage and libcluster are good, I think, for your problem and are solving very much the same problem. One of the great things about Erlang is that it handles node connection / heartbeat / failure recovery for you. We are using peerage in production for several products that have k8s autoscaling functionality (powered by some statsd metrics) and I have never had an alarm go off for broken clustering. Distributed state is a trickier beast that I'll leave to others. Your particular data needs will very heavily bias that answer from simple to complex. I've been able to get away with pg2 and change broadcasts because I don't need a lot of the bells and whistles that come with other tools.
Actually I'm in latex
Hey, thanks a lot for heads up! I hope it's fixed now :)
thank you :) Can you please tell me what is your background, if you use elixir/phoenix in production and if is there any specific topic I dig into in one of the next articles?
This is amazing. Can someone compare this with Drab? I tryed Drab before and was suprised how big can assigns context became.(~500kB transfered through websocket on every action in my case)
Hey I can't speak to drab but did want to mention about payload size. At Lonestar keynote (not online I believe), Chris demonstrated the small payload size for a variety of decently complex cases. This is achieved through an efficient diff algorithm. There are a few cases the it doesn't handle yet, but I'm sure it will given the pre release state.
why
You can do what you want. I am always considering JSON:API specification since if it's a public API developers can use already written clients for JSON:API format. If this is private only, I would probably not bother and do some small responces that are sufficient.
Someone who migrates from Elm to Js due to a breaking change should not be taken seriously
 I find it odd that you would provide a `404` with a title not found as json when that is the status code and status text or a 404 http status. `assert_raise` with the `Ecto.NoResultsError` probably shouldn't be in a controller test, phoenix should return a `404 Not Found` when this is thrown. According to the json api this is compliant. " server **MUST** respond with 404 Not Found". An alternative is to not throw the exception and handle it yourself. &amp;#x200B; # context module Documents def get_document(id) do case Repo.get(Document, id) do nil -&gt; {:error, :document_not_found} record -&gt; {:ok, record} end end #controller def show(conn, %{"id" =&gt; id}) do with {:ok, document} &lt;- Documents.get_document(id) do render(conn, "show.json", order: order) end end # fallback controller def call(conn, {:error, :document_not_found}) do # handle it end &amp;#x200B;
I'd say there's definitely enough to get started. Once you finish that, skim through the standard library documentation and you should be good to go. 
Thank you for your reply. It's because there is predefined format for errors and if you follow it for all errors (404, 500, validations), then JSON:API clients can easily parse it the same way... yes it's not a must, but may (https://jsonapi.org/format/#error-objects). Actually the reponse is easy and I am returning it exactly as I want by overriding ViewError in Phoenix. The problem is the test. I know the solution or not throwing an exception, but that's not acceptable imho. In other words even if you forget about JSON:API and want to check the status code of 404 in the test, you cannot... or at least I don't know why. &gt; assert_raise with the Ecto.NoResultsError probably shouldn't be in a controller test Exactly my point...
I'd say that [https://elixirschool.com](https://elixirschool.com) could be your next destination on this Elixir party bus.
I had to look at a lot of different things (elixir schoo, dave thomas 'elixir for programmers' course, getting started guide). In the end, Elixir was the ONE language where I didnt feel confident just reading and doing small practice though. I had to actually build something large (an actual app), and the functional programming style just cant be explained in tutorials, it has to be experienced. Even if you comprehend everything, you wont truly 'feel' it until you try writing code flows without using if statements or loops. I would say actually building something is 100x more important for elixir than other languages ive learned. Thats probably not elixir per say, but maybe just functional style after years of imperative.
`Ecto.NoResultsError` is only being thrown because the controller is calling `Repo.get!/3` [https://hexdocs.pm/ecto/Ecto.Repo.html#c:get!/3](https://hexdocs.pm/ecto/Ecto.Repo.html#c:get!/3) Remove the "!" and use a case statement to check for nil and return the correct response. A standard 404 or custom error objects. You can test for 404. test "not found when document...", %{conn: conn, document: document} do response = build_conn |&gt; using_basic_auth(@username, @password) |&gt; get(Routes.document_path(conn, :show, document)) assert text_response(response, 404) =~ "Not found" end This is a good reference for testing and overwriting the default phoenix 404 behavior. [https://hexdocs.pm/phoenix/testing\_controllers.html#show-when-the-user-is-not-found](https://hexdocs.pm/phoenix/testing_controllers.html#show-when-the-user-is-not-found)
I really recommend Dave Thomas course on Elixir. He is really good!
So there is no other way other than not using the bang methods? Because Phoenix already catches this exception and maps it to appropriate views....everything is working, just the test cannot be written. It bugs me :D. I guess this is because get(conn, path,..) helper is not the full story here and I might need a higher level tests than controller tests... Ok, from your link this is clear: &gt; Our controller action needs to handle the error thrown by Ecto. We have two choices here. By default, this will be handled by the phoenix_ecto library, returning a 404. However if we want to show a custom error message, we can create a new get_user/1 function that does not throw an Ecto error. It's just not possible. Thanks again, I guess I will either have to change Ecto bits or not test the end result...
This dismissive attitude is not helpful. There are lessons to be learned here and we should be listening. Especially given that he migrated to clojurescript which does not have the problems mentioned with JS. From the talk, it seems that "the Elm experience" pushed them to explore other technologies, and they found in Clojure a more integrated environment than Elixir in someways (i.e. clojurescript -&gt; clojure -&gt; datomic) which there is no equivalent in Elixir for (although Elixir is more integrated in other ways, such as the tooling, frameworks, etc). I would guess that, if Elixirscript was production ready, they would likely have stuck around, but one language to rule them all was an attractive point for them and there aren't viable alternatives in Elixir at the moment. I also wonder if LiveView would provide the experience they need (as it can be an Elm/JS replacement in some cases but most likely not a suitable replacement for games).
Oh that sounds very cool. I am hoping to see the keynote online soon.
My colleague told me there was some technical difficulty with recording. I haven't verified that but trust he heard it from somewhere reputable.
I required more than just Elixir's "getting started" to get started (no pun intended). However, nowadays when I forget how to use something I check them just to remember and they are very good with that. If you can get it, the [The Little Elixir &amp; OTP Guidebook](https://www.manning.com/books/the-little-elixir-and-otp-guidebook) is really good for beginners. I don't think you can be confident about using Elixir just after finishing the "getting started" docs. I believe if you can understand how all the examples in the "Mix and OTP" docs work, you are ready to start your own project
But why doesn’t this work? if true, else: “else”, do: “do”
Im going through [Alchemist Camp](https://alchemist.camp/episodes) right now and it seems to be ok. Has anyone had experience with this resource?
If you want to understand how OTP works n using into your projects please spend some money for this book https://www.oreilly.com/library/view/the-little-elixir/9781633430112/ It will give you good idea about how OTP works and how to use into your system to make it more scalable.
This looks like a great book, I'll check it out! I have access to it through my University's library online for free
Yeah this is the best resource available regarding OTP, also don't forget to checkout "learn you some erlang " OTP is very nicely explained there and why did they introduced it and how it helped developers to build application and focus more on business logic instead of managing other stuff. It'll b good if you have a look on Erlang too just a rapid glance not in depth. After once you build applications you can go for "beam book" and "Erlang in anger" In case u stuck somewhere you can msg me always anytime. In my github I have many elixir project repos u can check it out. https://github.com/yatender-oktalk
Are you interested in webassembly? I’d love to be able to easily call from elixir into Rust/C++ code compiled to wasm and published to NPM.
I wouldn’t mind seeing something like Django’s password upgrades. [https://docs.djangoproject.com/en/2.1/topics/auth/passwords/#password-upgrading](https://docs.djangoproject.com/en/2.1/topics/auth/passwords/#password-upgrading) 
Funny, a startup I worked for in Germany actually moved from Clojure/Scala to Elixir.
Thanks for using my library for managing the configuration (config_tuples) and spreading the word!
For me, the official guide and docs were fine to get started. However, I'd previously done both the Odersky Scala courses on Coursera, so pattern matching and immutability were already very familiar. After launching a fairly sizable project, I started buying screencasts and books to fill in knowledge gaps. The screencasts didn't work well since most were *really* outdated and the guy making them was expanding into other languages. The books were great, especially the ones from Manning and Pragmatic Bookshelf. If it's of interest, I've made a ton of Elixir screencasts over the past 16 months based on what I wished I'd had in 2017. They're up on [my Elixir site](https://alchemist.camp/episodes) and [on YouTube](https://youtube.com/alchemistcamp).
What languages had you been using previously?
https://mobile.twitter.com/LonestarElixir/status/1103408089192165398 Hopefully it will be recorded on ElixirConf
Because of how the macro is defined, the options are a keyword list, so you can enforce an order, that is exactly what the if macro does: [Source code](https://github.com/elixir-lang/elixir/blob/v1.8.1/lib/elixir/lib/kernel.ex#L2999)
In case anyone is checking this thread for an update, Chris McCord made the repo public this week. [https://github.com/phoenixframework/phoenix\_live\_view](https://github.com/phoenixframework/phoenix_live_view)
How ‘bout nokogiri ;-D
The two I see recommended a lot are Phoenix in Action from Manning, and Programming Phoenix from Pragmatic Programmer. I just finished working through Phoenix in Action and thought it was great. It walks you through creating a CRUD app with user authentication and an use of Phoenix channels. I haven’t picked up Programming Phoenix yet, but based on the table of contents it looks a little more in depth, and it’s written by Chris McCord, creator of Phoenix! I think you would be good with either choice! 
Stephen Grider has a course on Udemy that’s good, catch it on a deal for $9.99
Yes I have gone through the course from Stephen grider. It was very much useful from a beginner perspective. I suggest that option. 
I would suggest you to go for "programming phoenix" it is the best resource available out there to learn phoenix there you will learn everything about that like making video streaming app using sockets,Ecto and authentication &amp; much more. you will learn a lot through this book i would definitely recommended it.
Just checked an Phoenix in Action is currently only preorder. Is there another certain I can't see?
For me, the official guide and docs were fine to start with, but I'd previously done both the Odersky Scala courses on Coursera and was comfortable with pattern matching and immutability. After rewriting one existing rails app into phoenix, I started buying screencasts and books to fill in knowledge gaps. The screencasts didn't work well since most were really outdated and the guy making them was teaching a lot of other languages. The books were great, especially the ones from Manning and Pragmatic Bookshelf. If it's of interest, I've made [a ton of Elixir screencasts](https://alchemist.camp) over the past 16 months based on what I wished I'd had in 2017. All code works in the current versions of Elixir.
I like his react courses, but his Elixir course is pretty outdated and still teaching Phoenix 1.2.
You can read it in beta now and get updates as they come. I second the vote. The Manning books on Elixir are solid.
I learned a lot from Shankar Devy's "Phoenix Inside Out" series on Phoenix/Ecto in-depth. I'd highly recommend it. I was new to Elixir when I started it. https://shankardevy.com/phoenix-book/
Yeah it’s in preorder, however, I think it’s finished. 
Let's finally put in practice what we've seen about concurrency primitives in Elixir! In this article we see how to use `spawn`, `send` and `receive` to make multiple concurrent HTTP requests, merging the results in a single one. Then we see how to refactor our code with `Task`, which makes everything easier. The most passionate will find a small challenge at the end.
Cool! Is there any docs how to handle form inputs? It's a tricky thing in React, I wonder how LiveView handles it.
assert_error_sent is what you want: https://hexdocs.pm/phoenix/Phoenix.ConnTest.html#assert_error_sent/2
I've really enjoyed learning elixir through exercism.io. It doesn't give much insight into mix and large system design but it has been really good to learn the core modules and how to do things in an elixir way. The mentor feedback was really good too. 
Someone sounds bitter.
Yes, thank you, exactly what I was looking for:)
If you don't trust your technical partner to make technology decisions then you are not going to succeed. As an entrepreneur without a technology background you should not be deciding what the tech stack is.
I know that, and I fucking trust him. I just want a simply explanation. I'm actually not meeting him until later in the week but I'm just too excited/eager to get a better understanding. I'm asking from a direction of curiosity rather than mistrust. Hope you understand =)
I didn't get that impression out of the article
One trend I’ve seen in the last several companies I’ve worked for is a separation of a team of front-end developers and back-end developers. The front end team builds the user facing app in JavaScript. The backend team builds some web services that provide the data for the front end application. The justification for such a setup seems to come from a desire to have highly interactive UIs and eventually build native mobile frontends or allow 3rd parties to integrate with the backend in the future. The cost of maintaining the two code bases and teams in time and dollars is much more than building a single integrated web application. LiveView aims to occupy a middle ground in the design space where you can have some good interactivity in the UI, without building a separate JavaScript application, leading to reduced cost of development. If/when you need a mobile app or allow 3rd parties to access your data, then you will need to build an API, but you can defer that cost until you’ve built your core user experience.
LiveView is brand freaking new as of this week. Tons of disclaimers that it shouldn’t be used in production yet. Risky move to jump on board with that right now. Elixir is great, I use it in my day job, but I’d hold off on live views for now. 
Thanks a lot for your explanation. I think this is very clear because the company I'm currently working in is doing the front end/back end thing. My partner was suggesting LiveView and I want to get a basic understand so I can help in whatever way that I can. This is very helpful. Cheers
&gt; elixir is really scalable (n' fast), but what does it mean really in business terms? I think that synopsis translates pretty cleanly to business value, and it's an accurate synopsis. What is it you are trying to actually ascertain about the tech stack beyond that, and why? `fast` for languages means well-written code can perform a task without creating a poor user experience; `scalable` means a lot of things, but mostly that well-written code can stay fast and easy to work with in the face of unprecedented (but anticipated) usage. Perhaps you should be asking your friend?
Hi /u/kx233, may I suggest to delete this crosspost and instead post a direct link to the article? I believe it will lead to a more productive discussion. Thanks for sharing!
The Phoenix [guides](https://hexdocs.pm/phoenix/up_and_running.html) are a good place to start. 
I use the discount code elixirforum on pragprog ebooks for 30% off. Elixirforum.com is a great community to supplement reddit :)
good luck sorting things out
I found the guide at [http://elixirbridge.org/](http://elixirbridge.org/) pretty useful for getting the basics, especially coming from a rails background. It takes you through building a real-time chatroom using a controller, genserver and websockets.
Thanks for the advice. I'm still using the old interface and there it looks just like a regular link directly to the article, so I didn't realize this is an issue. I think delete/repost would be kind of spammy, so I'm going to leave it as is now, but I'll definitely avoid cross-posting in the future.
PM me your situation and email, I might be able to sponsor that book
Thank you so much. I bought the book. I saved $8.
If you're using amqp, mqtt or similar you don't need load balancing as your consumers will be pulling items of work off the queue rather than having work pushed to them.
“Elixir looks really nice, and I can't wait to use it more.”
One alternative is to give `gen_rpc` a try: https://github.com/priestjim/gen_rpc. It is almost a plug and play replacement to `rpc`. You can still connect the nodes and perform coordination via Distributed Erlang but the actual RPC happens via separate tcp/ssl connections.
Very cool! 
Sorry, I am confused. :D I thought Erlang Distribution was fine for OP?
I was referring to the thread in the cross post erlang subreddit. 
Oh, my bad then.
In this post, I detail a useful pattern for composing Ecto queries with an emphasis on readability.
Erlang clusters form a full mesh so you cannot partially join two clusters with stock distributed Erlang.
This was a fun one to write because at one point I thought Elixir had inheritance(!!). I thought GenServer function injections were done through inheritance! *Spoiler: it’s not, it's done through through \`defoverridable\`* &amp;#x200B;
Doh, you are correct. The goal is to perform communication between *clusters*. I thought it was intra-cluster, thanks for pointing it out.
Np. Probably should have made that more clear in my original comment. 
Lance Halvorsen’s book is very good too. https://pragprog.com/book/lhelph/functional-web-development-with-elixir-otp-and-phoenix Pragprog too, so you can use the same code. 
Here's a similar pattern that's worth taking a look at: https://elixirschool.com/blog/ecto-query-composition
Here are more than enough [Elixir tutorials on YouTube](https://youtube.com/alchemistcamp) to get you started.
How long does the code last?
I don't have a link but you want to Google Absinthe subscriptions. Subscriptions are the real time aspect to the Graphql spec...so you just need to figure out how Absinthe handles subscriptions. 
Jump on the elixir slack and go to the absinthe channel too. The Absinthe guys are really responsive. I don't know what the current state is, but you used to have to use a specific version of the apollo client back in the day for support with the subscriptions.
I’ve been using it for over a year now. PragProg is a sponsor of the forum so if that one expires you should be able to find a thread with a new promo code.
There is no evidence here it was politics. Is there even evidence they used it widely? I can only find mention they used it on one system and it was by one guy. Is there even evidence he was the thought leader? Also, their github repos have recent activity by pinterest employees. Sorry to say but it appears that you're losing this discussion. I've taken the liberty of downvoting your posts in this thread since they are incorrect. Have a nice day. 
Thanks 
Thanks.
We do almost the same thing in our project! Differences: - we use strings as keys so we can pass values from HTTP params as is - we’ve created a behaviour out of it, and callback modules need to implement base query, filters, and ordering clauses (this helps us not repeating the reduce in every module) - the behaviour makes the final call to repo which allows us to add pagination - if there is a filter key in the map that is not specified by the callback module, we log an error and ignore it.
thanks for sharing, that was a very nice video. As usual presentations from Jose are awesome! The first section of the talk, about how they got to creating broadway was very informative.
Thanks for the feedback!
&gt; Is there even evidence he was the thought leader? Clearly, when it came to Elixir he was. Have you ever worked in medium to large companies? They tend not to recognize the value of the really talented ones. In fact, those are the ones who are often eventually ejected for a non-conforming presence. All you have to do is 1) be smarter than your boss 2) he figures it out 3) you figure it out that he figures it out and you're fucked (at least, at that company).
Very informative post, cheers!
Fantastic, thank you!
There seems to be some kind of overlay on the youtube video that means buttons such as "watch later" no longer work. Could these be removed please?
Thanks for flagging this! Yes, that's absolutely not ideal, we'll look into it but as it might take some time for us to get to the bottom of why it's doing that, here's the YouTube link: [https://www.youtube.com/watch?v=OR2Gc6\_Le2U&amp;t=25s](https://www.youtube.com/watch?v=OR2Gc6_Le2U&amp;t=25s)
Oops just saw that you already found the youtube link!
Thank you! :)
Dates are tricky. Having something that outputs into a predictable format for consumption by the backend is going to be your safest bet. You might want to use a date entry JS module or something so you get predictable input. Just as a basic example, month and day are reversed depending on where in the world you are. There are way more complexities as well.
This is such a great talk. The first 20 minutes apply to every programmer in every language and gives plenty food for thought - the next part has a lot of practical tool suggestions, some of which I'll definitely need to look into. It's also a great showcase of how many goodies the Erlang platform packs in terms of operability.
The dates come from user input in the title fields of Basecamp2 posts, which we retrieve through their API. Date stuff sucks in general, but this system isn't protecting the launch codes. It's OK if it misses some edge cases, At some point, we will refactor to control the user input, but I don't have time for that. I just want an easy, quick-and-dirty solution so I can move on. What I did after posting this is hand-parse the first few formats I've seen. It's mind-boggling how creative people can get, though. Curious if there's something better out there, but googling didn't turn up anything.
I've done something like [this](https://gist.github.com/de306bfe912fd01bb1395bac84652698) before. You can extend it to try and regex replace stuff.
Notably, one of the biggest issues with "automatic" squishy date inputs... is that there's a bunch of dates that can be arbitrary. I mean, with an uncontrolled input, what date's 01/12/2018? Because there's 2 perfectly valid responses, almost 12 months apart. It's worse once someone decides you just need the last 2 digits for years - 11/02/09 can be like 6 different valid dates (Feb 11, 2009; Nov 02, 2009; Feb 9, 2011; Sept 02, 2011; Sept 11, 2002; technically Nov 09, 2002 (though that last one's really stretching)). Trying to infer off of that can get you very wrong data. To the point where a correct guess is actually the edge case - because e.g. 27/02/2019 has only one valid date, but 2 days later has 2 interpretations even in the same form.
In the past, I've been satisfied with the browser implementations of JS date objects. I've found them Pareto-optimized for many use cases. By this point, I have a function with a list of of Timex formats that should cover most likely inputs and hold up for the basic, ephemeral KPI tracking we need it for.
I'd love to see some of Pry's features ported. For example in a pry session, I tend to call \`show-source\` and I miss it in IEx.
For what it’s worth, I had zero Ruby experience when I decided to start tinkering with Elixir nor had I ever worked with a purely functional language. It was a little difficult at first, but now I would never go back. The resource that worked best for me was the Elixir Bootcamp on Udemy by Stephen Grider. I usually prefer books but for some reason it made things click. 
For learning I can also recommend the official getting started and docs: https://elixir-lang.org/getting-started/introduction.html https://elixir-lang.org/docs.html
How fast did you get a job in Elixir? Have you been ever rejected ?
I'm pretty interested in elixir for web development. Are you expecting phoenix live view to make a big impact on the popularity of the language? 
Job? Elixir? This language is just for fun
I do not agree :(
Yes. It gives you almost the same as React.JS in about 80% of use cases for the fraction of effort.
I didn’t get a job in Elixir, we just began using Elixir in a few projects at my current job. I know of at least 5 companies in my immediate area that are now using Elixir so I assume the jobs are out there. 
I am three weeks in on a part-time Phoenix gig that might turn out to be next full time job. So pretty much still figuring out basics (and annoying people at Elixir Slack) like testing custom error messages and other things for proper JSON:API spec, integration with Swagger or Blueprint generators (not a good luck so far, will probably do it manually as always). I with I could say more about it, but I cannot, hopefully in the future. I am also thinking about starting a completely new app on the side for learning or rewriting one of my side project in Elixir.
I'm working on a statically typed language for the Erlang VM, it's called [Gleam](https://github.com/lpil/gleam) There's a thread to chat about the language on the [Elixir forum](https://elixirforum.com/t/gleam-a-statically-typed-language-for-the-erlang-vm/20349)
I got a job writing Elixir/Ruby with only Python experience. Any good company is going to test you language agnostic anyhow.
I came from Ruby background (and PHP and Linux and what's no), but I am convinced I would get the contract even if coming from other language. Either you were a good engineer or not. You have to learn Elixir on the job even if coming from Ruby so I don't see a big difference. As an ex-CTO I can tell you I would welcome someone from mobile background! &amp;#x200B; It will help, however, if you read on a bit on functional programming.
I'm working on a port implementation for \[Enigma VM\]([https://github.com/archSeer/enigma](https://github.com/archSeer/enigma)) this week :) once that's done, I should be able to release builds with a working erlang shell!
I'm building a tick-based 4x space strategy MMO backend that will share aspects of Planetarion, Eve Online, and Stellaris.
&gt; Should I build solid portfolio with Phoenix projects before even apply some resumes? Don’t wait, just start applying. But working in some projects on the side to get familiarity will only help. But yeh, don’t wait to apply, there’s no point in waiting. 
Try out [timex](https://hex.pm/packages/timex) it sounds like it might be what you’re looking for. 
Related video: José Valim - KEYNOTE: Announcing Broadway | Code BEAM SF 19 [https://www.youtube.com/watch?v=ZOExnT1PYjs](https://www.youtube.com/watch?v=ZOExnT1PYjs)
Thought this was a neat trick that a lot of folks are not aware of. I find it especially helpful because I never remember how to "cancel" an IEx command, and up just entirely exiting out of IEx.
Please can someone tell me why elixir tanked so much in price like that ? What's happening ? What triggers the sell off ? 
Wrong sub yo /r/elixirtoken
Here's a sneak peek of /r/elixirtoken using the [top posts](https://np.reddit.com/r/elixirtoken/top/?sort=top&amp;t=all) of all time! \#1: [2,000 upvotes and I'll donate 10,000 ELIX](https://np.reddit.com/r/elixirtoken/comments/7qap65/2000_upvotes_and_ill_donate_10000_elix/) \#2: [If this gets 2k upvotes by the 25th, I'll give away 10k ELIX](https://np.reddit.com/r/elixirtoken/comments/7kbvnz/if_this_gets_2k_upvotes_by_the_25th_ill_give_away/) \#3: [If this gets 1k up votes, I'll donate 1k elixir](https://np.reddit.com/r/elixirtoken/comments/7h9afy/if_this_gets_1k_up_votes_ill_donate_1k_elixir/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
The productivity level of building a Phoenix + Liveview application is going to be very compelling. If the application fits LiveView well, it'll be a no-brainer. Get it done in a fraction of the time? Yes please. React/Vue/Angular + JSON API/GraphQL API is a lot of pieces to put together, learn, and iterate on. The time it took for me to pick up Liveview and build something was a couple days. It took me quite a bit longer (weeks) to figure out React and all the prerequisite pieces you need to make a reasonable application. Even after that time with React I wasn't happy with it. So many dependencies, unknowns, and complications of the combination of libraries. React itself is simple, but add a UI library, React Router, Recompose, Axios, and whatever Webpack and Babel hoops you need to jump through and you're in for a lot of mental cycles to get anywhere. It's not a perfect comparison: I'm a better developer now plus I already know Phoenix and that's the bigger piece than LiveView. However it's clear enough that adding features with LiveView takes **a lot** less effort. It's going to be very interesting to see where LiveView goes in the next year. 
This just came through on the Elixir Forum summary, thought it was worth sharing here: [Joe Armstrong on OOP](https://elixirforum.com/t/the-oop-concept-according-to-erlang/21078/10)
Wow this is amazing! 
I need this in my life, thank you!
tried, iex sessions are not saved, only erl. anyone got this behavior?
Me too. Not sure why.
Looks like there are some solutions discussed here: [https://github.com/elixir-lang/elixir/issues/6475](https://github.com/elixir-lang/elixir/issues/6475)
Definitely fewer jobs but there are more than every year. Last job was Elixir and Ruby and I just got an offer from a local startup that's 100% Elixir at well above market rate. I'm looking forward to it.
Is this an exercise you are doing for fun? If not you could just go \`foo |&gt; Enum.sort\_by(fn {\_,freq} -&gt; freq end)\`
the video doesn't play on safari/mac . the play isn't clickable.
Wouldn’t be great to process a large HTTP response, in chunks, with Elixir streams? Something like: ```elixir HTTPStream.get("https://.../large_image.tiff") |&gt; StreamGzip.gzip |&gt; Stream.into(File.stream!("image.tiff.gz")) |&gt; Stream.run ``` In this first of a two-parts article, we see how to transform an HTTPoison async response into an Elixir Stream, to easily process large remote files on the fly, gaining code clarity and reusability.
Wow i was just thinking of almost that same thing. Are you thinking of doing realistic gravity etc or more arcade style?
Concatenation. Don't know of anything else though. iex(1)&gt; hop = "meow" "meow" iex(2)&gt; hop2 = "waf" "waf" iex(3)&gt; hop &lt;&gt; hop2 "meowwaf" &amp;#x200B;
While im no expert, from what im reading in the getting-started guide, strings in Elixir are encoded as binary. So the &lt;&gt; operator is a binary concatenation operator. Binary data can be defined using &lt;&lt;&gt;&gt; so &lt;&lt;1,2&gt;&gt; &lt;&gt; &lt;&lt;3,4&gt;&gt; = &lt;&lt;1,2,3,4&gt;&gt;. So the answer what it does and what its for: it joins binary types, and strings are encoded using UTF8 which is binary, so it joins strings. &amp;#x200B; Been a long day, so hopefully my explanation is understandable. &amp;#x200B; [https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html](https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html) &amp;#x200B;
Too add to this: erlang was created to manage small binary packets in telephone switches. That is why erlang/beam etc have really good binary operators including very good pattern matching. So if you get a package where, the first 3 bits is an id, the next 3 are an address, and the rest is data; you can pattern match based on the id and address too know how and where to send the package. Its a really efficient way of parsing a lot of small packages very quickly. &amp;#x200B; &amp;#x200B;
Thanks all. I should have been more specific. But in the example... iex&gt; "Authentication: " &lt;&gt; credentials = "Authentication: Basic bla bla" iex&gt; credentials "Basic bla bla" iex&gt; Authentication: \*\* (SyntaxError) syntax error before: authentication iex&gt; Authentication: credentials \*\* (SyntaxError) &amp;#x200B; I was trying to figure out exactly what this was doing but I kind of see this now. I don't fully understand why after concatenation "credentials" is binded with "Basic bla bla" and not the full concatenation of "Authentication: " &lt;&gt; credentials" &amp;#x200B;
Ahh. ok this makes alot of sense now! 
 https://stackoverflow.com/questions/38507273/what-is-the-operator-in-an-elixir-function-signature
"Strings" in Elixir are actually just a kind of binary type. So `&lt;&lt;97, 98, 99&gt;&gt;` can be represented as `"abc"` if it's meant to act like a string. `&lt;&gt;` is the "binary concatenation" operator, which essentially just means joining two pieces of binary data together into a single piece of binary data. And because strings in Elixir are binaries, to join strings together you use the binary concatenation operator. `&lt;&lt;97, 98, 99&gt;&gt; &lt;&gt; &lt;&lt;100, 101, 102&gt;&gt;` will result `&lt;&lt;97, 98, 99, 100, 101, 102&gt;&gt;`, which can be interpreted as `"abcdef"` if meant to appear as a string. Try it out in iex!
 [https://www.youtube.com/watch?v=ErmCWhmzP7c](https://www.youtube.com/watch?v=ErmCWhmzP7c) 
`credentials` becomes bound to "Basic bla bla bla" because it's pattern matching. It finds "Authentication: " on the left side, and whatever remains is bound to the variable `credentials`.
This is pattern matching. You're matching the string literal "Authentication: " followed by anything. credentials will bind to whatever you put after "Authentication: ". If you change "Authentication: ", it won't match.
= is a pattern match operator, not an assignment operator. The left side of the expression (the pattern) is being compared against the right side (the term). The first part of both sides of the expression are binary literals, so the match continues. Since the second part of the pattern is a variable Elixir binds the remainder of the right side's term into it. Note that because Elixir allows rebinding of variables, even if credentials variable is already bound, the expression will succeed because the variable will be re-bound. However, you can prevent this and force the variable's current contents to be matched with the ^ pin operator. If either a) the literal parts of the pattern/term don't match, or b) the credentials variable is already bound and pinned, the expression will return a MatchError: iex(1)&gt; "Authentication: " &lt;&gt; credentials = "Authentication1: Basic bla bla" ** (MatchError) no match of right hand side value: "Authentication1: Basic bla bla" (stdlib) erl_eval.erl:453: :erl_eval.expr/5 (iex) lib/iex/evaluator.ex:249: IEx.Evaluator.handle_eval/5 (iex) lib/iex/evaluator.ex:229: IEx.Evaluator.do_eval/3 (iex) lib/iex/evaluator.ex:207: IEx.Evaluator.eval/3 (iex) lib/iex/evaluator.ex:94: IEx.Evaluator.loop/1 (iex) lib/iex/evaluator.ex:24: IEx.Evaluator.init/4 iex(1)&gt; "Authentication: " &lt;&gt; credentials = "Authentication: Basic bla bla" "Authentication: Basic bla bla" iex(2)&gt; credentials "Basic bla bla" iex(3)&gt; "Authentication: " &lt;&gt; ^credentials = "Authentication: Basic bla bla1" ** (MatchError) no match of right hand side value: "Authentication: Basic bla bla1" (stdlib) erl_eval.erl:453: :erl_eval.expr/5 (iex) lib/iex/evaluator.ex:249: IEx.Evaluator.handle_eval/5 (iex) lib/iex/evaluator.ex:229: IEx.Evaluator.do_eval/3 (iex) lib/iex/evaluator.ex:207: IEx.Evaluator.eval/3 (iex) lib/iex/evaluator.ex:94: IEx.Evaluator.loop/1 (iex) lib/iex/evaluator.ex:24: IEx.Evaluator.init/4
Another excellent post, looking forward to the next part! 
I met him at Elixirconf in Seattle last year. That dude knows his stuff. Super cool as well. 
Thanks :-)
Yeah, I'm just doing it to develop a bit of fluency with elixir. Thank you though :).
&gt;As the client insisted on delivering an MVP as soon as possible, we simply didn’t have the time to spend on polishing our Elixir and Phoenix skills. ASAP = use Rails &amp; Phoenix where Rails would do just fine? Seriously, would anyone want to work in architecture like this? This is so over engineered. The post makes sense if you are trying to migrate from Rails to Phoenix. Building something like that from 0? It doesn't make any sense. &gt;It’s hard to say whether a pure Rails implementation would take us less time. Yea, very hard... :facepalm: As much as I like Phoenix, I wouldn't want to work with this project. If you are gonna use MVC framework, just choose one. It's already hard to find a Ruby or Elixir dev, but both? There is so much wrong with this post that it triggered me:/ This is so over-engineered and badly designed. I wouldn't want to be a developer that gets that code later and has to implement features/maintain the codebase.
I don't know if this is the only problem, but in your second sortf function, you are dropping the head of the sorted list if that pattern match succeeds. Try this. `def sortf({_, freq} = element, [{_, compFreq} = el2 | t]) when freq &gt; compFreq do` `[el2 | sortf(element, t)]` `end` &amp;#x200B;
Thanks for the feedback - we'll look into it!
I find it's easy to miss important releases or articles. I'm working on a custom feed that will tell you the software news, releases, etc for the languages / packages you use. It's live at [Version Conflict (https://www.versionconflict.com)](https://www.versionconflict.com/). You can use it without an account, but registering is where most of the features are. &amp;#x200B; I was using GenServers for job processing, but switching to [honeydew](https://github.com/koudelka/honeydew) queues really streamlined my data pipeline. GenStage is interesting, but I had trouble grokking how to implement it for my use cases.
Yeah thank you, i realized that after embarrasingly long hahah. I just copypasted from sublime, could turn on tab = 4 spaces. Maybe thatd help readability.
Basically, the entire map is a giant DAG(1), much like that of Eve Online's, though the one I have planned is far larger. The server will tick as planetarion(2) does every 20 minutes, updating fleet location, player resource and cash balances, etc. In the game, there will be various NPC factions, all with dispositions varying from hostile to friendly, much like Stellaris (3). I'd be totally open to bringing on collaborators. Jussayin :) 1: https://en.wikipedia.org/wiki/Directed_acyclic_graph 2: http://www.planetarion.com/ 3: https://store.steampowered.com/app/281990/Stellaris/
**Directed acyclic graph** In mathematics, particularly graph theory, and computer science, a directed acyclic graph (DAG (listen)), is a finite directed graph with no directed cycles. That is, it consists of finitely many vertices and edges (also called arcs), with each edge directed from one vertex to another, such that there is no way to start at any vertex v and follow a consistently-directed sequence of edges that eventually loops back to v again. Equivalently, a DAG is a directed graph that has a topological ordering, a sequence of the vertices such that every edge is directed from earlier to later in the sequence. DAGs can model many different kinds of information. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Great video. One small suggestion if I may, I went to your "Elixir Foundation" series but was sad to see videos mostly related to Phoenix. Perhaps you can create a separate one for Phoenix and Elixir like how you have done for Rails and Ruby? :)
 I didn’t cover Phoenix in my video series perhaps you looked at the wrong one? I cover how to build an Elixir app solving server side rendering. I will cover Phoenix later.
My bad, I meant to say elixir the language instead library like cowboy. Right now I am looking for quality elixir tutorials in the intermediate level FYI :)
We have 26 episodes right now we cover cowboy / plug for about 5 episodes. The rest are all elixir concepts of writing elixir code, structuring an elixir app, Otp, GenServer etc...
Thanks! My mistake for skimming through them, I will check them out.
Yes, it would be possible, though if you start a new container from the same image you would need to apply the hot-update again as changes are not persisted back to the original image as they are immutable. &amp;#x200B; Why is it that you want to do this?
Should be able to do it by creating a volume in docker compose yml file. That volume will allow you to map files on your machine to the ones in the container....so when you make changes in your local folder it will see the same changes in the container.
Just wondering, have heard that Docker is unnecessary as the BEAM VM supports hot reloading and most of the things people use Docker for. 
I don't think that docker solves any of the problems that hot reloading solves, and the other way around. &amp;#x200B; Docker is solves the problem of isolation and repeatable builds. Deployment using it generally mandates being able to restart application instances to replace the running docker container. Hot reloads solve the problem of being unable to restart application instances (i.e. network switch firmware that cannot have downtime) &amp;#x200B; There are plenty of ways to approach deployment of Elixir applications, all are valid and have their own set of advantages and disadvantages. RE hot reloading I would say that it is not a good time investment if you can afford to restart instances, which you likely will be able to unless you are making uptime critical embedded firmware.
This would put your entire release in the volume, making the docker container empty.
The image/container could have the erlang, elixir, and other dependencies installed, and the mounted volume could have just the source.
Hot code upgrades don't work by copying the code around, you have to prepare an Erlang release which would contain all of the items you have listed. 
I'm working on [parallel directory tree traversal](https://github.com/thomasbuttler/ParallelTreeWalk) If Linux has cached everything in RAM, or even if your storage is direct attach SSD, this won't do you any good - the processing overhead will simply not be worth it. However, if you're waiting on spinning rust, it will keep the elevator algorithm fed, and if you're using NFS, it will keep your file server much busier. The idea is, instead of doing nothing while waiting for the result of a stat() call, to have dozens of stat calls in flight at once. Try timing with +A32 or +A128 to the erlang VM to find the sweet spot for your environment.
I don't really think that's true. Beam doesn't solve:
I don't really think that's true. OTP may solve some of the same things, but only given that you work in an exclusively erlang ecosystem, which is a big asterix in a world where many companies exactly use docker to have stack-agnostic CI pipelines etc.
Docker is overrated
I agree, elixir is a perfect fit. 1 thing which concerns me is that most of it is handled server side. Which means to always have an active connection from the client to the server, this could potentially (for mobile) cause issues. 
Nice
And just published my first Elixir article: [http://nts.strzibny.name/basic-http-authentication-in-elixir-phoenix/](http://nts.strzibny.name/basic-http-authentication-in-elixir-phoenix/) &amp;#x200B; I hope to publish more as I learn to answer questions for others.
Getting a "ReferenceError: 'Promise' is undefined".
must be a problem with convertkit, worked ok for me
You can try [elixir school](http://elixirschool.com/) where you can also contribute back to the project as you learn.
Great job, thank you all!
Wow, really cool!
Nice write up. FYI the layout of the site is unusable on mobile, the fixed header takes up like half the screen 
Thanks, I will work on fixing that tonight. I have some other performance (loading) improvements but those will have to wait until I can break things ;)
I yanked the logo and sized the text relative to the viewport, should be much better. Sorry about that!
Super cool... But just a question about using elixir _(since I'm mainly using ruby but interested to learn elixir and also a fan of raspberry)_ with the raspberry... Do you choose it on purpose for learning? Or does it bring something that usual python couldn't?
Hi! &amp;#x200B; \&gt; Do you choose it on purpose for learning? I started learning Elixir before I knew about Nerves, once I found out about it (Nerves) I decided to scratch some hardware itches I had. Elixir was used over Python to immerse myself in the ecosystem as much as I could. Now I use it because I enjoy it so much and it has some awesome benefits (see below). &amp;#x200B; \&gt; Or does it bring something that usual python couldn't? One powerful thing that Elixir/Nerves provides over Python is fault tolerance. This is very helpful when you have code that fails because a sensor has died, or returned garbage data. The process can die, restart, and continue on. The weather station I built had its temperature sensor fail and the rest of the application kept reading / reporting data from the remaining sensors. &amp;#x200B; Diving into the production end of the spectrum there is NervesHub which allows you to create pipelines of firmware and update devices in the field. Super cool stuff! &amp;#x200B; Feel free to send me any questions you have, I'll try to help as much as I can ;)
As an aside, this makes me want to write a title generator. _a/an **XXX**-like language for the **YYY** [VM|processor|platform] with a [compiler|interpreter] written in **ZZZ**_
[https://liveview.zorbash.com/](https://liveview.zorbash.com/)
Looks great! Good job! Something like this has been on my mind for some time, but haven’t set out to do it yet.
Super cool!
Hi! Author of the demo here. I'd say that roughly 40% of observer\_cli has been ported at this point. Feel free to ask me questions. Would anyone be interested for a hex package of this?
here is the youtube link if anyone wants to you know. be able to click share or speed up the video etc. https://www.youtube.com/watch?v=ieljR3gPTaQ
I just blogged about this, have a read: [https://zorbash.com/post/observer-live/](https://zorbash.com/post/observer-live/)
Absolutely, but last time I tried it was less than ideal to offer packages using Phoenix web sockets. See my outdated package that does something similar, step 5. https://github.com/mgwidmann/flames/blob/master/README.md Still could be done, none the less.
Any idea why some of the numbers keep changing back and forth very dramatically? As if it is switching between two nodes.
If you still haven't bought the book, it's on discount again. Use the promo code "aintnofool2019" for 40% off. The code's valid until midnight April 3 (not sure what time zone).
Haven’t watched the video yet but scanned the slides. Unless there’s a bunch of unscripted content in the middle, this seems disappointingly sparse of technical content and includes a dash of vendor pitch. RedHat/CoreOS have skin in the game for promoting the idea of Kubernetes operators and claim to have basically invented the idea, which is up for discussion. It’s actually kind of weird to see that, a few slides after the explicit reminder that Kubernetes itself is a product with marketing spin. Anyway, if anyone reading this happens to want to write an Operator in Elixir instead of Go, check out the Bonny package on Hex/GitHub. I had a lot of fun tinkering with it a month or two ago. I do recommend some knowledge of Kube primitives and keeping the Kube API references open.
phoenix js has reconnect baked in with a backoff
Do you know why the WebSocket would not re-establish? If you were using Phoenix, it should attempt to re-establish in an exponential backoff, so the initial 3-4 attempts happen within \~15 seconds. You can customize this to be more aggressive as well. &amp;#x200B; Some people use long polling for mobile because it's more resilient to the particular issues that mobile provides with regards to network reliability.
Data connection on mobile should not be considered reliable period. That does not mean you should avoid websockets or long polling, however you should ensure you construct your app to fail gracefully (and retry gracefully) wherever possible. Pheonix's implmentation of websockets does retry connections automatically very well, but you can also do things like have an indicator that dislay is not being updated or that the user has lost connection by using [navigator.onLine](https://navigator.onLine); you can even manytimes understand if the user is working off of cell or wifi on mobile devices with navigator.connection || navigator.mozConnection || navigator.webkitConnection; and have your interface mutate to handle the situation if it warrants. 
MVP does not necessarily mean low traffic. I agree that it is a convoluted setup, however it does appear to offer the advantage of piecemeal binging the rails side into elixir land as their team ramps up on the language while providing for a large bang-for-the-buck performance baseline against most of their end user traffic. &amp;#x200B; It seems like a "fair" tradeoff in complexity to get to market with a baseline core in the language they would like to eventually live in while placing some of the MVP quick build items in a language that they are more comfortable in. That is, assuming that the MVP is being built to drop in market with a know traffic level that requires speed optimizations. Knowing that MVP implementations don't always come to life when just entering the market from ground 0 but are also fairly common (especially for development vendor engagements) for situations like a "come save our asses from a horrible underperformaing implementation that cant stand up to our current traffic even with tremendous scale out". 
This is a second part of [the article of last week](https://www.poeticoding.com/elixir-streams-to-process-large-http-responses-on-the-fly/). This time we are going to process on the fly a 30 million lines remote file, summing the numbers on each line. We will see how to implement the functions we need to convert a stream of chunks (the one built in the part 1) to a stream of lines. We'll then run a benchmark of two different implementations. We will then see how easy and quick is to process just the first 30 lines of the same 125mb remote file.
Finally getting around to replacing our "current real-time feature provider" with Channels, through PushEx. I'm excited to get control of an important part of modern applications and save a lot of $$
Hey /u/derekkraan, what are your thoughts on not supervising a linked process? This means I have 2 processes, let's say my process and my library module. Rather than exposing the library setup / intricacies to the application, I do so through a dedicated module that has a simpler interface. In this case I would supervisor my process, then link the library process to mine. It's not supervised, but is linked to a supervised process. Good post and important to remember that finding a situation where supervision doesn't work may be a code smell.
Ok, fair enough. Your point of view makes some sense. BUT. It still doesn't make sense to have sidekiq in that setup. They had enough knowledge to setup REST API in phoenix. What's the problem to set up background jobs in Elixir? I see point in using rails for admin stuff. But that could have been made as a separate microservice. Instead they choose to build one monoliths in two MVC frameworks. Unfortunately, I've worked with a codebase that was done by another agency. And it was similar story to this one: some technologies were used unnecessary. I was surprised to see that /r/ruby liked that post, but whatever. I stand by my opinion, this could have been done with just rails. They would maybe pay more money for servers to scale, but they wouldn't have a stupid spaghetti code from day 0. LOL
Links are the back-up that ensure that if the supervisor dies, that all its children processes also die. So in a sense, by linking a process, you are supervising it. It just happens to be a very crude form of supervision.
Any feedback will be appreciated :)
Nice! CircleCI looks like a good option to migrate off Travis. A standardised way to build and publish hex packages for tagged commits would be useful.
It's not switching between nodes. It's mostly the IO numbers that change in that way and those, in the home tab are calculated on an interval which defaults to 1s. The IO for the demo app is mostly pushing and receiving data through the websocket connections and only a handful of users are connected at any given moment.
Well done! Thank you for sharing!
This was really helpful for my recent elixir project. Though one suggestion would be to document the distillery configuration a bit better. The `ReleaseTasks` stuff didn't work for me and I don't have the experience with Distillery to figure out what it was supposed to do.
Hi! Glad you found it helpful! Would you mind opening an issue on GitHub about that? It’s working on our projects so fixing it for you would definitely help us documenting it better.
Interesting! I kind of like how you have organized the templates, views, and controllers into each respective domain.
No but you can make a mix task for it. 
Awesome!
Nice! this would have been awesome a couple years ago for me. But starting new projects I will definitely be using it. Thanks!
Thank you! Would appreciate if there were a simple guide how to properly build a release, deploy and then update it the way it meant to be done according to this boilerplate.
There is actually nothing fancy about the task we added to OTP release. We followed the guide from the Distillery repo: https://github.com/bitwalker/distillery/blob/master/docs/guides/running_migrations.md Then wired it in our Docker setup… But like /u/remiprev said, open an issue so we don’t forget to document it better!
Phoenix Channels: A transport method GraphQL: A query language They're not really at odds with each other. You can send GraphQL over a phoenix channel (I do it all the time). GraphQL is comparable to SQL whereas Phoenix Channels are comparable to Plug (HTTP).
You can use Absinthe/GraphQL subscriptions with Phoenix Channels: https://hexdocs.pm/absinthe/subscriptions.html
Yeah it didn't look fancy. I'm just a newbie at distillery is all 🙃
&gt; GraphQL is comparable to SQL I think GraphQL is much more comparable to REST than SQL since both REST and GraphQL are competitors. But I could be wrong... 
Take the dive. You’ll figure out what you don’t know pretty quickly and there’s people/resources that can help you with that as you go along. More likely though - you’ll realise you know more than you think. 👍
You will do fine. Elixir is actually a pretty simple language. Functional programming involves more "unlearning" if you are used to object orientation and mutation. It's pleasant once you get used to it, though.
I was going to put together something similar myself..
Less is better if this is your first dive into Elixir and similar languages with functional and actor properties. Don't try to map knowledge to much, because if you make a mistake there, your view of the language capabilities are going to be formulated wrongly. Keep an open mind!
Don’t worry, you’ll be fine. There is a lot to learn when starting elixir, but it’s the same for every language. You certainly don’t need a CS degree to learn elixir or any language for that matter. If you want to dive deep into how things work, a certain background would help, but still nothing you can learn by yourself - but again, for using a programming language, the only thing you really need is motivation :)
If you've been doing modern JS you'll actually be pretty well set for it - you'll find yourself at home with familiar object decomposition, maps, filters and so on that's what I feel is the core of what you're doing a lot of the time in elixir, everything else you can pick up on the go. Some of the more uncommon concepts (looking at you, genservers) have walkthroughs (or talks, if that's your thing) explaining them to a beginner Go for it, you'll probably find it easier than you expect 
Processes have a different meaning, a process is a function with an inbox and can shoot messages out to other processes. Do not use :atoms to store dynamic content, you have a limited number of them. Arity is the number of arguments a function takes. Pattern matching is half the fun of elixir/erlang. You’re going to learn erlang. OTP is super powerful and you’re going to use functions from it all the time. Erlang is made to crash, that is, don’t write exceptions. Use supervisors to watch and restart processes.
I'd be interested to know how you've added types to the language, and if they get erased or how are they represented in the bytecode (do they compile to something similar to what the `is_&lt;type&gt;` guards compile to?).
I have the same background as you and just started learning elixir a few months ago! Lean into pattern matching, and the pipe |&gt; operator. You’ll find there’s often a very “JavaScripty” way to do things and a more Elixir way of doing it. I found the docs to be SUPER helpful, and still have them open daily when working in Elixir - but it was overwhelming at first. I started with building a rest API using Phoenix since I liked the scaffolding that the Phoenix cli gives you. There’s also a Udemy course by Stephen Grider I followed
Just start on it. It's a great language and a lot of fun to use. I learned it myself in the last few months. A few things that are useful to know, firstly when you install a dependency with Mix the full code for it is in the deps folder of your project, just looking through it can be very helpful (though expect a bit of head scratching, while it is a relatively simple language elixir is quite expressive. Ten lines of code written by someone who really knows what they are doing can accomplish quite a lot so module code can appear very dense initially. Expect a few gotchas, for instance one of the small things that had me scratching my head for a while was just writing an if statement. In javascript or similar languages you can write something like: bool small; if (x &lt; 10) { small = true; } else { small = false; } &amp;#x200B; So in elixir I was trying something similar only to find the assignment was lost at the end. Turns out in elixir you can't assign a variable inside an if statement, you return a value from it so it ends up more like: &amp;#x200B; small = if x &lt; 10 do true else false end &amp;#x200B; It's a simple thing and once you understand what's going on it makes sense that it has to work that way (Elixirs if statement is more like syntactic sugar around a function that returns a value than the if statement you are familiar with from other languages. Little gotchas like that can be frustrating but bear with it and eventually elixir just kinda clicks and you wonder why everyone else has been doing things wrong all this time :). &amp;#x200B; Finally I went through a few learning resources but I have to say the \[Pragmatic Studios Elixir Course\]([https://pragmaticstudio.com/courses/elixir](https://pragmaticstudio.com/courses/elixir)) is absolutely fantastic. 
Types are completely erased at runtime so there is no performance overhead to using typed. The flip side of this is that there is no runtime safety checks on the FFI so it has to be correct (which is same level of safety when writing Elixir or Erlang).
It’s heavily inspired by the "pods" structure from EmberJs :)
You've already learned one language successfully so Elixir will be much easier than the first one was! There will be differences, but nothing you can't figure out. Specifically the main issues you'll probably hit early on are the enforced immutability and working JSON. This should be a good spot to [get started with Elixir](https://youtu.be/G3JRv2dHU9A?t=341).
Exactly what I came here to say. If you're using Absinthe, you'll *probably* also be using channels.
You still should! There are many ways to organize an app :D
It depends. REST is a framework on how to structure APIs over HTTP. GraphQL doesn't tell you how to structure your APIs and doesn't care about the transport method. Now there's a comparison there for whether or not you should have a GraphQL endpoint, but you can serve both a GraphQL endpoint and a RESTful endpoint so they don't _really_ compete at any technical level. But they are comparable at a business level.
I was in your shoes a year ago. Self taught developer, solely in frontend JavaScript. I wanted to learn a language that had nothing to do with frontend and picked Elixir. I think Elixir is a wonderful language to go from JavaScript to and I am so glad I did! I've learned a lot about languages in general by diving deep into Elixir, and because of that, I've learned Rust, ReasonML, Elm, Ocaml, F#, and a bit of Haskell since then. Take the dive!
Well said about the unlearning. Furthermore, each language you learn makes the next easier to pick up. You’ll know most of the language in a couple of weeks and it’ll take 1-2 years to learn where all the bodies are buried. Take your time and enjoy the discovery. 
ExDoc is already great. These are some nice quality of life improvements! 
I don't think Go really compete's with Elixir/Erlang's model. The closest competitor would be Scala + Akka.
I too thought that was a weird comparison, but as I was typing a response, I realized that it's actually more correct than not.
Full-text search is going to be AWESOME!
Exactly.
As someone with somewhat messed up wrists, keyboard shortcuts are a gigantic improvement!
Elixir is simple, not much to worry about. But at some point you’ll have to learn erlang too. 
What am I looking at?
Tnx. Got it working quite fast
Looks like a simple BrainF*ck interpreter
Why pattern match on charlist instead of using matching on binary?
Memory model maybe? Also, Tasks is a high-level stuff (kinda), I'd rather start from processes, spawn, links, monitors, GC, all that. But in general it's a good list.
Thanks for your thoughts. I think the documentation is kinda the go-to resource for this topics? [https://elixir-lang.org/getting-started/processes.html](https://elixir-lang.org/getting-started/processes.html) ? Added to my list :) 
The things you listed are actually past the 20% imo. You want to start with the language before OTP. So pattern matching, tuples, working with immutability, recursion and pure functions, and ex unit is where I would start. 
Try http://rss.app
_Following since question and answers are interesting..._
Are there any resources (GitHub projects, Talks, ...) you can recommend on this topics? I got from my colleagues the advice to watch this talk [https://www.youtube.com/watch?v=nBtz9IJBO4g](https://www.youtube.com/watch?v=nBtz9IJBO4g)
It seems to me like "the whole book" is already the 20% that's most useful, and the 80% is mostly stuff that didn't fit in the book (like which external libraries are commonly used).
Pretty much yes. Speaking about GC: https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html https://www.erlang-solutions.com/blog/erlang-garbage-collector.html
I think it depends on what you are using it for. If you are a web developer than Phoenix, Ecto, Pattern matching, efficient and readable pipelines (and I would go out of my way to say anything OTP is not in the 80% effective range). If you aren't using it in a web development environment well then im not sure because I haven't used Elixir in another environment yet :P 
I think GenServer, Tasks, Supervisor and the actor model are not what you're looking for, they are more advanced topics. If you're new to Elixir then focus on functional programming, pattern matching, lists, maps, tuples, atoms, etc. Single threaded code using the code data structures- this is what 80% of Elixir programming about. OTP and the concurrency model is powerful, but the majority of the time you won't be using them directly, especially if you're making fairly standard web applications.
I did not know about binary pattern matching. I liked Prolog. This makes me feel familiar with list pattern matching.
[https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial](https://www.udemy.com/the-complete-elixir-and-phoenix-bootcamp-and-tutorial)
Speaking about control flow: coming from a python and go where you typically check for certain conditions and eventually return early you have to rethink you strategy in Elixir since there is no return statement. One way to tackle this is to use railway programming and the with statement, like in those examples: https://gist.github.com/sudostack/839019423be90118ff36d1bbab80e607 I feel it's really a shame that the Elixir guide doesn't mention the with statement in the control flow section (if/case/cond). Instead it's mentioned in passing in the section doctests and patterns.
This one. This is how he teaches he starts with the things I've listed. Its great! https://pragprog.com/book/elixir16/programming-elixir-1-6
I'm a big fan of Elixir School [https://elixirschool.com/en/lessons/basics/basics/](https://elixirschool.com/en/lessons/basics/basics/)
True. Supervisors is actually built over links.
&gt;book Sorry but which book are you talking about? :)
The 20% of your list is definitely "pattern matching". Tasks are pretty trivial to learn how to use, also. If you're not familiar with them, immutability and recursion will be a huge piece for you. I'd say learn those, then learn how maps work, get familiar with lists vs strings and then start building stuff. After you've built a few things, then start playing with genservers, supervisors, protocols,etc.
I wrote a blog post about that topic: [https://wrestlerman.me/posts/small-tips-for-elixir-beginners/](https://wrestlerman.me/posts/small-tips-for-elixir-beginners/) Hopefully, you will find it useful. 
Sounds about right! Instead of using NIFs though, you may want to look at Ports, which makes interaction between Elixir/Erlang VM and external programs work well: https://hexdocs.pm/elixir/Port.html
This may not be a good fit for Elixir, depending on how complex your "orchestration/glue" needs to be. It's entirely possible that implementing your whole app in C++ will be easier than hooking your simulation modules into an Elixir app. There are several excellent ways to connect Elixir apps to C++ modules, including NIFs, Ports, and C nodes, but none of these methods are trivially simple. I'd actively consider the C++-only design before committing to an Elixir based solution. Popping up native visualization windows seems especially difficult with Elixir, if that's a thing you want to do. 
&gt; Usually I grab a book and read it from start till the end and start implementing afterwards. Whatever Elixir book you'd normally grab. [Programming Elixir](https://elixir-lang.org/learning.html) maybe?
Cool! I bookmarked it, Kudos.
My recommendations if you go this route: use nifpp for the nifs, it makes writing nifs with c++ trivial; and use the safe_exec_env module for riskier code yoh write to prevent crashes in your code from taking down the node.(disclosure: i wrote and maintain the latter.) The 1ms thing is no longer true, either. Now that we have dirty schedulers kn thr vm, you can now declare your nifs as cpu or io bound and all is well
Thanks, that may be the way to go. I was leaning towards wrapping c++ libraries to consume from elixir but doing a stand alone process might end up being simpler.
Thanks! Hadn't come across nifpp in my research I'll have to take a look. It seems like what I'm talking about would fit with a cpu bound nif. I've read some about the overhead added by dirty nifs, is there anything else you need to be concerned about with them?
Do you think the simpler the glue between the instances the better it would be entirely in C++ or vice versa? I am considering a C++ only design as well however many of the things OTP gives you for 'free' would be pretty valuable.
The more logic you'd get to write in Elixir, the more potential benefit to using it. Try starting to write both and see which one hurts less?
Thanks
not really, other than of they crash they still take down the node.. the overhead is really quite minimal though...
I recommend Julia if you're thinking of writing high performance, multi-node simulation code from scratch. A part of me wants to write a library that will make message passing between BEAM nodes and function dispatch from elixir to Julia transparent, since a lot of the semantics are similar (the architecture, however, is not).
https://aeplay.org/citybound this is an actor based distributed simulation inspired by erlang but developed from rust
Golang is good fit for this case. It’s preemptive like elixir and offers much better performance. Also c++ interface is simpler compared to elixir.
Not to be the ‘well actually’ guy but go-lang has a cooperative scheduler. 
Well thanks for cooperative comment.
Wrote two simple libraries and made a PR in the last week: * A plug to set locale for web applications * [https://github.com/three-dolphins/locale\_plug](https://github.com/three-dolphins/locale_plug) * Weixin (https://open.weixin.qq.com) OAuth2 strategy for Ueberauth * [https://github.com/elixir-wechat/ueberauth\_weixin](https://github.com/elixir-wechat/ueberauth_weixin) * Submit a PR trying to fix a bug for oauth2 library when building ueberauth\_weixin, not merge yet * [https://github.com/scrogson/oauth2/pull/132](https://github.com/scrogson/oauth2/pull/132) &amp;#x200B; Writing Elixir is full of fun, the document is so good, and [http://elixirforum.com](http://elixirforum.com/) is really a great help.
I'm not one to be critical, but this course is outdated and woefully underwhelming. I'd only recommend it if you can get it for &lt;$10, otherwise out your money toward a good book like Elixir In Action.
Very interesting thanks, I hadn't seen that before
lists:map (which is what Enum.map calls under the hood) is already body recursive, which is why the stdlib results are almost identical to the body-recursive test. One of these tests could safely be eliminated.
YouTube link, if you find that site's Video UI lacking: https://www.youtube.com/watch?v=SbRvX1CQ9ic
It drives me nuts
When algebraic effects are the most efficent way to do IO in such a case and you support that your user base implements side effects on their own, can you simply abstract that a little bit and give some helper library? So to say, in order to make implementing algebraic effects more easy and simple to use?
Hi! Thanks for pointing that out. Yes, the blog post fails to point that out explicitly. I like to keep it around though, as every time I implement something that is already in stdlib I like to show it alongside so that people have a point of reference. Otherwise questions like "but how would it stack up against Enum.map" would be fairly common. Plus, Enum.map does better than my body-recursive implementation pretty consistently which I think is also interesting.
I have 2 years of personal experience with Elixir and here are the 2 most important things to understand: * Immutabilty * Recursion Although Erlang and OTP knowledge may be useful, I only learned about them about a year after I started using Elixir, as most of the frameworks you are going to use will abstract these away for you. I would also recommend pratice to get better using a site like [Exercism](https://exercism.io/) (disclaimer: I am a mentor for Exercism).
Do not forget to also join the [Slack Elixir group](https://elixir-slackin.herokuapp.com/) to ask questions :)
Similar idea - I made a new function called `MyAppWeb.authenticated_controller` that wraps up the same functionality, and then you just `use MyAppWeb, :authenticated_controller`. Six of one, half dozen of the other. defmodule RHRLiveWeb do def authenticated_controller do quote do use MyAppWeb, :controller def action(conn, _) do apply(__MODULE__, action_name(conn), [ conn, conn.params, conn.assigns.current_user ]) end end end end
I definitely prefer the plug approach over using a macro just for this. It's a bit more transparent and you don't need to use in every single controller.
What makes this better than \`conn.assigns.current\_user\` ?
Simplicity
Thanks for the feedback :)
So far, me too. But the macro approach originates from Chris McCord way back in 2016 and can be found here [https://dockyard.com/blog/2016/05/02/phoenix-tips-and-tricks](https://dockyard.com/blog/2016/05/02/phoenix-tips-and-tricks). I'll bet that's where OP go the idea. I've been tempted to go this route but it feel more OOP. Chris uses the plug approach in the programming phoenix book, that's been my approach so far.
The creator of Ruby on Rails? DHH doesn't appear to be in that article unless I just missed it completely.
As Chris McCords puts it: &gt;.. the repeated `conn.assigns.current_user` access gets tiresome and obscures what we care about, namely the `current_user`. Lets override `action/2` to see how we can clean this up. &amp;#x200B; OP's blog post is inspired by: [https://dockyard.com/blog/2016/05/02/phoenix-tips-and-tricks](https://dockyard.com/blog/2016/05/02/phoenix-tips-and-tricks). Chris does a better job explaining the logic behind the implementation.
That's fair. The performance difference you mention is interesting, since your implementation seems to be doing a tiny bit less that Enum.map does, having no guards and one less frame in the call stack: def map_body([], _func), do: [] def map_body([head | tail], func) do [func.(head) | map_body(tail, func)] end vs def map(enumerable, fun) when is_list(enumerable) do :lists.map(fun, enumerable) end ... map(F, [H|T]) -&gt; [F(H)|map(F, T)]; map(F, []) when is_function(F, 1) -&gt; []. I wonder if it all boils down to having your base case defined first, but you'd think the VM would optimize simple stuff like that away.
The tooling, documentation, and design decisions throughout the Elixir ecosystem generally leave me with a "huh that was really simple" sort of a feeling. Modules and Functions instead of Classes, Class-instantiations, and all the design pattern/UML woes that come with coupling state and behavior in an object is a bit of an adjustment if you have deep-set OOP tendencies. Regardless modules and functions is a lot easier to grasp than OO-PHP will be. Some concepts like immutability and recursion might give you a headache early on, but they'll budge soon enough. We copy instead of mutating and it turns out that removes a large number of common bugs and concurrency issues in the process. Pattern matching looks foreign initially, but it's very easy to pick up and you'll want in every language afterward. Instead of iterating through an object to get a deeply nested pair you can just pattern match on the structure of your object/map/struct instead. Not only is pulling data out like this more explicit, you're going to save a lot of mental cycles here. Phoenix is just a bunch of plugs and tooling around a conn struct for a given request/response. All we're doing with Phoenix is pushing this conn through a pipeline of functions that take a conn and return a conn. It does it quickly and with concurrency built in. Finally there's OTP which isn't easy. It's powerful and there's a lot to learn. The good news is you can get pretty damn far with only a cursory knowledge of OTP. Anything you do in Phoenix will be concurrent **by default**. If you are having trouble scaling a Phoenix app, you're in luck because that means you have quite a bit of users. Some recommended resources to start out: * [Elixir-Lang Getting Started](https://elixir-lang.org/getting-started/introduction.html) * [Elixir School](https://elixirschool.com/en/) * [Dave Thomas's course](https://codestool.coding-gnome.com/courses/elixir-for-programmers) * [Elixir in Action](https://www.manning.com/books/elixir-in-action) * [Programming Elixir](https://pragprog.com/book/elixir16/programming-elixir-1-6)
it's not for brainiacs but it will be much easier if you have some experience with functional and (especially) concurrent programming, virtual machines, type theory, etc.... javascript is much simpler than elixir in comparison, and you'll find much more resources on JS than on elixir. node isn't very difficult to understand, it's just a javascript runtime, which means you're able to run javascript code directly on your machine (instead of through a web browser, which is where all javascript code ran before the advent of node). with node you get new things that weren't possible with just the browser, like file I/O (creating/deleting files on your hard drive, things like that, basically pretty much anything any other language can do that javascript couldnt do before because of the browser limitation).
I enjoy tips like this. Thanks for sharing!
Short version. We all have a brain capable of learning and advancing. Ted talks on this etc. Any language can be for you. I think a better question would be, what's the barrier of learning like? Self driven learning is still at the core of what Elixir is. I would pick a project you want to make and figure out how to do it in Elixir. If you want example apps etc / hand holding. Pick up a phoenix book.
Does anyone have the words.txt file used in this article? I'm trying to generate it but I'm getting a huge llvm error.
Learning the functional way of doing things will require some brain bending for anyone coming from prosecutable/oop languages, but I think anyone can get the hang of it. After that, I would say that elixir is easier than most languages, functional or otherwise.
A pirate walks into a bar with a steering wheel on his pants, a peg leg and a parrot on his shoulder. The bartender says, "Hey, you've got a steering wheel on your pants." The pirate says, "Arrrr, It drives me nuts."
[removed]
I would argue that the syntax of JavaScript isn't hard but the contortions it makes you do to make things work do increase the complexity more than necessary. This makes it simple to create blog posts and trivial apps but once you go beyond that promises, async/await and callback hell will set in. In contrast, Elixir takes the principal of least surprise approach. The only caveat to that is that it is the least surprising thing for a functional programming mindset. Learning OTP also is actually much less daunting than it seems. But that feeling will make it seem like you've got a lot to go when you really don't. IMHO, those that **do not** have the typical OO imperative mindset to overcome will have a much more difficult time than those who are new. So if the OP is new to programming, that would be a benefit I would think
My mistake - for some reason I thought Jose Valim was in the original team. A quick Google search tell me it is not.
Thanks (to everyone else too). How long does it normally take to become proficient enough to make fairly simple CRUD app, if you dedicated about 10 hours a week?
¯\\_(ツ)_/¯ It depends. Try the [Phoenix Guides](https://hexdocs.pm/phoenix/up_and_running.html). Especially through to the Contexts Guide and you'll have a good walk through building a CRUD app. If you're unsure about something, try going through some relevant material from the Elixir-Lang site.
I have retrieved these for you _ _ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
&gt; If I take up learning Elixir and Phoenix, and put PHP on the sidelines, how long does it take people with a basic programming background to learn it well? Honest opinion: It really depend how you think. Some people like thinking in OOP and other in functional. I think I know more people learning OOP better than functional. This is more of an opinion but maybe your fundamental is not strong enough and/or you just need more experiences (ie don't give up) and try simple project and slowly advance slowly toward harder and harder project. Also Elixir job market is small compare to php. There is no need to jump on the band wagon yet. If this is for a career or making a living, I'd suggest you learn something that can bring food to the table. That's PHP, Ruby, Python, Javascript, etc... If you want to stick to web dev, and making a living I'd suggest either PHP laravel and Ruby (Ruby on Rails). I won't be suggesting Javascript since it seems like you're struggling nor Python since I don't believe Python have a strong web presence compare to PHP and RoR. &gt; However, I'm struggling to keep up with things and am seeing the limitations to my natural intellect becoming evident. Almost everything in life is a skill, this is especially true with programming. As with any skill it's just practice and deliberate exercise.
Shouldn't this be "Phoenix boilerplate"?
Working on evaluating Elixir for our work. We do simple but really custom stuff, internal business logic apps with usually lots of background jobs, document production, interfaced with CLIs, HTTP APIs, web-facing (heavy) UIs, and more rarely hardware, but we're in the capacity to stick raspberries in front of thoses pieces of hardware. Three months in, I'm really finding joy in this process after extensively trying a lot of languages for our small team. Things like Phoenix LiveView are really interesting too since I'm also evaluating userland JS replacements for our web UIs. So far, Elm and Vue + Typescript were two migration plans from Vue + JS, but having state maintained on the server with the expressiveness of Elixir would be a huge plus. This is a bet to go all-in in a language/platform for the next *x* years, to develop our comfort and tools in it, so I'm trying to keep enthusiasm low, but it seems like it would fit !
Erlang is pretty dreaded
Lol what? How is WebAssembly the 5th "Most Loved" language? Surely people aren't enjoying writing at the assembly level, right? If they mean they are writing Rust/C and then compiling to webassembly I'm not sure why it's considered the 5th most "loved language" since they're only using it as a compilation target... Regardless, great to see Elixir on there!
Lots of people really misunderstand webassemby and what it's for. I'm guessing most people voting for this were basically just voting for "first class language on the web that isn't JavaScript", despite never having used webassembly.
I did a literal LOL when seeing Drupal has a commanding lead in "most dreaded" web framework. I did ONE project in Drupal a number of years ago. Never again, lol
In this article we see what a hash function is and what it can be useful for. We see how to calculate the hash of strings and files using the Erlang :crypto module and Elixir streams.
&gt;The thing I don't understand about this survey is the validity. Surely, a respondent weighing one language against another requires any survey respondent to be familiar with both languages? THIS.
&gt; A hash function is a function that converts a variable size sequence Correct. &gt; of bytes Incorrect, SHA-1 and SHA-2 works on bit strings (it do not need to be multiply of 8), however it is not common to support such cases. &gt; to a unique fixed size sequence of bytes Incorrect, by pigeon hole principle it is impossible to narrow infinite set of strings to unique, fixed-length set of strings. &gt; usually represented by an hexadecimal string of length between 32 and 128 characters Usually such digests aren't presented at all, because are used for internal hash table lookups. So if you use map with more than 32 keys then you will use Erlang's internal hash function. &gt; It’s a sort of digital fingerprint Only in case of cryptographically secure hash functions. &gt; MD5 and SHA-1 are the most used to hash files, since they are fast and provide a good way to identify files. It is worth mentioning that you should **never** use MD5 in production code, and you should avoid SHA-1 whenever possible. If you need to check file integrity then use SHA-2, SHA-3 or Blake2. --- It is also worth mentioning that this covers only cryptographically secure hash functions, which in most cases aren't needed. If you want simple and damn fast hash function, that do not need to be secure against malicious parties then you can use `:erlang.phash2` which can handle any `term()`, but as I said earlier, you **SHOULD NOT** use it to hash user-dependent input unless you are aware what you are doing.
Hi! Thank you so much for your comments, super detailed! :D This short post was written to just to give an idea of what is a hash function and how to use functions in the :crypto module to calculate the hash of a file. Once got the idea on how to use :md5, switching to :sha2 or :sha3, if needed, is trivial. &gt; Incorrect, by pigeon hole principle it is impossible to narrow infinite set of strings to unique, fixed-length set of strings. Sure, let's say the probability of collision is low, and it depends by the algorithm and size of the digest. Since this post is meant to be a short practical article, I couldn't start talking about collisions etc. ;-) In the case of the article (hashing files), security is not a requirement, so we can use MD5 which is fast. Why you say they shouldn't be used in production for just this purpose? &gt; Usually such digests aren't presented at all, because are used for internal hash table lookups. So if you use map with more than 32 keys then you will use Erlang's internal hash function. It depends what's the use. It's clear from the code that the output is a binary, which is then converted to hexadecimal string. &gt; you can use :erlang.phash2 In this way you can't check the md5 checksum of a file you've just downloaded.
I'm implementing the board (card) game, *Love Letter*, in Elixir.