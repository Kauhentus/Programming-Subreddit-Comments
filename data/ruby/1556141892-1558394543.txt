Let's stop them early!
Go to to [Confreaks](http://confreaks.tv/events?utf8=%E2%9C%93&amp;query=ruby&amp;commit=go) and watch a ton of conference videos.
&gt; Because it requires people to use java. A major point of the article is literally about how it *doesn't* require people to use Java. It doesn't need a JVM to run. &gt; Why would it be so much faster than JRuby? That seems fishy. That's literally the question the article answers in detail. It ahead-of-time compiles to native code, instead of running on a JVM, so there is no time to start up a JVM, load class files and start parsing. &gt; Guess we'd have to let headius make a comment about that eventually. If you ask him he'll tell you that he's trying to apply the same technology to JRuby because he's seen it work on TruffleRuby.
For that, learn from a tutorial such as [https://www.railstutorial.org/book](https://www.railstutorial.org/book) \--- very popular one.
True. We can even use something like https://github.com/cavalle/chrome_remote to capture screenshots via CDP. There is also the `ScreenCast` API, but I only found JS examples for it.
Thanks a lot for affirming this info, Chris. I think it's good for you to note, /u/shevy-ruby, Chris here is one of the main developers of TruffleRuby and he is very knowledgeable about this topic. So take note of what he says.
Practical Object Oriented Design in Ruby by Sandi Metz is still one of the best programming books out there in my opinion. The concepts have helped me in other languages like Python and PHP too.
Matured a bit from its [initial announcement](https://www.reddit.com/r/ruby/comments/9kwp1n/monotime_a_sensible_interface_to_monotonic_time/), with more convenience methods, duck typing, better docs, and better tests. Oh, and an actual [changelog](https://github.com/Freaky/monotime/blob/master/CHANGELOG.md). Please kick the tires and let me know what you think.
&gt; I don't think the user should have to remember any of this. Custom `input` is only required if you are using a macOS with webcam or an external display, or are using something like `xvfb` with a display/screen number. &gt; If the main toplevel name is ScreenRecorder, I would add something like &gt; ScreenRecorder.record &gt; ScreenRecorder.start &gt; ScreenRecorder.run Well, how do you recommend differentiating between the two recording modes - `ScreenRecorder::Desktop` and `ScreenRecorder::Window` - in this case? &gt; echo $DISPLAY shows :7 Yeah, `input: :7` is required for it to work. Which distro are you on? Local or a VM? I am yet to figure out what determines the `$DISPLAY` number. On my local Ubuntu input is `:0`, which is why I set default to `:0`.
You can just read the book online for free and decide later if you want the screencasts or downloadable versions of the book
An ignorant here... Does TruffleRuby just a dropin replacement of the ruby interpreter (the default MRI)? I guess that if it's the case it should not be compatible with all the ruby, right? I mean, for example I don't think one can run rails with this implementation.. So for which scenarios it's useful and viable (regarding the compatibility with ruby code) to run under Truffle? Thank you very much.
The series post linked below may serve as a good introduction to dry-rb ecosystem and specific purpose the core gems serve. The series post starts at **My Past and Future Ruby** and ends at **Conversational rom-rb, part 2** [https://www.icelab.com.au/notes/author/tim-riley](https://www.icelab.com.au/notes/author/tim-riley) &amp;#x200B; There's a mini book covering the basics of dry-web-roda: [Dry Web Roda Todo App](https://dry-web-roda-todo-app.readthedocs.io/en/latest/)
Yep, it's goal is to be a drop in replacement for MRI. They're crackin' on right now with regards to Rails and so forth and are making good progress. There are various tickets over on GitHub about these points... but you might really be interested to know that one of the goals is to be able to even execute C extensions akin to MRI via \`sulong\` direct translation. Here's one ticket with some chatter: [https://github.com/oracle/truffleruby/issues/1400](https://github.com/oracle/truffleruby/issues/1400)
What are the current set of obstacles remaining for it to run Rails? Is there something I can follow to stay up to date on the progress around that area?
This is really great stuff. Thank you so much for sharing this. I'm really excited to dig into this soon.
[concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) has something like this with [`Delay`](https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Delay.html) and [`#delay`](https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Promises/FactoryMethods.html#delay_on-instance_method).
I don't think MRI start up can be improved significantly. What makes it slow is loading all the gems. If you try `ruby --disable-gems`, you can see that it is very fast
This is great, I kinda wish we could use truffle Ruby or at least jruby at work. New developments are really exciting these days
Is there any open source or maybe just an example app which uses rom-rb to some bigger extend? The examples don’t really show the big picture for me. 🤨
my test of last year [https://imgur.com/D5m2Ack](https://imgur.com/D5m2Ack)
Gems need to be fixed. Startup time is slow
So far these are the best books changed my way to think and write Ruby codes, not really about Rails thought. 1. The Well-Grounded Rubyist 2. Practical Object Oriented Design
1. Think of these as different platforms. mRuby for instance is used in embedded applications, Jruby runs on the JVM etc. 2. Different people have different needs. MRI Ruby is fine for most people but it has shitty support for concurency for instance. Hence JRuby or Rubinius. It also uses a lot of memory. Hence mRuby. 3. Yes, JRuby for instance is used heavily in production, and mRuby is used heavily in Japan http://engineering.appfolio.com/appfolio-engineering/2017/5/24/how-is-ruby-different-in-japan 4. Some higher level languages have multiple implementation (Python has for JVM and .NET, perhaps even more).
I wonder if ruby 3 or 4 will just be truffle ruby?
Replace rvm with rbenv.
There is not THAT much implementation you've listed. We have (and I am trying to provide answers "why?" for each of them, according to my own imperfect understanding): * the "main" Ruby implementation aka CRuby (for "Ruby implemented in C") aka MRI (for "Matz Ruby Implementation"), which is, well, the main; * JRuby, which is Ruby for JVM; reason for this kind of projects is Java infrastructure — gain from it and enrich it (and yes, there are JVM reimplementations of most major scripting languages; at one point there also were .NET implementations—IronRuby, IronPython—but they are not active anymore) * Rubinius: I am not sure about the current state, it seems to be kinda chaotic (some time ago it was stale, some other point they declared that it is not Ruby reimpl, but some generic tool for implementing language, then they were back to Ruby...), but I believe it was started as an experiment for more "hackable" Ruby, with most parts implemented in Ruby itself; there are a lot of reasons for such projects existence, and Python, indeed, have PyPy being more or less the same; * TruffleRuby: I am not sure here (TBH, I constantly read and constantly forget the details), but I believe it is an approach to make faster Ruby on the new modern VM + part of what Rubinius claimed (more of Ruby implemented in Ruby itself). The [Aim](https://github.com/oracle/truffleruby#aim) in the project's README can be of interest, too. (mRuby is NOT a "Ruby implementation", but rather Ruby-like simpler compiled language for embedded devices) So, to answers to some of your questions: 1. There are implementations for infrastructures where CRuby is not suited; or experimental implementations from scratch to see if some things could be made better/another way; 2. In fact, they **do** contribute to "main" Ruby: both Charles Nutter of JRuby and Benoit Daloze of TruffleRuby are very active in discussing core language features and finding bugs and inconsistencies in the "main" implementation (which on itself shows how "alternative" impls are valuable: because there is independent way to validate main implementations consistency), and, if I am not mistaken, ruby-spec project (not to be confused with RSpec; it is formal and runnable specification of the whole language) was initiated by Rubinius authors 3. Don't know much about widespread. Some surveys (can't find the links) suggest that JRuby has, like ~several percents market share; while TruffleRuby is too new to say much about it and Rubinius too unstable; mRuby, AFAIK (NOT being a Ruby implementation!) is widely used in some areas and markets; 4. About other programming languages: at least Python does have as much implementations. And PHP [seems too](https://en.wikipedia.org/wiki/PHP#Implementations). C has several (or rather many) different compilers indeed, sometimes barely compatible; while Go is more or less Google-controlled.
If you are working on some feature, it will be good to squash it before to push it. So what's the problem to use local CVS (if you can not work on feature without to commit something but you have not connect to central repo) then to generate diff and to push it in central repo when/where it will be available. \- Why do you need decentralized VCS? Because of fashion? \- Why do you need Git? Because of decentralizing? Or history re-writing? \- Is it possible that a lot of modern devs are hipsters who can not live on Linux distros which are older than 1/2 year, or whose smartphone is not the last IPhone, so obviously VCS must be updated version of Git, sure? Is it possible that we often are dealing with hipsters fashion and not with technical arguments? Is it possible? ;)
The RubyKaigi presentation will release in about a month btw.
How much time is left before this program drains your battery completely?
I haven’t actually given that a shot 🤔 I’ll try it tonight.
&gt; So what's the problem to use local CVS (if you can not work on feature without to commit something but you have not connect to central repo) then to generate diff and to push it in central repo when/where it will be available. Because it's a pointless hassle when I can instead use git and not have to deal with it. &gt; - Why do you need decentralized VCS? Because of fashion? So I don't need to deal with that pointless hassle when I can let git deal with it. Also, your hypothetical scenario assumes there is one single central repository. For many projects that is simply not true. For Linux for example, the repository set is more like an acyclic graph: Linus has his tree. Sub-maintainers have their trees. Various companies have their trees. People push and pull changes in all kinds of directions as features mature, people pull bug fixes from various sources etc. The idea of a centralized repository is one that only makes sense to people who use systems that makes it hard to more accurately model how people would like to be able to work. I remember the bad old days of shipping and applying patches because the source control systems people used didn't support anything better. It was an awful mess. &gt; - Why do you need Git? Because of decentralizing? Or history re-writing? Because I worked with CVS and the SVN for many years, and it was a tremendously shitty experience compared to Git, in pretty much every way. It doesn't matter much if you're an individual developer or tiny team working on the same features most of the time. It matters massively when you're working in large, distributed teams, and even more so when you're working on projects that are shared across many teams with different priorities. &gt; - Is it possible that a lot of modern devs are hipsters who can not live on Linux distros which are older than 1/2 year, or whose smartphone is not the last IPhone, so obviously VCS must be updated version of Git, sure? Is it possible that we often are dealing with hipsters fashion and not with technical arguments? Is it possible? ;) The "hipsters" in this case are the people wanting to use obsolete technology with total disregard for the technical reasons to move on. The description you're giving here suggests you don't understand what "hipster" usually refers to - hipsters tends to more often pick up retro trends using bullshit arguments about aesthetics than continuously upgrade. [as a side note, none of the most "hipster" spots in the US are major tech hubs; hipster culture tends to largely clash massively with tech culture exactly because hipster culture tends to be antitethical to pickings things by merit] And this case it's doubly ridiculous given that git is not some new fad - it was first released in 2005, and it was not the first decentralized solution. &gt; Is it possible that we often are dealing with hipsters fashion and not with technical arguments? Is it possible? ;) This tendency to try to cling to SVN or, even worse, CVS, certainly does have a feel of hipster fashion. There are certainly no technical arguments supporting it.
That certainly *can* be improved, because it rarely changes. Even optionally opting in to building/using a cache would help. E.g. if you "strace" MRI you'll see that a significant proportion is even spent on system calls to figure out which files to load, not just parsing them. Actually you could do that as a third party tool: Trace which files is loaded up to a given point, and write out a bundled file that when loaded will reproduce the same state. It's a bit tricky because you'd need to account for things that makes assumptions about file location etc. but it's doable.
Why?
My issue is rather that there are so few. There is a lot of unexplored design space... I'm working on my own [ahead of time compiler](https://hokstad.com/compiler) (don't get too excited; I don't have time to work on it often; I've just picked it up again after about a 2 year hiatus; and it wasn't the first 2 year hiatus...) for example that is finally getting close to compiling itself (the big goal for me is that the compiler itself is 100% Ruby; the libraries are almost entirely Ruby, with some minor low level exceptions using an embedded lower level language, and it should generate code that is as "static as possible" given Ruby's dynamic nature). The thing is while good ideas will cross-pollinate sometimes, people have wildly different ideas of what to do and how to do it, and different requirements, and competition is how we get the chance to try out new things and see which ones works best. This is only a problem if we get two competing versions that are popular but refuse to work on being compatible with each other. So far we don't have that issue. &gt; Do other programming languages (such as Python, Go, C and the likes ...) come with lots of their own implementations too? C, yes, many dozens of compilers. Python and Go much less so.
I think you have a misconception. I also think you don't know the terminology e. g. you mention mRuby CRuby and MRI Ruby ... I don't know what you see the difference between CRuby and MRI? Anyway, to answer your question - for 99%, MRI is the main ruby. Having alternatives is nice but ultimately MRI is what I use daily and I think 99% of the other people use it too. JRuby is primarily for the java-heavy folks. When you already use a lot of java then it makes sense to leverage the JVM on top of it. I personally don't need java but others may, so there you go - may be useful when you interface. mruby is where matz is most active; it targets small devices, a bit like lua; it also has been sent outside planet earth already \o/. It will probably in the long run, hopefully, become the new MRI one day, where MRI may be super-duper-modular. But ... for the time being ... MRI is where everything really happens. Rubinius was important a few years ago but it kinda died. TruffleRuby is also dead even though the guys recently wrote how they are mega-super awesome fast. But, let's be honest - MRI is where the really important stuff happens. As to why they work on that, well - different reasons. Company support is at best only a marginal reason. Other languages have different implementations too such as python. But if you ask me - the alternative implementations are mostly irrelevant for most people really. MRI is the main go-to; it's also where matz makes decisions (even though some decisions may land in mruby first since matz works on it directly). Personally I think it would be better to have only one MRI that is also mruby, rather than two separate entities, but I guess it was too difficult to re-model MRI while keeping users of ruby. mruby is unfortunately primarily only for C hackers, which excludes lots of people - in particular those who don't know C too terribly well. :(
There is also DragonRuby. &amp;#x200B; I recommend you to write WhyIsThereSoManyRuby, maybe then you'll find out.
\&gt; [Delay](http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Delay.html) ~~Lazy evaluation of a block yielding an immutable result. Based on Clojure's~~ [delay](https://clojuredocs.org/clojure.core/delay)~~.~~ Replaced by [Promises](http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Promises.html). to be honest I don't understand their documentation: [http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Promises.html#delay-class\_method](http://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/Promises.html#delay-class_method)
&gt; There is a lot of unexplored design space... The thing is - you need to get people to USE the language. Most of the "design space" is fancy on paper BUT ABSOLUTE GARBAGE when "implemented". Ruby also has a lot of crap, let's be honest, but the good thing is that you can happily decide to NOT use most of the crap and still have a really great language. I think the issue of MRI +/- mruby is still a real one. To me the distinction does not make a lot of sense. The linux kernel can run on toasters to super-mega clusters, so the same should be possible for ruby too. But I understand that it was not easily possible to make MRI run on small devices too, so it made sense to have mruby - I just don't think it makes a lot of sense to keep having both MRI and mruby at the same time in the long run ...
So I can build 2D games with Ruby for the Nintendo Switch.
&gt; Most of the "design space" is fancy on paper BUT ABSOLUTE GARBAGE when "implemented". Which is exactly why you want people do to separate implementations instead of trying to push all kinds of things into a single implementation: Most of it will make no sense, and will fail fast. Some of it may make sense, but not for all use-cases, and should live outside the main implementation. Some of it will be fantastic, and can be leveraged in other implementations over time. Some of that can happen with people experimenting on MRI, but not all. E.g. ahead-of-time compilation of Ruby may very well never become more than a curiosity for most, but in any case it's not practical to combine with MRI. &gt; Ruby also has a lot of crap, let's be honest, but the good thing is that you can happily decide to NOT use most of the crap and still have a really great language. And the best way of ensuring that keeps being the case is to have people experimenting outside the main implementation. &gt; I just don't think it makes a lot of sense to keep having both MRI and mruby at the same time in the long run ... Maybe not in the long run. But mruby is unfortunately *nowhere* near being feature complete enough to replace MRI, and MRI is nowhere near being able to shrink down enough to the space where mruby lives. It will take a lot of work. And that's fine, as long as both aim to reduce incompatibilities.
Just wanted to say that this is really cool
I would argue that the ability to edit code on a Nintendo Switch has nothing to do with the ability to build 2D games for it, even if both are done in Ruby. Why run a quine on it? Why run it in an editor on the device?
Good comment. Let me see if I can elaborate! &gt;I would argue that the ability to edit code on a Nintendo Switch has nothing to do with the ability to build 2D games for it, even if both are done in Ruby. Well it certainly helped me when I had to: - Jump to different points in the game without recompiling some form of debug state. - Monkey patch RNG so that a specific outcome would always happen. - Live code layout tweaks so that it looks just right in both screen and hand held mode. - Live edit layout of the game and watch how animations looked on standard definition screens (yes, Nintendo forces you to make your game playable on 480p square TVs). So yes. Being able to hot load Ruby, on the device in "prod mode" was incredibly valuable. &gt;Why run a quine on it? Because Quines are cool T_T &gt;Why run it in an editor on the device? See first response. Some things cannot be tested on a computer. It must be tested on the device: perf, color saturation on 70 inch screens, rendering and layout on an old ass TV you've bought off of ebay.
Really cool!
It was done by a guy named [Collin](https://rubykaigi.org/2019/presentations/PeterQuines.html#apr20) at the RubyKaigi post-conference hackathon. I was in shock when he pulled it off. Full credit for the code above goes to him.
I dont think TruffleRuby will ever be usable to run Rails. They are just hoping to port the necessary C extensions and hope that in the future the extensions will be written in Ruby (or whatever Graal compatible language). Which in theory is possible but I doubt it will happen. There will be some "stock" version of rails that you can run but for any other specific deployments your C extensions will not work.
This isn't unusual. Most languages have one or two very widely adopted implementations, and then a collection of alternatives built for specific environments, research, or for commercial/political/legal reasons. I doubt anyone has a comprehensive list of every C compiler that ever was, because it's usually the first language ported to any new platform. Must be in the hundreds, if not thousands, depending how you count the variants.
&gt; They are just hoping to port the necessary C extensions No we're aiming to run the unmodified C extensions. This works with major C extensions like pg, sqlite3, mysql2, etc. We do this with an interpreter for C code (really for LLVM code.)
Do you think it's realistic to be able to run every C extension out there ? What I meant is that you can get the subset of C extensions that Rails uses but can you really make a universal interpreter for 60% of other C extensions ?
&gt; Do you think it's realistic to be able to run every C extension out there ? I think it's realistic to run all C extensions which are written in bug-free, well-defined C, but many C extensions use undefined behaviour. We may need some creative solutions when get find issues, or in some cases we may upstream fixes to the C extension maintainers - and some of them have started accepting these small patches. But with the patches merged, we're then just running the same C extension as MRI does.
So yeah that's what I meant by my post. You can get some subset running but all those gems written in a not-so-well-defined C wont run and the best you can hope is that your team finds a way how to fix them. I did not mean what I said in a negative way that TruffleRuby/Graal is useless. I just think it is unusable at the moment (and maybe in future for exactly the reason stated) for a lot of ruby shops. It's a research project I know but still..
Right - I was focused on the 'port' part - for anyone reading for extra clarity what we aren't doing is porting C extensions from C to something like Java - that's the JRuby approach.
True. Should have worded it better.
The [guide](https://ruby-concurrency.github.io/concurrent-ruby/master/file.promises.out.html#Delayed_futures) is clearer. So you might write your example like: karma_cake_future = Concurrent::Promises .delay { Nokogiri::HTML(open("https://www.reddit.com/user/#{name}").read } .then do |user| [ user.css('#profile--id-card--highlight-tooltip--karma').text.to_i, Date.parse(user.css('#profile--id-card--highlight-tooltip--cakeday").text) ] end karma, cakeday = karma_cake_future.value # future resolves
oh that's cool but where is the \`name\` coming from? in my case I need to have access to that value
Looks cool. Have you considered compiling a list of sites that run on ruby? You could use [Built With’s API](https://api.builtwith.com/lists-api)
Please share it here!
It's just a captured variable - it's probably better to pass it to the delay method rather than doing that, but it's just a quick example. If you wanted additional structure you can add promise methods to your own classes and decorate them - which would also provide an opportunity to encapsulate the logic. Not saying you *should* be doing this, just pointing out that it exists.
For comparison, taking a look at what pyenv offers, there is: standard python activepython anaconda miniconda ironpython jython micropython pypy pyston stackless
Im interested, but I wonder how your algorithm would look like . Any chance that you provide more details ?
Amazing!
This list seems a bit confused, there is almost a 50/50 split of interpreters / distros there. Interpreters: cpython ('normal' python) pypy (JIT'd python implementation) ironpython (running on .net) jython (running on JVM) micropython (light weight, analogous to mruby) pyston (it's dead and never left alpha, pypy won the JIT wars) 'Distros': activepython anaconda miniconda stackless (This one is a bit debatable but It's core modification, greenlet, is packaged as an extension for CPython and used by lots of libraries now. It's capabilities are also included in pypy so most of what you are downloading now is the support libs/API packaged as a distro)
Thanks for the clarifications.
Good idea, but problematic - not the tracking part per se, but ... how do you actually KNOW that people who put themselves on a map, actually really use or are related to ruby in anyway? I feel there should be some additional possibility here, for example, connect it to rubygems.org and/or github. Make the second steps of course purely optional rather than mandatory-sniffing, so that only those who want to reveal that can do so (actually that may still require some authentification ... but perhaps rubygems.org has something that could be used or from rails; surely something must exist to query "authenticity" ... if that is even a word...)
Seems to me that many of the same optimizations could be added in MRI - like lazily loading gems.
I checked it against the company I work at and it picked up all the analytics but not the key javascript framework we use, doesn't seem very good.
this is uber cook, need to find time today to play with it!
Im interested to hear about it and possibly help, could you PM some more info? Thanks
FYI: For rubies (ruby implementations) see the Awesome Rubies page &lt;https://github.com/planetruby/awesome-rubies&gt;. My favorite flavor is, of course, secure ruby (sruby) for blockchain crypto contract scripting / programming. See &lt;https://github.com/s6ruby&gt;. Cheers. Prost.
Just tried it on my company and had the same issue. Didn’t find angular. But it found everything else. Even stuff that I can’t even figure out how it knows. We signed up for a service 2 days ago and it already shows that we use it. It was able to identify rails though which I assume would be the primary usage for your site in particular.
FYI: You can find a list of world wide ruby meetups @ https://planetruby.github.io/meetups and a list of world wide ruby conferences @ https://planetruby.github.io/calendar/2019
Projects like this and truffle are bolstering my hope for a ruby renaissance.
yes, first which I remember was Mercurial (and seems it's still better than Git). Your opinion about hipster's culture is interesting. My IMHO is that Linus Torvalds or Stallman are some kind of hipsters. Stallman is very complex and ambiguous person and I can not discuss him (also due to respect to him for his work) but Linus, as typical hipster, hipsters idol and mastermind, created Linux and Git. Both are super buggy and/or overly confused. Actually, VCS is very simple software, why are Git abstractions/formats leaking? Why CLI is so complex? From my point of view answer is complex and root of the problem is "hipsters culture": motivation "for fun". There are different professions. Hipsters are not able to create big and serious enterprise software because it's very boring and no fun. But they like to create software for fun! They prefer startups - Linux instead of academic and very highly-quality BSD systems, Git, etc - should be fun! Not high-quality which means boring work. Look at Haskell. It's super-hipster language. Where super simple things (for fun, sure) become rocket science. Students, for fun, creates a lot of uncompleted low-quality libraries, then they abandon them and Haskell, as point of hipsters interests, is full of super-shit libraries (which has not any real value) and totally lacks real-world and enterprise libraries. Because no fun to implement super big interfaces, formats, etc, but it's fun to play with type-level abstractions. Yes, you can call somebody "hipster" but he is very serious and productive developer, which is able to work not for fun, which uses technical arguments, not personal and often very inadequate opinion, so if somebody looks like hipster and you are sure that he is, may be he is not a hipster. Hipsters will never learn old things, they will create numerous new one, he don't respect existing, he will introduce new thing and mostly they are total shit. Do you remember XP methodology and it's hype? It was obvious that it's total hipsters shit. But... hipsters introduced it, propagate it anywhere, today I can say: hipster = shit. Due to quality, due to their inner conviction of their uniqueness and the value of their unique opinion. This is a typical psychological inadequacy and it is always easy to observe it in their behavior. Eccentric daffodils that would have been treated before, now they have been turned into icons. Would you like to be operated on a hipster-surgeon, who is boring to operate your festering appendicitis and he, for fun, will operate on your spleen? Hipsters is more psychological thing then technical, and such inadequate persons are idols in IT, but there are a lot of areas where such clowns are impossible (due to problems which they will create). May be you call as "hipsters" another kind of persons?
&gt; What will not happen in Ruby 3? &gt; * Frozen string literal Does that mean what I think it means? (I don't mind at all if default frozen string literals has been stepped back from)
hey!, great. Let me know if you have any issues
&gt; My IMHO is that Linus Torvalds or Stallman are some kind of hipsters. If you think so, you really need to read up on what hipster culture is, because it does not fit *at all*. The only reason Stallman can even remotely seem hipster-ish superficially in some ways is because he's held on to cultural aspects that hipsters have latched onto exactly because of their retro appeal. I haven't seen anything from Linus that is remotely anywhere near hipster culture. &gt; Both are super buggy and/or overly confused. Lol, what. I've run Linux since '93. I've run production workloads on it that have run without reboots for many years at a time. Multi-year uptimes is normal for production Linux setups, and it's usually practical considerations rather than need which causes people to reboot. Yes, the nature of open systems is that if you make uninformed choices, then you are free to pick options that won't work well together. If you don't want that you can pick one of the more conservative, well tested and supported options. As for confusion, maybe you find it confusing, but I don't. I use them because they are reliable and meet my technical needs. &gt; They prefer startups - Linux instead of academic and very highly-quality BSD systems Insisting a BSD is the better choice out of some sort of view of its academic purity is much closer to a hipster attitude than picking Linux because it is a pragmatic choice given it's mainstream and easy to hire people for. &gt; Hipsters will never learn old things, they will create numerous new one This is pretty much the opposite of what hipsterism is. Hipster culture often embraces picking up and learning old-fashioned things, and rejecting a lot of new things. A lot of hipster cultural signifiers are very explicitly "dated", as a *reaction* to fast moving modern fashions. To quote Matt Granfield, who wrote a book about the subject, "the way to be cool wasn't to look like a television star: it was to look like as though you'd never seen television." Again, you may want to read up on what hipsters are, because they're not what you think they are. &gt; May be you call as "hipsters" another kind of persons? From your descriptions, I'd say you're much closer to a hipster than the people you suggest are hipsters. You're expressing the kind of disdain for mainstream choices and praise for old outliers that is one of the cornerstones of hipster culture.
The first paragraph on [https://guides.rubyonrails.org](https://guides.rubyonrails.org/) indicates which version of Rails the docs are for, with links to previous versions. [https://guides.rubyonrails.org/v6.0/](https://guides.rubyonrails.org/v5.1/) redirects to [https://edgeguides.rubyonrails.org](https://edgeguides.rubyonrails.org/) which reflects the documentation in the master branch of Rails's git repo.
While what was done was cool, I have to say this is overall disappointing. Wish the Switch wasn't such a piece of crap. Really disappointed with what has happened to the Wii and then Wii U and all of Nintendo's demonstration of bass ackwards thinking which not only includes these decisions, but the decisions to sue and force into oblivion so many indie developers making fan art (games). Completely disgusting and the big N can die in a hole for all many of us care for their lack of vision and understanding of their target audience.
OK, OK. But you avoid to answer: would you like to get (I hope this will never happen!) on the operating table to the hipster, who will operate on what is fun for him, and not what is needed? Reliable quality products are hard boring work, there is no fun in it. And you can not do everything just for fun. And this is true for most serious professions. And only in IT this nonsense is possible. What do you think of Steve Jobs? Genius? Or an inadequate idiot who fired people after talking in an elevator during a lunch break?
Any feedback would be appreciated! This is the first gem I've made that I hope others can actually find useful.
I mean after basic Rails, I am hopping TuffleRuby could run Discourse unmodified, I think that is one of the biggest Ruby / Rails Open Source project and it would make the biggest impact.
guides.rubyonrails.org is always the guides release for the latest release of Rails -- so not for Rails 6 yet. It says so at the top, "v5.2.3". And there are ways to access older versions of guides if you are interested in what the guides say. edgeguides.rubyonrails.org has changes that have made been made by contributors after the last release, so they haven't been released yet. But they're there to review before release, or examine for something that hasn't yet had a final release. Like 6.0.0.beta. You can see that where the guides said 5.2.3, the edgeguides say "These are Edge Guides, based on master@fb42684." Because edgeguides is automatically released based on what's currently in master, but not necessarily released yet. In either case, it's possible for there to be errors or omissions in the guides. Even though guides.rubyonrails.org was released with Rails 5.2.3, there could be things that were outdated and not fixed, because nobody noticed or nobody took the time to do it, or whatever. And likewise, edgeguides may not yet have been updated to cover all changes in the current 6 beta release, although one hopes it will be before Rails 6.0 final!
You're close. Here's a rewritten version: def index # Bail out early if user input is "" if params[:q].blank? @coordinates = 'Please enter a query' return end search = LocationiqApi.new('pk.29313e52bff0240b650bb0573332121e').find_place(params[:q]) # Hash#dig will return nil if ANY part of the lookup fails latitude = search.dig('searchresults', 'place', 'lat') longitude = search.dig('searchresults', 'place', 'lon') if latitude.nil? || longitude.nil? # Output an error message if lat or lon is nil @coordinates = 'No search results' else # We are good to go! @coordinates = "#{latitude}, #{longitude}" end end A few changes: * Checking the input query with Rails' provided `blank?` method instead of `nil?`, because "" is not nil - [read up on this](https://blog.appsignal.com/2018/09/11/differences-between-nil-empty-blank-and-present.html) * Using `Hash#dig` to access the nested fields in the search results. If any part of the lookup rails, the entire method returns `nil`. This is where your crash is occurring, because when a search fails some keys are missing in the result * Using Ruby string interpolation for the successful result
First off, don't post your API keys on reddit, or put them in version control. Go change your API key now. Second, look at what the API returns when it can't find what you're asking it for (use curl or irb/pry to play with it), I would guess that `@search["searchresults"]` returns `nil` when there are nothing is found so you need to check this.
for one mruby is used by shopify on all their stores, so that's a lotta end users
Just ignore em all except MRI (the "main" ruby), or maybe JRuby. If you need to pay attention to another, you'll know it. Python has a few implementations too, yeah.
Wow, this is super helpful! Thanks so much :) The code is a big improvement although one thing I notice is happening is that when the index template is loaded it automatically submits a blank search, at least that's what I think is happening as "Please enter a query" is there when the page is loaded. Any idea how I would prevent this from happening? Also, is it okay for all this logic to be in the controller or should it be moved somewhere else? I thought it was the convention to keep controllers lean. If not, I guess it should probably be in a custom action rather than index action? Thanks again!
I just try for fun your gem and it works a fun. &amp;#x200B; If I can ask a feature, it will be a function "to\_h", to convert your classes in hashes (that are more human readable). I provide an example: &amp;#x200B; Arx('1809.09415').to_h &amp;#x200B; could return something similar: &amp;#x200B; { id: "1809.09415", url: "http://arxiv.org/abs/1809.09415", title: "On finitely ambiguous B\u00FCchi automata", summary: "Unambiguous B\\\"uchi automata, i.e. B\\\"uchi automata allowing only one accepting run per word, are a useful restriction of B\\\"uchi automata that is well-suited for probabilistic model-checking. In this paper we propose a more permissive variant, namely finitely ambiguous B\\\"uchi automata, a generalisation where each word has at most $k$ accepting runs, for some fixed $k$. We adapt existing notions and results concerning finite and bounded ambiguity of finite automata to the setting of $\\omega$-languages and present a translation from arbitrary nondeterministic B\\\"uchi automata with $n$ states to finitely ambiguous automata with at most $3^n$ states and at most $n$ accepting runs per word.", authors: ["Christof L\u00F6ding", "Anton Pirogov"], categories=["Formal Languages and Automata Theory], published_at: "2018-09-25T11:40:39+00:00", updated_at: "2018-09-25T11:40:39+00:00" pdf_url: "http://arxiv.org/pdf/1809.09415v1", doi_url: "http://dx.doi.org/10.1007/978-3-319-98654-8_41"&gt; }
The ahead-of-time numbers for booting TruffleRuby are very good to see, and we're looking forward to precompiling JRuby as well. However, I'm confused about your assertion that TruffleRuby starts up faster than CRuby. The TruffleRuby "-e" numbers are basically equivalent to running CRuby without RubyGems loading at startup, correct? So if you compare apples to apples here: ``` [] /tmp $ rvm use ruby-2.6.2 Using /Users/headius/.rvm/gems/ruby-2.6.2 [] /tmp $ GEM_PATH=. time ruby -e 1 0.09 real 0.07 user 0.01 sys [] /tmp $ GEM_PATH=. time ruby --disable-gems -e 1 0.02 real 0.01 user 0.00 sys [] /tmp $ GEM_PATH=. time ruby -S gem --version 3.0.3 0.14 real 0.10 user 0.03 sys [] /tmp $ rvm use truffleruby Using /Users/headius/.rvm/gems/truffleruby-1.0.0-rc15 [] /tmp $ GEM_PATH=. time ruby -e 1 0.07 real 0.02 user 0.01 sys [] /tmp $ GEM_PATH=. time ruby -S gem --version 3.0.3 3.42 real 4.85 user 0.27 sys ``` Is it really fair to say TruffleRuby starts up faster than CRuby?
To be completely fair, here's JRuby 9.2.6.0 on JDK 8. We provide the --dev flag to improve startup in a development environment. ``` [] /tmp $ rvm use jruby Using /Users/headius/.rvm/gems/jruby-9.2.6.0 [] /tmp $ GEM_PATH=. time ruby -e 1 1.59 real 4.49 user 0.22 sys [] /tmp $ GEM_PATH=. time ruby --dev -e 1 1.31 real 1.82 user 0.16 sys [] /tmp $ GEM_PATH=. time ruby --dev --disable-gems -e 1 0.95 real 1.19 user 0.12 sys [] /tmp $ GEM_PATH=. time ruby --dev -S gem --version 2.7.9 2.01 real 2.66 user 0.29 sys ``` We are eager to follow your lead and precompile JRuby core, and I'm optimistic we can also precompile any Ruby code users run too! Great technology you have there!
Dude be nice.
This is cool as fuck.
Others have already noted that each of `{edge,}{guides,api}.rubyonrails.org` states a version number (or git sha, in the case of the edge ones). If you check git for that sha, though, I think you'll find that technically, 6.0 is not documented anywhere right now. (Oops!) Until the final 6.0 release (which is when api.rubyonrails.org will automatically switch over), edgeapi / edgeguides will be your best option, even though strictly speaking, they're now documenting the very early stages of 6.1-to-be. (To your other specific question, the class-level `respond_to` moved to responders, but the instance-level version remains. The documentation you're seeing is all fine.)
I don't work for MS, but they are the largest contributing company to open source projects on GitHub, so they already throw away a lot of money on open source so giving away large oss projects probably seemed natural.
Did you get a chance to read this? [https://bundler.io/v1.13/guides/creating\_gem](https://bundler.io/v1.13/guides/creating_gem) &amp;#x200B; I usually follow those steps.
&gt; I dont think TruffleRuby will ever be usable to run Rails. There is no 'wording that better', you were just wrong.
I used the main guide at rubygems.org and just kept on trying. I recommend to you to do the same - publish early, publish often, just to find out what works bst with your workflow. You will improve on it as you go.
Yes, exactly. Back in Ruby 1.8.2 times when I started writing a webgen (static website generator), execution times of the CLI command where nothing was to do were many times faster than now because of Rubygems. &amp;#x200B; Maybe [gel](https://speakerdeck.com/matthewd/rubykaigi-2019-gel-section) (heard from it because of RubyKaigi) will help in this regard.
A decent one I know is the repo for icelab.com.au – https://github.com/icelab/berg
Autoloading RubyGems could be applied in MRI too. However, I don't think pre-initialization is easily portable to MRI.
Like Kevin responded on [https://eregon.me/blog/2019/04/24/how-truffleruby-startup-became-faster-than-mri.html](https://eregon.me/blog/2019/04/24/how-truffleruby-startup-became-faster-than-mri.html), we don't disable gems and it's all transparent to the user, meaning the commands run the same, but without the overhead of loading RubyGems eagerly.
Basically we already run small blog-like Rails 4 and 5 apps, and standard C extension database drivers. We need to find out the blockers for larger applications. One of them was sassc needing a more complete FFI implementation which I merged recently in 1.0.0-rc16.
Sure! Sounds like a great suggestion, and not too difficult to implement. Would be useful for HTTP responses and stuff I guess.
See [How I Start - Let's Build a Gem Together!](http://yukimotopress.github.io/start) by Steve Klabnik or better [Hoe Developer's Guide - Build, Package and Publish Gems with Rake Tasks - Ready-to-Use Build Scripts](http://yukimotopress.github.io/gem-tasks) by Ryan Davis, et al. Cheers. Prost.
Bootsnap does this to some degree. I think \`bundler install --standalone\` could also help, by not requiring RubyGems.
There is no connection between "just doing things for fun" and not being prepared to put in the effort for quality of the type you suggest. A lot of progress comes from people finding enjoyment and fulfillment in pushing the boundaries and delivering something of high quality because they enjoy taking pride in their work. So I reject the premise of your questions - they have relevance to the discussion.
Indeed, most of this is transparent, and the big challenge of getting day-to-day Ruby tools starting up fast is still a problem to be solved. I'm glad to see this work is paying off for you, and I'm looking forward to native-compiling JRuby along with the Ruby libraries and tools Rubyists typically use. It's definitely promising technology...perhaps the problem of Ruby startup can finally be put to rest soon!
&gt; loads of options out there that I didnt know of (Plugin, engines, etc) I've never even heard of Ruby plugins and engines. What are these things?
It seems to me that CRuby could do pre-initialization in much the same way, by taking their instruction sequences and mapping them back into memory in a pre-booted state. However I do know this is complicated by the lack of pointer abstraction throughout the CRuby runtime; they'd need to rewrite at least some of those references as the code loaded, if it were captured from a previous run. &amp;#x200B; What may work better for MRI is being able to store off the instruction sequences in a cache, such as what's done with the bootsnap library. That would still have some deserialization overhead, but they have a very simple instruction format and more flexibility in how they boot that code. In TruffleRuby and JRuby, we have rather more complicated in-memory structures to represent code, which obviously makes the heap snapshot more attractive. &amp;#x200B; Great stuff, I hope we can follow suit with JRuby and bring our users the startup time they deserve!
\+1 for gel. So much of the overhead of booting a typical Ruby application is wasted searching and re-searching of the same paths. RubyGems basically just adds load path entries every time you activate a gem, which makes searching for files O(n) where n keeps growing the more libraries you use. Gel is pre-caching an index of what files are contained in those gems, so they can be accessed in constant time...it should have been this way in RubyGems years ago.
How is this not nice? I'm curious, at what point did statement of facts and observations become mean or otherwise loathsome? Just because I said a mega corporation who doesn't give two dumps for its clientele can cease to exist and I hope the market punishes them for their very "mean" (inconsiderate and really not actually market driven) actions should not make my remarks "mean" in any way.
Thank you.. Do you have some kind of use cases for using this API?
got to play with the examples and it was awesome. have to find ways to make this happen at work.
Indeed, I've deployed apps to production that don't need rubygems at all thanks to `bundle --standalone`.
This sounds like it has an undesirable side effect. With MRI, the `require` you get with `ruby --disable-gems` is ruby's original, simple, unadulterated version. At that point, if you decide to `require 'rubygems'`, you then get the complex version monkeypatched in by rubygems. IOW, I can control what version of `Kernel#require` I get with MRI. Sounds like I don't get that control with TruffleRuby. (A nitpick, for sure)
Thanks for sharing [/u/merongivian](https://www.reddit.com/user/merongivian). Hope you don't mind my tweeting it to some core Rails devs. Want to continue to show them that Opal needs some attention and love from Rails core so that it's part of the supported stack. Sure would be a tremendous asset if they could wrap their heads around that concept as per that thread: [https://twitter.com/ylluminate/status/1121814141105258496](https://twitter.com/ylluminate/status/1121814141105258496) &amp;#x200B; I guess DHH is forgetting his earlier chat with me re: Ember... Oh well, but yeah, Opal really needs to get some serious attention as it's the best option at the moment and may be for a long time to come until a LOT, lot, lot of issues are sorted out with WASM.
I'd say this could probably come in very handy when optimizing your code and collecting performance metrics in general, especially considering that it gives you exact measurements of CPU time and heap allocations.
As Chris pointed out, and as was mentioned in the article, this is only the startup time of the \*base VM\*...basically the time it takes to get you to "zero" before you actually run code. It's a very small part of overall application startup, but it's an important part when all you want to do is run a simple script. We're actively looking into duplicating what the TruffleRuby folks have done in JRuby, since startup time is the single most common complaint from our users. &amp;#x200B; Unfortunately the the big challenge -- and it's very big -- is getting real-world commands like "rake" and "gem" and "rails" and "bundle" to run as fast as CRuby. So far, nobody has a solution to this problem. JRuby has worked mightily to reduce startup time for medium to large commands, and as a result we're in the neighborhood of 3-5x slower than CRuby...which is sadly the best startup of any any non-CRuby runtime. There's a lot more work required both in JRuby and in TruffleRuby here. &amp;#x200B; Make no mistake, though, CRuby sets a \*very\* high bar for application startup time, and even their performance is lamented within the Ruby community. Solving this problem is going to take collaboration between all implementations, not just new technology or tricks that only benefit one of them. We'll get there, and the native TruffleRuby work is a good place to start.
Hey @jdickey - Graphiti creator here. We actually support any backend, from ActiveRecord to Sequel to Net::HTTP. The only difference is AR comes "out of the box" - but you need only write an adapter to use something else. That's actually easier than it sounds. You might want to check out: [https://www.graphiti.dev/cookbooks/without-activerecord](https://www.graphiti.dev/cookbooks/without-activerecord) Thanks for giving us a look!
Thanks! I'll be sure to check that out.
Having dealt with rubocop-rspec extensively, I absolutely do not like where this is headed. Their style guide makes a number of things worse and more complicated, as well as less expressive of intent. Before the style guide was started, they were taking pull requests that were in direct opposition to the only existing style guide. Betterspecs.org is excellent, and leads to very expressive specs that help with team understanding and maintenance. In all of this, what I haven’t seen is a _reason_ that we need to change the style guide.
As I mentioned earlier - feedback is much appreciated. I'm not involved much in the day-to-day of rubocop-rspec, but I know that the members of its team are smart and reasonable people. I'm certain that they are going to respond well to constructive criticism. I suggest sharing concrete frustrations you've got with rubocop-rspec either here or on the project's issue tracker.
[Here's an example](https://github.com/rubocop-hq/rubocop-rspec/issues/94). They started discussing whether this new rule was beneficial, but the author had already implemented it in master, and _made it the default_. Later, [people asked that it be disabled by default, but they just closed the PR](https://github.com/rubocop-hq/rubocop-rspec/pull/421).
The very first rule/style makes me go =/
My gem [tabulo](https://github.com/matt-harvey/tabulo) uses Enumerable in the Table and Row classes. See [here](https://github.com/matt-harvey/tabulo/blob/master/lib/tabulo/table.rb#L9), [here](https://github.com/matt-harvey/tabulo/blob/master/lib/tabulo/table.rb#L202), [here](https://github.com/matt-harvey/tabulo/blob/master/lib/tabulo/row.rb#L4) and [here](https://github.com/matt-harvey/tabulo/blob/master/lib/tabulo/row.rb#L26). It doesn't use `enum_for`. Not sure if that helps.
A "community guide" that's largely one guy's interpretation. I get "opinionated", but ISTR that back in the day, community consensus was actively sought before cops were enabled by default. Even if the committer owns ~20% of the commits made to the entire repo. I find myself relying on other tools (e.g., [Reek](https://github.com/troessner/reek/)) far more heavily than RuboCop and the Style Guide now than I did 5-7 years ago. The direction has been clear for some time.
&gt; A "community guide" that's largely one guy's interpretation. I get "opinionated", but ISTR that back in the day, community consensus was actively sought before cops were enabled by default. Even if the committer owns ~20% of the commits made to the entire repo. You might want to clarify this a bit. I don't believe our process ever changed, although originally the work on RuboCop followed work already done on the style guides (as they had been around for a few years when RuboCop was born) and at some point people started having most style guide discussions on RuboCop's issue tracker (in the context of proposed changes to existing cops or the creation of new cops) and this in turn lead to some style guide updates. At any rate, we're certainly aware of the problem of enabling more checks by default and we plan to address it before version 1.0 is out. See [this ticket](https://github.com/rubocop-hq/rubocop/issues/5979) for details. Also, keep in mind that this particular style guide joined the RuboCop HQ organization years after rubocop-rspec was created, so there's certain amount of disconnect that we have to address down the road. Ultimately every such project is going to be opinionated to some degree, as it's impossible to get everyone to agree or everything. We've always sought broad agreement on everything outlined in the guides and everything enforced by default by RuboCop and its core extensions. This article is mostly an invitation for more people to join the conversations related to RSpec, so we can do the best possible work on that front.
It sounds like you want to add authentication / authorization to your app. This is the process where you make users log in before they can do something. In your location controller you can then verify that a user is authorized before doing anything. Check out [Devise](https://github.com/plataformatec/devise)
https://github.com/ruby/ruby/search?q=enum_for&amp;unscoped_q=enum_for
Please let be begin with a disambiguation: `rubocop-rspec` is not in any way a style guide. It's a set of linters that can and should be configured and disabled to match the style used in your project and company. `rubocop-rspec` provides more checkers than the [`rspec-style-guide`](https://github.com/rubocop-hq/rspec-style-guide), because the style guide only contains the common practices recommended for every use, while you may want to enforce something in your project style that goes beyond that. Completely agree that BetterSpecs were excellent, but were also not maintained for a long while, and a bit outdated as well. What happened to BetterSpecs, which partially led to stagnation, is a [long-running initiative to move away from a site with custom deployment to GitHub pages](https://github.com/lelylan/betterspecs/issues/153). It also turn out that the published site is way behind [its GitHub pages version](http://lelylan.github.io/betterspecs/). Furthermore, site and GitHub pages versions [have diverged](https://github.com/lelylan/betterspecs/issues/168). Seeing this sad situation, and no activity on this front, I announced the intention to merge the contents of BetterSpecs to RSpec Style Guide, and later [did it here](https://github.com/rubocop-hq/rspec-style-guide/pull/55), including open tickets. Rest assured, all the recommendations from BetterSpecs found their new home in the new RSpec Style Guide. If you feel that something valuable was left behind, I encourage you to open a ticket or even better submit a pull request.
Could I make it so the controller action can only be performed if the current user is logged in?
You're looking for authentication/authorization. Devise makes all this relatively simple, but if you're newish, it may be worth it to go find some tutorials and try to implement a very basic implementation yourself. That way you will better understand the underlying concepts and processes a bit better when you do decide to use Devise or something similar in the future. Feel free to PM me any time if you have specific questions or problems you need help with. Always happy to try and help.
Enabling the cops by default is a way to let you know that new cops were introduced. I agree to some extent that it may be annoying at times to make additional steps if you updated `rubocop-*` version in the project you're working on. However, [it's not time consuming at all](https://fili.pp.ru/fixing-a-thousand-of-rubocop-offences-quickly.html), the only command you have to run to immediately disable all the newly introduced cops is `rubocop --auto-gen-config`. I creates a `.rubocop_todo.yml` file, disabling all the cops that have offences, including offence counts and configuration options: # Offense count: 127 # Cop supports --auto-correct. # Configuration parameters: EnforcedStyle. # SupportedStyles: when_needed, always, never Style/FrozenStringLiteralComment: Enabled: false Configuration options are immediately at hand, and often times they let you to enforce the style you use on the project. On the other hand, if the new cops wouldn't be enabled by default, in order to be able to track newly introduced cops and introduce them on a project, one would have to follow the [CHANGELOG](https://github.com/rubocop-hq/rubocop-rspec/blob/master/CHANGELOG.md), and manually enable them.
The style guide itself is not opinionated, and is the [result of work of many people over the years](https://github.com/rubocop-hq/rspec-style-guide#credit). I also includes the views on RSpec style by RSpec maintainers, and it's way easier to write a guideline than to write a new cop. Reek and RuboCop are not mutually exclusive, and I've seen cases when both were used on the same project. I highly encourage you to embrace the flexibility of RuboCop by using cop configuration options. It would also highly benefit the whole ecosystem if people would express their concerns on GitHub issues for related projects.
With Devise: ``` before_action :authenticate_user! ``` or if you want to whitelist (`only`) or blacklist (`except`) only certain actions: ``` before_action :authenticate_user!, except: [:my_insecure_action, :index] ```
Yes, that is basically what devise offers you in an easily integratable way. See here for example: http://blog.magmalabs.io/2018/07/03/use-devise-devise_token_auth.html There are tons of other devise tutorials, google is your friend here (e.g. search "rails devise authentication tutorial").
the problem with this is that the endpoint can be accessed by any user that is signed in, not just that particular user (which is what i want)
Thanks! I pm'd you :)
Then you have a choice between a lot of different [authorization](https://awesome-ruby.com/#-authorization) gems. * Devise (or others) = Authentication * CanCanCan (or others) = Authorization
Yes that’s how all authorization works. Devise will handle that.
What do you mean it will handle it? I'm already using Devise. Do I have to create a Location model and associate it with my User model?
Just add a field (boolean, default false, for this example, I’m calling it “can_access_location_page”) to your user model that represents if the user can access that particular page. That’s your flag for if they can access it or not. Then set up a before action before_action :not_found, unless: -&gt; { current_user&amp;.can_access_location_page? } This also assumes you have a method called not_found in application controller. That could be whatever - a method that raises an exception, shows an alternate page, whatever. I’d err on the side of showing a 404 for any page that doesn’t exist to a user. If it’s only one action, you can add on only: [:index] or whatever you need. Change the field for the user you want to access that page and you’re done. This is stupid simple, and, if you find you use this often, you should consider adding something like cancancan to your app.
You said the Locations come from an API. So in that case, no it doesn’t sound like you need a model associated with User. If you’re using Devise, then your controller should have the authenticate_user! available to it. Another reply said this, but you can add a before_action to the controller like this: class MyController before_action :authenticate_user! end If Devise is setup correctly and your user is authenticated, then they will be able to access this controller. Otherwise, the request will automatically return a 401. That sounds like what you want unless I’m not understanding something?
that's a bloody nice gem.
wow. I didnt know we could search like this in github. Thanks
GitHub search was limited to only searching X MB of the repo. If repo was larger than X, then not everything would show up in the search results. Not sure if this is still the case.
Well I think it's going to be a branch-job for me because webpacker alone is going to be quite some change.
Here's how Shopify does it, they're [running the rc in production](https://twitter.com/dhh/status/1121126215803260928): * Blog post: [https://engineering.shopify.com/blogs/engineering/upgrading-shopify-to-rails-5-0](https://engineering.shopify.com/blogs/engineering/upgrading-shopify-to-rails-5-0) * Railsconf 2017 talk: [https://www.youtube.com/watch?v=I-2Xy3RS1ns](https://www.youtube.com/watch?v=I-2Xy3RS1ns) * Gem to support dual booting: [https://github.com/Shopify/bootboot](https://github.com/Shopify/bootboot)
`respond_to` was not moved to a gem.
The `#allocations` method is used by the logger in Rails 6. An app request log with Rails 6 might look like: `Completed 200 OK in 101ms (Views: 4.4ms | ActiveRecord: 32.5ms | Allocations: 12867)`
You can be polite and also be intolerable at the same time
Is sprockets gone in rails 6? Are you required to use webpacker for something?
It says "webpacker by default". That doesn't mean you can't still use sprockets but I guess eventually it makes sense to migrate. I haven't looked into the process at all (and I'm one of the few that likes coffee) but I guess the benefit is we can use npm packages...
Thanks! `Enumerable` is one of my favourite aspects of Ruby. Just implement `#each`, and you get a bunch of other methods for free. I certainly found it helpful when writing the gem.
&gt; messaging order constraints If you have ordering dependencies on your background jobs you have a much bigger problem than your queues backing up.
&gt; This RSpec style guide outlines the recommended best practices for real-world programmers to write code that can be maintained by other real-world programmers. This real-word programmer is here to tell you that if you're concerned about this then stay aware from `let!` (and even `let`, really). All you need is `before`. Don't make yours and others' lives complicated! Be careful with shared examples too. Try to keep the dependencies minimal and try pass arguments explicitly: `it_behaves_like "a cargo cult developer", @arg1, @arg2`. Otherwise you'll be tracing through lazy and/or eagerly loaded spaghetti to find out why your tests are failing. Or even what they're doing. Look at it this way, would you write code like this: def foo $callers_context[:poo].some_method $callers_context[:bar].some_method end Or like this: def foo(poo, bar) poo.some_method bar.some_method end Also read this: http://xunitpatterns.com/
&gt; Please let be begin with a disambiguation: rubocop-rspec is not in any way a style guide. The defaults are in fact a style guide as many teams will not change them to avoid debate. Saying people shouldn't do so has no effect on the reality of the situation.
I think it'd be better if you filed this as a ticket on the project's issue tracker.
Have a look into [Date.parse](https://ruby-doc.org/stdlib-2.4.1/libdoc/date/rdoc/Date.html) (and maybe `Time.parse`). You can specify a format that will be used to parse or it tries to guess the correct format. (Needless to say this can go awkwardly wrong, so providing the format if you know it is always safer).
Date parsing requires assumption of format, otherwise 04/05/2019 is ambiguous. If you know the specific template at runtime, use (`Date#strptime`)[https://ruby-doc.org/stdlib-2.6/libdoc/date/rdoc/Date.html#method-c-strptime] to parse it.
\[The Rails 5 Way\]([https://www.goodreads.com/book/show/30990216-the-rails-5-way](https://www.goodreads.com/book/show/30990216-the-rails-5-way)) is pretty good.
I understand this, but those teams are making a mistake, that can be compared to the use of default options when creating a new Rails project. It makes sense to run it as: rails new . --git --database=postgresql --skip-puma --skip-action-cable --skip-coffee --skip-turbolinks --skip-test --skip-bootsnap --skip-sprockets --webpack RuboCop's [README states](https://github.com/rubocop-hq/rubocop/blob/master/README.md) in its very first paragraph: &gt; RuboCop is extremely flexible and most aspects of its behavior can be tweaked via various configuration options. Probably it's not emphasized enough that everyone is encouraged to adjust the configuration to match the established style, and this is not explicitly mentioned in RuboCop extensions ([1](https://github.com/rubocop-hq/rubocop-rspec), [2](https://github.com/rubocop-hq/rubocop-performance), [3](https://github.com/rubocop-hq/rubocop-rails), [4](https://github.com/rubocop-hq/rubocop-sequel), [5](https://github.com/rubocop-hq/rubocop-md)) , that sometimes even provide cops that contradict each other.
Does [this recommendation](https://github.com/rubocop-hq/rspec-style-guide#let-blocks) address your concern? &gt; Do not overuse lets for primitive data, find the balance between frequency of use and complexity of the definition. There's [a comment from Myron Marston](https://www.reddit.com/r/ruby/comments/73nrhk/ama_the_authors_of_effective_testing_with_rspec_3/dnsyanp/?st=jv0udjan&amp;sh=2bd8d1ea), long time RSpec maintainer explaining this: &gt; I find `before` and `let` to be useful for particular situations, but find that they often get mis-used/abused in the wild, unfortunately. My rule of thumb is to use them when there's a compelling benefit, but don't reach for them as the default way to write specs.
&gt; There's a comment from Myron Marston, long time RSpec maintainer explaining this: I've [seen Marston's arguments from 2011](https://stackoverflow.com/questions/5359558/when-to-use-rspec-let/5359979#5359979) and [mostly have never agreed](https://github.com/lelylan/betterspecs/issues/8#issuecomment-37266134). Here ~7 years later in 2018, it seems he _may_ be starting to realize they're bad: &gt; My rule of thumb is to use them when there's a compelling benefit,... &gt; ... but don't reach for them as the default way to write specs. No. There's never a compelling benefit: interpreter detecting your typo and lazy loading objects under test are not compelling. If I was concerned about an interpreter detecting a typo I'd be using a different language. Lazy loading, what is the point? If your tests are consuming resources to the point that you need to lazy evaluate them your tests have a problem. Remember, we're talking maintenance phase here: people need to go back to tests written months and years ago. Tracing through lazy loaded `let` hierarchies sprinkled with eager loaded `let!` with `before` hooks and shared examples that depend on the caller to define more `let`s is not maintainable. Obscure tests is not a compelling benefit. And really, we're talking maintainability _and_ style, so consistency is important. Let's throwout the very important argument above and consider this. It's safe to say (I think) that after 20+ years the TMTOWTDI camp has lost out to the There should be one—and preferably only one—obvious way to do it camp. I mean that's why we're here talking style guides, right? We don't want TMTOWTDI. In this case not everything can be done with `let`, you need `let!`. And not everything can be done with `let`, you need `before`. Why have some tests use X and some use Y and some use X and Y and maybe Z? Be consistent. KISS: use `before`. It's all you need. And really, learn what makes tests good and bad **in general**, then apply that to the language you're using. Don't look to some "style guide", "best practices", or Random Programmer X as the be all end all. Remember "Skinny Controller Fat" model? This was considered a "best practices" from nearly day 1. Many people bought in to it and now have/had maintenance nightmares. On the other hand people had been writing and creating layered architectures for years. The information was out there. It was no secret how one should organize code. Starting to rant here so let me get back to my point: 1. Learn what makes tests good and bad in general 1. Read the docs and evaluate things based on your previous experience, gut, and/or common sense 1. Use it in projects -toy or legit, then used the alternatives in projects, and experienced the results
With Auth0's pricing, I would love to hear what are the benefits of using them long term. Running an app with 1000 activedirectory "enterprise" internal users would cost $1100/m for authentication alone. https://auth0.com/pricing
No if you run TruffleRuby with `--disable-gems` it behaves the same as MRI - it won't enable the lazy RubyGems.
Right on! Thanks. Details like this are encouraging.
As of Java 8 (which allows interfaces to contain default implementations), they fill a somewhat similar role as far code sharing goes. Modules in Ruby have a lot more uses though, namespacing, procedure 'packages', etc. You second quote is wrong though, in Java any class that implements an interface must provide implementations for all methods defined in the interface.
thank you. ah, just like how in Ruby, when a class `include`s a module, it can use all the methods of that module, correct?
In Java interfaces are more often used to define type compatibility so while you can actually define the 'code' of a method in a Java interface it's more common for the interface to just define the method signature and every class that implements that interface provides the code for the method (in the class definition).
that's interesting, its new to me, I have more to learn on Java, thank you!
AD users are for users you want to have access to AD needs, ie exchange, windows accounts, etc. If you've got 1000 employees who need AD accounts, $1100/month is pretty cheap. If you're setting up a web app and need authentication and identity management you use their regular accounts which are unlimited under developer plans and above. For other options there is Okta, Azure identity, and ping identity
FWIW all the \*instance\* methods get included unless you do the self.included(base) base.extend ClassMethods end trick which would bring in the class methods. Also one thing re: ruby modules that I took a while to pick up on is what happens if Module has method x and the Class has method x, Class#x wins.
2D Platformers and twin stick shooters require physics/collision components, so I'm thinking of simple 2D games that I like playing that don't need those: Idle-clicker incremental games come into mind, it's a CRUD app with a timer, also Chess. If I can make a chess game, then I can iterate and turn it up a notch to a simpler version of any Tactical roleplaying game (FF Tactics, Fire Emblem Heroes, etc.).
What kind of users would I need for only ad-based authentication?
I'd start with a couple of things: &amp;#x200B; * Make your location service name generic, no point in having a service object if it still exposes the name of the underlying service you're using * Handle specific error cases for non-200 responses, perhaps they want to try again, i.e. for a 50X error, or perhaps they need to modify their input, i.e. 422 * Move logic out of the controller, can do this using a form object * Move presentation logic out of the controller (i.e. the controller doesn't need to know how you display latlon as \`Coordinates: @lat, @lon\` * Make use of layouts/partials in the view I threw together a quick and rough (and untested) example: services/location\_api.rb \`\`\` class LocationApi RESPONSE\_OK = '200'.freeze BASE\_URI = '[https://eu1.locationiq.com/v1/search.php](https://eu1.locationiq.com/v1/search.php)'.freeze &amp;#x200B; def call(place, limit: 1) response = HTTParty.get( BASE\_URI, query: default\_params.merge(q: place, limit: limit) ) &amp;#x200B; if response.code.to\_s == RESPONSE\_OK response.parsed\_response else \# Would handle the error cases you care about here \# rather than raising exceptions for any non-200 code response end end &amp;#x200B; private &amp;#x200B; def default\_params { key: api\_key } end &amp;#x200B; def api\_key \# No point in injecting this at the constructor \# if it always comes from app config, or code is tested \# it helps there Rails.application.credentials.locationiq\_key end end \`\`\` &amp;#x200B; app/models/base\_form.rb \`\`\` class BaseForm include ActiveModel::Model end \`\`\` &amp;#x200B; app/models/location\_form.rb \`\`\` class LocationForm attr\_accessor :name, :lat, :lon validates\_presence\_of :name &amp;#x200B; def valid? validity = super &amp;#x200B; return validity unless validity &amp;#x200B; update\_lat\_lon &amp;#x200B; return true unless lat.nil? || lon.nil? &amp;#x200B; errors.add(:name, :invalid) &amp;#x200B; false end &amp;#x200B; private &amp;#x200B; def update\_lat\_lon @lat, @lon = [LocationApi.new.call](https://LocationApi.new.call)(name).fetch( 'searchresults', {} ).fetch('place', {}).values\_at(:lat, :lon) end end \`\`\` &amp;#x200B; locations\_controller.rb \`\`\` class LocationsController &lt; ApplicationController before\_action :authenticate\_user! &amp;#x200B; def new location = [LocationForm.new](https://LocationForm.new) &amp;#x200B; render :new, locals: { location: location } end &amp;#x200B; def create location = [LocationForm.new](https://LocationForm.new)(location\_params) &amp;#x200B; render :new, locals: { location: location.tap(&amp;:valid?) } end &amp;#x200B; private &amp;#x200B; def location\_params params.permit(:location).require(:name) end end \`\`\` &amp;#x200B; views/locations/new.erb \`\`\` &lt;main&gt; &lt;!-- MOVE TO PARTIAL OR LAYOUT //--&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;!-- Log out shows when logged in. Log in shows when not logged in --&gt; &lt;% if user\_signed\_in? %&gt; &lt;li&gt;&lt;%= link\_to "Log Out", destroy\_user\_session\_path, method: :delete %&gt;&lt;/li&gt; &lt;% else %&gt; &lt;li&gt;&lt;%= link\_to "Sign Up", new\_user\_registration\_path %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link\_to "Log In", new\_user\_session\_path %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &amp;#x200B; &lt;h1&gt;Location Search&lt;/h1&gt; &lt;!-- devise flash messages --&gt; &lt;%= render 'shared/flash' %&gt; &lt;%= render 'shared/errors', errors: location.errors %&gt; &lt;!-- Button to search coordinates --&gt; &lt;%= form\_for(location) do |f| %&gt; &lt;%= f.text\_field(:name) %&gt; &lt;%= f.submit%&gt; &lt;% end %&gt; &lt;%- if location.lat.present? &amp;&amp; location.lon.present? %&gt; Coordinates: &lt;%= [location.lat](https://location.lat) %&gt;, &lt;%= location.lon %&gt; &lt;%- end %&gt; &lt;/main&gt; \`\`\`
&gt; With implementation of interfaces, you can pick and &gt; choose the portions you want to use. You could even abuse/misuse/creatively use modules on a per method basis. Some projects do that e. g. you can cherry-pick which method to "include". I find this to be overkill but people are crazy/creative. Also note that matz suggested adding "interfaces" to ruby eventually; it was not a finished idea, he only mentioned it at the core tracker for ruby.
In addition to what /u/Mancinoz said I'd add that your controller is still very tightly coupled to the service class. By the virtue of `.dig`ging through the raw response hash, the controller still knows about the inner data structure of the `LocationApi` class. If you ever switch location providers or the API changes substantially, instead of just changing the logic in one spot you will have to change it everywhere you use it. Consider adding a value object (a simple `Struct` would probably be more than enough for your use case) as the return value of the service class. That way you can easily access the data in a more friendly way (e.g. `location.lat` instead of `location.dig('searchresults', 'place', 'lat')`) and you are insured against future API changes.
&gt; Module has method x and the Class has method x, Class#x wins. Huh? I tested ... and ... you are right! module Foo def self.test puts 'hi from Foo' end def test Foo.test end end class Bar def test puts 'hi from Bar' end include Foo end Bar.new.test Foo.test Output is: hi from Bar hi from Foo That surprised me too. I would have thought that "last defined wins", so since include Foo would overwrite the old method which does not seem to be the case. So I am confused right now ... admittedly I just woke up though so I am not quite in thinking mode yet ...
interface: "I solemnly swear to provide these methods" module: "I now have these functions" &amp;#x200B; interfaces are a way in java to work around some of the drawbacks of static typing. A method can define an interface as argument, and thus accept an object of any class that implements the interface. In ruby, we have duck typing, and methods don't declare what arguments they accept. Any arguments are assumed to implement the needed methods, to have the required interface. Thus interfaces don't exist in ruby, and you're making a mistake in trying to translate the concept to anything that does exist.
The benefits are that you're paying for it to be someone else's problem. If you work in an enterprise, $1 per internal user is dirt cheap compared to your engineering time.
Including a module doesn't 'import' the method into the body of the class, it adds the module to the ancestor chain of the class. A method call on an object of the defined class will only call the module method if it's not defined on the class (or the singleton class of the object).
&gt;class LocationForm Shouldn't your `LocationForm` inherit from `BaseForm`..?
Thanks a lot for detailed writeup, I agree with a lot of points here. Additionally want to thank you for filing [an issue](https://github.com/rubocop-hq/rspec-style-guide/issues/94), this is how the decisions on changing the style guide should be made.
It's because include isn't quite doing what you think it is, but is instead adding the modules into the inheritance tree. So calling super from a method in the class will end up invoking the method in the module. I *think* behind the scenes it ends up defining the methods on the eigenclass but I'm a bit baby brained at the moment and generally need to refresh myself on the details in the rare moments it becomes important.
I can see why they remind you of each other, but not really. An Interface in Java is a specification of _what_ methods a class has to implement. A class can say it implements an interface, and then the compiler will ensure it really does implement the methods the interface requires. And a call site using an object can insist that the object be an implementer of an interface, and then count on the methods being available if it is. There isn't really anything like that in ruby, any part of the language that specifies the _interface_ (the methods that must exist), and is checked by the language to ensure it is true (neither at runtime nor at compiletime -- there's no checking of types at compile time at all in ruby). A ruby module mix-in has method _implementation_, not just specification of what methods what exist. Module mixins, in fact, in this sense, are a form of "multiple inheritance". A ruby class can get method _implementations_ from multiple direct ancestors -- not only it's parent class, but also any number of module mix-ins. Java doesn't have this kind of multiple inheritance at all. Where they are all similar is that they are all notions of "type". In object oriented programming, an object's "type" is basically what methods it implements. A particular class is a type that all instances of that class or any sub-classes belong to -- since all such instances will have the methods defined by the class. A Java interface is a type in that all instances of objects that implement the interface will have the methods required by the interface. A Ruby mix-in module is a type in that all instances of classes that mix-in the module will have the methods defined by that module -- for instance, all instances of classes which mix-in Enumerable will have methods like `all?` and `any?`. But also, `Enumerable` basically _requires_ a class mixing it in to have an `each` method, although `Enumerable` doesn't _define_ this method, so in this sense it does kind of serve as an "interface", although that isn't actually enforced by the language exactly. So basically, they are all different ways the respective languages define the concept of "type", so since Java doesn't have module mix-ins, and ruby doesn't have Interfaces -- they can end up serving similar roles even though they are formally different.
Sadly I felt that that would not convey the strength of my sentiment. I've tried this before and I think others need to be more forceful in their expression of dissatisfaction in order to start becoming more vocal. There's a point where simple expressions without the guttural composition don't help and we've crossed that threshold. I've put my money where my mouth is and I and many others I know have now boycotted Nintendo, but we have to make this displeasure known to others do we not?
What does it actualy use to do the actual HTTP connections? net/http? I'm having trouble figuring out where the code that actually does the HTTP is, in the [repo](https://github.com/rom-rb/rom-http). There are pro's and con's to the kind of abstraction behind ROM, but one of the con's is I find it very hard to figure out where the code actually doing the work _is_ and how it's all related.
&gt; I'm having trouble figuring out where the code that actually does the HTTP is https://github.com/rom-rb/rom-http/blob/32600d1463bbbaf40981f7eb12460d8e1d1cc804/lib/rom/http/handlers/json.rb
While it certainly can be quirky with class2 you can do this (amongst other chicanery): require "class2/autoload" # builds classes from API's JSON below require "pp" commit = Commit.new(:author =&gt; { :name =&gt; "luser1" }) pp commit.to_h __END__ { "response": { "sha": "f52f1ed9144e1f73346176ab79a61af78df1b6bd", "commit": { "author": { "name": "sshaw", "email": "skye.shaw@gmail.com", "date": "2016-06-30T03:51:00Z" } }, "comment_count": 0 } } Or even: require "class2" # Incoming JSON uses camelCase spec = { :commit =&gt; { :fooBar =&gt; Time, :bazFoo =&gt; Integer } } class2 spec do include Class2::SnakeCase::Attributes # use snake_case accessors include Class2::LowerCamelCase::JSON # and serialize back to camelCase end # :foo_bar works too commit = Commit.new(:fooBar =&gt; "2019-04-29T13:42:31+00:00", :bazFoo =&gt; 999) puts commit.foo_bar.class # Time commit.foo_bar = Time.now puts commit.as_json["fooBar"] puts commit.to_json Bring your own HTTP client.
Well it is 8*8 and 9*9 why though you'd have to inspect the source... Or it may be in the docs.. Not gonna check on phone rn
You are right. Will remove it from the blog.
So why comment at all?
The argument is to define the base of the system the number is already in as a string. &amp;#x200B; For example, for a number 256 in hexadecimal system: &amp;#x200B; \`\`\` \&gt;&gt; "FF".to\_i(16) =&gt; 255 \`\`\`
Yes, it should, nice catch, edited.
So why post at all? Rtfm imho
 "01".to_i(2) # =&gt; 1 10".to_i(2) # =&gt; 2 "11".to_i(2) # =&gt; 3 So 2 seems binary as base. 81 / 9 = 9 When you use another base than our ten-finger (digit) system then naturally you need different positions for tracking the same relative increment/decrement. I guess part of the confusion arises mostly because: a) we don't really know any other system other than base 10 very well, not even base 2 and b) we actually only use the 0123456789 symbols. Things may be different if we were to have 6 fingers and only 6 symbols to use.
ok, thank you. so x = "100".to\_i(9) =&gt; 81 becouse: (0 \^ 9) + (0 \^ 9) + (1 \^ 9 ) = 81 :) Now I understand
Your math should be: (1 \* 9\^2) + (0 \* 9\^1) + (0 \* 9\^0) but yes.
Hm. What actually makes an HTTP request to a server. Or am I misunderstanding, and this is not something rom-http does?
Nice. Looks like by default it uses multiple separate processes to parallelize? that should be pretty darn safe. If you choose to use `:threads` instead, you may find out what parts of your test harness (or actual codebase?) are not concurrency-safe, which may not be a bad thing to find out.
I don’t disagree with the point you made, but I think that the way you went about expressing it was ineffective. Let me give you an example. Someone built a really cool thing using legos. People are like, wow this is cool, nice job! Then someone jumps in saying, “why would you do this? LEGO is an evil company, we shouldn’t be supporting them.” That person has now completely disregarded the work we were enjoying, instead injecting negativity about the tools used into the discussion. Maybe it’s true, but it’s not a great choice of time, place to have that discussion. Or at least, it could have been done in a way that doesn’t ignore or invalidate the work that OP put in.
It does it right there in the code he linked doesn't it?
You should read the online document
If engineering time is let's say $100/h, does this mean that setting up and maintaining authentication would take more than 15h/year? I'd think that authentication would be a set it and forget it kind of thing.
&gt;What actually makes an HTTP request to a server In ROM communication with data backends is handled by [`Dataset`](https://rom-rb.org/5.0/learn/glossary/#dataset) objects. In case of `rom-http` it is [`Dataset#response`](https://github.com/rom-rb/rom-http/blob/master/lib/rom/http/dataset.rb#L386-L388) method, which uses the injected `request_handler` (that you can provide or use the built-in one for JSON APIs). I understand that it may be hard to figure things out on your own. Fortunately ROM actually has a pretty straight-forward model that can be easily explained. The whole thing is based on the idea of a data pipeline. Data is fetched from some source and then it goes through multiple processing "layers". In case of `rom-http`, here's what happens: ``` request_handler &gt;&gt; dataset &gt;&gt; relation &gt;&gt; schema &gt;&gt; (optional) mapper ``` Now: - `request_handler` - issues the request, gets a raw response body and returns an array with hashes - `dataset` passes raw array with hashes to the relation - `relation` goes through each hash and applies its `schema` - `mapper` sets up struct objects (once we support associations in this adapter, it will also handle merging associated data) Replace `request_handler` with a database connection and you will see how it works in `rom-sql`. Hope this helps.
Aha, you're right, I missed it. request_class = Net::HTTP.const_get(ROM::Inflector.classify(dataset.request_method)) request = request_class.new(uri.request_uri) Okay, so it is Net::HTTP, through some abstraction I don't quite understand, but presumably could with some work. Cool.
Linking to it would be more useful advice. https://ruby-doc.org/core-2.0.0/String.html#method-i-to_i
The to_i method is being called on a string object. Lookup ruby string - https://ruby-doc.org/core-2.6.3/String.html And then look up the method to_i https://ruby-doc.org/core-2.6.3/String.html#method-i-to_i Based on the documentation it shows you the base. So to_i(8) returns the integer value assuming the data is the octal representation of a number.
Try the following: * self implementing method x. * self including a method which implements x * having a super class with a method x, * a super class with a module that implements method x
It's actually by design based on a precedence. IIRC I read it in the Metaprogramming Ruby book in the back section. :)
&gt; The main reason is that Sean Griffin, one of the core contributors at a time, wanted to promote store accessors to full-featured attributes backed by not very well-known Attributes API. Unfortunately, that did not happen and likely will not happen in the near future—Sean has recently left the Rails Core team. :( :( :(
&gt; Sean Griffin [https://blog.seantheprogrammer.com/moving-on-from-rails-and-whats-next](https://blog.seantheprogrammer.com/moving-on-from-rails-and-whats-next)
Nice. Always good to see these types of posts, as we don't usually have time to follow all the commits. Store accessors _changed? methods will be very useful, and the lack of negative queries for enums are what kept me from using them (and using enumerize instead, which is still more useful but the bare rails version would be good enough for easier things). The new rails routes switch is also nice when your app is bigger.
Simple trick, but I like it!
Same applies for upgrading (`composed_of` aggregations](https://api.rubyonrails.org/classes/ActiveRecord/Aggregations/ClassMethods.html) to use the Attributes API. Now I doubt it'll happen at all :/
Am I the only one that just CMD/CTRL+F `/rails/info/routes`?
why net/http? why not using faraday and allow the user to choose their http client library? Is net/http still recommended to work with?
Hey, thanks. I eventually tracked it down! The metaphor of being on the top floor of a building was indeed used by [Yehuda Katz at RailsConf 2014](https://www.youtube.com/watch?v=9naDS3r4MbY). Although he in turn traces the metaphor back to Steve Jobs in the mid-nineties. However, the key point I was seeking - that the next floor down should be just as useful - was a passing commentary on that keynote, at the same conference, in a talk by Ernie Miller [link](https://www.youtube.com/watch?v=uDLtgjx5_Ss&amp;feature=youtu.be&amp;t=1555). And where I actually picked this up was from Sean Griffin in a 2015 podcast where he references Ernie Miller's remarks in a discussion of the Attributes API. [link](http://bikeshed.fm/8)
If you think there are too many rails entries Then submit non-rails related entries? I like ruby, and rails, and I use rails mostly of the time when touching ruby. I don't do much ruby programming outside website/API related stuff.
Rails is by-and-large the biggest ecosystem in the Ruby community and the framework of choice for most Ruby developers of sites both large and small. Further, Rails is not too restrictive but it does have a “preferred” way to do most things; I’ve found that this leads to a lot of “how am I *supposed* to do this” questions. Your question is certainly valid however; I’m often shocked at how many developers assume right out that I am using Rails simply after I say I am developing a website in Ruby, or if I ask a simple Ruby question they give the Rails answer. The intertwining of the two in the community is always a topic of debate.
Because it's included with Ruby and it works reasonably well for most cases? https://github.com/rom-rb/rom-http#extending shows how you can bring your own `default_request_handler` if you need it.
Part of the issue might be that /r/rails does not welcome link posts like /r/ruby does. The other day a friend of mine submitted a link post to /r/rails and it got removed. I later posted it to /r/ruby and it didn't get removed. It seems that /r/rails is mostly for Q&amp;A posts, not for link posts. That might be another reason why you are seeing so much Rails-related content in /r/ruby. PikachuEXE and frostwyrm99 raise valid points too.
&gt; The problem is that working on MIT/Apache licensed software doesn’t exactly help pay the bills. This is a real problem. Fortunately, we seem to be getting past the "denial" stage, but there's still far too much self-entitled and -interested shouting going on to craft effective solutions.
We will be writing about this feature soon.
I'd say there's a non-zero possibility. ;) I'm just used to doing it from the console.
Exactly what /u/Rafert said + this is just a default handler that's built-in so that it's easy to get started with `rom-http`. I suspect many people will want to use custom handlers, that's why it's configurable.
Yeah that's because net http has such an idiotic design I guess. It just constructs Net::HTTP::Post etc.
Right now I can't think of many common uses for this, so that is probably why it isn't a method in Rails already. The best way for you to solve this issue is probably to define a custom method (as you have). You can automatically add it to all models if you write it inside the \`ApplicationRecord\` class.
&gt; I'm not convinced this is the greatest solution. Why not? Ruby makes monkey-patching possible exactly so you can do this kind of thing. Yes, a lot of people frown on monkey-patching, but unless you're writing a library for other developers to use, what's the big deal? To wit, Rails' ActiveSupport is full of monkey patches, some of which are eventually integrated into Ruby stdlib (like `Hash#slice`). In fact, if you wanted this idea implemented in a widely-used library, I'd say a feature request on ActiveSupport is your best bet.
This is more of a general concept question, not only related to Ruby. Not trying to sound condescending, but if I were you i would brush up on the knowledge about the difference about these two. &amp;#x200B; Ill leave an example for the usage and difference, hopefully it helps. &amp;#x200B; &amp;#x200B; class User def is_inactive? status == 'inactive' end def self.clean_up_inactive_users self.where(status: 'inactive').destroy_all end end So, in this case, `User` class has an instance method `:is_inactive?` and a class method `clean_up_inactive_users`. The first method is called only on the instance of user, and the method only knows about the user that called the method. User.first.is_inactive? and the second one is called on the whole user class and knows about the class in general, but not about any instance of `User` class. User.clean_up_inactive_users One more thing to note, calling an instance method on the class or a class method on the instance will raise a `NoMethodError`
Thanks, this was an amazing example, I just pictured it in my mind and it cleared everything, thanks alot
glad i could help
You are defining class B inside the module M, so mymeth will not be directly available in B. &amp;#x200B; To fix this, get rid of class A and define \`mymeth\` directly in the module: &amp;#x200B; module M def mymeth "mymeth" end end class B include M end obj = B.new obj.mymeth #=&gt; "mymeth"
By including module M in class B, you are not making class A available to class B. You are only including methods defined inside the module. To include this method from class A, you can either pull it out from the class and remove the class completely, or have class B inherit from class A. &amp;#x200B; module M def mymeth 'mymeth' end end class B include M end B.new.mymeth =&gt; 'mymeth' or module M class A def mymeth 'mymeth' end end end class B &lt; M::A end B.new.mymeth =&gt; 'mymeth'
If you ever end up doing a PR into ActiveRecord for this, `only_some?` might be a better name for it, has a nice flow to it `[1,2,3].only_some?(&amp;:odd)`. If you don't mind me asking, what situation are you using it in? Off the top of my head i can't even come up with a suitable example.
I never heard of a use case for this. If you think there is, you could always report at the bug tracker, but to me this sounds like a 1st april joke. However had, let's for the moment assume that there are real use cases for this schroedinger cat code example - I guess you attempt to use a more idiomatic way for this. I am not sure if there is one, but you could make a case at the bug tracker if you can find a good API. I would not know a good name for this though. I also never had a use case to "dealing" with "some but not all". If there were I tend to pull down many things to filtering, via select/reject and then having a look at the end result (empty, not empty etc...). That seems to work just fine. And, by the way, if any? &amp;&amp; !all? works for you, as strange as that is, why would it be a problem? I don't quite understand why some people try to micro-optimize every little character they use - you folks have way too much time to be able to do that!
Typical usage, for example: module Foobar Now you may wish to make use of that project in another project. You have two major ways here: toplevel calls such as Foobar.call_some_method and the include (or extend variant ... but let's ignore that for the moment) way, into a class or module. Both offer flexibility at different points. I typically begin by adding toplevel methods, at the least for the functionality that I wish to expose. For example some of my larger projects may have: Foobar.disable_colours to disable commandline-use of colours. Often there is some class that does the job, and then I may add a toplevel method below that class, like: module Boo class Foobar def initialize generate_some_pdf_file end def self.generate_some_pdf_file Boo::Foobar.new.generate_some_pdf_file end end (Dont mind the indent or unnecessary Boo::, I just wrote this quickly without checking - the idea is to define these methods to make the API easier to use and also remember; I never want to have to remember anything, everything I do should just work as-is, all the time, and surprisingly this works well in ruby)
Good post, and I learnt something. Thanks for writing it. Particularly interested in the bulk insert functionality you went into that i wasn't aware of! As a bit of an aside, could you look at changing the CSS for your page so that scaling up and down (ctrl+/ctrl-) works in-browser? It's a bit of an accessibility no-no. When you use vw for font sizing, you completely override the browsers ability to scale the page. See this post from 2018: https://www.stefanjudis.com/today-i-learned/viewport-units-for-font-sizes-destroy-zooming/
Defaults are important. Where is the error handling code? net-http is known to break in multiple ways (it recovers and raise specific net-http, but not quite). As far as I can tell, it doesn't also retry on error. As a "client to the backend", besides the rom integration, it doesn't look very robust. Is that supposed to be deferred to the users, like I should implement that all in my custom request handler? This is not all net-http. ´JSON.parse` can also throw parsing error. Where's the recovery code?
You can find many step-by-step getting started blockchain tutorials (from zero / scratch) with ruby at [Open Blockchains](https://github.com/openblockchains) including: - Programming Blockchains Step-by-Step book / guide. Let's build blockchains from scratch (zero) step by step. Let's start with crypto hashes... - Programming Crypto Blockchain Contracts Step-by-Step Book / Guide. Let's Start with Ponzi &amp; Pyramid Schemes. Run Your Own Lotteries, Gambling Casinos and more on the Blockchain World Computer... - Programming Bitcoin Script Transaction (Crypto) Contracts Step-by-Step - Let's start with building your own bitcoin stack machine from zero / scratch and let's run your own bitcoin ops (operations)... - Programming Crypto Collectibles Step-by-Step Book / Guide. Let's start with CryptoKitties &amp; Copycats. Inside Unique Bits &amp; Bytes on the Blockchain... PS: By the way, Ruby is (almost) perfect for (smart) contract scripting. See (secure) ruby : -) for more @ https://github.com/s6ruby Cheers. Prost.
Thank you so much for taking the time out to reply. I’ll be having a look right away :)
It doesn't matter what language you use. If you like ruby, and you don't have a good reason to use something else (e.g. The company you really want to work for uses C++, or a library you need to integrate with is in Python), then use it. There are many ways to get started in the world of software. Some people go to university; others take shorter, intensive courses; others work first as interns; others do lots of personal/open-source projects to get started; .... But the one key thing that unites all of this routes is ambition, dedication and a passion to learn. Beyond that, it really doesn't matter what specific technology you use (e.g. ruby) or what problem you try to solve (e.g. blockchain). There's no need to think of transitioning to a new tech stack a little later down the road as a significant hurdle. Focus on learning the principles of building good quality code.
&gt; Is there a specific reason as to why this is? Is Ruby &gt; an uncommon language for Blockchain development I suppose if you use e. g. C++ or possibly Java and Go, you may have an end result that may work faster, so the comparison is not fair IMO. As for "favoured" - that depends a LOT on the bias of the person at hand. If someone already knows C++ and python, using ruby just does not make any sense in the stack. For prototyping ruby is great. It also is by far the best language out there (totally unbiased comment, I swear!), mostly given how utter shit most programming languages are (I am not kidding here - most programming languages are UTTER GUTTER TRASH; "professional" developers don't like to admit this because otherwise they have to explain why they invest +40 years of their life staring at a computer screen and writing obscure instructions ... though if it is just a job for wage then I guess it's ok; I just don't understand why this would be "great" per se ... future generations will look at us with a great surprise thinking that could have been enjoyable doing years after years. What ruby does is allow for a lot of flexibility, so you can pick what you like and (mostly) reject what you dislike, as opposed to e. g. python. I do not think it is good to compare ruby to e. g. C++ - it is so different in every aspect really, use cases, niches, speed, enjoyment and so forth. If you want to become "professional" you have to be good in several languages, most likely, in particular when it comes to the grunt job of optimizing (which unfortunately is an evil necessity; ruby is awesome, and it has gotten a lot faster compared to the 1.8.x days, but it is nowhere near on any parity to compiled languages, in particular when a computer system is under heavy loadm e. g. Garbage Collector kicking in).
I don't use ruby much anymore, but back when I did, I really loved ruby and really hated rails. At least for my cases, way too much bloat and there are much simpler perfectly functional solutions. Well anyhow, I guess the answer to your question is that ruby got heavily associated with rails, and python has moved into being the de facto go-to higher level language. That's my take on it, and I personally I think it's a shame, I think ruby has a lot to offer, I have no interest in rails, and I rather hate working in python. If I were to ever pick up ruby again, I'd definitely be in agreement with you and would prefer to move most rails posts to /r/rails
In ruby you typically should separate between modules and classes. Rather than defining the method on class A, define it in a module, and then work with that module. The distinction between classes and modules is mostly arbitrary/random, or a design decision matz made; and either way it is best to use ruby in a way how it was designed. So in this case, define some module with the method, and then "mix in" that module onto class B. Same for class A by the way. You can even use and define instance variables in modules just fine. Consider modules more like an "interface" that is more flexible then a class; even though that distinction is somewhat arbitrary too. But it will be a lot easier if you stick to how matz encourages you to use ruby. If you really must then consider scoping, e. g M::A M::A.some_method That should work too. But again, it is best to define these things into a module anyway. You can define it within a "sub-namespace" soo.
Firstly, thank you for replying, I appreciate it. I haven’t seen any blockchain startups or job offers that mention Ruby. The 3 I listed are the languages I almost never fail to see which is why I assumed they were superior for that specific application (blockchain). This is based on my inexperience so reading what you’ve written has been educational as well as informative. I’ve heard that Go specifically is one of the fastest, along with Java and C. Isn’t this a big factor to consider when developing a blockchain? Would there be any significant difference if I built 2 blockchains, one in Java and the other in Ruby? I’ll be looking to work for a Blockchain start up, primarily for the experience and to learn. But Ruby seems to be a less chosen path within the Blockchain industry, either that or I’m quite misinformed. Thanks.
Can you elaborate on what you use this for? I can't really think of why you would have different logic for #any? than you would have for #some?. I think more likely I would break the list into two, or only operate on the one set using a select or reject.
You should use a class method when the method does not need access to the state of your object. class Square def self.number_of_sides 4 end def area @side_length * @side_length end end Of course the example here is a bit convoluted, you would use a constant here because the number_of_sides method has no arguments, but you get the idea. If your method is about your class but it does not apply to an instance of it, use a class method.
why do you want this method at all?
A more efficient implementation would be something like: def only_some?(&amp;block) matches = count(block) matches &gt; 0 &amp;&amp; matches &lt; count end
This came back to my mind this week as well when I saw a tweet that referenced Ernie Miller’s talk. Congrats on tracking it down and thanks for following up.
It's literally `.find`. If it finds one, you got your "some".
 class B include M def your_accessor A.new.mymeth end end obj = B.new.your_accessor
`any?` seems to do what you want. Also check out ActiveRecord's [`many?`](https://api.rubyonrails.org/classes/Enumerable.html#method-i-many-3F).
Fact that you've found one odd number in [1,1,1] doesn't confirm that list has any even numbers and vice versa.
#any? returns true on the first matching entry and doesn’t check any more entries. OP wants to return false when all entries match, so all entries need to be checked. It seems #many? Has the same short-circuit behavior as #any?
This works for a rewindable/repeatable Enumerable like Hash and Array but not for a stream, def only_some? total = 0 matches = count do |entry| total += 1 yield entry end matches &gt; 0 and total != matches end Will work for all Enumerable objects.
&gt; Is that supposed to be deferred to the users, like I should implement that all in my custom request handler? For now, yes. In the future we *may* add a more robust default handler with proper error handling etc. This hasn't been decided yet.
Hey OP, if you want to learn ruby, check out launch school. Been recommending them. Not associated with the company, just a student myself. In 150 hours, I went from being able to write a loop in python to being able to write a command line blackjack game(was around 200 lines of code). I can solve some impressive(to myself) problems. If you look at codewars, I'm currently doing 6kyu and some 5kyus and I'm only in chapter 1 of the program.
All these examples require the complete evaluation of the entire enumerable. This isn’t really necessary. Both any and all actually short circuit when they find the first truthy an falsy statements. To do this efficiently, you only need to look for the first *change* in truthiness.
Here you go: arr = [1,1,3,5,2,3,4,5,6,7,8] module Enumerable def some_but_not_all? return some_but_not_all?(&amp;:itself) unless block_given? found_true = false found_false = false e = each while true begin v = e.next #puts v # uncomment this to show that it short-circuits rescue StopIteration return false end if(yield(v)) then found_true = true else found_false = true end return true if(found_true &amp;&amp; found_false) end end end puts arr.some_but_not_all?(&amp;:even?) # =&gt; true puts [2,2,2,2,2].some_but_not_all?(&amp;:even?) # =&gt; false puts [true,true,true].some_but_not_all? # =&gt; false puts [false,false].some_but_not_all? # =&gt; false puts [true,false].some_but_not_all? # =&gt; true Iterate through looking for a true value and a false value. Return as soon as we've found one of each.
&gt;I end up defining my own method in my enumerable classes They're not actually monkey-patching, they're just defining the method over and over. I agree that extending Enumerable is reasonable here, or implementing the method in a module and importing the module into the classes that need it. Their implementation also yields elements more than once, which might not be desirable if the check is expensive.
I this this does less work: def only_some?(&amp;block) !block.call(first) ? any?(&amp;block) : !all?(&amp;block) end
Care to develop more on why ruby is one of the best language out there? Or why the other one are that bad? I often read your posts but I don't understand your point of view quite yet ...
To reinforce the degree of /u/fsoawesome 's _faux pas_, the framework being demonstrated is cross platform. The Switch was merely used for the demo. This means that the outrage was even further off-target.
It’s not hidden
Why not `SomeButNotAll.new(enumerable).true?` No need to monkey-patch Enumerable or other basic objects, no need to copy-and-paste repeat code. Composition over inheritance.
I believe that logic is wrong to treat `first` specially.
Ah. Yeah.
Is not treated specially, I needed some element to run the predicate with first, I could have also used `Array#sample` and it would have worked the same, but `Array#first`is just cheaper.
The only thing I hate about SimpleDelegator/DelegateClass is that Psych doesn't serialize them into the new class, but whatever the delegated class is. Sorry, just spent a day trying to force it to, but apparently Psych also ignores any hooks that are in DelegateClasses. They only way I found was to re-initialize it as the DelegateClass after loading. If Psych is built-in to ruby it should handle this without having to hack it together...
[FusionAuth.io](https://FusionAuth.io) could be an option as well - similar features but is even less expensive. Can even be free if you host it locally or in your cloud. Solid docs too.
I like using `SimpleDelegator` when scraping data to create page objects out of Nokogiri nodesets. It is a simple way to decorate data and add some context very quickly. Here's a tiny example snippet: class ResultsPage &lt; SimpleDelegator def listings css('li.product-item, [class*=product-listing-page__list-item]').map{|el| Listing.new el} end end class Listing &lt; SimpleDelegator def brand at('[class*=product__brand]').text.gsub(/ tire/i, '') end def model at('[class*=product-name]').css('&gt; text()').text end def url at('a[href*=buy-tires]')[:href] end # ... end results = ResultsPage.new(nokogiri_doc).listings # ... etc I like how easy it is to stand up a simple context-aware dsl with SimpleDelegator.
And they are not gems!
It's just not right, because `first` is still included in the array `any?` checks. Assuming it's meant to mean "more than one". [1,2,3].only_some? {|a| a == 1} # =&gt; true if `block.call(first)` is true then `any?(&amp;block)` will _always_ be true (because first being true satisfies the conditions of `any?`), there's no reason to ever need to test both.
ah i see now. clever!
Good info 👍
This method terminates at the first opportunity rather than trying to count everything. module Enumerable def some?(pattern = :itself.to_proc) inject(nil) do |t, item| match = !!(block_given? ? yield(item) : pattern === item) return true if match == t t.nil? ? !match : t end &amp;&amp; false end end It also supports patterns a la `any?` and has a default that just tests truthyness.
 def some?((h, *t)) t.any? { !yield(@1) == !!yield(h) } end
Why on earth would it make way into ActiveRecord?
I think it's not a goal of standard library to provide any method you can imagine. Instead, it gives you some sensible basics (or even more than basics in case of Ruby) and you can build upon them - just like you did. Some people mentioned before that they cannot see a use case for this. I can imagine some, but then again - it's easy to do on your own.
People frequently just instantly associate Ruby with Rails. And this subreddit has a long history of being very hostile towards non-rails world (dry-rb, hanami, sequel, rom) and I guess that many people from those projects just gave up on posting here.
(I have no interest in bitcoin etc) but the subset of ruby idea is fascinating
I guess so. Concurrency, pattern matching (in 2.7!), inferred (I guess) type checking, PITA MFA ON rubygems, keyword arguments, bring on 2020. So many meetings 😀
Very nice!
I still think it should be integrated into rubygems.org. Don't get me wrong, I understand reasons against it; keep the main API small; he may want to keep it separate, be motivated, hopefully receive monetary support and not be hindered by any bureaucracy and so on and so forth. But at the same time the other side of the medal is "user search", which is sort of the main idea behind the ruby toolbox, since you get to search for existing gems that way. And that feature should simply become a first class citizen for rubygems.org. There should also be an optional user-quality rating. Now, rating can be abused, so this needs lots of thoughts before it is implemented (I am thinking of a light weight variant a bit more like kde-apps.org; and perhaps a non-dev registration for rubygems.org too, for people who may wish to e. g. vote without wanting to publish any gems... ) - the idea would be that people could rate on projects ASIDE from downloads. Right now I don't really have an idea how good any given gem is. I can look at the downloads, and judging from that say that a project is good if lots of people use it - and to a large extent this is true. But there are gems that are just plumber-work enabling other gems, and in itself quite useless ... we could really need qualitative ranks. If you don't want negative ranks then grade things differently based on mean percentage upvotes only or something. So 100 votes lead to 50 points, 200 votes lead to 101 points and so on; so you get a slight qualitative ranking the more votes one has (but make sure the system isn't up for gambling through fake accounts).
We applied to the WhatsApp service with Twilio like 3 months ago, and what is clear to us is that Twilio (or WhatsApp AKA Facebook) doesn't care about small companies like us, we were commiting to a minimum use of $500 monthly and they haven't approved us yet. They ask you to have a Facebook business account even when you don't need that type of marketing, we still did it though but no response yet (and it seems they only consider the ones spending thousands and thousands of dollars there).
Cool!, I didn't know there was going to be support for pattern matching on method definition.
Nice. Question. I thought we wanted wasm for the client, but wanted transpilers in our favorite languages. Does this get us closer to that?
This extension doesn't compile Ruby to Wasm to run it anywhere. It's the opposite actually. It allows to execute Wasm binaries/modules inside Ruby: You can imagine a Rust/C/C++/AssemblyScript program, compiled to Wasm, that you can run inside your Ruby application. Does it answer your question?
Nope. I understand what this does. I’m asking if this gets us closer to that goal, of ruby -&gt; wasm.
The extension does not compile Ruby to Wasm. So I think it means for you that it doesn't get you closer to the “ruby -&gt; wasm” goal.
“Us”
Using WhatsApp for business purposes is very common in Brazil. Anywhere else?
Intriguing! So is wasm seen as a future way of having platform agnostic binaries on the server side? I, for one, thought its target was the client. Also, and again please excuse my ignorance, what is the performance profile of Rust code compiled to wasm run in Ruby? Does it run as fast as Rust or more like Ruby?
I’m sorry for your experience so far. WhatsApp are in charge of who they accept onto the platform right now, and hopefully that is something that will loosen up, but I have no insight on that myself. Best thing for you to do is check with your Twilio account manager to check on any progress.
WebAssembly has been designed to work on both client and server side. It's platform agnostic. &amp;#x200B; About performance, it depends of the backend of the VM. The \`wasmer\` library relies on the Wasmer runtime ([https://github.com/wasmerio/wasmer](https://github.com/wasmerio/wasmer)). The Wasmer runtime provides 3 backends: singlepass (fast to compile, slow to execute), Cranelift (correct balance between compilation and execution), LLVM (slow to compile, very fast to execute). With LLVM, we get native performance. Right now, the \`wasmer\` libraries uses the Cranelift backend of the Wasmer runtime. It's faster than Ruby, but slower than native code. In the future, we want to select what backends to use.
It’s pretty big in south east Asia too,
thanks for your work on this and taking the time to explain things so comprehensively. do you see us heading to a place where all languages can easily share a common set of wasm libraries (e.g. for data science)? pinch me, it sounds too good to be true.
Ahh this is so exciting. I'm currently learning a bit of Rust, and I plan to port a cli gem of mine over to Rust as a learning exercise and to make it more performant. I love the idea of running some rust/wasm in parallel of a ruby app on computation heavy tasks. This extension seems like it negates the need to use FFI? I'll be following this one for sure. Are there any areas where a Ruby dev &amp; Rust noob could contribute?
 That’s the ultimate goal yes :-).
It really depends. If you want to join an existing project you need to learn the language they are already using. If you are starting your own project you need to check it the libraries you need are available in the language of your choice. Ruby has many that you may need. Generally I think Ruby is a good choice because you wouldn’t be writing the core of the blockchain app anyway. That requires huge amount of knowledge and experience in specific fields like cryptography. You will likely be building some layers that rely on existing code that is maintained by others. For example you may create a casino in Ruby on Rails and you rely on existing libraries to provide the payment part in crypto.
I want to hear about those projects
Thank you for explaining, this is what I had at the back of my mind, however you’ve clarified it for me. I assume this is where the CS background comes in handy, when you’re trying to build the core chain rather than a DApp that’s just an extension of an existing one. Due to not having a technical background, would I benefit more from focusing on the building the layer on the existing code? Thanks.
Good to see ruby isn't giving up against its real nemesis (no, not python ... it's javascript).
May not be twilio's fault, but this is good info, thanks!
&gt; Twilio supports sending WhatsApp templated messages without requiring a change in how you use the Twilio Programmable Messaging API. &gt; In order to send a templated message, you include the full body of the message in the API call. Twilio will send the message as a templated message if it matches one of the approved templates. If the Body does not match a pre-registered template, the message will be sent as a freeform message, which may not deliver if it is outside a WhatsApp session (see below). This is a clever way to not require extension of the twilio API, which presumably doesn't have API for "templated messages", which whatsapp requires for unsolicited communication. However, it seems pretty error prone. I may intend my message body to match a template. If it does not, do I have any way to get indication that it did not, and my message may simply have been thrown into the wastebin? Is there any message sent confirmation?
I guess it has multiple goals, official and inofficial ones. My favourite inofficial one is to DIE, JAVASCRIPT, DIE! But there is evidently a lot more behind the idea of web assembly. The only problem here is that we depend on ... Rust. So we exchange javascript for ... Rust. That is not really a huge improvement. What happened to C and C++, anyway? Have they given up in the face of Rust? After all the Rustees still aim to rewrite everything in Rust.
Awesome! What about support for exposing Ruby functions to the WASM module? I noticed in the code of the extension, the instance is created with an empty imports object. Would it be possible in the future to pass, for example, a Ruby Hash of Procs to expose to the module?
Cross-compiling (source-to-source) from (secure) ruby to (javascript-like) solidity (and, than on to ethereum virtual stack-machine (evm) bytecode) should be possible. That's the plan for this summer (of code). Otherwise, of course, you can always run the "plain vanilla" and "yes, it's just ruby" code with ruby itself already today :-). PS: Bitcoin's contract language, that is, (Bitcoin) Script is pretty much useless for general programming / scripting - it's "stateless", that is, you can't store anything, has no loops and jumps, etc. and, thus, not a "compile target" for (secure) ruby.
Yes, it’s going to be possible. We are working on it :-)!
Superb work, Christoph! Thanks for all the hard work over the last DECADE 🎉
Congrats! Such a helpful tool! 🍻 here's to 10 more years 😄
Any luck solving this?
To get updates on the message status after you send it, you can subscribe to status callbacks. To do so, you need to pass a \`status\_callback\` URL along with the \`to\`, \`from\` and \`body\` parameters. When the message changes status, your URL will be requested with those details. I just tried this with a message that fails a template and the status callback URL was called with an "UNDELIVERED" event. In the console, I could see that it failed with a [63016 error](https://www.twilio.com/docs/api/errors/63016) because I didn't use a template outside of the session window. Ideally we would have stored templates that you could reference by an ID and just supply the parameters to avoid this potential issue, but as you say, we are extending the existing Twilio API for now.
Sorry, solving what?
Can we stop this? Microservices are a technical solution to a political problem, full stop. If you don't have the issue of disparate teams working on the same system, you have no reason to consider it.
Sure. Except when you actually have to redo stuff at a largish org, people fight you on it. You may understand why you would or wouldn’t consider it, but many people don’t, or need backup to socialize a more monolithic approach. It was a huge issue at our company when we embarked on our complete rewrite. I know companies that embarked on a uService approach only to have it totally fail and they all had much less traffic or reasons to even consider it. So, for some people the examples and how we did it will be very useful as they attempt to redo whatever legacy system they have. We have a lot of blog posts planned to explain our 2-3 yr journey to ci/cd, this was a crucial part of it.
wasm binaries can be compiled from any compilable language, so you could write your performant code in C# for anyone cares. I think there the wasmer is using Rust to execute the wasm binary, but we aren't obliged to write any Rust to execute it.
&gt; Sure. Except when you actually have to redo stuff at a largish org, people fight you on it. You may understand why you would or wouldn’t consider it, but many people don’t, or need backup to socialize a more monolithic approach. It was a huge issue at our company when we embarked on our complete rewrite. You literally just described 'a technical solution to a political problem'.
Yes. Only a handful of people know enough about crypto to work on the core. If you are ambitious enough to put in all the work you can be one of them, but the language is the least of your worries. Higher math is the tough part. Plus you need to fully understand what has already been done in the crypto space so you can build on top of existing knowledge. I think it’s a good idea to start with Ruby as it has a less steep learning curve and you will be able to do impressive things in a short time. Then, you can move on to less user friendly, compiled and fast languages like some version of C or Go, etc. It’s tough to start with C. Don’t do it.
Why do this? Jekyll and other static site generators already generate websites that are insanely fast and small. Why add a bunch of JavaScript for no good reason?
But you can't just take a monolith and cast a spell on it to break it into services. The approaches are utterly incompatible. A service architecture requires boundaries from the get go -- boundaries that _can_ be established within a single project, but generally _aren't_.
I'd argue that every successful micro service system I'm aware of started as a monolith, so I'm not really sure what you mean.
We have. We will talk about it in our “how” blog post. We have done work to make sure it’s not hard to separate into services. We also have some internal uServices, because we need a simple service with high throughout at about 10k reqs/sec.
Are your services autonomous?
Right. That’s why I started my post with “sure.” That’s a word that means I agree, but as someone that had to fight with a lot of people at our company about this, saying it’s just “political” describes the hardest parts. Having proof points, including a success story in a fairly large company, that’s public would of been helpful for me. So we hope to provide that to others.
To what extent do you mean? Our single uServices probably is, assuming i understand what you mean by autonomous. Our other services in the monolith aren’t completely. They are isolated to make it easy to extract them into a service when need be. We are eyeing one now and it’s going to be very simple. If you could describe a little of what you mean by autonomous, it would help me.
What I think you're missing is the 'why'. Monoliths are fairly optimal structures technically, the 'fairly' meaning there are technical reasons to break them into slightly smaller chunks depending on use cases. Microservices are purely political is nature. There is no good technical reason to break a system into _micro_ services. You only do this for political reasons. Your argument seems to be 'well yea, it works for us thus good'. My argument is, fix your politics and you just don't have this issue.
Fun? :-) I was also thinking of doing something similar - not for my regular blog, but I have another info site that's also built by a static site generator now, but each post's the same table that the generator makes from a json file plus some markdown. I was going to cut out the middleman and push the json files to get interpreted by the site on the fly... I could see a blog site working the same way. Loses some of the speed advantage the static site has, but fun, fun is also important. :-)
&gt; Fun? :-) &gt; &gt; That is a fair reason!
To learn? Understanding Jekyll's hooks can be a pain and the documentation isn't great. Understanding the history API in the browser is a useful skill. I was also impressed with how little JavaScript this actually took on the front end. And not a lot of Ruby to add the feature to Jekyll too. I guess I learned something too.
Correct. The source of the Wasm module does not really matter (except for the ABI, but WASI should be the standard on the long-term).
&gt; the problem is that they are too opinionated on which JavaScript framework they use Being opinionated isn’t a flaw, it’s a feature. That means developer effort can be focused. Different frameworks have different design philosophies and trying to support everything out of the box isn’t really a good idea.
This has been very informative, thank you for taking the time out to explain things in detail. I understand things a lot better!
Solid points. On a sidenote it's funny that your service bus project is called Wormhole, cause that's exactly the internal name of a project I'm working on - which is, you guessed it, an ETL pipeline to get data from various sources to data lake using Kafka and Akka Streams.
Problem is, you are highly likely to define incorrect boundaries between services if you are developing some kind of a new product that could evolve in unknown ways.
As did most unsuccessful ones, for sure. Monolithic vs microservice is simply an architectural question. A monolithic service is the architectural equivalent to a global variable or God Object. They're convenient, accessible, and all of the data you need is right there. But they habitually evolve into spaghetti code where the assumptions in one portion force non-obvious constraints in another, they make testing difficult and expensive because of lack of tight scoping, and so on. That's why they're antipatterns and code smells. And service architecture and software architecture are extremely analogous. Heck, I'm not sure I can draw a clear distinction...still working on that.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Ruby3 will have types](https://www.reddit.com/r/RubyLang/comments/bjtq0f/ruby3_will_have_types/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [React-style components written in Ruby, running on the client via WebAssembly](https://www.reddit.com/r/RubyLang/comments/bjtr7z/reactstyle_components_written_in_ruby_running_on/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
actually when referring to ordering constraints I was not considering background jobs. but rather in a queue across a system (e.g. rabbitMQ) in which you need to respect messaging order semantics when adding consumers.
What makes this better than just using erb?
It's hard to have a discussion around the qualifier "successful" since very few engineering teams measure waste. I'd argue 50 developers flailing about doing what _could_ be the work of 10 is not successful from an engineering perspective, even if the business is successful enough to float the engineering budget.
Ours is built with Kinesis. We did a bake off between it and Confluent (Kafka as a service), but decided staying in the AWS ecosystem made sense for us. For big data we use cloud break instead of EMR. A couple blog posts will delve into that. I called it Wormhole because you put stuff in one side and it pops out somewhere else. On the output side we use lambdas or Spark. We are a heavy user of lambda. ‪Dynamic Routing with AWS Lambda@Edge by Driven By Code https://link.medium.com/dzWzUQIymW‬ That’s a good example of just a portion of our lambda use. We have been slowly turning all of our batch jobs into streaming job. Wormhole will be our go to for events and real time processing. Inside our BE Rails monolith we use sidekick to async everything we can, but for passing lots of messages to other apps or the Internet, we use Wormhole.
Here is the wikipedia article for the Service Autonomy Principle: [Link](https://en.wikipedia.org/wiki/Service_autonomy_principle) Here's a really good article by Udi Dahan on the subject: [Link](http://udidahan.com/2006/01/08/autonomous-services-a-step-beyond-service-orientation/) As a rule, if you are expecting services to query data from other services, you are likely not building a service architecture at all; instead, you're building a distributed monolith. Services only query data from their own database, they do not use other services _as_ a database.
I don't find this to be true in practice. When I visit with clients and study their domain, the boundaries become evident with sufficient analysis. Probably the biggest impediment I've seen to discovering boundaries is programmers that want to plunge straight into programming without thinking things through. The usual rationale given is "hey, we can iterate on it later," but the underlying reason is usually that the programmers have more fun hacking on code than getting together in front of a white board. Of course, I'm painting with broad strokes, but I'm distilling my experiences :)
Ok, yes. Our single uService we have now is autonomous by that definition. The “services” inside our monolith are not, obviously, but if separated (like say our pricing engine) would be totally autonomous by this definition. Thanks for the second link! Good article. I had actually read through the first one before, but the second one I had not. And I agree...we would try very hard to not distribute our monolith if we went to uServices. But, at our scale using partitioning in Postgres 11, we may never need to break up our BE Monolith. But, some of our Apis get a lot more traffic than others, so some say it may make sense, but for now it’s performing well and is as simple as it can be even though it’s a complicated service. Our single uService called UVD is completely autonomous, shares nothing with other services/applications and is used by our data pipelines for real-time, fast VIN decoding.
&gt; And service architecture and software architecture are extremely analogous. Heck, I'm not sure I can draw a clear distinction...still working on that. SOA is an architectural _style_. Software architecture is the domain of irreversible decisions. They are quite different.
In case you can't use Statsd or similar (like in my case for some clients), a low-tech trick which can be used is to add a simple health-check HTTP endpoint to your Rails app (which I usually protect behind an authentication token), which you'll monitor using external tools like [https://updown.io](https://updown.io) for instance, and which will check the latency &amp; return 200 if OK, 500 if not OK. This allows to get alerts for background services. A way to implement that is to leverage the \[OkComputer gem\]([https://github.com/sportngin/okcomputer](https://github.com/sportngin/okcomputer)). It provides a built-in \[Sidekiq latency check\]([https://github.com/sportngin/okcomputer/blob/master/lib/ok\_computer/built\_in\_checks/sidekiq\_latency\_check.rb](https://github.com/sportngin/okcomputer/blob/master/lib/ok_computer/built_in_checks/sidekiq_latency_check.rb)). You can also implement custom checks (like the one below to verify the number of sidekiq processes): &amp;#x200B; \`\`\`ruby class CustomSidekiqCheck &lt; OkComputer::Check def check size = Sidekiq::ProcessSet.new.size if size == 1 mark\_message "ok" else mark\_failure mark\_message "#{size} process detected" end rescue =&gt; e mark\_failure mark\_message "An error occurred: '#{e.message}' (#{e.class})" end end \`\`\`
I can't answer the first part, but to the second part: &gt; I'm looking to pick up coding. while researching to choose a language, beginning to &gt; find there are just so many to pick from, hard to choose. at least with each having so &gt; much to offer it's reassuring that any you pick should be useful. &gt; I am however looking for a language easier to learn. I can explain a bit my background. I started to move away into Linux, from windows in ... 2003 or something like that. I first used perl. Later I used PHP. I don't remember when but I switched to ruby ... in 2005 or something along those lines. The question back then was between ruby and python. I picked ruby mostly because of this old interview, oddly enough: https://www.artima.com/intv/ruby.html It's still my favourite interview. :) (Excluding oldschool Alan Kay lectures). The philosophy is the biggest difference between ruby and python. I think python is a perfectly fine choice though; I use python as well. Ruby is better though. I could explain why but this is something everyone has to decide on his own really. I do NOT think that ruby is the simplest language to learn though. It is very, very consistent; and very elegant (unless you write like a clown) - but simple? Hmmm. Not sure. There are too many concepts, "more than one way" is great, as it gives you flexibility, but you have to decide what to use and what not to use. I also stopped wanting to learn functionality that I don't want to use, so ... Even then ruby is still great. You just focus on what is nice and ignore the rest. In other languages you don't have that. You sort of have to use whatever random shit has been pushed downwards. JavaScript is a wonderful example. A joke language but it is so successful due to how dominating the www is. The www is one of the biggest catalysts for programming language. You sort of HAVE to focus on the www in addition to other parts. If you have the time, I would actually recommend to you to use both ruby and JavaScript. You'd have more advantages both ways. I wrote quite a bit of javascript in total, in particular when I was using PHP, and for some simple ad-hoc logic, or jquery events (yes I still use jquery, despite people saying it is dead - it just works fine for my use cases and I have not found a SIMPLER alternative; and I am most definitely not investing hours into some random framework that behaves differently). Be warned though if you use ruby for some time and enjoy the subset that you may use, using javascript will be very difficult, since you'll just cant help but notice how this is an utter garbage language. Only PHP is worse really. Javascript is a 3 weeks designed joke of a "language" and the joke is on us. It IS, however had, a USEFUL language. You can write a lot of stuff and get away with doing things that are instantly useful to many people, due to the browser being so important (which, these days, translates into Google controlling what you do really, since it is a de-facto monopoly). As for game engines in general - I found them to be very, very hard. For some reason games are surprisingly difficult. There are lots of micro-decisions that one has to do, and that takes time. It's not impossible but in my opinion it requires a LOT of deliberate design and ideally you write down lots of design documents, and implement accordingly - that sounds annoying but it will help a LOT if you intend to make changes lateron. My early games sorta died mostly because I kept on changing them as I went ahead, until I ended up doing just a random, terrible mess. And didn't have enough motivation to resume once the motivation was down ... I still finished a gtk-minesweeper mini-clone. :P (It has a bug right now but it used to work just fine once ... actually minesweeper is a fairly simple game to implement; other games can be MUCH harder. In every case, the stricter you are about what to implement and what NOT to implement, the better. I once had seen someone doing at the least a prototype for settlers of catan in ruby-gtk ... it was great, but unfinished work, from someone else. I did not feel like continuing to invest more into that... by the way, we could really need more high-level game engines in ruby. We have gosu ... but not many more.)
If you are looking at Ruby for game development: The DragonRuby GTK is the newest, but also the most promising (imho): [https://dragonruby.itch.io/dragonruby-gtk](https://dragonruby.itch.io/dragonruby-gtk) Ruby2D is interesting: [http://www.ruby2d.com/](http://www.ruby2d.com/) Gosu is has been around the longest: [https://www.libgosu.org/](https://www.libgosu.org/) If you want to just experiment and get familiar with Ruby: Try it out: [https://ruby.github.io/TryRuby/](https://ruby.github.io/TryRuby/) Simple introduction: [https://pine.fm/LearnToProgram/](https://pine.fm/LearnToProgram/) Documentation: [https://ruby-doc.org/](https://ruby-doc.org/) Challenges to learn the fundamentals: [http://rubykoans.com/](http://rubykoans.com/) More advanced challenges: [https://exercism.io/tracks/ruby](https://exercism.io/tracks/ruby)
I don't think you're correct here but I strongly object to the downvotes you're getting.
So /u/duckst0rm /u/otakugrey /u/fucking_passwords what do you think now after what Nintendo has done and how the other various asshats have treated /u/amirrajan here now: https://www.eurogamer.net/articles/2019-04-29-nintendo-pulls-switch-indie-game-from-eshop-after-dev-reveals-he-sneaked-in-basic-code-editor-easter-egg Just look at the assholes who are cussing out Amir and doing this injustice to him for a creative effort? I think this really goes to help drive the situation home.
I’ve made a couple hobby games in Ruby, and I learned a ton. Both were roguelikes, one was a terminal game made with a Ruby binding for ncurses, one was made with Gosu. I probably learned a bit more about game dev, specifically roguelike dev, than I did about programming in general or Ruby language features, but I still think it’s a great exercise and a great way to get your toes wet with a language. Just don’t expect to produce a super performant game that you can package and sell on Steam.
In that spirit... def some? reduce(nil) do |m, o| val = yield(o) return true unless m == val or m.nil? val end return false end
Prometheus is my current go to. There's a ruby gem where you just tell it what to listen to, and it'll show it on a basic endpoint called `/metrics`. It can be consumed by anything you like that way, but there are handy plugins for things like grafana.
I think the main thing that has me hesitant on picking up ruby is the lack of 3d game engines. &amp;#x200B; thats why luxe caught my eye: [https://luxeengine.com/dev-log-5/](https://luxeengine.com/dev-log-5/) &gt;"It will take time for this to be available, but **it will be possible to use any language you want with luxe** via script system plugins. The API can be bound to other languages easily, and the workflow for that language can be idiomatic. If the language can be used via C API binding you're good to go. As a proof of concept, we've already played around with python, rust and haxe externs. &amp;#x200B; I also heard about Sol2 for lua, and was wondering if ruby could have its own equivalent to sol2. which would be a big undertaking right (not likely)?
We have something similar but the endpoints are unauthenticated since anybody looking at it will see nothing interesting. Then we have alerts setup with PagerDuty and slack and a few others so everyone in the world knows if something goes down.
I know this is old, but have a look at how [Chef does search](https://github.com/chef/chef/blob/master/lib/chef/knife/search.rb)
Or a little shorter (and mimicking the \`any?\` and \`all?\` behaviour without a block): class Array def some? reduce do |m, v| val = block_given? ? !!yield(v) : !!v return true if val ^ m val end false end end Some interesting benchmarks: class Array def some? reduce do |m, v| val = block_given? ? !!yield(v) : !!v return true if val ^ m val end false end def some2? reduce(nil) do |m, o| val = yield(o) return true unless m == val or m.nil? val end return false end end &gt; array = (1..1000000).map { rand(1000) } &gt; Benchmark.bmbm do |x| * x.report("some?") { array.some? &amp;:odd? } &gt; x.report("some2?") { array.some2? &amp;:odd? } &gt; x.report("any^all") { array.any?(&amp;:odd?) ^ array.all?(&amp;:odd?) } &gt; end Rehearsal ------------------------------------------- some? 0.000020 0.000004 0.000024 ( 0.000019) some2? 0.000018 0.000003 0.000021 ( 0.000018) any|all 0.000011 0.000003 0.000014 ( 0.000012) ---------------------------------- total: 0.000059sec user system total real some? 0.000012 0.000002 0.000014 ( 0.000010) some2? 0.000015 0.000002 0.000017 ( 0.000014) any^all 0.000012 0.000002 0.000014 ( 0.000008) &gt; array2 = (1..1000000).map { rand(1000) * 2 } + [999] &gt; Benchmark.bmbm do |x| * x.report("some?") { array2.some? &amp;:odd? } &gt; x.report("some2?") { array2.some2? &amp;:odd? } &gt; x.report("any^all") { array2.any?(&amp;:odd?) ^ array2.all?(&amp;:odd?) } &gt; end Rehearsal ------------------------------------------- some? 0.000028 0.000005 0.000033 ( 0.000027) some2? 0.104508 0.000452 0.104960 ( 0.105575) any^all 0.032254 0.000041 0.032295 ( 0.032372) ---------------------------------- total: 0.137288sec user system total real some? 0.000016 0.000002 0.000018 ( 0.000014) some2? 0.095715 0.000238 0.095953 ( 0.096274) any^all 0.031930 0.000044 0.031974 ( 0.032027) I understand why the random one is faster for any and for all, since they both short circuit early. I have no idea why my method is that much faster in the nonrandom case. I think the conclusion here is to just use any? \^ all? unless you know that some? will be true with very low probability (i.e. very probably all true or very probably all false).
"If the language can be used via C API binding you're good to go." &amp;#x200B; So Ruby *could* work, but I don't know if anyone is actively coding on it. &amp;#x200B; This may interest you: [https://github.com/ffi/ffi](https://github.com/ffi/ffi)
thanks, looks like it creates a query string, then sends a API request with that: [https://github.com/chef/chef/blob/master/lib/chef/search/query.rb#L160](https://github.com/chef/chef/blob/master/lib/chef/search/query.rb#L160) then I'm not sure how that search query is handled
Ah, that's all Solr search (or elastic).
and this belongs in r/ruby because?
NSSAF (Nova Scotia athletics federation) has deemed rugby to dangerous. High school will no longer have teams. The link above is a petition trying to get rugby back. Theres also a movement where you can send emails to nssaf@gnspes.ca explaining why rugby is important to you and why it should be played at a high school level ect. Personally my team is in shambles. We where looking forward to play in the playoffs but it was cut short due to this. I know the rugby community is tight as well as the reddit community. Im not personally A big Reddit guy my self but I’ll try to be active and keep info coming. Any questions I will answer. If anyone can help please sign the petition and send emails. Thank you rugby players all around the world.
Wrong sub, my dude
F
Thanks! I just checked, doesn't look like it. I will share it with the author (my co-worker).
Thanks. I did not, this is the brain-child of my co-worker [Michael](https://github.com/thebadmonkeydev).
My personal perspective on this is that you shouldn't have more micro services than you have distinct teams. If you have 100 plus developers, it's reasonable to build a micro service based architecture. If you have 20-30 a tossup in my mind If you have 12 it probably isn't worth it If you have 5 it definitely isn't worth it
_"What happens when I type a URL in my web browser and hit enter?"_ is my favourite interview question. If someone describes themselves as "full-stack", you can find out just how full they mean with this question, but that's just the half of it. By being so open-ended, it's revealing about the candidate's proficiency, experience, instincts, and interests. I've received answers that took an hour and a whiteboard and described anything from the UI interaction to the ASICs in the routers, the routing of microservice requests, the politics of domain registration, the economics of cloud computing. Sometimes I even learn something.
I respectfully desagree, I think that this question is good for assessing the level of seniority, not how "full-stack" someone is. Maybe I have a wrong conception about the meaning of "full-stack".
&gt;You may not know this, but the [Sidekiq](https://sidekiq.org/) web UI is written in Sinatra, so you may already have a Sinatra app running inside your Rails app! Actually, sidekiq web has been a pure rack app for years now.
My usual quip is that "you're not full stack unless you're smelting your own copper", which is intended to challenge the commonly held notion that full-stack means JS+HTML+CSS, at least one server-side language, and SQL. But no, I don't think it relates to seniority. My own answer to this question was an extended interdisciplinary deep dive even when I was still a very junior engineer in the mid-nineties, and it was because I'd been building ISPs from scratch for a year, including everything from website design to patching &amp; tuning _innd_ to debugging a faulty E1 line with an oscilloscope. It's still the interviewer's responsibility to give the candidate space to express their strengths, interests, experience, preferences. So I'll still guide the discussion, but that's my favourite open-ended starter.
You can run a custom script via: rails runner myscript.rb myargument Though it should suffice to use require 'config/environment' In your script directly (if said script is located in Rails.root)
Kids (say, under-40s) these days don't feel the need to understand the world in that level of detail when they can delegate to "trusted" bits of tech. Then they're completely at sea when those trusted bits fail, for whatever reason; often to the point of not being able to identify exactly *which* artefact was the root cause. "Just replace it" is fine, if you're sure you're solving the right problem. I've been developing software for 40 years now and, for the first half of that, what today counts as a fairly deep understanding of the hardware side of things was a practical necessity. As I get older and more pressed for time, I find myself enjoying those deep dives into the details less and less. But if you don't know that they're *there,* and be able to refresh familiarity with them quickly enough to diagnose an existing failure, you've ceded control of your task/project/career to the whims of fate or, often worse, some random vendor.
Get a job where you use Ruby every day.
Expert is a very strong word. This means that you know C and are familiar with Ruby's internals.
Build something. Then something else. Then something else. A job is the best way to do this but it’s not the only way. Like everything, it takes time, practice and exposure to the right lessons.
Yup that’s where I want to land myself, ideally. Is it necessary to know all of the C stuff or good enough to know how ruby is compiled? Like YARV and how the stack based system works or do I need to totally understand C?
Unfortunately Ruby isn’t that common here.. I am actively participating in meetups and am going to be a speaker in one next month, but it doesn’t feel like I’m doing enough
Who do YOU consider a Ruby expert? What do they know/do that you don't/can't?
thanks! all examples of runner I had found passed the string of a code path (inside the rails app), but if I can pass the filename that would work well, I think.
Updated with a link to your Sidekiq PR!
pick a open source project and help out.
I think it depends on what you mean with the word "expert". For example, am I an expert in ruby? I don't think so, for several reasons. "The reasonable man man adapts himself to the world: the unreasonable one persists in trying to adapt the world to himself. Therefore all progress depends on the unreasonable man.” - this quote is attributed to George Bernard Shaw but perhaps others said it before him. Anyway ... I am unreasonable but also lazy so I only use a subset of ruby. In fact, I can not even explain to you how lots of the new additions/changes in ruby work, in particular when I dislike the syntax. But even aside of that, there is a lot of ruby I deliberately don't use. I only focus on the subset. In my opinion the number 1 strategy that beats ALL OTHER STATEGIES is to really really really really write a LOT of code yourself. It does not matter what quality it has, you will learn as you go and pick up idioms. Try to solve things that are some problem anywhere... does not matter where, your own problems, problems by friends/relatives or in job-related affairs. (Since I am quite selfish, I started solving my own needs, which actually worked best; though I also solve problems by relatives... for example lately I extended a lot of my ruby code with www-sinatra routes, simply to get the functionality available via a www interface as well, so that other non-computer users can easily use stuff in the browser. I'd wish we could use ruby completely without any javascript too ...) So practice beats everything. That leaves obtaining new information. Here I can recommend to read lots of blogs. Many of them contain awesome information. StackOverflow is also ok ... you can learn too by answering, but SO has some problems so ... be wary. I stopped using SO actively in the sense of no longer asking any questions myself. I do however had still read SO and sometimes comment, but only sporadically. In the long run I think you should also consider combining ruby with a faster language ... does not matter which one. C and C++ would be obvious choices (and IMO, C is still the ultimate king), but Java is fine too and Rust may be ok, despite having such a horrible syntax and a fanatical user base). Crystal may also be fine but it is not ruby, only very similar. I hate type systems in general when they become mandatory, they ALWAYS lead up to making the syntax shittier. I also recommend to you to publish gems early and often. You don't have to go excessive here ... for example, I once had almost 130 gems published. I am now down to 80 or so and still trying to cut it (so that I can mostly focus on fewer gems, that are a bit larger and thus hopefuly a bit more useful; I even had minigems published but I feel that minigems are only useful for really important core functionality. The larger gems are often better, also for learning.) But the number one advice from me is really ti write a LOT of code. It's by far the best way to learn and the most useful too, since the code can hopefully solve existing problems.
Thank you for the lengthy reply! How do you find inspiration for gem publishing? Is it okay to publish gems that reinvent the wheel just to get experience?
Don't worry about C. For a long while.
That makes senee, I like that definition. It's also a good indicator that I still have a lot to learn.
&gt; ActiveRecord I think you mean ActiveSupport
You could also write that last line as: matches.between?(1, total - 1) And potentially even further generalise the method, like: def only_some?(min_true: 1, min_false: 1) # The same implementation you wrote... matches.between?(min_true, total - min_false) end
Anyone actually using Skylight in production? It seems everyone has settle on either NewRelic, or Scout.
To be honest, if you want to go the C route, then you should learn C properly and completely. I tried to go by with only knowing ruby but that does not work well when it comes to C, even though the ruby API is quite logical. When it comes to pointers, I am a goner, so there is really really no way around C IF you go that route (and it's a good route, C is the king, even though ruby is better than C). The fact looking at how much is written in C should show why. But you wrote a ruby expert, so I am not sure why you include C knowledge. You don't have unlimited time available so it may be best to just focus on ruby for the time being, something realistic, 6 - 24 months or so, write a LOT, and if you think you need to extend into C, go write a lot of C (but it is quite hard, requires more thinking than ruby does).
Becoming an expert kinda requires you to put in the hours. So using it every day as part of work is the most natural way to gain those skills. Meetups are cool. But you need someone above your level to actively ask for help. Having experts around me really accelerated my skills.
There you go, crickets.
I'm not so interested in the exact definition of "Full Stack" but I do think that a proficiency consisting of "JS + HTML + CSS + ServerSide + SQL" is an important distinction as someone with all of those skills could build an application from scratch.
&gt; Ruby isn’t that common here Where is here? Also, I work in Ruby professionally and know of several other Ruby companies in my area, and there isn't even enough interest to have meetups. If you've got meetups, odds are Ruby is plenty popular where you are.
not only at sea, but they seem to gloss over that \_every\_ design decision (including those design decisions you are tossing over the wall to those "trusted bits") is inherently full of tradeoffs and compromises. It is almost impossible to conceptually understand the system without understanding the tradeoffs made.
Kinda piggy backing on others here. But the common saying to becoming an expert in any technical specific skill usually takes 10,000 hours worth of experience and engagement (Roughly 1.5 year's of active skill development). One can easily become good and proficient in a shorter amount of time. But expert level just takes time and pertinence.
I like this question, but only because I spent 6 years as an embedded software engineer. I refer to myself as full-stack but I always qualify the statement with my embedded experience. Also, obligatory [what-happens-when](https://github.com/alex/what-happens-when) link.
Props and +1 for the effort listing. Seems to be euro-centric, though.
That's just this month in May. Last month in April the listing includes / reads: - Thu+Fri Apr/4+5 (2d) - Rubyhack @ Salt Lake City, Utah, United States - Fri-Mon Apr/5-8 (4d) - Rails Camp (United States) South @ Bandera, Texas, United States - Thu-Sat Apr/18-20 (3d) - RubyKaigi @ Fukuoka, Japan - Tue-Thu Apr/30-May/2 (3d) - RailsConf (United States) @ Minneapolis, Minnesota, United States
Added support for this (and a few other serialization methods) in [v1.2.0](https://github.com/eonu/arx/releases/tag/v1.2.0)!
Thank you! :D
That ui is a mess, it needs to be greatly simplified. I've had to build a small ruby app recently to this too, connect to an FTP, full the data, upload to S3 then eventually upload to redshift tables. Such a pain in the arse having to deal with FTP again. Luckily it's a very tiny microservice that once fully built can just be left alone to do it's own thing.
``` require 'config/environment' # =&gt; cannot load such file -- config/environment require_relative "config/environment" # works ```
&gt; once fully built can just be left alone to do it's own thing. I've heard that before!
Yes it is!
True, especially when working with archaic technology like FTP.
"Ruby under a Microscope" by Pat Shaughnessy gets into all that. For more high level stuff I recommend "Eloquent Ruby" by Russ Olsen and "Confident Ruby" by Avdi Grimm. [Ruby Tapas](www.rubytapas.com) is a really useful site. It's a subscription service but there are some free episodes. My job pays for it.
Is this just for active record? Typically I would just just `-&gt;(id) { User.find(id) }`
yeah this was probably a bad example as in my case the keys are strings and the blocks are network requests
&gt; def only_some?(min_true: 1, min_false: 1) &gt; # your implementation… That's twice as long as my implementation, it's harder to read, and it only outperforms on long collections where the false-result value comes near the front. [This benchmark](https://gist.github.com/drbrain/29308a1e0c2928f4f9534ef02229f8ef) makes your implementation look good if when the data works for it, but is 15-20% slower for the pessimistic case and a wash for random data. I'm extra dubious about this "optimization" when you added the options for overriding `min_true` and `min_false` as at best your implementation is four times slower all? on random data (see linked benchmark above). PS: Enumerables may not be repeatable so your #none? example will not work for all objects you can enumerate as it attempts to enumerate the list twice, when determining the `min_false` value via #count and again when determining how many items match the block via `yield`.
Wow, nothing personal but what a Frankenstein of an environment.
https://github.com/taskrabbit/forklift
Which we then rebuilt in node https://github.com/taskrabbit/empujar
There are plenty of SAAS' that do this. Here's one https://www.xplenty.com
Build stuff. What have you made using ruby so far?
there are over 10000 gems at the moment for ruby, Totally make them for whatever. Its fun practice.
I feel like pearl should also be included. Ruby and Pearl have a lot in common.
Not much to be honest, as I’m a Ruby on Rails developer so most of it are basically modules and concerns.. I’d like to start building more stuff. I did take part in a PR for Rails 6 so that was nice
Here is Singapore. I guess when I say not as common I’m comparing it to java/php/python/JavaScript. The meetups we have are pretty small, about 20
I guess I need to discover more on the inner workings.. tenderlove and the people in the Rails team comes to mind when I think of a Ruby expert!
Thanks! I have the Eloquent Ruby book and almost done with it. I’ll look into Confident Ruby soon! And then once I’m confident enough I’ll try the first one.
Thanks for taking the time to write this up. I share your pain, I work for one of the few companies that manage tire and wheel fitment data, so I'm familiar with the dance you're jigging. (On the upside, that's what allows or companies to be successful!) Reading through your introduction post felt like I was reading about an alternate dimension version of our company. Our company was rooted in .net exclusively until recently. So, we have an unsavory amount of random single purpose .exes written ages ago that handle csv/ftp/db things. I started learning Ruby a few years ago to help with some data projects, and it really slays for this kind of stuff! I've recently been building out some ideas using Kiba, and have really enjoyed it's declarative approach. It feels similar to what you've worked on, but without the web interface.
&gt; That's twice as long as my implementation, it's harder to read Fair comments. I only wrote this as suggestions for extension, not because "my way is objectively better". There's certainly some tradeoff; I don't think my method is *that* long or ugly. &gt; it only outperforms on long collections where the false-result value comes near the front Yes, but that could be very significant in some circumstances. Like, pretty much any **big** enumerable object. And your benchmark misses the point, so its result doesn't really interest me... I'm **not** actually suggesting this as a better replacement for `all?`; I'm saying the methods "functionally equivalent" (but will clearly not match performance of a method compiled in C!). You're right about the edge case behavioural difference where the enumerable is empty, though. &gt; 15-20% slower for the pessimistic case and a wash for random data I'd suggest benchmarking with a big array of actual random data, not just micro-benchmarking on tiny arrays. What happens for `Array.new(1_000_000) { rand &gt; 0.5 }` (and you can also try playing with that `0.5` value)?
I've done quite a bit using Kiba: https://github.com/thbar/kiba The developer is quite helpful in responding to queries as well.
Shouldn't it be `~/filename` ?
This is documented behaviour. &gt; The given pathname may start with a “~'', which expands to the process owner's home directory (the environment variable HOME must be set correctly). “~user'' expands to the named user's home directory. You are asking for the home directory of the user *filename* You can work around by explicitly specifying the current directory. `File.expand_path("./~filename")`
No, I said that the filename starts with a tilde. "\~/filename" means that "filename" is in the home directory. It does not start with a tilde. uTorrent creates a dat file starting with a tilde. `~uTorrentPartFile_17D0BCB92.dat` &amp;#x200B; If I do `File.exist?("~uTorrentPartFile_17D0BCB92.dat")` that works fine, but the `File.expand_path` with the same name says the file does not exist. &amp;#x200B; As I understand it, `File.expand_path` should only replace the tilde with HOME dir if the file starts with `"~/"` not just a tilde.
Dude, and all others downvoting him, wtf is up with you?? /u/fsoawesome just expressed his opinion about a piece of hardware and company behind it... How in hell has this not to be considered a legitimate comment in an open source programming language discussion forum thread ??? Why a sentence like "Github is shit because it was acquired by Microsoft" is ok and this is wrong? Are you all hysterical kids or what? And look what happened just some days ago... Nintendo has removed /u/amirrajan's game (with the embedded ruby interpreter) from the Nintendo store, because they suggested /u/amirrajan's code would open security holes in their console, which is totally false as it was running in a sandboxed space with some essential ruby keywords disabled (like require). Most importantly /u/amirrajan's work was done only with the purpose of delivering a tool that kids could discover to start getting in love with programming. So yeah /u/fsoawesome's comment is (and was) perfectly on the point, rather than inopportune!
Have you considered using [Airflow](https://airflow.apache.org/) ? We were successfully using it for rather complex scenarios when we had hybrid Hadoop installation - some stuff was running on premises and some in AWS EMR.
I remember having had a similar problem once; it was when the environment did not know the home path to the user, so ~ would fail with some exception. What I did was build up the target string prior to check it via File.exist?, and I would also rescue the exception. Nto super-elegant but it worked. You should be able to do the same. I guess the more important part is to find out why the command fails in your particular setup - I am pretty sure you must be doing something special, because it will most likely work in irb. (I use Linux though, not Mac OSX).
I understand that now, I tried to escape it as well like File.expand_path("\~filename") I think it is a bug that should report on https://bugs.ruby-lang.org/issues/ and see what the maintainers say.
It failed in irb also. One can do: touch '~abc' irb File.exist?("~abc") File.expand_path("~abc")
I think in my situation I would have to workaround as follows: If file starts\_with "\~/" then do File.expand\_path, else File.join(Dir.pwd, filename) Thanks a lot.
You have not read the official documentation then: https://ruby-doc.org/core/File.html#method-c-expand_path Quote: &gt; The given pathname may start with a “~'', which expands &gt; to the process owner's home directory (the environment &gt; variable HOME must be set correctly). You could argue that this would be incorrect (but I doubt it and I guess people may disagree with you here), but either way you could always file at the bug tracker if you would like to see this behaviour changed. As for right now, the behaviour is documented in the documentation, so it is not a bug - it is behaviour as specified currently.
I don’t think it’s a bug. The function is for paths and under unix means home dir of user named filename. How is the function supposed to know it’s supposed to be a file?
I think it is a bug to assume that ~ isn't valid in filenames and should be treated as such.
Well i assume if there would be a user called filename the function would properly return something like /home/filename But there obviously isn’t.
Yeah, if it were the bash shell itself that would work. However, to get that actual string in ruby, you need to understand how ruby string literal escapes work. "\~" is actually the same as "~", because the backslash can be used in front of any character to mean "that character" in a double quoted string. So you actually need to use single-quotes: `'\~foo'`. Or Double quotes with _two_ backslashes: `"\\~foo"` I think you'll find that either of these work for you: File.expand_path("\\~filename") File.expand_path('\~filename') This is all consistent with how the shell works with special interpretation of `~`. And with how ruby string literal works -- yes, ruby string literals get confusing when you need a literal `\` because of the escaping rules. (At some point, just about any escaping rules will get confusing one way or another).
PERL - Practical Extraction and Reporting Language
Back then my problem was I wanted to like it but I couldn't because of the complex English vocabulary that the book used... With regards to my English skills in a scale from 1 to 10 I could rate myself at 7 at the time, yet I clearly remember I was getting stuck every 2 sentences and since everyone was so hyped about it it was really frustrating not being able to read it... Kind of pissed me off that it was aimed at beginners... I mean, in many cases beginners are also beginning their journey into the English language as they are learning their first programming language... So I found it a bit unfair to those of us that the book was written like that... Anyway book apart, Why has been such a great contributor to Ruby's world that I can only admire him! Just wanted to finally let out this old times unexpressed rant ;)
I can't get, why do we need this? we can use implicit conversion if we really need some type. for example: "hello".to_str =&gt; "hello" Time.now.to_str =&gt; NoMethodError (undefined method `to_str')
With the exact code you've provided, B::A.new.mymeth Which will be the exact same thing as: M::A.new.mymeth I don't think the code you wrote is doing what you want it to do though. What are you trying to do?
Or M as is, but class B include M::A end Module mix-in with "include" is basically a form of multiple inheritance.
We did. We also had a hybrid (Hadoop in the DC and EMR in AWS) situation for a while. We ultimately dropped EMR and use Cloudbreak in AWS. Ill have to get the details on why we chose not to use it. We had Talend for a while, but that was just an unwieldy nightmare of writing xml! I’ll find out the details on why we ended up not using airflow.
Can you elaborate? Interested in how Rails coupled to bundler
Why would you process one million objects in ruby instead of dumping them in an indexed data store?
&gt; Is it necessary to know all of the C stuff or good enough to know how ruby is compiled? If you're a Ruby expert, you know both. &gt; Like YARV and how the stack based system works or do I need to totally understand C? If you want to work on Ruby internals, then yes. For Ruby in general, I'd start here reading the Files section: https://ruby-doc.org/core-2.6.3/ And refer back to this page when working with a Module or Object interface you need to know.
Don't know what ETL is? From the article: &gt; When developers encountered a new data movement need or “extract, transform, load” (ETL) challenge, they would often create a new tool for the job.
If you try to boot rails without bundler installed, it will fail. It actually references the Bundler constant.
&gt;This falls under the “at first it seems immoral to do this, but the more I do it, the more I feel this is how the world should be” category. I think that initial gut instinct is worth listening to. Why is the shorthand syntax better? You save two characters, but at the cost of potentially confusing readers who aren't familiar with this syntax. I'd argue that the cost of the latter is much higher.
Awesome, thank you.
&gt; potentially confusing readers That's a valid use case. Now I know who really looks at my code reviews.
yup we built this in house so we could stop paying for SAAS's, which were extremely expensive at the volume of data we were working with.
Oh neat! I was the lead developer on this :D (Former Truecar employee)
This is useful, but it's only half-ish of what we built - Armatron is also the user interface for managing these jobs, the logging tool, and the credential manager.
Why would you care about a 20% performance drop when benchmarking operations on tiny arrays? All performance tests have their flaws (i.e. they are constrained to what *exactly* is being tested), but I find yours particularly moot. Besides, if performance is really critical then the code should be written as a native C extension.
Yeah this is the sort of thing that causes trouble in a team of diverse skill levels. I'd rather see `?"` or `&amp;&amp;=` in a codebase than this.
No. Don't do this.
I didn't even understand the description for the longest time. Glancing over the syntax, I thought it was an article about the `Hash[key: :value]` syntax.
My "favorite" evil Ruby: &gt;str = % &gt;this is a quoted string that ends on linefeed &gt; Yes, whitespace used as the quote character. It's particularly evil, because if you instead of the assignment puts anything on the left hand of the "%" that allows the '%' to be parsed as the infix '%' operator (even if nonsensical), it changes the meaning of the following line. &gt; p % &gt; this is not a quoted string that ends on a linefeed &gt; And by "favorite", I mean "if a coworker does this, I'll throw stuff at them until they stop". `?"` or `&amp;&amp;=` is mere minor villainy in comparison.
I've always been a fan of the h = Hash[col.map{|el| [el[:some_key], el[:another_key]] }] syntax but have had coworkers yell at me for it.
build a small thing then! do it only in ruby and start small. make an interactive like question program or something.
Hah! Yeah, I can totally understand their concerns. It's a bit dense.
&gt; I think that initial gut instinct is worth listening to. Why is the shorthand syntax better? You save two characters, but at the cost of potentially confusing readers who aren't familiar with this syntax. I'd argue that the cost of the latter is much higher. So basically a lot of Ruby shorthand.
hol up
This is evil.
&gt; a blockchain developer WTF is that even supposed to mean?
Blog series: Things not to do in Ruby.
Is it me or it’s not really possible to read this on mobile?
It’s not just for you.
I think a guiding principle that is helpful to determine if a style is great or questionable, is whether you can stick with it consistently. The problem with that syntax (besides being uncommon and confusing), is that you can't use it beyond a single element, which is not a majority usecase of array. When you have a situation where a certain style is usable only in a small subsets of cases, and carries no great upside, leaving it out for consistency is usually better. Also, annoying git diffs whenever someone wants to add to your array and now need to introduce curlies.
Finally not based on Stack Overflow questions, which just proves the others languages are more complicated - and not in a good way.
Takes your team from oops to unreadable.
This is based on the number of repos on GitHub, which is a pretty useless metric.
Wtf is wrong with your site? Mobile browsing is a thing since before your subject matter.
It is still massively flawed. Not everyone is active on MS GitHub. It also is a difference if there is a repository with 1k in size as opposed to 100k. People often correctly point out how useless TIOBE's metric is - but the metric used by other websites is just as lousy. The amount of really useful information that can be extracted from it is very low; mostly you can only find some general estimate indicative of how popular a language MIGHT be. But it's a very weak association to be made. In my first 4 years of ruby or so, you'd assume that I would have written zero code because I published just about nothing. Which metric analyses that information part?
Yup. To be fair - just about all the metrics are quite useless in general. They can only be vaguely indicative of some aspects of any global subpopulation at hand. People will naturally take these values and base a lot of their decisions on it, though.
lol https://i.imgur.com/SjK2goe.png
It is the new user experience we have been learning about.
https://outline.com/sdGTyb
I discovered this a while ago and put it into actual use in dry-validation. Now it lives in [dry-schema](https://github.com/dry-rb/dry-schema/blob/3c4cc7a027afe33283c7e0cf92d5c59c1c83f7d7/lib/dry/schema/predicate.rb#L58-L68): ``` # Negate a predicate # # @example # required(:name).value(:string) { !empty? } # # @return [Negation] # # @api public def ! Negation.new(self) end ``` I find this posibility to be pretty damn cool.
[AngryRaise](https://github.com/sshaw/angry_raise) uses this. For example: raise!!!! "an error occured" raise!!!!!!!!! "an error occured" raise!!!!!!!!!!!!!! "an error occured" etc...
Hey, sshaw\_, just a quick heads-up: **occured** is actually spelled **occurred**. You can remember it by **two cs, two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Looking fine now.
delete
It was impossible, sorry! I fixed it this morning.
I fixed it, sorry!
give i1 and i2 as arrays i1a=i1.split(‘’).uniq i2a=i2.split(‘’).uniq return ((i1a | i2a) - (i1a &amp; i2a)).length
`#prime?` is already available as a method on class `Integer` in the Ruby core library. Use this for testing if a number is prime. `5.prime? # =&gt; true` The `Prime` class is more useful for generating prime numbers. `Prime.first 5 # =&gt; [2, 3, 5, 7, 11]`
`!@` apparently works as well. And it's more consistent with other unary methods like `-@` and `+@`.
For a naïve implementation, I'd reformulate the problem as "how many differences are there for each pair of characters"? Then, to get a list of character pairs, split the strings into characters: a = "ABCDEFG".chars b = "ABCXEOG".chars and combine them into a list of pairs: list = a.zip(b) Finally, sum up differences (folding the sum over the list and add 1 when the pair differs): diff = list.inject(0) {|sum, (x, y)| sum + (x==y ? 0 : 1) } The method version would look something like this: def diff(a, b) a.chars.zip(b.chars).inject(0) {|sum,(x,y)| sum + (x==y ? 0 : 1) } end That implementation will however create a bunch of arrays (of size `a.length + b.length`), which are immediately discarded. To remedy memory usage and GC pressure on larger strings, I'd refactor this into something like this: def diff(a, b) a.each_char.with_index.inject(0) {|sum, (c, i)| sum + (b[i] == c ? 0 : 1) } end Note that both implementations don't handle strings of different lengths. You could ensure for argument `a` to be the longer string of the two, but *why* that is, I'll leave as an exercise :-)
I will do like this. def compare_string(a,b) return 0 if a == b val = (a.size - b.size).abs [a.size, b.size].min.times do |i| val += 1 if a[i] != b[i] end val end
Why am I getting this error when I try and run that code then? https://i.imgur.com/QnmbP33.png
You may be using an older version of ruby? I believe `Integer#prime?` was introduced in version 1.9
oh. Interesting... so I don't have to Monkey Patch it manually at least. Seems they just included that same snippet of code I wrote in Prime rather than have Integer require it and just call it from there. Though all that really does is let me skip a few characters of code. Now I'm more interested in why the community chooses to have the language need Prime to be required, rather than have it done automatically? Wouldn't that be a more elegant solution? Maybe there are optimization issues if you end up having to load up the entire set of prime numbers into the memory every time the integer class is called? If that's the case, I wonder if there's a way to avoid it... TBH I also feel like my head is trying to think in concepts that are so far ahead of where my actual programming skill is, that I might be way off base/not making sense/literally talking out of my ass
I'm getting out of my depth here, but I *believe* the rationale is that Ruby core is entirely written in C, whereas the Standard Library leverages that core to provide extra functionality, but is written in Ruby. As the implementation of `Integer#prime?` is Ruby, rather than C, it gets dropped to std lib. As you already surmised, std lib functionality needs to be explicitly required for performance reasons. You can think of it as a *convenience method* provided by the `Prime` library. This concept will become familiar and you may soon find yourself writing your own convenience methods. Hopefully some professional programmers will throw some meat on those bones after the weekend. Sounds like an interesting discussion for your bootcamp. Good luck, I'm quite jealous.
While I would be interested in principle, it always depends on a chicken-egg (aka time) problem. Most of the time that I invest into ruby goes into commandline-related stuff; and then after that, either/and ruby-gtk and sinatra (for the most part). I think the biggest problem in regards to game engines is that they are written in C and/or C++ usually, and when you don't really know either of these languages very well then you are at a dead end (with/in ruby). Ideally if it were possible to do everything in ruby itself then this would be great, without having to be a C/C++ expert. But since that is not likely to change, I think it will continue to remain a chicken/egg problem.
Thank you very much! Can you clarify the following: I understand what line 2 is doing, but can you go further and explain what .abs is doing? Also, on line 4, I see that you are running a loop and that it's iterating through the strings, but what is .min? Can you tell me what .min does? Thank you again.
``` a = "ABCDEFG".chars b = "ABCXEOG".chars a.select {|char| !b.include?(char)}.count ```
Yet another way: &amp;#x200B; `def diff(a, b)` `(a.chars | b.chars).length - a.length` `end` &amp;#x200B; `diff("ABCDEFG", "ABCXEOG")` `=&gt; 2` &amp;#x200B; `diff("ABCDEFG", "ABCDEFG")` `=&gt; 0`
Something like this was my original thought as well, but it will actually return double the total you want in this case, because it returns all the letters that are different from both arrays, not just from one array. You could do ``` a = "ABCDEFG".chars b = "ABCXEOG".chars (a - b | b - a).length / 2 ``` if there are alway two arrays of the same length. Or it's a great solution if you just want to actually know the difference between two arrays. Also `a &amp; b` if you want to know what's the same
The reason it's not included by default is because it's not used often. I've never used it once in 14 years of Ruby programming.
I mean, sure, interested. However, this seems like a a 'If there's interest, we might do something, beg us.' Which, no thanks. Do let me know if and when there's anything to investigate.
there is mittsu
google "mittsu github"
&gt; mittsu github https://github.com/jellymann/mittsu It has a cute tank game.
I want it.
nice meeting you at Railsconf mr. devoops :)
 x.=(10) x = 10 Now _that_ was surprising...
What is surprising about that?
I'm really glad that there are other sane folk around who aren't just part of the herd. We're in a bad state right now as far as tech is going and it's just getting worse as is evidenced here. Has anyone taken a moment out to look at statistics? Look at this stat of Wii vs PS3 vs Xbox 360 sales: https://i.ibb.co/w0D6TKg/consoles.png Now consider this: https://www.ibtimes.com/nintendo-switch-will-sell-40-million-units-end-2020-according-dfc-intelligence-2479279 Just let that simmer for a minute. We must ask ourselves a few questions here, but I'll just focus on one point. Instead of trying to compete (unsuccessfully) with mobile phones with a dead end platform (yes Switch, I'm looking at you), why couldn't they build on a platform that everyone loved? They had amazing success with the Wii. They screwed the pooch with the Wii U because they changed the controls and didn't keep innovating. Then they tried to figure out how to recoup with the Switch. They should have said: "Oh shit, we have a killer here with the Wii. Even 70 year old grandpas are buying this to fish on." Then they could have said, "Ah, we can make the Wii U the next generation Wii with better graphics and more power and make this thing MODULAR - treat it like a basestation." With the advent of powerful mobile phones they they'd have already had the vision, "Now we will release the Switch which is simply an extension of the powerful main basestation (or extensible) Wii U that will give us a mobile presence. We'll also allow a Switch-like unit to be combined with mobile phones for more creative control and thus keep our finger on the pulse of the market the entire time." Nintendo is retarded in the literal sense. They have no vision, yet had the easy position to see all of this and act accordingly. This is what everyone wanted and still wants, but they're such assholes and idiots that they won't listen to their proctologist who tells them where to stop sticking their heads.
&gt; Besides, if performance is really critical then the code should be written as a native C extension Then why did you even propose a faster solution? Why are you even here when you could be having fun wrangling pointers with malloc and free?
&gt; What method should I use to solve this problem? There is no simple 1:1 method to solve it in one go, I think; at the least I can't think of one right now. A naive approach may be to just iterate over the strings and compare them 1:1 on every position and manually count. There are most likely many better ways to solve the problem. This is IMO very similar to what is done in bioinformatics, e. g. hamming distance, levensthein distance etc... For this, the gem here may be helpful: https://rubygems.org/gems/diff-lcs Hamming distance works for same length strings. Gems can solve this as-is btw: require 'rubygems/text' # =&gt; false include Gem::Text # =&gt; Object levenshtein_distance "ABCDEFG", "ABCXEOG" # =&gt; 2
abs is for absolute values. To make you understand: \-4.abs ==&gt; 4 4.abs ==&gt; 4 &amp;#x200B; Min is take the minimum between values: \[5,7\].min ==&gt; 5 &amp;#x200B; In my case I do like this: \- if the strings are equal return 0 \- if the strings are different, count how long is the difference between the two strings and to this value adds the char that are different.
Rails is just fascinating. I don't use it, but I can appreciate how heady and addictive such rapid development can be. This was all, what, an afternoon's work? That said, it's also terrifying how much there is underneath that many devs don't realize, and how constricted one has to become to understanding a single framework. Without waxing poetic, there seems to be a major philosophical distinction between software developers who want to get it done and those who must know how it all works. I suppose one could strive for both.
1. For performance. 95% of ruby programs will never need to use that method, so it's not loaded by default. The ruby *core* library is globally loaded; the *standard* library must be loaded explicitly. 2. There's no need. The standard library adds `Integer#prime?` already. 3. You would do this by raising a discussion on the rubylang bugs board, or opening a PR in github. But as mentioned already, I doubt your request will be accepted... Unless *maybe* you propose to rewrite the method in C, and add it to the core language...
&gt; However, incredibly fast development in the beginning leads to &gt; slower development cycles in the future. Citation needed. &gt; Every new feature requires more test coverage Why? Evidently this can only apply to people who require tests. Often tests then become a substitute for a lack of brain AND an inability to use a language that does not have "strong compiler checks" (if we focus on most tests; not all tests are like that, it depends on the test framework). &gt; Would it crash in production if I’ve missed something? Only if the one who wrote the code is a noob. Noobs write code that crashes. Tests are then a substitute to prevent the noob factor. &gt; Over the past few years, the amazing Ruby community came &gt; to understanding that it needs type-safety and increased &gt; runtime performance. Not really. Type-safety is only required by noob clowns. Increased runtime performance? Well, matz said it best - nobody minds if things become faster. However had, ruby was never designed to be a C replacement from the get go. The focus is on the human being, not on serving the machine. And this is the problem with people like the blog author - they try to retrofit ruby based on their own noobness. Why can't these people stick to C? C is in many ways still the king among the programming languages. The answer is evident - noobs struggle with C even more than with ruby. &gt; Stripe has made a big leap forward with their recent project, Sorbet. A terribly unnecessary and useless project. By the way - have they finally open sourced it or are they still hiding it, while promoting it? I mean really ... &gt; Sorbet adds a kind of type safety to Ruby. It adds a lot of useless syntactic noise to ruby. &gt; Sorbet makes a developer’s life easier by denying to run a program &gt; on methods arguments mismatch upon static compilation. That is the opposite of making the life easier. They add handicaps so that the code will not run unless you satisfy a compiler or type checker etc... The usual reason for having to serve the compiler is so that the net result executes faster. The "type safety" comes only secondary at best. Here in all these useless promos for "types", they completely (!) omit the speed gains. So why does not my ruby code then work 1000x faster, if I use types already? &gt; However, Sorbet doesn’t change the way the interpreter views &gt; the application code. Good! The less it can damage, the better. It's a fad that will fade away quickly anyway; only some larger companies will use it (they have a different use case than hobbyists). &gt; It also does not make a program run faster by any means Ok - so it is indeed completely useless. As I wrote initially, and just now. &gt; as Sorbet is not responsible for any precompilation optimizations. The excuses ... &gt; In fact, a program utilizing Sorbet in runtime would run a bit slower. Oh, GREAT! So I get punished by having to use types, and the net result is that my noob code produced more syntax noise also runs faster. Pffft - what do these clowns even think? By the way - is it open source already or still kept a secret? &gt; A serious drawback of using Sorbet is inevitably worse syntax. FINALLY! I have said that over and over again. By the way - crystal has the same problem. The type system added a lot of syntactic shit to crystal. And that was only the beginning - if you look at github changes to crystal, they clown-up the language even more daily. "abstract class Foobar" - wow. What is the next step? I suggest: public abstract class &lt;string&gt; Foobar Way to go, crystal folks! This is actually a wonderful demo how type madness taints the brain and then the language. So here is my suggestion - out with you clowns. Stay away from ruby. I used to not understand why the haskell folks were so elitistic but now I can understand it. They actually need to DEFEND the language from psychopaths. Not all new ideas are crazy, mind you; and some are fine even if very strange ... but many ideas are sabotaging a language. Not even as a primary focus but as a side effect. &gt; It adds a lot of signatures, mandatory T::Sig extensions, magic comments &gt; (# typed: true) and separate .rbi files T::Sig madness - yep crap. Magic comments ... well .. it is not a big deal. You can filter away all comments in any .rb file anyway right? Separate .rbi files - this is not the fault or decision by Sorbet. That was ruby that decided to keep it separate - and that is actually a sane approach. Because that way you don't sabotage and taint .rb files. Actually separate .rbi files are a LOT saner than the type madness. &gt; This makes Ruby lose its beauty and expressiveness. Here I agree in general. This is also a reason why I think ruby 1.8.x was the best. Some changes are understandable; frozen strings for example really come with a significant speed gain. It is the major reason why I use them too. But ... they also do add complexity; and taint the beauty. x = '' is better than x = ''.dup It's minor compared to the type madness though. The type madness is really insanity. The sooner Sorbet goes away the better. These people could be working on so many better things instead. &gt; It becomes more enterprise like Java, where safety and confidence are crucial. Yes. Companies push for it because they are the dumbest among them all. They want generic dumb-code. It is the dumbification of programming. That is why you need to keep companies out. Unfortunately this is not so easily possible due to monetary reasons ... but in an ideal world we would have languages completely decoupled from companies (and have that a sustainable model too). Also - no amount of money can compensate for bad design. Look at Google's Dart and tell me that this has an EPIC DESIGN. &gt; Of course, using Sorbet is optional, but looks like the Ruby team has an &gt; intention to merge it into the core That is not quite what matz said. But the support comes through .rbi, so it is not completely incorrect either. I just have not seen that the ruby core teams wants to push Sorbet into core; I think it is more the approach to try to want to appease the company clowns who rely on that. It is not admittedly Sorbet alone - the clowns at shopify, which admittedly also help the ruby core team / matz in some ways, also are SUPER ENTHUSIASTIC about this type madness. This is why, if you, dislike the types, should point out that the madness coming from these companies should not come at expense of normal ruby users. Companies have a tendency to bulldozer over people in general. It's not a good idea to give them more and more leverage into any language. &gt; meaning that sooner or later Ruby which we used to love will be no more. Now THAT is actually BULLSHIT! It also shows that the author has not listened to matz or understood the philosophy or how ruby is used. Ruby has always been multi-paradigm from the get go, even if OOP is in my opinion the core tenet in ruby (that is, ruby OOP, not Java OOP or any other). But you had functional ideas; and people having different ideas suggest it and accept that too. Still, I do not completely disagree with the statement per se. As someone else wrote on reddit, companies may begin to demand type-clowns for hire, and at this point it can indeed become a problem since people may no longer avoid the type madness if they want to land a job where they can use ruby. And THAT would actually be shit. So ... resistance against these clown-companies is very important. &gt; There will be no joy of sitting aside a lake observing its beauty, but &gt; heartless business requirement of confident deploys. Yes that is a real possibility. We have to monitor these companies very carefully. They will clown it up for sure. &gt; It’s a bit pessimistic, of course, but I always valued the visual experience &gt; a programming language gives. It is actually not pessimistic; it is realistic. Ruby HAS gotten worse from a syntax point of view. Not every change is as bad as other changes, but some are just ... strange. Why does omitting a value in a Range now imply infinity? That simply does not get into my head. You can indeed say the same about oldschool $1 or @1 but this is still syntactically different; and in all these cases, they allow you to write more succinct code. $1 existed in ruby for a very long time, and while it is not pretty, it is useful. Alternatives would require more code. That applies to omission of values in Range referring to infinity too - you can't get shorter with syntax when you ... omit it completely. :)
 &gt; Sorbet seems like a great tool for existing Ruby applications with &gt; huge codebases Nope. Sorbet does not seem to be a great tool for anything other than to appeal for noobs who can not program. Aka these people who get hired in masses by companies so that they can churn out business code like drone workers. Communism in mass, just in the form of capitalism disguising that they use slave workers (ok not really slaves per se but you have to work in order to make a living and do things you don't like, right? So it is still a form of slavery nonetheless). &gt; where any change would require lots of attention (and tests) to &gt; not to break existing code. Why? I don't understand this. I am not saying that tests are useless; it depends on the use case, scope. Different test systems. I do test for retaining functionality for example. I don't test for compensation of writing noob code though. That would not make any sense. It's interesting to see that test people are primarily responsible for wanting to slap types onto ruby. &gt; Type-checking would indeed increase the trust into deploys and &gt; make shipping easier. Or write sane code by competent hackers. By the way, why would "shipping" be made easier? You can use gems and "gem install bla" works. You can even push everything into one tarball/gem and push that or make it available somewhere e. g. oldschool ftp websites. Or even use setup.rb - I am even using that in a project for faster batch-install of everything, without gems. People seem to forget oldschool stuff ... &gt; Therefore such a move is absolutely justified if you already have &gt; many LoC and/or developers. Nope. It is not justified, neither in regards to LoC or the worker drones. &gt; Modern web applications are typically database wrapping APIs Not really. In the last 2 weeks or so I wrote a lot of sinatra-code. Sinatra is pretty epic as an idea; as an idea it is great. Essentially all my code for commandline stuff can work via a web/REST API too. That is also great. Not all of this requires a database per se. And I can still do everything I can do via ruby, anyway. I can use authentification too. &gt; Ruby 3x3 goal confirms that the community is aware of the &gt; performance issue But the 3x3 goals are not community goals. Matz issued that goal. That is different. To me performance was never critical since I did not start to use ruby due to performance/speed issue. I don't mind any improvements here, of course, but it is not my primary focus, so why should I make it to be my primary focus? It's simple a goal that the ruby core team has. It's not a bad goal but it is not a "community goal" for sure. There is no global community. The "rails community" is not the "ruby community" either. Zed Shaw already was wrong when he wrote that years ago (he does not know the community evidently and judging from the learn ruby the hard way, he also does not know ruby either). &gt; but still, even x3 speed increase wouldn’t make Ruby fast. It does not make ruby as fast as C that is true. Python is not as fast as C either. The 3x3 only means faster than e. g. ruby 2.0 exactly. &gt; Sorbet allows to declare a method’s arguments’ and return types. &gt; Indeed, if you try to call this function with a String, it would raise &gt; upon calling srb tc: extend T::Sig sig {params(a: Integer, b: Integer).returns(Integer)} def sum(a, b) What a horrible shit. Can't someone buy Sorbet so that it goes away? Can't the Sorbet developers get some real jobs and work on real problems instead? Actually, that API looks like rspec. That's also quite ugly. At the least rspec is in some ways still interesting, whereas this type horror is just terrible. &gt; JIT is a nice attempt to do so, but usually its performance gain is &gt; neglected by the amount of CPU load and RAM it needs to &gt; perform its just-in-time compilations. That depends. The optcarrot tests shows some significant improves. It's not for every application, but for some it does speed up things considerably. https://medium.com/@k0kubun/ruby-2-6-jit-progress-and-future-84e0a830ecbf You can ask Takashi for where mjit does the most improvements. "Deadline" will be ruby 3.0 evidently. &gt; Premature optimization is bad, you would say. I would not. Knuth said that right? But aside from premature anything, type clowns are in general bad. &gt; However, sooner or later a business understands that Ruby became &gt; a bottleneck and even caching doesn’t help enough. Indeed. Ruby users are not the next up and coming facebook though. &gt; But what if there was a language with syntax similar to Ruby, but statically-typed &gt; and incredibly fast? This would restrain technical debt and make the &gt; codebase sustainable for long-term development, still keeping the &gt; expressiveness. Imagine having C-like speeds but preserving the development &gt; joy and great shipping confidence. This would make it perfect choice both &gt; for new and existing applications. &gt; There is such a language. Nope, sorry. It's blind crystal promo. The type shitness is the same problem that crystal has - crystal code looks like someone took ruby and pissed on it. Not all of crystal code but please, have a look at github and tell me that crystal code written today is better than e. g. written 3 years ago. Crystal code, syntax-wise, got worse. (Admittedly ruby's syntax also got worse ... ) &gt; It resembles Ruby so much that it is even possible to run some Ruby &gt; code with Crystal! It resembles ruby, yes - but it is not ruby. It is another language. The two are not exchangable 1:1 in any more realistic code example. And what is an abstract class, anyway? What were the crystal devs smoking when they came up with abstract madness? Who is making these decisions, anyway? &gt; Crystal uses an LLVM backend Which actually LIMITS you. I can use/compile ruby on my linux stack without llvm. Isn't that great? It also makes crystal dependent on llvm. Whatever the llvm folks do, crystal has to make too. You can say that this is not a drawback but it is still a constraint. Why are these constraints not mentioned? I think crystal is a great idea AND great language nonetheless - it is good that it exists. In many ways it is the closest sister language to ruby, too. But it is not ruby and that has to be mentioned. And the type madness is the same or similar shit that e. g. Sorbet and other type clowns have. &gt; All these gains preserve the familiar Ruby-like syntax you are &gt; already in love with: # crystal.cr def hello(who) puts "Hello, #{who}!" end hello("world") # puts "Hello, world!" I am getting angry here. Yes you should simple examples? Ok let's look at this crystal example then: https://crystal-lang.org/reference/syntax_and_semantics/virtual_and_abstract_types.html abstract class Animal end Animal.new # Error: can't instantiate abstract class Animal That's still as great? And that is just a tiny example. We can find larger ones: https://citizen428.net/blog/a-rubyist-looks-at-crystal-part-2/ macro define_abstract(klass, *names) abstract class {{klass.id}} {% for name, _index in names %} abstract def {{name.id}} {% end %} end end define_abstract Abstract, :one, :two class Concrete &lt; Abstract def one 1 end end Not as pretty anymore right? &gt; Crystal has a smart compiler, which does not require to explicitly &gt; declare types everywhere, but still, it’s fully type-safe. YOU CAN NOT USE CRYSTAL WITHOUT KNOWING, UNDERSTANDING AND USING THE TYPES. There is no way around that. What he wrote here only applies to those cases where crystal knows what the types are. And this number is not at 100%. &gt; Among the other features Crystal has is extremely simple bindings to C libraries. And that helps how? People have to understand C if they want to write bindings. There is no way around that, even in libffi code, you have to know what the thing is does or how it works when you write the libffi specific parts. &gt; Although the language has not been officially released yet (still 0.x), &gt; it’s already been used in production be many companies, including &gt; Manas, Yahoo, Nikola Motor, Rainforest, Diploid, NeuralLegion and more. It's funny that he again mentions the companies ... did he not learn his lesson when mentioning Sorbet already? ;) &gt; To close the arc, with Crystal you’d ship features fast and confidently &gt; during the whole project lifetime, not only in the beginning. Ok, stupid propaganda - I "ship" ruby code all the time, from the early stages to the late stages, makes no difference. So, no, it is "not only in the beginning" - that is pure company propaganda.
Are you even more surprised to find out that it's actually `x.send(:=,10)`
&gt; developers who want to get it done and those who must know how it all works. Its my responsibility to teach our new hires how to use Rails, if they have used Ruby before, it take me about an afternoon to get them proficient with Rails, and I do that by following a request through the full stack, all the way from rack to the controller. And digging into a few things like route generation, form helpers and and such. Rails is actually a fairly simple framework to understand, backed by really nice ruby code, so teaching it to a motivated person is really easy and quite fun. It can be a nightmare to learn through most tutorials though, I wish I had me when I was learning, and I wish they hadn't pushed the "Rails Magic" part so hard in the marketing.
In my professional life, the difference between "get things done" and "must know how it works" aren't mutually exclusive. You can "get it done" with a "get it done" framework even faster when you understand how it works. Tangential thought here, but business needs solutions fast. Using an established, stable and maintained toolkit (Rails or otherwise,) in favor of using whatever is "the new hotness"-framework/toolkit is a clear decision to me. Development timelines are easier to estimate with the establish framework.
This is incorrect. The first line is a syntax error: $ pry [1] pry(main)&gt; x.=(10) SyntaxError: unexpected '=', expecting '(' x.=(10) ^ [1] pry(main)&gt; However, the syntax is available for accessors: ``` $ pry [1] pry(main)&gt; User = Struct.new(:name) =&gt; User [2] pry(main)&gt; me = User.new("Bob") =&gt; #&lt;struct User name="Bob"&gt; [3] pry(main)&gt; me.send(:name=, "Alice") # same as me.name = "Alice" =&gt; "Alice" [4] pry(main)&gt; me.name =&gt; "Alice" ```
Because for the sake of a few lines of code, having a method which runs in up to O(1) instead of always O(n) is a massive improvement. Especially when dealing with big arrays.
dev.to now requires a "social login".
Open source, closed content.
If you don't want to login to [dev.to](https://dev.to) you can see post in my blog on Github pages. [https://artur-martsinkovskyi.github.io//2019/rubyish-flyweight/](https://artur-martsinkovskyi.github.io//2019/rubyish-flyweight/)
 in the exchanges I had with the dev manhnt9 on discord that is not how it came across to me. After all if there's little interest it doesn't make sense to divert resources away from other work they could be doing. At first they didn't think too much of it, but unless they investigated it how could they. Once I explained there looked like ruby support was no where to be found in the 3D eng. space. He saw, okay well lets find out how big exactly the demand is. I'm just volunteering, (i'd be happy to pass the baton as well). The only thing I can see (being a sign of indifference, after all there are many languages that could be supported) is that they could be doing this reddit post themselves, but I don't mind, I like the idea of seeing my inkling through that this would be a nice perk to have/add for the ruby community. &amp;#x200B; Another thing is that thanks to the github page C++ interface to Ruby's C API. the bulk of the work is done manhnt9 wrote: "It won’t be too hard to add ruby support. " so in that sense the chicken or egg issue that was brought up in the comments shouldn't be that big of an issue. I am going by his word here and the fact that it sounded like adding Lua wasn't too tough to do.
The author just posted the link wrong. They posted https://dev.to/arturmartsinkovskyi/rubyish-flyweight-3afp/manage But it should've been: https://dev.to/arturmartsinkovskyi/rubyish-flyweight-3afp
Looks useful. Do you have a link to the template?
cool I didn't know about this. that tank game does look nice. one thing that caught my eye from the Prime engine was vulkan support.
I think it is quite terrible. It's essentially a colossal DSL that is so mega-specific that it is hard to even call that ruby anymore. On top of that it is a hugely complicated stack. &gt; That said, it's also terrifying how much there is underneath &gt; that many devs don't realize, and how constricted one &gt; has to become to understanding a single framework. Because rails is more like its own language on its own really at this point. &gt; Without waxing poetic, there seems to be a major &gt; philosophical distinction between software developers &gt; who want to get it done and those who must know how &gt; it all works. I suppose one could strive for both. I don't like that approach at all. I think the sinatra approach (start small, build up on it) is the right way to go. Unfortunately padrino is just a shallow rails clone; and hanami also follows into that. They don't want to just extend sinatra itself ... which is a mistake. We got a mega-complicated stack all over everywhere. Simplicity was slaughtered.
From the YT description: [https://github.com/lazaronixon/the\_construct](https://github.com/lazaronixon/the_construct)
&gt; it take me about an afternoon to get them proficient with Rails, Sure sure - the dreamers. In 2 hours you have all rails experts ... Does anyone believe that? Seriously? I mean you are like the rails factory here dude, with the "single afternoon" claim. &gt; Rails is actually a fairly simple framework to understand No it is not. Sinatra is about 50000x simpler. In fact it is just a thin sugar over rack. You don't have to know one bit about MVC in order to expose any ruby code via a web/REST interface through sinatra. &gt; It can be a nightmare to learn through most tutorials though Because they are convoluted and boring. In fact - how utterly boring rails is has always been my biggest problem with it. Sinatra was a lot more fun, but admittedly after a certain point there is the inevitable question ... "what now". And sadly people point to padrino or hanami but these are just rails clones. I don't want to be stuck with a rails world view when I approach the www; I am not even sure I want to be stuck with a rack approach either. But for some strange reason we are stuck with this in ruby and possibly outside of ruby too. When Zed Shaw once wrote rails is a ghetto, he should have written the www is a ghetto. That would have been much more accurate. &gt; I wish I had me when I was learning Yeah yeah the mystery man - 2 hours and you turn any proficient ruby user into a rails guru. Anyone believing that? &gt; and I wish they hadn't pushed the "Rails Magic" part so hard &gt; in the marketing. There is no magic - it's a lot of thought that went into that DSL.
I don't think that solves the problem as stated, you're treating the strings as Sets of character thus not handling position nor the same character appearing multiple times in a string.
Re-read the question. The objective is to " return the number of characters that are different". It states nothing about position. Also, it doesn't matter how many times a character appears in a string, only that that the characters are **different**.
Your last example does not have fewer allocations, `a.each_char.with_index` is the same shape as `a.chars.zip(b.chars)`. The idiomatic solution: `a.chars.zip(b.chars).count { |a, b| a != b }` is going to have `2n + m` allocations (n = length of a, m = length of b). Something like: `a.length.times.each_with_object(0) { |i, sum| sum += 1 if a[i] != b[i] }` would be a bit better at `n + m` allocations. Important thing to note here is that Ruby doesn't have a character type so indexed access into a string actually returns a string (performs an allocation), though the allocation should be limited to a pointer, it won't copy the character data itself. Given this you won't get better than `n + m` allocations here without dropping to C.
I’m curious that you get folks who know ruby but don’t know rails (i.e., there’s dozens of us!). What were most of these folks doing before? Are they applying for entry level positions?
 The way I would do this is to wrap the room variable in a call to Array() at the top. That way you are guaranteed that the variable will always be an array. If you are passing in an array already then the call effectively does nothing.
Pretty much every other solution in this thread is using the same interpretation I came away with. This isn't Levenshtein distance btw, just `a.chars.zip(b.chars).count { |a, b| a != b }`
You were right. I removed my code.
Yep, pretty much entry level, they have mostly only used Ruby in University etc.
I feel like Stimulus kind of came out of nowhere but it looks really cool, there was a lot of buzz about it at last weeks' RailsConf. This kind of approach is much more my speed than ripping out rails views completely and replacing them with those monolithic JS frameworks that are so popular right now.
I started learning Ruby for data processing / DB / scraping work a few years back, and consider myself pretty fluent with it. However, I am not a very good Rails dev. I have written a few Rails apps to help me in my day-to-day and have dug through the source to better understand it, but I just don't have much experience with using it frequently. So I guess I match that description, a little bit. (Bonus shout-out to Ruby for hacking data! It slays at processing text!!!)
Thanks, the video was inscrutable to me.
Turbolinks Android is deprecated, but it's otherwise interesting.
My bad. Turns out that `=` is not a typical method operator. I should have tested my example. :-) On the bright side - I learned something new myself. :D
Hi, could you elaborate on the higher maths. I have studied some abstract algebra at college but i still don't have enough knowledge to understand advanced cryptography :(
There is no such thing as "up to O(1)", your version is O(n): &gt; A description of a function in terms of big O notation usually only provides an upper bound on the growth rate of the function. — [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation) (fourth paragraph) And if this is a thing you're doing often on datasets of hundreds of thousands of records or more then, as I said before, keeping that data in an indexed datastore and performing the operation there will be faster than loading the data into ruby, running even some C extension (where the maintenance burden is huge due to the limited knowledge base), then garbage collecting all the objects when you have the result.
Indeed, you are correct: https://gist.github.com/dmke/a117fc9d57ed148a34e9fb7e3ee21904
I thought [https://github.com/soutaro/steep](https://github.com/soutaro/steep) rather than Sorbet is the candidate to be included in CRuby?
Does Reddit allow one to block all posts on this related to Crystal or "types"?
This can be the 246th workflow management tool, according to this list: https://github.com/common-workflow-language/common-workflow-language/wiki/Existing-Workflow-systems The nice thing about rolling your own tool is you can meet some specific requirements to your own environment. But there's just so much out there to choose from already, most notably Airflow, that rolling your own is hard to justify.
It's *far different* than "ruby with types", not *far more.*
Thanks for mentioning my work!
maintaining a parallel set of type files separate from your source code sounds like a huge chore. changing the code breaks the type files every time - brittle!
folk say the same thing about tests. it's true in a way. type annotations and tests are both intentional repetitions, and both require changes when the code changes. it might be that much-used code, like the stdlib and gems, get the most annotations in the same way they often get the most tests.
You have to keep your types consistent across your project whether you have type annotations or not. The nice thing about a compiler is that it’s there to tell you what code you need to update; otherwise, you’re grepping across your files and hoping your test coverage is good enough.
The .rbi file are auto generated from static analysis, docs, types notations and maybe runtime information, you are not supposed to write them yourself.
something your calling to_i on is false (e.g. curr_coord[1])
That's a really cool syntax. It's naturalness is proved by the fact that I discovered it intuitively. It must exist by analogy with the keyword arguments.
Where could we suggest naming? In the bug tracker?
They will most likely go out of sync though.
For the most part not really. Code from gems, stdlib and your own codebase that's already stable or you're not currently working on won't be a problem. Then it just remains to be seen what strategy they will use to keep up with the new code you're adding or want to modify.
Put a space between the `+` and the `1` on line 6 Put a space between the `+` and the `2` on line 7
I'm aware that there are application generators for Sinatra out there (like Corneal), or even whole frameworks like Padrino based on it, as well as other amazing non-Rails frameworks. But my main reason for creating this gem was to learn more about Sinatra and also to give a bit more structure to my Sinatra applications, since I often found myself having to do the same configurations repeatedly when making new applications. The gem started off as a simple Sinatra template, but ended up becoming a CLI once I started adding more and more options. I released it in the hope of encouraging the use of non-Rails frameworks and making Sinatra a more appealing choice to new developers and encourage them to consider using it. Hope it's at least a bit useful!
Would you be able to show us some sample data that reproduces the issue? I've been running the following code: `def test_method cur_coord, new_coord, colour = :black` `return false if cur_coord[0] != new_coord[0]` &amp;#x200B; `if colour == :white` `return false unless cur_coord[1].to_i +1 == new_coord[1].to_i || cur_coord[1].to_i + 2 == new_coord[1].to_i #moves 1 or two spaces forward` `return false if cur_coord[1].to_i +2 == new_coord[1].to_i &amp;&amp; cur_coord[1].to_i == 2 # only moves two spaces on the first move` `else` `return false unless ((cur_coord[1].to_i - 1 == new_coord[1].to_i) || (cur_coord[1].to_i - 2 == new_coord[1].to_i))` `return false if ((cur_coord[1].to_i - 2 == new_coord[1].to_i) &amp;&amp; (cur_coord[1].to_i == 7))` `end` &amp;#x200B; `return true` `end` &amp;#x200B; `puts test_method "a7", "a6"` `puts test_method "a7", "a5"` `puts test_method "a7", "a4"` `puts test_method "a7", "b4"` &amp;#x200B; But I've not been able to replicate your error.
Props for creating a generic form builder! When you stop using Rails, it's disappointing when you have to say goodbye to SimpleForm, so it's great to have other options. It's also impressive how many themes SexyForm comes built in with. One question: have you heard of [Forme](https://github.com/jeremyevans/forme)? That's the form builder gem that I personally adopted, and it's quite nice. It's still missing some things such as Bootstrap 4 support, but it has other nice things like Sequel and Roda/Sinatra integrations.
You'll only meet the error with a White piece.
Ah, I'd miscounted the lines: that's that mystery solved :)
The whole community is watching your work. Thank you for what you are doing.
The reason this errors is because `String#to_i` takes an optional argument *base* which defaults to 10 but may be between 2 and 36. "1111".to_i 2 # =&gt; 15 "f".to_i 16 # =&gt; 15 The parser sees `cur_coord[1].to_i +1` and is trying to call `to_i` on a String passing the argument `+1`. That is not a valid argument and then chaos happens. This is a symptom of Ruby's *sharp knives*. The language allows us to write `1 + 1` instead of `1.+(1)` and `"1111".to_i 2` instead of `"1111".to_i(2)` but when using theses sharp knives we need to be carefull. Your expression in its purest form would be `cur_coord.[](1).to_i(10).+(1)` but the language allows us to do `cur_coord[1].to_i + 1` if we are careful.
Hello, still early but some weeks ago I started a (secure) ruby to michelson (tezos) contract script project. See &lt;https://github.com/s6ruby/ruby-to-michelson&gt; Cheers. Prost.
I saw it! Looking forward to its progress.
Yes, the bug tracker issue for the feature being named is a great place for name suggestions.
compilers are great! usually they work on the source code, though.
No lie this killed me. It was fixed a couple days ago, sorry about that.
I'm not sure what this blog post adds over just looking right at the rspec docs?
&gt; there’s dozens of us! I think that might have been reasonably accurate in 2008-2009 at the height of the marketing blitz. It's well into the thousands now, judging by the number of other frameworks out there (and that have come and gone in the interim) and the number of contributors to, let alone downloads of, such. I was a proud cheerleader of Rails for a good 6-7 years; we've worked hard over the last two years to become fully Rails-free in production and new development intended for production. It's a *fantastic* tool for whipping out a one-off that nobody is ever going to touch again; the architectural constraints-by-omission become increasingly apparent, intolerably restrictive, and voraciously resource-intensive as you scale up. I'm not saying it can't be done; there are great teams out there with great products built on Rails. But the amount of sheer work they have to do over time that just seems like "doesn't everybody have to do it this way" has no doubt driven enough big-bang rewrites using microservices, and the resulting failures, to provide a more-than-respectable attendee cohort for the next NotRailsConf.
How is Falcon different than Puma?
That’s a great point. The microservices trend is the folks running for the hills: they might have run too far, but there is definitely something unpleasant they wanted to leave behind. And yes, I was being a bit glib about us being just a dirty dozen. I’m far off the Rails and there is no shortage of tooling available to us. Six years or so ago or so I hated seeing so many rails-only gems, but I believe the norm is increasingly for gems to provide interface for Rails OR any Rack based framework.
It moves too fast; he seems to assume that you know what he's going to type next (and if we did, why would we watch the video?) Cool music, but a spoken explanation would be better. It would also tend to keep the typing from being too fast to follow.
You repeated this paragraph twice: &gt; It’s great to see Ruby’s GC continue to evolve and improve as new versions of Ruby are released. We’ve come a long way since Ruby 1.8, and further GC improvements and new additions like the garbage compactor will make Ruby memory even faster and more efficient. Are static types going to be a requirement in R3? One of the things I really like about Ruby is the dynamic typing... sure it can cause problems, but so can static typing... I can totally see use cases for static types in Ruby, but hopefully this is optional... Neat article, thanks for sharing! Anyone know if/when the RubyKaigi talks are published? Looks like [only the keynotes](https://www.youtube.com/channel/UCBSg5zH-VFJ42BGQFk4VH2A) so far.
Oops, I don't know how that paragraph got copied twice. Thanks for the heads up! Static types will absolutely not be a requirement for Ruby 3. Static type annotation will be entirely optional, like tests. Mats is hoping to preserve Ruby's dynamic nature while adding optional type analysis tooling for IDE integration and to help ensure program correctness.
ha no worries, I was kinda skimming it and then started getting deja vu... had to do a double take :) Gotcha, cool! Like I say, I think there are some cases where static types could have saved me some time debugging, but being able to get all meta and do things dynamically is what keeps me coming back. I have to use Ruby for Chef, I don't have to use it for personal projects. Actually, I'm really interested to see how type annotations could work for Chef... hmm... now you got me thinking ;)
_One_ of the things I love about [Hanami](https://hanamirb.org/) (our current shop standard) is their embrace of [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) with an emphasis on [monolith first](https://guides.hanamirb.org/architecture/overview/). You can have multiple "apps" (default web, admin, CLI, etc) within a project and those, or pieces of those, may eventually be extracted into separate services (which is *very* straightforward), but there's no seeming compulsion to do that simply to reap the benefits of Clean Architecture. Take a look, if you haven't already.
Should be defined in .gemspec no? Check out the cucumber gem, they have custom defined docs link.
I think putting type info into a sidecar file is a good compromise. Certainly its easier on the interpreter to maintain backward compatibility. Additionally, these extra files can be used to generate more efficient binary serialization protocols without much effort. If the jit compiler makes it in for v3 we will have a very serious upgrade to the Ruby ecosystem. Coupled with the recent announcement that Windows will include a Linux kernel and run containers natively I'm pretty stoked for Ruby's future, syntax perversions be damned :D
Thanks, Misti25. Maybe not. First, I recall being on a page on RG that allowed me to edit a very few things, one of them being the doc link. Second, my doc link on another of my gems has an anchor ([https://github.com/BurdetteLamar/markdown\_helper#markdown-helper](https://github.com/BurdetteLamar/markdown_helper#markdown-helper)), which appears nowhere in the gemspec for that gem. So I'm still stymied, I think.
It definitely can be specified via metadata in gemspec: https://guides.rubygems.org/specification-reference/ (see METADATA section). About markdown_helper, though, it is a mystery indeed...
*Thank you!* That's actually *readable!* After 25 years in web dev, it always amuses/enrages me when people build sites that are seemingly designed for under-25s with perfect vision. WCAG has been a thing for as long as under-25s have been *alive*, people!
It was changed to make it easier for gem publishers to have different links for different versions of a gem: [https://blog.rubygems.org/2019/03/08/and-then-there-was-one-metadata-links.html](https://blog.rubygems.org/2019/03/08/and-then-there-was-one-metadata-links.html) &amp;#x200B; The documenation on gemspec metadata shows how to specify the documentation link: [https://guides.rubygems.org/specification-reference/#metadata](https://guides.rubygems.org/specification-reference/#metadata)
I really like the recent trend of adding gradual typing to dynamic languages. I find dynamic languages don't scale as well as statically typed ones, and gradual typing really helps bridge this gap
Thanks, zverok_kha. I've used the metadata -- works!
Thanks, retardo, for this info. That almost had to be the case.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Does anyone here know about using Ruby with Bluetooth devices?](https://www.reddit.com/r/programming/comments/bluv2t/does_anyone_here_know_about_using_ruby_with/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I thought _maybe_ rubygems removed that feature for the gemspec instead. Have you tried specifying it in the gemspec? and re-releasing? Let us know if it worked? If you want to change it without a re-release, that would be a problem. It's possible rubygems no longer supports that.
is faster :)
Haha. Fair enough :) I hadn't heard of it until this post, so figured I'd get it from the horse! Looks like a cool project, but from a cursory google search, I'm not really sure why I would chose one over the other.
I've never seen any conflict. I get things done better by knowing how it works. It does mean when working with a new technology, I want/require/demand some time to get basically acquainted with it before diving in and producing immediately. Work environments should be accomodating of that, because don't you want your workers to know what they're doing?
Sorry my english is not good enogth..
Thanks, jrochkind. Feature removed, per retardo's reply. I have put the link into the gemspec, per zverok_kha's reply, and have released a new version of the gem.
will have to ask that Junior developers in my company who have read the Relish docs and still didn't get it. After reading my TIL note it seems they did. Magic I guess
Respect. I can't say ever developer or dev-lead I've met is like you. That said, it's not only that one might not know how things are done, but one might feel discouraged from architecting things a different way if it doesn't match the blessed way. For example, I eschew scaffolding because I don't adhere to AR models being domain models. But when I see folks getting AR models setup and running in seconds, I do get a minor tingle of jealousy until I remember that baby ARs turn into god objects over time.
Yep I've taken a look and I like what I see. Hanami is totally what everyone looking for strong frameworks should be hopping on, no doubt. I don't use it due to the idiosyncratic nature of my work and teams. I've stuck to Roda and architecting by hand (I would totally characterize my approach as monolith-first, DDD-inspired layering). I have no problems splitting off services and operations into separate workers or apps. Its delightful, for example, to see domain models that can truly be built up and work from any data source.
JIT is already there, in Ruby 2.6. It's just not that helpful for a lot of applications.
[https://gorails.com/](https://gorails.com/) has nice videos. But I don't think it's what you're hoping for...
I understand that. I've taught English as a second language _to_ outsourcing teams before, and I understand how scary it is. (Let's see the average American dev go to Shenzhen and hit the ground running in a Mandarin- or Cantonese-speaking team there.) I'd encourage you to try anyway. You'll be able to listen to it and hear your mistakes, and so will your audience. *That's okay!* You can always record it again, and experience will give you confidence. Don't give up!
Roda is my second-favourite framework. We spent a year and a half doing one of those clean-sheet-of-paper big-bang rewrites using Roda to build what turned out to be almost 70 different "apps" before we were finished. It worked, and with a larger team, it would have been *several* hells of a lot of fun but, my `$DEITY`, the amount of sheer *work* it took to deploy and operate that constellation! I completely hear you about idiosyncrasies. Maybe try an off-the-books skunkworks implementation of one of your well-defined, heavily-loaded apps/services using Hanami instead, and benchmark/code-review that? I've seen that sort of thing work a *lot.* To be fair, I've also seen it blow up in the proponent's face more than once, too, and the carnage is *not* pretty. Good luck and thanks for replying!
I am in the same boat :p codeacademys course was decent for starter
I’ll always recommend codewars, they don’t teach tutorials but it’s a great way to research and figure shit out on your own
I used to play with rubymonk.com, looks like it's still up?
Exercism.io
You can also try [https://teamtreehouse.com](https://teamtreehouse.com/) but it's also with a subscription.
https://www.learnenough.com/courses Their text courses are completely free to read online, you pay only if you want to download them or if you want videos.
it's certainly 'fun'
[The ruby warrior](https://www.bloc.io/ruby-warrior#/) A fun little game where you must code ruby to bring your warrior to safety and vanquish his enemies.
You may like my gem [minitest\_log](https://rubygems.org/gems/minitest_log). The code is on [GitHub](https://github.com/BurdetteLamar/minitest_log#minitestlog).
You will be able to use YARD docs to generate the rdi.
Tryruby still exists: [https://ruby.github.io/TryRuby/](https://ruby.github.io/TryRuby/)
I wish there was only one direction you could compose functions in. I feel like this paragraph is something I'll have to look up often, just like the difference between lambdas and procs: &gt; “Backward” composition maps to the mathematical operator ∘ we discussed earlier so g &lt;&lt; f is the same as g ∘ f meaning that calling the resulting composite function with an input x will call g(f(x)) &gt; “Forward” composition is the opposite of the above so g &gt;&gt; f is the same as f ∘ g meaning that calling the resulting composite function with an input x will call f(g(x))
Excellent introduction to function composition, then leading into the history and implementation of it in Ruby. Great read!
I remember using then when I first started with Ruby years ago. I'm glad it's still around.
It's also great for seeing how others solved the same problem.
The point made around 17:30 about not mixing levels of abstraction is a very important one.
That’s a wonderful suggestion and might go about starting that myself on the side. Thanks!
Looks great! I think I'll give it a go. Thanks :)
Oh dang! Looks awesome. :) I'll have to give it a try. Thanks for the recommendation.
Very helpful tool for the arsenal, thanks!
Never heard of it, is it like CodeAcademy?
It’s code practice &amp; mentorship. There are exercises, and you submit your solution. Then a mentor will review and help you through any parts you get wrong or could do better.
Oh, awesome! It looks very similar. Is it all the same material but just without the little drawings, etc. ?
And what would be the precedence order in this case? First two function composed into one then passed right as a single function and repeat?
Being able to compose functions in both directions is absolutely vital if you work in a functional language. As with anything in software, yes it's open to abuse. But when you find yourself needing it, you'll be extremely glad that the syntax exists.
&gt; Being able to compose functions in both directions is absolutely vital if you work in a functional language. Can you think of a toy example where this is the case?
It'll be instantly applicable in constructs like `#collect(&amp;object.:&lt;&lt;)` vs `#collect(&amp;object.:&gt;&gt;)`.
not if I override `#send` }:)
&gt; Being able to compose functions in both directions is absolutely vital if you work in a functional language. I don't think it is. I've never used [`&gt;&gt;&gt;`](http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html#v:-62--62--62-) in Haskell. You should always be able to switch the arguments syntactically.
self posts are not for linking your blog. Put content in your post.
I think this is a pretty decent article, showing how to do some debugging, telling us about the kinda neat Net::HTTP logging feature I didn't know about, and introducing us to problems with lack of timeouts on IO. But yeah, don't use "self post" with just a URL in it, use a link post for a link. One important point is that your network calls should _always_ set a timeout. What if the remote server connection _didn't_ have it's own timeout, and was willing to let you wait as long as the response actually took, say 10 or 20 minutes? In some cases you could have a bunch of workers hung up waiting for a response, with disastrous consequences for the app stability. With the actual solution in OP, as they say, "In order to turn the EOFError into a Timeout error" -- why is a Timeout error preferable to the "EOFError" though? Unclear. While applying timeouts to any network requests is crucial, so a fine solution if it solves the immediate problem, I'd still want to know why unexpected server behavior was leading to a weird error with a loss of stack trace. And I'm suspicious of the exception-swallowing code referenced in the previous article: rescue StandardError =&gt; e Rollbar.error(e, 'Error at Server', extra_params: {...}) end Are we sure this becomes okay when the `e` was a Timeout instead of an EOFError? Blocks that rescue generic `StandardError` and then don't re-raise or otherwise effect logic flow, just log and let the program continue as if the exception didn't happen -- seem suspicious.
Wops, I'm sorry, I didn't know that, I will investigate it.
There's some history here: [http://ruby.github.io/TryRuby/articles/try-ruby-version-4/](http://ruby.github.io/TryRuby/articles/try-ruby-version-4/)
All-in-all Minitest is pretty small and I would recommend reading through the source (at least reading the method names). You can take a peek at Minitest's own test files for examples. https://github.com/seattlerb/minitest#specs is a good jumpstart and you can look at the assertions file for more methods
The only metric that matters is this: How many engineers currently work at your company that know a given language? If it is enough that they feel confident to support the project forever then you can use that language.
Yeah, it all started here I believe - https://help.rubygems.org/discussions/problems/34216-unable-to-edit-newly-published-gem-server-error
Nice! Found out about [*Launchy*](https://github.com/copiousfreetime/launchy/) through your project.
[removed]
[removed]
Is there something else that you need from minitest/spec other than what’s in the Minitest README? I personally prefer combining the spec syntax with _assertions_ (as opposed to expectations), and you can find the list od all assertions [here](http://docs.seattlerb.org/minitest/Minitest/Assertions.html). For documentation on expectations, go [here](http://docs.seattlerb.org/minitest/Minitest/Expectations.html). As you might have noticed, the official up-to-date rdocs are on docs.seattlerb.org/minitest.
First of all, thanks for the review, I will refine the articles. I'm new in this forum, I will use the link post next time. &amp;#x200B; I agree with default timeout, actually we had it in place, but it was bigger than the one in the target service, this caused some problems. I forgot to mention it. &amp;#x200B; If I understand it correctly, you imply that the article should explain things in more detail. I explain here and will update the article as well. &amp;#x200B; In network operations the EOFError has many reasons to show up. It is hard to tell the real source without significant debugging. However in our case the execution in the target service would never finish without a timeout, and showing an EOFError in this case is misleading. &amp;#x200B; Unfortunately the exception-swallowing code has been in our code base for ages. It makes the hair stand up on the back of my neck, but what to do? Refactoring would be an awesome option. But not delivering for the business always meets significant resistance from the leadership lever in this project. That's why I did this article in my free time:D
That is a great way to do it. Someone else suggested that I try: ary = [*args] which accomplishes the same thing, though is tricker to read.
Thank you. I discovered functions composition with this article and it blows my mind.
This is great info, thanks!
Interesting. I've used `+` before but had no idea `-` was a thing. Should have known... lol. It's so obvious. I'm curious though, where did you see this? content = +"\n" content &lt;&lt; "## #{title}\n" content &lt;&lt; "\n" content This code seems needlessly... terrible... the way content is evaluated by itself looks like it's being returned to me, as in this is the body of a method... which why even use a string at that point? def content "\n## #{title}\n\n" end I guess maybe you could make the argument that the first version is more readable? And in this case, the cost of creating the temporary variable probably is negligible... Or maybe you've trimmed it down for the purposes of this example and the real code is much longer... your "practical use" example isn't really practical in and of itself, but I see how that can be extrapolated to real word scenarios. Anyway, that's probably too much analysis on what was example code! Thanks for sharing!
I'm not the author. But I would assume that example is an summary of output code in a commandline tool. Where the original contains much more unrelated stuff. Like conditionally adding newlines and such. e.g. `content &lt;&lt; "\n" if eol?`
Great guess! That's just a simplified example from a bigger chunk of code.
I built a testing library several years back by leaning on the oddities of unary plus and minus. Make positive and negative assertions with unary plus and minus against arrow procs :-) https://github.com/peterc/testrocket
I saw this positive string being used in Faraday's code last night while browsing around. Meant to look it up later today but here we are! Thanks for sharing this insight
My favorite use of unary minus for procs is to define it as currying: --&gt; (x, y) { x + y }.(1).(2) # =&gt; 3 I call them extra-stabby lambdas.
Have you tried applying to places? I've known a lot of people who have transitioned into QA from other backgrounds. Maybe learning some CI frameworks? (e.g. Jenkins). QA is just as much about process/people problems as it is about coding
Hi there - I've hired a number of QA staff over the last \~10 years so I'll see what I can think of. It goes without saying that this is all personal opinion and others may have strongly differing views (doubly so in software, triply so on Reddit) :) &amp;#x200B; If you don't have a history of QA on your CV then I'd guess you're aiming at some sort of junior position, in which case showing the projects that you've done yourself is a great start - I'd strongly suggest that if you haven't already, you create a public Github page with your work on. You could also look for some open source projects and make contributions to their tests too, as a way of learning and showing your interest in the subject. &amp;#x200B; Together with this, you may want to get some experience of using common bug tracking tools (often Jira) and showing that you're not just about the code part, but also about the QA part. Show you can assess a project, determine what needs to be tested, and automate the bits you can automate. &amp;#x200B; I wouldn't worry too much about specific languages (although I love Ruby for developing quickly and effectively) for your automation, but you might find some knowledge of Javascript to show off alongside your Ruby and Python is beneficial. There are quite a few test frameworks that use it, which might encourage somebody who already has existing automation in that language to hire you. That being said, I also see a lot of ads around for C# and Java automation with Selenium, so that might be another consideration. Personally I really like [Codecademy](https://www.codecademy.com) for starting out in a language. I've also had some good fun extending my knowledge with the challenges on [Exercism](https://exercism.io/). You might also find [Pluralsight](https://www.pluralsight.com/) quite good, although I'm not sure they have much of a free trial. &amp;#x200B; If you're keen on Ruby testing in particular then some popular frameworks I've come across are [Capybara](https://github.com/teamcapybara/capybara) and [Watir](https://github.com/watir/watir) \- I have used Capybara quite extensively and found it greatly eases the process of interacting with and controlling the browser, compared with straight up Ruby Selenium bindings. You might also want to investigate various test runners such as [Cucumber](https://cucumber.io/) and [RSpec](http://rspec.info/). &amp;#x200B; I find it quite hard to get in depth resources on the exact combinations of language and test framework I want to write, so a lot of my learning has been through experimentation and finding little pieces here and there. What I have found though is that once you get the concept of how automated testing fits together, transferring those skills to another language or test scenario gets easier each time. I also find writing automated tests incredibly fun. &amp;#x200B; Best of luck in your endeavours!
Language - Ruby Test Runner - all or any of cucumber, rspec, minitest, etc Type of Testing \- api - create collection of module/classes using a popular http client for a collection of endpoints - goal is to be able to write tests while exposing minimal http detail. You should not have to worry about how to make an api call in a test. The test should just contain test/app logic + data \- selenium automation - pick Selenium or Watir or Capybara. Personally, Watir for all purposes. When the application you are testing is Rails, then pick Capybara. \- others &amp;#x200B; Test Harness/Framework Now you get to combine all the above together. The goal is to create an intuitive test framework that is consistent, follows norms (style guide, test layout, separation of data/logic), and easy to teach/show/bring another QA engineer up to speed. Do not get too clever on solving problems through advanced syntax or monkey patching or anything weird. Keep it simple and keep in mind the technical level required for a new engineer. Litmus test - if new QA engineers struggle more than expected to come up to speed, the issue may reside in the test framework complexity. &amp;#x200B; Now you have working a test harness and working tests, where do you run them? Think about containerizing tests and test dependencies with docker to solve portability problem. Think about that test container and CI integration. If Jenkins, look into Jenkins jobs or Jenkins pipeline (scripted + declarative). &amp;#x200B; Tests are running somewhere automagically now, think about how to report/track test results. Jenkins offers test reporting and dashboards to a degree but rarely adequate for a mature organization.
Good point on the API tests. Have you ever tried the [Airborne](https://github.com/brooklynDev/airborne) gem for RSpec? I've had good success writing API tests with it.
If you want to make a compiled game, I'd recommend the DragonRuby Game Toolkit: [https://dragonruby.itch.io/dragonruby-gtk](https://dragonruby.itch.io/dragonruby-gtk) &amp;#x200B; [http://www.ruby2d.com/](http://www.ruby2d.com/) is also interesting.
Always happy to see someone learning Ruby! You'll want to take a quick look at [https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-while](https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-while) and it's inverse function [https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-until](https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-until) This is probably the hint you need, but, give those a glance and see if that doesn't point you in the right direction. If you still need more help, poke me again and I'll try and provide some more insight. :)
It's kind of hard to fill in the gaps. You've shared your winner methods, which make sense, and you've shared how you are capturing input. But not sharing anything in between that, so I'll just outline how I'd design the whole thing. 1. the board is a 2 dimensional array, representing the x and y axes 2. ask player for game type (PvP, PvC), and names, as you have above 3. then start your loop \`until have\_a\_winner? || board\_is\_full? do; ... end;\` 4. ask player 1 which column they want to drop their coin in. put an identifier in the lowest available row in that column (looks like your using X and O) 5. hasWon?(player1) or board is full 6. if not, prompt player 2 for column choice or generate column number for computers choice 7. haWon?(player2) or board is full 8. loop repeats
while(true) end will loop forever. while(!somebody_won) somebody_won = did_they_win () end Will loop until somebody wins
Just to chime in on what you've already done: In image 1, "or" can be represented by the literal word "or" or double pipes (`||`). A single pipe (`|`) is something completely different. In image 2, you have extra `end`s at the end of the method. This will likely make this file not run at all.
most QA jobs are entry level.
This is not the source of your problem, but I have a question about the hasWon method. Are you use you mean to use the | operator instead of the || operator? They're very similar, but they work a bit differently in ruby. The | operator, when applied to integers, is a "bitwise mask" and when applied to arrays it's a union operator. For example, [1,2,3] | [2,3,4] gives you [1,2,3,4] Meanwhile || in ruby always returns the left value if that value is truthy. So [1,2,3] || [2,3,4] returns [1,2,3]. Now in the case of simple booleans, true | false is identical to true || false, but it's generally proper form to use || instead.
I wish it could be used like... array.map &amp;(upcase &gt;&gt; reverse)
No wonder it does not work -- judging by color scheme, you are coding in C++Builder.
I actually didn't know that there was a difference between double pipes or a single one. Part of the code was given to us by the professor, including the hasWon method, and he didn't explain anything about it, so I assumed it meant or. Also my file does run I just didn't want to include my entire code in my post because it's lengthy lol
Well my professor gave us part of the code for the assignment which included the hasWon method, and he never discussed how any of it was supposed to work, so when I saw |, I assumed it was meant to stand for or. I had no idea it meant something else, but thank you for pointing that out and explaining it to me!
where are you based? message me :)
this simply isnt true -- particularly when it comes to QA "engineer"/SDET vs "QA"
"most" is the wrong word, but there are many entry-level QA positions available that will be a good start at least.
&gt;cptDreamboat Thank you for the info! I'll make sure my Github is up to date, look into those open source projects to contribute to, and the other resources you talked about.
I have not tried applying yet, but I will l look into Jenkins.
&gt;and he never discussed how any of it was supposed to work I feel frustration in your tone, and I totally agree with you and feel for you. On #ruby there are usually a bunch of us and if you come with code and direct questions you usually get an immediate response.
Unfortunately it sounds like you would learn more from a good book than your teacher. Hackerrank.com has a ruby primer. Simple to go through. That might help you out a lot. Ruby by convention also uses snake case (i_am_a_variable) instead of camel case (iAmAVariable). Are you new to ruby or programming in general?
I generally look at the [source](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/railties/databases.rake). But it's not for everyone. Here's [drop](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/tasks/database_tasks.rb#L179) Here's [setup](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/railties/databases.rake#L232) Here's [setup](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/railties/databases.rake#L265) Setup is calling out to [load](https://github.com/rails/rails/blob/master/activerecord/lib/active_record/tasks/database_tasks.rb#L361) If you have a tool like rubymine you can throw some debug statements in the gem. You can also find the gem on your disc and throw a debugger in there.
Look at launch school books. I'm a student but I believe you can access the books without being a student. They have from basic to advanced books, git, command line and regex books. Learn to program by Chris pine(may or may not be too basic for you) The ruby programming language by Matsumoto(creator of ruby - haven't read but supposedly an advanced book)
Alternatively using bundler, you can run `bundle open activerecord` to open your project's activerecord gem, and add byebug or binding.pry lines to wherever you need them.
Looking at the comments it seems like you have a pretty shitty teacher, fortunately for you its pretty easy to get started with Ruby on your own: https://play.google.com/store/apps/details?id=com.sololearn https://www.tutorialspoint.com/ruby/ https://ruby-doc.org/ Some useful books: The Well Grounded Rubyist 1, 2 and 3
Whoa. Last time I looked into Ruby game dev (many years ago), DragonRuby Game Toolkit did not exist, but it's exactly what I wanted!
The way to do that is part it into a gist https://gist.github.com/discover and link the gist.
Isn't 1.9 EOL?
Totally agree with everything on here. Great info for OP!
&gt;Now in the case of simple booleans, true | false is identical to true || false, but it's generally proper form to use || instead. Not quite. Single | does not evaluate eagerly, meaning if you have false | true | false, all three statements are evaluated by the interpreter whereas if you have false || true || false, only the first two statements are evaluated (it terminates immediately on the true). Initially this doesn't seem like a big distinction because both sets of statements evaluate to true but if you are calling methods that return booleans then you would be doing something different. Say you have foo?(false) | foo?(true) | bar?(false) | bar?(true), all four of those method calls will be executed regardless of the return values of each of the methods.
That's cool, I didn't know that.
Many years ago they used to host ruby gems. You needed to require them like `{github-account}-{repo-name}`. Then Github decided they didn't want to do that anymore. Then gemcutter.org showed up that became rubygems.org later. This is pretty great for private lib hosting. Some orgs definitely will be willing to pay for that.
Many (most?) of the Java world seems to be using [bintray.com](https://bintray.com/apache) to host their JARs. The [Gradle](https://gradle.org/) build tool even [comes with a method](https://docs.gradle.org/current/userguide/declaring_repositories.html#sec:declaring_public_repository) to declare this as a source. [Bintray also supports](https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray) npm, Docker, NuGet, etc... Let the battle begin.
&gt;I'd strongly suggest that if you haven't already, you create a public Github page with your work on. QE for several decades now, and I upvote all of this. The absolute best thing to do is pick something that excites you, whether it's testing against your phone or writing software to automate some testing process, find a target you like (whatever website or software you like to use), pick a language that interests you, and go through the process of figuring out how to test it, do it, and commit everything to your github repo. &amp;#x200B; Take the time to polish your documentation skills, from in-line code comments to repo [readme.md](https://readme.md) to anything white papers that describe your process and what you've learned. commit everything to the repo. &amp;#x200B; Do that once and you're already on par with most professionals. Do it several times and you'll be compelling as a hire.
Au contraire, most industries which depend upon computers - my experience is in pure computer science, health and biology tech, and financial tech sectors - have parallel tracks between software engineering and quality engineering, from entry-level through the most senior technical contributors.
Got back to my computer and had a sec to write a quick example: https://gist.github.com/phoenixuprising/eddb71387ae4e4f6080c071e04bdc897
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rust] [Ruby and Rust, sitting in a tree ❤️](https://www.reddit.com/r/rust/comments/bn8ve2/ruby_and_rust_sitting_in_a_tree/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hey thanks! Those locations were I was looking for. I always do \`bundle open\` and insert a breakpoint to see method calls but at this time I didn't even know where to insert it.
Yeah I use \`bundle open\` all the time. It's really useful when you are developing a gem for rails app. But this time around, I didn't even know where to insert a breakpoint.
OTOH I always found publishing to Bintray excessively complicated. Maybe Github will offer proper tool support
for me personally: Eloquent Ruby and Metaprogramming Ruby where the two books that helped me the most.
Well, artifactory support is atrocious, so if I can RIP that out and replace it with this, I'm in.
Regex for All Caps with question mark should be higher in case/when than the one with question mark only. The general idea is that you go top to bottom from the more specific cases to less specific ones.
https://www.amazon.com/exec/obidos/ASIN/0321721330/zenruby-20/ref=nosim/
Hi, it look a good books, have you read it?. A frind of mine has read 99bottles-sandi metz. If you read that which one do you recommend?
This gets asked as lot. The thing people that don't realise is that the major benefits from a JIT are when you compile the code dependent on the current environment. That's where the optimisations are. Things like native memory addresses, runtime values like file handles, regular objects, any part of the state of your program or outside environment really, get baked into the compiled code so you don't have to keep looking them up, which is what usually makes Ruby slow. But this fundamentally makes the code non-reusable. A JIT that lets you re-use the code across process would be a very limited JIT. So the answer is yes, but it would likely not be a productive thing to do because you'd have to hobble the JIT to do it. (PhD in JIT compiling Ruby.)
&gt; Not really looking for a solution so much as wondering if regex is the way to go here. From what you've told us, no. &gt; I can ask it a question in all caps but it will still reply with 'sure' when it was supposed to tell me to relax I don't see "relax" anywhere in the provided code.
Is there a reason you're using the .each_with_index method, rather than .each? Since you don't seem to be using the index in the loop. It looks fine and fairly straightforward to me, not sure what else you'd need
%w[a e I o u].each_with_object({}){|e, h| h[e] = 1} # =&gt; { "a" =&gt; 1, "e" =&gt; 1, "i" =&gt; 1, "o" =&gt; 1, "u" =&gt; 1} You should make a new instance for each value of the hash.
You can do this: a = ["a", "e", "i", "o", "u"] def transform_array(ar, ind) ar.map do |v| [v, ind] end.to_h end puts transform_array(a, 1) # {"a"=&gt;1, "e"=&gt;1, "i"=&gt;1, "o"=&gt;1, "u"=&gt;1}
What kind of tutorials are you looking for?
I think most people wouldn't use the pg gem directly, especially if new to ruby. you can look at the documentation for the pg gem: [https://bitbucket.org/ged/ruby-pg/wiki/Home](https://bitbucket.org/ged/ruby-pg/wiki/Home) you will need to create the postgres database, and know a fair bit of sql: create tables (with fields) and then query them, also insert data etc. sounds like a lot but actually using a rails app makes it so much simpler, e.g. \- git clone [https://github.com/localhostdotdev/bug](https://github.com/localhostdotdev/bug) \- cd bug \- bundle install \- rails g model User name email \- rails db:migrate \- rails console \- User.create(name: "you", email: ["an@email.com](mailto:"an@email.com)") \- User.all \- etc.
array.zip(Array.new(array.size).fill(num)).to_h This is my best golf. Create a new array that’s the same size as your input array. Fill it with the number. Zip the two arrays together. Can’t remember if you actually need the to_h or f zip does it for you.
It's super simple. %w(a e i o u).each_with_object(1).to_h
When conditions are evaluated in order. Also: your response=nil and .to_s are both unnecessary, and your regexes don't meet the described requirement. &gt; Reddit formatting was weird my code is actually indented Four spaces.
&gt; I think most people wouldn't use the pg gem directly, especially if new to ruby. Yeah if it was me I would use Sequel gem to interact with the database (I haven't been a ruby dev for a while, so this might be outdated advice).
or `array.each_with_object(number).to_h` for a bit better performance.
That was my first version but I felt the urge to golf 1 character off
Are you totally new to programming or just ruby? If you have programming experience, what's languages and what's your ability level?
Sequel is still the best choice. Newer ORM packages like ROM-rb even use sequel under the hood.
Many ruby shops around. You can become a programmer, tester, devops, etc depending on your type of skills at one of these places that uses ruby.
Rails developer
They have a pretty advanced vim setup I’d assume they are competent and just need a new to ruby but jot new to dev tutorial
Well, ruby is mostly used for web application development. This means you would probably end up using Ruby on Rails in a role which could be full stack development(HTML, CSS/LESS/SASS, Ruby)or back-end development(Rails/Ruby APIs). you could end up doing dev-ops stuff with Ruby scripting(I know a few people who write chef "recipes" in Ruby). Ruby is also a general purpose programming language so really the sky's the limit. This could be command line(CLI) tools for Linux/Unix/Windows/etc to developing GEMs( [www.rubygems.org](https://www.rubygems.org) ) packages for the Ruby ecosystem.
unrelated, but mirin your vim setup
Thanks. Indeed at first I didn't find its own repo..
Thanks. As you said at first I didn't find its repo.
Gems (libraries) in Ruby are normally documented either in the repo, or via RDoc which is auto generated from comments in the source code.
Yes, so instead of describe "Something" do it "does something" do (1 + 1).must_equal 2 end end I use describe "Something" do it "does something" do assert_equal 2, 1 + 1 end end I even set `ENV["MT_NO_EXPECTATIONS"] = "1"` before requiring Minitest to avoid the `must_*` monkey patches.
I've just been lazy and wrote bash scripts for any automation I've had to do in the past. I've written in C, Python and PHP before however wasn't much past rewriting existing code and patching. I'm a sys admin by trade and just felt it would be helpful to have some Ruby experience under my belt. The main purpose would be SQL jobs mainly using postgres.
Not outdated. Sequel is still the best and most complete library to interact with the database. ROM is nice when you want to create objects from your database record (a bit like ActiveRecord, but using repository pattern), but Sequel still wins (for me) for working with raw data.
My path back when I was a rubyist was; &amp;#x200B; * Try (and fail at) learning rails * Realise that the problem was that I didn't know ruby * Read this book -&gt; [https://www.apress.com/gp/book/9781430223634](https://www.apress.com/gp/book/9781430223634) * Succeed at learning rails * Read this book -&gt; [https://www.amazon.co.uk/Design-Patterns-Ruby-Addison-Wesley-Professional/dp/0321490452](https://www.amazon.co.uk/Design-Patterns-Ruby-Addison-Wesley-Professional/dp/0321490452) * Watched pretty much every Railscast -&gt; [http://railscasts.com/](http://railscasts.com/) * Built some stuff and put it on the internet \^\^ this all took around 4 months. Went on to be a ruby/rails dev for 5 years.
Thanks for the great answer. Isn't there some intermediate metadata of some sort that could be persisted to make the JIT kick off faster though? I haven't tested MJIT on our app yet because we found a few showstopper bugs in 2.6.3, but I'll likely look into it later this year. What worries me before even trying it, is that we're continuously deploying new version of our app. During most of the workday, new version get shipped every 20/30m. Not sure that's a long enough TTL to repay the initial compilation cost (tests will tell).
I've learned from https://pragprog.com/book/ruby/programming-ruby , solid book imho.
are you going to swinburne by any chance?
why?
You're going to get a much better response from this community if you ask specific questions dude. Does the assignment insist you use ruby for this?
sorry this is my first time in this community Yes I need to use ruby and gosu only.
i hope for a AMA :)
Please AMA :)
- there is any plan to make fibers more prevalent and not wait for guild? - when all your libraries will use space :D ? - do you have any status with websockets current implementation? I saw some really nice numbers :) - what is the status with falcon? is ready to replace puma or we need to wait years - any integration with graal/truffle(project loom here is not ready so you will have to wait for this I guess)? - how do you feel the ruby community? - what is the feeling for ruby core devs, regarding all the plethora of languages around? - what is your opinion of using jit + llvm - what ruby needs to become more prevalent? YOU ARE DOING' amazing work to ruby :) I even did a tiny PR to falcon!
I'd be glad to answer specific questions if you have any, but you should really be trying to do this yourself first.
I suspect we go to the same university and I have completed this task so feel free to message me and I can perhaps offer some level of help
&gt; Is there any plan to make fibers more prevalent and not wait for guild? There are [plans to work on `Thread#selector`](https://github.com/ruby/ruby/pull/1870) within JRuby and TruffleRuby. Matz asked for feedback from other core developers. He knows it's important. It can take time to get consensus. However, because most of my work is within user-space, I don't need to wait, and neither do you. You can use [`async`](https://github.com/socketry/async) today, and historically for the past 3 years, it's supported all active versions of MRI, and to a certain extent JRuby and TruffleRuby where possible. I first heard about guild concept around the same time I started working on `async`. I don't actually know if there is a working implementation of guilds yet. I talked about Process and Thread, and the form the basis of the model for parallelism. There are lots of reasons to use one over the other, for example, processes provide isolation, while thread can share resources (e.g. loading code into the VM). There are really two options forward for MRI: - Remove GIL to allow threads to be truly parallel. - Add Guilds to isolate multiple Ruby VMs within a single process. Honestly, I couldn't comment on what option would perform better, but we can already get a feel for it with JRuby and TruffleRuby which don't have the GIL. So, on those systems, guilds won't improve parallelism much. I wish they also have Fiber, but right now we are still waiting on [Project Loom](https://www.baeldung.com/openjdk-project-loom). &gt; Why do all your libraries use space [indentation ]:D? I use tab indentation consistently across over several hundred projects (of different languages). A tab is a tab everywhere, but in my experience, using spaces for indentation is very inconsistent if you cut across all grammars/languages. When I write code to maintain projects, e.g. reformatting or reworking code, tabs are much more predictable. Otherwise, you need to implement some logic to try and guess indentation size. I also use tabs in code presented on my blog, and I'm not a fan of hard wrapping text. Code readability and presentation is very important to me. So many sites (even github) make code impossible to read on mobile devices. With tab indentation, you can easily change tab width based on media queries. That, plus soft wrapping, seems to produce the best experience across the widest range of devices. The same logic applies to my editors too - wide screens, I prefer 4-wide tabs, on my laptop I use 2-wide tabs, etc. Since it's so important, I really wish editors and web-sites would do a better job of code presentation. Having a robust model for indentation is a key factor in this, based on my experience implementing [jQuery.Syntax](https://github.com/ioquatix/jquery-syntax) which is 10 years old. That being said, there are still tons of areas which can be improved. Personally, I only think editors and formatters are scratching the surface of what's possible, e.g. stuff like [code bubbles](https://www.youtube.com/watch?v=PsPX0nElJ0k). &gt; So do you have any status update regarding current WebSockets implementation? I saw some really nice numbers :) I recently sustained 100,000 connected websockets on a single instance of Falcon. It used ~4GB of memory, but recently I reimplemented the low level handler and I think I'm down to about 1/2 or 1/3 of that. I'm still running tests. Honestly, Ruby will never be at the same level as a native C-language implementation. Rack hijack and other concerns add some overheads that are hard to avoid. But, my goal is &lt; 100 allocations per WebSocket connection, which I recently reached: ~80 allocations per connection on average. You can try it out for yourself: https://github.com/socketry/async-websocket/tree/master/examples/chat &gt; What is the status with falcon? is ready to replace puma or we need to wait years? Falcon can replace Puma right now, if you are happy with HTTP/1 application server. I'm personally not happy with just replacing Puma though, I want to replace Nginx too. Like so many Ruby application developers, 90% of my Nginx deployments are just fronting Puma, Passenger and Unicorn. Based on my testing, this organisation is sub-optimal for a variety of reasons: https://github.com/socketry/falcon-benchmark &gt; Any integration with graal/truffle(project loom here is not ready so you will have to wait for this I guess)? The entire ecosystem of `async-*` gems is tested on JRuby and TruffleRuby, e.g. https://travis-ci.org/socketry/async and I try to provide direct feedback e.g. https://github.com/socketry/async/issues/29 - things are improving but it's a lot of work, and I also have to decide what my main focus is going to be. MRI is most important to me right now. But I'm excited to see how the JVM can improve Ruby performance. &gt; How do you feel about the ruby community? My passion is about writing code. I actually don't spend a lot of time in the "community", so my experience might be a bit limited. If I have spare time, I either write code or spend it with my family. That being said, in the situations where I have been involved, my opinion is that the Ruby community is an amazingly diverse slice of Humanity. I love that people get excited about different things. I haven't found any other community as consistently passionate about tackling interesting software engineering problems. When I was at Ruby camps, I saw such a huge range of interests, people trying to solve different problems with Ruby. &gt; What is the feeling for ruby core devs, regarding all the plethora of languages around? I believe that the more languages you can read and write, the better you are as a developer, because you understand the trade-offs and limitations of different approaches. Roughly speaking, the core Ruby dev team is about ~100 people. I'm not sure how many of those are active developers, but if you do some napkin math: 100x 10yr experience = 1000yr+ person-experience years across different languages and systems. Yet, we all still love and use Ruby. Ruby is a mature language which has exceeded critical mass. That happened with Rails around 2013. Since then, people have been polishing various aspects of the language and surrounding eco-system. Ruby is a unique combination of language, infrastructure and community which has not been replicated in other languages. "Programmer Happiness" really underpins the design of `async` and many other aspects of Ruby. When I use other languages, I sometimes wonder if they were optimising for programmer frustration instead. &gt; What is your opinion of using JIT + LLVM? JIT is almost always a good thing if done correctly. The current implementation trades simplicity for efficiency, but the point is to figure out if it is worth investing more effort into it. You can look at the numbers, ignoring the JIT overhead, and ask the question, does compiling Ruby to native code improve performance? The key factors in answering this question are directly tied to how dynamic the language is. Every layer of indirection requires some kind of lookup and this adds overhead. The question then becomes, can the JIT extract enough information to make assumptions about how the code is structured? Even interpreted code can benefit from this approach (e.g. polymorphic inline caches). That being said, Ruby is probably not the right language for heavy CPU bound workloads, and that's okay. &gt; What does ruby need to become more prevalent? Ruby needs to be used more in schools, and it's a great language for education. I have experience teaching both Python and Ruby and I found Ruby was more consistently understood. Kids would make mistakes like `len(string)` and `.upper(string)` because the language an odd separation between "functions" and "methods". In order to do this, people who know Ruby need to work with kids and get them involved in programming with Ruby. I also believe that concurrency is a big issue facing languages right now. Languages like Swift which debuted without a good model for concurrency, or Rust which is only just finalising what level of async/await hell they want to reside on, C++ which is still trying to figure out whether to expose coroutines and how many template arguments it should take, Java which has implemented about 10 different ways to do callbacks, all of them cumbersome to use. If we can nail concurrency for Ruby, it will be very appealing to software engineers and businesses who want to build scalable applications. &gt; YOU ARE DOING amazing work to ruby :) I even did a tiny PR to falcon! Thanks, I appreciate your efforts too!
&gt; Isn't there some intermediate metadata of some sort that could be persisted to make the JIT kick off faster though? Maybe we could persist the parsed bytecode from the source code. That wouldn't be JIT-specific - if it worked it'd work for the interpreter as well. But Rubinius tried that and it didn't seem to help much. Could we persist the compiler intermediate representation produced from the bytecode? Maybe. But generating IR from bytecode is trivial. This isn't where the problem is. Any level of representation beyond that is process-specific, for the reasons already described. And this is where the real work of the JIT gets done. If we wanted the JIT to work faster I'd suggest a simpler, first tier JIT that runs until the real JIT can get time to run. But! Ruby's language and ecosystem means that Ruby fundamentally has a kind of ice-hockey-stick shape of optimisation. Doing a little bit of optimisation gets you no result. You have to do a ton of optimisation, and then you suddenly get a good performance result. So a first-tier JIT to run quickly would likely not produce code that's really any faster than the interpreter so what's the point? Basically - nobody knows how to do what you're asking effectively. Lots of very well resourced companies working on the JVM for example have not managed anything useful in this area either. It seems unlikely Ruby will come up with anything without some really big new ideas.
&gt; I recently sustained 100,000 connected websockets on a single instance of Falcon. It used ~4GB of memory, but recently I reimplemented the low level handler and I think I'm down to about 1/2 or 1/3 of that. That sounds really good! It would be very interesting to compare performance versus ActionCable/[AnyCable](https://github.com/anycable/anycable)/[Iodine](https://github.com/boazsegev/iodine)/[Agoo](https://github.com/ohler55/agoo) (especially ActionCable).
&gt; Maybe we could persist the parsed bytecode from the source code. That wouldn't be JIT-specific - if it worked it'd work for the interpreter as well. Yeah, `bootsnap` already does that. &gt; Basically - nobody knows how to do what you're asking effectively Yeah I figured as much. Thanks for the answer though.
I’m really looking forward to this. Anything that makes my code safer is OK in my book!
I just wanted to give you a big thanks for your thoughtful answers. It was interesting to read. Your note about falcon and nginx resonated well: when I was first learning Ruby, I had a really hard time understanding the separation of using a web server and an app server, and I think it would be great to simplify that model. Good luck!
Rails is all about a sliding scale.between configuration and convenience. Rails is super powerful in its ability to generate and scaffold apps for you with even one command you can have a RESTful routed site. But the real power of rails lies in a happy medium in between what you're doing (configuration end of spectrum) and the scaffold generator (convenience end of spectrum). I suggest looking I to resources about how environments are set up in rails. You can even begin a new rails project automatically set up for postgres using an option in the rails new command.
Same thought on Web and App Server. It was only a few days ago some new Ruby Rails developer asked the question, why do we have Puma AND Nginx? It is like one of THE most common question, you then started the usual explanation which you have been giving for the past X years. Or some might even get fed up and tell those people to RTFM. &amp;#x200B; And then all of a sudden Falcon popped up in my head, I read about how we really shouldn't need Nginx in the setup. Then I thought these beginner's question aren't really dump, or ignorance ( Sorry for the lack of better word to describe ) , it is that we are trapped into the current mind set we need Nginx. &amp;#x200B; I suspect you will still need some Web Server if you are Github or Shopify, but something like Basecamp or Discourse could be working with just Falcon.
&gt;When I use other languages, I sometimes wonder if they were optimising for programmer frustration instead. ROFL. That made my day. Thank You. Questions. 1. Have you spoken to any Rails Core in RubyKaigi? I suppose the only way for wide adoption would be Rails using Fibre. 2. Just out of a matter of interest, What do you use Ruby for? Rails? Sinatra? Or something else? 3. Have you looked at Crystal ( [https://crystal-lang.org](https://crystal-lang.org) )? What do you think of it? And they uses fibre as their concurrency model. And again, Thank you for your amazing work.
I’m not a fan of how this looks. I’d rather have real type hinting, similar to what Python is doing.
There was an article posted on this subreddit a couple of months ago on this subject, here's the link: https://thesmartnik.com/about-ruby-certification.html
Has someone mentioned [Crystal](https://crystal-lang.org/) yet? :)
Nice!, I hope they'll upload the Matz presentations with English subtitles as well!
Anything implemented directly in C is going to have an easier time scaling up. I think you can expect Ruby to be about 10x to 100x slower than native compiled languages. There has been some discussion about implementing ActionCable with `async`: https://github.com/rails/rails/issues/35657 Regarding benchmarking them all, maybe we could do something similar to the falcon-benchmark.
Totally agree, we are trapped with Nginx way of deployment/thinking. Yes, new users often ask the most insightful questions. You should always listen to them! They challenge our assumptions. On the one hand, Nginx is a great server, a known good quantity (i.e. battle tested). But it does add both latency and complexity to any application that really shouldn't be necessary by default. Also, Nginx will probably never support HTTP/2 natively in the reverse proxy, which is a limitation. I feel like this affects the entire way of thinking around Ruby web applications: WebSockets, SSE, bi-directional streaming, push promises, etc.
May I suggest you accessing the DB through this gem instead: [sequel](http://sequel.jeremyevans.net/) ?
&gt; Have you spoken to any Rails Core in RubyKaigi? Yes, but one thing I found out is that my ideas about Fiber is not new. It was tried before, and I wanted to understand why it failed. I think there were two main reasons: - Lack of compelling infrastructure/eco-system. - Lack of awareness and education. &gt; I suppose the only way for wide adoption would be Rails using Fibre. Actually, Rails works out of the box with Falcon, no changes are required. But you can use, for example, the `async-postgres` adapter to improve concurrency. Sure, it would help if more people were on board, but I don't blame them for reserving their judgement. The best way to convince these people is objective benchmarks and amazing functionality. People who jump on that bandwagon will build amazing systems. That's already happening and I find it very exciting. &gt; Just out of a matter of interest, What do you use Ruby for? Rails? Sinatra? Or something else? I use Ruby as a general purpose scripting language and for prototyping ideas. For web applications and web sites I use https://github.com/ioquatix/utopia I also created https://teapot.nz which is a package manager and build tool for C/C++ (or any language actually, it's completely generic). I really choose between two languages for any project: C++ if performance or interfacing with existing native code is required, Ruby for everything else. Sometimes specific projects require a language, e.g. scripting Blender requires Python. &gt; Have you looked at Crystal (https://crystal-lang.org)? What do you think of it? And they uses fibre as their concurrency model. Yes I am familiar with Crystal. It looks like a great language in many ways. Sometimes it's nice to start fresh. That being said, it will take time for it to be accepted and gain critical mass. The question you have to ask is, what problem are they solving? Fiber for concurrency is a good model and I'm happy they adopted it. `libevent` might not be the best solution. There are interesting things happening e.g. `liburing` which will be a game changer for concurrency.
[removed]
Only every single time something about Sorbet is mentioned.
pw = gets&amp;.chomp
No.
Crystal will be a viable alternative for these purposes when a 100Kloc legacy Rails app can be compiled using the Crystal compiler with no changes (or only changes made by an automated tool).
:(
I will admit I'm scared of fiber/evented base servers, after bad experiences in the past. The falcon docs say: &gt; It uses one Fiber per request, which yields in the presence of blocking IO. But you also list: &gt; Asynchronous Postgres and MySQL database adapters for ActiveRecord in async-postgres and async-mysql. Is it always context swapping on IO due to lower-level hooks, so it can context-swap on DB access already? What additional benefit would asynchronous adapters at the higher levels add -- that is, what are we missing without them? Or without those adapters, is it not in fact context-swapping on IO waits for DB access? (DB access is the most common IO wait in a typical Rails app, of course).
&gt; I will admit I'm scared of fiber/evented base servers, after bad experiences in the past. Maybe you can elaborate on that for me? &gt; Is it always context swapping on IO due to lower-level hooks, so it can context-swap on DB access already? So, you are thinking about the right issues here. But let me clear something up for you: these opaque C libraries don't become magically asynchronous just because we have non-blocking I/O in Ruby land. In the case of Postgres, [there are specific C functions you must use to handle non-blocking database queries](https://github.com/socketry/async-postgres/blob/93695ea656260efd3dc67a225da86b7941c5ef54/lib/async/postgres/connection.rb#L54-L68), and in the case of MySQL, [it isn't even available yet in a way I can easily consume](https://github.com/brianmario/mysql2/issues/1034). &gt; Or without those adapters, is it not in fact context-swapping on IO waits for DB access? (DB access is a very common (the most common?) IO wait in a typical Rails app, of course). Yes, that's correct and everything else being equal, you end up with about the same performance as Puma.
Does anyone use it? Honest question because I’ve always been really interested in isomorphic client-server apps, but it’s never panned out it seems like.
`gets` will return whatever the user has typed in, including the line break at the end of the string. `chomp` will remove this final line break, hence `gets.chomp` will return whatever the user has typed in without the line break. An alternative would be to test for a string including the line break, eg `if lg == "admin\n"`.
\`source [utils.sh](https://utils.sh); function1\`
I second this question :)
&gt; Also, Nginx will probably never support HTTP/2 natively in the reverse proxy... I think it will, as a paid feature. What bothers me is how unquestioning audiences are towards the nginx choice, specially since new features are half-implemented in the free version so that they can sell the full features in the paid version. HTTP/2 support is a good example: last time I checked, nginx disabled HPACK's dynamic table, didn't implement prioritization, and didn't implement server push, and as far as I know, only the last one has made it to the free version since.
I'm also interesting in learning more from people using it. One interesting thing I saw is [https://hyperstack.org/](https://hyperstack.org/).
For creating simple programs with not much logic, it is extremely good, like a weather app. For something advanced, use Ruby/GTK
Well I don't think compatibility with existing Ruby codebases has been or ever will be a goal of Crystal. It can still be viable without that, and Sorbet fulfills a different need from Crystal.
It's in production on several sites I worked on, the setup we used was not isomorphic except for some haml templates we were able to share and rerender on the frontend with updated data (see opal-haml) and some presenter classes. Those sites were very popular with several milions page-views per month and really performant. The people behind hyperstack have code in production as well. The same goes I think for Clearwater and Inesita (which are other opal-based frameworks).
Slides here: http://code.jeremyevans.net/presentations/rubykaigi2019/index.html#1 Really interesting performance improvement approaches I haven't seen elsewhere. Also explains some of the unusual implementation choices in Sequel, like why methods are split out into different modules.
That was somewhat my point. They fill very different niches, so the fact Crystal always comes up is a bit ridiculous - yes, it's plausible that a significant rewrite in a different language would improve a legacy codebase, and for greenfield work it might be the perfect tool, but when the problem is a huge existing tarball of decidedly-not-type-safe code that's not a practical solution. Doesn't mean Crystal isn't viable _in and of itself_ but it's definitely not a viable alternative to Sorbet for the core use case of getting existing Ruby codebases under control.
Gotcha, we actually totally agree then!
It's just what i linked to, I don't believe the documentation on that method changes signficantly going forward. If it does, oops!
Why are you using the safe navigation operator here? I can't seem to find a way where gets would return null
&gt; Maybe you can elaborate on that for me? Well, needing lots of libraries to be rewritten to accomodate. I understand you have a new approach that needs _less_ specialty stuff. But apparently still rewriting? I know a thing or two about this area, but pretty much just enough to know what questions to ask, I'm not an expert in this stuff, I am really just trying to get a handle on what is available _now_ in falcon, and what performance characteristics to expect. Are you saying that without the yet-to-be-done rewrite of (eg) postgres adapter, a falcon 'worker' can _not_ switch out on a db IO call, it will keep the processor (with other falcon workers waiting to do work blocked waiting for it to finish) basically until it completes? But that nonetheless, falcon performs about the same as puma? Even though puma _can_ switch out (thread-based, rather than fiber-based) workers when they are blocked on db (or any) IO? The ability to multi-task workers swapping them out as they are waiting on IO just ends up not actually benefiting performance, or not enough to outweigh other concerns? This is somewhat surprising to me. I wonder if it may depend on the nature of the workload (how much IO or specifically db IO), or possibly the nature of 'performance'. Without the pre-emptive multi-tasking a thread-based approach can provide, I'd expect at least more _uneven_ performance under heavy load, where if lots of requests become queued, the later ones end up waiting a lot longer than they would with preemptive thread-based multi-tasking (and earlier requests finish a lot quicker), even if the statistical aggregate averages are about the same. For a load with very slow responses (say, it is waiting 500ms+ on the db, a misbehaving workload to be sure), I'd expect that could become noticeably problematic, where for example over-simplified 4 requests that come in 'at once' might take 500ms, 1000ms, 1500ms, 2000ms to return, instead them all taking about about, say, 1000ms under a puma-style scheduling regime.
There was a mistake not calling Opal 1.0 a couple or more years ago to be honest. This project has been at 1.0 quality level all of this time and it could be argued that we're now at Opal 2.0. Opal is amazing and yes, dig in and enjoy this in every production environment you want to try it on. Also have a look at [Hyperstack](https://hyperstack.org/) and jump into the Slack room (a new site is nearing completion): [https://hyperstack.org/slack-invite](https://hyperstack.org/slack-invite) &amp;#x200B; Also, please feel free to encourage core Rails to adopt Opal (I guess DHH doesn't recall the chat we had about Ember before and the thread is gone now for some reason): [https://twitter.com/ylluminate/status/1121814141105258496](https://twitter.com/ylluminate/status/1121814141105258496)
Thank goodness. Opal has really been at a 1.0 for years now and one could arguably call this 2.0. It's definitely a great option and frankly may be the only viable option for Ruby in browser as, after a lot of digging, research and talking, WASM may never really handle Ruby "properly." To this end it would very much behoove the entire Ruby community to get behind Opal and really show the world just how great universal Ruby really can be.
Will it be possible to have "duck types", basically an 'interface' that the implementing class does not declare itself to implement, but is checked at runtime?
I have several apps (one big example is [CatPrint](https://www.catprint.com/home)) that have been using it in production for 3 years now with hyperstack, even from way back when it was react.rb and reactive-record. 99% of the UI code is hyperstack + Opal. Honestly, it really has felt like a 1.0 release ever since we started back then; I can only think of one or two bugs that I've come across that entire time. &amp;#x200B; It just feels really good writing all my code in Ruby, any time I've had to go and write JavaScript it feels like such a chore. I really highly recommend using Opal!
Awesome! Great to hear :) Do you have luck experience with it?
I have used it in production in several sites myself and have seen it used by many others in the community. Honestly, 1.0 is a bit of a misnomer because it's been at 1.0 quality for at least 4-5 years now. This is more like 2.0, as /u/ylluminate said. &gt; it’s never panned out it seems like. Well, it sure has panned out for me and my team as well as many others. It's our go-to solution for almost anything JavaScript-related and its stability and support is absolutely rock-solid at this point. You simply cannot go wrong with Opal. The *only* issue it ever had was some unfortunate and ridiculous drama that occurred 4 years ago. But the project not only survived, but has continued to grow and the only people who still care about said drama have way too much free time on their hands.
I think the pragma is default behavior in ruby 3. At least back in 2.4 that was the plan.
In the first place I should have said gets(chomp: true). IO#gets returns nil to /x1A.
What does it do?
Perhaps in Ruby 4
how to do long key presses in apple script though
Mostly file inclusion (with some fanciness) for markdown files, which GitHub has consistently refused to implement.
What exactly would be the issues of compiling Ruby to wasm?
[http://rubykoans.com/](http://rubykoans.com/) are pretty good
?
Originally created by Why the lucky stiff. He is like the artist who use Ruby as a paint brush. His other works, Why’s poignant guide to ruby, is very interesting, too. You can check it out here https://poignant.guide
Why could not WASM handle mruby or similar?
Feedi turns feed data into a fantastic API. Feedi simplifies how you handle RSS, Atom, or JSON feeds. You can add and keep track of your favourite feed data with a simple and clean REST API. All entries are enriched by Machine Learning and Semantic engines.
Thanks
Congrats!
It's in there but the syntax is an even greater horror show than the rest of it. https://sorbet.org/docs/abstract
You can run falcon with the same multi-process multi-thread hybrid model as puma. But if you use concurrency aware libraries you can generally get better scalability using just one thread per process.
If you have any questions while working with it, let me know. I can help you out. One thing I can say if you are working with GTK, you will also need to learn to use Glade. Development would become much faster. You can also work with VisualRuby. It's like bootstrap for GTK. But I will suggest first to learn GTK and Glade, then jump to VisualRuby.
This is a great overview of the conference. Got it in my head that I should go next year!
No not without JavaScript, but without writing your own polling JavaScript code
Good catch. I was not even considering early termination, just the return value, under the assumption the somethingWin? methods were idempotent. That also makes a good case for using logical instead of bitwise or.
I'm pretty sure, I've used `rake db:prepare` since at least v3. What's new here?
I think this belongs in /r/rails
How does this differ from Jekyll + GitHub Pages?
Rails HTML polling with javascript written by someone else
&gt;WASM may never really handle Ruby "properly." can you elaborate?
Super interested. I remember time ago I experimented with JRuby and a Java 3D Engine, but I cannot remember the name. I'll try to spread the word about this.
"without readable javascript"
[Ruby Koans](http://www.rubykoans.com/)
I think this is the intended link: [https://www.youtube.com/watch?list=PLoGBNJiQoqRDJvwOYLuu7jnprRKhuc7Cp&amp;v=bf5pQVgux3c](https://www.youtube.com/watch?list=PLoGBNJiQoqRDJvwOYLuu7jnprRKhuc7Cp&amp;v=bf5pQVgux3c)
That is `db:test:prepare`, not the same task.
Fair enough! I think you're right about `while`, and generally you should be ok... but I just ran into something the other day though where, in 1.9 they were positional parameters and in 2.5 they were named, so I was getting non-obvious errors...
I'm honestly having trouble what the thing you linked to actually does from the examples/docs, on a quick skim. I'm not totally confident it's what I'm talking about... does the implementing thing have to _declare_ it implements the "abstract class or interface"? If so, that's not "duck typing". "Duck typing" would require _recognizing_ that it has the methods you require (as defined in some interface), without the implementing class, at the time it was written, being aware of that interface and what it requires. It's possible if I spent more time with the doc I'd be able to understand what it's talking about (or more likely installing sorbet and playing with it, which I haven't). To be fair, it does say "TODO: This page is still a fragment. Contributions welcome!"
I can give you some pry guidelines from the first ruby project I ever made!
Came here to say this. Misleading title. &gt; This snippet will load the JavaScript code for us so that we don’t have to write it ourselves. OK, that's not without Javascript. More accurate title might be "Rails HTML polling with the render_async gem".
As far as I can tell it's a nominal type system so no duck typing. Why structural typing wouldn't be included for a language like Ruby is pretty confusing...
It’s in Fukuoka next year. Easily one of the coolest cities in Japan. I highly recommend going.
It's the basic principle of 'typing' in Ruby! People are always saying "typing in ruby is duck typing". PLUS, it's actually pretty straightforward to implement in a runtime-checked system like the one here.
It was in Fukuoka this year - it's in Matsumoto next year.
Yep, it's explained in the article in details. It feels like there's no JavaScript since you don't need to write it :)
Oops. You’re right. Was looking at the wrong year. Nagano is an awesome place too.
Indeed.
I've mentioned this book a few times, but I'd give David Black's The Well-Grounded Rubyist a look.
You'll still need to debug it.
Did not know about `-"foo"`, cool
&gt;Metaprogramming Hi, thanks. I'll read thoose.
thanks
Ruby meetups are also a great source for all skill levels :)
Imagine a science experiment, where you have one variable and many controls. The practice described by the article is analogous to deliberately introducing variability (via randomness) to controls. I'd strongly recommend that teams avoid this approach, for the same reasons scientists would lose their research grants if they made the same mistake. The lesson that should have been learned by the team is that daylight savings ought to have been considered during the product design sessions. I want to add a word about this commentary, as well: &gt; As important as tests are to me, I don’t give as much attention to tests as I give to production code… In my reviews, I tend to have lower standards when looking at the tests. If something is worth doing, it's worth doing well. It doesn't serve teams in the long run to lower the bar for tests.
Sandi's book is fantastic. It tells a lot about refractory and ways of doing that by making your code understandable and simple for anyone. It embrace a lot of OO knowledge using a very simple exercise, the 99 bottles of beer on the wall. The read is very smooth, colloquial and easy to read. I don't say that will expand your full understand of ruby, but for sure will improve your life as a OO programmer. Fully recommended it. For more useful reviews: https://www.goodreads.com/review/show/1707492301
That's true
idk what y’all are saying this still saves me time and effort
I've changed the title a little bit
"A curated list of awesome things related to Ruby on Rails (recent changes were inspired by awesome-vue)" https://github.com/ekremkaraca/awesome-rails
&gt;If something is worth doing, it's worth doing well. It doesn't serve teams in the long run to lower the bar for tests. I agree with you, I'm just sharing one weakness that I observe, at least in myself. I didn't mean to say it was a good practice, apologies if I wasn't clear on this. &amp;#x200B; &gt;The lesson that should have been learned by the team is that daylight savings ought to have been considered during the product design sessions. The point of the article is more about finding issues in general, exploring the various states of the domain. If we could know what we're currently forgetting, work would be much easier! &amp;#x200B; &gt;Had the team spotted the daylight savings edge case upfront Not this time, nope! &amp;#x200B; &gt;Would they have even been able to ascertain definitively whether the randomized test scenarios shown at the end of the article actually covered DST? I think so, yes. After some random generations, the DST situation arises pretty fast. &amp;#x200B; &gt;Imagine a science experiment, where you have one variable and many controls. The practice described by the article is analogous to deliberately introducing variability (via randomness) to controls. I'd strongly recommend that teams avoid this approach, for the same reasons scientists would lose their research grants if they made the same mistake. An interesting remark, thank you. I guess I want a science experiment to produce a result, or let's say a model, that is as generic as possible. To get there, my opinion would be to slowly release as many controls as possible and test the results against the hypothesis and against the model to ensure it is still valid. I'm not a scientist at all so I may be off here. I will be interested if you could elaborate on this, if you find the time and willingness to do so, it would be welcomed!
Going through [https://exercism.io/](https://exercism.io/) was a huge growth in my knowledge of syntax.
I don't follow the science experiment analogy. Property-based testing is not a corruption of the scientific method, it's more a way to perform a battery of experiments - within specified parameters - as a way of teasing out unknown lurking variables. Do you object to RSpec's randomization of test order as well on the same grounds? Saying effectively "you should've thought harder" after a defect appears is easy to do with hindsight, but not very kind or productive. If bugs could be reliably caught by just "thinking harder" than what's the point of writing tests in the first place? At the end of the day tests cannot prove the correctness of a program, they can only disprove correctness. We're throwing little falsification darts at an infinitely-large dartboard (program space) to do that. Property-based tests, mutation tests, fuzzers, these all rely on some randomness but they help us throw sheaves of darts at areas of the dartboard we may not have even seen before. I think they're quite valuable techniques with proven track records and I strongly recommend that teams use them.
Ah, yep, can definitely see how that might lead to confusion.
Wow! Some awesome resources! I’ll have to check both out. Thank you for sharing :)
Awesome! Oh and he made that? He’s got a unique way of using Ruby.
If I’m newcomer to Ruby would you recommend I start with Shoes? I just looked into GTK with Glade, it looks awesome! I love how everything is visual allowing for some quick UI development. Do you have much experience with GTK + Glade? Also, how about Rails? Do they offer a feature that allows to create user interfaces?
[https://github.com/blacktm/ruby-wasm](https://github.com/blacktm/ruby-wasm) I'm not sure I agree that WASM could not handle ruby properly. I think the issues would be that you have to get the tool chain all working properly and interoperating between the WASM runtime environment and the development station. However compiling to JS instead of WASM has some advantages anyway: * You have full interoperability with other JS code, and the DOM * Things like source maps work, so you can set break points right in Ruby code etc. * The JS code is not beautiful, but is readable which makes debugging sometimes easier. * Hot loading works - i.e. change a ruby file and its instantly recompiled and patched into existing code. It will take a bit of work I think to get a WASM tool chain to work like that - possible but just more work. All of the above could probably be fixed by tooling, but atm I think its a lot of work. Meanwhile its not clear that a WASM implementation would be faster. Why? Because you are going to be hosting the ruby VM running ontop of WASM. But with Opal you have translated the Ruby code to JS, so you get the full benefit of the JS JIT compiler. FYI The opal project I believe started before WASM was generally available.
I don't think the article is describing property based testing, it's describing something that seems _inspired_ by property based testing. I could be wrong, but the author referenced property based testing tools that they explicitly didn't use. &gt; Do you object to RSpec's randomization of test order as well on the same grounds? Randomizing test ordering is a countermeasure for irresponsible use of global state. Test Bench doesn't randomize test ordering, because all of us who use it don't write tests or code that depends on global state. But I don't _object_ to test order randomization, per se. I think it's a separate deal than suggesting randomizing values could have caught an edge case sooner. &gt; Saying effectively "you should've thought harder" after a defect appears is easy to do with hindsight, but not very kind or productive. If bugs could be reliably caught by just "thinking harder" than what's the point of writing tests in the first place? I didn't say that at all. The ideal would have been to consider the edge case of DST in the first place. The next best thing was to identify the gap and close it, which the team apparently did. The fact remains that handling DST (3 days during a 24-hour period) is an inherent characteristic of the domain. The final result of the test at the end of the article obscures that scenario completely. &gt; I think they're quite valuable techniques with proven track records and I strongly recommend that teams use them. I'm not raising an issue with property based testing. I'm raising an issue with relying _less_ on unit testing because of the presence of property based testing.
&gt; I agree with you, I'm just sharing one weakness that I observe, at least in myself. I didn't mean to say it was a good practice, apologies if I wasn't clear on this. I'm evaluating the material under the assumption that your intent is to reach and influence the community, so I'm bringing more scrutiny to bear than I would in an informal discussion. I realize now you were being open about a weakness -- I didn't get that from the article itself. Sorry for that. &gt; I think so, yes. After some random generations, the DST situation arises pretty fast. That isn't what I meant, though. If at any point in time, a developer asks, "does this code handle a 24-hour period with three days due to DST?" there is no longer any single test that obviously covers that edge case. You have to infer the answer by studying the tests in agonizing detail, and you would naturally wind up with less confidence in the tests. &gt; I will be interested if you could elaborate on this, if you find the time and willingness to do so, it would be welcomed! I didn't mean any more than what I said -- a science experiment must be precisely repeatable because all variables are precisely controlled. A unit test shouldn't throw random data around in the hopes that eventually it'll uncover an edge case. Property-based testing is also precisely repeatable, but the "experiment" itself is run for the entire range of values for every property.
Last time I looked at Opal it was really heavy. Has it slimmed-down in the last couple of years?
Probably not, although you can certainly minimize which parts of the ruby standard library you need. But of course you are getting a lot of power from the libraries, and thus you are probably saving having to manually write a bunch of JS code anyway.
I'm not sure you need the full Ruby VM in order to run most of Ruby, although you could probably have to load an extra module/gem to load the Ruby compiler in order to run thinkgs like \`eval\`, kind of what mruby already does.
* Why link to this spammy website instead of the [original article](https://dev.to/molly_struve/level-up-your-ruby-skillz-working-with-hashes-4bid)? * This reads like someone who wrote a blog page about the [Hash docs](https://ruby-doc.org/core-2.5.1/Hash.html). It's a mostly fine explanation of the various different methods. But I don't feel like I've "levelled up my 'skillz'"... E.g.: how about saying something about using `map` in ruby &lt; 2.5 in place of `transform_keys` and `transform_values`. Also, I can't articulate why but this is really bugging me... first we say "a hash is": { a: 1, b: 2, c: 3 } and then hashes can be more, but one of the examples: # Symbol Keys (Hashrocket notation) { :a =&gt; 1, :b =&gt; 2, :c =&gt; 3 } is the same thing but using outdated syntax... it's not really "more"... I dunno, maybe I'm being unnecessarily nit-picky.
The doc for [exec](http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-exec) says &gt; This behavior is modified by env and options. See spawn for details. The doc for [spawn](http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-spawn) gives the details. &gt; spawn has bunch of options to specify process attributes: &gt; env: hash name =&gt; val : set the environment variable name =&gt; nil : unset the environment variable It also gives an example. &gt; If a hash is given as env, the environment is updated by env before exec(2) in the child process. If a pair in env has nil as the value, the variable is deleted. &gt; # set FOO as BAR and unset BAZ. pid = spawn({"FOO"=&gt;"BAR", "BAZ"=&gt;nil}, command)
you could use the `env` command too, e.g. ``` `env A=1 rake something` ```
It's really never been markedly heavy over the last few years. It's definitely on par with native JS performance - since it's JS. There were some glitches maybe 3-5 years ago where it was generating some inefficient code that was resolved.
There’s a rubocop plugin for vscode that can autoformat. Not at my laptop but if you respond I’ll find out which one it is. Mind you that it’s pretty slow though, not the smooth experience that is prettier. Rubocop CLI has an autofixer option as well!
Rubocop has an auto-corrector built in: `rubocop --autocorrect`, or `rubocop -a` for short. Configure your chosen editor to run `rubocop -a` on save. (Almost?) all popular editors already have a plugin to do this, and more.
The docs of `exec` and `system` tell you to look at the docs for `spawn` for details on the `env` and `options` params. These docs have all the info you should need: https://ruby-doc.org/core-2.6.3/Kernel.html#method-i-spawn
Cool. I'll definitely try these out.
Not a vscode user, but if `rubocop -a` is quick to start from the command line then you could probably tweak the plugin to reduce the number of files inspected to speed it up (e.g. look at git diff to only run on changed files)
you can have rubocop already loaded in the background to make it faster, there is gem for that i saw a month ago or something
There’s also a ruby plugin for prettier if you don’t mind running your ruby formatter in nodejs.
Some folk do a git pre-commit hook to ensure lints are appeased. [Here's one example](https://blog.dnsimple.com/2018/06/quick-tips-for-practical-rubocop-workflow/#pre-commit-hook) of that strategy. Alternatively, hook RuboCop into whatever you use to run tests, so `rake` or `rake test` or whatever it is also runs the lints locally. If you use PRs to merge code, there are also GitHub integrations that'll check RuboCop.
Is there nodejs support? Would be cool to be able use nodejs packages to build some wrappers around express, orm using metaprogramming. =&gt; A new web framework with nodejs speed and DRYness of ruby
I like it
If you go beyond scraping a single URL [mechanize](https://github.com/sparklemotion/mechanize) (another Sparkle Motion production) is going to be far more capable than rolling your own.
 Toreman is a one’ish-line shell script [forman](https://github.com/ddollar/foreman) clone that of running everything in the same window runs everything in [tmux](https://github.com/tmux/tmux) panes. &amp;#x200B; With tmux, interleaved output, and interactive debugging are not a problem any more. &amp;#x200B; It’s also possible to selectively stop/restart processes. ## Usage Run toreman, it will parse your Procfile and run each entry in a separate horizontal split. &amp;#x200B; Use C-b h/j to navigate between panes, and C-b z to toggle full-screen zoom. ## Installation If you’re on macOS and are using [Homebrew](https://brew.sh/), it’s as easy as: brew install pirj/homebrew-toreman/toreman
selenium web driver with headless chrome will allow JavaScript execution
You only run it on the file(s) that you've *just saved*. This is independent of git.
If I’m reading this correctly, it won’t work with non-sh compliant shells. The check for `.env` in particular won’t work in fish shell. A few other things: - Tiled layout might work better for wider screens and is probably a better choice in general, to be honest. - I’d grep for `^#` just in case. - If my memory serves me well, `split-window` needs to be run from an existing tmux session, which is not mentioned in the readme. Otherwise, it’s a nice one-liner. Simple, editable, and to the point.
Do people that don't use Heroku use `Procfile`s?
Switched to docker compose here, but we did, at some point.
For local development, yes. Probably even people that use Heroku.
We're using [overcommit](https://github.com/sds/overcommit) for this which is dealing with JS linting and rubocop rules. We also have things to warn us of security issues with our dependencies. It is a pretty simple to use and powerful tool. I both love and hate it, as is with all linters (for me at least). This is what I am mentioning fighting with in my post. I'm looking for something that fixes these issues automatically before I run my pre-commit hooks. And I think the VSCode plugin mentioned in another post just may do the trick! Thanks
I feel like Docker is the better solution but this is interesting.
(My rough translation of the question and Matz's answer) &gt; **Q:** If you create a globally popular programming language, could that lead to a huge financial success? How much money did Mr. Matsumoto make after creating Ruby and making it a successful programming language, for example? &gt; **A:** While I understand why people might be curious about how much money I make, I have no plan to disclose the exact figure. I expect no positive consequence from doing that under the current [economic/social/political] climate in Japan. &gt; That being said, I am employed by two companies, Salesforce.com and NaCl, both of which allow me to work on Ruby on a full-time basis. In addition, I provide consultation services to several companies, and give lectures and write articles for a fee. All of this gives me a comfortable amount of income for a *salary-man* programmer to expect. &gt; However, it is unrealistic [for someone like me] to have 'a huge financial success' through a main salary and side jobs. If you want that to happen, you will [instead/in addition] want to seek opportunities with equity package.
Thanks! A very wise answer :)
\&gt; Check out overmind if you prefer 1600 lines of Go over one line of shell script lol
https://jp.quora.com/profile/Yukihiro-Matsumoto has answered a lot of questions related to Ruby and programming languages in Japanese. Incidentally, it looks like Quora is pouring resources to Japan right now [with a focus on Ruby](https://jp.quora.com/%E6%9C%80%E8%BF%91%E3%81%AEQuora%E6%97%A5%E6%9C%AC%E3%81%AERuby%E8%B3%AA%E5%95%8F%E3%81%AE%E9%9B%86%E4%B8%AD%E6%8A%95%E4%B8%8B%E3%81%AF-%E4%BD%95%E3%82%92%E3%82%81%E3%81%96%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B).
Quora seems to be doing something right. I had always considered them to be that platform where people ask super weird questions for no reason. However, I've actually seen useful info from them come up in multiple searches the last couple of months.
I would actually prefer this since it's already in my toolchain. But my main requirement is that it knows about format from the .rubocop.yml file and from viewing [the repo you're probably referring to](https://github.com/prettier/plugin-ruby), this is not supported.
Anyone else from an ops background and did a weird double-take here?
I have a lot of scraping tools that I use procfiles to help organize startup. I use Docker for a lot of things too, but I felt that in this situation, using a procfile was easier to use. It essentially spins up faktory / sidekiq workers in different configurations.
How big is ruby in Japan? My friend(gaijin) who's in Japan keeps telling me they are hiring gaijin because there's not enough local developers
People like Alan Kay and Matz answer questions on Quora quite often — and this kind of high-level participation is seen on Quora across disciplines and fields. It's amazing. No other platform gets that kind of in-depth interactions without one-off interview invitations, Reddit included.
I heard some nice things about Cookpad.com (top SNS for recipe) which is a big ruby shop. They seemed to have had some issue at the executive level in ... [2016](https://www.japantimes.co.jp/news/2016/05/20/business/corporate-business/cookpads-maverick-founder-stirs-recipe-unrest/), wow I didn't realize it was that old.
If you go to Matsue, where Matz lived, there are posters and cardboard cutouts of Matz welcoming you at the airport. Their travel guides talk about Matsue as being interesting for being where Ruby came from. [https://www.visit-matsue.com/more/know\_more/modern\_matsue/do\_you\_know\_ruby](https://www.visit-matsue.com/more/know_more/modern_matsue/do_you_know_ruby)
Agree, changed to tiled mode by default, and added an option to specify layout by passing it as an argument to `toreman`. Fixed commentary removal regexp. Thanks for pointing this up. Added a note that `toreman` should be run from a running tmux session. Do you have something in mind how to support non-sh compatible shells? Tried `ls .env &amp;&amp; source .env` and just `source .env`, both print an error/warning when the file is not present.
Off the top of my head: &amp;#x200B; \`\`\` tmux split-window 'exec sh -c \\'source .env; exec sh -c "$(tmux show-options -vg default-command)"\\'' \`\`\` &amp;#x200B; A mouthful, but those \`exec\`s ensure that you don't build a tree of unnecessary shells. I can't guarantee it's safe or optimal, as I write these once every two years at best, almost never at worst.
Cookpad is a sponsor of Balkan Ruby (happening today/tomorrow) I guess they are still doing good.
Tried that, it seems that `sh` stops execution if `.env` is not found. Anyway, I'd gladly accept a pull request to make the script cross-shell compatible.
That command is telling tmux to replace the shell it starts in a split with an `sh` that sources environment from a file and then replaces itself with whatever is the default command for tmux, passing environment through the whole chain of execution. ``` tmux split-window "exec sh -c '[ -s .env ] &amp;&amp; source .env; [ -z $(tmux show-options -vg default-command) ] &amp;&amp; exec sh -c \"exec $SHELL\" || exec sh -c \"$(tmux show-options -vg default-command)\"'" ``` There will be a dangling `sh -c` in the process tree, unless default command uses `exec` itself. This here is why overmind exists, for example. Universality with no dangling side-effects is hard. PS: I'm gonna go scrub myself bloody in a shower now. That invocation is making me physically uncomfortable.
Thanks for such a clear translation. Do you happen to know more specifically what about the “the current [economic/social/political] climate in Japan” that Matz alludes to leads him to believe it would be unwise to disclose his exact income? Or is that just his indirect way of saying that it’s none of our business?
Seems like a classy guy.
I must have spent five whole minutes trying to figure out where the ‘comments’ were on Quora, and why they weren't immediately visible / how to get them to disclose. Finally realized the title meant in the *Reddit* comments. 🤦‍♀️
So guy creates language. Gets ripped off for IP?
1. The culture is difference. You just don't disclose these sort of information. Heck not many does it in western culture either. 2. There is huge paid gap in Japanese society, Inequality. 3. Considering the average salary of a software engineers with little exp in US is 140K a year, That is excluding all the benefits and bonus, it is the highest around the world within the industry. Matz being paid by 2 company, and one being in US meant his income will likely be consider as ridiculously high by Japanese standards.
Shared less than a week ago
#MINASWAN
[https://medium.com/driven-by-code/facebook-messenger-bot-using-webhooks-e481218ee7a2](https://medium.com/driven-by-code/facebook-messenger-bot-using-webhooks-e481218ee7a2)
Thanks for the no-tracking link.
Same!
Same!
I was thinking more in terms of file size.
Not really any different than JS proper, no, not an issue. Give it a try. Go write an in-browser simple pong game in Opal and experience the joy.
That was a video, this is an article published 2 days ago.
That's what I've been using as well
[http://codekata.com/](http://codekata.com/)
It can be helpful to explore code from well known open-source projects.
Yes, i've read it a lot of times. Could you recommend me one?.
I remember reading rake, brew helped me.
Thanks..
Is this supposed to be a spam ad? That's the most wretched looking thing I've ever seen. Is this a joke?
why does it matter?
yes
Yes that's what it is. There's probably nuances to both but I came from Java and class methods work how I expect a static method to.
I've been using RubyMine for years, but I don't really like it. The hinting and completion is really, really poor. I've never been able to make heads or tails of what libraries and gems it can see, and it frequently complains about method calls and such that it should see (and not things that are defined at runtime either). As for VSCode, I've tried both the `Ruby` and `Ruby Solargraph` extensions. Both extensions seem to do a better job of finding basic methods, but a really bad job at Rails-magic and other dynamic stuff and stuff. Side note: they all do a terrible job with Chef. I suspect RubyMine's Chef plugin is just plain broken and they haven't noticed. There are no good IDEs for Chef as far as I can tell.
I avoid ruby mine, it hides lots of stuff for ruby developers. You just want a simple IDE and to do everything yourself so that you learn. I would actually say go for Atom or Sublime Text. They are just simple text editors. VS Code is pretty much like an IDE, but also hides very little. I use VS Code only to write code and see lint errors visually, everything else I do happens in a terminal window.
All of the JetBrains IDEs blow VS Code out of the water. VS Code is a great lightweight code editor, but not quite a full fledged IDE, in my experience. I'll open it up for a quick one line change, or do some scripting in it, but I open up Rubymine for a full blown coding session.
I use Atom. It has tons of packages to handle Ruby and Ruby on Rails and is great.
ah, you are the opposite of me. boy is Java quite verbose but am getting used to it. ty!
ty
Yeah I'm not going back anytime soon.
haha... ah, I need to for work. boy Ruby I miss, it's a beautiful language.
I personally use Vim but I usually suggest Atom or Sublime Text to me coworkers when they're switching editors. I don't know how familiar you are with Ruby (or maybe Rails?) but I always advise people to make sure they learn to do something manually before moving to an editor that does things for you. For example if you're just starting with Rails and immediately start using Rubymine you'll have all these nice menu items for things like migrations/rollbacks, tests, etc but you don't have to actually learn *what* they're doing.
Atom and a terminal for life!
Flame war warning...
I have the same problems with IntelliJ. Even with a gemfile, a build.grafle, or a Pom.xml, IntelliJ can’t figure out what libraries to install or how to run the project. For java stuff I usually muddle trough until it works, but for ruby I just stick with emacs. I don’t understand why IntelliJ can’t read these project files and set up the whole damn environment correctly and automatically.
I mostly avoid having the IntelliJ IDEs try to install dependencies, run tests, or run my projects. Bundler, rake, puma, and so on from the command line for all of that. I don't even use the Git integration. I just want really, really good code hinting because the majority of my projects are old and have been through many hands, so they're wildly inconsistent and they're terrible to work on without some sort of help. I don't do much Java dev so I can't speak to that, but the reason I started using IntelliJ was PhpStorm. There, the completion is absolutely fantastic and it has never given me any issues. Of course, I do almost no PHP work anymore, so that does me little good.
VSCode sits somewhere between Sublime/Atom and Rubymine. It's not a full IDE, nor will it ever be, but it has a lot of the features a full-featured IDE would have. I used it for a while but just switched away from it, simply because there are UI things that really bother me, like the fonts support, particularly in the sidebar and the search. I work on projects with thousands of files and a hard-to-read search just doesn't work for me. And the ruby/rails support is sub-par, at best, compared to others. I've found Atom can do everything VSCode did for me (though maybe not others) and it looks better, which makes me more willing to spend time in it. I switched away from Sublime to VSCode, not because Sublime was bad, but I needed a change. But Sublime is absolutely the best in terms of speed. I personally don't find the need for something like Rubymine, but I've been writing Rails code for, jeez, 10+ years. It just gets in my way and never does what I think it should do. But it may be for you. VSCode is free, and Rubymine has a trial/demo. Try them. Spend a week or two with each. You'll find things you like and don't like about both. Everyone's needs and wants are different, and there are reasons some people love VIM over anything else. Just try them out.
[vim-chef](https://github.com/vadv/vim-chef) is pretty good for basic Chef. But then you're developing in vim...
I work in a Java shop however given my role I can get away with using JRuby a lot... I would recommend it when appropriate.
I just got RubyMine and I can’t seem to understand how to get it to work consistently with docker without having it freeze at some point because my container didn’t close properly. I also can’t get used to the keyboard shortcuts and not having files open when I single click them. I know I can change the settings but they seem very different from other IDEs to me. I waste a lot of time trying to do something like find what the equivalent to ctrl+t is. I find the whole experience incredibly frustrating and usually end up switching to VS Code and saying I’ll make time to watch some tutorials and try again later, but I’ve been so put off by it that I’d rather use terminal.
&gt; I avoid ruby mine, it hides lots of stuff for ruby developers. You just want a simple IDE and to do everything yourself so that you learn. I could not disagree with this statement more. I think VS Code and Atom are both excellent editors with a very rich ecosystem, but the level at which I can dig into the full stack if my application with Rubymine is not comparable. I can open up gem classes, add breakpoints and debug through my code at the framework level with relative easy. Is it bloated? Probably. Is it expensive? Without a doubt. Would I ever switch? Not a chance.
oh cool, never used JRuby before, sounds interesting.
Been using RubyMine and JetBrains IDEs for years but I stick with VS Code for JS and TypeScript development. RubyMine’s refactoring tool’s are light years ahead, its test runner is infinitely better and so is its database integration.
For me the biggest reason I've used rubymine is for deep debugging tasks. It's interactive debugger and introspector makes it easy to use in addition to the standard ruby debuggers etc.
Way back when RubyMine was a one time purchase for $50 and the other options weren't as good, I thought it was well worth it (as was Sublime Text). Now? I think it's bloated, slow, has a ridiculous pricing model that actually *downgrades* to an older version you when you stop paying. VS Code is faster, somehow has better code completion, has a much richer plugin ecosystem and it's free.
for me is the oposite. cvcode is not usable for type hinting, completion, refactoring, usage. rubymine is years away
But I can debug with binding.pry and see gem source files via GitHub anyway.
You need to be more specific. Are you looking for metaprogramming? Learning ruby's internals? Native extensions? Best practices? Programming for the command line? Gem authoring? Using web frameworks (like Rails)? "Advanced concepts" can literally be anything.
I think you should use vim
Not OP but, do you have anything to suggest regarding command line and best practices (specially thinking/planning systems/apps desig) ?! Cheers
https://www.railstutorial.org/ ia a great resource, the learn enough to be dangerous series has some good command line stuff, good stuff in general really. rubymonk.com has some advanced material too, if metaprogramming is up your alley. Hope that helps
Which packages would you recommend? I played with Atom for a bit but I had no idea which packages would get me some hinting and Rails awareness.
Atom packages I used for Ruby/Rails: linter-csslint, linter-erb, linter-htmllint, linter-rubocop, linter-ruby, linter-sass-lint, and then the core packages for language support: language-ruby, language-ruby-on-rails, etc. Non language specific packages I like: file-icons and minimap.
Are you passing your API key somewhere? As a header? You need to pass it somehow.
According to [the documentation](https://www.rubydoc.info/gems/open-weather/0.12.0/OpenWeather/ClassMethods#city-instance_method) `Forecast.city` takes 2 arguments.
Yes, it's in the initializer method.
Really? You get an error message. Why don't you click on the link? It seems 'blahblahblah' is not a valid api key.
appid = "blahblahblah" Hmmmmm, I wonder what might be causing error? 🧐
Ruby Under a Microscope goes pretty deep into how the language actually works
Of course I’m not going to post the actual api key here...
I have clicked on the link and read through the faq. I have already signed up for an api key, I just didn’t post the real one in the question for obvious reasons.
Does your key even work? Have you made a successful request with curl or any other client?
[rubybib.org](https://rubybib.org) covers some advanced topics in Ruby.
Yeah, that's not me.
For me, RubyMine’a excellent code navigation (including into methods that Rails generates at runtime) is the #1 reason I use it. And I like that I can navigate from my app code directly into a gem and then jump around inside the gem. In fact I find it so much better than navigating through GitHub files that sometimes when I’m learning about a new gem, I’ll clone it and load it into RubyMine rather than try to navigate around in GitHub. I also like that if I navigate to a stdlib method, it shows a stub method with docs.
Ok, but that's what the error says. So unless you give us a (second) "valid" key, or otherwise provide reproduction steps for how you obtained the key, of course we're all just going to assume that your key is wrong.
D'oh! This fixed it of course. Thanks very much!
I'm getting good mileage out of David Copeland's [Build Awesome Command-Line Applications in Ruby 2](https://www.amazon.com/Build-Awesome-Command-Line-Applications-Ruby/dp/1937785750) (2013). For Ruby-specific best practices (I'm coming from PHP), Sandi Metz' [Practical Object-Oriented Design](https://www.amazon.com/Practical-Object-Oriented-Design-Agile-Primer/dp/0134456475/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=A5SS0GD0EZ30HASW09RV) (2019) and Russ Olsen's [Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=pd_bxgy_14_img_3/138-7782528-3565415?_encoding=UTF8&amp;pd_rd_i=0321584104&amp;pd_rd_r=fcbababf-7a7c-11e9-9511-65a57d25cf2b&amp;pd_rd_w=lW0jz&amp;pd_rd_wg=2yiyq&amp;pf_rd_p=a2006322-0bc0-4db9-a08e-d168c18ce6f0&amp;pf_rd_r=FS855XKREVDKQYPSFZ9M&amp;psc=1&amp;refRID=FS855XKREVDKQYPSFZ9M) (2011) are opening my eyes to how it's done here. In particular, Metz' focus on the role of messages in OO design has changed my approach to planning and testing - just in time for a critical project.
That is awesome!
:))))) loto? 6/49?
am prins septari
The odds are `1/6!`. That's `1/6*5*4*3*2*1`, or `1/720`, or `0.14%`. Unlikely, yes. But hardly euromillions-jackpot-unlikely. And the probability of this happening after **240** attempts (judging by the command line output) is actually **28.6%**.
Ooph, lucky number 240. Reminds me of the tennis player who finally broke his terrible losing streak against Jimmy Connor: "Nobody beats Vitas Gerulaitis 17 times in a row!"
haha, 240 lines since I've been doing the ruby tutorial. more like 13 tries :D
The jokes on you. `"foobar".chars.shuffle.join`
class String def shuffle “foo bar” end end
&gt; `"foobar".chars.shuffle*''` For anyone who stumbles across this and, like me, was wondering what's going on at the end there, multiplying an array by an empty string is shorthand for the array's `join` method. Documented [here](https://docs.ruby-lang.org/en/2.0.0/Array.html#method-i-2A).
You can also open gems from the command line with: bundle open GEM_NAME Not quite as convenient but it’s helpful when you need to dig into dependencies.
&gt; So that's `0.28%` chance of it happening in one try Looks about right to me. irb(main):001:0&gt; 1000000.times.count{ "foobar".chars.shuffle.join == "foobar" }.to_f / 1000000 =&gt; 0.002756
The exact percentage is actually `0.277777...`. This is relatively simply maths :)
I'm sure you're right but I'm pretty sure I've drinked away every combinatorics course I took.
The 2 swappable `o` characters break your calculation. (Spoiler alert, the probability of drawing one foobar is double). The probability to obtain `foobar` in one throw is the product of following probabilities: - 1/6 (probability to draw a `f` first) - 2/5 (probability to draw any `o` among the remaining letters) - 1/4 (probability to draw the remaining `o`) - 1/3 (you get it by now) - 1/2 - 1 (`r` is last and alone, 100% chance to draw it) To calculate the probability of drawing `foobar` within N=4 throws, you first calculate the probability of not getting `foobar` in 1 throw: it is 1 minus the above, or simplified to 359/360. Then you power it to N to know the probability of not drawing `foobar` in N throws: (359/360)^4. Finally you subtract the above from 1 to get the probability of drawing at least one `foobar` in any of your first 4 throws: 1-(359/360)^4, which is about 1.1%.
Very happy to hear it should be open sourced this summer!
Technically a class method in Ruby is still an instance method (it's an instance method of the class object's singleton class; the class object is the instance). Java doesn't follow that same underlying model as far as I'm aware. From a POV of how it's used though, they accomplish the same thing and are effectively synonymous
How do you know the o’s are in the original order...? ;-)
very interesting, ty!
Did you read my edit? I already said this. (P.S. I have a degree in maths, but thanks for the explanation ;))
Get this man on the phone with the president
 srand 52; 'foobar'.chars.shuffle.join #=&gt; "foobar"
Years ahead or years behind? "years away" doesn't denote a direction...
None of those operations are in-place, so there's a zero percent chance those o's are in the right order.
You are soooo right. I'm just using it "out of the box" and it's extremely helpful. The only tweak I did was defaulting my keyboard to use normal functions keys by default - makes using Go To Definition much easier.
Not exactly synonymous, I think one big difference is that you don't get polymorphism with Java static methods, as for Ruby class methods, polymorphism is not only possible but used quite frequently.
Thanks, learned something new!
Dammit /u/tomthecool! OP SPECIFICALLY told you not to!
Somehow I missed your edit when I first started typing, my bad. I have a degree in maths too. ;)
Rubymine is much better at figuring out your code. You can even jump into Gems to see what the code is doing.