Ah, but in the *best* case it's O(1). :)
Late reply, but it's also worth noting that often times it takes twice as much code to do something in Java as it does in Ruby. So assuming that line counts factor into their rankings, it would artificially inflate the popularity of Java, C, and other relatively low-level languages
Agreed. Don't use shared examples as much as possible. And in general, I don't try to 'DRY' tests, I like my read my tests without a lot of indirection. And while on the topic of 'DRY'. let me just say that a lot of folks do not understand the principle of DRY, just like most people do not really understand SRP.
To put it another way, if you've duplicated code, then you need two tests, and shared examples will de-duplicate your tests. If you remove the duplication in your code, then shared examples will be useless :)
Wait...are you *the* Matz?
I'm a longtime sysadmin turned tools, automation, and glue programmer. I do most of my work in a relatively plain text editor like vi, or if I'm feeling like a graphical UI I'll use nedit, textpad, or notepad++ depending on what OS I'm sitting on.
Kind of surprised that doesn't include an enum = arr.each with an example of an external iterator running in a loop.
Iteration over iteration made your business logic coupled with those active record joins and groups. You said that 'Sometimes, not always', that means that those joins part of a particular use cases? I don't like to leave that kind of smell be in my code for too long, in 6 months, you or other dev on your team, will look at those complex validations and don't understand what is going on. It will be a pain to make a change.
I think STI is a good use case for validation extraction, there are multiple contexts and slightly different use cases for each child model. You can have multiple validators for each child model and still inherit validations from the entire model validator. I always have each functionality in multiple classes/files. I don't think it's a good practice to keep all the code on the model and use shared functionality through the model. Let me know if I'm saying crap :)
Hubot is so much more than a javascript bot. It allows us to gain so much insight into what is happening. ChatOps is about culture and context.
&gt; Someone else passed me this and I took them at their word. Have you asked them to correct their bad information? 
I guess it must have to come down from the top. We use it at work, and the most complicated shit we've used it for is booking staging servers
&gt; You can work from anywhere. Last year I worked probably in five or six different cities around the world. Just working from my laptop wherever we decided to go. I really wish more companies would let developers take advantage of the ability to work remotely. The time to travel for extended periods of time (more than just a two-week vacation) is one reason I find myself leaving jobs and taking month-long breaks in between.
 long_string = %{ It was the best of times, It was the worst of times. } Is identical to long_string = "\nIt was the best of times,\nIt was the worst of times.\n" `"\n"` is the escape character representing a newline and newlines are preserved in multi-line strings. So if you were to change it to long_string = %{It was the best of times, It was the worst of times.} The string would only contain one newline. `lines` basically splits the string on newlines, but it doesn't care whether the string has a trailing newline or not, so `"a\na"` and `"a\na\n"` both have two lines as far as `lines` is concerned.
Trying to find the lowest of the three numbers in every row
I think it's meant to generally lower communication overhead even if it's at the cost of technical capability. Maintaining shared awareness can be tough when 60% of your employees are remote. 
thanks, that was it, I need to learn identation
Your logic is faulty. The first comparison it does is to compare the first and second numbers on the line. If the first one is smaller, it prints the first one, without even considering that the third one might be smaller! You would benefit greatly from working out the process for yourself, in English. Let's say I give you three numbers, A, B, and C. Describe to me how you would find the smallest number.
In the future, I would recommend learning more ruby-ish ways of looping, it will save you time in the long run! For example, instead of manually incrementing a set of 3 indexes as in: while i &lt; 90 number_one = numberz[a] number_two = numberz[i] number_three = numberz[x] #program stuff i += 3 a += 3 x += 3 end You could try: numberz.each_slice(3) do |mini_array| number_one = mini_array[0] number_two = mini_array[1] number_three = mini_array[2] #program stuff end Calling `each_slice` with a 3 tells ruby to slice the array up into chunks of 3. The `|mini_array|` after the `do` will update as each slice is pulled from the `numberz` array. That way, we don't have to any math!
Firstly, you could replace the declaration of a string array and subsequent conversion to an integer array with just constructing an integer array to start with; replace `%w(` and `)` with `[` and `]` and add commas after each number. As far as your first solution: As soon as one of those conditions evaluates to true, the entire statement will finish executing. Therefore, if the first number is less than the second number, it will never check the third number. If you wanted to do it this way, you'd have to nest the logic so you check the third number, but it's going to get rather complicated to remember which positions you've checked. A simpler solution (besides using the built-in ruby function, like you've done in the second example) is to loop through the values and continuously store the smallest value, then print the final lowest once you've checked them all: def minimum(a, b, c) result = a [b, c].each do |n| if n &lt; result result = n end end result end You could integrate it as follows: while numberz.size &gt; 0 next_three = numberz.shift 3 print "#{minimum(*next_three)} " end The Array#shift function takes the first n elements off an array and returns them as a new array. The `*` operator (splat operator) effectively turns the array into arguments. The `#{` and `}` in the double-quoted string interpolates the result of the call to the minimum function into a string with a space, so you don't have to call print twice. Since the array gets smaller each time we take 3 off it, it will eventually be empty and the while loop will stop executing.
Or just use ruby syntax and use `eval`! /s ;)
Here is a minified version. In general, learn how to use what ruby provides and recombine it. In 7 years of ruby, I've never used a direct `for` or `while` loop. Use everything array has to offer, as well as enumerable. Here I use `each_slice` and `max`. http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-each_slice numbers = Array.new(30) { rand 1000000 } puts "num: #{numbers}" numbers.each_slice(3) { |a| puts a.max } 
Thats the key though, it's really not about HuBot. It's not that special, there are plenty like it. It's the culture of the company that is important.
I'm aware, his second answer actually already used the min function, although he sorted it first too, not sure why. I gave a longer explanation to try to explain the underlying logic. 
I believe there is a little trash can icon on the side of the window that should clear all text.
Nice article, thanks!
I don't understand the advantage of using fibers (cooperative multi-tasking, only giving up CPU on explicit yields) here over threads. On any ruby platform (on Jruby, I think fibers are _actually_ implemented as threads anyway; on MRI, you have the GIL either way). I would be interesting in hearing more about why this is useful, perhaps some actual benchmarks comparing to a solution implemented with threads (for instance with [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby)'s ThreadPool). It may well be that fibers really are faster, on some or all ruby platforms, for this particular use case involving spawning shells/processes -- but I'd like to see some actual demonstration of such. 
I do not think that system('clear') works for windows, athough I tried it. system 'cls' works when I use IRB, but I want to be able to clear the Run Tool Window of Ruby Mine with some kind of command if such exists at all. 
Most people think [my color scheme](https://github.com/phoffer/sublime-settings/blob/master/blue-json.tmTheme) is too colorful/diverse, so you might like it.
Solarized is an oldie but goodie. http://ethanschoonover.com/solarized/img/screen-ruby-dark.png
I see no reason for avoiding `module A::B` declarations. Just be aware this expression means module definition named `A::B` where `A` is a class or module object identifier. Nothing more, no mutual nesting, no inheritance. As you've demonstrated, you may reopen the former 'A' module to define nesting. Other ways to access `MARCO` constant are qualified access or module inclusion.
Color schemes aren't really editor dependent. Some color schemes are available for many editors, such as Solarized. So you don't have to switch from Sublime, you could just look try finding a [color scheme you like](https://packagecontrol.io/browse/labels/color%20scheme). Also, I'm going to give a shameless plug to my own themes/color schemes for Sublime: [Materialize](https://github.com/saadq/Materialize/blob/master/Screenshots.md). I personally use [this one](https://raw.githubusercontent.com/saadq/Materialize/master/screenshots/Material%20Spacegray.png).
Surprised by nobody cite [base16](https://github.com/chriskempson/base16). It has for many editors. 
Threads require locking as they may be running asynchronously. Fibers are predictable in the way they execute. It's much easier to reason about. Feel free to benchmark the two solutions. 
For those of you who don't know about it check out /r/digitalnomad , has about 14k subs and is very active.
What is the purpose to relate number of fibers to number of processors/cores, as you suggest in in the "Process Limit" section, if multiple fibers can't be running simultaneously on multiple cores anyway? 
I really feel like I can trust this sites judgement on design...
FYI: There's no competition (and judgement) about the quality of the design to get included in the theme of the month series. It's just "chronological", that is, all themes added in August 2015 got included, think of it, "What's News?". Cheers.
Money, distance from home, flexibility (able to work from home sporadically, not having a very strict schedule). These are insignificant compared to "a boss that knows the trade", "colleagues I can get along with" and "degree of corporate disfunction"- but those are difficult to estimate prior to working for a while in the company. 
If they allow remote work, if they do peer code review and their technology stack (what they use for communication, wiki, story tracker, version control, CI, deployment process, etc.). but I will only stay if I like the people.
I'm surprised that they didn't run into more issues with threads other than require. Good writeup though!
I'm not sure exactly where you are in your learning but given that your using `map(&amp;:to_i)` I assume moderately far along, or it's part of the setup code from the problem. If the former is the case, a better solution looks like `numbers.map(&amp;:to_i).each_slice(3).map(&amp;:min)`. The only thing I'm adding here that you're not using already using is `each_slice(3)` which breaks an enumerable up into groups of 3.
Normalize to this. Ok now we can Normalize to this. Now Normalize to this. Eh
The child processes can run on separate hardware processors by the OS scheduler.
- How much they're paying me - How much I have to work - How bad is their current development environment
the last one reminds me that I should asked more money for my current job
I'm assuming you're a junior, so: - do they use the latest ruby/rails version or will I be stuck with an outdated one for years - are there skilled colleagues to learn from, e.g. if the team has java, php and .net backgrounds and just started writing ruby, that's not so good. - do they use the standard tools, git, mac, rspec,... These days I'd also look for other things, - has the project enough funding - do the owners care about the project or the money - do they use microservices or a behemoth
I can't help pointing out the craziness in naming a GUI library 'shoes'.
Money, team (are there people I can learn from), culture (is it a toxic bro-y work-all-hours place).
I'm a fan, found my current site theme for schneems.com here last month. Thanks ❤️
Or strings to eval, or iseq objects, both which you can store as ordinary .rb text files until needed. Hard to get simpler than that. Trusted application which negates any trust issues from user input, and eval really isn't that much slower^1 than directly input code unless you call it a bunch of times from an iterator instead of including the iterator code inside the string/YARV instructions to evaluate. ^1 (I've seen it run faster, actually, though it's more consistently faster than procs/lambdas than directly input code - The more work in there, the less the initial overhead slows it down. Lots of small evals suck, one big one doesn't.)
My three questions would be: 1. How long does it take to setup a development environment for a new employee? 2. What's the process for deploying to production? 3. What are your usual channels of communications? The reason for these particular questions is more as an indicator of company culture. Question 1 tests how much the company automates things. Ideally they'd reply "run this script and you're done". Because new employees are a relative rarity, a company that automates this probably automates everything. Question 2 tests automation as well, but also how much power they give developers, how they review code and how extensive their tests are. Ideally they'd say something like "any change that has been peer reviewed is merged to master, master can be deployed at any time". Question 3 tests how the company deals with interruptions and remote working. Ideally most communications should be asynchronous to avoid disturbing people, so something like Slack/HipChat/Campfire/IRC or whatever would be ideal, with video-conferencing or face-to-face meetings used occasionally for when high-bandwidth discussion is necessary.
Well, _why. 
I'll raise you 60 users all RUNNING the fat client software with remote desktop. 
Can you give a good basic rundown of database normalization in terms of why you look for it and what specifically you look for?
In the last line of ruby code example, the Proxy url is repeated again : &gt; driver = Selenium::WebDriver.for :remote, :url =&gt; "http://localhost:4444/wd/hub", :desired_capabilities =&gt; caps I guess you will have to change that too.
&gt; do they use the standard tools, git, mac, rspec Since when is Mac a standard in the industry? http://stackoverflow.com/research/developer-survey-2015#tech-os 
FYI: You find all themes (100+) with direct links on the front page -&gt; [drjekyllthemes.github.io](http://drjekyllthemes.github.io). Good point. Will try to add links and screenshots next month. Cheers.
So... because you only see Macbooks on the conferences you go and people in your circles buy Macbooks, we can say it's the industry standard to a point where you ask for companies if they use them, and mislead junior devs to think it is. Solid argument!
Do you really think that survey applies to ruby developers? When was the last time you tried to bundle a medium sized ruby project on Windows? Good luck with those native extensions...
&gt; people in your circles Am I mac privileged now? I've done ruby for 7 years now, 5 of them professionally. I've used ruby on windows, linux and mac, in that order. And: it's made by mac users for mac users. Not so much ruby itself, but the tools and dependencies you need as a developer. I get the anti mac position, I'd even say it's valid to a point. But I'd never start a job if they don't hand out macbooks to devs. It would be a major pain for me to get everything running smoothly, to use all the tools available. Windows doesn't even have a usable CLI and linux comes with too many annoying quirks and needs too much maintenance. Out of curiosity, what do you use?
I've financed my first iMac back in 2010 by lying on the form, saying I was employed. I could barely make the payments. That was the best decision I ever made. I'm still using it right now, at least until they announce a new one in a week. That one I can actually afford. My laptops were all company property. Which is my point - if the employer isn't willing to hand over a fresh apple at the start - something smells fishy.
I feel (mildly) the opposite. Ruby works great on Linux, but getting rvm/rbenv to link against the correct gnu readline library so irb/pry can get vim keybindings is a PITA.
Look no further, your answer is: Monokai 
Immediately I thought http://www.squid-cache.org/
I've never worked on a database that's anywhere *near* as poorly designed as that website's example! Please tell me such dumb data structures don't actually exist outside of excel spreadsheets, in the real world?...
Well I'm sure the examples shown were just for the purposes of the tutorial.... But yes, I've seen some bloody awful databases in my time. 
As books go, POODR made me the man I am ;)
Looks exactly like what I'm looking for, thanks!
Actually, looks better than bower-rails with easier integration. Starred!
"industry standard" or not, I would not want to develop ruby on Windows, and I think most other experienced ruby developers would not either. You can develop ruby on linux fine if you're comfortable with linux. Most of us prefer Mac. 
"What's the budget for your project?" This is a canary-in-the-mine question, because based on the response you get an insight into how the business functions. If they have poor management processes, or don't have a clear idea of what it is they are building, it's usually revealed in answers like "There isn't really a budget" or the more magical "Unlimited!" It's not really intended to find out how much money is available - more about the business and how they manage resources. And that ultimately affects how you end up working. The best response is often "Look, we really don't know. But we're going to take this in stages and try to discover things as we go."
Yeah. It's hard to take small projects seriously when they go and use the name of a larger, well established project. Feels like they're fishing for search engine hits.
I don't really think git is ideal for deploying assets. Or code, for that matter.
Yep, recently this: http://www.goalr.co, and most of the assignments on The Odin Project.
I think what you need to do is jump into a rails project. If not a client project, do one for yourself: a blog or something might be a good idea. You can read about rails, but without doing it, you'll never feel like you're ready. I have a feeling that you might be similar to me, in the sense that you need to know how things work before you can feel comfortable using/building on them, and the thing is, just reading about something rarely ever is the same as actually doing it. I'd say go checkout out the rails tutorial by Michael Hartl and just follow along. There will be some parts that you don't understand, but that's ok. Go through the whole thing once, then go and checkout [Rails guides](http://guides.rubyonrails.org) to find out what's going on. Good luck mate! I kinda feel you on the whole procrastinating because of self doubt. I've been doing this rails stuff for a couple years now, still have that niggling doubt that makes me ponder a million and one 'what ifs' that never really transpire anyway. For that, checkout [this site](http://waitbutwhy.com/2013/10/why-procrastinators-procrastinate.html), it's the best article on procrastination I've ever read (and I've read quite a few, this is the only one that makes sense to me and doesn't make me feel like a completely useless shit). Good luck mate!
haha, 'hipster technology'. Thanks for the link, that's just what I was looking for. I've been at this full-time so I always feel like I could be doing more. 
&gt; Self doubt (I sometimes think that I'm not cut out for this, and subsequently that I might not enjoy this as a career. This leads to procrastination.) Generalized for any programming, or specific to the planned track you're following? TBH, I have zero interest in Rails, I'm just using Ruby for the Ruby. I don't have anything against Rails per say, I just tend not to be excited by the concept of developing web servers. I'm more interested in the development of programming languages, among other things. Edit: Downvote for asking about a potential psychological issue? It needs to be considered. People can get those kinds of concerns when they're feeling overwhelmed AND when they don't really want to do something but ignore not wanting to do it. Webdev would certainly fill *me* with a sense of not wanting to do that as a career. Maybe the issue, maybe not, but you don't know unless you check.
Don't forget that your brain needs time to process, sort and categorize new information. Some of those important processes don't get to work until you've had some time to sleep. Quantity of learning won't help you if the quality suffers because of it. I'm more around a year in, progress seems to accelerate with mastery of additional concepts. It usually speeds things up if I take extended breaks or even fit a nap in there when I've crammed so much into my head that it hurts. Make sure you keep up with your brain's maintenance schedule. Might want to pay attention to the growth of your expectations of progress in a given timeframe as well. I got frustrated around the point you're at, until I realized how much progress I had made and further realized my expectations were growing exponentially... And being *exceeded* month after month. Even if you turn out to be the greatest genius that ever lived, it's still going to take you time to fully learn and integrate all the various engineering principles. Rome wasn't built in a day.
1. [To check up on gov't data that has been altered.](https://github.com/Schwad/Whistleblowing-Parser/blob/master/payment-parser.rb) 2. [To do mTurk work faster](https://github.com/Schwad/Faster-Turking/blob/master/all.rb) 3. [To live tweet out Montana State Legislative election results](https://github.com/Schwad/MontanaVotes2014)
and 60% of the time, it works every time _/growl_
Happy to see ArrrrCamp listed :-) I've just added a discount code, if you use "REDDITOR" during checkout you'll get a 10% discount. Let me know if you'll join us in October!
You should most certainly not be calling to_s on both in your equality check. This allows you to have anything stringable to equality match a custom value type. EmailAddress.new("hello@example.com") == "hello@example.com"
Not only have I seen databases like that; my boss has asked me to _build them_ on occasion. (No, I have not actually written a schema like that.) They worked on software in the 80s where records were fixed sizes. So when designing the schema you would add "user defined fields" at the end of the record as padding. This way _when_ the requirements change you still had a place to put data in the record. This has influenced how they want me to design modern software: "oh well, I can't imagine the customer will ever want more than 5 mappings; so why not just add `mapping_1`, `mapping_2`, etc?" **_WHY NOT!?_** BECAUSE THAT'S NOT HOW _RELATIONAL_ DATABASES WORK?!?!?!
oh - and another thing, don't try to take all this on alone as a solo contractor/developer... work with a team. Good teams are out there hiring people with skillsets just like yours.
Thanks for some nice resources. I've just been going through "The Odin Project" and it seems pretty good, I'm just upto the part where you need to make tic tac toe so that seems pretty exciting! I'll have a look at the other resources you've used after I finish this course.
Interesting approach. I will try that. Thank you!!
This is my first post. I'm trying to learn ruby, and I don't understand any of the code above the puts section.
You should attend some programming or computer science lections first. Otherwise you'll grow up into codemonkey, filling Internet with shitty code. Only after you understand, what are datatypes and how they are stored in memory you'll understand this code in the proper way.
Nevermind, figured it out. For posterity's sake, pry/irb get the display format from an object's `#inspect` method. [1] pry(main)&gt; class FunObject [1] pry(main)* def initialize(foo) [1] pry(main)* @foo=foo [1] pry(main)* end [1] pry(main)* [1] pry(main)* def inspect [1] pry(main)* ":) &lt;(#{self.class})&gt; {foo -&gt; #{@foo}}" [1] pry(main)* end [1] pry(main)* end =&gt; :inspect [2] pry(main)&gt; FunObject.new(:lol) =&gt; :) &lt;(FunObject)&gt; {foo -&gt; lol} Interestingly, however, this only seems to work if `#inspect` returns a String: [1] pry(main)&gt; class FunObject [1] pry(main)* def inspect [1] pry(main)* 2 [1] pry(main)* end [1] pry(main)* end =&gt; :inspect [2] pry(main)&gt; FunObject.new =&gt; #&lt;FunObject:0x-23dfed58&gt;
interesting, thanks! 
&gt; The workers are wrapped safely in individual jobs. This encapsulation is essential to prevent duplicate work and prevent unwanted side effects. I don't understand this claim. Let's say the extra steps were not put in their own separate jobs, but instead just additional procedural steps in the same original job. Imagine the steps are still defined exactly the same though (idempotent, etc). How would there be a possibility of duplicate work or unwanted side-effects that was not present in the suggested 'individual jobs' implementation? An example? It may be wise to use separate jobs for other reasons (most efficient use of your CPU? I dunno, maybe), but I am not seeing how it prevents duplicate work or unwanted side effects. 
Just tested it and you're correct
I found some bizarre stuff the other day while trying to write semantic Ruby (normally *very* easy with ActiveSupport). I wrote if end_date - start_date &gt; 6.days which, if I were to design ActiveSupport, would totally work. But it doesn't. The reason? `Date - Date` returns a `Rational` for some reason, and `6.days` acts like an `int`. Normally, you'd think "Okay, that's fine; at least we're comparing two things of roughly the same type", but the `Rational` is 1 if it's been 1 day and the `int` is 1 if it's been 1 second. I rewrote it as if end_date - start_date &gt; 6 which is obviously less semantic, but at least it works. I really don't understand why ActiveSupport doesn't use some kind of `ElapsedTime` type that could keep track of all of this.
Try using `BasicObject.new` as an `#inspect` return value.
Thanks. My BAC made it a little difficult to understand at first but I believe I get it now. My impression is that `Array#include?` calls `#==` on the arg for each element, which, if `#to_s` is called on each operand, would return `true` for `EmailAddress.new("Foo@foo.foo") == "Foo@foo.foo"`, but `false` for `EmailAddress.new("Foo@foo.foo") == "foo@foo.foo"`. This would of course be contrary to the intent of the `EmailAddress` class.
&gt; It is important to keep each job idempotent, meaning the job can be called repeatedly but will only perform the actual work once. That is not what idempotent means. Idempotence is a property of transformations that can be applied multiple times without changing the result, which is in many ways the opposite of what this post says. Idempotent operations don't need a check to ensure they 'run only once'. &gt; In order to keep the VideoCopyWorker job idempotent there needs to be a check for whether the video has been copied yet: How do you handle partial success? What is half the video was copied? What if the video was fully copied but whatever data store you use to determine 'successful copy' wasn't updated? etc. This is why the definition of idempotence is important. If your job is actually idempotent you can just rerun it at any hint of failure, worst than can happen is burning some compute resources unnecessarily. 
good to know! how do people find issues with thread-safety? or it's more of a matter of looking at exceptions in prod?
 [1] pry(main)&gt; class Foo [1] pry(main)* def inspect [1] pry(main)* BasicObject.new [1] pry(main)* end [1] pry(main)* end =&gt; :inspect [2] pry(main)&gt; Foo.new =&gt; #&lt;Foo:0x-2322ba44&gt; &amp;nbsp; irb(main):001:0&gt; class Foo; def inspect; BasicObject.new; end end =&gt; :inspect irb(main):002:0&gt; Foo.new NoMethodError: undefined method `to_s' for #&lt;BasicObject:0xb9282008&gt; 
No mention of Slack... I see the benefit of Gitter over Slack (namely for FOSS), but I feel like this discussion at least requires mention of Slack. It seems like it's just saying "It's better than IRC", which is not exactly a tall order these days.
Not to Slack-bash, but since it's been brought up, I'm not a fan of projects using Slack. Setting aside it's a private company that can do whatever it wants whenever it wants, it feels exclusionary to me. I'm a Linux desktop user and Slack doesn't have a native client. Sure, there's the web site, but I really don't want yet another tab I'm never going to keep track of and eats up 100s of MB of RAM (I'm judging from other web-based chat apps I've used). Another option is the Chrome application shortcut thing, but Chrome is pretty terrible on Linux. Anyway, that's not to rant. I just wanted to raise points for consideration when choosing how you want to interact with your community. I used to be quite active in #boston.rb, but it moved to Slack and I (and others) essentially got left behind. Even those that want to join have to request an invitation to the room, rather than just hopping in and chatting. Of course, gitter suffers from several of these problems as well. But they at least have a Linux client (even if it is just some Chromium wrapper). Edit: I'm not with the Rubinius project so I'm not speaking on their behalf. Just a Rubyist sharing his thoughts :-)
I was just informed that there is a Linux Slack client in beta. Most of my comment may be irrelevant soon.
How?
Introduce a `create`, `update`, or `delete` action for a resource that otherwise shouldn't exist, or should be secured. I've seen it multiple times from Rails built in generators, this is a step worse. 
All of these chat apps are the same: the native app is always just a browser wrapper. 
Try this book https://leanpub.com/everydayrailsrspec Its starts out really easy and in a way thats still accessible while you're learning ruby
Another one ... their process around feature work. How they provide estimates, and communicate release dates, how they handle estimate misses and their actual dev process for shepherding work from ideation to deliverable. You're going to be doing that stuff day in day out, and if they do something that grinds your gears, like logging your hours everyday , or using standup as status update meetings ... you're not going to be very happy
Can you give an example? I don't follow. Secure ness is handled by before filters? 
If you don't want a create action, that should be handled in the router
I haven't used Gitter before this post, but the OP seemed to mention private messaging of some kind, so I poked around in the rubinius room to see if I could find it -- if I click on someone's icon in the right-hand mini sidebar, I get a 'chat privately' option. I don't know if there's a more convenient way to choose someone to chat privately with by name, hopefully. But the feature seems to exist. 
The important thing the benchmark-ips gem does, that this write-up doesn't mention, is use statistics to figure out how many iterations need to be run to find a statistically meaningful difference. Rather than have you just arbitrarily picking a number of iterations. It's not a magic bullet (statistics aren't magic), but is much more likely to give you actually meaningful differences. 
If there really is something incorrect or odd about the SSL cert of the site you are trying to connect to, but previous versions of ruby had a bug in them that let it through anyway, then that would be consistent with your story. Or it could be a bug in MRI 2.2.3, sure. Or it could be something else. SSL cert verifying debugging is confusing. If you tell us the hostname you are trying to connect to when you get that error, then someone can try to look into it, try it on their own machine on various platforms and versions. That's what anyone, including you, need to debug this further. If you don't easily have that now, your first step is debugging things enough to get it. 
It's just a browser tab. Maybe you need a new computer if one more tab is too much.
hm, yeah, that does seem unlikely to be misconfigured on their end. I don't have any trouble connecting to `https://accounts.google.com` from my OSX machine using net/http under MRI 2.2.3. Sorry, I dunno. 
Yep I follow this serialization/deserialization layer as well.
There's a much longer list of steps to try [here](http://railsapps.github.io/openssl-certificate-verify-failed.html), although I'm not sure they'll be any help.
It might be that you're using SSLv3 and Google will be denying you because of that. SSLv3 is vulnerable to the [POODLE](https://isc.sans.edu/forums/diary/SSLv3+POODLE+Vulnerability+Official+Release/18827/) attack and is recommended that you don't use it. Switch to TLSv1.2. I'm not sure how you go about configuring this on OSX as I don't own any Macs.
Ruby 2 + OpenSSL don't really ever play nice together. RVM makes it even _more_ confusing since sometimes it downloads a precompiled binary Ruby (with a good OpenSSL integration) and sometimes it compiles its own (which will almost always end up with the OpenSSL errors above). Pretty frustrating. :-/
I install 2.2.3 on 5 Yosemite machines via RVM yesterday, so I don't think it is an issue with Ruby or RVM, per se. First, make sure your Homebrew or Macports packages are up to date. Next, remove 2.2.3 via `rvm remove 2.2.3` Finally, reinstall 2.2.3 from source `rvm install 2.2.3 --disable-binary`
_\*sigh*_ Class methods and scopes are not equivalent and interchangeable unless you have a passion for writing bad code. If you do not instinctively understand the advantages of each approach, you need to step back and think about whether you care about maintainability and reuse or not, and in which contexts. That said, there are some rules of thumb you can learn: Generally if you want something smaller than `find(:all)` and you're not after `find(:id)`, you _might_ want a scope. It's the Rails convention, it's what people expect, do that. If you need a method that has nothing to do with retrieval of records out of the DB and that isn't clearly an instance method, use a class method. Saying "I want a subset of records, but I won't use scopes" is basically kicking future you in the balls with steel toe-capped shoes.
&gt; you need to step back and think about whether you care about maintainability and reuse or not, and in which contexts. If you *really* care about these things you wouldn't use Ruby to begin with... I'm wondering what kind of maintenance difficulties can be created by using a class method returning a scope vs using a scope. IMO a class method is preferable because they allow you to use ctags / "jump to definition" in editors. 
great article, thanks for sharing!I liked the bit about preloading associations with the scope attached to it to avoid N+1 queries, neat trick. 
So, read the README, and I can't for the life of me see what this is for. You've documented the what, but not the why. Is the idea that you build swappable modules and compose them at run-time based on user input or something? How does this model improve my life? I feel like I should be the target audience for this library, as I do a lot of data processing, but I don't really see the value. What am I missing?
I would caution against the overuse of scopes. Too often we have scopes that are either used in one place only, which is senseless because the idea is that the scopes are reusable. Doing so just makes the model fat, and harder to work with. Or they are used in too many places which makes it hard to change. When we have long daisy chains of scopes littered through the code, it becomes hard to see how your changes to the scope impacts your application. I only use scopes for very literal bits of logic that aren't ever going to change, or if by doing so has little impact. 
Yep, mostly watch for "odd" exceptions.
This is a good article nevertheless. Thanks for thinking of posting it here jrochkind, this help :-) 
&gt; If you really care about these things you wouldn't use Ruby to begin with… I think you're trolling. If you use Ruby properly with dependency injection, law of demeter, duck typing, inheritance, mixins and so on, you will have the most maintainable and reusable code you can have. What would you prefer using instead? I strongly recommend POODR if you are not sure how to write maintainable code in Ruby.
&gt; I think you're trolling. I'm not. I read POODR, I know all these things you listed and use them daily, but I also have plenty of experience refactoring big Ruby projects which is most of the time just a guessing game (even with decent test coverage). Statically typed languages are superior in this regard.
If you have read POODR and absorbed its contents, I'm not sure how you are still in the position you're in. I have refactored many large Ruby projects, the current day job has nearly 100 controllers and 41k commits written by a rolling roster of over 100 developers in the last 6 years. The only thing that saves it is that it's Ruby. We have a book club where we review book chapters, and yesterday it was my turn to present POODR Chapter 5, on Duck Typing. It specifically mentions the weaknesses of static typing vs dynamic typing in the context of maintainability. Can I suggest you go back and read that chapter again and think about your refactoring approach - if you are left thinking "I wish I had static typing", it hints at you probably not doing something quite as well as you could be.
I was kind of confused by it as well, although I can see how it'd be useful for web scraping. 1. **Extract** - grab page(s) from website in question 2. **Transform** - combine data into your own format 3. **Load** - Insert data into database It's very modular so it would be nice for a big scraping project across multiple websites, or a project with a very large and complex website. I could see it being used for purposes like this and might even give it a shot. You could use it in any case like this, though, where you get some data in some format that you need to represent in your own, different format, and save it to some place. Another specific use case might be updating statistics tables in a DB. 1. Grab data you need to calculate stats 2. Transform data (calculate stats) 3. Save stats to DB
Sure, but instead of all the module-building, why not a monolithic WebScraper class? Or a StatisticsUpdater class? Just have 3 methods - extract, transform, load... I guess I'm not clear on why this pattern saves any time or cognitive load during development or use, and why I'd want or need a gem to implement it. /me = confused
Very true, I do end up implementing the same basic flow when I do scraping projects, on my own, and its always worked out fine. I see your point. It's sort of just saved us some boilerplate.
it's a method call. The dot operator always calls methods. `.parse!` is a method call, aka message send. There is a method called `parse!` that you are calling. (Methods can end in punctuation in ruby). Technically, you are sending the message `parse!` to the object -- which is usually handled by a method named `parse!`, although there are other ways objects can respond to messages instead of using the default method lookup. But don't worry about that for now, it's a call to the method `parse!`. `OptionParser.new` is a method call too -- calling the method `new` on the class `OptionParser`. `OptionParser.new do ... end` is a method call in which you are passing a block to the method -- that's what `do... end` does, include a block argument in a method call. That call to the `OptionParser.new` method, with a block argument, returns something. (In fact, because it's a `new` method, we know what it returns, without having to look it up -- it returns an OptionParser instance). Then `.parse!` is called on the thing it returns. Same as if you did, say `"some string".reverse.upcase`. You can chain method calls, right? That's all that's happening. 
Thanks! I can't remember reading that chapter, I probably skipped it. Sadly she doesn't seem to mention refactoring/maintaining software in her comparison which is what I was hoping for and what this argument is about. Anyway: She seems to assume type systems like C or Java have. These points don't hold when using Rust or Haskell (not sure about C#): &gt; However, discovering at runtime that nil doesn’t understand the message it received is not something the compiler could have prevented. These errors are equally likely in both type systems. &gt; The compiler cannot save you from accidental type errors. It's like comparing statically typed languages to dynamically typed ones and using PHP as the reference for dynamically typed languages.
It should be noted that this is a Rails question.
Are you saying you're not familiar with ETL? _(Not being sarcastic)_ 
It usually is in small enough cases. Tools like these are more for when you're moving around larger chunks of data or have more complicated needs for running things asynchronously or with more complex rules than can easily be implemented in a single instance of the application.
Something that isn't touched on in other answers, but is core to understanding this: Almost everything in Ruby is an 'expression'. That means that almost every bit of code you write actually returns something. I'm not saying you should do the following, but as an example: value = 4 other_value = if value &gt; 5 10 else 0 end puts other_value =&gt; 0 `if` actually returns an object just like a method would, thus the stuff between `if` and `end` is evaluated and becomes `0` in this example. Since it's just an object like any other you can call methods on it directly: value = 4 other_value = if value &gt; 5 10 else 0 end.to_s puts other_value =&gt; "0"
Yeah I started picking up on that after I saw end being used for chaining. That's pretty cool! Thanks for the info :)
Just don't over-use this feature, it's really helpful in some cases but you can also create some really obtuse code :)
I believe you could also use the regex `/a(?:z..|.z.|..z)/`
Thanks for this. I have been learning Ruby for 2 months and have been switching between these methods arbitrarily without knowing the difference between them.
Oh I don't intend to haha, it's just good to know. As an aside, if you have any particular references to recommend on "quirky" Ruby features, I'd love to take a look at them! 
No problem! No, I'm generally familiar with the term, it's just such a complex issue, and the gem seems really simple. The hard part of ETL processing isn't the flow management, it's the bits inside each of the stages. I don't see how this gem helps with the hard part - it seems to be automating the easy bit (basically flow control). It seems to simply be a quick model for segmenting the bits - no support for exception handling or error tracking, for example, which is a constant pain point for me. In the Wikipedia article you cite, each step has a dozen possible things to do, none of which are aided (AFAICS from my initial read) by this tool. That's all I'm saying (well, really, clarifying I guess). My question is, what is the value of having this somewhat complex system for building steps, when the steps are so domain-specific and (generally?) unchanging? What's the advantage? I certainly understand why ETL tasks are important, just not how using this gem really makes building, say, a blog scraper, simpler enough to warrant the external dependency?
Returning the receiver means `each` can be used as an in-place `map`. [1] pry(main)&gt; toppings = %w(pepperoni mushroom bacon pineapple) =&gt; ["pepperoni", "mushroom", "bacon", "pineapple"] [2] pry(main)&gt; toppings.each { |topping| topping &lt;&lt; " pizza is the best!" } =&gt; ["pepperoni pizza is the best!", "mushroom pizza is the best!", "bacon pizza is the best!", "pineapple pizza is the best!"] 
thanks! I don't understand now though why simply leaving numberz[a] / numberz[i] even though it would be incorrect gives no results (or just the first 3) when "numberz[a] / numberz[i] ** 2" works
Perhaps, but Ruby is not a functional language, and downgrading `each` to make it less useful to imperative programmers won't make it one. Edit: not a *pure* functional language
Cross-compiled from a mac. Hey, I'd love to program FPGAs -- but to do that it looks like I'd have to use windoze. Not gonna do it. Wouldn't be prudent.
A solution that does it all with a single regex using forward lookahead and a non-capturing group. string = "ambmaksjdhamamzkhgdkjvkkujannz" string.scan(/(?=\w{0,3}z)a(?:\w{3})/) =&gt; ["amzk", "annz"] 
You should probably look at ChefSpec: https://github.com/sethvargo/chefspec We don't unit test anything further but our cookbooks tend to be fairly simple. We do use [minitest-handler](https://github.com/chef/minitest-chef-handler) to run what are effectively integration tests on vagrant as well though. Mostly these look for the proper files, check that services are listening on the proper ports, etc.
Right. It supports watches too -- yet we don't see anybody complaining that they can't use a watch as their development machine. If you want to develop for only Android in Ruby using a machine that is not a mac, use Ruboto. This product requires a mac. If you don't want a mac, this is simply not the product for you.
I didn't realise that it was such a controversial opinion. Sorry!
Rack 2 is on its way: https://github.com/rack/rack/blob/master/lib/rack.rb#L21 Rails 5 will depend on Rack 2: https://github.com/rails/rails/blob/51211a94bd7a34d80f2412a7f94fefe7366647a5/actionpack/actionpack.gemspec#L24 So I believe it will be released soon. The materials you linked are quite date by the way :)
It's not controversial. It's just silly.
I didn't realise it was meant to be OS X only, it doesn't actually say that anywhere. I always thought it was supposed to be like phonegap: develop wherever, build 'in the cloud' or whatever and deploy to app stores on whichever build targets were wanted. The recommendation for Ruboto is cool though, I'll check it out.
Outside of the Rails core team, not much gets discussed about the dependencies until major releases actually occur. Watch the floodgates open at that point.
Rubymotion essentially maps to the cocoa api's correct? Honestly while I know I could learn it, I just haven't found myself being particularly interested with those APIs. Populating table views, learning what pieces I need, etc. I found that to be a fair bit different from most other development i've done. React native I find to run decently well, and I'm already familiar with developing content in that way. Plus I find getting content to display is much quicker to code, than using the interface builder, or coding UIKit.
If Rack 2 is on its way, then it sure doesn't look like the Rack 2 that past discussions talked about. They talked about supporting Websockets and evented servers like EventMachine. None of those goals worked out; in the end nobody knew how to do it in a way that isn't either complicated or implementation-dependent.
Rack request exists and does not have huge complexity. However it is certainly more complex than a simple hash gives indication of.
Hi there, Passenger author here. In my opinion, Rack is still a very good interface for most purposes. Although the corner cases caused by newer developments in the HTTP world are pretty painful. It suffers from pretty much the same problems as WSGI. ## Websockets No support for this at all. This is currently being "solved" by either using server-dependent APIs, or by using the [Rack socket hijacking API](http://old.blog.phusion.nl/2013/01/23/the-new-rack-socket-hijacking-api/). More about the Rack socket hijacking API later on. ## Server Sent Events, or more generally streaming responses The Rack specification does not specify when response chunks should be sent over the wire. It is server-dependent. The situation in practice is... complicated. Most servers sent out each chunk over the wire immediately -- the only exceptions are Thin and WEBrick. But this is complicated by the fact that Nginx buffers the entire response, negating the advantages. If you turn off Nginx buffering then you open your app to slow client attacks. Only Passenger fully solves this by allowing streaming *and* offering slow-client-protection-buffering at the same time. So your specification should specify when data must be sent over the wire. The Nginx buffering situation will still hit you, although I believe it doesn't really affect you because Erlang already supports massive I/O concurrency. Additionally, I'm thinking about introducing Elixir support in Passenger some time in the future, probably in 2016. ## Support for evented servers such as Thin + EventMachine Central to Rack is the application object. Rack expects that when you call the object, it performs all its work and returns a response tuple. This works on servers that use blocking I/O (i.e. servers that are multi-process, multithreaded or multi-fiber), but not in evented servers such as Thin where the execution life time of the request is decoupled from the life time of the call stack. I heard that Clojure has a Rack-like standard too, and they solved at least the problem of call stack life time coupling by splitting the application object call into two calls. First, the server calls a method on the application object to indicate that a request has begun. Then the application is supposed to call a callback method some time later, indicating that it has generated a response. However, this only solves part of the problem. For applications and middlewares to be truly server-independent, they must be able to perform operations in a non-blocking manner. This requires some kind of abstract I/O API that works on both evented servers as well as servers that use blocking I/O. But this is a huge undertaking, and implementing this undoes much of Rack's simplicity. So far, nobody has bothered because Ruby only has one evented I/O implementation, namely EventMachine. So everybody uses the EventMachine API directly. I have no idea how much of this problem applies to Elixir. Since you are built on Erlang, maybe your entire ecosystem uses blocking I/O. If that is the case then you are not affected by this problem. ## End of response problem It is a common pattern in Rack middlewares to call the next middleware, and then when the next middleware has finished, to perform your own work before returning your own response. However, the act of detecting when the next middleware has finished is surprisingly awkward. One may be inclined to think that when `@next_middleware.call` has returned, you can do your own work. But the fact is that `@next_middleware.call` returns a body object, and the body object's `#each` and `#close` method can perform additional work that may interfere with you. So to properly detect when the next middleware has finished, you write an object that wraps the next middleware's body object. When `#close` is called on your own object, *then* you can do the work you wanted. See the `Rack::Lock` middleware for an example of how awkward this is. I think we can do better but I have no concrete proposal. ## Input rewinding There is a field in the Rack environment object, `rack.input`, that represents the HTTP request body. The biggest problem with this is that reading from `rack.input` is a destructive operation. When a middleware reads data, the data is gone unless the middleware goes through some effort to preserve the data. Here is a common problematic pattern. Suppose you have middleware A followed by middleware B. Both A and B want to inspect HTTP POST parameters. So A consumes rack.input and parses the POST parameters. Then A calls B. B consumes rack.input to parse the POST parameters, but rack.input has already been consumed by A. If I remember correctly, middlewares in the Rack library solve this storing any data consumed from rack.input into a temporary file, and then changing rack.input to point to that file. I suppose this works although I'm not entirely happy about this. This behavior isn't documented anywhere; the Rack specification doesn't list this as a requirement for consumers of rack.input. I tried to push for the concept of rewindability. I wanted to say, all servers that implement rack.input must provide some kind of buffering mechanism so that consumers can call `#rewind` on the rack.input object, allowing them to consume the stream again from the beginning. One of the reasons why I pushed for this concept, was because I saw that a lot of real-world code tried to call `#rewind` even though the Rack specification didn't allow this. The Rack authors and authors of other servers eventually voted against this, because they wanted to keep servers and the Rack specification simple. I suppose both approaches are valid. But whatever you choose, make sure it is clearly specified. ## CGI headers Rack uses CGI-style header names. This was fine when Rack was invented, because for a long time a lot of people were familiar with CGI-style solutions (including FastCGI). However, CGI is so out of fashion nowadays that I think CGI-style header names would cause more confusion that it's worth. This isn't a problem for Rack, but you should seriously consider not using CGI-style header names in your own standard. ## Header casing Make sure you clearly specify the casing of headers. In Ruby, a Hash with String keys is case-sensitive. This causes problems for middlewares and servers that want to check whether a specific header is set. They currently have to downcase the entire header hash table to check whether a specific header is set, which is bad for performance. If in Elixir it is possible to have hash tables with case-insensitive keys, then you are not affected by this problem. ## Socket hijacking Supporting WebSockets is very non-trivial. WebSockets is too different from normal HTTP. People tried to solve this with the Rack 2.0 effort, as was discussed a few years ago. But in the end, nobody figured out how to solve this. At the same time, people need WebSockets, and they need it yesterday. So at some point a few Rack authors were like 'fsck it', and introduced "socket hijacking". This allows the application to take over control from the server over the raw TCP connection, so that the application can do whatever it wants, such as handling WebSockets in background threads. It is quite clever. It is clearly a hack, yet it is a very useful thing to have. However the API is quite messy, and also badly specified. There is a lot of [undefined behavior](https://github.com/ngauthier/tubesock/issues/10#issuecomment-72539461). I do recommend that you have a socket hijacking API, but I also recommend that you specify it more clearly. ## Conclusion So, this is all I can think of from the top of my head. Maybe there's more. I'll update this post if anything more comes into mind.
Hi Jim, thanks for your article. There are a few things that confuse me though. The most relevant to me is: why are we cloning nodes when they are immutable? What is the point of going through a method as convoluted as `next_children` when we could simply pass `children` to the Node constructor? I'm talking about going Node.new(self.name, @children + [new_child]) rather than Node.new(self.name, next_children + [new_child]) 
I heard them say a few months ago they would look into Windows support if there was demand there but I don't think anything's changed.
&gt; I am likely to end up following them unless there is an obvious alternative set of names. Why not just Use Http-Header-Names? By the standard, This-Is-The-Most-Wellformed-Format – I'd actually transform something-like-this to Something-Like-This once after parsing the HTTP header itself, and then I expect everyone to use that. NO_MESS_LIKE_THIS - This is a scheme that originated in CGI, as noted, by the fact that these were passed as environment variables. FastCGI copied this scheme to remain as compatible as possible. But, I don't see why a Dev should care if FCGI or whatever is used. I know that HTTP is used, and that's what I'd like to use. &gt; I will keep considering this but my current feeling is to very actively NOT support websockets. At least have a "socket hijack" pendant. It's a useful feature to have in general. I want to use WebSockets, and I want them to be able to be used easily. Without another running service, without a mess. A plain "request.acceptWebSocket()" should suffice. However you solve this, if "plug" is capable of offering something similar, then that's good too. In general, I come from C++/Qt before I did ruby/rails, and there you have signals/slots everywhere ("Evented computing" or "publisher/subscribe" are other names for that). I think that it's a good idea to use it in web applications too. Projects like Node.JS proof this. Rails suffers from this: How do you pump stuff from one connection to another? Hacks. With such an evented set up, the common controller actions (or however you call them) look the same to the developer, but s/he is able to make use of the more advanced functionalities of it if needed without any hacks, as that's possible by design. Especially thinking about event driven protocols like WebSockets, this is especially interesting as one could support accessing the same routes from a HTTP request and from a websocket JSON packet. I'm currently wondering how I'm supposed to do this with my Rails project, and it's not fun. It feels like reinventing a wheel. Why hasn't anyone solved this yet?! Sources: I implemented a C++ HTTP server library with WebSockets et al.
&gt; Does Rack 2 change the Rack API in significant ways? Yes, it will support WebSockets and use a new API for middleware. Old middleware will be able to use a wrapper to continue to be used, but lose out on most new features. &gt; Are there any docs or write-up anywhere? No, because it isn't done yet.
Well using the phonegap example again their lowest rung paid plan works out at about $120pa which I think is pretty reasonable- that's a small yearly cost to be able to build for ios, android and windows phone. The main difference there is you only pay for the build service and the tools are open source, whereas rubymotion is more geared towards provide your own build platform (OS X) and subscribe to the tools. Glad to see rubymotion is still doing well, I'll get to try it one day :-)
Try codeacademy
Have tried it, didn't like it. Felt like I was just writing code without actually learning anything. I've done Chris Pine's Ruby tutorial and am going through the Well-Grounded Rubyist, but I learn better through a course. 
Do [the Ruby Koans](https://github.com/neo/ruby_koans).
Thanks! Could you tell me what the UoW course is called so I can find it? Also, I know Ruby and Python are similar enough, but I don't want to start over with a new language because then I'll have wasted the last few weeks of learning Ruby. I'll have to relearn the Python syntax and all its nuances.
I guess I'm not sure what exactly you're looking for then, as there are a ton of excellent resources out there. What exactly do you mean by a course? Lectures? Interactive tutorials? Books? 
Two sources I found helpful: * [Treehouse Ruby courses](http://teamtreehouse.com/library/topic:ruby) * [Codeschool Ruby Track](https://www.codeschool.com/paths/ruby)
BerkleyX's programming for software as a service classes were rails-focused
&gt; Bloc - $4,999 for web development bootcamp &gt; Viking Code School - $11,800 or 18% of your first year's salary &gt; Hack Reactor - $17,780 Hory sheet! Really? Wow.
eDX's Saas courses are entirely Ruby.
There's also [Learn Ruby The Hard Way](http://learnrubythehardway.org).
[Pragmatic Studio](https://pragmaticstudio.com/) has a set of Ruby and Rails courses. They aren't cheap, but they're pretty good (though a little light-weight). 
&gt; Hack Reactor - $17,780 wat
When you use string interpolation, anything that is inside the `#{}` brackets is evaluated as Ruby, same as if you did it outside of the interpolation call. The only difference is, [the result gets `#to_s` called on it to convert it to a string](http://www.rubysteps.com/articles/2015/customize-your-ruby-classes-with-to-s-and-inspect/). So, one way to think of this is to write the (non-interpolated) Ruby code that returns the result you want, and stick it in the interpolation: `"something that uses #{params[(klass.to_s + '_id').to_sym]}"` There's a lot going on there though, making it hard to read (for me, anyway). So you can pull that Ruby code to its own line, and store the value in a variable: key = (klass.to_s + '_id').to_sym "something that uses #{params[key]}" and if you're doing that, you may consider not evaluating any ruby code inside the interpolation, other than a simple variable: key = (klass.to_s + '_id').to_sym value = params[key] "something that uses #{value}" Often times, when you're dealing with a tricky syntax issue like what you experienced, you'll benefit from pulling the different pieces apart.
* [Odin Project](http://www.theodinproject.com/courses?ref=home) * [Michael Hartl Rails Tutorial](https://www.railstutorial.org/book) * [Code Wars](http://www.codewars.com/) * [Ruby Warrior](https://www.bloc.io/ruby-warrior#/) * [Ruby Monk](https://rubymonk.com/) * [Ruby Koans](http://rubykoans.com/)
As @nmtake pointed out, it's a precedence problem. When doing math where there's more than one operator, I like to be explicit about precedence, and use parens even when they don't affect the order of operations. Why? Because then I don't have to think about precedence :) Some people will argue against it... they say you should know Ruby's precedence and that you should only use parens to communicate that you're doing something that differs from the defaults. And they make a good point. As for me... I don't always remember the precedence. I know a lot of other people don't, either. So I make it clear by using explicit parens, that way the only rule you need to remember is "stuff in parens gets evaluated first" :)
Nice! Exercism and Code Wars look like good cross-language concepts.
yeah exercism supports lots of languages... it's pretty awesome
These (at least the last two) are not online courses, but physical campuses where you attend classes with other students. Hack Reactor in particular is for people who are already developers looking to become technical leads or more senior in their development skill. 
Nope. From their web pages: [Viking Code School](http://www.vikingcodeschool.com/program): "Viking is an intensive online training and job placement program... 100% online... remote" [Hack Reactor](http://www.hackreactor.com/remote-beta): "Remote Beta: Join our digital classroom." (and if you scroll down, you'll see that it does in fact carry the same $17,780 tuition tag as the in person version)
Wow, just installed and ran it against my project- great improvements to the speed!
fwiw Hack Reactor's Remote Beta is 2.5k up front. if you don't get a web dev job within six months they waive the other 15k. if you do, it comes out of your wages. 
Interesting. I've dealt with HR and didn't realize they had an online only option. My bad. 
hrm, interesting. where do you se that? The closest thing I found was [this blog post on financing](http://www.hackreactor.com/blog/announcing-need-blind-admissions-for-hack-reactors-remote-beta-immersion-program) which doesn't match your description, and looks pretty complicated (to me).
hack reactor lists need-blind deferment on their [faq page](http://www.hackreactor.com/questions/): &gt; Our online Remote Beta course allows US applicants to defer tuition on a need-blind basis. After being accepted to the program, students can defer up to $15,000 of course fees until after finding a job. but your link says it is discontinued: &gt; PLEASE NOTE: The need-blind program is no longer being offered. You can now apply to finance the program through one of our lending partners. i'll shoot them an email and see what's what. 
I don't like Rubocop-like tools. Coding-style talibanism is a questionable ideology.
What makes you say that? :)
DevBootcamp also teaches Ruby
How often do you read other peoples code? Does anybody have to work with your code later on?
&gt; reasonably close to the community-wide language code style *Reasonably*. Rubocop makes the style rules a law, when they should be a guideline. 
Thanks for the suggestions, I'm also working with Chefspec but wanted to square away Rspec first as it was suggested. Will check into minitest as well. Thanks!
I don't see anything rails-y, but anyone can feel free to correct me. 
How long was it taking you to run before? Even on my large-ish projects it was never long enough for me to open up reddit. Maybe my large-ish projects aren't as big as I thought. :|
Only a few seconds, but with repeated runs it is completing in the milliseconds range.
Coming from Linux, I can only describe that as a very strange workflow. Normally you execute a ruby script by browsing to the directory it is in, within the command line, and running ruby filename.rb 
Look into something like phantom-js or poltergeist. 
Soon. Need to finish the `readme` and fix a few things. 
 line = "client.like reblog_key:W3UmPOmT, 'id:105694540945'" line.gsub /reblog_key:(\w+), 'id:(\d+)'/, %q{\2, '\1'} =&gt; "client.like 105694540945, 'W3UmPOmT'"
It saves developers from having to code review stylistic changes. That, in itself, is worth it.
That's because it's no accident at all and is less to do with duck typing and more to do with actual theory. A pure function and a hash map are indistinguishable. In fact if you remember bits and pieces of calculus you won't be surprised to know that in set theory functions are equivalent to their graphs. A hash is really just the "graph" of some proc and when you memoize a proc you essentially turn it into a hash.
Consistent style is helpful for teams and collaboration. One or two junior devs can unleash hell on a codebase. Rubocop and tools like it help keep everyone on the same page.
What is the nature of your trouble passing a code block with `do... end`? It should work fine, I'm not sure what you mean about why it's difficult or impossible. 
I meant to say that I tried passing one or more inline blocks to a method without the brackets. As method arguments I guess. 
I've used ruby in windows with puppet. You'd normally execute it the same. I'm not sure how OP got the idea to drag the script over.
Really interesting idea. Related, any idea why I'd want to use #() with Proc? This syntax always feels weird to me: `some_proc.(a,b)`
I'd go for the alternative: get the mp4 length as metadata from the mp4 file by downloading a reasonable portion of the file (256K?) and parse that. MP4 files for progressive download *should* have the metadata *before* the data.
I started off in a non developer position at a .NET workshop and learned Rails on my own time. After having proved some competency, I was promoted from support to product implementation. I excelled there and was promoted to team lead. Throughout my career with the company, I created Ruby scripts and simple applications as well as proof of concepts that would allow me to do a better job. My proof of concepts started to get some attention and I stepped down from a team lead role to become our company's first Ruby developer. 
&gt; The situation is more frustrating for boot camp graduates because they’ve paid very high tuitions, forgone their regular incomes, and put their lives on hold for several months, but they’re not getting what they’ve been promised - high starting salaries, in an exciting industry All parties involved are guilty. The "boot camps" for severely flubbing their placement and salary numbers, and the students for letting greed override their better judgement which would have hopefully led them to the realization that something that sounds too good to be true probably is. 
I didn't know about `$stdin.noecho &amp;:gets` or `$stdout.reopen` until about 7 years in... so while this is foundational stuff, I think there's definitely still something for people to learn - especially ones that aren't as far along in their programming careers as you may be.
Short answer: The value is of the tool: DSL to describe ETL workflow in OOP way (an partially in functional), make it modular &amp; simple to understand. The value of ETL: Achive Single Reponsibility (don't mix queries with transformations and persistence) (more explanations are below) 
Hopefully now that free starter edition is available, a whole new set of developers will gather around it, causing at least an increase in the "home-made" support resources available... When the only barrier to going live is removing the free starter edition spashscreen, perhaps more devs will be more motivated to switch to the paid version. If this happens and goes after RubyMotion plans, then I really hope the condition you have depicted about support and ecosystem will change. From a business-model point of view though, I think it's undeniable they made a good move. I just hope they will keep this growing up.
I didn't do it for greed, and I think it should how little perspective you have on the matter for thinking that greed is what brought most of us to the industry.
The main goal of this tool is to makes communication between developer and codebase simple. Of course there is a certain level of 'getting started' overhead, however it completely pays off as rails application starts to grow. That's right that it's very small (&lt;100 lines of the code) but it took us more than 3 years to find a proper way of describing workflows with ruby.
&gt; instead of all the module-building, why not a monolithic WebScraper class? 1. Testing. i.e. if you have a particular module it's very easy to mock the state. i.e. Transform: just mock state you need and pass it to the described class. No need to fake server response when testing transformation (screencast is coming) 2. Code quality - detect flaws faster. i.e. adding a small method doing some calculations to the model usually passes almost any code review but over time it tends to grow (and very badly). The main point here is to make sure that adding a operation to the wrong place looks suspicous at the first place. For instance a small transformation on "Load" stage looks very suspicous. 3. Code duplication starts to smell fast. If there is a couple of Extract modules for different workflows but all of them look alike. Sounds like a clear sign to do something about it. hope this helps!
So there are a couple pieces to this puzzle... The first is understanding Ruby-specific syntax like blocks, and behavior like `instance_eval`or `call` to evaluate those blocks in a certain context. The other pieces really are understanding how this is implemented - and typically you want to separate the high-level DSL part from an underlying object structure that provides the behavior. This is known as "porcelain" and "plumbing" - which I first heard used by git. I've written a whole article called ["Express your domain clearly with DSLs"](http://www.rubysteps.com/articles/2014/express-your-domain-clearly-with-dsls/) which should help answer a lot of your questions, and understand how this stuff works. It even uses an RSpec-like syntax for the examples :)
If someone had 5+ years professional dev experience I would wonder what the hell they were doing messing around with some boot camp...
Well, if you want to *pay* to get yourself a massive headstart jumping into a new domain, rather than learning yourself over the same time, that's perfectly fine. The constant over-the-shoulder advice from people who are already experts in the domain is also great. It's the same as a lot of undergraduate university degrees: if you were *really* self-motivated and disciplined, you could buy the teaching material for most courses that make up the degree and learn yourself everything the uni degree teaches you for a fraction of the cost. But in this case you're paying for the structuring of the degree, the expert help, additional learning resources, the certification the uni provides.
They're not flubbing anything. A lot of graduates, even from Ruby/Rails programs, get jobs writing something other than Ruby. A ton of people from the Rails program I did are getting paid to exclusively write everything from JS to Java to Salesforce.
Ruby inherited (and improved) the very convenient `ARGF` idiom from Perl; this variable acts as a sort of "pseudo-file" composed of all of the file arguments supplied on the command line (as well as standard input, if it's nonempty). Thus, you can use `ARGF.read` to get the contents of all of the files in one fell swoop. With that in mind, here's my approach: p ARGF .read .upcase .delete('^A-Z') .bytes .map { |b| b - 64 } .reduce(:+)
The Ruby community didn't seem to inherit TIMTOWTDI though. 'My way' is always better for rubyists it seems. 
I really like SettingsLogic https://github.com/settingslogic/settingslogic
First of all, for hosting code snippets, use something like gist.github.com or pastebin. It's much better than taking screenshots of text. Currently, your program doesn't work. I'll explain what your program does now, skipping the 'getting' of `start_year` and `end_year`. while start_year &lt; end_year so you are looping over something, till the `start_year &gt;= end_year`, i.e. the negation of `start_year &lt; end_year`. This is the first mistake, since you need to include the `end_year` in your list. Currently, if `start_year == end_year`, `start_year &lt; end_year` will be false and the loop will halt before considering `end_year`. if start_year % 4 == 0 Currently, you say something is a leap year if it is divisible by 4. That's not completely completely correct. If something is divisible by 100 it is **not** a leap year, unless it is also divisible by 400. So 1900 wasn't a leap year, but 2000 was. In pseudo code, this is: divisible_by_4 &amp;&amp; (!divisible_by_100 || divisible_by_400) or, in ruby year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0) Then we have start_year += 4 ok, you've found a leap year and now your jumping to the next candidate. elsif start_year % 4 != 0 Ok, this is where it get's a little wonky. First of all, if `if a % 4 == 0` is false, then necessarily `a % 4 != 0`, that's just logic. So your `elsif blah` can be replaced by a simple `else`. Then you do start_year -= 1 and are counting down until you find a leap year. Currently, this might work, but when you take the real conditions for a leap year into account, you can get stuck in a loop! Take `start_year = 1896`. 1896 is a leap year, but 1900 = 1896 + 4 is not! 1900 is divisible by 100 but not by 400. 
Are there any pros or cons to making my app a class as opposed to a module? Right now I've been considering everything a module, but I'm not opposed to moving it into a class structure if there aren't any issues doing that over the module route. What do you think here? 
Thanks for pointing me at this! Looks really useful, hadn't heard of it before. Much appreciated!
 class Year def self.leap?(y) (y%4==0) &amp;&amp; (y%100!=0 || y%400==0) end end 
Post a concrete code example.
By green field I mean you get to create everything brand new instead of having to work with old existing code.
Thank you for all your notes, I will take them into consideration and attempt this challenge again in a few days. PS, I didnt even realise 100th years were omitted
You should find this post useful: http://www.justinweiss.com/blog/2015/02/24/how-to-configure-your-rails-app-to-ship/
I like the config gem: https://github.com/railsconfig/config
Good letting people know rbenv can gobble disk space with lots of old gems/rubies, but I expected the "how I fixed it" part to be something more than, "I clobbered it and started over". 
A good read, especially with the Trailblazer architecture in mind. I really like the SOA architecture when working in an ecosystem where you have multiple connected applications, but this is a good point against using SOA to split complexity rather than domain. How do people feel about this? Has anyone pared back an SOA into a single stack, or the reverse?
Not every blog post is meant to contain a "20-Steps-to-Success" instruction list. Sometimes they inspire people in 19 paragraphs and then have just a handful of links. Clickbait for what?
You mean, like... require File.expand_path(File.dirname(__FILE__) + '/hex') Which would pick up the file if it's in the same directory as the other file?
Yep that syntax will work. Just need to specify the full path of the file at the top of the main program. require '/path/to/file/hex.rb'. Or you can require it relative to the location of your main program. So lets say your hex.rb file is located back one directory. require_relative '../hex.rb' Try opening IRB and practicing. It will return true and you'll be able to call your hex method if you got the syntax right.
He likely had a buttload of old Rubies that he's not using for current projects anymore. Run `du -hsc $RBENV_ROOT/versions/*` to see what your junk drawer looks like, then `rm -rf $RBENV_ROOT/versions/jruby-9.0.0.0.pre1` (or whatever) to delete versions you no longer use or need. My installed versions are currently $ du -hsc $RBENV_ROOT/versions/* 319M /usr/local/rbenv/versions/1.9.3-p550 292M /usr/local/rbenv/versions/2.1.4 808M /usr/local/rbenv/versions/2.1.5 624M /usr/local/rbenv/versions/2.2.1 696M /usr/local/rbenv/versions/2.2.2 238M /usr/local/rbenv/versions/jruby-9.0.0.0.pre1 2.9G total $ I lived in 2.1.4 an excessively long time, obviously.
You'd probably have way more luck selling your book if you had some sort of useful information on the site or an excerpt. As it stands now, this is just an ad, which is why I downvoted it.
Not a lot of useful information contained within, I'm afraid. 
Yes you can, unless you've been using the same version of Ruby for multiple projects. I hadn't realized that old versions of gems could come to represent such a fat amount of disk space.
Just note writing `.rb`extension is superfluous, at both `require` and `require_relative` methods.
&gt; Rather steep learning curve because there's lots of "magic" going on I think that has less to do with the framework itself and more with the fact that many beginners who learn Rails don't bother to learn Ruby first. Once I understood the basics of Ruby metaprogramming a lot of the Rails magic made sense. 
There's a lot of implicit stuff like passing of instance variables from controller, content type negotiation, default template rendering etc. With simpler and more explicit frameworks you have a pretty good idea what's going on, not so much with Rails. Explicit is easier to learn while implicit is easier to use once you have some knowledge and experience.
Introduces performance reduction, but I think all #to_procs do. 
Holly crap, that's clever! 
It's true that `Symbol#to_proc` is less performant than opening an explicit block on any modern Ruby, but you might not know that recent versions of MRI go out of their way to optimize the common case of, for instance, using `#reduce` with a bare Symbol: [ -&gt; { [1,2,3].reduce &amp;:+ }, # :send -&gt; { [1,2,3].reduce :+ }, # :opt_send_without_block ].map { |code| RubyVM::InstructionSequence.of(code).to_a[13][6][0] } **Edit** to point out that "recent" apparently means 1.8.7+.
Do the Ruby koans.
The pros: * Fast development * tons of gems * fun to program in The cons: * steep learning curve * too easy to write messy code * outdated directory structure * Huge memory footprint * Slow 
You are [apparently not alone](https://github.com/randym/axlsx/issues/276). Try bumping [this issue](https://github.com/randym/axlsx/issues/352) to see if you get any answers, but you may need to explore alternatives to axlsx at point, it is not likely the situation will improve in time for you.
can you integrate the capistrano recipes/provisioning goodness implemented in this rails template? https://github.com/mattbrictson/rails-template
I just backed it for $35.
Neat, but what you save in keystrokes or gain in cleanliness you lose multiple times over in readability.
Configuring a gem in an initializer is a workaround? 
Yeah, you are right. Never though about it that way until now. But then again it is less intuitive then the other two. Though as it's not documented it seems more like the feature of another gem and not Paperclip. But you have a good point. Must admit, I was wrong.
Used in production as a gateway/mapper API for existing mobile APP. Tests show that slowdown was only 0.5%. Probably because application behind API gateway was quite slow and ruby spent lot of time in IO and performance hit of contracts was negligible. And it does help to reason about code better. Especially if you use it as a Design by Contract, not type safety mechanism.
On the other note, I agree having compile time type safety is even better.
Well, pattern matching does simplify code, at least, in my opinion - it makes different code paths look more declarative, instead of having imperative if/elsif/else statement.
I agree with your issues on refile -- even the basic DDoS avoidance they they have integrated is all horribly engineered looking at the source. For instance instead of just doing a white-list configuration of allowed resize sizes with a simple caching in front of the refiler they build this ridiculous crypto signing url crap to try to prove that the developer was the one who inserted the url construction into the html and not the client... I got a headache reading through the code it is so backwards. 
Daniel, your work has been incredibly helpful for me when testing out ideas for new projects (to minimize the app initialization process). I really appreciate everything you have done for the community, and I hope you are given the support you deserve. Also looking forward to seeing these new templates. Thank you!
People are talking about the pros and cons of Rails Composer: [new rails developer here - should I use an application generator?](https://www.reddit.com/r/rails/comments/3k9evl/new_rails_developer_here_should_i_use_an/) on the /r/rails subreddit. Great to hear your perspective.
I can understand that; well done. I've used DBC in several other languages to help keep our heads on straight. (I *miss* Eiffel.) Ruby, like most dynamic languages, seems implacably hostile to the concept, doesn't it? You can either use DBC or you can write Ruby that the team carrying on from you can understand and deal with. Or maybe I'm just over-thinking this; it wouldn't be the first time. Thanks for sharing.
Disassemble other people's work. For example, go through the entirety of [ZenDesk API Client](https://github.com/zendesk/zendesk_api_client_rb) gem. Once you understand it all, you can go on irc and be smug about it, like everyone else there :)
I would recommend the reinventing the wheel method and caviarpropulsion's answer, that helped me the most. Once you are comfortable enough with pure Ruby try to learn how to write clean and readable code. Turns out that is important :) And learn how to test your code, that is perhaps the most important thing. Tests saved me more times than I can count since I learned how write/use them.
That's not a good design pattern to follow. Typically rescue is used in a begin / rescue / end block. If you have a series of conditional expressions to evaluate catching it at the bottom of that block is clear and simple for another developer picking up the work. Are you sure the pattern you're using above even works?
why would ```something.match(regex) ? something.match(regex)[0] : nil``` be considered better than ```something.match(regex)[0] rescue nil```? I'm not arguing, just curious. The second one seems simpler and more concise to me.
&gt; Are you sure the pattern you're using above even works? why would it not work? ```something.match(regex)[0] rescue nil``` is essentially the same as ```something.match(regex) ? something.match(regex)[0] : nil```
I'm not neccesarily opposed to rescue like that stylistically; but one thing to beware of is that raising an exception can be very slow, relatively. So doing this all over, or an inner loop, can be bad for performance. This is perhaps one reason why it's become known as bad practice. http://technicaldebt.com/the-cost-of-using-rubys-rescue-as-logic/ That article also links to a video that explains a pitfall of rescuing StandardError, which is what end-of-line `rescue` does: http://devblog.avdi.org/2012/11/19/rubytapas-022-inline-rescue/
I ask because I've been doing Ruby development for about 7 years and I've never seen that. Frankly I'm surprised it does work. You are showing this in a very tight example. Do you have a larger block of code as a sample? It may be easier to make a suggestion to you based on context. As /u/remigijusj suggests elsewhere here, I highly recommend you take a look at Avdi Grimm's Confident Ruby. So much of Ruby programming is building code that is clear to other developers - while the language may make something concise or terse, it may not be the best solution for helping other developers (or you many months/years later) pick up the code. PS - Nothing here is a slam or harsh criticism. It's a very good question you originally posed.
Interesting - first time I've seen it. Seeing a rescue statement hanging at the end just feels odd, independent of the performance concerns. Most calls that throw exceptions have non-exception versions, which I'd be more inclined to use.
In addition to what others have said its also much slower using rescue. 
If you want to try some challenging programming problems, [Project Euler](https://projecteuler.net/archives) has some really fascinating ones in its archives. I've been going through it day by day, and am really enjoying the process.
as ABC_AlwaysBeCoding said, learning a new language gives you insights into new ways of achieving things. Try something that is very different from Ruby such as functional languages. In fact I just published a [post](https://medium.com/buttercloud-labs/learning-ruby-through-clojure-fee5eb990226) on how I improved my Ruby by learning Clojure.
I don't think there will be something in stblib that would help you. Such a thing requires talking to window manager, therefore you need different library for each system you use. I think the easiest way (take it as a first version, you can optimize later) would be to take screenshots in some interval, then crop the image to area that you are interested in and then do the stuff that you desire. So, search for the gem, that enables you to take screenshots on your OS (I've found one for Windows -https://github.com/jarmo/win32screenshot ). The cropping can be done via ImageMagick.
Can someone explain how Clojure and Ruby work or can work together? I am on the middle of mastering ruby and just recently last week heard of Clojure related to Ruby? I have research some info but nothing concrete. Thank you!
The problem with that is that the project I'm thinking about making would need to be taking dozens of screenshots per second, and if I were doing that, as well as cropping each of them, it could easily use up all my memory, not to mention taking up a lot of disk space. It's a thought though, I suppose... I didn't realize it would be so difficult to monitor the display within Ruby. Bother.
When you say work together, do you mean calling one from the other's runtime? If so, you're pretty much limited to using Clojure and JRuby, since they're both on the JVM.
I'd be surprised if this wasn't related to games somehow. :p
Heh. The responder below is dead-on. I'm playing FF XII, and there's something called a Quickening Chain, in which you press certain buttons depending on what you're presented with. It's easy enough to code an algorithm to hit the best button depending on what you're shown, and it seemed like it would be fun to do it in Ruby. But you need the ability to see what you're actually being shown, and act accordingly.
The reason why something.match(regex)[0] rescue nil is a bad practice is that rescue catches all errors, and there are errors that could occur at any time that you should not be catching (for example system interrupts). The "rescue nil" idiom is only appropriate for casual coding - console commands, one-off non-production scripts, etc. 
System interrupts are not caught by `rescue nil`, it only catches `StandardError` errors. &gt;&gt; raise Exception rescue nil Exception: Exception from (irb):1 from /Users/jonasnicklas/.rvm/rubies/ruby-2.2.0/bin/irb:11:in `&lt;main&gt;' &gt;&gt; raise StandardError rescue nil =&gt; nil
Ffmpeg can output bitmaps from the display pretty easily. You could use that fairly easily to do what you want
http://www.puzzlenode.com/ has some unique exercises, of varying degrees of difficulty. http://ruby.bastardsbook.com/ is a few years old now but some of the projects (scroll to the end of the TOC) could inspire some "web-scraping + data-munging + visualization" type of projects if any of them are into that kind of thing. Not ruby specific, but have you seen Mark Guizdal's computing education blog? https://computinged.wordpress.com/ Has a lot of articles and resources, including this: http://coweb.cc.gatech.edu/ice-gt Good luck! 
I assume you will be stepping them through the basics of the Ruby language: variable declaration, strings, operators, conditional statements, puts and gets, arrays, iteration, methods, hashes, and possibly objects. This may be easier or harder than anticipated depending on the students prior exposure to programming. I think the best approach you can take is to craft simple exercises around each of these topics.
This is a great response. Technically, is there any reason ruby couldn't support a desktop application? 
What are the biggest competitors to Ruby for webdev at the moment? Node?
I guess Node.js and Python.
That is pretty awesome, I think the [RailsBridge Curriculum](http://docs.railsbridge.org/docs/) might be a good place to start. I taught the beginner class a few times to people without prior experience with programming with great success.
Interestingly if you are interested in penetration testing or security tool development, metasploit is a huge codebase written in ruby.
Holy shit I had no idea.
Diving into the rails framework with the Rails For Zombies tutorial is always enjoyable for those new to the language. http://railsforzombies.org/ Its also quite a popular framework for the web and will be useful to have some knowledge of!
I believe you can make Tcl apps in ruby, and there's Rubymotion too for OSX desktop apps (also IOS and Android).
Desktop as in a GIS mapping program or as in an editor like windows notepad? Too slow for the first, might work for the second. Sounds like a project.
At the beginning of the year, I wrote a ruby gem to control motors and interpret GCode for a CNC machine that I made from scrap wood. http://youtu.be/-XWgvHnS8a0 Ruby definitely has uses outside web development.
I didn't know that, but I also hate Python with a pretty strong passion. I do know that Ruby's something like 6x less performant than node.js. Ruby also pretty much entirely lacks the ability to do multi-threaded stuff (you can do it, but it's complicated) where most other languages have much better support.
Love this site.. Nothing groundbreaking, but the overall "social coding" concept has taught me SOOOO much. 
If you think Ruby's beautiful but are frustrated to write anything concurrent or parallel with it, hit up Elixir.
Elixir is great. Now to wait for Phoenix to catch up with (and get ahead of) Rails :)
6x less performant in what?
Succinctly, metaprogramming is "code that writes code".
Threads in Ruby are trivial to work with. This wasn't always true, but those days are far behind us. There are some specific cases where Ruby Threads are less than ideal on the standard Ruby VM, but even in those cases they're not complicated, they just block. If needed, alternate VMs exist with more excellent thread handling (Rubinius and JRuby, for instance). The simplest usage is no more complex than this: Thread.new do # your code here end And your code runs in a new thread. Regarding your "6x less performant", I'd love to see some data supporting that. It seems wildly inaccurate, but compelling data would trump my skepticism.
Seems like you don't understand terms you use. 1. When you say 'metaprogramming' you mean 'functional' 2. Putting 'procedural' as opposite to it proofs 1. 3. The real 'metaprogramming' paradigm is mostly about dynamic identifiers creation, that in fact makes your code real ugly unreadable, ungrepable and so unsupportable shit that the Rails partly are.
&gt; A language that doesn't affect the way you think about programming, is not worth knowing. -- Alan Perlis You'll often hear people throwing around terms like elegance, expressiveness, and readability. I think it says something interesting that these terms are so ubiquitous among Rubyists that it borders on cliché, while many of the conversations in other communities seem to emphasize specific techniques or concepts that language addresses particularly well. Ruby has a strong place in web development, but it has a rich ecosystem beyond the web as well. Systems orchestration and configuration management, security research, distributed systems, text processing, application testing, automation and much more. All of these have widely used tools written in Ruby. There are some areas where Ruby is not a compelling choice, as well. Game development (though RPGMaker uses Ruby), mobile applications (though Ruboto makes this more viable), scientific computing has much stronger support in the Python ecosystem, etc. In my opinion, experience with Ruby has a profound impact on how you write code in other languages, and is worth knowing, regardless of your area of focus.
I think we'll see ASP.NET make a comeback here soon now the MS officially supports it cross platform. I admit it's got my interest (I would _love_ to see Iron Ruby make a comeback with it). Python on the web is OK, but Django isn't really keeping up with Rails at this point. Node.js has really taken off, but I'm not comfortable with it yet. You have package managers for package managers and countless bundlers with someone reinventing the wheel every other month. It's exhausting keeping up with it especially with all the ES6 stuff. I'm going to wait for the ecosystem to mature before I invest a lot of time in to it. 
ruby's been helping to pay bills for the last 11 or so years. it is the most humane language i have learned (over 20 or so years) for making tools that can scale from trivial to mind-bending in a way that lets me learn. nothing of what i do is remotely driven by web-oriented technology. occasionally i rip out a web app because i can, and it makes the most sense for my target deployment. i've developed infosec tools to analyze compromised disk images, index network traffic, boil oceans of alert data, and the list goes on. plus, the existing codebase in rubygems has never left me wanting for a decent toolkit, and i've only occasionally had to break down and write my own implementation of a protocol/format/etc. from first principles.
I agree with the second part, but I disagree with your code. &gt; ```something.match(regex) ? something.match(regex)[0] : nil # error!``` Run this in your console again, its return nil assuming you use "42" instead of 42
&gt; It happens to fit the web very well for a number of reasons I don't think there are any properties of Ruby which makes it "fit" the web (it's a general purpose language and has a terrible http library built in). It's simply because of Rails why it got _that_ popular for web development.
Why do you focus so much on metaprogramming? It's not nearly as useful in the real world as people might think. For example: you can create pretty DSLs with simple method chaining and some blocks.
My point was what would happen when `something` is _not_ a string. In that case the expressions are not equivalent. Since Ruby is not statically typed, you can't generally be sure that your variable is a string. Maybe that seems an improbable case, but from my practice those kinds of errors happen pretty often, especially in bigger codebases. It helps to raise errors as soon as something unexpected happens, and not kick `nil` 10 lines down, then wonder why something totally unrelated shows up.
Fair point.
The point of being a programmer (as in a career) is not to become a "Ruby programmer" (and I say this as a guy that LOVES Ruby). The point is to become a "good programmer" and (don't just take my word for it!) the best way to do that is to be a polyglot and stay language-agnostic.
This is how try is implemented though, send(:symbol) rescue nil
No, it's not implemented with rescue. I was talking about `try` from `ActiveSupport`
What you are asking for is not quite simple, and definitely not part of the stdlib. I'm not sure how to do it. 
Alright. Thanks for the input.
Thank you for being verbose. Very helpful.
There's not much of an advantage. Desktop apps require a lot of deep integration with various OS libraries. So you're better of working in whatever the first class language is on that OS -- C++ on Windows, Objective-C on Mac. If you use something like Rubymine for desktop app development then you lose all of the OS vendors debugging tools and documentation.
&gt; the bash ninjas still laugh at it. Bash is so damn ugly, and I am not aware of any great tools to unit test bash scripts.
Seems like you're unhappy at your place of work, perhaps you should look for an employment situation where you can make better use of your knowledge.
A side note, I tend to think pythons list comprehensions are really cool, and then I go grab a cup of coffee, come back, and have NO idea what I just wrote.
&gt; Some people say that it is because there are a few functions in Clojure that share names with some Ruby methods but that's about it. I wouldn't say that at all, as someone who has switched from Ruby to Clojure for personal projects. First, one needs to understand the general development methodology used in Ruby and Clojure, and I would say the best source for that would be Russ Olsen's "Eloquent Ruby". (Coincidentally, Russ now works for Cognitect, the company that primarily develops Clojure and related technologies.) In Eloquent Ruby, and in large, when looking at real world Ruby projects, you'll see that Ruby users reach for general data structures such as Arrays and Hashes before they start writing custom classes. This is the same focus on general data structures that Clojure users have. Ruby users love to make DSLs and use metaprogramming, and Clojure takes that much farther once you understand macros and s-expressions. This is almost impossible to summarize, but I'll try: Clojure's code is itself written in a tree-like data structure composed of linked lists ([s-expressions][se]), allowing you to write code that writes/modifies code with ease that is unparalleled in the programming world. (Except for obviously in Lisp/Scheme.) There is an overall focus on minimalism of ceremony, as in Ruby. You'll find wonderful succinct shortcuts via macros for common patterns, parameter destructuring built into function definition, and reader macros for common idioms. Examples of these are: - `[]` literals used for defining Array instances. - `{}`literals used for defining Hash instances. - `:keywords` which function the same as in Ruby, which borrowed them from Lisp. - `#"regexes"` literals which have the same regex syntax as Ruby. Boolean logic is the same, where `false` and `nil` are false, and everything else is true. (Both use `nil` instead of 'null', again, as both borrow this from Lisp.) Actually, I should just stop writing, because there's a wonderful blog article that summarizes it better than I could have: http://briancarper.net/blog/536/clojure-from-a-ruby-perspective I would say, if you've done a lot of Ruby, and have read Eloquent Ruby, reading Joy of Clojure or Clojure Programming should show you many similarities in mental model and approach. What would you gain from switching? Particularly incredible metaprogramming, which Ruby would be incredibly jealous of. (And much cleaner than using `method_missing` or `eval`.) And **sanity**: once you start to love the persistent data structures of Clojure and the STM reference types, you'll never want to go back to programming without them. The world of variables and references is a scary place. Or if you're interested, maybe seeing Rich Hickey, Clojure's creator, talk at Rails Conf would help: https://www.youtube.com/watch?v=rI8tNMsozo0 I know, as anyone reading this that knows Clojure will know, that I have severely glossed over the details here and avoided discussing FP and FP terminology, but I'm just rushing out a reply. Sorry, just trying to help those that may be interested in Clojure and need a little push to start looking into it. [se]: https://en.wikipedia.org/wiki/S-expressions
Try golang then. It made me as happy as Ruby did back in the day.
Well done, the second is much more idiomatic. However, the sure sign that you are on your way to being a proper ruby programmer is that you introduced a subtle bug in the 2nd version. ;)
There are thousands of API client gems, what makes this one so special that one can be smug about understanding it?
Yeah, but everyone loves Rails (at least on this sub) and isn't that big testament to metaprogramming? 
There's a wonderful `String` method [`#tr`](http://ruby-doc.org/core-2.2.0/String.html#method-i-tr) which does quick and dirty character replacement for you. It also takes patterned ranges, so a rot13 cipher could be implemented as such: def rot13(str) str.tr("a-z","n-za-m") end Generalizing a bit, we can make it into a Caeser Cipher: def caesar_cipher(offset, string) string.tr("a-z",[*"a".."z"].rotate(offset).join) end Plus, it leaves any unmentioned characters alone, so you don't have to make a check for spaces. "hello world".tr("hw","j2") =&gt; "jello 2orld"
At a previous job, I worked for a high-frequency trading firm. While their high-performance-dependent components were written in C++, glue code and back-office processing of trades was written in ruby.
This is not the Ruby way...
Well, it is used in those but at least in Puppet it really shows all its weaknesses. I would go so far as to say the choice of language was the worst decision the Puppet implementers made.
I smell a homework assignment... :-/
I've seen instances where I agree with you completely, and feel that the methodology behind the code would be far clearer if spaced out into a few lines. Personally, in this instance, I don't find it terribly obfuscating, as the purpose/result of the ternary is pretty clear. All subjective, of course.
I didn't say metaprogramming was bad, merely that it is easily abused, and for those of us not writing large complex frameworks it is often the wrong tool to reach for. Obviously, each use case should be evaluated on it's own merit.
How so? It feels like an exact opposite of Ruby. In Ruby the programmer is given a lot of very powerful tools (e.g. metaprogramming, monkeypatching, builtin regular expressions, builtin subshell invocation with backticks, rich standard library modules like `Enumerable`, etc.) and is trusted by the language to use them responsibly. In Go? Well, [Go was deliberately designed to be very simple so that it's usable by subpar programmers working on large teams with other subpar programmers](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/). In case you're too lazy to click on the article I've linked to here's a quote from Rob Pike himself: &gt; They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. And you can truly feel this mindset when working with the language. In particular I love that [this is what Rob Pike thinks about filter/reduce/etc.](https://github.com/robpike/filter): &gt; Having written [apply/filter/reduce in Go] a couple of years ago, I haven't had occasion to use [apply/filter/reduce] once. Instead, I just use "for" loops. You shouldn't use [apply/filter/reduce] either. No wonder Go is designed as it is. I'm honestly flabbergasted as to why such a horrible language* got so popular. \* - I'm probably going to get horribly downvoted (pun intended) for expressing my honest opinion, but I don't really care.
Hi William, It is very hard to read the code you posted due to formatting! If you could host it [here](https://gist.github.com/) it would be much easier to read and analyze.
As a rails developer - I don't see the point of this project. Most freelancers start a new project every 2-3 months. You're not really saving a lot of time for developers by providing this tool. Most competent developers can get bootstrapped within 15-20 minutes. When you do the math - it just isn't worth it. 
Yeah, best programmers are those who have a desire to learn and improve. What happened in our shop was that we switched from one programming language to Ruby. Same people and same attitude stayed. Same things that were messing our previous code are messing up our Ruby code. And our boss never ever hired experienced developers. I'm not hating on my work buddies. They are great people but that attitude of "I will not try to improve unless you will show me, teach me, tell me" is kinda frustrating. 
Trollop is pretty handy, FWIW.
Ruby is also heavily used in the security realm. Metasploit is damn near 98% Ruby
If you are a beginner at programming, ruby is a good language to learn object oriented programming, since *everything* is an object in ruby, unlike other languages that have some other non-object things floating around (like java) or have object orientation weaved in as an after-thought (like perl).
I would really appreciate your help looking at my first post, for my first script project. Not for any school or assignment other than my own learning. Thanks, bfulb
I find ternary operators hard to reason.
[removed]
Thanks for the source. The data supports the claim, so I'll update my opinion accordingly. Much appreciated!
How long ago did you do the first one? I just saw this problem on CodeWars and I am still solving it like your first attempt. 
yes, it ran as it was programmed which is good. however, I want - "a" to be a variable number captured from a User Input. - "b" to be entered by User after the question "What is your bonus percentage" - it should be any percentage from 10 to 30 percent. THEN I want to either multiply or divide the number entered, against "a" to get the percentage that is rendered by using "b". THAT is how I want to get to a "c" - a number reached by the rendering of a salary number "a" by a bonus percentage choice "b". It is how to write the variable nature of the salary and the % that is stumping me. With straight numbers and math, I am fine. This may not be the right way to approach getting this done. If there is a better way to set this up, I would love to know what it is. I do not know how to express the right 'statement' to make that condition available. Thanks for sticking with me on this! bfulb &gt; a = 1 &gt; b = 2 &gt; c = a + b &gt; puts "a is #{a}, b is #{b}, c is #{c}" &gt; a = 4 &gt; puts "a is #{a}, b is #{b}, c is #{c}" 
One issue you are running into is that you are describing the relationships based on the bonus percent and salary before these variables are declared. The lines that say: n = $INPUT_LINE_NUMBER n2 = $INPUT_LINE_NUMBER are not doing what you think they are in, in this case. It looks like you want these variables to capture the salary and bonus percent that the user inputs. However, since `$INPUT_LINE_NUMBER` is just a nil at the time you do the variable, they actually don't represent those numbers. What you'll want to do is change these lines: print "What is your annual Salary?" sal_bonus["salary"] = gets.chomp to: print "What is your annual Salary?" salary = gets.chomp And do the same with bonus percent. Then, move your code around so the calculations come *after* the capture of variables. Also, you can go ahead and delete the `sal_bonus` hash. Hashes are very useful in Ruby, but this program does not require one. Your script should now look like [this.](https://gist.github.com/anonymous/af604f43af3da8c49e81) However, we run into another issue with the syntax on this line: bonus_amt = (bonus_percent) salary There is no implicit multiplication going on here. Ruby isn't sure what it means when you throw these variables next to them. Specify that you want to multiply them explicitly: bonus_amt = bonus_percent * salary Additionally, since every value passed into Ruby through the command prompt is a string (gets is actually short for "get string"), this multiplication will fail. Let's go back and change the lines that say: salary = gets.chomp ... bonus_percent = gets.chomp to salary = gets.chomp.to_i ... bonus_percent = gets.chomp.to_i Here, `to_i` is short for "to integer". This lets Ruby know to change the string `"100000"` to the integer `100000`. Your code should now look like [this.](https://gist.github.com/anonymous/9338e75a6b3b22f70569) Uh oh! It runs, but the answers are wrong. Looking at the output, the bonus amount is clearly too high. We need to divide the bonus percent by 100 before multiplying it with the salary. However, since the bonus percent is an integer, it can't represent decimal values. Let's change the line: bonus_percent = gets.chomp.to_i to: bonus_percent = gets.chomp.to_f Here, `to_f` tells Ruby to turn the variable into a floating point number, which is a fancy way of saying decimal. Our last step is to fix the error on the line: net_ann_tot = sal_bon_tot * fed_tax_percent A tax percent of 23 doesn't multiply my salary by 23. Though, a tax rate of .23 doesn't multiply my salary by .23 either. It multiplies it by .77 since `1.00 - .23 == .77`. So let's fix that line: net_ann_tot = sal_bon_tot * (1.0 - (fed_tax_percent.to_f / 100.0)) Notice I wrote `1.0` instead of `1`, and converted the tax percent to a decimal. We want to make sure that Ruby is calculating these figure with decimal places. With integers `1 / 100 == 0`, `1 / 2 == 0`, and `999 / 1000 == 0` since Ruby will always round them down. Our final program looks like [this.](https://gist.github.com/anonymous/edef0d88454e1c9d35a1) Happy coding! 
Wow. You seem really, really unhappy. Why don't you find a better job? You know, just save up some cash for a couple months then jump ship for something that's actually challenging. Your coworkers aren't going to get more motivated on their own and it's impossible to make people improve when they insist on stable, paying mediocrity. &gt; Ruby is good only for console apps and webapps. So. What's stopping people from picking up defunct Ruby wrappers for desktop GUI tools or making their own? Aside from apathy and laziness, I mean. What's stopping you from writing a lesser amount of code in another language, then embedding mruby (along with any gems of interest) in your application to call Ruby code to do the interesting dynamic stuff that would give other languages fits? &gt; I'm trying to acquire deeper knowledge of Ruby by studying books like "ruby under a microscope" ... Why bother? Why learn stuff I ain't gonna use in my daily work? That book starts out on parsing text, tokenization, abstract syntax trees, bytecode compilation... Are you really having a hard time imagining the utility of that kind of knowledge or are you just frustrated by an environment full of people that think they *know* a language if they can output "Hello World" to a user? Suppose you make a habit of that kind of study moving forward, learning everything there is to know about state machines, compilers, stacks, heaps, analysis of decompiled code, et cetera. Do you really think it would be a universally useless skill or are there opportunities out there just waiting for people that learn how those things work in depth and that want to apply themselves toward pushing the envelope? Why learn non-Euclidean geometry, lambda calculus or any other advanced skillset when you can punch a clock and do the bare minimum? You do it for yourself, because you want to. It doesn't matter if your co-workers, your colleagues or anyone else around you understands what you're learning or wants to learn anything about it. You have Ruby because people like Matz have descended to the very depths of hell made manifest in C, all because they wanted to program in a language that doesn't feel like eating broken glass. You can't let yourself be discouraged just because someone else doesn't get it.
To quote Sandi Metz, "I'm boolean impaired".
Watir by any chance?
Pretty early on in my learning Ruby, where I was still thinking very much like a Java programmer, doing double-iteration loops (i=0, j=0, iterating through both.) Ruby has a lot of really useful iteration methods that are far more elegant than doing it that way.
You're absolutely right.
That's a very interesting point, I hadn't thought of it from that perspective. Creating constants would perhaps be a more clear approach.
Actually, the only reason I used normal capitalization for the method definition is because that's how they spelled it out in Coderbytes, which I found poor form but stuck with for simplicity. When creating my own methods, I stick to lower case =) Good point though. I hadn't even realized I'd left that before posting it here, else I'd have taken the time to correct it. Also, I hadn't even thought of using a 'case' expression instead of multiple elsifs, that's a good point.
I think the purpose is to preview emails when developing without having to actually send them.
Previews are built-in to 4.1+ https://richonrails.com/articles/action-mailer-previews-in-ruby-on-rails-4-1
&gt; Such a thing requires talking to window manager You can get around this limitation by streaming your screen and somehow connecting to the stream from Ruby. &gt; the project I'm thinking about making would need to be taking dozens of screenshots per second You might be able to sample from the stream quickly enough. I have no idea how to connect to a video stream from Ruby.
...isn't [0,0] the typical coordinate for top-left in most screen-based grids?
It is. In my experience, people who don't know that [height, width] is standard also won't know that [0,0] is the top-left.
Thanks for the 'both' correction - amended docs and gem spec!
Hence &gt;most screen-based grids Just about any graphics library puts the origin at top-left. Math/graphing/whatever is its own, completely separate domain.
Sure. Why not. You don't have to be faster than the wolves, just one of your friends.
I've found that transferring to ruby isn't your biggest hurdle but using a framework like rails has been very challenging due to all the automagical behind the scenes things that rails does. It's great if you know it inside and out but really hard to understand for a newbie
Per usual, everyone assumes Rails even though OP only mentioned Ruby. As a non-Rails Ruby developer this makes me sad.
Read the Pickaxe book, cover to cover, after taking an Adderall. You will also then see how trivial it is to write something like Rails.
I find this to be troubling as well. Ruby is a great language and most people see it as "that thing that made twitter."
Awesome that you found a niche outside of convention, but I still like being able to fall into a codebase and not have to spend 9 months trying to understand it before being effective. Maybe this exists outside of Rails, but your attitude is entirely without merit.
Consumer vs Tech markets are fighting again it seems. Tools for other developers are very fantastically written in pure Ruby. There appears not to be an bridge between people who build for society and people who build for people. Lastly an undue hostility against popularity.
I.. don't really know what to make of this comment.
I learnt Ruby by working the [Matasano challenges](http://cryptopals.com). I had a Perl background, and a few weeks was more than enough.
I'm learning a great deal from the Lynda.com ruby essentials videos. However I have no idea how to apply this shit to anything. Learning rails aswell. It has a lot of info on databases and tables. Awesome. But haven't figures out how to apply any of this yet. I feel like I'm retarded and it's depressing the shit out of me. Its only been a few days though.
you'll be fine. rewrite all your shell scripts in ruby, and anything else you can think of. read the class documentation of the classes you use, and Google for solutions to EVERYTHING, even things you think you know. ruby lets you do many things you won't expect when coming from other languages. Also, pick apart a few gems, and turn a few things you've written into proper gems. I find many gems spend a lot of time using the more complex nuances of ruby in order to present the nicest dsl they can. 
puppet, chef, sinatra, nanoc, jekyll, sass, compass, homebrew, vagrant...
you forgot [metasploit](https://www.metasploit.com/)
No shit Sherlock. But that's not at all my point. Do you only read what you assume people are going to say? It's like you don't even speak English or something, "Give me a break?" What?. I'm talking about JOBS, not applications. What are you talking about? See my other comments. EDIT: Woah dude, you got some kinks! Remind me to suppress the curiosity to read comment histories of trolls!
I knew about heredocs, but I had no idea they had all those nifty first-delimiter-based tricks. Thanks OP!
The hostility isn't towards rails. It's towards acting as if ruby == rails.
Interesting. What I find interesting his how the top comment has absolutely no contribution to the original post at all! Like the guy who is learning Ruby is going to be helped by this whiny observation that, thanks to Rails, all of the other Ruby projects are employable. It's almost like the top comment isn't in response to the original post at all!
Oh, yes... you're right. It's not "most people" by any stretch. There is a contingent among the ruby-learners set that is learning it because it's hip. And it's not at all unusual to get a certain kind of response to questions about ruby... where the respondent is framing his response on the assumption that your goal is to use Rails and you are making a website, and trying to be the next twitter. And that Ruby is the magic clue that makes your internet instant millionaire dreams possible.
So, the missing bit of information is, "why is this person learning Ruby?" I learned a lot about Ruby by using Rails. So if I suggest that OP learn Rails as a avenue for Ruby, somehow I'm at fault?
Check out the ruby docs on Tempfile they explain it: http://ruby-doc.org/stdlib-1.9.3/libdoc/tempfile/rdoc/Tempfile.html#method-i-unlink
Have you seen the most recent benchmarks that show Ruby outperforms Python in terms of performance? At one point, it might have been valid to say that Ruby was slow - but as of today, [it is faster than Python](http://www.unlimitednovelty.com/2012/06/ruby-is-faster-than-python-php-and-perl.html) for some general-purpose benchmarks.
Woah, take your meds, buddy.
Hey everyone, I think I found DHH in the thread!
It gives you the chance to name the large block of text (e.g. DOC, SQL, HTML, etc). In some cases editors, like Atom, will pick up on the names like "SQL" and appropriately syntax highlight the heredoc text.
Someone else will have a real answer, but *I thought* temp files of any kind (meaning generated by ruby or otherwise) got cleared out on system reboot. 
For me, the utility lies in how you manipulate those constants. For the two alternatives you listed, you would invoke methods on them by appending the method call to the end: %q(some long string).gsub(...) Also, it becomes especially cumbersome to pass strings like that to methods: connection.execute(%q{ SELECT * FROM ... }, "SQL") Compared to heredocs: connection.execute(&lt;&lt;-SQL, "SQL") SELECT * from ... SQL But ultimately, it's a matter of personal preference. Which is another "little thing" that I like about Ruby. :)
Create and open a file -&gt; File descriptor is opened -&gt; unlink (the file is actually now gone as far as the filesystem is concerned but your process still retains the open file descriptor and is able to read/write on it) -&gt; close (once the fd is closed the unlinked file actually poofs and is really gone). So either you let the process continue till it ends at which time it closes the FD, or you specifically close it when you no longer need the file. .close! will force the fd close to happen as you call it and make sure the file is unlinked, without specifically calling close! (or close) it will only be released on object cleanup which you can force by forcing a GC run -- but you may not actually accomplish the close on the run if the object is still referenced. Short answer: As soon as you are done with the temp file close! it and let the tempfile object lazy clean on GC.
AppAcademy grad here (second cohort)... CaesarCipher brought back memories of the awesome experience @ a/A. I hope you're having a killer time bc the program is definitely worth it!
I just know that my puppet catalog compilation (not even application, I understand some resources are slow to apply when e.g. checking permission of hundreds of files) takes about 30 seconds for a fast node and two minutes for a slow one (with a couple of thousand resources. There are also a few benchmarks by someone who rebuilt the whole thing in Haskell as a one man project (minus some edge cases so it i not usable in production) which easily was an order of magnitude faster without much optimization. Ruby is very much the wrong language for this and being faster than others at the slow end of the spectrum doesn't help much there.
Yes, `close!`is exactly the same as calling `close` and `unlink`, and if you're able to call it, then you don't need a Tempfile, because after `close!` there is nothing more that needs to be cleaned up. I'm in a situation where I can't call `close!`, because I'm giving it to the user, and I don't know when they're going to be done with it. In the above example there is nothing referencing the tempfile, but it's still not deleted. But I guess it should be good enough that Tempfiles are deleted when process ends. Thanks!
You were close. `Tempfile` object is no garbage collected because finalizer still holds its reference ([Tempfile#initialize](http://rxr.whitequark.org/mri/source/lib/tempfile.rb#134)). It may be an implementation bug, probably finalizer should be set through a weakref object.
&gt; you can only access [an instance variable on another object] indirectly Under the assumption that you're referring to `#instance_variable_{get,set}`, what exactly classifies them as "indirect"?
Nothing. That's the one I went through. It has a fair bit of metaprogramming.
Class (re)definition introduces a new `Binding`, which‒for better or worse‒can be stored in something more permanent for later access: class C @@b = binding foo = 42 end p C.class_variable_get(:@@b).local_variable_get(:foo) # =&gt; 42 There's really no good reason to ever (ab)use this "knowledge", of course.
http://rubular.com/
Very nice, thanks.
I think this post is a good overview of regular expressions. It has a good number of Ruby examples that you can try out on irb. http://www.blackbytes.info/2015/06/ruby-regex/
The article includes a way to remove the leading whitespace. The feature request to make it a proper feature of the parser is here: https://bugs.ruby-lang.org/issues/9098
I'm pretty close to acceptance - going to be doing the final interview with Kush Patel pretty soon. Any suggestions for it? And I'm really glad to hear your experience was fantastic! I'd love to hear anything you'd like to tell me about what it was like, and how things were for you once you graduated.
So, uh, [this happened](https://eval.in/432506).
&gt; I haven't worked with RHEL7 yet, but the concept of having /tmp in memory would give you reason to clean it more regularly; not less. Indeed, but it's interesting to be aware that what you write to /tmp might never hit the disk in some distributions. If you really need it to, you have to use /var/tmp instead. &gt; It looks like the tmpfs/ramdisk is not by default You may be right, I assumed CentOS/RHEL would have followed Fedora as it changed to tmpfs by default, but it's entirely reasonable Red Hat delayed the change to avoid breaking expectations. But it's quite possible it may change in the future, and that other distributions start doing the same thing eventually.
That's horrible and wonderful at the same time, on the other hand as a colleague pointed out it's not quite the same as if local variables were shared between class reopenings: https://eval.in/432720
[Better version](https://eval.in/432792)
Sweet!
How do you know that local variables are not visible in any method definitions and that they aren't visible if you reopen a class? Is this something you learned pragmatically, or is it spelled out in documentation somewhere?
Wow, this is really enlightening, I knew WeakRef existed, but I want to learn more about it.
Well, I'm creating image processing helper methods, similar to ones CarrierWave provides (`resize_to_fit` etc.), so after using them people can do what they want with the processed images. But you're right, I forgot the other key feature of Tempfile, it creates filenames practically with a gurantee that it won't clash with any other file. You can still use the "tmpdir" library for that, but it's really convenient to have it baked in into Tempfile.
You can still get into a race condition leading to duplicate records with that code. Search for the term "upsert" if you want to read how to do proper find or create that isn't racy.
Suppose we are designing a website with a restricted section for users only. We redirect users to the login page if they try to enter the restricted url manually. Edit: Provided that the users are not signed in when they attempt to access the restricted url. 
Tom Stuart's Understanding Computation http://computationbook.com
Before we started doing all responsive sites we would detect and redirect mobile visitors to a separate mobile site. We've also used redirects to filter based on geographic location.
Web applications are web sites as well as applications. Search engines index particular URLs and user's bookmark them. What happens when they change? Do you serve up errors to the users clicking search links or bookmarks? Redirects are useful for signaling that content at a given URL is now at a new URL. Redirects also serve to trigger navigation when form data is submitted, you shouldn't use the same URL to receive data as you do to render the response.
Every time you submit a form, it is a POST request. When the data is saved, you should redirect to a GET request that views the record or next step in an idempotent manner... that way if they hit reload it doesn't resubmit the request and add a duplicate record. 
Learn to write tests. I prefer rspec. 
what do you mean?
Write a wrapper for a command line utility you like and use an excessive amount of Regex: https://github.com/mikerodrigues/arp_scan/blob/master/lib/arp_scan/scan_result_processor.rb Or parse some weird protocol you happen to use: https://github.com/mikerodrigues/onkyo_eiscp_ruby/blob/master/lib/eiscp/parser/iscp_parser.rb
&gt; Why limit yourself to Ruby? You shouldn't assume people are limiting themselves. My first year of programming, I barely touched languages other than Ruby aside from minor shell script configuration and some modifications to an LUA script here and there for game modding. It wasn't because I thought Ruby is the only language I'll ever use/need, it's because I wanted to get a solid foundation to avoid duplicating effort by partially learning underlying concepts a multitude of ways, to differing degrees of completion. Now? I've expanded my collection of Ruby books and added some extremely technical volumes on C++, Shell, LUA and algorithms. I'm also tracking the development of [Crystal](https://github.com/manastech/crystal) and [Streem](https://github.com/matz/streem). It isn't safe to assume someone is limiting themselves to one language, maybe they're biding their time and growing into the practice before delving into increasingly complicated implementation models.
also I am still learning so my way was the only way I could do it, thanks for your input!
If you look at the line above: `arr.delete(arr.max)`, you'll see I deleted the maximum number from the array. Hence, I correctly started at position `1` not `2`. The solution you posted above, as well as being (IMO) much harder to read, makes the *assumption* that the maximum number is at the *start* of the array.
First of all: Are you *sure* you need to make changes to the Nokogiri gem? What problem are you trying to solve? There's a very good chance that there's just a bug in your code, or perhaps an existing Nokogiri feature you're unaware of. Anyway, assuming you really do want to go ahead and edit the Nokogiri source code, there are various ways to do this. Assuming this is a proper bug fix/improvement/new feature that you feel will one day be merged into Nokogiri, I'd do the following: 1. `git clone git@github.com:sparklemotion/nokogiri.git`. 2. Make whatever changes you like (don't forget to add tests!), and then `git push`. 3. Create a PR. 4. While your PR is pending, if you need to use your version of the gem in a project, then write the following in your `Gemfile`: `gem 'nokogiri', github: 'my-github-username/nokogiri'`. But as I say, there are various alternatives... For example, you could not bother forking the nokogiri repo. Instead, you could just create a local copy of the repository, make your changes and use `gem "nokogiri", :path =&gt; "/path/to/nokogiri"` in your `Gemfile`. Although this is a very bad long-term solution for obvious reasons. Or, perhaps, you'd like to change Nokogiri's behaviour in some special way with a monkey patch? In which case, you should not need to clone the repository at all; the monkey patch should just be made within your ruby application. (And again, this is *generally* considered a bad long-term solution, for obvious reasons.)
I think we are talking two different things here, I am not going into what attributes I look for when hiring a sysadmin; of course I look for problem solvers that are able to communicate and work through complex issues etc. I am specifically talking about a value trade off when it comes to their ability to glue/automate etc. I can go a little deeper so maybe we can align. Lets start out with a premise, I believe it is important that my sysadmins are able to support each other and the org. To that end, it is important to standardize things like glue/automation where possible to a language that they all understand. If a jr glues a deploy/ci process it is important that her peer is able to jump in and understand/troubleshoot/extend that system. these systems gain technical debt over time just by existing, they need to be maintained and supported. If a new language comes onto the scene that we want to standardize against I have to weigh the advantages for doing that with the costs (opportunity costs for the staff learning the new language, slower time to market, stability issues as they figure out gotchas, reworking the current glue to the new language or now support two glues etc). Even if that process works out to our advantage, the other side of that is staffing. If I go out looking for a new sysadmin the highest value portions of that employee are more of those high level things I talk about above and you are talking about + any specific skill sets I need. When it comes to "basis" skills like I consider glue/automation I don't want to limit my pool dramatically on that but more so on those higher level issues. I know that out of 100 resumes I receive, 75-80 of them will have python experience and 30-40 of them will have ruby,go,or some other glue/scripting. So if we swap to a lesser used language in this area I either must ignore the lack of current knowledge of a large portion of the candidate pool and hope they can learn it and get up to speed or filter down the small portion that do not know the current markets defacto language. Basically by jumping off of the leading language it sets a state where new hires are coming in with a basic deficit OR it limits the pool of candidates to a much smaller pool before I even am able to filter down based on their problem solving abilities/specific knowledge/experience etc. So I guess I am saying there is a definite advantage for a sysadmin being able to use the most common glue language over a lower usage ones (but that is not mutually exclusive, the more they know the better) -- it allows a "no-cost low-risk or neutral" selection for a basic skill set while freeing the hire decision completely to much more valuable attributes. That said, given a candidate that excels at all of the other needs/skillsets I would still consider a hire if they did not know whatever language we had standardized on (IF they made it to an interview). 
Transactions with unique indexes ought to. Although it makes my head swim to think about it, I'm not totally confident. But even if you are just talking single "create" or single "update", not find-and-create -- you're going to need constraints on the rdbms side to avoid possible duplicate records. Constraints is how you do this. 
This is so true. And I agree - rspec is the way.
If you have a unique constraint on the predicate a transaction isn't going to change anything. Without upsert or a unique constraint you need a table lock to do find or create safely.
The easiest way is to use Bundler, and list the gem in your Gemfile with a "path" option pointing to your local checkout. There are other ways. In an ideal world, for making changes, you don't need to point to the gem from an external project at all -- your changes are tested by tests in the gem itself. So all you need to do is make a local checkout, make your local changes (including new/changed tests), run the tests from the gem source itself, pull request, etc. You never need to require the local checkout from inside your project folder at all. We don't always live in an ideal world. When I need to, I use bundler with the :path option. 
Makes sense. But it applies to isolated create or update too, not just upsert, right? 
even if you remove the max you don't have to check if one number equals the max, cause there isn't one number that equals the max. so you start from combinations of 2 numbers. &gt;~~The solution you posted above,~~ ~~The solution I posted was produced by someone else.~~ &gt; makes the assumption that the maximum number is at the start of the array. there is no such assumption, if you throw 1 ( in there &gt; #combination(1) ) you just get the same array. So you actually are checking if one number equals the max where there is no such posibility. So you start with 2 (in there &gt; #combination(2) ) which give you all the 2 number combinations where you add them and check if equal with the max. thanks again for your code, it really helps in my learning process. edit: I made yours into one liner: def subset_adds_to_max?(arr) (2..(arr.length-1)).any? { |length| arr.combination(length).any? { |subset| subset.inject(:+) == arr.max } } end but yours with only the change of 1 to 2 would be faster cause it doesn't check combinations with the max: def subset_adds_to_max?(arr) max = arr.delete(arr.max) (2..arr.length).any? { |length| arr.combination(length).any? { |subset| subset.inject(:+) == max } } end 
This doesn't really answer OP's question: You could render a login form instead of redirecting.
Commented rubygems out as you suggested, no change. error message: bundle exec ruby insta.rb insta.rb:2:in `require': cannot load such file -- uber-ruby (LoadError) from insta.rb:2:in `&lt;main&gt;' Thanks for helping!
I believe you'll either need a Gemfile that defines your dependencies (which I didn't ask if you have) or a [gem_name].gemspec file and a Gemfile that defines the source. Does "gem list" show that you have the gem installed? ps-I've never used rbenv. We settled on rvm at work.
Here's a simple example from some code challenge I did: https://github.com/tgmerritt/assignment/blob/master/spec/class/sentence_spec.rb
The require for the uber-ruby gem will be just 'uber'. So in your Gemfile, you should make that line: gem 'uber-ruby', :require =&gt; 'uber' If I gem install uber-ruby and run "require 'uber'" in irb, it works fine. So if that doesn't work for you (or the bundler suggestion), then there might be something jacked in your environment outside of this. :(
sudo re-install may actually be (part) of the problem. rbenv works by creating a set of directories that isolate each version of ruby along with its gems. When you switch to a version of ruby either globally or for a particular directory/project via rbenv, it symlinks the desired ruby to the relevant path(s). Since you are using bundler to manage gem dependencies you should not need to be using 'gem install' anything, and especially not 'sudo gem install' anything. Bundler should grab and install the required gems, and since the rbenv folder(s) should not be in /root, you won't need root permissions to install into its folders. I suggest the following: * Run 'rbenv list' to make sure you have the version(s) of ruby installed you think you do. * Make sure the default ruby version in the list is the one you think it should be. If not use rbenv to set the global default. ('rbenv use &lt;ruby version&gt; --global', if memory serves me). * Switch to your project directory, make sure you are on the version you think you should be on with 'ruby -v'. One of the notable features of rbenv or rvm is selecting your ruby version per project. If you are on an unintended version look around for your rbenv dotfile in the project directory which is setting the ruby version. Correct as needed. * Verify that all the gems you want for your project are listed in the directory's 'Gemfile' * Delete your 'Gemfile.lock' in the project directory * run 'bundle install' in your project directory * run 'bundle exec &lt;yourfile.rb&gt;' in your project directory - *This is very important*, it makes bundler also play with symlinks and the environment so that your project 'sees' the gems it manages instead of your system gems. 
I was thinking that the gem is properly installed for one instance and not the other. Could this be the case?
running bundle update to try and fix this now.
&gt; you solved it! require 'uber' was what I needed to do. I'm confused; above you said you already tried that: &gt; tried requiring uber - same error 
Do *NOT* use shorthand when debugging. One of the major questions from the start was what name to use with require, since it is *often* different than the gem install name. I didn't mention that the required name was "uber" (I checked) because you claimed you had already tried it.
Awesome! This is great. :) Possible uses... Uber could integrate and bring pets ot you?
One tactic I haven't seen mentioned: [Local git repos through Bundler](http://bundler.io/v1.10/bundle_config.html#local_git_repos). 1. `git clone git@github.com:sparklemotion/nokogiri.git /user/freezkyd/ruby/nokogiri` 2. `bundler config local.nokogiri /user/freezkyd/ruby/nokogiri` 3. Make `gem 'nokogiri'` in your project's `Gemfile` look like: `gem 'nokogiri', git: 'sparklemotion/nokogiri', branch: :master` 4. Run `bundle update nokogiri` any time you make changes to your clone and see how it behaves in your project. 5. Make your pull request and remove the modifications to your `Gemfile` when you're happy.
Yep, an incredible useful feature but really hard to implement in a scalable fashion.
You may be able to extend whichever of the classes/methods/modules of the gemf that you want to change and use your extension. This will keep the bulk of the work, but allow you to customize individual methods.
There was a post somewhere recently (HN?) on confusion over what /dev/urandom really does, and misleading statements in the man pages, that seems relevant. I wish I could find it now. 
wtf, am i not allowed to express my opinion on a public discussion feed these days? times they are a'changin..
Well from what I have googled the main difference is that /dev/urandom is async and both use a CSPNRG algorithm.
I can't think of a problem where a string that has array-like characteristics would be a good generic solution over a custom class.
Here you can find some offers: http://jobs.elixirdose.com/
Thanks!
 &gt; fruits = 'apples,pears,oranges' fruits.split(',')[1..-1].join(',') =&gt; "pears,oranges" &gt; &gt; The gem was written after enountering code that with littered with lines like the above, with repeated splits and joins. The meaning of the code was obfuscated by the chained transformations. I think you've solved the wrong problem. Store the fruits as an array while you're working with the data, and convert the result to a string when you want to display it. If its always the first element you're getting rid of, you can use multiple assignment: fruits = %w(apples pears oranges) head, *tail = fruits tail.join(',') I might be wrong, but it looks like you _might_ have been working with csv data. If you were, and in case you weren't aware, ruby has a [CSV](http://ruby-doc.org/stdlib-2.2.3/libdoc/csv/rdoc/CSV.html) class in the standard library.
It doesn't have a strong presence quite yet in the job market. However, I expect that over the next 6 months that will start to change as some startups who have built parts of their stack with Elixir begin to hire.
No it wasn't CSV data, it was loads of legacy data in forms like: Europe -&gt; Great Britain -&gt; England -&gt; London Spain/Canary Islands/Tenerife Etc. &gt; I think you've solved the wrong problem To a degree that's true. Really, I've made a really simplistic object with the right behaviour, whereas a real solution should have been to refactor to use a proper object. That would have been a really invasive and longwinded refactoring in the codebase in question so I opted for a quicker and simpler solution. Yes, I wouldn't honestly expect many people writing an app from scratch to have a use for this. It was useful in my context though.
Let me turn the question around for you: If you love Elixir and believe it will eventually take off, can you afford NOT to try to find work in it (or in Erlang, which would be binary-compatible), given how valuable you'll be in a few years when it DOES have a healthy work market? When I got into Ruby, it was barely at version 1.8 and Rails was not even 1.0. It was very difficult to find work in it then, but that has paid off *in spades* now. Back then I just loved the language and basically *forced* myself to find work in it because I loved working with it so much. I would advise you to do what you love and not worry too hard about the money. The money will follow your success in doing what you love here. If you like Elixir, take ANY work in it for now, and work your way up.
Don't listen to the haters, I think it's awesome to do novel things with Ruby.
Well when your opinion is "there is no use case for this thing I've never seen before", it seems like it'd up for some criticism.
Yes. https://seneca.systems/careers/product/full-stack-engineer We're hiring full-time engineers to work in Elixir. Bleacher Report also does significant work in Elixir. It's a young language but companies are starting to adopt it in the Bay Area.
Either we need a larger code sample or what you've pasted here is incorrect. There is no constant reference to `ThorX` in this code sample, and thus that error cannot arise directly from this. Can you provide more context? Also look into the Reddit formatting options to help us read your post a little better.
Not yet, but it's something worth looking at. I make small "investments" here and there in things that I think are neat / might be relatively lucrative in the future; Elixir is one of those "investments" for me. Even if nothing comes of it (which I doubt), I feel like learning it and being actionable in it gives me more concepts and experience to draw from. Plus its so damned fun. 
Not per se (yet), but as someone who hires developers, I'd always look favourably on someone who's gone out of their way to learn a new language on their own.
You should rename that file without spaces. first_class.rb would be much better. Change to the directory in terminal and do: ruby first_class.rb 
Still not working even with the name change =[
Use Ruby-style variable naming: event_name say_hi Make use of Ruby's many convenience methods for concision (there are a lot to learn): def initialize @events = Hash.new { |h, k| h[k] = [] } # constructor variation that runs default block on cache miss end def subscribe(event_name) @events[event_name].push(lambda { yield }) # auto empty array created #Also I'm using yield here to trigger error if block not provided (see below about blocks) end def publish(event_name) action_list = @events.fetch(event_name) do # fetch will run block on cache miss puts "key (#{event_name}) not found" # if run, the puts method returns nil, which gets returned to action_list end action_list.each(&amp;:call) if action_list # will not run if action_list is nil end Instead of lambdas, a block is more idiomatic: eve.subscribe(:say_bye) { puts "Bye" } # also, lower-case variable name for instance 'eve' Depending on style, here are some alternatives for the above @events = {} # use a vanilla hash def subscribe(event_name, &amp;block) # explicitly declare block argument raise "No block given" if !block_given? # explicit error action_list = @events.fetch(event_name) do @events[event_name] = [] # explicitly create the empty array on cache miss # value of this block is returned to action_list if evaluated, i.e. @events[event_name], i.e. [] end action_list &lt;&lt; block # &lt;&lt; is alias for push() method end Btw, blocks can be expressed with either `{}` or `do` `end`. Usually the former for single lines, latter for multi-line.
I did that because i didn't know any better :) thanks for the input!
What does `Hash.new { |h, k| h[k] = [] }` do? Is there any difference between that line and `Hash.new([])`?
I updated comment with explanation. `h` is the hash itself, and `k` is the key on a cache-miss. I provided the alternative with a vanilla hash b/c this would be a Hash with non-default behavior. It's okay to use if it stays encapsulated inside the PubSub class, but we don't want to return it for others to use b/c it would contain unexpected behavior. Do not use `Hash.new([])`. It assigns the value of the reference to the object, `[]`, to be the default value for the hash on cache-miss, which means: arr = [] h = Hash.new(arr) h["cache miss"] # returns arr h["another cache_miss"] &lt;&lt; 3 # pushes 3 into arr h["cache miss 3"] # returns arr, i.e. [3] Only use it for pure value types: h = Hash.new(0) h2 = Hash.new(0.0)
Thanks , that solved the problem 
Just a warning... If you use Hash.new([]), it will actually return the _same_ array instance every time the default value is accessed. As arrays are mutable, this can easily come back to bite you. Instead, use Hash.new{[]} or Hash.new([].freeze), depending on how the default value is going to be used.
It's also probably a good idea to do the first line of subscribe as: `raise "No block given" unless block_given?`
tangential reminder to tangential question: Just remember that the *Heroku's* postgres db is only 10,000 rows or something. AWS DynamoDB will give you tons more for free. There are even gems for it like [ocean-dynamo](https://github.com/OceanDev/ocean-dynamo) that allow you to access DynamoDB through an ActiveRecord pattern.
In production I'm using Amazon RDS - in most cases Postgres 9.4 with the JSONB works quite nicely for certain domains that require a bit of NoSQL.
TIL.
Hmm... I tried to this before and then a couple lines down I would get an error saying I couldn't use the "push" method because it was saying that @events[evtName] was an integer (0). 
I would say more like AWS Elastic Beanstalk (that deploys on AWS EC2) or the easier to use Heroku (also deploys on AWS EC2). Digital Ocean is for folks who want to deploy full Docker images. Though I've previously setup a dokku instance (think open source Heroku) on docker and pushed that to Digital Ocean. Am I making any sense?
Ah I see now, it's because you're initializing `@events` with `@events = Hash.new(0)` so using `||=` will cause `@events[evtName]` to initialize with that key as 0 (because 0 is truthy in ruby) and never gets to the `=` part of the `||=`. Try initializing using `@events = {}` instead of setting a default value of 0 so that `@events[evtName]` returns `nil` (a falsey value) when using `||=`, or initialize with the other suggestions that folks have given here like `@events = Hash.new { |h, k| h[k] = [] }`
You are making sense.
Would love to add this to https://github.com/schneems/derailed_benchmarks
Yeah I found that out the hard way. I was working on a project which was logging the GPS co-ordinates of 117 vehicles every 5 seconds - got an email from Heroku within 5 minutes.
Bingo! This is the correct answer. 
 ActiveRecord::Base.establish_connection( adapter: 'postgresql', database: , username: , password: '', host: , port: , pool: , encoding: 'unicode', min_messages: 'error' ) This is what I've used in the past to perform the call to Postgres using ActiveRecord. Now in terms of "working with JSON," are you talking about parsing JSON data to be stored in Postgres, or storing data in Postgres as JSON objects? 
No exactly 'academic computer science' is it? More like practical engineering.
You can find micro web frameworks and HTTP JSON API builders listed in the [awesome-webframeworks](https://github.com/planetruby/awesome-webframeworks) page @ planet ruby. Cheers.
The whole point of a micro-service architecture is that you avoid frameworks and other platforms, such as ESBs, that dictate how you build and deploy your software. Microservices are -quoting from Silvia Puglisi's RESTful Rails development book, p137 • Microservices are independent operating system processes. • Microservices are self-contained, highly-decoupled processes. • Microservices use language agnostic API to communicate. Using a framework would negate at least two of these tenets. If (when) I develop a micro-service deployment it will consist of many independent Sinatra apps that communicate either through REST APIs, or by means of a queue (RabbitMQ / Resque) which would probably be better as it would facilitate asynchronous communications.
I'm not sure why your comparing Postgres to Dynamo, they are completely different storage systems with completely different semantics. They are not even remotely comparable in use case. 
Thanks for the correction. I misread.
Isn't this Container Engine, not App Engine? They're quite a bit different.
Sequel ships with plugins for lots of pg-specific stuff, including JSON types. 
Kind of nit picky for this example, but in general avoid using instance variables in your classes except during initialization. Setter/getter methods are more idiomatic. For this example I would use attr_reader :events and then replace all your @events ivars with events (which is a method that returns the instance variable). 
Yeah see I'm the opposite, probably because Ruby was my first real foray into programming (barring a bit of Java at uni). I just feel like it reads really nicely when looking at code, like there's 0 mental overhead. `if !...` isn't in any way hard to comprehend either, but for me personally there's still that extra split second for my brain to translate it into something more natural in my internal (subconscious) representation.
Do you have any reading material that could get me going? Because that's seriously how I've done things lol
Having worked on a fairly large scale (terrabytes of data) collection of processes, let me tell you that the queue method is the way to go. Otherwise when one service goes down, everything else that relies on that service is fucked. Just make sure you can recover when your queue goes down.
Yes, it is greater. Ideally you should find 1.9 or 2.0 as 2.2 is current.
I did not know this so you have made me happy today. Now to see if it works!
Then what was the solution that used instead? 
Manually installing stuff and setting it up on even a modest number of nodes, especially with a team, is a good way to get inconsistent behaviour and hard to find problems in large deployments or clustered systems. It's a good idea to have some kind of configuration management. If an important server drops off the face of the earth, can you faithfully set it up with all the little config tweaks and things with a couple of terminal commands? Ansible, Chef, Puppet, Docker- these all offer solutions to these kinds of problems and can be set up and managed as code, shove them on a private repo somewhere and you've got instant record of which server does what.
Thank you for the up votes and feedback - much appreciated!
I don't necessarily test my code, even if it is "suggested" (probably while I am unemployed). With OOP concepts, though, I can recommend using them to organize your code as it grows and not worry about showing off. 
1. If things can be done async 2. If the queue doesn't go down
It has interesting offers ... Would love to find companies to allow remote working like so many ruby companies, since I am from Europe.
Can never have enough football data. So are you collating this from different sources? 
Looks like you got your square brackets and parentheses switched around, but thanks for the M&amp;W vid! Love those guys. 
1. When can things not be done async? (the answer to this question will unravel some key tenets of distributed systems) 2. If a queue goes down you can buffer locally. That's part of why unidirectional fifos (aka binary logs, if you've read any of Linkedin's literature on kafka) are so much more friendly to CAP theorem than JSON apis.
**SOCCER!!!!** /s
Mounting a Sinatra app does not create a new process, it creates new routes within your Rails app that are handled by different code. Running code in a process makes code running in that process dependent on other code in that process. That doesn't suddenly make it not a microservice, or that would apply to every line of code you write, not just a framework you've added. I'm sure it's possible you can find libraries that break that last tenant (such as Resque!), but any web framework won't do that because they're build for rendering web content, which is by definition language agnostic. While I think a bunch of Rails apps goes a bit against the spirit of microservices, it's still a totally valid approach to breaking up a monorail.
I just went with AWS instead. 
Awesome! It would be cool if you could also generate valid [JSONResume](https://jsonresume.org/schema/) strings so that everything can play nice. It's a cool platform and it's always good to see more people plugging into it. 
I had no idea JSONResume exists, I'll definitely check it out. Thanks!
The basic premises asserted at the beginning of this isn't true: "Object-relational mapping is nothing but a layer of additional complexity that exists just because we want to mutate objects and persist them in a database." Creating, updating, and persisting state may be want you want to do, but we did that with raw SQL and in memory-representations for years before we had an ORM. ORMs are for providing a better abstraction to work with data in a relational model. I know there's a lot of hand-waviness to get around this later on in your article, but it's a fundamentally flawed argument. 
&gt; Creating, updating, and persisting state may be want you want to do, but we did that with raw SQL and in memory-representations for years before we had an ORM. But we didn't "mutate objects". This part only became possible with ORMs (keeping track of the changes and all that stuff). Also: The "better abstraction" is debatable. It leaks.
That too.
Nerd!!! Kidding, that sounds great :) Edit: hmmm, that username... 
He has some great ideas, but I'm not sure why Piotr Solnica is still using Ruby.
Probably could use a better name, I don't think unemployed want to be reminded of **jobless**
Thanks for your comment. It makes sense. Since you use Watir, I have a technical question. Do you use a framework or a particular method to map re-usable elements like buttons, text-fields or divs? For example, at my work we map each element to a symbol like username: @b.text_field(id: "id_string") and use it as username.set everywhere. What is your testing framework like?
I made reusable methods to demonstrate that I have general understand of OOP concepts like polymorphism and abstraction. My thinking was that if I were to use this script in a production scenario, I am sure I would like to use my methods to perform redundant clicks and text_field.set methods.
May be better off asking in a audio-visual forum like doom9.org forum or avsforum.
Well, this one (below) has to check n! possibilities. You could do even more to make it inefficient, but this will bog down your computer for relatively small strings. reverse_str = lambda{|str| str.split(//).permutation.to_a.select{|x| x==str.split(//).reverse}[0]}
Just trying to understand the question here... should a string like "{[}]" evaluate to true or false? Because if it is supposed to be "true" I don't think the stack method works properly. 
I don't think they need a reminder.
No.
There's a difference between making changes in a database and having a whole abstraction on top of it where objects are being changed and there's some special system to figure out what then needs to be changed in the database. This is precisely what I call additional layer of complexity. Data transformation of input to a form that can be persisted in a database is a much simpler solution to this problem, and it doesn't require you to load objects into memory, mutate them and "persist" back. I write "persist" because you don't really persist your objects, you serialize them by looking at their properties and figuring out how it should be transformed to a form that can be persisted.
&gt; At that point you either sprinkle SQL all over your code Who does this? Someone who hasn't heard of functions yet?
I think this article starts with the shortcomings of this paradigm as well as its current trend, then just stops there. It doesn't look at any other shortcomings seriously. It doesn't look at the benefits to using RoR. But most importantly, it doesn't analyze why a start up specifically would choose one over the other (prototype time, time to launch, amount of code before coming to a result, etc.). "future proofing" your start up by picking a language you think will be very popular three years from now is the single most idiotic thing for a start up to do.
Do the functions have SQL in them?
&gt;Then you have broken your microservice segments improperly That's one opinion. I know many people who have set up services to look up data in specialized data stores. &gt;Are you being purposefully obtuse with this; I really can't tell? I am pointing out that you have just advocated for a single point of failure process.
What a shitty article
It's perfectly fine.
a) They don't have to if you use a query builder (no one should build SQL strings by hand anyway). b) You said "all over your code".
And I think it's useful at all levels, too. I'm getting in more advanced Ruby code now, and sometimes as a last resort I run my code through pythontutor only to realise a really stupid mistake I made. Glad you like it!
&gt;I am pointing out that you have just advocated for a single point of failure process. If a queue system is a single point of failure than you are implying that your production is inherently designed as a single point of failure with or without queues. No one in their right mind (or that cares about uptime and resiliency) would run with one daemon/proccess http/app or queue -- any non naive production would have well designed redundancy and fail over. Can you please elaberate how a queue system being used for its specific pourpose and installed/used properly is in anyway more risk to your app than a home brew buffer. Again I am assuming your microservices app will inherently need to be running on multiple devices and load balanced/fault tolerant. I am genuinely curious what your world-view is.
First of all, `YAML#load` takes a string containing YAML, whereas `YAML#load_file` takes a file name. The latter is effectively the same as doing `YAML.load(File.read(filename))`. Secondly, this works for me: # irb -ryaml &gt;&gt; YAML.load "name: 'bob'" =&gt; {"name"=&gt;"bob"} I recommend using `irb` to see what the output of your statements is.
Yeah, I've also found that using ls in the terminal is helpful to see what directory you want to cd in. Just like moving through finder on a mac. 
Other than what @twerq mentions above, it might be a good idea to actually go the micro-services route and have the presentation layer common (assuming that you want to have a uniform UX to the outside world), and each service exposing an API that the presentation layer invokes and weaves into the ui.
Using node, the runtime, as a counterpoint to rails, the web framework, seems intellectually dishonest at least. Node isn't a web framework, but he's doing numbers comparisons like it is. It'd be more honest to compare the numbers to sails or express.
Are you an "other big company"? Anything even close? I would consider whether it's featuritis. The company's architecture should certainly not be beyond developers' ability to reason out persistent problems in basic functionality.
Why would you say so? The lambda style scope definition as opposed to the class-level method definition? OR the way it provides a concise way to chain behavior before hitting the db? Please elaborate further.
I'm unsure on windows but I assume it works the same as on a POSIX OS: It doesn't matter what the relative location of the files is in this case, it matters where your 'current working directory' (CWD) is. A request to open a file with a relative path, such as `config.yml` will be relative to the CWD. Unless you modify it somehow, the CWD will be the directory you type the command in. In your example above it appears to be `C:\Program Files (x86)\Notepad++\`, which means your script is trying to open `C:\Program Files (x86)\Notepad++\config.yml`. If you want to reference `config.yml` as a relative path you need to change your CWD to the Desktop, in other words `cd ~/Desktop` (or whatever it is in windows) before running your script. The other option is to use the path of the current ruby file as the base, e.g. config = YAML.load_file(File.join(File.dirname(__FILE__), 'config.yml')) 
Cool. I suggest moving everything into your project directory. The Notepad++ folder isn't a suitable place to keep files like this.
We have one of these on some classes to manage soft deletes. That in of itself wasn't so bad but some brilliant engineer put two includes on there so now every time you access anything with this model it loads these two other classes doing queries that really are not needed. It's been there so long now undoing is practically impossible. 
Agreed – default scopes suck. Even if you're just doing simple sorting with the default scope, you can get bitten. For example, let's say your default scope is just order(:created_at), but then you need to do a join or an aggregate function on that table. Chances are, created_at can't be in your results, so it fails.
Your biggest challenge here is going to be explaining why DI makes any sense at all in the context of Ruby. I've yet to see a good argument that supports it's use.
"Twitter had to switch away from Rails" is always such a weird argument to me. So you're saying, I can get to Twitter status by using Rails? Who says Twitter would even be where they are, if they hadn't used Rails? Also it seems to me that Twitter is such a huge beast now, that no ready made solution - which obviously needs to be broad - would cut it. So that's hardly a critique of Rails really.
Right on point, Floede.
Extremely basic. You might want to indent with 2 spaces, fairly standard Ruby practice. Explicit returns as the last statement in a method are optional. If you're talking about instance_eval and you're talking about how class_eval changes the reference to class in addition to the reference to self then you should probably talk about how instance_eval changes the reference to the current class to the singleton class of the object. x = Object.new x.singleton_methods # =&gt; [] x.instance_eval { def example;end } x.singleton_methods # =&gt; [:example] The most useful aspect of plain eval is that it allows you to specify the scope in which the code is evaluated through the use of bindings. Maybe you want to execute some code in an .rb file in a specific object's scope, I dunno. # directory/load_test.rb puts self That's it for the file... class Test load 'directory/load_test.rb' # Because we use load to execute code, after all. end # =&gt; main class Test def self.get_binding binding end end code = File.open("directory/load_test.rb", "r") {|f| f.read} eval(code, Test.get_binding) # =&gt; Test In any case, you can do that with eval. Using eval with string interpolation is mainly for quick hacks where you need to smuggle some variables across scope and you're more interested in making it work right now as opposed to working up something clever. You'll want to refactor the eval out before actual use. Not because of safety but because of performance. Every time eval runs, it has to tokenize the code, compile to bytecode and interpret. Something like that, at any rate. That's why benchmarks for eval are really slow when you run test code with it inside a million run iterator but not so slow when you run it with test code embedded inside a million run iterator inside the eval. The interesting thing about metaprogramming is that you can use it to localize complexity, (the same reason we develop and use programming languages instead of coding everything in raw assembler,) using the complicated code to run greatly simplified code that meets specific requirements in your project. If complicated metaprogramming techniques increase your workload without paying for itself, then you shouldn't use it. In that particular case. (Which is why you'll generally want to write your microcontrollers in C instead of Ruby, because the added workload of Ruby's features slow the microcontroller down with no benefit at that level of programming. Same kinds of considerations. Have to use the right tool for the job, metaprogramming may or may not be the right tool.)
I use [`dry-container`](https://github.com/dryrb/dry-container) + [`dry-auto_inject`](https://github.com/dryrb/dry-auto_inject) and don't feel like I need a whole framework.
Ernie Miller addresses, in his Rails Conf 2013 Talk, the internal complexity within ActiveRecord needed to have default scope work, https://youtu.be/yuh9COzp5vo?t=23m37s.
I don't think default scopes are ever a good solution. Yes, it works for the multi-tenant database problem, but it's the kind of solution that will almost certainly come back to bite you in one way or another. I'm still a fan of explicit scoping, which could be done here with a "for_tenant" scope or something.
Twitter is a sound name but its story with Rails backend replacement does not set a rule. See how well scales Github with similar or possible higher load and they are running on Ruby/Rails almost exclusively.
We have a css package, yes. Not a gem, because we use a grunt pipeline. But huh...i thought micro services would not each have a UI... what if we wanted to change presentation logic sitewide? Like.... all errors should show in a modal.... we would need to impliment that on each service? 
Regret to click the bait. Plain and naive article, full of bold statements either unsubstantiated or based on some ridiculous implications like google search hits, unsourced and possibly webproject-unrelated benchmark, comparing apples(Rails) with oranges(Node.js), irrelevant job trends etc. I'm sorry for anybody who would take this guy seriously and make some important decisions based on his "advices".
Yes. We use an npm package. It just reeks of duplication. Each app has an application layout file. That can not be good practice. Right? What if we wanted to change it? 
Does micro services architecture specify how to handle the ui layer? Should it be a ui app? Should it be multiple apps following a convention, and sharing code with a gem/package? I'm gonna get my google on, ;) 
npm package, gem, same idea. If you had a monolith app and wanted to change all the errors to dialogs, you'd have to touch every view file that showed an error, right? How is this any different if those view files are split up among different project repos, apart from the annoyance of visiting each project?
Huh. Good point. 
Don't get me wrong I'm not advocating for a monolith. But i thought, one presentatilon which would call apis for its services.... would be better... for some reason.
Is the title in English? I feel like I am having a stroke.
That's not very helpful. Protip: suggest how it should be written
That would be simpler, but then on the other hand your UI and various APIs need to be released in sync, effectively creating a hard relationship between the pairs of UI feature / API section. Localizing the UI code to each project means you can ship each service on its own without affecting anything else. Autonomy is one of the goals of the pattern. I'm not saying this is right and you're wrong, I'm just helping you understand the decision. There are always trade-offs; simplicity and ease of development for autonomy and separation of concerns. I will say that focusing too much on easing the developer experience often leads to an unmaintainable monolith, and Rails is especially bad for that.
totally valid ^
It seems to me that it "Enables association DSL in classes that don't inherit from ActiveRecord" :)
I guess yet it doesn't stand up even to mild scrutiny and it's not like the "PHP: a fractal of bad design" article.
There shouldn't be any duplication, anything UI related shared between apps should be in the UI library. I don't know anything about using NPM packages with rails, but if it was a gem you could keep your application layout in there and just have a one line `application.html.erb` that just renders it.
Simply put, it does this for convenience. The Single Responsibility Principle isn't a law of nature, but rather a helpful guideline in most cases. It is probably true that the Integer class has a few more things than perhaps it needs if we are strict about the SRP. Even if the Integer class (for example) violates the SRP, I still think it's a good thing that it's designed the way it is. Either those responsibilities (that you outlined) stay with the Integer class, or they get put elsewhere. If they were to be put elsewhere, then each individual class may be simpler, but the ecosystem as a whole (particularly for such a routine operation as this) becomes more complex. (I recognize that you're not just talking about integers here). Ultimately, rules like SRP exist to make life easier for programmers. Following SRP doesn't necessarily create better programs (from the user perspective), nor does it necessarily reduce errors (though that is a nice side effect). It mostly just makes the actual code easier to reason about. If following a rule (like SRP) makes the resulting code harder to reason about, then the rule should probably be ignored at that time. It is more important for code to be correct, understandable, and easy to make decisions with than it is that it follow any particular rule or principle.
Cool! The way you wrote it reminded me that one of my clojure friends had said that "Ruby is kindof a lisp". So to prove it to myself, I duplicated your code in clojure as a proof of concept. Thanks for giving me a few hours of something to fiddle with (and perfect my macros). https://github.com/jbristow/jobless-clj
There might be similar thing achieved using Forwardable. However when using that you need to explicitly tell delegator what fields should be used. Then you are more explicit but loose a little flexibility :) 
Nice! I added a link to jobless-clj at the end of Readme in ruby jobless. Just one note - in project description you wrote CSV instead of CV. :)
IoC containers are great at uncoupling your objects from one another... and coupling them to an IoC container.
I wouldn't use rails either, but seriously, every single one of those reasons was ridiculous.
&gt; That's one opinion. I know many people who have set up services to look up data in specialized data stores. Fascinating. What consensus algorithm did they use for high availability/failover? &gt; I am pointing out that you have just advocated for a single point of failure process. Only if your queue is being run by people who don't understand distributed systems.
Thanks! 
Someday I'll have the will and follow-through to turn off the new Mac OS autocomplete. Thanks!
Check out the Ruby Koans
The other advice in the thread is good, but in truth, my recommendation would be to just go and build something as your next step. I've been working with Ruby for over a decade and I still go and write toy projects anytime I want to learn something new (currently building something with rom-sql to see if I like it).
Perfect, thank you 
Start building something simple, and keep iterating! Have fun!
YMMV, but something that's helped me a lot with learning any language is observing where your packages and whatnot (gems in this case) fall short / don't work, and then poking around to see why. I've been having to do that a lot as of late since I've been using Neo4jrb with a few things, and official support for certain things is kinda sketchy. Also, just building things is always an approach worth doing. I have 1-2 "go to" apps I try to write when I'm learning a language; url shortening service (with user accounts and link metrics), and an IRC bot that can respond "That's What She Said" to appropriate sentences in a given IRC channel. Neither are incredibly hard, and flex your brain in a reasonable amount of areas. 
Future proofing is just a form of premature optimization, from my perspective. Picking a language / framework / stack that you are actionable in and can Get Shit Done in is the most important part of that decision process; not what the landscape is going to look like 3-5 years from now.
rubymonk.com www.theodinproject.com/courses
I used to run a training course targeted at people in this situation. I no longer do but I've uploaded a few of the videos from it to YouTube. It's a random scattering but you might enjoy them: https://www.youtube.com/watch?v=by5fFOBhtPQ https://www.youtube.com/watch?v=Kg4aWWIsszw https://www.youtube.com/watch?v=V_dZQ6AeZDE https://www.youtube.com/watch?v=mBXGBbEbXZY https://www.youtube.com/watch?v=aISNtCAZlMg
Who do you think we are, PHP developers?
I hadn't even thought of that.
Forgot to mention [Shellwords](http://www.rubydoc.info/stdlib/shellwords) for explicitly escaping arguments. For 99% of the time just converting the user input to a String and passing in separate arguments to `system` is good enough. An additional bonus of the multiple arguments calling convention, is it ensures the user input is mapping in as a single option to prevent option injection; many unix commands have options which allow you to execute other commands.
This is the right answer. Build something. Solve a problem.
Building something when you don't know how is frustrating, slogging through it gives you experience in being frustrated and teaches you to persevere in the face of horrible, low-quality code that you should not want to retain. More completely, I think it's best to start building something, then pause development every time you run into something you don't know how to do, study like a mofo, go back to it, refactor your project, add additional features, hit another roadblock, study like a mofo, refactor your project... I didn't go into programming with knowledge of that learning cycle, I only realized it early because I have prior life experience with learning bad practices by repetition. Namely, from chess. I didn't learn chess properly as a kid, played it incorrectly too long and I still wind up struggling with basic errors on a bad day even though I can give full strength engines a run for their money on a good day. That's because I learned bad habits from trying to slog through mistakes with repetition.
Why are you using the String representations of the events instead of the class constants when matching/subscribing? (`"Events::Foo"` vs `Events::Foo`) Sounds rather error-prone.
&gt;Fascinating. What consensus algorithm did they use for high availability/failover? Not sure what the relevance of this question is. I know people who have written a micro service which does nothing but query a specialized store and return an answer synchronously. Why don't you want to address this?
Be careful not to fall for the "use exceptions for control flow" trap. It's pretty convenient to use exceptions, but debugging becomes harder the more you use it. I usually pipe my commands through a few handlers each of them can return either an error or pass the command to the inner handler. The controller is only responsible for mapping from a result (`Result&lt;T, Error&gt;`) to an HTTP code/JSON response. This also frees the domain from knowing about the specifics of HTTP.
In this simple context, I agree but in a full API, consistence would be nicer IMHO.
Really? I thought the difference couldn't be clearer. Do you have any questions about the technique?
yep :(
[Google Cache Version](http://webcache.googleusercontent.com/search?q=cache:http://jakeyesbeck.com/2015/09/20/rails-http-status-codes/&amp;ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=pEsBVuaCOKLOyQPnpqygBA)
Or you can build your REST API with [Grape](https://github.com/ruby-grape/grape) and mount it in your Rails app. I've used it for a standalone API app and it's magical.
Try this gem: https://github.com/norman/friendly_id
Is using authentication not an option? In other words, only allow authenticated sessions and only allow them access to resources they actually own.
You can define a `to_param` method on your models, which can return something like a unique slug (or maybe a username for users) instead of a numeric identifier. That way something like `user_url(@user)` will (without any extra effort) produce routes like `/users/kandanomundo`. Another approach I've seen is to do something like base36 encode the primary key ID in a `to_param` method with something like `id.to_s(36)` and then decoding it in the controller with `User.find(params[:id].to_i(36))`. Edit: One other trick that doesn't **really** obscure your IDs, but can be handy, is that strings like `'123-hello-world'` will automatically have `to_i` called on them when you try to `Model.find`, which means you can provide "prettier" URLs by concatenating the unique identifier and a slug or parameterized string of some sort for `/users/123-kandanomundo` (but be aware that in this case `/users/123` would still find your record and render your resource successfully).
That could be one solution, but suppose I want User A to be able to interact with User B by viewing their profile or some other shared resource?
That looks like it might be very useful!
To piggy-back on this, there are numerous *authorization* gems (opposed to authentication) that allow you to control access to your resources. CanCan is one that I have used to great success in the past on enterprise administration applications for large #s of users with sometimes fine-grained authorization patterns.
Still, beginners should be given good direction. I think beginners would get more value from a more detailed example.
I have been a fan of using exceptions to control flow for APIs. It is very useful. I generally check if a user is logged in with a before filter on a parent APIController. I use this technique of catching exceptions for handling missing records, invalid data, and all other error reporting. Catching and handling your API error reporting in one place is very handy for building an API.
With Postgres it is easy to use UUIDs as the id. You'll take a tiny performance hit. The rack-attack gem can limit attack-like behavior. It won't prevent access, but it will keep people from iterating over your whole user (or product or whatever) list every night. 
You could do exercises from [codewars.com](http://www.codewars.com/) and after you solve them take a look at the solutions from others to learn how they did it. Also take a look at the [Ruby documentation](http://ruby-doc.org/core-2.2.3/) and try out some methods on irb/pry to see how they work, in particular you should become very familiar with [Enumerable](http://ruby-doc.org/core-2.1.0/Enumerable.html).
You're right, that would be a better approach. Thanks for the feedback.
I removed this line from my sample: raise exp if Rails.env.development? || Rails.env.test? so locally, I still have it raise the exceptions so I don't accidentally have any hidden errors.
Alternatively, if you want short non-guessable URLs, I use http://hashids.org/ruby/
I found that Grape was too disconnected with RoR and you have to add manually add some of the cool railsy features like caching.
Simplest example is `man -P $PAGER`. Normally, `man` will pipe the output through `less`/`more`, but you can override that to be anything (ex: `man -P "wc -w" ls`).
Worth contemplating, although I don't think it's neccesarily always that clear-cut, I see something in it. (But Rails is probably not beloved by engineer types either, it's not exactly good engineering). 
Can we fulfill the Statement 3: X language is for Y programmers. - C is for Programmers-engineers. - Java is for Programmers-engineers. - Haskell is for Programmers-mathematicians. - Python is for (Programmers-engineers and Programmers-writers?). - ...
Use UUIDs.
Hah, I am writing a lot of workarounds. I am too new to rails to offer any sage advice. Just today I was in a panic for a half hour when it seemed that the Oracle Enhanced adapter was not recognizing date types in database views. Well, the adapter wasn't, but I was able to specify the types explicitly. I think this could be fixed if the class queried `user_objects where object_type = any('TABLE','VIEW','MATERIALIZED VIEW')` or something like that. Also I learned the hard way that rails models cannot "see" the request object, so default scope was useless and I needed to set it as an explicit scope in the controller. Just as well, but this is no fun.
"your hapiness and productivity as a developer is deeply correlated with correspondence of your mindset to mindset of language and ecosystem you work with" This ratio is spot on. It's a relationship so trust your feelings :) (and thanks for sharing that Matz chapter zverok)
There is no material difference between using a query generator and using a query. 
You know, that makes me think... Has anyone written anything comprehensive like an annotated guide to the MRI source code, along with references to what it actually does in Ruby? Might make a decent open source project that would be a good reference for problems like that. I know there has to be some C/C++ programmers lurking around here.
You're welcome :-) It **is** extremely useful. Perhaps it should be stickied in the sidebar?
Very well written article. Have to admit I've planned do similar investigation for still [unsolved leakage](https://github.com/puma/puma/issues/342) with Puma, but been overcome by laziness. I've been excited this discovery would fix also the Puma issue, but is seems *redcarpet* gem is quite unrelated. In the meantime we've moved some of our Rails apps to Thin which resulted in slightly slower average response times but the memory usage become stable.
I wonder what the reason is for Data_Wrap_Struct to not complain when the free function pointer is NULL, I wonder if that's ever useful.
Composabililty isn't a "material difference"?
Right, as /u/jrochkind [pointed out](https://www.reddit.com/r/ruby/comments/3llnlk/activerecords_default_scopes_are_an_antipattern/cv8x0yn) as well. Thanks for sharing!
Riveting. Had me on the edge of my seat the entire time.
Regarding question 4 in the list, `"How best to generate a random string in Ruby?"`, here's a simple alternative (and much more generic) solution provided by [a ruby gem I wrote](https://github.com/tom-lord/regexp-examples): require 'regexp-examples' /\w{10}/.random_example # =&gt; "ctiIbk_E5X" /[a-z]{6,8}@(hotmail|gmail)\.com/.random_example # =&gt; "eyongil@gmail.com" /(\d{3}) \1/.random_example # =&gt; "579 579" /\p{Cyrillic}{10}/.random_example # =&gt; "шШѼМчѫѐмПѶ" /random capitals/i.random_example # =&gt; "RaNdOm cApitalS" /[[a-z]&amp;&amp;[^aeiou]]{20}/.random_example # =&gt; "mfthzdlbrxkcqpftpvkt" ... You get the idea :)
Nice! Setting encoding is always good.
I like the securerandom library. require 'securerandom' puts SecureRandom.urlsafe_base64
Thanks! And... I was the "take the VCR apart and put it back together" type as a kid. It hasn't worn off. Probably be a while before I'm good enough at C to do a meaningful analysis of my own. That mention of the Ruby Hacking Guide leads me to conclude people have been wanting something like that for a long time.
I'm Ron Burgundy?
I guess that's up to your requirements/needs for what you're doing? Do you need your data to be kept up to date, or are you fine with it forever being a snapshot from when you first scraped it? In most cases, people are not fine with it forever being a snapshot from when it was first scraped. But it's not really a question of ruby or design or 'best practices', it just depends on your needs for your application, your domain, the uses it will be put to, the requirements of the users/uses, etc. Or am I missing something? 
I put a question mark because i'm not that confident on Python as a language for writers... but I see such an expressiveness writing Python programs that some times I think so.
ok that helps a lot. This exercise is simply for my own knowledge and I've envisioned the API being a snapshot of the data from when I first scraped it. Just felt weird having code in my lib file that are essentially one time scripts. If I wanted it to be kept up to date then the answer would be to background job it right?
Can someone please tl:dw?
Matz is experimenting with three concepts that may or may not be included in Ruby 3.0. 1. Man-machine collaboration through a static analyzer (e.g. rubocop or ruby-lint) that uses [soft typing](https://www.omniref.com/blog/blog/2014/11/17/matz-at-rubyconf-2014-will-ruby-3-dot-0-be-statically-typed/) (i.e. inferred typing) to determine if a program will crash or not. 2. Performance enhancements through JIT compilation, but preliminary implementations have shown to increase memory consumption as a side effect. 3. Concurrency improvements through better abstractions like streams and pipelines. When used, the running program would place itself inside an event loop, disable the GIL, and force objects to be immutable. Matz calls it Rube Goldberg Programming. No promises are being made at this time. He's just experimenting right now.
Thanks a lot!
It's nice, and it's a lot of work and trouble! If you only need to do it rarely and you don't care about a bit of delay in getting new data, sometimes I've resorted to simply indexing into a new temporary table, then swapping/renaming it to the production table and deleting the old production table. In fact, one time recently I resorted to doing that even for a nightly refresh. It was messing up my database performance a lot otherwise, to be writing to the fairly giant table that was also currently in use, and I realized I could get away with a temporary table and swap once complete. 
There's Ruby Under A Microscope, which I've recently found is basically required reading for the Ruby source code.
&gt;Simply using a string of (unprocessed) characters is not a very secure password. A simple way to turn a human-readable string into a secure password is by leveraging Ruby's OpenSSL::SHA256 module. This provides a secure hashing algorithm for a provided plaintext password. DSE will automatically hash a plaintext password using this algorithm. For more information on secure hashing and digests, see this page. What do you propose is the advantage is hashing the password in this case? It does not provide any additional entropy or key space. I believe you are conflating storing passwords with a trap door encryption (hash) and key strength. 
Came here to post the same thing. The password should go through a KDF, such as bcrypt or scrypt, before being used in this way. Edit: DEFAULT_CIPHER = "aes-256-cbc", no authentication. This is VERY DANGEROUS. 
&gt; is targeted for just encrypting and decryption of data I am aware of that. However, brute forcing a password is usually a trivial exercise, compared to brute forcing the AES key space. 
results as of yet are here: https://docs.google.com/a/dnil.net/forms/d/1eo9vuE_z8eeAT-_4tu4vuKKh7d7RRYKSP4FpldcPBhw/viewanalytics?usp=form_confirm
&gt; SecureRandom.urlsafe_base64 /[\w-]{22}/.random_example :)
Great job Michał! I am currently working on a little project of my own and this tool could prove really useful for me. Im in!
I agree, and I find it even more astounding and depressing that HTTParty is so popular. It does not perform well (extremely slow in comparison benchmarks). It is not flexible, there are many things you can't do with it. It is not thread-safe. Why is it so popular? 
It's not quite that kind of static analysis rubocop can handle. Better representative would be ruby-lint, although far from usable outside scope of a single source file.
What about using something like EM-Synchrony (https://github.com/igrigorik/em-synchrony)? Do you reckon that would help reduce the complexity somewhat?
The docker ecosystem is evolving quickly and I'm unsure what the current best deployment tools are. Last fall, I was frustrated with the available means to deploy docker containers. So I wrote my own :) https://github.com/mrinterweb/freighter. Freighter borrows a little from Capistrano in terms of configuration and deploying over SSH. I wrote Freighter because I wanted easy container deployment. I've been using Freighter for about 8 months and it works well for me. I would love to hear what other deployment/orchestration tools people are using for Docker.
Probably not. The GIL is there to prevent race conditions when manipulating mutable objects.
Updated the tl;dw. Thanks.
Note that rocketjob is GPL-licensed, making it illegal to use with closed source applications (i.e. most businesses). This is why Sidekiq is LGPL: so it can be used with closed source apps.
+1 Great tip! As an option, you could just `docker-save` your image and ship it to your Docker hosts, I mean, the base image is just 70+ MB!
Good points. Much more could be said regarding actually running the containers. I'll be very brief on each point. 1. disk: When deploying a new container, you want to make sure that you clean up older containers and stale images otherwise, you could fill up your disk. 2. logging: I use rsyslog and use a log aggregation service like loggly.com 3. networking: A lot could be said here. I map containers to ports and each container effectively exposes one port. I use a load a load balancer to direct traffic to hosts running the containers I'm directing traffic to. I'm sure much more could be said about networking. 4. running a rails console: (I know this was not on the list. I just wanted to add it) I run this code to connect to a rails console in a container from the host: docker exec -it $(docker ps | grep &lt;my-container-name&gt;:latest | grep 0.0.0.0 | cut -f 1 -d ' ') bash -c "export TERM=xterm; exec bundle exec rails c" That's a heck of a command, but in my system, it finds the docker process by the name and IP address bound, and runs the rails console through docker. Took me a while to come up with that little ditty so I hope it helps someone (millage will likely vary). There is so much more that could be said on running docker services in production. I don't consider myself an expert in this subject, and I have not wrote about it as I'm sure there are better ways than how I do things. Docker is very exciting, but it is also a new frontier that is evolving rapidly.
Not saying that I think this is important enough to justify using it (or anything) but it has a good name.
No, my understanding is correct, even in terms of your link. In particular that link describes transactional data as: &gt; Financial: orders, invoices, payments Do _not_ under any circumstances store this in Redis. 
Big contrast to the Python world where Requests dominates and for good reason, it's excellent.
&gt; Redis is not a reliable data store &gt; Do not under any circumstances store this in Redis. Applies to both quotes. You are telling people what to do, it's usually a good idea to provide more adult reasoning than "you're doing it wrong" - particularly if you're going to misspell it. Why is redis an unreliable data store? 
This seems like a reverse question: Redis isn't a reliable data store because it was never built to be one, by design. If it was never designed to be a reliable data store why do you think Redis is a reliable data store?
Transactional data can mean "the set of all user ids which visited the site on YYYY-MM-DD", something which Redis is awesome for and the traditional ACID database is not.
Thanks for sharing this! I've been looking for a resource on this for a while!
That's interesting. I have not used docker-save. I've been using hub.docker.com as you can just `docker pull &lt;image&gt;` and it just pulls the updates. Incremental changes are more likely to be quicker to deploy by pulling than packaging the entire image into a tar file each time. 
Yeah I loled a little when I read mongo and noticed the title did not read more like: "High volume, randomly trustworthy, distributed background job processing solution for Ruby." 
https://github.com/rails-api/rails-api the github page for rails-api (which was merged into rails 5) explains a bit. It basically boils down to you could do it in those others, but then you'd have to implement and maintain some things rails does yourself. Which may or may not be worthwhile, depending on the target application.
I'm guilty. what should I be using?
One thing I've seen [binarycleric](https://twitter.com/binarycleric) do is put a `private` modifier right above the `attr_reader` statement. This limits visibility to client code, so it hides some complexity, but it still allows instance methods to reference instance variables without using `@base`.
Yes there is. For example going on rants about why people should not use ORMs.
Sorry if that question seemed inane, I just don't know what you think "material difference" means. I think composability is extremely useful when you need to generate different queries at runtime, for example, based on user input.
Go to github. In the search bar type CMS and then click on ruby as the languages. You should see about fifty thousand rails CMS projects. None of them are even close to being decent so click on PHP or Python or Java or any other languages. Apparently it's not possible to write a decent CMS in ruby.
Came here to say this -- the sequel/roda plugin system is incredibly straightforward and useful.
I think we're all on board with encapsulating the behavior of data, but ORMs typically provide the active record pattern whereas in many cases that "1 row = 1 object" mapping of data is suboptimal. I do use such an ORM (Sequel::Model), but only when working with a single row. SQL is more natural for multi-row operations, so I use a query builder in those cases. I do lose certain ORM features, but if those features could be decoupled from the ORM, then I wouldn't have to. In my case it's not the database that changes, but my users' needs. By providing an API that is backed by a query builder, instead of giving them static queries, I can give them tools to construct their own queries. I use Sequel::Dataset to build (and compose) queries. I understand ROM uses it internally, but I've never used ROM and have no opinion about it. &gt; Why can't you compose using just SQL? I don't understand how I would do that in a general way without writing a query builder. Query builders typically hold an abstract representation of a query and then emit the concrete (SQL) representation as needed. I read "just SQL" and think "strings", and strings are a brittle and error prone tool for this task.
&gt;I think we're all on board with encapsulating the behavior of data, but ORMs typically provide the active record pattern whereas in many cases that "1 row = 1 object" mapping of data is suboptimal. Suboptimal how? It's a well established pattern which has been in use for a very long time very successfully. Aside from that your description of activerecord is wrong as models clearly also encapsulate factory behavior too. &gt;SQL is more natural for multi-row operations, so I use a query builder in those cases. This is a tacit admission by you that there is no material difference between sprinkling SQL all over your code and using a query builder all over your code. You have chosen not to encapsulate the behavior of your data in one class. &gt;In my case it's not the database that changes, but my users' needs. By providing an API that is backed by a query builder, instead of giving them static queries, I can give them tools to construct their own queries. There are lots of gems which give you this capability with Active Record. In fact AR is probably much more composable than Sequel. 
Do you really question if redis is a reliable data store or are you being willfully obtuse? 
I'd like to know the reasoning behind the assertion, I know lots of people who use it as their main datastore without any sort of problem, since when is asking a question enough to brand someone of being willfully obtuse? This is the crap that has me fed up with the Ruby community.
fhernandosc@gmail.com :)
I will contact jetBrains to transfer it now. Should be done soon. :) 
yay! ^ .^
Email sent to jetBrains to transfer. Thanks. :)
You don't "need" it, only if you want to use websockets. You probably would have been running Redis if you were doing that before Rails 5. I'm not sure what a more reasonable solution would be.
I have to disagree. It looks like a fairly plain abstraction around websockets. I'd like to think I have a pretty nuetral opinion on the subject since I don't really even like using rails, but maybe I'm just pleasantly surprised, because hearing about actioncable at railsconf this year had me thinking it was going to be all about rendering partials to make SPAs while rendering from the backend.
Redis _and_ running a separate process too.
By there are *many* cases in which a model may not belong to something *yet*. What about that?
It's basically the app-level equivalent of having a foreign key constraint in the database. Really it's kinda helping to enforce best practices (but you should do it in the db as well anyway).
For more built-in debugger support, you could try [pry-byebug](https://github.com/deivid-rodriguez/pry-byebug).
I wondered on this too. The JavaEE implementation onwebsockets is just another annotation. But the point here is probably that the application server has to implement it and not the framework. Does anyone know if redis is required in development as well?
&gt;Sorry, I don't care about the design problems of ORM, so I'm not going to help any more in filling up the internet with discussion of them. There is not a design problem and all your ranting and raving isn't going to create one. &gt;Using SQL strings, how do you separate the projection, filtering, and paging logic for queries against arbitrary tables into separate methods? Every language let's you compose strings in various ways. What do you think Sequel does? &gt;Is that knowledge or speculation? It's knowledge. I have tried both and AR is much more composable.
Over-engineering is putting a ton of effort into something that's completely pointless. Under-engineering is when you need to do something but refuse to do it because that would involve actually making something. We shouldn't have a single way to do things, true. But, what's stopping you from writing something you need in a very general way then writing a simple wrapper that works as an interface between the primary system and the support system? You don't *need* the code to be a 1:1 correlation, provided the interfaces are compatible. You can do that by designing it to be compatible from an internal standpoint or you can design it to expect a simple, efficient adapter that can make use of any already-existing features. What's stopping you from writing it like a library instead of like internal code for a very specific application?
I actually enjoy the rails-api mostly because this how I've been creating APIs for quite some time. The only major difference is that instead of the Representable gem the `--api` uses the Serializer one. I'm testing both now to see where the pro and cons stand any feedback is welcomed.
Because it achieves React-like interactions whilst keeping the full Rails/Ruby stack i.e. no need for isomorphic convoluted JS front-end.
It looks like something Sinatra had since 1.2 years ago called streaming. With no hard faye/redis dependencies.
Yeah. I've just always felt that Marshal.load/dump was a lot of overkill though, and I wanted an operation that would be pretty fast (since it could be done very frequently). Still, I have no numbers to back up that intuition. It would be interesting to benchmark dup'ing a 1D array versus Marshalling a 2D array. 
The graphic used in this post is confusing and mostly inaccurate. The implication in the image is that the VM is somehow multiplexing Ruby threads onto OS threads, but this isn't the case, threads in MRI 1.9+ and jRuby (for all versions afaik) are OS level threads. Ruby 1.9 / jRuby have no 'green threads', although conceptually Fibers are similar. The GIL in MRI simply limits access to the interpreter to a single OS thread at a time. This is an important distinction to keep in mind as Ruby threads, being OS threads, are pre-emptive, green threads (and Fibers) aren't. This means you have to defend against different classes of concurrency issues for each.
you should pass the keys of the params from initialize to self.class.valid_params 
but then I would create all attr_accessor's including foo.something and baz.else and I want them to throw NoMethodError. valid_params need to filter and assign.
Good points. I read on some blogs that Ruby 1.9+ was using green threads and not native threads. Thanks for that! And thinking more I agree with your thought saying VM was somehow multiplexing. I've made some changes. Thanks for replying.
One approach: class Base def initialize(params) params.each do |k, v| send("#{k}=", v) if self.class.allowed_params.include? k end end def self.valid_params(*params) params.each { |param| attr_accessor param } define_singleton_method(:allowed_params) { params } end end class Foo &lt; Base valid_params :bar end class Baz &lt; Base valid_params :qux end You would need to implement `valid_params` differently if you want it to be callable multiple times in a subclass body. 
So just to recap. There can be all sorts of different parameters passed in to params hash. When you inherit from a **Base** class you allowing the subclass to specify which params this subclass is interested in via **valid_params** method. **valid_params** method does few things: whitelist the params(filter out only the one that this particular instance is interested in), creates accessor methods and assigns the values to instance variables from the passed params hash. I can't just inherit from OpenStruct because there is more to **Base** class than this. This example only isolates the whitelisting and assignment.
Ok I know what you mean. Unfortunately I don't control the params hash that is passed in to new. It can be anything. Thats where the **valid_params** method comes in. It allow subclass to say: &gt; OK Base, you probably got tons of different params in that params hash, but the only one I am interested in are the ones I've listed. Please create them as my instance variables and setup accessors for me. Thank you!
An actor like implementation mapped to HW threads sounds like the optimal approach: - most of the community is already familiar with it - we could have quite light VM processes a la Erlang/Elixir/Go? - should scale quite nicely if the VM manages a pool of HW threads The static analysis could also help to improve the virtual machine, I think the Ruby MRI VM has stagnated for quite some time (just turn off the GC in 1.8.7, 1.9 and 2.x and the performance deltas are minimal or non-existent). Maybe a JIT is too much for 3.0? In any case adding SMP support and improving a bit the VM is the crux of Ruby's future. EDIT: we are talking about static analysis not actual types in the code (thanks @moomaka for pointing it out) 
I remove it every single time, it just doesn't do the job correctly.
It makes me to think...How much Ruby is behind the other languages/technologies nowadays related to Concurrency/Speed? I suppose in the future some changes will come, they are already coming. 
thanks for that.
&gt; I don't believe there is anything on the table for static typing in the VM, rather it's more on the static analysis side. Introducing a type system at the VM level in Ruby would be very difficult. Indeed, I stand corrected [0] - just looking at this old ticket: https://bugs.ruby-lang.org/issues/9999 - I don't find any of the variants Ruby-like or something that I would actually use. [0] - https://youtu.be/48iKjUcENRE
...and everything becames even more cumbersome, when we need TWO copies of those tests: one with SQL backend, and one with ElasticSearch one.
Could [Shared Examples](https://www.relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples) be a solution for (a part of) your issues? I use them often, especially with specs that are the same for different objects and/or very similar tests.
Yeah, I already use them (`include_context` in my code -- it's just an old syntax circa RSpec 2 and still working), but there's still tens of blocks like I've shown above: with let this and let that and include shared examples, and repeat it again and again...
"I'm gone! I have left the Internet. So long and thanks for all the fish" Reads like a suicide note. =( Here is another rails template that I think many people use https://github.com/RailsApps it comes in different flavors/sets. There are a few others that are up to date as well, I do not use them I have my own but let me know if you have any questions. 
Are you aware that shared examples are a differnt beast form shared context? Also you can nest shared examples/context. I don't understand your issue. With shared examples/contexts you should have the tools in place to remove all duplication in specs. Here are some helpful articles: * [Different ways of code reuse in RSpec](http://testdrivenwebsites.com/2011/08/17/different-ways-of-code-reuse-in-rspec/) * [Maintaining a Large Test Suite a DRY Approach to RSpec](http://devblog.orgsync.com/2013/06/04/maintaining-a-large-test-suite-a-dry-approach-to-rspec/) Also keep in mind, that you can give shared examples/context parameters, that'll help immensely if you did not already use it. Just a quick pseudo-code example: shared_example "a nice spec" do |expected_result| include_context "a shared context" it "has expected result" { expect(subject.result(value)).to eq expected_result } end shared_context "a shared context" do let(:value) {'foo'} end describe "a object" do include_context "a shared context" subject do Object.new end it_behaves_like "a nice spec", 'bar' end 
"So long and thanks for all the fish" is a Douglas Adams reference - so I would interpret that as a bit more wry and jokey.
I had this concern. The cases where I would want this behavior are, for instance, when the user is not logged in. However, in those cases, I much prefer explicitly showing that: 1. We queried the database with a ActiveRecord call that was allowed to return `nil`, indicating we are accepting responsibility for cases where the database query returned no results. 1. A record was *not* found in the database. 1. A null object was explicitly chosen to fulfill our responsibility for handling no results. This kid of gem seems prone to create confusion between when a NullObject is expected to sometimes emerge from a query, and when it was not anticipated.
As for Marionette, you should check up this book: https://leanpub.com/marionette-gentle-introduction
i remember the guy, did some fundraiser a while back via [indiegogo](https://www.indiegogo.com/projects/cancelled--147#/story)
not exactly what i'm looking to do. i need to be able to date the keys like 'date' and 'booking'.
This is terrible advice.
Ty adding a .select() call before .where() to see if that does it: Booking.select("DATE(created_at) as date, count(*) as bookings").where( ....... I believe the call to .count is not needed now. Sorry I can't test it, since don't have your data model on hand. For reference, check out http://guides.rubyonrails.org/active_record_querying.html#group 
Ruby Quiz was a weekly mailing list activity that probably was not intended for someone new to programming. I use them for monthly "hack" nights in our local ruby group and usually it takes small groups (2-3 people of varying skill level) an hour or two depending on the challenge. I agree with what others have posted, try codewars or ruby koans. Also, a lot of the ruby quizzes can be pretty esoteric so I wouldn't sweat it.
&gt; essentially every gem out there will defer to some graphics processing toolkit There does exist [chunky_png](https://github.com/wvanbergen/chunky_png) which is pure ruby, but it's rather slow compared to imagemagick/minimagick. Also, it only works on pngs. 
Thanks for sharing!
Yeah, thanks, I was a bit confused around shared examples and contexts, will update my understanding of the topic!
Sadly, that's not very useful if you want to keep the abstraction of a `DogKennel` alive. `DogKennel#map` will return an array, so `dog_kennel.map(&amp;some_block).location` will not work. What you actually want after calling `map` is a new `DogKennel` with the same properties as before, but new dogs which are the results of mapping over the old dogs.
Of course, I'll be there together with /u/blackdev1l. :) Can't wait for the Lotus keynote.
Great to see a Ruby conference in Italy. FYI: For more conference, camp n meetup news you might be interested in the twitter Ruby Calendar feed e.g. [@rubycalendar](https://twitter.com/rubycalendar) - also incl. the RubyDay 2015 of course ;-) Cheers.
tomorrow is the last day to get tickets with the early bird price
Since [by definition, `map` will always return an `Array`](http://ruby-doc.org/core-2.2.0/Array.html#method-i-map), I don't think it is too surprising that `dog_kennel.map(&amp;some_block).location` won't work. Unless you're suggesting that a new `map` method be defined that returns `self` instead of an `Array`, that would be interesting but seems similar to a [Fluent Interface Pattern](https://en.wikipedia.org/wiki/Fluent_interface). Which is cool, but for this example I think the default `map` behavior is sufficient. Thanks for bringing up this idea though, I hadn't thought of that use case for this.
If you don't want to invest in a two-hour long video: TL;DR: `ActiveSupport` adds methods to Ruby core classes, as I'm sure you know. One of those methods is `String#blank?`, which returns a boolean (sometimes I miss this convention in Rust, the `?`) if the whole string is whitespace or not. It looks like this: https://github.com/rails/rails/blob/b3eac823006eb6a346f88793aabef28a6d4f928c/activesupport/lib/active_support/core_ext/object/blank.rb#L99-L117 It's pretty slow. So Discourse uses the [`fast_blank`](https://rubygems.org/gems/fast_blank) gem, which provides this method via a C implementation instead. It looks like this: https://github.com/SamSaffron/fast_blank/blob/master/ext/fast_blank/fast_blank.c For fun, Yehuda tried to re-write `fast_blank` in Rust. Which looks like this: extern crate libc; mod buf; // a small buffer struct + impl, not shown use buf::Buf; #[no_mangle] pub extern "C" fn tr_str_is_blank(b: Buf) -&gt; bool { let s = b.as_slice().unwrap(); s.chars().all(|c| c.is_whitespace()) } Turns out, this implementation ends up being faster than that C one, while also being significantly more straightforward. This video is a two-hour dive into why that is.
At some point I was thinking (dreaming) of rewriting the Rails's routing algorithm in Rust, that would be such a massive speed-up.
Did you install rvm globally, or just for your user account? Assuming the latter, you don't want to use sudo to install your gems. The root user doesn't have rvm available to it, and is trying to install the gem system-wide instead of just into the correct rvm gem directory. tl;dr try again without sudo; or reinstall rvm globally if you really, really have to
Please try [the search feature](https://www.reddit.com/r/ruby/comments/1nh6e2/are_you_migrating_to_elixir_go_nodejs/) for such general topics, as this is a duplicate and OT.
Neither. It's in the best interest of everyone who is fascinated with these languages to claim that "Ruby is dead!", etc. The more people they can convince to make the switch, the more support for their pet project. It's worthwhile to learn new languages for the sake of learning, but in terms of migrating my work toolbox...that switch will be made if and when the economics make sense. For people who are writing books and selling tutorials in Elixir, maybe it already makes sense. For me it doesn't.
I'm using jruby and java :) L.O.V.E
Oh, and as part of my general pitch for why Rubyists should care about Rust, consider https://www.reddit.com/r/programming/comments/3mud0e/using_rust_with_ruby_a_deep_dive_with_yehuda_katz/cvid2jl?context=1 Even though the Rust is faster in this case, it may not be as fast as a super expert C developer can make it, but if you're a Rubyist who dabbles in C sometimes, Rust might be easier, more maintainable, and faster than the C you would write. Which is what matters at the end of the day.
Skim the `sudo` on the `gem install`, rvm doesn't generally like sudo. 
Python now has such a commanding share of the analytics market that it would be strange not to use it. 
&gt; Rust might be easier I seriously doubt this. Simply because Rust is stricter than C when it comes to type safety/memory safety and has more features. I totally agree with maintainable, though. The Rust compiler definitely catches more silly mistakes than a C compiler.
Several of our early production users have said that they've had a much, much easier time teaching people who come from Ruby/Python Rust than C, because catching those silly mistakes is effectively teaching. In other words, C may be easier initially, but is basically a huge minefield, whereas Rust is a bit more complex up front, but helps you out, because you _will_ have to face that complexity at some point. Also, "C is simple" is certainly a meme, but have you seen that spec lately? C99 is ~550 pages. I do love it anyway, and have written a large amount of C extensions, but work on Rust for a reason :)
Could you share your argumentation?
I'm beginning to incorporate Go into my stack with ancillary services. Re-wrote a Node WebSocket server in Go and it's been a great experience. I'll probably experiment with some Go microservices next, maybe a full API-only backend after that. But even if all that goes well I don't expect to drop Ruby for Go anytime soon; I'll use one or the other depending on the project. It probably *will* replace my use of Node.js, though.
Not to proclaim fanboyism for Dave Thomas, but he does have some compelling arguments to use Elixir for some things. Rob Pike also makes compelling arguments for using Go. At the end of the day, I get paid to write Ruby (and some PHP). I do see a bright future with using Elixir and Go (a lot of the companies I follow have based non-trivial pieces of their architecture on Go, at least, not so much for Elixir). I'll make some small investments in learning Elixir (and Phoenix!) along with Go, and I'll tinker with porting things that would be more idiomatically expressed in either to see how I feel about it. At best, I might be able to start using them in customer work; at worst, I have some new perspectives to look a things from ([Linguistic Relativity](https://en.wikipedia.org/wiki/Linguistic_relativity) applies to programming just as much as it does to spoken language) So, no; I'm not "moving" to either, but I am paying attention and learning, trying to find opportunities to further my career and do cool things with either of them if appropriate.
May I ask what something like this would be used for?
Elixir and Phoenix look interesting, but move everything? No.
So does that mean he was able to make String#blank? call the rust version instead of the C?
I think Ruby and Rails are still pretty good at what they do. I am interested in Elixir and Phoenix but it's too early to make the jump or see the clear benefits, at least for me. I have been also learning Clojure and I find it more interesting than most languages. And I don't really care about Go. I don't even know why it's trending and what it offers. I'd rather learn Rust if it comes down to it. 
Yes, that's the idea exactly. Views are overkill for simple applications, but as your query logic grows in complexity, views can be a very useful tool for managing that. And you're very welcome!
It's definitely a cool trick, but it's certainly not idiomatic. 
Why not? IO#write is aliased as IO#&lt;&lt;.
Holycrap, I totally had that book when I was a kid...
The hours staring at the screen of my dad's QX10 trying to figure out what the hell I was doing...
Heh. I ended up tracking down the guy I "borrowed" from 30 years ago via Facebook. Turned out he didn't want it back :) So... which one should I do next? 
I don't particularly like Go, a (not really similar but everyone acts like the two are competing) language is Rust, and I'm learning that. As for Elixr, I'm way too stubborn and I have way too many people trying to get me to learn it to bother with it.
Star trek, of course :D 
So Gosu has a nice high level API. The main project doing this kind of stuff is Piston: https://github.com/pistondevelopers/ As you can see, there's a lot there. It's kind of its own little ecosystem of games and graphics related Rust stuff. One really cool thing in the Rust + Graphics space is Glium: https://medium.com/@tomaka/the-glium-library-5be149d87dc1 I've heard some people say that they switched to Rust for Glium alone. This stuff isn't my strong point, so I haven't used it much myself, but that's an overview.
I did and what I get is: ` puma -C config/puma.rb` `[11412] Puma starting in cluster mode...` `[11412] * Version 2.14.0 (ruby 2.2.2-p95), codename: Fuchsia Friday` `[11412] * Min threads: 1, max threads: 6` `[11412] * Environment: development` `[11412] * Process workers: 1` `[11412] * Phased restart available` `[11412] * Listening on unix://usr/share/nginx/html/projectbox/shared/sockets/puma.sock` `/home/vagrant/.rvm/gems/ruby-2.2.2/gems/puma-2.14.0/lib/puma/binder.rb:315:in 'initialize': ` `No such file or directory - connect(2) for usr/share/nginx/html/projectbox/shared/sockets/puma.sock` `(Errno::ENOENT)` it's actually the same as the log.
Not what you asked, but you might want to consider Passenger, which generally installs and configures pretty darn easily . 
**If** this turns out to be the issue (or some other file operation variant), then OP needs to file a bug against Puma. Ignoring a bad file op is just setting people up for a world of pain. Big emphasis on **if**. Quick edit: You would also want to check all the permissions on that entire directory structure. Using the proper accounts; nginx and puma. If you can `ls -ld /usr/share/nginx/html/projectbox/shared/sockets/` then you can access the entire tree; If not, find the directory that doesn't have the user/group or -rwx properly set. Or, if it fails with "File Not Found", then you'll know exactly which subset directory need to be created; `mkdir -p /usr/share/nginx/html/projectbox/shared/sockets/`. 
Awesome! Thanks 😁 I'll check those out. 
I feel like this has a lot of potential. The amount of setup does seem like a lot, but I don't know of a better solution. Really cool tool, hope it gets the attention needed to grow into something great.
&gt; is the code powering rubygems.org open source? Totally https://github.com/rubygems/rubygems.org that would be great
I came there from passenger!
It ought not to be. Both methods are defined on Enumerable, and should work on anything Enumerable. http://ruby-doc.org/core-1.9.3/Enumerator.html#method-i-each_with_index http://ruby-doc.org/core-1.9.3/Enumerator.html#method-i-with_index
I am just experimenting around with new technologies. I started a post asking people about their stack and about 80% where using Puma (never heard of it before). So I decided to try it and here I am, still trying to try !
That's what I thought based on the docs too, but when I try it in IRB, with_each gets angry at arrays. EDIT: whoops meant to say with_index there
Drama is telling people to not be dramatic. :/
Did you mean `with_index` instead of `with_each`? See also: http://ruby-doc.org/core-2.2.2/Array.html#method-i-each_index
Huh,I just reproduced that too. Yah got me. And yet an array thinks it is `.kind_of?(Enumerable)`... aha, the `with_index` function is on _Enumerator_ not _Enumerable_. (not "with_each" as you said above, that's not a method). Okay, now I'm confused too. Ah wait, if you call `each` without a block, you got an Enumerator. So check it: [1,2,3].each.with_index {|i, o| puts "#{i}:#{o}"} That works. There's no reason to do it instead of `each_with_index`, but you can do `with_index` if you already have an Enumerator (an object which enumerates through some list), instead of an Enumerable (the list itself). I seldom have that. The mystery is now why `with_index` works on a straight Hash. irb(main):012:0&gt; {:a =&gt; "a"}.with_index {|o, i| puts "#{o}:#{i}" } NoMethodError: undefined method `with_index' for {:a=&gt;"a"}:Hash And the answer is, it doesn't either. 
oh whoops, no my bad, i mistyped from my phone, this discussion is just about with_index v each_with_index 
You are probably confusing two distinct objects: `Enumerable` *module*, which defines mentioned `#each_with_index` method and `Enumerator` *class*, which defines `#with_index` method and also mixes-in `Enumerable` module. &gt; Similarly, `Array` or `Hash` also mix-in `Enumerable`, so have `#each_with_index` accessible. They have nothing to do with `Enumerator`, so there is no way how could inherit its `#with_index` method.
You can certainly think of it that way. Another (perhaps more generic) way of describing the situation you encountered is to say that the method `Enumerator#with_index` exists, but the method `Array#with_index` does not.
Shows what? Reverse dependencies? How/where? Kind of? 
Aha, cool. I find ruby-toolbox to be a great idea; I've always found it's UI a bit lacking, personally. (Or maybe 'lacking' is the wrong word, since some of it's problems for me are it's busy-ness). 
`drwxr-xr-x 1 vagrant vagrant 68 Sep 30 11:25 /usr/share/nginx/html/projectbox/shared/sockets/` so I guess permissions are ok. 
I don't know where does it came from. I posted the configuration file If you want to check out.
It's passed as a parameter to the bind function in your config, under where it says "Setup socket location". The output looked different so it seemed like you might have updated it. 
`instance_eval` isn't really related to `eval`, though. `instance_eval` basically just sets the scope of the block while `eval` executes an arbitrary string. 
I think I cannot take it anymore. I 'm going back to passenger ! 
You are the man
Hmm i should probably check brew doctor. Interesting enough, el capitan did not blow away my xcode. I updated last night, ran my react-native apps just fine. Haven't really checked my ruby install yet ;)
&gt; Writing Fiber-aware wrappers for async calls feels kinda weird but using them isn't. Is there a library that enables this? Also, AFAICT, every IO client or server has to be coupled to EventMachine.
Because every gem you want to use that does I/O needs to be written for EventMachine too. Rubyists tend to use lots of dependencies, and you kind of need to exile yourself to a separate universe of EventMachine-aware/compatible gems, and that universe never really developed critical mass, because there weren't enough people working on it, because see above. With Node.js, you're starting in an ecosystem that was developed for evented concurrency from the start, because node.js is all about that, you have no choice. Also, IMO, because for _most_ use cases, threads are actually just as good as or better than evented (yes, even in MRI with the GIL -- the use cases for evented concurrency overlap heavily with the use cases where threads work well **even with** the GIL -- when you have lots of I/O going on). And threads require less re-architecture of all of your dependencies -- they need to be thread-safe in the right way, but they don't need to be totally rearchitected for EM (in a way that makes them work *only* with EM). There **are** a few use cases where evented really will work much much better than threads -- but they are relatively few. And some software manages to use EM internally for these use cases in a way that is encapsulated and you don't need to be aware of (I think Puma does this internally?) Granted, one of the use cases where evented really shines is a high-traffic server with persistent client connections (say WebSockets). I think not just Rails, but ruby in general, is likely to not do super well in this area for the foreseeable future, which is unfortunate, because this is a very pertinent use case these days. We'll see how ActionCable does, but it's definitely way more complicated to make this work with ActionCable's approach than in, say, node.js. 
Thanks for the heads up!
I really think notorious1212 has something here. Look at the config example from puma's repo: https://github.com/puma/puma/blob/master/examples/config.rb#L75 looks you're missing one extra / in the unix:///path. Have you tried this?
or woman
While I agree there are more simple ways of handling ruby versioning - rvm offers quite a few features. I agree it's probably not the best ruby versioning manager for newbies for roughly the same reasons I don't recommend vim/emacs as a text editor when new devs are trying to build stuff. Not because they are bad tools, but because the focus here isn't learning a new tool. With all that said - that's entirely different than saying "rvm isn't a good tool, don't use it". Which is paraphrasing what you've said. I happen to think rvm is a great tool and does its job quite nicely. I blame rbenv for [pretending it's a superior tool by giving bullet points as anti-features](https://github.com/sstephenson/rbenv/wiki/Why-rbenv%3F), that aren't anti-features at all in my opinion.
Did you try removing entirely, and reinstalling? I may have left out some brew reinstalls I did. I'll check my bash history. brew uninstall curl brew install curl
If there is one with gemsets I will switch today. addendum: [needs to be gemsets supported by RubyMine.](https://youtrack.jetbrains.com/issue/RUBY-12839)
Gemsets. That's it. There are issues I've seen that I never want to debug again. Yes, bundler solved most of the issues. But there have been situations where just having a gem installed *period*, in your environment, will cause issues in other code that you wouldn't think would be loading it. Gemsets are the only way to avoid that if all your projects are on the same version of Ruby. I regularly use hundreds of gems in my projects (dozens of them authored by me) so I may have more exposure to weird conflicts than your average newbie.
This can still be a symptom of a larger issue. In my experience sometimes the personality type that doesn't respect the monoculture just doesn't respect other people's opinions generally. Sometimes these people end up being general problems in the company.
Nodejs is "web scale"... Ruby cannot http://canrailsscale.com 
Alright, and in my experiences the personality type that praise the monoculture don't respect other people's opinions generally. Sometimes these people end up being general problems in the company. One key thing not to do either way is complain on reddit about your co workers while not taking the time to speak with them and discuss your opinions either way.
https://github.com/jf/rbenv-gemset
[removed]
Ruby != rails
This person speaks truth
this reminds me of being a kid a looong time ago. if you didn't make it home in time to watch the muppet show, you just goddam missed it. then you'll had to wait 20 years for the Internet to be invented and another 10 more for YouTube. and finally you could see that episode with Animal and Buddy Rich that your friends NEVER STOPPED TALKING ABOUT FOR THE NEXT 20 YEARS!!! dammit I'm old. git orf me lawn. rant over. where can I see this video? 
Here's the thing... My first professional programming job was at a .NET shop. We used .NET for everything. (This was mid 2004) I was told that the OSS tools that I used before were for kids and that they weren't suitable for the enterprise. I imagine there were other shops like that, because there was actually a time before Ruby existed, and before Rails blew the fuck up. I got really into .NET... I stopped working with PHP at that time, and I stopped working with Linux for the most part. After some amount of time, a few of us were pretty interested in working with Ruby/Rails. Some of the developers were very much on board with the change, some of the developers failed to see the value in the change, because .NET offered a means to the same end result. The system administrators were furious. We had a huge Microsoft footprint, and now they needed to start supporting us on Linux. It's not just about the language of the week here. Sometimes tools come along which can present benefits to an organization that can outweigh the pains of migration. That toolkit may very well not be nodejs, but it's sometimes important and perhaps even valuable to evaluate different technologies in case there is a good fit. It's for these reasons that I don't believe in the one true way. It sometimes seems ironic that it's the mentality that actually brought me to Ruby.
I'm not saying "overriding cd is the root of all evil". I'm saying: given two choices: one which overrides a pretty widely used and fundamental aspect of the shell, and another which leaves it alone, I'm going to choose the latter.
uh... ya. I didn't write !==
[Only the best for you my friend.](https://www.youtube.com/watch?v=56sZOUPegUw)
For understanding an existing project... how about just building a new blank Rails app, adding all your existing models to it (just copy ./app/models over), adding RailRoady to it, and asking it to generate the UML? I have no experience with RailRoad, RailRoady, or UML. I think UML may not be very popular in the ruby/rails community, and you might have trouble finding a solution that meets your needs. 
That's the only way to get bonus points, since Node is trendier than Ruby at the moment.
I love how these highly downvoted aphorisms actually spark the real discussion in Reddit threads. 
Your other coworkers are doing themselves a professional disservice by not cross-skilling. If a small, evented, platform is the idea for a small-transaction, possibly high-concurrency application, Node is the answer. I find EventMachine to be less predictable than Node, and the Erlang VM is often overpowered. I also see no issue.
Depends on if they sprung this on them or if it was discussed properly. Any new technology usage should be agreed upon by the entire team due to the complexity and supportability involved in doing so. There are plenty of reasons to add new tech, but there are also plenty of people who would rather shove in their preferences for bullshit reasons. 
nice work!
Maybe. I'm piling on the years and have moved into a pretty solid devopsy/build-and-release engineer for a large Rails app. I spend most of my time with deploy and build scripts and log into Jenkins *far* more than the app and barely touch its internals, which is not unlike the last couple devops roles I've had. The front end of our app, written in Ember, mystifies me generally, and I've never really liked javascript that much anyways. I don't need another thing to support or something to investigate when it breaks or is otherwise non-performant or another ecosystem to learn about when my backlog of work is as big as it is already, and neither does the actual operations team who manages everything from phones to network to production environments (they generally implement my change requests after I've verified them in a staging environment). It was bad enough learning how to build SFDC/Java-ish Flex apps in our CI system with no prior in-house experience. If somebody was like "hey, let's build this in Node!!!" I wouldn't be the first one to have a cause for concern, especially at my current salary. I would need to see a significant and demonstrated use case before I approved. 
Jetbrains RubyMine has a menu entry to generate a visual graph of all your models and attributes.
And as a followup: we're in San Francisco and have had massive difficulty finding qualified people for our run of the mill organization. I couldn't imagine adding more demands to our open positions. 
My argument is that continued education is part of our professional responsibility: I certainly view it as mine and I lobby hard for my teams to do the same. Cross-skilling and skill-training is, I believe, critical to long-term sustainability. 
And trendiness delivers business value exactly how? If you're in an OSS community project, that's one thing, although I hope community interactions resolve the issue pretty quickly. But for commercial shops…it simply doesn't work that way. Back in the day, I got fired from a job I'd been lining myself up to get for *years*, because I didn't understand why The Boss was making a big deal about "use Red Hat, not Mandrake, dammit!"; it was (then) the same package system, the same libraries, etc. Then, years later, I got into devops and the light went on. That turned into an interview question; I now ask people "what's the biggest thing that ever got you fired that, looking back, you agree with your boss on now?" People who can describe at least one such situation that they learned something meaningful from get an up-tick; those who don't aren't necessarily down-voted, but they have to work just that little bit harder to win me over. Confirmation bias? Meritocracy (in that it preserves existing power structures and processes)? Possibly…but the last two people I've interviewed who didn't answer that and got hired anyway turned out to be *disasters*.
Its a big deal to the ops team who has to provision machines and deploy your code.
Hi there, please check your email inbox. The license should have been transferred as it has been removed from my account. Have fun!
Writing [CPS](https://en.wikipedia.org/wiki/Continuation-passing_style) code, by hand, in Ruby, is tedious.
Where do you have time for continuing education when you have so much shit to do already?
I consider it a professional requirement, like testing or planning. So I do it from 9 to 5, in the office. My job is to build the best possible product as fast as possible, but sometimes that means slowing down and taking in the general shape of the technical ecosystem.
Yeah, but that's a methodological failure in my book: a result of management insufficiently supporting developer education. I liken education to testing: a step away from the direct problem that it's our professional responsibility to leverage towards.
wouldn't it be a red flag if you had a variety of things that got you fired to choose from
If my answer was I've never been fired would I have done poorly on the question? Why not ask about a time you argued for something but realized you were wrong later and how did you handle it? 
Ah, I see; striving for "100% buzzword compliance". One of the Top Five Causes of Business Failure, along with undercapitalisation, hiring the wrong skills or personality type (which the OP touches on), and the rest. Thanks for the laugh; I needed that today.
Trendiness delivers value to the coder by increasing their chance at a better paying job. Businesses aren't the only entities who want to make more money.
"Well let me think... I've been fired from a few jobs so...."
I've thought about that too... took a brief skim of the sidekiq source, and thought maybe it would have to be a fork rather than feature in sidekiq, but maybe not. I do think for what sidekiq does, concurrent-ruby rather than Celluloid could be a pretty good fit. 
What's a Typeform?
Edit: I am one of the engineers working on deppbot, together with @juanitofatas. Thank you for your validation of our idea, @jrochkind! We too have seen a few Gemfiles where `bundle update` failed and we try our best to understand and fix those. No doubt, we are dependent on `bundler` working accurately, we still hope to promote the idea that projects should be updated early and updated often. We love Ruby as much as you do, and we do hope this drives the community in the correct direction. :)
@juanitofatas definitely played an instrumental role on the project!
Right now, we haven't encountered any problem of that magnitude. Mostly, it's something on our end that's not working. But we are big on open source and we will definitely contribute if the opportunity arises. :)
There is a word for people like this: dead. As in: "The Node.js developer was found dead at the bottom of a tall cliff after a pre-merge code review."
Coworkers don't get to impose curriculum on other coworkers. And I don't really think I have much to learn by picking up node. I know how reactor loops work, and I know javascript enough to know that I hate it.
You da man!!! Works beautifully.
[removed]
[removed]
Try and avoid method_missing and eval as much as possible. They only bring pai and suffering down the road. They are useful in some cases though. For example you should use method_missing when creating a proxy for a model that has lots of methods. In that case method_missing is really useful. But generaly ruby offers better metaprogrming options. Still the project sounds really cool, especially if the generated cv helps you land a job :)
Gnuplot is good to learn if you need to make plots from a range of languages or environments, as its input format stays the same. I'm using Gnuplot form Ruby these days but called it from R and Octave in the past. My Gnuplot knowledge carried forward in each case instead of having to learn a new plotting language.
That's one way, indeed. I ended up using *rails-erd*, per /u/geraldbauer 's suggestion.
[removed]
[CLICK HERE FOR WATCH LIVE MATCH](http://ipeace.us/forum/topics/https-life-indiegogo-com-fundraisers-hq-tv-rotherham-vs-burnley-1) [CLICK HERE FOR WATCH LIVE MATCH](http://ipeace.us/forum/topics/https-life-indiegogo-com-fundraisers-hq-tv-rotherham-vs-burnley-1) [CLICK HERE FOR WATCH LIVE MATCH](http://ipeace.us/forum/topics/https-life-indiegogo-com-fundraisers-hq-tv-rotherham-vs-burnley-1)
[removed]
[removed]
IT"S BACK UP!!! REJOICE!
Oh nice! Well Have a nice day and I love you!
I'm not sure I've ever seen a Gruff graph I'd consider "pretty"
Out of curiosity, have you looked at Crockford? Personally, I find it's not JavaScript I hate, but the DOM. Following Crockford and writing without the DOM is, imo, quite nice. But to each their own, of course. JavaScript's prototypal object model is lovely, really.
I've been using chartkick (not on the list) and am very happy with it's flexibility and ease of use.
The `#ruby` IRC channel is full of people happy to assist beginners.
I'm having a go at it, should be a fun experiment. Sidekiq's internals are relatively static so I might not even need c-r. We'll see. https://github.com/mperham/sidekiq/compare/concurrent-ruby
PM me if you have questions 
The first thing you should do when you have a question is search for a solution on Google. Chances are, someone has had the same question as you at some point. For complex questions, post them on www.stackoverflow.com with the tag "ruby". If you really get stuck, PM me and I can probably help out. Good luck and don't get discouraged, it takes a while before you will feel comfortable. 
Is it any better than solnic/virtus?
 I've really enjoyed using [typhoeus](https://github.com/typhoeus/typhoeus) it does a great job of running requests in parallel and encapsulating each request, but also most importantly it has a cool name. 
Login to the freenode irc server, and join the #ruby channel. There are hundreds of users there, I'm in there everyday and they have helped me a great deal. Make sure you google your problems first, otherwise they will get annoyed with you.
Personally, I'd use concurrent-ruby instead of bare threads. Even if only for [ThreadPools](http://ruby-concurrency.github.io/concurrent-ruby/file.thread_pools.html). I think you're going to get better performance (especially but not only under JRuby), and clearer semantics. 
[removed]
Thanks for the feedback. I used method missing (to answer u/pyrrhicvictorylap 's question) as it skimmed up the code that was needed. However it does seem that it's not ideal in this case so I removed it and replaced it with [dynamic method definitions.](https://github.com/Yorgg/cvme/blob/master/lib/cvme/document.rb)
Gruff graphs try too hard to look like the old Apple Numbers/Keynote graphs, and its not appealing
[removed]
:O For sure! Thanks!
I can only say that it is much simpler that virtus and that it works better than virtus for my needs. 2 modules, 5 classes, something like 26 methods total. It has a runtime dependency only for activesupport so I can use a `HashWithIndifferentAccess`, and I'm considering taking that out. On the other hand traitorous doesn't handle inheriting classes and it doesn't provide as fine grain control over accessors and default values. The main difference is in the way the two gems goes about coercing incoming values. I use a small number of Converter objects that respond to `[:do_import, :do_export]`, and then rely on the converter to do whatever typecasting needs to be done. There are a few more of those to write still, but I've done a couple of small side projects with this and the existing 5 converters have been completely sufficient for my purposes. The ability to export the same data structure (more or less) as is used upon import was critical to my needs and is what ultimately led to me writing my own library. Hope this helps. 
Right now, the flow to get your GitHub project setup with receiving `bundle update` as Pull Requests is simpler. Also, our Pull Request is pretty descriptive and link-friendly. Looking at this https://github.com/ruby-bench/ruby-bench-web/pull/122, you can actually click through to the gem, see a comparison of the changes between the version updates, and see the Changelog (if it exists) on the gem. So it's even easier to review the changes that you will be merging into your project. Hope this explains! Thank you!
[removed]
Sidekiq doesn't create Threads dynamically, everything is pre-allocated on startup. Only exception is when a job fails, I discard the Thread and create a new one just in case. No need for a pool.
[removed]
[removed]
[removed]
[removed]
[removed]
I built https://github.com/winston/google_visualr a few years ago and it's a wrapper around Google Charts. Demo available at http://googlevisualr.herokuapp.com/
That was a (very bad ) joke...
Oh, thank you.
Thanks.
[removed]
Have you tried mp4info? I've never used it, but the first thing I'd look at in wondering "Will a gem work on Windows", is whether it contains any compiled C code, or tries to call out to a unix executable with `system`, or depends on gems that do one of those things. method_missing is of course irrelevant to whether it'll work on Windows. If it's pure ruby, it _probably_ will. Or you could just try it and see, it's unclear to me if you have? [mp4info](https://github.com/arbarlow/ruby-mp4info) doesn't have an `ext` directory, which is what things with compiled C source have. It doesn't seem to have any system or backtic call-out calls in it. It doesn't actually have ANY dependencies in it's gemspec. It does include a [mysterious patch file](https://github.com/arbarlow/ruby-mp4info/blob/master/lib/mp4info-windows-binmode.patch) showing that nevertheless some fixes for Windows were neccesary at some point, because of Windows file system issues maybe? It's unclear what this `.patch` is doing in the repo, but hopefully it was left there accidentally and the diff it represents was already incorporated in the main source. And yes, it [looks like that is true](https://github.com/arbarlow/ruby-mp4info/blob/227c4c24a651ba966696ec8a05f71b8e0fdbe2c6/lib/mp4info.rb#L198-L199). So that's how I'd do a 10 minute investigation of the source to see that it probably should work on Windows. And then I'd try it and see. It's true that it's lack of tests is disturbing, but it did get a commit 18 days ago so it seems to be more or less maintained. If I had a problem with it on Windows, I'd file an Issue. 
[removed]
[removed]
[removed]
[removed]
Nope, I'm a different mperham who also just happens to know a lot about Sidekiq too. Using Celluloid allowed me to focus on the overall OOP and system design and less about thread-safety and race conditions. Now that the system design is stable and hasn't changed in years, I can backport it to raw threads.
[removed]
[removed]
This is hilarious.
[removed]
[removed]
This site will provide you with more links than any other site to enjoy watching the Mladá Boleslav U21 - Sparta Prague U21 live broadcasting. Mladá Boleslav U21 - Sparta Prague U21 online is just one of many sport games that we provide the links for completely free of charge. See all the live action on your iPad. Find the Live TV Section and you will definitely find many of your best-loved teams. We hope you will enjoy the Mladá Boleslav U21 - Sparta Prague U21 live telecast stream. We always try our best to get you the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **soccer**► **[enjoy watching Mladá Boleslav U21 - Sparta Prague U21 online](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Mladá Boleslav U21 - Sparta Prague U21 online](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Mladá Boleslav U21 - Sparta Prague U21 online](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Mladá Boleslav U21 - Sparta Prague U21 online](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ So enjoy the game you choose and now we offer you to see online broadcasting Mladá Boleslav U21 - Sparta Prague U21. Here you may discuss interesting and relevant events of Mladá Boleslav U21 - Sparta Prague U21. Also see the reviews of Mladá Boleslav U21 - Sparta Prague U21 match and join the discussion of soccer experts on this page. Searching for live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** ? You are in the right place! You are only in one step to enjoy **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming**. Your’s search adventure of **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** is over. Our website provides You **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** and other sport events**live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** is absolutely free of charge, You don’t need to pay for **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming**. To avoid any problems Yon can refer while **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** we try to provide You several source of **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming**. This mean that if something happens with the one **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** source, You can switch to another source of **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** and have no chance to miss your’s favourite **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** We will be very pleased when You share the link of **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** with Yours friends. For them it would be a great opportunity to enjoy **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** and find other live broadcasting of sport events they like. One more time – our website provides You not only the opportunity to watch **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** but other live broadcasting of other sport events. So hurry! Bookmark our website and enjoy with us **live online streaming of Mladá Boleslav U21 - Sparta Prague U21 live online streaming** and future live broadcasting of Yours favourites teams and sportsmen. 
[removed]
the whole idea of an app that scans the network looking for that one second in time when the button is pressed is just inefficient as hell. until the dash buttons can be hacked to directly trigger an event I will not use them.
[removed]
[removed]
&gt; chruby Oh boy. I packed up from rvm and have been using rbenv (with ruby-build) as it was supposed to be better. chruby was suggested as well, but most devs I knew had migrated to rbenv. What's problematic with rbenv? 
This website will provide you with more links than any other website to enjoy watching the Sri Lanka U19 vs Uzbekistan U19 live broadcasting. Sri Lanka U19 vs Uzbekistan U19 live online streaming is just one of many events that we set up the links for completely free. See all the live game on your PC. Find the Live TV Section and you will definitely find many of your preferent teams. We hope you will enjoy the Sri Lanka U19 vs Uzbekistan U19 live broadcasting. We always try our best to get you the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **soccer**► **[enjoy watching Sri Lanka U19 vs Uzbekistan U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Sri Lanka U19 vs Uzbekistan U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Sri Lanka U19 vs Uzbekistan U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Sri Lanka U19 vs Uzbekistan U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ So enjoy the game you choose and now we offer you to see online game Sri Lanka U19 vs Uzbekistan U19. Here you may discuss interesting and relevant events of Sri Lanka U19 vs Uzbekistan U19. Also see the reviews of Sri Lanka U19 vs Uzbekistan U19 match and join the discussion of soccer experts on this page. Searching for streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** ? You are in the right place! You are only in one step to enjoy **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live**. Your’s search adventure of **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** is over. Our website provides You **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** and other sport events**streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** is absolutely free of charge, You don’t need to pay for **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live**. To avoid any problems Yon can refer while **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** we try to provide You several source of **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live**. This mean that if something happens with the one **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** source, You can switch to another source of **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** and have no chance to miss your’s favourite **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** We will be very pleased when You share the link of **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** with Yours friends. For them it would be a great opportunity to enjoy **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** and find other live online streaming of sport events they like. One more time – our website provides You not only the opportunity to watch **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** but other live online streaming of other sport events. So hurry! Bookmark our website and enjoy with us **streaming live of Sri Lanka U19 vs Uzbekistan U19 streaming live** and future live online streaming of Yours favourites teams and sportsmen. 
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
This website will provide you with more links than any other website to enjoy watching the Hockey Club Valpellice - Asiago online broadcasting. Hockey Club Valpellice - Asiago online broadcasting is just one of many sport games that we set up the links for completely free. Watch all the live play on your computer. Check out the Live TV Section and you will definitely find many of your preferent teams. We hope you will enjoy the Hockey Club Valpellice - Asiago live broadcasting. We always do our best to provide the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **hockey**► **[enjoy watching Hockey Club Valpellice - Asiago online broadcasting](http://r041.donnael.com?S=3)** ___________________________________________________________________________________________ **hockey**► **[enjoy watching Hockey Club Valpellice - Asiago online broadcasting](http://r041.donnael.com?S=3)** ___________________________________________________________________________________________ **hockey**► **[enjoy watching Hockey Club Valpellice - Asiago online broadcasting](http://r041.donnael.com?S=3)** ___________________________________________________________________________________________ **hockey**► **[enjoy watching Hockey Club Valpellice - Asiago online broadcasting](http://r041.donnael.com?S=3)** ___________________________________________________________________________________________ So enjoy the competition you choose and now we offer you to enjoy watching online streaming Hockey Club Valpellice - Asiago. Here you may discuss amusing and relevant events of Hockey Club Valpellice - Asiago. Also enjoy watching the reviews of Hockey Club Valpellice - Asiago match and join the discussion of hockey experts on this page. Searching for live streaming of Hockey Club Valpellice - Asiago live streaming** ? You are in the right place! You are only in one step to enjoy **live streaming of Hockey Club Valpellice - Asiago live streaming**. Your’s search adventure of **live streaming of Hockey Club Valpellice - Asiago live streaming** is over. Our website provides You **live streaming of Hockey Club Valpellice - Asiago live streaming** and other sport events**live streaming of Hockey Club Valpellice - Asiago live streaming** is absolutely free of charge, You don’t need to pay for **live streaming of Hockey Club Valpellice - Asiago live streaming**. To avoid any problems Yon can refer while **live streaming of Hockey Club Valpellice - Asiago live streaming** we try to provide You several source of **live streaming of Hockey Club Valpellice - Asiago live streaming**. This mean that if something happens with the one **live streaming of Hockey Club Valpellice - Asiago live streaming** source, You can switch to another source of **live streaming of Hockey Club Valpellice - Asiago live streaming** and have no chance to miss your’s favourite **live streaming of Hockey Club Valpellice - Asiago live streaming** We will be very pleased when You share the link of **live streaming of Hockey Club Valpellice - Asiago live streaming** with Yours friends. For them it would be a great opportunity to enjoy **live streaming of Hockey Club Valpellice - Asiago live streaming** and find other live online streaming of sport events they like. One more time – our website provides You not only the opportunity to watch **live streaming of Hockey Club Valpellice - Asiago live streaming** but other live online streaming of other sport events. So hurry! Bookmark our website and enjoy with us **live streaming of Hockey Club Valpellice - Asiago live streaming** and future live online streaming of Yours favourites teams and sportsmen. 
[removed]
[removed]
Having something that runs 24/7 to look for that one packet is not what I consider efficient.
[removed]
[removed]
[removed]
Not sure posting on stack is a good idea for low questions are immediately downvoted. Newbies questions are commonly considered as a low quality ones.
This page will provide you with more links than any other website to enjoy watching the Palestine U19 - UAE U19 live broadcasting. Palestine U19 - UAE U19 live online streaming is just one of many events that we provide the links for completely asolutely free. Enjoy watching all the live play on your computer. Find the Live TV Section and you will definitely find many of your best-loved teams. We hope you will enjoy the Palestine U19 - UAE U19 live broadcasting. We always try our best to get you the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **soccer**► **[enjoy watching Palestine U19 - UAE U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Palestine U19 - UAE U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Palestine U19 - UAE U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ **soccer**► **[enjoy watching Palestine U19 - UAE U19 live online streaming](http://r041.donnael.com?S=4)** ___________________________________________________________________________________________ So enjoy the match you choose and now we offer you to see online streaming Palestine U19 - UAE U19. Here you can discuss interesting and relevant events of Palestine U19 - UAE U19. Also enjoy watching the reviews of Palestine U19 - UAE U19 match and join the discussion of soccer experts on this page. Searching for live broadcasting of Palestine U19 - UAE U19 live broadcasting** ? You are in the right place! You are only in one step to enjoy **live broadcasting of Palestine U19 - UAE U19 live broadcasting**. Your’s search adventure of **live broadcasting of Palestine U19 - UAE U19 live broadcasting** is over. Our website provides You **live broadcasting of Palestine U19 - UAE U19 live broadcasting** and other sport events**live broadcasting of Palestine U19 - UAE U19 live broadcasting** is absolutely free of charge, You don’t need to pay for **live broadcasting of Palestine U19 - UAE U19 live broadcasting**. To avoid any problems Yon can refer while **live broadcasting of Palestine U19 - UAE U19 live broadcasting** we try to provide You several source of **live broadcasting of Palestine U19 - UAE U19 live broadcasting**. This mean that if something happens with the one **live broadcasting of Palestine U19 - UAE U19 live broadcasting** source, You can switch to another source of **live broadcasting of Palestine U19 - UAE U19 live broadcasting** and have no chance to miss your’s favourite **live broadcasting of Palestine U19 - UAE U19 live broadcasting** We will be very pleased when You share the link of **live broadcasting of Palestine U19 - UAE U19 live broadcasting** with Yours friends. For them it would be a great opportunity to enjoy **live broadcasting of Palestine U19 - UAE U19 live broadcasting** and find other live webcast of sport events they like. One more time – our website provides You not only the opportunity to watch **live broadcasting of Palestine U19 - UAE U19 live broadcasting** but other live webcast of other sport events. So hurry! Bookmark our website and enjoy with us **live broadcasting of Palestine U19 - UAE U19 live broadcasting** and future live webcast of Yours favourites teams and sportsmen. 
[removed]
[removed]
[removed]
Much of this was review for me, but I enjoyed it all the same. As mentioned in the video, check out https://github.com/JuanitoFatas/fast-ruby for some optimization insights.
why not ask? http://gabebw.com/
I think the idea of the post was to shed some light into how Sinatra and co. work and it certainly hit the spot. The Nancy name is a great pun.
Hasn't been touched in 18 months == dead.
Uh, well that's weird. I'll admit I've never done it myself. What happens if you go directly here: https://rubyonrails.typeform.com/to/g9CVKl
7 || nil is evaluated. ruby always returns the value of the last evaluated expression. 
In Ruby, most things return a value. Technically everything returns a value, but I'm not referring to nil as a value here. Both `or` and `||` don't go through each value, but rather stop as soon as they encounter a truthy value. This can be seen with the eval.in snippet [here](https://eval.in/445321). Rather than simply returning true or false, it returns the value. In case you don't know what truthiness or falsiness is, it's basically what a conditional will interpret a value as. If it interprets it as it would a true, it's truthy. If it doesn't, it's falsey. Rule of thumb: nil and false are falsey, and everything else is truthy.
&gt; Nope, I'm a different mperham who also just happens to know a lot about Sidekiq too. Can't tell if sarcasm... How likely is it that there are two mperham sidekiq authors? More likely that you've cloned yourself, and set one of the clones to maintain your reddit account, while the others get other stuff done.
[removed]
This site will provide you with more links than any other site to enjoy watching the NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting. NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting is just one of many sport games that we provide the links for completely costless. Watch all the live game on your PC. Check out the Live TV Section and you will definitely find many of your favorites teams. We hope you will enjoy the NOVA Novokuybyshevsk - Enisey Krasnoyarsk live telecast stream. We always do our best to provide the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **volleyball**► **[enjoy watching NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting](http://r041.donnael.com?S=6)** ___________________________________________________________________________________________ **volleyball**► **[enjoy watching NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting](http://r041.donnael.com?S=6)** ___________________________________________________________________________________________ **volleyball**► **[enjoy watching NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting](http://r041.donnael.com?S=6)** ___________________________________________________________________________________________ **volleyball**► **[enjoy watching NOVA Novokuybyshevsk - Enisey Krasnoyarsk online broadcasting](http://r041.donnael.com?S=6)** ___________________________________________________________________________________________ So enjoy the competition you choose and now we propose you to see online game NOVA Novokuybyshevsk - Enisey Krasnoyarsk. Here you can discuss interesting and relevant events of NOVA Novokuybyshevsk - Enisey Krasnoyarsk. Also see the reviews of NOVA Novokuybyshevsk - Enisey Krasnoyarsk match and join the discussion of volleyball experts on this page. Searching for watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** ? You are in the right place! You are only in one step to enjoy **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live**. Your’s search adventure of **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** is over. Our website provides You **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** and other sport events**watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** is absolutely free of charge, You don’t need to pay for **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live**. To avoid any problems Yon can refer while **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** we try to provide You several source of **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live**. This mean that if something happens with the one **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** source, You can switch to another source of **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** and have no chance to miss your’s favourite **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** We will be very pleased when You share the link of **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** with Yours friends. For them it would be a great opportunity to enjoy **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** and find other live broadcasting of sport events they like. One more time – our website provides You not only the opportunity to watch **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** but other live broadcasting of other sport events. So hurry! Bookmark our website and enjoy with us **watch live of NOVA Novokuybyshevsk - Enisey Krasnoyarsk watch live** and future live broadcasting of Yours favourites teams and sportsmen. 
No, this is incorrect. Ruby "shortcuts" logical expressions. So for an OR condition, if the first expression results in anything other than false or nil the second expression won't be evaluated at all. For an AND condition, if the first expression returns false or nil the second won't be evaluated. 
This page will provide you with more links than any other website to watch the Anyang KGC - Seoul Thunders live broadcasting. Anyang KGC - Seoul Thunders online is just one of many sport games that we set up the links for completely costless. Watch all the live play on your iPad. Check the Live TV Section and you will definitely find many of your best-loved teams. We hope you will enjoy the Anyang KGC - Seoul Thunders live telecast stream. We always do our best to provide the best possible HD Streams to watch Live Sports Online. ___________________________________________________________________________________________ **basketball**► **[watch Anyang KGC - Seoul Thunders online](http://r041.donnael.com?S=2)** ___________________________________________________________________________________________ **basketball**► **[watch Anyang KGC - Seoul Thunders online](http://r041.donnael.com?S=2)** ___________________________________________________________________________________________ **basketball**► **[watch Anyang KGC - Seoul Thunders online](http://r041.donnael.com?S=2)** ___________________________________________________________________________________________ **basketball**► **[watch Anyang KGC - Seoul Thunders online](http://r041.donnael.com?S=2)** ___________________________________________________________________________________________ So enjoy the game you choose and now we offer you to see online broadcasting Anyang KGC - Seoul Thunders. Here you can discuss interesting and relevant events of Anyang KGC - Seoul Thunders. Also enjoy watching the reviews of Anyang KGC - Seoul Thunders match and join the discussion of basketball experts on this page. Searching for streaming live of Anyang KGC - Seoul Thunders streaming live** ? You are in the right place! You are only in one step to enjoy **streaming live of Anyang KGC - Seoul Thunders streaming live**. Your’s search adventure of **streaming live of Anyang KGC - Seoul Thunders streaming live** is over. Our website provides You **streaming live of Anyang KGC - Seoul Thunders streaming live** and other sport events**streaming live of Anyang KGC - Seoul Thunders streaming live** is absolutely free of charge, You don’t need to pay for **streaming live of Anyang KGC - Seoul Thunders streaming live**. To avoid any problems Yon can refer while **streaming live of Anyang KGC - Seoul Thunders streaming live** we try to provide You several source of **streaming live of Anyang KGC - Seoul Thunders streaming live**. This mean that if something happens with the one **streaming live of Anyang KGC - Seoul Thunders streaming live** source, You can switch to another source of **streaming live of Anyang KGC - Seoul Thunders streaming live** and have no chance to miss your’s favourite **streaming live of Anyang KGC - Seoul Thunders streaming live** We will be very pleased when You share the link of **streaming live of Anyang KGC - Seoul Thunders streaming live** with Yours friends. For them it would be a great opportunity to enjoy **streaming live of Anyang KGC - Seoul Thunders streaming live** and find other live broadcasting of sport events they like. One more time – our website provides You not only the opportunity to watch **streaming live of Anyang KGC - Seoul Thunders streaming live** but other live broadcasting of other sport events. So hurry! Bookmark our website and enjoy with us **streaming live of Anyang KGC - Seoul Thunders streaming live** and future live broadcasting of Yours favourites teams and sportsmen. 
That guy's talk is great, but the code he links to (`talkingquickly/rails-server-template`) doesn't work. I've been pulling my hair out for days trying to get this set up after watching how "easy" it is, but so many errors that come out of nowhere from firewall packages and strange breaking API changes in Chef. I'm sure it was great when the talk first came out, but right now it's very broken. 
Everything in ruby evaluates as a value. (Or "returns" a value). Another way to say that is that all statements in ruby are expressions. The ruby expression `a || b` returns `a` if and only if `a` evaluates as true, otherwise it returns `b`. That is what the `||` "short circuit boolean or" operator does. In ruby, everything but `nil` and `false` evaluates as "true" in logical expressions. So `7 || nil` returns `7`, because `7` is not `nil` or `false`. Likewise, the `&amp;&amp;` opererator is the 'short circuit boolean and'. `a &amp;&amp; b` will return a "truthy" value only if both `a` and `b` are "truthy" (not `nil` or `false`). But the "short circuit" nature of `&amp;&amp;` means that `a &amp;&amp; b` stops when it has enough to know if it should be true or false. If `a` is false, then `a &amp;&amp; b` can't possibly be true, so we know enough. So the `a &amp;&amp; b` "short circuit boolean and" will return `a` if `a` is false, otherwise it will return `b`. Wow, this is harder to explain than I anticipated, not sure how clear this is. If you haven't already, you should start by understanding "boolean algebra" and truth tables. I'm not finding a link I'm happy with for this right now. 
[removed]
Once you get inside the initialize block you're in a different scope, so you have to qualify Bar with Foo. If you reference Bar at the top level of the module Baz then you do not need Foo as a qualifier. Check this out: http://stackoverflow.com/questions/7549625/ruby-classes-include-and-scope
Although `class Test` introduces new scope, identifier resolution **finds unqualified constant** `Qux` by traversing to outer scopes. That is the point ! The question is about why the same would not apply to included `Bar` ?
[removed]
I think there has to be a balance. If we wrote *everything* in the 100% best language for the job, everyone would have to learn 100s of languages, rather than dozens and languages would have to have hundreds of interfaces to any other useful language, not dozens (diluting effort spent).
[removed]
Ruby constant namespace lookup is frequently confusing to me, I can't quite keep it straight. Here's an article about some of it's weirdness, although in this case not related to your observation I don't think: http://blog.honeybadger.io/avoid-these-traps-when-nesting-ruby-modules/ I think most rubyists don't try to mess too much with this kind of constant lookup -- they just fully qualify everything but the most trivial, and I'm increasingly seeing constant references always prefixed with a top-level `::` even too. I don't know which is the chicken and which is the egg. 
Yeah, I want to know what's going on in your case too! But after years of being confused by unqualified constant lookup in ruby, figuring out a weird thing I come across only to forget it again later next time I run into it, I've personally decided it's just too weird and given up on wrapping my head around it. It does work as expected with fewer levels of nesting. I'm not sure why it doesn't in your case either. I guess `include` somehow only brings in the direct level for unqualified lookup? Doesn't make sense to me either. module SomeModule OurConstant = "our_constant" end class SomeClass include SomeModule puts "From class definition: #{OurConstant}" def return_constant "From instance method: #{OurConstant}" end end puts SomeClass.new.return_constant # =&gt; "From class definition: our_constant" # =&gt; "From instance method: our_constant" Here's another explanation of unqualified constant lookup, I'm not honestly quite sure if it addresses what's happening here: https://cirw.in/blog/constant-lookup Most of the core ruby developers are Japanese, I don't think I've seen any of them on /r/ruby. 
I know only about classic Ruby Warrior - https://www.bloc.io/ruby-warrior/
[removed]
[removed]
[removed]
We use the httparty gem heavily. It makes this kind of work a lot cleaner. #!/usr/bin/env ruby require 'httparty' res = HTTParty.get("http://google.com") puts res.headers.inspect 
You can use `response.header.to_hash` to get a hash with key/values for each header attribute. If the age is included in the HTTP header, then you can access it like `response.header.to_hash["age"]`. See: http://ruby-doc.org/stdlib-2.1.2/libdoc/net/http/rdoc/Net/HTTPHeader.html, which is a module included in the `Net::HTTPOK` class. 
Define "header age" 
[removed]
Apologies, it does work. I was just being a noob! Many thanks for your help, it is greatly appreciated!
[removed]
EXACTLY. THANK YOU FOR THAT ICEFLAME.
Well done! Just made my pledge.
Great news, well done.
&gt; As you stated, in Ruby, everything but nil and false evaluates as 'true' or 'truthy' in a logical expression(and presumably Ruby evaluates every logical expression?) Ruby evaluates _everything_. In the sense that any legal ruby statement or code has a 'return value', some value it evaluates as. Everything in ruby is an expression. Some things return `nil`, like `puts` does, you're right. I'm not sure what examples you are going through, but they are odd ones, sort of demonstrating tricks and weird things to do, not things that would normally be done in ruby code. If you are a beginner to programming, and the tutorial you are using isn't working for you, try another one. 
[removed]
From what you provided, the specific input "47" is failing because of the way your loop is structured. You are iterating over the values of the *decimalValue* array sequentially and the first value that matches the condition is 40: if (decimalValue[i] &lt;= num) &amp;&amp; (decimalValue[i + 1] &gt; num) You are then decrementing 40 from 47, giving you a result of 7. Continuing your iteration of the array, you see values 50, 90, 100, and so on, none of which match your condition. The JavaScript repl you provided uses a *while* loop instead of an incremental loop and this is where your problem lies.
Non-inherited constants are never accessible without full qualification. Your ability to access `Qux` actually has nothing to do with the inheritance or module nesting. It's accessible because it's in a parent lexical scope, which happens to be a module definition in this case but that isn't important. Conceptually it's just like a lambda/proc/block accessing a variable from it's definition scope. Maybe it's the inheritance that is confusing: When you place `Test` inside `Baz` that does not imply inheritance. Unqualified nesting of classes and modules simply creates name-spacing, it doesn't impact the inheritance hierarchy. Baz::Test.ancestors =&gt; [Baz::Test, Object, Kernel, BasicObject] Note that neither `Baz`, nor `Foo` are in the inheritance chain of `Test`. You can access `Qux`, but that is due to lexical scoping, not inheritance. However: Baz.ancestors =&gt; [Baz, Foo] This is because `include` inserts `Foo` into the inheritance chain of `Baz`. Thus if you were to try to access `Bar` directly inside `Baz`, it's no problem as it walks the inheritance chain to `Foo` and finds `Bar`. 
[removed]
Woot! Congrats Daniel!
[removed]
&gt; So why can't be accessed without full qualification inherited constant Bar from module Foo ? Because `Bar` doesn't exist in `Baz`, it exists in `Foo`, `Test` has no access path to `Foo`. &gt; I think you are mistaken here. First it is considered own to Baz module contrary to inherited Bar. I'm not sure what this means. &gt; Second, the lexical scope either does not explain the difference between include and indirect constant definition, either runtime non-lexical definition making it also accessible unqualified: You can think of it as Ruby binding the constant definitions into the lexical scope of the module/class definition blocks. It doesn't actually matter if the const is defined inline or dynamically, it's automatically available in the lexical scope of the definition of it's 'holder', if that makes sense. You can see this by defining `Test` differently. module Foo class Bar end end module Baz include Foo ALICE = 1 # direct lexical const_set :BOB, 2 # indirect lexical class Qux end end class Baz::Test def initialize Baz.const_set :HELLO, 'world' # runtime definition p Baz.constants # [:ALICE, :BOB, :Qux, :Test, :HELLO, :Bar] # see all constants are visible at Baz scope p self.class.constants # [] &lt;- no constants in Baz::Test p [ALICE, BOB, HELLO, Qux] # [1, 2, "world", Baz::Qux] # see all module scope constants are properly resolved # using unqualified specification - except p Bar # uninitialized constant Baz::Test::Bar (NameError end end Baz::Test.new =&gt; [:Test, :ALICE, :BOB, :Qux, :HELLO, :Bar] [] NameError: uninitialized constant Baz::Test::ALICE As you can see we have the same structure, but `Test` isn't defined inside `Baz`'s module definition and now all those constants are inaccessible from `Test`.
Thanks for your support with GoRails, Chris.
&gt; Because Bar doesn't exist in Baz, it exists in Foo, Test has no access path to Foo `Baz` *is aware* about `Bar`and exists in a sense of an inherited constant. I gave examples with `Module.constants` calls as a proof. Putting class `Test` definition outside of `Baz` module unfortunately still does not explain the issue with unqualified resolution: module Baz include Foo class Qux end p constants # [:Qux, :Bar] &lt;- Bar exists in Baz scope as unqualified constant ! class Test def initialize p Qux # Baz::Qux p Bar # uninitialized constant Baz::Test::Bar (NameError) end end end Still waiting to see some logical explanation or link as a documented behavior. EDIT: From Module class docs (shortened): Module#include(module) Invokes `Module.append_features` on each parameter in reverse order. Module#append_features(mod) -&gt; mod Ruby's default implementation is to **add the constants, methods, and module variables of this module to mod** if this module has not already been added to mod or one of its ancestors. 
[removed]
&gt; Baz is not in Test's inheritance chain, Nowhere saying `Baz` is in `Test's` inheritance chain. &gt; Test never even asks Baz if it has Bar. It checks it's locally available scopes, the global scope and then it's inheritance chain. None of those things have Bar This is simply wrong statement. As has been repeatedly demonstrated, at constant identifier lookup `Baz` **is** asked as the closest outer scope. How other can you explain successful lookup of **unqualified** `Qux`constant in `Test#initialize` ? 
&gt; This is simply wrong statement. As has been repeatedly demonstrated, at constant identifier lookup Baz is asked as the closest outer scope. How other can you explain successful lookup of unqualified Quxconstant in Test#initialize ? There is a difference between asking `Baz` for a constant and looking for a constant in the lexical scope hierarchy. In the former case `Baz` will check itself and it's inheritance hierarchy, in the later case no inheritance is considered, it just checks the scopes. module Foo class Bar end end module Baz include Foo def self.const_missing(name) p "Someone is looking for a const named #{name} in Baz!" end class Qux end class Test def initialize p Qux p Derp p Bar end end end Baz::Blah =&gt; "Someone is looking for a const named Blah in Baz!" Baz::Test.new =&gt; Baz::Qux NameError: uninitialized constant Baz::Test::Derp As the above shows, `Baz` is not asked for any constants when `Test` is initialized.
I had to write explicitly `Baz's` *scope* is asked/searched. `const_missing` is invoked in different case, so unrelated to the issue. Sorry for the confusion. The question *"How can you explain successful lookup of unqualified `Qux` constant in Test#initialize ?"* still unanswered. EDIT: a few of notes to consider - `Module#const_set` can assign a constant to a module and register it for scope lookup from anywhere and anytime during a runtime. - `Module#include` can assign reference to inherited constant but likely not register it for scope lookup - bug or a feature ?. In addition it inserts inherited module in ancestors list. - Scope lookup works from a point of call up to the top level. When fails, it raises NameError exception with fully qualified identifier to the scope of a call. 
my thoughts: 1. 100k is not a lot. store everything in memory 2. how fast is 'quickly'? can you use a traditional database to avoid prematurely optimizing this problem? 3. soon after you establish such a priority queue which is based on one rule, other rules for priorities come up, be prepared 4. redis zsets, if you want to stay on redis 
dont understand the question but you should probably look at https://github.com/RubyMoney/money
thanks for the reply and I will to try and articulate better. I want to track real estate rental income which occurs either weekly or monthly. if the money is not marked as received then it would be mark as owing though the main hurdle i'm trying get over is the before mentioned income tracking. I am still trying to see if the rubymoney gem is applicable though it looks like it is mostly used for currency conversions?
[removed]
&gt; yes I'm new to Ruby Do you know the basics? What a class is, etc? You need to know these things before attempting to write your own classes. &gt; Create a Book class. Make sure that important attributes of books can be handled. Make methods corresponding to what you can do with books. Ok, so what do books have? They are usually written by an author, and have a title. Date of publication maybe? ISBN? Publisher. They also contain pages, and text. What can you do with a book? You can flip a page, read the page, etc. You can search through the pages looking for a certain word. etc. You see, you have some properties and some methods. If you can implement these things, you'd already have learned a lot. &gt; store them in a file using yaml So you'd probably want to load the books from a yaml. Yaml is just a way of writing down data. If you store every book as a hash, you'd get something like books: - title: Some title author: Some author ISBN: "12312-124124-1241" pages: - "Lorem ipsum..." - "Lorem ipsum..." - "Lorem ipsum..." - title: Some title author: Some author ISBN: "12312-124124-1241" pages: - "Lorem ipsum..." - "Lorem ipsum..." - "Lorem ipsum..." It's your job to learn how to load this stuff from a file, convert it to hashes and convert those to a Book instance. &gt; Can you search for a specific book in your ruby program? You'd probably want a Library class, that holds all the books and can search book titles (or authors, ISBN, etc) for a certain phrase.
[removed]
Which part of the job do you want the gem to help with? Are you trying to accept payments online, or are you just manually entering payments received and keeping track of user accounts and balances? Something else?
Thanks for the comment. Does your solution work if there can be multiple jobs for a given serial number? Would I have to keep track of key names and increment them somehow? ala: job2::abc123 ? I'll look into MULTI...EXEC. Am I on the right track that the procedure would be to look at the existing keys to see if any match my newly-prioritized SN and then update their score(s) in the index? Thanks again.
That project was the inspiration for this, although it focus on passing CI tests and this one is just focus on passing unit tests
Thank you so much for the reply! I'm new to Ruby, but i know all the basics, classes, arrays, hashes etc. This helped me pretty much! =)
[removed]
This is great, thanks. I didn't realize customizing the form helpers with a custom builder was possible. 
I think https://github.com/mbulat/plutus might be along the lines of what you're really looking for
[removed]
[removed]
[removed]
Currently SciRuby community tries to do Ruby more suitable for tasks like this. Not that outcome is fascinating, yet it worth a look. In particular, large dataset processing is supposed to be done with [daru](https://github.com/v0dro/daru)
&gt; Does your solution work if there can be multiple jobs for a given serial number? Would I have to keep track of key names and increment them somehow? You would likely need a secondary index for this stored elsewhere. e.g. a `Set` of serial number to Job ID to support multiple jobs with the same serial number. The basic flow to increment the scores in pseudo code, I quickly typed this out so there are likely errors, only use as a basic guide: job_ids = SMEMBERS 'serial_number_to_job_id_map::&lt;serial_number&gt;' job_ids.each { ZADDXX 'job_queue' &lt;job_id&gt; &lt;new_score&gt; } An example organization of keys: `serial_number_to_job_id_map::&lt;serial_number&gt;` &lt;- Set holding the job_ids, one for each serial number `job_queue` &lt;- Sorted Set, values are job_ids, one key `jobs::&lt;job_id&gt;` &lt;- String, holds the job payload, one for each job, this could be all in a single `Hash` key also When multiple elements in a ZSET have the same score they are returned lexicographically by key, so however you generate `job_id` should take this into account to get FIFO-ish semantics. Enqueue a job, in pseudo code: MUTLI SET 'jobs::&lt;job_id&gt;' &lt;job_json_as_string&gt; ZADD 'job_queue' &lt;job_id&gt; &lt;default_score&gt; SADD 'serial_number_to_job_id_map::&lt;serial_number&gt;' &lt;job_id&gt; EXEC Get a job to work on, in pseudo code: # pop the highest ranking job_id off the queue, # this is an atomic operation and as such there should be no # contention for the job_id job_id = ZREMRANGEBYRANK 'job_queue' 0 1 job = GET 'jobs::&lt;job_id&gt;' # the job payload DEL 'jobs::&lt;job_id&gt;' SREM 'serial_number_to_job_id_map::&lt;serial_number&gt;' &lt;job_id&gt; NOTES: You may need more strict correctness guarantees here, for example what happens when a job fails? What happens if I try to enqueue the same job twice? etc. How important this is and which guarantees you want to try to get depends on your requirements. That said I will warn you that guaranteeing 'exactly once' processing with 100% reliability isn't a realistic goal, you can get to 'at least once' semantics with some additional tweaks, a distributed queue like SQS or RabbitMQ is recommended for this though. 
Possible dirty hack. You could use the entire sequence: "," as your delimiter. It would probably work, but like I said it's a dirty hack.