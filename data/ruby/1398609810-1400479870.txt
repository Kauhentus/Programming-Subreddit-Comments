Lower case post?
please use something like http://pastie.org/ or pastebin to post code.
Tried switching cases on all the .rb's and still returns the error. What should it be upper case or lower case?
I hate it when rails gets automatically equated to ruby. Next time, try /r/rails. Also, include the full backtrace. And who the hell posts screenshots of code? Ever heard of pastie.org?
no actually I haven't. I am new at this. and sorry for the confusion, Since I am Using both ruby and rails code I wasn't sure where to put it. 
Thank you for informing me where to get that from. 
http://pastie.org/9117355
use %=post.body instead of %post.body, too 
My bad. Let me correct my mistake by going into more detail about what I said, and hopefully helping you to get more and better help with your rails issues in the future. The first issue at hand: Rails is Rails and not (just) Ruby. While most Ruby people have a humble amount of Rails experience, not all Ruby people will have extensive knowledge of what can go wrong with Rails. Rails is a huge framework written in Ruby, and a very big chunk of what Rails does has nothing to do with Ruby beyond the basic building blocks. That's why you're better off asking Rails people about Rails problems. Next, when you run into an error, and you want to ask for help, you need to provide these people you're asking with as much information as possible. Otherwise, they are left guessing. This usually includes all relevant code and the full stack trace, if applicable. You can post all of these to pastie.org, or a github gist, which allows for multiple separate files. I'm sorry for being rude. It just so happens that rails stuff being asked on ruby forums is one of those things that makes me go *hnnnnggg*. Happy rails coding!
should be `Post.order(created_at: :desc)`
How do I make it so the code shows up in my comments like everyone else in this sub does? 
You indent the code by 4 spaces to create a code block, or surround it with backticks (`) to create inline code spans.
No, I know what you are saying is true. I do need to hear it. I just can't learn the slow and steady way. I have to try and do a project that is a little outside my skill set in order to progress. I have been reading through a couple ruby books and doing some projects at the same time. Really want to get this as fast as possible. 
I think it is because I didn't run rake: db migrate before testing it.
`prints "like this?"` 
If you did a `rails g scaffold` then you are correct. The scaffold creates the model, controller, views, testing, some stuff I'm probably forgetting, and also the migrations. The migrations are what actually update your database table, so if you never ran the migrations (with rake db: migrate) then the posts don't really exist. You have a file that says what to do to the database, and files that interact with the database in various ways, but your database is still the same. As someone pointed out further up, if @posts is nil then there's no each method (because the method is being called on the object, and the object is nil.) Why might it be nil? Say you did `@posts = Post.all`. That asks the database for everything in the posts table. But since you never ran the migration, there is no posts table. So it returned nil. Since nil doesn't have an each method (as, among other things, it's not a collection), you get the error. You may have already known all that, sorry. But in case you didn't, hope it made sense.
Looks about right to me. There's no syntax highlighting here, though, so for longer code, use a pastie, or a gist ;)
i did `rails generate resource ` I tried to migrate the db but terminal returned an error
I would say it really depends on what you’re optimizing for. And I speak from first-hand experience, because I did the same thing as you eight or so years ago. I’d been using PHP previously, and I dove into Rails without having any undersrtanding of how Ruby worked—I didn’t even really understand that Ruby was a separate language. I’m sure I asked a lot of questions just like yours, and learned a lot of things in parallel because I was eager to make things and didn’t want to go what I perceived as the slow way. I was able to get to Hello World and make really simple, small applications, which at that time I thought were awesome, but in retrospect realize were terrible. I spent four years doing terrible work without realizing it, and learning a bunch of bad habits in the process, almost entirely because I wanted to go “fast”. Now, in addition to working on my own products, I also teach Ruby and Rails, and when I do specifically make them spend most of their time just using Ruby, before they do a little bit of Rails work at the end. They become so proficient with Ruby, that when they get to Rails after a couple months, they’re able to come in where I was at after four years, but with no bad habits, and it only took them a month or two. If I could do it all over again with myself I’d do it the “slow” way and save myself several years of struggling. So if you’re optimizing for the short-term, do it all in parallel, but if you’re optimizing for the long-term, learning Ruby really well first will be _way_ faster in the long-run.
I haven't used the resource generator but it seems that it's the same as scaffolding, except it doesn't generate the views. So what I said should be true. If migrating is causing an error that's the first thing that should be fixed. What's the error (if you haven't already fixed it.)
either works with active record.
i doubt that `post.order` anything works
Just out of curiosity, what aspects of Ruby do you normally cover in yours classes? I'm a CS major whose been working with Rails and found Ruby itself pretty easy to pick up (at least in terms of syntax) but I'm a bit worried I'm in the situation you were in and I don't know what I don't know (if that makes sense.)
Yes, that is true. Too early in the day to figure out how reddit threads work.
I definitely didn't migrate the db yet. so thats probably what is. I need to figure out why it isn't doing that.
I'd refer you to /u/Velium's excellent answer here: http://www.reddit.com/r/ruby/comments/24003u/best_practices_in_connecting_to_external_apisweb/ch39uek
What if the user opens up another browser tab and looks at another page?
tell me more... (i was not aware of this issue)
It depends on what level I’m teaching. If they have no prior progamming experience, then I teach the basics of programming through Ruby, so they’re getting intro to programming and intro to Ruby simulatenously. Then I layer on object-oriented principles and the parts of Ruby that are non-standard and somewhat unique to Ruby (blocks, symbols, etc.). Then I teach testing, and from that point on, everything they do is test-driven. Then I teach design patterns and good programming principles; separation of concerns, single reposnsibilty, facade pattern, etc. Once they’ve built a number of Ruby-only programs with these principles, then I layer in using Ruby to build web applications using Sinatra. And once they’ve built a few with Sinatra, then I teach Rails. What’s awesome is that by this point, I barely even need to teach Sinatra or Rails. They’re foundation in Ruby is so good that they don’t see Sinatra and Rails as these magical frameworks. It's all just Ruby, so they can basically teach themselves now. "Computer Science" is a bit broad and the term is applied so loosely that it's hard to know what you might or might not know, and what parts were emphasized in your education. If you have prior programming experience with a language, I think one of the best ways to get into Ruby is to do the [Ruby Koans](http://rubykoans.com). That teaches programmers with experience in other languages the Ruby syntax, as well as kind of gets you started down the testing path. If you're using Rails and you feel like it's difficult to work with the framework, then you're foundation in Ruby and/or programming for the web (request/response cycle, etc.) probably isn't strong enough. The stronger your Ruby-fu, the easier Rails becomes to understand. If you find Rails generally easy to work with, but you're applications quickly turn into giant messes, then you're foundation in software architecture and design probably isn't strong enough. This part is often missing from computer science curriculums. Very rarely do they teach you how to write good code and actually build a program well. DHH wrote a [post with the five books that he recommends](https://signalvnoise.com/posts/3375-the-five-programming-books-that-meant-most-to-me), and I'd say those are an excellent place to start. I hope that helps. If you want to give me some more details about what you find difficult and/or confusing I can try and point you in a more specific direction.
For web apps balancing what to store and where is difficult. If you store any state on the server scaling the application to multiple servers becomes harder. Session data must be replicated across servers. If you store any view specific information to session, user might not be able to use multiple tabs in your app because session is shared between tabs. Sessions are based on browser cookies and cookies are shared between browser windows and tabs. I prefer to store state in: * RESTful URLS: /race/1, /race/1/laps, ... * Encrypted/signed secure session cookie * Memcache * Database Each has its own pros and cons.
How do I incorporate my params (name, rating) into my POST url?
Yup, I've seen that in the last codebase I've worked on too
when doing POST request you specify parameters in request body and not in URL. See: http://stackoverflow.com/questions/14551194/how-are-parameters-sent-in-an-http-post-request
At the end of the day, while I think VIM is great and never leaving the keyboard can boost productivity, I think honestly most developers spend more time thinking and running tests than they do typing. VIM is very efficient and worth trying to become proficient at, but at the end of the day my personal feeling is that being able to actually edit code faster has very little productivity benefit in the grand scheme of things. 
first - thanks for the informative response. Basically, I am creating a fantasy sports site for an obscure sport. The user will select a race, and then select 3 runners from that race. The session variable is used to store the raceID, so that when the user submits the picks, those picks can be put into a DB with the associated race. The multiple browser window issue is interesting, but I'm not sure that it messes with my code in this case. Moving to a RESTful URL might make sense though. I am interested in learning more about this, do you have any recommended resources?
So the create definition would be unchanged... def create @hotel = Hotel.create!(params[:hotel]) respond_with(@hotel) end Do you know by chance how you would send the post request body in Cocoa?
As /u/Intolerable said elsewhere in this thread, I think you just need to capitalize the reference to the Post class in line 5 (ie: `@posts = Post.order("created_at desc")`), though I'm a little surprised your controller wasn't throwing a `NameError: undefined local variable or method` error on line 5. Also, as has been said in other comments, this is more of a Rails question than a Ruby question. It'll take time for you to be able to recognize the difference, but if it helps you, here's why: the issue here wasn't with any of the Ruby language itself, but rather with getting the components of the Rails framework talking to each other. The error in your view was caused by a typo in your controller.
Yeah I tried everythin. Switched the capitalization, did `rake db:migrate` and still the shit keeps kicking back. 
Not sure about the actual objectiveC libraries, but you can experiment with http://code.google.com/p/cocoa-rest-client/ 
In iOS 7 you have the new NSURLSession, also take a look at AFNetworking for easy requests as well as MagicalRecord and RestKit as Rails-friendly object wrappers. 
You can use [RestKit](https://github.com/RestKit/RestKit/#post-patch-and-delete-an-object) for all your restful api requests. If you only need to make super simple requests, you can use [AFNetworking](https://github.com/AFNetworking/AFNetworking) (which RestKit uses under the hood).
I believe you can simplify the entire [`options_callback`](https://github.com/Plasmarobo/simpleoutput/blob/master/lib/simpleplot.rb#L27) method to one line: @metadata[@current_name].merge! options [`translate_name`](https://github.com/Plasmarobo/simpleoutput/blob/master/lib/simpleoutput.rb#L51) can be simplified to this: name || @current_name `appendHash` and `setHash` share a lot of code. Try to extract it into a private method. Btw. please use `under_score` for Ruby methods. That's what everyone else does.
Awesome syntax! I'd make the "Usage" section a bit more clear though — it'd be nice to clarify what "you have to include and extend it" with an actual code example, for instance.
Any reason you don't use/extend (vs re-invent)? * http://www.omniref.com/ruby/2.1.1/classes/Thread##value (tasks) * http://www.omniref.com/ruby/2.1.1/classes/ThreadGroup (groups) &gt; make simple parallelism tasks actually simple IMO they are simple :) Thread.new{ begin; async_yay!; rescue =&gt; e; puts e; end }.value
Is this clever satire? I hope it's clever satire.
Code is very ugly (no offense meant to the author, only to the java-ish looking code); try to improve it maybe by reading/using: * https://github.com/bbatsov/ruby-style-guide/blob/master/README.md * https://github.com/bbatsov/rubocop * http://apidock.com/ruby/ERB * http://www.sitepoint.com/value-objects-explained-with-ruby/ * http://blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html Also, it's not clear to me what it's for (maybe screen-shots of the results would help).
Great hint, thnx - Sometimes people have to use windows. We are likely not the choosen ones.
Double-plus. This is one very clean API - love all the CLI tools built in as well. Might have to dust off the old Arduino and have a play with this.
Colour me stupid, but I hadn't come across scrolls before either. Thanks for the clue up.
You know that "posting personal information on reddit" is like [the third listed thing you can't do](http://www.reddit.com/rules/) under any circumstances, right? I'd either delete this post (which isn't really anything to do with Ruby anyway) or enjoy your no-doubt-imminent shadowban. :-/
I guess it's apparent that my background is C/Java. Working on updating the styling a bit. I'll see if I can add screenshots to the Readme. Thanks!
WTF? I'm sure DHH can look after himself without the help of fan boys. This is a bit messed up man and, as Shaper_pmp says, you're setting yourself up for for a ban. 
Because I want to learn.
You could simply store all posts as a hash and serialize that hash to a file as JSON or YAML.
Very good: I prefer explicit parallelism than implicit, like celluloid. some suggestions: * thread class is good, except Exception : you should print/log exceptions in thread execution&lt;/li&gt; * manage the limit of thread count should be nice, * manage Queue for good communication between Threads. So perhaps a api for configuration of Eldritch will be nice. 
Closest thing of the to of my head would be rails for zombies but that's for Rails :(
You could store each post in multiple files, organized by date and title, and save the index to a file of it's own. that could scale pretty good.
I'm guessing you'll need to make your own custom models class (A replacement for ActiveRecord::Base) that knows how to handle save, create, etc. and instead of working with the database uses whatever flat-file method you want to try. I might start with directories being "tables", and files in that directory (named by id) being "rows", with the data stored in JSON if I were to do it. You can get more complex from there if needed.
No, not as the files grow larger. YAML / JSON etc take time to parse, and carry a large memory overhead. A better approach would be some sort of random access file containing sections which describe the length of the index block, a section containing the index records which provide the addresses within the file for the entries, and the entries themselves. This means there is no need to parse the entire data file - you use random file access and looking up records is done by: * accessing the index block and finding the entries you are interested in * reading these entries from the main body of the file. It requires more housekeeping but is much more efficient.
You mean something like... http://www.kidsruby.com/ ?
Wish one was my talk :(
Wait, I think this sounds too far ahead for me.
From the README it seems like this is more syntax sugar than a library that actually simplifies concurrency. I'll still have to deal with the things that actually make concurrency difficult such as race conditions, deadlocks, etc. Is that correct?
The simplification comes mostly from the together blocks. I explained this in detail in [this post](http://www.reddit.com/r/ruby/comments/245aap/eldritch_a_dsl_that_simplifies_parallelism/ch49p6u). Together blocks currently automatically join threads in said block and allow for single threads or groups of threads to be killed cleanly. It also allows a thread in a group to get a list of its peers. You still have to deal with race conditions and deadlocks. I wish I could make it so that no one has to deal with them, but I don't know if that's even possible. Our original goal for this project was to make tasks that should be simple in concurrent programming (ex: killing a bunch of threads) actually simple. We didn't aim to tackle to very complex stuff.
How about making your own blogging engine? Or a twitter clone? Or are you looking for things bigger then that?
I doubt the blog posts will be huge individually. Why not just have each post be a datetime-stamped flat file in some kind of folder. no need for an index that way either.
I'd take a skills based approach... what sorts of skills do you want to develop/ demonstrate? Security, data analysis and visualization, payment systems, etc. Find a project that requires you to do that, and then blog about the development process. Also, yeah make it either useful to you or make it fun--making software that's relevant, useful, and easy to use is hard to master. Or anyway that's how I pick my side projects. 
Twitter is really easy... there are several tutorials floating around that copy twitter, so you won't stand out with that. If you're going to clone something, pick something that won't make it look like you just followed a tutorial. How strong is your knowledge of object-oriented programming and OOP design patterns? If you don't have a rock solid handle on OOP, I think it's worth stepping back and writing, say, a command-line version of chess/checkers/fooGame to learn more about OOP and ruby the language sans rails. Rails is magical enough even when you have a good foundation in the language. Play around with metaprogramming.... it's the killer feature of ruby, in my opinion, especially when you are writing functions that take blocks.
Contribute to an open source project. 
Why Ruby specifically? I love Ruby, but if you're after instant gratification, javascript + canvas might be a better bet. Nothing to install, just open the dev panel on your browser. 
I'm not sure I understand your first suggestion. I do want to add message passing between threads. I also want to allow together blocks to use a thread pool instead of just creating threads. This would be configurable and optional.
It works for me (and it's the expected behaviour): http://pastie.org/9120814 
I agreed with you all the way up till metaprogramming. While it's a really powerful feature of Ruby, you have to dial back your enthusiasm for using it everywhere. Like, if I'm looking through a large codebase I'd damn well better be able to find where a method is defined by searching for it.
Hey :) I've only had a cursory look, and your code seem pretty solid. Short methods are always a good sign. A couple of things leaped out: Firstly, no tests. That's an alarm bell. Secondly, there's quite a few references to "http://a.4cdn.org" - I'd definitely make this a constant somewhere, as it could change. I'd probably also break out the classes into separate files, but other than that... no complaints :)
I agree that some people take it to an extreme and that you should watch how heavily you use metaprogramming. However, I disagree that you have be able to find a method via a simple text based search. In some cases, the benefits of the metaprogramming approach far outweigh the problems caused. If you are working with a library written in a language known for metaprogramming, you should be well aware of the fact that you may have a hard time finding where methods are defined until you understand the code.
and you don't end up with yet another blog engine.
Working with a library, it's fine. And Rails is well documented. If you're working with a project that's 70,000 LOC though, you really want to find that method and not be cursing the person that thought they were being clever. I don't think DRY is so important that you should make more work for the next person looking at your code, but if you can come up with a hypothetical where it's a better idea then I'll gladly change my mind :)
That too!
I'm not saying we need to sprinkle metaprogramming everywhere, just like we don't need anymore effing DSLs (please, no more!), but it is occasionally convenient. OP will have to understand it if he wants to get beyond a totally superficial understanding of what rails does for us.
http://ruby-doc.org/stdlib-1.9.2/libdoc/pstore/rdoc/PStore.html Pstore allows you to store a hash in a file. You could use this to store a blog. Just refer to things by the hash key.
Absolutely, but the context of this thread was 'getting a job'. Understand it, totally. But if the choice came when hiring I would not want the person using define_method everywhere in their code.
The Koans? http://rubykoans.com
Nice writeup. I especially like the use of `EmptyHashNode` which gets rid some conditionals. You didn't take care of colliding hashes, did you? It would be nice to mention them with a few words and maybe talk about how to implement it.
By 'colliding hashes', do you mean duplicate hash keys, or keys whose hash values are identical? If it's the latter, no, I didn't consider that. Thanks for the suggestion!
Noob here, what is metaprogramming within ruby? I've worked with Java and PL/SQL, never heard of the term. 
Try to develop an application that touches a lot of different bases. Testing (rspec, capybara, jasmine), user auth (with oauth), subscriptions, statistics/reporting, frontend framework (ember/angular/backbone), api (with versioning), background jobs, image processing, use vagrant/docker/chef, proper configuration management (secrets/figaro), capistrano w/ deployment tasks, bootstrap 3, sensible structure for your javascripts/coffeescript and css/sass, decorators/presenters, caching, development tools (rails best practices, pry/jazz_hands), etc. etc. This doesn't just server your resume, it challenges you to develop something with many moving parts.
Code that writes code. There's a good tutorial for it on [Rubymonk](https://rubymonk.com/learning/books/2-metaprogramming-ruby)
Same, works here. http://repl.it/SA5
Thanks for putting me on to `jazz_hands`! I had no idea the `pry` concept went so deep.
&gt; I was thinking you could download the JSON responses That's basically what you should do. You can make your life easier by using something like [vcr](https://github.com/vcr/vcr) to mock your http responses for your integration tests automatically. Speaking of integration tests: You should have only very few tests which actually hit the network. Everything else (like your parser or the code which generates statistics) should be testable without depending on the internet.
Just build something cool. It doesn't even need to be businessy. Just find something you are interested I and make cool shit. That's how you'll stand out.
Yes. She or he were just referencing the 1.9.2 docs. Here's a [link to 2.1.0](http://www.ruby-doc.org/stdlib-2.1.0/libdoc/pstore/rdoc/PStore.html)
Thank you.
Yeah change 1.9.2 to 2.1.0 pstore is in all of them. Great little tool.
Sorry but, where do you 'get' pstore? I don't see something exactly like it on ruby gems.
&gt; However, I disagree that you have be able to find a method via a simple text based search. I strongly disagree with you disagreeing. I recently wasted a lot of time, because someone on our team decided to DRY up code using meta programming. It was almost impossible to follow the control flow without raising exceptions in several places and looking at the stack trace. (Needless to say his DRYing up could've been easily done with sane OOP techniques.) A second point: Text based search is the **only** reliable tool you have in a language like Ruby to find methods. Working on such a low-level far away from the actual semantics of the program is bad enough. Don't make it even harder...
As an employer, I value open source contributions more than applications (though sideprojects are great too). If you can get some pull requests accepted on Rails or some gem, it demonstrates that you understand Ruby enough that someone else found your contribution useful. I found a couple of bugs in RABL (https://github.com/nesquena/rabl) yesterday, and it could be a good library to start on, as though it is still maintained, it doesn't seem to be under so active development, so it should be easy to find a couple of simple issues to solve.
I found http://www.codewars.com/ pretty nice. It's not very visual, but it's motivating, because you can gain experience points and level up.
The example I gave was poor and isn't a proper illustration of what I'm doing. What if the call to `hey_there` wasn't in another method but was just free in the class. Like: class Bar include Foo hey_there end
use `extend Foo` instead of `include Foo` if you want to use `hey_there` within class definition 
What enumerable_any said. VCR is great for this kind of thing. Just wanted to add that what you are reffering to is not a changing api, but a changing api response. The endpoint hasn't changed, just the data behind it.
Your API isn't changing; your data is. Encapsulate the API in a class, like 4chanapi or whatever. All it will be is a thin wrapper, putting parameters into the right spot for an API call. Tests for your 4chanapi are going to be a pain and will probably require something like VCR. Testings for your classes that use 4chanapi will mock out the 4chanapi class, and sub in a class that just returns the same data every time, and your tests don't ever have to change.
Thanks! I did some benchmarking in part 1, comparing Hash#has_key?, Array#include?, and the binary tree. The hash is around 15x faster than the tree, which is around 100x faster than the array (at least for that contrived example). I'm working on some rebalancing trees, which will be featured in part 3. http://zvkemp.github.io/blog/2014/04/25/binary-search-trees-in-ruby/
Mocks. Use WebMock or VCR.
Yeah, TDD is only about writing your tests first and then writing code that passes those tests. Writing integration and validation tests that your code should pass is great practice.
Thanks for your answer, I looked into VCR and I can definitely see it's useful. I updated my post with a question about binary files. How do I handle them?
I'm still pretty new to development (I do come from a web design/front end background), but was able to learn a good chunk of JavaScript and Ruby/Rails at the same time. I've been at it for about five months and was able to get a good grasp on NodeJS, Angular, jQuery, vanilla JS, Ruby, and Rails. I actually started with JavaScript and was excited to deploy Node applications using the MEAN stack...then I started fiddling with Ruby and fell in love...thus making me decide to learn both. I had a very basic background in development (took some CS and programming courses in college), but overall I found learning both to be a good experience. Concepts that were difficult for me to grasp in a JS made sense when I looked at them in Ruby, and vice versa. If I had to choose one, I'd personally choose Ruby to focus on, learn the basics of Sinatra, and then get into Rails. It definitely depends on what kind of project you want to be able to develop.
Ohh, well that would explain why I cannot find it. Thank you.
Unit tests should not use live data. In fact I suspect that *no* tests except final, end-to-end integration tests should use live data.
I've started teaching myself to program last year and went through a range of languages before settling on Ruby and Java. The most important advice I was given in selecting a language to learn was to "learn the language you have the best resources for". If you have a lot of helpful JavaScript people in your environment, learn JavaScript, if you have a lot of Perl people...well, maybe not Perl. I've settled on working with Ruby because of the incredibly helpful community based around it and the resources they've made available over the web. I would have a bit of a play with an introductory tutorial for Ruby to see if you like it, then try asking a few questions on Twitter and see how responsive you find the Ruby community. If you're a lady, I highly recommend looking into Rails Girls workshops, as they're a great, free way to get into working with the language.
I am reading through someone's blog post on `self.included` right now. Don't know how I missed it in the past. Thanks a million dude!
Isn't this what Twitter "lists" are supposed to achieve?
Excellent! Glad to hear from an employer! I'll definitely be sure to check out that repo.
Well congrats! Thanks for the ideas there.
Been programming via OOP for about 4 years and I just took a class on design patterns. I'm currently working on a command-line utility that is based on ruby. Cloning Twitter via Rails isn't a bad idea either! I'll definitely have to look into metaprogramming though. Thanks!
Thanks for spelling out the base of the application I should really invest in (though it is most of them). I'll definitely keep those goals in mind. 
Awesome. I'll definitely try to think more in that direction. 
Sounds awesome
No, but some people do, and it would be nice to not have to click 40 links to follow the whole list. I'm just saying.
1. I see tests as managing risk when performing changes and so it's not clear to me you're doing much of any value if your tests aren't focussed around business/user cases first and foremost (aka integration tests). 2. All of my testing pain comes from bootstrapping data to my models so I can write meaningful tests. What do people use to make this less painful? Neither fixtures nor factory girl seem like super great solutions.
Threads + Resolv http://stackoverflow.com/questions/4614032/how-do-i-fetch-a-sites-ip-in-rails
Since you are using Git Bash, I'm assuming you are trying to develop Ruby on Rails on Windows. I'm sorry to disappoint you, but if that's what you want to do, you are going to have a really hard time, as Ruby support for the OS is just terrible. I personally develop Ruby on Rails on my Windows laptop, and I use git bash, for that matter. But I run my development environment on a Virtual Machine. I suggest you to take a look at http://www.vagrantup.com . It provides tools to create, run and destroy virtual machines, so it's dead simple get a Linux VM up and running for Rails development. If you have any doubts, I would gladly help you. I spent a lot of time working on all kinds of alternatives. 
Is it? I've used my twitter account for probably 4-5 years now and still don't really know the use case for lists. 
I'm the same and I've still never used lists, but I guess this is the reason they built it
I've found having a good integration test suite to be quite helpful. Simple changes in the view though &amp; breaking tests is another burden that can be annoying, but in many ways I think it's a good tradeoff. I still do test controllers, but only in certain cases. For testing APIs, i'll use controller tests. Testing more intricate functions that dont get hit as easily when testing integration. Though the latter I'm trying to step more away from. Either way, I always use the DB with controller tests. Only thing I stub out is 3rd party requests, and queuing jobs to sidekiq/delayed job.
Oh wow, that's really clever! 
You can use the ruby-ares-davidbalbert gem: https://github.com/davidbalbert/ruby-cares-davidbalbert This is an extension which wraps the C-Ares asynchronous DNS library. Or you can use the builtin Resolv library, which is blocking. Just use multiple threads to increase your concurrency.
Another reasonable option is to just download Virtual Box and use an Ubuntu/Xubuntu/Debian VM.
Actually i found a gem em-udns, it's pretty fast but it's missing querying cname function. So far this is the best i have seen + its based on eventmachine. Another gem is rubydns, but is slightly complicated than the above one. For rubydns I dunno why but the example given by author doesn't work for me. 
&gt; All of my testing pain comes from bootstrapping data to my models so I can write meaningful tests. What do people use to make this less painful? Neither fixtures nor factory girl seem like super great solutions. I assume you're talking about UI tests\* since you shouldn't need to setup several models for anything else. Have you tried not using any data setup and solely interacting through the UI? So in order to check if your Todo list is properly displayed, you create a Todo through the form first. \* Just in case you don't: Post an example?
I love how he's trying to squeeze everything into MVC and even suggests system-test heavy test suites for complex UI logic. I don't want to be near such a project, trying to cover UI logic through system-tests is insane. Just use presenters or page objects and unit test them if you want to have some decent test coverage. I also don't get why he seems to be so afraid of software design/architecture. MVC is hardly a software architecture and everyone trying to realize a large project based on it has probably noticed its flaws at one point or another.
&gt; While you're watching the presentation, listen to the justifications for the design. They're all about testing! Jim Weirich might have only mentioned testing benefits, but there are definitely more. A domain specific database layer (with methods like `count_posts_for_user`) alone has several advantages: * The methods tell you exactly what kind of data your application needs, so deciding on the correct database to use becomes easier. * Want to add a redis-based caching layer to some of your queries? That database gateway is the perfect place and it's all neatly hidden from the application. [1] * PostgreSQL finally has feature X which makes it the perfect candidate for your app? Swap out `MongoDBGateway.new` with `PostgreSQLGateway.new` and be done with it. [1] [1] No matter what database gateway you choose, you can always reuse the same tests for it.
Python devs are too busy getting shit done to write 2-3 meaningless blog posts a day.
I'm not sure if you are aware of it, but Rails has **nothing** to do with MVC pattern (asides from stealing some names). It does not even adhere to the *Separation of Concerns* principle. 
&gt; I have lost incredible amounts of time fighting the tools for populating this data in my test database. ..for system tests, or unit tests? any single "unit" being unit tested should in theory have 1 or 2 collaborators. you aren't working on the "test data" level, you're working at the "class interface" level.
&gt; but Rails has nothing to do with MVC pattern I think *nothing* is a big stretch. The only real difference I currently recognize is that the model doesn't update the view automatically. In UIs this is usually done using the observer pattern. Other than that: Looks pretty close to me. &gt; It does not even adhere to the Separation of Concerns principle. How does it not?
He's parodying this from /r/Python: http://www.reddit.com/r/Python/comments/24a4r0/it_could_be_personal_selection_bias_but_i_dont/ (It also occurred to me I may be one of the select few who subscribes to both subs and enjoys both languages about equally.)
Usually system level but either way - a unit test of the report system would need to have data to generate reports from.
I bet you could come up with a clever way to create multiple decorations
Let's see: - rails "models" (also know as [active record](http://martinfowler.com/eaaCatalog/activeRecord.html)) are combination of domain an persistence logic. Unfortunately, this also means that said "models" have no place for application logic. Which results in service layer being merged into "controllers". - rails "views" are dumb templates, instead of instance, that handle UI logic. In order to compensate for this, the UI logic gets merged into "controllers". - rails "controllers" are, instead of simply being responsible for altering state of model layer (which rails doesn't have, just a collection of ARs), contains both application logic (handling multiple domain logic containing instance and persistence) and UI logic (deciding what data is require from "models" and assigning it to various templates) So basically you end up with CRUD + templates + logic. And yes, you are kinda correct about web applications not (usually) using observer pattern. The classical MVC is not really suited for web. But people pre-Rails came up with various patterns, which were better suited for web: Model2MVC, MVP, MVVM and PAC(which is SoC implementation that is unrelated to MVC pattern) would be the major examples. Rails applies none of them. ... now, bring on the downvotes for my blasphemy.
... is it sad that I was really upset that this wasn't an app that puts a porn star mustache over any picture?
Same here, I was really confused.
DHH has *always* basically been saying &gt; Basecamp is *just like* essentially all the apps out there, and we extracted Rails from Basecamp and then built a few other, relatively low-traffic apps from Rails, so you should be able to make *any app worth writing* work with Rails out of the box. If you can't, you're probably a limp-wristed test-first-and-always Clean Architecture acolyte who needs a different line of work. Quality is for morons. Anybody with significant agile experience should have figured that out in about the first 30 seconds of being used by the original `Test::Unit`, let alone pronouncements since. I've been saying for 25 years that when I started developing software for money way back in 1979 (after growing up in a family of engineers and medical professionals), I thought that we were about 30 years away from a true profession of software engineering (at the time). I attributed the lack of progress to what I called "The Microsoft Effect": ship crap, and by the time your customers/victims *realise* it's crap, ship new, flashier crap that your house organs (*PC Week* et al back in the day) praised to the skies. DHH and the mentality expressed in his post are worthy successors to Microsoft with regard to the resistance to if not degradation of professionalism. But before you say, "Hang on, it's just *Rails*", think how influential he, through Rails, has been *outside* the Rails community itself; how many large orgs are building mission-critical Rails apps; and how much time and energy is *wasted* hitting and reinventing workarounds to the walls the professional OO development community solved 30+ years ago. Hell, even [the Apollo Program practiced TDD](http://www.confreaks.com/videos/3287-mwrc-software-development-lessons-from-the-apollo-program). What, ego aside, has DHH ever blasted out of this world?
You are not alone, friend. 
Isn't that the point of ORMs like ActiveRecord, though?
What is this? I only see a signup page and I don't want to sign up.
https://github.com/kstephens/cheap_advice
Right - user-experience fell at the first hurdle.
I understand your frustration of not being able to use the app, but it literally says what it is right above the sign up form.
&gt; Such damage is defined as changes to your code that either facilitates a) easier test-first, b) speedy tests, or c) unit tests, but does so by harming the clarity of the code... Seeing exactly this on a large project I was just brought on to. The manager and the team (somewhat) are big fans of "Uncle Bob".
**Practical Object-Oriented Design in Ruby: An Agile Primer (Addison-Wesley Professional Ruby Series)** www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=sr_1_6?ie=UTF8&amp;qid=1398842637&amp;sr=8-6&amp;keywords=ruby#reader_0321721330 **Eloquent Ruby** http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104/ref=sr_1_9?ie=UTF8&amp;qid=1398842637&amp;sr=8-9&amp;keywords=ruby **Metaprogramming Ruby: Program Like the Ruby Pros** http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476/ref=pd_rhf_se_s_cp_6_BXWQ?ie=UTF8&amp;refRID=02JTWKY2ZDHPVZWX181R
Ha. Ha. He said *"spank bank"**. 
http://www.amazon.co.uk/Design-Patterns-Ruby-Addison-Wesley-Professional/dp/0321490452
Thank you abashinyan.... Are there any free ebooks abailable?
I didn't find the `params` hash hard to understand, but struggled with other parts of the request-response-cycle: render :new # does this call the new method? redirect_to new_user_path # does this call the new method and returns the results to the user??? Nope to both of them. They're just constructing HTTP responses. It would've been much easier with something like this: def create(request) user = User.new(request.params[:user]) if user.save Response.new(:redirect, users_path) else Response.new(:bad_request, render(:new, user: user)) end end HTTP is just a simple request-in, response-out protocol which would map nicely to a method's parameters and return values.
This looks like an easy attempt at getting email/password combinations for free. Don't use your regular passwords, if you have one.
awesome. also, didn't know that def had that new behaviour in 2.1, nice.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Design Patterns**](https://en.wikipedia.org/wiki/Design%20Patterns): [](#sfw) --- &gt;___Design Patterns: Elements of Reusable Object-Oriented Software___ is a [software engineering](https://en.wikipedia.org/wiki/Software_engineering) book describing recurring solutions to common problems in software design. The book's authors are [Erich Gamma](https://en.wikipedia.org/wiki/Erich_Gamma), [Richard Helm](https://en.wikipedia.org/wiki/Richard_Helm), [Ralph Johnson](https://en.wikipedia.org/wiki/Ralph_Johnson_(computer_scientist\)) and [John Vlissides](https://en.wikipedia.org/wiki/John_Vlissides) with a foreword by [Grady Booch](https://en.wikipedia.org/wiki/Grady_Booch). The book is divided into two parts, with the first two chapters exploring the capabilities and pitfalls of object-oriented programming, and the remaining chapters describing 23 classic [software design patterns](https://en.wikipedia.org/wiki/Design_pattern_(computer_science\)). The book includes examples in [C++](https://en.wikipedia.org/wiki/C%2B%2B) and [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk). &gt;==== &gt;[**Image**](https://i.imgur.com/HgJOXAw.jpg) [^(i)](https://en.wikipedia.org/wiki/File:Design_Patterns_cover.jpg) --- ^Interesting: [^Design ^pattern](https://en.wikipedia.org/wiki/Design_pattern) ^| [^Software ^design ^pattern](https://en.wikipedia.org/wiki/Software_design_pattern) ^| [^Pipeline ^\(software)](https://en.wikipedia.org/wiki/Pipeline_\(software\)) ^| [^Pattern ^\(architecture)](https://en.wikipedia.org/wiki/Pattern_\(architecture\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch5v20g) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch5v20g)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thank you.
Thank you vanakenm.
I thought it was gonna put a mustache on porn images / gifs / videos.
Oh wow I just got it, he meant "stash". Not "stache".
How about some error messaging? I see you won't let me submit empty forms or invalid input ... that's good. But remember that your user is more important than anything ... if you don't tell them why you're not accepting their input they will get frustrated. Even in a simple form where the "right" way to fill it out should be obvious ... always inform the user. Another criticism ... you seem to have 1-form-per-model. This makes getting new collections and lists tedious. I should be able to create a collection, a bunch of lists ... even add links from a single form. (Look at *delegate* and *accepts_nested_attributes_for* Your URL shortener doesn't resolve to the original url if you copy/paste it into the address bar of the browser. Also, using sequential IDs as part of the shortened URL is not a good idea ... should be a random unique string. I currently know exactly how many urls you have in your database, and I can go ahead and walk through other people's links (assuming the above problem with the url shortener not working didn't exist). It'd also be nice if you showed the original URL ... once I've entered a link, you turn it into a shortened url, and I have no idea what the original link was, unless I used very good tags. Your application is not deep-linkable. I can't keep a bookmark to my favorite list because putting http://www.pornstache.me/collections/70[1] in my address bar results in an error page. Your ajax requests return bits of executable javascript doing DOM replacement. This was the way it was done not too long ago (or at least a way recommended in some tutorials), but It'd be a lot better if you had your AJAX requests return JSON and have all of your front-end application logic centralized ... maybe even use a framework. This application is small, but once an application becomes "large" trying to maintain all of those little snippets of javascript in hundreds of views will become a nightmare. You expose actual database IDs all over the application. This can be a security issue. Instead of using your PKs as object identifiers out in "user space" you should have a "unique identifier" (UID) for every object that you can expose to the public. Prevents people from just walking records. If you've got a security bug, an attacker could very easily start accessing other people's data by naively guessing URLs. Also, exposing ID's gives an indication of how much data you have stored ... and even the depth of your user base. This is proprietary information you should seek to conceal.
Email address is optional.
Thank you so much for the advice, I will get on trying to implement these things. I did most of it following lots of tutorials and basically just trying to figure it out. Thank you! Also, I have not yet implemented the URL shortener so those are basically just printing the ID to make it look a bit better and not have a huge crazy switch from being long URLs to shortened ones later as far as what users can see. I will also be implementing a pastebin style share links later. My first time with Ajax and rails I am planning on hashing the URL for link-ability soon. I will take all of those security concerns very seriously and work on, working them out. Thank you again! Also the opposite of what I want to do is actually collect any data, I hope people use completely anonymous names with completely different passwords than anything else they use. I want them to be able to just log in from any where and have their collections available. The next step is giving the user the ability to make their collections 'public', there will be a Public Stache section where it will pull in all public collections for people to check out, vote and comment on. Sort of like reddit.
Play on words
Plant Trees!
Personally, I was going to leave email out all together but I thought how terrible would it be if you lost all your favorite porn because you forgot your password? Its completely optional and all passwords are hashed/salted I used devise.
Speaking of passwords... I assume you are hashing them? Also, are you using an authentication gem like AuthLogic or Devise? Or did you roll your own? 
That clearly didn't work out well for you. Everybody misunderstood.
Sometimes trying to be clever will do that. Sorry you didn't like it.
I think the point was that users should be able to immediately start using the site without signing up. Then after they use it for a bit you can show a link like "create an account and save this forever!"
I agree with you on the other parts of the response cycle, I like your explicit Response.new syntax as well. I think understand the concepts of the responce do format.html stuff, but I don't the syntax. I manage to get by somehow with it.
Oh I see, Thanks for the suggestion.
What's wrong with `Test::Unit`? Also, I don't think DHH has been saying what you think he's been saying.
I'll second the Gang of Four recommendation. No, it doesn't have any Ruby examples, but the writing is very clear in explaining when and how to use the patterns it describes.
Nope, not the only one . [(I'd even commented)](http://www.quickmeme.com/img/2e/2ef0515a073435e1ff323586ab5b2cbd1c121c754c0057361d0d46984d86eb87.jpg)
It's actually a [HashWithIndifferentAccess](http://apidock.com/rails/ActiveSupport/HashWithIndifferentAccess), but I won't fret :)
I highly highly recommend the Russ Olsen book (first on this list). He's a great writer so it's a quick read, and it really improved my code a lot.
Russ Olsen wrote Eloquent Ruby, which is second on the list. Sandi Metz wrote the first.
i use jQuery for interacting with the dom, and javascript for handling the logic behind that interaction...i guess? If you coffeescript then it is basically ruby
I mispoke (somebody else in thread linked it), but Russ Olsen most definitely wrote a great book on patterns. http://www.amazon.co.uk/Design-Patterns-Ruby-Addison-Wesley-Professional/dp/0321490452
I do too!
Thanks agency95. And how did you manage to study both javaScript and Ruby/Rails at the same time? Thanks
So, on top of the previously recommended (and excellent) PODIR, GoF Book, Metaprogramming Ruby, and PEAA I'd like to recommend: **Confident Ruby** http://www.confidentruby.com/ **Ruby Science** https://learn.thoughtbot.com/products/13-ruby-science I haven't actually read Eloquent Ruby, but I've heard good things about it.
I actually suggest the Head First design patterns more often than Gang of Four. It's much more approachable. 
Refactoring to patterns by Joshua kerievsky
Well… let me see if we can get on the same page, because I'm not sure I understand where you're coming from. Given some options, my reporting class just exercises scopes on AR models and some non sql sorting and grouping. I can test: 1. whether the Report class properly sets the flags and options, but that's kind of useless to me, because without data it's mostly trivial code. 2. the scopes on the AR class it is associated with, but that is of little comfort to me because changes in their functionality down the road won't alert me to breaking behaviour in my reports. So, what keeps me up at night is whether the Report assembles the right kind of output. i.e. given these opts, the rows being returned should roughly fit these constraints. It seems to me that the "best" way to reduce uncertainty in the face of new features would be to say, "given this data, the report should output exactly this other data", upon which I might as well be using a privacy scrubbed subset of production data. How else can I say "this report is behaving as intended"?
Congratulation in your success. I like the boot-camp philosophy of learning 5+ hours a day. Thanks for you response and your time posting so good information.. For TDD, I believe Michael Hart book and Ryan Bigg "Rails in Action 4" are good books: http://www.railstutorial.org/book You can check this websites too: http://railsapps.github.io/best-recommended-learning-rails-books-resources.html http://blog.xdite.net/posts/2013/01/30/2013-reading-list/ 
&gt;I don't setup any test data, I simply interact with the UI. Yeah! but you still have to fill the UI with something. My forms have complex validations and associations and keeping track of that manually inside my tests is a non starter :). In order to create a ScheduledItem I need a SchedulableUser and a Document and a Date and so on. ON AN UNRELATED NOTE, &gt; expect(page).to have_content "Clean kitchen" What is rspec's deal, man? In whose universe does that dsl look like any other code they write on a daily basis? We have an assertion on page that establishes an equality between the output of a method send and a received string. I still think assert(page.content, "Clean kitchen") or maaaaybe page.content.should :==, "Clean Kitchen" feels easier to comprehend.
My excuse is that in past 2 days I had to interview 3 potential candidates. It tends to leave some impact on ones expectations.
Yarrrrr!
&gt; an instance variable on the Wombat class object Well, whoever does this shouldn't earn money programming. Of course all hell will break loose if you store state on global constants.
i like this Ruby User’s Guide
Please source your claims of what DHH has said. 
Fucking moron, i think you missed the most important one? http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452
I must be the only person who didn't really like POODR, it was ok but it's very much a beginners book.
I was betting a lot of rails programmers looked at the salary graph and thought, "damn, I need to start looking for a better paying job."
Yeah, but still, memoization is an over used technique in the ruby community, based on the codebases I've had the (mis)pleasure of working with in the last few years.
I have seriously seen this: class DoNotDoThis def huh? @some_method ||= some_object.present? end def some_object @some_object ||= more_memoization end end Seriously? Did we *need* to memoize whether an object exists or not? WTF?
I was asked to do something like this as an interview question. I never actually wrote a blog post but my code is on github: https://github.com/mweppler/simple-blog
Would this have the problem, which other people have mentioned, of getting slower as the total number of posts grows?
I have over 5k karma on reddit. does that count for anything??
this is the followup for this post: http://www.reddit.com/r/ruby/comments/23vhe9/10_free_ways_of_learning_ruby/ I've still got Ruby on Rails books coming up, keep an eye out for them!
I keep hoping my nearly 6 years &amp; 10k+ karma will do *something* for me.... I think I am going to be waiting a bit longer....
The syntax highlighter has limitations. It cannot distinguish between `puts(&lt;&lt;PARAGRAPH)` and `puts &lt;&lt; PARAGRAPH`. You should write `puts &lt;&lt;-PARAGRAPH` or `x = &lt;&lt;PARAGRAPH`. From Ruby.tmLanguage file: symptoms: not recognized as a heredoc solution: there is no way to distinguish perfectly between the &amp;lt;&amp;lt; operator and the start of a heredoc. Currently, we require assignment to recognize a heredoc. More refinement is possible. • Heredocs with indented terminators (&amp;lt;&amp;lt;-) are always distinguishable, however. • Nested heredocs are not really supportable at present
Thanks! I didn't know `puts &lt;&lt;-PARAGRAPH` works! 
holy shit, just shy of a 100k for 0-1 years experience? i need to move.
Even more interesting is their supply vs. demand graphs for NYC: https://hired.com/blog/nyc-tech-landscape/
What amazes me is how well paid the US appears to be. In London (UK) Junior positions are averaging perhaps £30K ($50K USD) and mid-weight positions @£45K ($75USD) and we have higher taxes and cost of living! I'd move in a heartbeat.
From the controller you can also do this sort of thing: class HomeController &lt; ApplicationController def index render locals: { test_var: "hi!" } end end 
Everyone that i work with has a degree (not always in computer science, but mostly in a scientific field, which is close enough)
Check out www.practicingruby.com 
You are correct. We (as in my co-workers and I) spoke with Hired at the most recent Railsconf and they primarily placed for companies in SF &amp; NYC.
&gt; even with obamacare I'll go out on a limb and say *because* of the ACA. Insurance premiums were going up at several times inflation for many years preceding the law's passage, but they've gone up double-digit percentages since. The insurance at my last job cost me $1000/mo for a high-deductible family plan. As bad as that was, the exchange showed that comparable plans through healthcare.gov were going to run me from $1400 to $1600/mo. Now, you can say I'm an outlier because I'm a well-paid programmer, and that's fine, but that's sort of what this thread is all about.
It's just one metric that many decent companies only take with a grain of salt. You have to view it like a degree in many cases. It's nice to have but it's not the magic bullet that will get you a job.
Try [Metaprogramming Ruby](http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros-ebook/dp/B00A376YAK/). It's on the farther end of the "intermediate" scale, but it's great. From the sounds of it, it may stretch you, but it's worth it.
Computer science degrees aren't all that useful to a career in programming, either. I got a compsci degree from a decent college and I didn't come out of it knowing that much more than i did going in. If anything a degree (in any field) just gives you some time management skills and teaches you how to take something through to completion.
Destroy all software has been really helpful for me. I also just recently started reading crafting rails applications and it's super good so far.
Im also curious if my github account at my current employer counts. Its privately hosted and they own the code, but I wrote it!
In the same window, you mean ? If so, try using rails server &amp; to launch the server as a background task, keeping control on the shell. (just type enter to see your command line)
yeah, this is my intuition on it. though i'm still waiting to get a good explanation of it as a code smell and an alternate pattern recommendation. :x
Often times I refactor it away by separating the code that goes out and grabs all that data that's being memoized into some kind of factory object. That way, the consuming code asks the factory to go off on its' mission and come back with a data object that I can then pass around.
[Ruby Tapas](http://www.rubytapas.com/) by Avdi Grimm are tasty. [Ruby Under a Microscope](http://patshaughnessy.net/ruby-under-a-microscope) has been insightful. [Ruby Koans](http://rubykoans.com/) have taken me on a lovely journey deep into Ruby. There are others people have mentioned in the thread that are good as well but even just these give you a LOT of material.
Ruby Monk www.rubymonk.com
I don't see him saying what you claim. The only thing I see him claiming that I disagree with is that testing first is bad. However, I disagree with the likes of bob Martin just as much when they say testing first is the only right way. 
I know Ruby Weekly newsletter www.rubyweekly.com 
Knowing the answers to these questions in no way demonstrates the candidate can write good code. I know a number of rails developers who have all this knowledge but still churn out unreadable 50 line methods, overcomplicated controllers with a mess of `before_filter` spaghetti, and lack a basic knowledge of good OO design principles. Rather than looking for expert rails knowledge i would focus on developers with great OO design flair with an efficient work flow. Give them something to refactor and see how they fare. Any monkey can learn rails, but having a decent eye for designing a clean OO architecture is a whole other skill that's far more important. 
Yeah that struck me as... ridiculous. Does anyone here fall into that range of 0-1 years experience? How much are you making?
A job? 
Employee, spouse, and kids. No plan I've ever seen makes a distinction on NUMBER of kids. I've seen increases at some places, and not others, but they've all increased. Some employers choose to absorb those increases. 
It's called a Jr level position. I'm a Jr Sysadmin and I'm getting paid to learn Ruby and other sysadmin stuff. Finding them is the tricky part. 
What would 'basic skills' mean? You are an experienced developer but didn't work with Ruby before or you have no idea about professional software development at all?
In euros?
I split each week between SF and the real world. The SF equivalent to my $750/month "flyover" apt would be over $5k per month including the outdoor space. As it is, finding a reasonable studio for under $2k was tough. I go out a lot because my SF apt is less than 100 sq ft. Dinner, drinks, parking, etc. All about 2x cost in SF. It *can* be done for less but at the moment it costs me $138k/year to maintain the standard of living I had in college; Ramen noodles, Natty Ice and going out every night.
Almost every job I've ever had has been willing to pay me to pick up new skills as needed, and not just junior ones either. When I first learned ruby, I had initially joined the team as a senior developer, maintaining legacy stuff in other languages. Once the legacy stuff was solid, they invited me to learn ruby, paid for books and conferences, and eventually made me lead on several core apps in ruby.
I'd say it's filtering bias. * r/ruby: 22,071 subscribers * r/python: 70,513 subscribers That's a **320%** difference in size.
It's a code smell if what you're trying to memoize can change. `@cache ||= rand()` is bad, `@cache ||= 2 + 2` is good. If you have good reason to believe your objects will only live for a short time (you instantiate new objects for every request, for example) you might get away with it.
Hmmm...I work in the Bay Area, and I have experience with ruby (on rails) and AngularJS, but I have less than a years experience with both of them, so I make 55k. I wonder around what time I can start asking for my six figures. 
It says right there that ruby is 2/3 as popular in non-Bay.
I would posit your cs program was not as good as you think it was.
Before you do, realize how much of that is evaporated by rent and taxes.
Yes, but unfortunately for you I have already been filling the position for the past 3 years.
I should have said 'not that useful to a career in web development' :) If i wanted to go into computer graphics or OS programming it would have been more useful :)
As someone with 7 years... the only things you're going to get are people being amazed you haven't switched usernames a dozen times.
&lt;sob&gt;...wait, maybe that is just you and the way you render....
http://www.leandog.com/
THANK YOU. I find it borderline crass that companies (and the community) are requiring involvement in Github and StackOverflow as an indicator of a ruby devs abilities. Absolutely ludicrous; double or nothing there are many more talented RoR devs who see no value in pursuing those avenues. Git is handy for version control, otherwise, GitHub is another gimmicky dev community. 
&gt; This is a denial-of-service (DOS) attack vulnerability. Since symbols can never be garbage collected Not the case with 2.1 anymore, symbols can now be gc'd. There was a problem with strings too, eg if you use if params[:foo] == "bar" you're wasting a space allocated for "bar" string each time this code is being run. Extract this into a variable and .freeze
You're absolutely right. Rails doesn't insist on using OOP, though it should have done so. People learn how to write a blog, then TDD, get familiar with tons of (mostly poorly written) libraries, and they never tend to learn Ruby itself. Ruby is far from being simple if you deep dive. It's quite hard to understand what a non-Rails application code does for an average Rails developer. Dzen doesn't come with a single app written.
very often i have seen memoization used for storing queries, which makes no sense to me given rails already does this. (using ruby in rails at least.)
One of the most valuable things to learn is object oriented design. Read the book Practical Object Oriented Design in Ruby. Make your code easy to maintain. 
I think you accidentally the code.
&gt; As with any technology, there’s knowing Rails and then there’s really knowing Rails. In our search for true masters of the language I am glad they are searching for the true masters of the rails language; these guys obviously know what they are talking about.
Build one or two significant rails projects, polish/test/refactor them nicely, and then apply like crazy. Like 200 applications. I don't know what your actual skill level is, but the better 3-month rails bootcamps in SF have placed many people without any prior dev experience with a quality ~100 hour final project that demonstrates their competence in basic development tasks. That's enough to get hired in the tech hubs (SF/NY/TX), at least.
/r/rails
I'd start with [webmock](https://github.com/bblimke/webmock). It's the most straightforward tool. It's also not as "slick" as something like VCR, in the sense that you'll be doing a lot of work by hand. But I'd recommend you start out with something explicit until you know exactly what's going on.
More specifically, using webmock: 1) Make sure to initialize it in spec_helper.rb # Include it require 'webmock/rspec' # Make sure any external API call fails with error unless it's been stubbed WebMock.disable_net_connect!(allow_localhost: true) # If you want to stub a commonly used API throughout your tests, do it here: RSpec.configure do |config| config.before(:each) do stub_request(:get, /maps.googleapis.com/). with(headers: {'Accept'=&gt;'*/*', 'User-Agent'=&gt;'Ruby'}). to_return(status: 200, body: "{}", headers: {}) end end 2) Use your stubs as the webmock guide shows within your individual tests
Rack::Test does its job. Check out [this](https://github.com/scottbarstow/ruby-bandwidth) as an example.
I don't get all these command line wrappers. Why would I want to use `:Git status` when I just as easily could use `:!git status` and reuse my local aliases?
I pretty much stopped using NERDTree when I picked up [ctrlp](https://github.com/kien/ctrlp.vim).
Man, just make one and slap your dotfiles up there or something. In this day and age it's hard to even be a hobbyist programmer without at least some piece of code that others can benefit from.
I have two years working experience and I'm earning £27k ($45k) here in the UK, and I'm a lead dev. 
Some people want to turn vim into emacs. It's insane.
If I had to pick just one of thse, I think it would be the vim-rails plugin, primarily because of the fantastic navigation commands (:Emodel user, :Econtroller admin/users, etc) and the ability to add custom ones via 'projections'.
Agreed; though the main function of fugitive that I use all the time is :Gw to write the file and add changes to git index.
I agree with this for many commands, and tend to just run git in a separate tmux pane. However, fugitive.vim does have some really convenient features like Gmove, Gblame, Gdiff. The former is nice because it moves the file and updates the buffer to the new location, and the other two are just more useful in the context editing a file than as terminal output. I also use eunuch.vim for reasons similar to Gmove. **Edit:** vim-bundler seems particularly unnecessary
I'm making similar calls for my app. I'm using VCR to test them as it seemed the most reliable and simplest of the options. Though it does have some problems with selenium + capybara JS testing...
I actually just did this recently (mock github API responses). I'd also start with webmock and disable all external requests via your spec_helper (assuming you're using rspec). Then run your tests without mocks to see what webmock complains about... it will pretty much give you the code to mock the object. The only complicated part, is you'll have to provide the response body that whatever you're testing will need. If it's simple hashes, you can just fake it, but if it's more complex (for instance you need to call .map on the response object), and you need the response to be attributes of some object, I'd go with using OpenStruct's to build out response objects. (And you can actually use factory girl objects backed by OpenStructs to really clean up your code).
do you know of any goo tutorials for ctrip? I have it installed be don't know how to use it. I was originally going to use it with sublime.
If you don't want to install ruby on your machine to do this, then install VirtualBox with a Windows Guest. Install ruby and compile the application. Once done, delete the VM and uninstall VirtualBox. Probably the most unobtrusive way to do this.
You already have the python one so why add a post for this? [can someone compile a python script](http://www.reddit.com/r/Python/comments/24jwgb/can_someone_compile_a_python_script_into_a/) Also, just installing ruby would have been quicker than making two posts.
Can't say that I do. I'm probably not what you would call a power user of it. Pretty much what I do is just hit "Ctrl P" and start typing the file I want. The github page I linked has a basic usage section. I can't say that I really use it for more than what's there. Maybe someone else here could point you in the right direction?
Is there a reason why you can't just install ruby on your windows machine? A little [help page](https://www.ruby-lang.org/en/installation/) to get you started with that.
I also like fugitive but I only really use Gblame and Gdiff. I find Gdiff to be nicer than `add -p`. I like having the staged and unstaged in a vimdiff.
This post doesn't do justice to the plugins listed. For example, one thing I use a lot from the Rails plugin is `gf`. It finds the file related to the section of code you're currently on. So, model relationships will open the related model, controller methods open the related view, etc. https://github.com/tpope/vim-rails/blob/master/doc/rails.txt#L121
Disappointed not to see Syntastic and Neocomplete/Neosnippets in there. 
Pfft nerdtree... How does one live in vimland without Ctrl+P? Also: map &lt;C-\&gt; :tab split&lt;CR&gt;:exec("tag ".expand("&lt;cword&gt;"))&lt;CR&gt; Ctags are so good. Not technically a plugin though.
Or just use a real IDE [RubyMine](http://www.jetbrains.com/ruby/) because it does all of these things better than VIM ever could, and also has a VIM plugin [IdeaVIM](https://github.com/JetBrains/ideavim) that supports most of the useful shortcuts. RubyMine handles symbol indexing, refactoring, static analysis, and everything you can imagine a million times better because it was built to do it from the ground up. VIM is just a text editor that has been modified to support your language. The productivity boost you gain from a real, functional IDE is immeasurable. It supports every piece of functionality outlined in that blog post natively and has it's own plugin ecosystem as well. Whatever floats your boat I guess, if you enjoy 20+ year old text editors, power to you. For the record, VI is awesome when SSH'ing, and I use the motion keys and shortcuts extensively. I used VIM exclusively for over a year before switching to RubyMine. [janus](https://github.com/carlhuda/janus) was a good starter plugin suite.
You hit Ctrl-P and then you start typing fragments of the filename you want.
Pickaxe http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0 is still the definitive guide. 
Not quite. Going from VIM to RubyMine, you lose hardly any functionality. Going from RubyMine to VIM, you lose a ton of functionality. Even the functionality that VIM tries to implement works poorly if at all (easytags anyone?). VIM is good because of it's shortcuts and motion keys, RubyMine is good because of everything else. Which functionality do you think is easier to implement? RubyMine has near flawless symbol indexing. I can type any method, module, or class name (even partially) and it will find it. I can navigate to any symbol in my code or a gem with a single keystroke or mouseclick. I even get autocompletion of method names and variables along with intellisense for function arguments; for both my code and the standard library or gems. I can view signatures, documentation (internal and external), and source code for any method with a single keystroke as well. You don't see a productivity boost with that? Can VIM even get close to that?
That or just ctrl-z and put the vim session in the background.... run your git command then "fg" to come back into vim.
The big draw to vim &amp; emacs is the ability to make the editor do what you want. IDE's do a lot for you but you are generally forced down very specific paths and you're going to be using the mouse quite a bit more. Those who really dig into vim &amp; emacs are typically very heady with keyboard usage. But like you said... it's whatever floats you boat &amp; allows you to be productive on a personal editor. 
RubyMine is pretty nice and I have it for when I want to do debugging but for my normal workflow a tmux session with my window split with vim top left, guard top right and 2 panes on the bottom(psql, and bash) works really well and basically never requires my mouse/trackpad. I tried to use RubyMine for development but just found it really clunky but I find that with all IDEs. I think overall though it's just a matter of what you've used most before as to what you think beats the other one. I've mostly used text editors for my whole programming career and find IDEs clunky. If you start out with IDEs you're probably going to be a lot more comfortable in them and find text editors missing too much functionality you like.
I spent a bit of time tuning RubyMine to emulate VIM as much as possible. This includes installing IdeaVIM, restricting windows to 1 tab each, adding keybindings for a lot of shortcuts I used in VIM (split windows, etc). After some work I ended up with an environment that emulates VIM almost perfectly, and still affords me all of the benefits of an IDE. So I agree with you entirely, and at the end of the day, I personally feel an IDE can be turned into VIM easier than VIM can be turned into an IDE. You also just made me realize that I glossed over the fact that RubyMine has visual debugging, which includes visual breakpoints (no more binding.pry), variable inspection, call stack, etc. Everything Pry can do with a real interface and no need to even modify your code or any gems you use.
Don't do this. 20 good applications will land more interviews than 200 fire and forget ones.
Hey do you mind elaborating on the problems with selenium/capybara? I'll be working with those over the weekend.
Will check openstruct. But honestly I'm leaning towards vcr because of the whole "not sure if what I mocked was the right response" issue
Ruby Hash class is what Java calls Hashmap. Look up the Ruby docs for the Hash class and read the list of methods, and those of its ancestors. Then look up operational efficiency of Hash 
Google Rails Tutorial, first result. 
Avdi Grimm did an excellent screencast on that topic: http://www.rubytapas.com/episodes/52-The-End-of-Mocking (unfortunately the site is down right now). To recap: `GithubClient` with methods like `commit_count_for(username)`. Test this by using Webmock. Inject `GithubClient` into every high-level concept and test these high-level concepts by injecting a fake github client. If you're using rails: Injecting stuff into a controller isn't really possible. But you can resort to adding a global config object which keeps an instance of the currently active github client and change this when testing. If you want to do it cleanly: Hexagonal architecture basically solves this injection problem by inverting the dependency between rails and your application.
Sure, I'm not an expert or anything, but I was running into some troubles where I'd get intermittent VCR No Cassette Loaded failures on my tests. At first I thought it was order dependency failures, but I was able to rule that out with some careful retesting. So I started looking around, and noticed a post on a github issue where the creator of VCR mentioned that it doesn't play nice with JS testing because JS testing through selenium is fundamentally multi-threaded/asynchronous. This creates a situation where VCR thinks the test is done, but it really isn't, and BAM no cassette failure! So to fix it, I encapsulated each test, in entirety with the VCR blocks instead of just the component triggering an external call. This consumes a bit more memory and I presume is moderately slower. But it reduced my no cassette errors pretty much entirely. I want to say I no longer get false errors like that, but I honestly don't remember as it has been a couple weeks since I last touched that project.
oh man, how do you use Gdiff like add -p ?!? that sounds awesome
I think I'll need several months. End of year sounds feasible. But anyway, once I sign the contract with the publisher, I'll have the deadline :)
Hmm, I actually did the opposite and switched from rubymine to vim. I still have yet to find something that rubymine did better. I guess if you're running on windows or like using your mouse it might be better, but I haven't looked back.
Sounds like [this](https://github.com/Spooner/releasy/) might be what you're looking for.
Definitely. Just signed up for a notification if you need another technical beta reader I'd be happy to help. Performance is a strong interest of mine.
You don't need to use the mouse, it supports VIM motion keys, macros, %, /, and even some : settings such as ":set ignorecase smartcase". Remap the keys however you want. I can prove you wrong easily. Debugging. Can you add breakpoints into your code or an external gem in VIM without modifying it? I look back on the days of inserting 'binding.pry' or 'debugger' statements and almost cry. I can just click a line of code to add a breakpoint and immediately inspect and navigate the call stack, evaluate any expression, or inspect any value by mousing over it. The breakpoint can be conditional and the IDE supports adding custom watch expressions along with a local variables window that shows all variables in scope that are immediately inspectable, similar to Chrome Dev Tools. It is objectively better at debugging.
Look into rubocop too, which does static analysis based on the guide.
I really enjoyed Michael Hartl's Ruby on Rails tutorial that has you basically build a Twitter clone from start to finish. I had only played with Ruby for a few weeks before going through the tutorial and felt like it did a good job teaching me how to actually build something better than "Hello World."
1. Open a file and make some changes. 2. :Gdiff - This opens the unchanged, staged version of the file on the left. Your changed, unstaged version will be on the right. 3. Selectively copy your changes over with vimdiff commands (:help vimdiff) to the staged file. 4. Save and close the staged file. 5. Commit In my .vimrc I've added: nnoremap &lt;leader&gt;gd :Gdiff&lt;cr&gt; nnoremap &lt;leader&gt;gD :diffoff!&lt;cr&gt;&lt;c-w&gt;h:bd&lt;cr&gt; The first one is just a shortcut to start the diff. The second will stop the diff and return you to the unstaged file you were working on.
Surely this has been posted enough already by now?
hey jocellyn, thank you for writing this blog post about API. Your other blog posts are interesting and informative as well :D I was just wondering what are you using to power your blog? Thanks! 
&gt; Since 1.9 If you've been coding Ruby since 1.8 you know all this, and if you're new you've never seen most of these constructs.
I agree with this rec. Take your time and type in all the code by hand and you'll get a lot out of the Hartl tutorial. Once you've gone through Rails Tutorial and have a high-level understanding of how the different parts of a rails app fit together, I'd start trying to build your own simple projects while making heavy reference to guides on http://guides.rubyonrails.org/. I've been doing this for a while and I still go back to Rails Guides all the time.
I still find with unfamiliar codebases a file navigator comes in pretty handy, but I've instead switched to using a macvim build with a native GUI file explorer. Much nicer to look at. Actually at a glance my VIM setup now looks almost exactly like sublime / atom, but I have full VIM commands rather than their limited VIM mode (and of course, if I so desire I can double click files and open things in tabs and move around with the mouse).
Most ruby blocks return something. You an also do this with Case statements too. Though depending on the context of what you're doing, wrapping it in a private helper method that returns the value (implicitly) might be cleaner. Have fun!
this feature is easily abusable, I've had to debug code like: cmd = if some_condition some_other_hidden_bar = :foo "command -l #{etc}" else some_other_hidden_bar = :bar "other_command -l #{more_etc}" end this doesn't mean you'll abuse it but when you do this for a living you'll face code from many people and varying quality, I personally prefer stricter languages just because they forbid the chance of screwing it up which translates to less wierd shit in the long run. also the ternary way seemed fine and the way to go, it seems you're overcomplicating things for the sake of it. specially since you could've used: cmd = some_condition \ ? "command -l #{etc}" \ : "other_command -l #{more_etc}" which looks ugly but works and can't be abused the same way as the other. 
I think if it's used, it should only be used like a multi-line ternary and nothing else. Only one line and one logical statement per clause.
A quick quiz. What does def return (as of Ruby 2.1)?
Exhaustive.
You can get a lot use from rails. There is tons of helpers to help you generate something fast. But if you are really looking learn how it works, then use Sinatra. There are plenty of books and tuts out there on both. You picked a good lang :)
Howdy, I saw a few issues: Twice you use = which is assignment, when you want == for comparison. I think something is wrong on the first line when you say deck = [2..14]4. If you look at this in irb, you'll see that it's an array with one element, the range 2..14. I also think you're missing an 'end' at the end of the program, currently the while loop isn't closed. I re-wrote the program adding some ruby-isms, but keeping the structure fairly similar, let me know if I can explain anything better and I'll give it a try. #Construct an array deck = (1..52).to_a #Randomize the array deck.shuffle! #Assign half of the deck to each player player1,player2 = deck[0..25],deck[26..51] hand_count = 0 #Play until someone wins until (player1.length == 52 || player2.length == 52) hand_count += 1 state = (player1.last &lt;=&gt; player2.last) if state == -1 player2.unshift(player1.pop) puts "Player 2 won hand #{hand_count}" elsif state == 1 player1.unshift(player2.pop) puts "Player 1 won hand #{hand_count}" else puts "Hand #{hand_count} was a tie" end end puts "Player 1 wins" if player1.length == 52 puts "Player 2 wins" if player2.length == 52
Rails is pretty standard, Sinatra is probably easier for a small project like you describe.
You should try either Rails or Sinatra. Here's great article [comparing Rails and Sinatra](http://www.sitepoint.com/rails-or-sinatra-the-best-of-both-worlds/)
When you say stand-alone application do you mean like a bundled executable? [Releasy](https://www.ruby-toolbox.com/projects/releasy) and [Orca](https://www.ruby-toolbox.com/projects/ocra) both do that competently on various platforms.
You can try [Learn Ruby on Rails](http://learn-rails.com/learn-ruby-on-rails.html). And then you can move on Michael Hartl's Ruby on Rails tutorial.
This also works and I use it a lot if var = condition var.do_something end But yes, Ruby is awesome because it's consistent and intuitive, so you can basically guess the syntax very often.
Hello, I am using http://middlemanapp.com/ and I can only recommend it! It is very intuitive, powerful ruby engine that compiles markdown into HTML. You can have your blog or static page in a minute. Moreover, if you know Rails as I do, you will be familiar with working with styles or images at asset pipeline .. Good luck :)
You are right, I wrote about it as well :) http://jocellyn.cz/2014/05/03/hash-with-indifferent-access.html
Two more languages which come to mind that can do this are Rust and Haskell.
Hey, thanks so much. You showed me my issue. I wasn't catching the state in a variable. I would have used .shuffle!, but I was told not to. It's part of an assignment for my algorithms class for a bootcamp I'm attending. I've only been using Ruby for about 10 days, so I still make some of those mistakes like not capturing the return value in anything. I made a mistake copying the code over. It's supposed to be: deck = [*2..14]*4 It works in IRB. After this loop works, I'm going to change the else part into another loop that deals with that portion of the game. I'm actually going to modify it to compare the -4 index of the array. However, I'm going to have to add some error checking to make sure that -4 doesn't equal nil. Thanks again!! EDIT: I just realized that when I write my code, Reddit interprets the splat operator as me wanting to italicize. 
Interview somewhere else and find out.
Rails and Sinatra are for web applications. It sounded like that's not what you were asking for, but it might be your best bet. As far as I am aware there is not really any framework for desktop apps. Also ruby doesn't have the best GUI libraries, but there are a few you can use. Lastly for IDE I always suggest vim with a few plugins, but rubymine will probably meet your IDE expectations. 
For Tools: RubyMine is the best. Learn the keyboard shortcuts... although there are no GUI Tools like you might have with MS Visual Studio, Xmarian Studio, Qt, XCode... etc. Desktop? Rails can certainly be a desktop application -- just run it on your computer only. lol. It sounds like you mean 'desktop' in the more traditional sense of an executable. Like an .EXE or .APP? Why do you HAVE to do it in ruby? Why does it have to be a desktop? Are these requirements from someone else? It would be easy to make the case that Ruby may not be the best choice for this project if it HAS to be a 'desktop' app. I would go with Mono, Obj-C or C# (pending on the OS requirements) if it HAS to be a desktop app. This a very narrow way of thinking to say it "has to be this and has to be that" without a really good reason why it has to be. As part of being a software engineer you should always pick the right tools for the job at hand. Ruby and Desktop don't exactly go together that well for that style GUI based applications (the ones i think you're describing) that are not in a web browser. I'm sure you could build something that was ruby based and ported to some form windows, but you would be re-inventing the wheel that many other tools can do currently right out of the box. What would that be anyway? It sounds silly not to consider the browser to be a GUI for a desktop application. If the application can be command line driven, that might work well for the project. What does this application have to do?
don't forget cmd = taelor.dumbass? ? "downvotes" : "upvotes" edit: because I'm a dumbass and didn't read the first sentence.
And Scala. I think Scala is the most ruby like of the newer breed of functional languages too so a natural fit for most of us ruby folks (though Scala can be a lot more complex than ruby).
interesting! thank you for sharing! I was wondering because I use something similiar called ruhoh (http://ruhoh.com/), which is a ruby gem that is a static site generator also! I thought it was possible that you might have been using the same. Thanks again and I look forward to looking reading more of your blog posts.
I think that was the one OP started with, unless I'm missing something.
ahaha, I'm a dumbass. admittedly, I skimmed over it and only read the last half. 
You should just look up a way to convert your programs to binary and recompile them in something like .deb, if that's possible anyway. Then again, as long as you have whichever ruby dependencies your build relies on to run ruby files, you should be able to just save them in that format and run them in any OS that supports ruby, no?
I guess Shoes replaces OOP or something?
That works for Windows and Linux. But it's worthwhile to note that OS Mav ships with Ruby 2.0 and previous versions shipped with 1.8.
Probable explanation of downvote: that makes no sense. Object-Oriented Programming is a way to program--a style to solve problems. You don't replace how you model your system with a gem. It is a GUI toolkit, i.e. Shoes is to Ruby as Swing is to Java (roughly, kinda).
One other option would be to define the two commands as methods and just stick with the one-liner. Having said that, are you actually doing anything with the cmd variable after? Because this really seems like it should be a method in itself, which would also probably get this line back under 80 chars.
That's sort of what I meant, download a ruby dependency (aka: package or interpreter) and assign it as the default program to handle ruby files. I figured there'd be universal interpreters out there to do that with. Thanks for explaining though man.
This is a good practice. I picked up up after reading the Confident Ruby book by Avdi Grimm. You will get tons of great practices from that book.
Yes, we are doing something later with it. This was by no means complete code and was simply posted it as a proof of concept/hey look at this. As it turned out, other_command didn't support a critical argument that command did that was needed to proceed, so my intended refactor/feature upgrade didn't work. 
&gt; EDIT: I just realized that when I write my code, Reddit interprets the splat operator as me wanting to italicize. Just put a \ before the \* to escape it.
I have been using this practice while working with models (User.all), didn't know we could do the same with params. This is definitely useful, thanks.
It is like ID card for ruby gem. There is name, version, license, author etc. Also there is info about dependencies (other gems required). Example: https://github.com/plataformatec/devise/blob/master/devise.gemspec
I thought shoes was no longer being worked on? If it is, I'd be so happy.
 (params[:id] || []).each
Thats what I thought - not a lot of activity on Github. 
That is not a good alternative. See the explanation here: http://www.reddit.com/r/rails/comments/24n2x4/guarding_with_arrays/ch91s4i
Yes it is, did you actually try it? Plus, the person you linked to isn't using an `or` operator, they're calling `fetch`. They're completely different operations. Mine works, theirs doesn't.
you are correct, apologies
Why do you prefer `params[:id] || []` over `Array(params[:id])`. Not nitpicking, genuinely curious.
For one it reads easier, and I don't think that's just a personal preference. It's immediately obvious why you're doing "my" way, but it's not immediately obvious why you're putting it in an `Array`. Second, `Array(params[:id])` swallows what probably should be [logged as an error](http://www.reddit.com/r/rails/comments/24n2x4/guarding_with_arrays/ch9fo9e). Given that in this example `params[:id]` is supposed to return a collection or `nil`. If `params[:id]` is sometimes spitting out integers (as in the example I was responding to) you should know about it.
[Celluloid](http://celluloid.io) also has pools
The project is quite alive. [Shoes 4](https://github.com/shoes/shoes4) is a rewrite on top of SWT. That said, JRuby is going to be a hard dependency.
I'm moving from C# to ruby, so my reading list is gonna change a little. Would reddit ruby programmers be interested in posting it to the this subreddit?
I'm not interested in your 'around the web' ads. 
What's the motivation for reading Kehoe's Learn Ruby on Rails before Hartl's book?
Listing out everything you require is generally how it's done. I don't think there's anything stopping you from doing something similar in Ruby if you wanted.
There are wiki products in other languages that do the job well enough that no one has felt enough pain from them to justify re-inventing the wheel in ruby.
Why does there need to be?
I think it's *particularly evil* to do an assignment with the result of the if clause and another within, why the hell not both inside the if? like normal people. if some_condition some_other_hidden_bar = :foo cmd = "command -l #{etc}" else some_other_hidden_bar = :bar cmd = "other_command -l #{more_etc}" end there's no reason to not do it like this. 
Write one. 
What they say they want and what they're willing to work with are very different things. Especially if they've been looking for a while.
I wish I had the skills. I'm just a hobbyist, and my ruby is non-idiomatic and hacky. Maybe one day...
I wouldn't do this with the example you set - as there are two variables being assigned. However, if it was only I might use the following pattern: cmd = if some_condition "command -l #{etc}" else "other_command -l #{more_etc}" end It's briefer, but I like this because it makes it very explicit that whatever else happens inside the if/else the central part of the whole code block is to get something into a variable, so if you're skimming the code you can pretty much read the name of the variable and skip the code and you should get a general idea of what's going on. This doesn't happen on the other approach, where a maintainer would have to read a lot more to get a feeling of what is going on. 
Here you go: &gt;Nagappan, Nachiappan, et al. "Realizing quality improvement through test driven development: results and experiences of four industrial teams." Empirical Software Engineering 13.3 (2008): 289-302. Reprints available from Springer; see [here](http://link.springer.com/article/10.1007%2Fs10664-008-9062-z). PDF linked to from [scholar.google.com](http://scholar.google.com/scholar?hl=en&amp;q=realizing+quality+improvement+through+test+driven+development); see [here](http://131.107.65.14/en-us/groups/ese/nagappan_tdd.pdf). Trade-press article reporting on the paper's findings [here](http://www.infoq.com/news/2009/03/TDD-Improves-Quality). Just because you've been indoctrinated by a well-known cult of personality into calling valid science "cargo cultism" doesn't make it so; rather the opposite, actually.
because it's painful to have to install php on your development box when you want it to host mediawiki and the rest of your stack is in ruby.
Thanks for the link, I'll read it thoroughly and let you know what I think. For starters, 4 case studies is not conclusive. If you have more id love to get links. 
Have you heard of gollum? https://github.com/gollum/gollum
Sounds like a good first project to practice on. :)
There's also Instiki: http://instiki.org/show/HomePage Not quite MediaWiki, but may do the job depending on your needs.
google is your friend ... and you would find: [gem guides](http://guides.rubygems.org)
If it's for internal access, you can roll your own wiki in minutes with a Markdown gem.
Sorry for the disappointment. It wasn't meant to be smart or tricky. Just useful, at least to me. How would have you done it?
Agreed. It turned out to be really simple to do. And using a library like Image Magick only made it simpler. Good for me. In any event, the point was utility and not code complexity or some tricky algorithm. Good code among other things should be easy to read, easy to understand and favor reuse. I improved the quality of the output by carefully selecting the ASCII characters. See here: http://blog.dwaynecrooks.com/post/83806327881/photo-ascii-in-ruby-improved-quality. Then, I made it so that one can render the output in HTML. Each character in the output is wrapped in span tags with an appropriate class applied. See here https://github.com/dwayne/photoascii/blob/2ccd05cd520bb70bc22930cc6afc2c193da3b4a8/photoascii.rb. And this, https://raw.githubusercontent.com/dwayne/photoascii/master/results/dwayne.png,is the output you get if you use a grayscale color scheme applied to the characters.
tbh The title suggested me, the result will be [similar to this](http://linux.byexamples.com/wp-content/uploads/2007/02/jh-ascii2.png)
ugly and popular are not mutually exclusive in programming languages. see: php
It's percentage based, not absolute number. So it's hard to say to what degree it's fewer people making Ruby projects, and to what degree it's more people from other languages starting to use Github more.
Well, weird shit could still be happening even with ternary operators because ruby gives you a bazooka and no clear instructions on how to use it, but I see your point. Again: I don't use this often but in some specific cases it can be useful, we don't need to use all the features just because they are there but conversely just because a feature can be abused doesn't mean that it should never be used, if that were the case we couldn't use anything in ruby.
Because yoohoos sit around asking why this doesn't exist rather than making one. Define robust please, that's kind of subjective. And there are ruby wiki's.
The fact also is that JavaScript is the only front-end language. There are so many back-end languages, it's obvious that JS has to be first
These graphs don't really show much information one way or another. But it's not a big secret that a lot of people jumped to Node (or other languages) when Ruby stopped being the cool new language. Ruby (and its popular libraries/frameworks) are more mature but less exciting now. Notice how there's significantly less drama. We've settled down and are doing cool shit for customers without the need to proselytize every 5 minutes. That will happen to Node/Clojure/Cool Language Of The Week one day too.
I'm not being racist, you f*cktard. :)
While this is called out under 'Caveats' in the article, I think it's important to stress this is only looking at the detected primary language for a repository. I do a lot of Ruby web projects and most of them are detected as primarily javascript because there are so many lines of random javascript code brought in. Does that make it a javascript project? Absolutely not. Generally I have between 10 and 200 lines of javascript code actually written in the project and at least as much in javascript tests. It's only the common practice of having the javascript libraries in your repo that is escalating that count so much. Now with that said, it doesn't invalidate the data. It does not surprise me personally that the growth of new Ruby repos isn't accelerating as much and if I had to guess why, it's exactly because as a language we are maturing. There are already gems out there that solve the easy or very common problems in sane and well-tested ways. I don't see that stability as much with javascript. How many javascript date picker libraries are out there right now? How about libraries for cross browser compatibility (not just the common ones)? Templates? URL rewriting? Thats not to say that there aren't solid significant projects in javascript that are solving real issues in new and interesting ways, but I think there are a lot of abandoned pet projects that can't be accounted for like this.
If you read it through: &gt;GitHub is a specific community that’s grown very quickly since it launched [writeup]. It was not initially reflective of open source as a whole but rather centered around the Ruby on Rails community; What you're seeing is the addition of other communities (don't forget the decline in % of Ruby isn't necessarily reflective of the rise of of another, but the addition of ALL the other languages combined). Did you even read the article or just post based on the graph? &gt; * GitHub hits the mainstream: James quickly nailed the key point: GitHub has gone mainstream over the past 5 years. This is best shown by the decline of Ruby as it reached beyond the Rails community and the simultaneous growth of a broad set of both old and newer languages including Java, PHP, and Python as GitHub reached a broader developer base. The apparent rise and drop of languages like PHP, Python, and C could indicate that these communities migrated toward GitHub earlier than others. This would result in an initially larger share that lowered as more developers from e.g. Java, C++, C#, Obj-C, and Shell joined. &gt;* The rise of JavaScript: Another trend that instantly stands out is the growth of JavaScript. Although it’s tempting to attribute that to the rise of Node.js [2010 writeup], reality is far more ambiguous. Node certainly accounts for a portion of the increase, but equally important to remember is (1) the popularity of frameworks that generate large quantities of JavaScript code for new projects and (2) the JavaScript development philosophy that encourages bundling of dependencies in the same repo as the primary codebase. Both of these encourage large amounts of essentially unmodified JavaScript to be added to webapp repositories, which increases the likelihood that repositories, especially those involving small projects in other languages, get misclassified as JavaScript.
Thank you for pointing this out. As I mentioned in the disclaimer at the top of the article, I simply edited the work, I don't necessarily have the same views. But in the original essay, I think the point you mentioned about "where is the empirical evidence for TDD?" would possibly have been missed because the statements were very hand-wavey. Now that we have a concrete claim, I'd love to see Uncle Bob (or someone) else provide more support for it.
&gt; Lots of people claim to see problems with Rails but there is only a few willing to discuss particular examples - for me this does not add up, but there is probably more than one reason for this Probably those guys are just trolling. Otherwise they would come up their own framework or submit PRs to make Rails better. Or at least participate in a ping-pong. Haters gonna hate.
It might be politically impossible to throw php and mediawiki up on a **development box**? Are you on glue?
&gt; Otherwise they would come up their own framework I thought about doing this, but the support code you'd need for a hexagonal architecture is actually very small. And for the annoying bits (like type coercion) there are already excellent libraries out there (e.g. virtus). &gt; or submit PRs to make Rails better. Rails is fine as it is. It serves well as a web framework. Most people have issues with it trying to be an application framework. It doesn't provide any structures beyond simple MVC. And IMO it shouldn't. It's a web framework. &gt; Or at least participate in a ping-pong. There are usually two problems which are solved by decoupling yourself from the web framework: a) Very complex use case rules which would otherwise be scattered across models and controllers and very hard to understand/test. b) Decoupling for the sake of decoupling: Which means replacing components and testing becomes easier. The problems with the ping-pong regarding these two problems are: a) Breaking down a complex application into something manageable isn't trivial. I wouldn't bother doing it. b) If you use simple use cases it looks like you've overarchitectured things. DHH will of course just put everything into the controller using well named private methods and kill all these benefits your decoupled application had. DHH's approach will look simpler mainly because of less classes/lines. But it's harder to change and harder to test which is not apparent to the untrained eye.
Not every company allows you to provision your own servers outside of local VMs. Many companies have VERY stringent security because they have seen the sort of shit storms (i.e. large data leaks) caused by idiot developers who will throw more or less anything onto "development boxes" which then go more or less unadministered and unaudited by the ops teams.
I think I saw a solution to this on [codegolf.stackexchange.com](http://codegolf.stackexchange.com), where the guy determined the darkness of each ASCII character programmatically. He created a test image and sequentially drew a character on it, counted the black pixels, and saved the result. 
uh...it just linked me to the list of friends that like "The Real Housewives of Atlanta" .... which of course is 0, so it was a blank page.
Thanks for using the app. In response to your UH, response, you should consider yourself lucky you don't have any friends that like that trash. Cheers. Thanks again. 
Seriously, you're being very anglophone centric. Also the guy in that ruby-forum topic is a big jerk and is shocked that people don't want to work with him. It's just not all about you, or me.
Percentage based graph by itself doesn't tell you much. See the graph from absolutely numbers: http://sogrady-media.redmonk.com/sogrady/files/2014/02/repos-by-lang-github1.png which basically says "Nothing to see here" :-)
Among other interesting things, this video talks about how in medicine we know quite a bit more than we can "prove" with the gold standard definition of "proof": https://www.youtube.com/watch?v=dBnniua6-oM 
&gt; Rails is fine as it is. It serves well as a web framework. Most people have issues with it trying to be an application framework. It doesn't provide any structures beyond simple MVC. And IMO it shouldn't. It's a web framework. I 100% agree. If you want rails to be more than that, fork it and make it so. 
Can you be more explicit about what you are implying? Second, that video is an hour and a half. Can you summarize how they "know" something without "proof"?
Well the gold standard for proof is a double-blind experiment. However that type of experiment is very often impractical, impossible, or unethical for a wide variety of reasons. So instead we rely on more circumstantial evidence that increases our confidence in a hypothesis but is not "proof". Someone demanding proof as a prerequisite to belief would be missing out on a great deal of valuable knowledge. 
Are you makng any clear point about the TDD debate? If so, please be more direct. 
What do you mean by "appears (to me) to have vanished in Ruby 2.0"? Can you give an example? It still works on my end [as expected](http://stackoverflow.com/questions/3009477/what-is-rubys-double-colon-all-about): $ ruby -v ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux] $ irb irb(main):001:0&gt; module Foo irb(main):002:1&gt; BAR = 1 irb(main):003:1&gt; end =&gt; 1 irb(main):004:0&gt; Foo.BAR NoMethodError: undefined method `BAR' for Foo:Module from (irb):4 from /home/bry/.rubies/ruby-2.1.0/bin/irb:11:in `&lt;main&gt;' irb(main):005:0&gt; Foo::BAR =&gt; 1 irb(main):006:0&gt; 
Correct me if I am wrong. Double Colon (::) is namespace resolution. It can also call Class Level Constants. So when you do this: MyModule::MyClass::MySubClass MyModule::MyClass::MySubClass::CONSTANT it is calling the name space of: module MyModule class MyClass class MySubClass CONSTANT = 'test' end end end This differs from Dot Operators (.) in that with Dot you are calling a property or method. # This will call a method MyModule::MyClass::MySubClass.new MyModule::MyClass::MySubClass.run MyModule::MyClass::MySubClass.property = test MyModule::MyClass::MySubClass.property #=&gt; test This either initializes the object or calls a class method: module MyModule class MyClass class MySubClass CONSTANT = 'test' attr_accessor :property def initialize # stuff end def property=(property) @property = property end def property @property end def self.run # more stuff end end end end These have been in Ruby as long as I can remember. Does that help?
^'::' is called the 'constant lookup operator' and it does exactly that.... allows you to access classes/modules(which are in fact constants) and any constants which are defined in them. Like enroxorz explained, the 'dot operator' is used to access the state or behavior of an object. Think of it this way, the '::' is really a way to traverse scope until you find the constant you are looking for which could be a class, module or a constant defined in either of the previous two. The '.' is used to access state or behavior once you are in the desired scope. Example: class OuterClass module InnerModule def self.module_method puts "I am in the module" end end end OuterClass::InnerModule.module_method #=&gt; I am in the module - "::" is being used to traverse scope - "." is being used to access behavior once the desired scope is reached 
IMO Uncle Bob's entire Blueprint-of-a-Church metaphor which he uses is very unprofessional and confuses the issues.
enroxorz gave a good answer. I've been writing a game using libgdx and JRuby and these two operators show up in interesting ways. java_import com.badlogic.gdx.Input::Keys java_import com.badlogic.gdx.maps.tiled.TiledMap In this case, TiledMap is a Java class in the package com.badlogic.gdx.maps.tiled, and Keys is a class within the java interface called Input. If I wanted to access one of the constants in Keys, I could then write, Keys::CONTROL_LEFT The . operator used with java_import is *java syntax* that is carried over into JRuby. You can also access a java object directly by using the namespace operator :: and JRuby's special syntax for java packages, @map = Java::ComBadlogicGdxMapsTiled::TiledMap.new
Yes, that helps me understand how the two operators are currently used. Why didn't Matz originally use dot for both of these, for a simpler syntax?
I don't have an answer for that. However, I do find it easier to delineate between the two. Function and properties are functions and properties, while classes, modules , and constants can be easily identified.
Valid question. I've been building Rails apps since 2006 and since then I spent about 1 month per year on code optimization (not scaling or caching). I'm sure you can easily find people with even more Rails experience, but there're only a few who spent as much time optimizing. I simply enjoy that process more than most people. I contributed performance patches to Rails (2.x). I created ruby GC patch for memory profiling and wrote memory profiling support in ruby-prof. I presented twice at RailsConf and once on PGCon (on performance). There're more blog posts with performance-related advice from me here: http://www.acunote.com/blog
They are not the same. class MyClass def self.InnerClass; 77; end class InnerClass; end end MyClass.InnerClass.class # =&gt; Fixnum MyClass::InnerClass.class # =&gt; Class
It's really cool that we have a community that is willing to spend time to share and contrast ideas with each other. That being said I think either DHH is picking the worst examples or most Rails developers write a lot of shit code.
This is an interesting point, I didn't realize it could be used that way. Double colon will prefer to return a constant over calling a method, but if it can't resolve to a constant, it appears to behave exactly like dot.
They're all just values.
In ruby dot (.) sends a message (a method name and collection of arguments) to the object proceeding the dot. There is no direct property access outside of a class or module. All instance variable access is done through a method call. `attr_reader` and `attr_accessor` dynamically generate methods named the same thing as the instance variable which look a lot like property or field access in other languages. You can generate these methods yourself: attr_accessor :foo is equivalent to: def foo; @foo; end def foo=(o); @foo = o; end You can also access instance variables through #instance_variable_get, but you're still calling a method to read the value.
This is a better argument... https://www.youtube.com/watch?feature=player_detailpage&amp;v=vqEg37e4Mkw#t=1320
Try putting ~/ before the require path. 
I downloaded it and installed it. I created hello.rb as a blank ruby page and ran it and it worked fine. Did you create a hello.rb page or are you referring to the index.html? I ask because I ran it once before I realized there was no ruby file in that folder. 
Except when they are. &gt; MyClass.InnerClass.class # =&gt; Fixnum MyClass.InnerClass::class # =&gt; Fixnum &gt; MyClass::InnerClass.class # =&gt; Class MyClass::InnerClass::class # =&gt; Class
This thread has been linked to from elsewhere on reddit. - [/r/shittynosleep] [I’ll never poragom in roby again ( x psot from /r,ruby,](http://np.reddit.com/r/shittynosleep/comments/24ud1k/ill_never_poragom_in_roby_again_x_psot_from_rruby/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag) ^I ^don't ^read ^PMs!* 
lol what a crap comment and article
The Ruby community is great (cf. Ruby Quiz), but the Rails community is mostly composed of passive aggressive wannabes who over-rate their own ability but aren't prepared to handle public code review of any shape or form.
Declarative programming via pseudo-JSON gets exceptionally unpleasant, real damned fast.
Actually with the latest code, you can achieve similar if not better results. You have the option of tweaking the color scheme one you generate the HTML based ASCII version. Check it out again. With CSS3 at your disposal you can even target portions of the image and animate it for example. https://github.com/dwayne/photoascii/blob/master/photoascii.rb#L123
[Discussed on SO](http://stackoverflow.com/questions/18931952/devise-token-authenticatable-deprecated-what-is-the-alternative). Follow the link to the gist and use one of the methods there and there's even a gem now (scroll through the posts on the gist, I used the first method in the gist so I don't want to suggest something I haven't used). 
I could have sworn I read this exact post several months ago... Deja vu?
DHH didn't pick the code.
I checked the date to make sure it's really new. After all, Ruby2.1 (not to mention the preview from september 2013) is around some time yet. I just searched with Google, didn't find anything exactly the same. Though obviously there are quite some "what's new in Ruby 2.1" blog posts and they list more or less the same content.
I have something similar for _Tower of Hanoi_ if someone is interested. Not a solver but a well tested model that forbids certain moves.
Not a game, but interesting.
Self bias
I too am interested in this. I think I remember hearing it is because Ruby lacks a competitive efficient library for table driven maths. This deficiency makes Python or R almost defacto choices for machine learning etc. Also Pythons massive adoption by the scientific community has produced a wealth of tools.
Yeah, I guess it's not too surprising. I keep seeing a bunch of "What's new in Java 8?" posts over on /r/java as well, and those also start to run together after a while.
Check out http://sciruby.com/ - it could use some support as a cool way to bring Ruby into the scientific community. I'm ashamed to say that while I bought a t-shirt, I haven't contributed any code yet... but it's a cool set of projects! On github too: https://github.com/sciruby
Is this a sign OP is Brian Shirai?
I'm pretty sure this exact question came up recently ?
Looks like it wasn't in the ruby subreddit, maybe it was in the python or one of the science subreddits.. TLDR python has much better ecosystem for science. numpy, biopython, scipython, pandas , scikit, openCV bindings etc Ruby could catch up if it can copy all those 
&gt; numpy Yes, this. Everything is built in this Once nmatrix is there, ruby might be able to get there : https://github.com/SciRuby/nmatrix 
It's too stateful to be considered "beautiful" IMO. But that might be personal preference. btw. You can simplify this: if winners.key?(token) winners[token] &lt;&lt; details else winners[token] = [details] end by passing a default proc to the hash: `@winners = Hash.new { [] }` FYI: since `winners` is an instance variable on the module, it's global state. This usually ends up biting someone in a larger project.
I'd love to have means to make it easier to use in Linguistics research. Like, the NLTK book and related resources, but in Ruby.
Oh, it's *this* approach again. Have fun with that. I still remember doing this in C all the time: #include &lt;my_header.h&gt; 
Its already making good inroads with things like Bioruby, but we really need some good advanced mathematics libraries. Objects for advanced number and value storage, and so forth. Trying to do any slightly advanced math, even statistics (say, calculating a regression for a set of values) is needlessly complex
&gt; NKTK Thanks for sharing this the library seems fascinating, this seems like a field where Ruby could really shine (pardon the pun).
It isn't exactly a reference, but it works: https://eval.in/147267.
The lack of libraries comparable to numpy and nltk is the single biggest reason, IMO. A lot of that is mitigated by using jruby, where you can call Java directly, but if you're not a programmer by trade, that might be a little opaque. Super powerful though.
NLTK, sorry.
I don't think it's "beautiful" or "not beautiful." There are certainly some things you did that I differ from stylistically, but my question wasn't really targeted like that. Why would you consider it "beautiful?"
Holy shit, you're right. That makes it even worse.
1. I felt like I found an elegant design that decouples Tic-tac-toe game logic. That's all this library really does. One should be able to leverage this library to build any kind of client on top of it. Say a command-line client, a web client. Or even build a game server around it. 2. The design actually works to decouple game logic for other kinds of games based on the state machine engine concept. 3. The algorithm for Minimax actually side-steps Alpha-Beta pruning and uses the symmetry inherent in Tic-tac-toe game configurations to reduce the search space and improve performance. I felt good about my implementation of the XO::AI::GeometricGrid that implements equivalence based on transformations of the grid. Certainly I have a biased opinion because I wrote the code and to boot I just finished writing it. Maybe a couple weeks from now I'd see more clearly some of the crap I've written (as it usually happens).
The distinction between Procs, lambdas, and blocks is a little weird. Between the `do`/`end` is a block, this is a purely syntactical construct, like an `if` statement or a `while` loop. Unlike an `if` statement you can wrap up a block in an object, this is what a Proc is. A block doesn't know if it has been wrapped up in a Proc, so there isn't any keyword like `self` to reference the Proc from the block. However blocks are closures, so they can reference variables declared before they are, and the value of the variable is resolved when you call the block, this lets you reference a block (wrapped as a Proc) within itself like so: factorial = lambda do |n| return 1 if n.zero? n * factorial.call(n - 1) end p factorial.call(4) #=&gt; 24 `lambda` is a method that takes a block and returns a special 'lambda' type Proc. 
Because the lambda evaluates the variables at call time, I'd argue that in the example you have the lambda doesn't actually refer to itself but rather refers to a variable that you are hoping refers to the lambda. The distinction being that if you reassign the variable, you'll no longer get the desired behavior x = lambda do x end y = x x = 3 y.call
This is an interesting trick. I guess you are "upgrading" the lambda into a method that exists on itself and then calling that. 
Narcissism.
What a useless post.
It needs enough good libraries that it can start to create an ecosystem within the scientific community so that it inspires the very talented people who can and want to write kick ass libraries to do so and make it main stream. It also requires that existing scientific Python users, or new people entering science who also program to prefer Ruby to Python enough that they're willing to do both. Python just has the [first mover advantage](http://en.wikipedia.org/wiki/First-mover_advantage).
I about lost it when I read "break the interactor chain" in the interactor example. Seriously, my rib cage hurt I laughed so hard. And I'm definitely *not* one to stick to doing rails the DHH way, either...
Probably. I also believe it hooks into LAPACK and a few other matrix math libraries as well.
Wow! I didn't realize that the double-colon could be used more generally for method invocation &gt;&gt; "hello"::reverse =&gt; "olleh" TIL
Thanks. Using the y combinator, I'm able to solve the problem completely. I'm on my phone right now so I can't post the solution but I'll try to do it when I get home. 
To be clear, it can be done, just not that way. class A class &lt;&lt; self private def b puts 'b' end end end A.b # =&gt; NoMethodError: private method `b' called for A:Class
Good luck with everything. I'm in the same boat, but in a bootcamp. We were told how to run RSpec in the terminal, but had to reverse engineer everything else from the test they provided. 
I recently found artoo.io and while its not extremely scientific or technical it is an applied example of using ruby in a technical manner.
A few notes: 1. https://github.com/dwayne/xo/blob/master/lib/xo/ai/player.rb#L11 - You're using `protected` when you probably want `private`. 2. https://github.com/dwayne/xo/blob/master/lib/xo/grid.rb#L71 - You shouldn't be reaching into another object like this to get information. This would be a great place to use `protected`. 3. Do not check in your `.ruby-version` or other things you use to customize your setup. Along these lines, you can specify Ruby version info in the gemspec. `spec.required_ruby_version = '&gt;= 1.9.3'` 4. Did you know that the Ruby standard lib has a Matrix class? http://www.ruby-doc.org/stdlib-1.9.3/libdoc/matrix/rdoc/Matrix.html 5. Have you looked into "Tell, Don't Ask"? (There's a certain irony in that sentence.)
Haha, me too! They way over abstracted that. None of the examples do any justice to any of the patterns that we use to clean up our code. I'm really curious if there were any good submissions and it's the people deciding on the code or if most of these people have no damn idea what they're doing. And yeah, I'm definitely not sticking up for DHH other than the fact that his code is far more sane in these examples than everyone elses.
Ruby is way slower than other scripting languages when it comes to arithmetic ([benchmark](http://benchmarksgame.alioth.debian.org/u32/ruby.php)) due to that numbers are objects too.
Ugh. More is less. Less is more.
* Better documentation, so that ruby.org would be on par with python.org. * A public development process - something on par with the PEP's. * Faster interpreter startup time - ruby / irb / pry just feels slow compared to python.
&gt; So what does ruby need to be more competitive in the scientific field To be Python. *(just kidding - couldn't resist)*
Damn, still uses liquid templates. :(
So ,what about Octopress?
Eventually, it will have most of the features that the middleman has?
That's never going to change
#instance_exec executes a block/proc/lambda in the context of the receiver (which in this case is the lambda itself).
It's developed separately to jekyll.
I think you over engineered. Take a look at my solution here: https://gist.github.com/radarek/b4fada966889263051b1 Did you made with tdd or just wrote upfront and checked if it passes all tests? I did it with tdd (working on one test, red, green, refactor) and there was no way to end up with code like your.
Not my post, but, indeed, I find that refactoring a larger Ruby codebase in Vim, without having some plugins to aid, can be painfull. Especially when following the Ruby best-practice of having one file per class, where a global search-replace does not always cut it.
And [nanoc](http://nanoc.ws/)?
1. I checked and I see what you mean. I didn't know a subclass could call private instance methods. It's also interesting how I read this (http://stackoverflow.com/a/3534581/391924) before and made the mistake anyway. 2. I mimicked the code I saw here: https://github.com/ruby/ruby/blob/trunk/lib/set.rb#L104. 3. Is it that I should never check in my .ruby-version or just when I'm creating gems I should never check it in? http://stackoverflow.com/a/16738020/391924 4. Yes. Chose not to use it. 5. Yes. That's why, for example, the Minimax code is written the way it is. See MaxPlayer and MinPlayer and how they are used within the code. Thanks for pointing these things out.
Separately? Or on top of?
*"forked from brandonhilkert/fucking_shell_scripts"* *sigh* Puppet and Chef aren't for deployment, they are for *provisioning*. If you're deploying with Chef, Puppet, Ansible or Salt...you're just doing it wrong. Right tool for the right job people.
Agreed
...both.
Hey, I'm a Middleman-lover too... That said, being able to publish seamlessly through Github Pages offers Github repo maintainers, well, easier maintenance of their documents. Obviously if you can setup Middleman, you're probably capable enough to write the Rake script to cmd-line publish it to Github pages (or S3, or what have you)
The tight integration with GitHub Pages really is the only valid reason to prefer Jekyll over Middleman.
So aside from free hosting on github, would you say there are any advantages to Jekyll?
1. I see *a lot* of people confuse how `private` and `protected` work. Often they come from languages like Java and they assume it works the same in Ruby. 2. I'm a really fascinated by that. Thanks for pointing it out. You'll note they use that same call in a number of other places. I wonder if that's faster than a protected method. Sometimes the Ruby stdlibs do things for performance that you might not normally do. 3. When you create gems. It means you'll have to update your gem when a patch version of Ruby comes out. Also, why are you restricting it to 1.9.3? For projects you're on that will be deployed somewhere (e.g. a web app), you'll want to lock down the version because you're looking for consistency in the environment you're working in. Basically, if you're letting other people use it you should probably be as flexible as possible about what versions you allow. 4. OK 5. I'm afraid I don't follow. `MaxPlayer` and `MinPlayer` are stateless modules. There's no state to ask about. I asked this because you have code where you do ask an object about it's state and then make a decision. For example, in `Minimax#build_search_tree` you ask `terminal?` and then call two different scoring methods based on the response.
I'd argue with that statement. Once configured, chef can be the engine behind container based deployments. Want to do a deployment? Have chef spinup and provision completely new servers without taking down your old ones. Then make an API call to your load balancer to add the new instances and force down the old ones. At least that's what I'm using chef for and I don't think I'm doing it 'wrong'
No.
I've hacked Jekyll quite a bit to build sites that probably should not have been done in Jekyll...so it's hard for me to say, actually. If you want to do what Jekyll purports to do: quickly generate a blog, some pages, and maybe some non-standard-pages ("Collections" is still listed as unstable, so I'm not keen on trying it out at the moment)...then it might be the ideal choice, especially with Sass support built in (which, for some reason, was an incredible pain in the ass to get going via optional Jekyll plugins). Limitations are good, if you know why you're giving up some freedom and what you're gaining in cognitive-ease and such. The big "feature" of Jekyll is its very large community. Middleman, sadly, does not have that yet...and while I feel it's a pretty stable system and API...customizing Middleman is still a bespoke experience for me every time. There's not enough Rails-like-mindset on convention, and currently, when I'm "free" to do things, it's usually not the right kind of freedom. However...the fact that I can choose my templating system, data layout, routing system based on that data, etc...makes Middleman way more powerful (without yet being a full on Rails/Sinatra app) and worthwhile...and that's the kind of app I like to build (static pages based off of data arrays that don't yet require a database). This is a long way of saying: Jekyll may (now) easier to use right out of the box. And if you're OK with being within Jekyll's constraints (Liquid, a plugin system that, for me, is difficult to grok, etc.), then it may be the better choice for smaller, focused projects. I mean, when you consider the alternative -- rolling out an entire Wordpress site, or Tumblr, just to make a landing page...Jekyll is **way better** than that. I see MiddlemanApp as being the go-to system for when I want the ease of static deployment with some dynamic data behavior (but not the whole database thing, obviously) 
That's a fair enough point.
I do not follow that one file per class "best practice," but I've found I don't really get burned by it. I do this kind of stuff a lot though, on the command line: grep -lr "old_name" app lib | xargs -L1 sed -I '' -e "s/old_name/new_name" Generally, large scale changes like that are rare enough that I don't mind the pain. I certainly wouldn't adopt an IDE because it occasionally helps me with that rare kind of change.
The `permutation` method accepts a block so you don't need to convert it to an array and the call `each` on it. Additionally, you'll want to take the `uniq!` call out of the loop and only do it once at the end. That last part speeds this up tremendously.
Why would you want to rescue a malformed CSV error? Surely that indicates to you that your CSV is broken and you should bomb out
[This](http://sequence.complete.org/node/149) looks like its the same question you asked but in haskell. Other google hits yield similar answers which is to use the Y contaminator as /u/Kache suggested.
That's not the case, no.
Short answer - no. You could create a headers hash out of the first row or something to stop field counting. Long answer - Interesting question. My first test case was &gt;require 'csv' &gt;CSV.open('test.csv', headers: true) do |rows| &gt; begin &gt; rows.each{|r| puts r.inspect} &gt; rescue &gt; CSV::MalformedCSVError &gt; end &gt;end Which I'm sure is what you did. So, once that failed, I dived into the CSV class, and specifically the definition of foreach. The important bit of foreach looks like this: &gt; open(path, mode, options) do |csv| &gt; csv.each(&amp;block) &gt; end And the money bit is the definition of each: &gt;def each &gt; while row = shift &gt; yield row &gt; end &gt;end The "shift" bit is the bit that parses the next row. As you can see, you aren't in the scope of the block you provided at the time that shift raises the exception, so any rescues you provide inside that block won't work. You can rescue the exception easily enough by sitting outside that, but because your block is not responsible for raising the exception, it can't catch it. That means that any rescue you put in for each will only catch the overall fail as an exception case, at which point the loop has already terminated and you've lost your location. The only way to rescue the exception for a single line is to parse each line individually, which is exactly what you are already doing. Either that, or go monkeypatching and earn the eternal hate of anyone maintaining that section of code.
Thanks for taking the time. That's what I figured would be the case. Convenience comes at a cost, after all.
A class or module can have a property (method), so this wouldn't work.
It sounds like you're looking for a CSV library that works like this: https://gist.github.com/dogweather/1479664d12d0c7c27492 describe BetterCsv do it 'has a nice API' do parser = BetterCsv.parse('info.csv', headers: :first_row) parser.each_row do |parse_result| next if parse_result.error? puts "Found the name and phone #: #{parse_result.name}, #{parse_result.telephone}" end end end This should not be hard to make. Just start with that spec, and work top-down writing the library, using CSV to do the work. This would be the _Adapter_ design pattern.
Heh. Should that ever exist, I'll be sure to use it. Though I would change the name. It's bad enough we have FasterCSV clogging up the namespace with its large unanswered question "Faster than *what*"?
Short answer: No Long answer: No.
Load the file (or chunks of it) into memory and preparse it, discarding the rows which cause exceptions? I used to do a lot of this sort of work and sanity checking your data is the only way to go.
Just curious, you say Python is used more for science/math work due to language reasons... what do you mean by that? Obviously momentum is on Python's side in the form of rich libraries and community adoption and support, but it seems like you think it also has some inherent advantage? I've seen arguments that go both ways, but I'm interested to hear more. I've spent a significant amount of time in the past few years doing numerical work in ruby and I've been very frustrated by both the features/behavior and the poor code quality behind the libraries that exist (to the point where I'm considering throwing my own hat into the ring) but I've never felt like ruby couldn't support this sort of work every bit as well as Python, if a little differently. Edit: I have no opinion as to whether ruby is dying or not, though obviously it is not as *trendy* as it used to be.
&gt; Faster interpreter startup time I'm not sure what system / ruby version / etc you're using, but 'irb' on my machine is pretty fast... $ time echo 'exit' | irb Switch to inspect mode. exit echo 'exit' 0.00s user 0.00s system 26% cpu 0.002 total irb 0.36s user 0.05s system 99% cpu 0.419 total $ time echo 'exit' | pry [1] pry(main)&gt; exit echo 'exit' 0.00s user 0.00s system 24% cpu 0.002 total pry 1.18s user 0.13s system 99% cpu 1.316 total The Python REPL is admittedly faster, $ time echo 'exit()' | python echo 'exit()' 0.00s user 0.00s system 26% cpu 0.002 total python 0.01s user 0.01s system 92% cpu 0.019 total But is ~1 second really hurting you? It's not like the REPL start time has any effect on the programs you're writing... just leave pry open and call 'reset' if you have to wipe your locals. Pry is an immeasurably superior REPL to the default Python REPL anyway (although who knows if 'ls variable -mj', syntax highlighting in the REPL, etc matter to people doing scientific computing) Edit: OSX Mavericks, RVM, Ruby 1.9.3 for the benchmarks.
It's still very much alive and well in automation: [Chef](http://getchef.com) and [Puppet](http://puppetlabs.com) for starters.
Why not ruby for concurrency and parallelism?
You can tell a language is being used for boring business-critical applications rather than exciting startups when you begin hearing about how that language is dead.
No real threading and GIL unless you use jruby or rubinious.
**Science/Math computing?** python is the most mainly option, but if you want the bare-metal power, you simply don't use it, because this simple reason compiled languages are always faster than interpreted, Point to C/C++ **Cross platform business apps?** the enterprise world demands Java and .Net because big companies provides some sense of security called 'support', and for the users is more common they have already installed the routines/vm to run the apps Point to Java **Statistical Modeling/Financial Modeling?** nobody cares, if you can calculate faster is better **Blogs/small Web sites?** keep using wordpress, don't waste time of the dev team **Performance Apps?** have you tried Go? and also if your architecture sucks, dont care the language is builded it will sucks no matter what you do. **Wanna be a hipster?** use a mustache **Scripting?** LUA is small, and some game engines use it. Python its good, but also ruby.... perl... well have you ever tried to read perl code? **Browser game/small app?** Javascript bitch! **Concurrency and parallelism work?** hello jruby, rubinious **Teaching?** ruby its more easy to understand than python, but you will have to learn more **Single Page Apps/Web Apps?** single page if you are using, angularjs, backbone or emberjs, I don't care on what is builded the backend web apps.. hail to the Queen Ruby my point is, like it or not, all lenguages are oriented to different proposes and all of them eventually will die, nothing last forever btw... cobol and fortran are still alive and kicking 
I'm about to start a contract job with a startup company that is using Ruby/Rails, my old job is apparently making the switch to Ruby as soon as they get their downtime. I don't think Node.js is ready simply because javascript is that an INCOMPLETE language, and while Python is nice it's most popular web framework has nothing on Rails. I first started using Ruby a few months ago and it's amazing to write programs in, I just wish it was a bit faster.
&gt; Wanna be a hipster? Erlang, Go, Node, Rust, etc . . . This seems like a very balanced analysis
Yeah, that brings back C header-forest memories. RSpec startup *is* slow, but a bit of forward planning gives you other options, like two to three different versions of `spec_helper` that load the bits of Rails you need. *That distinction itself* is intention-revealing. If there's something so obscure in your dependencies that you need to document it that explicitly, I'd argue that you've uncovered a code smell. (And people who've paired with me know that I tend to be forest-for-the-nematodes detail-oriented, so...)
When edge cases overwhelm new practitioners who are trying to find how the community prefers to do things, shark-jumping becomes a real danger.
&gt; Blogs/small Web sites? keep using wordpress, don't waste time of the dev team The hipster store called . . . They said you don't need to be so passive aggressive. Meanwhile, WordPress keeps swallowing the Internet . . . &gt; perl... well have you ever tried to read perl code? Yes . . . actually I have. And I would like to see Ruby have a much broader user-base than PERL someday. &gt; btw... cobol and fortran are still alive and kicking Unfortunately, COBOL is still kicking. FORTRAN should be relegated to critical performance tasks only. What I want to see is Ruby take over for a lot of the existing ugly languages. It would solve a lot of the problems I see in the programming world. Many languages are so ugly, they scare people away and make programming not fun.
We are programmers. We enjoy an astonishing amount of liberty in the tools we use for our jobs–if you can get the job done with it; better, faster, cleaner; you can justify using that tool to whoever you answer to. And there is no community so open or easy to modification as Ruby's. Because of that, Ruby will go wherever you lead her. You have the ability to embrace her beauty now, and lead her along with all of us down new and exciting paths. Now is the time: she's been proven [more modern](http://blog.codinghorror.com/why-ruby/) (point 3) than .NET, [more](https://news.ycombinator.com/item?id=7073316) [mature](http://blog.npmjs.org/post/78085451721/npms-self-signed-certificate-is-no-more#comment-1264682159) than Node, [more expressive](http://www.artima.com/intv/ruby3.html) than Python. ***** **Science/Math computing** Contribute to [sciruby](http://sciruby.com/)! It's going places. **Cross platform business apps** We all know that the web is the future of cross platform compatibility, in ways we cannot even dream yet. **Statistical Modeling/Financial Modeling** Build something with or better than [RinRuby](https://sites.google.com/a/ddahl.org/rinruby-users/). Then show me how! I'm dying to learn R. **Blogs/small Web sites** Wordpress will only finish thrashing in its grave when we make a CMS more convenient. [Pick](http://refinerycms.com/) [one](http://radiantcms.org/), [and](http://www.locomotivecms.com/) [make](https://github.com/twg/comfortable-mexican-sofa) [it](http://www.browsercms.org/) [so](https://github.com/svenfuchs/adva_cms). **Performance Apps** We're talking about the future, and Moore's got our back for a while longer, right? Or are we talking about [mruby](https://github.com/mruby/mruby), built by Matz and sponsored by the Japanese government? **Wanna be a hipster** Hey, that's how we got started, as did all languages. Don't knock it until you've tried it: Erlang, Go, Node, and Rust are all better suited to solve certain problems than Ruby, and always will be. Know your problem domain and tools. Even the woman you love may not be the best company for a horror movie night, don't force it on her. **Scripting** This is Ruby's heritage. Forget what you know about Rails and try to [build your own shell](http://www.jstorimer.com/blogs/workingwithcode/7766107-a-unix-shell-in-ruby); contribute the tools you improve/build back to [Thor](http://whatisthor.com/) or your own project. **Browser game/small app** Seriously, check out [Opal](http://www.opalrb.org). Then imagine a robust Canvas wrapper library in it. The client-side never looked so little like the [dark side](https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0CEsQtwIwBA&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DGH9FAfKG-qY&amp;ei=uwhrU53eIJHZoASjvICoAw&amp;usg=AFQjCNELrDViAPupfkp7fHJXCASX9hX9Xg&amp;bvm=bv.66330100,d.cGU). **Concurrency and parallelism work** Well, [JRuby](http://jruby.org/). **Teaching** If you know your students have the chance of going into programming, why would you teach them [anything but Ruby](https://www.kickstarter.com/projects/lindaliukas/hello-ruby)? Imagine a young C++ student trying to check out the source code for a core library function, then compare that to [Rubinius](http://rubini.us/). **Single Page Apps/Web Apps** This is where Rails dominates. This is where nothing has touched Rails, and it is where most modern frameworks draw their inspiration from today. And yet the ecosystem is rich with [precocious](http://lotusrb.org/) [new](http://www.padrinorb.com/) [frameworks](http://cramp.in/) that are trying to take what we've learned from the experience and innovate. ***** Let's think about this; where can Ruby go? Wherever you want her to. Indulge in the liberties afforded to you, exercise your enthusiasm, and build a more beautiful tomorrow. &gt; – *A love letter from a drunk Rubyist* *P.S.* Claims that [Ruby is dead](http://rubini.us/2013/10/15/introducing-rubinius-x/) have been [greatly](http://www.reddit.com/r/ruby/comments/1oi99k/introducing_rubinius_x/) [exaggerated](http://trevoke.net/blog/2013/11/11/ruby-is-alive-and-well/).
Sorry for the hijack, but I was actually going to post something similar to this earlier. I'm currently automating tests on an iPhone 4S with Calabash. The application that is being tested is a video streaming app. This is what I currently while iterating through each video: Check if the stream fails. If the stream fails, close the failure modal window, log the failure, and return to the iteration loop. If the stream does not fail, check to see if the modal overlay containing the back button is up. It is up for 4 seconds after the video finishes loading. If it isn't, open it by swiping. Hit the back button and return to the iteration loop. The problem that I'm running into is that the load times for movies vary by an extreme amount. Some load in two seconds, and some take as long as 15+ seconds. My program crashes when an element that is being checked for does not exist, e.g. the back button. I'm currently using the unreliable technique of just assigning a 2 second wait time to each step in order to allow elements to load, but this isn't completely crash-proof, especially with the slow-loading movies. I'd like to know what to use for the following: Allowing my program to continue running/recover from an attempt to access an element that hasn't loaded/doesn't exist (continuing on to the next video) Retrying an attempt to access an element immediately after it has failed, and continuing to do so until it succeeds (so that I don't have to set a flat wait time for each video, and the ones that load fast aren't allocated any more time than necessary, while the slow ones get as much time as they need). 
I know code academy, but I was looking for something a little more advanced and thats more in lines with the concepts of programming than Ruby itself. Anyways, thanks!
Thanks, I think I will be completing all the their exercises in Ruby. Wish it was more focussed on Ruby rather than web development. Anyways, thanks!
This has become a personal war between uncle Bob and DHH, using Martin as mediator.
No pointers in ruby. *Sorry* 
Any chance you could let me know how you estimate the Ruby portion? How long do you think an average developer take to finish it?
In our projects we set fake logger just like that: module FakePoltergeistLogger def self.puts(*) end end # spec_helper.rb Capybara.register_driver :poltergeist do |app| # We don't want to see Semantic UI debug messages in the RSpec output Capybara::Poltergeist::Driver.new(app, phantomjs_logger: FakePoltergeistLogger) end 
So use jruby or rubinious. That's like saying "ruby has a GIL except it doesn't". BTW python also has a GIL.
Thank you very much for the idea. I didn't even think of this!
If you want to have no DSL, then Rack is the lowest level layer you can realistically get. It is the interface that all Ruby servers speak. At that level you are working with requests and responses directly. There is almost no framework at that level. You *can* get even lower than that: write your own socket server and parse HTTP yourself.
Perhaps, pretty naive; but I would like to know the possibility of working on Rack for a simple website (lets say simple CRUD, simple page generation etc). I know its possible, but I would like to how hard should I be expecting it would be in terms of having to handle security, authentication etc.
Completely. You can load activesupport's autoloader without loading rails. It incurs a pretty minimal penalty in terms of setup time. Also, I find that folks advocating for "explicit dependencies" are quite often just wanting faster tests.
Yes, looking at it now. Thinking what to choose.
Building a socket server and parsing HTTP is my dream project. Was just looking up to recheck whether I am missing something.
PM sent
Fast *enough* tests *are* a Good Thing; if you don't have them, you're likely to go off on a branch and start hacking away, only to discover afterward that your code no longer works the way you thought it did. 10 metres per second per second can get interesting over, say, a couple of kilometres. But you *do* have source control, don't you? *Groundhog Day* was a good movie, but it leaves something to be desired as a development strategy.
Test First Ruby is pretty good.
Using `argdo` can be a good way to handle these types of replacements within vim.
you can require CGI and HttpServer if you want to wire everything together yourself. depends on your pain tolerance.
Wow, thanks!
I think it means "I haven't tested this on anything except for OSX and I don't plan on it." It sounds like it just uses FFMpeg and ImageMagick so you should be fine.
Yea.
From your link, Ruby is #12, directly beneath Perl and VB.NET. That's not stellar.
I do work remotely. Couldn't be happier.
whats your email contact
"6 Upcoming Ruby Events You Can't Probably Can't Afford Plane Tickets To in 2014"
PM sent. For more you should checkout /r/forhire or /r/railsjobs (assuming it's a rails gig)
I hate seeing code like this, usually because I'm the one who wrote it and should know better. Reversing the responsibilities between the caller and callee is a valid principle but I would argue that this isn't the way to re-factor spaghetti logic like this. Rather than refer to smells, or violation of SOLID principles, here how I would have refactored that with a quick pass: def add_line_item(line_item) update_pricing(line_item, @line_items) @line_items &lt;&lt; line_item if line_item.is_quotable(line_items) end def update_pricing(line_item, line_items) line_item.apply_discounts(line_items, DiscountRate.get_rate ) line_item.update_website_price(line_items) end # line_item... def is_quotable(line_items) line_items.select { |item| item.kind_of?(Website) }.length == 0 || kind_of?(Ad) end Most other method implementations should be obvious from their names. Clear separation of responsibilities at the class and method level, simple short methods that make sense in the business context and can be documented as such. And no magic numbers! 
\&gt;In America, Singapore and Israel are in Europe
what happened in 2012??
i dont like this, why not a service object ?
SICP is an amazing book for better understanding programming as a whole. Well worth a read. 
RubyMotion is doing amazing things with Ruby, by giving it Objective-C speeds to yummy Ruby syntax.
I always say, if there isn't an AST, it's not a "real" DSL.
Rails routing isn't directory based. Look into the routing guide http://guides.rubyonrails.org/routing.html#nested-resources Specifically nested routes or scoped routes.
thanks, have been looking into it for sometime.
Thanks, thats a great resource. I will probably start with it!
This was helpful. http://code.tutsplus.com/series/ruby-for-newbies--net-18166
This is kind of fun! Here's how I solved it: http://exercism.io/submissions/9714ea0e0e2c2c29565e2338
I enjoy seeing different solutions to the same problem. I intentionally did not look at anyone else's solution until I finished my own. I think that everyone can learn a lot from just seeing different implementations and wondering why things are done a certain way.
Thank goodness! I was so tired of compile errors when installing Ruby due to the readline crap. Hope that's what this [bug](https://bugs.ruby-lang.org/issues/9578) means. edit: disclaimer: I am new to Ruby so everything is a pain right now.
"Can't miss"? Really? I live in London, quite close to some of those. If I were to book tickets for all of them now, I'd need to do this: * €410 for La Conf (last few remaining) * $265 for RedDot (Early Bird II) * ? for EuroCamp - no pricing/tickets available yet * €250 for BaRuCo * €199 for ArrrrCamp * 400.0 ₪ for Rails Israel So I've now spent the equivalent of $1600 on tickets. Travel is going to cost me around £1,200 if I'm really savvy (Paris and Berlin I can do by train), so there's another $2k, we're up to $3.5k now. Then, I need to think about accommodation. Realistically, including food, if I slummed it a bit I could probably do the lot for about $2k, so we're at $5k total. I then go and sit down with my girlfriend and explain I've spent $5k on visiting six countries this summer. She isn't coming by the way, so I'll be on the road a fair bit at the end of May, again at the end of June, I'll be in Berlin for my birthday in August, Barcelona in mid-September, Ghent in October, and Israel for what in the UK is known as "fireworks night" in November. She argues with me and insists on visiting at least 2-3 of these places with me, pushing out my flight and accommodation budget some more. There is no way on earth we are going to get away with just one night of conf either, and a romantic meal will be needed in each, plus some sight-seeing - in fact, she's right, RedDot and Rails Israel are far enough away we should spend a week in each location. So I'm now looking at around $8k-$10k in spend. Maybe more. Also, my boss is really, really angry because I'm having to book out long weekends throughout the year. I also realise this means I won't get a proper holiday this year that isn't related to one of these confs - I'll be too busy going to Ruby conferences. If I were contracting, I'm not sure when exactly I'd get any real work done - I'd spend most of the year either preparing to go to a conf, or recovering from a long trip away. So by attending these "can't miss" events, I'm broke, damaged my relationship with my girlfriend, ruined my work/life balance, removed a proper holiday from my schedule and left me wondering why I didn't just stay at home and look out for good videos of talks after they were delivered. I know this is a facetious argument I'm making, but whilst it's good to highlight the many conferences - some of which we might not have heard about - it would have perhaps made sense to discuss the good bits of each and why I should choose one over another. Conferences are good. Everybody should try and do one a year to get a sense of the community and to socialise with peers. But they are never, ever, ever "can't miss" events.
I also can't install Ruby... There are always two compile errors, one is fixed by adding an include in one file, the other is fixed by adding two defines in another file. This is the case since a year or so. If I fix those two issues, Ruby compiles, but is failing to configure the `io/console` and the ssh or ssl module. Why? No idea. I can't even start `gem` with that installation. Google doesn't help either. The only way to install Ruby on my OSX machine for me is to install Ruby Version Manager. So frustrating. 
And why do you want to compile it yourself and not to use RVM or rbenv?
Because I don't need to manage multiple versions and I like having all my binaries in `/usr/local/bin`. 
and also it can take a day or two for RVM to be updated when a new ruby is released.
I tend to wait a bit before adopting fresh version, usually there is a list of know issues after few days. I work on many big apps on different ruby versions so I might be biased.
Oh, cool. This is a lazy question, what's the syntax for using rvm to install 2.1.2, if its not known? Thanks
Just the other day I built from the git 2.1 branch to solve this compile issue, so yes, it should be fixed (although it hasn't been fully back-ported).
I used "rvm upgrade 2.1.1 2.1.2" and it worked without a problem.
This kind of stuff is neat but I'm always surprised that people have enough spare time for wacky projects like this.
is it any different than testing in ruby &lt; 2.0+? are you wondering which libraries to get started with? or what makes a good test? this is a terrible broad question.
That's cool, not a criticism. I just don't have a lot of free time. :)
I guess i am looking for examples and which libraries to get started with.
Rspec, minitest, or test-unit There's a plethora of available sources if you just Google one of those library names. 
No, it's not, at all.
The correct link is [here](https://plus.google.com/events/ci2g23mk0lh9too9bgbp3rbut0k)
I'm not a fan of the title either, but the actual conversation is important and not hyperbolic
I think DHH is responding to a much more extreme view of TDD that is pushed very hard in some circles. You can see an example of what I'm talking about [here](https://www.youtube.com/watch?v=WpkDN78P884&amp;feature=youtu.be&amp;t=58m). It should jump to the 58 minute mark, if not what I'm talking about starts there. 
It's quite easy with RVM / Rspec... (assume 'ClassUnderTest' is the actual name of whatever class you're testing) require_relative '../path/to/class_under_test' describe ClassUnderTest do before(:each) { @cut = ClassUnderTest.new } # setup goes here it 'has the following instance behavior' do @cut.sample_method(5).should eq(25) # or whatever the expected outcome is end end Name the file 'class_under_test_spec.rb' and stick it in a folder called spec. Then from the root directory, run rspec spec And there you go! The rspec docs are [here](https://github.com/rspec/rspec-core).
no
I made one to practice parser expression grammar about a year ago: https://github.com/RyanScottLewis/brainfucktt Not a compiler, though. Very cool!
than why did you use a hyperbolic posting title? You could have said "I think TDD is/not a viable practice because of X". I'm not even going to read your article with such an annoying headline.
I made one to practice parser expression gramm**e**r about a year ago: https://github.com/RyanScottLewis/brainfucktt Not a compiler, though. Very cool! **FTFY**
We can always rely on you for good-natured humor :)
&gt; I'm not even going to read your article with such an annoying headline. You should. You'll be in for a surprise.
Nice!
Think of a problem that can be solved by software for a client - perhaps yourself, friends or family. Adopt that problem as a project. Make small, incremental steps towards implementing that project. Rely heavily on documentation and research best practice and appropriate patterns for the classes you are developing. If part of the project isn't working out re-factor until it does. Present product to the client and be motivated. Works for me! Also look for Ruby podcasts/maybe join a related IRC channel or post to forums. Being part of the community associated with the tools I'm using helps spur me on.
What are you using ruby for? Have you made anything with it other than test code? The best thing that keeps me programming is sweet sweet accomplishment. When something is complete and I will use it myself, or build on top of it for other projects. Using a programming language just for the sake of using it I imagine could get pretty drab. 
Totally. Learning a language absent a project always leads to stalling/boredom.
TDD is good, but requires more common sense that we thought initially.
Start solving [these](https://projecteuler.net/problems)
What's the best site for best practice and patterns?
Look into Ruby Cookbook it shows a lot of different implementations that you can find useful and then try to build something.
Hi, fellow Rubyist here. I've been in a few Ruby and Rails projects (by which I mean, Ruby on Rails and pure Ruby projects). You can say I'm one of those TDD lovers. Pretty much all of my projects were based upon TDD. My biggest recomendation is Everyday Rails Spec. That book teaches you pretty much everything you need to know and with fairly good examples. My personal recommendation. You can also find pretty good books on Cucumber, although I can't recommend much of that. Also, I'd recommend to avoid Test::Unit. With great alternatives like RSpec and Cucumber, do yourself a favor and keep yourself out of that. Cheers.
Hi, fellow rubyist here. rubymonk.com is where I learned my stuff. It covers pretty cool topics beyond the syntax, teaching you how Ruby works and even giving a go at metaprogramming. All with exercises, do you don't get bored reading. RubyKoans is also pretty cool but if you actually like to read, take a look at Why's (poignant) Guide To Ruby. You'll laugh your pants off and learn a lot. Also, Why is a very important part of the Ruby community itself and that is just a bit of the (huge) legacy he left us. It's a must-read for the community itself, even if you already know Ruby (my case when I read it). Cheers 
Being excited about development has little to do with the tools you're using, but is more about the problems you're solving with those tools.
That would make a great [@tenderlove](http://twitter.com/tenderlove) pun.
Now, you know that in Ruby, like most OO languages, the dot has a very special meaning. While imperative languages, like C, use f(x), the OO equivalent is x.f(). This may seem trivial (and it is) but have you ever thought about its syntactic meaning? In fact, f(x) is a much more mathematical approach of viewing this. Transforming a value x through a function f. OO thinks more of "transforming a collection of values/changing the state of an object x through a method f". This means the dot has to imply comunication. Now, for :: there is actually no communication at all. Only specification. For instance, imagine you had the following: Module MyModule class File def self.open(filename) puts "Openned it" end end end If you tried to run File.open("passwords.txt") you would actually get the default File class. This being because you would be communicating with a class (File) and causing its class method to run (open) and may even change something in the class itself (and certainly in your programs state. The program state is never the same after a function is called. Even though values may not have been changed, there are always function calls and memory changes under the hood). If you wanted your class method, you would have to specify the namespace. MyModule::File.open("passwords.txt") This actually has no communication at all, you're not altering any values in the module because, as we know, it's just a set of classes. Then why the need for modules? Pretty much, compiler (*e.g.* C++) or interpreter (*e.g.* Ruby) sanity. That way the compiler knows what function do call an you may have classes with the same name and everyone is happy. Finally, you ask "Put that aside. Could've Matz done it with the dot?". Probably yes. Even though the dot has a special meaning and functionality, let's imagine it was possible to overcome the limitations. Would Mat have done it? Probably no. Let's face it. Ruby is a language for humans. Readability is actually a big and important issue. It's much more easier to distinguish Module::Class.ClassMethod than Module.Class.ClassMethod. It's even easier for the interpreter. tl;dr: . implies changes in the global state of the program, :: specifies a module/namespace, it does not certainly imply any changes, it's pretty much for human and interpreter sanity and functionality.
Sourcemaking.com for refactoring. But most stuff is in books, not sites. * Refactoring by Martin Fowler * Confident Ruby by Avdi Grimm * Practical Object Oriented Design in Ruby by Sandi Metz * Patterns of Enterprise Application Architecture by Martin Fowler * Head First Design Patterns * Refactoring to Patterns by Joshua Kerievsky * Working Effectively with Legacy Code by Michael Feathers * Growing Object Oriented Software Guided by Tests by Steve Freeman &amp; Nat Pryce * Domain Driven Design by Eric Evans That said the blogs of Avdi Grimm, thoughbot, and codeclimate are great resources. 
Not 100% Ruby, but The Changelog is good. It's basically the unofficial GitHub podcast.
Stop learning how to code. Feed a passion for creating, which requires knowledge of coding.
What books have you been reading? I recommend Michael Hartl's Ruby on Rails Tutorial if you can't been through it yet. It's available [online for no cost](http://www.railstutorial.org) and it walks you through building a complete authentication system and basic Twitter clone from scratch. It was definitely the most helpful Ruby on Rails guide I've gone through. I've done all of the Codecademy/Codeschool type tutorials which was good for learning syntax but not necessarily for putting that syntax into context and explaining *why* I'm writing that specific code. Knowing I was building an actual, working app from start to finish definitely kept my interest much more than writing thirty different variants of a while loop. Finally I'd recommend coming up with an idea for a side project that will keep your interest for a while -- then just dig in. I took the authentication system and a few other code samples I made while going through the tutorial and now use it as a framework for a side project I'm working on. I think the most important way to keep your enthusiasm and energy up is to find something you're passionate about and build an app related to it. And lots of coffee helps, too. Anyways, good luck.
http://javascriptjabber.com/
Cool, thanks! Have come the same path :) .. Yet to ready _why though :(. I was kind of looking something like a listing/syllabus/curriculum sort of thing that enumerates the core topics so, I can skim over and head to what I need to learn.
also 5by5 has restarted the Ruby On Rails podcast [http://5by5.tv/rubyonrails](http://5by5.tv/rubyonrails), check it out
Ruby Rogues - though I like the unintentional typo being essentially "red red" :-D 
The sound quality is so incredibly shitty I couldn't do it.
The core Ruby team's nomenclature is known for being inaccurate. Cf. semantic versioning.
You should take a look at the metasm project, you could do it all in pure ruby, and support Windows as well. You might even get 64 bit support easily
Thanks, will definitely check it.
The thing about Ruby is that it is very difficult to list the core topics because there aren't that much. Everything is core and is a bridge to advanced topics. Have you tried Eloquent Ruby? It's still not the sort of thing you're looking for but it covers the core and has its fair share of advanced topics that are important in the "Ruby Way". Besides teaching Ruby, it also teaches how to write good Ruby.
They had Postmodern (creator of useful ruby tools: chruby etc.) on an episode recently.
As someone who has worked with Ruby for ten years and has read a whole lot of ruby code written by other people, these style guides get filed into my "who gives a shit" box. By and large the Ruby community uses all sorts of different styles so you might as well get used to them, and no the world wouldn't be better if everyone used the same style. Adhering to these style guides is not going to make you write better ruby code, so don't stress about them, there's more important things to worry about. Go learn something germane to Ruby like how "ghost classes" work rather than spend your Saturday on pedantic shit that doesn't matter.
We based our style guide on this in my office, with some modification. Right off the top, the 80 column limit is ridiculous. It is a holdover from the punch card days. It still made some sense when monitors still had low resolution. However, today it just makes no sense... Especially as people these days advocate for more descriptive variable, class and function names, you can quickly find that 80 column limit frustrating. However, we do recognize that some constraints are necessary, and complex, long one liners can be hard to follow. We changed that spec to 160 columns. At that length, it still encourages you to keep your lines a reasonable length, and fits in github's view port comfortably. Additionally, it conserves vertical real estate nicely, so you can keep more code your screen. 
Point of that style guide is not that all ruby code in the world should be written in that style. It's just a style guide that Github uses in their projects. I agree that it is pointless to try to define style guide that suites everyone everywhere. However it is a good idea that in a project there is an agreement on the style code is written. This makes it easier to understand the code base and it saves time as you don't have to discuss style issues in every code review. This guide can be a good starting point that can be changed to suite preferences in your project.
Thanks, have that book. Yet to start.
Does anyone know of a good podcast manager that would make it easy to download/listen to these podcasts on an Android phone?
I use [pocket casts](https://play.google.com/store/apps/details?id=au.com.shiftyjelly.pocketcasts) and love it. 
&gt; It's an entirely new way to use Ruby. What do you mean by that? :)
yeah, the thing about style guides isn't that it matters what's in the style guide, it's that you have chosen and stick to a style guide in your team at all. it's about reducing cognitive overhead when reading code, and that you don't get into pedantic arguments in the future during code reviews etc.
Another ruby is dead submission? Please give me a break...
I just install rubocop (and other style checkers/linters) as part of my CI process. it takes a few minutes to set up and allows me to enforce some kind of homogeny across large codebases with multiple contributors.
You can build websites with it. Not just static websites, but web apps. Moving, breathing, living visuals. You could build a facebook with it, a youtube. The entire internet is possible with rails. To begin: http://guides.rubyonrails.org/
Yes, rubocop is great. Always have it in my Guardfile guard :rubocop do watch(%r{.+\.rb$}) watch(%r{(?:.+/)?\.rubocop\.yml$}) { |m| File.dirname(m[0]) } end
Ah I see, well it blew my mind when I first started using it, but then I had no experience with anything in that region before that =)
I personally write my code with less than 80 characters for each line (100 characters max). I don't enforce this rule in my team, this is just my personnal style. And I know that this is a holdover from the punch card days, however now it's been reconverted to something different: an indication about clarity. First, Ruby is so terse that even without paying attention lines are less than 80-100 lines. Second, if I end up with a 80-120 characters line, it's usually a sign that I need to extract something out, or the idea I'm expressing is too fuzzy and it needs rethinking/refactoring. Lastly, as a bonus side effect, you can have a dual screen code/spec on a 13" laptop and see almost everything (but really this is not the reason I do this). I've seen some truly amazing code by experienced developers, with lines less than 80 characters and methods less than 10 lines. And it reads like a breeze, truly inspiring. I'm not at that level yet, but most of my methods are less than 15 lines.
I usually listen to all of them at 1.5x speed (all podcasts), sometimes if they are a fast talker I have to slow down, but for 99% that's a good compromise, and I often don't listen to them in one sitting. Just find ones you enjoy and listen, if you don't have time for some of them, then skip them. Personally I like the longer ones for my commutes.
I use podcast addict
Nice, no more ads!!
I put the dots at the start of the line so it's clear it's a method call.
Well damn. I didn't know that was valid syntax. Thanks for the tip!
If you like the Python blog post and want to learn programming, you might as well follow that post. Once you get the foundations down, adopting Ruby will be easy.
*ACKSHULLY* it's a 79 column limit for printable characters. *Guhoy*.
Is Arango just a renamed clone of Mongo?
On projects with a lot of people and code review requirements, static analyzers make life bearable.
Why shouldn't they want to? There's probably hundreds of reasons someone would want to build from source. Most of them are even valid. 
&gt;`Use hashrocket syntax for Hash literals instead of the JSON style introduced in 1.9.` I don't agree with this. The new syntax has less line noise and almost always looks aesthetically better and cleaner.
It sounds to me like you need a mentor to push you in directions you haven't thought of, or don't have the time to think of. feel free to contact me (thatrubylove) gmail https://codementor.io/thatrubylove https://www.bloc.io/mentors/james-okelly/edit
&gt; However, today it just makes no sense Its still VERY relevant. On a 1080p screen the 80 column rule allows for 3 documents in a standard font size to be fully visible in vim;or for two with a separate window for whatever. 160 columns sounds....ill-considered I have to say.
They have a Bitcoin donation address on the homepage.
The barrier to entry for viewing an add is much lower than obtaining and giving away bitcoins.
Rarely have I wanted to have more then two documents in front of me. I use sublime for my editor, and our column limit fits two docs easily. If I need another document... Well I have two more monitors, and can just open another editor instance. 
I'm surprised how much I like the new syntax. I thought I'd hate it.
the example you have would be almost the same for minitest, no? if we are testing simple ruby apps or Sinatra apps, what does rspec offer over minitest? 
Seconded, Ben Orenstein does great interviews.
Instead of complaining about a free show, how about offering some advice to them about improving their sound quality? Better yet, fund the show in any way you can so they can justify buying better equipment?
Cool. Thanks for posting this. Code was very readable, I had a good time going through it. It's interesting to see how one might go about building a web crawler in Ruby.
I admit it looks a little odd when the key and value are both symbols, but syntax highlighting improves that quite a bit. Plus, a lot of the time my values are not symbols, and in those cases the new syntax looks way better.
I don't think the author knows what "fork" means. 
Instead of bitching at me, how about assuming good faith - that I've given advice and feedback to them? I help fund podcasts and screencast series that get it right - thanks!
Is this a really badly done job of satire?
I think it is satire.
&gt;JRuby lacks green threads, so it has a higher carbon footprint than the alternatives. Clearly a serious article. Some of you people are daft.
I don't understand all the downvotes. While completely worthless, I thought this article was hilarious.
Those aren't forks, they're spoons!
beautifully done example. wish I'd read something this simple when I first started with Ruby. 
I think "DSL" as used in ruby is just a fancy word for "API". (If you don't think so, please explain the difference!) So the only way to be using none of anybody elses API at all, I guess, is to use no libraries or gems at all. (Even stdlib `CGI` has an API, doesn't it?) So what are you really looking for? What is it about 'DSL' that you don't like or want to avoid? You certainly _could_ write a web app using no gems related to http at all. (It would be easier if you are writing a CGI app that's gonna be served by apache httpd or something else that respects the simple CGI interface. Writing your own http server could be done, but there's probably no reason to re-invent this except self-education). But why would you want to? 
Well I feel API and DSL is quite different in terms of the way its used. DSL seems to geared towards sugar coating an API, if you will. I feel working with an API gets you a closer interface with the gem. But working with the DSL seems like working with a new paradigm all together in some cases. DSL feels like a fancy language and often is inconsistent with the rest of the language in attempts to make it seem natural to English. Which I understand will look easy for beginners, and certainly shaves of the entry barrier to use it. But I wish to work with standards following APIs that might require me to go through their docs but will still will look like native Ruby.
I don't think the author bothered to research squat. &gt; PHP started out as a joint effort by Facebook and Wordpress to make Ruby less pleasant to use, in a bid to discourage those using “view-source” in their browsers from stealing corporate secrets. Unless the entire article is a deliberate troll, in which case, well played! But somehow the voice I heard in the back of my mind while reading this was chanting "ha ha, only serious".
With emphasis on *really badly done*, possibly.
I think the rule should be to use hash rocket syntax for any hash that intermixes symbols with non-symbols, and new syntax where all the keys are symbols. I don't think it's that weird to see: def some_thing a = { one: 2, three: 4 } b = { "Content-Type" =&gt; "text/json", "Content-Length" =&gt; 45 } c = { Dir.new("/") =&gt; true, :name =&gt; "Fred" } in the same file or method.
Well you can do something like: { a: 5, "b" =&gt; 6 } My point was that in a case where you must use even one hash rocket, you should use hash rockets for everything in the hash { :a =&gt; 5, "b" =&gt; 6 }
I rather enjoyed the closing quip for Opal, hehe.
what's with the blank line at the end of the file thing? there must be a reason, everything else in the guide is designed to thwart unnecessary whitespace.. 
This reads more like a markov text generation result than anything else.
Same here. This is [uncyclopedia](http://uncyclopedia.wikia.com/wiki/UnNews:Nigerian_micro-cap_plans_IPO)-worthy.
Medium just posts some of the most ignorant articles for any topic. 
I wouldn't be surprised if medium.com actually just scraped the internet for various topics and made them using a bot. They do it for science articles too.
Or run [codesake-dawn](https://rubygems.org/gems/codesake-dawn) that is standalone, not linked to ruby-advisory-db and frequently updated
&gt;If you want to make a counter-argument then make one. If you are bored of the whole thing then just move on I already made my argument. You have no idea of what you are talking about. &gt; Same with statements like "ruby has a GIL". No only stupid people like you who are not aware of all the ruby implementations. &gt;Unless made clear like "JRuby had X" people will assume MRI Jruby is ruby. Rubinious is ruby. 
Practical route: come up with a project that's just a little bit bigger than you think you can handle, and write it. Pick up books/articles on refactoring and go through what you have produced. Look for code smells, figure out where they are in your Ruby. If you can't think of a project, find a Ruby project you like and start looking at issues and providing patches - collaborate, and learn. Or alternatively, go and do [Ruby Quiz](http://rubyquiz.com/) in order - do all 156 and understand the answers given, you'll be in the upper few percent skillset wise. Academic route: pick up the [Metaprogramming Ruby](http://pragprog.com/book/ppmetr/metaprogramming-ruby) book and you'll suddenly start to understand the internal mechanics of Ruby. Start reading through the more [heavyweight tomes](http://refactoring.com/) that you'll find useful. Maybe do the [Koans](http://rubykoans.com/), which aren't as practical (or as fun) as Ruby quiz, but will make sure your core strengths and understanding is all there. It's Ruby, you get to choose your own adventure! I'd do a little of both. Certainly knowing how Ruby works under the hood has helped me plenty, but I would never have got as far as I did if it weren't for plenty of projects. Remember though, this is meant to be fun, so if it's feeling boring you're not doing it right. Good luck!
If there's one thing Project Euler has taught me, it's that my first solution to any problem can *probably* be made exponentially faster through recursion.
No, it's an interesting noSQL DB though. It's a bit of a mixed bag in some ways - it's a graphing DB... and a document store... and a key value store. Maybe not as fast as some other noSQL DBs, but it covers more bases.
Liked this post. A reminder (like we need reminders at the moment) that TDD is primarily a *design* tool. 
Here's the x-post link for your convenience. x-posted to [/r/programming](http://reddit.com/r/programming). ____ this was posted by a bot currently in development. Please send a message direct with suggestions. 
503
I can't think of any reason I'd want to force an editor to be a half-assed IDE when there are so many IDEs available which already do the job just fine.
Personally, I prefer TPope's method in [Effortless Ctags with Git](http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html).
Is this a troll? Or are you honestly saying that a shitty IDE which almost never supports what you need is comparable to VIM?
I saw two when I searched, fyi - _Build Phase_, and _Giant Robots Smashing into Other Robots_
How do you send events to the state machine? I'm pretty familiar with FSMs, but not the "state pattern."
So you want an api with less 'magic', more just plain ruby methods. But Sinatra still too much 'magic' for you, you want something even lower level?
I've been doing this for a couple of years. It's great.
Check the logs?
It's telling me that I need to install tzinfo-data but I already have and it's still not working. How do I access the Gemfile so I can update it?
Put the output of the rails s command on a gist or something along with the log and information like what OS you are using.
&gt; First, what's up with the `**headers` argument? `**headers` is a keywords-splat, which will grab all extra keyword arguments into a Hash, just like `*` (the normal splat) grabs all extra positional arguments into an Array: def test_args( pos_obligatory, pos_optional=2, *pos_rest, kw_obligatory:, kw_optional: 5, **kw_rest) puts "pos_rest = #{pos_rest.inspect}" puts "kw_rest = #{kw_rest.inspect}" end test_args(1, 2, 3, kw_obligatory: 4, kw_extra: 6) # =&gt; pos_rest = [3] # =&gt; kw_rest = {:kw_extra=&gt;6} Thus, `do_request` is intended to be called like this: do_request('GET', '/foo/bar', 'body', :'Content-Type' =&gt; 'text/plain', :'Content-Length' =&gt; 4) and `headers` would then be {:"Content-Type"=&gt;"text/plain", :"Content-Length"=&gt;4} &gt; Also, if I'm reading this right, does this allow you to pass a method to a another as an argument? Not quite. `def` has been changed so that it returns the symbol of the defined method's name (whereas it was `nil` before): def foo end # =&gt; :foo and `private` can take a symbol for an argument: private :foo What you see here simply combines these two steps. It is not passing the method as such, only its name.
Ah, windows I assume you have added the line gem 'tzinfo-data' to your project7s Gemfile and bundle installed right? Apart from that, cannot help. On sidenote: When people who do webdev say "gist" something they almost always mean pasting it here https://gist.github.com/ then copying the link.
I'm new to this whole thing, thanks for the help! Could you tell me how to add that line to the right Gemfile? and ohh okay now I know about gist, thanks.
It is the Gemfile in your rails project (Literally called Gemfile). use whatever text editor you want. You will also want to read this: http://www.railstutorial.org/book Also consider this a taste of the pain that you will be letting yourself in for by using windows for ruby development and consider creating an Ubuntu Linux Virtual Machine (Using the virtualbox software) for learning ruby. 
Exactly, I sort of hate magic totally. Wish there was something thats purely 100% Ruby code.
I mean, the thing is, it's _all_ 100% ruby code.. what else is there? It's all calling methods on (sending messages to) objects. What else is there in ruby? Nothing. But, yeah, some libraries use too much abstraction, are too over-engineered -- to make the method calls as 'simple' as possible for the expected use cases, but at the cost of obscuring what's really going on under the hood (usually by using too many layers of intermediate objects that you aren't supposed to need to know about). That's, I think, what we mean by 'too much magic'. I agree that this is a problem in the ruby community, although I think maybe not as much as it used to be. But I don't think there's any clear line between "DSL" and "API", between "purely 100% ruby code" and... um, I don't even know what. It's all just ruby code, that's all there is -- I mean, i suppose one _could_ write a ruby program that actually parsed some other toy langauge invented for the purpose of config files or whatever, but that's not actually what most people writing "DSL"s are doing. Those "too much magic" ruby "DSLs" are still just calling methods on ruby objects. It's a continuum of how much abstraction there is, or how close to "what's really going on" you are. But if you take too far down to "no abstraction, really close to the metal", then you're writing an http server yourself using TCP socket primitives just to have a web app -- and I suspect you aren't really interested in going there, or if you are it's just as a learning exersize not because you believe it's actually the best way to write web apps. People like Sinatra for being more transparent than Rails. I assume you have looked at it and still found too much abstraction for your tastes? 
&gt; if r.url.include?('imgur') **&amp;&amp;** !@downloaded.include?(r.url) This what you want. Cool script
Redirects to this for me. http://search.charter.net/index.php?origURL=http%3A//www.jellyblub.com/&amp;r=http%3A//www.reddit.com/r/ruby/comments/25fa20/just_deployed_my_app_on_digital_ocean_still_in/
Hm me too, weird. When I type it in it works fine ??? What the hell???
Why not cron it instead rather than have the process live for so long? Is there a reason why the API isn't just initialized in the class init? I've not used that gem but unless there is a reason otherwise if you're going to loop it you might as well just create it once instead of re-creating it at each loop. Personally I'd also use command-line args for the background target location (along with some simple validation) to make it friendlier to use. Before line 54: bg_file = ARGV[0] if File.writable?("ARGV[0]") raise 'Background file target is not writable' unless bg_file Then line 54 becomes downloader = RedditWallpaper.new 'earthPorn', bg_file This could be taken further to incorporate further args to allow the user to specify the subreddit(s) they want at runtime rather than that being static as well. Validation could be as simple as foo.is_a? String or it could go so far as to validate that the subreddit actually exists.
Added CNAME record, good to go. I think that ruined me :(
attach_file looks for the the label value associated with the file_input element under the hood it calls find(:file_field, locator, options).set(path) Is the "bring up a file browser" a modal triggered by JavaScript? have you considered using pry to pause and debug at the point the file browser is loaded? I have attach_file working in several situations, it generally took some tweaking to get it working smoothly. 
[**@blader**](https://twitter.com/blader): &gt;[2014-05-13 06:36:24 UTC](https://twitter.com/blader/status/466104655693352961) &gt;If it's easier to raise than to hire, it might be a bubble. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/25fu5x%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Ah god. I figured it out.... The element was not visible so I set visible: false and it worked.. hahaha.
I'd give my left arm to be able to find a decent Ruby/Rails developer in the South of England at the moment. So I'm going to go with yes.
Nobody even knows what Ruby is in Spain. It's C++, PHP, or gtfo.
what's the unemployment rate in spain these days? you'd think some people would retrain for skills relevant to this decade. 
I think decent is the key word here. I'm drowning in resumes from people who just spent ten k on a rails bootcamp with no understanding of fundamental data structures.
I'm a young ruby/rails/webdev programmer who moved to London a few weeks ago, currently freelancing - if you've got an interesting project, give me a bell at rubydev@simonwoolf.net ([site](http://simonwoolf.net) · [CV](https://github.com/SimonWoolf/CV)) :)
That is a most idiotic statement. I have had a hard time finding someone that can code themselves out of a box. It does not matter the language. The problem here is not that we are in a hiring bubble, it is that people have been leaving the tech field to go into areas where they do not have to work 60 hr work weeks. After the crash in 2000/2001, I had a number of friends leave the field. Then there is also the point, that people want to use technology, not control it. The increase in need for bright software and infrastructure engnineers has increased, but the output from schools has not kept up. In addition, wages have been stagnant. Not just in the tech field, but across the board. But when the wages for an indemand skill pay the same as 10 years ago, you will have a hard time finding people. Blame greed, blame what you will. So, don't base a bubble on being able to find people.
Just ride it for all it's worth.
Neat little script. I gemified the code and made a few modifications so it also works on OS X: Source: https://github.com/jordanbyron/reddit_wallpaper Gem: https://rubygems.org/gems/reddit_wallpaper 
The problem is the salaries though. The average of £40-£45K (edit: in London) for a mid-level dev is probably about 10K short of what it needs to be to compete *internationally*.
The demand for programmers is industry wide, precisely because of how hard it is to train new folks (not everyone can do it).
It's somewhere between "very high" and "what's this 'job' thing you keep talking about?".
I know your probably busy but do you know of any free courses via coursera, EDX, udemy that you would recommend someone should take to learn fundamental data structures?
As someone who recently took a job teaching one of those bootcamps, why do you need a junior dev to have an understanding of fundamental data structures? In my experience as a dev, that understanding comes in handy ... Later on, when you're a more experienced dev and working on more advanced problems. Mind you: I think they're really important to understand. I have a CS degree; I'm convinced by default. I've also worked with a fair amount of junior devs, and I think that's something they can learn over time.
Thank you!
maybe the word bubble could be more attributed less to jobs disappearing and more intern/jr type jobs appearing. I was not in the industry 10 years ago or during 2000/2001 but I find it hard to believe that wages have been stagnant, with 120k-180k and rising salary in san fran. Greed is a good thing to blame, but it has created a wave of bootcamps to train new people in hopes to make up for the low output from schools. This will cause the salaries to eventually come down.
That's why I only will be a contractor unless the company has a decent track record of typical 40 hr work weeks. If I work more than 40? Great, my pocket book at least gets compensated and it probably will pay for a nice vacation for myself and my family with 0 loss of income.
I think it's dependent on the work enviroment. If you are at a place where everything is code reviewed and the junior dev has a good amount of access to somebody more knowledgeable, then it will work. The problem is when you are at a place that doesn't have that kind of culture or resources. You get somebody who does something silly like recreating a new hash for each row of the return query. And well it works, but only until a certain point. I actually think what is missing is not actually the data structure course, it's all the experience you gain from having to implement these data strucutres. And to know what data structures are out there so that you can frame a problem correctly. I volunteer with a local org tutoring intro to programming and the importance of data structures has been a constant argument. 
Where are all these junior type jobs you speak of? I would love to transition to a web development career, but everything in Phoenix, AZ wants 3 years experience. I'm stuck in a hard place of not having enough experience to get a job, but not enough time to develop on my own between work/family obligations. It's very frustrating.
That's good they do that. Let's face it, it doesn't take long, of someone doing 50-60 hours per week knowing they're actually REALLY making 25-50% less money than they should be for the time they're putting in.
[Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby] (http://www.brpreiss.com/books/opus8/html/book.html)
It's pretty much the same as in any other field that is having staffing problems. It boils down to "This is bullshit, why can I not find a single talented senior developer for $40k/year with bad benefits and no work/life balance?!?!?!" People are largely convinced that the market is tapped rather than considering that their offer is not attractive.
- That font...I can hardly read it! - You ask for a username and then require the email to login! - What does everything do...streams and streamers? The site desperately needs mouse overs since much of the iconography and naming conventions are unintuitive (to me at least). I'm not intending to be unkind with the above comments. May I suggest that you do some basic usability reviewing of it - ask friends and family to look at it, use services such as feedbackarmy, etc; since at the moment its obviously early stages from the UX perspective.
If you can program, apply anyways - worst comes to worst you flunk an interview :).
Well maybe you should look for someone who is willing to work remotely. After all IT is one of the few industries where this in fact is possible yet so many employers are easy to say "nooo I need my developers to sit in my office at least 8 hours a day 5 days a week" ... simply can't wrap my head around that.
[Cuba](https://github.com/soveran/cuba#readme), [Scorched](https://github.com/Wardrop/Scorched#readme) and [Ramaze](https://github.com/ramaze/ramaze#readme) are other nice Rack options to explore. [Hobbit](https://github.com/patriciomacadden/hobbit#readme) is another new one that is truly minimalist and encourages you to use Rack and be explicit. [Camping](https://github.com/camping/camping#readme) is one of _why's project that is fun to take a look at and has the self-imposed constraint of being less than 4kb. [NYNY](https://github.com/alisnic/nyny#readme) is a micro-Sinatra, that you can upgrade to full Sinatra if you need growing room. And for a non-Rack option :O, there's [Lattice](https://github.com/celluloid/lattice#readme) which is an actor based solution using Celluloid::IO and a port of Erlang's webmachine. It's not finished and is bleeding edge but another one to keep on the radar.
It's a regional issue. In Toronto dev boot camps are churning out more juniour rails people than the market can absorb. Senior rails devs are still hard to find.
I work as a freelancer and have for years. If you're having a hard time hiring, what's a good way to state a mutually beneficial value proposition?
I've gone on 2 interviews in the last 6 months and both places wanted more experience. I see nothing here for junior level devs.
I've needed to work remotely quite a few times (including currently right now) and while it can work, I feel comfortable saying that it is categorically inferior to working onsite when it comes to productivity. Remote work is fundamentally a compromise no matter how many times GitHub says "It's super great and you should try it!"
I'm going to be honest, one of my favorite phone screen weeding out questions is "What code do you write on your spare time and why?" If the answer is "I don't" that's an easy "no-hire" decision for me. Hell, it's not even a trick question, the right answer is obvious. Does that suck for people with work/family obligations who are already swamped and have no free time? Definitely. But if you don't find coding fun enough to do it on your spare time, you simply will not be as good as the person who does, and I'd much rather hire and work with the person who enjoys what they're doing.
Your best bet for finding a job that requires damn-near-zero experience are small businesses in the 35-50 employee range where you'd be the first or second programmer and maybe the 5th tech person (you don't want to be the IT guy too on the side). They can usually only afford hourly rather than salary and the pay will suck, but you get your experience and peace out to a better paying job in 9 months.
120k is not a large salary in the bay area, and more importantly, if they're having trouble hiring talent I would say it's pretty obviously not a large enough salary. Source: that's approximately how much I make.
I do code in my spare time when I can. Doing it with any sort of consistency is the problem. Most days I leave for work at 6 am and don't get home until 7 pm. It makes larger projects for a portfolio hard to complete. I have several things I've started, ended up not being able to work on for a few weeks, and then have trouble getting back into. I would love to find a small company to work for and get some experience with. Again, everyone wants 3 years experience. Even the handful of junior dev positions I have seen on Craigslist want 1-3 years experience or a BS in CS. I feel like most of the time junior = we don't want to pay for what we need.
I worked from home for 18 months. Learning how to do so optimally is a skill that takes practice. At the start I would constantly be distracted, but by the end I felt that I would be even more productive at home. I could ignore the normal distractions of an office, like small talk and being asked questions by co-workers. I have a 1 hour commute to work now, so that's a 10 hour day. If I were to work from home, I would easily be able to do as much as in the 8 hour office time that I get
Well I have collaborated remotely and semi-remotely in many setups. And while it can suck if people aren't motivated or the time difference is too big and you can't break work up into independent chunks, most of the time it did work out pretty damn good. And if people aren't motivated, making them be at a certain place at a certain time simply so they can be supervised usually doesn't fix the underlying problem. Why would you say that remote work is a compromise? I'd even go so far and say office work is a compromise, since more often than not offices are really noisy and distracting. I'd rather sit in my home office where I can hear the birds outside than sit in an office where every 10 minutes somebody comes along to just quickly interrupt my thought process to ask me a mundane question while in the remaining time I can hear people chatting at the coffee machine and printing out tons of useless paper copies next door.
the thing I never understand is that it's so easy for a developer to get a new job. Why do they put up with bad jobs? I've never had a job where I worked too many hours, and I've been doing this for a long long time. 
Hey, this looks like just what I'm after. Thanks :)
Hmm. Good point. Thanks!
I applied to 5 jobs and got 4 interviews. only one of the five are considering my and I am waiting to hear back. To answer you question, I tweeted there is Ruby Rogues episode explaining how to get a JR job. https://twitter.com/brianllamar/status/459322038461923328
IMHO, DiSSS approach doesn't apply here. For a very simple reason. I know my fair share of programming languages and I'm not able to deconstruct in rudiments. I'd break it down into three parts: The most essential part of a language is the syntax. After that, you can write whatever you want and have it working. If your syntax isn't correct, the code won't run. Simple as that. Then we have the algorithms. A language is more or less prone to various kinds of algorithms. However, that depends on the syntax. *e.g.* in C/C++ you have a lot of tree algorithms, however writing tree structures in Ruby is just a lot more unnatural. Finally, the "language way". It depends on syntax but also on the community behind it and on the purpose a language has. Each person has a unique way of writing code. However, in order to have a (more or less) universal comprehension of what you write, communities tend to follow certain principles. I also believe that is what you achieve when you take yourself into a new language or paradigm: you need to start to learn your abc's. After that, you start to build sentences (algorithms). You develop new ways of solving a problem and, to improve your code, you start solving simple (and progressively harder) problems. That way, you improve your algorithmia. Finally, you learn about stylizing your sentences. When you are comfortable enough to write rather big sentences you start to notice they can be improved and can have those nice little touches that make them different from your colleagues. In a programming language, that's when you become part of the community, start to understand how they think and what are the conventions, the best way to achieve better code. Add a bit of your own personal touch and you have a unique programming style, based on the community standards. That's pretty much the way I have felt for each language I have learned. Finally, regarding Ruby: [RubyMonk](https://rubymonk.com/) and [Why's (poignant) Guide To Ruby](http://mislav.uniqpath.com/poignant-guide/) (have a blast reading this, highly recommended, important part of Ruby community). These are the pointers I can give you (and also this one: 0x3A28213A) about learning Ruby. RubyMonk even has Metaprogramming and _why is such a huge part of Ruby itself it should be read by any Rubyist. Cheers. EDIT: syntax
I see you have not met the dev managers I've worked for. I generally do work for my employer in my "spare time," and I'm not allowed to tell you about it. I know this puts me at a disadvantage when it comes to the job search, but that's life.
for us it's not so much that those guys don't know the worst case run time of various sorting algorithms, it's more that they don't know ANYTHING outside of the rails framework including ruby. most of them don't even know how to do a rails production deployment without heroku. 
Increase offered salary by 15k annually?
90% of the people coming out of a boot camp are going to kill your project.
A lot of it comes down to the organization, the types of resources available, how fast the train is moving, etc. Not every place is so well established that it can dedicate resources to getting a no-experience person up to speed. Some projects need everyone firing on all cylinders from the start. In a lot of cases, immediately graduating from a rails bootcamp and thinking you are ready to apply as a developer or junior developer is naive. (Depending on what the hiring organization is looking for.) There is a lot of core Ruby that needs to be learned before you can create anything in Rails beyond the simple CRUD interface scaffolding can give you. And a lot of critical thinking / problem solving / problem breakdown skills that need to be developed. It takes a lot of time (and mistakes) to start putting those things together. It's not specific to Rails or the Ruby community, but the proliferation of learn X in Y weeks does not help. A lot of hiring firms don't understand this and will send over any resume that has the word Rails in it. Hence the gripe above. Building something non-trivial, or contributing to open source projects can lend credibility to the certificate you get at the end of a course. 
I think it comes down to the overall organization and culture. If your company has a work from home culture from the start, or some large portion of the population already worked from home, it would be very easy to approach the problem that way. If you are part of an organization where 99% of people work in the office and constantly collaborate in-person, going out and hiring someone who will work entirely remotely will leave them marginalized. Chicken and the egg problem in large organizations. 
You misapplied the logic: not a Ruby hiring bubble, rather, a venture captial bubble.
*nod* That I understand. It's something I'm struggling with. It's _really_ hard to teach them a very comprehensive set of fundamentals in only three months; getting them to understanding git, maybe writing tests, and being able to get their way around rails, is already pretty good. Unfortunately "learning rails" is kind of all-encompassing and can sometimes drink them up, regardless of how many times we mention it's not the be-all end-all.
thanks for reading!
Oddly I've seen plenty of people who have spent 100k on private university on a CS program that couldn't code their way out of a box. 
That's probably true. Although what can work quite well (experienced that first hand) is to hire a complete new team that works remotely. Only problem is to cut packages of work that can be given to the team members without too much back and forth discussion. I'm still wondering why not more organizations have a work from home culture. I mean at least in IT.
I didn't even know Phoenix had ruby jobs. I left because of the lack of them, and it was the best thing I've ever done for my career. I'm pretty sure the job I have now doesn't even exist in Arizona. 
$120k is hard to get in SF unless you're a senior engineer. A midlevel developer will make around $100k and a novice, even if they hire either of them anymore, will make around $85k. $120k is barely enough to afford a one bedroom apartment in the city that's less than 40 minutes from downtown on transit (rents east of twin peaks start over $2800) let alone enough to raise a family and buy a house almost anywhere in the region.
Totally, fair, commutes in particular are dead time. When I worked at Google in Mountain View, I had a 20 minute commute, which is about as much as I'm personally willing to tolerate. A lot of people at Google worked around longer commutes from SFO to MTV with the WiFi-enabled buses, but that's clearly not a luxury most companies can afford or even remotely justify. I did the MTV to SFO commute for a month for some contract work up in the city, and I know I could never have done that long term. That said, the team and the work itself also greatly affects the efficacy of remote work. Some teams just suck at it. Some teams are more widely distributed with more time zones involved (my last job had 6 different time zones on one team; frequently awful). Some work requires a lot more collaboration than others (e.g. literally anything at Google). All of this factors into how well remote work plays out. If you can split things up and do work in isolation or if the task is relatively small, remote work can be fine, but I strongly suspect that this is the minority of real world tasks. At least, that's been my experience over the last 8 years, during which I've probably been doing Ruby in a remote setting for at least 50% of that period. Don't get me wrong, I don't think remote is strictly bad. Sometimes it is your best option, but I think it's important to recognize that in most of the cases where it's your best option, it's because it's the only way to get the best person to work for you. If that same person could work on-site, you're usually in a better position. That said, I sometimes need quiet and isolation and freedom from water-cooler talk too, and I think even onsite-only companies should give tech workers the freedom to work-from-home when they need to. There will always be times when working from home is the most productive thing to do; even Google, which is notoriously anti-remote-work, had an OK-to-work-from-home-sometimes policy (at least while I was there anyway; not sure about current status of that). 
Thank you! I got pretty excited for a second about def returning a symbol, alas. It's still a pretty cool little syntactic trick.
This is borderline illegal in the United States - you cannot discriminate against someone due to marital status or age. I think it would be quite easy to argue that one in court, given that you're only looking to hire people who have an abundance of free time. Tread carefully.
See other comments on the subject. I'm not asking for abundance of free time (I mentioned it only because it's a common objection, but not one with merit). I'm saying, "do you ever code for fun?" And I'm pretty damn sure the lawyers don't have a problem with it because I actually asked them before I ever asked that question.
See key word: median Of course it's not a "large" salary. It's the median! 95th percentile programmer "large" salary is $165k. For comparison, this is about the same as a low-end salary for certain MD specialties. 
It's really more human nature than anything else. Fear of the unknown. Afraid to make a change. The thing is, if people did it more often, they wouldn't be afraid of it, they'd embrace it and respect it.
exactly. i think those types of programs are perfect for example a seasoned php developer who wants to modernize his/her skillset. i don't think they're great for a total newb who thinks they're a magical way to skip years of study and practice. 
Yeah some things on the list are more important than others but a big problem I found when I was starting to learn rails was that I had no idea what I didn't know. I think this would be an awesome resource for someone who has a some knowledge of rails but is still in the beginning stages of learning. If you see something that sounds like gibberish, especially in the "ruby language", "rails framework", or "WWW" sections, start googling!
I meant that more along the lines of some of the requirements they want on some of the "junior" postings I've seen. 3 years experience, musts have shipped production code, well versed in front and back end development. I wouldn't consider that a junior level developer.
Drop the management jargon unless you're talking to managers. Not just because it's good practice for life but in general coders can be prickly, especially to slick inaccurate statements (Pareto Principle? Mathematically inclined academics don't assign magic numbers based on the number of peas in their garden). It's a quick and easy way to lose respect. But to avoid being completely negative being able to bs WELL to management and being able to code well is a rare and valuable combination of skills as long as you remember your audience. Oh, and to answer your question: First: in general (as /u/reallyaninja said) obviously syntax. Then read one article on OOP. Then build things, build, build, build. Learn just enough that you can create a program that does something in the area that you want, and then build that. When you finish build something more difficult, iterate. You'll learn the most important parts when you have to solve the problems that you encounter, which you wont know ahead of time. Because the only problem that matters is the one that's breaking your code at that moment. What I tried to say [but using humor](http://www.commitstrip.com/en/2014/04/10/how-you-can-tell-who-the-real-coder-is/)
Yeah, unrealistic job posting expectations are pretty common, particularly when the job requirements aren't written by another developer. This means one of two things. Either they want a senior developer at a junior developer's salary or they are willing to compromise and hire a junior developer even though they probably really want a senior developer. The former is a red flag, the latter just means you should apply anyways and during the interview process, try to show that you're a good candidate despite less experience.
You would not have to use the xpath locator if you had a label associated with the file input. so the html would look like this &lt;label for="image[upload]"&gt;Image Upload&lt;/label&gt; &lt;input class="file optional" id="upload-image name="image[upload]" type="file"&gt; then your capybara code would simple be attach_file("Image Upload", "/test/file/path") There is no need to use find(:xpath) at all 
There is just too much VC money being pumped into the system so every 22 year old with an idea and some bravado is getting money to start a company. If there is a bubble it has nothing to do with hiring. The problem is upstream with too much money being infused into the technology ecosystem and companies being started that shouldn't be in the first place.
Exactly. Bubbles are not caused by internal economic forces within a market. They are caused by artificial driving forces like too much VC money creating too many technology companies that should not exist in the first place.
&gt; I think this would be an awesome resource for someone who has a some knowledge of rails but is still in the beginning stages of learning. You've just described my situation perfectly. Except now I *have* an idea what I don't know, and I'm intimidated. Ignorance was bliss! But seriously thanks for sharing.
That is true, coding in your spare time can also encompass learning a new language or building your own app
Nope, not a protected class. 
The git segment should have the subsection "remotes". Github is not the only way to move code off of your machine. Either that or the whole section should be changed to SCM. Edit: "move" is more clear than "get".
I'm dumping RFC on them left and right, mind you. I'll be damned if one of my students leaves without knowing RFC 2616.
There's also [thoughtbot's trails](https://learn.thoughtbot.com/trails), which you can contribute to via github pull requests. (full disclosure - they employ me).
Just write code. Make things. Post those things online and get commentary. Make more things. Programming isn't magic. You get better by doing it not thinking about doing it.
If you look at the map, there is only one section of it that is labeled as rails. Therefore everything else on the map is self labeled as things that are outside of rails. It is a map of the competencies you would need to be a rails developer.
Is this pretty new? It looks like a really nice tool!
I am honestly shocked as shit to hear that. The last time I looked for work in SF for rails work it was extremely difficult with a wide variety of coding challenges, interview questions, whiteboard examples and the like that too often ranked very high in their absurdity and irrelevance. I had put two years of rails experience on my resume and regularly got things that I had never seen in the real world. 
&gt; Maybe you should stop searching for a decent Ruby/Rails developer and instead just try to find a good developer. I can't say if I am good, but when I was recruited for my current job the conversation went like this: Recruiter: We are looking for a Ruby developer. Sqeaky: Why are you calling me? Recruiter: Your resume says C++. Sqeaky: It should, I don't see the connection. Recruiter: This guy I know said any C++ could learn Ruby. Sqeaky: I suppose I could, by why should I? Recruiter: We'll pay you twice as much as you make now. Sqeaky: Code Academy has some Ruby lessons, I can start in two weeks. Been doing the job for a year, and it is awesome. 
 &gt; Since Minitest has no built-in facility for sharing tests, you can just implement your own. Or use `Module.include` or `Object#extend` or subclassing or or or... If anything, minitest has more facilities for sharing tests than rspec, and they're *built-in*, and faster. 
Yeah, with very slight re-labeling, this is a general web engineer competency graph. You can sub-in the language and framework of choice. IMHO, no one should start web programming with Rails or other, mature kitchen-sink web frameworks. It hides too much of this from you and you'll inevitably miss something. Rather, start from the basics and build up your knowledge. If you need something fast, use a CMS application.
I'm curious, what background did you have before learning Rails? Did you have or did you eventually get a degree in computer science or software engineering?
Definitely a good to-do list if you're looking to proactively level up. 
I like it, and I'd like to generate some mindmaps like this to show different competency sets. Any idea which tool made the mindmap in question? Any suggestions for tools that can convert markdown/json to a reasonably attractive mindmap? edit: one answer to my own question: http://drichard.org/mindmaps/
Yes, I agree with you... that was the whole point of the post. What I meant was, Minitest doesn't have a built-in facility for sharing tests _in the way_ that RSpec does. You would just use plain-old Ruby, which I much prefer.
that would be invaluable! Even just to let people know that it exists. 
This is great - thanks! As someone learning ruby, it helps with organizing the many parts and from there, prioritizing. So I'm wondering: As a complete noob, where would one start? Is it better to learn the basics of everything else before the Rails Framework? Any suggestions would be well-received!
I first started off straight with rails and tried to pick up ruby on the way -- it was disorienting and unhelpful for me. My recommendation is to start with Ruby and get some basics down (objects, arrays, hashes, iterators, classes, blocks). Try writing your own useful command line apps (a web scraper or file text analyzer is a good place to start: i wrote a simple app to analyze citations in a paper). Then, try learning Sinatra instead of Rails. It is less magic and gets you used to the idea of web APIs. Try adding activerecord for databases yourself. Try minitest for specing. You may never need to go full rails. After you've done that and if you really need to learn rails, it will go far smoother and you will really appreciate exactly the what and why of how rails does things.
You should learn ruby first. Learn how to program and think like a programmer (if you don't know already), otherwise you will have no clue whats going on or why Rails does things the way it does. You should also learn the www section of the infographic before learning Rails.
Do any companies actually use that? Everyone I know just uses git in an SVN'ish manner with a central repository rather than pulling directly from each others machines. (Assuming that is what you are alluding to.)
Yes, I know a few people who learned via rails and assumed most of the stuff in activesupport were ruby stdlib methods then got a rude shock on their first non-rails project.
I'm curious about that. What problems did you find when using Ruby in Windows?
On that note, I have a group that helps people code out of boxes with Ruby. http://rubynewbies.org/
get over yourself. he put "fuck you" on a slide at a conference, so what. since when have ruby devs been such whiney annoying cunts. he has opinions, opinions you probably disagree with, SO FUCKING WHAT. the fence is a fucking dull place to live.
The takeaway is that "Rails" is *vast*. Being competent with the whole stack takes a long time. Other stacks are complicated, in my opinion, but only Java holds a candle to the complexity involved with developing with Rails. I've been at it for 7 years, personally and professionally, and I'm still learning new things all the time. It doesn't help that the state of the art moves forward almost as fast as I can learn. ;-)
There's only one pop culture programmer, and it's DHH.
there's no meaningful discussion to be had. everyone needs to stop crying over what DHH says, it's pathetic. if you think someone is "being rude" to you by strongly holding an opinion which is contrary to yours, then you're a fucking idiot.
and yes, i'm being rude to you.
That comic strip should be shown to everyone studying computer science/engineering as soon as they enter their course.
Yes I use rebase at work all the time
Your example throws `it_requires_authentication` onto `Minitest::Spec`. My knowledge of minitest spec's DSL is hazy here, as I spend as much time as I can in test unit syntax, but I believe you could also throw it in a module and extend it only in the tests you care about: # spec/support/requiring_authentication.rb module RequiringAuthentication def it_requires_authentication session[:user_id] = nil yield assert_redirected_to sign_in_path end end # spec/controllers/monitors_controller_spec.rb describe MonitorsController do extend RequiringAuthentication it_requires_authentication do get :index end end
Could you explain how rebase is different than merge. I've read a few articles, never tried it though. Something about removing git commits, etc.
Here is a link to the original article: https://www.codefellows.org/blogs/this-is-why-learning-rails-is-hard
I've only done it once (accidentally committed, but didn't push, some secret key files). I wanted to remove the files from the repo AND the history, and rebase let me do this by "squashing" all the commits together -- so the 2 commits (one where I added them, one where I removed them) "cancelled out", and the 2 commits were squashed into one commit that didn't show the secret keys. So yeah, you can do lots. You can edit history, delete commits, squash commits, etc. probably more, but again I've only used it once so I'm a noob. 
&gt; although his opinions on practices are equally as valid as everyone else, he is certainly no ultimate authority about how we should do things he's not claiming to be, that's your own spin that you've put on it as a reader. you're basically saying that because he started rails that he's not allowed any opinions on it anymore in case they're construed as the gospel truth. 
Doesn't work for me at all...but I had to repl.it. When I hit 1, it says 49 is not an option. So I removed the chomp[0], to just chomp, and it worked. Then it tells me I can't put a piece in column 1, row 1. So I gave up.
Not really, and your comment is fair enough. Perhaps if I put it this way. By being the creator of Rails, his opinions are valid, equally so to other developers, but by using hyperbole to make his point ("TDD is dead"), is not very helpful. His statements are said with conviction as if they are truth, when in fact, what he's saying is that it doesn't work for him personally and he's offering another view point. "in case they're construed as the gospel truth", this sadly can be the case, as he is looked up to by many many developers. 
You can use the rubocop to get feedback on ruby 'best practices'. Flog is a similar gem. With that being said: 1) The ruby 'standard' is two spaces for indents. 2) I would suggest writing accessor as: attr_accessor :row1, :row2, :row3 3) Make a print method. def print_each(obj) obj.each { |i| print "| #{i} " } end 4) Methods are supposed to do one thing. GameBoard#set_square is doing three things. Break it up. def get_symbol(player) sym = if player == 0 sym = "X" elsif player == 1 sym = "Y" else SetError.new end end def out_of_bounds?(row, col) if (row &lt; 1) || (row &gt; 3) # check to make sure they aren't an idiot. They sometimes are. It's sad. return 1 elsif (col &lt; 1) || (col &gt; 3) return 1 end end Those are **my** suggestions. Dont take them too seriously. 
Attacking DHH's character is a really weak way of debating the point. Is TDD dead? I dunno, but if he wanted to have an intelligent conversation he should have stuck to the issues instead of trolling DHH personally.
Yep, I'm pretty sure that would work.
This.
Good point. Although the take away for me was the the lack of tact in presenting the ideas, just happened to be spoken by DHH. There's a trend where ideas are presented with over the top hyperbole, controversy, subtle disrespect to previous work. I mean let's face it "TDD is dead" is a strong statement designed to gain immediate attention, to stir controversy. Even if this starts conversations, the style is not constructive. DHH knows he has a legion of fans who will lap this up. That said, I still believe his talk was though provoking and he brings up some very pertinent points regarding the overly scientific language we use to describe practices. That said, he could learn a thing or two from the late great Jim Weirich, a brilliant speaker, respectful, and was courteous of various positions, regardless of where he stood.
This applies well to all forms of web application development really. You just swap out Rails-specific contexts with .net ones or python/django or whatever else you might use. I guess the command line stuff for changes on windows to know various UI tools, especially in the windows server environment. But things like CI and that still apply.
If merge is a piece of string that binds two heads of a commit tree together, then rebase is a **chainsaw**. Use it to shape the tree the way you want, with the commits you want to have where you want to have them. I'd advise against using it on commits you have already shared with some other commit tree though, as that will most probably end up confusing things for more people than just you. 
And I don't understand how your comment has anything to do with what I wrote.
English is my fourth language. I can tell you that he's a dick. Willfully. Not out of accident. If you watched his hangout with Fowler and Beck, he was well-spoken, well-reasoned, careful in his statements.
I think it's more a cultural barrier than a language one. DHH is very Danish. That's worlds apart from modern American culture, where everyone is a delicate flower, every even remotely contentious statement must be bundled in layers of equivocation, and everything *must* have two equally-valid sides.
i'm not alone...it's a douche title. http://codon.com/the-dhh-problem
They both come from Scandanavian countries, iirc. Linus received a lot of backlash lately for his blunt, impolite demeanor. He chalked it up to being Finnish. Also, while we can validly call into question the breadth of DHH's experience, Linus can safely say he's been just about everywhere a kernel can go.
Ok, that helps explain the 6 to midnight time slot. But not the 20 minute maximum on talks. How can there be any depth to the presentations in 20 minutes? (Don't mean to criticize, I'm genuinely wondering, and so are some other coworkers of mine)
Ah, okay. I usually used to reset to a previous commit. I ought to use rebase from now on.
Strange, I can't reproduce that! Screenshots, if you get a chance? 
Awesome, I am used to the 4-space tabs from python, so I never even noticed. Thanks! 
I love ruby, and I share your concerns over the future of the community. I fear that our community's legacy will come to mirror perl's.
What's so bad about that? Perl is still alive (and has been for almost MY entire life). I hope Ruby reaches the same age with the same following. That said, I do disagree with the author about one point: there is a middle ground in "accepting the rails way", Same as partially accepting the TDD-doctrine or drinking the FP-koolaid. It's just harder to "standardise" in a professional environment. 
Random thoughts below. Every product has a life cycle. Ruby is hard. Rails is even worse. People who know Rails well mostly know only Rails, and don't know ruby. Ruby comes with a legacy burden, it's easy to miss that if you're a web app developer, but when it comes to supporting a library that has to be backwards compatible, it's hard. Ruby lost scientific niche, and will doubtly dominate as an embedded language with mruby since vim etc have been using python, perl and lua for years. There's a major leap between a ruby beginner and a ruby ninja. There's a lesser gap for those is js. IMO ruby (and rails) took the wrong way by using threads instead of async i/o. Java is king in this area, while jruby is mostly only useful when you need java libraries. Ruby is easy to read. But it's easy to misunderstand what's being written too. I don't advocate for anything else, i use ruby since there don't seem to be a more convenient general purpose language out there. I wish lua dominated in this battle, but don't see it being adopted anywhere recently but in neovim. TDD vs noTDD doesn't make the point. There's always a sane compromise that doesn't wreck your design, but helps you to with it.
To clarify, I would hope for ruby to continue growing over its long life. I wasn't a programmer during the time perl was responsible for holding the web together. While I respect perl's legacy a great deal, the programming community at large discourages newer developers from spending the time to learn it. It's certainly loved and revered, but it's not a major player in the general community. That's a respectable fate for ruby in the next 10 years, but the rubyist in me wants to see the language and community keep growing.
But a part of those "new programmers" progress into &lt;entry level programmer title here&gt;'s, learn more complex concept and might even dwell into the area of other languages... That, or they're forced to add feature FooBarCantLiveWithout to site_manager_11.8.251.pl before this friday...
Somewhat of a late reply, but here it goes: Your interface is the direct result of the design/architecture of your application. IMO, you should testing help you assist in making design decisions; not force/guide you. You wouldn't change the whole design of a building only to be able to insert a 2cm big pressure sensor so you can measure whether the actual force on some strut matches the theoretical forces? I always stop "testing deeper" when I reach those kind of design decisions. 
If it weren't for ruby, I doubt I would have ever gotten to learning system level programming in c and rust. But ruby is mi amore &lt;3
I am on debian testing, we have 4 or 5 fulltime linux users and we have a few full time emacs users. You don't need to change, and don't let anyone try and convince you otherwise.
Nope, I just tested it with a newly created account and I didn't need a prime membership.
The first one is always free! Ruby is - imo - a perfect gateway language. (No, i'm not saying TOY language, I use this stuff to make real applications as well ;))
Actually, what's OSX specific? I've haven't pored through them all. Send us a PR if it's something OSX specific that doesn't need to be.
why do people upvote this utter dross.
My guess is it's just because Repl.it is in beta / running Ruby 1.8.x Not sure what part of your code wouldn't work in that environment but here's a screen: http://i.imgur.com/Ew4By6X.png
It didn't seem to me that the presenter was saying that DHH is wrong because DHH has a bad character. The presenter is reminding Ruby developers to not only listen to DHH, but to other people, as well. The presenter's objection to DHH's sensationalism is tangential.
I'm just a lowly Ruby/ Rails noob, so feel free to tell me to sit down and shut up. But I get the feeling that the Ruby community is suffering from the "high school superstar" syndrome. For a good long while Rails was the hottest shit on the block. New, high profile, with some major success stories. And over time Rails has matured and settled into being a very good and highly respectable option. But, its a little in shock just being one of a few (many, some, whatever) good options instead of the go-to hotshot.
Strange, I'll look into it 
While I feel that the ex-prom-royalty characterization may apply on a personal level, it feels like a gross simplification of a diverse community. Most of us aren't trying to reconcile questions like, "how can we make rails cool again?". But instead, "how can we grow the language/libraries such that they keep up with the expectations we have for modern systems?".
&gt; What's so bad about that? Perl is still alive (and has been for almost MY entire life). Perl is dying, and quickly. http://www.tiobe.com/index.php/content/paperinfo/tpci/Perl.html I bet newer generations of programmers don't know what Perl is. For that matter, COBOL is still alive.
Thankfully I haven't had to do ruby on windows for a while now so the below might be slightly out of date: Ruby itself is not too bad now with rubyinstaller and the railsinstaller makes it easier than ever. The problem is with the general ruby ecosystem. As we saw above there are assumptions made by many gems that they will run on *nix which causes problems when you are on Windows. Windows itself is not a good platform for non MS code development. * Even simple things like wanting to generate an SSH key? one command on *nix, on windows, not so much. * Need to spend a lot of time in the command-line? The windows default shell is utter garbage (I cannot live without my multi-tab oh-my-zsh solarized shell :) ). Need to jump in and out of ssh connections? In one window? Good luck. * Are you developing on windows and deploying on Windows? Say good-bye to easy deployment with capistrano. (Have a look at capistrano-windows gem for an idea of what is required and the drawbacks) * Are you developing on windows and deploying on linux? Now you have to make sure your gems work on both and do not need platform specific versions. * Looking for help on the net, especially when you have a problem that only appears on windows? I don't know of any experienced rubyists who use windows so your help options are more limited. * Want to use Redis? 3rd party version only. * What about those newfangled configuration management technologies like puppet or chef to manage your windows servers. noooope (well, yes, but not as good as the *nix versions due to OS limitations like no good package manager.) * Online tutorials and blogs generally assume *nix so you need to mentally translate in your head if they use example linux commands. (Or sometimes the equivalent is just not possible) * Want to do ruby professionally? I would bet money on the number of windows ruby shops being tiny. So you are going to have to learn *nux eventually. * More things that I cannot think about in the morning Everything listed above is not a showstopper. They can all be worked around, alternatives found. But at some point I think you just need to accept that you are paddling against the flow which is slowing you down (and probably frustrating you).
I love the Ruby language, and I do like the progress it has had. However, the Ruby implementations are not as good as they should be. They advance very slowly, and believe a lot has to do with the culture in the MRI community; it's just too passive and respectful. Unfortunately it steals away most of the Ruby language development which should be going into Rubinius, or a better fork. I bet if Ruby MRI was better maintained there wouldn't be any need for Rubinious, or RubySpec, or RubySL. It's total fragmentation! That's why Ruby wasn't even to cash on the Rails boom. And that's why the popularity keeps declining even though it's an amazing language.
I was referring to the undertones (sometimes explicit) of "Is this the end of Ruby?!?" that I thought I saw in this and other posts (and definitely in the comments). Questions like the one you referenced are measured and practical. I wasn't referring to that side of things. I also almost went back to edit to say it's almost exclusively an internet thing. When I talk to experienced, competent devs IRL they're much less hyperbolic.
I called it a state machine first of all for lack of a better name. But let's step back a bit. The state pattern is used when you have a class whose methods perform different operations based on the internal state of the object. One way of handling that is by using an FSM internally. Such an FSM can usually be implemented by a set of conditionals. An example is my XO::Engine class (see https://github.com/dwayne/xo/blob/b6c51ac67b2ada515b4a87de84bb26a532b2f8a2/lib/xo/engine.rb). The methods #start, #stop, #play and #continue_playing do different things depending on internal state. The state pattern instead uses classes to represent the different states and each class would re-implement the methods that depend on the state. So it's not that you send events. You just call methods and those methods perform operations which may or may not change the state of the object. When the state of the object changes then only the behavior of the methods change. Check out the examples and let me know if they help. https://github.com/dwayne/state_pattern/tree/479c03f9179bcb1d6e4fbea42fa9e45b96188799/examples
There will always be those like us who treasure the history of our industry. Perl was the first 'postmodern' programming language, and, unsurprisingly, I don't think ruby would exist as we love it today without perl. First class regexps anyone? :D EDIT: What's interesting to me is how distinctly perl dropped off following rails' release year. But it could be too much to assume a correlation on this graph alone.
Yes, Perl was a great language at the time, and it inspired good syntax in Ruby, but it's dying fast. And I think that's a good thing; there's not much need of Perl nowadays.
I like ruby most for general purpose computing as well. It's extols the virtues of a multiparadigm language while being extremely forgiving in its syntax. Ruby can take on so many distinct forms, I see it much like [Sculpey](http://en.wikipedia.org/wiki/Sculpey) of programming. Except blocks. I'd be happier with first class functions. ¯\_(ツ)_/¯ Speaking of functional programming, I'm reminded of an excellent talk from Jim Weirich, taking ruby so far outside how we typically use it :D [Ruby Conf 12 - Y Not- Adventures in Functional Programming by Jim Weirich](https://www.youtube.com/watch?v=FITJMJjASUs)
I know tickets are sold out.. but anyone know where a student like me can get a ticket?
I'm not sure what you mean, can you give an example how you would do that in PHP? If it's just getting the number of viewers, you can just use any HTTP client and access the [Twitch API](https://github.com/justintv/twitch-api) eg. [GET /streams/:channel](https://github.com/justintv/Twitch-API/blob/master/v2_resources/streams.md#get-streamschannel)
damn, didn't want to shell out the $$ for it. I'll play with the free version i posted, and will consider mindnode over the summer again if I've gotten more serious about mindmapping. thanks.
On a side note, you should definitely check out Eloquent Ruby. I just finished it and thought it was a great read. Being someone coming from Python, Eloquent Ruby could quickly get you up to speed with Ruby's best practices.
Because they like discussing things 
You may want to check out several "code competition" sites that have you code to solve specific problems. I've been working with [Talentbuddy.co](http://www.talentbuddy.co/) and it has been entertaining and keeps you on your toes with the challenges to provide you. I'm a noob so thir Hard problems usually stretch my skillset and push me to explore the Ruby language.
This will definitely help out as I learn Rails.
| I do not want to see an entire language ecosystem driven by the head of a web framework. This. A thousand times this. It *does not matter* what you think of the specific Web framework or of its developer; any language worth writing in *has* to be greater than the sum of those parts. That, too, is something that DHH has given little, if any, indication of understanding. When you hit the gold mine early in your career, you don't learn. You don't and *can't* know what it was that you did right and what it was that you just got lucky with. Confusing one with the other is a great way to delude yourself and fundamentally distort the market you aim to serve. We've known *that* much since at least Shakespeare, if not the ancient Roman hubris he was writing about. There *has* to be more to Ruby than Rails. There *has* to be more to Web development *in* Ruby than Rails. When, nearly ten years on, a quarter of all the trade communication about Ruby is mitigating or avoiding what makes Rails *hurt* once you get past your 15-minute blog, all the Fox News-esque braying from the guru's acolytes and zealots can't put the genie back in the bottle. 1. Fear 2. Anger 3. Denial 4. Bargaining 5. Acceptance Where are *you* on your Rails journey?
I'm under impression that we are facing a post-rails era in the Ruby community and I'm looking forward to it. 
Double click the Gemfile or open it with a text editor.
And that's what's wrong with corporate America. You're so afraid of what you think might possibly happen that you make boneheaded decisions. 
You are certainly right about that. Very perceptive.
Tiobe is well-known to be broken, please don't cite it as a benchmark for programming language use or livelihood.
&gt; Tiobe is well-known to be broken Sure, I'm going trust a random guy on reddit over an established benchmark for programming languages in the industry. If you have better numbers, I would like to see them.
I don't have better numbers, but Tiobe's stated methodology basically ranks languages by search engine queries. Languages where programmers "need more help" are going to be naturally weighted higher than languages that don't. The playing field isn't level to start with so the end result isn't valid, IMO. There's also the problem of "widely used, but not necessarily loved", where Visual Basic, VBScript, Java and Javascript, et. al. will clearly have lots of people reluctantly using them. Compare that to something like Go or Clojure, where the users are basically 100% people that are actually interested in the language.
They're not sold out. AFAIK just the first batch of pre-early bird tickets. Brian will clarify, I'm sure.
http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/
Ruby has always been fragmented. TMTOWTDI is part of the core language philosophy.
Author here. I think that has a something to do with. I've been observing another trend for a while. The older an ecosystem has been round, the more crap that has to be maintained. Properly maintained code falls apart or must be heavily restructured to keep it shippable. There are simply more larger Rails applications that are collapsing under their own technical debt (and Rails encourages you to take on a lot). As more developers hit this phase they usually question how they got here more concerns and practices enter the community's knowledge base.
I do as well, but earn more.
TL;DR; That's an interesting point I hadn't thought of. And I wish the internet, specifically coders on the internet, were more civil and level headed. Huh, that's interesting. I don't think I've read about that before. However, now that I read it put simply and factually I think I've seen a lot of people talk around the subject or put it in a way where their nerd rage gets in the way of clear headed discussion ("The Rails Way will lead to an unmaintainable nightmare!!!!!!", "Why aren't you doing it the Rails Way?!?!?!"). Rather than what I think should be the style (e.g. "X has these immediate drawback, these down the road and these benefits"). I think this was Ryan Bate's greatest skill (aside from the simple utility provided by his demo's) was that when discussing a topic he never spoke as if he was personally invested in your project. Just, here's an idea you're responsible for yourself.
[This blog post](http://blogs.perl.org/users/mithaldu/2013/08/do-your-piece-to-fix-tiobe-or-stop-talking-about-it.html) outlines why their methodology and approach is broken. Another reply has also given you an independent ranking of language popularity which seems to back up conclusions in the blog post I linked (in short, perl is still widely used). Further, when I said "well-known", I was referencing the above linked widely-read article. Googling "is tiobe accurate?" gives me multiple links all questioning the accuracy of the website. If you had investigated at all, you would have seen that many others question its accuracy (one calling their methodology dubious at best). So instead of attacking my position as "random guy on reddit" maybe you should have done the bare-minimum due diligence in whether or not your source was reputable?
Hey Adam, I checked out the video you provided in your article, and both there and in this post you talk about the technical debt incurred and encouraged from/by Rails projects. I was wondering if you have any alternatives in mind, or specific pain points that you see as contributing to this encouragement of technical debt.
Two big ones right of the bat: ActionView + ActiveRecord. You can minimize technical debt by carefully using bits of each library. ActiveRecord: do not call any parts of the inherited API from classes other than itself. IE: never use `where` from another class. ActionView: use mustache. ERB/Haml whatever templates accumulate a ton of complexity over a project's lifetime.
Thank you. I too have many concerns with Rails views, and have been loving ember as a result. I wish something like Ruby Object Mapper would get off the ground so we had an alternative to the encapsulation ActiveRecord tends to break and coupling it demands.
Are you in the Boston area? I will PM you.
Looks like the average temp that time of year is about 55F - 65F. Probably not quite hot enough to get me to fly to the other side of the world.
Writing your own application specific persistence layer is much easier than you think. Give it a go.
But it IS still alive and as you happily pointes out: so is COBOL. The latter one being the most excellent example since COBOL software moves around gazillions or europoundollars every minute.
The problem is not ruby, but their API that is designed to send a response and close connection immediately afterwards.
I go over those details during my announcement at BostonRB: https://www.youtube.com/watch?v=Q4AXTSOBQJA&amp;t=32m Unfortunately the presentation wasn't on the correct screen so you cannot really see the slides properly. But those slides are here: https://docs.google.com/spreadsheet/ccc?key=0AkxLXLr7k4-DdE5wUWhDUnJUN0c4MWZPMEVmaHU0UHc&amp;usp=sharing
That just counts GitHub and StackOverflow languages. JavaScript #1 and C #8. LOL.
&gt; This blog post outlines why their methodology and approach is broken. Right. That doesn't seem to be ideal, but I don't see any better numbers. &gt; Another reply has also given you an independent ranking of language popularity which seems to back up conclusions in the blog post I linked (in short, perl is still widely used). That site has even worst methodology; it only uses two sites. Either way TIOBE also shows Perl it's widely used, but *also* shows the usage has been decreasing over and over.
where are you from? Maybe a glass of port wine would heat you up enough? ;)
Congrats on fixing your bug, and a **BIG THANKS** for making Open Source better! It always makes me feel warm and fuzzy when I can contribute to someone else's project, or when a stranger contributes to one of mine. Making the world (or at least the world wide web) a better place, line by line
Great article, thanks for posting. I also bought the book. What concerns me is it is re-iterated a couple of times on the importance of tying together specific versions of knife/chef solo/capistrano for everything to work harmoniously. If there is a future requirement to update one of those gems (e.g. for security, incompatibility with future middleware) and it all begins to fall apart I am really back on my own likely out of my depth in terms of required knowledge to piece it back all together. 
What's wrong with the state machine approach? I haven't finished reading the source, so I'm only assuming you're talking about the engine code. Seems fitting -- a game is a process, and each step of a process is a state. How would you have designed it differently? I'm really curious to see other approaches.
It does work, but I would highly recommend not doing that. It's hard to read and more functional than object-oriented. A better alternative would be to either encapsulate that conditional in a private method or assign your result variable in each block.
Those salaries in SanFran, are not even comparable. Do you know what the cost of living is out there? or what it costs for a house? 100k in SF is liike 60k anywhere else. 
It's a nice tale of what every developer goes trough when trying to contribute something upstream. Something many people don't realize when they simply see a patch of two lines of code. I sometimes get annoyed when people say "I'm scratching my own itch", or that other people are "doing me a favor" when reviewing the patches I submit upstream. If I truly was scratching my own itch I would simply implement a workaround that works for me. Submitting patches upstream is hard work, and I'm doing such projects a favor by going through it. In the end it's the best thing to do, as everybody benefits, not just me.
First of all, a loss of less than 1% and still in the top ten programming languages hardly strikes me as heralding the utter and complete death of the language. Second, TIOBE is an index of popularity relative to other languages - as the number of programming languages increases, others will be lowered even if their *actual popularity* remains the same because the pool of languages is bigger and they represent a smaller portion of the total. Therefore, your conclusion that perl is "dying" I find utterly laughable - it's entirely possible it's losing spots on TIOBE and *still increasing in popularity.* Your insistence that you "don't see any better numbers" - your conclusion isn't inline with those very numbers you're presenting, so I don't see what benefit providing you with additional research would give. Not sure why you're putting so much weight in TIOBE, I think it's clear perl isn't going anywhere.
&gt; First of all, a loss of less than 1% and still in the top ten programming languages hardly strikes me as heralding the utter and complete death of the language. This is straw man argument. &gt; Second, TIOBE is an index of popularity relative to other languages - as the number of programming languages increases, others will be lowered even if their actual popularity remains the same because the pool of languages is bigger and they represent a smaller portion of the total. It is clear you don't know what popularity means. &gt; Not sure why you're putting so much weight in TIOBE, I think it's clear perl isn't going anywhere. And it is clear you deny reality.
Your original comment: &gt; Perl is dying, and quickly. I don't see how my most recent comment can possibly be a straw man as it directly addresses the very first thing you said. That's the *exact opposite* of a straw man. Thanks though, I didn't mention your ad-hominem earlier ("random guy on reddit") - instead focusing on trying to intelligently and politely discuss the points you made. Clearly, you are not interested in politely discussing this topic, rather you are only interested in arguing and only insofar as you can prove yourself correct. C++ on the TIOBE index has a similar curve to perl- losing 16% popularity to less than %6 just now in about the same amount of time. It's actually a much bigger % drop than perl was. Yet I have a hard time believing you would draw the same conclusion, that "C++ is dying, and quickly."
&gt; I don't see how my most recent comment can possibly be a straw man as it directly addresses the very first thing you said. A language asymptotically decreasing in popularity towards zero is what most people would consider dying, not the "utter and complete death of a language". &gt; Yet I have a hard time believing you would draw the same conclusion, that "C++ is dying, and quickly." I do, in fact. It might have more life in it than Perl, but it's also dying.
this: https://rubymonk.com/ and by this (best) ruby book: http://eloquentruby.com/
good explain
Posts like this make me sad and frustrated. I think it's great that the author is trying to understand these concepts more deeply and share that understanding. At the same time, details about programming language semantics are quite precise and when articles like this get things sort of wrong, it just leads to more confusion. &gt; When we talk about dynamic typing, we talk about a mechanism where the type of a variable can change It's clearer to say that the type isn't *known* until runtime. The type may never change. &gt; and be resolved on the fly at the exact moment it gets parsed by the interpreter. Throwing "parse" in here is misleading if you know anything about how languages are implemented. The type of a variable is *not* handled at parse time, because parsing is actually part of the early compilation process. If you could fix the type at parse time, your language *would* be statically typed. &gt; When we talk about static typing, we talk about a mechanism where the type of a variable is resolved in advance by the interpreter/compiler. This is right. &gt; With statically typed languages, you cannot say that x is a string and, a few lines after, that it is an integer. That’s all there is to say about it. This is wrong. It is perfectly fine for a variable to change its type in a statically-typed language. All that matters is that the change can be tracked *at compile time too*. Many optionally-typed languages (which are static type systems) support this. (It is true that most statically-typed languages don't support this, but that's a choice of those languages and not a principle of static typing itself.) As far as weakly-typed goes, at this point, it's best to just treat that term as scorched Earth and not use it at all. It's been given so many conflicting definitions that it's not a useful term in communication. Just [read this](http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html) and you'll see what I mean. Personally, I follow the old definition of "weakly typed", which means that if the language lets you re-interpret the bits of some variable as another type, then it's weakly typed. Everything else is strongly typed. That means C, Forth, and assembly are weakly typed and almost every other language is strongly typed. &gt; It’s not because Ruby lets you change the type of an object as many times as you want that it doesn’t care about what you do with it. Oof. It is absolutely vital to understand the difference between "variable" and "object". Ruby does *not* let you change the type of an *object*. An object's class never changes. However, a variable can refer to an object of one type and then later be assigned to refer to a *different* object of a different type. You can say that the variable's type has changed. In contrast, Smalltalk has a method called `become` that actually does change an object's class.
Thanks for clearing this up. Misinformation can be poison that we carry with us for a life time. Have gold good sir.
They're not mutually exclusive. * Static + Strong: Java, C, C++, Objective C, Haskell * Dynamic + Strong: Ruby, Python, Lisp, Erlang * Dynamic + Weak: Perl, Bash, JavaScript I'm curious if anyone's ever written a static *and* weakly typed system.
It would have been nice to mention the difference between implicit conversion (e.g. #to_str) and explicit coercion (e.g. #to_s) in the article. It allows String-like objects to be treated as Strings. Some methods, such as String#+ check if the object it is passed responds to #to_str, and use the result (which should of course be a String). Here's an example: https://eval.in/152288 There are more such methods, for example, #to_int.
All three of them have been way too agreeable. I really want Robert Martin to join one because he actually has some starkly contrasting views.
I think these terms strong/weak/dynamic/static are useful in broad comparisons of languages, but the more precise you try to get, the more problematic it becomes, because the terms really aren't that precisely defined, and many of the distinctions are really continua.
C is static and weakly typed.
To elaborate the view idea behind C is that it's just RAM.
The most interesting part to me was Kent saying that design is separate from TDD. I'm curious to see the reaction of all the people who say TDD leads to better design. 
Find something that interests you and create your own rails app, upload it to github and link to it on your CV. Talk about how it's relevant to the job(s) you are applying for. Completing a course in anything does not impress anyone. Going out and creating something based on that knowledge does.
Thank you!
C is an interesting creature. It does allow treating blocks of bytes as arbitrary data types, but without performing the kinds of automatic transformations (e.g. string -&gt; int -&gt; string) that Perl does.
I highly recommend checking out this gem for anyone interested in using ES with ruby: https://github.com/toptal/chewy
this. Take a gem like geocoder and turn that into some sort an application or something. There are so many gems that can easily be made into a nice application. checkout https://learn.thoughtbot.com/rails theres a pretty good layout for you to go by. if you actually understand how to do all of that, you are definitely ready for a junior role in rails development. 72 hour course is not enough to be hirable imo, give some more time into it if you are truly interesting in taking this to a job/career. 
Sure, we have Rack now-a-days, and from that came a large number of essentially micro-frameworks. You also have the move to a SOA style of doing things: need async stuff? Build a small service with Sinatra and EventMachine in Ruby, or build it in Node.js. Need parallelism? Clojure or maybe Go might be your ticket. Or gawds, maybe someone decides to rewrite your app in Java or Scala or whatever because enterprise. So likely gone are the days of single 50,000 lines (server side) Rails apps. (To pick a number that represents probably a decade or two of engineer-years worth of work). But for anything more than 500 lines of code and less than say 25,000 lines? I still see Rails being alone on that hill, at least in the Ruby world. Even in systems larger than that: a larger Rails app supported by N service apps. I also think Rails will continue to be a good tool even as we move to fancy JS client side apps. As in, I'd love to know how one would organize an Angular app with say 25 (Rails) models each with 3-4 views = 100ish screens. I wouldn't want to write a back end of that size/complexity in Node/Express.js OR Sinatra.
All of the advice given already is absolutely on point. In addition to that though, I would start learning a JS front end framework (e.g. Angular.js), and use it both with and without a Rails backend. Basically, it will do three very valuable things - 1) expose you to a new language, which makes you a better programmer in general. 2) differentiates you from everyone else in a similar position. 3) puts you at the bleeding edge of what some people think is the future of Rails (Rails backend + JS frontend). As far as actually getting hired (note: personal opinion) - seek out startups (ideally, outside of Silicon Valley) that have a lead developer and little else. They pay might be shittier, but you'll grow a lot and become much more marketable in the process. Just for fun, here's one I've heard is hiring like crazy and is built on Rails - http://www.trunkclub.com/careers
&gt; As in, I'd love to know how one would organize an Angular app with say 25 (Rails) models each with 3-4 views To be honest, I'd rather write, test and maintain 25 SPAs than a single monolithic rails app. But whatever, the point is that we do now have choices! Personally since Rails and I have never seen eye-to-eye I love being able pull *"the good bits" ^tm* of Rails into an app without being tied to the entire rails ecosystem. Vive la difference!
Make something. Once you finish that, make something else. Repeat.
You asked for *better* numbers than TIOBE, not perfect ones.
FWIW I've found that testing leads me to better design because a test provides a second client for my component (with production being the first client). This second use case helps me realize what production assumptions are currently baked into the component. Also trying to test a component or collection of components in isolation forces me to decouple them from the rest of the system via interfaces and dependency inversion. So testing helps me discover how to increase the modularity of my designs. In case you're interested I wrote a few more notes about testing here, and also linked to the growing OO software, guided by tests book: http://stevewedig.com/2014/02/03/software-developers-reading-list/#test-driven-development 
We switched to building apps from lots of tiny Sinatra apps years ago. Instead of each app being a huge "views + controllers + db" monolith with thousands of lines and conflicting concerns (eg., auth and content management in the same app), we have lots of tiny, reusable, extremely focused apps. Works really well, and lets us use other tools (eg., Node.js and Go) for some modules where it's appropriate. 
Have you actually had to write, test and maintain 25 SPAs? In my experience, writing the monolith is *way* easier, for a lot of reasons.
Rails is very prominent but it is not the only game in town. Sinatra and Padrino are excellent alternatives.
Excellent, but not widely used for production apps. Or at the very least, as widely used.
Glad it's working out for you. I personally wouldn't want to write apps in that manner for a variety of reasons. It is nice to see people "exploring" a bit though.
Article would be a lot better if it discussed ES a bit more, and the various strategies for keeping your indexes current. Using ES with rails is actually the easy part.
\&gt;Preaching half-truths on a blog This is nothing new.
I'm betting that now-a-days by the time an app is that large it would end up being a main Rails app + N smaller services because of reasons. (Or there will be efforts in the development team to move that way) So that comment really wasn't a limit to where I'd stop using Rails - I've used Rails on some projects with a decade or close to two of engineer-years in them, and i didn't hit a point where I was cursing Ruby much (eg: I didn't feel the need for compile time type checking for example). I have former coworkers that worked on Rails teams that were a 100 people large, so 300-500 engineer-years(?) size app by the time he left that project. But Rails does some things well and some things not. I suspect by 25-50K lines size or sooner the team will hit some performance thing, or web-real time requirement or some async feature and write more and more separate services, where the line count doesn't show up in rake stats (because it's a separate 500 line Node app, or a Clojure web API over some Java library (export fancy fancy reports to Excel / Word anyone, because business/the enterprise wants it? :) ). If I knew I was writing an app that was going to be say 100 engineer years or larger, I don't know where I'd go: start with an SOA model from the start and let the various teams pick their own tools, likely. Some would pick Rails I'm sure (or be gently guided to Rails), and some to other tech.
In my experience, the fact about trading one type of complexity for another is a myth. I build applications with a very small stack, and the applications themselves end up with less code and less complexity than Rails counterparts. There is this idea that if you hand pick your small tools you end up recreating Rails, but in reality what happens is that most of Rails is composed of features that you don't need, and thus you don't need to recreate in any way. Also, there's this idea that you need some kind of "glue" to tie all the pieces together, but in my experience there's no such a thing. You do have to require the gems, I don't think that can be considered "glue". Using a well designed library is easy because it doesn't depend on the context in which it is used, so there's no need for boilerplate. All this things I'm saying are not theoretical, there's a lot of people that have been building web applications like that for years.
Unless you're building ridiculously small applications with your stack I highly doubt they're less complex than Rails and would love to see what you mean by "less code". Do you include all of the boilerplate you have to write? "There is this idea that if you hand pick your small tools you end up recreating Rails, but in reality what happens is that most of Rails is composed of features that you don't need" So you end up recreating different parts of Rails in each application you write? How many times over would you say you've reinvented Rails in a smaller scope? "Also, there's this idea that you need some kind of "glue" to tie all the pieces together" How do you make the components work together then? " All this things I'm saying are not theoretical, there's a lot of people that have been building web applications like that for years." Have any examples? A Github repo would be fantastic.
Test, refactor, code review. That with a nice style guide and a competent team should be enough.
Have you tried the other approach? It seems simpler conceptually, but in practice it's a *lot* more work.
Having been in situations where I'm brought into large Rails projects, that's the time I fire up RubyMine and use it's analysis / refactoring tools to attack the large codebase. RubyMine isn't my everyday editor, but it's *really* good for that kind of thing. An app composed of 2 dozen services loosely coupled together sounds a lot harder to tackle. Each piece individually easier to tackle of course, but harder to ask questions about large scale refactorings, ie "what do I need to change if I change this field name?" (Object field or database column). Haven't done it myself, so can't speak from experience here. However even tracing the flow of a request through the app stack would get complicated: ("oh , ok it makes a request to the sign in service, let's flip over to that project folder and see what it's actually doing, because here I am on this rescue project and I need to know..").
This. Software projects can grow to millions of LoC and stay maintainable if your team is any good. Look at the Linux kernel, for example.
Do you consider Rails' way of modelling and structuring web applications to be the only possible/viable one? or optimal even if there are other viable alternatives? If the answer is yes. Do you consider Rails to be the best possible implementation?
I do practice that, in fact thats the only way I get any work done. Lets say your technical debt for that monolith is through the roof. To the point where refactoring would take months (since there might not be any acceptance tests to keep you sane). Which mess takes longer to refactor, the 100K or the smaller Rails engine, that might be the only code that you actually need to touch for that particular feature or bug? But, 25 is a LOT of engines though... I've only had to dealt with 5 or 6, so I guess that might be the other extreme. 
If you read that post as "use something else than Rails" you're missing the point.
&gt; Unless you're building ridiculously small applications with your stack I highly doubt they're less complex than Rails and would love to see what you mean by "less code". Do you include all of the boilerplate you have to write? I'm not talking about ridiculously small applications, but normal applications and even some big ones. But I don't know why is it that you highly doubt they are less complex. There's no boilerplate to write. &gt; So you end up recreating different parts of Rails in each application you write? How many times over would you say you've reinvented Rails in a smaller scope? I don't end up recreating different parts of Rails in each application I write, I have never reinvented Rails. I really would like to see what experience you had that made you arrive to those conclusions. Based on my experience, I can tell you it's not the case. &gt; "Also, there's this idea that you need some kind of "glue" to tie all the pieces together" How do you make the components work together then? The components work together easily, because they are basically modules and functions that you can use and call. For example, take a look at this gem for [escaping HTML tags](https://github.com/frodsan/hache) and you will realize there's no need for boilerplate or glue. If you take a look at [this article about Ruby Microframeworks](http://www.sitepoint.com/ruby-microframeworks-round/) and search for "Hache", you will see an example of how it is used. It's a very direct way. &gt;"All this things I'm saying are not theoretical, there's a lot of people that have been building web applications like that for years." Have any examples? A Github repo would be fantastic. Some websites built with this approach are [Educabilia](http://educabilia.com/), [AT&amp;T's M2X platform](http://m2x.att.com/), and this [job board](https://jobs.punchgirls.com/about), which is [open source](https://github.com/punchgirls/job_board). I really recommend reading the about page in the job board, as it explains how they were able to build it even though it was their first ruby project ever. The [Redis](http://redis.io/) website is a bit old now, but it was also created with simple tools. It is also [open source](https://github.com/antirez/redis-io). 
Is this your project OP? It's a really interesting idea.
Do you have any data to support this assertion?
&gt; Never going back to monolithic architecture Because that's a great mindset. What issues did you hit with monolithic architectures that made you decide to go down this route of man o' war architecture?
Not my project, but a very interesting idea indeed. I think it'd work better as part of a test, personally -- but this is sweet if you like living on the wild side.
Sorry, not the downvoter. And of course I'm questioning your statement. If I blindly followed everything someone else has told me I'd be a shitty developer.
Why do you assume that the monolith has technical debt through the roof? If you can't avoid making a mess with a monolith, you're probably going to avoid making a mess of splitting it up. That's not even to say splitting it up doesn't have value; it often does. But it offers zero value in avoiding problems with refactorability. Just *try* and redraw the boundaries between 5 or 6 engines. Much harder than a monolith, for example.
I am actually not telling you to do anything, but then so far you have not offered a single argument to support a contrary view, other than a disparaging comment about our "mindset" being wrong for a vague "variety of reasons". Either engage in constructive debate, or stop trolling.
I've seen something like this before, but with deprecations. The idea was you'd announce a deprecation, then wrap the offending code in a block with a date attached. Once the date passed, the code threw an exception and you could patch it out knowing you'd given enough notice.
My current project is a rewrite of a single monolithic python app. It has a handful of SPAs and other clients hanging off of the Rails and Sinatra services which provide the backend. In my experience, using SOA and SPAs has increased the reliability of the system whilst making it conceptually easier to understand the architecture, easier to test, and easier to diagnose and rectify problems. If there is a negative, it has been that deployment complexity has increased but if it had to grow I would be a lot more confident moving forward with this type of architecture than a monolithic one.
Well, of course rewriting yielded a much better system. It can often be much *harder* to detect and rectify problems when errors start propagating from one internal service to another. "The exception is buried in app F, but it's because app B sent it the wrong data." You may have had a wonderful experience, but that doesn't mean that monoliths can't scale up well past where they tend to break down in your experience.
These are not the usual definitions of strong/weak or dynamic/static typing. 
&gt; It can often be much harder to detect and rectify problems when errors start propagating from one internal service to another. "The exception is buried in app F, but it's because app B sent it the wrong data." How is this different to *any* application without decent logging/monitoring? Sorry but I find that a specious argument. &gt; You may have had a wonderful experience, but that doesn't mean that monoliths can't scale up well past where they tend to break down in your experience. ....but at a cost. IME one of those costs is the amount of time it takes to get new people up and running. My son is currently being trained in a monolithic system - 6 months of training! 6 months! With SOA its feasible to take a new hire and have them productive in a mater of weeks because they don't need to be able to navigate the forest to cut down a single tree. (and there's no worry that they will chop down the entire forest by mistake!) Anyways as I said, this isn't the point.
And...?
What would you call PHP and Javascript type system? "Leniently typed" or "lax typing" or what? "Weak typing" has for a long time come to mean what you say (absolutely no type safety), but language changes and it's become idiomatic to refer to automatic, implicit type coercion as weak typing.
Actually Ruby is statically typed!! Watch this talk by acclaimed Rubyist Gary Bernhardt: https://www.destroyallsoftware.com/talks/useing-youre-types-good
[And unsurprisingly /r/programming is contrarian and cynical as always.](http://www.reddit.com/r/programming/comments/25se6v/todo_notes_that_throw_an_exception_if_theyre_not/) I'm glad I don't work with people that suck the fun out of everything like that. I wouldn't use this in production (or probably at all), but it's interesting and clearly labeled a "proof of concept". Maybe in a personal project one day.
It is of course a matter of opinion, but since TIOBE measures search engine results, and Github measures the code people actually write and Stack Overflow measures the questions they're asking about the code they actually write, it seems pretty definite to me that the numbers I presented are significantly more realistic.
&gt; it seems pretty definite to me that the numbers I presented are significantly more realistic. More realistic about what? StackOverflow will give you numbers about people on the StackOverflow site, and GitHub will give you numbers about projects hosted in GitHub. There's tons of people and projects that don't belong in either. Search engines give you numbers about people that use search engines, which is basically **everyone**.
In that case both StackOverflow and GitHub are included in TIOBE.
Mine too, or rather on 3 3x2 whiteboards. Some of the languages specified for the older tasks aren't really in common use anymore (SNOBOL, anyone?) One of the great things about this craft is, you never have any excuse for being bored. One of the not-so-great things about this craft is, you never have any excuse for being fully relaxed. On balance...
Be careful with that [name](http://en.wikipedia.org/wiki/MechWarrior), especially if your gem gets popular. Probably best to save yourself some grief and just rename it now.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**MechWarrior**](https://en.wikipedia.org/wiki/MechWarrior): [](#sfw) --- &gt; &gt;__MechWarrior__ is a profession in the fictional universe of *[BattleTech](https://en.wikipedia.org/wiki/BattleTech)*, a wargaming and science fiction franchise created by [FASA Corporation](https://en.wikipedia.org/wiki/FASA_Corporation). The series' [intellectual property](https://en.wikipedia.org/wiki/Intellectual_property) is currently owned by [Microsoft Game Studios](https://en.wikipedia.org/wiki/Microsoft_Game_Studios) (MGS), although [Smith &amp; Tinker Inc.](https://en.wikipedia.org/wiki/Smith_%26_Tinker), has announced that it has licensed the electronic entertainment rights to the franchise. MechWarriors are individuals who pilot [BattleMechs](https://en.wikipedia.org/wiki/BattleMechs), large robotic war machines that are central to the *BattleTech* series. &gt;__MechWarrior__ may also refer to: &gt; &gt;* [*MechWarrior* (video game series)](https://en.wikipedia.org/wiki/MechWarrior_(video_game_series\)), a video game series for PC and consoles and tablets &gt; &gt;* [*MechWarrior* (video game)](https://en.wikipedia.org/wiki/MechWarrior_(video_game\)), the first game in the *MechWarrior* series &gt;* [*MechWarrior: Living Legends* (video game)](https://en.wikipedia.org/wiki/MechWarrior:_Living_Legends), a full-conversion [Mod](https://en.wikipedia.org/wiki/Mod_(computer_gaming\)) of [Crysis](https://en.wikipedia.org/wiki/Crysis) in the [Battletech](https://en.wikipedia.org/wiki/Battletech) universe &gt;* *[MechWarrior Online](https://en.wikipedia.org/wiki/MechWarrior_Online)*, a free-to-play reboot of the *MechWarrior* series &gt;* [*MechWarrior* (role-playing game)](https://en.wikipedia.org/wiki/MechWarrior_(role-playing_game\)), a [role-playing game](https://en.wikipedia.org/wiki/Role-playing_game) set in the *BattleTech* universe &gt;* *[MechWarrior: Dark Age](https://en.wikipedia.org/wiki/MechWarrior:_Dark_Age)*, a collectible miniatures-based wargame (also known as *MechWarrior: Age of Destruction*) &gt; &gt;* [*MechWarrior: Dark Age* (novels)](https://en.wikipedia.org/wiki/MechWarrior:_Dark_Age_(novels\)), a book series that serves as a companion to the miniatures game of the same name &gt;* MechWarrior: Tactical Command, the first MechWarrior game for tablet &gt; &gt; --- ^Interesting: [^MechWarrior ^\(video ^game ^series)](https://en.wikipedia.org/wiki/MechWarrior_\(video_game_series\)) ^| [^MechWarrior: ^Dark ^Age](https://en.wikipedia.org/wiki/MechWarrior:_Dark_Age) ^| [^MechWarrior ^Online](https://en.wikipedia.org/wiki/MechWarrior_Online) ^| [^MechWarrior ^\(role-playing ^game)](https://en.wikipedia.org/wiki/MechWarrior_\(role-playing_game\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chkw6ti) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chkw6ti)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
this is the book that inspired people like Jim Weirich and David Hansson you might downvote it, but this book is the gateway for ruby to reach western world. this book is historically important. I'm looking for it just to look at how it was written at the first edition.
K&amp;R is historically important. Pickaxe in other hand is just like family album - you love it, anyone cares.
**mech_warrior** Information: Author: bglusman Description: MechWarrior is a Mechanize and Celluloid powered site crawler Main Language: Ruby Number of Forks: 0 Number of Watchers: 0 Number of Stars: 0 
While this is useful, what does it have to do with ruby?
Came in here to say this.
Yay! Let's put yet another layer on top of things so we have even less of an idea of what's going on :D
It's not that bad.
Do we really need to abstract on top of sidekiq/resque though? They're already super high level. What do we gain from adding more layers?
Yes, precisely. While the name continues to have value to the copyright holder, OP will run the (probably small) risk of grief. It's a clever name but it's probably best not to stick with it.
Sad but true...
You can switch between them without having to rewrite workers.
Nice, it's always good to see the actor pattern gaining in popularity. A few comments meant for encouragement. Sidekiq uses self.perform_async and perform vs implicit activation. I would personally prefer a class method instead of overriding new. I only took a quick look, but I didn't see anything about supervisors. They make working with actors much easier as a system grows in complexity. Without a way to kill a failing worker and retry it's workload, it feels more like an auto executing proc than a true actor. Again, this may be there already, but I'm checking it out on my phone and will have to take a better look later. 
Thanks for checking it out! It means a lot. Can you elaborate on the supervisor idea? I haven't heard of this before. About killing and retrying actors. I could implement that quite easily, but it would require message processing to be idempotent. This is a necessary constraint, correct? For instance, if you retried a non-idempotent action, your actor could be in an inconsistent state upon starting the retry. 