I use awesome_print every day. Will this change allow me to write my own formatters for my own classes? I occasionally make some meta programming- or dsl-heavy objects, and awesome_print either prints too little to be useful, or way to much (@ivars full of lambdas, etc...). I thought I could define my own `ai` method like I can an `inspect` method, but that doesn’t work. Could this allow me to write a Formatter for it instead?
Yep. :) &amp;#x200B; it's not going to look 100% like this, but basically you should inherit (but not strictly required) from the `BaseFormatter` class, and then implement a formatter like this: [https://github.com/awesome-print/awesome\_print/blob/awesomeprint2/lib/awesome\_print/formatters/ext/nokogiri\_document\_formatter.rb](https://github.com/awesome-print/awesome_print/blob/awesomeprint2/lib/awesome_print/formatters/ext/nokogiri_document_formatter.rb) basically you define `self.formattable?(object)` (class method) and `format(object)`\` and call `formattable_for` with a symbol that your class will reflect as. e.g. `Nokogiri::XML::Document &gt; :nokogiri_xml_document`. &amp;#x200B; more docs on that coming as i formalise the interface.. but basically that's how it goes. I also intend to put some options regarding coloring in the class, and a few other things... so you can just have custom ap formatters that rock and roll as you get into different projects. The aim is that they should not be super intrusive: ideally, you just have the core base-class set of formatters, and then include in specialized ones per project. &amp;#x200B; hth!
wait until OP learns about ruby\_cowsay... amirite? :)
i mean... i'll accept a PR... :D
I think I lost a complete day to the cowsay gem... good times. 
Thanks, mate. I kinda get the idea now. 
Can you quickly show why we'd want to use it? Didn't see it at the first link.
 irb(main):001:0&gt; ap Hash.new.methods [ [ 0] !() Hash (BasicObject) [ 1] !=(arg1) Hash (BasicObject) [ 2] !~(arg1) Hash (Kernel) [ 3] &lt;(arg1) Hash [ 4] &lt;=(arg1) Hash [ 5] &lt;=&gt;(arg1) Hash (Kernel) [ 6] ==(arg1) Hash [ 7] ===(arg1) Hash (Kernel) [ 8] =~(arg1) Hash (Kernel) [ 9] &gt;(arg1) Hash [ 10] &gt;=(arg1) Hash [ 11] [](arg1) Hash [ 12] []=(arg1, arg2) Hash [ 13] __id__() Hash (BasicObject) [ 14] __send__(*arg1) Hash (BasicObject) [ 15] ai(*options) Hash (Kernel) [ 16] all?(*arg1) Hash (Enumerable) [ 17] any?(*arg1) Hash [ 18] assoc(arg1) Hash [ 19] awesome_inspect(*options) Hash (Kernel) [ 20] awesome_print(object, *options) Hash (Kernel) [ 21] chunk() Hash (Enumerable) [ 22] chunk_while() Hash (Enumerable) [ 23] class() Hash (Kernel) [ 24] clear() Hash [ 25] clone(*arg1) Hash (Kernel) [ 26] collect() Hash (Enumerable) [ 27] collect_concat() Hash (Enumerable) (but, like, with color)
i don't understand what you mean by portable there. 
I'm not quite following the logic. It's true that long-time developers who have a local Gemfile.lock may never update it, and new contributors will get a different set of dependencies. Maybe that alone is potentially bad? But the answer seems to be implying that new contributors may get a `bundle install` that _fails_. But if the new contributors are using the exact same Gemfile as the long-time developers... and the long-time developers have _some_ Gemfile.lock that satisfies all conditions in the Gemfile... isn't it a bug in bundler if new contributors get a `bundle install` that fails with the very same Gemfile, instead of finding dependencies that satisfy the requirements, which we know exist because the long-time developers have em?
I think they mean that `awesome_print` has use cases that go beyond the REPL/debugging. For example, the author of Kiba always uses it to display streaming data. It's kind of weird to be comparing `pry` to `ap` I think. Yes, `pry` displays your data nicely. But `ap` is just a totally different tool. 
&gt; To me, AS and some other thing we're getting these days, are a really different philosophy than I am used to Rails being. Instead of some tools I can use to build whatever I want, they are much higher levels of abstraction, with much less ability to customize. Agreed. I think that's from an (understandable in context) reluctance of the core team to tinker with core architecture (more/different layers as consensus is reached in the community would be nice) and so, to keep pumping out those marketing-magical dot-oh releases, they're limited to adding more bags on the side of the existing system. ActiveStorage may serve Basecamp and a subset of similarly-featured apps quite well, and it *is* handy in a post-Paperclip world, but we're all getting more than a little bit jaded here.
I feel like this example doesn't do justice to `ap`. The point isn't that you can print methods, ala `pry`, but like `JSON.pretty_generate` for any data, quickly. And, like, with color. Thibaut Barrere uses it all the time with his `kiba` gem so you can inspect data flowing through the system. Great for importing/exporting/looking at data. As a data developer, I really appreciate your work with `ap`, thanks. 
I love `awesome_print`. Use it in every project (except my codebases at work, they're not into it) But `pp` gets the job done pretty well too
Yeah, that makes sense. The slowdown of backwards incompat changes _is_ welcome. It's pretty mature good software. It still needs changes, like webpacker, which could still use some work. But I'd happily take major releases focused on performance and reliability. I don't know if that would work for marketting purposes, but adding odd things like ActiveText into Rails probably isn't making anyone who thinks "ruby and/or rails is dead" change their mind. It makes me think... uh oh, is Rails becoming Drupal? If I wanted drupal, I would have drupal'd. 
&gt; it's a common one... But I think it just doesn't really hold up to any scrutiny. There's a difference between useful and correct. Abstractions (even leaky ones) furnish a mental model to simplify working with a system above a given layer of complexity, and your argument is focused on some incidental implications of the abstraction instead. I'm happy to concede that objects don't "decide what to do" with messages. I don't know that Metz has ever used that language herself, and I certainly don't know enough about Ruby internals to argue to the contrary. Regardless, the value of describing this action in terms of message-sending vs. method-calling is that the former encourages, in Metz's words, a more polymorphic and anthropomorphic approach to designing the behavior of your classes, whereas the latter invites a more imperative approach. To try to modify a class's behavior so that it received a message and then interdicted the given method call would be missing the forest for the trees. Yes, if you take the metaphor extremely literally, that is what you should _be able to do,_ but that's hardly necessary and a long way off from where its instructive value lies. Finally, I'm not saying it's _wrong_ to use the language of "calling a method". Ruby's core API in fact supports both metaphors, in the form of `Method#call` and `Object#send`. As always in Ruby, TIMTOWTDI; I'm just saying that in this case (and many others), message sending makes things easier to understand. (_e.g.,_ why can you not use `self.private_method` inside a class definition? The caller is the same—but the recipient of the message is explicit.)
Additionally, users can't use the Gemfile.lock from your repository when they use your gem I agree that checking in the Gemfile.lock means you can't detect breakage on CI runs due to changes in your dependencies as the latest matching gems should be fetched, just like your users will do.
&gt; I agree that checking in the Gemfile.lock means you can't detect breakage on CI runs due to changes in your dependencies as the latest matching gems should be fetched, just like your users will do. Maybe? This only works if you build before they do. If you setup your gem to run on CI nightly then you _may_ catch breakage. I don't know if there is a perfect answer here. One option is to limit a gem's dependencies to &lt; the next major version, but that only works so long as the gem author is actively maintaining the lib and updates quickly when this breaks transitive dependencies with other libs. The other option is to make the deps open ended on the high side and only restrict when needed which requires a change which has it's own issues.
&gt; But if the new contributors are using the exact same Gemfile as the long-time developers (because that of course is checked in)... and the long-time developers have some Gemfile.lock that satisfies all conditions in the Gemfile... isn't it a bug in bundler if new contributors get a bundle install that fails with the very same Gemfile It's possible that the dependencies in the `Gemfile` have drifted in a way that their latest versions are no longer compatible with _each other_ (eg: one dependency requires `"nokogiri", "&lt; 1.0"` and another requires `"nokogiri", "&gt; 1.0"`). In that situation, I don't know whether bundler will "look backwards" to find older versions of those dependencies that are compatible with each other and also satisfy the `Gemfile`. 
&gt; Maybe that alone is potentially bad? Maybe the different set of versions triggers bugs the long-time devs aren't seeing. Is that what they mean by "broken dependencies"? Yes. It resolves to a set of gems that satisfy the stated dependency constraints, but have never actually been run together. &gt; Although your CI oughta be testing with a fresh bundle install on every run, which if you don't have your Gemfile.lock checked in will always be the same thing a new contributor on first checkout would get. Right, but that only ensures that CI was passing with the set of gems _at the time of your last commit_ -- not to mention the possibility of behaviour changes that your CI doesn't pick up. --- Moreso than new developers, who you can at least help out at the time, this also determines how possible it is to bisect your repository. Running a bisect on Rails [was](https://github.com/rails/rails/pull/18992) hugely painful when every step required sorting out any subsequently-learned dependency quirks and finding a set of gems that'll work together in practice, and not just according to their maybe-overly-optimistic dependency constraints. Basically, by not committing the lockfile, you're discarding potentially-useful historical information ("this set of dependency versions were known to _actually_ work with each other"). --- That FAQ's advice is missing a key piece of the puzzle, however (which is why [this issue](https://github.com/bundler/bundler/issues/5879) is still open): your _CI_ should run -- either exclusively or additionally -- without the lockfile. It is important to know that an upstream change has broken your dependency tree; it's not important to drop that information onto whoever happens to wander along next, especially if they're future-you trying to construct a coherent picture of the past.
This was pure pry started from the command line. THank you for the wonderful gem!
Yep - this is one concern. The other is that ap has few dependencies, whereas pry comes in a half dozrn gems. Which is good, but takes a bit of getting used to. The goal of ap is to provide the introspection info display framework I guess. So it's lightweight, fast and easy to get detailed insight into how an object is structured. Also with color. :)
Only on a separate run to give you insight into how the dependency graph will change. Friends, the purpose of gemfile.lock is to ensure all consumers of an app (be it a dev, qa or a deployment env) all use the exact same dep graph. Without the lock, bundle install acts the same as bundle update, which means you may find yourself pushing code that worked fine locally but really craps out in prod. Updating the graph is actual work, as is bringing gem path libs back into semver releases. It should be done as part of your sprint, not really your ci. 
We're talking about a library, not an app. The point is that as a library, your consumers may be using any version permitted by your stated gem dependencies, and probably the latest, regardless of what your lockfile says.
Left some comments on it, let me know if you'd like me to take another look at it later.
Yes exactly. Misread the headline. Not sure I entities agree with it. But it's interesting 
Thanks Brandon. Sure I've crossed paths at some point ;) As far as the nit picjs- rubocop will catch all that soon when it's hooked up. Most of the changes involved moving existinh code and so the goal there was to keep it the same for now - get the strucrure right. So the big question I have is, does this architectural approach have merit here? The inheritance of base formatter seems odd,but not crazy. Stuff like that. Is the narrative of the pr sound?
I use it all the time. I love it. And I love it so much that I which there was a good alternative for JavaScript too but I couldn't find any.
Original author here ;-) Great job James, keep it up!
check out previous discussion on this: https://www.reddit.com/r/ruby/comments/86yvcy/where_can_i_learn_actual_ruby_programming_not/ also, https://github.com/dreikanter/ruby-bookmarks has a list of resources that might help 
Yep not an AS issue :)
It has a well defined public API that's easy to extend upon by the looks of it. Most of my more serious critique would be around documenting that thoroughly so it's easy to build on top of later. Insofar as abstract or base classes, it's a tried and true idea that makes sense if there's a common API. Consider ActiveRecord as an example of this. The trick is making that API small so you don't end up with massive child classes off of it, which doesn't look to be a problem here. The good part about this design pattern is that you could likely add a registration system for new types in a configuration / initializer type script for custom use-cases. That's why I'd say documenting it well will be pretty important. Most of the headache is around enumerating on all the possible classes to "format", but considering the base of knowledge already here you're probably in the clear. As an aside, I'd make sure to test the more unique formatters as well and use dev dependencies to load those in, as I've seen a few issues crop up in the thread. Might also consider having a good fall-back system in case a formatter borks that can handle cases like that with potentially a reference to opening an issue.
It's not that bad, there are definitely quicks but that's because AS is still young lib. Yes it's different compared to Paperclip or Carrierwave but quite similar to lib like Dragonfly . We will get there eventually :)
[removed]
With webhooks, a good practice is, instead of processing each request in the controller, save it as JSON in the database and, then, trigger a job that process it in the background. That way, if there is any problem, no information will be lost. As an example, during a couple of days last month, Sendgrid sent the category of the emails as an array, instead of a string (I guess that someone messed up something on their side). That broke the process I use to parse the JSON but, once I fixed it, I just had to reprocess the raw events and all the information was correct afterwards. If I didn't do it that way, I would have had to parse logs in order to recover the events... Not cool. Also, when receiving webhooks, it is polite to have a fast controller, and don't let the remote server waiting for an :ok. 
Not to side-track this thread too much, but do you think there are still major shops that use capistrano, and does it still have a practical use-case? I feel like the "conventional" "devops" strategy these days would be to have a baked image for each major build of your software (made with something like packer+chef for vm images or even more simply just a dockerfile and a shell script).
awesome_print prints your objects more beautiful than pry. It's not a replacement of pry, it's enhancing it. Try &gt; require "awesome_print" &gt; AwesomePrint.pry!
Yeah, I've used it in the past. If I needed more-beautiful printing then I'd use it, but for my humble needs pry does a decent enough job *and* makes debugging a joy.
Since we're on this matter, do you reckon it is wise to sidekiq the JSON storing or is it overkill?! In my particular case, I have around 500k webhooks coming on a short period of time (an hour timeframe more and less) and I'm using sidekiq during the process but I was never really sure if it was really necessary.
Oh, you're right, that sounds very problematic. Now that I think about it, I don't think there would be any significant gain in this feature. Developers can still kick off a background job after a new file is attached, which would hit the derivation links to preload them, in which case the derivatives would be uploaded (if `:upload` is set to `:true`). In the meanwhile, the derivation URLs will probably already be hit by the user, which would also upload the derivative if it hasn't been already (that's not a problem). Yes, they will then pay the overhead for the upload, but from my benchmarks it's only about 200ms for a ~2MB file, so it's not that bad. One option would be to simply not have the endpoint upload the derivative, but rely that developers will manually upload them via a background job. In that case Shrine would provide an API for directly calling a derivation and uploading the result to the same location where the endpoint will look for them. But that would be dangerous, as you'd risk some derivations never being uploaded (e.g. if you don't retroactively regenerate a new derivation that you've added). And while you're preloading the links in the background job, it could be that multiple users have already accessed a derivation link, but since uploading for the endpoint itself is disabled for each of them the derivative was generated, so that's worse than if the first request uploaded the derivative it generated. Anyway, when I run all combinations in my head, this approach would have trade-offs, and I don't see any significant gain (and my head now hurts). It would be good, however, for Shrine to expose an API for calling a derivation and upload the result, so that you can do it if you want to (Like `ActiveStorage::Variant#processed`). Something like: uploaded_file.upload_derivation(:thumbnail, "500", "500")
The pickaxe ruby book and practical object oriented programming in ruby 
I'm slightly confused by you using xor instead of or. Even in your explanation &gt;&gt; Bitwise ^ (XOR) basically takes two arguments, a first and second bit, and returns a new bit with the 1s from the first bit, and adds in the 1s from the second bit where they are missing. It feels all you really want is just or as you shift the values such a way that they will never have overlapping 1s. In which case xor would behave different from or. In your case they are the same, - but the logic with xor is a bit harder to understand.
I have a rule in my `.pryrc` that requires awesome_print. If not found, it does a `bundle exec gem install awesome_print`, waits, then requires it. I feel like I'm working in the 1.9.2 days when I don't have pry and awesome_print.
Hey, I _love_ ap, thanks for making this awesome gem! I'm really looking forward to getting some more meaningful outputs from my own domain and value objects - it should make event-driven programming far more intuitive. Cheers!
I do it to prevent drifting. If I update my Gemfile.lock dependencies I want it to be a conscious change, not an accidental or random one.
I'm back as promised! So you're commenting that this rewrite makes it much easier to write new formatters, and you said this: &gt; So you could build a formatter/introspector for, say, `ActiveModel::Relation` that would dig in and pull out very specific elements so you can debug/inspect it. Do you have, or will you write a short documentation or guide on how to write those? This would be some next level shit, being able to have custom formatters for domain-specific classes and models with added or removed information depending on whether they're relevant or not.
You have quite a lot of traffic, an I guess that inserting events to Redis is more efficient than inserting them into Postgres. The reason why I insert the raw payload in the database before processing it is to make sure that I will never loose any event.
I've always sworn by The Well-Grounded Rubyist by David Black: [https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692/](https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692/ref=sr_1_1?ie=UTF8&amp;qid=1548333524&amp;sr=8-1&amp;keywords=well+grounded+rubyist) . There's a new edition out next month which should cover Ruby 2.6.
Yep! I plan to write a post about that soon. :)
That would be awesome!!
Good one! BTW, in Ruby 2.6, you can just do this instead of producing new Enumerator: def generate_csv(column_names, records) [column_names.to_csv] .chain(records.lazy.map { |record| record.attributes.values_at(*column_names).to_csv }) end (Which answers some of the questions about "why THE HELL do anybody need `Enumerable#chain`")
OK thanks. I'm not sure I agree, but I see the point. It may depend on size/complexity of the project too, most of our projects aren't Rails. &gt; Right, but that only ensures that CI was passing with the set of gems at the time of your last commit Some CI systems allow you to schedule regular runs on master regardless of commits, of course. &gt; not to mention the possibility of behaviour changes that your CI doesn't pick up. True. The thing is, though, that _users_ of the gem are going to get a dependency tree matching what you'd get without a checked-in Gemfile.lock either way. With a checked-in Gemfile.lock, all developers are using the same set of dependencies -- but the users of the gem are not, and now they may be running into problems none of the rest of anyone is. Granted, it is not appropriate to make newbie attempted contributors the first line of defense against that, running into it when they're trying to fix something else. Maybe the other missing piece of advice is that _maintainers_ should be _updating_ their Gemfile.lock regularly -- and certainly before any release -- whether or not it's checked into the repo. 
Thanks for your input. I was not thinking about changing the way things are working right now because it works pretty well, but I always wondered if I was doing things right. And yes, quite a lot of traffic, sometimes I feel it is more than what my tech skills can handle lol.
Think of it in physical terms. Let’s say you were a house builder, and you bought foundations directly from a company that made them. You did the same thing with every house, you installed the foundation into the ground and then started building on top of it. Then one day you buy a foundation for a new house, like you always do, but the manufacturer gives you a different version of a foundation. It looks the same, but it’s made of a totally different material. You don’t know this, so you start building a house on top of it, and then about 5 days in the house collapses into the ground because the foundation had a different density and couldn’t support your design. Allowing different versions of the libraries you depend on change randomly is like building a house on top of a foundation that you don’t control and that can change at any time. It’s a recipe for disaster.
I've always enjoyed [Ruby By Example](https://nostarch.com/rubyex) from Kevin Baird 
Right, I understand the basic concept. The particular discussion is about when you are developing a gem. When developing a gem, there is _always_ the possibility that the users will be using with newer/different dependency tree than you used or tested with. It's part of how making a dependency works. Even if you check your Gemfile.lock in, the Gemfile.lock in your repo has nothing to do with what version of dependencies users of a gem get. What matters if your gemspec, as well as the other peer dependencies the hosting project is using. If you lock all the dependencies in your gemspec to _exact_ versions, then you can predict exactly what your users will be using -- but that wont' really work, because it's gonna end up conflicting with other peer dependencies, not letting host app update to get security patches etc on indirect deps until the gem author releases a new version that allows it, etc. This is just part of the challenge of dependency management, and writing dependencies. The question is the best way to deal with it. Which there are pro's and con's both ways when it comes to whether you check in a Gemfile.lock to a repo with gem source code. 
Dependency management is definitely terrible. I think it’s mostly because humans don’t think in terms of graph data structures.
Awesome! TIL! 
Great article!
I did not know that, mostly because I don't use (or need) bundler or gemfiles. I sort of stuck around with oldschool .gemspec. Actually, I even remember the good old days of setup.rb and I am bundling it in one of my project simply so that I can quickly install a ruby-project even without gem or bundler/bundle. On a side-node, I agree with jrochkind - does not make a lot of sense to me. Then again I also don't feel the bundler authors/developers are the brightest people on this planet, so perhaps it fits ... AND it originated mostly from rails, so that does not speak for top-notch intelligence either, necessarily. :P (It's still good that rails exists but I don't use or depend on it either. I am perfectly happy with ruby as-is. Ruby is awesome; but not necessarily all of ruby is awesome too.)
I tried it. It's nice but I eventually realized that I don't really need it compared to pp. Sometimes more is less.
Hah! I use pp and that's about it - just like tenderlove once wrote on his blog that he is a puts-debugger, I am a pp-debugger. pp all the way!
&gt; its leagues ahead of pp I don't think so. The comparison is a bit like bash versus zsh. Everyone agrees that zsh is better than bash (from a technical point of view) - yet a huge majority uses bash (I do too). And not all of this can explained via "because it is the default". Simplicity IS a powerful reason.
Many of my larger gems always have bin/* components, following some internal code (when it is useful to use it from the commandline). This is purely for convenience really, just as you may combine different applications on linux from the commandline.
Went back and read The Ruby Way recently. Even as a seasoned Rubyist I still picked up stuff. But yeah, the pickaxe book ([link](https://pragprog.com/book/ruby/programming-ruby) if you're not familiar with the term) is where many of us got started. Oh, and _anything_ by Sandi Metz.
1. I also try to use symbols whenever possible and `symbolize_keys` makes the switch easier. Not sure what are plans for `String` class though. 2. \+1 for `Hash#fetch` 3. I totally agree. Issues connected to using `rack-timeout` are described in its documentation ([https://github.com/heroku/rack-timeout/blob/master/doc/risks.md](https://github.com/heroku/rack-timeout/blob/master/doc/risks.md)), so it should be used with some caution, but it's better to use it than doing nothing in my opinion. Thanks for sharing your thoughts and sorry for a very late response :) 
Hey, thanks for the comment. The example is imaginary, so for sake of simplicity, let's assume that a requirement is to display a list of the languages to end-user in alphabetical order. Thanks to such a data structure we would fulfil the requirement even when somebody would add an unordered element to it. 
Travis supports building at regular intervals so you can be informed the same day/week a dependency has broken its contract. Assuming your dependencies declare the correct requirements, of course. If you have everything declared correctly and rely only on documented behavior it really won’t be your bug when your dependency has a breaking change. Of course, we all know how well that works out in practice 
It is clear that you simply don't use ruby for things like many/most other people using it, so have different needs and priorities. I am not sure why you keep thinking this is a profound thing to share. The basic approach and semantics behind bundler have been copied on many other non-ruby platforms since then, demonstrating that what bundler does is something that meets a lot of real-world dependency management needs accross platforms, not just something they are cargo-culting. It takes more than cargo culting or following Rails mindlessly to get someone to implement the fairly complicated semantics on an entirely new platform like JS or Rust or Go. It's because the semantics address real-world needs. Insulting the intelligence of maintainers of popular projects provides no light on the issue, it just makes you look like a jerk. You can say what you don't like about the projects, although a lots been said already about what people don't like about Rails. Continuing to chime in on every thread about bundler to say that you don't think it should be used does not, in my opinion, provide any benefit to the readers. 
I don't understand WebAssembly. 
Yeah, if you are really into pp, that's great. Though I do find it to be lacking often.
tried it but it broke my custom formatter classes #&lt;NameError: uninitialized constant AwesomePrint::Formatters&gt;
Hey- what version are you on? (pre1 or pre2) can you share more about your custom classes etc?
i was wrong, this was just a typo in my application code
It's a high-performance, standardized, machine-readable language. That _machine-readable_ part is the source of a lot of performance: the runtime doesn't have to waste time parsing human-readable abstractions, and instead has guarantees like: - I will only ever have to support _n_ instructions, all of which are well- and efficiently-defined - Instructions will only ever operate on _a_, _b_, or _c_ arguments (The above may vary from version to version of wasm but the runtimes will be updated accordingly). This kind of restricted API means that performance can be much higher than traditional JIT-compiled V8 JS.
*It's happening!* Awesome work.
So you have made a custom formatter for your app already? 😍
This might help: [http://railsdiff.org/5.2.0/6.0.0.beta1](http://railsdiff.org/5.2.0/6.0.0.beta1)
it looks like a lot of hoops were jumped through in order to compile ruby to wasm. can you expand on what had to be done?
hmmm im a bit confused, i think my app code was right, but i had installed the `2.0.0.pre` version, which did break my custom formatter. I've now put in `2.0.0.pre2` and it all works. the formatter is for printing `Sequel::Model` objects in the way that I prefer
Expand on what, exactly? I'm not a contributor to run.rb at all.
in the repo there’s a dockerfile for how it was compiled but idk anything about compilers so was wondering what’s going on. 
Thank you.. good stuff 
Feel free to share your code? Might be worth looking at .. But I'm not sure it will work in place as it was 
This was such a more thoughtful response than I expected. Classy!
Well, you are lucky in a way. I work for a B2B and scalability will never be a big issue for us. :)
Is it possible for Ruby to be "the new Javascript" or am I misreading it??
Yes. Ruby can be the new, extra slow, Javascript.
Why would it be slow if it's being compiled to wasn't?
I think we're compiling Ruby's interpreter to wasm, not the Ruby code itself. &amp;#x200B; Practically, we can run interpreter inside the browser, and it still needs to parse and execute Ruby code. This is going to be incredibly slow.
I think `bundle update` should run in your CI as an experimental build before running tests. This job is allowed to fail, but it's purpose is to catch errors early. Your release code should use `bundle install` in your CI, to end up with a definite and tested version. 
While emscripten allows compiling C to wasm, most C code won't just "work" in the browser out of the box, since it relies on various syscalls or libc functions to exist that don't. The hoops being jumped through are in order to provide MRI the platform it needs to run with minimal modifications in the browser.
Ohohoh!
Oooooooooooooooooooooooo!!!
Yes. Please go away now and leave us alone
Rust seems to be leading the way as the WASM language of choice. 
Same answer for PHP :)
I think the foundational thing here is SQL. Focus on just SQL without Rails, and how to use joins to get information from multiple tables at once. There are really just a couple techniques. Then figuring out how to do it in ActiveRecord is more do-able, because you know what you're trying to do. 
&gt;Then again I also don't feel the bundler authors/developers are the brightest people on this planet Hi 👋, Bundler core dev here. We obviously don't appreciate this sentiment. It's also massively false. The other core devs on the team are some of the brightest people that i've ever known. &amp;#x200B; I suggest you visit the Bundler repo on Github to say hi and see all the huge problems that we have to figure out.
Don’t put that on us...
Cool Man!
Great! Thank you very much
Then how is this solution better that existing that are used in repls or elsewhere?
great website 😂
I love React, and it’s my front end library of choice. However this isn’t very accurate: “React is lighter than any other Javascript framework.” It’s not a framework, and of the front end solutions — it’s not the lightest (with configuration it can be competitive however) Also, from a SoC perspective, my personal opinion is the last method is the only real viable method. The API / backend should be entirely agnostic to the front end client. If it’s a React / Angular / Vue / whatever or a combination. Another confusion was the article discussed using yarn for everything with create_react_app but kept referencing an NPM server / client? Perhaps this article was edited to reflect using Yarn and not completely updated?
I am curious now how slow it'd be. Slow as in completely impractical, or slow as in you wouldn't want to use it for very intensive applications? Could it be useful in any context? I remember a few years ago seeing a gem that allowed you to write Ruby and compile it into JS. Never used it really, but it looked cool. Wonder how feasible something like that would be with WASM.
So you go without breakpoints?
Your example might have prevented timeouts and improved your memory usage and time to first byte, but your request time is still bound to the amount of data you're going to send back. A more scalable alternative is to create your CSV file in the background and make the client poll whether the file is ready and then download. 
&gt; is Rails becoming Drupal? No, rails is becoming Basecamp.
&gt; Then one day you buy a foundation for a new house, like you always do, but the manufacturer gives you a different version of a foundation. It looks the same, but it’s made of a totally different material. You don’t know this, so you start building a house on top of it, and then about 5 days in the house collapses into the ground because the foundation had a different density and couldn’t support your design. This analogy describes the inevitable effect of taking dependencies on unstable implementations, regardless of whether Gemfile.lock is in version control. Sure, checking in Gemfile.lock *might* reduce certain pain points, but it doesn't fix the pain for everybody. Your users _will_ be exercising your library with all those combinations of versions of transitive dependencies that you can't possibly permute through. Checking in Gemfile.lock merely gives an illusion of stability. But it's just that -- an illusion. If you want a stable foundation, _depend on stable things_. The #1 misconception I see about dependency management in these threads is the unspoken assumption that how we use bundler in conjunction with version control matters. It might a little, but not enough to move any needle. Depending on libraries that flail and churn is the real problem that Gemfile.lock dances around. I know this because I _don't_ depend on libraries that flail and churn, and I have exactly _none_ of the problems people purport to solve by checking in Gemfile.lock.
Are you talking about when a library doesn’t actually respect semantic versioning?
No. Semantic versioning does not inherently make software more or less stable. It's intent is to make instability (breaking changes) explicit. What we want to depend on is software that is stable -- that is, software that isn't _prone_ to needing breaking changes all the time. That's it. Everyone sort of assumes that semantic versioning is a cure all. It's brings some beneficial things to the table, but beyond that, it's often hyped up to snake oil levels. Consider: in your analogy you are calling these libraries the "foundation" of a house. TCP and HTTP are also part of that foundation, but they somehow _don't_ magically change every time you build a new house. So, what I'm saying is, if you only put things in your foundation that are stable, you won't care about whether Gemfile.lock is checked in at all or not! In fact, you'll probably opt to leave it out, because it's more trouble than its worth. After all, our version control repositories don't need one more pseudo binary artifact that constantly invites merge/rebase conflicts.
Meh, depends on personality of Junior Dev. Some will learn by understanding Ruby first. Some will learn by making copy paste Rails code to work (having brief clue what it does, then elaborating on that the knowledge)
From the business perspective, the biggest problems with the way React et al are used are that: 1. It became a mindless default for many but they don't ask whether it offers any business benefits. 2. It's applied in an all-or-nothing fashion - you either don't use it or build a single-page app. I [wrote about this](https://www.gregnavis.com/articles/the-architecture-no-one-needs.html) previously so I won't repeat it here. The article seems to confuse integration and build system setup. There are some integration aspects (e.g. `react_component` or using axios to fetch data) mentioned in the article but it's mostly about setting up the build. Build is the easy part.
I disagree. Learn to program first. But then again I dont believe in full stack ideology.
The most effective site to a problem.
What do you mean about full stack ideology? You mean one person who shall do both front and backend?
Yes, although a working knowledge of both is useful.
If this is for a Unix filesystem, I think a root node is the best option. It just simplifies so much. If you want to add a tree under another tree, you just have to insert the root node there. 
I'm confused when you checked if this is for a Unix filesystem. What do you mean by that?
I'm not sure if I understood the problem, but there are services like rollbar.com or airbrake.io which collect exceptions from your applications. And sentry.io comes to mind, but I've never used that. You may also push any other random event to those services.
I am not sure one can call full stack an ideology
Semantic versioning is definitely not a cure all, but it’s meant to communicate breaking changes, exactly like you said. Unfortunately, “stable” is completely subjective and semantic versioning is the best thing we have to bring some kind of attempt at organizing the chaos.
There is absolutely nothing subjective about what I mean when I say "stable." In this context, stability means how seldom a library breaks its interface. A library that introduces one breaking change per year is more stable than a library that introduces one breaking change per month. That's saying nothing about the additional instability caused by projects postponing breaking changes for the next major update, which semantic versioning is often misunderstood to endorse. Semantic versioning will never actually _fix_ the chaos you speak of, but it absolutely can be fixed. Programmers just need to apply substantial effort towards getting their interfaces right _before_ they release a library and invite the world to depend on it.
That someone is spending time to come up with something like that? That is just weak click-baiting. I mean, there aren't even any arguments in pro or con - it's just a static page with a stalemate answer. That is just wating the time of everyone, so downvotes are deserved. If you want to reason either way, at the least put some effort into what you write.
Well - the "question" was linked in here at ruby though, not at PHP. Might have been better to put it to php - that way our time here would not be wasted with non-questions and non-answers to these non-questions.
What the ... ?
I'd done a similar thing with headers in html, and ended up using a root note for much the same reason: https://medium.com/square-corner-blog/challenge-table-of-contents-generator-c99171fde831
I would say either * unlink the file in the rescue if it exists * download into temp directory and move on success, delete tmp folder after everything is done
It does fix it by preventing breaking changes from getting pulled into you project without you knowing right? I don’t agree that a Gemfile.lock doesn’t give you any guarantees about stability. If you pin versions f libraries, it does. 
I’m not really sure why action cable was included in the core, it’s been pretty much abandoned since. 
I feel like ActionCable was prematurely released not really ready for prime-time, and has stayed that way. I stay away from it. It's too bad that it may have inhibited other experiments in WebSockets since "it's built into Rails now", but not sure how much would have been done anyway. 
Currently in a Ruby on Rails bootcamp and this is golden to me thanks for sharing! 
I think the important point is that you do not want someone who does not have a preference. You can be decent at all of it, but you probably won't be excellent at the full stack. So if someone doesn't have a preference they are probably decent at most of it or worse.
It's actually getting proper testing support in Rails 6.0.0. Not saying that makes it any more production ready, though.
Probably because DHH &amp; 37signals wanted it in core. At least that would be my guess. Same as turbolinks. 
Nice article, and it clearly explains a problem which I'm sure not many people were aware of. Good job! I've wrangled with this issue too. Out of the box, ActionCable works with any Ruby web server (in practice, sounds like there are some exceptions though). As long as hijack works, it's possible to ship the IO off to a background thread which uses it's own event reactor for processing. This design means that the ActionCable server is completely responsible for how it works, and doesn't really depend on the server in any way. ActionCable scalability is entirely it's own concern... ... except as you say if the server uses `select`. Puma using `select` is it's own design choice and it's probably a bug in the case you mention. So, the solution is just to avoid ActionCable with Puma. Given all the different requirements, I can certainly see how the ActionCable design makes sense. That being said, the alternative is to use a [concurrency model that makes sense](https://github.com/socketry/async) in the core of the [server](https://github.com/socketry/falcon). If you do this, you don't need to build solutions like ActionCable... you can just use [web sockets directly in your controller](https://github.com/socketry/async-websocket/blob/9646f8cfcfa44f828c4e18a47c6bb1d5455ef560/examples/utopia/pages/server/controller.rb#L8-L21).
Is anyone using [AnyCable](https://anycable.io/)?
At best, semantic versioning lets us optionally defer updating our code that depends on a library whose interface changed. But deferring is not a solution to the chaos. "Pinning" versions is not a long term solution. I'll explain why. Consider this entry of a hypothetical Gemfile: ``` gem "some_library", '~&gt; 2.0' ``` Do we agree that the project is "pinned" to the 2.x series of the library in question? Okay, now suppose version 3 is released of some_library. Are the project maintainers still _supporting_ 2.x? Unless the project is popular enough to draw a lot of contributors, chances are the upstream library has abandoned that 2.x series. So, for this and other extremely cut and dry reasons, whenever libraries you depend on introduce breaking changes, it's in your best interest to upgrade as soon as you can. Think about old rails 2 apps that can't be upgraded because they depend on abandoned CMS plugins. It's all the same problem. Semver let's you control _when_ you have to accommodate breaking changes, but it doesn't make the problem go away (at all). In the end, we are better off depending on libraries that exhibit a certain measure of stability. The frequency and nature of breaking changes matters far more than how those changes are signalled. 
haha i think you read my mind with the second one ! ...the temp folder / buffer folder sounds like a good idea. i'm sort of confused about the first solution, what do you mean by "unlink"
Your suggestion of simply “depending on libraries that exhibit a certain measure of stability” is not helpful. A project may be “stable” by your definition today, but not in 2 years. There’s no controlling that. Because it’s code that you don’t control. There’s really no solution to the problem. If you don’t write the code, you can’t control its stability. And the concept of “stable enough” is subjective, even though you say that it’s not. Stable enough for one team is not the same as another team. It’s the definition of subjective.
I've already seen this problem solved.
Windows has drives which historically are called `A:`, `B:`, `C:`, etc. Because `A:` and `B:` were primary and secondary floppy disk drives, `C:` is the HDD or SSD today. On Linux/Unix there isn't something like this. There is only one big tree and the root node is called `/`. If you mount a drive it's available somewhere under `/`, most often under `/mnt/`. Because Unix has this single one hierarchical file structure, it's simple to add nodes somewhere and your abstraction is correct. On Windows you would have to plan for more drives than one and every drive would have his own root node.
That’s funny. how?
I use libraries that are manifestly less likely to change because they are thought through and designed.
You’re very dense.
Alright, kiddo. Have a nice day.
Hello, author of nio4r here. Well first check out @ioquatix's stuff because it's pretty cool. That said, let me summarize this post for you and provide a prescriptive conclusion: &gt; This is why ActionCable uses the nio4r gem, which offers support for epoll, kqueue and poll. &gt; Puma calls select and breaks the underlying system. tl;dr: Puma uses `select` which can't scale beyond 1023 connections. Solution: Puma should use `nio4r` like ActionCable does?
Heh, yeah... and the kids will still be asking in years to come "Grandpa, what's a 'B' drive" Just as a qualifier, modern Windows does have a notion of a "root" node via UNC filepaths, but it's an ugly hack. Accessing the `C:` drive looks something like `\\.\C:\`, where `\\.` is the root, though take this with a grain of salt. It's been more than a decade since I last touched a Windows box, and I'm happy/likely to be wrong. 
Great work on the nio4r gem! &gt; Solution: Puma should use nio4r like ActionCable does? Sure, that’s one solution... but I can’t change Puma. What I can do, and is far easier (and faster), is switch to a server that already uses `epoll` or `kqueue`, such as iodine. Than again, I’m iodine’s author, so I might be biased. 
&gt; Then I use a begin/rescue block to continue if the file download has an error. begin ftp_download(file) rescue File.unlink(file) end
This ad even has UTM params 
I am in production for almost a year using AnyCable-Go and it's fantastic. Lightweight, stable and was very easy to switch from vanilla Cable
Ruby does use `poll` internally when available for other things. Odd that this was never applied to `IO.select`. Oh well, at least we have `Object#then` and `Proc#&gt;&gt;`...
Action Text...
Couldn't find an appropriate existing issue on the puma repo for this but here's the closest thing including a previous attempt to migrate to nio https://github.com/puma/puma/issues/1316
any explanation ? haha , ill just look at the File api doc then.
that too
I finally understand what refinements are for, thanks! I knew what they were, but I never understood any sane way to use em. But replacing your if/elsifs with polymorphism, on classes you don't control -- is totally a good one. I've written parsing and AST stuff in the past which could benefit from this. 
Both of your points seem true of pretty much any method call (ie message send) in ruby to me. Since ruby isn't typed, `x.something`, you never really know where it's defined unless you introspect. And methods never have declared return values. The more so the more you're using polymorphism. But polymorphism is neat and often helpful. I agree with Sandi Metz. Refinements are a cool way to get it on classes you don't control. Refinements are scoped very strictly and lexically limits their usefulness, but also limits their potential for making code _really_ mysterious. You can't inherit refinements or get them implicitly, the `using` is always around somewhere. I'd have to spend a bit of time trying to use this technique to be sure what I thought of it. But initially I like it. 
To me, this is the first good use I've seen. Since refinement scope is strictly limited (you can't inherit a `using` from a superclass or namespace or anything, it's gotta be in the file), it seems fine to me to use it for a very specific, rather than general-use, purpose. Only code wanting that specific purpose will `using` it. You could call the method `convert_to_isbn` if you don't like `to_isbn`s idiomatic implications. Why would you want a specific-purpose`convert_to_isbn` method on any old object? Normally you wouldn't if it meant monkey-patching (let alone adding to the original source) so it was there globally, adding another method in many places it's not relevant, it's object bloat. But refinements totally let you do it only when you _do_ want that specific purpose. 
&gt; it seems fine to me to use it for a very specific, rather than general-use, purpose. But it's causing a lot of extra verbiage just to avoid a single method with a `case` that would keep things all together. If you had a large, complex module with lots of passing objects of different type around that might need certain behaviors, then *maybe* I'd be convinced, but in that case I'd likely question the overall design. &gt; Why would you want a very-specific-purposeconvert_to_isbn method on any old object? I wouldn't ever want that. The cleaner alternative to that would be to provide a ISBN() method on main, or a ISBN.parse() or the like (though I'd prefer ISBN()). 
yes, I agree with that sentiment. I think I would probably have to pay you to let me write css....
Which one are you on out of curiosity? I did one a few years back. The bit i found the hardest was understanding the magic of rails and how it differs from standard ruby and bits of it are more DSL like. 
heh, my colleague would really hate on the `folder` part.. :) https://superuser.com/a/247396
I was always puzzled by the word "law" in "law of Demeter". It imply it's a rule which if you break whole universe will collapse. Like "law of gravity". It's a helpful guide advice. If you follow it you will end up with more maintainable code. It's not a law, noone will end up in jail :)
Doesn't work this way with everyone :). Personalities play huge role in learning. Some people are good at math and logic = easier tu understand Lang first, some people are better at visualizing the end result and build up knowledge towards it
Well, it could be like the "law of attraction", or the "law of 6 degrees of separation". You don't go to jail for those neither. 😉
Jim Weirich called it the “very good suggestion of Demeter”. 
https://youtu.be/NLT7Qcn_PmI Is this talk what you are talking about? 
he was such o great guy, R.I.P. Jim :( 
I see, or "law of the jungle" :) 
Passenger+Nginx works with Action Cable, but we recently found one caveat in multiprocess setup: Passenger’s balancing algorithm always choose the first process for cable connections. This you cannot scale “cables” by adding more processes(
&gt; If you do this, you don't need to build solutions like ActionCable... you can just use web sockets directly in your controller. You still need something to handle business logic: subscriptions, multiplexing. That’s what Action Cable is for. And Action Cable Channel (class) is actually a controller for web socket client. It’s a framework, not just WS server. Though the problem is with the server part, or more precisely the fact that it’s hard coded (we cannot easily replace it with something else). It would be great to separate server from the framework, make it adapterizable. I proposed this [two years ago](https://github.com/rails/rails/pull/27648).
I guess it's inline with Sandi Metz's advice to make code cleaner by using polymorphism (among other things instead of lots of case/if statements). It's a standard school of OO design. But if you don't control the classes involved, you can't refactor them for polymorphism yourself (and if it's a special purpose on very general classes, maybe wouldn't want to pollute them globally like that) -- refinements is one way to do it. I feel like I finally see the point of refinements. But yeah, they are a new feature, and ruby has a lot of features. Which have grown a lot since I started using ruby in 1.8, if I hadn't been able to learn them as they got added it might be overwhelming for me. If you want to keep the code immediately understandable by beginning ruby devs, maybe refinements is a bridge too far. But one might be accused of trying to write ruby like it's PHP, heh. I don't know, software is hard. 
To add to that, the Law of Demeter cannot be measured purely in the number of chained method calls, but depends on the semantics and intended use. Are you using multiple method calls to dig far into another class' responsibility? You're breaking the Law of Demeter then. However, if you write something like: User.where(...).order(...).limit(1) This isn't breaking the Law of Demeter, because every method call mutates the receiver until the result is the intended state, rather than dig into unrelated objects. (If you use the same query often, it may be helpful to extract into a named scope, but it's a separate issue).
Delete the file, but unñink
Ah gotcha, I understand. I grew up with 3.5" floppies being prevalent.
Hehe I'll change it.
Yeah. This would be better focused on the coupling aspect.
IMO it's best to tackle interview questions from the POV of what do they want me to demonstrate. My guess is they probably want you to write a recursive function that traverses the nodes. Interview questions always love to ask you to write recursion in my experience, I think it's in CS interviewing 101 for managers book. They probably want you to compare root nodes with other root nodes' sub-nodes and their sub-nodes, etc, and build up a data structure as you go. They may want you to demonstrate that you understand Hash keys are unique and leverage that property or that to leverage Set's built in de-duping properties. They probably want to identify your knowledge around building up a Hash data structure that can be delivered at a API endpoint via JSON or XML. 
so you just want to write the front end and a gem adapter, it sounds like. if you’re serious about this project you should probably learn more about blockchain and understand that no gem will make it so simple that you don’t have to understand what’s happening. 
Thanks for the response. Did you downvote the post? I'd like to see other responses as well.
I find that suggestion awful, because in this case it is not the individual classes concern what is going on. The operation we want to carry out is not intrinsic to the type of the object carrying the value. What we are saying (and this same issue applies to her examples, which I disagree with for the same reason), is: I want to parse a value from the input object into an ISBN. But a number should not be expected to know what an ISBN is. Likewise a String should not be expected to know what an ISBN is. In particular, we may have specific formatting requirements, like including or stripping spaces, or using "-" between certain groups. This is knowledge that belongs in the ISBN class that actually knows what the ISBN is. *When taking input that knows about ISBNs* it is reasonable to ask them. Hence the suggestion I made of having ISBN() call e.g. `#to_isbn` *if the object responds to it*, same as e.g. Integer() will convert if the object responds to the right methods. Refinements (or monkeypatching) *might* have a place here if you're overloading lots of behaviours on large number of classes, but what they achieve in this case is to spread the actual logic out over multiple classes and making it hard to nail down what to expect. Basically the proposed approach is making the object dress up as something its not and lie about it. That, to me is in direct opposition to Alan Kay's definition of OO, which stresses message passing: It is the *objects* responsibility to decide how a message is interpreted. Turning that on its head is a big thing, that should stand out visually if you want to do it, not be obscured.
nope. no idea why someone would do that it was a perfectly legit question. some people are just a holes i guess. glhf! :) 
Thanks!
i'm the author of this gem https://github.com/krtschmr/monero/ which is used in some production websites already. i'm good with monero, but never developed anything for bitcoin. if i just want to send out some bitcoin programatically it's a bit crazy that i need to collect my inputs first and generate own transactions. i think running the btc-daemon and connect with an RPC, using json sounds easier. i used money-tree now to generate addresses based on a xpub key. this works great so far. catching incoming transactions i could either catch via a running daemon aswell or i just use blockchain.info API but that's a bit crazy to monitor constantly 24,000 addresses just to find the next payment.
It goes up to ~~11~~ 2.5.
Thank you so much for this, I have been experimenting. However. can't seem to get the same result you get on the edit, nothing writes? File.open("C:/Users/Compy/Desktop/A.txt", 'a') do |file| file.lines.each do |line| puts s.gsub(/[^a-z\n]/i, '\\\\\&amp;') end File.close
It really depends on other requirements. Are nodes unique? This will dictate a lot of your implementation. If they aren't, well, you are in for some tough decisions. If they are, look for an existing node, and then append to it. The other thing to look out for, is if you get the paths in this order: "World/Europe/Netherlands" "World/Asia" "North America/Canada" "World/North America/United States of America" You'd have no prior reference to North America, so you would create it as a top level node, but you'd have to check your top-level node set to know to then move it under world later. I would probably implement this by turning every path into a series of edges. "World/Europe/Netherlands" "World/Asia" "Europe/Germany" "North America/Canada" "World/North America/United States of America" becomes a set of edges: [World -&gt; Europe, Europe -&gt; Netherlands, World -&gt; Asia, Europe -&gt; Germany, North America -&gt; Canada, World -&gt; North America, North America -&gt; United State of America ] Then you simply construct your tree with those nodes and edges. 
Went through and played with TracePoint for a bit and saw what I could come up with. Ended up creating a gem afterwards, which is why you see trace\_spy mentioned in another thread. &amp;#x200B; Notes: [https://gist.github.com/baweaver/7e5d8fe356765d7af7e15749687ec28c](https://gist.github.com/baweaver/7e5d8fe356765d7af7e15749687ec28c) TraceSpy: [https://github.com/baweaver/trace\_spy](https://github.com/baweaver/trace_spy)
`File.open(.., 'a')` opens file in `append` mode, which is `Write-only, each write call appends data at end of file.` ( https://ruby-doc.org/core-2.6/IO.html#method-c-new ). Try using `r` instead.
That regex looks problematic. I'd usually recommend you check out [Rubular.com](https://Rubular.com) to validate your regular expressions, but their site currently seems to be having a problem. [0] pry(main)&gt; File.read('./text.txt') =&gt; "This is a test. What's happening?\n" [1] pry(main)&gt; File.open('./text.txt').each_line { |l| puts l.gsub(/\s/, "\\ ") } This\ is\ a\ test.\ What's\ happening?\ =&gt; nil &amp;#x200B;
[https://stackoverflow.com/questions/43172002/awk-gsub-ampersands-and-unexpected-expansion](https://stackoverflow.com/questions/43172002/awk-gsub-ampersands-and-unexpected-expansion)
interesting, thank you :)
Two things going on: '\&amp;' is a backreference operator that is, oddly, not specifically documented at https://ruby-doc.org/core-2.6/String.html#method-i-gsub. '\\' is a single backslash character. `'\\' == 92.chr` With those two things in mind, do a dry run through each string and imagine what Ruby is actually seeing when it evaluates the string at the moment of substitution. 
Nice explanation, thx
you have no end on your do block. also if you use File#open with a block you don't need to close it .
This sub is always so willing to help people do their homework.
you don't need `puts`
Wait you disagree with the suggestion to use polymorphism instead of case statements generally, or just using refinements to do it? You are familiar with the general idea to use polymorphism instead of case statements?
I really like what you proposed. One suggestion, if it's not a socket, don't call it a socket. That gets super confusing really quickly. `Client` or `peer` are generally nice names. One fundamental issue is how concurrency should work. I'm now firmly in the camp that sequential flow control is much better than callbacks. Some of these abstractions that are suggested or designed assume a fairly user-hostile model of concurrency and then build elaborate solutions (e.g. subscriptions, multiplexing) to make up for it. I'm generally against that. &gt;Though the problem is with the server part, or more precisely the fact that it’s hard coded (we cannot easily replace it with something else). From my POV, this doesn't really matter, because there is nothing better to replace it with. That being said, nothing is stopping you from making a compatible competing server capable of the same functionality. In fact, `async-websocket` is built on top of faraday websockets which is IO agnostic. I did the same with `async-http` which is built on `http-protocol`. That being said, `falcon` and `async-websocket` are just so much easier to use IMHO that they leave the competition in the dust. ¯\\\_(ツ)\_/¯
Yes and once you get past the abysmal sound quality it's a really first-class piece of software philosophy from someone at the top of their game. RIP Jim Weirich :/
&gt; You still need something to handle business logic: subscriptions, multiplexing. Yes. &gt; It would be great to separate server from the framework, make it adapterizable. I agree. The server should be definitely be separated form the ActionCable implementation - and so should the Pub/Sub layer. A high-level framework should "glue" things together, not manage low-level implementation details such as the server, the protocol or the pub/sub implementation. The lower level implementation details should be left to lower-level modules that can be replaced according to need, decoupled from the framework. I hope your PR helps change things in the future.
So, if what you're saying is correct, then this can happen not only with puma, but also with any dependency making use of `IO.select`, like `net-http`. That makes a lot of the ruby ecosystem unusable at webscale. But I guess this is only a relative concern. I don't know of any product building websockets on ruby, at least.
Cool tips, and allow be to offer my (biased) opinion... &gt; Puma is the default web server for Ruby on Rails since version 5.0. By default it will launch a single worker process and use threads to process requests. To get optimal performance you should tinker with this. Puma might [limit concurrent clients and even break if using ActionCable](https://www.reddit.com/r/ruby/comments/ajr0q0/how_actioncable_broke_puma/). Why not switch from the default server to a faster one? [Iodine](https://github.com/boazsegev/iodine) can handle more concurrent connections per worker (it uses `epoll` on Linux and `kqueue` on BSD) and it's significantly faster than Puma. A single Puma thread provides about 23K req/sec for Hello World with 200 concurrent clients. Using iodine with a single thread provides 63K req/sec. A single iodine worker can handle tens of thousands of concurrent clients, while Puma is limited by the system's `select` call to 1023 concurrent clients per worker. This includes "sleeping" clients (keep-alive / hijacks / WebSockets). &gt; A good starting point is to have one worker for each CPU core on your server. I was under the assumption that blocking Database calls (which Rails often performs) would benefit from a higher worker/cpu ratio...? &gt; Do not render with a loop So true 👍🏻👍🏻👍🏻 &gt; Use a CDN for your assets Yes 👍🏻 Even servers that provide native static file support and support pre-compressed assets (such as iodine) can't overcome geographical latency - but a CDN can. &gt; Does it have to be real time? No? Try a timed cache I would also add - use a background job and send the results using WebSockets or AJAX. It's better for a client to watch a page with a nice graphic loading message than to have them wait for the browser to load. &gt; Give up Giving up on Rails doesn't mean you have to give up on Ruby. Rack applications are easy enough to author and can be extremely performant.
I think this is a little bit disingenuous because if you really, _really_ wanted it, you could instantiate BasicObject and only implement `method_missing` and dispatch however you please e.g. to a private table of closures. What's more, objects can reconfigure themselves on the fly by dynamically removing and adding singleton methods. The result of either are notoriously slow and far from idiomatic. But it is possible. For me, the reason to think of Ruby as a message-passing language is that by thinking in those terms, I write better Ruby; cleaner, simpler, more expressive and more composable. And this is still possible because everything's an object. This is the real legacy of Smalltalk in Ruby - not message passing (and some have argued anyway that the actor model was abandoned between Smalltalk-76 and Smalltalk-80), but that everything's an object, which thereby still permits writing in a message-passing paradigm but doesn't require it. There's no mention of message-passing in Ruby's design or source code, and that isn't beside the point, but it doesn't obliterate it either. Writing in this mode is simply good Alan Kay-style OOP. 
&gt; So, if what you're saying is correct, then this can happen not only with puma, but also with any dependency making use of `IO.select`... That's true. But Ruby hardly ever uses `select` internally (AFAIK). As far as I can tell, NET::HTTP uses [blocking IO](https://github.com/ruby/ruby/blob/trunk/lib/net/http/response.rb#L55) and doesn't call `select`, so it should be safe enough to use. &gt; But I guess this is only a relative concern. I don't know of any product building websockets on ruby, at least. Technically, the issue could also occur when too many "keep-alive" connections crowd a single Puma process, it's just more *likely* to happen when using WebSocket connections with Puma. 
this seems to work in the console, but it doesn't actually print it to the file. It just echos what it should be. Am I missing something here, or are we just telling it to echo? Do I need to somehow pipe it back into the file with "&lt;&lt;"?
&gt; I was under the assumption that blocking Database calls (which Rails often performs) would benefit from a higher worker/cpu ratio...? This isn't really a 'rails' issue, all database calls are blocking unless your architect your app differently, it just depends on how you handle them. In the case of puma and assuming you haven't architected for concurrent requests its multiple threads per worker. The process count with any Ruby app (running on MRI) does not need to exceed the CPU core count. Realistically if your app is backed by a SQL database then you shouldn't be terribly concerned with 'blocking' database requests, you should be minimizing the number of database requests. &gt; Do not render with a loop This isn't bad advice, but it's not what most people think it is. It's quite slow in development because template caching is disabled but in production it's not a big deal. &gt; Why not switch from the default server to a faster one? It depends on your architecture, you don't need to have your web server hanging on to open connections if they aren't handled by the app. e.g. you don't need to maintain open http connections in your web server, have your load balancer handle that. If you are dealing with web sockets, then yea, you may see benefits with other web servers. Using puma has development advantages due to integration with rails if you don't have these issues. 
&gt; I'm now firmly in the camp that sequential flow control is much better than callbacks. This is really a long discussion, but let's agree that not everyone is on that camp. In fact, this choice will force a number of writing constraints on the application, so an application should be able to make a choice about using coroutines / green threads vs. using callbacks. For example, this might effect the placement of a `write` function call, since it changes behavior (the function returns immediately vs. waits for all the data to be sent to the client). &gt; From my POV, this doesn't really matter, because there is nothing better to replace it with... This isn't true. [Both Iodine and Agoo provide an API that allows them to be used instead of the ActionCable internal server](https://github.com/rack/rack/pull/1272). I even tried to push a [PR to support that API](https://github.com/rails/rails/pull/33295). I thought you knew that. [Weren't you part of the discussion?](https://github.com/rack/rack/pull/1272#issuecomment-385656965) 
&gt; This isn't really a 'rails' issue... True, this is part of the Rack specification and design. &gt; The process count with any Ruby app (running on MRI) does not need to exceed the CPU core count. There are two considerations for this: 1. Blocking IO (i.e., databases) - in which the worker is free to switch to another Ruby thread and concurrency on a single CPU core is often okay. 2. CPU intensive tasks (i.e., template rendering, etc') - in which case the Ruby GIL will prevent Ruby threads from using more than a single CPU core and true concurrency will require another process (worker). Between these two, AFAIK, there are cases in which a ratio of more than a single worker per CPU might be beneficial. However, I also suspect this might a misunderstanding, so I was hoping to understand more. I suspect that a single worker per CPU is ideal and that the high worker count is often an attempt to overcome connection concurrency limits imposed by the `select` system call. &gt; &gt; Do not render with a loop &gt; This isn't bad advice, but it's not what most people think it is. It's quite slow in development because template caching is disabled but in production it's not a big deal. As a server implementor, allow me to share a secret. An `each` rendering will often get rendered as an array of strings in the response. This requires the server to iterate over the array, either merging the String data or calling `write` separately for each String. This significantly slows the network layer and the server. The logs will show the response as complete, but the client will experience a significant delay. So, even in production, **Do not render with a loop**. &gt; you don't need to have your web server hanging on to open connections if they aren't handled by the app. Your assuming facts about the way that the load balancer work which aren't always true. Why do you assume that the application server won't have to deal with "keep-alive" connections? &gt; Using puma has development advantages due to integration with rails if you don't have these issues. Really? What advantages? What integration? Switching to Iodine is as simple as replacing the Puma gem in the Gemfile with the Iodine gem and removing (or replacing) the data in the `puma.rb` initialization script (which should have been environment specific, rather than a project file). 
I'm going to preface this by saying I'm absolutely not adversarial towards you, I love what you are doing and the ideas you are bringing to the table. But that doesn't mean I won't critique your ideas I hope you do the same. &gt; This is really a long discussion, but let's agree that not everyone is on that camp. Fair enough! &gt; In fact, this choice will force a number of writing constraints on the application, so an application should be able to make a choice about using coroutines / green threads vs. using callbacks. Any choice you make has this effect. If you choose callbacks, you are also forcing the design. I think there are objective reasons to choose sequential asynchronous code over callback driven state machines, the main ones being maintainability and correctness. &gt; For example, this might effect the placement of a write function call, since it changes behavior (the function returns immediately vs. waits for all the data to be sent to the client). If you want to use a write queue with async so that your function returns immediately, this is very easy. ```ruby require 'async' require 'async/queue' Async do queue = Async::LimitedQueue.new(4) writer = Async do while chunk = queue.dequeue puts "write(#{chunk})" end end 10.times do |i| if i % 5 == 0 and i % 3 == 0 queue.enqueue("FizzBuzz") elsif i % 5 == 0 queue.enqueue("Buzz") elsif i % 3 == 0 queue.enqueue("Fizz") else queue.enqueue(i.to_s) end end end ``` In the above example, the queue is fixed to length 4. This was to demonstrate the problem of code that has no back-pressure. If the loop would iterate forever, the queue would grow proportionally. In my mind, this is a problem. Eventually the code needs to block. How do you handle this case with your server implementation? Additionally, the user won't know if the write failed because it goes over a queue. So, I personally see this design as a downside, e.g. error propagation, etc. &gt; This isn't true. Both Iodine and Agoo provide ... Don't get me wrong here, I love that you implemented those servers and made that proposal... but you've missed the point of my statement. It doesn't matter **to me** ("my POV") because I'm not satisfied by the concurrency model that was proposed, to the extent that I think the concurrency model is hard to use. 
when you use `puts` like that, it will not write to the file, but to standard output in-place file editing like you are expecting is difficult, see https://stackoverflow.com/questions/4397412/read-edit-and-write-a-text-file-line-wise-using-ruby it is much easier to write to a new file and then replace the old file with new file if you wish
Ah, understood. Probably less risky anyhow in case the batch file goes wonk. Thanks!
&gt; But that doesn't mean I won't critique your ideas I hope you do the same. Of course :) I might be passionate about the subject, but please don't mistake my passion for aggression. I love the ideas you bring to the table - even the ones I don't agree with. &gt; If you choose callbacks, you are also forcing the design. Yes, every choice has an effect. This is why I think this is a choice that shouldn't be bound to the framework. Rather, the framework should be able to use lower-level modules that offer wither one of these approaches. &gt; If the loop would iterate forever, the queue would grow proportionally. In my mind, this is a problem. Eventually the code needs to block. How do you handle this case with your server implementation? This is a great question. I assume each vented server solves this differently. The iodine server currently offers an internal queue that uses a linked list of user "packets". This allows the developer to send as much data as the memory would hold. However, there's still a risk there that a client will create a lot of requests and read them very slowly. Iodine includes some mitigating mechanisms to minimize these risks and I'm currently debating if I should add one more (I think I'll stop iodine from reading slow client data until the backlog of outgoing data is relieved). As with every approach, there are ways to attack any mechanism. &gt; I'm not satisfied by the concurrency model that was proposed, to the extent that I think the concurrency model is hard to use. I'm not sure I understand. The API we proposed would work with both concurrency models. For example, the `pending` method will (probably) aways return `0` for a coroutine based server while a callback based server will probably return an actual number. As another example, the `on_drained` will probably get called immediately after each `write` call on a coroutine based server, while an evented server might call it at a future time. However you slice the pie, the API should fit any concurrency model. 
&gt; I might be passionate about the subject, but please don't mistake my passion for aggression. I love the ideas you bring to the table - even the ones I don't agree with. Awesome!! :) &lt;3 &gt; This is why I think this is a choice that shouldn't be bound to the framework. Rather, the framework should be able to use lower-level modules ... So, I'm an advocate of modular design. Rack for example is an awesome example of what you can achieve. That being said, `rack` uses the concurrency model of `http/1` which is request/response. That maps beautifully to a function call. In contrast, look at how much trouble they are having trying to define a concurrency model that exposes `http/2` streams. I worked on this problem for a while and designed `async-http`, [e.g. 99 bottles of beer](https://utopia-falcon-heroku.herokuapp.com/beer/index). Maybe you can define this as part of the rack SPEC, but right now I don't believe it's possible and I don't even know if it's a good idea. The scope is simply **huge**. &gt; I'm not sure I understand. The API we proposed would work with both concurrency models. I didn't say it wouldn't work with different concurrency models, in fact I'm pretty sure I wrote code to show that it would be compatible. Here are some of the problems I have: - Error propagation - how to know when a write would fail or not if you write to an internal queue, do you propagate the error back? If you use callbacks, your state machine has a 2nd input - handling error. - Back pressure - how do you know to limit writes? - Timeouts - client is no longer responding - how to handle write timeouts? What about a group of operations bounded by a timeout? - State machine design - you cannot write sequential code and instead must feed events into a state machine. For simple things it's not too bad, but for more complex behaviours it's hard to reason about correctness (given this state and this input what happens) and maintainability (if I receive this input, how do I change the code so that this transition occurs). - Integration with other operations - e.g. query the database - does this block? The only solution I see to this is to define [some kind of concurrency model within Ruby](https://bugs.ruby-lang.org/issues/14736) that all servers must adhere to. 
One side note on the swapping. Hitting swap is bad. Absolutely. However, this does not mean that swap should not be enabled. It is a safety net, even on a VM. Applications and systems go crazy sometimes and we hit peak memory usage. If swap is not enabled, the system will become unresponsive and the services goes down. Proper monitoring should be in place to alert someone that excessive memory is in use, but I would rather my application hit swap and be slow than for it to go down.
`\0` can also be used instead of `\&amp;` the default capture group can also be used for recursive subexpression calls with `\g&lt;0&gt;`
&gt; True, this is part of the Rack specification and design. Nothing prevents you from making concurrent database calls during the processing of a request. It's not particularly useful for many applications. We do exactly thing in Java in several of our apps without using a reactor based app executor, it's just not a common use case for Rails apps. &gt; Between these two, AFAIK, there are cases in which a ratio of more than a single worker per CPU might be beneficial. the only use case for more workers than there are CPU cores is when using a non-threaded web server, e.g. unicorn. There is no purpose in having more than 1 puma/iodine worker per CPU core, you can absorb IO wait with threads. &gt; As a server implementor, allow me to share a secret. &gt; An each rendering will often get rendered as an array of strings in the response. This requires the server to iterate over the array, either merging the String data or calling write separately for each String. I'm not sure what it is you are talking about here, but it's not what the article is talking about and not what I'm talking about. `render` is a call to execute a template partial, calling it in a loop in development mode causes the template to be compiled multiple times but this is only because template caching is disabled in development mode. In production there is little difference. &gt; Your assuming facts about the way that the load balancer work which aren't always true. Why do you assume that the application server won't have to deal with "keep-alive" connections? Why would it? If we're talking about performance optimizations, it makes little sense for your app server to be paying the connection termination overhead when there are much better suited systems for dealing with such things, like load balancers, e.g. haproxy. 
&gt; The only solution I see to this is to define some kind of concurrency model within Ruby that all servers must adhere to. That's essentially what NodeJS does... NodeJS learned from Ruby's short-comings and enforced a model that (for better or worst) provided a consistent platform to work with. On the other hand, part of Ruby's beauty is the freedom to choose different approaches - a freedom NodeJS developers can't match. &gt; rack uses the concurrency model of http/1 which is request/response... Yes, that is quite sad. Rack is practically a CGI. Even for HTTP/1 this CGI approach introduces issues (such as handling blocking Database calls, etc') that require servers to support multi-threading or other concurrency models. &gt; Maybe you can define this as part of the rack SPEC... Funny story, but iodine started as a Ruby only implementation that offered an alternative to Rack's approach (passed a response object as well as a request object, allowing the response to be sent at any point, so code could be evented)... but nobody used it. Yes, perhaps we are stuck with what we've got. Developers resist change. &gt; Here are some of the problems I have... **Error propagation**: The API doesn't expose this server-side concern. It just drops the connection, allowing for client side recovery. This is similar to the WebSocket JavaScript API that might (or might not, as it isn't required by the standard) inform you about the error... and will drop the connection. It's also similar to the low-level network operations, such as the `write` system call in the C layer. Even when the data was "written", there's no guarantee that the other side received it, only that it was pushed to the wire (or, more likely, the kernel's buffer). **Back pressure**: This should be implementation specific. Iodine will do one thing, Falcon will do another. Again, IMHO, this isn't the API's concern. This is the underlying implementation's concern. In theory, that's why the `pending` method was [requested during the original discussion](https://github.com/boazsegev/iodine/issues/6#issuecomment-242201065), but I don't think this should have been a framework concern. **Timeouts**: The API doesn't expose this server-side concern to the WebSocket / SSE connection handler. As far as the connection handler is concerned, the connection is closed. Network code should always assume a connection might be lost. Disconnecting on error / timeouts doesn't add any overhead or complexity. **State machine design**: I think I don't understand your concern here. By nature, any persistent connection will have a state. But I don't see how this prevents a developer from writing sequential code when using fibers / threads / coroutines or even when using callbacks. Of course, I would probably avoid sequential code while others might prefer it, but the point is that both options are possible. **Integration with other operations**: Ruby gems will continue as they are, or they will change. Current database libraries perform blocking operations (which is why iodine has a thread pool) and maybe in the future some database operations could be evented (such as iodine's Redis connection engine). I assume coroutines would wrap IO.write / IO.read to allow for async database access (assuming there's no C library and the Ruby methods are the ones actually used), while iodine will probably use the thread pool to overcome blocking IO (as it does for HTTP). This isn't the concern of the server handling the WebSocket / SSE API except to the extent that servers should probably accommodate whatever developers want to use (or developers will switch to a server that does).
&gt; Rack is practically a CGI. The CGI model isn't a bad one. It scales using processes - then threads - then fibers. The model is the same and well understood, even with coroutines. Callbacks (including promises/futures), on the other hand, are a completely different model and completely change how you must approach programming. &gt; [Back pressure] should be implementation specific. On the one hand, I agree with you. On the other hand, it makes it very hard to reason about how code works. ```ruby while true send_message end ``` Does that consume all memory or not? I think by default it shouldn't. It's part of the contract of the interface IMHO, because it tangibly changes how you write any kind of non-trivial code. The model you describe regarding back pressure and timeouts is just too simple. While it might work with some toy examples, as soon as you try to do upstream databases, http RPC, redis, etc, things start breaking. The only tool we have for managing this complexity with any kind of sanity is `ensure` and you throw that away almost entirely with a callback-based state machine. &gt; I think I don't understand your concern here [about state machines] Try writing something with `async-websocket` that has sequential logic - e.g. get a users first name, last name, age and address. With error handling. Then try writing the same thing with callbacks. Make sure it's robust, correct and maintainable. I think we can see the difference pretty easily. &gt; I assume coroutines would wrap IO.write / IO.read to allow for async database access Nope, that's actually not how it works. `libpq` exposes concurrency as part of it's interface: https://github.com/socketry/async-postgres/blob/c3f16e47955301f3195e68e6653d3f87c23e1db0/lib/async/postgres/connection.rb#L50-L71 - your assumption about how this works is not uncommon though. 
&gt; `render` is a call to execute a template partial, calling it in a loop in development mode causes the template to be compiled multiple times... Depending on circumstances, it could also effect the final Rack response. The final rack response is often `[200, {headers: "foo"}, [String]]`. In this cases, the response body is a single String object and it's easily sent as an HTTP response body. However, looping through partial renders sometimes results in: `[200, {headers: "foo"}, [String1, String2, String3...]]`. In these cases the server needs to merge the String objects and the HTTP response time might be effected (sometime significantly). The worst case scenario (which occurs) is when the "body" object isn't a true Array, rather the `each` method call results in an internal callback to some other lazy rendering scheme (sometimes used for "streaming" responses)... ...In these cases the server might delay the response until all the callbacks were called since it might not be possible to finalize the headers before knowing the final data length. Although this is solvable using chucked encoding, it still consumes a server thread for as long as the `each` loop is running, resulting in a blocked thread. You might be looking at the part where the template is parsed, but there are other side-effects. &gt; it makes little sense for your app server to be paying the connection termination overhead... Because connection establishment and termination has a large overhead, load-balancers are likely to keep the connection to the application server alive (to be reused by another client or the same client). This means that, even with a load balancer, an application server might call the `select` system call while waiting for a large number of open connections... potentially too many clients for the `select` system call to handle correctly. This is why it's better if application servers support `poll`, `epoll` or `kqueue`.
&gt; Depending on circumstances, it could also effect the final Rack response. No, it doesn't. We're talking about this function: https://github.com/rails/rails/blob/master/actionview/lib/action_view/renderer/partial_renderer.rb#L297 This has _nothing_ to do with anything you are describing, not in the least. It sounds like you are vaguely talking about streaming responses with is an entirely different topic than how partials are rendered. &gt; Because connection establishment and termination has a large overhead, load-balancers are likely to keep the connection to the application server alive (to be reused by another client or the same client). You should be configuring your load balancer to termination the connection and maintain a pool to the backend that roughly looks like the size of the backend's thread pool. Otherwise you are vulnerable to a connection flood that will take out your app server. 
&gt; We're talking about this function... You're right, I think I was mixing it up 👍🏻 &gt; You should be configuring your load balancer to terminate the connection and maintain a pool to the backend that roughly looks like the size of the backend's thread pool... Thank you for the suggestion. However, this approach **costs (more) money**. Limiting connections per worker and using more workers / machines is great, but it's cheeper to use better application servers that can handle higher throughput and aren't as effected by connection flooding attacks. Another concern is that **this approach isn't always viable**. How would you do this on Heroku, where [multiple connections might be "alive"](https://devcenter.heroku.com/articles/http-routing#simultaneous-connections) even if [concurrent requests are limited](https://devcenter.heroku.com/articles/http-routing#request-concurrency)? Note that this weakness doesn't require concurrent requests. Keep-alive will probably remain alive for 40 seconds (give or take), or longer. A slow client might open 2000 connections, at a rate of 50 per second sending a single request per connection and keeping the connections open. This will (potentially) brake a worker that's based on `select` unless there's more workers to shoulder the load (at which point, this becomes a race). Having said that, this is definitely a very valid point. I'm not sure I would agree with the math. AFAIK Nginx will return a busy error when [the `max_conns` limit](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream) is reached, and between preparing a response and sending a response (which are two separate events), servers might be able to provide service to more requests than the number of threads they have... but it definitely solves the issue when limiting connections to a low threshold.
&gt; The CGI model isn't a bad one. It scales using processes - then threads - then fibers The The CGI threads / fibers are the solutions people are finding for the CGI approach... and these solutions come with limitations. They don't solve, they mitigate. Their existence doesn't mean CGI isn't bad... while(true) { send_message } Yes, this is probably bad code. Where would it fit in a developer's application? ever? A fast enough client will consume all the data at the same speed that it's sent and the CPU will spin endlessly. A slower client will either allow the CPU to rest while blocking the thread / fiber (between blocking IO calls), fill up the memory (on an evented server) or hit a security block (disconnecting). There's a limit to what a server should protect itself from. Developers should be considered "safe", if not necessarily competent they can be safely assumed to be "not malicious" (if they want to break it, it's theirs). &gt; The model you describe regarding back pressure and timeouts is just too simple. Maybe. I don't think it is. Then again, I tend to design things in a very minimalistic / lazy way. Data goes into a persistent database, a message goes to the client. The client ACKs, the data is either deleted or marked as read... did we loose connection? The client gets the data at least once (+1 for ACKs). &gt; Try writing something with async-websocket that has sequential logic - e.g. get a users first name, last name, age and address... I'm not sure I ever wrote a backend API that had sequential logic. The whole of the logic you described would probably fit in the same API call with different arguments (set + parameter list / get + parameter list , both probably using JSON). I don't think I ever designed a sequential API... maybe because HTTP is stateless and it's still at the root of many design choices, or maybe because networks are fragile and I might need to stop/resume anything mid-stream. &gt; libpq exposes concurrency as part of it's interface... Yes, this is often where coroutines start falling apart - there's just too many of these function calls to cover. The moment you use libpg, you're out of Ruby. Suddenly, wrapping the `write` call isn't enough. Even in C it probably isn't enough, because it's a dynamic library and it might use it's own name resolution... so it has to be coded separately. Then again, with a good enough coverage, you're probably enjoying all the advantages (and disadvantages) of threads at a fraction of their cost. **P.S.** I'm not against coroutines. I just see them as equal to threads. The fact that they use less memory or that the blocking IO isn't really blocking under the hood isn't relevant when it comes to their functionality. And I'm not a fan of multi-threading. I like the idea of sending a laundry list of tasks to some callback secretary rather than sequentially handling all tasks.
All makes sense, that’s the exact value of coroutines, plus determinism, but can scale 100000x the ceiling of threads.
Yes, they do offer much better scaling 👍🏻 FYI, my quick calculation, based on a 2Mb thread stack size and approximately 64Kb fiber stack size (I didn’t look at Ruby, these numbers are from a different library) then it’s about 1:32 rather than 1:100K... oh, and the context switching price is usually similar 😉
What’s updog 
do you have any example with iodine and rails, that is not hello world?
I admire your work, but such aggressive product marketing can be discouraging. You really should be very clear, that you are the author of Iodine. 
Not sure I agree fully.. I think I'd rather have my users see "high server load, please try again later" rather than them use an insanely slow checkout system that perhaps is so terrible it forces them to give up and never return. 
The fact that this is "super alpha, unstable, no tests" doesn't really motivate me to read about it... When I've built things in the past, I typically wait until v1. 0 before sharing the work. 
Nice to know Idione which is what I’m looking for websocket, in additional, could build in Crystal language whichever is a good fit for production use.
A single modern CPU core can do about 100 million context switches per second. An 8-core CPU approaches 1 billion context switches per second. Of course you'd probably want to do other work between those context switches, so let's say between 1-10 million context switches with useful work done between. Here is an implementation for Linux amd64 I wrote: ``` .globl coroutine_transfer coroutine_transfer: # Save caller state pushq %rbp pushq %rbx pushq %r12 pushq %r13 pushq %r14 pushq %r15 # Save caller stack pointer movq %rsp, (%rdi) # Restore callee stack pointer movq (%rsi), %rsp # Restore callee stack popq %r15 popq %r14 popq %r13 popq %r12 popq %rbx popq %rbp # Put the first argument into the return value movq %rdi, %rax # We pop the return address and jump to it ret ``` Here is that code being benchmarked on travis, on 1 core: https://travis-ci.org/kurocha/coroutine/jobs/457144080#L782 With regard to stack size, you can get away with as small as you want. Some implementations use stack copying and use tiny stacks. The practical minimum would be 4kb, but you could do as low as a few 100 bytes per coroutine. Certainly not with Ruby, but 16GB of ram with 4KB stacks will get you around 4 million simultaneous coroutines give or take. e.g. https://github.com/hnes/libaco states "It is extremely memory efficient: 10,000,000 coroutines simultaneously to run cost only 2.8 GB physical memory (run with tcmalloc, each coroutine has a 120B copy-stack size configuration)."
Ah, right, readme wasn't updated. That's great that that works for you, but I sincerely doubt I'd wait for 1.x to release every idea I have as I use gems as proof-of-concepts for other people to build on and learn from. Insofar as them not being tested or documented, I would invite you to read through the comments on \`Qo\` as an example of a pre-1.x gem I work on. I used it as a PoC to demonstrate Pattern Matching in Ruby while it was being debated on the issue trackers, and it made the point I wanted it to make. That said, I still find use for it in my applications and gems, including this one. This gem was the result of a dive into TracePoint and trying to expose a more fluent API around it. You likely read the Readme at its 0.0.1 version, which was the first "show that it works" pass. I do that to get feedback from people I work with and chat with, which is very valuable to the development of an idea. To restrict the release of a concept to some ivory tower ideal of being 1.x ready just does not feel very Ruby to me. We hack, we share, we improve, and we learn. To stymie that would be unfortunate.
So basically you want to replace the lines in the file? That's a bit tricky to do without first reading the first file. What about this: +[u@test devel]$ cat test a b c d e f +[u@test devel]$ cat test.rb file_name = 'test' lines = File.read(file_name).lines lines.map { |line| line.gsub!(/[^a-z\n]/i, '\\\\\&amp;') } File.write(file_name, lines.join('')) +[u@test devel]$ ruby test.rb +[u@test devel]$ cat test a\ b\ c d\ e\ f I dunno, there's probably more "ruby" way to do this but like this it's fairly readable and obvious what's going on. WARNING: This requires reading the whole file in memory first, so don't try this on "big" file (big being bigger then few gigabytes). 
I mean why not? They probably learn at least something.
I'm disagreeing that it can be boiled down to a single advice without considering the specifics of the situation. In this specific instance, the issue is that a String is not generally an ISBN. An Integer is not generally an ISBN. What you're carrying out is a conversion that is likely to sometimes fail, and that should be clearly signposted as "here be dragons". This is why e.g. `#to_a` is deprecated; the `#to_i`,`#to_s`,`#to_a` etc. methods are sloppy conversions that may or may not give you a result that makes sense. There's a reason there's only a few of them that acts this way, for very basic classes, and a reason why you should be careful about using them. In some instances they are justifiable, such as for debug output. But for a lot it isn't; it's why we have the much stricter `#to_int`,`#to_str` and the like that explicitly only exist or should exist on classes that are close enough. Attaching a `#to_isbn` method uncritically is perpetuating a lie that you can uncritically treat these objects as ISBNs. It is also why we have `String()`, `Array()` etc. to create a much clearer signpost that says "we're taking an input that may or may not fit, and trying to do a reasonable conversion, and you may get an exception. (e.g. `Integer(0)` will raise), and that isolates the responsibility of defining the conversion away from the source class. Case is a more appropriate solution here because it is honest about what we're doing: We're explicitly taking an input that is *not* inherently a ISBN, and saying "it's ok to do this conversion in this case if it matches these constraints, we know this because this is the code that knows what an ISBN *is*". Attaching a conversion method to those objects gives the wrong idea: It's *not* going to make sense to try to convert an arbitrary integer to an ISBN. And it's a violation of expectations for a conversion method to be present but throwing, so either it violates the pattern set by the built in conversion methods on String etc., or it will not raise appropriate exceptions. Doing it as a refinement is certainly better than monkey-patching, because then you're at least signposting slightly more clearly that you're about to do something weird, and reducing the amount of code where integers, strings and the like has a method that is giving misleading signs about what is going on. But you're still attaching methods that break expectations onto objects that will also include objects that certainly are not ISBNs. &gt; but it is common amongst people using message-passing models, it shouldn't be painted as an unusual idea in message-passing models. The point of message passing vs. method calls, and why Alan Kay argues it is one of the most central aspects of OO, is the distinction between whether or not it is the *environment* or the *object* that decides how to treat a method. Refinements in Ruby lie about this. Our "method calls" are conceptually message passing thanks to meta-programming, method_missing and send, yet when you add in a refinement you're conceptually overriding this, so that it still *looks* like we're asking the object "to_isbn", but we're not: we're asking the refinement. It's not genuine polymorphism - it's not changing the object or class, it is temporarily altering the method lookup within the relevant scope to inject a separate stage to the method lookup. It's fundamentally in conflict with message passing for that reason: it's doing the faked method lookup entirely within the using scope. This code illustrates just how thin a veneer it is: ```ruby module Ref refine String do def to_blah :blah end end end class String def does_to_blah_exist? to_blah end def method_missing sym if sym == :to_blah puts "to_blah does not exist" end end end class Foo using Ref def blah(str) p str.respond_to?(:to_blah) p str.public_methods.include?(:to_blah) str.does_to_blah_exist? str.to_blah end end p Foo.new.blah("42") ``` Using polymorphism is the right choice when you're asking an object about something *it* should know. And hence, it's perfectly fine for one of the conversion options to be to check if an object *does* respond to `#to_isbn` or the like, and use polymorphism then. If you want to use a *message passing* variant of dispatch by type for conversion instead of case, coupled with polymorphism for objects that genuinely know that can be converted, you can do this: ```ruby class ISBN class ISBN def initialize(ob) @val = ob end def to_isbn self end class &lt;&lt;self def from_integer(ob) ISBN.new(ob) end def from_string(ob) ISBN.new(Integer(ob)) end ... add as many conversion methods as makes sense ... def convert(ob) if ob.respond_to?(:to_isbn) ob.to_isbn else send("from_#{ob.class.name.downcase}", ob) end end end end def ISBN(ob) ISBN.convert(ob) end class ConvertibleToIsbn def to_isbn ISBN.new(1234) end end p ISBN(5) p ISBN("5") p ISBN(ISBN.new(42)) p ISBN(ConvertibleToIsbn.new) #p ISBN("x") #p ISBN(nil) ``` (If you uncomment the last two you'll get exceptions, as you ought to). The ISBN() helper is not needed, you could just call ISBN.convert() directly, but I *like* the convention of the classname() methods. Though in this case, this is excessive, it may well be a decent solution if the conversion logic is complex. It puts the logic where it belongs: In the class that is responsible for knowing what an ISBN is and how it works, and it creates a clear visual sign that "I'm about to interrogate this object to find out if it is convertible" vs. suggesting that you just assume it is as calling a method directly does. It also makes it clear where to look for the documentation of the conversion. 
https://ruby-doc.org/core-2.6/doc/regexp_rdoc.html#label-Special+global+variables
That's understandable too. It greatly depends on the site. If it is an ecommerce site then yes. Amazon has proven through statistics what latency does to their sales and it is significant. If it is a SaaS business then swap away. Swapping for 15 minutes isn't as horrible as the site going down and breaking the SLA uptime.
All posts / websites / podcasts with arguments aren't much useful either. &amp;#x200B; I mean, people spend hours debating whether or not Ruby is dying. This website is quite the opposite. It just states a point and lets us move on. &amp;#x200B; Why all the anger?
I made the switch, at the end they're very similar. VScode has been pushing out awesome update after update and I think in the long run will be the superior editor.
Well, in my opinion the best is RubyMine, but if you want an answer, I’d say try VSCode, see if it fits you and decide. From my experience, both editors offer similar features and support quality. They are equivalent, but with a tendency for VSCode to innovate more. Also, atom seems more and more abandoned: nuclide and atom-ide are dead because Facebook don’t support them. Meanwhile, Microsoft is investing a lot in VSCode development since the beginning.
No
Try vim or emacs.
Thank you and apologies. I thought I did mention that, but that was apparently on the other thread. I fixed it. 
cool, plans to stream more?
It doesn't matter is the correct answer. Pick an editor, become proficient with it by learning as.many shortcuts as you can.
&gt; But Ruby hardly ever uses select internally (AFAIK). All standard library network libraries [used to use IO.select directly and now use the `io/wait` primitives](https://github.com/ruby/ruby/blob/trunk/lib/net/protocol.rb#L45-L46). I think that they fall back back to `select` in BSD systems, but I'd have to check on that again. However, other widely-used community gems use `IO.select` directly. [Here's how redis-rb uses it](https://github.com/redis/redis-rb/blob/master/lib/redis/connection/ruby.rb#L67-L79), and we're talking about smth used by sidekiq and resque, so it affects a lot of products. I could dig up a few more skeletons if I'd dig http clients and other network-related tooling. And this shouldn't be surprising. Most articles you find over google on how `Timeout.timeout` is dangerous will suggest you to use `IO.select`, because it was the available option at the time. To a certain point it still is, as ruby doesn't provide a way to wait on IO using system-dependent APIs like epoll or kqueue. In a way you feel like they only provide a `select` interface because, for all of its faults, it's a pretty stable API. Point being, if you argue that I shouldn't be using puma because of it's `select` usage, that's probably not going to fully solve the problem. 
&gt; Technically, the issue could also occur when too many "keep-alive" connections crowd a single Puma process Given that virtually all ruby application server usage is proxied, I'd say this is not an avenue worth exploring. 
&gt; Given that virtually all ruby application server usage is proxied, I'd say this is not an avenue worth exploring. True... which is why I’m not blaming Puma. Rather I blame ActionCable for not being more aware of its platform of choice and it’s limitations. 
&gt; Given that virtually all ruby application server usage is proxied, I'd say this is not an avenue worth exploring. True... which is why I’m not blaming Puma. Rather I blame ActionCable for not being more aware of its platform of choice and it’s limitations. 
After reading through your post history, I’m very impressed. You obviously know your shit. I’m assuming you aren’t looking for a job but thought I’d ask anyway. 
After reading through your post history, I’m very impressed. You obviously know your shit. I’m assuming you aren’t looking for a job but thought I’d ask anyway. 
You can also do this at the class level. I’ve had a few situations where private methods grew too complex so I extracted them to classes. They still felt like a private implementation detail that I didn’t want exposed. Private constant scratched that itch better than anything else I’ve tried. 
Iodine works with Rails out of the box. Just replace the Puma gem with the `iodine` gem and comment out / remove any Puma specific initializations (config/puma.rb). Or do you mean WebSocket examples?
What is this point of this? Eagerly opened hoping for actual contract programming
Both are nice but both are built on the Electron.js platform, which is a bit of a memory hog at times. IME VSCode is a bit better, memory wise and monthly maintenance related, and of course is backed by Microsoft so it gets monthly updates. If you have memory concerns Sublime Text is king IME (staying in the same vein of editor) BUT of course it's not free which is why the other two came into existence. They (VS/Atom) are mostly reverse engineered, e.g. key mappings, plug-ins, from Sublime Text for what it's worth. 
It used to be called thefirehose bootcamp but they got acquired by trilogy education and I’m taking it at UC Berkeley Extension 
will be fantastic for both. we are using puma and also action cable :) so an example with some numbers will be greatly appreciated. Plus is a good marketing :) same for falcon, from u/ioquatix
&gt; All standard library network libraries (including net-http) used to use IO.select directly... For single IO polling ([IO#wait](http://ruby-doc.org/stdlib-2.2.6/libdoc/io/wait/rdoc/IO.html#method-i-wait)) Ruby will use [`ppoll`](https://github.com/ruby/ruby/blob/a2eb04f52dccb9b42404f8b133acb36b577e3b54/thread.c#L4122) when available, [fallback on `poll`](https://github.com/ruby/ruby/blob/a2eb04f52dccb9b42404f8b133acb36b577e3b54/thread_pthread.c#L2003-L2031) and only later [fallback to `select`](https://github.com/ruby/ruby/blob/a2eb04f52dccb9b42404f8b133acb36b577e3b54/thread.c#L4172-L4243). This approach should include `poll` support for all BSD systems. &gt; if you argue that I shouldn't be using puma because of it's select usage, that's probably not going to fully solve the problem. There's a huge difference between the way Sidekiq, ActiveRecord, Redis and friends use `IO.select` and the way Puma does. The database connections are all established during the server's initialization stage and are managed (or should be managed) using a connection pool. With any reasonable amount of database connections per worker (let's assume 50), the file descriptors used by these resources will not reach the 1023 value limit. For this reason, these resources (unless abused) should be safe enough. On the other hand, **new connections**, ones established while the server is already running, aren't guaranteed a low file descriptor numerator. In these cases, the `IO.select` call becomes dangerous. Even at that point, Puma could have beed fine, since it's likely that the managing proxy wouldn't allow more than a limited number of concurrent requests and a few trailing "waiting" connections... although we're assuming a safe proxy setup (which might not be what you get on a default Docker container, this really depends). But not with WebSockets in the picture. At this point, all bets about connection limits are off... 
42 seems like to many. 
I'm a bit surprised that file serving is part of iodine. Most developers just use nginx go serve static files. Can you elaborate on why one would use iodine instead?
I was a vim user, then sublime, but for the last 5 years, rubymine. No regrets :)
I wouldn't use iodine for static file if I could use Nginx... but the truth is that this option isn't available on some platforms. A very good example is Heroku, where it's either static files that can be accessed through a CDN or static files that are served by the Ruby server. On such platforms, the use of the static file service (i.e., `iodine -www ./public`) is a wonderful performance booster for those assets that aren't on a CDN or for those pet projects that don't use a CDN (such as POC projects).
Nope, not looking - but thank you anyway 🙏☺️
Technically, instead of doing `argument == NO_VALUE_PROVIDED`, you could use `NO_VALUE_PROVIDED.equal?(argument)`. This would eliminate any possible funny behaviour caused by objects with weird equality implementations. 
Yep! Just have to get a good list of topics going. This one was done blind, so I had no idea what I was going to talk about, just that I'd be playing with TracePoint. I may do something similar for s-expressions later, as I have ideas that involve manipulating Ruby code for things like upgrades. 
Yep! Just have to get a good list of topics going. This one was done blind, so I had no idea what I was going to talk about, just that I'd be playing with TracePoint. I may do something similar for s-expressions later, as I have ideas that involve manipulating Ruby code for things like upgrades. 
Both effectively owned by Microsoft, will be interesting how this plays out
It's actual contract programming with ruby. See &lt;https://github.com/openblockchains/programming-cryptocontracts/blob/master/ponzi_simple.rb&gt; as an example. What are you missing?
My bad, thought you were being satirical. Just getting my bearings in rials and I guess I missed something when I looked through your code. Could you describe in words how this runs?
I see your point, and perhaps my original comment was a little harsh, sorry. My comment was largely in regards to the first impression I got from reading the README (which, after all, is what you've effectively linked us to) - e.g. "I haven't bothered testing it yet". The accuracy and importance of such statements sometimes matters less than the impression it can give readers. 
Very cool, the edge-node solution. Thoughts if I kept my approach, but then found a way to insert directories into the right places? Would it be a clumsier, unnecessarily complex approach compared to yours?
I'm using Atom with the vim-mode-plus extension and the vim behavior is better than actual vim, IMHO. I'm sure all of it could be done in vim but I've never enjoyed messing with vim config.
The comments right on the top of the ruby script tell you how to run the contract. Note: All sample contracts are "stand-alone" scripts (and only depend on lib/universum.rb - the blockchain machinery): # to run / test - use: # $ ruby ./ponzi_simple.rb For more it's best to read the book / articles. Not sure if it's a good idea to paste it all in here for your convenience :-).
How it's support for macros? That's probably the part I've missed most every time I've tried any of the "turn-into-vim" extensions in any editor/ide.
All code editors now owned by Microsoft, thats why i've switched to Word.
Practically the same thing. Both made with electron, both owned by microsoft.
Cool, I followed. Trying to find more ruby streams
Actually I think that is pushing it. I can see how it might not seem so at first, but look at what this expression is saying. It's not just telling `Order` that you want some records. It's specifically telling `Order` how to fetch those records. You're not actually talking to `Order` here; you're talking to a collaborator of Order - an instance of `Order::ActiveRecord_Relation`. This is a case where Rails is disingenuously hiding the fact that the LoD is being subverted, because `Order.includes` is first delegated to `Order.all` which returns the default scope i.e. that relation object. So in fact you are crossing into the collaborator of a collaborator. Nevertheless I might write the same initially, but upgrade the whole expression to a scope on `Order` as soon as I'm sure it's the right query.
Yes, this is how Rubinius differentiates between not-provided values and a provided `nil` in its Ruby implementation of the core library.
I switched to VS Code from atom, and it's actually rather good. The great thing is you can install it and try it for a bit and see if it's for you :)
No worries. To be fair I was testing it, just manually at that point. Just hadn't bothered with unit or integration level tests quite yet, as I sometimes tend to do when I don't know what an API is going to look like yet. Normally that happens whenever I had something I was playing with in a REPL that I more or less 1-1 converted to a gem wrapper to share it around. I may start using preview / prerelease for those in the future.
Jetbrains. 
First, that only works if nodes can be unique. You would get some serious issues with world cities, as there is a fair amount of repetition there. So you would need to deal with that, my solution doesn't go that far. Your solution might be able to tackle the above situation, that mine can't (as-is). So, it might not be unnecessarily complex. It might be simply more complex.
Not just technically, it's simply correct. The equality test is none of `argument`'s business, so sending it `:==` is downright wrong.
You’re making excuses for not coding. Both will do the same thing. Use VIM.
Spot on. Dot dereferencing across ORM associations is exactly where Demeter should be treated as a law, IME. I don't want code that traverses my entire database schema, because then it's _coupled_ to my database schema. What I want are _query objects_ that return data structures that I can couple to instead. The result is way less entanglement that way.
No because [Object#== and Object#equal? are the same method](https://github.com/ruby/ruby/blob/774c60955a725e378caded5e074863ceddb27ca8/object.c#L4084) PS: if you want to object and say “what if Object#== gets overridden!” first, that person is a huge jerk and second, that huge jerk would do the same to #equal?
Looks like it doesn't supports macros, and the couple of separate extensions that were started to implement them were abandoned long ago.
Going to be caching all of my twitch streams and other content onto this channel within 1-2 days of broadcasting content, still working on uploading yesterdays stream. These videos will stay up so you should be able to link to or reference them as you will.
It's not that crazy of a suggestion, OP obviously hasn't settled with an editor yet, what better time to give vim the chance it most certainly deserves? :)
There's still an important difference between `argument == NO_VALUE_PROVIDED` and `NO_VALUE_PROVIDED == argument`. That's the key point I was making. Using `Object#equal?` rather than `Object#==` is more of a personal choice, to make it crystal clear that this is using object identity. It also allows you to safely use other subclasses of `Object`. In reality, OP's method will work fine in 99.99% of cases. But if we're discussing *design patterns*, I would rather advocate one that will work in 100% of cases (assuming nothing *insane* is done, like redefining `Object#equal?`... which would likely just make ruby crash completely!)
It’s completely ok in either order as the constant is private and if someone goes to the trouble of making an object that’s the #== to the default object they either what they’re doing. When they’re going to the trouble of making an object that is #== to the private constant default they can also go to the trouble of redefining #equal? on the default object that will return true for some special object. There’s no way you can 100% any of this. Calling #equal? on the default constant is harder to understand because the caller has to reach into and manipulate objects they don’t own. The best *design pattern* is to allow extensibility in familiar ways that are easy to read, understand, and maintain. Calling #equal? on the constant is the opposite of this because it makes code that has none of those properties. Calling #== on the argument with the default constant as the argument is the best way because it hands control to the caller and trusts that they know what they’re doing. PS: Redefining any method on Object is bad, as many objects rely on the default behaviors.
Absolutely not. The constant here is an implementation detail to the class. It's absolutely none of `argument`'s business nor responsibility to determine if it is, or is not, equal to some private internal value of a class it may have never even heard of.
&gt; For single IO polling (IO#wait) Ruby will use ppoll That was a good refresh, I had forgotten where was that info. &gt; On the other hand, new connections, ... Granted, you're right about the redis sidekiq/resque scenario. But AFAIK no http client uses connection pools by default, as they can't assume same-server reconnects like the redis persistence client scenario. Nor smtp clients (unless you're using stdlib's, which as we've seen can use `pool`). These will still count as **new connections**, and will therefore be subject to the same limitation described, or not? I mean, I do think that you're touching a valid point regarding a known limitation of an API used in widely-adopted ruby software, and you're exploiting it to market your project, which I guess is fine. But I think that the bigger issue here is the enormous footprint of this API across ruby network-related OS software, and lack of alternatives using plain ruby core: Ruby only supports `select` and the aforementioned `ppoll`/`pool` shims, but none of `epoll`, `kqueue` or IO completions. NodeJS or go support these in the mainline on multiple platforms, providing stability and reducing friction. Ruby doesn't, and so we're debating implementation details, callback-based vs. coroutines, and all that is interesting for those in the know, but is ultimately pointless if I just want to nip-tuck some html pages in rails. I guess that node developers talk less these things :) . 
&gt; But AFAIK no http client uses connection pools by default... Yes, client connections **should** use the `IO#wait`, since their never know if they are running within a server context. The official NET::HTTP does... but private gems are harder to monitor and networking has a lot of little hidden details that are easy to miss. Maybe this issue will make some gem authors go "oh my god, I'm doing the same thing". &gt; I think that the bigger issue here is the enormous footprint of this API across ruby network-related OS software... This is a big issue. But I was talking about this with people for years and I was mostly ignored. Big issues are hard to change. But small issues - small issues spread like wildfire and help us all learn. I hope that this small issue will spread the idea that will eventually add an `IO#poll` or `IO::Collection#poll` PR to the language. &gt; you're touching a valid point regarding a known limitation of an API used in widely-adopted ruby software, and you're exploiting it to market your project... It's open source, I'm not really selling anything. **Iodine is free**. I'm just trying to shine a light on an issue and be part of the solution. 
The one you like. No one ever talks about this in the professional world (outside of casual conversation). I find that folks looking to leArn stumble on this a lot. It’s an artificial barrier to getting down to the work of actually learning to code. 
&gt; It is sometimes required for the methods with optional arguments to be able to differentiate between its default value and the value passed from the caller. I don't think I have _ever_ needed to do this. &gt; SomeClass#call Well, this may be why. `#call` is probably _the worst_ method name one can use. If you used meaningful methods you may have something like this: `SomeClass#handle_scenario_for_no_value_provided`, `SomeClass#do_something_with_argument(argument)` and you can let the caller decide. Reminds me of Fowler's [FlagArgument](https://martinfowler.com/bliki/FlagArgument.html). 
Possibly the first time I ever seen where using `#equal?` was the way to go. But, too bad the whole idea of `differentiate between its default value and the value passed from the caller` is just wrong. 
What a looser. Emacs!
Agree the wisdom of this whole approach is another matter. I’ll confess to having produced something similar myself though under pressure. Arguably if this is so necessary, perhaps the argument expected should be a refactored to a situationally specific parameter object. 
Would you mind sharing some of the things you enjoy about RubyMine? I’ve been on Sublime/VSCode since I began programming, but I recently have been interested in RubyMine.
In general, you are right, it's best to avoid flag arguments. I actually had to use it only once: [https://github.com/Azdaroth/active\_model\_attributes/blob/master/lib/active\_model\_attributes.rb#L27-L36](https://github.com/Azdaroth/active_model_attributes/blob/master/lib/active_model_attributes.rb#L27-L36) &amp;#x200B; This is for implementation of ActiveRecord Attributes-like interface for ActiveModel and I think this is exactly what was needed there.
&gt; No because Object#== and Object#equal? are the same method &gt; PS: if you want to object and say “what if Object#== gets overridden!” first, that person is a huge jerk and second, that huge jerk would do the same to #equal? `==` is overridden by _many_ classes including many from the stdlib (String, Hash, Array, Numeric, etc, etc) all override `==`. I don't really understand why you would be upset about `==` being overridden, it is weren't Ruby would be a very strange language. `equal?` should never be overridden and I don't think I've ever seen it overridden. 
I think it may be better if you also provide a specific example.
String, Hash, Array, Numeric, user defined subclasses of Object, Compable, user-defined modules, etc., &amp;c. are not Object. (You can determine this by `Object == one_of_those_things`.) If you wish you can `super` from implementations of #== for these listed Modules to Object#==. Definitions in these places do not override the behavior of Object#==. (They do not change the `Object.new == Object.new`.)
sure. - autocomplete - you can disable any plugin that you dont use - find/replace - you have js at your fingers(we are using vue) - css and saas, less - haml, slim, erb - refactoring that works - find usage - debugging but best just have a look here: https://www.jetbrains.com/ruby/features/
A note on terminology, Rubyists rarely redefine methods, replacing a definition with a different definition. We commonly override methods from the parent class where inherited behavior is incomplete or incorrect. Comparison protocols in ruby are frequently implemented such that the argument passed in may determine the behavior of the comparison, especially with #==. This general behavior of delegation allows objects of different classes to duck type to each other. It’s so common it’s baked right into ruby’s core library. Here in [String#==](https://github.com/ruby/ruby/blob/2210709b79222ecd2d9758f7316fdbd7c068ea84/string.c#L3259) where a string-representation (an object defining #to_str) asks the argument to determine if it is #== to the String that #== was called on. String#== trusts the user to know what they’re doing. It allows users to extend the behavior of String without redefining anything on String. You’ll find the same in Array#==, Integer#==, Float#==. You’ll also find #=== behaves this way, and see the same concept of delegation in the Numeric coercion protocol. This behavior of delegation is the opposite of what you claim to be correct and is foundational in Ruby. You can go on saying “never, ever, ever”, but this type of thinking limits the flexibility, extensibility, and usability of your ruby programs. PS: I’ve never seen rubyists like being forbidden from doing a thing and I’ve tried to forbid lots of things in very, very popular gems. This is a very silly hill to continue to try to defend. There’s even the refinements feature that allows users to isolate method redefinition to enhance safety when somebody thought “no, my users are forbidden from doing this!” and the user replies “I can, and will, even safely!”
You make some good points, but I respectfully disagree with you. The fact that the argument being passed to `#==` may determine the method's behaviour here isn't relevant, in my opinion. Take my hypothetical example above of the `EqualToEverything` class. The original design of the method being discussed was "If you don't supply an argument then do X; otherwise do Y". Just because I happened to provide a slightly weird object as an argument, why should this trigger behaviour X? That wasn't the intended design. It *shouldn't be possible* to trigger X when supplying an argument... Unless you redefine/override the method! In this case, I would favour using either a subclass or `Module#prepend` to redefine the method and make it extensible, if desired. I don't think it should be possible to change the method's behaviour, simply by passing in an unusual object. At the very least, this - in my opinion - breaks the principle of least surprise.
Good golly, you are so far off in the weeds and still going. Have fun out there!
Couldn't you have avoided the `NO_DEFAULT_PROVIDED` check by using`Hash#key?`? That way you would also gain some performance because the defined method body wouldn't need to go through return if provided_default == NO_DEFAULT_PROVIDED every time. That's what I have in mind: if options.key?(:default) provided_default = options.fetch(:default) # save because `key?` guard define_method name do return instance_variable_get("@#{name}") if instance_variable_defined?("@#{name}") provided_default.respond_to?(:call) &amp;&amp; provided_default.call || provided_default end else define_method name do instance_variable_get("@#{name}") end end Would this work?
Just to finalize, it's not as easy as just switching to IO#wait APIs. Those APIs only work on one socket. If one needs to monitor multiple sockets, then select is all we have in ruby core. So one does need a new API to circumvent select use. 
Hmm, this is a good point, I don't exactly remember why I went with that solution, but I suspect I might have seen it in ActiveRecord code somewhere when I was checking how Attributes API work and just did the same thing in the end, but the solution you proposed would work here as well. Thanks for the suggestion! 
Thank you for sharing, I never heard of programming stream with twitch (which indeed it's pretty logical). I wonder if there are other authors around.. _NB: The sound is terrible, maybe it's from me but I don't have any issue with other videos_
That requires you to change the ordering from the comment you replied to. `argument == NO_VALUE_PROVIDED` would use `==` from `argument` which could be anything. You have to write this as `NO_VALUE_PROVIDED == argument` or `NO_VALUE_PROVIDED.equal?(argument)` or `argument.equal?(NO_VALUE_PROVIDED)`.
Say you change the signature of the method across major versions. You can trigger the default behavior for the old version and allow the user to be compatible with either major version by passing an object that is equal to the special, hidden object with a tiny bit of extra effort by delegating through #== Or you can say “sucks to be you” and force them to do a ton of work to provide compatibility. You don’t know how software will change through time so allowing for flexibility is always the better path. 
I don't understand this comment. What do you mean by "trigger the default behavior for the old version and allow the user to be compatible with either major version"? Also, isn't one of the major reasons for bumping the major version when you *break* backwards compatibility? And lastly, I don't know what you mean by "ton of work"... You can use `Module#prepend` to override the behaviour in whatever other way you like, if need be.
Oh? How so? I'll look into it, still figuring out fine details on streaming so it wouldn't surprise me if something needs tuning. 
Looks like you only typed single underscores surrounding FILE. It should be two both before and after.
Formatted it for you class List attrreader :all_tasks if _FILE == $PROGRAM_NAME my_list = List.new puts "you've created a new list" my_list.add( Task.new( 'Make Breakfast' )) puts "You have added a task to the Todo List" end def initialize @all_tasks = [] end def add(task) all_tasks &lt;&lt; task end end # &lt;&lt; that looks like an issue class Task attr_reader # &lt;&lt; also an issue def initialize(description) @description = description end end
Oh really? Why is that needed? What is this line actually doing?
i was messing with it inbetween trys so probably did mess it up myself. 
`__FILE__` is a method that returns the filename of the file it is called from. `$PROGRAM_NAME` is a global variable that contains the executing command. It's common to check if those are the same and then take some action. If they are not the same it usually mean that the file was required from some other file, and then you want load the the file but not "run it".
so the end that you are saying is supposed to be an issue should actully end the List class and the to methods defined are in said class
wow thanks so much! so the program runner wasnt supposed to be in a class? that kinda makes sense.. 
At first I just did it with 4 spaces in front of each line, thats how markdown (what Reddit uses) defines a 'code' block. The rewrite, i did by hand knowing ruby.
Are you coming at this from java? Thats the only place where the script stuff is in a class that I know of.
actually yeah but i know java just barely more than i know ruby
The other way of doing a markdown codeblock is to put 3 backticks (\`\`\`) on the lines directly before and after the codeblock. ``` \`\`\` puts "this is code" \`\`\` ``` 
No, you're quite right. u/drbrain is arguing from a general position about the treatment and use of parameters and operators, and hasn't grasped (or refuses to accept) that the hack in the OP subverts and inverts the standard case. 
It's alright, I think the bottleneck could be the `find` method, if it's doing a full scan each time, it's gonna be a slow algorithm.
Ah, thanks. Is there a de facto "fast yet readable" way to pull this algo off?
Apparently that doesn't work for the "old" reddit view
The easiest way is to use a hash to cache some values, hash access is `O(log(n))` which is as fast as you can get. It's a fun exercise, as someone who interviews candidates and designs exercises I will consider it for future candidates. Here is my solution: https://repl.it/@gosukiwi/UnrulyBonySystemcall
How is \`find\` implemented? I think you can solve this problem with linear performance o(n) using hashes instead of arrays. require "awesome_print" class Node attr_accessor :children def initialize() self.children = {} end def add(filepath) descendants = filepath.split("/") add_filepath_descendants(descendants) end def add_filepath_descendants(descendants) return unless descendants.any? child_name = descendants.shift child_node = self.children[child_name] ||= Node.new child_node.add_filepath_descendants(descendants) end end countries = [ "World/Asia/China", "World/Asia/Vietnam", "World/Europe/Belgium", "World/Europe/Germany", "World/Europe/France", "World/Europe/Norway" ] world = Node.new countries.each do |country| world.add(country) end ap(world, raw: true)
&gt; But what if the Movement class needs to be different between a dog and a human? Seems silly to create a HumanMovement and a separate DogMovement class. Why does it seem silly? If the movement needs to be different, why wouldn't they be different classes? &gt; In composition, how do you extract similar behaviours which can vary slightly by the objects which use them? In general... with composition, again. 
&gt;Seems silly to create a HumanMovement and a separate DogMovement class. Why? That's a good separation of concerns. So what if they're both "movements"? The way I try to think about this is "what is different between these two similar entities". Then I try to extract that. Maybe you don't need a DogMovement and HumanMovement class, maybe your Movement instance just needs to take a `legs` parameter? I'm sure you've seen it but I come back to this video where Sandi Metz explains this a lot: https://www.youtube.com/watch?v=OMPfEXIlTVE
In your else statement, why not create a reference to that node you create, then push it into the array, then set current_node to that node. ``` child = Node.new(directory) current_node.children &lt;&lt; child current_node = child ```
This is not a conventional view, but I believe the noun based approach to object design makes it far harder to build successful systems with OOP than it needs to be. The first thing to understand is that all complex processes require state, and usually can be described as a state machine, at least from the perspective that it is useful to look at the world for the purpose of building software. A “shipment” is a state machine, and a process. An elevator is a state machine. You are a state machine, you do not have finite states, but you are a complex process which could otherwise be described that way. An object should have one responsibility, to do the thing it models. It likely requires internal data to do its job over time, that is its fields. To do something useful in a system it needs to collaborate with other objects, that is its dependencies. A big exception is data holder objects, which are glorified structs. But they are exceptional and not interesting in a design sense. If you focus on the process, everything comes out of that. To be clear, this is not conventional thinking. But I strongly believe it is sound, and in line with principle. Thinking this way caused many things to snap into place for me, I just wish someone had explained it this way to me sooner.
&gt; The easiest way is to use a hash to cache some values, hash access is O(log(n)) which is as fast as you can get. Hash access is O(1), at least in general, it could be worse based on collision rate. Your solution is kinda weird - You're storing a 'look up cache' in the 'tree' instead of just storing the children of each node as a Hash which would have the same performance characteristics without the memory bloat. What is being implemented here is basically a Trie would is a data structure I would expect most engineers to understand with some poking. I wouldn't ask a candidate to name it or regurgitate it on a whiteboard but isn't a pretty basic concept. 
In your context, you might be implementing what is known as a Strategy Pattern. Here's an example: https://github.com/nslocum/design-patterns-in-ruby/tree/master/strategy As other folks have pointed out, there's nothing wrong with separate HumanMovement and DogMovement classes - if they make sense in your design. What you are doing is deferring the behaviour to these classes, which makes your design much more flexible in the long run.
&gt; Hash access is O(1) Oops, you are right, most of the time it's O(1), I was thinking about binary trees for some reason... &gt; Your solution is kinda weird - You're storing a 'look up cache' in the 'tree' instead of just storing the children of each node as a Hash which would have the same performance characteristics without the memory bloat. Good catch, I implemented that before implementing the Node's `add`, I think it could actually go away! I updated my solution :)
Something really, really critical to keep in mind: Inheritance is not an "is a" relationship. Inheritance is a "is *substitutable* for" relationship. The pervasiveness of the belief that inheritance is an "is a" relationship is one of those pernicious myths perpetuated by and through developer culture that never seems to go away. It's one of those ideas like herpes that never seems to die, but has never been true. It's merely common. It's unlikely that the strategies used for two-legged movement and four-legged movement will be substitutable for each other given how specialized the mechanics are. And to head off the obvious next question: No, four-legged movement is _not_ composable from two two-legged movement strategies. Again, the mechanics are just too variant for any of these things to be _substitutable_ for each other while preserving the semantics (_mechanics_) of their respective purposes. Similarly, a rectangle and a square are not substitutable for each other. 
Here is my take on it, which is really rudimentary but gets the general idea: require 'minitest/autorun' class DirNode def initialize(value = nil) @value = value @children = {} end def insert(dirs) return if dirs.empty? current = dirs.first if child = @children[current] child.insert dirs[1..-1] else @children[current] = DirNode.new current @children[current].insert dirs[1..-1] end end def find(dirs) return @value if dirs.empty? current = dirs.first @children[current] ? @children[current].find(dirs[1..-1]) : nil end end class DirTree def initialize @root = DirNode.new end def insert(path) @root.insert path.split('/') end def find(path) @root.find path.split('/') end end describe DirTree do it 'works' do path = 'some/path/to/a/place' tree = DirTree.new tree.insert(path) assert tree.find(path) assert !tree.find('/some/non/existant/path') end end
[https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html](https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html)
There's also the third option, the Dark Horse, which is to not compose OR inherit. Just have a totally separate Movement object that is on your Person object, and that way the concerns actually are truly separated.
Oh, of course it's the array method! Coming from JavaScript land, I'm so unused to own methods being called directly....
Yeah, there's nothing special about `at` -- wherever you see that is calling `at(i)`, and then yielding the result! There are very few things in ruby that are special, mostly it's just methods. 
Methods... and so much sugar you keep thinking something is sugar when it's not
A section of docs on "how to use with rails" would help me try it out. Even if you think it's so simple it doesn't need docs... even if it's two lines it will be helpful. What if I want to have traffic proxied through nginx, how do I deploy? etc. 
"sugar" in ruby is usually just... methods. :) Methods that do so much you forget they're just methods, but they're just methods. 
Thank you for the feed back. That's very good advice. I'll do it soon.
I am really crap of describing things without an example So let me put an example here: ```ruby # inheritance class Movement def initialize(leg_count) @leg_count = leg_count end def step_forward "step_forward_with_#{@leg_count}" end end class Animal def initialize(leg_count) @movement = Movement.new(leg_count) end def step_forward @movement.step_forward end end class Dog &lt; Animal def initialize super(4) end end class Human &lt; Animal def initialize super(2) end end ``` Inheritance allow you re-use the code for similar behaviour However in some case it lacks flexibility Let's say there is a disabled human and he/she has 1/0 legs You can't represent that with the code above ```ruby # composition # Same Movement class as above class Animal def initialize(movement) @movement = movement end def step_forward movement.step_forward end end class Dog &lt; Animal def initialize(movement) super(movement) end end class Human &lt; Animal def initialize(movement) super(movement) end end ``` With the above classes the responsibility of specifying movement is shifted from the subclasses into the caller (that calls `Dog.new` or `Human.new`) And you can represent special instances for the same class now: ``` normal_dog = Dog.new(Movement.new(4)) normal_human = Human.new(Movement.new(2)) disabled_dog = Dog.new(Movement.new(3)) disabled_human = Human.new(Movement.new(0)) ``` For convenience you can assign default value (I prefer to do so with keyword arguments): ```ruby class Animal def initialize(movement:) @movement = movement end def step_forward movement.step_forward end end class Dog &lt; Animal def initialize(movement: Movement.new(4)) super(movement: movement) end end class Human &lt; Animal def initialize(movement: Movement.new(2)) super(movement: movement) end end normal_dog = Dog.new normal_human = Human.new disabled_dog = Dog.new(Movement.new(3)) disabled_human = Human.new(Movement.new(0)) ``` 
EDIT: my code doesn't have single quotes not sure why reddit added those.
Reddit's Markdown expects code to be prefixed with four spaces. "Fenced code blocks" à la Github isn't suported.
It does. I put the ``` in the code to demonstrate what I meant.
Nice, would be good to add a link to your Twitch channel here and in your YouTube description. https://www.twitch.tv/baweaver
"if username = users.has\_key?(username)" should be "if users.has\_key?(username)"
So happy to see Ruby running on Lambda, but I don't understand why Sinatra is necessary in this particular example. I would have thought that using API Gateway would provide better integration with the AWS stack and remove a dependency that will affect memory usage and startup times. Whaddamimissing?
 Inheritance is fine for the rare use cases that it was designed for. Ppl in the advent of UML and class diagrams started using classes and inheritance for everything and ended up with a closely coupled heap of mess. Then ppl started saying that inheritance is bad and composition should be used. I think this generalization also misses the point. I can't really tell you if Movement class is needed or inheritance is good or bad in that example because you would have to tell a lot a more about what these things do in your system. What you said so far: &gt; if I had a human class and a dog class I might have a Movement class with a step_forward method. gives me this: That's not how I initially would think about stepping forward. Stepping forward is something a Human or a Dog can do. hence I would put a method into a class that models things that can step forward. Without more it's just one class, and can be instantiated for many things between which the system does not distinguish, as it doesn't need to. Systems should be designed for objects and interaction between objects, where implementation often reveals Objects and Classes invisible to the system domain. (These are revealed once you have code, and you can re-factor the code to incorporate them.) Patterns can help you here, especially if you have smelly bits of the code, you can try imagining different patterns applied to that code, and *if* one you think improves it you can apply it. Designing systems on a whiteboard with a bunch of diagrams without a single consideration of the algorithmic behaviour of the system inserting textbook examples of patterns so we feel educated and good about it is worthless. Results in bad code that's full of YAGNI constructs.
Yah. You're assigning the result of users.has_key?(username) to the username variable. #has_key? returns a boolean already, so you just use it alone in your if test. Also, chomp always returns a string, so no need for the #to_s calls. Also also, next time, either indent with 4 spaces, or use pastebin or a gist to share your code. :-)
You're not missing anything, apart from maybe extensibility in the future with different paths, but still, it doesn't make any real sense to use Sinatra here.
Seconded. There's nothing silly about naming classes according to their purpose, and I came here to recommend the same video. No-one else teaches OOP with such clarity as Sandi Metz. 
The goal of the tutorial is to show Rubyists how easy it is to deploy code to Lambda. AWS offers a ton of services and it can be pretty overwhelming to the uninitiated. I wanted to write a tutorial that shows Rubyists that they can leverage tools they already know and still start playing around with Lambda.
For reddit formatting, write your code "normally", then indent the whole thing by 4 spaces. (This is easy if you use a decent text editor.) Don't use back-ticks.
Nicely done, nicely written up, thanks!
IIRC it's Evil Martians' creation, and they use it.
Chef uses Ruby based DSL. So if you're full-stack or DevOps, Ruby knowledge helps.
I'm a bit lost on that "why not" section - it says that timecop can accelerate time but it also hints that the built in helpers can too.
you’ll likely learn a lot more about object oriented programming and enterprise systems in the ruby community. and you’ll find a much more elegant language than python. given it isn’t a popular language in areas outside of web applications, you’ll likely find yourself learning other languages for data analysis, mobile, or other applications. and that’s a good thing too in the long run. 
I started working through Zed Shaw's Learn Ruby the Hard Way and right off the bat the whole concept of #{codehere} is very fascinating. It's so much cleaner than breaking everything up in python. I think I might like this...
Ruby is used in a lot of projects. It's used in server maintenance and tooling as well as developing web backends. It is a fully capable language, and despite some of the anti-hype you might hear, it's got more in common with Python than most people are willing to believe. Both languages are interpreted, both suffer the ill effects of the GIL (Global Interpreter Lock) and more. Be aware Ruby is what powers a lot of things on the internet, like Github, Gitlab, Airbnb, Salsify, and more. Why would you use Ruby? Well, for much the same reason you use any language. Because you want too. What are your particular metrics for wanting too? Are you super dependent on having absolute performance or scale that exceeds millions of users? Well, probably don't \*really\* want either of the two main languages you mention. However, attempting to exceed those limitations with either language will teach you a lot about scale, and the real limitations of the language versus what people rant about. What are some things Ruby is weak with? Well, Ruby's graphical libraries leave a bit to be desired. Does this mean it can't be done? Not at all, but you might be taking an adventure into designing a wrapper around some graphical tooling in another language and then building Ruby bindings to that library. Just in regards to what you're talking about, I've done all four of the projects that you've mentioned, and one at a very large scale (scraping data from Charity tracking websites to generate information on where Charities are spending and getting their money from.) in Ruby. Of particular note, I built my own console library, not because I needed too, but, because i found it to be an interesting problem and I wanted to know how to solve certain pieces of that problem. Bots are fairly simple. I have coded tools for interacting with Reddit, Trello, Jira, Twitter, and various forums I participate in. There's a number of people, including myself, that have toyed with MUD servers written in Ruby. Nothing of super scale here, and while it's a tangent unrelated to what you're asking, I feel like for some reason I should point out exventure. It's actually an Elixir project, but, it's in the vein of a MUD server / game :) Hope this helps out some. 
sounds like a plan. you’ll find that ruby has gathered lots of nifty ideas that are found scattered across many other languages. in future, you’ll come across them elsewhere and be delighted you know what they are. ruby really sets you up for becoming a polyglot. no diss on python, which is a swell language, but i always find pythonistas reluctant to leave their shell. 
Very cool, thank you for the reply. I'm far FAR far from being able to adequately evaluate anything related to building a MUD server, but it's simply one of many project ideas I could think of that I could use as a vehicle for learning. Since you've done large scale scraping, may I ask; What is the difference of Scrapy vs. Nokogiri? Do you have experience with both? At a glance (of someone who is just learning) nokogiri looks like a more powerful version of python's BeautifulSoup but isn't a full on framework like Scrapy. But what the heck do I know. Any thoughts? I only ask because I find money to be a fast motivator - if I can get to the point where I can complete simple to moderate web scraping projects decently enough, I could solicit myself on freelancing sites like Upwork perhaps and make some beer money on the side: which does a few things. Creates strong incentive to get better and keep learning. Lets me perhaps save enough expendable money to buy a better machine (currently using my work issued laptop for this which is far from ideal) and also gives me some exposure to professional work, marketing myself, setting expectations and general work flows of doing development for other people. anyway, thanks so much. 
oh, and pick up russ olsen’s “eloquent ruby” once you’re past tutorials and are trying to write some ruby code of your own. his book greatly motivates *why* ruby does it the way it does. 
I'm processing all these comments slowly, but to answer your question quickly, my `#find` is: def find(node, value) if node.value == value return node else node.children.each do |child| result = find(child, value) return result unless result.nil? end end nil end &amp;#x200B;
Once I have some spare dollars I definitely will. Thanks for the recommendation. 
to be fair in py3 you can do f-strings ``` f"hello {name} the weather is {weather.in_f}." ```
I'd personally recommend why's poignant guide.. In my opinion it was great introduction to Ruby including irb since it kept away from the dry and unemotional passing of knowledge that most of the other books on programming suffer so much IMHO... It's free too.. Maybe a little bit outdated but enough for learning basics
To really answer that, I'd need to be a lot more experienced with Scrapy. I'll do some research and see if I can get you a sensible answer. Right now, my ignorance of the Python libraries past using them and referencing the documentation prevents a super skilled answer. In general, I find nokogiri to be fairly usable for most requests and was what I used in my large scale project. Although, that one was a very interesting exercise in using an alternate Ruby implementation (JRuby), threading, and dispatching the work of parsing many links to individual workers. The way nokogiri frames some of the querying into a very ruby-esque feel is part of what makes it enjoyable to me, but, this is always a double edged sword. Thankfully, nokogiri also supports implicit selectors and such as well.
Stripe is built with Ruby but **not** Rails.
i am the only dev who uses an IDE at my company of 30 ruby devs. same thing when i worked for a fortune 500 company. that said, im faster and higher paid than most devs... i owe that to my IDE, im not that smart
I just googled this and......what in the universe...this is so strange. I'll definitely bookmark this for later. hehe
It is a bit strange but I found it amusing which 99% of the books on programming cannot say :D
But this is an example of why I'm attracted to Ruby. Ruby is quirky. It's practitioners are weird. The whole thing just doesn't make any damn sense. But code wise it's as clean and simple as you'd expect something made from Japan to be. so strange. 
when i was a professional ruby dev, i just used emacs, without a lot of fancy packages. most of my teammates used vi or sublime. we had one ex-java guy who used rubymine, but he was definitely the exception.
I'm not sure this is a gem I'll be using -- it seems like we all wound up with our own implementations of type-enforced data structures that we're all happy with for slightly different reasons (I tend to use [Eventide's](https://github.com/eventide-project/schema) for obvious reasons). However, I want to list several things I'm really impressed by: 1. You've respected us (the audience) by capturing our attention with a reasonably complete solution, rather than something that is in-progress or half baked. This is language communities get better tools (*shudders to think about the javascript ecosystem*) 2. An overall, coherent design philosophy is evident. Because of that, I can imagine the possibility of a constructive discussion about our differences in design philosophy, instead of litigating whether the code seems "better" or "worse" than alternatives. 3. Respecting the need for users to sometimes operate without safety mechanisms is important. "Don't freeze objects you don't own" is a sound line of reasoning even for people who prefer to freeze their data structures. I say that as a card carrying member of the "don't freeze objects in Ruby ever" camp. 4. It's apparent that you've studied other libraries and have actually put thought into their most (and least) desirable traits. You're not just indulging a programmer's itch to make their own thing popular. 5. This line right here: &gt; All future versions should be backwards compatible. Because the gem is “finished,” I don’t see any reason to introduce breaking changes. You don’t need to do shotgun surgery if the public API never changes. That's a declaration of _stability_. You've signaled that you've more or less finished the library. Sure, software is never "truly" finished -- there's almost always opportunities for further improvement -- but you've delayed your public release until you feel comfortable inviting coupling. If only everyone understood how important this was... Thanks for this contribution.
I am one of the few devs who use Vim at my company, we are a contractor and work for many fortune 500 companies, that being said, I'm faster and higher paid than most devs... I owe that to Vim, I'm not that smart. /jk hope /u/olddang45 doesn't get offended ^^; You can use VSCode as much as you like, you will miss basically nothing.
im a fan of using the tool that makes you more efficient. thats why i dont really preach to others about it.
I learned using Sublime, but RubyMine has definitely made me a more efficient developer. Couldn’t recommend it more.
I agree, that's why I suggested OP to just keep using VSCode :)
I use emacs too, but I really like using the jet brains ecosystem. Rubymine is no exception. I also do a lot of work in c, python, and other languages from time to time. It's nice not having to fight a configuration file to get the right mode, and just have it work consistently the same, and intuitively. Emacs is great, but it feels like no two modes are built the same way.
For me, it's really about elegance and readability. I've tried many languages in my life but got stuck with Ruby because it's just highly readable if you code with it properly. Python is already inferior to this regard, and for other stuff it seems just similarly capable.
I agree. For example, I was curious about classes so I did a quick google and it was so plaintext I understood exactly what the chapter was trying to explain. Even though I've been learning for about.....uhh, an hour and a half. this is easier to read than Crime &amp; Punishment. 
Two of my colleagues use vs code. I use textmate. Honestly it all boils down to whatever you are comfortable with. They all work great
The only thing I really liked about the Jet Brains IDE's were the fonts. When I look at the Rubymine page, the font is rounded and beautiful. I wish I can make VS Code look like that. otherwise, I like everything else so far about VSC. Particularly the quick and lazy access to a terminal right in the window. Easy peasey. 
Stand-alone Ruby is great tool for Linux sysadmin tasks. There are a wide number of gems that support git, cloud tools, linux container libraries like LXC/LXD, in addition to Chef as was previously mentioned. There is also good support for cryptographic libraries and serialization protocols for doing serious work with microservices in cloud environments. What I like about Ruby is that you have your choice in flavors for different uses. Embedded apps? Use mruby. Corporate IT? JRuby or Truffleruby has you covered, and gives you native access to Java libraries. Want to compile to binary? Check out crystal which is pretty true to Ruby's syntax and uses LLVM to compile down to machine code. Want to build distributed systems? check out Elixir which is Ruby like syntax running on a 30 year old, battle tested BEAM interpreter of Erlang. There's an anti-hype cycle right now against Ruby as a language which is over played. Once you start to investigate the ecosystem you'll find that its much larger than just Rails. 
Yeah and what people neglect a lot in this industry is that quick understanding means high productivity. If someone can write correctly in this language he and his peers can progress so fast on a project ... But if people start to write like shit and variables are obfuscated then it's like in any language, pretty bad. The only real bad point about Ruby I noticed is it's really slow compared to Node, Elixir, etc. but I believe Python isn't any better on this, so yeah.
Lol. 
this is the kind of feedback I was hoping for. I don't want to feel like I'm missing out on the breadth of niches python can and is filling by getting into Ruby simply because I find it quirky and beautiful. What you mentioned, alone, is a lot of variance and paths to look into much much MUCH later. It's just good to know it isn't "rails or bust". :D
Some of the [best resources to learn GraphQL](https://reactdom.com/graphql)
That fixed it! Thank you so much. I see why that was wrong now too. Also zaph thanks for pointing that out, I forgot that . chomp makes things a string. I'm still getting the hang of things as you could maybe tell 😅 I appreciate the patience as well!
Done and done, thanks for the tip!
For 99% of my code through my 11+ years of experience was written in vi with no additional packages.
FWIW, I've written MUDs in NodeJS, Ruby, and Elixir, and my experience with Elixir has been miles above node and ruby for a MUD server. The elixir version isn't quite ready for players yet but it's shaping up pretty nicely https://www.youtube.com/watch?v=lykw0G-ABow
Does VSCode have "run anything? (Ctrl + Ctrl in RubyMine/IntelliJ etc.). If not, I would say that this alone is a massive difference.
I've been a dev for 20 years and the only languages I use an IDE for are Java and Delphi. VSCode is a great highly-capable-but-not-full-IDE editor - you can easily work on professional-grade software with it. Full IDEs are nice, until they aren't, and they can be quite the resource hogs. I've got a RubyMine license, but I still prefer working in VSCode.
You can change your fonts in VSCode! I use Hasklig personally.
One of the machines I'll be working on is a 2011 Thinkpad x220i with a little i3 processor and Linux Mint. Thankfully, I was able to get 8 gigs of ram and a little SSD into it for free so it actually runs quite decently for it's age - but I wouldn't want to have it lug a whole IDE around. The dream scenario is to get decent enough to earn some side money somehow and buy a new macbook air down the road (maybe freelance web scraping on upwork or something. who knows.)
VSCode has a full-blown terminal integrated into it, as well as the ability to define tasks for commands you want to use frequently.
Atom is better for ruby on rails in my opinion. I have always found the plugins/support better in atom for rails and specifically and I assume that is because Github was made with rails and Atom is made by Github. That being said I use Emacs as I have found that has the best support things like auto indentation block highlighting, basically does everything. Easily customizable if you start to learn Elisp
That's not the same thing though, is it? If you press `Ctrl` twice, you can basically invoke anything from within RubyMine - spawn a terminal, run Rails commands, run Rake tasks, use Git, run shell commands etc., all without having to open a terminal. 
Click the link. It's a reference to *scaling* time, rather than just changing it. For example, this could mean that running `sleep(1)` actually causes the clock to move forward by an hour. Such behaviour is rarely needed, but can sometimes be helpful in integration testing. 
I've looked at your solution. Very cool! Thank you! With this input: "World/Asia/China" "Asia/Japan" The tree would be: root World Asia China Asia Japan In order to prevent this, my theory is to implement a tree traversal method `#find`, which would return the found node, or `nil` if the node isn't found. Then in `#add`, insert `Japan` as a sibling of `China`. Would you say this is the best way to implement it?
Do you happen to know what the IntelliJ / Rubymine font is? [looks like this](https://www.jetbrains.com/ruby/) Actually, I'm also having some trouble installing Ruby Solargraph. I installed Ruby, and Rubocop so I can have some intellisense action going on but Solargraph just won't get there. &gt;&gt;&gt;[Error - 2:21:40 PM] Starting client failed Error: spawn solargraph ENOENT at notFoundError (C:\Users\name\.vscode\extensions\castwide.solargraph-0.19.2\node_modules\cross-spawn\lib\enoent.js:6:26) at verifyENOENT (C:\Users\name\.vscode\extensions\castwide.solargraph-0.19.2\node_modules\cross-spawn\lib\enoent.js:40:16) at ChildProcess.cp.emit (C:\Users\name\.vscode\extensions\castwide.solargraph-0.19.2\node_modules\cross-spawn\lib\enoent.js:27:25) at Process.__dirname.ChildProcess._handle.onexit (internal/child_process.js:198:12) I can't figure it out. :\
Very cool! Willing to share the code for that? I'd love to glance around it.
Oh, VSCode has that as the "command palette" - Ctrl-Shift-P by default, I think. I use it a lot!
I use rubyLocate rather than Solargraph - lots of folks like Solargraph, but rubyLocate is much quicker (and less prone to breaking), in my experience. I'm not sure what the font is, but I just fired up RubyMine on my machine, and it doesn't look like that at all - it uses NotoSans by default on my Ubuntu machine. [This is what Hasklig looks like](https://i.imgur.com/Ur75oWO.png).
Read. More. Code. Much like when learning English you read 100x what you write. Reading code lets you internalize idioms, discover functions and patterns, and so on. Start with smaller projects and then progress to larger ones. Search GitLab or GitHub for anything that tickles your fancy - [you can filter the results down to just Ruby projects](https://github.com/search?l=Ruby&amp;q=testing&amp;type=Repositories). If the projects have a good test suite, download them and run it. Try changing the tests or the code to see what fails. See if your intuitions about what works and what will fail are correct.
Hmm, I can't find rubyLocate in the VSC Extension marketplace. I'm curious to check it out since Solargraph is giving me the gears right now. 
It's just one of the Intellisense options. If you installed the standard Ruby package (https://github.com/rubyide/vscode-ruby) then you should be able to just set your Ruby intellisense option to "rubyLocate".
Ok, that makes more sense. I removed solargraph for now then. I want to keep this simple but would still like auto-complete/intellisense functions. When I save a file, I do get a Rubocop error" &gt;&gt;&gt;rubocop.bat is not executable execute path is empty! No idea. ..
I'm all for de-gemming posts.
I would use whatever makes you most efficient. Sometimes you'll move into a shop where everyone is using a particular product / tools in which case it's usually less hassle on all if you follow suit. I've been using RubyMine with the keyboard set up to emulate an editor named Brief - If you can remember that one you're from the age of Dinosaurs like me :-)
Oh I see, I thought that's what you wanted, but I guess in that case, you'd want this, right? ``` root World Asia China Japan ``` In that case yeah you need to traverse all nodes, maybe you need to check the parents? Like, in the `Asia/Japan` case, you need to see if the node Asia has a parent, if it does, add the branch to that parent, otherwise, attach it to root. I modified my solution: https://repl.it/@gosukiwi/RegularTatteredOpen64 Note that I use a hash AND add them to a children array, so that's quite heavy when it comes to memory, but it has a fast insert, as it doesn't have to traverse the tree every time you add. The alternative would be traverse the tree when adding and getting rid of the extra hash, which would be more efficient when it comes to memory.
Get your head around Git. Learn some command line basics, but Gitkraken and gitk are great tools to use on top. Get a great editor. I use sublime text. It's 'nagware' but I paid for the license. It was very worthwhile.
Rubocop is a linter and code formatter. You can install it as a gem (`gem install rubocop`). I personally use rufo (via [vscode-rufo](https://github.com/bessey/vscode-rufo)) for formatting, and just `ruby -wc` for syntax checking, as they're much, much faster. You set the Ruby linter to `ruby -wc` with: ``` { "ruby.lint": { "ruby": true }, } ``` The vscode-ruby project has documentation on all the linter options.
I've been using VS Code today while starting my learning. I've dabbled in the past with Sublime Text, Atom and some other one (can't recall it's name now). So far I'm liking VS Code. The only issue I'm having right now is I'm trying to get a couple extensions working but they're not working out so well. But, future problems. For now, I just need to clickity-clack some keys and learn this. :) When I'm done the "Learn Ruby the Hard Way" stuff, I'm going to try and get Git setup and make a repo and just push and pull stuff to it and get a feel for it. I used to clone repos and pull them down using Sourcetree but it was gui, and it was many years ago. 
I should have looked into this before I even started messing with extensions: Does it matter what folder I run "gem install x" in?
I'd definitely learn some basic vi/vim. You'll find them on virtually any machine you end up on. Very useful should you find yourself in a terminal for any reason.
No, though run it from the vscode terminal (Ctrl-`) to be sure it's the same Ruby environment.
I learned Ruby \~12 years ago after a stint at software engineering with C#. I currently work on a large Rails project but it's architected in such a way that the web/Rails specific parts are very well defined and mostly separated from the core code. In this sense, a lot of the daily work I do is "pure" Ruby in that it's just plain-old-Ruby-objects interacting with each other to solve a given problem. Because of this, I wouldn't consider myself simply "a web developer". I \*can\* write code that interacts with a user via the web, but I can also write any general-purpose software too. Arguably, you could do the same with any general purpose language but here's why I'd pick still pick Ruby: 1) It's very easy to write \*clear\* code that expresses the problem domain. This helps mould your thinking and communication skills such that you can express your intentions and the details of defining the problem and how best to solve it. This (for me) is the #1 programmer skill. The programming language is the easy part - expressing your thinking and intentions in a clear ways transcends all technology choices because you can discuss your software in such a way that you have confidence in it, write thorough tests, and write code that others can pick up and collaborate on. 2) Still a great job market. Demand for Ruby developers exceeds supply, there's plenty of companies using it, you can be confident of finding a job and getting paid a good salary.
When I use TimeCop, I prefer to use \`around\` block instead of \`before\` + \`after\`. Would love to see it in the future posts
In most of my time with Ruby, everyone used a simple text editor. RubyMine however is getting really popular, though probably still in the minority. Personally I don't think an IDE is necessary.
RubyMine is amazing - it is resource intensive but it is so worth it. But I’m using VSCode at present because I am self-employed and didn’t like that they switched from perpetual to subscription. VSCode needs to work on their debugger. It was working when I ran Unicorn but when I switched to Puma it shit the bed. Could be anecdotal, but that’s the change that hosed me. If you are using binding.pry to debug everywhere, RubyMine will blow your mind. If you are using puts statements to “debug” - RubyMine will melt your brain. You need to know how to debug code properly, and quickly. That’s the value of an IDE. 
Yes, that would be the ideal next step in my process of preparing for this question. I've been analyzing your solution, and still need more time (thank you again for sharing an updated solution!). Curious, why did you choose implement a `parent`? [This](https://pastebin.com/4tae0EXS) is what I have so far, but my approach is based on children nodes rather than parent nodes. I wonder if this is just a preferential decision, or one is better than the other.
A lot of languages have picked this up. Javascript has `\`Interpolating ${code(parameters)} code in strings is cool.\`` I mean, it's all basically syntactical sugar on `printf`
Use what makes you feel good and efficient. For me that is VIM, but there is no problem using any editor that makes you feel good at the end of day writing code. The only time I dip into IDE land is for java and that is more a sign of the language (and boilerplate) deficiencies than a choice of editor.
I don't understand what you're saying you'd love to see. You are confused about how to use the built-in Rails API with an around filter, the same way you use TimeCop?
Do you mind expanding on why you don't freeze objects? Does that include constants?
Used to use VIM. Now I use RubyMine. ¯\\\_(ツ)_/¯ Use VSCode if you want. Rails tooling is designed for CLI interaction, so whatever you want to edit text is fine.
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
yeah i really liked some of the features he showed me in rubymine. there wasn't anything that made me feel like i couldn't get similar results with tracing, but there's definitely a noticeable convenience factor there. if i hadn't already had years of emacs habits (and rubymine was a little lighter on system resources) i might have switched.
It's because I need to attach the branch I create to something, so I find the parent start calling `add_child` to that node, or to root if I can't find a parent. If you can get away without needing a parent, then that's fine too, not a requirement or anything, it's just what I found easy to implement. For example, I can call `tree.add "Japan/Tokyo"` and it works fine: `[root [World [Asia [China ] [India ] [Japan [Tokyo ]]] [Europe [Belgium ]]]]`, because it knows `[Japan [Tokyo]` should be added to `Asia`. Note that because `Japan` already exists in `Asia`, it won't add it again (`unless children.include? node`). So you can call `add_child` many times and if it's already there, it won't do anything. It will always return the node though, that's required for `reduce`. Your code looks good though, I like that everything lives in the `node` class. There are some things which are not quite Ruby-ish though, not like it's a bad thing. For example, you implement `print_subtree`, where a more Ruby-ish approach would be implement `to_s` and just call print on it: `puts node`, no need to call to_s, as it's done by `puts`. In `#find`, you what to always return the same type of object, so find sometimes returns a node, sometimes returns nil, which can lead to errors if the programmer forgets to check. Also, when you do returns you normally do it a the very top of the method, something like this: ```ruby def find(node, value) return node if node.value == value node.children.each do |child| result = find(child, value) return result unless result.nil? end nil end ``` Now, if `children` is empty, it will return nil, so that nil at the end is extra: ```ruby def find(node, value) return node if node.value == value node.children.each do |child| result = find(child, value) return result unless result.nil? end end ``` Also, Ruby has many collection methods which you can use to make life easier, like [find](https://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-find): ```ruby def find(node, value) return node if node.value == value node.children.find do |child| find(child, value) end end ``` So, depending on the interview, they might look for different things. If they are dumb, they will look at the implementation and see if it works, and pass if it works and reject otherwise, if they are smart, they will look at the kind of things I mentioned. When I inverview candidates I really don't care if it works or not, I care about how well they can use Ruby. This is fun so I just continue with the review :p So here: ```ruby if node_found current_node = node else current_node.children &lt;&lt; Node.new(...) current_node = Node.find(...) end ``` You are triggering a find where you already know the result you want, which is the new node, so you can just say ```ruby if node_found current_node = node else new_node = Node.new(...) current_node.children &lt;&lt; new_node new_node end ``` Your solution is actually prettier than mine I think, I took the liberty to make it more Ruby-ish: https://repl.it/@gosukiwi/TechnoLightSearchengine Great work :)
I like ruby a lot better (I'm in /r/ruby after all), and think it's certainly suitable for more things beyond web (let alone Rails), and have used it for such things (although I admit I mostly work in Rails, I have written things that have nothing to do with Rails or web). But as far as advice for what's most marketable in the job market in 2019, especially for jobs that aren't Rails or web? I have to reluctantly say I think it's python. 
What IDE do you use and what advantages does it provide you over an editor? 
Honestly I used TextMate, Vim, and Sublime with just syntax highlighting for ages. Now I would say the best free tool is VSCode, as the Solargraph plugin is really impressive, and linter integration is far better than Sublime. RubyMine is still better though.
I think most of the Rubyist here would agree that Ruby is simple and highly readable. That's true, yet untrue. Ruby DSL can be both simple and complex depending one how one uses it. In my opinion, Ruby has many inbuilt functions/methods. E.g upper and lower case methods is inbuilt to string class itself. map, select methods, are good tools when handling hashes and arrays. If a custom method you need frequently is not in the core string class, no worries, meta programming is there to help. So for me, why I love Ruby, is because how powerful and flexible it can get. Because of that, I'm not just Rails person. I use it to script take for system admin work and to script tasks that is difficult to be maintain in say, bash script. What I would like to see or what Ruby is a bit lacking is performance and concurrency. When comes to Ruby and some other compile language, is performance. Ruby lack of performance comes at the cost of its high readability and flexibility. So if performance is not a main concern, it will always be the choice to work with in my cases. Concurrency is not in built in Ruby core. Although there are gems providing that functionality, I see prefer this feature to be at core of Ruby. All in all, you never limit to 1 language in a lifetime. For me, Ruby is my main language, Python secondary due to it popularity. Golang for performance and concurrency, in which I use to integrate Golang into Ruby with ffi too. JavaScript for html scripting. 
If I don't want an object to be mutated, I won't write code that mutates it. Neither will anyone on my team. If we need extra defensive measures to prevent mistakes, there's a lot about ruby that's less than ideal in those circumstances. Dynamic typing, for instance. Ruby is best for teams that have the discipline to prevent mistakes on their own IMO.
Oh, I see what you mean now.
I’ve done ruby development for about 12 years and used vim for the vast majority of that time. 
I've heard a lot of people like VS Code for ruby actually. If it works for you, I don't see why it would stop. I use SublimeText. Many rubyists use souped-up editors like these. Some use RubyMine, I think it's the only "IDE" for ruby that's good. I wouldn't say it's got overwhelming usage among rubyists, but it is used by many. My guess would be at least as many or more use editors, although fancy editors that can have ruby-specific and developer-oriented functionality like VS Code or ST, not, you know, NotePad. 
&gt; ninja edit: Discussing this with a co-worker, he advised I learn Ruby anyways because, in his words, "All you listen to is Japanese Math-Rock anyway. You might as well complete the image and learn Ruby." End of discussion. You have your answer. Also, links please. If you need more: Ruby is a very good language to learn programming because after a very short while this will happen to you: - "Hmm, I wonder how id do this... I could google it, but maybe it will just work like this other thing?" - thing works like the other thing, you feel great because you did not need to google it. In the end, if you do it as a hobby, you pick whatever language you like best and gives you the most joy. And that better be ruby. 
There is only vim. Everything else is for writing bad poetry.
If you're looking into a career in software engineering, I would practice listening to and talking with complete idiots who don't know what they want, or what they're talking about, but somehow wound up in charge.
I run an RSS/Atom feed news aggregator focused on ruby: http://rubyland.news/ It does include some podcast episode links. 
Does `travel_to` support a block argument that auto-returns to the original time? Most people use `Timecop.travel 1.day.ago { #do stuff }`
Chef and Puppet! To play devil's advocate, Ansible is all python. (I'm the Chef person at my company)
Yes, it does: `travel_to(1.day.ago) { puts Time.now }`
If you want your new version with a different API to be successful you need to make the transition easy. Completely changing how everything works will mean slow adoption and a split support. Ruby itself went through this for 1.8 to 1.9, and Python is still going through this with 2 to 3. Rewriting a method with Module#prepend then not using `super` to change its argument behavior is a ton of work. You must continually maintain a fork of code they do not own, along with all its bugs and hidden interactions.
RSpec matcher definition looks good. Seems that block precedence may be the issue. Instead of using `do |n| end` in your assertion use `{|n|}`. 
A quick study of the ruby core library shows the natural case is to have the argument be the receiver of #==, not the argument.
The argument being the receiver of #== is the way the ruby core libraries work, and is the most flexible way.
&gt; At a glance (of someone who is just learning) nokogiri looks like a more powerful version of python's BeautifulSoup but isn't a full on framework like Scrapy. Yes, that's exactly right. AFAIK, there is no equivalent to Scrapy in Ruby. But I still prefer writing Ruby scrapers using Mechanize to Python scrapers with Scrapy or Python scrapers with Mechanize. That's because scrapers can quickly devolve into a hell of procedural spaghetti code. Ruby makes it easy to write things in a more declarative style. Like this: usernames = agent.document .css('div#content a') # Find all links .map(&amp;:href) # Get their URLs .select { |href| href.include?('comment') } # Keep only URLS for comments .map { |href| agent.get(href) } # Fetch the URLs .flat_map { |doc| doc.css('span#username') } # Find the username elements .map(&amp;:text) # Extract the usernames .map(&amp;:strip) # Remove whitespace Imagine writing the same thing in Python.
If you are learning Ruby study AND use TDD. Your tests are code as well and it forces you to understand your own code. When you feel you are starting to get the hang of Ruby and feel good about completing katas or whatever you're doing to learn check out Uncle Bob; clean code, SOLID principles, architecture. These along with TDD can show you how it's more about good architecture, extendability, and readability than it is about clever one-liners or code that works but is resistant to change. Keep exposing yourself to material that is challenging and don't ever use the 'black box' (gems, libraries) without peeking at some of the code to see how it works or at least trying to figure it out. 
Right on. And I do acknowledge the benefits of strict immutability under certain circumstances, it's just generally not for me.
Thank you for speaking up here! Reading through the post and comments, the whole time I was thinking of you as the counter example. Also, I don't mean to resurrect a zombie post. I was just minding my own business and thinking my thoughts then suddenly "A wild Aaron appears" and it's got to be remarked on!
Damn. Thanks to that intense pic of of JCVD in the smash hit, Timecop. I want to use it even more *does splits in kitchen while freezing my tests*
Take a screenshot of a bunch of text and paste it into https://www.myfonts.com/WhatTheFont/
This answer is best IMO. LOL python is a fine language though. The white space thing drives a lot of ppl nuts but every language has it's quirks. /me shrugs ruby will teach you the basics of the language tree though, e.g. smalltalk, lisp, that they both share. note: scrapy is awesome. even if you go the ruby route you should use it
I've had a late night and won't be able to get to this tonight but thank you SO much for your impassioned reply! I can't wait to dig in!
VSCode, Sublime Text 3, &amp; Atom are all basically the same with the exception being price and ST3 is written in C and the other two with Electron.js so they use more memory. But they all can use the ST keybindings so your knowledge should transfer. VSCode should be plenty for ruby IMO, vim or emacs could work too if you want long term stability. I've been using Sublime Text since it's creation 10+ years ago, it's only gotten better. I think there is too much complexity with IDEs for ruby. Without types you lose a lot of what they bring to the table. The typical ruby setup is 3 monitors; a terminal, a browser, and an editor. Use guard in the terminal one to run your specs/test, and livereload in the browser and you get most of what an IDE brings. Maybe the only thing an IDE brings to ruby is project wide refactoring but I've never found that to work well. 
Is the issue that words with mixed case letters aren’t being removed? For example: Example, with a capital E - is that failing and is that the issue? Because I see one bug: you should #downcase the word first. %w[E x a m p l e] is an array with unique strings because “E” != “e”
Sorry. Should have specified that. All characters are the same case like the example. The example is from the false positive set. 
Hm ok. I’m not at a computer, so let’s troubleshoot together. What does “absono”.split(//) return? 
If I do it in irb, just what you would assume. Funny thing is, removing words with any letter but 'o' doesn't seem to be a problem. If I split the 'o' words 1 at a time, the arrays are correct, the uniq() calls are correct, but after several hundred calls, they screw up. 
Hmm where are the words coming from? Is it possible that it’s not an “o”, but some character that looks like an “o”? 
They're coming from an array in the same file(sublime). I guess I can try seeing what their ascii number is. That is a great idea! I have been screwed over like that before.
Yeah give that a try. Or try to reduce the code down to a single repeatedly failing word and work from there. There’s something we are missing here. 
Problem is, the words aren't "failing." The words are passing the filters.
I think it’d help to reduce the code down to something that repeatedly fails and post that. If the problem is that it only fails after X iterations, then try to wrap it in some loop until it fails or something. That line of thinking will either produce a useful test case, or present the problem to you. 
It's midnight here. Thank you for the help! I'll present the results later today.
Yeah, that's *almost* the same thing! :-) ... From what I remember, Command Palette in VSCode is almost identical in functionality to that found in Sublime Text, right? I recall Command Palette not being able to run shell commands though. Maybe if you have RubyMine/IntelliJ/PyCharms etc., you could try it out and see how much of a difference there is (or isn't!). 
Is split(//) preferable to split("")? I've only ever done it the latter when processing strings.
What a thoughtful and well-written post. Out of curiosity as someone not very experienced, given your stated reasons for why you are unlikely to switch, is there something this or another solution could offer that would make you consider it. You seem experienced with the problem space, so I'm curious to learn what issues remain to be solved.
That's what I wanted to say, thank you! &amp;#x200B; I think the article would benefit from an example of this API. 
The argument but not the argument? Truly zen, but also yes. The argument is the absence of an argument, which is why the convention does not apply. 
[Metasploit](https://www.metasploit.com/) - a pen-testing/security framework - is primarily written in and extended using Ruby. I guess that's a niche in its own right.
What in earth are you talking about? Something to do with changing a method signature, yet simultaneously *not* changing the method signature? You can't have it both ways. Back on topic. The method design was all about "not supplying an argument". Therefore the design pattern should not be dependant on the argument's implementation, but instead only on its existence. 
Still using Textmate :) I've tried using Rubymine, Vim, _etc_ but after a decade of coding in Ruby the muscle memory is too strong. I'm not sure you get that much value out of IDEs in Ruby land. Different for languages where you lean on the IDE (Java, C#, etc) just to get by. To be honest, I used to get annoyed by the comment cruft a colleague's Rubymine would inject in the code. It always felt it was trying to be too clever - well beyond what you need in day-to-day Ruby coding. VSCode looks nice - and it's probably going to be around for quite some time. It's based on Atom, isn't it? Or the same toolkit (Electron). That's probably a hint re its ongoing utility. If it works for you, I'd say keep on using it.
Not sure why you got downvoted. Too 1334 for the youngsters? :D
Indeed, `.split //` is slower than `.split ''` which is slower than `.chars` This is enough to filter words out of an array: $ irb head :001 &gt; %w[absono some words with repeating letters].grep_v /(.).*\1/ =&gt; ["some", "words", "with"] 
suggestion: use chars method instead split
`.chars` is the fastest and most idiomatic, but `.split ''` is still faster and cleaner than `.split //` This is enough to filter words out of an array: $ irb head :001 &gt; %w[absono some words with repeating letters].grep_v /(.).*\1/ =&gt; ["some", "words", "with"] 
Nothing is stopping you from learning some python later anyway, it's not a radically different language.
Hmmm thanks definitely got me thinking!
Whenever I run into something like this, I throw pry into the mix and binding.pry when the unexpected thing happens so I can play around with it.
I use a very simple editor, no IDE. I don't think you need an IDE for ruby; you only need your brain really.
I highly doubt you get paid more because of vim alone.
Thanks Nathan. I'll send your payment via PayPal, as agreed. But jokes aside, I appreciate it. Not a lot of Rubyists seem to be interested in this sort of stuff, at least not these days. Also, I wasn't aware of Eventide Schema, but I've added it to the article.
I also prefer using timecop in this way: around do |example| Timecop.freeze(Time.local(1994)) { example.run } end Instead of what you've written: before do Timecop.freeze(Time.local(1994)) end after do Timecop.return end This also works well with timecop's ["safe mode"](https://github.com/travisjeffery/timecop#timecopsafe_mode), which prevents tests from forgetting to reset their state. **However**, the ActiveSupport timehelpers have actually [already got you covered here] (https://github.com/rails/rails/blob/94b5cd3a20edadd6f6b8cf0bdf1a4d4919df86cb/activesupport/lib/active_support/testing/time_helpers.rb#L55-L58) to an extent: def after_teardown travel_back super end --- On a related note, there is also one subtle difference between the two libraries: ActiveSupport [*sets the microseconds to zero* when freezing time](https://edgeapi.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to). I believe that idea has been discussed within timecop too, but the maintainers have decided against it as the library is not meant to be rails-specific [citation needed].
Also relevant: [My PR](https://github.com/travisjeffery/timecop/pull/216), which is still not merged... 🤷‍♂️
I've been using SublimeText for a few years now (maybe 8 or so) but I'm testing RUbyMine right now. The larger codebase I now work on, with all its different philosophies applied during 9 years of development motivated me to try it, with autocompletion and code inspection tools in mind.
I've heard of that for sure. I had an inkling to explore the whole Backtrack / Kali / Pentest thing. I even have a copy of Violent Python that I've never opened. Go figure. 
check out squeeze! it's a string method. https://ruby-doc.org/core-2.4.0/String.html#method-i-squeeze
When you say TDD, you're referring to Test Driven Development, right? I know WHAT that is, but I have no idea how to do it but that will come later. For now I'm literally on 100 level Ruby. When I was googling around for Ruby information, I seen a few times something called RSPEC and testing. Is that the same thing? Or is that for something else entirely?
[My favorite Math-Rock album](https://www.youtube.com/watch?v=8VCCkymXplE) Ruby is love. Ruby is life!
Yep, TDD is Test Driven Development. It is a really REALLY good habit to get into. If you ever plan to write software professionally, most companies say they use it and most of those actually do follow through. The benefits of TDD are somewhat synonymous with the classic karate kid " wax on, wax off". It will feel frustrating at first but then you understand the benefits when it was really needed (look up Red, Green, Refactor &amp;&amp; "TDD like you mean it"). Another way of thinking of how it is useful is that it is a conventional way of using the scientific method while building the behavior of a program. You mentioned RSpec, I highly recommend RSpec because it is so widely used and really has no drawbacks from a use perspective. There are other ways to test in Ruby but none are as adopted as RSpec. All it is, is a library to run code that tests what you tell it. BUT, don't over load yourself just yet (which contradicts my original response). It seems like you are still getting the feel for Ruby and maybe writing code in general? When your programs are starting to do what you ask them consistently, or you are comfortable enough you "see solutions in your head" that's when you are ready to learn a whole new way of thinking in tests first.
I like this idea. Remove if original doesn't equal squeezed. Won't handle ' absono' unfortunately. 
When I used to work in QA, the office I worked in was very big into TDD as well. When they would get new interns or grad new-hires they would ram TDD down their throats. They would make them right unit tests for stuff that didnt' exist yet, then have them slowly build their code or changes afterwards to satisfy the test parameters. I knew dick about coding back then (not like I do now either but we're changing that now!) but that mentality really stuck with me years later. When I'm done LRTHW and start poking around at things, RSPEC is near the top of my list. Even if I'm making simple scripts that do stupid things, I think making it a habit, like going to the gym, will pay off in the long run. 
Sounds like your former office was doing TDD! :)
Well, it's certainly a growing area. My teenage son is into all that sort of stuff, about to start a uni degree focussing on it. I take him to a meetup once a month and the story from most of the other young folks who attend is they rarely get to finish their degrees before they get plucked into a high-paying job before they finish. Huge demand in this area. I've no idea where you're at with your career, but if it's an area that interests you I'd encourage to spend a bit of time getting to know the tools. "Network Security" wasn't even a consideration when I started out, so it's fascinating to see how our industry expands and changes. Too late for an old fart like me to get into it, but I'm happy just to be still coding. :) 
+1 for Vim! It takes years to learn but it's so much faster to use than anything else (except perhaps they other mouseless editor, Emacs).
Our company's backend is also 95% Ruby, but 100% Rails-free.
Whoa TIL - never seen that one before
Tried that and still no bueno. Very peculiar.
Thanks! I would say the gap is in the design philosophies I hinted at. Here are a few reasons, and unfortunately they are a bit long winded (and I hope I'm not taking away from the discussion about the gem itself): 1. All else being equal, it's cognitively simpler to mutate data structures directly (e.g. `account.balance = 100`) than to always build a new structure with the desired changes (e.g. `account.with(balance: 100)`). Immutability may offer some protection against errant code mutating a data structure that it shouldn't be touching, but I don't value any countermeasure against errant code other than making sure that the people writing code are up to the task. 2. I have generalizations available to me, for instance, that can copy all attributes from one data structure to another, which I do quite frequently. Those generalizations have some valuable features, too, like only copying _some_ attributes but not all, and they can be integrated into more specific data structure classes like messages. All that to say this: these generalizations are highly useful, and have to be built on _some_ API for altering data structures, and the most reasonable choice are ruby attribute setters, like the `account.balance = 100` example above. That's how ruby's data structures like `Struct` work, after all. On the other hand, if we had coupled to the approach taken by this gem, e.g. `account.with(balance: 100)`, then our tooling for copying data from one data structure to another would not be compatible with ruby's own data structures, or any library other than this gem. The author of this gem has exceeded ruby's own data structure primitives in quality, but at the cost of introducing a specialized API that forces libraries that _use_ this data structure library to be coupled directly to it. The benefit of this library, therefore, would have to be immense to make up for the loss of compatibility with `Struct` and `OpenStruct`. 3. I'm not able to make much use for coercion in data structures, since I have a separate library for defining serializers within the class namespace of a data structure. Data coercion is not something I ever need out of data structures. Hope this helps... I can go into greater detail but frankly I'd rather be doing that in a separate discussion where my own opinions might be more appropriate...
My Network scanning farm at work is primarily ruby because of this.
I recently switched from Sublime to VSCode. I don’t need a full IDE because I don’t want to spend hours configuring something and having a cluttered interface. But VSCode does have some better integration (such as linting) that is nice to have. But, at the end of the day, you’re just editing text files. Project-wide search and some syntax help/auto-complete/etc. are your most useful tools. Keybindings and such will come to you whether you use vi or RubyMine. Just pick something that looks nice, give it a spin, and see how it goes. If you don’t like it, there are plenty of options - Sublime, Atom, VSCode, RubyMine, Coda, nano/pico, vim/vi, emacs, ... I could go on.
[https://discord.gg/KpcVgPc](https://discord.gg/KpcVgPc) 
There's a pretty big one here: https://www.rubyonrails.link
This seems like a really fresh server.
&gt;i Is this active anymore? 
He's making fun of top comment.
I thought it was vice versa? Poe's law I guess... 
Extremely
Glad you find it useful :)
Yes. Some of the more active channels include ‘coding’, ‘front-end’ and ‘work-offers’. The community is full of incredibly helpful people!
It may be active but it seems impossible to get in. I filled the form about a month ago and still haven't heard from them.
First preview of the 2.0 series. App simplification, new router, rewritten actions, fresh code reloading strategy.
I joined.
So was Roda used for routing as planned? I'm not seeing a lot of the details that were discussed here per se right off the top: https://discourse.hanamirb.org/t/hanami-2-0-ideas/306 It would be really cool to see a breakdown of what made it in and what didn't.
&gt; I’ve never encountered a Rails developer, myself included, who truly wants to test an object completely in isolation from all other objects I regularly aim to do this, and I'm sure I'm not alone.
Really helpful, thanks for elaborating.
I am professionally fluent in scraping both with Ruby and Python. It truly depends on the size of the task at hand. Generally speaking, parsing data is infinitely more pleasurable in Ruby. Ruby really slays at text processing, and that's what scraping is all about. However, if you are managing a large scale project that has regularly recurring scrapes against many websites, Ruby starts to lose ground to the Scrapy framework. It's the equivalent of Rails for web scraping, and until very recently, Ruby didn't have a great answer for all of the things that go alongside a commercial scraping operation (organization, data management, logging, retry/reschedule, proxy management, lots of common settings related to scraping). It all exists and is doable in Ruby, but you had to invent it all on your own, gluing the parts together. Recently, the Kimurai framework has appeared as an attempt to answer this issue. If you are starting out scraping in Ruby, I'd recommend first just playing with simple tools lke mechanize, which will help you make requests, manage http sessions (cookies), and includes nokogiri for parsing the data. It's a fantastic tool for many jobs. Once you have a handle on basic requests and parsing, move onto Kimurai to get a sense of a full project. There are a million ways to diverge in between, but I feel like that's the best approach to get started currently. Additionally, don't hesitate to build fluency in Scrapy too. You don't have to be great at Python to get a ton of mileage out of Scrapy, (similar to being able to create impressive web apps with rails without knowing much Ruby) and ScrapingHub will host and execute your scrapers from a remote host for free(!!!). I spent a lot of time building a scraping framework for my commercial needs in Ruby, and when I eventually stumbled upon the true power of Scrapy (it's not the request/parsing: it's the project management) I realized that everything I was trying to figure out on my own was about to be replaced by one month of learning Scrapy and Python. I still prefer quick one-time scraping jobs in Ruby, and generally deslike writing Python, but I can't argue with how productive and effective I am on a framework like Scrapy. 
There's [#ruby](irc://irc.freenode.net/ruby) on freenode...
&gt; Imagine writing the same thing in Python. Thanks, I'm good.
Oh, hello ugly.
One of the confusions people have when approaching the ruby core libraries is the amount of behavior packed into a single method, especially with regard to which arguments (or lack thereof) trigger which behavior. There are so many behaviors crammed in there that even after years you will discover or re-discover something you've forgotten. This makes the pattern "do something different when no argument is specified" one that should be avoided. It makes method documentation long, difficult to write, and sometimes confusing due to the multiple special cases for the many different behaviors that appear depending on which arguments are given, not given, and what types they can have. (I know because I wrote and improved a large portion of the English documentation for ruby's core and standard library.) But say I didn't know that and designed a v1 API where behavior changed whether an argument existed or not, then discovered how confusing it is through documentation and bug reports (valid, due to poor or confusing documentation) and wanted to change. I look at my v1 method signature and realize it has two types, the first being "do something with this object" and the second being "do something with no object" and decide to make two methods. Also, along the way, I came to understand that too much change is bad, so I want to allow users to upgrade easily otherwise they never will. I change from the v1: def some_method argument = NO_ARGUMENT_SENTINEL to the v2: def some_method behavior_object def do_default_behavior And allow the user to provide a collaborating Behavior object to `behavior_object` that specifies the behavior they want. This Behavior object wraps zero, one, or many values that were previously supplied as `argument`, and has a defined interface for for this. If the v1 implementation has `argument` as the receiver of #== I can document how to implement a Behavior object that duck-types to both the v1 and v2 implementations. (Specifically by having V1V2CompatibleBehavior#== respond with `true` when sent `NO_ARGUMENT_SENTINEL`.) This cross-version duck-typed back-door is important because you don't control your users' dependencies. A user may be using library A which depends on your v1 along with library B which wants to use v2. Through thoughtful design you can provide a gentle transition that guides your users along. Outright breakage means no-one upgrades until the last dependency they need upgrades so you miss out on bug reports and other feedback you can use to improve your software.
The admins are very active. Give it another shot.
Seems good! Two things I might tweak: 1) variable names. \`name\[:name\]\` isn't very clear. Maybe call it "character" so you can do \`character\[:name\]\` instead. 2) string interpolation is usually preferred over string building in ruby. \`"#{accum}, #{character\[:name\]"\`
So reduce should be thought of as: "I have a collection and I want to extract one meaningful value from it." What you would really want to do with this problem is a map - reduce. Map can be thought of as "I have a collection, and I want to transform it into a different collection" 2.5.3 :001 &gt; x = [ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ] =&gt; [{:name=&gt;"Bart"}, {:name=&gt;"Lisa"}, {:name=&gt;"Maggie"}] 2.5.3 :002 &gt; x.map(&amp;:values) =&gt; [["Bart"], ["Lisa"], ["Maggie"]] 2.5.3 :003 &gt; x.map(&amp;:values).map(&amp;:first) =&gt; ["Bart", "Lisa", "Maggie"] 2.5.3 :004 &gt; x.map(&amp;:values).map(&amp;:first).reduce { |acc, name| "#{acc}, #{name}" } =&gt; "Bart, Lisa, Maggie" Side note: I probably wouldn't map twice if the data set wasn't trivially small.
Also there is a big Rails chat on Gitter..
Thanks for your input. Would it be better or worse to do this? [1] pry(main)&gt; x = [ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ] =&gt; [{:name=&gt;"Bart"}, {:name=&gt;"Lisa"}, {:name=&gt;"Maggie"}] [2] pry(main)&gt; x.map { |character| character[:name] } =&gt; ["Bart", "Lisa", "Maggie"] [3] pry(main)&gt; &amp;#x200B;
&gt; hanami-router has been rewritten more than a year ago. It's more efficient (+10k req/s for simple Rack benchmark) and it's now based on mustermann path matchers, which powers Sinatra routing as well. I might be out of the loop, but I vaguely remember that Sinatra's routing didn't work well if you had _a lot_ of routes, since it basically had to match then in order instead of using some kind of tree structure. How would this affect Hanami?
I'd say yours is better. mapping twice felt dumb to me, but I only have so much time while my tests are running to do stuff on reddit. :)
Hehe. Alright, thanks.
Nope, it wasn’t used. I found Roda really hard to integrate with because of the block syntax.
That’s interesting. Where I can read more about this topic? Which order of magnitude is it for you “a lot”? I’d like to run benchmarks for this. Please note that Hanami and Sinatra are sharing the path matcher, not the routing implementation. Mustermann is a kind of powerful regexp engine that can match the incoming requests.
:'( Heartbreaking.
Yeah, one of the reasons we were really looking forward to Roda.
Why? Can you please elaborate? Tnx.
https://github.com/jeremyevans/r10k This was jeremy evans' self-made benchmark engine to illustrate the point (he did talk about routing performance in a presentation, somewhere in youtube). I do remember him saying that routing performance was the reason he moved away from sinatra (his preferred web framework at the time) and did his own thing (which was a fork of cuba). I think that the disappointment of roda not being adopted for hanami's router implementation comes from not adopting a proven-fast router instead implementing your own, which for all it's worth, might suffer from the same drawbacks as sinatra's. But then again, integrating something is sometimes a pain.
Their form does not allow me to re-submit.
DHH (creator of Rails) use TextMate (it is code editor, and an IDE). I prefer to use SublimeText which is similar to TextMate (and more modern as for me).
I don't remember where exactly I read up on about it, since I recall it was a few years ago. The Roda website [has the following to say](http://roda.jeremyevans.net/why.html): &gt; In addition to being more maintainable, Roda's approach is also faster in general. Sinatra routes requests by testing each of the stored routes against the current request, in order. With Roda, once one branch of the tree matches, only routes inside that branch are considered, not any routes after that branch. Roda also has support for a single route that dispatches to multiple branches via the multi_route and multi_run plugins. For large applications, routing in Sinatra is roughly O(N), where N is the number of routes, while routing in Roda can be close to O(log N), depending on how you structure your routing tree. For small applications, because Roda has lower per-request overhead, Roda is about 2.5 times faster than Sinatra. Regardless of whether Roda is truly 2.5 times faster than Sinatra, the performance characteristics (Sinatra being O(N) versus Roda being O(log N) are accurate as far as I'm aware. For a small application I doubt it will matter much, but for larger applications your routing performance may decrease. Worse, depending on the order it would also be inconsistent. If the route you're looking for is at the very end, it would take longer to match compared to it being at the start of the list.
Yeah, you're right. Still gotta love the squeeze. When I first looked at the String class I thought why so many methods? But, overtime, you'll find a use. 
I learned your implementation: [https://imgur.com/a/bPAEZlN](https://imgur.com/a/bPAEZlN) Thanks so much for sharing it and "Rubyizing" my solution. I love your solution. I spent time with `reduce`, learned Keyword Args, and it's really cool how you removed extraneous logic from my solution. Still got a ways to go but I'm very grateful for you helping me out. I'm gonna compare yours to mine more closely, revisit your comments, and more.
Glad you found it useful! Ruby is a beautiful language and it takes some time getting used to it, but it's definitely worth it. The best way to learn it IMO is 50% writing code, 50% reading code, check out the source code on well-respected Ruby projects, like Rails. I think just by following [Sandi Metz 5 rules](https://robots.thoughtbot.com/sandi-metz-rules-for-developers), you can get to cood, clean code. Something which helped me wrap my head around object-oriented paradigm is Sandi's great book [Practical Object Oriented Design in Ruby](https://www.poodr.com/). She has a bunch of YouTube videos too, [this](https://www.youtube.com/watch?v=8bZh5LMaSmE) is a big favorite. Overall I'm impressed with your willingness to learn :) Right now, we are not hiring juniors, but if you decide to learn Ruby and particularly Rails, once you feel confident in your skills feel free to contact us at [Beezwax](https://beezwax.net/), or contact me directly and I can get you an initial interview. We usually hire developers to work in-place if you live in the bay area, but we have many remote devs too. I live in Argentina and work remotely. Good luck!
Go Hanami Go!
Interesting! I added a serializer that I've written ([HALPresenter](https://github.com/sammyhenningsson/hal_presenter)) to a copy of this benchmark to see how it performed. It was 2.00 times slower than panko and allocated 1.96 times more objects than blueprinter. (Not too bad for me and my one-man-army.) One thing that I think is important to consider though is the media type being used. It's a bit unfair to compare `application/json`, `application/vnd.api+json` and `application/hal+json`. Since they are not equally complex.
I can vouch for it's high activity rate I'm constantly getting useful information down there, be it with my questions or following the other discussions
This is not bad, the other comments in this post are good, there is only one thing I'd like to add: you want to avoid type-checking, it's normally considered a code smell, sometimes you just gotta do it, but try to avoid it as much as possible. While it doesn't use reduce, here's the way I'd do it: ``` [{ name: 'Bart' }, { name: 'Lisa' }, { name: 'Maggie' }].map { |person| person[:name] }.join(", ") ``` I guess you could say `join` is somehow like reduce :P while you are learning, it helps having [Rubocop](https://github.com/rubocop-hq/rubocop) set up in your editor, it helps you learn Ruby conventions.
Enumerable#flat_map collapses nested Arrays so you don't need to double-map: &gt;&gt; [{:name=&gt;"Bart"}, {:name=&gt;"Lisa"}, {:name=&gt;"Maggie"}].flat_map(&amp;:values) =&gt; ["Bart", "Lisa", "Maggie"] This is OK when you know there is only one entry in the Hash.
Yes, #join could be implemented with #reduce, but is more understandable, maintainable, and faster.
If you're not put off by the title, Chris Pine's [Learn to Program](https://pragprog.com/book/ltp2/learn-to-program) will step you through the essentials in Ruby. In terms of Rails, people seem to get a lot out of Michael Hartyl's [Ruby on Rails Tutorial](https://www.railstutorial.org/). These might not be the kinds of resources you are after, but I hope there's something there for you. 
Post an example that I can run and I'll have a 2nd look...
Show more of your code. I haven't tested this but I imagine your issue right now is using an old value for f. Break your statement down then do some debug logging to see if this is the case: if f.count != w.length f = w.split(//).uniq end Are you actually trying to filter these words out? Again, without seeing more code can't say much.
Why's poignant guide is a beautiful piece of litersture that even teaches you the language
A bit of paging is perfectly normal, healthy even. Some stuff just doesn't need to be resident.
Tutorials are quite sparse, even more so good ones. Learn to Program was suggested which was nice; I think ultimately you sort of have to just write a lot of ruby code. The OOP model in ruby is quite simple and logical and you can modify ruby at any moment in time (open classes).
I ran the benchmark with the new `hanami-router` `2.0.0.alpha1` vs `roda` `3.16.0`: Hanami has a perf degradation between 1,000 and 10,000 routes. Within the limit of 1,000 routes they perform the same. Which I think it's good for most of the apps out there. Here's the results: https://gist.github.com/jodosha/c2f0fa4cd8ee4bd102eea2d3a9e339c3
Has anybody already checked if the 2.6.0 security issue is fixed in this release?
Which issue are you thinking of?
This one. &amp;#x200B; [https://mensfeld.pl/2019/01/exploring-a-critical-netprotocol-issue-in-ruby-2-6-0p0-and-how-it-can-lead-to-a-security-problem/](https://mensfeld.pl/2019/01/exploring-a-critical-netprotocol-issue-in-ruby-2-6-0p0-and-how-it-can-lead-to-a-security-problem/)
It’s the first thing mentioned in Changes in the above linked release page.
Changes mention: Net::Protocol::BufferedIO#write raises NoMethodError when sending large multi-byte string Issue page makes no mention of that specific method. So I'm just trying to be sure here.
That makes sense I will investigate it, I agree it’s not completely clear.
Yeah, they fixed the issue (merged to master) almost as fast as it was discovered, but only now decided to release. Finally. 
Sweet, thanks.
I needed to use the ~&gt; operator in conjunction with package version checking, so here is the custom matcher I wrote. Useful links: - https://serverspec.org - (similar) https://www.inspec.io - https://ruby-doc.org/stdlib-2.5.3/libdoc/rubygems/rdoc/Gem/Dependency.html
You haven't "solved the backward compatibility problem"; you've simply changed the original API such that your V2 is no longer a breaking change. If V1 and V2 work the same way, then of course there is no issue. There was nothing inherently *wrong* with the original API; you just don't like how it behaves. Which is understandable, as it's not "the ruby way" of defining methods. Other languages, such as C, allow you to overload functions with multiple implementations, using different method signatures/arities. Ruby does not allow this. --- If you're following a dependency injection design pattern, then I agree with you. But if we're discussing a "function overloading" design pattern, then shoehorning dependency injection into it is wrong. Which pattern you actually end up using is another question, for another day.
Sorry for a bit clickbaity title. I ran the Jeremy Evans routing benchmark that test nested but otherwise completely simple routes. Would still like to know why Sinatra has troubles here.
Just checked the Amazon description and you're right - have an upvote :)
Inspired by Hanami’s choice to not go with roda??
The benchmark does not yet work with Hanami 2 that's why I didn't include it. So perhaps not really. I think Jeremy just likes efficient software :).
well first step would be to learn how to format code on reddit so that your post is actually readable..
Check out [The Odin Project](https://www.theodinproject.com). It's a free and open source, online, guided curriculum and community to help learn fullstack webdev with Ruby and RoR. There's a pretty active community on discord if you have questions or whatever as you self study your way through the courses. Best part, imo, is that you do projects throughout and push everything to TOP's github to get your projects included in the student solutions on the website. So you get practice with that stuff too if you don't already have experience.
That's not too bad, although 1000 routes is not that big of a number. For example, GitLab Enterprise Edition has 1201 Rails routes. GitLab Community Edition has 959 Rails routes. It's worth mentioning that I'm not hating on Hanami. I have been keeping an eye on it for a few years and generally really like the direction it has been going. Unfortunately, I never really got to play with it since I don't really do web development in my spare time, and GitLab will never move away from Rails :(
He's asking because your post looks was written after the discussion here: https://www.reddit.com/r/ruby/comments/alf6rb/hanami_v200alpha1/
this is an interesting problem and i don't have a definite solution. My first suggestion would be to not use relative paths with `require`, use `require_relative` instead. see if that makes a difference.
Right. Yes, I think I got the link from the discussion there actually. And since there were no results attached... I ran it :).
Thanks /u/tenderlove
Congrats on the release. I've never been a huge fan of the dry group's syntax choices, but I can definitely see the uses. I wrote something similar, but more along the lines of usual Rails syntax: typed_parameters do options strict: true # Throw error on validation failure, e.g. type mismatch on :create do param :user, type: :hash do param :first_name, type: :string param :last_name, type: :string param :email, type: :string param :password, type: :string param :notification_opt_in, type: :boolean, optional: true param :birthday, type: :datetime, coerce: true, optional: true param :preferences, type: :hash, optional: true param :role, type: :string, inclusion: %w[user admin], optional: true, transform: -&gt; (k, v) { [:role_attributes, { type: v }] } end end end Where you would use it like so, def create @user = User.create typed_params[:user] end
Definitely -- integrations tests are valuable (particularly when refactoring), but creating classes that can act in isolation and can be tested in isolation gives you fast test suites and confident OO code.
Thanks for the feedback. A viable alternative is to implement a tree based structure. I’ll investigate in a while, for now I’ve got more urgent stuff to work on. Cheers.
Hey - I'm one of the admins there. Message me your email and I'll make sure you get invited. Sometimes there are glitches, but we can get you sorted.
InSpec has this functionality natively, FYI.
Completely understandable, and good luck!
Hi. Thank you for reaching out! My email is _@gmcabrita.com
Thank you! 💖
That actually appears to be an issue with markdown on reddit's mobile site (possibly the app too, although I didn't check there). It is formatted appropriately on desktop, which is where I originally wrote it. I apologize for not knowing that the mobile site would completely bork the markdown. I'll look into how I need to change it so that it looks correct on both desktop and mobile.
Thank you for your great work on this! Just curious, is this going to change how `dry-validation` is used? I'm trying to imagine whether it's useful to validate "schema" separately from other types of validations (e.g. verifying that an `*_id` param references an existing DB record). Could you also clarify more what are the things `dry-validation` will provide on top of the `dry-schema` functionality?
https://wrocloverb.com/
The method handles a single number at a time, right? So presumably you will iterate over the numbers in the csv with a different method, and call the one in your example as a filter. If that's the case, the the question of what/how to return is determined by what the method that handles the return needs. 
IMO it shouldn't matter as long as the intention is clear. I would rename the method to validate_phone_number so its clear your intention is to validate. If it was Rails and you were writing a custom validation method, you would add an error when the data is not valid, which you're doing here in some way. 
&gt; The method handles a single number at a time, right? Correct &gt; So presumably you will iterate over the numbers in the csv with a different method, and call the one in your example as a filter. Correct² &gt; If that's the case, the the question of what/how to return is determined by what the method that handles the return needs. I think I still don't quite get this. Let's say the only criteria would be that the number starts with a 2. In that case, would I do a return number if number[0] == 2 or return number unless number[0] != 2 In the first case we would instantly know what we want but in the second we would instantly know what we don't want. I know that in the end it doesn't matter, but I'm wondering if there is something like a style to follow.
&gt; IMO it shouldn't matter as long as the intention is clear. I would rename the method to validate_phone_number so its clear your intention is to validate. So there isn't something like a style to follow and as long as my intention is clear I can do whatever I feel like?
I tried playing around with this problem just. Honestly as long as your code doesn't become unclear, then go for the most efficient method. Ruby is known for having more than one way to do things (its very versatile and expressive), other languages such as python enforce a much more stringent or strict approach. Both have their advantages. In this case a negative assertion was more efficient and more clear. I tried an unless statement for 'bad number' also tried returning the number if it passed the validations. Neither was pretty. I would agree with /u/[damianborowski](https://www.reddit.com/user/damianborowski) that the method should be renamed to validate\_phone\_number also i would return 'invalid' instead of 'bad number', i just think its more inline with the method naming and purpose. 
Thanks! I was just wondering if there was a specific style to follow. But if there isn't one and I'm fine to write it however I feel as long as it's clear and readable than that's nice too.
I would be interested in a follow-up post that profiles sinatra to pinpoint where it's spending the most amount of time.
No worries, yeah for smaller validations like this this way is fine. But for larger complex validations its better to whitelist than blacklist especially if the blacklist could grow. Whitelisting means you can be explicit about what you want approved rather than having to list everything you dont. A good example of white/black listing can be seen in firewall policies. 
I feel like positive assertions are easier to read. One vote.
You can also add comments if you are concerned about code clarity. I know a lot of people think comments are a sign of bad code, and that "good code" should be self explanatory, but I disagree. Comments are another tool in the box to help you write better and cleaner code. When used appropriately they can be very helpful.
Basically `tap` is different than `map` because `tap` will return the original thing (whatever you're calling `tap` on).
I'm not sure it matters "what you do want vs what you don't want", what you've written is pretty clear. But I _might_ extract the _validation_ code from the extracting/cleaning code. I also wouldn't return 'Bad number' instead of a phone number (unless that's the exersize directions?) Thinking about that also reveals that you return early if the number if greater than 11 digits, so there's no reason to do the slice `number[1.11]` in the end -- it can't possibly be more than 11 digits, if you got there, right? I'd also avoid mutating input with `gsub!`, using `gsub` instead. And then `number.length &lt; 10 || number.length &gt; 11` is just `number.length != 11`, right? So maybe: def clean_phone_number(number) number = number.gsub(/\D+/, '') return 'Bad number' invalid_number?(number) number end def invalid_number?(number) number.length != 11 || number[0] != 1 end I'd do something more like that, but there's always a bunch of ways to do it. 
Good point. And it's less about readability than reliability of your logic, I'd say! If you are listing all the things that could be wrong (blacklisting) you might forget one. Less likely if you are writing for this is what it _must_ be to be right (whitelisting). 
 Oh wait. &gt; number.length &lt; 10 || number.length &gt; 11 is just number.length != 11 No, you were allowing 10 or 11. And then I messed up your logic further. Anyway, carry on! 
I have several programming projects going on; thanks school and work; and this one is a side project. When I get back to it, I will be posting more. I am trying to get rid of these words as they don't fit a pattern that is trying to be met.
If It was me I would throw an Exception rather than return in case of an error, but I don't know the instructions of this exercize. Your code snippet is self explaining so I wouldn't be worried about this except modifying the argument by using gsub!
It's pretty simple and short enough to decipher, but in such cases where I think I might be confused later I'll usually just post the rules you listed as a comment above the method.
No matter what you do, try to avoid using double negation. If the choice was between "return if number[0] != 2" or "return unles number[0] == 2" then I wouldn't be able to say which one was better, but using unless with a negation is much more difficult to parse than if with a positive assertion.
slightly different though as `tap` can also be run on nil! 2.5.3 :012 &gt; nil.tap{|x| p x} nil =&gt; nil 
Thanks for the suggestion. Unfortunately, it doesn't help. :(
another thing that I would advise when you're expecting to match multiple numbers/ranges is a single case statement instead of a plethora of boolean logic case number.length when 10 number when 11 number[0] == '1' ? number[1..] : 'Bad Number else 'Bad Number' end
&gt; This was jeremy evans' self-made benchmark engine to illustrate the point (he did talk about routing performance in a presentation, somewhere in youtube). Is this the talk you mean? https://www.youtube.com/watch?v=N92aD4mNUFA&amp;feature=youtu.be&amp;t=1996 
``` def clean_phone_number(phone) phone = phone.gsub(/\D+/, '') # remove non-digits from the number string phone.slice!(0) if phone.length == 11 &amp;&amp; phone.start_with?("1") phone.length != 10 ? phone : nil end ``` I would say your original was not very easy to read. There were a lot of different branches, exit points (places to return from) and more. I also changed the return value from a string to a string or nil. If this method can't clean the phone number, the result is nil, or undefined.
Looks clean and succinct. I'm curious about the `:foo?` symbols. Are those mapping down to matching methods somewhere? Is the `?` suffix meant to separate those "operators" from other methods which act as compositors?
The only time I find myself using tap is with `Hash`. For any of "my" objects, I'm going to convert: user = User.new.tap do |u| u.build_profile u.process_credit_card u.ship_out_item u.send_email_confirmation u.blahblahyougetmypoint end Into a method with a terrible name only an Objective-C developers could love.
To ruin your understanding of `#tap`, try using `break` in it. irb(main):001:0&gt; 1.tap { break 2 } =&gt; 2 Big fan of tap though! Great for logging in a chain of methods: users .map { some transform } .tap { |u| log.debug(...) } .select { ... } .tap { |u| log.debug(...) } .reduce(0) { ... } .tap { |total| log.debug(...) }
I’d recommend this one as well because it teaches about yield_self https://stackoverflow.com/a/47890832
There's a subtle non-equivalence to be aware of, because (assuming this is an ActiveRecord or AR-like example): user = User.new.tap do |u| u.username = "foobar" u.save! end gives you the same result as user = User.new do |u| u.username = "foobar" u.save! end but this: user = User.create.tap do |u| u.username = "foobar" u.save! end is not the same as: user = User.create do |u| u.username = "foobar" u.save! end Because in the latter example, the username is set before saving. A tap following a create could leave an attribute dirty &amp; inadvertently unpersisted. 
those are inbuilt predicates of dry-schema. rather than providing a block, you describe your conditions as an array of predicates that are type specific. iirc, you can define your own as well (dry-validation example): https://dry-rb.org/gems/dry-validation/custom-predicates/
The hard-to-remember effects of `break`, `next`, and `return` in blocks always bothered me.
I once ignored the political and social aspects of software because I too thought all problems could be strictly technical, but I was wrong. You've spent so much effort trying to be technically right about some narrow point that you're completely ignoring how people use and interact with software, which means you will be wrong. I've shown that I have years (over a decades) of experience with Ruby, but you have repeatedly shown you have some things to learn. For one, don't attempt throw around insults by explaining how ruby doesn't have method overloading, but C does (a language I've already shown I'm familiar with by pointing to the C implementation of #== for multiple classes). For another, don't make testable statements like "redefining Object#equal?... which would likely just make ruby crash completely!" when you have not tested them: ruby 2.6.0p0 (2018-12-25 revision 66547) [x86_64-darwin18] airake (0.4.5) airbrake (8.0.1) […] I've maintained and been a committer for ruby code you use every day and know Ruby's principles inside and out. Software I've written, maintained, or committed to include the Ruby language including adding multithreading to the zlib wrapper (working in C), various improvements to Net::HTTP (including transparent decompression using the zlib work), documentation for the standard library, etc.; maintaining RubyGems; maintaining Rake; maintaining minitest; and many other gems.
There is an unofficial style guide, called rubocop. [Have a browse](https://github.com/rubocop-hq/ruby-style-guide/blob/master/README.md#syntax). Couldn't find anything specific to your question when I skimmed through, but I have the rubocop extension in vscode, and it flagged me when I had an expression like `if !&lt;something&gt; &lt;some_comparison&gt;`, suggesting I should instead use `unless &lt;something&gt; &lt;some_comparison&gt;`. So my takeaway was that generally instead of negating an expression in a conditional, you should use `unless`. But I do get the impression that one of the guiding principles for Ruby's design in general is flexibility, and it seems logical to assume that the purpose this flexibility is primarily to allow programmers to choose to write code in whichever style they prefer. As others have said, as long as what you're intention is is clear to yourself and to others who might read your code, it really doesn't matter. All that said, I think having two comparisons in a disjunction, '`&gt; 10` or `&lt; 10`' is, no offence, kind of insane :) I would strongly recommend just checking for `== 10`. *Much* clearer in my opinion. Disclaimer: I am pretty much a noob at Ruby, but I have been programming in Python for years, and I've always placed high importance on style conventions and readability.
Why would you ever want to break in a tap?
Next just finishes the block. Break finishes and returns the value. Return returns from the whole method or lambda.
I think the font is Menlo
``` def clean_phone_number(number) matchdata = number.gsub(/[^0-9]+/, '').match(/\A1?([0-9]{10})\Z/) matchdata[1] if matchdata end clean_phone_number('1234567890') # =&gt; "1234567890" clean_phone_number('11234567890') # =&gt; "1234567890" clean_phone_number('21234567890') # =&gt; nil clean_phone_number('2123456789068678') # =&gt; nil ```
It has nothing to do with each other at all. 
&gt;Looks clean and succinct. Thank you! &gt;Are those mapping down to matching methods somewhere? Yes, they map down to [Predicates](https://github.com/dry-rb/dry-logic/blob/master/lib/dry/logic/predicates.rb) module from dry-logic. The same predicates are used in dry-types when you use constrained types. &gt;Is the ? suffix meant to separate those "operators" from other methods which act as compositors? Yes, and these compositor methods are for convenience, it all boils down to composing predicates using logic operators, ie `value(:integer, gt?: 18)` is the same as doing `value { int? &amp; gt?(18) }`. Block-based DSL gives you more power though, you can use other operators like `|` (or), `&gt;` (then) and `^` (xor).
&gt; Just curious, is this going to change how `dry-validation` is used? Yes. I want to separate schema coercion and validation, which is type-check oriented, from domain-specific validations. &gt; I'm trying to imagine whether it's useful to validate "schema" separately from other types of validations (e.g. verifying that an *_id param references an existing DB record). I'm 100% convinced that it should be separated. You can combine the two in some kind of a DSL of course, if that's what you want, but conceptually, these are two different concerns and if they are handled separately (even if it's just behind the scenes), the whole system is much more managable. Here's what I'm thinking about (more or less, this needs some discussion before we get to the implementation phase): ``` ruby class NewUserContract &lt; Dry::Validation::Contract # params define the most basic type-checks, the sort of stuff that # must be verified before we can check anything else params do required(:email).filled(:string, min_size?: 2) optional(:login).filled(:string, min_size?: 2) optional(:password).maybe(:string, min_size?: 10) optional(:password_confirmation).maybe(:string, min_size?: 10) end # now, here, we can go nuts with all sorts of macros # ...like the classic confirmation check verify confirmation: :password # ...or a classic uniqueness check, this can be provided by various plugins verify unique: :login # ...or a custom validation logic, with the ability to set your own custom # error messages attached to a specific param key verify :login do |params| if params[:login] &amp;&amp; !params[:password] failure('Need password when login is provided') end end end ``` &gt; Could you also clarify more what are the things dry-validation will provide on top of the dry-schema functionality? It will expose dry-schema API like I showed above, and provide a new API for defining complex validations. By `complex` I mean validations that require access to more than one value from params, or the ones that rely on external systems (most commonly - a database). Another addition is a new API for defining custom errors, with custom data for interpolation (this is a huge limitation in in dry-validation currently).
Thanks for sharing this. It's very unfortunate that this type of solutions are still not the standard in our community. I'm always happy to see other people trying to solve this problem. I just had a short discussion at work about data validation and I basically said it's the hardest problem I've ever attempted to solve in programming. There are so many ways of doing this, both when it comes to internals as well as the top level DSLs. &amp;#x200B; When it comes to syntax choice, I would like to explain a couple things. I \*really\* don't like DSLs that are heavily based on passing various options. One of the first decisions I've made when I started working on a validation library is that it will not be based on options. They are too ambigous and too complex. I experienced this when I was working (and using) Virtus, and also I've never liked how it works in Rails, with all the validation options that I never-ever remember. That's why in \`dry-validation\` and now \`dry-schema\`, I wanted a DSL that is more obvious to understand, and I wanted to remove as much ambiguity as possible, because you really don't want that in a data validation library :)
I don't have anything constructive to say other than that I love the dry-rb project. Thank you for all the work!
oh man thank you, you have no idea how much it means to me when I read this type of feedback :)
I'll just do a series of guarded checks. It's simple to understand and map exactly to what you have just described. def clean_phone_number(number) number.gsub!(/\D+/, '') # return nil for bad number. return nil if number.length &lt; 10 return nil if number.length &gt; 11 return nil if number.length == 11 &amp;&amp; number[0] != '1' return number[1..-1] end 
Homebrew was built with Ruby?!
That sounds very exciting! Thanks for the code example, it really explains the idea nicely. This separation now makes total sense to me. Just to clarify, the idea is that none of the high-level custom validations will be run unless *all* "basic" checks have passed? In other words, is the "dependencies" feature, where you could specify that a custom validation depends on a field, going to be removed?
ditto, all the gems have been super useful and a joy to use, great work!!!!
&gt; Just to clarify, the idea is that none of the high-level custom validations will be run unless all "basic" checks have passed? Yes, exactly. I also plan to provide a powerful API for "digging out" values that you need, so that it's easier to define these validations.
Why not `rake stats`?
Ironically I am reading the answer on SO and still have no idea why/when to use or need tap. And I actually find the variant WITHOUT the tap simpler to understand, too. But that may just be me ...
If you write code like this then there is already something very wrong with you ... Honestly, I don't understand how other people use ruby these days. It feels totally alien and different to how ruby used to have been used in the past; also uglier and more complex. I don't understand this.
Talk about useless code.
In general I personally always recommend to aim for what code SHOULD do. A good example is .reject versus .select. Both are useful, and I often feel inclined to use .reject; but I then try to select positively forward what I want to use; for example, prefer "if" over "unless" since unless is a tiny bit harder to understand. Or ideally be able to omit any if/else clause. I try to aim for a direct approach. I don't use ternay either since it takes longer to get the intent through it. "If anyone else would read my code, then she would instantly know what phone numbers I DON'T want. But I'm wondering if this is the right approach?" I would restrustucture the whole code to make it simpler. A simple if-else clause may be better altogether.
Exactly. Talk about overengineering a problem that's already solved.
That's such a complex problem. It sounds more like the DNS entry hasn't changed yet. Most ISPs will accomodate the TTL on your DNS, but sometimes it takes a while to propagate out fully. What did you set the TTL to when you changed the A / CNAME record?
Hey, RandyTheWonderLizard, just a quick heads-up: **accomodate** is actually spelled **accommodate**. You can remember it by **two cs, two ms**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Tap is language cruft imo. For all of these examples that are using to group code, a simple begin/end block does the same job and makes it easier to insert error logic in the future. 
You wouldn't, but it does support an odd behavior, so I figured I'd show it.
I didn't mean to insult you, or your intelligence. The question I was answering here is not "Is the design pattern of altering behaviour based on the number of parameters a good idea?". I was answering "What would be the best way to implement that design pattern?". The answer is not "You don't implement it. You do something else." - which is what you seem to be suggesting. I think your answer was wrong, because it was the correct answer to the wrong question.
Ruby has fallen victim to the functional languages hype cycle. The nice thing is that you can ignore many of these features. The bad thing is that devs new to the ecosystem have sworn off OO almost entirely so code organization is poor and cleverness high. 
First: I appreciate that this isn't your style, but please don't say there is something wrong with me. If you're seeing this style more and more, then the style of the community is changing. I have also been writing ruby for a long time and my own style has changed many times. Second: Chained looping code is ugly? It gives a pretty simple view of what we're doing to all elements in this list in a: \`map -&gt; filter -&gt; reduce\` sort of way. The method naming describes the transforms or filters, the complexity of those methods are defined elsewhere and the logic of what is happening is defined here.
Folks are trying to help out. Please don't be so negative to other community members...
Sorry, I misread the results of the benchmark. Roda is still faster on smaller subset of routes. See https://twitter.com/jeremyevans0/status/1091134258205286400
```[7] pry(main)&gt; 'b' =&gt; "b" [8] pry(main)&gt; "b" =&gt; "b" ``` ```pry(main)&gt; "b".ord =&gt; 98 [15] pry(main)&gt; 98.chr =&gt; "b" [16] pry(main)&gt; ``` it works for me. german layout.
You can use \`rake stats\` as you can use thousands of tools. That's not the purpose of the article.. The \`find\` library matters here.. Also, I just propose a use case to show you how the \`find\` library works. &amp;#x200B; Also \`rake stats\` mainly focus on the app but don't count LOC in \`config/\`, \`db/\`, custom directories, etc.. &amp;#x200B; Anyway, Thank you for your feedback. &amp;#x200B; &amp;#x200B;
A bit haughty.. isn't it?
First: I never addressed you, personally. If that hit a nerve then good. I could care less about what fashion of the year you subscribe to. Second: chainable loops are not just ugly, they’re slow, too. 
Is this session running on a screen/tmux/ssh? 
What OS do you use? How do you install Ruby? is this only lowercase \`b\` or also uppercase \`B\` ? Does it work in the shell, before you start irb? If you have Docker, what happens in the shell of \` docker run -it --rm ruby:latest\` ? 
Ugly AND slow. And it's illegible. Just look at what you're doing in your example. That code belongs inside the Users class, not outside of it. Move logging macros into a mix-in and call it a day. Easier to follow, easier to maintain, and more performant. &amp;#x200B;
"hmm, this sounds like a ruby/readline thing" *googles "ruby readline missing character"* &gt; Github issue: "can't type the 'o' character," in pry from 2014 [still open](https://github.com/pry/pry/issues/1275), 54 comments.
Just a note of explanation, as I've been caught out by this before. Whenever I change servers I usually wind back the the TTL on the A-record to something like 5 mins a few days before the change. Depending on what it was set to beforehand, that should give it enough time for the TTL setting to propagate. Once the new server is up and running, we'd change the A record and then wind the TTL back up to whatever it was before. Having said that, there was a large ISP here in Australia that was notorious for not honoring TTLs and we had to contact them directly to flush out the cached DNS entry. I'm not a sysadmin, so none of this may be best practise. But it was a strategy that seemed to work.
&gt; No, you were allowing 10 or 11. And then I messed up your logic further with the 1 thing missing that. Anyway, carry on! Lol, thanks though! Just one more question: &gt; I'd also avoid mutating input with gsub!, using gsub instead. A couple of people have suggested this. What is so bad about gsub! ? 
`rake stats` exists only in Rails, so it's still useful for non-Rails projects.
&gt; In general I personally always recommend to aim for what code SHOULD do. Thanks! That's what most people have suggested now and I'll probably follow that advice. &gt; I don't use ternay either since it takes longer to get the intent through it. Really? For me it is way easier to understand ternary than if/else, that's why I prefer those. I can easily see the logic in one line.
Interestingly, I was having problems even starting pry before (getting Readline errors). After recompiling the Ruby version, I was good to go. However, this nagging issue persists.
Nope.
- macOS 10.14.2 - rbenv - lowercase `b`, uppercase works to my surprise - works fine in the shell - I'm not running Docker at the moment
Just for fun, I fired up Docker and downloaded the latest Ruby image - all works just fine in irb there. Hmmm.
The way your code is written, gsub! is modifying the actual object given. So, `clean_phone_number(my_var)` modifies my\_var directly, removing the non-digit characters. `my_var = "1-203-204-2435"` `clean_phone_number(my_var)` `my_var == "12032042435" # true`
This method has a bug, as it will turn a phone number of length 10 into a phone number of length 9.
The first case already takes care of that. 
`irb(main):009:0&gt; clean_phone_number("1234567890")` `=&gt; "234567890"` `irb(main):010:0&gt; "1234567890".length` `=&gt; 10` &amp;#x200B; From the OP: \&gt; If the phone number is 10 digits assume that it is good \&gt; If the phone number is 11 digits and the first number is 1, trim the 1 and use the first 10 digits
There's plenty of us writing ruby who prioritize clarity over cleverness, who also manage to do so without telling people there is something wrong with them personally beyond the mistakes they happen to be making.
I knew there’s a bug now. But I won’t bother changing it. 
Replied via PM.
IMO separating out the valid number logic doesn't really help here, because a number of length 11 that starts with 1 isn't really valid, it's actually a number that needs to be transformed. Really, a valid number is one of length 10. Modifying a length 11 number to length 10 by chopping off a leading 1 is a special case. ``` def clean_phone_number(number) number = number.gsub(/\D+/, '') number = number[1..-1] if number[0] == "1" valid_number?(number) ? number : nil end def valid_number?(number) number.length == 10 end ``` I don't think the extract really does anything to clarify, it just adds another method.
Got it! Yeah, the type-checking totally seemed smelly. Which is why I turned to r/ruby hehe.
yes, it is.
I don't know what's going on, but i have the strongest urge to call you up on skype and see if we can figure this out. DM me if you are interested.
This is the right solution
Most of the important performance discussion here is happening in the other remarks, but I will say one thing that stands out to me: The proven track record of the work of Jeremy Evans really stands out in our considerations. Having Roda would have offered a lot of additional confidence and an additional community that can stand behind Hanami - a very performance oriented and astute community. 
does `INPUTRC=/dev/null pry` make any difference?
YES IT DOES... so what's going on here?
Yea I know, but why is this a bad thing? If I do my_var = my_var.gsub(stuff in here) than I'm modifying the actual object as well, right? So why not keep it more simple and just use gsub!
No, gsub returns a copy of the object. To demonstrate: `irb(main):001:0&gt; number = "123A45"` `=&gt; "123A45"` `irb(main):002:0&gt; number.gsub!(/\D+/, '')` `=&gt; "12345"` `irb(main):003:0&gt; number` `=&gt; "12345"` `irb(main):004:0&gt; number = "123A45"` `=&gt; "123A45"` `irb(main):005:0&gt; number.gsub(/\D+/, '')` `=&gt; "12345"` `irb(main):006:0&gt; number` `=&gt; "123A45"`
Not sure... Here's what I can tell you, and even this I'm not 100% on: /etc/inputrc or ~/.inputrc or whatever $INPUTRC is in env is basically responsible for setting up keybindings and changing the keymap in GNU readline. The more I talk about this the less I'm convinced I know about it, but I think it's basically responsible for proxying keystrokes and recording entered lines before they even make it to the application, as readline itself is kinda a pseudo shell (ever wonder why C-r works exactly the same across readline apps?). We might be able to get some more information by locating your inputrc and inspecting it. But honestly unless there's a giant "eat the keystroke b" mapping in there, it'll probably take someone a lot smarter than me to determine if this is a bug in your version of readline or ruby -- and that's probably the next real step.
Yea I get all of that. But what I don't get is why the people saying I shouldn't use gsub! show their code using number = number.gsub(/\D+/, '') And as far as I know, this is the exact same thing as gsub! . I get that it would be different if I would assign it to a different variable, something like number_clean = number.gsub(/\D+/, '') But if I'm assigning it to the same variable that I'm using gsub on, then what difference is there?
I hate `find`. For many use-cases it basically forces you to `stat()` everything twice. It was one of the easiest wins for [FastFind](https://hur.st/projects/fast-find/), just passing the stat object into the block (sadly the only meaningful speedup on MRI). Of course a half decent implementation wouldn't need to stat files at all, since file/directory information is usually returned as part of the dirent structure. Ruby doesn't expose any of that, unfortunately. I should probably pick up [FlashFind](https://hur.st/projects/flash-find/) again. It's a more serious departure from the `Find` API, and *tries* to make better use of concurrency, with sadly mixed results.
 $ irb irb(main):001:0&gt; require ".\mycode.r#{?a.succ}" Easy workaround. No further fix needed! 
`irb(main):009:0&gt; def argument_modifier(number)` `irb(main):010:1&gt; number = number.gsub(/\D+/, '')` `irb(main):011:1&gt; end` `=&gt; :argument_modifier` `irb(main):012:0&gt; myvar = "123A45"` `=&gt; "123A45"` `irb(main):013:0&gt; argument_modifier(myvar)` `=&gt; "12345"` `irb(main):014:0&gt; myvar` `=&gt; "123A45"` `irb(main):015:0&gt; def argument_modifier(number)` `irb(main):016:1&gt; number.gsub!(/\D+/, '')` `irb(main):017:1&gt; end` `=&gt; :argument_modifier` `irb(main):018:0&gt; argument_modifier(myvar)` `=&gt; "12345"` `irb(main):019:0&gt; myvar` `=&gt; "12345"`
Ah, but adding another method often clarifies, because each method does one thing. but your call!
`gsub!` modifies the string passed in. Which callers may not expect. input_number = "123-456-7890" output_number = clean_phone_number(input_number) output_number you'd expect to be `1234567890` at this point. But what do you expect `input_number` to be? Do you expect it to have changed? If you use `gsub` it has. In this case to `1234567890`, which was the same as output number. But if you had done more transformations, it might just be some intermediary step that doesn't mean anything. If the method _returns_ the cleaned number, I don't expect it to have also modified what I passed in. Can lead to weird and confusing bugs way down the line. 
&gt;They would make them right unit tests for stuff that didnt' exist yet, then have them slowly build their code or changes afterwards to satisfy the test parameters. REPL testing &gt; TDD. Heresy, I know. 
Besides acknowlodging your joke, thanks for using the ?a literal. I didn't know it before, so you tought me something today, fellow rubyist :) I have no idea when this might be useful. Is it just to save one character compared to 'a' or is there more to it?
I still think it would be better to merge the toolbox into rubygems.org. I understand it is not so trivial 1:1 due to various reasons, but I think from the user perspective it would be way better to have the functionality available at one website rather than more than one (actually, maybe have an URL gems.ruby.org, so it residing at www.ruby.org; and rubygems.org then be an "alias" to gems.ruby.org ... but anyway I digress - the ruby toolbox is quite useful on its own as-is).
Just an update. The Gemfile.lock got corrupted somehow so rake was trying to use a different version of mongo than heroku local was. :-/
I can not give an answer to that but I remember faintly that ?a worked for a very long time. I think the oldest pickaxe even mentioned it.
Golfing is pretty much the only use I know lol
Thank you for this...I went ahead and got a copy. I learned Ruby in bootcamp a year ago, but havnt done too much with it since then and would love to brush up on it, so definitely interested. I'll keep you posted on what I think :)
`b` is an `Integer` representing the byte, not a `String`, so you need to write it with a method that supports that: `output.putc b`.
if you ever get the opportunity to write `result = ??` in production code, take it. It's worth turning off the Rubocop warnings and risking the ire of your colleagues. Also note that `!!!??` makes a nice stand-in for `false`.
RES-tagging you as Ruby Satan
`? + ?? == "??" ? !?? : !!!??`
Thank you for schooling _me_ this time in that you can concatenate literal strings without an operator.
 &lt;&lt;~EOF "welcome." You're EOF 
&gt; return returns from the whole method or lambda. Before some of Ruby 2.x return was returning only from method and so would break through any number of nested lambdas. Uh... I _think_ nothing changed in 2.0/x, but rather `return` can work oddly in a `proc` (rather than a lambda). Which is hard to explain (for me right not anyway), but will make this (still) work: def foo(array) array.each do |item| return "found a 10" if item == 10 end end Returns from the whole method, not just the `each`. A block ends up treated as a `proc` type, all `proc` objects are similar. This example is good for explaining why this behavior that seems insane when you try to explain it isn't -- you expect `return` to return from the method there. Maybe. If something _did_ change relevant to return and lambda in 2.0 or some other 2.x, and I'm forgetting or didn't know, a cite or other details would be welcome! 
Ctrl+F the "Returning from" here: https://github.com/ruby/ruby/blob/ruby_2_1/NEWS And see this answer: https://stackoverflow.com/a/50557965/322020
Interesting! What they describe as the 'new' behavior is how I thought it always worked, from when I started with ruby in 1.8. I wonder if it was a bug that it didn't? Or in what cases it didn't before. &gt; Returning from lambda proc now always exits from the Proc, not from the method where the lambda is created. &gt; Returning from non-lambda proc exits from the method, same as the former behavior.
thanks, got a copy!
I had a similar issue and this fixed it for me as well!
I’m in the exact same situation haha. Grabbed the book to help me get back on it. 
Got my free copy, thanks!.
Wasn’t my first language but at my company (mid sized insurance) we use Ruby and Rails to build in house business applications and APIs. If you check out today’s “who is hiring” HN thread [here](https://news.ycombinator.com/item?id=19055166) you’ll see the kind of tech that people are hiring for. From a quick search there’s about 20 companies that mention Ruby. 
Learned ruby as a first language and work in it professionally. You'll typically find ruby in companies at the MVP (minimum viable product) stage due to its rapid prototyping... I've found that as companies grow, there's almost always pressure from higher-ups to move to a more "enterprise" language for the main product back end. From what I've seen, Java is a popular transition choice. There are however still tons of companies out there using ruby in their main applications, namely Stripe (no rails), Shopify (still rails), Basecamp (obviously), Digital Ocean (i think?), among others. I know that Twitter was a Rails application that moved to Java/Scala. That said, almost every company I've ever worked for has had multiple language stacks, and engineers focusing on those stacks. A lot of devops folks will use ruby or python, since they make scripting easy. 
Thank you! Got a copy 👍
Works perfect. Thanks!
ah, thank you. Cool!
thanks!
Have you been working with other languages? My strongest is JavaScript. I also learned C# a few months ago for an apprenticeship, but same boat, havnt really used it since then. I really don't want to lose what I'm learning!
Not really. I work with motion graphics so programming kinda fell in the background and I stopped doing it. When I tried to get back to it a year later it felt too overwhelming(Ruby on Rails that is). Definitely my fault.
Awe, oh man. Well, on the plus, you learned it before..so its still in your brain somewhere, just a matter of kickstarting it back on the top of your mind..it wont be like learning it from scratch, for sure. Motion graphics does sound pretty cool though.
There was basically no code there that was real. How can you tell me where it belongs? Why are you so angry with loop functionality? Something still needs to write the log statements, I don't care how you get to a logger. Make it a mix-in, but still call the logger. I'm not sure I trust what you're talking about here. Using convenience shortcuts? Do you write ruby? The standard library is like 99% convenience shortcuts for simple operations that are nicely implemented for you. Also, extensive mix-in use is a wicked anti-pattern and terrible for discovery. Have you read the rails code base or had to debug anything there? Also, working with collections is a extremely clarifying way to program and generally reduces the types of odd scenarios you can get into because of various return types. This is why Java's optional provides a \`.map\` call. It's much easier to program around and write clearer code for even the concept of a single-element collection than \`null\` or \`something\`. Can also delve into how Haskell makes use of \`fmap\` when it comes to the \`Maybe\` monad.
I don't care whether you like my code or theirs, but I appreciate that you also care about fellow developers and keeping the community great!
I care
it was not my first language. it was and still used extensively in some of the infrastructure pieces of one of the biggest cloud providers in the world.
I don't think OO is bad. I think you need to have clear easily understandable and digestable code. I don't think 100 line methods are any more functional than OO. Pulling out the concerns of transforming data or passing data is just cleaner code. Loop convenience methods are just a great way to separate the context of what I'm trying to do here versus there.
wow, cool. 
also if you’re on a mac, homebrew is ruby. if you do devops puppet and chef are ruby. the best microweb framework that you can use to prototype shit is sinatra which is ruby ruby is everywhere and is so much more than rails. it’s no longer the new shiny toy, but maybe that’s a good thing
sweet, yeah I have homebrew. I have not used puppet and chef, and have done some sinatra. cool! right now I have to learn Java though. 
meh. java is as vanilla as it’s ever going to get. no guts no glory.
yeah, gotta learn it right now. I love me my Ruby, but current situation demands the java. it is learning though!
http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
ah, haha, looks like a good and entertaining read from the quick perusal, thanks!
Needs more foxes.
I have ~5 years working with Ruby professionally, started as PHP dev, then discovered Rails and it's ecosystem and jumped right into it 😀, Ruby is a pretty nice language to master You will find Ruby in companies doing web development and light background job processing. There are companies out there looking for Ruby/Rails devs I'm currently implementing some ETL processes using Ruby and Sidekiq. 
cool! yeah I have not gotten to rails yet, just ruby foundational stuff and then got into sinatra a bit, but having to learn some Java right now. sounds really cool though!
Cannot add to cart. Are the coupons used up?
Cannot add to cart. Are the coupons used up?
I wonder how this compares to Perl's [`File::Find`](https://metacpan.org/pod/File::Find). 
I know of nothing. Especially something that claims to be cross-platform. 
Cannot add the book to cart 
Same for me.
My first commercial language was Smalltalk, but could never get any ongoing gigs using it. After 15 years or so in C, Delphi, Java and the like getting an opportunity to code in Ruby was like coming home. I agree, it's a beautiful language. Even after a decade of working with Ruby I still love it. I don't think I could ever go back to coding in another language, even if the pay was better. In terms of what sort of companies, most of my work has been in either Healthcare, Education or large scale system administration - though lately it's been writing client-facing web application using Rails. There's plenty of work out there. A lot of places don't necessarily advertise they use Ruby, but thanks to tools like Chef, Puppet, etc it's pretty much made it inside a huge number of enterprises.
Thank you for this, I love the dry ecosystem, and I'll definitely use this gem!
From what I understand, GitHub runs on Rails. I don’t disagree with anything you said. But, eh. Big name, worth mentioning. 
My experience with java is that most of your programs break when there's a new point release. Any new version of a language will do that to some degree, but java is the worst. Also, I'm scared of a language owned by Larry "you haven't won until everyone else loses" Ellison. Have you paid your license fee yet?
Oops, it was fast! updated link in the post above. 50 more
see updated link
see updated link
see updated link
see updated link
see updated link
Thanks, got it
Ruby was not my first language. I think originally I once used BASIC and Pascal; lateron more seriously LPC and perl; then php, then ruby. I use ruby for literally everything these days. To me it does not matter whether companies use it or not - I don't adjust myself as to what any random company wants, I adjust myself to what I can use effectively and what is fun and go from there.
Homebrew works on Linux as well, even officially.
I never understood any appeal to java anyway. To me it is a verbose, boring and useless language. I don't use any java here on my *nix system but I use a lot of ruby and C/C++.
&gt; I don't think I could ever go back to coding in another language, &gt; even if the pay was better. The thing is that most programming languages are really AWFUL. Ruby is very good but not perfect either; it is pretty but not all of ruby is pretty. It raised the bar, though. It's hard to use languages that are worse than ruby, and new languages that are pushed, are so terrible. I think the truth is that most people are terrible at designing a programming language.
&gt; Ruby has a fairly low learning curve That's not really true. There are a lot of idioms and syntax-choice in ruby that are not necessarily super-easy to grasp for newcomers. Ruby just is an extremely coherent and consistent language once you understand how it "works". It also is not an utter spaghetti-mess, unlike PHP and JavaScript. But ruby is also not the simplest language ever designed. &gt; Unlike in JavaScript, Ruby lets you inspect the location in memory of a value with the object_id method That is also not true - that just returns the associated object id number, not the "location in memory". You have a lot of introspection in ruby available but it's nowhere near as on the same level as pointers in C. &gt; I've never used this in a practical sense You can use it in combination with ObjectSpace. However had, it probably is not too terribly useful for 99,999% of the people out there. &gt; This works great for single words, but you can even turn a longer string into a Symbol &gt; and increase efficiency with the .to_sym method What a horrible advice. &gt; I use symbols over strings wherever I can I guess this is an example of where ruby is not the simplest language possible - symbols are not like strings and vice versa. &gt; In Ruby, parentheses are generally optional, which can sometimes lead to Ruby that looks &gt; very natural language-y and easy to read. &gt; Although it can get a bit confusing if you've got multiple arguments. Nobody prevents you from using () there. Other than you being lazy, of course. Making parens optional gives you more flexibility IF you need it. In python you DO NOT GET TO CHOOSE AT ALL. And that is a fundamental difference showing the different philosophies at work. &gt; For example, is 5 the second argument to bar, or the second argument to foo? &gt; Without brackets it's not clear I always use () for method definitions when there is at the least one argument. I hate the non-() style that some people use. But two things ought to be said still: - If you omit the (), and use the "def foo bar, bla", you actually save one character since you don't have to use the trailing ')'. (The leading '(' will become a space " " so you do not save that one, but you save the trailing character.) - It is also a bit easier to type the "def foo bla, ble" than the "def foo(bla, ble)" variant. But anyway, I recommend to use the (). The world is not going to end if you use a few more (), we already have lisp to take away most of the world's supply of (). It takes me more time to mentally decompose the "def foo bar, bla" variant than the one with (). &gt; But in Ruby, trying to pass a reference to the method actually invokes it! So we end up with: def greet(name = 'Harriet') puts "Hello, #{name}" end welcome = greet # This line actually executes the greet function welcome "Paula" # undefined method `welcome' for main:Object Pass a reference to a method? I never heard that term before. But I think this is bogus anyway - if you need to use different names you can use aliases to the method as-is. The thing is - JavaScript is such a terrible language that things that are complicated (and stupid) are extremely easily done in ruby. &gt; In JavaScript there is not really a concept of true classes Because it is more a joke than a language, so no surprise there. &gt; This is super confusing, so I really like that Ruby just offers the one way &gt; to do it! Of course there is more than one way to create a new class or instantiate a new object in ruby. But the thing is - most of the time you just want and need the simplest default way. It's nice that javascript folks consider ruby but I think it is best not to try to apply javascript terminology and concepts onto ruby via a 1:1 parity - that just doesn't work very well in my opinion.
Also here a good read-up for what Symbols really are: https://ruby-doc.org/core/Symbol.html I think jeremy wrote that (not 100% sure but I think he wrote some Symbol summary some time ago because people kept on wanting to unify symbols and strings and they are not the same).
What would a non-AWFUL language look like to you?
cool. do you work for a company or do free-lance, or just hobby? I'm just wondering where the self-determination as to what you use arises.
Thank you!
cool. and so Chef and Puppet used more on the devops side rather than SE side? Yeah I know someone at Amazon who says they also use some Ruby. 
yeah, it's so verbose. what i'm gathering going from doing lots of extensive coursework in Ruby, going to Java. 
I thought it read like someone who only did a bootcamp, and [indeed](https://www.harrietryder.co.uk/blog/northcoders-interview-process/). She should continue to learn, it seems she's very interested, but should be learning lower abstractions, not higher ones.
It wasn't my first language, but I started learning it as a hobby while I was a PHP/ColdFusion developer, and managed to turn that hobby into full time work. I've seen two primary areas where a company might use Ruby. The first is small startups looking to quickly bring a product to market (MVP, as /u/ni3t mentioned). The second is within large companies, for either internal tools or internal sysadmin work. I remember talking to some RedHat employees a few years back, and while they had no intention of deploying any public-facing Ruby code, Ruby was used in-house for tools that were developed specifically for their employees.
awesome. hmm, maybe a startup some day for me or an internal tools type of role somewhere if I can/do get back to Ruby. ty!
Can anyone provide an example of how to implement the author's \`Book.find\_by\_ISBN\` Metaprogramming example?I'm not sure what they're getting at here. (Pro JS/React developer, Ruby newbie)
You'd use #method_missing to inspect the message being sent to the object, see if it starts with "find_by_" and then trim that part off and use the remainder to build your query (or w/e). If it doesn't start with "find_by_" you'd call #super to get the normal method_missing behavior.
Awesome. And that just works in a class that inherits from ActiveRecord?
I'll be honest and tell you that I didn't read the article, and I've also never used Active Record (or Rails) in the decade that I've been a professional Ruby developer. I use Sinatra and Sequel. So I don't know the answer to your question. I'd also suggest that while this kind of meta-programming can be super enticing and sexy, you really should use it very sparingly. Using #method_missing is pretty slow and the implementation will inherently be conditional and thus more difficult to understand compared to just implementing methods for your use-case. Conditional execution paths dramatically increase the complexity of your code and make it much more difficult to reason about. There was a time when the Ruby community fell in love with this type of meta-programming and not too long later there were tons of "anti-pattern" blog posts warning of its dangers. I'm sure you can find them if you look.
Back in my freelance days I dabbled in Rails and realized it was way better than what I was making most apps with at the time (PHP). When I started my own niche SaaS product I built it with Rails. Three years later and we’re on track to do $3m this year with a team of 8. We have no intention to change the back end and we’re actively looking for more Rails devs!
To answer your question, yes, this is present in any class that inherits from ActiveRecord. However I and most developers I know just use the basic `find_by`.
&gt; AND slow Not necessarily. Check out Enumerable#lazy.
Oh yeah, that's a big one. Forgot about GitHub. 
&gt; That is also not true - that just returns the associated object id number, not the "location in memory". You have a lot of introspection in ruby available but it's nowhere near as on the same level as pointers in C. This is splitting hairs, I could also argue that most of the time you can't figure out the 'real' memory location in C, just it's location in virtual address space and on most modern OS's it's nearly impossible to map this to a physical memory location. An `object_id` is rather analogous to a virtual memory location. &gt; Pass a reference to a method? I never heard that term before. But I think this is bogus anyway - if you need to use different names you can use aliases to the method as-is. They are referring to the fact that a bare usage of a function name in javascript returns a reference to the function. e.g. `let myVar = myFunction` results in `myVar` referring to the function `myFunction`. The equivalent in Ruby would be something like `my_var = method(:my_function)`. 
TBH that one has flip flopped a bit in rails too. So maybe the author's learning material is an old rails book. The general convention now is \`\`\`find\_by(something: 'thing')\`\`\` but there was a period (circa rails 2.3 or 3.0 IIRC) where the methods were written as \`\`\`find\_by\_something('thing')\`\`\`. I think they're still supported through method missing, maybe for legacy support? TBH I'm not sure as I just adapted and moved on with my coding life. :) 
passing a method by reference is pretty commonplace in JS, but i agree it’s completely unnecessary in ruby. the whole point of passing methods (as callbacks) is to avoid race conditions. with a synchronized flow like ruby that’s not necessary
&gt; Pass a reference to a method? I never heard that term before I don't think they were complaining as much as simply pointing out a surprising difference. I mean, the title states coming from JavaScript. In JavaScript, or Python, that first statement would be setting the variable to the reference to that method. I.e., it does not execute and evaluate, it just points to that function. In Ruby, it is executed, and evaluated as an expression. It's distinctly noteworthy coming from js, or py.
I found your comment extremely condescending to the OP, basically saying that she's stupid and lazy. I strongly suggest you consider how to get your points across in a more respectful manner. Thank you, that is all.
uh... maybe I'll join! haha or well, a Ruby/Rails shop. Frankly I've only slightly dabbled with it since the curriculum I take has us using Sinatra at this point.... But things have been on the back-burner Ruby-wise since I currently need to learn Java right now. Congrats, sounds pretty cool!
Friend, are you trying to specialize in being known as the person who writes really rudely on /r/ruby? Your points may be useful, but you don't have to be rude about it. 
&gt; Nobody prevents you from using () there They obviously know that, based off the fact they mentioned right in your own quote 'parenthesis are generally optional'. They also wrote '..can lead to code that looks.. although it can get confusing when you get to multiple arguments', not "you write code that looks .. although its confusing when you get to multiple arguments". The difference? The latter implies is from the perspective of what **you** create, and implies its the only way. The former is from the perspective of what you **find**, and does not imply that its the only way / that you personally have to make things that way. The former is also true; because they're optional, you can find some confusing syntax abuse. It is important to take note of what is possible, because that will determine what you will find a la murphy's law. 
Thanks!
Your points would be better expressed without the weird aggression and childish opinions about the author and other languages sprinkled in. You come across like someone with little experience outside of Ruby, which is ironic since you sure seem like you should know that Ruby was built with joyful communication and collaboration in mind. 
Not my first language, but I use it regularly at my job at Zendesk. Zendesk started out ~12 years ago as a 3-tiered nginx/rails/mysql app. Eventually the rails monolith became a burden, so more (micro)services got created. Some in ruby, some in other languages like Scala or Node.js or Golang. So now we're more polyglot, but I think ruby still makes up the majority of all in-house code we've written. FWIW, I've worked in software professionally for almost 20 years.
Update: problem solved, I used cookies with curl and it works fine!
wow, that sounds really cool, awesome. thanks for sharing.
Thanks :)
Is this your first time seeing /u/shevy-ruby? We see his comments all the time in /r/programming, along with his alt account /u/shevegen (which I assume got suspended or banned, so he switches between the two) `Extremely condescending` is exactly how I would describe almost every one of his comments.
Documentation and writing on all of this is really pesky to find, and that \`nil\` -&gt; \`nil?\` change always nails me.
It doesn't serve the same purpose in terms of code readability which is the main use case of `tap` IMO.
This should be a fairly literal translation: #!/usr/bin/env ruby class ReverseIt def self.reverse(values) n = values.length for i in 0..n values[i] = values[n - i] values[n - i] = values[i] end values end end values = [1, 20, 53, 42] rev = ReverseIt.reverse(values) for i in 0..values.length puts "Reverse: #{values[i]} -&gt; #{rev[i]}" end It would help to have the expected bugged output. 
This is what I came up with after about 10 minutes. Please note that idiomatic Ruby tends to avoid using \`for\` loops and prefer iterators instead, but in order to preserve the original bugs I had to make use of it. &amp;#x200B; \`\`\` def reverse(values) n = values.length &amp;#x200B; for i in 0...n values\[i\] = values\[n-i\] values\[n-i\] = values\[i\] end &amp;#x200B; values end &amp;#x200B; values = \[1, 20, 53, 42\] reversed = reverse(values) values.each\_index { |index| puts "Reverse: #{values\[index\]} -&gt; #{reversed\[index\]}" } \`\`\` &amp;#x200B; One way of correcting it (not tested) \`\`\` def reverse(values) n = values.length &amp;#x200B; for i in 0...n/2 values\[i\], values\[n-i-1\] = values\[n-i-1\], values\[i\] end &amp;#x200B; values end &amp;#x200B; values = \[1, 20, 53, 42\] reversed = reverse(values.dup) # &lt;- make \`reverse\` operate on a copy of values values.each\_index { |index| puts "Reverse: #{values\[index\]} -&gt; #{reversed\[index\]}" } \`\`\` &amp;#x200B; Here, the bugs are fixed by swapping in-place using Ruby multiple assignment (which is definitely the idiomatic way of doing it) and making a copy of the array before reversing it in-place. Obviously, other solutions exist. &amp;#x200B; HTH
I levelled up at OOP Ruby by watching [Sandi Metz's talks](https://www.youtube.com/playlist?list=PLg8u8tlvFV2irT3bfrXiUnlSvSOn7e7NQ) and reading • [RubyTapas](https://www.rubytapas.com/), and its little-known but well-decorated subset, [MOOM](https://avdi.codes/moom/), • [POODR/99 Bottles](https://www.sandimetz.com/products/) • [Refactoring](https://www.amazon.com/dp/0134757599) • [Object Thinking](http://www.informit.com/store/object-thinking-9780735619654) • [PoEAA](https://www.amazon.com/dp/0321127420) • [Design Patterns](https://www.amazon.com/dp/0201633612) • [Smalltalk Practice Patterns](http://www.informit.com/store/smalltalk-best-practice-patterns-9780134769042) Be careful with those last three pattern books. They are tomes of great power. 
Not my first language, but I've been using it professionally for 4 years. Work primarily on Rails apps and do data scraping / collection / processing with it (no modeling; for that I'd use Python).
To be clear, using `#method_missing` to inspect messages being sent and doing whatever you want with it instead of throwing an error is part of base Ruby, not just Rails.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [Run.rb: Run Ruby in the Browser using WebAssembly](https://www.reddit.com/r/RubyLang/comments/aml4ki/runrb_run_ruby_in_the_browser_using_webassembly/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Is it just me, or is there an audio sync issue?
nice solution. :) I especially like that it only has to traverse half the list. Although it might be more commonplace to see an empty array variable assignment prior to the loop, instead of parallel assignment within it. Parallel assignment, while nice and convenient, tends to make code harder to read. \`\`\` def reverse(list) n = list.length new\_list = \[\] for i in 1..n/2 new\_list\[i-1\] = list\[-i\] end new\_list end \`\`\`
sweet, really cool to hear. maybe i'll be able to work with it professionally one day. was my first learning language - frankly have to get through a bit more material towards the end of the stack. have to learn Java right now. I can now better appreciate how beautiful and even aesthetic a language Ruby is.
Thanks, that looks pretty close to the original.
Thanks, yeah, I was wonder if I should be using do ... times instead.
Ruby WAS my first language. Apps built in it helped me get a real job. Don’t use it at work (react and Go) but do build personal stuff w it 
As I said, there are several ways to fix it, including of course modifying the method to return a copy of the array. This would also make for a convenient follow-up question about the pros and cons of side effects in functions. I just picked the laziest solution ;) Also I’d like to point out that while indeed this solution (and OP’s template) only traverse half the array, it has to make a full copy first, so your solution is actually slightly more efficient. Regarding multiple assignment, that’s a fair point. As I said before, I just picked one way of fixing it, others are possible.
Yeah, actually, that’s probably the preferred way of doing it. 
Oh. I thought a method was instantiated for each column in that model on class load. TIL
I would hate to work with you. 
Ruby wasn’t my first or even second language. My background was VB6, Pascal, .NET C# and a few others. After about 6 years working professionally I learnt Ruby and Ruby on Rails and switched. The company I work for is one of if not the largest digital agency in Australia. We only use Ruby and primarily Ruby on Rails (very very rarely another language or framework for web applications). We now have over 40 employees. If you love the language there is plenty of work out there.
`%%` just gives you a literal `%` It doesn't translate to an `if` statement. 
&gt; %% replaced with % if first thing on a line and % processing is used What is meant by `%% replaced with % if first thing on a line and % processing is used` then?
`%%` is replaced with `%`, if `%%` starts the line. `%%` in the middle of a line is not treated special. All of that only applies when `%` processing is used. 
Ok, you are parsing the documentation wrong. Try to read it like this: `replaced with %, if first thing on a line`.
Oh.
awesome. Ruby has been great, haven't been able to work with it as of yet.
awesome! congrats!
Doh! I should have known that (or at least tried to run it myself). I just realized that I had too few dots in the ranges. It should have been `i...n` to match the original's termination expression `i &lt; N`. I've edited it accordingly.
&lt;3
arr = [{name: "bart"}, {name: "lisa"}, {name: "maggie"}] out = arr.inject([]) do |memo, hsh| memo &lt;&lt; hsh["name"] end p out # =&gt; ["bart", "lisa", "maggie"]
https://gist.github.com/ashokallu/5e22e5f043cdddeffa80b5ce880511db#file-ruby_enumerable_inject_method-rb I was fascinated with Enumerable#inject method that I have written ruby implementation of inject method, I hope this might help you 😊
If you're using Bundler with your rails apps, it should take care of installing the same gem versions. If you aren't using Bundler with rails apps, well, you should be. As far as rvm - personally I would switch over to rbenv when you go to a new laptop. A lot of what rvm does/did was designed in a pre-bundler world, and just adds complexity to the state of the art now.
Well you are using bundler right? All that info is in your Gemfile &amp; Gemfile.lock file re: gems. As for rvm's cached files those live in \~/.rvm (in your home folder) and there are some settings in your bashrc file. Although you're still going to have to reinstall rvm because of the dependencies which it takes care of when you install the script from rvm.io What I usually do when wiping my system is rsync the directories/files I need to another drive and then rsync them back. I also have a ruby script that will bootstrap all my config settings, e.g. vim, git, base16 themes, but you'll have to write that one on your own. FWIW rvm setup is fairly easy on a new machine and running bundle install isn't that hard either. You might be overthinking this one. 
I don't understand the point. Why are you doing interviews in languages you don't know? How can you tell if the candidate is any good? 
There are more `for` loops in this thread than I've seen in 7+ years writing Ruby :p
Oh yeah that makes sense. New to rails apps and totally forgot about bundler .. So I guess i should just make sure bundler is installed and that should take care of my rails apps. i did briefly look into rbenv , and originally chose rvm over it because it seemed simpler. Ill look into it again thanks
Well thats the problem , I was not sure how many different directories rvm uses or where they would be located; and I wanted to make sure I had a thorough sync of all the folders. Maybe im just overthinking it.. 
This isn't true of everything, but generally you only ever went to reuse configs found in your `~/` directory. Anything lower can be version or install specific. So you might be overthinking some of this. Rails will let you know what to install when it comes to gems and your Gemfile should (and if not, you may want to) be Ruby version specific and Gemfile.lock will be Bundler version specific, otherwise Bundler will loudly tell you. That said every time I reinstall environments I always hit issues getting Homebrew versions to play nice with gems and development environments. Looking at you nokogiri, imagemagick, and Postgres. If this is something you think you will run into again check out some dotfiles repos on GitHub to get your environment documented, organized, and best of all bootstrappable. 
Im not using HomeBrew, never had a problem with it .. but just dont like it. Dont like all the extra management. 
Most are the hidden files; .bash_profile, .gitconfig, .bashrc Here is a popular one https://github.com/mathiasbynens/dotfiles
You might consider Docker as an alternative to rvm / rbenv. For my rails work it makes it very easy to keep my development environment isolated inside a container. You can use the official Ruby image from Docker hub and you're off to the races on any system. This is especially helpful for the rest of the stack (eg database) to keep it completely isolated for each project, and with a Docker compose file or similar you can just check out your repo and run it all with a single command.
The c code for int_pow isn't very difficult. Squaring is easy, so you reduce the power function to a bunch of squares. You only need to multiply 21(? give or take) times to find the 1312000th power. int_pow(long x, unsigned long y) { int neg = x &lt; 0; long z = 1; if (y == 0) return INT2FIX(1); if (neg) x = -x; if (y &amp; 1) z = x; else neg = 0; y &amp;= ~1; do { while (y % 2 == 0) { if (!FIT_SQRT_LONG(x)) { VALUE v; bignum: v = rb_big_pow(rb_int2big(x), LONG2NUM(y)); if (RB_FLOAT_TYPE_P(v)) /* infinity due to overflow */ return v; if (z != 1) v = rb_big_mul(rb_int2big(neg ? -z : z), v); return v; } x = x * x; y &gt;&gt;= 1; } { if (MUL_OVERFLOW_FIXNUM_P(x, z)) { goto bignum; } z = x * z; } } while (--y); if (neg) z = -z; return LONG2NUM(z); } 
Look at bignum.c, not numeric.c. I'm guessing that elixir doesn't have the optimisation that ruby has in bigsq - multiplying a number by itself can be much faster than normal multiplication. See this comment in bignum.c: /* efficient squaring (2 times faster than normal multiplication) * ref: Handbook of Applied Cryptography, Algorithm 14.16 * http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf */
MRI uses this algo: https://en.wikipedia.org/wiki/Exponentiation_by_squaring I'm guessing the other languages you tried are using the naive algo.
uWaterloo represent!
ah good catch. Looks like i'll be spending some time working through that paper. Thanks!
That might only be a part of the puzzle. There could be a bunch of other things that might be slower in your other language that ruby has optimised away. You probably need to benchmark all the various bits to figure out which things ruby is doing faster than your other lang. This might be slower than the even? check in ruby, which just looks at the last bit. A naive implement of rem(n,2) might be actually performing division. Ruby optimises div(n, 2) using bitshift, your other lang might not. 
Rust seems to using the same algorithm. https://doc.rust-lang.org/nightly/src/core/num/mod.rs.html#1682-1702
The theory is that if you use bundler(Gentile in project) you should be able to wipe your entire disk at any point and still be able to just bundle install on new. If you cannot guarantee that then you were doing something wrong from day one (e.g.: overiding code installed gems in .rvm folder instead of extending their functionality)
PS: See the [Programming Crypto Contracts Step-by-Step](https://github.com/openblockchains/programming-cryptocontracts) guide / book for more contract samples in ruby (e.g. [satoshi_dice.rb](https://github.com/openblockchains/programming-cryptocontracts/blob/master/satoshi_dice.rb), [ponzi_governmental.rb](https://github.com/openblockchains/programming-cryptocontracts/blob/master/ponzi_governmental.rb) and many more). 
Ah, `yield_self`... I have a love-hate relationship with that one xD For one, I think the name sucks, and something like `apply` would make much more sense. I also think it'd be great if one could pass arguments to it, which would be passed to the block.
And GitLab as well :)
`#reduce` is nice, but for that example you could just do `names.map{|x|x[:name]}.join(", ")` ;)
`+` is slow for strings, don't know how interpolation compares, but I imagine it's similar. AFAIK it's best to do `accum &lt;&lt; ", " &lt;&lt; character[:name]`, which mutates the existing string instead of allocating a new one.
There's nothing wrong with type checking, only in this case you don't *really* want to know about the type, you actually want to know if it's the first element in the array and inferring that from the type of the accumulator, which is hard to understand unless you look up exactly how inject works. See my top-level answer for a cleaner way around this.
It will be aliased to ‘then’ What is an example of needing to pass arguments?
That regex may work, but consider that it will try a) for each character b) every remaining character until it finds a duplicate or runs out of characters. With longer strings that have no duplicate, this will get very slow very fast.
When you pass in a lambda, proc or method, those might require additional arguments. Adding options maps is another use-case I could think of. Something like this string.apply(awesome: true, &amp;foo.method(:bar)) A somewhat more likely example could be: "foofile" .downcase! .gsub(/foo/, 'bar') .&lt;&lt;('.txt') .string.apply("content", &amp;IO.method(:bar)) but in my experience it really just becomes useful as code gets more complex, so there's not really a simple everyday example I can think of that really shows why it's necessary.
Thanks! I wasn't sure of the speeds off the top of my head, but I did know `+` is slow and stylistically interpolation is usually preferred. TIL `&lt;&lt;` is fast!
You didn't ask me - but I think Elixir in a non-AWFUL language. Problem is, it's hard to find a job with companies using Elixir. It's a hard balance to strike - knowing a decent language and having plenty of job opportunities. That's one huge advantage of Ruby - they're still are plenty of gigs out there for it.
Your 'improved' version is ~44-48x slower. This is mostly because you're now allocating a ton of unnecessary objects. In the case of the complex command it's actually _really_ slow taking ~2ms to parse the command. Warming up -------------------------------------- old_simple 9.688k i/100ms new_simple 216.000 i/100ms Calculating ------------------------------------- old_simple 102.901k (± 3.2%) i/s - 523.152k in 5.089352s new_simple 2.154k (± 4.7%) i/s - 10.800k in 5.026011s Comparison: old_simple: 102900.7 i/s new_simple: 2153.7 i/s - 47.78x slower Warming up -------------------------------------- old_complex 2.093k i/100ms new_complex 47.000 i/100ms Calculating ------------------------------------- old_complex 20.889k (± 3.7%) i/s - 104.650k in 5.016625s new_complex 478.197 (± 3.8%) i/s - 2.397k in 5.019967s Comparison: old_complex: 20889.2 i/s new_complex: 478.2 i/s - 43.68x slower Test cases used: cmd_simple = 'curl https://isrubydead.com/' cmd_complex = %Q{curl \ --header "X-Page: 42" \ --compressed \ --request PUT \ --user "bob:p@ssword" \ --cookie "NAME1=VALUE1" \ --user-agent "Ruby" \ --data "name=Sue" \ https://isrubydead.com/} Benchmark.ips do |x| x.report('old_simple') { ParseCurl.parse_old(cmd_simple) } x.report('new_simple') { ParseCurl.parse(cmd_simple) } x.compare! end Benchmark.ips do |x| x.report('old_complex') { ParseCurl.parse_old(cmd_complex) } x.report('new_complex') { ParseCurl.parse(cmd_complex) } x.compare! end 
I really like the object oriented solution for your problem but I have some issues with your solution ... - Scanning ObjectSpace to find subclasses could cause problems with autoloaders. Those subclasses may not be loaded at the moment `Base.subclasses` is called. I would rather hardcode them in your gem if you don't want gem users to register their own 'Word parsers' (or however those Base-subclasses are called) - `Base.===`: I don't like operator overloading (most of the time) because it makes code harder to understand. I had to read the following section multiple times to understand what is happening: `Base.subclasses.detect { |klass| klass === word }` (What about ... `Base.subclasses.detect { |klass| klass.matches?(word) }` ?)
Thank you for suggestions, I'll update the code accordingly since your points make sense to me. `Base.subclasses` is indeed a little hacky, but I couldn't find a better way to do that in pure Ruby. I'll try to come up with a less-hacky solution.
Thanks for the benchmark, I'll try to improve the performance before releasing the gem.
Hi, I'm a member of the TruffleRuby team and the author of that blog post. If has any questions about this I'll be happy to answer them here.
 # use a global constant Word::ALL_WORDS # returns all classes that can be used for this matching thingy # use a registry Word.registry &lt;&lt; Word::Header # you could call this after definition of Word::Header Word.registry &lt;&lt; Word::Authorization Word.registry.words # bad naming 
Very nice refactoring! Good idea to override the "case" operator `===`, though I expected you meant to use it for a `case` statement; with explicit usage I would probably also use `matches?` or something like that. It would be nice to be able to parse the `curl` command with the `optparse` standard library, but I don't see a way how you can pass it arguments coming from somewhere else that's not `ARGV`. And I'm not sure if you'd be able to use the desired pattern with `optparse`. Btw, you could avoid the `ObjectSpace` logic if you added an `inherited` hook in your `Base` class which saves each subclass into an array: class Word::Base def self.inherited(subclass) subclasses &lt;&lt; subclass end def self.subclasses @subclasses ||= [] end end # ... Word::Base.subclasses #=&gt; [...]
Upvote for using self.inherited! Awesome!
Is the question mark supposed to be part of the regex? I'm not sure I'd want to lazily capture 0 or more ocurrences of something. I'd either s/*/+/ or drop the ?.
Pretty cool and worth a look!
TruffleRuby is looking great, good job guys!
It's probably because big integer multiplication is quite well optimized in Ruby. It either uses the [Toom-Cook algorithm](https://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication) or delegates multiplication to the GMP library, if compiled to do so.
**Toom–Cook multiplication** Toom–Cook, sometimes known as Toom-3, named after Andrei Toom, who introduced the new algorithm with its low complexity, and Stephen Cook, who cleaned the description of it, is a multiplication algorithm for large integers. Given two large integers, a and b, Toom–Cook splits up a and b into k smaller parts each of length l, and performs operations on the parts. As k grows, one may combine many of the multiplication sub-operations, thus reducing the overall complexity of the algorithm. The multiplication sub-operations can then be computed recursively using Toom–Cook multiplication again, and so on. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
sigh... if you are going to ask a question, take the time to format it correctly. ------------------------------------------ Hey guys! It's possible to save a element in a variable and print it on a textbox? HTML element: &lt;span id="ctl00_ContentPlaceHolder1_ucInfoClient_lblDispCash"&gt;2870,14&lt;/span&gt; What I tried to save/copy: puts "Disp. Cash: " + browser.find_element(:id, "ctl00_ContentPlaceHolder1_ucInfoClient_lblDispCash").text column4 = browser.find_element(:id, "ctl00_ContentPlaceHolder1_ucInfoClient_lblDispCash").text What I tried to print/paste: browser.action.send_keys(:colunmn4).text Thanks for ur time =) ------------------------------------------ Ok, so this is bad ruby mixed with would never work ruby. Are you using [Capybara](https://github.com/teamcapybara/capybara)? You should be. First find the element. value = browser.find_element('span#ctl00_ContentPlaceHolder1_ucInfoClient_lblDispCash') Now you can get the text from that element: value_text = value.text Now you can use send_keys to send in the value_text to your text box, but you haven't found it. Find the element you want to interact with text_area = browser.find_element('textbox#whatver_id') Now call send_keys on the element. # you don't need to send :enter, but frequently its helpful text_area.send_keys(value_text, :enter) Notes: 1) Use single quotes unless you are doing variable interpolation 2) You are calling #text all over the place in your code, I have no idea what you think that is doing, but its not doing anything beneficial. 3) Use string interpolation rather than building strings. So rather than: puts "Disp. Cash: " + text Do: puts "Disp. Cash: #{text}"
The enumerable module is one of Ruby's most widely know and written about features, I'll never understand why some people who have noting new to contribute feel the need to publish rehashes of existing blog posts.
I just pulled truffle rc12 and for the first time was able to create a basic rails app with postgres, great work!. Bundler also seems much quicker than it was in rc11 but it did segfault several times requiring running it a few times before everything installed. 
Thank you, Janko! I'll replace my hacky `ObjectSpace` approach with that. Yes, I intended to use `===` in case initially but decided not to afterward, which resulted in this awkwardly named method. I don't think I want to support arguments coming from elsewhere, here's the actual gem executable code that uses `OptionParser` that I've left out of the blog post: #!/usr/bin/env ruby require 'optparse' require_relative '../lib/parse_curl' options = { format: 'json' } OptionParser.new do |opts| opts.banner = 'Usage: TODO' opts.on('--format [format]', '-f', 'Format of the output (json, http, ruby, js)') { |v| options[:format] = v } end.parse!(ARGV) if ARGV.first puts ParseCurl.parse(ARGV.first, format: options[:format].to_sym) else ARGF.each do |line| puts ParseCurl.parse(line, format: options[:format].to_sym) end end This supports passing curl command via STDIN, which makes it really easy to use from Vim (passing the current line containing the curl command with `:.!./bin/parse-curl`).
Thanks menge101! I tried to find rules about how to ask something here, but don't find it hahahaha, its my first time in this sub. I'll try that =D. Thanks for ur knowledge!
- when do you think truffle can be used properly with rails? - do you plan to address the memory usage? - will be possible truffle to call java libraries(javafx, swing) - will be possible to call any c library from ruby using truffle 
I'm not a TruffleRuby team member, but I can warmly recommend that you open GH issues with logs etc, as the team is welcoming such feedback (I've done it a couple of times).
Excellent to hear that you could successfully create Rails app. If you do have the `hs_err*.log`s from the bundler crashes then could you report the issue [on github](https://github.com/oracle/truffleruby/issues)? I'll try reproducing the issue locally.
Could you point me to where the logs may be located? I'm not seeing where I usually find them for JVM crashes. I'm using the 'native' configuration for Truffle so I'm not sure where the crash dumps end up. 
This is interesting. Are there other uses you think it would be good for?
🙄🙄🙄...
For now the focus is on (blockchain) contract scripts. What do you have in mind? PS: For more (alternative) rubies see the [Awesome Rubies Page @ Planet Ruby](https://github.com/planetruby/awesome-rubies).
Ah, right. Please report it on GH, with any details that might help to reproduce it, and we'll take a look.
I suspect you have '1.17.2' specified in your lock file. Bundler / rubygems now does some shenanigans where it will try to load the version of bundler your lock file requires. 
I'll try to give you detailed answers tomorrow (reddit appears to be having some issue for me at the moment). In the meantime could you clarify what you mean by &gt;what are the assets of truffle compare let's stay with ruby, jruby? Do you mean what are our strengths compared to those two projects? &amp;#x200B;
Nope. Output from a directory with no Gemfile: $ ruby -rbundler -e 'puts Bundler::VERSION' 2.0.1 $ ruby -rbundler/setup -e 'puts Bundler::VERSION' 1.17.2 If I have a `Gemfile.lock` specifying 2.0.1, then the `require "bundler/setup"` actually fails with the error `You must use Bundler 2 or greater with this lockfile.`. 
i wonder if you wanna file the report on bundler Github instead of ruby bug tracker. might get more attention/response. 
that is correct. I'm curious what are the strengths :)
Works perfectly! Thanks again!
Thanks. I'll have to have a look at Elixir. Put a new wrinkle in the noggin.
dat pic tho... :)
Seems like Bundler wouldn’t have control over what version of “bundler/setup” is loaded, unless that submodule path exists in one version but not in another...
Great news, good step forward and great work to the team
Seriously though. You already posted this here last year when you wrote it, so it just seems like you're spamming at this point. https://www.reddit.com/r/ruby/comments/921wec/the_enumerable_module_in_ruby_part_i/
Maybe it's most interesting for homedir installation, for servers where you don't have root access ... :)
I think linuxbrew will end up having more recent versions of things and generally have packages that aren't easily available from the distro's package manager.
I think I might have been dealing with a gremlin. After several restarts, because of other projects, I can't replicate this. It is now working like it is supposed to!
I apparently dealt with a gremlin. After several restarts, because of other projects, I cannot replicate the problem. The code seems to be working like it's supposed to. Thank you for your help!
Hmm, that would seem logical, but this whole thing is screwy. If you get the right bundler by `require 'bundler'`... what happens if you `require 'bundler'; require 'bundler/setup'`?
Yeah, this is the value-add. You can work outside the distribution packaging, get new things installed alongside. Who knows if anybody will use it or care? But it's there.
1. How do you decide which C extensions to test TruffleRuby against? 2. Do you expect TruffleRuby to support complex C extensions such as app servers / network libraries (I’m the author of the iodine app server)?
Yep, it's definitely easier for a dev to release something on brew than on each of several different distros' package managers, especially given brew's easy github integration for unofficial taps. Official package management for many popular distros can be slow and bureaucratic, IMO.
RIP install options. If you want anything other than vanilla ffmpeg, for example, you’re compiling from source now.
Man. I can kind of understand the need (focus on binaries), so I guess pushing this out to taps makes sense. But I'd also imagine there are some important packages where options are critical - `ffmpeg` as you say, but `qt` another. I'd hate to build the latter from source each time. There's data on the formula page (https://formulae.brew.sh/formula/) that shows the number of installs with options for each. Generally small, but not insignificant.
What I see as the primary benefit is that it is a user-level package manager, rather than one which requires root to install.
You're probably right, but traditionally `brew` doesn't work well on multi-user systems. I realise that isn't the case you're arguing, but a single-user box where you don't have root (but the admin is still cool with you using an alternative package manager) seems an edge case in itself. Again, you're right. But it feels like the kinds of use cases where this works overlap the space Docker lives in. Dunno. Trying not to be negative.
You make a great point. Though I specifically am referring to single-user mode. I personally prefer packages to be installed at the user-level than system level unless there's a good reason to require root access.
🙄🙄🙄...
Nailed it. linuxbrew is very VERY useful to obtain access to recent projects. I use it to install Neovim, Postgres, chruby and a host of other tools on my Mint box. And, it is so easy to update them. Please don't negate linuxbrew, it has its place.
Actually, my guess is for developer machines. Now it will be easy to have \*one\* setup script that works for all devs.
I’m not sure exactly what you are asking for... Try `JSON.parse(json)` to parse a json string. 
take a look at the [win32-autogui](https://rubygems.org/gems/win32-autogui/versions/0.5.2) gen for windows automation. or else try coupling watir + sikuli for automating anything else. 
Homebrew was always Apple-like in this regard. "We know what you want better than you do" It's also quite crappy at dependency management. You can upgrade e.g. readline by itself to a new major version and then look at all those broken runtime dependencies.
Looks great and is a welcome effort in the space. In the more general sense, might some of the design choices be too restrictive if the goal is to compute deterministic results? It seems like the first cut here is a safer way to write solidity (which is needed!) but maybe less useful for including into other projects that just want to compute and compare a quorum of functions. 
Sourcetree is fine for like 99% of your Git needs. I'd also suggest getting [KDiff3](http://kdiff3.sourceforge.net/) and learning to properly diff and merge files with it.
&gt;when do you think truffle can be used properly with rails? We can currently run with a test rails app and are working hard to fix the remaining barriers to running large applications without modification. &gt;do you plan to address the memory usage? We do look carefully at memory usage. There is often a trade off between performance and memory footprint, and this will vary greatly with the application and how it is run. SVM can offer a very small image and memory footprint for some applications. &gt;will be possible truffle to call java libraries(javafx, swing)? Truffle offers extensive polyglot functionality allowing calls between languages. Please see [https://github.com/oracle/truffleruby/blob/master/doc/user/polyglot.md](https://github.com/oracle/truffleruby/blob/master/doc/user/polyglot.md) for details. I'm not sure how much people have tried to use this for JavaFX or Swing, but please give it a go and tell us about any problems you find. &gt;will be possible to call any c library from ruby using truffle? We already support some `FFI` features for this, and we're actively working on expanding our `FFI` gem compatibility to improve in this area. &gt;what are the assets of truffle compare let's stay with ruby, jruby? We aim to offer fast performance, very good compatibility with MRI, and all the other features provided by [Graal VM](http://www.graalvm.org/). &gt;there is any roadmap for the stable version? There is a road map to release a stable version of GraalVM, but TruffleRuby itself will remain experimental for the time being. &gt;will be possible to use sulong native-image to compile a ruby script and all the libraries? Not at this time. &amp;#x200B;
Why are you putting so much work in C extensions? Would it not have been much easier to port the big Ruby gems to Ruby instead? I remember when many Ruby gems had Ruby fallbacks for when the C compiler is not available, but that might no longer be the case. You had a fully working Ruby interpreters ears ago, and the only reason big libraries like Rails are not working is because of C extensions right?
We have initially looked at C extensions used by common Rails applications and other widely used Gems. We are expanding our testing at the moment based on gemfile locks sent to us by interested users. Iodine is an interesting case as I would class many of the things it does as almost an anti-pattern for us. We don't support forking at this time, and it's probably not a sensible thing to do in TruffleRuby's case, and we do not currently support some of the `pthread` functions you use. We do want to support running C extensions with multithreading if they are safe, so forking the process may not even be needed on TruffleRuby. We do have a macro definition so you can detect that you're compiling on TruffleRuby, so it might be possible to disable compilation of some aspects of Iodine, but it's also worth talking with us as pure Ruby can often be as fast as C extensions on TruffleRuby so you might not need some of those things anyway.
We already have snap packages for Linux, a nice alternative when the package manager doesn't have a new enough version. I honesty cannot see myself using homebrew outside of OS X.
If we ported the common C extensions to Ruby we'd probably have to support those ports, and it quickly becomes a lot of work, and it would only solve the problem for those popular gems.
We seem to be living in a world where folks claim know what you want more than you do: systemd, bundler, the Apple touch bar... It's fine when things just work, but there are days when stuff screws up and you end up feeling like a victim. Homebrew was the last thing to do this to me. Partially my fault, but there was no way to walk back from it other than to go into `/usr/local/bin/` and manually repairing symlinks. Not the world I want to live in. 
Fair point. I'm fairly conservative with what I run on servers, so it's rare to need something outside of the normal packages, with the occasional step into 'experimental' - but I can see the cases where it could be handy. And if it works for you, more power to you. 
Many gems, for instance database drivers, have no maintained and compatible pure-Ruby equivalent. Large Rails apps without a single C extension gem are I would think fairly rare. And I think few C exts have a pure-Ruby fallback.
Neat... thanks matey.
Once “bundler” is required, 2.0.1 is loaded, and requiring “bundler/setup” doesn’t change that.
Good point. If you need more "power" you can use "standard" classic ruby or mruby. The restrictions of sruby for now reflect the restrictions of Ethereum / Solidity which is kind of the "world standard" or most popular contract language / runtime today if you keep (store) the code and state "on chain" in contrast to running your contract in a container or something.
&gt; Not sure I understand the value of "Linuxbrew" - I can't see &gt; Homebrew as a replacement for apt-get etc on stable distros The world is larger than your tiny debian prison, my friend. The use cases for this have been explained numerous time - please read up on them Randy Lizard.
And that is a problem how? I compile everything from source here, through ruby. I don't use the FHS approach though, been using a similar approach as GoboLinux does. Most programs (including ffmpeg) are super well-behaving. Using something like debian-packaged ffmpeg would on the other hand lead to numerous problems.
Qt is particularly annoying. I hate the qtwebkit stuff especially much. Qt is such a huge bloated mess - I am surprised KDE can even work on this train wreck.
&gt; It's also quite crappy at dependency management. You can upgrade e.g. readline by itself to a &gt; new major version and then look at all those broken runtime dependencies. A very bogus comment from you. Simply use a versioned AppDir approach such as GoboLinux does; then you don't have "broken" runtime deps because all the deps are always there. You can even build on this and use something like NixOS does (minus their systemd addiction; that really killed it for me). 
&gt; We seem to be living in a world where folks claim know what &gt; you want more than you do: systemd, bundler, I had to upvote you for truth here, despite your earlier comment that you do not understand why homebrew exists when we all could use apt-get instead (which, by the way, makes me wonder - do you use vanilla debian or devuan instead?). &gt; Homebrew was the last thing to do this to me. Partially my fault, but there was no way to walk back &gt; from it other than to go into /usr/local/bin/ and manually repairing symlinks. Not the world I want to &gt; live in. I don't really use homebrew myself; I use a self-written hack that allows me to compile/install whatever I want to, in ruby. However had, your complaint about /usr/local/ seems hugely arbitrary to me. I am sure you can use prefix options in homebrew too, right? So why would it not be possible to use versioned AppDirs? GoboLinux showed how this can be done and I use a similar approach since a very long time. And it works well - including symlinks. There is absolutely nothing wrong with symlinks!
The thing is - there is more than one use case WHY people may find the linux-port useful. Homebrew got more options that way and more users in the long run. Why would that be a bad thing? This is what I don't understand with Randy the lizard - I think it is GREAT that homebrew ALSO supports linux. Next step may be the other BSDs (not sure if it works on OpenBSD yet or not, but I am sure in the long run that'll be possible either way, if it is not yet possible). Why is it bad if homebrew can run on a toaster? The linux kernel does too and this isn't a bad thing.
Precisely!
After parsing JSON you just have regular Ruby hashes or Arrays that you can manipulate. After that just do \`JSON.dump(your\_data)\` and you will get a JSON string that you can again save to the file
&gt; I'm fairly conservative with what I run on servers, This is because you are not using the better versioned AppDir approach. With that approach you'd just keep your symlinks up-to-date. Old software exists and can keep on working as-is. You are constrained in the FHS system, so of course this cripples you. A good example is debian - stupid as they are, you have only one entry at /usr/bin/ruby, so when the versions changed, they had the rubbish idea to create e. g. ruby-1.8 or ruby-2.0 or whatever version they named it. What a huge failure the debian people are these days. Debian used to be great a long time ago.
I am not sure snap packages will gain much traction. &gt; I honesty cannot see myself using homebrew outside of OS X. Many people don't have a mac, so for these people homebrew is now an attractive option. I think this is a net plus (IF everything works; I had some problems getting things to run on linux, unfortunately; but I am sure in the long run everything will be smoothened out).
Don't tell me that but Homebrew. It's even more silly as while the runtime dependencies might be broken, the old versions are often still there. In a versioned directory. But Homebrew just links to newest version with an unversioned path.
So Is it in theory possible to write new pure Ruby ports with only TruffleRuby resp. Graal in mind ? 
&gt; I am sure you can use prefix options in homebrew too, right? Of course not. You can configure where the whole Homebrew directory will go but not how the different applications are installed. As now the preferred way is installing binaries and not building from source, you have even less options to change that.
Personally I have this booked: https://foragoodstrftime.com/ It works perfectly, definitely recommend it
plus, you can install dev dependencies without sudo, which is nice \*and the main thing I use homebrew for anyhow\*.
Ubuntu 18.10 has really a really nice UI around packaging that supports apt and snap. The Slack app, for example, is distributed using snap.
Very useful, I often use this when working in rails [https://railsdatetimeformats.com/](https://railsdatetimeformats.com/)
Hey! I'm the creator of ForAGoodStrftime - we recently did a revamp of it to update the nearly decade-old design. If you ever notice any issues, let me know. 
Thanks for the write up! Couple of suggestions: 1. The example you make might be confusing to newcomers as it makes observers and notifiers of the same class. It might be easier to understand an actor notifying a handler. 2. I’d love to see a realistic use of observable in a web application. Or a situation where it is highly recommended. That said, I’m personally wary of using this pattern because it breaks the explicitness of code. I’d like to read code and know what a method does without worrying it has spooky effects elsewhere in the system that i cannot immediately inspect.
Thanks I definitely will! The only thing that's bugged me about the website so far (that was also in the older version), is that since it takes your current date, if you go to the website the 11th of November for example, it's hard to tell in the 'build your own' if the 11 is for November or 11th.
That's a good point - let me see what I can do.
Yeah, I think this _is_ somehow custom behavior in bundler... or I guess rubygems? Looks like people file issues at https://github.com/rubygems/rubygems/issues too? I would guess it's related to the gone-horribly-wrong feature to "automatically switch between bundler v1 and v2". Been causing all sorts of confusing problems, seems to have been released without sufficient testing. :( https://bundler.io/blog/2019/01/04/an-update-on-the-bundler-2-release.html https://www.reddit.com/r/ruby/comments/ady4ga/bundler_update_to_20_breaks_test_in_travis_for/
Checkout the docs (and use) the Oj gem. Oj is a great high perf library that works well when used to serialize entire object trees for persistence. For general purpose work, lower latencies never hurt. 
I think he was referring to libraries like https://deterministic.js.org/ 
We experimented with snap packages briefly, but weren't too happy with it. We were also interested in the case "when the package manager doesn't have a new enough version," but found that installing a snap package could _destabilize_/break other things that were installed normally with apt-get. I don't know the details, not my area of expertise, and we gave up on it fairly quickly; when the yak-shaving began, we decided it wasn't likely to fulfill our hopes of making things _easier_. 
I've had almost zero problems with homebrew. I would say maybe I've been lucky or in the minority, but homebrew is quite popular, so apparently not, there are quite a few users like me where what homebrew does is just right. We may not want to do the things you want to do where homebrew gives you trouble. I don't want to do _anything_ but get working versions of the things I need, heh. But I guess that describes everyone, just different paths to get there maybe. 
"who observes the observers?"
thanks for making it! ive used it for so long, i dont even remember when i first started using it. 
It's great that you are writing so much about Ruby, but have you considered using some proofreading tools such as Grammarly?
Thanks for highlighting Determinstic.js. I see. Now that makes sense. 
Thanks for using it - I made it a long time ago as an example of a "quick side project" for a talk I was giving at the local Ruby meetup.
I think filing at ruby core is perfectly fine considering the fact that bundler was merged into default ruby as-is. The official bug tracker for ruby is still not at github for several reasons, so zeekar proceeded perfectly correct, IMO.
I am reluctant to use snap packages myself b/c of the unintended consequences. I think the Slack app is the only snap app that I have installed.
Yes, I was thinking in line with deterministic.js - I just couldn't remember the name (h/t @ HardLuck). It's funny you mention mruby, because I'd thought about building a little DSL to handle different classes of smart contracts (like ERC20 for example, or an IoT framework) and then run it behind Tendermint via CGO into the ABCI. It was a bigger project than I wanted to tackle for the moment. Your SRuby project has some of the same goals as I'd been eyeing for purpose built DSLs. &amp;#x200B;
&gt;I had to upvote you for truth here, despite your earlier comment that you do not understand why homebrew exists when we all could use apt-get instead (which, by the way, makes me wonder - do you use vanilla debian or devuan instead?). The recipe I've been using for years is "rbenv/rvm for Ruby, apt-get for everything else", though lately I've been moving towards Docker images. That's for servers. Locally it's been Homebrew / VMs / Docker for the development environment. I'm happy being wrong on this sort of stuff - it's how we learn. So when I say Linuxbrew doesn't make sense to me I appreciate being being told why I'm out of the loop. &gt; There is absolutely nothing wrong with symlinks! I agree. Nothing wrong with symlinks. But if you end up with hundreds all pointing to nothing it can be unpleasant to have to go and fix. An OS upgrade followed by upgrading packages in brew caused something to slip, as `/usr/local/bin` ended up with a stack of symlinks pointing to package versions that weren't there anymore. Wasn't fun.
Thank you. It's a timely, as I'm just about to swap dev environments from OS X to Linux and I've not had to deal with these sorts of cases. Consider me appropriately cautioned. Cheers.
You really don’t see how that can be a problem...? It’s much more convenient to install, upgrade, and uninstall things with Homebrew than it is to download, configure, and compile things from source. I’d think this would be obvious.
Well, I'm conservative on servers because I don't want them to die/get owned just so I can run the latest version of something. Ruby is a special case, where I'll happily run rbenv/rvm/etc. But you're right, and I probably need to be less precious about this sort of stuff. I'm pretty clueless, so I'm always happy to be wrong. &gt; Debian used to be great a long time ago. That makes me sad, as OS X used to be great too - for devs - a long time ago. Homebrew always struck me as a failing of Apple's - to not provide and support a decent package management system/community for the OS in the first place. Don't get me wrong. I appreciate the work that has gone into Homebrew as well as the efforts of all the package maintainers - work that I benefit from at no cost. But in the end, tools like Homebrew / Linuxbrew appear - at least to me - to be "hacks" around the failures of OSes to provide reliable, flexible and up-to-date package management. It brooks the question, is there an OS that gets this right? Maybe it's just the way things are. 
It does work very well, I have used it for years to augment my Linux distro's package system. I forgot to mention I also use it for: ripgrep, fzf, bat, exa, fd among other development tools. Linux Mint is based on Ubuntu LTS, which is often years behind with respect to tooling. Homebrew on Linux is great, especially for folks like myself who also have a Macbook. Same tooling on different OSs is extremely handy. It is awesome that it is now merged back into Homebrew itself.
Cool. Well, it'll be something to think about when I move off OS X. TBH, one of the things that's always driven me mad is the lack of a baked-in package manager on OS X - something Apple could have been proactive in supporting. But then we would have been at the whim of Apple, so having a community-driven system is probably the best model. It doesn't sound like switching to Linux for every day development is necessarily going to be a walk in the park, so I'll take your lead on this one and have a crack at LinuxBrew. Cheers.
Note, not every single package works perfectly. There have been some gremlins with Linuxbrew; for example `brew postgres@10` did not work for a very long time. I tried again recently and it does now work with Linuxbrew. Most stuff works the same in Linuxbrew as it does in Homebrew. A few edge packages don't, from time to time. Over the past few years, it has gotten a lot better. Now that it is officially merged in, it should get better still. Having a community package system independent of Apple is a very good thing. That it is official for both Linux and Windows + WSL is fantastic.
https://ruby-doc.org/stdlib-2.6.1/libdoc/observer/rdoc/Observable.html
I had many things installed as snap on Ubuntu never had many Problems, maybe things are getting better? I just love the integration with Gnome und Software Center...
Whoa wish I knew this earlier. Had to look through the docs every time.
Too bad homebrew is shit. It's devs are a bunch of fascist assholes.
I think I kind of fixed it: 1. Start Mac in recovery mode: restart while holding cmd + R. 2. Open Utilities &gt; Terminal. 3. Disable System Integrity Protection (I know, dangerous) using `csrutil disable` 4. Restart your Mac 5. Run `gem pristine --all` or `gem pristine &lt;gem-name&gt; --version &lt;version&gt;` 6. Reenable Sytem Integrity Protect in recovery mode using `csrutil enable`. Seriously, reenable it! This fixed the problem for almost all gems that gave the warning. The only one remaining is byecrypt for me, for some reason that one doesn't work.
Thanks man
Ruby was influenced much more by Lisp - both mixins and meta-programming in Ruby are modeled after various macro features in Lisp. Using blocks and yield statements between the object and the mixin fn is a much more Ruby'esque way to handle the problem than abusing the Enumerable features. If that doesn't jive with you, then maybe you don't understand blocks ;) I started writing Java in 1997 and I've been writing Ruby since 2004 and have cheerfully refused to ship a RoR endpoint ever since. Before that I wrote C and Lisp, but haven't touched either really in about 10 years. 
Enumberable#lazy is kludge on top of cruft. It's really okay to write declarative code. It won't bite. 
&gt;The standard library is like 99% convenience shortcuts for simple operations that are nicely implemented for you Sadly, I think you're mistaking Rails for Ruby's API. 
I think this broke my ability to use arrow keys in IRB... from what I understand, my ruby/irb may not have readline support any more after upgrading, but when I try to install readline, I'm told I already have it. Anyone else notice anything like this?
Busy being employed? 
ah never knew about this. I will include this too :)
Can confirm. Source : am employed. 
English is not my language. Grammarly works online, but I am working on text editor. Let me give it a try. Hopefully I can select a text and hopefully it will tell suggestions.
oof
While Python and Ruby are both used for web projects and related development utilities, Python has a lot more users in various sciences as well as college students. Ruby has been around for a lot longer than Elixir, so Elixir subs are going to be more recent/more active users. Also, because it's been around for so long, it already had established forums for discussion prior to subreddits for a technology becoming the norm.
Your last point is the biggest reason I think. There are various other groups to discuss Ruby. Just didn't catch on on Reddit
I've had similar recently - had to reinstall Rubies (via `rbenv`) after reinstalling readline. Might be just coincidence.
Suggestions for other active communities? 
ruby-talk [https://www.ruby-lang.org/en/community/mailing-lists/](https://www.ruby-lang.org/en/community/mailing-lists/) 
If it's deployed in a container, is there any hook for a warmup w/ JRuby or Truffleruby or is this pretty much an MRI only solution? 
That totally worked.... Wow, how'd that get broken. &gt;brew reinstall readline &gt;rvm reinstall ruby-2.3.1 Now it works fine.
After years of doing Ruby there's not much to discuss or be surprised by, IMO. It's a stable and sane language. Which is why I still use it every day,