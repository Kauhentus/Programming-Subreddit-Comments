&gt; Commence downvoting. Was that really necessary to say? I don't think so. 
Your brackets are off, you have test[:row['sEmail'] = row['xPerson']] When you should have test[:row['sEmail']] = row['xPerson'] Although that's assuming row is a hash. Though I would do something like this (Hash has a method which converts an array into a hash for you): test = Hash[ FasterCSV.parse( File.read( "dump.text")) ]
 require 'csv' test = {} CSV.foreach("dump.txt", headers: true, col_sep: "\t") do |row| next if test[row['sEmail']] test['sEmail'] = row['xPerson'] end I recommend the prior code since it does a check for an existing email in your hash. If the email exists the program will go to the next row instead of overwriting the email with the most recent user_id.
I've just found that [str#replace](http://www.ruby-doc.org/core-2.1.5/String.html#method-i-replace) doesn't actually replace one character with another *-as any sane language does-* but instead replaces the whole thing with the string you provide as argument... so there goes your usefulness.
I meant it in the context of "everyone can commence downvoting my comment", not the actual post.
Normally you would namespace your code into a module with the name of your gem, so that it doesn't clash with application code or other gem's code. So, `Deck` would become `Holdem::Deck` and so on. You can still use them un-namespaced with `include Holdem`. 
I have the other single line solution working as expected now. I am still trying to get this foreach way to work, but using the exact code you provided, I end up with this. irb(main):001:0&gt; require 'csv' =&gt; true irb(main):002:0&gt; test = {} =&gt; {} irb(main):003:0&gt; CSV.foreach("dump.txt", headers: true, col_sep: "\t") do |row| irb(main):004:1* next if test[row['sEmail']] irb(main):005:1&gt; test['sEmail'] = row['xPerson'] irb(main):006:1&gt; end =&gt; nil irb(main):007:0&gt; test =&gt; {"sEmail"=&gt;"7"} irb(main):008:0&gt; test.inspect =&gt; "{\"sEmail\"=&gt;\"7\"}" irb(main):009:0&gt; test[1] =&gt; nil irb(main):010:0&gt; test[0] =&gt; nil irb(main):011:0&gt; I do see that you replaced test[:row['sEmail']] with test['sEmail'], and it makes sense... but the output is not making sense. :) (btw. i think the 7 is coming from the fact that i have 7 rows in my test file... well 8 rows minus the header row)
&gt; require 'csv' &gt; test = {} &gt; CSV.foreach("dump.txt", headers: true, col_sep: "\t") do |row| &gt; next if test[row['sEmail']] &gt; test['sEmail'] = row['xPerson'] &gt; end Ack! It should read test[row['sEmail']] = row['xPerson'] My bad dude! EDIT: and the reason that you're getting a nil for test[0] is because test is a hash and not an array. If you want the first element from a hash you can do test.first. If you'd like the N'th element, you can do this [test.keys[n], test.values[n]] 
Why not simply HtmlPersonRenderer.new(person).display_address instead of HtmlPersonRenderer.decorate(person).display_address ? That way you avoid potential name conflicts between `person` and the decorator.
What am I looking at? Can only see an anchor wobbling around.
can you refresh? Is your internet connection slow?
The site for me is pretty fast, the anchor is shown maybe for a second. Both on firefox&amp;chrome. And I have half-shitty internet.
Anyway, try refreshing. For how long does the anchor persist for you?
thanks, glad you caught that. what's the best or conventional way to namespace? is it as simple as going into each file and wrapping with: module Holdem end
for how long?
I left it open for a few minutes, before giving up...maybe 3-4min.
I'm guessing it's that the page is over HTTPS, but the javascripts are from HTTP. I get errors such as: &gt; Mixed Content: The page at 'https://octopressthemes.github.io/' was loaded over HTTPS, but requested an insecure stylesheet 'http://fonts.googleapis.com/css?family=Antic|Raleway:300'. This content should also be served over HTTPS. octopressthemes.github.io/:1 &gt; Mixed Content: The page at 'https://octopressthemes.github.io/' was loaded over HTTPS, but requested an insecure script 'http://code.jquery.com/jquery-latest.min.js'. This content should also be served over HTTPS. If I click the shield in chrome's address bar that says "Load Insecure Scripts", the page loads. The trick may be to reference javascripts without http or https, but just //code.jquery.org/blahblah [EDIT: It's probably users that are using the HTTPS-Everywhere addon, since Github has HTTPS available]
So it was javascript failing :) Mandreko, thank you for this one, it's seems i was constantly loading it over HTTP, so it was good for me. It's working now over https also. Thnx again.
&gt; his death was not a surprise to his family How so? &gt; Do you think he didn't plan already for this or that he had no insurance? I would hope so. He probably didn't have much in cash as I would imagine between having TrinityLabs mismanaged into the ground last year probably hurt.
To be fair, I just ran into a similar issue on my blog while trying to optimize things. I knew exactly where to look :)
haha, nevertheless thnx again :)
That's (IMO) the way to do it - giving the object responsibility for how it presents itself breaks SRP. 
His illness was not a secret: https://groups.google.com/d/msg/trinitylabs-talk/f8XOageAwcY/3vJE5pEKApQJ 
I doubt he died from diabetes.
Maybe, maybe not. It's the #7 killer in the U.S. though http://www.cdc.gov/nchs/fastats/diabetes.htm 
Octopress is pretty good, as is Middleman, but the problem I always face with these is, should I want to do something non-standard, like pass my own markdown processing system, I either have to define it as my own tilt interface, or monkey patch gobs of code. Say I want to use Redcarpet, but wrap it in html-pipeline so i can add emoji and maybe code highlighting. In rails, or even sinatra, thats a piece of cake. In these I basically have to read the source code just to do it (I did it recently, for a blog I was working on). Still, I'd imagine they do exactly what 99% of bloggers need, and I'm just too picky. And these themes are great. Anything to get people off wordpress…
1. Never have a God class. The specific reason your code wouldn't run is that instance variables are used for a particular purpose in classes. In fact, you aren't really using the instance variables as instance variables here at all (all of those @s could be removed and your program works the same!) 2. You can have multiple classes in one program, and multiple methods in one program as well! It is best to split them in separate files, and use the methods 'require' or 'require_relative' to load in the code properly. I usually put the script that initializes stuff in my Game file, because that's where all the Game controls stuff are. Most Ruby projects of any size are a collection of files that require each other. If your file is approaching 300 lines, it's probably not organized correctly! 3. You can't really make Tic Tac Toe in any way that will demonstrate your knowledge of Ruby WITHOUT an Object Oriented approach. I would complete the object portion of this tutorial: http://tutorials.jumpstartlab.com/projects/ruby_in_100_minutes.html This will show you a.) class basics, b.) the ACTUAL purpose of instance methods. That might inspire you to get started on Tic Tac Toe.
I wasn't actually doing it with Octopress this time, I was doing it with Middleman, which I like because its a little less opinionated (i do not like liquid templates, i prefer slim). I just eventually wrote a custom Tilt processor and loaded IT as the markdown processor. I tried it with octopress a few years ago and got fed up fast and just wrote my blog in Rails. I suspect you could probably just override the default markdown handling functions and bridge it to your own pipeline
Not sure #empty? is a sensible question to ask nil, any more so than true, false, or 0. You might consider [`blank?`](http://guides.rubyonrails.org/active_support_core_extensions.html#blank-questionmark-and-present-questionmark), which is a common core extension provided by ActiveSupport.
&gt; I recommend the prior code since it does a check for an existing email in your hash. You can just use the ||= assignment operator to accomplish the same thing: test[row['sEmail']] ||= row['xPerson'] Will only assign a value to the specified key if one doesn't already exist. 
Are probably not a good idea. ;)
Cool article. An analogy that may be relevant: One woman can make a baby in nine months, but nine women can't make a baby in one month. But it doesn't take 9 women 81 months to make 9 babies.
Well neither of those variables will be `nil` since they're both the result of `join` in the original source, i.e. they're guaranteed to be `String`. Which, now that you've pointed that out, made me realize the `compact` isn't necessary either. You're correct though that if there were the possibility of nils having compact after the reject would make no sense, I brainfarted.
There is nice book about ruby threads http://www.jstorimer.com/products/working-with-ruby-threads
Rabbits...
I use them all the time, even on MRI. With stuff like Puma you can save a lot on IO (my apps spend most time doing some kind of IO like MQ, DB, HTTP etc).
I don't understand the given code. How are we calling `.each` on `Thread.new do ... end` ? I tried it in pry and sure enough it cannot find method `each` on `Thread`. array = [] Thread.new do 3.times do array &lt;&lt; 'blah' end end.each(&amp;:join) puts array.size
Use a `while` instead of an `if`. You should always think about what the criterion is that will break out of a loop if you are using one.
Fair enough, I was making a joke, that was obviously not taken well. Cheers! :)
Ask me how I know [you're trying to cheat on a homework assignment](http://www.reddit.com/r/ruby/comments/2o9ecq/loop_to_system_crash/), /u/zarzer and /u/stoffer921114. ಠ_ಠ
Ask me how I know [you're trying to cheat on a homework assignment](http://www.reddit.com/r/ruby/comments/2o9l8f/logical_loop_bug_with_array/), /u/stoffer921114 and /u/zarzer. ಠ_ಠ
We're working on an assignment indeed, but it's above what we've learned, so i'm trying to get the help i need to complete it. I have worked very little with ruby :/ Edit: I hope you don't see it as cheating, i'm trying to make the code work as you can see
=&lt; is not a valid Ruby operator.
[http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions](http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions)
&gt; In "is(a) == b" isn't the assertion/claim implied and obvious? No, that's why it's a question. If you want to assert something, then make a claim. Don't ask, and hope that people interpret the question as an assertion. Specifications should be clear, not dependent on interpretation.
I think you may be missing a method to end a call, which in turn should free the corresponding employee.
Care to elaborate for the less knowledgeable? :)
The `RSpec.configure` block is just huge. Stuff like this: config.expect_with :rspec do |expectations| expectations.include_chain_clauses_in_custom_matcher_descriptions = true end What does that even do? Does it matter? Why isn't this choice made for me? Testing should be so much simpler than this. And it is, for folks who choose to use simpler tools. I haven't used rspec since 2.x, but it was pretty good about being "zero config." 
How does a fresher escalate a call? Also, it's not clear from the question whether you're being asked to model a call center or design a working system for a call center. That may be deliberate. It looks like you're assuming the former. You may also want to consider the latter. When interviewing in-person, don't be afraid to ask for clarification regarding the requirements.
One tip I have is that in line 31 (https://gist.github.com/Jberczel/05f54b2a8ce66e32e4f1#file-call_center-rb-L31) it would be more appropriate to call a method on employee that changes the status instead of changing it directly. The same way that you have employee#free? , you could have an employee#take_call
because cpus are really bad at floating point math.
Because 0.1 can't be represented exactly by a computer, but 10 can.
Do you have it to where the fresher can input if he has an issue or not? How do we know if the fresher can handle the query? If the fresher can handle it then he has no one to call. Otherwise he must call. Then your solution comes into place. Hope this helps.
Most people don't have a problem with providing a bit of help or guidance with a homework assignment, but you need to disclose the fact that you are asking for help. You need to tell us up front what the class is, what the nature of the assignment is, and any specific directions given to you as to how to complete the assignment. Just posing a problem given to you by an instructor without any context is dishonest. The question in most people's minds is: Why are you coding this in Ruby, when, judging by several glaringly obvious errors in your code, you've never even done so much as a Ruby tutorial? Is this for a Ruby class, or is it some other class where the choice of Ruby as a programming language is incidental? That sort of thing matters a great deal, and will affect the answers and advice you are given. Don't expect anyone to do the assignment for you, but if you tell people what exactly you're trying to do and why they are much more likely to be able to point you in the right direction.
The answer to your question has to do with the way that [floating-point](http://en.wikipedia.org/wiki/Floating_point) arithmetic works at the very lowest levels. To really understand it, you would have to spend some time studying the mathematical details of IEEE 754 representation, and doing exponent math in binary, but I will gloss over the gory details here and try to explain it from a pragmatic, developer-oriented perspective. Imagine for a moment a simple, unsigned, 64-bit integer stored in your computer's memory. That set of bits has 2^64 possible values, representing the integers 0 through 18,446,744,073,709,551,616. If you want to store an integer larger than that, you need more bits, because 64 bits can represent, at most, 18... quintillion different values. Now, imagine instead a floating-point number stored using the same 64 bits. (The details of *how* those 64 bits represent this number can be found [here](http://en.wikipedia.org/wiki/IEEE_floating_point) if you're really curious, but you don't need to know them right now.) You can store a much bigger range of numbers in that float -- for example, you could store massive numbers like 2.3x10^48, or 1x10^88, or very tiny numbers like 4.7x10^-21, or 6x10^-33. But you still have only 64 bits! And as we know, 64 bits can store, at most, 18...quintillion possible values. There are far more than 18 quintillion different numbers between 1x10^88 and 6x10^-33. So how can we store so many different numbers in the same 64 bits? The trick answer is: we can't. Floating-point cannot actually represent *every* number between 1x10^88 and 6x10^-33. Floating-point makes a trade-off of *accuracy* to obtain its remarkable *range.* You might find, for example, that you could store 2.3x10^48 just fine, but if you tried to store 2.37264982295730984x10^48 instead, the computer might chop off some of those decimal places to make the number "fit" in the 64 bits available. In order to be able to store *some* 48-digit numbers, you sacrifice the ability to store *any arbitrary* 48-digit number. You limit yourself to being able to store only some subset of all possible 48-digit numbers. It's trickier to visualize how this same problem occurs for very small numbers, but the effect is the same: there are simply some numbers that we can write out just fine that *cannot* be stored accurately in floating-point. A good example is 0.01. The closest value that a float can have to 0.01 is actually 0.009999999776482582092285156250. For many purposes, like rendering 3D objects or simulating forces on a CAD structure, this is close enough to be useful. But for many other common purposes, this can be very dangerous. If you're talking about dollars, 0.01 is a penny. Let's say you wrote a program that (for some reason) calculated your paycheck by adding pennies together, and you decided to use floating-point math to do so. By the time you've added up a dollar, you're off by a whole penny. By the time you've added up your paycheck, you're off by several dollars. Bad news, indeed. This is why experienced developers will tell you to **never, ever, ever use floats to store monetary values,** and they are damn right. "But 400921FB54442D18," I hear you cry, "if I can't use floats to store dollars and cents, how can I write a program that handles money?" The solution is to use ruby's handy-dandy [BigDecimal](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html) class. (Don't be misled by the first line on that page which says "BigDecimal provides arbitrary-precision floating point decimal arithmetic," in this case 'floating point' means 'with the decimal point in any position,' *not* 'using IEEE 754 representation in the processor.') The BigDecimal class allows you to do totally-accurate math on decimal numbers of any size. It's not a machine primitive -- it's something that the ruby interpreter handles, rather than passing it on to the hardware -- but it's designed to solve exactly this problem. If you're using Rails, and you create a `:decimal` type column in your database, Rails will automatically assume that the values in that column should be BigDecimals. So this problem will be solved for you pretty transparently. This is a simplified overview of the issue, so if you have any other specific questions, ask away!
Or why not ask your TA? ;-)
thanks for the tip. i didn't go that far with this solution. it took me longer than expected just to model it, so i focussed my efforts to implementing the queue for #getCallHander. one thing i found difficult was trying to whiteboard it. i've been so conditioned to code in text editor. perhaps i need more practice there. 
yea, i didn't' get that far. hopefully it's just inexperience, but that took me awhile to get on paper.
thanks is this example of law of demeter?
thanks for catching. would this be acceptable? def employees_by_rank [freshers.shuffle, tech_lead, product_manager].flatten end
i didn't get that far. employees have default status == :free. set to :busy when they're dispatched to call. thanks for feedback. i'll have to think it over this week.
Oh no problem! Was not sure if you thought about it yet or not. Have fun with it!
[You take that back](http://en.wikipedia.org/wiki/Decimal_computer)!
**How did you find it?**
Generally speaking, if you're working with a value where accuracy is important, you probably want to leave Floats out of the picture entirely. The way that Ruby handles arithmetic operators (they're actually methods on the first operand) can lead to some "gotchas" if you're mixing BigDecimals and Floats in the same code. [Here's a short article](http://makandracards.com/makandra/1178-bigdecimal-arithmetic-in-ruby) on why it may be a better plan to avoid Floats entirely. BigDecimal allows you to pass an argument to the `to_s` method, which lets you override the default scientific notation (see the [api docs](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/bigdecimal/rdoc/BigDecimal.html#method-i-to_s)). Passing 'F' will force it to render as if it were a Float. So instead: money = gets.chomp.to_d change = money / BigDecimal('10') change2 = money * BigDecimal('0.1') puts "Here is your change: $#{change.to_s('F')} or $#{change2.to_s('F')}" Note that if the user enters "23.68923" as the value of `money` then your output will have more decimal places than just the tenths and hundredths. Rails provides a number formatting method that will let you specify the number of decimals, but I don't think there's one in bare Ruby. I could be wrong. I usually work in Rails so I'm not entirely used to bare Ruby.
well yes that's true
Maybe the problem is that AngularJS is too complicated and insinuates itself across core classes in a non-namespaced way
Just learn Elixir. You'll never get immutable types in Ruby, for example, without breaking REAMS of gem code.
The video is down, and I just discovered this thread 4 months later. Any way to see it still?
IMHO it's more worth it to just switch to something like Elixir, because you're still going to have to deal with reams of Ruby gem code that weren't written with functional concepts (or immutable data, etc.) in mind and will thus be subject to the same kinds of problems/bugs
http://elixir-lang.org/
I'll amend my statement with "except for very specific and hard to find CPUs"
Another announcement post by myself. Please comment (and hack) the bejesus out of it.
Believe it or not the level of inaccuracy is specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point), and conformance means you can *not* be *more* (or less) accurate, so that rounding errors are reproducible.
Yeah, it's a start. A more sophisticated method would do more of an round-robin than random selection. A step further would be to track the call rate by employee and choose the free one with the fewest calls in the past hour or something.
You can do this with [Enumerable#each_with_object](http://ruby-doc.org/core-2.1.5/Enumerable.html#method-i-each_with_object). And you can drastically shorten your `map_issue_to_time` function by using the terinary operator. Assigning to `issue` also isn't needed, as the `@client.Issue.find` will already be the value of the `map` method. If you want to become awesome with Enumerable, [try out the lab/exercise](https://github.com/ga-wdi-boston/wdi_10_ruby_enumerable) I made based around learning most of the enumerable methods. 
These numbers.
Hey thanks for that site. I found it actually better than codecademy in some parts. Especially setting up the environment. I'm still trying to wrap my head complete around classes. Especially when to use initialize methods (I understand they are need to boot certain parts but I'm not sure which ones need it and why?) And when @ needs to used and when the attr_acessors are needed? Sorry for all the beginner questions but I feel like I know the basic stuff(array, hashs, var, conditionals, ect) but not how to bring them all together. However, everyone here has been amazing and I deeply appreciate everything you and everyone have suggested and explained so far.
Great link -- thanks! Only thing more I'd love to see are code samples of these tests as well.
you may find this YouTube video helpful: https://www.youtube.com/watch?v=PZRI1IfStY0
muahaha. i've been discovered. edit: you made a throwaway just for this? i am impressed/disappointed.
The Pickaxe book https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0
Port something you wrote in Java to Ruby coupled with a book or two. 
[I have mixed feelings about learning Ruby that way](http://www.yokelpunk.com/2011/12/06/how-a-perl-script-helped-me-learn-ruby/). When you learn a language, you need to learn more than the language; you need to learn the *grammar*. If you learn to write Ruby by porting Java, you'll be writing Java in Ruby.
line 19-21 can be replaced with: employees_by_rank.find { |e| e.free? } 
I'd refactor like this. I recognize that the map.inject.to_s is maybe too condensed for some people so feel free to expand. I changed map_issue_to_time to just issue_to_time because it's cleaner to map a function than to have a function that maps. Follows typical higher-order function style. def total_project_time project_issues = {"ARF" =&gt; ["32237", "32232"], "BABS" =&gt; ["34048", "33765"]} project_issues.map do |project_key, val| { project_key =&gt; seconds_to_hours( val.map {|issue| issue_to_time(issue)} .inject(:+) .to_s )} end.inject(:merge) end def issue_to_time(project_issue_array) time_in_seconds = @client.Issue.find(issue_id).fields['timetracking']['timeSpentSeconds'] || 0 end Edit: Also I use Enumerable#inject instead of reduce because inject is more ruby idiomatic. They are the same method, reduce was just borrowed from other languages. Feel free to use whichever you prefer.
Find an internship!
x = 1 / 3 x * 1000000 that would cause some problems on your decimal computer. Every base has problem numbers.
TDD Conway's Game of Life.
Hey, good choice learning ruby! I personally found [RubyMonk](https://rubymonk.com/) really helpful for learning ruby. After that, like other people said, just keep writing code. Good luck!
That's why I said coupled with a book or two :) Perhaps I should rephrase : Read a book or two while you do a port, being mindful to write idiomatic Ruby. Then again, maybe that's a bad road for a lot of people. Maybe just starting a brand new project from scratch is the best way to go. Everyone learns differently. Of course, studying production code that's already out there is invaluable. Also, regarding books, I loved Eloquent Ruby. I also recommend Design Patterns in Ruby, as wells as the Ruby on Rails tutorial ( https://www.railstutorial.org/ ) . Even if you're not interested in Rails, it's a fun way to get acquainted with Ruby IMHO. Also, do check out http://exercism.io/ where you can submit exercises and get feedback on the code.
The exercise looks very cool I will try it out.
&gt; So if floats are so inaccurate, why would it be the default? I mean, I'm not too concerned about the money aspect (I'm learning from a sysadmin/tools standpoint), but if I'm trying to do some complex notational computations (like 103.4 * 0.10 lol) why would ruby put me in a float when I declare 103.4? x86 CPUs use IEEE 754 as their floating-point standard, which means that adding two `Float`s together in Ruby is, like, way goddamn faster than adding two `BigDecimal`s — because the interpreter can hand off that task to the processor without any abstraction. Defaulting to a heavier number type would slow down most Ruby programs for no good reason, like if the default car were a Greyhound bus instead of a sedan. (Sure, it can transport way more people, but you'd never need to do that, plus now your mileage is awful.) It is a level of precision that is simply not important for the vast majority of use cases. &gt; Better question, is there a better format I should be declaring variables with decimals in them? Or is that where BigDecimal comes in... No, `Float`s are what you want unless you're doing something that requires absolute precision. Currency is the most famous example.
What an interesting definition of properly.
I haven't met many people who agree with me on this, but I think the classic [Ruby User's Guide](http://www.rubyist.net/~slagell/ruby/index.html) is a good introduction to the language for someone who knows programming in general. It's really short, so you can just read it in one sitting and go on to read a lot of Ruby code. [Programming Ruby](http://ruby-doc.com/docs/ProgrammingRuby/) is how I learned, many moons ago.
It's Tell, don't Ask.
Pragmatic Studio's Ruby course is awesome! Well worth the cost. http://pragmaticstudio.com/ruby
“Vanilla” Ruby? As opposed to what?
Rails, which gets conflated with ruby an awful lot.
Yes, I figured that was the answer. But that's sort of my point—Ruby without Rails isn't “vanilla”. Rails is a Ruby framework, nothing more, and it irritates me to see people refer to it as if Ruby were just some DSL for Rails applications. Ruby is an extremely powerful and flexible general-purpose programming language. Let's not let it be defined by one specific use.
I'd probably also refactor. But we are lacking a bit of context here: use of @client in map_issue_to_time indicates that this is part of a larger class. It would be helpful to know more about the "surroundings". Also, a method starting with a capital letter ("Issue") looks odd.
I don't know about Ruby Koans. I find that "poetic" tone and style extremely annoying. I have absolutely no problems with programming logic and booleans, but some of the very first koans, I just can't understand and solve, because the wording is so cryptic IMO. 
Posting an article to a ruby subreddit with 'make' (and shellscripts!) as one of the essential parts instead of 'rake' ... ballsy :p (yea yea, I know, portability etc.) (Makefile syntax can go die in a fire!)
Indeed, a typo. Thanks for spotting!
That setup comes with executing `rspec --init`. It can probably be removed.
I am using this example of 0.1 + 0.2 == 0.3 =&gt; false to blow peoples minds who are working in IT but had no IT education :D I know its simple... but people sometimes miss simple things.
neither the ternary operator nor the assignment are needed. irb(main):001:0&gt; nil.to_i =&gt; 0 
Maybe it's an ActiveRecord model? Not sure why a class property would have one though.
Specifically this is so that these operations are portable. You can absolutely have different operations and functions that are exactly precise.
Sorry -- yes that's it!
Sorry, I get what you're trying to say. It's just that when I looked up Ruby tutorials, most of them had to do with Rails, and I wanted to learn Ruby first before learning the Rails framework. 
I'm definitely interested in Rails! It's just that I want to learn Ruby first before I learn the framework. Thanks for all the links!
Find something stupid that you want to make! I teach a lot of non-programmers how to program and the best way to keep motivated is to completely enjoy what you are doing. I recommend writing a Twitterbot, as it's silly and teaches you how to deal with delayed job, APIs, ruby modules and classes etc. 
Look into how nokogiri bundles libxml2 and how it optionally can compile it.
are the .o files cross platform? I'm not as familiar with C as with ruby
no, they aren't. you supply the whole thing in your gem and the c files will be compiled as part of `gem install`.
where does it actually do the compiling? 
&gt; So if floats are so inaccurate, why would it be the default? /u/savetheclocktower totally beat me to this one. He's exactly correct: floats are WAY faster to do math with, and usually good enough for most tasks as long as absolute precision isn't a requirement. &gt; is there a better format I should be declaring variables with decimals in them? Or is that where BigDecimal comes in... Exactly.
Use `git subtree` instead of submodule. Would be even better if the library itself can be installed with a package manager and you just have the bindings in the gem.
By the way, why @client.Issue and not @client.issue ? It is awkward to see capital letter in a name ofr method in ruby.
I'll look in to subtree, thanks eventually it may be possible to use a package manager, but I had to change something in kdiff3 to make it able to be command-line only (normally, it brings up a GUI in the event of a merge conflict, and I wanted it to exit with an error) 
He starts with this claim: &gt; As I mentioned in a previous post, Sinatra is often the superior choice when building a simple application to grab some info from an API. And digging into the other post this quote turns up including a code snippet which uses `RestClient`: &gt; When it comes to tapping into the power of an API, Sinatra has the upper hand. Because it’s simple, Sinatra has the flexibility to focus on the main task of pulling the information needed. I don't get this argument _at all_. You could and would write the exact same code in Rails. How can _consuming_ an API be made into an argument for either side?
I believe right next to where the source files are and then the gem can load those compiled files in the ext directory. Check out therubyracer gem, it has a good layout as well.
Thanks for the article. I would say that consuming an api doesn't require a web framework. A ruby gem using HTTParty could be a good consumer example. On the other hand, *providing* an API microservice is exactly what Sinatra is great for. It would run faster than rails and involve less overhead. 
I am using the jira-ruby gem which is a wrapper for jiras rest api. It is not a database call but a rest call to jira. Not too worried about time to complete since this is going to be a cron just that runs once a day.
I agree - this was kind of a riff on a talk I gave a little while ago so I went with it. Glad you enjoyed the article!
&gt; In this article, you’ll learn some interesting Ruby validation techniques. LOL … you meaning Rails validation techniques I hope you know the difference 
[Direct link](https://engineering.heroku.com/blogs/2014-12-05-timeout-quickly)
Since you're just running the `kdiff3` command, I would just make `kdiff3` an external dependency and let the user decide how they wish to install `kdiff3` (and from where). External dependencies can be specified via `gemspec.requirements`: gemspec.requirements = ["kdiff3 &gt;= 1.2.3"] When your code runs `kdiff3`, check for error codes and raise an exception saying "Could not find kdiff3, please install the package". See [rprogram](https://github.com/postmodern/rprogram#readme) which provides a Ruby interface to command-line programs. Also, **do not** commit native executables to your repo. They simply will not work on other architectures/OSes. Finally, please don't lazy compile at runtime, this tends to annoy users.
Not really about Sinatra, but about API consuming overall. I've been using it as consumer for a while in two cases: First case: To display each our page we need to get some info from our API provider. The problem is that once in two-three months API provider goes down. Or its response times peak up to 50 seconds (which led to 500 and 504 errors respectively). Adding cache aided problem, but for some users (who come after the cache expiration) it led to poor experience. One time we've even had their 500 page in our cache. Second case: We've had a widget, which displays teasers about main site info. The widget requests main site API if fresh response is not in cache. Then it gets several items from the response and passes it down to the front-end. This time we didn't cache 500 responses. But once cache expiration 'not in time' led to all requests flowing nicely to main site, which returned 500, which resulted in cache being empty, which triggered requests again and again. :) This led to main project server crash. Just a small cache issue in external service led to main service being down. So, as for me, the main problem in communicating with external APIs - that they fail or may have long response times. You can even DoS your API provider. Doing API consuming to make it work is easy, but consuming them in a right way may be hard. Furthermore, cache doesn't actually solve any of those problems in full - if something goes wrong, you need a fall back, which it doesn't provide. If we take a weather site example - it's not a problem if weather data is outdated for several hours. But that's a problem if it goes down. So, we had to make a custom gem to solve those cases. 
Just remember that floating point arithmetic *[is not associative](http://www.cs.uiuc.edu/class/fa07/cs498mjg/notes/floating-point.pdf)*
Whereas BigDecimal is designed for things like financial calculations
Did OP ask about BigDecimal? Are you on topic?
"BigDecimal" appears on this page 23, now 24, times but you have a good day now.
They're actually really, really good at "floating point math" but the floating point math a CPU does is a highly technical, specific thing and if you don't intimately understand what the rules are and how it works you can fall into traps by using it inappropriately.
Precisely imprecise is the way I look at it. It's one of the more amazing quiet inventions of our age. When it works it *really* works and you can work out when it doesn't. A lot of the world continues to spin because people understand exactly where it works and where it doesn't.
Check out The Well Grounded Rubyist. http://www.manning.com/black2/
Michael Hartl's [*Rails Tutorial*](https://www.railstutorial.org/book/beginning) sounds right up your alley.
I do too, but there's soooo much Ruby gem functionality that has to be rebuilt in it :/ (simple example- [Paperclip](https://github.com/thoughtbot/paperclip), which takes ALL of the pain out of the relatively painful/tedious task of managing multipart file uploads and related forms/form refreshing)
This is my first ruby program, but I'm a fairly adept python and R programmer. Also, have thick skin. In other words, do rip me a new one, as it were.
Rails is written in Ruby, but it's not Ruby. I use Ruby for gluing systems together. For example we have a daily job that schedules REST reports remotely, them polls the system until the reports are done, and then loads the data into an Oracle database and further processes the data using PL/SQL calls from OCI8.
Tried to watch [Aaron's Opening Keynote](http://confreaks.com/videos/4785-KeepRubyWeird14-opening-keynote) - YouTube says "This video is private" :(
&gt; Not sure #empty? is a sensible question to ask nil Right, but **why**? Considering that `nil` already responds to all of these (by virtue of being an `Object`, etc): sushi:~ vais$ ruby -rpp -e 'pp nil.methods' [:to_i, :to_f, :to_s, :to_a, :to_h, :inspect, :&amp;, :|, :^, :nil?, :to_r, :rationalize, :to_c, :pretty_print_cycle, :pretty_print, :pretty_print_instance_variables, :pretty_print_inspect, :===, :=~, :!~, :eql?, :hash, :&lt;=&gt;, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :pretty_inspect, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] 
My point exactly - if `nil` responded to `empty?` you would not have "brainfarted" :) It's not your fault - it's Ruby's not following its own **principle of least surprise** that failed you in this case.
Not exactly "ripping you a new one", just some suggestions :) Here is your original code for ease of comparison: require 'prime' primes = Array.new counter = ARGV[0].to_i counter = 30 if counter == 0 (2..counter).to_a.each { |x| if Prime.prime? x then primes &lt;&lt; x end } x = primes y = primes print ' ' x.each {|i| print "%-3d " % i} print "\n " x.each {|i| print '---- '} print "\n" y.each do |j| print "%-3d| " % j x.each {|i| print "%-3d " % (i*j)} print "\n" end Here is my version (basically cleaning up what you have and making it more idiomatic Ruby) require 'prime' counter = ARGV[0].to_i counter = 30 if counter.zero? primes = (2..counter).select {|x| Prime.prime?(x)} print ' ' primes.each {|i| print '%-3d ' % i} puts print ' ' primes.each {|i| print '---- '} puts primes.each do |j| print '%-3d| ' % j primes.each {|i| print '%-3d ' % (i * j)} puts end What I did was: 1. `a = []` instead of `a = Array.new` (but we don't need it anyway - see item (4) below) 2. `counter.zero?` instead of `counter == 0` 3. Drop the `then` in `if Prime.prime? x then` 4. Actually drop the whole block that initializes your `primes` array and use `select` instead. 5. `puts` is like `print`, but adds a new line automatically. I find `print "\n "` ugly, but that's just a personal preference. 6. Drop extra variables `x` and `y` - they are not needed. In general, try to use as few local variables as you absolutely need and name them semantically. This will make your code easier to read and understand.
What you're looking for is "Learn Ruby the Hard Way" by Zed Shaw. http://learnrubythehardway.org/book/
I was in your position and I found the best way to keep learning was to try and write code, even if it's crap. I would read books about Ruby patterns, best practices, etc. and I'd go back and tweak my code when I found a better way or "more Ruby" way of accomplishing something. 
I don't see any problems with the way you are approaching this. Having multiple `rescue` clauses that take different actions based on what went wrong is completely acceptable. The only thing I would change about your code is that crazy method signature: `repo_check(url,key,template,admin_group,reponame,user,pass,team,uat,test)` That is *way* too many arguments! Use keyword arguments or pass an options hash, so that you can refer to the arguments by *name* instead of relying on their correct *position* when calling your method. This problem is known as *connascence of position*. (Read http://en.wikipedia.org/wiki/Connascence_(computer_programming) about what connascence means in context of computer programming and the various types of connascence, all of which will inevitably bite you in the proverbial butt. Back to the exception control flow best practices (or lack thereof), perhaps whoever told you that this is "against best practice" could also demonstrate what they consider "best practice" in this case. You could then post it here as an example, and we will be able to have a meaningful discussion around that.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Connascence (computer programming)**](https://en.wikipedia.org/wiki/Connascence%20(computer%20programming\)): [](#sfw) --- &gt; &gt;In [software engineering](https://en.wikipedia.org/wiki/Software_engineering), two [components](https://en.wikipedia.org/wiki/Software_components) are connascent if a change in one would require the other to be modified in order to maintain the overall correctness of the system. &gt;__Connascence__ is a [software quality metric](https://en.wikipedia.org/wiki/Software_metric) invented by Meilir Page-Jones to allow reasoning about the complexity caused by dependency relationships in [object oriented design](https://en.wikipedia.org/wiki/Object_oriented_design) much like [coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming\)) did for [structured design](https://en.wikipedia.org/wiki/Structured_design). In addition to allowing categorization of dependency relationships connascence also provides a system for comparing different types of dependency. Such comparisons between potential designs can often hint at ways to improve the quality of the software. &gt; --- ^Interesting: [^Coupling ^\(computer ^programming)](https://en.wikipedia.org/wiki/Coupling_\(computer_programming\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmmqr6q) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmmqr6q)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I'd recommend Pragmatic studios. Its expensive, but wonderfully clear, step by step with syntax, theory and practical use. They dont code along, rather they develop an application to demonstrate and you build something similar with the exercises. Im going though it now, after both codeacedmy and code schools ruby courses, and its exactly what was missing in the "*now you now what ? and ! do on a method. Now lets move on to something else*" that both of those seemed to do. http://pragmaticstudio.com/ruby I'm also enjoying [Everyday Scripting with Ruby: For Teams, Testers, and You.](http://www.amazon.com/Everyday-Scripting-Ruby-Teams-Testers/dp/0977616614/)Its a more "on the ground" look at Ruby, making it go and do things right away. Lots of used copies for $4. Its worth that just to thumb though it alone. Im only past the first few exercises, but its already an excellent companion to the pragmatic course above. 
Fixed! Sorry about that.
Nice, thanks!
I actually asked for an example and he was not able to provide one so I suppose I will keep it for now and do something about the massive amount of arguments. Thank you!
Similarly, this gem bundles C. It is however, quite small and might be easier to review. https://github.com/pbhogan/scrypt
Yeah, if you ever type “raise” you should just assume that your code is going to stop dead at that point. If the caller wants to trap the exception and continue that's its business. But if you're using exceptions as a fancy goto or case statement you're doing it wrong.
If you are interested in a deeper exploration of Ruby exception handling, there is [the book](http://exceptionalruby.com/) (which is not free, but [here is a free video](http://youtu.be/qEHn46YtRM8) to get you started).
I've just started learning Ruby after coding for a year with Python. So far I love it. Using Python, you can make android apps using something like Kivy. I'm excited to discover Ruboto. Has anyone had experience with both Kivy and Ruboto? If so, which is easier to work with? Which one seems more polished? 
Correct, that is the context in which using exceptions for control flow is frowned upon. I.e. raising exceptions as a means of control flow. Handling exceptions as the OP does it, on the other hand, is common practice.
Nice post, but this rubs me the wrong way: output &lt;&lt; "&lt;tr&gt;&lt;td&gt;#{title_tag}&lt;/td&gt;&lt;td&gt;#{info_item}&lt;/td&gt;&lt;/tr&gt;" ... erb :index, :locals =&gt; {results: output} I guess this article is all about how fast-and-loose things can be, but building HTML as a string in your Sinatra route, then passing it to the template looks to me like bad advice. You know people will copy-and-paste this stuff forever, right? Think of the children!
Looks like the code has been changed, and now it has `threads.map(&amp;:join)`, which should probably be `threads.each(&amp;:join)`. If not for the GIL, we'd all be doomed with this kind of attention to detail :)
Why would you use rest-client for fetching data from the API? It makes no sense if you are not using any of the added value from gem. You might as well replace rest-client with open-uri and just use jhash = JSON.parse(open(url).read) No need for rest-client "behemoth" if you are not going to use it.
Hmm I don't get it. Either you assume that models only get modified by controllers or you have to do maintain all validations twice. What is the benefit? You call the argument performance. In the Ruby world you usually have to provide some benchmarks in that case :) PS: You might want to activate spell checking in your browser, I spotted a lot of typos just by quickly reading it.
&gt; I don't see any problems with the way you are approaching this. Having multiple rescue clauses that take different actions based on what went wrong is completely acceptable. You're spot on re the method signature but sorry, the above is **VERY bad advice**. Tying application logic to exceptions will make the code difficult to debug and re-factor. What is wrong with the code is that it doesn't abstract away the mechanisms that cause the exceptions, nor does it provide the building blocks to provide for the business logic to be implemented without those exceptions e.g. # Is a user authorized for a given repository? def authorized?(user, repo) # return a list of repositories belonging to a given user def repositories(user) #prompt a user for credentials def authorize(user) Hence you end up with something like : return authorize(user) unless authorized?(user, repo) create_repo unless repositories(user).has_key?(repo.name) etc. The draw back is that you might end up making multiple rest calls, but the advantages in terms of code legibility and maintainability (*especially*) are well worth it. Please note that I am not saying there is anything wrong with exceptions - I'd have created a an abstraction around RestClient that would primarily centralize where I would deal with these though e.g. [here's one I prepared earlier.](https://github.com/os6sense/sunra_utils/blob/master/lib/sunra_utils/rest_client.rb) P.S. As you can see from the first comment in there, I'm speaking from experience ;)
I see your point, but you are shifting the discussion (perhaps duly so in light of the OP's actual business problem) away from a lower-level concept of "best practices for exception handling/control flow" to a much higher level concept of "best practices for working with REST APIs", which is a whole different animal. Since the original question was about exception handling/control flow, I do not believe mine was a "VERY bad advice". As for best practices for interfacing with a REST API - I did not offer any :)
I also found that to be a bit dirty. What's even worse is I believe that code, once combined with the template given will produce bad HTML. The `tr` and `td` here are unnecessary in the template: &lt;table&gt; &lt;th&gt;The Weather in Buffalo, NY, USA&lt;/th&gt; &lt;tr&gt; &lt;td&gt;&lt;%= results %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ...
Yep. So, to summarize, the result is: 1. broken HTML (as you correctly pointed out) 2. XSS (up to the API provider) 3. ugly Ruby in the handler (building HTML as a string) 4. erb template that feels left out of the party cause the handler is doing the template's job (poorly per points 1 and 2).
&gt; easier to use sqs instead of setting up your own server &gt; You don't have to invest the time and money in something until you're sure it's a worthwhile endeavour couldn't agree more with that! ^^^ &gt; If you are sending &gt; 1 billion messages/month 1 billion requests will cost around $500 and if you have this volume of jobs, probably this cost will not be that expensive. &gt; can be handled by a ~50$/month server hm which queue service would you install on this server? How would you make Redis (or other storage) distributed, auto scalable? For 1 billion jobs it's also probably a concern. If you use Sidekiq and doesn't buy the pro version, you will lose messages if your server crashes. If you are using Heroku, you can choose the same region of your SQS for your apps on Heroku to avoid high latency.
&gt; You don't have to invest the time and money in something until you're sure it's a worthwhile endeavor. I had to decide on a queue systems multiple times recently, where the use case for the queue system was different each time. Of all the alternatives SQS was often one of the first to go because of price reasons (when we were hosting on AWS) or latency reasons (when hosting on GCE). I generally try to "do it right the first time" (don't we all?) and would rather use the "more advanced" system from the start than already plan a switch "in case everything works out as expected" (which should always be what you are aiming for). I would explain my reasoning with the following scenarios (the word "waste" is used very freely): Scenario A - it's not a worthwhile and you use SQS from the start: - You wasted some of the developers time Scenario B - it's not a worthwhile and you use a alternative from the start: - You waste some of the developers time - You waste some of the sysadmins time Scenario C - it's worthwhile, started with SQS and have to switch to a alternative: - You waste some of the developers time - You waste some of the sysadmins time - You waste even more of the developers time through modifying it for your new system (where some of the SQS assumptions might not hold true anymore) Scenario D - it's worthwhile and you use a alternative from the start: - You wasted some of the developers time - You wasted some of the sysadmins time As you can see you potentially waste some of the sysadmins time if it doesn't work out but save some of the developers time if it works out. Now it boils down to a decision of who has more time to spare. Setting up a basic version of the alternative that is suitable for development is often as simple as including a single Chef cookbook, so it sysadmin-time to dev-time is not even 1:1 but more like 0.2:1. Of course, if you know from the start that you don't have a special need for high throughput/volume and low latency and that this won't change in the foreseeable future SQS is fine, but if you do (or you might soon have a special need) I think it's better to use a alternative from the beginning.
lol the thumbnail, stupid ads
&gt; hm which queue service would you install on this server? How would you make Redis (or other storage) distributed, auto scalable? For 1 billion jobs it's also probably a concern. If you use Sidekiq and doesn't buy the pro version, you will lose messages if your server crashes. I have the feeling you are getting multiple things (background processing/queue service) mixed up here. 1 billion messages/month are only ~400 messages/second which is easily handled by a single instance of RabbitMQ or Apache Kafka (Kafka is easily scalable if you really need it). Storage is whole different pair of shoes depending on what messages you send. Most messages I deal with don't represent data that will be saved in the end (if you change 1MB a thousand times you still only have to store 1MB), so storage is only a concern for the message broker until the messages are delivered. Of course if you are handling a lot of messages storage of resulting data is a concern, but there are a lot of good options for that (e.g. Cassandra).
My votes are for the Rails Tutorial and Learn Ruby the Hard Way. I'd start with LRTHW because it gives you a nice fundamental understanding of Ruby (which the Rails Tutorial kinda rushes through). Also, it'll teach you some Sinatra which I think is great for beginners to learn before jumping into Rails.
&gt; away from a lower-level concept of "best practices for exception handling/control flow" Its just coincidence that I had an example which was quite so applicable. My real point was to **abstract**. As a general rule, low level abstractions should handle exceptions and provide a mechanism for higher level abstractions to understand the failure and address it ... unless there is no way to deal with them and then its a question of should some even higher level abstraction handle the exception, or are we actually dealing with a case where failure means fail?! IMO its infrequent where exceptions as a language mechanism need to or should be handled in the business logic - an exceptions is seldom part of that domain and as the general wisdom goes, it should not be used for control flow.
I just use return if Rails.env == production
I think agile web development with rails 4 is a good low level book on how to use rails with ruby to make websites. 
&gt; "do it right the first time" I agree with that, but the right thing will change if the app continues in use. The right thing for now can be SQS (less sysadmin hours), tomorrow X (specific requisites). I'm not saying that SQS is the best solution for all cases, but for common cases, I do recommend it. The migration from SQS to whatever (vice-versa) should be easy, as you shouldn't tight your worker's implementation to the queue service. And I believe it's cheaper to re-write some code than troubleshooting issues (i.e. losing messages, difficulties to scale) on your self-hosted queue service, for example in a Black Friday. 
What if you need to run them though?
"It already has a bunch of methods" (of which NilClass only adds a dozen or so) isn't a particularly compelling argument towards adding more. NilClass isn't a container type, so why would it be empty? Maybe we should throw in `#[]` and `#each` and `Enumerable` while we're at it. Perhaps you'd like the ObjC route: class NilClass def method_missing(*a) end end
Google around for desktop recording software.
Great search terms. "desktop recorder gem" returned [this](https://github.com/ivanacostarubio/rm-recorder) in the top five results.
I've tried both. With Kivy I was up and running quickly - the documentation is good and the community are friendly and helpful. It has its own Pythonesque template language for layouts that's expressive and easy to use. It's optional so you can use 100 per cent Python if you wish but you probably wouldn't want to. The only downside is the UI - it has its own OpenGL layer so you don't get the native UI of the device. The widgets Kivy comes with out the box are Android inspired and might be acceptable on an Android device but wouldn't look right on iOS. You can create your own widgets as some people have but it's not something I want to do which is why I didn't continue with Kivy. The UI issue is why Kivy seems to be used for games and not much else. I tried several times to get Ruboto working but eventually gave up. I'm a seasoned programmer who has had to hack his way through all sorts of things over the years so I expected to get a simple Hello World program running without any problems. I just could not get the program to run on the Android simulator (it built and installed okay) - the simulator kept downloading Ruboto and then the kit wouldn't install. I have run the Android simulator with other things so I don't think that's the issue. But if you go to the Ruboto site the documentation is as bare as a Soviet department store. I did post a couple of questions in the user group but the response wasn't great so I gave up. Let me know if you have more success!
After reading your reply, I looked into the Yo Bitch app and unfortunately most of the reviews are complaints that it doesn't work. Too bad. 
&gt; If you are sending &gt; 1 billion messages/month you are spending &gt; 1000$/month Billing is not based on the # of messages, its based on requests. Sending 1B messages &lt; 6.4KB each will cost about $50 a month, assuming this is a single read queue then you'll get charged another $50 for the read requests, total $100. &gt; for something that can be handled by a ~50$/month server We'd like to not die if a single instance goes down, so realistically you'd probably want at least 3 nodes in different availability zones so now we're up to $150 a month. We also want SQS's durability guarantee, so add up your message size, decide what what 'buffer duration' your comfortable with and add in the cost of the storage. SQS is actually cheaper in your example...
A code golf answer Hash[project_issues.map { |k, v| [k, v.map { |i| (@client.Issue.find(i).fields['timetracking']['timeSpentSeconds'] || 0) / 3600.0 }.inject(:+).round(1).to_s] }]
Freeky, I was not trying to make an argument for adding `empty?` to `NilClass` by showing that it's already got "a bunch of methods". What I was trying to do is elicit an intelligent, non-dogmatic explanation for why it does not make sense for `nil` to respond to `empty?`. (Along the lines of some Smalltalk or LISP legacy or some such). Your mention of the fact that it "isn't a container type" is getting warmer. Is there a written or unwritten rule that containers should implement this method? If so, do you have any references? Also, is `String` considered a container type then?
I'm just expressing an opinion, I'm not laying down dogma. Nils are dimensionless, contain no other objects, so have no business being `empty?` or otherwise. Strings contain characters, have a size, etc, so it's a meaningful question. I don't really feel like nil should just eat otherwise meaningless messages silently, it smells a bit too much like `On Error Resume Next` and suspect it will make code not written to cope properly with nil more difficult to notice. Even just doing `empty?` seems a bit arbitrary, given all the other methods you might argue for having similar treatment. That said, ObjC seems to manage. I'd be happy to be wrong.
Good question man. I'd also like to know 
Definitely "Metaprogramming Ruby 2". This book will take your Ruby to the next level, and you'll gain a great understanding of the Ruby object model and how things really hang together. With that said, this book is the opposite of dry... you follow some annoying people around their office during a hypothetical work week where your coworker teaches you all about Ruby. It doesn't get in the way, but it's a little cheesy. Regardless, this book is amazing. https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2 edit: By the way, this recommendation is based on your asking for the finer points of the language, so I assume you already know a little Ruby. Otherwise, I don't think this would be a good "first" Ruby book.
+1 for Eloquent Ruby. I read it cover-to-cover and it was amazing.
You are not wrong, Freeky :) There appears to be an old debate on this very same subject, with Smalltalk and Objective-C representing the opposite ends of the spectrum. Smalltalk's nil rejects any message sent to it. Objective-C's nil accepts every message sent to it. Looks like Ruby, ever the pragmatist, is somewhere in the middle, as usual. Here is a teaser taken from http://wiki.squeak.org/squeak/5962: &gt; As you might guess, this change created two diverging camps among the programmers. On one side sat the programmers that preferred the original "exception throwing" behavior, and on the other side sat the programmers who preferred the new "message eating" behavior. And they each gave their best arguments to try and illustrate why the philosophy of their side was superior to the other. It was a lively and interesting debate that had no victors, other than the de-facto victor voiced by the compiler implementers themselves; namely NeXT Computers, StepStone Corp, and later the FSF, all of which chose the "message eating" behavior. But, the opinions voiced in the "pro" and "con" arguments were interesting, and especially interesting in what they both actually agreed upon! &gt; Both sides agreed that the "message eating" behavior tended to create more elegant code! &gt; But of course, the "exception throwing" side responded by saying, "seemingly more elegant code, yes, but potentially troublesome and unreliable", and they gave their reasons for asserting this. We will look at some of those arguments, but first I will demonstrate how the "message eating" behavior can tend to make the code more elegant looking.
[poodr](http://www.poodr.com/)
Sure, we can both cherry pick requirements that make SQS or an alternative look good, in the end it's always up to the project requirements. &gt; you'll get charged another $50 for the read requests, total $100 If what the blogpost here says is correct, you'll get charged another $50 for deleting the messages, total $150. So for ~1 Billion messages they are in the same price range. 
Matz and Flannigan's *Ruby Programming Language*. Slightly dated at this point, but really good for diving into the details of the language.
Seconded; it was only after reading this that I started writing truly idiomatic Ruby.
Yeap. But all these requests can be in batches up to 10 messages - so you can `send`, `receive` and `delete` up to 30 messages with only 3 requests.
Definitely second that. You can't beat Matz - he designed ruby, and David's a pretty thorough author too.
Can second this – Great book.
The pragmatic course looks interesting. Thanks.
Eloquent ruby and metaprogramming ruby are the two we use at work to help experienced engineers learn ruby. 
&gt; Sure, we can both cherry pick requirements that make SQS or an alternative look good, in the end it's always up to the project requirements. I don't think it's at all cherry picking to compare apples to apples, comparing a durable distributed queue to a single Redis node doesn't make a lot of sense.
&gt; comparing a durable distributed queue to a single Redis node doesn't make a lot of sense Of course it doesn't, because Redis isn't designed to be a message queue (even though it can be used as one). Durability is just another feature, just like 64KB payload is just another restriction that might be relevant or not for a particular project.
_why's poignant guide to ruby. It may go over concepts you already know, but it will NEVER bore you. http://mislav.uniqpath.com/poignant-guide/book/ 
I think your missing a fundamental point, a distributed queue has very different semantics and use cases than single node queues, be it redis or anything else. Most important for the rest of your system is that distributed queues almost universally have 'at least once' semantics, something that single node systems do not have. 
Repeating a lot of what's been said, but I've read and recommend these (progressing from relatively basic to more advanced): * [Programming Ruby 1.9 &amp; 2.0](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0) (the "pickaxe" book): great introduction to the language, covers the basics of pretty much everything. * [Eloquent Ruby](http://eloquentruby.com/): covers writing solid, idiomatic Ruby. * [Practical Object-Oriented Design in Ruby](http://www.poodr.com/): unbelievably good book on idiomatic OO design in Ruby (much more than design patterns). * [Metaprogramming Ruby 2](https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2): pretty much what it sounds like. * [Ruby Under a Microscope](http://patshaughnessy.net/ruby-under-a-microscope): great guide to Ruby internals.
I was going to say that ActiveSupport adds `#empty?` to nil, but I guess I was thinking of `#blank?`. But nothing stops you from adding it yourself, perhaps in a `monkey_patches.rb` file!
Looking forward to this, great speaker lineup!
It's a must read for any developer who wants to work for me.
All the good suggestions are here, funnily enough though going back to your post Ruby doesn't even have a native for construct.
Actually, Ruby does have a "for" construct: for value in [10, 20, 30] puts value end Also works for Hash objects: for key, value in {:a =&gt; 10, :b =&gt; 20} puts "#{key} = #{value}" end
Yeah no native for construct, they are sugar for the each methods. [10, 20,30].each {|value| puts value} {:a =&gt; 10, :b =&gt; 20}.each {|key, value| puts "#{key} = #{value}"} 
Reminds me of [coercible](https://github.com/solnic/coercible#readme), but with a nicer API. I do like how Necromancer can accept raw Strings.
It's kind of trying to help you resurrect data:) I've named it following a long tradition of very descriptive names in Ruby community such as 'Capybara', 'Cucumber' or 'Sinatra' to name a few.
That's pretty cool. I hated it for about 30 seconds -- feels like PHP sorcery -- then I came up with like 12 things I need this for right now. So now I love it and will try it out. 
What's a use for this?
Fixed, sorry about that.
Bad habits, not really. If anything, it would benefit you to know Ruby 1.8, because a lot of systems out there are still running it, and you'll at least know what might be different if you have to target one of them. There aren't that many differences in the core language between versions, though. Most things are pretty simple, so if you write code for 1.8, there's a good chance it'll run on later versions with just a few quick adjustments.
Perhaps the **Books** section in this reddit's sidebar should be updated.
The breaking changes between 1.8 and current Ruby are so minor that you may well never encounter them in your code at all. There are a few new features, including a more concise Hash literal syntax for symbol-keyed hashes, but it's entirely optional, and you'll still encounter plenty of "old style" hash literals around.
I still don't understand why do I need an "Application Server" for my simple rails app. If I want cron I will use clockwork. Messaging is not particularly useful to me when I need a long running task or some sort of durability sidekiq has been great so far. The whole thing smells anti "unixy" to me. Anyone that used torquebox in production care to illuminate?
I have used Torquebox in production (About 2 years ago), its main advantage is the "Batteries Included aspect.". Bear in mind that I hadn't touched Java for about 10 years (since university) when I set this up. 1. It is fast, damn fast. 2. It clusters very nicely. I used Clustered caching and Clustered Queues, both of which were relatively easy to setup. I also used Clustered Scheduled tasks (Something which cron cannot handle) 3. Remote monitoring: With things like JMX and JVisualVM you can get realtime information on how things are going and even perform actions on the running applications, again all built-in. 4. You can write and deploy non-web services easily that may be supporting your web-app. 4. All this works on windows nicely (Yes, I had to use windows as well as linux). 5. A single admin interface for EVERYTHING (including cache / queues) using http://torquebox.org/backstage/ 6. A single mailing list with knowledgeable people which you can ask regarding issues in all of the above. which is really cool when you might have a problem between components. Not bouncing around mailing lists between teams. Again, all this can be setup using disparate technologies but in my case, that would have been more setup work and much more monitoring work. Now, for a single local small rails app, do you need all this? Probably not, but even in that case, a local torquebox with caching and queuing means you do not have to setup, manage and monitor memcached and sidekiq for example. And with torquebox 4 if you just want the web bit just use torquebox-web and get the speed boost without any of the other components. I would highly recommend reading through the documentation, you can probably do it in 30 minutes - 1 hour and it will give you a good idea of the possiblities. 
It's not a trend if it's happened forever
Another option is to not use `instance_eval` and pass in `self` as a variable. Machine.new :MyMachine do |m| m.when ... do .... end end
I frequently rely on known OK parts of stdlib, such as `uri`, `optparse`, `net/http`, `pstore`, `yaml`, `json`, etc. These libraries work very well and don't warrant adding yet-another-dependency. There's actually many useful libraries within stdlib. Checkout the [Getting to know stdlib](https://endofline.wordpress.com/2010/12/10/ruby-standard-library-mini-test/) blog posts.
I'm reading it now, but question - you using ruby 1.9.x? EDIT: nvm, didn't see article written in '10
that article illustrates what I meant tho.. ruby confuses the f#$@!%&amp;! out of me.. Like wow test/unit requires minitest which if you read careful you find out has a skip method that lets you state a reason... I don't know if he is sarcastic or not, but yeah let's say I bothered digging enough to figure this out, I'm probably not going to remember it very long time unless I have to use this particular code very often. it's not friendly at all to a developer who doesn't just work in ruby. even the documentation is not very practical to use although i really like the gem server one, which unfortunately does not include the standard library T__T;;
Most of the stdlib is great - at least good enough to use if you don't have a specific reason to *not* use it. The two exceptions I'll make are for serializing / parsing JSON (the oj gem is drop-in and much quicker) and any time I'm doing very HTTP heavy work (net/http works fine, but is wildly inconsistent and very verbose for nontrivial use. I usually go with a net/http wrapper like HTTParty or Typheous for more advanced stuff like true async).
&gt; Most of the stdlib is great - at least good enough to use if you don't have a specific reason to not use it. &gt; not so much a specific reason to *not* use it, but like 50% of the methods look like they were written in the 1980's and the docs are even harder to decipher than .NET help. Apple's API reference docs are infinitely better in comparison
I greatly prefer running my own code. Part because I understand it better, part because it fits my application better. It's rather rare to find a gem that fits your applications need exactly. usually there is always a trade off where you have to reshape your structure to fit the gem, and so end up programming a bunch to include the feature the gem provides. I've personally found at least 30 times that writing my own code ended up being less work than using the gem. Sure, the time spent was a bit more, because I had to understand what the gem did, but learning is never a bad thing in my eyes. Codewise, I've gone from ~60 lines of fitting gem into application to ~20 lines of solving the problem myself more than once. edit: to clarify, I still use a lot of gems because many of them actually do a lot of work for you. Also, to more specifically mention some of what OP wrote, You definitely should use ruby standard libs as often as you can. As someone new to Ruby, they can be really confusing, but what I've learned is that if the standard libs are confusing, it's because you're not comfortable with ruby syntax yet. I hated the standard libs when I started out, now they feel completely clear to me. (most of them at least...) Trial and error in irb is a good way to see if you've understood them right.
&gt; Profiles is a command line tool that helps you inspect your local list of provision profiles for a give UDID, and it also can search an ipa’s embedded provision profile for it. What is a provision profile? What given UDID? What is ipa, what is an embedded provision profile? WHAT ON EARTH IS GOING ON?! You might want to rewrite the beginning of the README assuming the person reading it has 0 knowledge of anything you are talking about. (For others wondering, after some googling I discovered this is something to do with IOS App development )
&gt; and you'll still encounter plenty of "old style" hash literals around. In github's own ruby [style-guide](https://github.com/styleguide/ruby) for instance. "Use hashrocket syntax for Hash literals instead of the JSON style introduced in 1.9."
[Rails.env.production?](https://www.omniref.com/ruby/gems/activesupport/4.1.6/symbols/ActiveSupport::StringInquirer?d=137296876&amp;n=0#)
Automation, I'm a QA engineer and I use Cucumber to automate all the tests. Also use Ruby to automate tasks I can't be bothered to do more than once 
Lol thanks for this reaction. Was about to post a similar one
I see. Looks like I'll need to re-download the source code for ruby. Thanks for your help.
+1 to the automating tasks. This and data scraping &amp; general crawling. I probably spend a quarter of my time using Mechanize alone.
I would advise that you don't use the Ubuntu package system to install Ruby. I find it easier and more flexible to use rbenv It helps you install and manage Ruby versions. It also helps with paths to source which Gems with C extensions need to compile. https://github.com/sstephenson/rbenv 
In my previous job, a skilled Ruby dev created a command line tool to parse security checklists in XML using the nokogiri gem. That's basically my intro to the Ruby world. I'm currently a Rails dev as well but I also developed a customized site parser using httpclient and nokogiri gems. It's gemified and can also run via cli. My plan is to wrap it in Rails as a web ui and use Sidekiq to have it scrape multiple sites in parallel. 
An alternative for rvenv might be RVM. I don't know if rbenv does this but RVM automatically sets the right Ruby version if it is defined in the Gemfile. http://rvm.io/
&gt; Most of the stdlib is great I'm assuming you've never looked close enough, the word [ghetto](http://www.mikeperham.com/2010/11/22/the-ruby-stdlib-is-a-ghetto/) has been used to describe it. It contains bad/slow/not-used-by-anyone code, sometimes is hard to use and doesn't have great docs (compare to Go or even PHP, for example). * has FTP, but not SFTP * has Time, but not TimeZone * has XMLRPC, but not SOAP * has things like Abbrev, DBM, NKF &gt; net/http works fine Besides being hard to use (as you mentioned), it's probably the slowest. See [alternatives](https://speakerdeck.com/nahi/ruby-http-clients-comparison) (there's 15+ HTTP clients for ruby). IMO Ruby's stdlib is not great (but it doesn't matter because rubygems).
UI Automation tests with Watir, Cucumber and RSpec.
You do not want to use Ubuntu provided ruby if at all possible. Use rvm or rbenv to install ruby
Thanks, I'm installing rvm now. I think I installed ruby from source by following a step by step guide from the web.
Ah.. weirdly enough I found myself writing something very similar within a project - without the good sense to break it out into a gem. Woot! Looks like I need to do some refactoring. :)
Same here, automation and data stuff all the time. I don't even use Ruby for web.
* programming contests * ACM * A.I. * artificial intelligence * game bots * social moderation * social network analysis * graphs * ratings * game tools * ratings * Quake configs generation * WinAPI/Applescript autoclicking * Sinatra hosted games, multiplayer * graphics * pixel formats * SVG * procedural generation * chat clients * prototyping before other languages seems like just **everything**
I use it to write smallish utilities that's useful to me. Often they start as a small single-purpose script that's merely thrown together, but if it lives for a longer time it usually evolves more into a usable program with several features or capabilities depending on what needs I have. I find ruby lends itself well to this, it's way more expressive than shellscript, but still light enough that you can just run a set of shell command and parse their outputs without much fuss. 
XML processing with Nokogiri (sometimes together with Mechanize for web site automation). All sorts of little development helpers (statistics across a large base of source code files etc.).
Well explained. Thank you
I don't deny I still feel like a big ruby noob, but not so much because of the syntax i think. maybe rather because i fail to see the patterns you guys do. the general pattern i notice most is what /u/tastur mentioned, ghetto-ness T___T;;
* Server management with Chef. * Scripting: thor or a quick hack instead of Bash. * Small, focused apps with Sinatra. * Presentations, using showoff. * Blogging, using Jekyll. * Generating graphs and stats for my Insulin/Carbs to manage my Diabetes 1.
Configuration management, continuous integration, scripts to automate tedious tasks. RubyMotion to create mac applications.
-1 for RVM unless in production where it won't be fucked with. I suggest [ruby-install](https://github.com/postmodern/ruby-install) and [chruby](https://github.com/postmodern/chruby)
Video game development. There's a nifty gem called [Gosu](http://www.libgosu.org/) that offers some nice features to build games in Ruby. Right now I'm developing a gem with a very similar API which will use [Opal](http://opalrb.org/) to compile your Ruby to Javascript so you can make [games that run in any browser!](https://github.com/nicklink483/dare)
Usually I found myself in a position of having a string input that later I need to use inside the Ruby app. For instance, I'm currently working on a project for a client that uses CSV import rather heavily. My client data has for instance column with 'Y' and 'N' respectively, but I'm importing this into a database thus prefer to deal with boolean field. Another project, that this library actually has been extracted from is used for reading user input. As you can imagine, the users of your command line app may not be actually Ruby programmer and it easier to accept a wider range of inputs and convert them to Ruby types. Essentially, I find it pretty handy to have consistent way to handle these conversions. You can also pass strict option to enforce the type hence it can act like as an assertion for the data.
An excellent point - I'll keep that in mind moving forward. Thanks!
Padrino/Sinatra for front facing Web/api stuff (not a fan of RoR) IVR phone systems Bulk emailing Page scraping Api management (such as Google Adwords/Paypal/etc) A im chat server using a proprietary protocol An asynchronous disconnected data service Data transformation and reporting
Yeah, that was just a "well, I have what I need, push it out quick and dirty" process there.
Ruby is my go-to programming language for anything I have to do via code. That involves writing build scripts, populating DBs using scraped data, scraping sites, automating manual stuff using cron, sending emails, and also programming Bitcoin. :)
I use it for server side scripting where it would be too painful to do something in bash. I even use it when doing my bookkeeping. I have to work with two payment systems using multiple currencies and apply sales tax correctly. I use ruby to handle the PayPal reports and them convert into something that can be imported into my accounting software. Also, Sinatra would be non-rails even though it's still web dev.
I do a lot of back-end ETL (extract-transform-load) operations, have built little special-purpose gems to do normalization of weird local data, and use JRuby constantly as a way to get access to zillions of great .jar files without the pain of actually using java. Oh, and I write tests for our java code using JRuby and Minitest, because it's just easier. 
Well, a lot of what everyone else said, but probably the most fun are the quick and dirty ones I've used to play video games. I was getting into this RPG and I wanted to compare armor/ weapons quickly and the game didn't have that function built in so I wrote my own in about 10 - 20 lines of code. Another time I was playing a game which had these codes you had to crack to get the clue to advance. So I wrote a few brute force cypher crackers for a couple of different encryption methods. No OOP, no good practices just the shortest route to the solution
Lots and lots of packaging automation in tandem with Jenkins.
It's because a substring that is part of one match, cannot be used again as a part in another match. At least not with the regex you are using. 
RVM is great, and Wayne Seguin is a pretty cool dude to boot.
I use irb as a sort of calculator a lot. For instance if I'm pricing out cloud services I'll write a function to convert between hourly and monthly. Nothing you couldn't do with a regular calculator, just makes it quicker.
A new recent use of ruby comes in the form of Rubymotion! The successor to the MacRuby project, Rubymotion uses the Objective-C toolchain to compile ruby into code that runs natively on iOS and as of Rubymotion 3.0, Android as well. I've used it for a couple of projects and I much prefer it to Objective-C.
Ruby is a great toolbox language. It might not be the *best* at a specific task, but if I know I can sit down and write it in 10-30 minutes in Ruby, there's no reason (except professional interest) for me to spend hours learning another language so that I can do it in 5-15 minutes. Ruby is a brilliant language for handling all those little throw-away scripting jobs, so I frequently coopt it into any small "hey, I can automate this" sort of tasks.
Indeed. In case any of these meet your fancy, I was just riffing on thesaurus results for "transmute", "transform", "trader": transmute -&gt; interchange -&gt; [cloverleaf interchange](http://en.wikipedia.org/wiki/Cloverleaf_interchange) -&gt; clover recaster transfigure renovate swap-meet trader broker monger hawker 
I use Ruby in Chef, I have been looking into Cucumber also. I also do some small tools that I make, such as a port checker, or serve a directory using Webrick for a quick share, or test a page. I also dabble in JRuby, Ruby, and most things with it. 
I was using ruby before rails existed to automate all kinds of tasks, including auto-generating Java code and running a build process based on changes to files that contained internationalization/localization data. Today its my go-to tool, along with cron for all kinds of automation. I've written a bunch of different stuff, including automating reporting and data integration when one medium-sized company was purchased by a fortune 500... Once we had mapped how to share data between their systems, a few ruby rake tasks and cron was able to automate the whole thing. I do this so often I created a 'shell' of an application that I call the "Rake Application Starter Kit". https://github.com/bokmann/RASK
Merging a number of data sources to generate enrollment packages in Canvas (LMS). Then setup the courses. Manage dropped enrollments. Finally to to monitor if the faculty have published the course and then list it for the students in our portalish thing.
I built a twitter bot on ruby and I personally like a lot.
analyse log. extract data.tools, compatible between windows/linux, (net,files...), hmi tools (with gtk, win/linux), protocol simulator (sockets...) for java connector development.
What about gem "progress_bar"?
Thanks for the replies. I was concerned this would be like the difference between Python 1 and 2, or Perl 4 and 5, where there are major features and the old one is just wrong for contemporary usage. 
[pry-coolline](https://github.com/pry/pry-coolline) gem adds as-you-type syntax highlighting. Pretty slick.
I have to agree with the sentiment here. IMO, they need to [gemify the stdlib](https://bugs.ruby-lang.org/issues/5481). 
For bash scripts, CNC programming (custom lib), calculus, i3wm, ...
A lot of prototyping. I even made my own framework for super fast lazy me. https://github.com/mess110/ki
Most recently I used it to write a small script that called a list of URLs that I provided and checked that the response was valid JSON. I like that the standard library is large. I used net::http for my web calls and the built-in JSON parser to check the responses. No external libraries needed.
/u/balloo_loves_you did you mean "digit" or did you really mean "number"? I am asking because 52 is not an odd number. Also, your expression does not distinguish between odd and even digits.
I see it requires Docker for Linux but not OSX. Could you elaborate on how that is used? 
Docker is only used by the Traveling Ruby authors (i.e. Phusion and contributors) for *building* the binaries. You, as a Ruby developer who just wants to distribute your app, just uses the binaries that we have already built and uploaded somewhere. There is no need for *you* to run Docker. On Linux, Docker is used to provide a controlled, isolated build environment. In other words, it serves as a ["holy build box"](https://github.com/phusion/traveling-ruby#why-it-is-difficult-to-supply-a-precompiled-ruby-interpreter-that-works-for-all-end-users). There is no native Docker for OS X (i.e. a Docker which can run OS X binaries) so on OS X we try to get as close to an isolated, controlled build environment as we can [by setting various environment variables](https://github.com/phusion/traveling-ruby/blob/master/osx/internal/reset_environment.sh), but it's not perfect and I'm sure someone will have just the right amount of Homebrew libraries to interfere with it.
ROM could really do with some documentation. I have little idea of what it is supposed to be.
This is a regexp question more than a gsub question. The default answer to regexp questions is "no".
If the additional keystrokes bother you so much, then just alias the commands in your bash/zsh config. Adding a completely unneeded layer of complexity just to save some typing isn't worth it.
Aha, thanks!
I also spend most of my day writing Ruby for Rails, but I also use it as my shell scripting language for any tool I need to build to make my job easier that doesn't need to directly integrate with my editor (I use Emacs Lisp for those things).
check out rubular.com. It's great for debugging regexes.
I use it for quick, hacky scripts that are slightly too messy to do in bash, but too small to bother setting up in C
yes, I did mean digits, and you're right I forgot to add an important part of the exp, it's fixed now to how it is in the script.
My old job i used to use it for scripting &amp; normalizing data from spread sheets quite a bit. I also wrote a command line tool to read text files of copy, and create the CSV to be uploaded into our system. This eventually did become a rails app though, so others could use it.
Getting my photos backed up on AWS Glacier. Didn't feel like paying for a GUI client so I wrote a ruby script to zip my photos and upload them to Glacier.
thanks! this is much more helpful
Stdlib is a good thing to get aquatinted with. There are some libs that I need very often like SecureRandom, BigDecimal, forwardable, delegate, open-uri, stringio, openssl, tempfile and fileutils. And then there are some things which don’t make sense to me to be in stdlib like minitest, given that it lags behind and I’m always going to want the latest stable version. That said, you have to consider the use case of things like embedded ruby where you may not have a network connection and using the old version of minitest baked into the language makes a lot of sense.
Thanks! I just wrote a speaker wish list and started sending emails - I couldn't believe it when they all said yes! :)
If Ruby was my first language, I would probably be proficient only in websites ) I am happy that my first was a classic sequence Basic-&gt;Pascal-&gt;C
Same here - Lead QA Engineer, heavily using Cucumber, Capybara, Site Prism, Selenium, Faker, Pry, and a handful of other minor gems.
Haha brilliant! Got my ticket, the train to Bath is expensive though! 
Now just integrate lookahead and you're done.
Interesting! I've always heard that Python's got better libraries for webscraping, but I'll take a look at Mechanize. Do you find yourself running shell scripts and outputting a csv file or something? 
Hmmm interesting. Seems like this is a pretty common usage, do you have any examples you'd be willing to share? I'm imagining some basic data massaging/pre-processing, file renaming? 
I don't like RVM rbenv is far superior
I'll be sending out an email to everyone in the next couple of days with a link to something like [this](http://www.thetrainline.com/ticketalert/) so you can get the cheapest possible train tickets ;)
wow, didn't know Faker, how did I live so long without it? :| Thanks
Ah nice idea, cool!
Ruby is already installed on Mac OS X So this is actually just a crutch for Linux to make it work the same smooth as Windows
Eh... yes, you could, and 99% of what you learn will still work, but you'll be missing out on a lot. I'd get a newer reference. Is there a post-1.9 pickaxe? 
Is this the project that's the evolution of DataMapper? If so, DataMapper is a kind of well-known name, if you mentioned that, it'd probably attract more interest/attention. 
I wouldn't recommend using OS X's builtin Ruby for anything. Use RVM/rbenv to manage your Rubies and get consistent results.
I have no doubt that there's dozens of DBM users :) but the only place I've seen DBM being used was in [gonzui](http://gonzui.sourceforge.net/requirements.html) (that was probably 10 years ago). I'm curious, how do you use DBM and why you need it to be in the stdlib?
Not usually, I wrote a distributed web crawler that backs out to Cassandra and Redis. Parse each page, do some scoring based on a few algorithms I wrote, occasionally some NLP, etc. Depends on the specific project. It handles around 25K pages/second right now. :)
This is cool - I actually have never seen non-web-based ruby programs outside of gem format. Are there any notable open-source examples?
Not really notable, but [WavHead](https://github.com/noidedmedia/WavHead)'s server is designed to be directly run by users with no server administration experience. 
If you just need a ruby, system ruby is good enough (tm)...
Or, if you're in a pragmatic mood, run it twice...
&gt; "do it right the first time" (don't we all?) Not anymore. My favorite quotes that I use whenever anyone asks me how we should do something: * [Everyone has a plan 'till they get punched in the mouth](http://www.brainyquote.com/quotes/quotes/m/miketyson382439.html) * [A plan is just a list of things that don't happen](http://en.wikiquote.org/wiki/The_Way_of_the_Gun#Parker). I have no idea what the requirements are gong to be three, six, and twelve months down the line. My main goal with all my software development is to get something out to a customer as fast as possible. That generally means cobbling a bunch of tools that other people made, and put a UI on top of it. What the customers use I will flesh out and mak efficient, what they don't I'll just drop, without having to feel like I wasted time building it.
Or, if you don't need the global/local stuff, chruby + ruby-install works nicely as well.
i would agree with you on that. i do catch myself needing odd little things like 'whats the word-count of this text'? or, 'what is this binary number in decimal?', or 'how can i reorient this text in a new format?'. I know that I have other tools to do all these but irb/pry is a one stop place to jump in and solve it right away. And yes, system ruby is good enough for that.
You don't by chance have a Dexcom CGM, do you? We're working on a RoR graph/statistics product for them. :)
And for those who want to see quines taken to their insane logical conslusion. https://github.com/mame/quine-relay
How so? I find RVM awesome
As rubyrt suggested, you need to use what's called positive look-ahead for the second group in your regular expression. You can read more about this feature in the [Regexp class docs](http://ruby-doc.org/core-2.1.0/Regexp.html) or in [this article](https://www.bluebox.net/insight/blog-article/using-regular-expressions-in-ruby-part-2-of-3), which introduces Ruby Regexp's look-around features in a nice and approachable way. So, without positive look-ahead you have this: "13579".gsub(/([13579])([13579])/, '\1-\2') #=&gt; "1-35-79" Adding positive look-ahead you get this: "13579".gsub(/([13579])(?=[13579])/, '\1-\2') #=&gt; "1-3-5-7-9"
Chef Heroku Toolbelt Vagrant
Does it statically compile OpenSSL? If it doesn't, there can be some serious usability issues as well as security issues. Furthermore, how does it get the trust root certificates from OSX? If it isn't accessing the KeyChain somehow, then it will be using the wrong root certificates. Ditto for Linux, since RHEL and Ubuntu store the trust root certificates in different places.
Man, this would be good if it supports Windows..
&gt; Does it statically compile OpenSSL? It does. &gt; Furthermore, how does it get the trust root certificates from OSX? It doesn't. It bundles the ones from CentOS.
The replacement is wrong. There is no second capturing group. That's why the sequence \2 results in an empty string and it does not do any harm. This is sufficient: "13579".gsub(/([13579])(?=[13579])/, '\1-')
Did someone recommend "Mastering Regular Expressions" yet? If you want to dive deeper into the matter without going through all the theoretical CS stuff that book is really helpful.
Not yet, thanks for the recommendation, I'll check it out. 
Nice gem :) But sometimes it is even nicer to hand code something, just to get the feeling how it works under the hood
Would be really cool if you'd post a few of those smaller Sinatra based web apps over at /r/tinycode we love seeing that stuff there :)
Nice catch, thanks, rubyrt! 
In addition to rubyrt's recommendation of "Mastering Regular Expressions", you may want to check out this Ruby Conf 2013 talk: [Beneath The Surface: Harnessing the True Power of Regular Expressions in Ruby](http://www.confreaks.com/videos/2862-rubyconf2013-beneath-the-surface-harnessing-the-true-power-of-regular-expressions-in-ruby). It's a nice, gentle introduction into how regular expressions work under the hood.
Back when this book came out, it was *the greatest* source for learning ruby because... (drumroll...) there were no other books. Technically the material in this book still applies, but do yourself a favor and get a better book. Not because the material is outdated, but because it's not the best way to learn Ruby programming anymore, and it hasn't been for a long time. EDIT: See [this discussion](http://www.reddit.com/r/ruby/comments/2oiu3d/whats_a_good_ruby_book_for_experienced/), lots of great books mentioned there.
solnic, in my humble opinion, that is like _the_ most important thing for you to do _right now_ to get people interested, excited and contributing, _not_ after 1.0.0. Stop writing the code and write those articles instead - word for word, you will get a much higher return on investment :)
Most of it is stuff that's probably not very useful to anybody else, so I haven't published it anywhere. I have [this small snippet](https://github.com/snake66/imusician-reports) though that takes the sales reports from the online sales of my band and massages it into somethin slightly more readable... It's actually progressed quite a bit since last time I pushed it, so I should probably update the github repo some time soon. **Update**: Since someone asked, I've updated the sales-report app, and uploaded another [small tool](https://github.com/snake66/fetch78) to download the library of sampled 78rpm records at http://78records.cdbpdx.com/. Enjoy, if anyone is interested.
Nothing fancy but really handy
Don't use stdlib as an example of contemporary Ruby programming practices. It is old, and Ruby core is very conservative about removing things that others came to rely on (which I actually appreciate).
Hope my criticism did not offend you. It was meant to be constructive. I think what you showed is just fine for a quick internal thing. But you know, when you put it out in public for all to see on a respectable engineering blog, it automatically acquires an aura of authority around it. So things that you know are quick and dirty will be accepted as the norm by people who do not yet have the benefit of your background and experience.
Ah, I see, thanks. Maybe you could still say "inspired by DataMapper", or even "originally planned as DataMapper 2.0, but plans diverged enough to make it a new project" (which is true after all), but I see why you might not want to do either on the official project page. 
I'd love to, but most of them were for an internal audience only :( But I'm working on a couple more that may be available to the public soon!!
Because no such package exists in your distribution, or because the package in your distribution is heavily outdated. In such a case, the only realistic choice you have is to follow the developer's instructions, which usually boils down to "install this specific version of Ruby and run 'gem install foo'". Then you, as the user, have to figure out how to install that specific Ruby version (because your distro probably doesn't have the right Ruby version), and you have to figure out how to use RubyGems. That sucks. Of course you can say, bah, distro packages are better. But who's going to make it? You can submit a request to your distribution's packager, but you will be at his/her mercy. Maybe the person is busy and honors your request in 6 months, but you have a deadline and you needed the latest version of the software yesterday. You can ask the developer to do provide distro packages, but your distribution is just a dime in a dozen. The developer has to take more than 10 platforms into account. What makes your distribution so special that s/he should spend a lot of time and effort in this? Why should s/he prioritize this over development work such as bug fixes or more features? Why should s/he do this for you at all when s/he can go out to have dinner with his/her spouse and play with his/her children? Unless you pay the developer, there is little external incentive to do this work. You are at the mercy of the developer's intrinsic motivation. In the ideal world, everything would be packaged using the distribution's native package management. Such as ideal world does not exist. Traveling Ruby (and similar solutions) is the next best thing. If you are at the mercy of the developer's intrinsic motivation anyway, why not make it as easy as possible for the developer? That way we will increase the chance that something actually gets done. Sure, you can go rant about packaging, but unless the developer is very very very intrinsically motivated, you can rant for a year and still don't have your packages.
I'm learning Ruby before Rails and am planning on applying for Dev Bootcamp. Regardless if you plan to apply there or not, before they interview you, they ask for you to do the beginner exercises at rubymonk.com. I finished it in 2 days and tried solving the problems there too (they have a special 'problems' section). After getting through a few, they started getting hard (note: these are beginner problems), so I've been browsing the web learning very basic Ruby from other places similar to RubyMonk, like rubeque.com. I've been jumping from interactive exercises, to small ebooks, to Youtube videos. I'm a customer of CodeSchool and paused my membership because it feels they summarize really well the best practices from an "advanced" beginner upwards. If you're really new to everything, understanding hashes and blocks and navigating around the web solving problems is really what you need to learn, I feel. I have a bunch of free stuff opened at once, like Learn Ruby the Hard Way. Today my cousin from Brazil asked me to purchase an iPhone 6 + GoPro with a bunch of accessories. Instead of using a standard calculator or Excel to plan this out, I'm using Ruby. You can practice really easily using the Ruby Interpreter (on your Mac you can access it by having Ruby installed, going in the terminal and typing 'irb'). You won't have to save files or use the web. It's a deal breaker inventing these personal exercises as an opportunity to practice creating, looping and adding through a hash, for example. Since this stuff is really daunting, you have to make sure you keep telling yourself to have fun. You can find some interesting links here: http://www.quora.com/What-is-the-best-beginner-course-to-learn-Ruby-on-Rails-Udemy-codeschool-lynda-treehouse-rails-tutorial-by-michael-Hartl-or-other Feel free to send me a msg so we can learn along. Take care! 
Hah I agree! Please notice I wrote "with 1.0.0" not "after 1.0.0" and frankly it's not a distant future. We're talking a couple of weeks from now. I focused so much on the coding part simply because I needed certain things at work and with my limited time...tradeoffs ;( But I can promise much better docs, tutorials and some articles explaining philosophy behind the design and so on :)
Cool let me know if you need any help!
&gt;We’ll drive you trhough input and output validation inside ruby applications, the good and bads and some possible solutions. They should get some spelling validation techniques.
`module_function` makes all methods available too, it's just that the instance methods are made private.
You can override that particular aspect with the right environment variables. Just add your own custom logic for looking up particular certificates and set SSL_CERT_FILE accordingly.
Yes I use a versioning strategy suggested by Semantic Versioning which says if something is on production then it probably should already be 1.0.0. I used to disagree with this and I completely changed my mind after gaining more experience when working on libraries. Every project won't get away from legacy and will have to deal with deprecating interfaces and upgrade procedures. The sooner you have the infrastructure to support this process the better. Besides having a library used in the wild gives you great feedback which is valuable and helps in evolving the library in the right direction.
Totally agree. Serendipitously, I just happened to be watching [this](https://www.youtube.com/watch?v=YqXU4o24Hkg) when I saw your post. Check it out - it's Yehuda Katz talking about Indie OSS, and I think you may dig some of the same ideas. [Don't Die: A Guide to Indie OSS - Yehuda Katz @ hack.summit()](https://www.youtube.com/watch?v=YqXU4o24Hkg)
It's used in Sinatra a lot for control flow. For example, when you do `halt`, it is actually doing a `throw` that's caught elsewhere. If you are interested in how throw/catch are used in the real world, go to https://github.com/sinatra/sinatra/blob/4e92d604be5269b1d6527a6093f112d10b5b9d7f/lib/sinatra/base.rb and do a search in page for `throw` and `catch`.
The [i18n gem](https://rubygems.org/gems/i18n) uses a fair bit of throw also, e.g., in I18n::Backend::Cache: throw(:exception, result) if result.is_a?(MissingTranslation) 
That is OK indeed! I'm old and I look for mature frameworks. I no longer get excited about wizbang framework 0.8 being released constantly re-inventing the wheel and solving the same problems.
`throw` and `catch` are very useful to break out of nested loops. `break` only breaks out of the inner-most loop. catch :ball do loop do while condition do if something_happened throw :ball, "something happened, man!" end end end end
The canonical example is to break out of nested loops, since it's basically a GOTO with an optional payload. It allows you, for example, to break out of a double-nested loop with a value as soon as you find it. Let's find the first error in a set of logfiles. Yeah, yeah, grep, whatever. It's an example. [filename, error_line] = catch(:err) do logfiles.each do f File.open(f).each do |y| throw(:err, [f,y]) if y =~ /error/i end end end puts "The error line is:\n#{error_line} We immediately break out of the inner loop with the data we need instead of having to set a bunch of flags with break statements. 
A company requires us to upload files every day with a large form submission. They don't provide an api and their web app is generally horrible. I found the watir gem and wrote a small script that fills in all the fields (since they are usually identical for each submission). It probably saved hours of typing :)
To me, the Node ecosystem feels like a bit of a false start. Node came to rise along with the NoSQL database hype, when NoSQL was going to be the next big shift. Well, that didn't prove out. That died down in a big way. Node isn't strictly tied to NoSQL, of course, but it was a driving force for attention that has petered out. As for Node itself, the problem it solves best is of a much narrower focus that what Rails solves. Most sites / tools aren't serving 10k simultaneous connections. It's a powerful tool when you need that, but if you don't, you're just working in a less friendly environment (IMO) without much gain. Likewise, the promise of same-JS-on-client-and-server has not proven out very well either. Another promising game changer that has stumbled in the light of reality. Not every new thing is really better than the old thing. But Rails is not the end of the evolutionary line either, and it is time for something really disruptive to step up. But each passing year, I'm more confident that Node isn't going to produce that. It's going to be something else. 
I think this post is spot on.
The short answer: no, not really. The only place I've used it for real is to retry auth attempts N times before failing out for real. The academic answer: raise/rescue is meant for handling exceptional conditions, NOT for control flow. If you want control flow to be able to jump locations (multiple loops, method calls, etc--those not handled by regular conditionals), then you should use throw/catch. I actually think the i18n example below is _horrible_ (taken out of context).
Nice, I'll check it out this weekend.
I Totally see now why older friends were not so hyped as I was about rails some years ago... 
Clicked the link to Tony Arcieri's blog. I miss his posts about Ruby. It's all infosec now, no mention of Celluloid. Looks like he burned out/got tired/gave up on the subject. Anybody happen to know otherwise?
Oh, tell me more about i18n, what don't you like about it? At least taken out of context without looking at the context, would you have used raise there instead? Or a conditional? (In context it may make more sense, we realize. I went and looked at it in context and there's... some complicatedish stuff going, which could be positive or negative.) And yeah, I fully am aware of the academic answer, but it's not leading to much insight, thus the question. (I mean, when the heck do you need control flow to be able to jump locations like that? I don't think I ever have, but possibly there were situations I didn't recognize where it could have made my code cleaner... or not). 
[http://www.jacopretorius.net/2012/01/catch-and-throw-in-ruby.html](This post from Jaco Pretorius) has some performance notes; I'm not sure if those are still true for Ruby 2.1.x though.
Basically, you're testing the speed of the call stack versus the speed of a Ruby array. In C (where you'd be comparing the call stack against C arrays), you'd notice a big difference. The discrepancy in your benchmark is likely due to the small array size (try at least 10,000 or 100,000) and the speed limitations of Ruby arrays. Your lampsort implementation is also worse than your recursive quick sort. Try this one instead: def lampsort intervals = [[0, size - 1]] until intervals.empty? do left, right = intervals.shift if right - left &gt; 0 # non-empty interval pivot = partition left, right intervals &lt;&lt; [left, pivot - 1] intervals &lt;&lt; [pivot + 1, right] end end end
Thanks for doing this. I have some feedback if you're willing to listen. 1. Dumping the entire lot into the first file is considered a bad practice by many. Extract your classes into files and require them in your main file. 2. IMHO your game logic follows a very procedural flow, with a vast assortment of nested conditional branches in each method. Rubists prefer small focused methods that do one thing. I for one feel like it's a smell if a method is approaching 5 loc. Maybe try linting with some code quality tools like rubocop and reek? 3. The Thor gem would be a good addition to this since its focus is easing the burden of cli applications such as this one. 4. Monkey patching is something I typically try to avoid. It's not a hard rule, but it's usually the last thing I reach for. Not the first. 5. Test. Test. Test. It's hard for a gem to gain traction without a full test suite. Sorry if those are points of pain for you. You've invited feedback, so here it is. Thanks again for putting this together. 
&gt; Well that didn't prove out. That died down in a big way. Can you point to some data / examples here? Alternatives to relational databases have seen strong adoption and there are plenty of reports to show this.
I don't have experience with rails, I'm an infrastructure guy so I use ruby/python for automation. I can say however that NoSQL for massive datastores is far from dead. Cassandra, Voldemort and others are in heavy use at FaceBook, LinkedIn, Yahoo, Amazon, Netflix, Pandora and Google, amongst many others.
After the end of your `optparser = OptionParser.new do |opts|` block, add `optparser.order!` More info in the docs [here](http://ruby-doc.org/stdlib-2.0/libdoc/optparse/rdoc/OptionParser.html#method-i-order-21). optparser = OptionParser.new do|opts| ... end optparser.order! Hope this is what you were looking for.
I still haven't found anything that came close to Rails/Ruby in term of maturity in development environment setup and deploying. Migration in Rails works. It can coexists with compatible schema changes from outside Rails migration. Try working on application that has other non-Rails team also changing your database in .NET MVC. Gemfile.lock works. Multiple developer can truly has same version of library on each machine, within each project. Node's npm or Nuget is a joke.
There are a couple of ACID compliant NoSQL stores now. See [FoundationDB] [1]. NoSQL is a somewhat maligned term IMHO. It covers a range of technologies some of which were never intended to be used for scenarios where transactional reliability is a requirement. [1]: https://foundationdb.com. 
If you are doing this then also look at the "Trollop" gem, they fulfill the same purpose but in different manners. It might be instructive to use both to compare and contrast styles.
Scraping, mechanize, twitter bots, task automation. I have a lot of emails/calls to manage and currently do so with Ruby, but also hoping to figure out the twilio rubygem to do some automated call reminders too. 
I saw that mentioned a few places, but haven't read up on adding gems yet (just starting to learn ruby). I'll add this to my list and check it out.
rubyrt, I am actually kinda confused about this myself - could you explain what's the difference beween `parse!` and `order!`?
Of course you do! :) BTW, what's the conclusion of the story about removing minitest from stdlib? Was it decided to keep it in after all?
There is so much fragmentation in testing, it's really tiresome. Looks like every project is using something else ("let me fix a bug in this library... wtf is bacon?! urgh..."). Then if you are doing web stuff you have to make yet another choice for testing javascript - it's the same story there. So you have to learn all the assertions for whatever framework you chose on the ruby side, then all the same-but-different assertions on the js side. Makes you wish there was some kind of a standard.
Silly bot matching ror in domain to ruby. You are drunk, power off
I always got frustrated with option parser. Then I found the slop gem So much easier! 
There is several gems that still supports 1.8.7. https://github.com/minimagick/minimagick https://github.com/toy/image_optim People are not always as eager as us when it comes to being edge, sadly.
There are several, but they are the minority. Most of the gems most of us use have probably dropped support for 1.8.7 at this point. And while that might have inconvenienced some developers, not very many -- community adoption of 1.9.3+ is pretty widespread. If a gem had dropped support for 1.9.3 the day after 2.0 came out, it would have inconvenienced a significant portion of it's users. Even though 1.9.3 is EOL'd, I'm sure some people will be using it for a while, and dropping support for 1.9.3 will inconvenience some of them. But that's not my question. If you've already decided to drop 1.9.3 support, and you are then considering dropping 2.0 support simultaneously -- is dropping 2.0 likely to inconvenience many more users? Or is anyone off 1.9.3 likely to be on 2.1 anyway, at this point? 
Thanks for your response! The 1.8=&gt;1.9 transition was way harder than anything subsequent, it is true, and somehow the community managed to switch together, nearly universally (unlike python 2=&gt;3, say). If ruby had done another transition as painful as the 1.8=&gt;1.9 one so quickly -- I don't know what would have happened. But I probably would not have been alone in being very unhappy. :)
Oh, not at all. No offense taken. You hit the nail on the head. I'll try to work on this habit moving forward. It's a carry-over from a job where we had a few of these hasty bad habits. By all means - if you see stuff like this, call it out. I appreciate the feedback.
I think what you're saying makes a lot of sense. I'd drop 2.0 from Travis and wait for any possible GitHub issues for 2.0 problems and fix them then rather than worrying about them up front.
Cool, thanks. Personally, I'd never spend time fixing issues for 2.0 if 2.0 wasn't tested in travis. If I dropped 2.0 from travis, I'd say in the README that 2.0 was not supported and don't bother filing issues on 2.0. If I'm going to support it in any way, I'd want test coverage, and CI for my test coverage.
You had problems trying to upgrade to 2.0, so you're still on 1.9? 1.9 is end-of-lifed in February. At some point you'll prob have to upgrade whether you like it or not -- when you do, do you see any reason that might keep you on 2.0 instead of 2.1?
We currently run Ubuntu LTS in prod, which is keeping us on 2.0. I don't see that changing until the next LTS release.
I never bothered with those differences. You can find some explanation in the docs. Other than that, I'd try all of those out and see what happens. I did not see any difference in a short test. But that does not necessarily mean anything.
Thanks -- the considerations there are potentially a bit different than for releasing a new version of a development library. Passenger can run legacy code that hasn't been touched forever -- but a newly released version of a development gem is only going to be used if code _is_ being touched. If code is being touched, is someone going to still be running 1.8.5? They are unlikely to find very many supported gems for 1.8.5, so mine won't be alone, I feel no need to support 1.8.5 (the burden of which would be substantially higher than supporting 2.0, for modern development). (1.8.5 is also entirely unsupported by ruby core team. Does RedHat release their own custom security patches when needed?) But might they still be stuck on 2.0 and not able to upgrade to 2.1? jamie_ca above provides an example where they might, because of officially included versions on stable distro's (their example as Ubuntu LTS), and, at least at present, most currently supported open source gems probably do support 2.0 no problem. That does seem to be potentially a strong argument for continuing to support 2.0. Hm, there are 2.1 features I'd like to start using though! My guess is that after Rails 5 comes out and supports 2.1-only, 2.0 support is probably going to drop throughout the eco-system. Or, of course, after 2.0 is EOL'd by ruby core team -- but no date announced for that. In the meantime, I think the "Ubuntu LTS" argument persuades me to maybe keep supporting 2.0. (But 1.8.5, forget about it. As it happens, we actually DO run RHEL 5 in my shop. But we do custom installs of ruby on those machines that need ruby, it's not feasible to develop in ruby 1.8.5 in this day and age). 
Rails 5 will support ruby 2.2+ only.
If you're authoring a library that you want the majority of Rubyists to be able to use, I would suggest supporting 2.0.0 and 2.1 (assuming 1.9.3 EOL). There's no shame in only supporting currently-supported versions.
But you think it's necessary to include 2.0.0 in there? There's still significant people that will be on 2.0.0 and not 2.1, you think?
In windows code I'm still in 1.9.3, I was never able to upgrade. I can't use linux on this cases because it's windows only apps (they use win32ole). If you read on the [rubyinstaller page](http://rubyinstaller.org/downloads/) (the main way to install ruby on windows): &gt; If you don’t know what version to install and you’re getting started with Ruby, we recommend you use Ruby 1.9.3 installers. These provide a stable language and a extensive list of packages (gems) that are compatible and updated. &gt; Ruby 2.0.0, specially the 64bits version, are relatively new on the Windows area and not all the packages have been updated to be compatible with it. To use this version you will require some knowledge about compilers and solving dependency issues, which might be too complicated if you just want to play with the language. so I think I'm not the only one that have problems with ruby &gt;= 2.0 on windows.
Nice, thanks! I'll check it out.
We sure could. Alas, I am merely a dev, and not ops.
Two recent examples: FoundationDB just hit 14.4 million random writes per second on EC2 and it's fully ACID compliant. [http://blog.foundationdb.com/databases-at-14.4mhz](http://blog.foundationdb.com/databases-at-14.4mhz) Neo4j, also ACID compliant, is claimed to do more than 1 million writes per second on a typical MacBook Pro when using the 2.2 import utility. It's no 14.4 mil but this is very different tech and hardware. (It's also a fantastic DB!) "NoSQL" is such a broad label at this point that it's probably not appropriate to make any broad statements about it. It barely has meaning.
It's a continuing problem that OSX lags behind Linux and FreeBSD version wise. You should be able to upgrade some things by installing them via homebrew and `brew link --force`.
We're on ruby 2.0 and can't upgrade to 2.1 due to a gem (I think it's Cassandra, not my area). That being said, I would kind of like to see people stop supporting 2.0. I'm sure we (or another company using the gem) would upgrade it to support 2.1 if that were the clear winner. 
OS X's system ruby is still 2.0, that would be the main reason to continue to support it.
True, but still rvm gives me more utility. What I was saying before is the fact that 2.0 is perfectly nice, when compared with 1.8.7, which had to hit end-of-life to finally be updated for vanilla systems (where the user is not knowledgeable enough for installing rvm or brew).
It would be great if there was a explanation of what each setting is and why the chosen values were set
Noob question: Is this a universal trick or it depend on the environment and settings of each Rails app?
I would have a set of unit tests in which I mocked out any internal database call or other internal interactions and tested every single reasonable response or status that is expected to be returned. Then I would also have an integration test that walked through a real world workflow that linked multiple API calls together (register user, view profile, update password, logout, login with new password, etc). This would only test the happy path.
I could go either way, depending on how popular the gem is. These transitions always involve some pain, especially when they happen so quickly. Perhaps Ruby should think about it's own LTS releases.
1.8 to 1.9 was big change. 1.9 to 2.0 was piffling in terms of work required by app devs. Remember ruby did not (and arguably still doesn't) follow semantic versioning so you can't base any assumption on versions numbers being an indication of change. 1.9 should have been 2.0 given the scope of changes.
I recommend testing the API (or really any piece of software) at multple layers in the stack. No one approach is perfect or complete, nor is a combined effort but some tests just generally work better as low level tests while others are better as integration or end-to-end tests. No silver bullets, try everything, use the best mix that works for your use case.
Sorry but "Try my settings without any context given!" is terrible advice. There is no explanation of what each setting does, why you set it or what the end result of each setting was. This is a bad thing as people might just cargo-cult the settings not really understanding what they are doing. Anyone thinking about this should read http://tmm1.net/ruby21-rgengc/ first (Skip to the bottom if you just want the definitions). http://samsaffron.com/archive/2013/11/22/demystifying-the-ruby-gc is also good if a bit old.
gsub returns an String with the change but it doesn't modify the original variable. Try gsub! instead
It depends. In this case you might try with those settings and it may be better because Rails is a heavy app by default. But make sure you can measure before / after using something like new relic and do not assume these settings are the best for you. And do not assume a speedup in the test suite means a speedup in the actual app. you want to measure the actual application.
Your method is super odd. It's very un-Ruby-y. Why do you have `cppFile[i]`? Why the hell would you run this separately for every single line? It should probably read: `cppFile.gsub!(gWords[j], eWords[j])`-- and just use File.read on the cppFile. Why would you read just the first 18 lines of the file? That so... arbitrary. Here's a better way to do all of this: german_words = File.readlines('german.txt').first(18) english_words = File.readlines('english.txt').first(18) german_file = File.read('germanVersion.cpp') german_words.each_with_index do |german_word,index| german_file.gsub!(german_word, english_words[index]) end puts german_file You really need descriptive names, decent style, etc. By the way, this will match inside words and things, too, which sucks. For example if you were gsubbing "und" with "and", all instances of "under" would become "ander". If you wanted to be smart about it, you could iterate over the file only once and check only whole words using word boundaries, like so: german_words = File.readlines('german.txt').first(18) english_words = File.readlines('english.txt').first(18) german_file = File.read('germanVersion.cpp').split(/\b/) substitutes = {} german_words.each_with_index do |german_word,index| substitutes[german_word] = english_words[index] end german_file.each { |bit| substitutes[bit] ? print(substitutes[bit]) : print(bit) } Didn't check, but that should check whole words only, only iterate over the german file once, etc. It's still case sensitive.
I've been using mainly c++, c, etc for 2 years. Ruby is my first scripting language, so I'm not used to it yet.
I'd also be concerned that the test suite, which might do everything once, may not accurately reflect the main application, which might do one thing 90% of the time it's running.
&gt; Node came to rise along with the NoSQL database hype Being more specific, it's hard to read about Node without reading about MongoDB. There have been a number of discussions around MySQL being incredibly poor when used with Node. Meanwhile, MongoDB, despite being "the thing" in the hip crowd, seems very much to have the hyper surrounding it dispersing. 
Understood. You're making your program do a lot of hard work. No matter what your language is, you should use descriptive names (in my opinion). Turns out that you can also pass a hash to gsub, which makes this even sweeter. Check it: http://batsov.com/articles/2013/10/03/using-rubys-gsub-with-a-hash/ So in my second example, you could just do `german_file.gsub!(/\b(#{german_words.join('|'})\b/,substitutes)` That's awesome! =)
I believe many of the major platforms are shipping with ruby 2.0 (RHEL/CentOS 7, OS X 10.9 &amp; 10.10, the current Ubuntu LTS)
A buddy of mine used shoes for a project (green shoes to be specific) and I've tried (red?) shoes which I didn't like. I was more inclined to build a web app with rails or Sinatra than to build it with shoes. My buddy didn't like green shoes. 
Check out nokogiri while your at it its the shit! https://rubygems.org/gems/nokogiri
You can use a bit of hash magic and Array.zip to zip two arrays into a hash. So substitutes = {} german_words.each_with_index do |german_word,index| substitutes[german_word] = english_words[index] end Becomes substitutes = german_words.zip(english_words).to_h substitutes = Hash[german_words.zip(english_words)] or substitutes = german_words.zip(english_words).to_h so german_words = File.readlines('german.txt').first(18) english_words = File.readlines('english.txt').first(18) german_text = File.read('germanVersion.cpp') # You don't need to split here now substitutes = german_words.zip(english_words).to_h german_text.gsub!(/\b(#{german_words.join('|'})\b/,substitutes) puts german_text Untested so the last bit might not be 100%
He only said that would be the best option. As it is this is still the only viable gui option
But it is jruby
Oh, it weren't the last time I took a look. But again shoes4 is pre release and not meant for production. 
There are Ruby bindings for gtk, qt, wxwidgets. Tk is even in the stdlib (but deprecated AFAIK). So there are alternatives. If you promote something as the best, you have also to explain why it is superior to the alternatives. 
&gt; gtk, qt, wxwidgets All of which are a heck of a lot more complicated than shoes and none of them are easy to deploy as a gem (Qt for example requires Qt already installed). I have only ever seen one ruby gui app distributable as a gem, that is redcar and it uses JRuby which he explicitly said he wants to avoid. I just upvoted the oriignal suggestion without expansion because as far as I am concerned, shoes is the ONLY viable option available to him with his requirements.
I think he just, like, beat the game.
I'd use tk for the following reasons: * it's in the standard library * it's easy to install on any platform GTK and QT, not so much. And shoes just isn't as powerful. http://ruby-doc.com/docs/ProgrammingRuby/html/ext_tk.html
I suspect the shift will happen when ruby 2.2 is released, and Rails 5 is released supporting only ruby 2.2, which is the currently announced plan. I just hope it doesn't happen before 2.2 is reasonably stable and bug free, past ruby releases have usually required a micro-release or two to fix bugs. 
I had thought that ruby was now doing semver, but went to look it up, and you're right, they still release API-incompatible changes in minor versions, hmm. https://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/ I also didn't realize they were planning on releasing a minor version every christmas, I guess that means we should see a 2.2 soon. The new version policy is an improvement over the past weird one, thankfully using a three-part scheme for release numbers now instead of the previous 4-part (with patch number) that had no particular justification or scheme behind it. I'm a bit annoyed at the commitment to release a (possibly API-incompatible) version every year on a specific date though. Instead of releasing a version when it's ready -- and once a year of backwards incompat changes could be a huge pain. That ruby and it's community are willing to backwards incompat to innovate is what got us the language and tools we love.... but it sure is a treadmill sometimes. 1.8=&gt;1.9 and Rails 2=&gt;3 burned a lot of people out I think, hopefully the developers won't forget and will continue to remember to balance stability with innovation. 
I'd say the baseline is you need enough tests to be confident in your code. If you ever need to fire something up and interact with it manually to make sure it's still working, then you don't have enough tests, right? When you say "Testing the side affect in the beginning test-first style gives me the ahah moment when I'm finally done", it sounds like you definitely need to test the side effects. Whether that's in the same test, or you try to split things up into different groups of tests, is a matter of code organization for maintenance (and for what you learn when tests fail), and it does matter, but I don't have the answer. :) If it's working for you, then sounds like you're doing it right. If there are some aspects of what you are doing that are not working well for you, then spelling them out might make it clear to you how to improve them, or else gives you the question to ask the Internets. 
Are you sure the arrays contain what you think? Debug and make sure `gWords[j]` and `eWords[j]` are what you think they are. Because if they are, it ought to be working. 
I'd do the replacement slightly different because I would not want to explode the regexp in case word lists get longer; also, I would output as I iterate the file: File.foreach 'germanVersion.cpp' do |line| line.gsub!(/\w+/) {|m| substitutes[m] || m} # OR: line.gsub!(/\w+/) {|m| substitutes.fetch(m) {m}} puts line end That is more robust in terms of file sizes.
+1 for tk. Tried shoes but it was too simple for the interface I wanted. Tk works without a problem with ruby mri and it not that difficult.
I love Matz's style of interpreter writing, the parser seems to be similar to the MRI parser. Though I think its too early to see the benefit of this lang, but I don't know how it will be useful?
The strings in my word arrays had the end of line character on them. I used a function to remove them and now it works.
Thanks for all the help guys!
Good point. Even better! I didn't test anything, so YMMV =)
If we're taking just the first 18 lines, doesn't matter =P. This actually calls for something like a directed acyclic word graph if we're being picky about it. It's not efficient to gsub many times, either. If it were being done at scale, you'd be better off building a bigger hash and using the split-at-word-boundary method I proposed earlier. That only iterates once over the text, does one hash lookup per word. Complexity for building the hash is O(N) for number of translations, complexity for doing the substitutions is also O(N) for the number of words. If you do a nested loop, your complexity is O(N*M). This comes at the cost of slightly more memory usage.
If you think of it like how *nix systems work, when you pipe the output from one command into another, you can take a lot of simple tools and get some fancy complex results out of them. I could see this being useful as kind of a cross-platform version of that, and the independent nature of each "module" could allow for very high concurrency.
Did you notice that the code I gave actually is "using the split-at-word-boundary method" and "only iterates once over the text, does one hash lookup per word"?
Yes, what you described is possible. But rultor works a bit differently. Here is how: 1. You decide that it's time to release 2. You type a command 3. Rultor clones the repo and starts a build 4. Build finishes (takes a few seconds or a few hours) 5. Rultor creates a tag and Github release The only possibility to insert something unwanted into the release is between steps 2 and 3. There are about 30-40 seconds there. But such a risk exists. If you want to eliminate it completely, you can configure rultor to get commit hash from the command, for example: @rultor release, tag is `0.3.4`, hash is `05ef6b`
nice. a commit could of course still be made between when I decide it's time for a release, and when I actually finish typing my command and rultor notices it. But, yeah, a minute or so in the end probably either way. The 'hash' arg is nice. Personally, I still find `rake release` takes only seconds too, and leaves me with my feeling of control, which may or may not matter. I do like the auto create of github Release page though, I'm maybe gonna look into adding that to my `rake release`. 
green-shoes
Ah, sure. Thanks!
From the example, it seems like it would make an excellent (and sane) shell-language.
I'm curious what Matz's opinion on Elixir is. As a ruby-inspired steaming lang i'll be curious to see how they measure up. Tried googling around for any quotes from him about it but came up short.
Yeah, put in that light, it does seem like a competitor to bash. I guess I'll keep my eyes open for developments! Does seem like a perfect language to develop bespoke Makefiles, which might be pretty cool.
With built-in fan-out/in language features taking advantage of concurrency this could be very viable.
... Which is a Ruby implementation. MRI (what you're probably used to) is just short for "Matz's Ruby Interpreter."
I would not recommend using shoes for any kind of project that isn't strictly for a hobby and experimental. I've used it once but it was buggy for various reasons. The biggest was that trying to download it was a pain (distro package was borken, the download wouldn't work on my distro, and there were multiple variations). After finally downloading it, there were huge memory leaks. Enough that my application crashed after using it for a while (basically me trying to dynamically create boxes and shapes and stuff). Given I was a beginner programmer when I tried and it was 3-4 years ago but I still stick by it. Things may have changes since then but I have had great luck with Qt on python and c, so if there's ruby bindings, give it a try. 
+1 for Automation. We use Selenium / Watir to write automated tests for the web application our company sells. 
`Integer#times` is already a method that iterates a block, so you don't have to apply `Enumerator#each` on it. That's a nice-to-have feature, but what would you suggest the method to return? The object itself or the print output? It returns a `nil` now. I personally like `Object#inspect` a lot for use cases like this.
**WOAH**. I just came to this subreddit to post a near identical link. I, too, had a program I just wrapped up (command line only); it's a more dynamic/up to date version of this https://github.com/Schwad/Get-Back-To-You ... And I wanted to share it with a few non-coding friends. First time GUI action. I'm a few days into diving into shoes and the best tutorials I'm pulling up are from the 2009-2010 era; or in little bits and pieces (I have read **Nobody Knows Shoes**); and still trying to grasp its potential. Does anyone here have a preferred tutorial/screencast/etc resource for Shoes ; thinking as a relatively new programmer?
The method now will return nil; but we can change it. Though I don't think there is a need for it. Object#inspect doesn't print the result as this does. I feel this will be of help to many coming new to Ruby who will be able to write code in a better readable manner.
That's why I prefer to extract words with scan(/\w+/) because that also allows to have multiple words on a line, whitespace at front or beginning etc. It's more robust.
Because puts is writing to a stream. Namely to STDOUT. You just made a nice and pretty clean class have side effects. Why should every class need to do I/O? I knows how to represent itself as a string. That's great. I can easily print it, combine it with other strings, etc. I really don't need it to print itself. 
That's what I'm looking at now. At Hash's. They really drop you in the deep end at this point. There's a big learning cure in terms of the example they used.
I did a little research, and it looks like the difference is about whether or not parsing the arguments happens in a posixly-correct way. * `order!` parses command line arguments in order. * `parse!` parses command line arguments in order when environment variable POSIXLY_CORRECT is set, and in permutation mode otherwise. `parse!` is actually implemented in terms of calls to `order!` or `permute!`, depending on the POSIXLY_CORRECT environment variable: def parse!(argv = default_argv) if ENV.include?('POSIXLY_CORRECT') order!(argv) else permute!(argv) end end As far as I can tell, posixly-correct way to parse arguments is to stop parsing as soon as a non-option argument is encountered, leaving the remaining arguments unparsed in `ARGV`. Here is an example: require 'optparse' options = {} op = OptionParser.new do |opts| opts.banner = "Usage: example.rb [options]" opts.on("-v", "--[no-]verbose", "Run verbosely") do |v| options[:verbose] = v end end $ ruby example.rb d -v Using `op.order!` you get: p options #=&gt; {} p ARGV #=&gt; ["d", "-v"] Using `op.parse!` you get: p options #=&gt; {:verbose=&gt;true} p ARGV #=&gt; ["d"] I think most people expect the opposite of posixly-correct behavior (at least I do). So, I take back my recommendation of using `order!` - one should go with `parse!` instead as you recommended. And this gives posixly-correct people the option of having their preferred behavior by setting the env var.
I guess that's the best of both worlds then: it's "gemified", and it retains the "blessed" testing library status. As I wined in another comment in this thread, we need more standardization (better late than never) even if that means testing in Ruby will always be a two-state solution, a two-party system with rspec and minitest :)
Are you using irb or [pry](http://pryrepl.org/)? Inside any Ruby [REPL](http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop), every object already prints itself. Check it out if you haven't already, it will change the way you program.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Read–eval–print loop**](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print%20loop): [](#sfw) --- &gt;A __read–eval–print loop__ (__REPL__), also known as an __interactive toplevel__ or __language shell__, is a simple, interactive [computer programming](https://en.wikipedia.org/wiki/Computer_programming) environment that takes single user inputs (i.e. single [expressions](https://en.wikipedia.org/wiki/Expression_(computer_science\))), evaluates them, and returns the result to the user; a program written in a REPL environment is executed piecewise. The term is most usually used to refer to programming interfaces similar to the classic [Lisp machine](https://en.wikipedia.org/wiki/Lisp_machine) interactive environment. Common examples include [command line](https://en.wikipedia.org/wiki/Command_line_interface) [shells](https://en.wikipedia.org/wiki/Shell_(computing\)) and similar environments for [programming languages](https://en.wikipedia.org/wiki/Programming_languages). &gt; --- ^Interesting: [^RubyMotion](https://en.wikipedia.org/wiki/RubyMotion) ^| [^Bigloo](https://en.wikipedia.org/wiki/Bigloo) ^| [^Lisp ^\(programming ^language)](https://en.wikipedia.org/wiki/Lisp_\(programming_language\)) ^| [^Pvts](https://en.wikipedia.org/wiki/Pvts) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmsri91) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmsri91)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Do it not for today's internal tool tomorrow on the web accessible need to be will.
I was just about to implement file upload in to my project and I was gonna use carrier wave but this seems much simpler for a beginner like me! Thank Op! 
Thank you! I had not thought about inserting non arguments in options. I would actually expect POSIX because I would always place non options behind options. Here is a simplistic test: o = OptionParser.new o.on('--foo BAR'){|v| puts "Foo #{v}"} o.permute %w{baz --foo bar} # prints "Foo bar", returns ["baz"] o.order %w{baz --foo bar} # prints nothing, returns ["baz", "--foo", "bar"] 
If you really need to check if a certain variable exists, you are probably doing something wrong. If you need to check if a certain variable is set, this means that you have no idea what your code is doing or even what code is executed. This is not a situation you should be in.
Absolutely! I faintly remember a posting on ruby-talk about why Ruby's "defined?" does not work the way people coming from Perl or other languages expect. But I cannot dig it up right now. Any local variable is defined from the position on it is assigned to regardless whether that code is executed: $ ruby -e 'def f; if 1&gt;2; x=99; end;p x, defined? x; end;f' nil "local-variable" What people usually want is a check for nil or just use the variable in an if.
You can get almost there without modifying `Object`: `23.times.each &amp;method(:puts)` And, as someone else mentioned, you don't even need `each` here: `23.times &amp;method(:puts)`
I would build gateway objects that interact with the side effecty endpoint. Test those with something like webmock. I would then pass in null objects (or else craft some kind of double) in place of that gateway object wherever you test code that wants to call out to that HTTP endpoint via the gateway. Also, I recommend not getting hung up on "integration tests" vs. "unit tests." That distinction is worse than useless.
A standard like.... xunit?
http://rubystub.com/668601743/
Cool interactive tool. :-)
I have not personally used the gem so i'd be very interested to hear about your experiences!
[Object#display](http://www.rubydoc.info/stdlib/core/Object:display), one of the most atrocious methods in corelib.
Rubinius is an implementation of the Ruby programming language, written predominantly in C++. The original Ruby language, otherwise known as Matz's Ruby Interpreter (MRI), is written in C. JRuby is another implementation written in Java. The promise of Rubinius was that it'd be truly thread-safe. The development was sponsored by Engine Yard, though I think that's over with now. I believe the biggest issue with Rubinius and JRuby is that they're constantly trying to catch up with MRI, so they're not a complete implementation of Ruby.
I've been using it recently. `rbx-2.3.0`, the latest release, is pretty much at parity with ruby 2.2's language features, sans refinements, I believe. It indeed does not have a GIL, so threads are actually spread across cores. In addition, most of rubinius is written in ruby, so you can read through the source code of most of the libraries. The only downside over MRI is the increased startup time. It takes projects longer to boot up. It's not as bad as jruby, though.
Just in case you weren't aware, JRuby added a "--dev" flag to substantially speed up start-up in development. It's not recommended in production because it tweaks some JVM properties to optimize start-up at the expense of later optimizations in a long-running app.
My understanding was that Rubinius was written in Ruby, at least as much of it as possible.
You're right. I got that wrong.
Ouch... print system("cat /etc/passwd")
What problems are you having with the compilation process?
Performance wise it will vary, the best way is to test it with your actual applications. In my case I'm running a test with a non crucial application. This application, even with some GC restrictions (= concurrent GC disabled due to a memory leak in the aws-sdk) is about 30% faster on Rbx 2.4.0 compared to MRI 2.1.4. 
&gt; memory leak in the aws-sdk Do you have any additional info about this? I'm trying to track down a memory leak myself and wonder if this is the culprit. 
A simple 2-player game of tic tac toe in about 15 lines or something like that.
how far could this go
Let's not. 
I've switched over to Puma + RBX in most of my web projects. The two pair together well. Startup time is the only big issue. And that's not that big of an issue.
https://github.com/rubinius/rubinius/issues/3205
The April 1st holiday creep is worse than Christmas creep it seems.
Hey, I would use this so I can confuse all my friends. More serious, I wonder how viable this is to non-programmer, they still have to decipher the symbol no matter how straightforward it is. And it's more taxing on the eyes too.
Beautiful. Once I heard you could do this in Swift, I figured it was only a matter of time before it popped up in other languages. I assume this only works on Darwin systems? Edit: Er, I guess since they're in Unicode it would *work* it just might not be capable of rendering on whatever program shows your code.
*emoji database column names*
Uhh... You can do this in any language that supports UTF-8.
I'm not saying he *should* get shot for this, but if he gets shot, we have a resonable guess as to why.
So long as you've for an editor that'll use an appropriate font.
&gt; The file is encoded as ISO-8859-1 Thanks a tonne. That's clearly the helper I needed in this particular case. Does leave me interested in the potential to exploit in the bigger picture. 
http://robots.thoughtbot.com/mygem-configure-block
I am using Pry; I know it prints the evaluation of the previous statement. But I was proposing this as this looked very expressive. But as stated before, I am violating some principles in programming doing this, typical Single Responsibility principle. So, yes; this is a bad idea.
Thanks, I understand the mistake of adding the capability to object.
I'm talking about testing the end point itself (as the API owner, like if I was 'Twitter'). I've done exactly what you're talking about on the client end. 'You're right about the distinction between unit / integration being somewhat useless (everyone has different definitions). 
Just to add on to u/thisisseriousmum 's comment. As odd as it might seem all operators actually are method calls. In the case of adding two numbers it's integerObj.+(integerObj) 
It works fine, thanks for asking!
You'r sure you are working on a gem? What you describe, is exactly the job of a [gem](https://rubygems.org).
Ruby will continue to improve incrementally but there are no revolutionary changes coming as far as I know in MRI. JRuby, on the other hand, with the upcoming Truffle backend look like they may bring some truly astonishing speed increases. http://www.chrisseaton.com/rubytruffle/cext/ (Links to previous Truffle blog posts are further down)
One problem is that the underlying stdlib classes are written in often non-DRY ways. For instance, in Hash, [#[]](http://www.ruby-doc.org/core-2.1.5/Hash.html#method-i-5B-5D) and [#fetch](http://www.ruby-doc.org/core-2.1.5/Hash.html#method-i-fetch) are two entirely different methods, neither calls the other. At least in MRI (and it's probably not spec'd whether they have to be or not). So say you over-ride one for your custom hash behavior, oops you forgot to over-ride the other one, your custom Hash sub-class now has inconsistent behavior (which maybe you meant and maybe you didn't). (And if some non-MRI implementation doesn't implement like MRI, but instead say implements `[]` to just call `fetch` -- then it's going to get inconsistent behavior with MRI if someone sub-classes Hash and only over-rides one of those methods and not the other). OP is worried about a similar problem with `#delete` and `#delete_if`. If Hash offered an API where it told you "Here is a method that's always called for deleting things, if you want to override deleting things, override this method, all other methods that delete things will always call this one in base Hash" -- then it'd be a lot easier to be confident in your Hash sub-class having consistent behavior. 
I really want to see it! I'm curious. 
 - Converted my wife's blog posts from typepad to wordpress automatically. - High frequency performance monitoring scripts (nice, easy to use but robust networking capability) - Pulling project management data via rest and generating reports for PCI compliance and release reports - Feeding store location and inventory via cloud storage using a ruby gem Basically, ruby is a real sweet spot for scripting and automation because the language itself is concise and let's you write in a 'script-ish' manner but still have access to tons of great consumable gems. I don't know what it is, but ruby gems are the most consumable form of libraries I've ever run accross. I don't know what the special sauce is but from having a need to finding a gem to getting it up and running it is almost always a joy. Quite the opposite of what I've found in the C/C++ and Java world. 
That is quite helpful thank you. EDIT: Moving along with this... in the example you gave, if I wanted to add an "add_task" function in the List class, and call add_task, I would do something like list.add_task (text). But I don't want that functionality in the View right? So I need a controller to create the new list and I'm back to needing to pass values between classes and not knowing how.... class List def initialize @list = ["grapes", "peas"] end def values @list end def add_item @list &lt;&lt; Item.new end end class Item def initialize(text) @item = text end end class View def render list = List.new puts list.values end end class Controller def initialize @console = View.new end def user_input case ARGV[0] when "list" @console.render when "add" **What do I do here?** end end end controller = Controller.new controller.user_input I don't want to put @console.add_item because then I would have to put that functionality in the View. I can't put @list.add_item, because my Controller doesn't know what @list is, because I'm defining @list in my View. 
Woah 
Who is the interviewer? He seems to be quite involved in Ruby development, but I don't know who he is...
It seems to me that the real issue here is adding stuff to an array on access. Really? A getter that causes state change? Is that ever a good idea? And just appending stuff to an array on every access without ever removing it.. Subclassing Hash is fine if you're just adding methods. if you're overriding basic methods like #[] in ways that cause memory leaks, it's just poor coding. You certainly can't generalise from that that subclassing is bad.
AKA the creator of Rubinius. Lots of stuff making a lot of sense now, thanks!
Thank you, it's really helpful
Try this: http://rubylearning.com/satishtalim/tutorial.html 
If you want a better all-around feeling, and a good time as a bonus, I'd recommend Why's Poignant Guide to Ruby. http://mislav.uniqpath.com/poignant-guide/ It's funny, basic, and shows a lot of how to pass information around and do stuff with it.
coding is something that must be practiced. its like learning to play an instrument or learning how to paint. the only cure for your issue is more practice.
I like learning to play
As well as RHEL/CentOS 7, please remember us enterprise guys that love us some ruby ;)
In terms of methods themselves, much of that comes from learning how to read the documentation. There are so many methods (and classes!) that it's not at all worth it to try to memorize them. Beyond that, here are a few things you'll see in most (if not all) programs: 1. Output. If your program run in the terminal, it'll usually be with `puts` or `print` 2. Variable assignment. 2. Input. If you're using the terminal, `gets.chomp` is your friend 3. Figuring out the the *class* of something. `.class` is your friend. 3. The basic math operators: `+ - * / %` 6. If statements (and conditional logic), which in turn require you to know how to use equality and relational operators (like `==`, `!=`, and `&gt;=`) 7. `while` loops and iteration 8. Arrays 9. Hashes 10. Writing your own classes and instantiating your own objects The biggest thing that my students struggle with is not knowing the type (the class) of a piece of data. When I do development, most of what I use are strings, booleans, integers, floats, arrays, hashes, and objects/classes of my own creation. This isn't exhaustive, but that's most of it. The error that I see my students making (and that they eventually learn to correct before I intervene) is treating an array like it's a hash, or treating an integer like it's a string, or.... In lieu of taking a class, what I'll suggest is that you make use of a good book or two. I really like [Chris Pine's book on Ruby (available for free online)](https://pine.fm/LearnToProgram/), but it's not the only one out there, and it might not be the best one for you (though I'm sure that it'll cover most of your questions here).
That's because you called `fetch` wrong, it's a method, you call it with parens. h.fetch(:baz) But you're right you get an error there, but it's a `KeyError: key not found: :baz`, not an `ArgumentError: wrong number of arguments`. But `#[]` could still be written in terms of `#fetch` but it'd have to be something like this (not sure if this is actually right, just pointing in the basic direction). def [](key) if self.default_proc self.fetch(key, &amp;self.default_proc) else self.fetch(key, self.default) end end Something along those lines, although in MRI stdlib it would presumably be done in C, not ruby. But `#[]` could still be written in terms of `fetch`, such that over-riding `fetch` would effect the behavior of `[]` as well. But it is not. 
Woah indeed! very impressive.
Interesting. I've been using [Hashie](https://github.com/intridea/hashie) these days, which is written in terms of Hash sub-classes. Of course, here the intention is to have something that really is a Hash, and has all the behavior of a Hash, _plus_ more. Before using Hashie, I/we (in a separate unrelated project; I'm not a Hashie committer) tried doing this without sub-classing Hash. To have something with all the behavior of a Hash without sub-classing, we tried using stdlib DelegateClass. It has been _really_ difficult to get right, with some really unpleasant new behavior in ruby 2.1, resulting from DelegateClass's new use of BasicObject. https://bugs.ruby-lang.org/issues/10564 If I'm understanding your links right, the main objection to sub-classing Hash is performance. I think I'm not too alarmed, for my uses performance probably doesn't matter, but who knows. (Certainly if I was writing the `rack` library, as in one of your examples, performance would be a higher priority). If you compared sub-classing Hash to using it via DelegateClass, I don't know if the performance would be any different either. For that matter, if the performance is vs a plain Hash (implemented in C), you'd have to compare it to the performance of a pure ruby object that is somewhat similar to Hash but doesn't try to mimic it completely by sub-classing, too. The conclusion most people seem to have is "Well, just _don't_ try to provide something that is just like a Hash but with added behavior, just don't do that." But that's pretty sad, why is that something you ought not to be able to do? It seems a reasonable thing to me, which is very easy on developers using the class -- oh right, I can use all my existing knowledge about what you can do with a hash, and do any of those things, plus these few new powers added. 
Mutation and this sort of thing is why I have been drifting away from Ruby and toward Elixir. Even if your own code is perfect, the entire Ruby codebase and gem codebase is riddled with these sorts of assumptions.
Ah, you have to set it up in advance by doing a `lame = D.instance_method(:lame)` in scope. Yeah, it's a neat trick, but not too useful for anything. People of course do something similar with `instance_eval` for DSL's, in a way that is somewhat more useful, and has become quite popular -- but which has tripped me up so many times that I'm kind of cold on it too. 
Any particular reason why you're starting with Ruby? Not that Ruby is necessarily a bad first language or anything, but this: &gt;There just seem to be so many methods and ways to do things it almost feels overwhelming which me even further. is why I normally recommend starting with Python. They're similar languages both in syntax, features, and community support (package managers, etc), but a large stylistic difference, IMO, is that Python generally has "one true way" to do something while Ruby gives you several options. Other than that, what everyone else is saying - learn by doing. Play around with the interactive shell (irb) and hack together some scripts. 
 **What do I do here?** The answer is always the same: send a message to another object. That's all there is ever to do in Ruby, it's all about objects sending messages to other objects. This means your object has to somehow know about the other object that it wants to talk to (objects that talk to each other are called "collaborators"). For example, your controller object knows about a view object because it created it. That's one way an object can know about another object. Another way is by passing an object as a reference when creating another object, like you do with your `Item` class: when you create an item object, you pass it a `text` object as an argument, which it then stores in an instance variable and thus has a reference to it, which it can use later to send messages to that `text` object. There are other, more complex patterns for connecting objects together, but understand that this is all it is: objects need to know about other objects so that they can send them messages. It is considered good practice when creating an object to pass it references to all the objects that it needs to know about. In your `initialize` method, store these references in instance variables. Then in any other method you can call on these objects to do work for you.
If you want one-on-one help, you're welcome to email me with any problems you're struggling with and I can help answer them. You're probably not as far off from understanding as you think, and with a little help over the hump, you'll get it.
I often recommend anyone learning ruby to start with http://rubykoans.com/ And progress from the koan to building kata's. Something like http://en.m.wikipedia.org/wiki/Fizz_buzz It gives you a focus and a goal, might work for you so your not overwhelmed. 
Seems to me that your students are on the right track treating an integer Luke a string. The missing part is to call "to_s" in order to cooerce the input into a string if its not one already. 
Ruby is weird because its "duck typed". That means you don't care what type you're working with. You just care that it quacks (like a duck). What this means in practice is that if you expect a string, call "to_s" on the input and then treat it like a string. 
You are making that way too painful. Just add an add_task method to the List class that takes an argument. class List def add_task(task) @list.push(task) end end then you can do: my_list = List.new my_list.add_task("oranges") puts my_list.values 
Well Grounded Rubyist PDF: read it, re-read it. Do ALL the examples as you are going along. If you do an example and don't get it, do it again. And again. Have irb open the whole time you are going through it. irb is your best friend. 
Rubykoans is definitely legit, but I think it may be a bit overwhelming for someone JUST starting out. 
Thanks. You are right, I was trying to do too much at once instead of go simple and refactor. I appreciate the input. 
Thanks for that. You are right. :)
Oh yeah, I have that. I skimmed it months ago, but definitely will put more time into it. Thanks for the reminder. 
You can't compile Ruby, since it's interpreted rather than compiled. That's about it.
Are there any workarounds or solutions for this problem suggested for future iterations of the language, or it's too baked in to fix at this point?
It's not really a problem. Lots of languages—python, for example—are interpreted. People are trying to build AOT compilers for ruby, but it's hard. 
Ruby's never going to become a compiled language, if that's what you mean. There might be a bytecode intermediary at some point (you can dump bytecode, but you can't load it right now). If you want to make a reasonable effort to protect your source, don't use scripting languages.
Make something. Anything. This spring I've decided to learn C++ with a friend, and with no experience whatsoever we're making a chess engine. It's gonna be a complete mess. The code's gonna suck, the engine will suck, and it's all probably gonna go to hell quite a few times, because that's what happens when you have no clue what you're doing. *But we will learn a lot. Especially from all the mistakes we're bound to make.*
What makes building AOT compilers for Ruby hard?
Given that PHP, Ruby, Javascript, Python are all interpreted scripting languages, it's not a particularly unique problem, it seems. That basically just leaves Java, which has security problems out the wazoo : )
Yeah, that's an interesting point. I guess it's more a matter of which libraries and frameworks are available to counteract any future security issues. Basically, I am building a web app that will have a higher need for attack prevention than a typical web app. I'm leaning towards node but it's still unproven in that way.
A few things: 1. Stupid levels of polymorphism 2. ````instance_eval```` is stupidly hard to get right in a AOT context. Normal ````eval```` even more so. 3. ````method_missing```` is also hard to get right, although Obj-C does it pretty well 4. Something about Hashes in ruby is hard to do statically, I believe There's a lot more reasons, but those are the ones I can think of off the top of my head.
No more or less secure than Python or Perl. You still have to be careful about escaping/sanitizing user input and running commands. Developers have to be extremely careful when writing C extensions, because you're writing C! Ruby is lacking 100% signing of all rubygems, which makes it difficult to tell whether a new version really came from the author or if someone is Man In The Middling http://bb-m.rubygems.org/.
I believe @jjopm means the JVM or JRE.
Get familiar with the concept of "magic". You call a method some magic happens and it does stuff. Magic happens whenever you don't need to understand something, or if you don't want to right now. That lets you focus on the bits you actually care about right now. 
I hadn't heard of this one yet. I'll check it out. Thanks for the recommendation.
I think a lot of people "fail" in this because they just give up too early. Don't do that, it can take a while for things to click. The other advice is to find a mentor.
This is pretty off the security topic, but since you piqued my interest: to back up a little, would this be compiling Ruby to Objective-C through Rubymotion, or...?
Wow. Thank you. Means alot. I'll message you soon.
Hadn't thought of this. Being able to ask questions in person would def help. Thanks!
Don't skim it, do it. The explanations are solid and very, very in-depth. 
No problem, happy to help. 
For sure. The only reason I say that is because if you don't know any ruby and get like 30-50% through the Koans, you may start to have some serious "wtf" moments. 
On http://ruby-doc.org/ &gt;There was 1 Ruby vulnerability reports in the last 14 days. 1 high. Most recent: CVE-2014-6140 Yea.. not very secure. Their docs show the most recent vulnerabilities because they happen so often. I'd recommend another language that doesn't have such warnings like rust or go. http://doc.rust-lang.org/index.html https://golang.org/doc/
Thank you everyone for your responses. It really means a lot. I often get discouraged at the lack of progress I make and not understanding why my code doesn't work but your answers give me the support that I need to keep going :)
I agree, but it's kind of apples and oranges though. Rust and Go very much have the advantage of security by obscurity. Thanks for pointing out the regularity of vulnerabilities with Ruby. It's probably the most concrete answer I've gotten so far. Is the existence of 1 'high' vulnerability so out of the ordinary compared to other languages though as to throw red flags?
Made a sticky on my desktop. Thanks! :)
Rust and Go are also much younger languages. I don't really think that they're any more or less secure, just not as mature or transparent. Java, for example, also has frequent security issues. I don't think that there's anything that's bulletproof. Browsers, operating systems, hardware--they all have vulnerabilities. I'd say that the vulnerability reports are a plus, even if they sound scary.
Yes, there is an entire category of memory management bugs which are avoided by using a dynamic garbage collected language like Ruby. On the other hand, this is not unique to Ruby. Python, Perl and many other languages also have these advantages.
Rubymotion does do that, kinda, but it costs money. I was more talking about how Obj-C's method dispatch is the way to do heavy polymorphism in AOT languages. 
Are there any examples where any famous Man In The Middle attacks were documented as rooted in a Ruby issue specifically?
Interesting point, smix, though drawing attention to vulnerabilities in commonly used Ruby applications is a valuable metric for how secure the framework is as a whole arguably. Yeah, I wouldn't see Rust and Go as a be-all end-all fix for anything. But the security by obscurity argument is strong for now. The same reason there is little malware for Linux while there is a lot for Windows and some for Mac.
I was trolling, this is spot on.
There was a talk called [Hacking with Gems](http://www.everytalk.tv/talks/2126-Aloha-Ruby-Conference-Hacking-with-Gems) which demonstrates what malicious gems _could_ do. Any package manager that doesn't verify packages downloaded via HTTP/FTP is vulnerable to MITM.
I use [Ruby Encoder](https://www.rubyencoder.com/) to deploy Ruby code on untrusted machines, and it's locked down by MAC address, so folks can't just go in and grab the encoded source and run it on any other machine. [GitHub even uses it](https://github.com/holman/feedback/issues/345) for GitHub Enterprise.
&gt; Languages rarely have security issues. It's usually libraries and frameworks that tend to have issues. It seems to me that language choice can affect the difficulty of writing secure code. For example, in BASH everything is a command unless you take fairly extensive measures to treat input as a string. In C, buffer overflows seem to be a consistent source of software vulnerabilities, where other languages seem to do a better job of validating input against buffer size.
Security by obscurity is not a good principle to follow. Just do a little research and you'll see that no security professional takes that seriously. Also, if a language has frequent security issues being reported to an official list, that's often a GOOD thing. It means that there are a lot of people auditing the language and frameworks for security issues, and many obscure flaws are being fixed, which might have taken decades to discover in less vetted codebases. It very rarely means that the language developers are making lots of bad security mistakes. Ruby's security researchers are top notch, Rails is totally fine for any kind of web app. I spent 2 years working on a Rails payroll app that handles billions of dollars in payroll, and there are many ecommerce sites and Bitcoin exchanges that use Rails. Just follow the best practices, and do a lot of reading. Use devise out of the box with their recommend configuration, and don't change anything that you don't fully understand. If you're actually serious about having NSA or NASA levels of security and reliability, you should write your app in Haskell or Rust. These languages are not "more secure", but they encourage programmers to write code that is more secure and has less bugs.
Ruby doesn't have a decent taint system and unlike php you can't disable the dangerous parts for web apps.
There is one for the jvm, not jruby another one, I forgot the name of it.
Do read the post and check out the other subreddits featured folks :)
`instance_eval`, `class_eval` and `eval` all accept literal strings of Ruby code. This is a security issue if you don't properly sanitize user input that gets passed to any of these 3 methods. Generally you shouldn't use them to process any untrusted input. There was a tool posted to this subreddit yesterday that likely passed user input to `eval` from a web interface (run Ruby in the browser type app). The top comment on the post was someone passing in something akin to the following: `puts File.read('/etc/passwd')` *This dumps the contents of the webserver's `/etc/passwd` file which is not something you want people on your website to be able to see. http://www.reddit.com/r/ruby/comments/2p30wo/rubystub_runshare_ruby_online/ 
"I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question." I'm with ol' Chucky Babbs on this one.
Instance variables are prefixed with `@`; `grocery_list` in your example is just a regular variable. In Ruby, as in most languages, a variable is just a named piece of data, and you've presumably given it a name to later recall its value. Consider the case of asking the user for their name and complimenting them accordingly: print 'What is your name, user? ' name = gets.chomp puts name + ' is a lovely name.' Here, we store the user's input in the `name` variable, then later *reference* it to obtain its *value* to print our message. This all makes a good deal of sense, and I suspect you don't actually want any of the alternatives. That said, there are a handful of methods that actually do expose the names of variables for whatever devious purposes to which you might want to put such an ability, but I am almost certain that isn't what you really want in this case.
[InfraRuby](http://infraruby.com/live) is a statically typed Ruby compiler.
How would I be able to grab the variables name ? I've been trying to find it online
[InfraRuby](http://infraruby.com/live) perchance? ;-)
Would you mind providing an example of how you'd "store an array of variables" in Java?
Thanks for making us subreddit of the day. Cheers.
[&lt;seinfeld&gt;Get Out!&lt;/seinfeld&gt;](https://www.youtube.com/watch?v=02qmZyY8bI8)
Thank you for moderating /r/ruby. I remember the bad old days.
Thanks for being one of the best subscribers and brilliant rubyists around /u/postmodern! Give some credit to the other mods as well /u/jamesgolick and /u/petercooper who still help out!
I just didn't give up. Plenty of Rubyists are brilliant, we just never give their projects a chance or they leave Ruby for emerging programming languages where they can make their mark.
For anything you'd use sed or awk for, then when you reach projects that would have been perl you pick between this and Ruby based on the task 
FWIW, Matz has discussed removing the GIL for Ruby 3.0, which could help substantially. 
Hey FckingClown. One more great idea is to write down a list of technologies and the level of understanding per each technology. Write it on one sheet of paper, then go and put it in your sock drawer. Do not read it for another 3-6 months. After 3 months, open it up and you will be amazed at your progress.
I'm not sure if Roberto Ierusalimschy (creator of lua) speaks English natively or not, but I believe he does not.
Eiffel is French, obviously. 
Someone less polite might accuse you of being incredibly insular. My guess is that most languages weren't developed by native English speakers - Bjarne Stroustrup (C++), Anders Hejlsberg (C#), Guido Van Rossum (Python). Those are the major ones off the top of my head.
I'm going to get downvoted like crazy but you should look at Zed Shaw's [Learn Ruby the Hard Way..](http://learnrubythehardway.org/book/) It really is tailored for not just for the Ruby beginner but a programming beginner.. He emphasizes the beginner rigorously working their way through the process of programming, step by step: firing up an editor, typing in code, finding mistakes before running the code, read lines backwards to catch mistakes, etc, etc. He saves the Ruby idioms for last, because he believes it's much easier to teach generic programming to a total beginner to avoid getting lost. Give it a try. Of course Zed's zingers are priceless: &gt;Every programming language has some kind of way of doing numbers and math. Do not worry: programmers lie frequently about being math geniuses when they really aren't. If they were math geniuses, they would be doing math, not writing buggy web frameworks so they can drive race cars. 
Whoa, how can you see him from way up there on that high horse? The fact that he's asking the question shows that OP simply doesn't know. Please don't make people feel stupid for simply asking a question.
I get what you are saying, most of the more popular programming languages are only considered having "made it" once there is English developer use. I wonder if PHP would have been as popular/prolific as it is today had Rasmus Lerdorf stayed in Greenland.
Erlang, swedish.
Pascal, Modula, Oberon... c++... Come on!
How would you characterize it?
MacRuby is dead, RubyMotion is specifically only iOS/Android and isn't feature-complete (and last I checked, couldn't use existing gems), and Ruboto is just a set of Android bindings on JRuby. JRuby provides AOT compilation of individual scripts to Java class files, but those are reverse-engineerable in all the standard ways. RubyMotion does actually compile to machine code, but you can't build general Ruby apps in RubyMotion. The goal of "I have code and want to cross-compile it to distributable native binaries" is unmet and out of reach for the foreseeable future.
Lua was developed in Brazil
Granted, that's a good definition, but I think it's saying approximately the same thing: Right associative: (1 + (2 + (3 + 4))) [starts from the right] Left associative: (((1 + 2) + 3) + 4) [starts from the left]
&gt; The JVM is very different from x86-64 instructions. Yes, the Java classfile format requires static type information, which compilers targeting this platform must provide. &gt; Plus, not supporting reflection means there is little to no reason to use Ruby. As valid InfraRuby code is valid Ruby code, you can use reflection in your tests (say for mocking) and run your tests in a Ruby interpreter. &gt; Almost all the most popular frameworks make heavy use of it. The site at [http://infraruby.com/](http://infraruby.com/) runs on a framework designed for InfraRuby, which does metaprogramming before compile-time with s-expressions. No reflection is required at run-time in this framework. &gt; EDIT: Also, you need to add type annotations to the methods and classes. That gives you even less reason to use Ruby. The annotations are useful documentation! You can also use Ruby interpreters for development and write the annotations only when required. &gt; A real AOT Ruby, in my opinion, needs to meet the following qualifications: &gt; Support for EVERY feature of the language &gt; Uses dynamic typing or type inference You'd need to solve the halting problem to support every feature of the language with type inference. And without type inference, you'd need a Ruby VM to run the code, just as Ruby interpreters do. &gt; Compiles to an AST which you can translate into machine instructions on a variety of architectures You can compile Java bytecode to native executables, with Excelsior JET for example. 
Swiss ~~guy~~ professor Niklaus Wirth for Pascal, Oberon, Modula II, (direct descendants of Algol W).
Twilio developer evangelist here. Love this. Saw someone build something similar at PayPal Battlehack as a way for people who don't have access to a computer to write their first line of code. Sadly, she had to change it to more of a "programming quiz" because she knew she'd get pwned in roughly six seconds if she let the audience run evals on her server. It's always fun to see people use Twilio in unexpected ways and "Programming by SMS" is certainly not one of the use cases the founders had in mind when they started things up seven years ago. Much appreciate you taking time to do a writeup. 
There's a lot of good info in this thread. If you ever want to pair program to work through any problems you might have, just send me a message. I'm also currently a student in a seven month Ruby/Rails program, so I can answer questions you have about that as well.
I used ruby to post my current pianobar song to firebase. I thought it was kinda cool. It's the first time I've ever used ruby at all.
One issue not adequately addressed is that clever metaprogramming techniques in libraries have led to RCE (remote code execution).
Ugh, I just had flashbacks to Principles of Programming Languages.
Oke thx If i understood you right then you mean that i should write all what i do not understand on a sheet of paper and don't look on it for 3 months right? But how should this help? And what you mean with "technologie"&gt;Hey FckingClown. One more great idea is to write down a list of technologies and the level of understanding per each technology. 
FYI: You can see some live planet examples online - [Planet Ruby](http://plutolive.herokuapp.com/ruby), [Planet Javascript](http://plutolive.herokuapp.com/js) etc. Happy planet. Cheers. 
That's super nice of you man. I'll send you a PM
Matz seems so nice :)
If it must be a string then Duck Typing means "do nothing". to_s is just the generic "turn this into something presentable" method. If you want to make sure the argument is stringish then the only method to use is to_str. See also to_i vs. to_int.
But that's the thing, the evaluation of the operation happens always from the left. Folds always "start from the left". But they either continue to defer execution for their second argument or they begin evaluation. Thinking of it in terms of those two examples you just illustrated shows why it's possible to have a strict left fold but not a strict right fold. Something that is confusing and unintuitive if you think of them as just being "from different directions"
8 minutes in and he has yet to get beyond preschool math. Mind = not blown yet.
thank you for your response, what is your favorite database to use with ruby? 
I guess a better way to ask my question would be how would you guys try and solve this problem. My current thinking is that we should just assign ID tags to all of the cars with their corresponding information and than use the ID tags to then create the content that is on the page. My biggest hang up with that method is that its kinda dirty, meaning that we will have to know the cut offs of the numerical value of manufacturers. 
Sandi's book is just a brilliant piece of writing. Her written voice is unbelievable. There's only a few tech books I've read twice and POODR is one of them. Eloquent Ruby is also a good book but it sits more like a reference book for me (it's also longer). I don't think POODR could scale to be the same length and size. POODR (to me) is trying to distill the older books like Refactoring by Martin Fowler into advice and I think it does it. For me, POODR is solid gold. It's gospel. It's epiphany.
+1 The koans are great. They give you a little progress bar so it kind of turns into an achievement game. I did them even after a few years of Ruby and I learned something. I'd probably learn something today. Whenever I start a new language, I look for a koans project. It won't teach it to you but it will help on the journey.
&gt; 1.to_s.is_a? String =&gt; true to_s does return a string so you know you're working with a string. to_str returns the original object implicitly cast as a string (i.e. the object implements the string interface so you can use the object as a string). I suppose you are correct that if you want to validate that the input quacks like a string you would call to_str and use the original object in your method. I'm usually calling to_s in some sort of pretty printing method so I want to accept ints and arrays , etc... So, I've gotten lazy in my thinking and hadn't really considered that what I was doing wasn't really duck typing. It's good to stretch the old brain box every once in a while.
I liked this version best: def display(template) if protect_privacy? template.display_address(private_version) else template.display_address(self) end end Requiring the consumer of the API to *first* set the argument and *then* call `display_address` is not only annoying and requires documentation. It also couples two public methods of the template API together. I'd also rename `display_address` to `display` in order to keep the interface identical between different templates/renderers. You might want to wrap these template objects with general purpose objects, e.g. for caching.
Yeah, he's not gonna go beyond that. Skip to 25:30 for some code. He shows a way to implement Algebraic Data Types using Ruby.
Routes are a very important part of your application as it represents the expected state and therefore should be self-evident as to their purpose. domain.com/by-company/ford/2011 domain.com/by-year/2011/ford domain.com/on-sale/2011/ford domain.com/on-sale/ford/2011 See what I mean? Based on the rest of your questions it sounds like you're starting from square one and you've never developed a rails app before. Honestly I can't pinpoint the best location to start from because all these parts are inter-related. As a rough guess, look at your URL API (routes) and figure out the way YOU would want to navigate through your application by URL alone (avoiding parameters when you can). Then look up rails tutorials (there's a shittonne) on how to make it work. You can't understand everything before you start writing your first app, you just have to push through the muck. Point in case, don't try and make this app first, make a very basic app that you can screw around with. &gt; Do I want to have just one database? Unless you've got a super-massive application, yes. &gt; Do I need to be more concerned with active record? What do you mean "concerned"? You'll definitely be using it. Perhaps the biggest point to get across to a newbie with RoR is that whatever object you have inheriting from ActiveRecord, that object requires a table in the database and the columns in that table map to attributes belonging to the object. Rails very much leans on conventions as assumptions (singularization/pluralization of models/collections for example). Tutorials/videos? Look at http://railscasts.com/. It's not active but there's a lot of good stuff in there; not necessarily about the basics, but useful nonetheless.
I just started taking a Web dev program. I think something like php is probably easier to learn first off, at least was for me. I just started learning ruby, it's a completely different beast all together. 
I don't know if this is what you are looking for If variable.present? Code here end
I agree, thanks! I wrote this to point out how my cleverness and desire to move quickly lead to some buggy code.
By 5 minutes in more than a dozen awkward jokes are made. By 10 minutes in, he's basically put down java, javascript, perl, and PHP without actually making any kind of good point. He also intimates that anyone who believes in using the right tool for the job is basically making an excuse not to join a conversation which is utter bullshit. By 15 minutes in, I just shut it off so I didn't have to suffer through more memes. Sorry, but this talk is just rambling shit.
Exact same reaction, hit stop at the 14:48 mark. Was interested in hearing about ruby's growth in non-web domains, but instead heard a bunch of cat jokes that were lame even by cat joke standards.
Tl;Dr I don't care if people eventually stop using Ruby, because the best feature of this language is its community 
I figure that's exactly what awaits ruby after Rails. And I'm a Rails hater. I wish there was more to Ruby.
If you are interested in ruby for not web-stuff (or for web stuff, but not rails/sinatra/grape) just check out Avdi Grimm's talks, tapas, and blogs (he's certainly not the only one, but one of the more popular, and easily searchable names). Ruby has been big in configuration management / devops space as well, you could look into that. Then there is jruby which is a godsend if you are in an organization that stresses "java java java!" There's way more to ruby than just rails.
I wonder a slight bit of the slow down with Raptor has anything to do with testing it with: &gt; Raptor's turbocaching disabled
ML typesystem master-race. Ruby, where's your method_missing/instance_eval-devoid fork with a compile-time typechecker?
looks good. the flexibility in presentation is a nice touch. i take issue with the word "planet" for tools that only read RSS/Atom, as it implies a globality which would include other sources, from email (RFC2822..) messages, to forum/messageboard threads which might be on the web (HTTP/HTML..) or USENET, new blockchain-based protocols/apps popping-up by the day, to classics like Internet Relay Chat. check out SIOC, from DERI or whatever theyre called now. it's a decent schema to describe these messages in both specific (this is a ForumPost) to generic (this is also a plain-ol-message). with this structure in place you can dispatch to domain-specific UIs when desired and also have a global merged view
Jokes aside, though my experience is still rather limited I found that the Japanese community (with notable people such as nobu, ko1, and matz himself) for better or worse is different from the English-speaking one. Not making a comparision here, but Japanese devs are generally humble, not very vocal and keep to themself IMHO.
thanks for this! 
Why not def display(template) template.display_address(protect_privacy? ? private_version : self) end ?
When in the middle of long refactorings, I'm notoriously terrible at going back and removing deprecated code. So, I made a gem that allows me to mark somewhere in the code to self destruct on a particular date. Prior to that date, you will see warnings in your test suite letting you know when and why the self destruct mechanism is there. After the date, it will start throwing exceptions in your test environment to basically self destruct the build. So far, it's been a great incentive/reminder to go back and clean up after myself.
I think this would probably be an example of the 'strategy' pattern. http://en.wikipedia.org/wiki/Strategy_pattern
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Strategy pattern**](https://en.wikipedia.org/wiki/Strategy%20pattern): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), the __strategy pattern__ (also known as the __policy pattern__) is a [software design pattern](https://en.wikipedia.org/wiki/Design_pattern_(computer_science\)) that enables an [algorithm](https://en.wikipedia.org/wiki/Algorithm)'s behavior to be selected at runtime. The strategy pattern &gt; &gt;* defines a family of algorithms, &gt;* encapsulates each algorithm, and &gt;* makes the algorithms interchangeable within that family. &gt;Strategy lets the algorithm vary independently from clients that use it. Strategy is one of the patterns included in the influential book *[Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns)* by Gamma et al. that popularized the concept of using patterns in software design. &gt;For instance, a class that performs validation on incoming data may use a strategy pattern to select a validation algorithm based on the type of data, the source of the data, user choice, or other discriminating factors. These factors are not known for each case until run-time, and may require radically different validation to be performed. The validation strategies, encapsulated separately from the validating object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication. &gt;The essential requirement in the [programming language](https://en.wikipedia.org/wiki/Programming_language) is the ability to store a reference to some code in a data structure and retrieve it. This can be achieved by mechanisms such as the native [function pointer](https://en.wikipedia.org/wiki/Function_pointer), the [first-class function](https://en.wikipedia.org/wiki/First-class_function), classes or class instances in [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) languages, or accessing the language implementation's internal storage of code via [reflection](https://en.wikipedia.org/wiki/Reflection_(computer_science\)). &gt;==== &gt;[**Image**](https://i.imgur.com/u1YFX3E.png) [^(i)](https://commons.wikimedia.org/wiki/File:Strategy_Pattern_in_UML.png) --- ^Interesting: [^State ^pattern](https://en.wikipedia.org/wiki/State_pattern) ^| [^Behavioral ^pattern](https://en.wikipedia.org/wiki/Behavioral_pattern) ^| [^Policy-based ^design](https://en.wikipedia.org/wiki/Policy-based_design) ^| [^Strategy](https://en.wikipedia.org/wiki/Strategy) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cmxok66) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cmxok66)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; There’s something about changing the signature of a class just for tests that didn’t feel natural. That probably bothered you, because you instantiated your objects very close to their usage. If you really embrace dependency injection you split the usage of an object and its construction far apart. So, changing the initializer would only impact the code where you construct your objects. For the same reason I wouldn't use default arguments: You basically mix object construction with object usage. They are pretty useful while refactoring a large codebase to a more loosely coupled approach, though.
I *love* RubyTapas. It is absolutely worth the $9/mo subscription.
There is this [magic square algorithm](http://rowdy.msudenver.edu/~gordona/cs1050/progs/tictactoermccsc.pdf) that you can probably use for the game checker. If you use that, the game checker would have enough responsibilities to be its own object. But, if you just want to simplify you current code, I think if you implemented a method like check_winner('x') that checked for a winner of type 'x' or 'o', you would have to check for blanks. I would go further and have a hash with the winning combinations. Something like: wining_combos = { top_left_to_right: [1,2,3] , middle_left_to_right: ... } and then use reduce or each so that we dont have the if else block full of this stuff @grid['1'] == @grid['2'] &amp;&amp; @grid['1'] == @grid['3']) &amp;&amp; (@grid['1'] So you could go from def game_checker if ((@grid['1'] == @grid['2'] &amp;&amp; @grid['1'] == @grid['3']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['2'] != ' ' &amp;&amp; @grid['3'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['4'] == @grid['5'] &amp;&amp; @grid['4'] == @grid['6']) &amp;&amp; (@grid['4'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['6'] != ' ')) end_game=true victory=@grid['4'] elsif ((@grid['7'] == @grid['8'] &amp;&amp; @grid['7'] == @grid['9']) &amp;&amp; (@grid['7'] != ' ' &amp;&amp; @grid['8'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['7'] elsif ((@grid['1'] == @grid['4'] &amp;&amp; @grid['1'] == @grid['7']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['4'] != ' ' &amp;&amp; @grid['7'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['2'] == @grid['5'] &amp;&amp; @grid['2'] == @grid['8']) &amp;&amp; (@grid['2'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['8'] != ' ')) end_game=true victory=@grid['2'] elsif ((@grid['3'] == @grid['6'] &amp;&amp; @grid['3'] == @grid['9']) &amp;&amp; (@grid['3'] != ' ' &amp;&amp; @grid['6'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['3'] elsif ((@grid['1'] == @grid['5'] &amp;&amp; @grid['1'] == @grid['9']) &amp;&amp; (@grid['1'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['9'] != ' ')) end_game=true victory=@grid['1'] elsif ((@grid['7'] == @grid['5'] &amp;&amp; @grid['7'] == @grid['3']) &amp;&amp; (@grid['7'] != ' ' &amp;&amp; @grid['5'] != ' ' &amp;&amp; @grid['3'] != ' ')) end_game=true victory=@grid['7'] else end_game=false end end To something like: wining_combos = { top_left_to_right: [1,2,3] , middle_left_to_right: ... } def check_winner(string) winning_combos.each { some_logic_here } end
I'm a big fan of Struct. Usually with a mixin that allows conversion from/to a hash for dealing with APIs.
that's certainly an option
I sense an IOC container about to show up in this discussion.
I'm surprised he didn't mention if you're looking for this openness just use send, or alternatively `method("foo_#{bar}").call(*args)`. wild = some_method(arg_2) || "bar" Foo.send("a_#{wild}_variable", arg_1, arg_2) And a few others, meta-programming is a breeze in Ruby. EDIT: I did a comparison to add a regular class to his benchmark, and was surprised that `OpenStruct`was noticeably slower class Poro def initialize(hash) @hash = hash end def foo @hash[:foo] end end hash = {foo: "bar"} open_struct = OpenStruct.new(hash) poro = Poro.new(hash) Benchmark.ips do |x| x.report("openstruct") { open_struct[:foo] } x.report("hash") { hash[:foo] } x.report("poro") { poro.foo } end Calculating ------------------------------------- openstruct 88.832k i/100ms hash 96.972k i/100ms poro 93.802k i/100ms ------------------------------------------------- openstruct 4.402M (± 8.0%) i/s - 21.853M hash 6.798M (± 9.0%) i/s - 33.649M poro 5.493M (± 9.8%) i/s - 27.203M # And because I wanted to make sure this ips gem wasn't affecting results nu = 1000000 Benchmark.bmbm do |x| x.report("openstruct:") { nu.times do ; open_struct[:foo]; end } x.report("hash :") { nu.times do ; hash[:foo]; end } x.report("poro :") { nu.times do ; poro.foo; end } end Rehearsal ----------------------------------------------- openstruct: 0.140000 0.000000 0.140000 ( 0.145523) hash : 0.090000 0.000000 0.090000 ( 0.085952) poro : 0.130000 0.000000 0.130000 ( 0.133351) -------------------------------------- total: 0.360000sec user system total real openstruct: 0.170000 0.000000 0.170000 ( 0.181935) hash : 0.080000 0.000000 0.080000 ( 0.080910) poro : 0.120000 0.000000 0.120000 ( 0.115121) EDIT x 2: Or maybe not if you're looking at meta-programming options Benchmark.bmbm do |x| x.report("openstruct:") { nu.times do ; open_struct[:foo]; end } x.report("hash :") { nu.times do ; hash[:foo]; end } x.report("poro :") { nu.times do ; poro.foo; end } x.report("poro.send :") { nu.times do ; poro.send("foo"); end } x.report("poro.meth :") { nu.times do ; poro.method("foo").call; end } end Rehearsal ----------------------------------------------- openstruct: 0.170000 0.000000 0.170000 ( 0.167534) hash : 0.090000 0.000000 0.090000 ( 0.088693) poro : 0.120000 0.000000 0.120000 ( 0.131595) poro.send : 0.360000 0.000000 0.360000 ( 0.354307) poro.meth : 1.290000 0.010000 1.300000 ( 1.310588) -------------------------------------- total: 2.040000sec user system total real openstruct: 0.140000 0.000000 0.140000 ( 0.142723) hash : 0.090000 0.000000 0.090000 ( 0.089221) poro : 0.110000 0.000000 0.110000 ( 0.116475) poro.send : 0.340000 0.000000 0.340000 ( 0.337984) poro.meth : 1.390000 0.000000 1.390000 ( 1.415328) Benchmark.ips do |x| x.report("openstruct") { open_struct[:foo] } x.report("hash") { hash[:foo] } x.report("poro") { poro.foo } x.report("poro.send ") { poro.send("foo") } x.report("poro.meth ") { poro.method("foo").call } end Calculating ------------------------------------- openstruct 91.527k i/100ms hash 97.315k i/100ms poro 93.841k i/100ms poro.send 70.153k i/100ms poro.meth 38.923k i/100ms ------------------------------------------------- openstruct 4.381M (± 8.3%) i/s - 21.783M hash 6.931M (± 7.8%) i/s - 34.450M poro 5.565M (± 8.8%) i/s - 27.589M poro.send 2.324M (± 8.5%) i/s - 11.575M poro.meth 669.851k (±13.4%) i/s - 3.308M 
Struct is awesome, and I prefer it over most things when I can. What would be even more awesome: keyword-based constructors, i.e. Post = Struct.with_arguments(:title, :body) Post.new(title: t, body: b) 
Compare and contrast. Open Struct: https://github.com/ruby/ruby/blob/trunk/lib/ostruct.rb Struct: https://github.com/ruby/ruby/blob/trunk/struct.c Struct is written in C where as Open Struct is written in ruby and implemented via method missing (slow). While you can do what they mentioned via open struct, the problem is you get even more, too much you could say. Sometimes less is more. Struct is one of those times.
no, sorry for not being clear, but the the point is being able to get an error if I mistype a keyword, which I can't do (by design) with OpenStruct, and the default struct with only position arguments gets very messy with a few fields.
Well, there's not much difference between my idea of "dependency injection using a constructor" and yours. I would've implemented it the same way. I was mainly focusing on the caller side of your code (which you haven't shown if I didn't miss anything). For example: class ServiceA def initialize(some_dependency=SomeClass.new) end end # within some other class service = ServiceA.new result = service.foo The only purpose of the constructor seems to be for testing. This is useful to some extend, but it doesn't fix any of the actual problems this solution has. Namely: It breaks the Dependency Inversion and Open/Closed principle, because you have to touch `ServiceA` every time its dependency changes. To fix this you'd inject _everything_ and avoid global constants (`ServiceA`, `User`, ...) altogether. So you would instantiate all dependencies at the entry point of your application and build one big object graph. Rails makes this impossible, though, since you have no control over the instantiation of controllers. You need to rely on global constants at some point. That's where IoC containers might come in handy. Sinatra on the other hand gives you full control over its instantiation.
I mentioned it in my response. Self fulfilling prophecy? We'll never know...
Hope it was helpful!
"mind blowing" as in seeing math and abstraction *as if for the first time*.
There's no difference in this case. Using the "#{x}" form is usually just used because its easier to add to later, just a matter of taste.
Whoa, exciting! Can't wait to hear more about this!
It wouldn't matter even if they weren't strings. Both puts and interpolation via `#{}` will use `#to_s` on the object if it isn't a string.
I'm glad you like it :) I'm using Opal to compile the Ruby int Javascript. If you haven't seen it yet, you can try [Opal in the browser](http://opalrb.org/) on their site.
Something like Github Flavoured Markdown would be cool to have in a forum.
How much time to you have available? I mean, a complete forum with web UI, login and the basic functionality you mentioned is already quite a bit of effort if you want to do it from scratch.
&gt; Novice programmers will look at this post and come to the conclusion that one should never use Hashie No, they will (should) conclude that Hashie is more expensive (5% perf penalty, ouch) than using simpler data structures. Maybe they'll remember KISS and hopefully will decide to be lean by default and not introduce unnecessary dependencies and bloat into their applications. Besides performance, there are other benefits of being "frugal" - easier testing, less complexity, simpler maintenance. So I love posts like this, they remind us Ruby-ists to be more "environmentally friendly" (create less memory garbage).
Cool idea. Reminds me of the '[Tombstone](https://github.com/lewispb/tombstone)' pattern but more aggressive.
Is the question, what is the difference between 'this' and 'that' or why does codeacademy say use 'this' instead of 'that'? Codeacademy is making you think about the output. Ask yourself what is the context. Are you outputting some message to yourself, your co-workers, a user of your gem or a command line user? Then, ask yourself whether x.to_s is the message you want to convey or maybe "Unsupported language: #{x}". In the rubinius source you can get an idea of what the puts Kernel method might do if it was C. https://github.com/rubinius/rubinius/blob/master/kernel/common/io.rb#L1776
Is there an online demo?
I just got my first RubyMotion app approved on the iOS App Store yesterday. There were a lot of moving parts with the application so it took about a month to create, and this is coming from a seasoned Ruby developer. To date, I have not found any limitations that you simply cannot do in RubyMotion that ObjectiveC/Swift provides. The application that I built is powered by a Ruby on Rails application with an Open API. The purpose of the iOS application is to provide a native mobile interface to certain functionality. The iOS Application is a softclock for employees to Clock in and clock out. It uses geofencing to ensure that they are only able to clock in and out within specified locations. A few of the features that I've built are: - Persistent Application Settings - Database Store/Retrieve - ViewControllers with Interface Builder - ViewControllers without Interface Builder - GPS Interaction (tracking user location) - GPS Haversine (calculating distance between two GPS Coordinates) - MapView - Displaying and Following User Location - MapView - Displaying list of points - HTTP GET/POST - Camera View (Taking employee picture when punching) - WebView - Source being an Endpoint URL - WebView - Source being HTML data from Open API See one of my earlier posts regarding my initial experiences with RubyMotion: http://www.reddit.com/r/ruby/comments/2ls3w9/rubyists_w_ios_experiencewhat_was_the_biggest/cly40lg As gensyms said, knowing Objective-C does help as the documentation is abundant in this. If I were to give one and only one piece of advice, it would be to stay away from Storyboards. Using the Interface Builder is fine for creating XIBs for each view, but do not use it for Storyboards. Things start to get complicated. Android ====== I've started to play around with the android development side of things. The documentation so far is less than par. The gems are practically nonexistent. Having developed some Android applications in the past, I have a good understanding of the lifecycle of activities and that definitely helps. Translating the Java documentation into a Ruby equivalent is similar to Objective-C with the exception that Objective-C ruby equivalent code is more object driven whereas Android ruby equivalent is more module driven. What I mean by this, for example, is that creating a WebView on the two platforms will have a ruby equivalent of: Objective-C @webview = UIWebView.alloc.init Java @webview = Android::Webkit::WebView.new(self) 
&gt; .. why? Because the point of the article was how best to add methods to a hash, or get the functionality of a hash in an object. So everything in the article is wrapping a hash. Here it's only done trivially to benchmark.
pry makes stupid thing loading all plugins automatically (see https://github.com/pry/pry/blob/master/lib/pry/plugins.rb#L70). I repeat: it's just stupid and I can't understand why someone thought that plugins should be loaded in that way. Adding couple of manual "require 'my-awesome-pry-plugin'" is so hard? Really? If you use bundler there should not be a problem. Just replace pry-nav with pry-byebug and it should work. If you don't use bundler (just regular gem) then you have to manually uninstall pry-nav gem. Did I say automatic plugins loading is just stupid?
I think that makes sense. Someone else pointed out that "user" isn't related to this Billing class necessarily, it's necessary for the "Usage" class. So from that, I'm guess you're saying instantiate "Usage" with whatever dependencies it has outside of the "InvoiceCreated" class and then pass that already instantiated object in?
Great idea! I got a live demo of the completed tutorial set up here: http://nicklink483.github.io/dare/tutorial.html
Thanks for all this info. Do help a lot!
RubyMotion is superb on iOS. It's fast, easy, and you can use all your Ruby knowledge, and even use Rails-style layouts for MVC, specs, and assets. As others mention, there's a little learning curve for Objective-C syntax, and a steeper learning curve for Apple's Cocoa libraries if you're doing any kind of typical UI/UX. Use the RubyMotion console for your learning to try your code live. I personally like terminal tools, such as emacs and rake. If you prefer GUI tools, Apple XCode Interface Builder is friendly and good for drag-and-drop UI and wiring, and it works with RubyMotion. For testing, I suggest supplementing RubyMotion with Apple Instruments, or a third-party testing tool such as Appium. The RubyMotion built-in testing tools are good enough for unit testing, and some functional testing, whereas Instruments is much better for profiling and benchmarking. The environment beyond RubyMotion can be a bit bumpy, in my experience. For example, Apple developer publishing has a bunch of steps for certificates, signing, submission to the app store, etc. Another example, various libraries aren't as well-documented or quite as stable as their pure-Ruby counterparts. The RubyMotion team is 100% solid, and responds quickly to questions and any iOS updates. They publish a gem called BubbleWrap that handles many common needs, and can get you up and running quickly, especially if you're using the console. One piece of advice I wish I'd known when I started writing with RubyMotion: look at Clay Allsop's body of work. He's a RubyMotion expert, and his gems and posts are top notch. http://clayallsopp.com/ 
Performance was only half the point of my post. While it is SUPER slow. My biggest point (which I guess didn't make it through in the article) is that hashie does too much. Its interface lends itself to common bugs that will increase your dev time, testing and continuing support in the long run. Adding hashie into your project is ADDING tech debt. I've never talked to a Ruby dev who used hashie on a project and was truly happy with it a year later. Hashie is a big ball of [YAGNI](http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it). &gt; We are well aware that it can be a bottleneck at times But are you aware of ALL the edge cases and new interfaces your code now supports by introducing hashie? &gt; custom OpenStruct inherited PORO Maybe you missed the part where I said not to do this either. OpenStruct is really slow. Use a PORO minus the OpenStruct inheritance, faster and with less interface ambiguity. ## Novice Programmers and Prescriptions If no novice programmers ever use hashie in production, i'll be happy. By nature of them being novice they don't have the tools to decide and come to a conclusion on this topic. Why? What i'm doing is being prescriptive. I'm making a sweeping statement like "never stick your hand into a running table saw". Are there times when that action is appropriate? Maybe, but smart people will figure out when to do that. ## TLDR If you knew me, you would know I don't make these types of statements lightly. You really shouldn't use Hashie unless you know the risks, understand performance penalties, and understand the importance of minimizing interfaces in objects.
&gt; the point of the article was how best to add methods to a hash PLEASE NO The point of the article was that adding methods to a hash is a bad idea. You shouldn't do it. Bad interface, bad performance, bad everything. If you need methods wrap it in an PORO like /u/slvrsmth's example above. Thanks for reading and writing up the benchmarks. Always question everything (and benchmark everything)!!! 
I started a similar thread a few months ago and got some great responses that you might also find useful: http://www.reddit.com/r/ruby/comments/2hvec8/is_rubymotion_suitable_for_client_work/
I hear what you're saying with pry-nav and bundler. But imagine projects at different states. One assumed .rvmrc, another assumed .versions.conf. Some others are stuck at Rails 3.2. Others need specific versions. The new problem now is, you'd need to remove pry-nav from those old projects and then commit that. I'm not saying it's impossible. I'm just broadcasting this because I know people run into this ... no one talks about it.
No need to break out the all caps &gt; the subject of the article was wrapping a hash. The point was how best to achieve a functionality similar to adding methods to a hash Better? The point wasn't to summarize your article, it was just to explain why I was wrapping the hash. Unlike /u/slvrsmth who doesn't wrap the hash but is copying the values to variables. Which would make the point of your article "If you need to wrap a hash in an object don't wrap the hash in an object. Use a Ruby class." Which wouldn't provide much guidance for someone who in fact does need to wrap a hash in something.
Using Hashie as a novice programmer is a crutch that hinders growth and writing proper OOP. What technical debt is associated by using the stdlib classes rather than the frankenstein classes that is `Hashie::Mash`? [r/schneems](http://www.reddit.com/user/schneems) is totally on point with this. It is fun code that is a minefield for production. Not to mention a 5% app bottleneck from one dependency is pretty bad in such a popular gem such as omniauth.
Word! Thanks again for the benchmarks. (^Sorry ^for ^the ^all ^caps )
"Sublime Text 3, the best IDE out there." /facepalm I'm surprised that their site doesn't also read, "Ruby on Rails, the best programming language out there."
Sweet! Thanks so much for this. I was actually reading up on Dart to build something based on Polymer and StageXL. Since your library looks more than complete enough for what I want to do, I think I might be using Dare instead! 
The Twitter gem by sferik takes a config blog (and also, obviously, wraps a remote API). Here's how he initializes a client: https://github.com/sferik/twitter/blob/master/lib/twitter/client.rb#L15-L20 And here is how config are setup when building a new client: https://github.com/sferik/twitter#configuration I've modeled my 3rd party api wrappers after the general patterns of this gem and had great success. 
It was, I've been thinking about using middleman to do some non-standard things, creating sorts of static pages that are not typical uses. Is there an easy way to get templates and assets from a gem included in your middleman product? If you've had occasion to do that, a blog post about that and the various things you can do there would be useful too.
 I think the test units are off to a good start, but you might want to consider using minitest/spec to make things a bit more readable in addition to splitting your tests into different files. You should also consider following ruby naming conventions ( i.e, file_manager.rb vs FileManager.rb ), in addition to organizing the layout of your app/gem. Generally, all your classes and modules will go under lib ( i.e., lib/brew/file_manager.rb ) and your tests should go under the spec or test directory. Checkout out rubocop for some help with code critiquing ( see links below ) Example project layout : Project ├── CHANGELOG.md ├── LICENSE ├── README.md ├── Rakefile ├── lib ├── test Links to check out: Rubocop - https://github.com/bbatsov/rubocop Bundler - http://bundler.io/ Note: you can use bundler ( `bundle gem foo` ) to create a skeleton for your project. Rake - https://github.com/ruby/rake Ruby style guide - https://github.com/bbatsov/ruby-style-guide Rubygems.org guides : http://guides.rubygems.org/rubygems-basics/
I prefer objective-hash approach as in gitlab gem: https://github.com/narkoz/gitlab/blob/master/lib/gitlab/objectified_hash.rb Also see [this discussion](http://www.reddit.com/r/ruby/comments/1qwdhn/ruby_api_wrapper_using_virtus_and_typhoeus/cdh8lzc)
First observation: Even for a small app, your Test.rb file is quickly becoming unmanageable because there's so much stuff in it. It would be more standard to have a test directory containg one file for each source file being tested. So test/brew_test.rb would contain tests for the code in brew.rb. (Note also that it's more standard to name your source files with snake case, even though the classes they contain are named with camel case. So the FileManager class would normally be defined in file_manager.rb.) Second observation: You should try to test only one thing in each of your test methods. This doesn't necessarily mean that you can only have one "assert" per test method, but each method should only try to test one aspect of a class' or method's behavior. For example, I'd probably break up the test code that calls the "convert_to" method on the Hops class into multiple methods like test_convert_to_grams, test_convert_to_ounces, etc. This will help keep all your test code in smaller, more manageable units, and it will make your test code function better as documentation for your project, because a new developer can easily get a feel for all the capabilities of a class just by scanning down the test method names. But in general, you're off to a great start! There's more you can do to make your code "rubyish", but just continue writing (and reading!) more Ruby code, and you'll keep picking up more of the conventions. 
The code itself looks fine, but there's no reason to add nine methods to `String` if all you're using the String for is as an URL parameter. `XP.new('http://foo.com').to_nokogiri` works just fine. Plus: Use a block when using `open` in order to close the stream automatically. You forget to close it [here](https://github.com/JikkuJose/xp/blob/master/lib/xp.rb#L15).
This is totally cool!
The slides look pretty neat, nice find! I've never used an IoC container myself, so I'm definitely not an expert. In one project I constructed the entire application at once in the boot file, think `config.ru`. It basically looked like this: WebApi.new(TaskService.new(TaskRepository.new("postgres://..."), GoogleGeocoder.new)) In rails I recently started using a global struct/hash to look up the dependencies, pretty similar to what Andy did with `Injectr`. Mine lacked the pretty DSL, though. The issue with this is, that you need to change global state in your tests if you want to replace any of the dependencies with stubbed versions in your integration tests (e.g. prevent the geocoder to talk to google).
I tried running the tutorials that are in the github homepage, but they are not working for me (Mac on Chrome) - No errors in the JS console, just an empty white page. The tutorial below (http://nicklink483.github.io/dare/tutorial.html) doesn't work either, but I can run http://opalrb.org/try/
this kinda sounds like a good application of the factory pattern? [Factory Pattern](http://blog.rubybestpractices.com/posts/gregory/059-issue-25-creational-design-patterns.html)
I'm not 100% sure I understand how the system works, but I'll assume it's some kind of database. One way I can think of to make this simpler is to take an approach similar to ActiveRecord, and write a generic EMR class that contains all of the information in a given record. Then you could subclass it for each type of record, and you'd then just have to write #retrieve and #save methods for each subclass to get the information in and out of the specific database. So you'd #retrieve a record when you want to start making changes, and #save it back when you're done. You could also have the object keep track of what has been changed since retrieval so that it only needs to partially update the record when saving back.
Clean Code is a great resource that touches on this topic and several other coding conventions. http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882 Uncle Bob (the author of Clean Code) recommends that you organize your methods based on the context and the level of clarity. He would suggest putting the high level code near the top with the smaller helper methods near the bottom. It compares a class to a newspaper. In a newpaper, you generally have the Subject at the top, with a high level description of the events that have taken place. As you read down the page, the articles will change from high level descriptions to low level details of the events. Obviously, there are sometimes exceptions to this suggested rule. TLDR: I wouldn't organize methods alphabetically. I would organize them logically from high level to low level.
That's what the search function is for... Public/affecting other stuff near the top, internals lower down, with a bit of localization by method relatedness or call hierarchy-ness
Everyone who writes tests should watch Sandi Metz The Magic Tricks of Testing http://youtu.be/URSWYvyc42M
I've noticed a similar behaviour with pry-byebug that it will sometimes stop *after* the `binding.pry` call, which might be in another method the call was at the end of the previous one. If you want to keep your gems separate put this in `~/.bundle/config`: --- BUNDLE_PATH: ".bundle" BUNDLE_DISABLE_SHARED_GEMS: '1' BUNDLE_BIN: ".bundle/bin" Now all gems are installed inside your projects `.bundle` directory, with binstubs for [`rbenv-binstubs`](https://github.com/ianheggie/rbenv-binstubs) so you don't have to type `bundle exec`.
I'm on mobile, so I'll try to be succinct. Edit: I reread your post. Keep in mind that best practice in Ruby (especially in Rails) is to keep the file structure very similar to the module structure. So, if you see a module called ActiveController::Session, it's likely to live in *active_controller/session.rb*. That helps a lot in navigating source. Original: First and foremost, read the documentation. It's good to examine the source, but you need to understand the public API to understand the source. Second, the "pry" REPL is super useful for figuring this stuff out as well. It's good about indicating what modules contribute to a given object's methods. I'll use that to get an idea of what methods are available on an object. From there, I'll pull the source down and grep through it. Basically, I'll take a look at the specific file I'm require'ing in and see how it pulls in the rest of the files in the library. I'll trace my way through to the file where the class I'm concerned with is defined, making note of any weirdnesses. Then when I get to that file, I'll have an idea of how the library behaves and what's weird or unique about it, which is key to deciphering what's up. Is that too vague? Let me know if I can go into more detail.
&amp;nbsp; I think that's a general answer, thats a bit reminiscent of the chicken and the egg problem because like you said, you have to understand the public API to understand the source, and 90% of the time you can guess how some magic happened, but would you say that you understand it without looking at the source code? &amp;nbsp; On another note, I'm not really trying to be negative and if I am then I'm sorry. I guess I'm still not completely sure yet where the source of this ignorance lies. I talked about Mount Everest, but I haven't really climbed to the top yet, so perhaps I should wait till I begin complaining. &amp;nbsp; What interests me above all is whether other Ruby programmers have felt the same and what made it click for them, and so far I think I'm reading a lot of people say that it ain't so bad once you've reached the top of Mount Everest, and I can totally picture it, I'm just feeling a bit lazy right now :P
That seems odd. Let me cook up a few tests in different html files to see where things fail like canvas loading. Also could you tell me what version of Mac and Chrome you're running? In Chrome it will be Menu -&gt; About Google Chrome, and of course for Mac click the Apple icon in the top left -&gt; About this Mac.
I'm a fan of [REPL-driven development](http://youtu.be/D9j_Mf91M0I). Or in your case, exploration. When I'm using a library I'm unfamiliar with, I'll often create a new project/file where I can use a minimal amount of code, drop a `binding.pry` at the end, and then use `ls`, `$` (`show-source`), and `cd` to dig around sample objects and see how they work. Even better: using the appropriate debugger so you can drop in and out of method calls.
Let me know if the colored circles show up in a canvas that has a black border: http://jsfiddle.net/GKK39/16/
I typically use ctags to look up method definitions and jump around code, or I just go to a file and search for 'def &lt;method&gt;' to figure out where I am. However, I do maintain some level of method organization. For starters, all includes go at the top of the object's definition. Because the included modules are essentially "part of" the class, I just think it's better from a readability standpoint if it's all included at the top of the file. Next comes macros. In a Rails world, it's very helpful to keep macros on top, because it describes what I like to call the "configuration" of a model. These macros are pretty much the first thing you see when you open the class definition file. Next, we have the initialize method. This goes in front of all class methods. I do this typically because that's the first thing I define in a lot of my classes. Gotta figure out the state before we know what to do with it, right? The initialize method is followed by class methods, and then (albeit I use this very rarely) private class methods. Typically when method logic grows to the point of needing private class methods, I will move whatever I was doing into a module and just extend it into the class. I'm not sure if private module methods are actually mixed into a class, but either way it communicates that you should not use those methods outside of that file. At the end of the file, we have the instance methods and private methods. They are in order of access: public first, then protected (which I rarely use), and finally private methods. Within those instance methods I typically like to organize it with the mantra "attributes first, actions later". So any methods written to primarily return data are first (usually "predicates" are the very first, methods which end in a "?" and return a boolean value), and after that I'll have methods that perform some kind of action. Action methods do return a boolean value but it's implied that the value is simply the result of whatever action they're performing. I never use exceptions for control flow, I always boil action methods down to a true/false response with asynchronous logging of some kind for error messages.
2nd test: let me know if the circles show up: http://jsfiddle.net/GKK39/17/ 3rd test: let me know if the circles move to the right: http://jsfiddle.net/GKK39/18/
&gt; No such thing as private class methods unless you declare private instance methods on the eigenclass. This is what I mean: class &lt;&lt; self private def hello puts "hello there" end end Is that what you're talking about with the eigenclass? The action methods I'm talking about with the "asynchronous logging" are really storing errors in some kind of object or actually logging them to a Logger object. For the most part I work with errors objects, like ActiveModel::Errors. Instead of insulting my own strategy for writing Ruby, in which there is no correct answer, why not offer your own suggestion for how to respond to these command style methods? I do admit that it's not a perfect solution, but I also don't want to be throwing and catching exceptions all over the place. I feel like ActiveModel::Errors is a happy medium.
pass callbacks or make heavily action oriented code return promises instead of immediate execution. I also see several smells: - More than 1 class method is generally a smell, unless they are unique constructor methods - Including modules, or "extracting functionality into modules" is a farce, and does not actually do anything to remove complexity 
that video would make someone who doesn't know ruby laugh pretty hard I'm sure :) for me, it's kind of nightmare-ish =/
Yep, check out [pry](https://github.com/pry/pry)
I leave that to Gary :) https://www.destroyallsoftware.com/talks/wat
I understand that monkey patching is pretty bad. But I just got excited thinking about such an interface: link.download, link.xpath(selector); etc :) About open: Oh, I didn't know that using `read`, won't close the stream. Sure, I will from now on use blocks for it; thanks!
If if you're on a case-insensitive OS (Mac, Windows, and some Linux) and you cloned a repo from a malicious source, your .git/config can be overwritten.
Oh pkg directory also need not be included? Very well, will do.
`pry` is a great tool; yet to bring it to typical workflow to analyze new gems.
`pry` is a great tool; yet to bring it to typical workflow to analyze new gems.
&gt; 2- I actually didn't get how to use the gemspec in Gemfile, can you explain that? Take a look at Sinatra's [Gemfile](https://github.com/sinatra/sinatra/blob/master/Gemfile): it has a line saying `gemspec`. That cues the gem builder to look for more details in a file with extension .gemspec (in this case: [sinatra.gemspec](https://github.com/sinatra/sinatra/blob/master/sinatra.gemspec)) that has more info about the gem. Take a look at [this description of gem structure and gemspec](http://timelessrepo.com/making-ruby-gems) for more info on what to put in your gemspec file, and how it all fits together.
that was good :)
Well, whether it's the best or not is largely up to the user, but it's definitely a handy tool to have at your disposal. I'd check out the conference talk I linked in the previous comment, which is a terrific guide for how to use Pry.
Thanks a lot, will read further.
&gt; It compares a class to a newspaper. In a newpaper, you generally have the Subject at the top, with a high level description of the events that have taken place. As you read down the page, the articles will change from high level descriptions to low level details of the events. They called this the *Inverted Pyramid* writing style when I was in school.
this + foo.method(:bar).source_location
Because of dynamic typing and extendability Ruby is pretty hard to follow from just the source code. With statically typed languages and more rigid languages it's easier, especially with IDEs, where you can just jump from method to another or look for the usages with a refactor tool. I prefer to use test driven approach and Intellij Idea's excellent debugging tools. First I setup tests for the feature I'm developing, then I explore the runtime behaviour of the code with the debugger. Breakpoint, step into, step over. "Evaluate" is a very handy feature that allows me to type in code in the running debugger context. All the variables that are defined in the debugger are available in the Evaluate mode. Also, documentation is a good help in that. One thing I have to say about Rails is that it's a pretty huge framework. By nature frameworks tend to grow big and that might be one reason to favor smaller libraries that do a lot less. Sinatra, for example, is a lot easier to grasp.
Nope. Downloading a String makes no sense.
Sounds like a perfect fit for good old inheritance. In Ruby there is no notion of an abstract class. You would implement shared functionality in the base EMR class, and the methods that are expected to be overridden by sub-classes do not have to make their appearance in the base class at all, but it is a good idea to "declare" them in the base class anyway, like this: def method_name raise NotImplementedError end And there will not be any repetition - the only code in the sub-classes will be the code that is different from one EMR to another. And dump the whole going-from-a-string-to-class-name thing - it is totally optional icing on the cake and will only serve to cloud you judgement in the present, and many WTF moments in the future. There has been a shift away from this kind of unnecessary meta-programming in the Ruby community over the past few years. Keep it simple :)
For the file descriptor leak, why not use an [std::ofstream](http://www.cplusplus.com/reference/fstream/ofstream/) instead of a raw file descriptor? That would take care of closing the file when exiting the scope where it is defined.
This just came in my inbox. Thought it might help: http://www.rubymotion.com/news/2014/12/11/announcing-rubymotion-3.html?utm_source=rubyweekly&amp;utm_medium=email Announcing RubyMotion 3.0: Android Platform, WatchKit Apps, and More The cross-platform native app toolkit takes a step forward with stable Android support, and the ability to build Apple Watch apps and iOS 8 extensions.
Because it actually creates a temp file with a random name, using `mkstemps()`. You can't do that with std::ofstream. [Here is the actual code](https://github.com/phusion/passenger/commit/deab76c5c9ef217df4c32f291ff8142800d114ed#commitcomment-8964155).
Ease of use!
oh wow, thanks for sharing!
Love that half of the comments in the discussion are "why does everyone hate hashie?" While that approach you linked to is better than using full blown hashie, why not use an openstruct? If you read the open struct code it's pretty similar. Also make sure not to use this (or ostruct) in perf sensitive code areas as that method missing and to_s is a killer.
I don't buy it. Both ways are baffling, but at least case-sensitive can be made consistent ("filenames must match *exactly*"), whereas with case-insensitive filesystems, you accept *some* differences (case), but not others (e.g. whitespace, spelling errors, alternative extensions...).
Check out Pry's `show-source` (aliased to `$` for easy access) method. :)
Does anyone have experience working with [Corona SDK](http://coronalabs.com/products/corona-sdk/) and RubyMotion? I'd be interested in hearing how the two compare.
nah
You're right on. Was actually wondering how come nobody noticed before :) We noticed when it was too late.
Ah, that makes perfectly sense, then :) Still think I would have fleshed out a proper tempfstream or something so this kind of confusion would not happen. Anyways, thanks for a great tool!
Thank you :) I think you are totally right. I was already starting to think that this could just be a case for inheritance, but I wanted to be thorough and make sure there weren't any other known patterns for mappers like this. 
&gt; Most people know it as way to ass external tasks to a Rails app I'm not sure I agree but I like the cut of your jib.
I think the 2 thing that helped me learn programming the fastest (still a novice though): 1) just trying to put together small projects. It distracted me from the pain of slow-learning. e.g. make a coin toss simulator or a rock paper scissor program 2) Learning more than one language at the same time...I started with javascript and I thought it was so confusing until I started learning c++. That opened my eyes. If you are just starting then you're looking at about 6 months of being uncomfortable. At least you better be if you want to learn.
How does minitest/spec make anything more readable? I think it's reasonable to prefer spec syntax, but if you cannot learn to write readable tests with plain test unit syntax, you won't be able to write good specs, either.
I would probably have a middleman command that copied them from the gem directory to the local source directory. It's a Thor cli so its pretty straightforward using ThorActions.
Ha! Thanks for pointing that out.
Right, but the grandparent post wrote with square brackets, `fetch["key"]`, that was what was wrong, square brackets won't work. Which is why they got `ArgumentError: wrong number of arguments (0 for 1..2)`. Sorry, typo confusion I guess. 
Thanks for the article. I understand ruby lets you do things even though that they are bad -- it's still unclear to me what's bad -- in terms of design -- with providing something that acts just like a Hash but with extra methods. It seems a useful thing to do to me. If ruby's implementation makes it impossible to do reliably or with performance, that's one thing. But I don't see what's wrong with the design; do you think there's something wrong with that as a design, or just that ruby's current implementation happens to make it hard to do well? But I see your article addresses some of that, thanks. 
The problem with copying them, is if a new version of the gem is released which changes them, then you have to copy them again, over your local ones (which if they had modifications, will have to be merged in). For Rails apps, I prefer keeping templates and assets in the gem itself, not copying them over, for this reason -- this is really the _reason_ I'm keeping them in a gem, so they can be updated easily by simply updating the gem. There's probably a way to do that with middleman too, mess with the load paths somehow, I'll see if I can figure it out, when I get around to it. 
For performance reasons, it's generally better to use `yield` unless you explicitly need to manipulate the block as an object. For this case, I would define the method as: def parse_pages(&amp;print_status) return "Scrape Failed" unless scrapable? 1.upto(page_count) do |i| yield i if block_given? retry_parse(3) { parse_single_page(i) } end self end 
You should be clearer, Hashie::Mash does too much. Hashie is a big library with a lot of things.
Nice, thanks for being open with your bugs and helping us all learn. I think the load balancing bug was not specific to node.js, but would effect anything with unlimited concurrency, right? Can that apply to a Rails app too (under Passenger Enterprise, that supports multi-threaded dispatch), could it also be set with unlimited concurrency and trigger the same issue? I don't actually run with Passenger Enterprise (so don't use multi-threaded dispatch in Rails apps), but I've also noticed my Passenger Rails processes getting uneven load balancing, looking similar to the report from Charles Vallières. I've never worried about it too much, because my application's concurrency/latency was behaving just fine for the actual load we get, but it's always seemed odd to me. I wonder if it's a similar bug somewhere. 
Nice try, cat facts.
Some versions of auto-generated docs have links to github source for the method doc'd. I use this a lot, I wish everyone did this (and yard supported it more clearly), and wish it went even further, clearly listing github links not just next to methods, but next to classes (a class can be defined in multiple files, so it might need to be multiple links). Even if you weren't hosted on github and linking to live github, the auto-generated docs could still clearly list filenames (next to methods and classes). I think it's crucial in a language like ruby where it's not always clear where a class/method is defined -- and can be done when generating docs. I was going to use `ActionController::Session` as an example since you did -- but either that class hasn't existed since Rails2, or it hasn't made it into the auto-generated docs since Rails2 (which is another sort of problem). But check out methods on ActionController::Base, click, 'on Github' next to any method, now you can see exactly where it's defined. http://api.rubyonrails.org/classes/ActionController/Base.html#method-i-response Note it's linking to the exact github commit/tag for the source file in the exact version of Rails you are looking at, not just linking to the current master. I do this seriously all the time when trying to figure out/debug Rails, which can be especially mysterious in it's source filenames sometimes. 
Hahaha. 
Yes, it's not specific to Node.js. It just so happens that Node.js is the only language we support that supports unlimited concurrency. The uneven load you see in your case is intentional. It is to allow idle processes to be shut down. If load is always even, there would be no idle processes. But this poses a potential future problem. Even load balancing conflicts with idle shutdown. It just so happens that Node.js apps tend to be lighter than Ruby apps, so that Node.js apps don't need idle shutdown. But as Passenger supports more languages, this might change. So at some point in the future we'll want to have a configuration option for this.
I find test unit way easier to digest. Contexts are actually terrible, in my view.
Sometimes you find methods in those github method source snippets that have methods coming "from nowhere" tho. It seems clear to me the problem is in the documentation and the fact that Ruby's structuring makes it impractical. Somehow the doc should (re)structured.. The current doc structure feels more appropriate for C languages or Java ಠ_ಠ
I can't recall coming accross that, do you have an example? Are they 'methods' (or rather messages) dynamically created by `method_missing`? There, I'm more likely to see the methods not covered by rdocs at all, which is indeed a documentation problem, then to see them covered but unable to link to source. Is that what you're talking about? 
Use compass for sass, and grunt watch or something to trigger compass and live reload. Short answer: yes, totally possible and lots of people do it Possibly check out http://linemanjs.com also, may have most of what you're looking for in a nice package
I think I found the best way? [Middleman](http://middlemanapp.com/)
Middelman is awesome! 
I've used nanoc in the past to some success.
Came here to suggest looking in to Middleman. I have been using it a lot lately.
[Guard](https://github.com/guard/guard) + [Guard-Slim](https://github.com/indrekj/guard-slim) [Guard-Sass](https://github.com/hawx/guard-sass) [Guard-LiveReload](https://github.com/guard/guard-livereload)
I don't alphabetize but I do use a comon structure: - The first method is usually initialize() if it is a class. - The last method is usually run() if it is a class (but not all of my classes has a run() method - my most important ones do have one, because I want to invoke only the same name for ALL my objects in ruby, whenever I need to use that. - Lately, I am also making use of [] as in def self.[](input) The advantage with [] is that I don't need to give a method a name. Usually the [] accessor is the most important one to have in my class or module; it's a bit like the generic .call() method for proc objects right? Except that .call has a name, [] does not have a name now does it.
Search function won't help you much when you have really huge projects. And when you write ruby code on a daily basis, you amass a lot of code.
middleman is great, its a really great way to work with that FE stack!
Well, you could still use Rails. It's actually a pretty good option for a JS MVC app. You get HAML, SASS, the asset pipeline, routing, S3 asset sync, environment-specific asset hosts, various deployment gems, etc. Instead of loading 'rails/all' you just load the railties you need and forget about ActiveRecord and such. You can make it as minimal and bloat-free as you want. I've used Bower for JS package management and built JS apps on top of Sinatra and Padrino in the past, but by the time I've added in all the features I just mentioned, it makes a lot of sense just to use Rails, especially if your backend app is also Rails.
Superscript is a way of expressing text. Since 'puts' outputs plain text, the only way of making this possible is by using some sort of markup (i.e. HTML) that would make it display in such a way. What context are you wishing the number to be displayed in a superscript manner? Webpage output? Command line output?
&gt; Edit: with a live reloading ruby htttp server Sinatra? Padrino?
If you like replacing hashes with POROs, you'll love what type systems have to offer! https://github.com/bitemyapp/learnhaskell
&gt;(Admittedly, haml is a lot better than jade for certain things, though.) Very interested in hearing more about why you think this
Because openstruct doesn't handle nested hashes. Also in Ruby 2.2+ symbols are garbage collected so it doesn't affect the performance. 
There is a much shorter way to do just that: p languages But the result is not the same as puts languages 
I totally agree. I would not necessarily make use of inheritance here - it more sounds like a case for facade and factory patterns: Define an abstract API (this does not even need to be in code but it won't hurt either) that describes all the operations you want to do with a single EMR. Then, create a factory that hands out instances that implement this API and encapsulate the connection to one specific EMR. This factory method would be the one receiving what is "emr_name" in your example. If there are things like connections that need to be established then you can even use [a block for transactional robustness](http://blog.rubybestpractices.com/posts/rklemme/002_Writing_Block_Methods.html): emr_factory.open "fooBarEmr" do |emr| emr.add_note "This patient is almost cured." end Cheers
I started using this because of all the recommendations and had to give it up. It's a brilliant combination of condescending and completely uninformative. Like all of a sudden, you're being told to use string interpolation. Except you're not told that's what it is, you're just told to type this thing exactly like it says here. The introduction even says that. &gt; Just keep going because with programming there's this very odd thing that happens. At first, you will not understand anything. It'll be weird, just like with learning any human language. You will struggle with words, and not know what symbols are what, and it'll all be very confusing. Then one day BANG your brain will snap and you will suddenly "get it." No, you won't just suddenly "get it" if no one explains what the fuck these things are you're being told to do.
"Aggressive" because it doesn't rely on you remembering to run a binstub or Rake task; run `rake` after your expiration date and, *boom* here comes the red bar/failed commit/failed CI build. I wonder if the OP has read [this wonderful post](http://andrzejonsoftware.blogspot.sg/2014/12/ill-refactor-this-later.html) by Andrzej Krzywda. Tech debt *kills*. Maybe not people, but it's slaughtered numerous projects I've held dear over the years. *You* are the key to halting this no-longer-silent killer! (da-da-*dahhhhhhh!*)
Certainly; just like the `times` method producing an enumerator from a `Fixnum`. I am downloading the file pointed by the link :)
Certainly; this does violate Single Responsibility theorm. But I seem to have a liking to how the code looks very readable.
It doesn't make sense. And it isn't meant to be used in real code. Just mashed up scripts people can simply copy paste and run. At the same time be very readable for even non developers.
Algorithms playground for common questions solved in Ruby syntax (most of it using dynamic-programming).
Sometimes it's just easier to express something in haml than in jade. For example, if you want to have a paragraph with a link: p | Check out a(href='/link') this | link If you have your text editor set to trim whitespace, it will render like this: &lt;p&gt;Check out&lt;a href="/link"&gt;this&lt;/a&gt;link&lt;/p&gt; You could just do it inline with jade, but with haml you can just do something like: %p Check out %a{href: "/link"} this link And it renders with expected whitespace. You shouldn't have significant whitespace in your html, but everyone does it anyway. 
Very simple and compelling argument. Thank you.
I wish I had read 'The Rails Way' (Fernandez) back when I had started with Rails. Edit: And please don't skimp on learning Ruby.
Check out SeattleRb while you're at it - I think they meet weekly?
[RailsCasts](http://railscasts.com) not maintained anymore but great videos
What's new/different from the other progress bars, like https://github.com/jfelchner/ruby-progressbar ? EDIT: Just saw that it's a plugin for your TTY toolkit. nvm.
Ask yourself this question: _What would be easiest for me to understand 6 months from now when I have to fix a defect in this code?_
Yeah can set up grunt to watch and convert: http://gruntjs.com/ Personally I use Codekit ($29) because I already had a copy available. It's a nice GUI for general workflow stuff like that: https://incident57.com/codekit/
I wouldn't recommend reading source code for its own sake. Start with the README for a given library, and if you run into specific questions, then try and find that specific answer For instance, capybara has a really well defined public API in their readme, but you might notice when running acceptance tests that it runs your app on a random available port on the host machine, it might then occur to you to figure out how it does that. However reading capybaras source code as a whole to try and learn just from study would likely be frustrating and time wasting. That being said, the tests for a given project are also a great way to learn more about what it does.
Most definitely. I believe the answer is; the shortest, least redundant code, which relies on common ruby practices.
A symbol is like a string literal, but it is immutable (it can't be changed), and a singleton (only one is created in memory, whereas every string is a unique object). Use them whenever you want to identify something, such as a hash key: person = { name: "Justin" } person[:name] # =&gt; "Justin" Reads a lot better than person = { "name" =&gt; "Justin" } person["name"] # =&gt; "Justin" Check out http://www.troubleshooters.com/codecorn/ruby/symbols.htm
short demo: https://showterm.io/380e8ddab5c8c058fbd27#fast
Great explanation here. Another value of the symbol takes advantage of some of the properties that were described above (singleton nature). Compare two strings vs two symbols. "foo" == "foo" #string comparison vs :foo == :foo The string comparison will go and compare each character in a linear fashion. The symbol comparison will just look at the memory address (and thus being quicker). It's minor but sometimes worth pointing out.
Basically, they're constant strings that are for internal use within your code. Use 'em anywhere you would otherwise use a string to identify something: Hash keys, option flags for method parameters, that sort of thing. For example, you might write a method definition like def format_text( justification = :left ) If you wanted to justify center, you could pass :center as a parameter instead. Why use them instead of plain old strings? Two reasons. First, it's convention. It lets you know that you're not passing the word “center” to the method to be used as part of the output text. Second, Ruby is supposedly “optimized” for the use of symbols, but it's not really that big a difference to be honest. The big reason is for clarity of code and to follow convention. Any time you're using text as an identifier for something, especially if you're not planning to output the text, you should probably be using a symbol.
So symbols are immutable (unchangeable) strings made for logic. For example, you can use a string to hold data (e.g. string = "some data"). You can also use a string for logic (e.g. if string == "hey" then do something), but logic with strings can be problematic (with new lines '\n' and weird stuff). Also, symbols are also much quicker when it comes to logic comparisons since **symbols with the same value are assigned the same ID**. Strings assigned with the same value are not given the same ID's so comparison are done character by character (which can be slow). if "symbol".to_sym == "symbol".to_sym puts "this compares the ID's of the symbols (very quick)" end if "string" == "string" puts "this compares each character value to each other (slow)" end
I use middleman for SPAs and love it. 
Came here to say this. All around better to use symbols when possible.
This illustrates rather well the trouble with methods named `generate` (or `process` or `go!` or whatever) — they usually enclose some multi-step process that much better suited to imperative programming than OO. Bear in mind that I'm presuming that neither `convert_to_cleaned_up_comments` nor `convert_to_text` has side effects, and they simply accept some argument and return a new object (if either does mutate state, then that should be made explicit somehow). `save_to_file` obviously does have a side effect (an IO action). So start with that: your public method should be called something like `save` or `write_to_file` (`save_to_file` is already taken, or I would have used that). What's it saving? The cleaned up comment text — and that's all it needs to know. def write_to_file save_to_file(cleaned_up_comment_text) end This way, it's clear when you read the code exactly what it's doing, without all of that imperative structure getting in your way. You can implement the rest of the methods along those same lines: private def cleaned_up_comment_text convert_to_text(cleaned_up_comments) end def cleaned_up_comments convert_to_cleaned_up_comments(relevant_violations) end [Depending on what the rest of your class looks like, this may not necessarily be the best way to go about this, but in my opinion it would at least be a step in the right direction.] 
Just thought of a real world example I can give you to demonstrate the difference in usage between strings and symbols. I was doing some UI scripting recently using AppleScript (specifically, the sadly deprecated Appscript Ruby AppleScript bridge), and there are two methods for sending keystrokes. If you want to send a typed string, you just have to pass it to the #keystroke method, but if you need to send, say, the F9 key, you need to look up the keycode for it and pass it to the #key_code method. This gets unwieldy and annoying, so I decided to wrap both methods in a single method that can take any key by name. But how do I distinguish between the F9 key and the literal string "F9"? Well, I wrote the method so that strings passed in are sent directly to #keystroke, but symbols passed in are looked up in a Hash and the corresponding key code passed to key_code. So I can call my method like keys("hello", :f9) to send the keystrokes H-E-L-L-O-F9. See the difference? The string is a literal that is output to the user, whereas the symbol represents something other than what it literally is, but makes it a lot easier to understand for the programmer.
1. My preference is for /r/ruby to be explicitly SFW. 2. I do not see very many project showcases when looking at the /r/ruby front page. 3. This project is not ready to be showcased.
Before Ruby 2.2 ([currently in RC1](https://www.ruby-lang.org/en/news/2014/12/18/ruby-2-2-0-rc1-released/)), **symbols are not garbage collected**. The practical implication here is that creating arbitrary symbols will slowly use up all of your memory, and is a potential vector for a Denial of Service (DoS) attack. As an example, see [CVE 2013-0269](https://www.ruby-lang.org/en/news/2013/02/22/json-dos-cve-2013-0269/). So, be careful, and know what tradeoffs you are making when choosing Symbols vs. Strings.
&gt; pornographic pornographic != nude or erotic
Github may disagree, but suit yourself. EDIT: Not to mention, the name of the app is *Porn*Time.
 Great read. Although, came across a slight hitch when trying to implement symbols. Author says a Symbol has both a string and a numeric representation. :symbol.to_s and :symbol.to_i should return the equivalent representation of the symbol. But while trying the same code in the Ruby repl, I'm getting a NoMethod error while using :symbol.to_i. My ruby version is 2.1.2. Am I missing something here?
Ok, thanks, man)
Ruby != Rails
That's true. You should never be converting user input to symbols (if you are not checking limits) because people can crash your app by flooding data to create symbols which aren't garbage collected prior to 2.2. This causes memory to balloon.
Because: 1. to_sym needs to do a string equality check to see if there is an existing symbol with that value (which is slower than checking equality with a single string), so it only makes sense to do this if you actually store the symbols instead of the strings and check equality multiple times 2. symbols won't garbage collected until ruby 2.1, so this causes a huge memory leak
Anytime you find yourself using a word as a 'flag' when thinking about your code, represent it as a symbol i.e. if friend.status == :available puts "Yay they're online." elsif friend.status == :away puts "They're not at their desk." else puts "Who knows where they are!" end
I learned a bit of Rails back in the day but decided to start from scratch by learning Ruby first. Best decision I could've made. I eventually realized that I really didn't need Rails for *all* my needs, and chose to start with Sinatra instead, and slowly started adding things to it (e.g, db/models). I think that's a great way to learn the basics of how Rack-based systems operate. Moving onto Rails from there will be intuitive, and even a welcome thing. It may be better than spending a lot of time on Rails from the start and not getting a hang of things. Lastly, knowing a microframework like Sinatra on the side will also enable you to create smaller services that can feed into your larger Rails projects in the future.
For some reason I expected article to suggest removing rack :)
I've done this enough in the past to regret it ;) &gt; ...so why do it? I suppose pseudo-functional cargo-culting was the reason in my case. Absence of "variables" felt good. At the end of the day, Ruby is a procedural, object-oriented language. Know thyself.
Run your project with jruby. It should help
Are you running 30 delayed-job processes, or running delayed_job with a concurrency of 30? If the latter, you're only running one ruby process which is doing all the jobs in a separate thread. Since ruby has a GIL lock, this only really helps if you're spending a lot of time waiting on IO like a database or network. The simple solution is to run more DJ processes - it plays nicely with concurrency like that.
I'm starting workers with -n 30, so I guess it's processes?
Great and concise article. Thanks.
To me, that's actually what you started with. The temporary variables are fine. You could also refactor to make this possible: relevant_violations.convert_to_cleaned_up_comments.convert_to_text.save_to_file(text) But if you need to write a whole lot of confusing code to get that to work, personally I would not consider it a net win. Unless perhaps you are going to be doing similar things repeatedly in different parts of code, maybe even with different orders of operation, etc, and it's really worth building out a design for it. I'd just go with your first version with temporary variables. Another possibility is to use OO here: class ReportGenerator def relevant_violations # ... end def cleaned_up_relevant_violations convert_to_cleaned_up relevant_violations end def cleaned_up_relevant_violations_text convert_to_text cleaned_up_relevant_violations end def save_prepared_file save_to_file cleaned_up_relevant_violations_text end end ReportGenerator.new.save_prepared_file
If the delayed jobs aren't CPU intensive, but maybe spend a lot of time on I/O, maybe they aren't actually all working at once, and the OS has no need to schedule them on multiple cpus, and it's not a problem? But I wouldn't expect them _all_ to _only_ be on one CPU. Then again, I know almost nothing about how OS scheduling works. 
Violation should have a "cleaned_comment" method, and the Comment object should have a "to_text" method: def generate comments = relevant_violations.collect {|violation| violation.cleaned_comment} save_to_file(comments.collect {|comment| comment.to_text}) end That makes 2 lines of clean code and only 1 temporal variable. Or even better: def generate comments_text = relevant_violations.collect {|violation| violation.cleaned_comment.to_text} save_to_file(comments_text) end 
why do you think that? bang version change the current object(in place). witch is bad in my empty stack developer opinion :)
The "!" naming convention is for "dangerous" methods or methods that change the original object. #to_i and #to_sym return new objects.
Based on the conventions of the standard library, a #to_sym! would need to mutate the receiver into a symbol, in place, rather than returning a new object. This is not possible in ruby. Thankfully. It would be pretty disastrous if it were. Imagine: a = "12" a.to_i! a.length # =&gt; NoMethodError: undefined method `length' for 12:Fixnum You could have passed a into some persistent data structure somewhere, and then applied some spooky action at a distance to turn it into an entirely different sort of thing that no longer responds to the same methods, waiting to trip up some other code that has no idea it's magically changed into something else. It'd be a terrible idea. In general, in ruby, you can't change the class of an object already created, ever. (You can add modules on top of it etc and do other potentially dangerous things. Those are enough. You can't just turn it into an instance of a different class). 
I mean, content concerns aside, I would nix the nudes in the readme.
Excellent, now if we only had this kind of explanation for everything! :) StackOverflow doesn't exactly fit the bill for this use case. Actually, if anything I find that the technical subreddits are reasonably good for ELI5 type doc.
That's really good question, why create new if there is already another one. Most importantly, I wanted something even more flexible with very lean architecture and intuitive api. This values are very subjective though. However, I think the formatting is the strongest point - instead of predetermined characters, you have ability to supply your own string with few common tokens. Nothing stops you from defining your own formatter. The library also uses the https://github.com/peter-murach/tty-screen to determine dynamically available space and resize if needs be. I'm sure that ruby-progressbar is awesome and would encourage people to use it. I think having a choice is a very good thing! I have more plans for the future for the library that may even more differentiate the approaches.
True – I should have my persistence not mixed in with generating the report.
Hmm... I'm a little skeptical, though, of this approach because it'll create a deeper — as opposed to flatter — set of functions. And I feel like it'd be harder to debug. I.e., each function actual encapsulates every else in the process, from its point back. Put another way, functions which are at the same level of abstraction haven't been kept together — something I was trying to do.
I'm going to come at this from a side angle. Pick up POODR (Sandi Metz) and look at how OOD could improve your code; read up on SOLID principles; perhaps also pick up a copy of Refactoring (Martin Fowler). You're struggling since you are just dealing with a bag of methods which is why it feels "unclean" to you but if you keep just tweaking the edges you're unlikely to get rid of the various smells.
Thanks, will do. I've added these books to my wish list.
&gt; I feel like every method should have a methodName! version That would make the number of methods explode. Note also that bang does not mean "do in place" but rather "potentially dangerous operation" - whatever that means in context. Changing an object's type is a bad idea as others have pointed out already. That is simply too much flexibility since often there are multiple references to a single instance which usually rely on some properties that are fulfilled initially. If the type changes under your hands there is a high risk of loads of errors difficult to hunt down.
I'm showing my newness to ruby here aren't I?
You can try that fairly easily: $ ruby &lt;&lt;CODE class X private def a;1;end def b;2;end end x=X.new begin;x.a;rescue Exception =&gt; e;p e; end begin;x.b;rescue Exception =&gt; e;p e; end CODE #&lt;NoMethodError: private method `a' called for #&lt;X:0x000000028513b0&gt;&gt; #&lt;NoMethodError: private method `b' called for #&lt;X:0x000000028513b0&gt;&gt; 
&gt; spooky action at a distance Going for the Einstein of Ruby award, huh? :)
Yep, and you got some really good answers.
I think maybe OP isn't familiar with what mutating methods actually *do*. Just in case, I'm gonna briefly cover it. Quick: what do you expect the following to output? greeting = "aloha" farewell = greeting farewell.upcase! puts "#{greeting}, friend! And, now, #{farewell}." We can definitely agree that the farewell should be "ALOHA" because it was upcased on line 3, but what about the greeting? Intuitively, we might expect that, because `greeting` never got `upcase!` called on it, it should've stayed as "aloha". Let's ask IRB: ALOHA, friend! And, now, ALOHA. Whoops! What happened here? This is a result of Ruby's system of objects and references. I'll draw a quick table of the relevant Ruby objects and references for each line. ### Line 1 greeting = "aloha" #### Objects Object ID | Value ---|------ 1 | String: "aloha" #### References Variable name | Object ID ----------------|------------ greeting | 1 ### Line 2 farewell = greeting #### Objects Object ID | Value ---|------ 1 | String: "aloha" #### References Variable name | Object ID ----------------|------------ greeting | 1 farewell | 1 Note what this line actually *did*. The basic Ruby assignment operation has a left hand side (variable name) and a right hand side (reference to an object). In this case, we interpret the right hand side `greeting` as a reference to object 1, and therefore assign `farewell` as *also* a reference to object 1. No copies; the two variables are now references to the *same* object. ### Line 3 farewell.upcase! #### Objects Object ID | Value ---|------ 1 | String: "ALOHA" #### References Variable name | Object ID ----------------|------------ greeting | 1 farewell | 1 The references don't change here. Instead, the `upcase!` method *mutates* the object referred to by `farewell`: object 1. Since `greeting` refers to the same object, we see "ALOHA" whether we get there through `greeting` or through `farewell`. ### Line 4 puts "#{greeting}, friend! And, now, #{farewell}." And we print "ALOHA, friend! And, now, ALOHA.". The objects and references don't change. --- I hope this helps explain what mutator methods actually *do* :) When in doubt, I recommend non-mutating methods over mutating methods, because it's easy to make mistakes like this. For example, prefer `upcase` (which *copies* the string and returns a reference to an upcased copy) over `upcase!` (which *mutates* the object you called it on), unless you have an excellent reason. (Mutation *is* faster than copying, but the difference is small enough that it's almost never going to be the bottleneck in your application. Once you've benchmarked your application, and discovered that copying is *the* problem, that's when you should switch techniques.) As an exercise, consider why the following code snippet *doesn't* upcase the greeting. (If you're not sure why this code behaves differently, try drawing object and reference tables.) greeting = "aloha" farewell = greeting farewell = farewell.upcase # This is the only changed line. puts "#{greeting}, friend! And, now, #{farewell}." Regarding your original question: consider why it often makes sense to change an object's *contents* through mutation, but doesn't often make sense to change an object's *type*. What are some realistic examples of each? One final note: `!` doesn't *always* mean mutation. It just means "dangerous", and mutation *is* dangerous, so that's usually how you'll see it used. Check the docs on each `!` method you encounter in order to confirm what it *actually* does.
No such thing as a private method in Ruby. :) Edit: Downvote me if you want, but look it up. It's true. Object#send doesn't give a damn if the requested method is private or public. So yeah, there are no private methods, just methods that make you say “please”.
What is it supposed to do? What errors are you getting? We will need more context to help :)
There is no need to return anything in initialize. I don't know why you think that. 
That's just semantics. There are private methods in ruby, but you can always call them if you really want to. There is also public_send that doesn't call private methods. Classes are open so a public method can be made private and vise versa.
Private methods exists but they behave slightly different compared to most other languages but still the general concept is the same. You are right that #public doesn't care (there is public_send though (which AS' #try uses for example)) but in Ruby you can even access instance variables which aren't exposed with an accessor method. Just because it's meant to be treated as private doesn't mean that you cannot drill a hole into the ruby :)
Thats because of the blog name I believe? :)
`self` in this case is just a reference to the current instance (aka `this` in e.g. java).
If we stick to this exact snippet there is *no* class method `send_results` he is trying to invoke. He should have written # &lt;...&gt; results = @page.search(".//p[@class='srch row']").to_html send_results(results) self end or make `send_results` a class method instead: class &lt;&lt; self def send_results(results) # method body end end 
that is interesting, though I don't understand why some strings were not constantized i.e. ('rack.methodoverride.original_method', 'Transfer-Encoding', "") while others were. 
Many bang methods do change in place, but that is not what bang is intended to signal. Matz himself [says](https://www.ruby-forum.com/topic/176830#773946): &gt; The bang (!) does not mean "destructive" nor lack of it mean non destructive either. The bang sign means "the bang version is more dangerous than its non bang counterpart; handle with care".
The concept causing the change of *greeting* and *farewell* is called [Aliasing](http://en.wikipedia.org/wiki/Aliasing_%28computing%29). Just to simplify further research for /u/Braber02 .
Note: this are SQL views
Yes, indeed. There is no classmethod. To invoke the classmethod from an instance, you'd have to use `self.class.____`. `self` in this case references the current instance, not the class. `self.send_results(results)` and `send_results(results)` are equivalent. See: class Foo def send_results(results) puts results end def invoke send_results(:invoke) end def invoke_self self.send_results(:invoke_self) end end f = Foo.new f.invoke # =&gt; 'invoke' f.invoke_self # =&gt; 'invoke_self'
The example examined in your blog post (I guess you mean Hashie::Mash?) is again only a very specific case of trying to create a class that has an object and a hash-like interface. And again, it is a case of a leaky abstraction rather than a generalisation that subclassing Hash is bad. A Hash *is* a proper object. Trying to implement Openstruct-like functionality by subclassing it is a bad idea. But subclassing Hash in general is perfectly valid.
I thought putting views in the database was something people just joked about because of how bad of an idea it is. What is the use case for this?
http://en.wikipedia.org/wiki/View_%28SQL%29 You can think of it as a virtual relation. One use is making read-only views of certain tables and joins, and then giving users access to them for reporting. The users see the view's name as just another table.
I would search online for answers. That Unicode idea sounds like it would make it work for both command line and web without using the superscript HTML tags
That expression is also often used to [criticize Ruby](https://www.google.com/search?q=ruby+spooky+action+at+a+distance). 
Heh, I should have checked IRB first. You're correct. So is this a Mechanize problem and not a Ruby one? He didn't include a stack trace.
I don't get what class methods have to do with this.
He didn't include anything. He didn't even say what his problem is :(
You didn't return a stack trace of the error. That's pretty much Rule #1 of getting others to help you troubleshoot.
This would be so nice.
Yeah, since he didn't include a stack trace or anything, I assumed (falsely) it was a Ruby problem, then made a dumb assumption while on the road. If anyone has any actual Ruby questions, supposedly I'm pretty good (except when it comes to object initialization, apparently)
Haha fitting.
I recommend using [Uru](https://bitbucket.org/jonforums/uru)
[RubyInstaller](http://rubyinstaller.org/downloads/)? [Cygwin](https://www.cygwin.com/)? [VirtualBox + Ubuntu](https://www.virtualbox.org/)?
Speaking of ruby inspired languages, [Opal](http://opalrb.org/) and [Crystal](http://crystal-lang.org/) are also worth looking into.
Thanks for the share! Here are the [slides](https://speakerdeck.com/benjamintan/rubyists-have-a-sip-of-elixir). And please help me [improve](http://speakerrate.com/talks/39971-rubyists-have-a-sip-of-elixir)!
RubyInstaller is your best bet, it will install a single version of Ruby. Cygwin provides a UNIX-like environment on top of Windows. VirtualBox would let you run Linux and all it's development tools inside of Windows. You will eventually find that it's much easier to develop software in a UNIX environment, such as Linux or OS X.
known issue, fixed in head version of rvm rvm get head then you should be able to install it
You're going to need this: Http://google.com
http://lmgtfy.com/?q=ruby+1.8+vs+2.0
Excellent. Thanks! This worked perfectly.
This is an example of over-thinking ( or over-engineering if you prefer fancy words ) your problem. To me, as others have also mentioned, the first version is, by far, the cleanest - to understand, to maintain, and to probably debug 6 months down the line. Everything else adds complexity with no great benefits in terms of maintainability. One of the great benefits of ruby is that it makes coding simple and fun - don't overthink and over-design your code.
Quoting a comment I made on Google+ about [his presentation at RubyConf 2014](http://youtu.be/kXcrClJcfm8): &gt; Reading his book and then seeing this prezi drives home the points. &gt; &gt; I've been doing OO for 20+ years, in a dozen languages, and most of the time I was making life harder for myself than it needed to be. You have, too. I've been on teams whose projects have failed in a way that, looking back, would have been _far_ less likely had we done thing this way. If you've been on at least three teams, you probably have, too. &gt; &gt; This isn't a silver bullet, but it's a _damned_ fine can of bug spray. His [book](http://clean-ruby.com/) is one of the three or so most influential Ruby books I've yet read, and easily in the Top Ten for my career. Why? Quoting again, this time from the README of one of my current projects: &gt; Put another way, it's turned into an illustration of [Greenspun's tenth rule](http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule). Paraphrasing: &gt; &gt; &gt; Any sufficiently complicated Rails or Padrino app contains an ad-hoc, informally-specified, bug-ridden, slow implementation of [DCI in Ruby](http://dci-in-ruby.info/). &gt; &gt; Generally, the more abstruse, less functional half; and "sufficiently complex" can be interpreted as "more functional than DHH's 15-minute-blog example", but I digress. 
Symbols are Strings for almost all intents and purposes. For example, you can get the nth character from either one the same way: &gt; "hello"[1] =&gt; "e" &gt; :hello[1] =&gt; "e" You can even put the characters of a symbol in quotes, and it's the still a symbol: &gt; "hello" =&gt; "hello" &gt; :"hello" =&gt; :hello This way, you can put spaces inside symbols &gt; "hello world" =&gt; "hello world" &gt; :"hello world" =&gt; :"hello world" But there are a few differences. You can't add together symbols like you can strings: &gt; "hello" + "world" =&gt; "helloworld" &gt; :hello + :world NoMethodError: undefined method `+' for :hello:Symbol Also, they behave differently in RAM. When you make a new string, it makes a whole new object, even if the characters are the same. But if you reference a symbol twice, it will be the same exact one in memory: &gt; "hello".object_id =&gt; 21209736 &gt; "hello".object_id =&gt; 21068220 &gt; :hello.object_id =&gt; 395528 &gt; :hello.object_id =&gt; 395528 Notice how the object id is different for the two strings, but the same for the symbol? This should give you a practical, working knowledge of Symbols (assuming you are comfortable with strings), and a good model for what they are. The best approximation is "they're just strings!".
Question was about 1.0, not 1.8.
The big break was between Ruby 1.8 and 1.9. Upgrading applications from one to the other can be a pain, and modern ruby apps are unlikely to work on 1.8. Still, most people did the upgrade, it's not as different as python 2 and 3 (apparently). Ruby 2.0, 2.1, and 2.2 are less different than 1.9, but still of course introduce some new features (although generally not backwards incompatibilities, although occasionally). If you are starting with ruby, you want to start with the latest, 2.1, and under no circumstances with 1.8. Ruby `1.0` I don't even know, just don't.
This is a really cool article but he's making things more difficult for himself than he needs to. In particular, there's no reason to write a Cypher string in his model. Instead of this: def users_also_bought(limit: 3) query_as(:product). match("product&lt;--(user:`Recs::User`)--&gt;(other_product:`Recs::Product`)"). where('other_product.slug &lt;&gt; product.slug'). limit(limit). pluck('DISTINCT other_product') end He could just write... def users_also_purchased(limit: 3) Product.as(:product).where(neo_id: self.neo_id) .users.purchases(:other_product).where("other_product.slug &lt;&gt; product.slug") .limit(limit) .pluck('DISTINCT other_product') end His gemfile is set to an older version of the gem. In 3.0.3+, he could do this... def users_also_purchased(limit: 3) Product.as(:product).match_to(self) .users.purchases(:other_product).where("other_product.slug &lt;&gt; product.slug") .limit(limit) .pluck('DISTINCT other_product') end He's omitting relationship types entirely in his Cypher string, which will hurt performance, and if he ever chooses to change a model's name and/or labels within Neo4j, his Cypher queries will break. The second and third versions will includes relationship types and will improve performance in a large database. Not having to know Cypher and its best practices is one of the nice things about using the OGM. It makes it easy to write Cypher when you want or need to but if you're just getting started, you should let the gem do what it does best. 3.0.3 also introduced a `find_or_create_by` method, which would simplify some more of his code. In a production environment, you'd also want to add some uniqueness constraints within the database, `property :email, constraint: :unique`.
thanks, i think logger object was what i was looking for.
Serious/genuine question... why is Crystal worth looking into?
[Simplicity matters by Rich Hickey](https://www.youtube.com/watch?v=rI8tNMsozo0)
"Double bang" is an expression I will insert into my vocabulary :-) Until now, I called this "operator" simply what it is: a double negation (`!!x` = `!(!x)`). Happy Holidays
yeah, it's not really an operator, it's literally just two ordinary ! operators. 
He's done this talk a few times, but I really like http://www.confreaks.com/videos/763-rubymidwest2011-confident-code Confident Code by Avdi Grimm - I saw it at Ruby on Ales and it was really relevant, and continues to be relevant.
Compiles to native code.
Hi, I'm a pretty new programmer who's only done stuff in Java. I was just curious about using the ternary operator to assign true and false. Wouldn't it make more sense to just leave the assignment as a boolean expression? What I'm trying to say is wouldn't this: boolean isBigNum = (num &gt; 3); make more sense than this: boolean isBigNum = (num &gt; 3) ? true : false; So wouldn't this be a better way to write it (sorry if the following doesn't make sense, i dont really know ruby) var firstTimeUser = &lt;% @first_time_user %&gt;;
I'd say my top 3 Ruby talks are, in order: 1. [Ben Orenstein's Refactoring from Good to Great](http://confreaks.com/videos/1233-aloharuby2012-refactoring-from-good-to-great), which you already mentioned. 2. [Bryan Helmkamp's Refactoring Fat Models with Patterns](https://www.youtube.com/watch?v=IqajIYxbPOI) 3. [Katrina Owen's Therapeutic Refactoring](http://confreaks.com/videos/1071-cascadiaruby2012-therapeutic-refactoring) As a bonus, I also recommend watching [Ben Orenstein's hilarious talk How to Talk to Developers](http://www.confreaks.com/videos/2488-railsconf2013-how-to-talk-to-developers). He goes over a lot of different stuff regarding public speaking, but here are the highlights for me: * 19:30 The shittiest language he has ever worked with. * 31:19 Every talk has a nodder. * 32:35 Story about MIT students pranking their professor.
I really enjoy some of aaron patternson's. Just really light hearted, but he goes into great technical detail. https://www.youtube.com/watch?v=kWOAHIpmLAI
Ternary operations don't have to return boolean values, it could return an object (or string, or integer, etc) for meeting a true of false condition. If/else statement don't have to return booleans either, unless you make them so. var currentColor = &lt;% @user_is_at_stopped_at_light ? "red" : "green" %&gt;; [EDIT: java has ternary operators too]
I agree this example is kind of weird as far as using the ternary operator goes. Actually, the double-bang is a little odd, too. It guards against propagating a nil, sure, but I would expect that first_time_user field is only nil when the row is created but not saved, in which case logically the user *is* a first time user...
I don't think this is a great example. Converting Ruby objects into Javascript parameters is often a nontrivial task. Even though it turned out to be only a few additional characters this time, it's often valuable to generate the parameters hash in a helper; don't get in the habit of doing this mess directly in the template. But even *then*, if all you're doing is trying to detect nil, then the `nil?` method is even clearer (or, in this case, the `present? ` method if available). The double-bang is a boolean conversion, which adds some extra possibilities and therefore some extra mental overhead. (If I were reading this code, I'd say, "why didn't they use `nil?`? Could they maybe pass in `false `, too? Do I need to write my code with that in mind?")
Yes, Bryan's talk is one of my favorites, too. Looking forward to watching the other two.
Came here just to share that. Was not disappointed.
With bundler and a Gemfile, you get a set of gems defined by version that you can rely on. Do you currently use bundler, if not, start there. If you want them installed in a specific directory for a project, you can use `bundle package` http://bundler.io/v1.7/bundle_package.html A good use case for that is packaging up an application into a .deb/.rpm system package, I personally wouldn't do that for an everyday development environment. I use `chruby` with the auto-switching option turned on. https://github.com/postmodern/chruby You can use ruby-install ( https://github.com/postmodern/ruby-install ) for building and installing ruby, and it supports arbitrary locations for installations, by default I think it uses `~/.rubies/*` I note that my gems are loaded from `~/.gem/ruby/`. i.e. Ruby `~/.rubies/ruby-2.1.4` and Gems - `~/.gem/ruby/2.1.4/` You could also look into `direnv`, which is kind of a systemwide auto-environment switcher. 
[Bundler](http://bundler.io/) is Ruby's equivalent of Python's virtualenv.
I found [this](https://www.youtube.com/watch?v=BeyTsdkItg4) a while back. Using ruby and a 35 dollar computer to hack your home for diy home automation. 
To expand on that, bundler also allows you to install gems into a specific directory. Running bundle install --path=./gems will install all gems into the project's directory rather than the global gems directory for your ruby version. I use that for several small projects. It's not really useful for something like Rails because it won't install a *rails* command that is available globally.
Everything with Aaron Patterson, he is so charming and fun, and does great work. 
Congratulations and thank you to the Ruby team! I'm very excited about this release and really loving the focus on performance in the 2.x series.
Thanks for the Christmas present!
Totally, this guy is such a master mind. [This is also a good talk by the same guy, it's about solving problems in software](https://www.youtube.com/watch?v=f84n5oFoZBc) 
Not sure why you're getting downvoted, it is because of x-mas and it is true that haven't adopted semantic versioning yet. ruby-lang.org says &gt; Version Schema &gt; MINOR: increased every christmas, may be API incompatible
The reason that UNIX systems are easier to develop on is mostly because UNIX was originally built by and for programmers, and nowadays UNIXes usually ship with all kinds of development tools pre-installed (Ubuntu for example has editors like vim and emacs built in). I've installed Ubuntu in VirtualBox on my Win8.1 system and it works like a charm.
That is the best versioning policy.
Use CFLAGS='-fPIC' to compile it.
Right. That was their self-contradictory announcement. 
No, and let's hope it stays that way. Python tooling is so fcuked beyond belief. 
I didn't realize that "Semantic Versioning" with capital letters and a [website](http://semver.org/) and a strict specification existed. I always thought it just meant that you had Major.Minor.Patch versions with a consistent policy for what those numbers meant and whether they had breaking changes. So Ruby has the latter, in that they have a version policy, but they don't follow the "Semantic Version" specification. And now that I know, I guess I don't really care whether they follow "Semantic Versioning" at all, though they do have a version policy that's easy to understand and seems to be now applied consistently. And then I also read this about "Romantic Versioning": https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e
I really like this article, but am bummed that it ends on this cliff-hanger: &gt; In our next post we will explore how you’d approach tuning the Ruby GC for Rails applications, balancing tradeoffs of speed and memory. Leave your email address below and we’ll let you know as soon as it’s posted. 
I had watched this one and forgotten the title and the name of the speaker... now I can rewatch it. Thank you!
Made me buy his book with the same title. 
Nope, they're still using Semitic Versioning.
On mobile so not a real answer, but do look up "duck typing". http://en.wikipedia.org/wiki/Duck_typing If that's too basic/obvious then I suggest grabbing a copy of Sandi Metz' book. This is a great exploration of idiomatic Ruby OOP. http://www.poodr.com/
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duck typing**](https://en.wikipedia.org/wiki/Duck%20typing): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) with [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) [programming languages](https://en.wikipedia.org/wiki/Programming_language), __duck typing__ is a style of [typing](https://en.wikipedia.org/wiki/Type_system) in which an object's *[methods](https://en.wikipedia.org/wiki/Method_(computer_programming\)) and properties* determine the valid semantics, rather than its [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming\)) from a particular class or implementation of an explicit interface. The name of the concept refers to the [duck test](https://en.wikipedia.org/wiki/Duck_test), attributed to [James Whitcomb Riley](https://en.wikipedia.org/wiki/James_Whitcomb_Riley) (see history below), which may be phrased as follows: &gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. &gt;In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. For example, in a non-duck-typed language, one would create a function that requires that the object passed into it be of type Duck, in order to ensure that that function can then use the object's walk and quack methods. In a duck-typed language, the function would take an object of any type and simply call its walk and quack methods, producing a run-time error if they are not defined. Instead of specifying types formally, duck typing practices rely on documentation, clear code, and testing to ensure correct use. &gt; --- ^Interesting: [^Boo ^\(programming ^language)](https://en.wikipedia.org/wiki/Boo_\(programming_language\)) ^| [^Polymorphic ^association](https://en.wikipedia.org/wiki/Polymorphic_association) ^| [^Operational ^definition](https://en.wikipedia.org/wiki/Operational_definition) ^| [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn58hep) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn58hep)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Interesting, I will take a look!
You pretty much want pipelines where you pipe the output of one function into the the mouth of another. Something like the following: def generate relevant_violations &gt;&gt; convert_to_comments &gt;&gt; convert_to_text &gt;&gt; save_to_file end I actually wrote a helper gem (arrows) that does just this using procs https://github.com/foxnewsnetwork/arrows Personally, I recommend you use this so-called "functional" method of building your data transform processes instead of the object oriented way of something like violations.to_texts.select(&amp;:stuff).map(&amp;:other_stuff) because the object-oriented way leads to bloating of the violation object and forcibly marries your transform process to your object which then makes your process brittle. 
You seem to primarily be asking for a dependency injection system. DI isn't really used in the Ruby world, I'm sure if you dig deep enough you can find an implementation but it's not really idiomatic. 99.9% of the DI usage I've seen in Java is only used for testing and mocking / stubbing is vastly easier in Ruby than it is in Java making DI unnecessary for it. In the 0.01% of cases where you actually need some sort of variable implementation at run time, there are many patterns that make this very easy, e.g. invoking a class from a string containing it's name is dead simple in Ruby. 
What your missing is that `@first_time_user` is probably not a boolean, it's probably a User object of some sort. Ruby, like many dynamic languages, has 'truthy' and 'falsy' semantics for branching. `if @first_time_user` is really a nil check, it will pass unless @first_time_user is nil or false. 
You should come out for the conference next year, March 5-6th in Bend, Oregon. https://twitter.com/rbonales/status/536595540788531200 I'd offer to buy you a beer but it's open tap! :)
If your "interface" consists of just one method (there are a lot of these one-method patterns in the Gang of Four book) you could use a block instead in Ruby.
That looks really useful, thanks!
Modules are overused and should be shied away from in most idiomatic ruby OO code.
I'm not sure about display and print, but inspect is used for debugging and to_s is used for display. For example, inspect on an array gets you: arr = [1, 2, 3] arr.inspect -&gt; "[1, 2, 3]" If you use string interpolation or puts, it will use to_s automatically. If you use the function `p`, it will automatically use inspect.
Can you elaborate? How are they overused and what is the solution?
Yes: https://github.com/plum-umd/rtc Matz also discussed adding some limited forms of static typing to Ruby 3 at this year's RubyConf
Hmm. So p is functionally different than puts? I thought it was just shorthand.
`p x` is shorthand for `(puts x.inspect; x)` Edit: thanks to /u/losangelesvideoguy for the pedantic correction :)
Yep! p should really only be used for quick debugging. It's part of the reason it's such a short function name.
`puts` implicitly walks arrays. 
basically, that's just how the people who made the language decided it should work. http://www.ruby-doc.org/core-2.1.5/IO.html#method-i-puts edit: you can click the toggle source and find the actual line that's making it work: if (rb_exec_recursive(io_puts_ary, argv[i], out)) { continue; } that's not very helpful, I admit, but it explains how it happens, if not exactly why.
sure! programming is mostly trial and error. don't be afraid to try things and see how they come out. `puts` happens to work this way, but other functions may not. if you had to use the double (nested) `.each` like in the example, would you understand how that works? it's going through each sub-array in the outer loop and each individual element in the inner loop. if you had three levels of arrays, you'd want three loops. here's one to play with: `[ ['1', ['one', 'uno']], ['2', ['two', 'dos']], ['3', ['three', 'tres']] ]`
I can't keep up with these new releases.
Often #to_s and #inspect are the same on a given object. But #inspect is always a sort of developers's debugging output of something to see what it is. to_s is converting something to a string, in whatever way makes the most sense for a given class, it can vary. Sometimes it's what might make sense to display to the user (rather than a developer). Sometimes it's something else. It may or may not be useful for a given class, you just have to look at docs or try and see what it does. I've never actually used `print` or `display` in my buncha years of ruby! :foo.inspect #=&gt; ":foo" :foo.to_s #=&gt; "foo" Sometimes the distinction doesn't make much sense at all, and it's just two variant string represnetations. f = File.open("foo", "w") f.inspect #=&gt; "#&lt;File:/tmp/foo&gt;" f.to_s #=&gt; "#&lt;File:0x007fec354f0500&gt;" 
This is really cool, thanks! I hope to add my own work to it some day.
If anyone else is curious about why they added `next_float` and `prev_float`: https://bugs.ruby-lang.org/issues/9834
Wellll, not exactly. That's the method definition, but it's effectively more like `(puts x.inspect; x)` That is, it prints `x.inspect` but the value of the statement is x rather than the return value of puts (i.e., nil). Calling return like that would be… problematic. You're not really wrong, I'm just being pedantic. :)
Greatness starts at around 42:00
DI is useful in every OOP language ("program to an interface not to an implementation" has been good practice for years). It enables you to switch out dependencies of classes with very little pain [1]. Littering your code base with constants (aka implementations) just leads to pain later on. You could replace them in tests/during runtime thanks to Ruby, but that's messing with global state and therefore bad practice. [1] &gt; In the 0.01% of cases where you actually need some sort of variable implementation at run time DI is useful for that use case, but that's not the main reason you do it. Look up O(pen/closed) and D(ependency inversion) of the SOLID principles.
To add to the confusion :-) there is also method pp. Try it on a large nested structure of Hashes and Arrays and see the difference to p. (Note: you need to require 'pp' to use it.) That method is also a debugging tool like p but with better presentation in case of large structures.
&gt; In general, in ruby, you can't change the class of an object already created, ever. irb(main):016:0&gt; a = 10 =&gt; 10 irb(main):017:0&gt; a.class =&gt; Fixnum irb(main):018:0&gt; a = a.to_s =&gt; "10" irb(main):019:0&gt; a.class =&gt; String irb(main):020:0&gt; Am i missing something here? 
Some things to ponder: http://codepad.org/Sh9joLaM - to_s is an implicit conversion except within double quotes and when called via puts or print. - print does not append the newline - p calls inspect rather to_s - inspect is intended for debugging purposes. And not a part of your question but important is to_str which is used to test the equality of string like objects - pay close attention to the absence of to_str in Baz and the effect of the handedness of the klass on which to_str is called. 
Always look on the bright side of life! ♫♫ :)
It's not in one folder, but did you take a look at [RVM?](http://rvm.io/)
POODR may be too remedial for someone who is well versed in OOP from other programming languages.
Ok, thanks! I think I know what you mean. For arrays that aren't multidimensional, my solution would get the same result, but their solution would allow for more operations, so this one would be better suited for more complicated applications.
You changed what object the `a` variable holds, but didn't mutate the class of any object -- #to_s returns a new object. irb(main):001:0&gt; a = 10 =&gt; 10 irb(main):002:0&gt; b = 10.to_s =&gt; "10" irb(main):003:0&gt; a.class =&gt; Fixnum irb(main):004:0&gt; b.class =&gt; String irb(main):005:0&gt; a.equal? b =&gt; false You can always assign a variable to a different value, but doing so doesn't actually mutate any values -- any other variables that held the old value still hold the old value, unchanged. Compare to methods that actually mutate the value. If you actually mutate the value, then that is of course reflected by any other variables that point to that same value. irb(main):006:0&gt; a = "123" =&gt; "123" irb(main):007:0&gt; b = a =&gt; "123" irb(main):008:0&gt; a.concat "4" =&gt; "1234" irb(main):009:0&gt; a =&gt; "1234" irb(main):010:0&gt; b =&gt; "1234" irb(main):011:0&gt; a.equal? b =&gt; true Ruby does allow you to mutate values, in a variety of ways depending on the particular class of the value. For instance, `concat` on a String. But ruby doesn't allow you to change mutate a values class. Which is presumably what a, for instance, `#to_s!` method would do, as opposed to `#to_s` which returns a new object. `#to_s!` does not actually exist. The `equal?` method is the "identity" method in ruby, it returns true only if the two arguments are the exact same object -- both variables point to the exact same object, such that mutating it will be reflected in both places, because it's just one object in memory. 
Module mix-ins are really nothing more than multiple inheritance. A module used as a mix-in is essentially just an abstract class used for multiple-inheritance. (Modules in ruby are also used for simple namespacing, which is a different thing). 
No, POODR is *exactly* what xenonscreams needs to map Java knowledge to Ruby.
If you are serious about learning Ruby, read that book. It is basic OO stuff, but it will help you connect the dots from your experience with Java to Ruby.
As someone "who is well versed in OOP from other programming languages" (C++, Java, Smalltalk, Python, etc), POODR is easily one of my Top Three Ruby Books Ever™. There are *important* differences in the way you think about OO in Ruby and the way you think about OO in most other languages, *especially* statically-typed ones. I, too, had done some Ruby very early on (in the 1.2 days) before spending a decade in the PHP Wastelands. It took me a good *year* before the light bulb really came back on brightly, even after reading POODR (though it, [*Eloquent Ruby*](http://eloquentruby.com/), and [*Clean Ruby*](http://clean-ruby.com/) **together** likely would have done a better job of getting my head screwed on straight). OP, good luck!
I don't think Ruby is dead or dying, but arguments like "Well, why would the core developers be talking about maybe perhaps someday working on performance if ruby was dead?" (what?), and "Cobol isn't dead either! it's still a 'vibrant part of the world of computing'!").... ...make me more worried than I was before I read this article, if people feel the need to resort to arguments like that. 
Where I work, Ruby is a huge code base, next to java, which I heard in a college class that Java was dead. I basically see it as, if you can do it in whatever language you feel comfortable in, then its not dead, just not as widely used. 
To me, [Why Ruby?](http://blog.codinghorror.com/why-ruby/) by Jeff Atwood (of Stack Overflow and now Discourse fame) is still the definitive piece on the whole "ruby is dying" meme. Here is a teaser: &gt; Ruby isn't cool any more. Yeah, you heard me. It's not cool to write Ruby code any more. All the cool people moved on to slinging Scala and Node.js years ago. Our project isn't cool, it's just a bunch of boring old Ruby code. Personally, I'm thrilled that Ruby is now mature enough that the community no longer needs to bother with the pretense of being the coolest kid on the block. That means the rest of us who just like to Get Shit Done can roll up our sleeves and focus on the mission of building stuff with our peers rather than frantically running around trying to suss out the next shiny thing.
Let's just say it is not a particularly deep article :)
It's really an end of the year "fluff" piece addressing some of the things I've heard mentioned over the years. It's by no means meant to be a deep dive.
the cool people now are moving to #go and rust :)
Like it's going to hurt Ruby to execute code more efficiently if it can be done without trading off features. I do kinda wonder why people would focus hype levels, though. I'm a total newbie and picked Ruby as my first language. I really like what I see so far, even managed my first bug fix on someone else's code. Even if the fix itself would be fairly trivial for an experienced programmer and isn't quite perfect enough yet I'm still happy about it. The only thing that seems potentially constraining down the road is the amount of performance hit between Ruby or using some other language.
The Perl is not dead articles have been more convincing. :)
And if you really insist on choosing between multiple such at run-time, create a collection of lambdas. I use modules as mixins pretty regularly. One classic use case is for presenters; take a look at what Avdi Grimm had to say about such things in [*Objects on Rails*](http://objectsonrails.com/), for instance. His implementation code is often a bit dated (it was written when Rails 3 was new and shiny, and works just fine up to 3.2.*x*), but the *ideas* are generally sound
The idea is frankly absurd. Ruby has a vibrant community with an incredible amount of talent. Python 3 has been out for six years, but slow adoption has force the maintainers to extend 2.7 through 2020. Perl 6 has been in development for almost fifteen years, but has yet to see a stable release. Meanwhile the Ruby community not only completed the rocky transition from 1.8 to 1.9, but has been able to move forward evolving both the language. Not only has the language evolved, so have the implementations, plural. Perl has multiple implementations for 6, but none of them are stable or complete. Python has multiple implementations, but they are not at version or feature parity; pypy doesn't have a GA for 3 yet and jython doesn't even have a GA for 2.7. Ruby, on the other hand, has three top tier implementations in MRI, JRuby, and Rubinius. With the Christmas release of MRI the other two are technically behind, but both projects have already implemented the new language features.
Really? For me, it felt like OOP 101 -- possibly because I was already well versed in both ruby and OOP before I read it. I assumed that folks with a strong understanding of objects/messages would find it remedial. Your feedback has convinced me to recommend the book in these circumstances.
Of course it will help ruby if it becomes faster. But that the ruby devs off-handedly mentioned that they were interested in improving performance, without any actual plan or commitment to do so -- is not an argument that ruby isn't dead. Heck, even if they had a plan and commitment it wouldn't be. "If it were dying, why tackle these issues now?" is just a plain silly argument to convince someone that ruby isn't dying. People work on dying things all the time (often in an attempt to keep them from dying, sometimes succesfully sometimes not). 
At least Rust is worth watching. It's a completely different domain from what Ruby wants to cover, and it looks like it's very much worth having both firmly in your tool belt.
I'm glad you've understood the point they were trying to convey. It's so easy to get caught up in the practicality of code and ignore the intentionality of it. Good luck!
Seriously, I am a rubyist and am not particularly worried about ruby dying, I think it and it's community are doing pretty fine. But if I wasn't sure, or didn't know ruby and it's community well, and read this article -- I'd be inclined to think that ruby _was_ dying if people were making arguments like that! "It's not so bad being cobol", really? Heck, I _am_ more worried now than before I read the article! 
This is mostly based on conversations i've been hearing on my travels this year. I don't think Ruby is dead, and I wanted to address it in a year-end light piece.
I like the look of it, but still having trouble on what i would use it for :)
&gt; which I heard in a college class that Java was dead [mrw](http://i.imgur.com/bZWGhrK.gif)
So "bang! bang! You're boolean", then. :ducking:
I don't like my tools to reduce through oxidization.
Does this also aggregate feeds from Green Ruby?
Just wait until it gets old enough that it becomes cool again.
Edit to add: for 00_hello I can get it to work by changing `require "hello" ` to `require "./hello"` and then not running `rake` but `rspec hello_spec.rb` But this method does NOT work for the next test file in 01_temperatures.