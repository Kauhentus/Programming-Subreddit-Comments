I'd rather not. Facebook is very harsh for any automated actions through UI, able to ban entire subnetworks in a minutes.
Ha, I'll fix that. As I work in e-Commerce, and almost no online stores function without JS due to payment details being tokenized on the front end (among other things), I forget people like you exist. But don't worry, I'll show you some love and make sure things fall back correctly. It's a quick fix. ‚ù§Ô∏è
GREAT List.
WORK IN PROGRESS! I need your help - This guide is intending to help identify issues with a ruby on rails deployment unrelated to bugs. Things like server scaling, CDN etc. It assumes you are working in an environment with decent test coverage and no recent deploys have been made but you are getting that "Shit the site isn't working" text message. Leave your comments here on what doesn't make sense / what I am missing. I'm planning on building this out into a robust guide including top tips and solutions for solving each of them. Thaaaaaaanx
tldr -&gt; no.
&gt; I forget people like you exist let's just say that with spectre out there I'm bit more paranoid then usual :) and thanks ;)
You may have changed my life
You had to install a gem unfortunately, get a look at this diva...
I'm not recommending one over the other, just putting the doc links out there in case the OP's company uses it. 
Oh woah, I was totally unaware of this. Thank you for pointing out. I am going to add this information to the post and make sure I give the appropriate credit. My apologies!
Since you have done something similar, it might be useful to OP if you estimated around how many developer-weeks it took, with developers of what experience level. 
That's pretty exciting, because it will let me search for things that are not a published gem.
[Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines) ;)
This is awesome!! I have quite a few place I could use this. Looking forward to trying it out. Thanks for your efforts.
This would be nice for a Markdown-based usage (sorta like Perl's [`Pod::Usage`](https://metacpan.org/pod/Pod::Usage): require 'tty/markdown' require "optparse" OptionParser.new do |opts| opts.on "-h", "--help" do $stderr.puts TTY::Markdown.parse(DATA.read) exit end end.parse! __END__ **foobar** - command to do something ## Usage `foobar [options] file` * `-a` This does foo * `-b``MAP` Mapping for something ## MAP Map is a list of blah pairs ## More Info - [Docs](http://example.com/docs) - [Bugs](http://example.com/bugs)
Remember when the slogan was "better living through technology"? üòú
The questions start off okay, then towards the end get into some trival details that people might not be familiar with. A good interview activity would be code reading. If the interviewee has public code read through it with the interviewer and explain the problem, how it was uncovered, different solutions that were attempted, how the final solution became implemented, and then have them walk through the implementation. Can always ask for "what could you do to make this better" etc. If they don't have public code, then the company interviewing can have some solutions to some ruby kata programs (like converting numbers to roman numerals) ready, have the interviewee attempt to read through the code. Give them the prompt "there is a critical system that was built by one programmer who mysteriously left, you need to decipher what the program does, and how it does it". Even if they don't know a method or some specific syntax, pay attention to the questions they ask. The point itsn't to see how much syntax trivia they've memorized but rather how well can they communicate. If you can communicate well, you can learn syntax. If you can't communicate, I don't care how much syntax trivia you know. 
This was originally part of JRuby. It was split off because it had very little code in common with its ancestor.
This is great!
Will make for some great vim preview
If crystal could easily import or be imported by Ruby it‚Äôd be quite a bit more interesting, to me. (Via C maybe, via Ruby instruction code maybe, have thought through none of the details.)
Thanks for this!
https://github.com/SamSaffron/lru_redux
By "efficiently" you mean performance? Benchmark it and find out! 
Great article, thanks for your sharing
"Just another Ruby hacker," hacker," r," ,
I don't know, I don't think building a production-grade LRU cache should be considered beyond an average ruby programmer's capabilities. We're not talking about an elaborate piece of machinery like a database.
Interesting, in his code he actually just uses one hash without a linkedlist and shifts things off when capacity is reached.
For anyone else reading this, here is a formatted version: a = ["a","d","b","b","a","b","c"].sort b = [] y = 1 i = 0 while i &lt; a.length if a[i] == a[i + 1] y += 1 i += 1 else b &lt;&lt; { a[i] =&gt; y } i += 1 y = 1 end end /u/elaitman1, I take it you are trying to count the number of times each letter occurs and return that in order of the number occurrences?
Thanks! I hope you write some awesome Ruby tools with it! Consider contributing back your use cases as usage examples. 
I really like this! If you don't mind I would really like to use this as an example in the docs. I think it's important to demonstrate how this library can be used in the wild!
How do separate statements break or otherwise obscure the flow?
Should be fixed now. Thanks for keeping me honest! üôèüèª
I agree with your comment. I've personally had a hard time enjoying the "joy" of yield_self in general. I haven't yet found a use case that I prefer it in. To me personally, there is a happy medium in the code examples listed. While it's just an example, I feel like it's not fair to compare yield-self to a "longest-form-scenario". I would have written it like this: # But first, I doubt just using `#url` for the method name is # a bad idea compared to `#construct_url`! data = JSON.parse Faraday.get(url) server = data.dig('object','id') || '&lt;undefined&gt;' "server:#{server}" In many example I've seen, yield_self is being used to chain an API url into data, and possibly transform it. I personally really don't like how that feels with yield self. I strongly prefer to use a construct where I'm saying "I want the json value of this web request" and doing what I need with it. It gives you a chance to change contexts of the data in your pipeline. Sure, you might assign a few extra vars along the way... but I think it helps significantly with human interpretation. I haven't yet come across my "A-Ha!" moment, though I'm sure it will creep up on me somewhere. But you know what, that's what's cool about Ruby. If yield_self makes someone happy, then I guess that's a good thing.
Yeah, I'm in agreement. Arguably the chain of `yield_self` and `dig` calls represents _one step per line_, but with just straight procedural code you can use whitespace to group related lines of a single step. So: response = Faraday.get(url) data = JSON.parse(response) server = data.dig('object', 'id') "server:#{server || '&lt;undefined&gt;'}" Scanning the code, the reader can see three distinct steps, because of the whitespace in between each of them. I tend to leverage whitespace a lot to group related lines of code, versus employing techniques like method chaining.
Not going to lie, I always really loved Visual Basic.
üëè
 # wicked way "Ruby".yield_self.cycle.take(2) # =&gt; ["Ruby", "Ruby"] In Ruby the idiom for this is `[‚ÄúRuby‚Äù] * 2`.
I disagree that they explain things clearly. I read them and don't get it. That's why I asked for other tutorials using ruby.
Congrats! Which one is yours? 
ComfortableMexicanSofa one
Have you been on this page already? https://developers.facebook.com/docs/facebook-login/access-tokens
Funny how above example demonstrates how easy is to write broken code when temp variables are used. `server` is vivified in conditional block only and code may work only coincidentally because *parser not runtime* put it in namespace and assign nil.
Neat stuff! Reminds me of [this cool article](http://nullprogram.com/blog/2014/01/04/) about Emacs Lisp's guts.
If the administrator needs to manage data which is on the website, their application will need to connect to the server that is running the website. A locally packaged rails application will not do this but would instead connect to a local database. If that is the case, you might consider building your administrator interface in rails, and deploying a single site browser using something like nativefier to build an executable that just visits the url of the rails app. https://www.npmjs.com/package/nativefier
This is sick. I can justify it's use, I'll deploy the rails app on heroku and job done. That was my initial thought (a wrapper) but it's a lazy solution. The project needs to have an online administration board and the Desktop application. A wrapper makes the user experience consistent...
Seems like familiarity always impacts one's perception of "readability" or quality in general. I was not trying to say that the method chaining approach was _wrong_, but rather, I appreciate (and prefer) a plainer approach.
Yep, correct you are. JavaFX is replacing Swing. http://www.oracle.com/technetwork/java/javafx/overview/faq-1446554.html#6 Looks like they are keeping Swing around for backwards compatibility reasons, but won't be adding to it anymore.
I'd appreciate any feedback! Was this helpful, difficult to read, make you curios about exploring RSpec?
You can also use it for a new one!
I avoid named parameters on mandatory arguments making it def initialize baz @baz=baz But I bet you have a reason not to use this in the real implementation
Hmmmmmmm. Nope. No I do not have a reason. You‚Äôre completely right, as in, that should solve my issue. I relatively new to SOLID design and other OOP principles and anti-patterns. I got so caught up in dependency injection and, what will later be, use of composition over inheritance, that I became married to the idea of named parameters. But they are unnecessary! Thank you for your input and taking the time to look though my problem. So by not using named params, the burden of needing a `baz` falls to `Bar` and the burden of needing a `bar` falls on `Foo`, just as it should be! Thank you! 
Haha, it happens to me all the time too. I thought you had something like 4+ parameters making it awkward not to use named. Glad to help
Dude, this is awesome. I just bookmarked it! Thank you. I have a few websites I'm tired of "visiting" inside the browser. This would make things easier just for the specific use case.
Oh, there are 4 params, but I think the other two can be named through an option hash, perhaps. Hmmm, I‚Äôm not quite sure what‚Äôs best
To me it seems just as plain, but yeah, everyone reads differently. 
You can mix named and unnamed def something mandatory, not: nil, howmany: 4 
`def initialize(bar: Bar.new)` As you've written that, if you don't pass an argument, and it tries to take the defautl value, `Bar.new`, then it will _raise_ because its missing Bar's required initialization parameter. So no, that's never okay. You have a default argument that actually will always result in an ArgumentError being raised if used. So you don't really have a default argument value at all. You have a required argument, not an optional one with a default value. So just write that. 
Thanks! Something about being so new to design principles for the first time has really gotten into my head; I always seem to think things are more complex than they really are! Thanks for the clarification and for your time!
"design patterns" are meant to help you write reasonable code, but it can be tempting to try to let them do your thinking for you, in which case they'll get in the way of reasonable code instead. 
Do you mind if I use this as the foreword for my next book? ^* ^* *(I'm never going to write a book, but if I did ...)*
It sounds like you have some other options going already, but just one to know about: http://shoesrb.com/
To be brutally honest there was nothing here Is haven't read many many times before. It wasn't bad in any sense but it was short and contained nothing new.
eeerm, def something_mandatory, not: nil, howmany: 4 surely?
`mandatory` is the first, non-keyword arg to the method `something`.
oops, my bad.
I‚Äôm not sure how named/unnamed is relevant here. You can still have a mandatory named parameter (as long as you are using ruby 2.1 or greater)
what are you trying to do, why not use reddit api
works awesome now, thx :)
You can also do named but required parameters: class Whatever def initialize(some_name:) end end Now `some_name` is a required named parameter. Whether the parameter is required or not does not depend on if it's named or positional: either can be required, or optional by having a default. 
Hi, I'm glad to hear this :) I have worked in [this game](http://alevagames.com/super-bombinhas.html) for very long, but never finished (it is quite large and demands a lot of artwork). It demonstrates almost all the potential of the library, but for now I haven't made it open source... Maybe I'll do it someday. On the other hand, I have [this other ongoing project](https://github.com/victords/dungeons), which is simpler, but already useful as reference. To run it, just execute "src/main.rb" with ruby. Have fun!
What I have found very useful is to take the specification of the feature and try to "rewrite" the specification with the description of the tests. And then "implement" the tests with code. The problem that I have found many people have is that is not easy to know where to test the behavior... They don't know if they should write system tests, controller tests, model tests... I wrote an article comparing three different ways that I have seen... maybe it could help you http://bhserna.com/2018/3-different-ways-of-testing-your-rails-app.html
Yes! You‚Äôre right, being named/unnamed (i.e. positional or not-), doesn‚Äôt make a difference; it‚Äôs either required or optional that I was looking for. 
Hi there! To get started, you could check [the project's wiki](https://github.com/victords/minigl/wiki/How-To). Unfortunately, it doesn't cover everything the library offers, so for the rest you'd have to go for [the documentation](http://www.rubydoc.info/gems/minigl/).
This is deep
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rbspy/rbspy/.../**ce8a99162492b1d4662e81475ff0ce4af3db516d** (mac-support ‚Üí ce8a991)](https://github.com/rbspy/rbspy/tree/ce8a99162492b1d4662e81475ff0ce4af3db516d) ---- 
They'll be well prepared to find new jobs... At the job inteview: - So, we'd like you to implement FizzBuzz, have you heard of it? - I literally wrote the book on it!
You understand right. Until 2.4 Ruby's Hash were really implemented as hash table+linked list. So it is were exactly similar to classic LRU structure (except you have to manually delete an reinsert items, as you correctly described). Now it has different structure, but it preserves whole semantic. So, yes, using manual delete and reinsert you may efficiently use Hash for LRU. Btw, there is mine https://rubygems.org/gems/inmemory_kv that could be used if your data can be serialized. It is a bit more memory efficient. And doesn't encounted by GC.
hello Matt
hello matt
There's a funny article about a job interview with fizzbuzz - let's try using machine learning (w/ tensorflow) in python -&gt; http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/ A more realistic real-world fizzbuzz is the Enterprise Edition (in Java) -&gt; https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
The idea is to write on the white board next time: $ gem install fizzbuzzer $ fizzbuzz prints 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, ...
Will do. Thanks! 
I really like what you've done with the TUI driven stuff. Very impressive work. Using something like chroma to come up with a color palette for the scale view is fairly inspired, and not usually something you'd see in a TUI app. 
Came for the welcome, left for the bad pun. Came back for the cheetos.
Agreed!
I love this
Freakin amazing. I'm learning Ruby, and I play a tonne of instruments so I can easily see myself using this in the future.
Hi! 
At RubyConf 17 this guy demoed his software (pretty bitchin'): http://sonic-pi.net/
Awesome! I will definitely use this... I'm wondering what ideas you have for representing wind/brass instruments since the notes are less visually obvious and the key of the instrument. I'm thinking of how I might add a representation for trombone for example.
This is amazing, thank you for working on this! Do you have any plans/interest in adding 9ths, 11ths and 13ths?
This is a pretty neat project indeed. Just tested here and has great potential for ruby musicians to experiment with!
Thanks a lot!
Thanks!
Yes! I'm looking forward to add a representation for flute. And it seems to me that it can be tweaked to help on Clarinet, Oboe, Sax, as they use Boehm system. Now about trombone, it seems really interesting! I found an image here that helped me to visualize: http://www.traditionalmusic.co.uk/its-easy-to-make-music/make-music%20-%200106-1.png It's probably not that difficult, maybe just need to highlight where exactly should that main part (sorry my absence of terms) be slided to really.
Thanks, it means a lot really :)
Thanks a lot, that means really a lot for me. Now that you say, we should definitely have those options. But the functionality exist tho, with --tertians SIZE option, using 5 for 9ths, 6 for 11ths and, 7 for 13ths. But adding options with those specific names could make it more accessible.
Thanks a lot. I'm planning into making all the output colored soon. And also adding some suggestions of 16bit true color terminals for all our TUI/ASCII delight.
Thanks!
Really beautiful command line app. I love music, but I don't really know the theory and such and this is definitely a great starting point. 
That was so bonkers. The music at the aquarium was top 3 of the week for me. Pure bliss and intrigue.
Yeah, I made sure to stop by after maxing out my daily food budget on steak, glad I did.
Yeah, but I have yet to combine them.
Neat, how does it compair to Gosu?
Very cool. 
Thank you so much. I always wish that there were more GTK tutorials or Ruby. There are almost none.
Some of the ones I use most frequently are json, erb, ostruct, and benchmark.
I used this in a job interview and got 9999999999 job offers
**If** the `arg` inside is compact, and **if** you don't any post-processing of each method's result... Then maybe. Otherwise, I don't think a lot of people love the code looking like: File.write('result.json', post_process([title, JSON.parse(Faraday.get(domain + path + ".json", limit: 100).body, symbolize_keys: true).dig(:result, :elements)]))
```module Dry class Matcher FormOrErrorMatcher = Dry::Matcher.new( success: Case.new( match: -&gt; value, *pattern { result = value.to_result result.success? }, resolve: -&gt; value { result = value.to_result result.value! } ), failure: Case.new( match: -&gt; value, *pattern { result = value.to_result result.failure? &amp;&amp; (pattern.any? ? pattern.include?(:exception) &amp;&amp; result.value.is_a? StandardError : true) }, resolve: -&gt; value { result = value.to_result result.failure } ) ) end end``` I found this over complicated. For me there is zero happiness writing this kind of code.
Can I PM you so we can possibly chat? I have lots of questions.
You should see the stuff Sam Aaron used to do with a Clojure repl and Supercollider. It was even more amazing.
Thanks. Checking it out!
Thank you, Lynda has nice courses on the topic. Wikipedia + Coltrane(this software) can also give you a hand. A good starting point would be to check about musical intervals. It's where my music theory interest has started. http://www.wikiwand.com/en/Interval_(music)
Sorry what u mean 
Thanks!
Thanks. Very nice experiments, reminded me a lot about the KraftWerk spirit.
Add your LICENSE, README, etc. files to your `spec.files` in `binance.gemspec` in addition to the `lib/` dir files you've already added so they ship with the gem. Remove the `spec.bindir = 'bin'` line, since those are Bundler dev files not your gem's executables. They shouldn't ship with your gem as bindir executables. (Bundler has the odd convention of an `exe/` directory, as opposed to the longstanding `bin/` RubyGems convention.) When you follow Bundler's way, use ``spec.bindir = 'exe'` instead if you ship executable files. In your case you can just omit the line until you have an executable. You might consider adding frozen string literal comments to all your Ruby files. Congrats on cutting a nice-looking gem!
Hi. It is actually an extension to Gosu, it is built upon it. The main features are: easier resource management, sprites/animation, movement/collision, GUI controls, tiled maps, easier text manipulation.
Wow thank you for the guides and resources. Will check it out! 
I haven't gotten fizz buzz yet but I like fizzbuzz = -&gt;(n){ [[ ["Fizz"][n%3], ["Buzz"][n%5] ].join].find(Proc.new{n}){ |result| !result.empty? } } 16.times do |n| puts fizzbuzz[n] end Provides opportunity to talk about a few different things in Ruby. I've asked friends on why they would use FizzBuzz and it comes down to 'see if they can code'. There seems to be a stigma that Master &amp; PHD degrees know how to research but not code. 
Oh, well that is pretty cool.
1. Tests 2. Exceptions/encapsulation of gem/API internals Faraday exceptions are passed to caller, etc... They should be wrapped in an exception (or exception hierarchy) specific to your gem. Otherwise client will do this: begin client.klines symbol: 'NEOETH', interval: '1m', limit: 1 rescue Faraday::Error =&gt; e # something... end Then if you choose to change to `Net::HTTP`, existing users code will break. In addition, clients are unaware of what exceptions are raised. Would be nice if params uses Ruby conventions: `client_order_id` instead of `clientOrderId` and maybe even `quantity` instead of `executedQty`. In general your client should enhance user's experience when dealing with an API. 3. Use `public_send` instead of `send` This prevents calling methods that are not meant to be called. In general I'd only call `send` on classes I created. In [this case](https://github.com/craysiii/binance/blob/23533bb44bc2e4534950957fc1c7710c5db882f1/lib/binance/client/rest.rb#L100) it appears unnecessary. Nice to have: Debug option to output HTTP request/response (though I don't thin Faraday supports one of these). 
Thanks for taking a look, and for the awesome advice :) Regarding bindir - I did think that was quite strange when I first generated my gem project. I'm using RubyMine, and figured that it had generated that because I was developing on Windows at the time (switched to WSL with Ubuntu). Could you expand a bit on the frozen string literal comments? What are the advantages? Just trying to understand, again thanks!
Because you're a consultancy and you want to maximize billable hours by making things overly complex.
Don't forget to fix styling and other code quality things as well: https://app.coditsu.io/opensource/builds/commit_builds/1562a833-2aed-46ab-a136-127231795613/validations
You‚Äôre probably missing cacert.pem and/or SSL_CERT_FILE env variable pointing to that file.
I would argue that if your app really has "a couple of hundreds of models" (and let me be frank, I don't believe you), you're bound to run into other problems, and maybe Rails or, more generally speaking, a monolithic approach might have been a bad choice. To answer your question, "dude": yes, absolutely, but you need a team that understands Rails and embraces the choices it makes, and such a team is hard to come by. In almost all projects I've encountered that employed Trailblazer and the likes, the team largely consisted of people who considered Rails beneath them, many fresh from university. It seems to me that there is a much stronger emotional pull towards complicating Rails than an actual need. I've been consulting and teaching Rails since 2005 and have billed a considerable amount of hours for _removing_ Reform (et al) from Rails apps because the fuzzy shifting of the source of truth led to ridiculous bugs that could easily have been avoided by Keeping Things Simple. So, I guess, thanks for that.
Trailblazer rings a bell?
It's lacking tests. I get that it's an api wrapper, but you need to ensure that your methods do what they suppose to. Look into VCR to set up external api tests. You also need to test things that don't require mocking.
Are you developing on Windows? Most likely the cacert.pem issue that cray4k mentions. Follow the top answer here: https://stackoverflow.com/questions/5720484/how-to-solve-certificate-verify-failed-on-windows in step 1 you don't have to use that directory. You can put the file in any directory just so long as you specify the correct system variable VALUE to the right path. Hope that helps!
I think the way in article is not a only sure way. But you couldn't disagree that culture of code is evolving. I we looking out to new rails updates we will see that developers of framework presenting a tools for "more OOP" programming instead of simple "Put all business logic to your models". Is that a more complex way - yes it is. But when u facing a complicated project - the simple way may lead you to a lot of problems.
I'm not completely sure why yet, but I had apparently troubles while upgrading when using `passenger_pool_idle_time 0`. I opened a ticket https://github.com/phusion/passenger/issues/2020.
Short question? What will you do if you have to create User in two different parts of your application and you have to apply different validation in each part? In public part user Must have first_name and last_name and in CRM names are optional fields to enter.
you should do a mini ama for folks with career changing aspirations. 
It all works if you have two sources, like I said in my example. But what if 3 or 5? You model becomes an uncontrolled piece of your mind. Don't forget to add callbacks and then try to debug all this shit.
you welcome - nobody likes such a surprise in the morning :P
No experience on this myself, but I went to this [talk at RubyConf](https://www.youtube.com/watch?v=1mme7HiLqzA) and found it quite informative. One of the biggest issues people run into with this is reading and writing to the file system IIRC, but there are workarounds. 
This post explains it pretty good I think: https://wyeworks.com/blog/2015/12/1/immutable-strings-in-ruby-2-dot-3
Interesting, what would be the problem there?
The whole article is about keeping things simple and code dry. And its not a matter of belief: clearly you lack experience of such complex projects - they happens, really - and it's not a matter of how much time you spent on same problems every year.
Short question. Now that you have the need to translate a couple of hundred models and business rules that's as complex as a a middle sized book from rails. You then apply your methodology and end up with a a couple of thousand classes scattered throughout your directory. How do you maintain that? &gt; Must have first_name and last_name and in CRM names are optional fields to enter. What is and what is not a valid user belongs in the model. Optional means just that. Optional.
He said nothing about callbacks. Also if you have 3 or five you just put different conditions on them. Are you saying saying in your paradigm where would be no conditional validation? What's your solution? Create a class for every possible combination of field validations?
Yes, its not when you have 5 classes. But man talking about hundreds of models, many of which interconnected. And still you insist on "keep all business logic in model"? For how long will you be able to maintain that code and more to say... further extend it? In order to keep it maintainable you'll have to move validations somewhere (think it will be concerns) and than further break it down by conditions. And still you'll end up with per-case based validations class. Or you can keep your models grow and unmanageable, say 1000+ lines-of-code-model. And if your customers are real business models goes fat very fast.
Why would anyone want to translate business rules classes? And rules usually apply to more than one entity at a time so numbers wont be so terrifying. It's not that complex. In truth what you'll got is much simpler than all-in-one model. Each class will do only what its designed for.
can we basically see it as an idiomatic form of piping in ruby?
Huh? They got absorbed into Gitlab. Gemnasium is done for but some features will be ported to Gitlab.
I think the contention is that the title makes it sound like getting acquired is the cause of the shut down. The way the article reads, they were shutting down anyway because they didn't want to/couldn't compete with github doing what they were already doing, and the subsequently got acquired for their IP. 
This is great news for those of use that use GitLab and were in the middle of implementing Gemnasium.
&gt; And still you insist on "keep all business logic in model"? Well I never claimed that. But your methodology would spread out the logic of those hundreds of models into thousands of classes spread out all over the place. &gt; Or you can keep your models grow and become unmanageable, say 1000+ lines-of-code-model. Pick one. Either a model with 1000 lines of code or one hundred files each with fifty lines of code. That's your alternative. To explode the line count and the file count. you think that's easier to maintain? 
&gt;Why would anyone want to translate business rules classes? And rules usually apply to more than one entity at a time so numbers wont be so terrifying. Read the article. Look at how many files he creates for something stupidly simple. Look at how many lines of code there are. Look at how deep the modules are nested. If you have a couple of hundred models this library is going to result in at least one thousand files. 
100% agree with testing. I picked up a book on RSpec a little while ago, finally going to dive deep into it. Thanks! Also, is VCR really the best solution? I've looked at it before, but the name puts me off for some reason.. 
Thanks, will check it out!
VCR is just easy to work with. It does a real call first time and then uses result as a mock. You can go full manual with WebMock if you don't like VCR. I hate RSpec with burning passion, but even that is better than no tests. Do testing with minitest, it's less involved.
lol, you sound like a retard, and not *just* because of your opinions.
 instance_eval(File.read(script), script)
And that's the point! Currently we have one Rails app that has more than 100 lines of code of callbacks in one model... Total shit. Rewriting it to dry-rb with Reform and services architecture will bring happiness again in our lives :)
I don't think that it can be used only for validation. It's more about implementing complex business cases for the same entities/models in different contexts. For multi-step forms, for cases where model must be differently processed depending on the data entry point etc. 'Create user' case is not the best example. But it's only the example of using such technique. I saw models with close to hundred conditional callbacks and validations, it's not really understandable and maintainable. In this case, I think it's better to be close to 'S' from SOLID principles(model for reading and writing to DB, form object for serialization and validation, service for implementing business rules) than have the only object that does all this by itself. Don't you think so? 
Conversation revolving about you having extensive experience in simple problems and teaching people of rails, sir. You don't even provided a single constructive argument against mentioned concept, except one when you makes some buck refactoring student-made code.
I used `method_source` to get the source code of a block and `ruby_parser` to parse it here: https://github.com/timhabermaas/ruby_monad/blob/a880fd3209425a023ce14a2c7ad8a73761078db7/lib/monad/syntax/do.rb#L25-L26 My use case was using Haskell's do notation in Ruby to escape callback hell for the monadic bind: https://github.com/timhabermaas/ruby_monad/blob/a880fd3209425a023ce14a2c7ad8a73761078db7/spec/monad/syntax/do_spec.rb#L21-L25 What are you building?
To me the title looked like if Gemnasium was bought by GitLab, while in reality they were getting shut down due to Github competition, and the team was joining GitLab just for the sake of it, they are going to work on security projects there which only partially correlate with their work at Gemnasium. While the words "Gemnasium acquired by Gitlab" title makes one think that the project stays as is and continues to grow under Gitlab's ownership. It's rather "Gemnasium's team hired by Gitlab", no?
oh, so `method_source` was the missing piece, thank you :) &gt; What are you building? General purpose Remote Code Execution framework. Basically something RPC-like but with no need to modify anything on server when new call needs to be made. Desired syntax is along the lines of ``` filename = "/tmp/test.file" if RCE.on(:server1).run { File.exist(filename) } puts "File exists on server1" else puts "File does not exists on server1" end ``` I'll see how much of that is actually possible `^_^` 
Interesting! Your example might not work, though: If I understand your approach correctly you need to somehow pass the variable `filename` to the other machine, otherwise it will be an undefined variable when the block is executed in the context of the other machine. One solution might be to serialize the `binding` of the block: irb(main):004:0&gt; a = 5 =&gt; 5 irb(main):005:0&gt; f = lambda { |x| x } =&gt; #&lt;Proc:0x007fa0dc05d780@(irb):5 (lambda)&gt; irb(main):007:0&gt; f.binding.local_variables =&gt; [:f, :a, :_] irb(main):008:0&gt; f.binding.local_variable_get(:a) =&gt; 5 However, you're limited to variables and can't use any custom defined methods, because they're not serializable. (I found this: https://hackage.haskell.org/package/distributed-static-0.3.8/docs/Control-Distributed-Static.html which might or might not help. I'm not sure I understand it yet.)
yep, I wanted to use `#local_variable_get`, `#local_variable_set` and `#eval` to transfer what is possible (and needed) to the other end. Using the ruby_parser, I could probably guess pretty accurately what local variables will be need on other end. My alternative syntax if the first is not possible is something like a = b = c = 1 assert RCE.on(:server1).run(a, b ,c) { |a, b, c| a + b + c}, a + b + c In the same way values are supposed to be passed to threads `Thread.new(1, 2) { |a, b| pp a + b }`. However, that is lot more writing, so I'll try to stick with the first one if at all possile :) 
I would get rid of those natural symbols if you could, I think they create a bit of a distraction, especially since you'd never see notes written out in that way usually.
More lines of code are bad thing. More lines means more places for bugs. It means you have to mentally keep track of more code. What's worse more files is a bad thing because to understand what a piece of code is doing you have to open up a handful of files and read them. 
Classes with business rules are just kind of functional objects, there is nothing to translate in there. Or, maybe, I just don't understand what you're talking about. I think code in article is just simplified example intentionally made stupid. Again no need to follow this concept if you have manageable code in your models.
Yes, it's easier to maintain things that follows DDD.
&gt; I prefer longer, clearer code to terse, tricky code. You know, that sort of underlines my earlier assessment that maybe you guys really just want to write Java, which clearly provides what you prefer (and I'm saying this entirely free of sarcasm.)
For this purpose String#+ is not the correct way to build Strings due to its immediate creation of garbage You should use the append method `&lt;&lt;` on an empty String to avoid these allocations: def wrap_text txt, wrapper wrapped = "" wrapped &lt;&lt; wrapper &lt;&lt; txt &lt;&lt; wrapper end Ruby also has wrapping built-in if you do a small bit of calculation that also saves you String allocations: `"hello".center 11, "=" #=&gt; "===hello==="` PS: I could put an even-more-snide comment like your rude gatekeeping comment about ruby and programming knowledge here at the bottom, but this one will do.
Have you looked at DRb/dRuby? It is a remote execution framework in stdlib, although it doesn't meet your requirements exactly (the remote host has to expose functionality to be called, it can't be sent new functionality). It used to get a lot of discussion in ruby community, but hasn't gotten much in years. It might be interesting to try to find discussions to identify why it didn't end up being of much interest/use to the community, what the challenges/problems/issues/etc with it were. 
He does have a point though; string catenation even inefficiently is pretty day-one stuff
Java has it's place just like ruby does. At the end of the day, the Rails team is fallible. On really large apps, MVC gets bloated. That's why you see so many apps with decorators between models and views or a service layers between views and models. 
TL;DR: add `to_s` to your eager load and autoload paths so that you don't shovel Pathname objects into $LOAD_PATH I also added `$:.map!(&amp;:to_s)` to my environment.rb for good measure.
I would also checkout string interpolation as it's super useful: def wrap_text(txt, wrap) "#{wrap}#{txt}#{wrap}" end
Those samples are starting to look uncomfortably like Java/Spring code.
If you're not here to teach people day-one stuff in a compassionate manner but you are responding to them you're driving people off.
Thank you! 
Mike, if you had the same situation as described above(Rails application with a lot of models, complex business logic, several data entry points for one model with different processing etc.), what would you chose: usual Raills approach (fat models, callbacks, business logic in models) or something else?
&gt; We have been thus far unable to compile Passenger on Ubuntu 14.04 "Trusty" 32 bit, using our build system. This is due to gcc using more than 3GB of virtual memory while trying to compile the latest codebase what is even happening 
Claims: "we will not go into comparing Active Storage with existing solutions, be it CarrierWave, Paperclip or Shrine, but rather try to make a beginner-friendly introduction to the framework". Two paragraphs later: "This approach sets Active Storage apart from the competition. Paperclip, Carrierwave, Shrine‚Äîall these popular solutions require you to"
&gt; This approach sets Active Storage apart from the competition. Paperclip, Carrierwave, Shrine‚Äîall these popular solutions require you to add columns to existing models. This is also written in the ActiveStorage readme, but it's not strictly true. With any of these solutions you can set up uploads on a separate `attachments` table, and link it with other tables via polymorphic associations. ActiveStorage does make it more streamlined, though.
&gt;Classes with business rules are just kind of functional objects, there is nothing to translate in there. Why even make them objects. What's wrong with a function if there is no state to keep track of?
Learn about the start and loop methods and then the sky is the limit :) Wish we had a 3D lib/wrapper though... (the only useful one I found last time I looked into this was JRubyMonkey3D, a (J)Ruby wrapper for a powerful Java 3D engine, but I was frustrated by lack of Ruby examples and the fact it was not complete, IIRC).
but it's actually faster https://www.reddit.com/r/ruby/comments/7u9tg3/wrap_text_method/dtjnqbu/ ?
Here's a very contrived example. Say you have a server that can only support one connection from your application. If you create more than one connection, your server croaks. Also, creating the connection is incredibly time-consuming. Extra difficulty - your application does many things at once, all of which need access to the server. So creating connections on the fly and closing them when done isn't a viable strategy. The easiest way to solve this is to create the connection within a Singleton. Singleton implies a contract - at most one connection will exist at any time. (There are better patterns to do this. Singleton is kind of like killing a maggot with a sledgehammer) The snippet of code you posted doesn't make sense, but it's difficult to understand what the original coder was doing without more context. From the name of the variable it's likely the singleton is a state store of some sort, and it makes sense to share it across all empty squares.
Those who do not remember J2EE are doomed to reinvent it. 
We're acquiring more than just the team, the backend of Gemnasium containing the libraries and vulnerabilities will be used by GitLab.
do I understand this correctly that Truffle ruby gives performance improvements up to x7-x8 times over MRI 2.4? https://pragtob.wordpress.com/2017/01/24/benchmarking-a-go-ai-in-ruby-cruby-vs-rubinius-vs-jruby-vs-truffle-a-year-later/
I still hold out hope that someday attributes API will replace composed_of :)
The direct upload doesn‚Äôt require webpacker. The js is already included. All it needs is a CORS policy on the server and direct_upload: true on the form file field. 
&gt; we will not **go into** comparing I think what they mean is, this guide won't help you migrate over.
Very cool. Does this mean we have to pay for Ruby now? I'm sorry, but Oracle has been tough to work with sometimes. They may squeeze my wallet for this comment. 
What are some patterns you end up using? Poro service objects? Simple form objects? 
Just tested again and no problem: https://github.com/oracle/truffleruby/issues/62#issuecomment-362065726
Low effort. Try harder next time.
Maybe a custom validation on user which handles the business logic which lives in a separate object and is super easy to test?
I've never done this, but googling around it looks like you can't uncompress a .zip as a stream. It looks like you can with .gz though. Googling around further, I think this will be of interest to you: https://github.com/rocketjob/iostreams
Yeah, there's some fantastic opportunities for speed. Even memory usage improvements on the JVM front. I think you'll find this blog post about SVM from a year ago interesting (/u/nirvdrum is going to update it soon hopefully): nirvdrum.com/2017/02/15/truffleruby-on-the-substrate-vm.html The SVM [has been open sourced](https://www.reddit.com/r/ruby/comments/7o3wy9/graals_substrate_vm_is_now_open_source_what_does/) now and I hope we'll see some markedly better results.
You're probably right that with small string + will be faster since there is plenty of memory, but if you were to wrap w/ huge strings I think it would have issues as you start having to do garbage collection. The preferred way (to my knowledge) is the way I linked below with string interpolation and should theoretically be the most efficient: https://www.reddit.com/r/ruby/comments/7u9tg3/wrap_text_method/dtj642y/
You are correct that the singletons can be used for null objects (that's what ruby does for `nil #NilClass`, but also `true # TrueClass`, `false # FalseClass`). The "singleton pattern" though is a little different. It's basically a way to lazily initialize something you only need one of (ever). Ruby provides a mixin for this pattern, which looks something like (stolen from the docs): require 'singleton' class Klass include Singleton end ObjectSpace.each_object(Klass) {} # 0 Klass.instance ObjectSpace.each_object(Klass) {} # 1 3.times { Klass.instance } ObjectSpace.each_object(Klass) {} # 1 In Ruby, the pattern is rarely used this way though as there are more flexible ways that work just as well. For example: module Foo class &lt;&lt; self def foo 'foo' end end end Foo.foo class FooClass def foo 'foo' end end Foo = FooClass.new Foo.foo Basically accomplish the same thing as doing `Foo.instance.foo`, but are a little easier to change as soon as you need two or more of them. 
Professor? Greece?
Very cool! I made a little starter kit with Middleman and Webpack that supports offline mode via the OfflinePlugin. [Here's the repo](https://github.com/ashwinv11/tadka) if you're interested
I don't get why they try so hard for this. Shouldn't they be able to just force a pure Ruby version of nokogiri? Or is nokogiri so dominant in benchmarks that that would negate their performance improvement?
You are right. We've just decided to show Webpacker steps, that are a bit different 
Because of OOP.
that's certainly one interpretation. 
I would hardly call one phrase a "comparison", even though it is a comparative sentence :)
It's because they don't just want performance, they want performance AND close-to-full compatibility with MRI native extensions. Which means running these as unchanged as possible. Other attempts at a alternative Ruby runtime usually have to choose between either, and suffer for it.
I second @codeduck. The provided code sounds weird to me. Specially if you analyze it in semantic way. Singleton means one single point of connection, one single caching mechanism, one single instance. Why would chess pieces be one of a kind? Pieces may have their own x, y coordinates, possible moves, types, status (alive or killed). Can't imagine all that with a Singleton pattern. 
That‚Äôs odd. I was on mobile so that could have been it. 
Hm, there actually doesn't seem to be a single correct way. For really short strings, my way (`+`) is actually fastest, on my machine it's up to around 60. Than using `#{}` is the fastest way untill around 1GB strings, where the `&lt;&lt;` way overtakes both `+` and `#{}`. Interesting. String size: 1 user system total real using + 0.207465 0.000000 0.207465 ( 0.207484) using &lt;&lt; 0.308743 0.000000 0.308743 ( 0.308756) using #{} 0.267816 0.000000 0.267816 ( 0.267819) String size: 1024 user system total real using + 1.027109 0.000000 1.027109 ( 1.027176) using &lt;&lt; 1.140164 0.009997 1.150161 ( 1.150194) using #{} 0.724079 0.000003 0.724082 ( 0.724137) String size: 1048576 user system total real using + 0.702478 0.258995 0.961473 ( 0.961514) using &lt;&lt; 0.729617 0.019981 0.749598 ( 0.749625) using #{} 0.376935 0.010016 0.386951 ( 0.386962) String size: 1073741824 user system total real using + 8.853085 16.469597 25.322682 ( 25.323361) using &lt;&lt; 5.135721 10.448621 15.584342 ( 15.585234) using #{} 5.209925 10.409736 15.619661 ( 15.619972) But I think we can say that `#{}` is good general recommendation, I'll modify my original answer to add that information. 
You win /r/ruby for today.
I didn't call it anything, just quoted ;) It'll take more than that comparative sentence to shrug off the "NIH" from that. 
Sorry, I usually try to put better examples when referencing code I have a question about, but I was going off memory here. After talking to some programmers in Slack and your example I think I have a better understanding. One area that I wasn't thinking of was memory/space. A Singleton object, since there's only 1 object instance of it, can be used to conserve memory. In the example I provided, I think that was the logic there (conserving memory). Since they needed more from the empty game board spaces than just "nil", and a new object instance for each empty position is wasteful, they used a Singleton. (Which may or not be best practice, but I at least understand the logic now I think.) You hit on something I heard a lot too, which is avoid Singleton class pattern unless absolutely needed. Thanks for help!
I guess I was just trying to say "don't look for detailed comparison here, this post is not about that" :) 
Be warned that gzip doesn't allow multiple files (at least not usually), that might or might not be an issue for you.
in fact, that's probably related to why gzip can be uncompressed as a stream and zip can't! 
This isn't specific to your problem, however I have found that Net::SFTP does a bad job of figuring out what version of the SFTP protocol to use, and/or has poorly implemented versions of SFTP* above 3. In my work, I have monkey patched the maximum protocol version to be 3 and it has resolved many issues for me. * it could also be that the SFTP server I was using had poorly implemented versions of SFTP above 3. I just know when I forced it to version 3, everything worked as expected.
... why? That was really confusing without a note about the one line default. I almost considered adding webpack with all the overhead to my app for that. If you are one of the authors, maybe you could add a note?
Nice, thanks for the feedback :D. Would you mind to check this issue link and share your opinion there? https://github.com/pedrozath/coltrane/issues/4
I believe that the out-of-the-box Rails approach does not scale beyond "build a blog". The community has developed several tricks that help scale development: avoid callbacks, form objects, etc but I don't have a magic bullet. I like to extract service objects that implement each different business transaction, conditional logic can hide there and keep the models relatively thin. I believe job systems like Sidekiq help because they force a very simple `perform(args)` interface on a single unit of work, providing a natural point to extract a business transaction that can then be performed asynchronously and remotely and dovetail nicely with executing service objects. Unfortunately that doesn't stop people from relying on fat model magic within them too.
May want to add a little more guidance (or modify the examples) to ensure a safe and closed proxy. It apears as though your examples both show unsuspecting users how to create a open proxy on your servers. May be great for doing protocol conversion, but also great for hackers looking for a stooge network.
"definitive" or complete are mutually exclusive to an open set/problem space such as projects build using Ruby/Rails. Good luck.
Its great if you like to have your fingers moving for long periods between thinking about actual code/logic...
Totally agree. The main idea of the article is to show that we can follow good practices of app design with Rails. We do this with dry-rb and reform, others can go their own way, but this does not change the idea.
If you're writing out all of the verbosity rather than letting your editor fill in the blanks, you are doing something wrong.
Thank you for the feedback, there is a note saying that this are the steps shown with "webpacker in mind", but you're right, it could be more obvious, I'll see what I can do
&gt; I've been consulting and teaching Rails since 2005 and have billed a considerable amount of hours for removing Reform (et al) from Rails apps because the fuzzy shifting of the source of truth led to ridiculous bugs that could easily have been avoided by Keeping Things Simple. Consultants that get called in to clean up messes often develop biased impressions of the techniques employed in those messes. If a software team made a mess out of Reform, they would have made a mess with stock rails, or hanami, or any other collection of libraries and tools. And I've worked in rails apps with north of 700 models. You can say a monolithic approach would have been a bad choice, but no monolith ever starts out that way. And you might have betrayed a bit of a misunderstanding about what "monolithic" means, as dry-rb and trailblazer are both used commonly in monolithic architectures. Let me ask you this question. Who holds a stronger command of how to design and implement complex software systems, the narrow subset of the software world that is The Rails Way, or the decades old software principles that have been accepted across the industry as a whole?
It's quite likely a pure Ruby version of Nokogiri would perform better for us than the C extension. Alas, no such version of Nokogiri exists. So, we're left with either writing one ourselves and trying to convince everyone to switch to it or just supporting the C extension so it installs and runs out of the box, just like on MRI. We've opted to spend our efforts on the latter with the expectation that this work will carry over and allow other native extensions to run as well.
Thanks for your comment. I was thinking on how it could be accomplished and did not come up with any idea on how to secure it. Proxy is used by both mobile clients and JS frontend. It means I cannot whitelist on request host basis and any kind of API_KEY included in the request would be visible. Do you have any tips on how this kind of proxy could be secured ? Can I ask you to repost this comment on a blog itself? It would be more visible and serve as a warning to readers before I update the text.
Truffle, Graal, Sulong, TruffleRuby, and the SubstrateVM are all open source. Like with any open source project, you'll need to evaluate the licenses to see if they match whatever is you're looking to do.
&gt; More lines of code are bad thing. More lines means more places for bugs. It means you have to mentally keep track of more code. What's worse more files is a bad thing because to understand what a piece of code is doing you have to open up a handful of files and read them. I really hate to say this, but I think your understanding of software design is immature, and it's showing here. If the only kinds of projects you've worked with are stock Rails projects and botched attempts at "object oriented" projects, I can see why you'd conclude that the former is preferable to the latter, but that only betrays a lack of exposure to healthier projects. Our software runs on top of databases, kernels, web frameworks, web browsers, etc. that, all combined, are comprised of over a billion lines of code that we never have to see, even though our code exercises them all. The reason that they don't increase the likelihood of our programs containing bugs is the same reason we don't have to mentally keep track of all those billions of lines of code code, which is _also_ the same reason we don't ever have to flip through all those files: the _isolation_ between our programs, their library dependencies, and their runtime environment severely restricts their ability to creep into our working context as programmers. Let me come at this from another angle: if a particular class cannot be understood without understanding oodles of adjacent classes, then the overall design is clearly missing. There's no isolation between classes, and therefore they all need to be understood together. In such a case, the separation afforded by classes is a lie; they have no boundaries. If they had boundaries, then _other_ classes would be as invisible as, say, your operating system scheduler. In other words, the same reason you don't ever have to go sifting through the guts of rails, or your web browser, or your operating system kernel, is the same reason why you'll never have to sifting through oodles of files and classes in a system designed ground-up with first principles. All I hear you saying is that you've never worked with high quality software, and for that I do sympathize.
This blog post only covers one benchmark, but TruffleRuby routinely beats out other Ruby implementations across a wide range of benchmarks. E.g., in the optcarrot benchmark, which the core Ruby team is using to measure its progress on its Ruby 3x3 initiative, we're 8.5x as fast as MRI (well past their 3x goal). We've given a fair number of talks at conferences talking about various aspects of our performance and how we achieve them. If you have a specific benchmark or issue where something seems slower than it should be, feel free to reach out. Or you can always [file an issue](https://github.com/oracle/truffleruby/issues) and we'll investigate.
FYI: The calendar is an open source page / project built with ... Jekyll and hosted on GitHub Pages. You're welcome and invited to add or update upcoming conferences and camps in the [data/conferences2018.yml](https://github.com/planetruby/calendar/blob/master/_data/conferences2018.yml) datafile, for example.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [planetruby/calendar/.../**conferences2018.yml** (master ‚Üí f93324b)](https://github.com/planetruby/calendar/blob/f93324bb30b4743f667d6f4fa2d64bd2b244333f/_data/conferences2018.yml) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtl7ksp.)
FYI: The calendar is an open source page / project built with ... Jekyll and hosted on GitHub Pages. You're welcome and invited to add or update upcoming conferences and camps in the [data/conferences2018.yml](https://github.com/planetruby/calendar/blob/master/_data/conferences2018.yml) datafile, for example.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [planetruby/calendar/.../**conferences2018.yml** (master ‚Üí f93324b)](https://github.com/planetruby/calendar/blob/f93324bb30b4743f667d6f4fa2d64bd2b244333f/_data/conferences2018.yml) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtl7lbw.)
It would operate on the [key, value] pairs I would assume, like map. 
You can also do (1..Float::INFINITY).lazy.flat_map{|a| [a].product([false, true], ('a'..'e').to_a) } 
If your development language requires your editor (cough ide) to spew a shitload of boilerplate per line of real code your doing something wrong too. 
For a ruby/rails backend/endpoint doing the proxy sign the urls server side as you expose them to the mobile clients or js front ends, the endpoint serving the requsest proxy can then verify the url is valid if the signature is valie for that url, log it and pass x-forwarded-for headers to inform the target site the request has been proxied for a specific ip. For nginx you are more limited -- the best you can do is whitelist specific URL structures (protocol, domain, uri prefix/structure) and only allow those to pass. In this case you should also setup logging and ensure forwarded for headers are set properly. 
So I think the issue you're running into is that most gems are assuming you have a JS environment in a webpage to work with... If you want to render to an image I believe the gruff gem (https://github.com/topfunky/gruff) could be what you're looking for?
ok.
Thanks, that's pretty much the functionality I was hoping for. I wonder if it's possible to omit the file name and execute a viewer automatically; it's workable, but a bit clumsy, to go back and forth between the Ruby session and a separate image viewer.
What exactly are you asking? Is your question specific to a particular platform? Is your question specific to Rails? Are you asking for a resource to [assist with debugging Rails applications](http://guides.rubyonrails.org/debugging_rails_applications.html)? Your question seems too broad to answer meaningfully. If you were looking for Rails debugging resources, I hope that link helped.
Don't forget interpolation I had thought about it in my initial response but neglected to include it. I expanded your benchmark to be more-comprehensive: require 'benchmark/ips' def wrap_plus(txt, wrapper) wrapper + txt + wrapper end def wrap_append(txt, wrapper) w = +'' w &lt;&lt; wrapper &lt;&lt; txt &lt;&lt; wrapper end def wrap_interpolate(text, wrapper) "#{wrapper}#{text}#{wrapper}" end def wrap_center_calculate(text, wrapper) width = text.size + wrapper.size * 2 text.center width, wrapper end def wrap_center_fixed(text, wrapper) text.center 11, wrapper end Benchmark.ips do |bm| bm.report('String#+') { wrap_plus('hello', '===') } bm.report('String#&lt;&lt;') { wrap_append('hello', '===') } bm.report('String#center calculate') { wrap_center_calculate('hello', '===') } bm.report('String#center fixed') { wrap_center_fixed('hello', '===') } bm.report('interpolation') { wrap_interpolate('hello', '===') } end Instead of using built-in benchmark I use benchmark-ips which includes an error range (not as good as ministat with its student's t test which reveals statistical significance): Warming up -------------------------------------- String#+ 199.382k i/100ms String#&lt;&lt; 164.768k i/100ms String#center calculate 178.765k i/100ms String#center fixed 196.179k i/100ms interpolation 194.228k i/100ms Calculating ------------------------------------- String#+ 4.064M (¬± 7.7%) i/s - 20.337M in 5.035061s String#&lt;&lt; 2.535M (¬±17.7%) i/s - 12.028M in 5.013029s String#center calculate 3.101M (¬± 7.4%) i/s - 15.553M in 5.043859s String#center fixed 3.390M (¬± 2.6%) i/s - 17.068M in 5.038572s interpolation 3.666M (¬± 6.2%) i/s - 18.257M in 5.000307s Interpolation at up to 3.893M i/s and String#+ down to 3.763M i/s overlap in their error ranges, so saying one is faster than the other is not something we can conclude from this benchmark. (A student's t-test may be able to allow us to conclude that, but I'm not willing to do that work yet because we haven't reached a decision point where we need that level of precision.) (Also, I may be able to save a bit more on the String#&lt;&lt; by removing the String#+@ (`+''`) that I don't need because I'm not using frozen strings, but let's carry on without that change.) As I mentioned in my original reply, there is another method we can evaluate the two techniques on, total allocations. I don't know of a benchmark tool that measures this, but it's easy enough to get an idea by checkpointing `GC.stat[:total_allocated_objects]` before each run: require 'pp' require 'benchmark' def wrap_plus(txt, wrapper) +wrapper + txt + wrapper end def wrap_append(txt, wrapper) w = +'' w &lt;&lt; wrapper &lt;&lt; txt &lt;&lt; wrapper end def wrap_interpolate(text, wrapper) "#{wrapper}#{text}#{wrapper}" end def wrap_center(text, wrapper) width = text.size + wrapper.size * 2 text.center width, wrapper end count = 1_000 initial = GC.stat[:total_allocated_objects] count.times { wrap_plus('hello', '===') } plus = GC.stat[:total_allocated_objects] count.times { wrap_append('hello', '===') } append = GC.stat[:total_allocated_objects] count.times { wrap_center('hello', '===') } center = GC.stat[:total_allocated_objects] count.times { wrap_interpolate('hello', '===') } interpolate = GC.stat[:total_allocated_objects] plus_allocations = plus - initial append_allocations = append - plus center_allocations = center - append interpolate_allocations = interpolate - center plus_per = plus_allocations / count.to_f append_per = append_allocations / count.to_f center_per = center_allocations / count.to_f interpolate_per = interpolate_allocations / count.to_f puts "plus allocations: #{plus_allocations} (#{plus_per} per)" puts "append allocations: #{append_allocations} (#{append_per} per)" puts "center allocations: #{center_allocations} (#{center_per} per)" puts "interpolate allocations: #{interpolate_allocations} (#{interpolate_per} per)" Running it shows String#+ allocates 33% more objects: plus allocations: 4001 (4.001 per) append allocations: 3001 (3.001 per) center allocations: 3001 (3.001 per) interpolate allocations: 3001 (3.001 per) (I think we get an extra allocation inside Integer#count, but I don't want to go check, changing the count executed still leaves us with 1 extra allocation, so I'll ignore it.) These extra allocations cause downstream effects in a long-running application such as memory fragmentation and GC pressure that are difficult to quantify in a tiny benchmark like this one. I have seen performance improvements from reducing allocations even in applications that only run for a few minutes. `/usr/bin/time -l` may be a reasonable proxy for this as it shows details beyond various timings. Furthermore, these strings are all short enough to be embedded in the struct RString (24 bytes or less), trying a string that isn't short enough to be embedded should give different behavior. Using the same wrapper but the text "this string does not fit in a struct RString" (50 total bytes in the output) gives different results: Warming up -------------------------------------- String#+ 128.634k i/100ms String#&lt;&lt; 115.002k i/100ms String#center calculate 152.032k i/100ms String#center fixed 157.843k i/100ms interpolation 130.501k i/100ms Calculating ------------------------------------- String#+ 1.884M (¬± 6.8%) i/s - 9.390M in 5.008386s String#&lt;&lt; 1.738M (¬± 6.1%) i/s - 8.740M in 5.047367s String#center calculate 2.434M (¬± 5.9%) i/s - 12.163M in 5.015035s String#center fixed 2.581M (¬± 5.6%) i/s - 12.943M in 5.030481s interpolation 1.887M (¬± 7.2%) i/s - 9.527M in 5.075030s First of all, note the large performance drop across all methods compared to the previous benchmark. Now these methods all have to allocate a string outside the struct RString which significantly impacts performance. Here we see String#center as the fastest way, with or without the extra calculation, because it knows exactly the right size string to allocate. String#+ and interpolation are the same speed, but String#+ is still creating extra garbage, and String#&lt;&lt; is slowest because of the extra method call. Using a 25-character long wrapper with the string as above gives (94 total characters) gives: Warming up -------------------------------------- String#+ 124.109k i/100ms String#&lt;&lt; 108.459k i/100ms String#center calculate 133.756k i/100ms String#center fixed 138.763k i/100ms interpolation 125.997k i/100ms Calculating ------------------------------------- String#+ 1.810M (¬± 8.3%) i/s - 9.060M in 5.041069s String#&lt;&lt; 1.593M (¬± 7.6%) i/s - 8.026M in 5.065951s String#center calculate 2.182M (¬± 8.4%) i/s - 10.968M in 5.059661s String#center fixed 2.489M (¬± 7.6%) i/s - 12.489M in 5.048447s interpolation 1.812M (¬± 7.8%) i/s - 9.072M in 5.036793s Comparing the performance of this benchmark to the previous we see the ratio of time between calculated and fixed String#center has fallen compared to the previous, so likely there is a performance difference when calling String#size on an embedded string vs an allocated string. Otherwise the numbers seem comparable relatively between benchmarks. If you want to know more about embedded strings see Ruby Under a Microscope by Pat Shaughnessy, which also covers a bunch of other ruby internals that may be important to benchmarking Finally, which method tested should you use if you even care about performance? We learned that it depends on the size of the inputs. While not discussed, because this is a micro-benchmark, it also depends on whether or not wrapping a string with text is an important part of your application, something you would determine with a profiler (but that's a separate discussion altogether). And now we get to how I would respond to "Please help me put together function that puts two numbers together and return the result". The above shows you many different things to think about when benchmarking code in order to get the most accurate results for the you time spent. It includes techniques, tools, things to think about, and some discussion of Ruby's internals that has an effect on how ruby runs this benchmark. The above is an introduction to benchmarking in ruby, so if somebody asked for an introduction to adding numbers in ruby I'd answer them in a similar manner as the above, or spend the time to write up a long response like this one, depending upon the topic.
Thanks!
Right, like other already included Enumerable methods, elements represent `[key, value]` pairs. It is already generalized for `[:all?, :any?, :chunk, :chunk_while, :collect, :collect_concat, :count, :cycle, :detect, :drop, :drop_while, :each_cons, :each_entry, :each_slice, :each_with_index, :each_with_object, :entries, :find, :find_all, :find_index, :first, :flat_map, :grep, :grep_v, :group_by, :include?, :inject, :lazy, :map, :max, :max_by, :member?, :min, :min_by, :minmax, :minmax_by, :none?, :one?, :partition, :reduce, :reject, :reverse_each, :select, :slice_after, :slice_before, :slice_when, :sort, :sort_by, :sum, :take, :take_while, :to_a, :to_h, :uniq, :zip]`
If you're comfortable with direct commands, you can call `open &lt;path-to-file.png&gt;` and theoretically your OS could determine the way to open it. Is that what you mean?
Thanks! This is helpful. Having gzip as part of the ruby stdlib is a bonus.
How does that differ from `(1..Float::INFINITY).lazy.map { |x| [1, 1, 1, ..., x] }.each` ?
Ruby doesn't force classes on you. 
Thx for catching that out. Corrected.
I, too would be interested.
This is where Ruby Together money goes now?
Fascinating! Tell us more.
It looks pretty nice! I like the base API, it looks cleaner than other approaches to the problem. I wonder, though, why don't you reuse RSpec matchers for matching the content? # before .with_content(a: expectations::Anything) # after .with_content(a: anything) # before .with_content(a: expectations::ArrayOf[expectations::Anything]) # after .with_content(a: instance_of(Array)) # before .with_content(a: expectations::ArrayWithSize[0..2]) # after .with_content(a: instance_of(Array).and(have_attributes(size: 0..2))) # before .with_content(a: expectations::NullableOf[1]) # after .with_content(a: be_eql(1).or(be_nil)) Not all of your examples are easily reproducible with built-in matchers, yet I still feel that composability is a way to go, so I'd separate "new powerful argument matchers" code from "match json with content and path".
What do you mean? What part did you not understand? The professor (teacher, tutor, whatever) doesn't care about the course he's teaching and hasn't changed the course material since the department of Informatics in my University was established. Such behavior is very common here in Greece (from professors in other Universities)
They're making money on the promise that you won't have to think about servers and deployment and any of that anymore. Of course anyone with half a brain can install Linux on a VPS, and get a web server working in like half an hour, but it still takes time and effort, and once you're getting a bit more serious, you will have to think about things like backups, scaling, security, monitoring, logging, etc. You can still do all that yourself, but it's not interesting work, it's not your core business, you're not particularly good at it, and you'd rather not take a gamble on the risk of getting any of it wrong. It's not that people are too lazy, they just have better things to do.
You're right, I agree.
Sharing it here in hope to encourage more folks to try it out. The more exposure, the more tests :-)
I agree here that #latlng is a better name for a method name than #to_a However, the semantics of to_s, to_h, to_i are not different. These methods including to_a return a representation of an object, they don‚Äôt say ‚Äúthis object is behaves like this other object‚Äù (to_ary, to_str, etc. do say that). The to_x methods are part of a conversion protocol to another representation, to_i on IO instances is the closest parallel to the to_a in this article. The to_xxx are part of a substitution protocol that allow you to implement an Array, etc., without subclassing. For example, to_str should only be implemented when your class expects to have all the features of a String including gsub, =~, bytesize, etc. If you have a useful array representation within your library you should define to_a because that is what the to_x protocol has always been for.
&gt; However, the semantics of `to_s`, `to_h`, `to_i` are not different Yes and no. All of them (and `to_a`) have semantic "representable as %datatype%", right. Yet the semantics of statement is different for various datatypes: * "representable as string" = "printable" * "representable as hash" ~ "compound serializable object" * ...while "representable as array (tuple)" has a questionable notion for non-collection objects, and that's the fact I am pointing at. Most of the time, even if making sense, it needs some clarification, and therefore deserves specialized methods.
That's only a symptom, not the problem on itself. The problem on itself is that `to_a` has unclear semantics for non-collection objects.
They are pretty transparent about where the money goes. We'll see how much this necromancy actually costs soon enough.
I didn't make an ad hominem. If you go up to a professor and display a lack of understanding of the curriculum, she's not administering an ad hominem attack by explaining to you that you appear to be uninformed. And since you had no rebuttal for my argument, you claimed that I didn't have one. Your response is actually a non sequitur.
And why is that? Are you claiming that it's common for people writing computer programs to have to undergo the same forensic experiences that have characterized your career?
https://www.reddit.com/r/ruby/comments/7ujou6/netsftp_connection_reset_by_peer/dtmwvqx/ Or just look one comment above...
I would add simplified pricing. With AWS you can tailor services to your need, but there are so many options, that you can easily step on a landmine. Just recently while testing RDS I used IOPS setting. 2 days later I checked the billing and I had $25 dollars for IOPS. Sure, it was my fault for not checking it previously, but with many cloud services which provide load balancing, databases and stuff, you have to be really careful. With hosting like Heroku or Linode you just run shit and know exactly how much you will pay for it.
This guy is the only person I know who has tried both (assuming he's actually tried heroku?) and finds self-managed servers deployed to with capistrano _easier_. (Plus, for anything but the most trivial deployment, you're probably going to need some ansible or something similar in there too, in addition to capistrano-rails). Heroku is not cheap, there are certainly reasons to choose a cheaper option, especially if your staff time is cheap, or you scale really large. But to say that heroku isn't (a lot lot lot) easier... is insane to me. 
&gt; should've been open sourced This was one person's project; they can do anything they want with their source.
wow, that's... very educational. Thank you for the write up I'll make a note about benchmark/ips, looks useful.
Yes you did make an ad hominem and you continue to do so. I don't understand your desperation though. Arguing for more complexity in code is an odd position and one that's hard to accomplish.
i'm curious why people downvoted this, I found it a good article. 
It would be nice if _any_ of this, including the `to_str` method is designated for a particular use case, were in ruby docs. Is `to_str`'s designated use case documented anywhere? But I think OP's explanation of what `Array()` does with `to_a` is by itself a reason to avoid it. I find `Array()` pretty useful to allow arguments that can be single values or arrays of values, and then `Array(arg).each` over them. 
I'll ignore your passive-aggressive weasel tone and just say "yes". When something misbehaves, your team has to find out why the NFS service hangs every time you hard-link 2^14+1 files or what methods `proxy_association` actually supports when you're writing a custom preloader or why Firefox lets selectors piece through the shadow DOM. So that you &amp; your team can fix it, contribute a patch back upstream for the misbehaviour and get on with your lives. in re this: &gt; you've never worked with high quality software What a really shitty thing to say to someone. 
OP doesn't talk at all about `Array.new(obj)`, but instead `Array(obj)` which is a different thing. http://ruby-doc.org/core-2.4.0/Kernel.html#method-i-Array
Huh? I am pointing out what appears to be a gap in your understanding, as one professional to another. I would want you to do the same were the situation reversed. There is no insult or attempt to discredit or demean you. So, no, I am not attempting to levy an argument against you as a means of avoiding your argument. The basic criteria of as hominem is not met. I am also not arguing to add complexity. I am trying to point out that complexity can be effectively isolated, as evidenced that your programs are already isolated from the ocean of complexity around them. Since you indicated you are sensing desperation in my posts, I can only conclude that you are not receiving my comments as they were intended, which is unfortunate. Anyways, cheers!
Your efforts at improving underlying software should be commended, but I was only claiming that there is plenty of prior art demonstrating isolation on our computers right now. All abstractions leak, but we are not generally encumbered with having to understand the complexity of our entire software platform when we write programs, and that same quality can be attained _within_ software systems via software design. I can infer the commenter had not experienced this based on his/her comments. I was not at all attacking the poster I responded to, though in retrospect I do regret the wording. Lots of great programmers never get a chance to work on healthy software *systems*. That's all I was saying - if the commenters experience with object oriented code involved having to fight too many files and classes at once, they haven't actually experienced an overall design that is sound. In fact, any design can be dismissed as _unsound_ when programmers go through all that indirection routinely. When people have only experienced poorly designed systems, I *want* them to experience what better design leads to, believe it or not.
Looks nice. I'm curious how much of the speed improvement is attributable to using the native code Oj library whilst active_model_serializers does not (AFAIK). I know that when I switched my serialization of postgresql jsonb columns to using Oj that they sped up a fair bit too. 
What's the use case for this? You should add shell scripts that will allow one to autocomplete the gem name. 
Good question. 
Jinx! You and Lucklevjr posted the same comment at the same time! See their comment [here](https://np.reddit.com/comments/7uvxyp/_/dtnl8m6). --- I am a bot who is owed many Cokes.
I just want to say, /u/in0pinatus pointed out that I wrote something that came across to him/her as very offensive: &gt; All I hear you saying is that you've never worked with high quality software, and for that I do sympathize. In retrospect, that is pretty awful wording. I apologize for writing something that could be easily construed as a harsh criticism of your ability. For all I know, you could be a very talented programmer (and, indeed, you seem to really know your shit in plenty of other areas). As I said to /u/in0pinatus, great programmers still seldom get chances to work in well-architected software systems. I see now what you meant by the ad hominems. Even though I am deliberately challenging your line of reasoning that I originally responded to, I am not intending to put you down. Please accept my apology for the awful wording!
We made sure that we are using OJ in both cases https://github.com/Netflix/fast_jsonapi/pull/36 The benchmark tests are run everytime you run rspec. I would love to see what you get when you try it on your setup
I don't think it's documented in the repository, but a document about conversion protocols in Ruby in [the docs dir](https://github.com/ruby/ruby/tree/trunk/doc) would be a great addition. A method accepting multiple types for an argument is always going to run into type conversion problems because ruby is dynamically typed. I've written similar clumsy code to handling Array vs single value when I accept String or Hash, etc. I think keyword arguments can be a less-clumsy way to address this weakness in ruby as you can accept different types on different arguments.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**doc** (trunk ‚Üí da01eb9)](https://github.com/ruby/ruby/tree/da01eb93e4ac7886389b48d5b47d7292e16acf9c/doc) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtnoi2b.)
Oh hi, maybe you can answer a question I have about some of your specs. Your library has some performance specs in it, requiring it to `perform_under(50).ms`, for example. How effective are these specific tests for measuring performance? I noticed there's also comparison specs with AMS 0.10.x, which makes more sense to me, as they're relative, not absolute, but these specs with absolute time constrains just don't add up to me. I mean, I could probably make them pass with a crappy code but a really fast computer, or make them fail with an excellent algorithm but a crappy old computer. Is there something I'm missing here? How do you make them meaningful?
This... and you... are bad ass.
But you can't avoid _essential_ complexity. Software systems actually get _more_ complex when they are _oversimplified_. I'll give an example of oversimplification: I was recently locked out of an important login account because they changed the validation rules for email addresses. Once my previously valid email address was deemed no longer valid, I couldn't log in, I couldn't reset my password, I couldn't do anything, etc. By putting all data validation "in one place," instead of with the original form submission everyone uses to set up accounts, they caused incredibly frustrating user experiences. And this is exactly the kind of thing both dry.rb and trb both address. You could argue Rails does too, with `:on =&gt; :create`, but that's too simplistic to work universally. You'd _want_ the validation to apply on updates, too, _when_ the login itself is being updated, versus being changed for some _other_ reason. I do agree that _accidental_ complexity should always be avoided. Some novices design overly abstract, general implementations that actually _ought_ to be more specific. They are probably hoping to eventually reuse the code someday, or something. I don't know why they do it, they just do. That kind of crap has to be headed off at the pass just like implementations that cling to The Rails Way to the detriment of the software quality and user experience. But if it's inevitable that you're going to end up with a lot of essential complexity -- and I've worked with Rails apps, for instance, that absolutely needed every one of those hundreds of models they contained -- the only way to scale up the human efforts around the software is to introduce isolation via software design. I've also dealt with very simplistic web apps that never need more than what stock Rails offers.
Those tests were useful early on when we were just shooting for a certain performance goal. All engineers internally who are working on it used the similar laptops. I am not sure how useful they are going forward.
One should slowly develop automated scripts, plus many providers like Linode provide you with backup options. Believe me even with paid plans in Heroku takes time to boot the app. When I host it on (kinda) dedicated servers, things render just like that with awesome speed. Even AWS takes time to respond, and 3 times till now apps on AWS faced problems and Amazon reduced the bills. With my own servers I know whats happening. I am in India, I do not get static ip in my home with large enough band width, else I will build myself a failsafe data center with replications in my friends places. But I feel cloud days are numbered as browsers start to support P2P protocols, we can soon make the Internet highly decentralized and thats what it really stands for.
Well, I am creating my own app http://nyoboo.com , I don't want to waste money on it, at least till the day I get insanely evil rich like reddit management. So I am exploring ways to reduce money.
&gt; It would be nice if any of this, including the to_str method is designated for a particular use case, were in ruby docs. Is to_str's designated use case documented anywhere? While certainly not the proper place, it's mentioned in The Ruby Programming Language book, section 3.8.7.2, Implicit conversions. There are also the `try_convert` methods. Which may provide more "expected behavior". 
I‚Äôve been using [jsonapi-rb](http://jsonapi-rb.org) in production for awhile now and the speed increase compared to AMS is phenomenal. Interested in hearing how this lib compares, speed wise.
That's fine. I use 5 dollar Digital Ocean VPS myself. You have to understand that extra cost to host on Heroku is literally nothing compared to developer cost. You gonna spend a day setting up ansible scripts for Linode? You just burned 500 bucks right there. In the long run Heroku might get too expensive or inflexible, but for startups it just makes sense. &gt; probably that companies tech guys or CTO is a fool That's just ignorant. 
Have you done any comparisons with jsonapi-rb? http://jsonapi-rb.org
&gt;But you can't avoid essential complexity. For the last time. You can choose not to overcomplicate things by using silly libraries like this. &gt;By putting all data validation "in one place," instead of with the original form submission everyone uses to set up accounts, they caused incredibly frustrating user experiences. And this is exactly the kind of thing both dry.rb and trb both address. Data validation belongs in one place. If you are validating the same data in multiple places you need to have your head examined. Also there are many ways to address programming problems and my experience tells me that trying to make ruby look and feel like J2EE is not the right approach. &gt;the only way to scale up the human efforts around the software is to introduce isolation via software design. Not shitty software design. 
Can author give a few notes on what they did to make it so much faster than AMS?
Nobody is going to do homework for you. If you have any specific questions then ask away. Looking at that assignment it's clear you gotta figure out how to read files and parse strings. Start there.
&gt; Here are gems where I used it: Well, both of examples more or less fall into "unless it is a collection" category (collection of country names, ordered set of strings representing command-line option).
Wow, thanks man! üôèüèæ
1. Formulate a proper question specific question, such as: How can I split a string into lines? 2. Throw that question on Google/Stack Overflow 3. Try at least the 3 top answers 4. If you still can't do it, come here and report to us and I'm sure someone here will help ya.
IMO the ease of setting up staging environments makes Heroku worth it. Add to that not having to worth about system maintenance and it's clearly worth the money
Since you're dealing with an array, a good idea is to check out Ruby's Array documentation: http://ruby-doc.org/core-2.5.0/Array.html One alternative for better code would be: def first_duplicate(array) array.group_by(&amp;:itself).keys.first end
Without changing the algorithm, we can use two things: * Hash instead of Array * `.each_with_object` for idiom "enumerate all values, changing some object on the way" a.each_with_object({}) do |el, already_happened| return el if already_happened.key?(el) already_happened[el] = true end For other algorithms, [this StackOverflow answer](https://stackoverflow.com/questions/8921999/ruby-how-to-find-and-return-a-duplicate-value-in-array/8922931) provides some.
No
+1. would love to read this as well.
The whole premise is weak. As a mature, popular platform, Rails already has a prevalence of pre-existing answered questions (the graph proves this). And as an SO mod, I can attest that we are allergic to duplicate questions. Obviously, that means over time fewer new questions need to be asked. Because Google. So for a project like Rails, counting new questions asked is likely the wrong indicator of popularity.
In newer versions of ruby isnt it illegal to return from a block?
&gt; If you are at an agency cranking out a new app every couple of months, then certainly you would want to switch things up and try out new stacks. IMO boilerplate code is really the only boring/repetitive aspect to making new apps five or six times a year. Cutting down on boilerplate is gonna have a much better ROI in terms of job satisfaction then switching stacks every six months. Rails does that remarkably well so as long as it keeps getting updated there isn't a whole lot of reason to stop using it.
Yes. It is just mature. I'm sorry there isn't the excitement of having to write your own gem for everything currently. I actually can't wait for Rails 5.2 with ActiveStorage. Why don't you talk about that?
I got a `NoMethodError`. Can you fix please?!?! HALP!!! ~sarcasm~ 
They are bored. 
I too have been using this library in production. And have been really enjoying the speed that these set of library's have been providing.
I mean javascript is noisy and loud, but to me that's because it's a messy primordial ecosystem that hasn't matured so it's constantly changing even at its core with all the different frameworks. Whereas Rails is the 'primary' framework that evolved from Ruby...it's mature, and much more stable, so there's not a lot of 'noise' or 'fighting' about it. That's how I see it.
Mature, sure, but ColdFusion, and Flash, they‚Äôre mature too. But popular? Maybe, but mature &amp; popular aren‚Äôt necessarily the same thing.
I don‚Äôt think this code works quite right. It will return the first value of the hash returned from group_by, which would be the first value that has a duplicate anywhere in the array. You actually want the first value you see twice when scanning from the left side of the array. So for [2,3,3,1,2] you want 3, not 2.
To be fair, he‚Äôs not arguing that it is or isn‚Äôt. Just that the indicator (number of questions asked) is not reliable as less questions are asked the longer a language is around. A better indicator would be job openings, number of open source projects, boot camps, etc.
Fundamentally. [Cartesian product](http://ruby-doc.org/core-2.5.0/Array.html#method-i-product) and [mapping over values](http://ruby-doc.org/core-2.5.0/Array.html#method-i-map) are quite distinct operations.
Agreed! üòÄ
Does this do some of the same things jsonapi-resoures provides? I usually use jsonapi-resoures for projects because it does so much out of the box. 
You're a fool. If your argument against Heroku is capistrano, then Heroku would be enough for what you want to accomplish. 
How would you explain Django's having more questions in 2018? Both frameworks are same age
Well yeah, exactly - that‚Äôs my point. I wouldn‚Äôt infer anything from just this one data point.
Well to be fair - you use two data points: Age and Stack Overflow question count.
Wow! This is great!!!
I feel like this article should've been published in 2015...
Apart from the non-Ruby naming scheme of the function the return of a fixed value -1 as indicator for "no duplicates found" is a) unusual and b) limits usefulness of the method. A much better return value would be nil. That would allow for easier usage of the result in boolean contexts as well as make the method applicable to a much wider range of values (negative integers among them, but basically any value).
Haha yeah, good point. However, you wouldn't believe the number of applications running in production using older versions, many on 3.2 and some even on 2.3. Also, it's part of a series we've been doing here: https://www.ombulabs.com/blog/tags/upgrades
üëç Suggestion: Add `NobleNames.title(s)` (or similar) and allow one to opt-out of or in to `String#to_title`.
thank you very much!
thank you !!!!
No. It's typically discouraged as bad practice, though.
This is true. We just upgraded our app to rails 5.0.6 after almost many months of on/off trying. Breaking changes take time to sort and of course testing the change in production takes a while. We have a test suite but it isn‚Äôt 100% on all cases. The upgrade caused a few little bug and one especially gnarly. TL;DR: Upgrading a big app isn‚Äôt easy.
You should see their git commits. ‚ÄúFix typo‚Äù 
How is this better than Twitter's gem?
Product yields an array. If product accepted an infinite enumerator in the last argument position, then none of the other arguments would ever advance past their first value: you're iterating a multiply-infinite Cartesian product in theory, but in practice you're yielding a bunch of 1s and a single incrementing number.
We've been using it for well over three years now and just love it to bits. We've been Rails-free for new development for a year and a half now but, as you note, Chamber isn't Rails-specific. We've used it with Sinatra, Roda, and our current preferred framework, Hanami. It just works. (Where have I heard that before?)
I wish you have enough experience in maintaining large apps, then you will know which is better.
That is actually pretty much how I handle it internally: `NobleNames.noble_capitalize(string)` is called when you call `String#to_title`. I will put this in the docs and add an option to not automatically extend `String` if it is not desired. Made the issue: https://github.com/Haniyya/noble_names/issues/3
If you collect enough automation scripts, its far far better than using Heroku. Give it a try.
Yeah, I believe that in modern Ruby culture the first rule-of-thumb of extending core classes by gems is "just don't" :) Somebody could even stop at this point, but I'd say that core_ext is excusable if: * it is secondary, opt-in (not the primary, always present) interface to the gem; * there is usecase for using new code a lot (example: terminal colors library, in some highly colored cases interface like `"foo bar #{baz.red} and #{quu.green}"` produces the most readable code) * the name is pretty specific, like `Numeric#sqrt` or `String#to_some_specific_datatype`: other code is either unlikely to have the method with same name, or it is likely to do exactly the same. Your gem is pretty useful, but neither of conditions above is covered: `#to_title` is included on requiring gem, the method name is quite ambiguous (highly probably that in a large codebase somebody already invented what `String#to_title` should mean), and as you said yourself, the problem is pretty niche, so in application it would be probably exactly one place, where developer will place "proper capitalization of user input". BTW, another good practice that seems to apply is avoiding global config as a _primary_ method of passing options. I can imagine multilingual app, where in English UI somebody wants to have "proper capitalization" by English rules only (to avoid false positives), and in Spanish UI -- by Spanish rules only, which global config effectively prohibits.
Some things about the api (which I don't prefer myself): The basic design and the `#to_title` method is about 2 years old by now and was mainly made this way because it was inspired by (or was supposed to replace) [String#titleize](https://apidock.com/rails/String/titleize) from rails. So if you are used to Rails's way of extending everything and just having it there it is the more intuitive approach, but this way of monkey-patching for convenience has come out of style (and rightly so) among more experienced rubyists. To remove `String#to_title` by **default** is something i would do on a rewrite or at least another major version bump as it is the main (and suggested) entry point for now. Totally agree with you though that, in hindsight, this is usually used so rarely (a before_ hook usually) that the best thing would be to opt for the second most convenient api in favor of object cleanliness. The languages not being a global configuration makes a lot of sense, but wasn't something i thought of until now (just one of the perks of making it open source and having other people look at it :) ) so i will open an issue and will try to implement it when i have the time. Something like `NobleNames.noble_capitalize(str, language: lang)` should be feasible. 
Heroku is a good toy to start with, but when you really want control its not worth it. Interns in my company use it to show little demos. Yes for that its great. Ya, CTO's and tech guys are ignorant of the other side of Heroku. Its just so sad. People should give things a try first.
Sorry, totally disagree. Heroku has been a pleasure to use, and has freed up tons of time to focus on development of the app it is hosting.
&gt; It's typically discouraged as bad practice, though. Why is that so? I think it is perfectly OK to use `return` in a `lambda` if there is more than one exit. Also, if a method iterates through some collection then returning from the iteration as soon as work is done seems also perfectly legit: def look_for_larger(x, enum) enum.each {|item| return x if item &gt; x} nil end Why would that be bad practice?
&gt;404 Page '/ferro/introduction/' not found They certainly take the "No HTML"-approach seriously.
I said **typically**; of course there are cases where it might be fine. But the general rule comes from this point: &gt; if there is more than one exit It is *generally* bad to have multiple exits in a method. Of course there are exceptions, e.g. guard clauses or breaking early from a simply enumerator, but the principle is to keep it clear when/what each method will return.
&gt; I'll suspend my usual objection about what we call "service objects" actually being "command objects"... [Agreed](https://www.reddit.com/r/ruby/comments/7bm1e0/why_arent_we_using_more_service_objects_already/dpmcv13/?context=2). The Ruby World is pushing me closer and closer to blog about this -and I don't blog! 
&gt; Product yields an array. `Array#product` yields an array, but when defined on `Enumerator`, it would return an enumerator object, like other projection methods of `Enumerable` - `collect/map*, flat_map, drop_while, each_*, find_all/select, group_by, take*` etc. Exploiting all the benefits of partial evaluation instead of total one. In other words `enum1.product(enum2, enum3, ‚Ä¶, enumn)` would return `Enumerator` object which can be later traversed successively instead of exhausted into an array at once. &gt; If product accepted an infinite enumerator in the last argument position, then none of the other arguments would ever advance past their first value This is true but that was not the point. Consumer of an enumerator can't know in advance whether will be really infinite/inexhaustible or not. The point is in *generalization* of `#product` method, despite specific cases and also make it usable for all classes including `Enumerable`. I have to admit, my attempts at simplifying real world examples are a bit deficient. Anyway thanks for the reply.
I believe that as a storage format, YAML is superior. It has a richer type system, and, most important, much more human readable &amp; writable. JSON is definitely a step forward comparing to XML, but it shines mostly for message passing.
I agree. I myself went with YAML for a project that needed a file caching system. Just recommended an alternative if OP is not satisfied with YAML.
I'm just going to throw this out there for fun: [GDBM](http://ruby-doc.org/stdlib-2.5.0/libdoc/gdbm/rdoc/GDBM.html) 
&gt; Known Issues &gt; * Performance is decreased when Google Chrome is running ????
lol
This is the gist of how I do it (just a ruby script, not piped in this case) IO.popen("lemonbar -g #{width}x#{height}+#{offset_x}+#{offset_y} -F #{fg} -B #{bg} -f #{font}", "r+") do |pipe| loop do pipe.puts "whatever" sleep period end end 
`Enumerable#flat_map` can be used to combine map and select: ["1", "2", "nah", "nope", "3"].flat_map { |x| Integer(x) rescue [] } #=&gt; [1, 2, 3] 
I'm curious about that one too... however, it should not be an issue on servers
We don‚Äôt really know that until we hear *why* Chrome‚Äôs presence apparently causes an performance drop, though 
It's really not the 'Ruby World', it's a small but rather loud contingent that is pushing this stuff.
I can't help it either. I have a strong olfactory objection to frameworks that, by design, ask application code to send a `call` message to a collaborator. 
Could somebody explain what do you get from this that you don't have with Operation object typical for dry apps? I honestly don't see it, but it might be that I'm missing the point.
Like I keep saying, it's not a strict rule - and in particular the use of **guard statements** (which is what that first answer mentions) are one exception I agree with (as does default rubocop). Guard statements, however, are very rarely written as blocks. I made that statement more to make the point that "long methods with multiple return statements, *especially inside complex blocks*, probably constitutes bad code".
We use headless chrome on servers :p
Um what do you mean by changing to different classes? 
Wow this is great. Thank you a lot for detailed feedback and I'll be sure to look at my code again once I got back. Really appreciate it. Thanks a lot! 
Also [PStore](http://ruby-doc.org/stdlib-2.5.0/libdoc/pstore/rdoc/PStore.html)
Is there a framework that does that? Afaict even this library doesn't require applicative code to invoke call on a framework artifact.
I had in mind this code from the article: class UsersController &lt; ApplicationController def create UserCreator.call(user_params).fmap do |user| render json: user end.or_fmap do |errors| render json: errors.full_messages end end
Do you have non-Ruby examples? I looked sometime ago, but couldn't find any. 
hmm good point
Ah, your objection is the use of call itself, as a matter of interface design? I have to say, I tend to prefer call over execute for command objects in Ruby, because it allows a short form that utterly removes the need for the redundant "do it" method. For instance, `UserCreator.(user_params)` can also work, and it allows the class to be named more naturally after a verb, which is invaluable for command objects. So, `CreateUser.(user_params)` is possible, which is nice (and exclusive to Ruby, iirc).
Thanks, let me look into popen. I'm not to familiar with it.
why not store it in relational form in sqlite, using sequel? your efforts are better spent thinking about the domain relationships than on how to parse and serialize.
Yes; if we're going to use promise-like result monads I'd rather just have the domain-level factory return one straight to the application service (which Rails calls the controller). Here's my ideal interface: def create repository = UserRepository.new repository.create(user_params) do |result| result.success { |user| render json: user } result.failure { |errors| render json: errors.full_messages } end end 
I‚Äôve used wkhtmltopdf but if I had to do it again I would use a wrapper for headless Chrome [like this one.](https://github.com/Szpadel/chrome-headless-render-pdf) . CSS differences between chrome and wkhtmltopdf caused a few mishaps. HTML templates were a requirement though so I couldn‚Äôt use a pdf library directly.
Have you tried looking at what the post body is that's actually arriving at the server? I.e. what exactly is being parsed (not what's being sent)?
Do you ever want to query it in the database? If so I'd go with json, stored in Postgres jsonb columns. MySQL probably has native json support now too.
Why not just use a function? Why do you need to put more pressure on the garbage collector by creating a class for every tiny little bit of functionality?
I have not known what lemonbar was before this. How are you using Ruby with it? All the stuff I see uses Bash.
my question isn't about accuracy but around the consumption of RAM and speed
You can output any script to it and then pipe it to lemonbar. Works great. I will post when I finish my script.
I would love to see the finished product. Thank you. 
FYI: Don't forget the HexaPDF see https://hexapdf.gettalong.org and https://planetruby.github.io/calendar/advent2017/09-hexapdf Cheers. PS: HexaPDF is the fastest PDF library (in rubyland), see the benchmarks.
That's what I was thinking when I saw it and recognized Operation. So, this is for people who like dry-monads library, but have some issue with other dry components? Well, seams like a small audience, but more solutions from different people could get more ideas out there so I wish them the best. BTW, thanks for your contributions. I'm enjoying working with Ruby in a way that I haven't for a while now because of ecosystem you are part of.
I just fixed the trailing slash problem.
Correct. Prawn is a little easier to use than hexapdf though. But that depends on what and how you are using it too. In the end we decided to "simply" wrap around latex: let ruby(rails) write out .tex files and then have latex consume that and create PDFs from it. It allows much easier and nicer typesetting. With Prawn, designing a table, adding some fancy footers or nicely lay-out text, is a real bitch. With wkhtmltopdf this is reasonably easy, as it is just "making the HTML look good". Getting proper PDFs from that is a bit harder, since the CSS and HTML tweaking requires clumsy workflows and hard to debug stacks. I'd consider the "use a headless browser to print to PDF" a smart-but-ugly hack at best. As such I'd say: go for Prawn, Hexa and spend some effort in creating proper classes and layout toolsets for yourself in there. And if you know and like Latex, just leave it out of Ruby alltogether.
Author here. Would be interesting to do some tests with latest headless Chrome or such, but as long as you need to shell out from Ruby I think Prawn will win for long running processes such as Rails. Also depends on the document itself. When I did the testing above making the document more complex (by adding more CSS) definitely slowed wkhtmltopdf even further. However for me the real benefit was just using pure Ruby and so I would prefer Prawn even if it's actually slower.
&gt; Like I keep saying, it's not a strict rule You said "It is generally bad to have multiple exits in a method." - and I disagree. &gt; I made that statement more to make the point that "long methods with multiple return statements, especially inside complex blocks, probably constitutes bad code". Well, *that* is something quite different.
&gt; You said "It is generally bad to have multiple exits in a method." - and I disagree. Yes, I was over-simplifying.... But I think it's fair to say that: * **Most** methods, in a well-written project, should only have 1 return statement. * A general rule of thumb, for beginners, would be to try to write methods that only return at the end, other than guard statements at the top.
I actually usually feel the same way about C# too. I‚Äôve written a lot of Ruby aver the last 5 years or so and pretty often I think, ‚Äúhmm, this is too clever for Ruby code. Nobody will ever find it. If this were C# at least the IDE could find it with static analysis.‚Äù That is to say, while I love Ruby, I loved C# too (and I miss static type checking and the stronger type system. Back when I was a C# developer, I actually said out loud, ‚Äúthank God I get to write C# for a living!‚Äù That being said, Swift is pretty pleasant too. And if you‚Äôre stuck with the JVM, Kotlin looks pretty pleasant. 
The article is talking in terms of computer resources - I'm talking in terms of the humans programming the computer.
Reusable objects are easy enough to implement in the context of the command pattern, also there's other techniques for reducing object allocations like flyweights. Because there are straightforward techniques for addressing common performance constraints, I feel comfortable completely ignoring garbage collection (and object allocations in general, for that matter) until there's a quantifiable bottleneck.
When I need accurate rendering control over tables (e.g. documents with tables spreading over multiple pages) or tight control otherwise, I use Prawn. I only use wkhtmltopdf for simpler scenarios.
i am inclined to agree. while i don't have a problem with someone creating a 'convert x to y' method, I think it's a little confusing (you could say a little too clever) to define these 'internal hook' type methods and use them without explicitly calling them
Thanks, I'll try that. What I'm looking for is something like the `plot` command in, say, Octave or Matlab -- it generates the plot and opens a viewer at the same time. Thanks again for your help.
some people say it's never or almost never a good idea to use it. If you don't see where to use it, I wouldn't worry about it. 
I wrote a new article with a little template for testing record creation via unit test on a Rails App... maybe this can help you with the "methodology" or "repeatable process" that you are looking for =) ... I hope it helps... http://bhserna.com/2018/a-little-template-for-testing-record-creation-via-unit-test-on-a-rails-app.html 
**Edsger W. Dijkstra** Edsger Wybe Dijkstra (Dutch: [Àà…õtsx…ôr Àà ãib…ô Ààd…õikstra] ( listen); 11 May 1930 ‚Äì 6 August 2002) was a Dutch systems scientist, programmer, software engineer, science essayist, and early pioneer in computing science. He held the Schlumberger Centennial Chair in Computer Sciences at the University of Texas at Austin from 1984 until his retirement in 1999. A theoretical physicist by training, Dijkstra worked as a programmer at the Mathematisch Centrum (Amsterdam) from 1952 to 1962. He was a professor of mathematics at the Eindhoven University of Technology (1962‚Äì1984) and a research fellow at the Burroughs Corporation (1973‚Äì1984). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Congrats Mike! Excellent product, and Faktory is sure to be a success. Thanks for sharing.
Great to see a write up on how to upgrade from Rails from 4.1 to 4.2 as I've been relying on http://guides.rubyonrails.org/upgrading_ruby_on_rails.html but that doesn't cover an area like common gems that don't support 4.2 in more detail. The layout of this article is also much nicer to look at and, thus, actually read too. Thanks! (Though I feel this should've been in [r/rails](https://www.reddit.com/r/rails/).)
Thanks!
Congratulations! Prepare yourself for a production code base being several orders of magnitude more complicated than you imagined when you were learning to program. It's going to be a big threatening mess, and it'll take you weeks probably to understand it.
But these are single function classes.
Try jruby threaded. Also lua which in nginx can connect directly to redis. That's likely to be the fastest.
Sounds like a gem of a job. Hope you got some great benefits Bundled in! If not, don't wanna derail your excitement! Congrats!
&gt; What are some things you wish you knew before starting your first Ruby gig? I *presume* it's a rails job (because most are)... The main thing I wish I knew more about, before starting, is a wider picture of "how the internet works". In the back-end, learn about the basics of web servers (e.g. apache/nginx); how SSL certificates work (letsencrypt in particular); maybe even a little about how DNS works (especially subdomains); and definitely get a good grounding in unix command lines if you haven't already. None of this is strictly needed for a job, but you'd be surprised how much a good foundational knowledge can come in handy! Also, along the same lines, spend some time playing around with the developer tools in your browser - this is a *huge* and powerful set of tools; there's a lot to learn here, but you should at least get comfortable with inspecting network requests and playing around with CSS/JavaScript editors. Again, just having some confidence knowing your way around the tools can end up saving you countless hours in future. Lastly, when it comes to the actual *ruby*, watch a whole bunch of tutorials (I can provide a list if you'd like, but there's tonnes of material out there!) about best practices. Ruby is a very easy language to "hack something together in", but it takes quite a bit more skill and experience to write something *good* in the language. In particular, be sure to experiment with the full ruby library -- don't just get bogged down in `if` statements and `each` blocks; it's a *very* expressive language. If you think your code looks ugly, then it probably is; there's almost always a "better way" to solve it in ruby. So read the documentation, experiment, and ask!
In general, when the command pattern is employed, it's easy enough to make it reusable in order to reduce object allocations (and, by extension, deallocations). Reusable: class Foo def call(params) end end Not reusable: class Foo def initialize(params) end def call end end However, I'm not sure about the flexibility afforded by this particular library.
http://i.imgur.com/s3Yw9P4.png
 def foo() end How hard is that? I mean if that offends you then module Foo def self.bar() end end The idea of writing a class with just one function in it (other than initialize) is madness and overengineering.
https://www.reddit.com/r/ruby/comments/7sjh65/just_got_a_new_ruby_job_what_to_do_to_really/dt6ny94/?context=2
Although there is a lot in GoF that is dated by today's standards, the explanation of the command pattern would be worth reading if you're curious about its origin. An example of a powerful technique composed out of command objects is the memento pattern. There are many others -- I don't have time to list them all, but there is solid research and theory out there behind command objects. I use command objects all the time, because they can model _behavior_ (and encapsulate the data necessary to carry out that behavior), and are easily substitutable. The software systems I build which lean heavily on this approach are some of the most stable, bug free, easy to change/extend systems I've ever worked with. In fact, I'd go so far as to say a lot of the pet examples in OOP books like bicycles in POODR fall short precisely because they ignore the notion of modelling behavior, and instead focus on modeling "nouns" that have a resemblance to tangible real-world things. I suppose it can be argued that the approach taken is helpful for beginners, but I often encounter beginner and intermediate level software designers inspired by such material that have fallen under a spell of thinking that classes need to have multiple methods to "feel right" (which I'm not sure authors like Sandi Metz intended).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ioquatix/trenni/.../**README.md** (master ‚Üí 7227fb2)](https://github.com/ioquatix/trenni/blob/7227fb22e689475ac49a9cc64f9818f2d740478f/README.md) ---- 
Do you want to accept a PR for async-http?
Yes, correct! After pulling my hair out all day today, I finally got it working. I'm new to Ruby, so this code is probably awful, but it works: https://gist.github.com/mjuszczak/5f235d2a992958dc288df76c9d914dc6 
If you go this route, I would highly recommend building some custom tooling around puppeteer. That's what we did and it worked out great.
The GOF book was spawned out of the J2EE era and most of it doesn't really apply to languages like Ruby. If you want to model behaviors ruby has a thing called modules you can mix into objects.
Hi, I finished with the ruby script for Lemonbar. I ended up splitting it into 4 files bsp_tree.rb time.rb wintitle.rb rubypanel they are here in the .bin folder of my git repo https://github.com/derrickcope/bin
Fudge, edited. 
Have you considered using regular expressions? There's a good Stack Overflow answer about doing so [here](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags).
Maybe the most important piece of software after Rails in a Rails app :)
You can think of the Ruby heap as a high watermark. It is how much your app has ever used until the process is restarted. The GC runs and frees some stuff out of that pool but Ruby still keeps it claimed. I will get to why in a sec. If you have 100mb high watermark and your app needs to allocate 11mb more it will ask the OS for 11mb more (I‚Äôm purposely light on details). Now you‚Äôre at 111mb watermark. Say that web request that caused that 11mb increase ends, GC runs and sees that 11mb is no longer needed, it frees the slots internally. You are now using 100mb of your 111mb watermark/pool. A new request comes in and your app needs 5mb more so now you‚Äôre at 105mb out of 111mb of your watermark and so on for the life of your app. Assuming you don‚Äôt have a memory leak, your watermark will get high and stay high but should stabilize. Your current actual use of it will depend on GC. Why does Ruby act this way? Because it doesn‚Äôt compact/defrag the memory. An object‚Äôs memory could be all over the heap so Ruby plays it safe and refuses to free memory. Ruby tries its best not to allocate so it will pull out any free slots in its heap for an object it can. It‚Äôs even worse for Ruby objects allocated with C objects in them (nokogiri). These are really unsafe for Ruby to free or move. Aaron Patterson has been working on compacting memory for Ruby and has made great progress. This could allow Ruby to one day actually truly free memory back to the OS. C objects are a big problem to it still as mentioned. Read his blog for more info.
As another commenter said, chances are you're going to be working on a Rails app, so some advice from someone who has worked on a number of those - be careful to keep everything well documented, well organized, tested, and comprehendable. In a big boiler like Rails it's easy for stuff to be a jumbled mess and lose track of what's happening where. I recommend trying to be as explicit as possible with your programming. In the Rails world there is a lot of "magic" gems and it's important to try and only implement features in a way that you really understand what's going on and you have full control of it. Also, if you're unit testing (and you should be), be careful not to introduce too many database calls into the tests (you can use fixtures an an alternative), or else they will grow really slow. For example, my current company's test suite takes 1 hour to run _if_ we split them up into 10 groups and run them concurrently. This is honestly a despicable situation and you should never, ever find yourself there. 
Thanks for the reply! Then why GC doesn't free live slots internally? If you look at screenshot there are 10M live slots starting 2pm. Something should hold them, right? There are no constant requests which create 10M objects every time, so they should be freed (marked as free) at some point? 
DE.
Any output from a script can be piped to lemonbar. That's what makes it so great. I am assuming your current DE has a panel built in. Lemonbar is really designed for WMs that don't have a bar. 
I see. Thank you very much.
&gt; Let me ask you this question. Who holds a stronger command of how to design and implement complex software systems, the narrow subset of the software world that is The Rails Way, or the decades old software principles that have been accepted across the industry as a whole? I'm not arguing against principles of software architecture, I'm arguing against shoehorning them into Rails. Rails works best when one follows its conventions (you may not agree with me, but this is where I stand after working with it for more than a decade). Yes, these conventions are not terribly academic, but they do the job _most_ of the time. If you want to go all architectural on your app, there are countless alternatives to Rails out there that are better suited. I'm just having a hard time understanding why people eschew, for example, Java (which has some _great_ frameworks, like Play) for something like Rails, and then try to turn it into the thing they wanted to avoid in the first place. It simply does not make any sense whatsoever.
&gt;The first part isn't true (feel free to give it a read) What makes you think I haven't read it. I didn't make any smug comments about how I thought you were ignorant and illiterate why do you feel compelled to make such a remark against me? &gt;How would that work? Modules can hold state if you want but that's besides the point. The point is that command objects are behaviors. They are objects that wrap only one function (the call function). They are not supposed to hold state and they are not supposed to model anything. If you want to model something then use a model. Rails even has a folder called "models" that you can use.
I don't really like methods modifying the parameters I give them.
I wasn't being smug. I was dealing with a sentence that comprised of two clauses, both asserting something as fact that wasn't true. I knew you either hadn't read GoF or had retained too little of it to matter because it didn't spawn out of the J2EE era. Even the first paragraph of the Wikipedia article demonstrates this. You can also feel free to accuse me of being ignorant and illiterate. If you know of any worthwhile books for me to read, I only gain by being exposed to worthwhile information. Trust me, I won't take it personally. Anyways, classes are, fundamentally speaking, closures. They may hold any state they require to perform their duty. By the principle of encapsulation, other adjacent collaborators must not access that state. In a sense, the state is invisible to the world outside the closure (class). Class design patterns like Command do not generally impugn on implementation details invisible to external collaborators. A command object _is_ an ideal model for behavior. "Model" isn't a style of class. It never meant that when Trygve Reenskaug published MVC. In the Rails world, a particular ORM has come to be synonymous with the M in MVC, but Rails is a very small portion of the software universe. Rails' model directory would actually be more appropriately called `app/tables`.
I generally don't design interfaces this way, myself, but when used for validation, it doesn't bring the risks inherent with passing in a value with intent to mutate (there would be no sense in passing in an object with prior state). There are other techniques, though: # Just returns a user record user = repository.create(user_params) # Returns the user record and a list of errors user, errors = repository.create(user_params, include: :errors) A parameter can cause additional return values to be emitted. Although, you lose some control this way. Previously, I could pass an any kind of value I wanted, now `repository` is instantiating a concrete instance of whatever class holds errors (e.g. Array). So, tradeoffs. At any rate, I wouldn't necessarily change the whole execution flow of the web controller method just avoid something unsavory about one method call.
&gt; Yes, these conventions are not terribly academic, but they do the job most of the time. Well said, but I disagree. We all have different exit criteria, design goals, and qualities that we're targeting with our implementations. Rails' patterns don't help me achieve the target I'm usually trying to hit, but they do work fine for small CRUD apps, which are a rarity for me to work on. &gt; I'm just having a hard time understanding why people eschew, for example, Java (which has some great frameworks, like Play) for something like Rails, and then try to turn it into the thing they wanted to avoid in the first place. It simply does not make any sense whatsoever. I think there's a fundamental disconnect in the community, though. Rails, to many of us, is a _web framework_, not an application framework. Trailblazer in particular seems aimed at people who love the Rails web framework, but don't want to treat it as an application framework. Dry, on the other hand, seems utterly ignorant about what web framework is being used, as the web is ultimately an "edge" concern (I tend to like that line of thinking). For myself, I'd rather write ruby than java, and ruby has some great frameworks, too. Also, I don't think dry looks anything like java, personally, and I don't think it's added anything to ruby that defies what makes its authors and community prefer ruby to java. It might have added some things _you_ don't exactly miss about java, but to each her own, right?
I was hoping nokogiri wasn‚Äôt a dependency... I suppose that‚Äôs too much to ask. This is almost more of a de-serializer. Very cool. Good work.
Thanks! Deserializer is a neat description as well. Do you have an idea about how one would go about removing nokogiri as a dependency? Is there an equivalent of multi_json for xml?
To the people who are interested in this, is there a need to abstract this to allow for generic backends? I don't think this has to be tied to XML but for us there was never a need for anything else.
https://github.com/ohler55/ox is lightning fast, and might be enough for what you‚Äôre trying to achieve.
Thanks! I'll look into it. If i remember correctly I have only a few points of contact with nokogiri (namespace handling, xpath engine and such). So no promises but I'll try to have people choose their xml engine.
read these two books: https://www.amazon.co.uk/Rails-AntiPatterns-Refactoring-Addison-Wesley-Professional/dp/0321604814/ref=sr_1_1?ie=UTF8&amp;qid=1517938240&amp;sr=8-1&amp;keywords=rails+antipatterns https://www.amazon.co.uk/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330/ref=pd_cp_14_3?_encoding=UTF8&amp;psc=1&amp;refRID=RPRY329V1QV4P8C1AJE8 They are both a bit old, but totally valid. The one is more practical (and about rails, if your Ruby job is indeed a Rails job), the other more general on OO design.
I can't get behind this. &gt; REST APIs have a fixed structure defined for each API endpoint. They either return too much data on each API call or too little. For example, if only titles need to be displayed on a certain page, returning extra fields doesn‚Äôt make much sense. Similarly, what if we wanted to return only the distributor‚Äôs name? In traditional REST APIs it would most probably require sending another request to fetch the distributor information for that movie. I stopped right there. There's a _huge_ presumption about REST APIs baked into that paragraph. Namely, that the hypothetical REST API in question is modeled after a schema that is _internal_ to the application, rather than being modeled after the needs of the web clients. This may be commonplace for rails APIs, that export a relational database schema, but that's not exactly an ideal practice. As a general pattern, this is called "distributed objects." It's the quickest, easiest way to staple a client and server together, but it's almost never an ideal. Go has a saying that rubyists would be well served to heed: instead of communicating by sharing data, share data by communicating (over messages). REST APIs can perform very well when they are used to transmit messages. Think about Slack for a minute. They have desktop apps, mobile apps, and a web app that all deliver more or less the same experience. The same HTTP APIs that work for mobile apps are going to prove more or less suitable for the desktop and web apps. There's symmetry because there's really only one logical user experience, even though it's implemented in multiple clients. GraphQL is a query language. It's for a specific use case -- when the needs of the clients differ dramatically. It offers maximum flexibility but at the cost of maximum complexity. Query languages and REST aren't even opposing concepts, and I'm tired of proponents of GraphQL using a misunderstanding of both REST and the purpose of query languages to advocate its usage. I hate to be harsh, but in this case, the title of this article is an imperative telling everyone to use something for all the wrong reasons.
Are articles like this still popular in 2018?
As Metz says, "it's just another form of inheritance". Does that help?
Graphql is a fairly expensive way to create an API. It has its own processing cycle. This doesn't mean that you shouldn't use it, or even that you shouldn't use it mostly, but be aware that most of the benefits that proponents of graphql tout fall into two categories: 1. Shared clients for the API 2. Baked in method for designing the API It's good, but it's not the only game in town for more easily making better APIs. 
Thank you for the kind words, all. I want to note that feedback is very welcome for all three new releases. I especially want to know if there are any problems with the ActiveRecord caching integration.
I have two blog posts talking about why modules can be bad - https://blog.codeship.com/good-module-bad-module/ - https://blog.codeship.com/when-to-be-concerned-about-concerns/ 
&gt; GraphQL is a query language. It's for a specific use case -- when the needs of the clients differ dramatically. It offers maximum flexibility but at the cost of maximum complexity. &gt; &gt; Thumbs up!
But it's not a form of inheritance though. And that's why I'm asking, so that didn't help. "inheritance is for specialization not for sharing code" that part everyone knows, but that's not relevant if no one explains why mixin is a form of inheritance. Do you know why she said "it's just another form of inheritance?"
I get it now, that's for explaining... I think I missed the context from the OP.
of course it does and since long nowadays...
But, it is a form of inheritance, though! In what ways can you identify in which it is different than inheritance. You identify a module that is an ancestor of your class at hand, and can call instance methods that were defined in it, and can override those instance methods in it and then call super to get the module instance methods, and the module instance methods can call 'super' to get further up the chain, or call other instance methods defined by anything in the inheritance chain, etc., all just like inheritance. That's why Metz says it's a form of inheritance. Because it behaves just like, well, a form of inheritance. 
I've never understood why some have such complex ideas about REST. REST is very simple, it is whatever you want it to be provided you follow HTTP and a few rules
&gt; But it's not a form of inheritance though. They're overwhelmingly similar. The most obvious thing is that they look different. The behavior stays the same. The hard part is knowing when to use each, which is vastly dependent on context. module Greeting def hello "hi" end end class Human include Greeting end class LivingThing def hello "hi" end end class Person &lt; LivingThing; end 
&gt;A command object is an ideal model for behavior Ruby modules are ideal for modeling behavior. They can be freely mixed into any object which needs that behavior. That's what they are designed for. &gt; Rails' model directory would actually be more appropriately called app/tables. Well isn't that smug. You think the people who wrote the framework didn't know the difference between a model and a table?
Who knows, but it's okay. I just wanted to have a discussion
Yeah, REST is not really difficult. GraphQL is just the new "hotness" at the moment. Even though it is about 4 years old I believe. We will learn from GraphQL and come up with something even better overtime, I am sure as we always do in tech or at least something we think is better (maybe GraphQL) and just realize we should of never changed in the first place.
these guys helped: RUBY_GC_HEAP_GROWTH_FACTOR: 1.25 RUBY_GC_HEAP_GROWTH_MAX_SLOTS: 300000 RUBY_GC_HEAP_INIT_SLOTS: 600000 ``` by default GC_HEAP_GROWTH_FACTOR is 1.8, I think it's too much :)
And hope like crazy the colleagues has also read those books so the existing codebase does not look like a conflicting mess to what is learnt from the books
Yeah, definitely not the only tool in the toolshed. I enjoy it more from the client consuming POV. There are things that we definitely need to do to prevent the extra processing and in a language like Ruby where we still don't have concurrency equiv to a language like Go querying for multiple things and then joining them can become expensive.
So it IS inheritance, or it's "just like inheritance?" Which one is it? But anyways, that's not what I'm interested in knowing making this thread, I want to know why it isn't a good solution like she said. You pointed out "inheritance is for specialization, it's not for sharing code" it's not for sharing code doesn't mean it can't be used that way right? Personally, I think sharing code and specializing don't have to be mutually exclusive either. So instead of referencing a principle, can you point out exactly why mixin isn't a good solution for implementing the RandomEchoHouse thing? 
Thanks, must have taken a year to write!
Cohesion is of chief importance when designing APIs of any kind, including HTTP APIs. If clients typically only need some fields, but not others, then the response payload is non-cohesive, i.e. wrong (or else there is some problem with the client, like it isn't caching data properly). Again, I go back to the example of Slack. When you are delivering the same user experience through every client, why would there be variation on what fields are used by different clients? When the clients have _good reason_ to need wildly different data from the server, you can then classify the different categories of clients you have. If you find, for instance, the clients vary based on the role of the person driving the user experience, i.e. Uber drivers vs. Uber passengers, your best bet is to build them each a different API. It may seem like more work, but if you built your backend properly, it really isn't, because you're just modelling different sets of use cases for each role, which needs to be done no matter what. On the other hand, if your API has to support oodles of organizations with all sorts of different needs, and those organizations have the technical staff necessary to work with a query language, something like GraphQL is an excellent choice.
Dunno, I know I up-voted you. People clearly use the up/down buttons to voice their kneejerk reactions, it sucks :(
Cool! It's funny, I just started learning about ES a few weeks ago, and have spent a lot of time writing a bunch of hacky ruby scripts that loads data from SQL Server into ES via Sequel. This is lovely to see as my intrigue grows! One question: # https://github.com/jrgns/sequel-elasticsearch/blob/master/lib/sequel/plugins/elasticsearch.rb#L25 @es_client = ::Elasticsearch::Client.new elasticsearch_opts Do you intend for this to be `@es_client ||= ::ElasticSearch::Client.new elasticsearch_opts` ? If not, what is the purpose of setting the instance var if you are just overwriting it every time you call the method? Help with debugging? Genuine question.
Note that you can install the JIT version with "rvm install ruby-head" today. If you need to enable the JIT with "bundle exec", this seems to work: RUBYOPT="--jit" bundle exec xxx More options with ruby -v etc (including "--jit-verbose=1")
Cool! It's funny, I just started learning about ES a few weeks ago, and have spent a lot of time writing a bunch of hacky ruby scripts that loads data from SQL Server into ES via Sequel. This is lovely to see as my intrigue grows! One question: # https://github.com/jrgns/sequel-elasticsearch/blob/master/lib/sequel/plugins/elasticsearch.rb#L25 @es_client = ::Elasticsearch::Client.new elasticsearch_opts Do you intend for this to be `@es_client ||= ::ElasticSearch::Client.new elasticsearch_opts` ? If not, what is the purpose of setting the instance var if you are just overwriting it every time you call the method? Help with debugging? Genuine question. (Edit: And if so, mind if I make that tiny contribution so I can feel cool? haha)
&gt; Ruby modules are ideal for modeling behavior. They can be freely mixed into any object which needs that behavior. That's what they are designed for. Modules can't _model_ anything because they don't stand on their own. Only those concrete classes that include modules can model something. If you mean that modules are ideal for _implementing_ generalized behavior, which is exactly what your second sentence indicates, then I'd somewhat agree (sometimes subclassing is, in fact, more appropriate). &gt; Well isn't that smug. You think the people who wrote the framework didn't know the difference between a model and a table? It wasn't smug. It's just a fact. And I think DHH built an ORM inspired by the ActiveRecord pattern, and decided that ActiveRecord subclasses can serve as the "M" in "MVC." So, yes, he combined the concepts of data access and domain modelling into one framework abstraction. He was wrong, as everyone is wrong from time to time. It's not a big deal, I'm wrong all the time, too. What matters is what we do when we realize we were wrong.
&gt; So it IS inheritance, or it's "just like inheritance?" Which one is it? Both give you an ancestor in your method handling chain. Look at the behaviour, don't get hung up on the definitions. &gt;it's not for sharing code doesn't mean it can't be used that way right You can use it that way, but it's bad style and leads to code that is hard to comprehend and difficult to extend. Rails's view helpers, for example, have given up any pretense of object orientation to become a junk-drawer for code snippets. If you continue with the video into the demonstration of strategy injection (I don't think Sandi specifically names it but I'm pretty sure this is the strategy pattern), you get a solution that has much clearer intent and is far more open for extension, and it's because the domain concepts have been properly extracted. 
&gt; It‚Äôs way to early to change any ruby code to be more JIT friendly. That's really not supposed to be the point of a JIT... if you're willing to change your code you could optimise it manually. The JIT's supposed to do that for you.
&gt; So it IS inheritance, or it's "just like inheritance?" Which one is it? I would say that [class inheritance] is a subclass of [mixins] (because it's a specialization. A subclass does the same thing as including a mixin plus some other things). I don't think the exact way they are different is relevant to the point being made on the OP however. &gt; it's not for sharing code doesn't mean it can't be used that way right? Most things "can be used" for purposes they are not built for. You can use a screwdriver to hit a nail on the head repeatedly using the screwdriver's handle. And if you don't have a hammer or a rock, that might be the best option. However, if the hammer is right there in front of you in the toolbox, using the screwdriver that way is ... suboptimal.
Post your code on GitHub. I can help out as well if needed. No money required. 
Go home dad. 
kinda :D but yeah, I hope it helps!
&gt; Running that it looks like MJIT is over 3x faster! ÂáÑ„ÅÑ„Å≠ÔºÅÔºÅ I mean, I love ruby not for it's performance but still, speed is always nice to have. Especially with **zero** changes needed in the user code. &gt; TruffleRuby is over 300x faster (I only mention it because it's my own implementation of a Ruby JIT), so there's still lots of rooms for optimisations (.. vs 3x) talk about understatements
What projects at Oracle internally use TruffleRuby ? Before releasing a JVM, the Oracle team runs a series of benchmarks on well known Java products which it maintains. Is the same procedure followed for Truffle ?
I don't think anyone uses TruffleRuby anywhere yet. We're moving towards that yet. We plan to test TruffleRuby on all the gems in RubyGems - a sort of reverse Travis.
For this example, I actually do care about startup time. I want to get the puzzle answer as fast as possible, and calculating the answer multiple times isn't useful. Unfortunately, truffleruby's startup is slower than the entire JIT and compilation under MJIT. I'm sure it's awesome for long-running servers, though. $ ruby -v truffleruby 0.30.2 [...] $ time ruby -e '' 15.96s user 0.36s system 349% cpu 4.673 total I'll have to find another example to pit them against each other.
Well, thank _you_ for participating in a meaningful, positive conversation that, frankly, this world could use more of. Next time I bet it'll be you keeping me honest :) Cheers!
If you're looking at TruffleRuby startup time, be sure to use the SubstrateVM version of TruffleRuby: https://github.com/oracle/truffleruby/blob/master/doc/user/svm.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**svm.md** (master ‚Üí 57a4c3d)](https://github.com/oracle/truffleruby/blob/57a4c3de7e10d5751e0847719d808bde0b3b0874/doc/user/svm.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtusfwl.)
Reconsider "waifus" as the subject matter.
Why?
Because not everybody likes looking at fake boobs while coding. 
Hey, glad I can contribute to the intrigue :) That wasn't intentional, so yeah, please create the PR! 
There are more appropriate examples too, such as using soda baking powder to absorb odour. Anyways it's meaning less to showcase analogies if no one answers my original question, why isn't mixin a good solution? Maybe i wasn't being clear enough, I want a more technical explanation, something more than just "it just isn't meant for that." 
That's quite a project given how bad so many projects are about Travis!
I can take a look too. Not a Pro but willing to help. It would be best to share your code on github or post the error on here
Blocked for egregious sealioning. 
&gt;Modules can't model anything because they don't stand on their own What the hell man. You keep mixing models and behavior. Models are for models. Modules are for behavior. You aren't fooling anybody by constantly swapping the terms.
I really just have one question, asked in the original post. It's fine if you don't know.
Oh man I‚Äôve implemented this manually on multiple occasions, glad to see it standard.
Thank you.
This was educational. Thank you. Please keep going. But you may want to try using a better microphone.
My question to you first: Are you completely new to programming too or just new to Ruby? If just new to Ruby, what prior programming experience do you have and with what language?
Well I am quite new to programming as a whole. I've only programmed on visual basic more or less and Html but overall I don't have much experience and I am still learning.
The only thing I can think of to say that will explain it briefly is that it's going to get very hard to maintain and comprehend as it grows. You'd have one module overriding one method of House, and another overriding another. It's easy for them to start accidentally interfering with each other, overriding functionality the other is depending upon, or accidentally trying to override the same method. You've got code split up between three (for now) classes/modules, but none of it is actually encapsulated from each other, anything in any of them can call any method in any of the others. Metz suggested it would take her 100 slides to explain well, or that the listener should try it themselves and find out. I too wish Metz would take the 100 slides sometimes, because this is a topic that many disagree and/or are confused on, you are not alone. You seem angry, I'm not sure what you're angry about. 
Thank you for the info. And yes I am currently in high-school but I have future plans for studying programming at university. I am hoping I'll be able to make it in the programming industry.
I wouldn't bump the major version, just the minor version. If you specify the lowest supported Ruby version in the gemspec, Rubygems shouldn't show newer versions of the gem on unsupported Rubies. However, it is up to you. As for proper versioning: If you use the major.minor.patch numbering, it applies to your code, not the Ruby interpreter. So the patch number is increased if, for example, a bug has been fixed.
Personally, I only drop ruby version support in a major release. But I try to take backwards compat very very seriously, I think more so than many in the ruby ecosystem. I wouldn't be surprised if it's common to do otherwise. But my thinking is that backwards compatibility and semver means that (excepting unintentional bugs), someone should always be able to upgrade within a major version of my gem, and have nothing break or stop working with no other changes. If they are using an old version of ruby that I drop support for within a major version series, that wouldn't be true. 
This is a good opportunity for you to exercise your reasoning and debugging skills. It may help to try [rubber duck debugging](https://en.wikipedia.org/wiki/Rubber_duck_debugging). Here's some background knowledge you may have missed out on: * Every method has a **return value**. * `#puts` takes an argument and **prints it to standard output**. * These two concepts are not related to each other. See if you can figure out (or at least look up) what the return value of `#puts` is. If you're still having difficulty understanding how the output and return value can be different, go do some homework. Your program says: # 1. Create a new Bottle. # 2. Tell it to #song. # 3. Take the return value from Step 2, # 3a. assign it to b, and # 3b. print it to STDOUT. puts b = Bottles.new.song # 1. Tell this bottle to #verses with the arguments 99, 0. # 2. Take the return value from Step 1 and return it. def song verses(99, 0) end # 1. For every number between hi and lo (inclusive), # 1a. tell this bottle to #verse with that number, # 1b. take its return value, and # 1c. print it to STDOUT. # 2. Take the return value from Step 1 and return it. def verses(hi, lo) hi.downto(lo) { |i| puts verse(i) } end # 1. Return a line of the song, with num interpolated where appropriate. def verse(num) &lt;&lt;~VERSE #{num} bottles of beer on the wall, #{num} bottle of beer.\nTake one down and pass it around, #{num-1} bottles of beer on the wall. VERSE end Your program prints to standard output in two places. Do you see it? Now, can you tell use why that extra `99` comes out at the end?
**Rubber duck debugging** In software engineering, rubber duck debugging or rubber ducking is a method of debugging code. The name is a reference to a story in the book The Pragmatic Programmer in which a programmer would carry around a rubber duck and debug their code by forcing themselves to explain it, line-by-line, to the duck. Many other terms exist for this technique, often involving different inanimate objects. Many programmers have had the experience of explaining a problem to someone else, possibly even to someone who knows nothing about programming, and then hitting upon the solution in the process of explaining the problem. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
My reading of the semver specification is that yes, sunsetting an EOL platform means a major version bump. It may not explicitly say anything about EOL platforms explicitly, but it does say explicitly that minor and patch releases should be backwards-compatible. That means if a program is written with Hashie v3.5 and everything works, upgrading to v3.6 should result in absolutely zero problems. Dropping support for my platform is a very big problem.
The game piece example is about using singleton to, yes, conserve memory, with simple data types. For instance, you'll note that ruby itself uses it with integers. `101` is always exactly the same object in ruby (which is necessarily immutable for that reason; in general, singletons that are _mutable_ are going to give you nightmares, especially under concurrency). I probably wouldn't be likely to actually implement a chess game that way. 
I'm not angry though.
I would suggest starting with JavaScript if you're new to programming as a whole, it's easier for beginners, and it can be used everywhere, and you don't have to install anything to begin with (which can potentially save you hours of hassling around). Ruby is a fun language but not so fun if you're just a beginner making simple console applications. And rails does require more than just beginner skill level to make anything useful. Best way to start off would be getting an online video training course/subscription, unless you are a book guy. If you're very new to programming, make sure you're good with all the fundamentals before starting or planning a project, because there's really not much you can do if you don't even have the basic skills, I personally found it counter-intuitive that if someone's trying to make a website while not even understanding the intricacies of a for loop.
Thank you for this guide! I am looking forward to this research.
Thank you for this information!
The reason is because the last expression in a method is implicitly returned from methods within Ruby. Fixnum.downto() returns self(Fixnum) (provided it's given a block which is the case above) and that is assigned to b which is then printed by puts()
That's interesting! I don't think I had ever noticed that section of the document. If you take Ruby as a dependency, then this paragraph definitely seems to say "don't worry about the major version bump".
Thanks for your input! &gt; I can completely appreciate not wanting to do a constant major version bump ... It's funny how averse we are to doing major version bumps, isn't it? Really, it's just incrementing a different number ... why is it so hard to want to do that? &gt; To that I'd say, don't drop versions of Ruby just for the sake of it. It's a silly reason that I want to drop it: I would prefer to be on the newest version of Rubocop for the library, which dropped support for older Rubies. üòÖ
Thanks, that's my simple reading of the specification as well.
As one of the two dissenters among the various opinions, I'm curious if you always run the latest Ruby on your projects and when you choose to update. Would you be willing to share your process for keeping up-to-date?
[ctags](https://andrew.stwrt.ca/posts/vim-ctags/) is very helpful for navigating through an unfamiliar codebase.
&gt; Especially with zero changes needed in the user code. Well, there was changes in the code in this particular case. Find them in the original article.
I gotta say, hashie specifically has een painful with backwards compat in the past for me, and this isn't going to make it easier. :( What are the downsides of continuing to support old rubies? Does it go beyond just not using new syntax, you actually have to do things differently to get it to work on both? What are the downsides of just calling it a new hashie major version?
[RubyMine](https://www.jetbrains.com/ruby/) is a fantastic IDE
&gt; It's a silly reason that I want to drop it: I would prefer to be on the newest version of Rubocop for the library, which dropped support for older Rubies. If it's a development dependency, do you really need to change the supported Ruby versions for your gem? You shouldn't need to run Rubocop for every version in your Travis matrix. But even if you wanted to, you could run Rubocop as a standalone process (i.e., divorced from "bundle exec").
If you are serious, install Emacs and spend two weeks learning eLisp. After that, you won't need any other editor or IDE for the rest of your life. 
Ive been using vscode with the vscode-ruby extension for the past 3 months or so. I recommend it.
I've tested many and RubyMine is really the best.
I wouldn't necessarily do a major version bump: with one release each year, this means that ultimately you will have one EOL ruby version per year, which would translate each one in a major bump at each minor ruby version change! In my cases, I'll be taking a gradual approach - just a few thought! - Make it clear that using EOLed versions of Ruby is not good in general (in your readme) ; as an ecosystem, it's a good idea to insist on that - Make it clear that you will only support a little bit after EOL time - Why not: leave the door opened for a company to fund support for LTS on an older version (if it's worth it for them), like Rails LTS does, in a way - Also this is a matter of balance: if supporting an older version is not a big pain, then it's easier to do, but if it prevents improvements &amp; significant speed-ups, then it's another story BTW, in the end, it's OSS, so users are not entitled to anything!
Vim is fairly popular in ruby community with a bunch of good plugins, so I‚Äôm not sure if there is any big need to change. Upcase has good intermediate level content that helped me when switching to rails dev and using tmux/vim 
I just want to say: congratulations for your amazing work on Ruby Truffle, Chris. I can't wait to use that. :) Why is Ruby core reinventing the wheel instead of kind of merging your technology? Is there some license issue or something like that?
I've never used an IDE for rails, just Atom or VS Code
Yep, I use RubyMjne with the ideavim plugin and some custom vim config stuff, vagrant, rubymine remote debug, guard and vagrant-fsnotify. Love it!
Maybe I'm weird but I just use sublime text.
&gt; I gotta say, hashie specifically has been painful with backwards compat in the past for me Yes, I feel you. It turns out that managing an infrastructure gem that is a transitive dependency in many projects is hard. &gt; What are the downsides of just calling it a new hashie major version? Not really anything, other than [the angst of incrementing the major version](https://www.reddit.com/r/ruby/comments/7vtceq/when_is_it_okay_to_drop_support_for_ruby_versions/dtvt1j4/). It feels like releasing a major version should have some sort of overarching reason like "we're making the project better" and when you don't have that, it's hard to make the case. &gt; Or wait, did you just say you are gonna refrain from removing ruby support except on a major version? Yes, sorry I wasn't clear! I think I'm leaning toward _not_ dropping support for them. My co-maintainer makes a good point as well [in this tweet](https://twitter.com/dblockdotorg/status/961280960586231812). "Dropping support" can mean different things. To me, if you're not testing against a version, you're not officially supporting that version, but that's not necessarily true. If the gem continues to work, you're still "supporting" it. &gt; If we agree it is, then it is indeed the letter of semver to not do it, not just the spirit, I think? Matthew [made an interesting point](https://www.reddit.com/r/ruby/comments/7vtceq/when_is_it_okay_to_drop_support_for_ruby_versions/dtvmdd0/) that I hadn't noticed before. It appears that the SemVer spec says "don't worry about it," which is interesting.
That's a good point. We should be able to tweak the Travis configuration to run tests, but not linting on older versions. I hadn't thought of that until now, thank you very much!
&gt; as an ecosystem, it's a good idea to insist on that Yes, definitely! I wonder how we could build awareness around this at the ecosystem level? I was hoping that I could pull Ruby version statistics from RubyGems.org [but it turns out that's not easy to do](https://github.com/rubygems/rubygems.org/issues/1335). I don't think I fully understand the technical problems with doing this, but it would be a great resource for gem maintainers. &gt; Make it clear that you will only support a little bit after EOL time I think that writing a policy around this is something we should do. It would be cool if we could have consensus as an ecosystem around when and how version support is ended. Thanks for your input. I appreciate it!
I'm not completely clear on what you're doing since you didn't correctly escape your code blocks, but it *appears* you're using backticks to quote your string so you can then use string interpolation, like this: ``` @coin_price = Cryptocompare::Price.find(`#{@coin.name}`, 'USD') ``` Neither of these things are necessary, and backticks are definitely incorrect and will break things. Backticks run their content *on the command line* and evaluate to the resulting output. The correct quotes to use for regular string interpolation are double quotes, but `"#{@coin.name}"` is still completely unnecessary, this is exactly equivalent to `@coin.name.to_s` which (if `@coin.name` is already a string) is redundant. Odds are you just want to oass `@coin.name` in place of the hard coded string `'BTC'`: ``` @coin_price = Cryptocompare::Price.find(@coin.name, 'USD') ``` 
Because it's unprofessional and, frankly, cringe-worthy. I will never watch this, and I could *never* share this with anybody in my professional circles, even if it was a great tutorial.
Thank you so much I'm so dumb, the first thing I did was what you suggest but i totally forgot to remove the single quotes around the @coin.name. Guess I just needed a second set of eyes. Saved me a bunch of time thank you so much.
Most devs I know don't use an IDE for ruby/rails, they use a fancy text editor like SublimeText, Atom, or even, yup, vim. I don't know if I agree that you should use an IDE. There's pretty much only one IDE for ruby, RubyMine. I've never used it. I use SublimeText. Things I find invaluable include proper syntax highlighting (ruby, html, and css, including erb and scss), the file browser tab on SublimeText, and the command-p jump-to-any file. I don't know if vim/MacVim has similar things or can be set up to have them. 
that seems like a fine solution! 
Is that the only plugin you need to install for VS code to develop Ruby/Rails apps?
`hi.downto(lo)` is implicitly returned (it's the last line in that method). You could try putting `return nil` on the line afterwards.
So you're saying it was a great tutorial. Thanks!
We'll never know, will we?
Sure but note that my views on tooling may be perceived as somewhat weird, e.g. not using a `.gemspec` or `Gemfile` when possible, avoiding bundler when possible, only using `rake` for tooling, being a dissenter here ;), .... First: Why do you want to drop support for these Ruby versions? Just because? Or is there a reason? I'm asking because I maintain kramdown and I dropped support for Ruby 1.8.5 (!) only last September. Why support Ruby 1.8.5? Because someone asked (now a long time ago) to have support for it due to RedHat's upgrade policy. So there was a reason for supporting such an old version. In September I asked whether support for Ruby &lt; 2.0 was still necessary and since no one complained, I dropped support in a minor version. So if the users of your library still need to use it on older Rubies and there is no compelling reason not to support these older Rubies, then support them. With the 2.x series of Ruby this is not such a big hassle. Another thing: Ruby is just a dependency of your gem. You don't have other dependencies (good so!). But would you change the major version if a gem you depend on changed? Probably not. So why make Ruby a special case? As for your questions: * Yes, I normally test my projects with the latest version of Ruby. I.e. I test (or try to test) with all the versions that are officially supported by one of my projects. And if a project supports 2.x, it should also support 2.(x+n) (for n&gt;0) since Ruby follows the standard versioning scheme now (in contrast to 1.8 vs 1.9). * With projects that are still very much in development or haven't yet seen widespread use, I'm a bit more aggressive in terms of requiring the latest version of Ruby. Take HexaPDF as example: It is thoroughly usable and well tested but still in the 0.x range and I only support Ruby 2.4+. Why? Because this version offers some nice features I want to use and there is currently no need for doing the extra work of supporting older versions. So there is a compelling reason for me to constrain the Ruby version. ps. Your [hashie gemspec](https://github.com/intridea/hashie/blob/master/hashie.gemspec) doesn't constrain the Ruby version. You might wanna change this.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [intridea/hashie/.../**hashie.gemspec** (master ‚Üí 49dfb8c)](https://github.com/intridea/hashie/blob/49dfb8c65f57268c69de6255f632d5a7457e9476/hashie.gemspec) ---- 
Maybe I haven't read your post thoroughly enough, but are you sure you need string interpolation in this case? What's stopping you from just doing: @coin_price = Cryptocompare::Price.find(@coin.name, 'USD')
The thing is: If the required Ruby version were specified in the gem itself, you wouldn't get any update on unsupported Ruby versions. So a `gem update hashie` would do nothing and there would be no problems. If you *want* to use newer versions that also need a newer Ruby version, it is the same situation as if the gem itself had a dependency updated to a newer version.
Yeah in the same boat. ST has just been good to me and I work efficiently. One ST plugin I would check out is GitGutter, that one is fantastic. 
+1 for starting with JavaScript if still in high school due to ease of setup as stated above. JavaScript will complement your HTML and CSS too. I also started there and made several interactive quizzes based on other subjects I was studying with HTML/CSS/JavaScript before I tried Ruby out ... after university because my university didn‚Äôt teach it.
The debugger is what sold me. It's saved a ton of time
LOL totally NOT trivial. Building a domain specific language is hard. You‚Äôre giving folks access to an execution environment so security is paramount. 
Make sure to try [robe](https://github.com/dgutov/robe) and [inf-ruby](https://github.com/nonsequitur/inf-ruby) if you go down the path of Emacs ~insanity~ enlightenment.
Congrats on the new position! I think vim/tmux make for an awesome ruby editor. You can read the help docs and go as deep as you want, but to get started a few plugins (like NERDTree) and off you go. Unless you're having issues using vim, I'd say stick with it. We're all very blessed with some amazing text editors to choose from. All of the one's listed here are very capable, the important thing is becoming proficient with whichever editor you choose. Best of luck!
secondly the debugger. i inherited a bunch of code that was terrible written terribly and debugging in a rails view saved by bacon 
&gt; It works! We went to 6.1 seconds from 8.3 seconds seconds just by enabling JIT. I ment this part, but true, later it's changed to suit the JIT better.
This is a very very non-trivial feature. You either need to create a DSL with limited functionality or something like posted by the other users. If you‚Äôre going to contract this out and expect it to work AND be secure, expect this to be astronomically expensive. Or it‚Äôll be dirt cheap and totally insecure.
Here's a few a find useful: [Endwise](https://marketplace.visualstudio.com/items?itemName=kaiwood.endwise) will auto add `end` after do/def/whatever. The author recently said he'll add this to the main vscode-ruby extension so might not need this for much longer. [Rails Run Specs](https://marketplace.visualstudio.com/items?itemName=noku.rails-run-spec-vscode) is handy for running a single spec or a whole file in the integrated terminal. [Rails Go To Spec](https://marketplace.visualstudio.com/items?itemName=sporto.rails-go-to-spec) lets you quickly switch between a file and it's corresponding spec (or create a new spec file if it doesn't exist). [Ruby Around the Block](https://marketplace.visualstudio.com/items?itemName=elliotlarson.ruby-around-the-block) gives you a shortcut to switch between inline and multi-line block styles. 
What kinds of security concerns should I look out for?
Do you have any links to anything that addresses what types of things I should keep in mind when implementing something like this?
Thanks! I've looked around a little and didn't really find anyone that had a list of plugins they're using for Ruby development other than Ruby lol. So I've been sticking with my free trial of rubymine this month or the past months Atom (which I don't like compared to VS Code). When I first started doing MEAN stack stuff I was using Atom so it's been sittinghere while I've been learning Ruby.
Been doing ruby for quite some years, made the switch to Vim about a year ago - and never looking back. You really really do not need an IDE, and the Atom/Sublime/VSCode are really just people who lack the patience to learn vim/emacs. They really don't do anything you can't do in vim. 
Just wanted to stop in and thank you. This helped direct me in the right direction and I was able to get through the exercise.
Rubocop is a linter that plugs in to Vim, I highly recommend it. Other that that, it sounds like you've got the stuffs you need. Congratulations on your first dev job! If you want a bigger IDE, others have recommended RubyMine and I second that emotion.
You basically have two options: 1. Build a DSL, the more secure option 2. Look into `eval()` and especially how to make it more [secure](http://nts.strzibny.name/safe-code-evaluation-in-ruby-with-safe/)
Auth0 has a product like this called "Extend": https://auth0.com/extend/ It provides a way for your end-customers to write their own integration code that is run against your platform. It's designed to be secure out of the box and creates many great extensibility options for your customers.
I'm sorry you feel that way. Cheers.
For my gems, I setup travis to test against only the officially supported versions of ruby and then use rvm (or chruby) to set my development version to the oldest one (so that I don't start sneaking new ruby features into my code). I don't usually restrict the required version unless there is a very good reason to do so since most things will continue to work. As such, I usually just do a minor version bump. When I drop support for an older version, really all I'm doing is stating that I am less likely to try and fix bugs in older ruby versions. I don't normally prevent users of old ruby versions from using it.
Vim + a mini-fridge full of Redbull. 
Nice username! Is HAARP really an icbm defence system, or does it brainwash the people with ELF?
But (as a beginning programmer) they have cooler sounding names lol. I think i will try Atom out because i liked a screenshot i saw of the colors and crap.
No mini-fridge... Better be full size!
Only if you qualify as an 'individual user'. Licensing terms and costs for companies are different, starting at $199 per year for a single RubyMine license.
Didn't consider that. Oops. 
&gt; One of the features I'd like to put in is allowing people to be able to write custom code for my RoR and have it ran to further extend my app beyond just some basics that I would give them. This can be a lot of work. Just make sure it's a feature that your users want before you build it üòâ. &gt; I'm using Salesforce.com's APEX/VisualForce as an example as it's really the only thing I can think of. JavaScript is popular for embedding. Ruby has [therubyracer](https://github.com/cowboyd/therubyracer) which makes (some level) of interoperability easy. NetSuite, Photoshop, Google Sheets are some products that use JavaScript for this. If you use JRuby, there's some chance that you can use a JVM language. MuleSoft ESB (written in Java), allows one to write extensions in Ruby or Groovy. Not sure what the difficulty level is here or what issues may arise. In addition to Lua, there's [GNU Guile](https://www.gnu.org/software/guile/), which historically has used Scheme but also supports JavaScript. &gt; had any tutorials or anything like that on how to go about implementing something like this that would be great. Depends on your requirements but something that comes to mind is running your client's Ruby code in a jailed/[chroot'd](https://en.wikipedia.org/wiki/Chroot) env with your libs included in the process load path. 
Shopify, which is a rails shop, did something like this with [Shopify Scripts](https://help.shopify.com/api/tutorials/shopify-scripts). They ran a bug bounty when they rolled this out and [spent almost 600k just on those](https://hackerone.com/shopify-scripts). IIRC some of that work is available as open source, but you're definitely looking at a major project that requires a lot of domain knowledge in things like seccomp. I would definitely try to avoid having to build something like this during the initial phase of your project. Maybe you can get away with defining some APIs on your end, and running the user-provided code on something like AWS Lambda? That said, maybe you're working in a business where it's not unusual for each of your clients to have their own (or at least an isolated) hosting environment running your software. In that case, you could think about designing your app as a [Rails Engine](http://guides.rubyonrails.org/engines.html). 
FWIW (and despite my above argument that a ruby version change does not require a major bump), it looks like Rails is going to settle in to a policy of bumping the minimum ruby for our major releases, and bumping it to the oldest version still receiving full (bugfixes, not security-only) support at the time. Looking back, that's pretty much what we've already been doing in practice. We're not ruling out the possibility of a future bump on a minor, but as we do have some cadence to majors already, it's generally not so critical: we're not putting it off forever awaiting a major-worthy change, nor are we releasing a new major just because of that change. As a policy, it's somewhat strict, but that's because our own back-branch support policies then keep the decision alive for a few more years: we still provide [security only] support for Rails 4.2 on Ruby 1.9 today... and we'll likely still be [again, security] supporting about-to-be-released Rails 5.2 on about-to-be-EOLed Ruby 2.2 through something like late 2021*, when even Ruby 2.5 will be EOL. * Total guess, inferred from historical data only, forward-looking statements may be closer than they appear, please no-one try to hold me to that.
I‚Äôd look into liquid and work with your users to determine what tags they‚Äôd need. Also, get a team together. Lastly, what is the business case for this?
Sure.. but the failure-to-save will be in the form of an error at bundle time, not some unpredictable misbehaviour -- and they can fix it by upgrading bundler, whose latest versions still ~~work on~~ behave the same on all rubies back to 1.8. I can see an angle by which the "public API" argument could apply to the versions of *all* the dependencies, tbh. But to me, it's not about the definition, but the purpose: your library's version number, especially under semver, is a coarse signalling mechanism to your user's package manager of whether the new release is likely to Just Work if installed in place of the old one. Why swing that hammer when the package format supplies a more precise instrument? Better to reserve the version bump for "you'll need to at least *check* your code", otherwise it loses its signalling value. 
Thank you for this. There are Rails APIs beyond the scaffolding. 
No: #ip Check write and read. #ls Check that ssh.run_command is called with the correct args #run_command Assert that it's calling the layer below it with the correct args.
Disagree with testing the accessor. On the one hand, you've ensured that nobody will suddenly handroll their own accessor method without breaking the build. On the other hand, you've wasted your time defending against an insane hypothetical. The appropriate time to add those tests is if someone were to change the accessors - right now, any beginner Ruby programmer can reason about exactly how #ip and #ip= are going to work because that functionality comes built-in to Ruby. (I suspect this'll be controversial just on the grounds of advocating for *not* writing a test). Think of your program like a hypothesis, with your tests as experiments to show that your hypothesis is met - you'd be better off testing (against your mock in unit tests) that you're using your SSH dependency correctly, and then writing integration and blackbox tests to ensure your program does what you want it to when dependencies aren't stubbed out.
Not sure what your business case is and if it's compatible, but consider just providing an API with webhooks support and letting your user access it "from their own servers" (it's 2018, so you could just push them towards Google Cloud Functions or AWS Lambdas, which are perfect for integration stuff like this.) Building a good API isn't trivial, either, but at least this way you're eliminating most of the big security and performance hurdles supporting in-app scripting would cause.
Well its not that safe probably, thats why I added the small word &gt; more
The reason mruby was created was for embedding Ruby code inside a C program. Think Lua for instance. So mruby is suitable more for enhancing C programs than building just with Ruby. That way you can program in mruby and have a binary in the end.
Ok, so the function verses return 99 and I am using puts on that. If I get rid of the last puts it doesn't output 99. Does that sound correct? BTW thank you for the answer.
All of them. If I was a potential customer and I learned that you‚Äôd built this as a feature, I‚Äôd probably cross your product off my shortlist. The security concerns of doing this are broad and pervasive and no individual has the resources to address them. 
**If I were**
Won't that mapping for inferring "class to name" lead into segmentation faults if the garbage collector (one hopeful day) compacts memory and relocates objects (and assuming that not all classes are required upfront)? Super cool project!
üíØ For what it's worth, you may want to start thinking about methods in terms of their **side effects** vs. **return values**. Usually, you're after one or the other (though of course there are exceptions), and it may help you reason about your program if you choose verbs for your side-effect methods and nouns for your return-value methods. For instance, given the method names `#song` and `#verses`, I'd expect them to give me back (return) some lyrics, but actually, both actually spit them out to STDOUT. If it were me, I'd rename them `#sing_song` and `#sing_verses`, or change them to return a string instead.
Whenever you get stuck like this I would recommend creating a Stack Overflow question with a detailed description of what you're trying to do, what's going wrong, and what you've tried to do so far to get past the problems. That way you can get potentially instant help for free. Plus, this isn't the last time you'll ever get stuck. Knowing how to get help effectively (without paying for it every time) is part of the skill of programming.
I do see your point; I also still see mine. :) I think I need to explore more the new-ish feature in bundler that prevents installing a gem that is declared not to work with certain ruby versions. I have kind of ignored it since it came into existence, I ought to be using it, and perhaps if I understood through experience how it worked I'd see your side better. In fact, I don't think I've even had my gemspecs declare what versions they work with, I didn't really realize that was an important thing (and would still work with old versions of bundler? Maybe I was avoiding it to support old versions). I've been so burned by backwards incompat in ruby gems (I've been working with gems that I think are _particularly_ egregious at this, even beyond the already fast-and-loose norms of the ruby ecosystem), that I've become kind of religious about trying to avoid it. There's also perhaps some reason to want to keep supporting people who are, for whatever reason, stuck on old versions (of ruby or really other major dependencies too), with bugfixes and new features, instead of abandoning them. Once the main stream of development of your gem has left them behind, it's hard to backport things -- but if you make it a major version bump, I think it is somewhat easier to keep track of backports if someone (at any future point) wanted to backport things to the old major version. For a project that follows semver (not rails), backports to the last major version are expected as a possible thing, backports to the last minor version not really expected. It would be confusing to have to track backports to potentially both previous major minor version. 
AFAIK MRI's GC doesn't compact today.
Great post - I'm thankful for Mike for sharing his experience setting this up! Another option (which I'm using for my upcoming [Kiba Pro](https://github.com/thbar/kiba/wiki#kiba-pro) offer), if you do not want to manage a running server, is to use solutions like [PackageCloud](https://packagecloud.io). I can push a gem version directly to there, then each registered client will have their own credential to bundle install.
Do you need to use Ruby? It would be a very cool project for a little Arduino chip with WiFi, you could get a ESP8266 and let it send http updates to your Rails backend.
I‚Äôve used the wiring gem to control the gpio pins on a raspberry pi. Perhaps you could go down that route?
I'm looking at Fluval's Reef LED wireless reef lights, and I am open to suggestions for other equipment. I'd love to be able to use this dashboard on a windows tablet and it would show the temperature of the display tank and sump, lighting scenarios etc. 
Ruby is my strongest language as of now. I could attempt going that route.
I don't have one currently. I could put together a screenshot gallery soon.
Perhaps, I'm exploring all of my options. I am looking at creating a "smart" mirror using raspberry pi that will sync with my iPhone and show the weather, notifications etc.
I would argue that your tests are insufficient on the sole premise that you have a required `ip` keyword argument in your initializer method, and then proceed to do absolutely nothing with it. When you run that `ls` method, ip is going to be nil, because you never set its value.
You can try [Dependable](http://dependable.webflow.io) - it automatically keeps your gems up date. (http://dependable.webflow.io)
Right on mate! That's kind of what I was trying to figure out, if the things have an API that I can piggy back off of. I think this will be a successful project that I am going to dub "ReefWare."
I found [The Well Grounded Rubyist](https://www.manning.com/books/the-well-grounded-rubyist-third-edition?a_aid=defmethod&amp;a_bid=b2a9cb7e) to be pretty helpful when I was just getting started! There's a new edition coming out written by [Joe Leo](https://www.linkedin.com/in/jleo3/), who founded [Def Method](https://www.defmethod.com) in NYC. Check it out! 
Bad bot.
Thank you in0pinatus for voting on Subjunctive\_\_Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Do you need Rails? Oh these hipsters in this sub...
Avdi Grimm posted this method a while back http://www.virtuouscode.com/2013/06/24/rubytapas-freebie-xmpfilter/
It was just a question and a recommendation. I have had so much fun playing with electronics the last couple of weeks, so I just wanted to pass my recommendation on. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Static Site with Jekyll](https://www.reddit.com/r/webdev/comments/7w8u0r/static_site_with_jekyll/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you baronobeefdips for voting on TotesMessenger. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Use middleman... it‚Äôs a better choice for static sites that aren‚Äôt blogs. 
That second one is really good, and I missed it the first time, thanks!
Hello, I haven't really used GraphQL in production but I've tried it in a small project. I feel like its advantage is that it can consolidate 2 HTTP requests like "GET apples" and "GET oranges", resulting in just 1 request to the back-end. Am I correct in thinking so? Or is it like the same according to different metrics (time, possibly memory?)
You can use Jekyll for that - there are even some decent templates out there for landing pages. It's not that involved to get a Jekyll site hosted via. aws. I think I pay about $1.02 a month for my Jekyll blog. If you don't want to do a lot of front-end CSS and HTML you can also try something like Squarespace. They have some very good templates and it's something you can get set up in a day. From a business costs perspective, the time it would take me to develop, customize, and deploy a Jekyll static site would cost more in my time than Squarespace's monthly costs for good chunk of time. If the trade-off of time is worth it for you, doing the extra work with Jekyll or something like Middleman is valuable experience!
It was for the book 99bottles and the test they wrote for it determined the names and functions of the methods pretty much. It is sort of like ruby koans. I didn't have much say in the matter unless I changed the test.
&gt; AFAIK MRI's GC doesn't compact today. Hence the "one hopeful day" :) However, github's ruby fork already does, and its work might end up in CRuby. But I wasn't being critical about this approach, just whether a compacting GC could affect it and also whether there could be workarounds. 
You can also host via github pages for free and you can take advantage of their built in jekyll compiler!
If you actually develop and release that, could you give us some sort of scripting language in the interface so we can make complex and nested conditionals? It‚Äôs one of the features I really would have liked in a controller. Also you might want to check out Vertex‚Äôs new controller for UI ideas. 
I agree the custom "expectations" like Anything or ArrayOf are very similar to RSpec matchers, but not for `ArrayWithSize` and `NullableOf` Also `ArrayOf` takes another expectation too You can write `ArrayOf[NullableOf[BooleanValue]]` I have no idea how to write that in built-in matcher though. Which is why I don't support any matcher. 1. Provide an alternate "syntax" to built-in matchers 2. Less code dependency on built-in matchers (and less chance to have unexpected bugs) 3. Less maintenance required (due to RSpec built-in matcher update etc.) 4. Lack of knowledge of built-in matchers from RSpec (for me!) 
If you use [`quickrun.el`,](https://github.com/syohex/emacs-quickrun) you can use `M-x quickrun-eval-print` to evaluate a region and put the result in the buffer as you want.
I just checked the sample kindle version of Learn to Program and the principles they upheld is promising. Especially the principle they teach only one way to do something that‚Äôs completely new to avoid confusion and thus not lower motivation. Very years of iterations to make it a beginner friendly text and also entertaining. Nice! Yeah, you‚Äôre right that Ruby Koans isn‚Äôt great for a beginner. I skimmed through it again and it really isn‚Äôt beginner friendly. I wouldn‚Äôt be able to go through it and get much out of it with 6-12 months of generic high school programming experience.
Well, for me, the very important thing about RSpec matchers is composability. So, when using some "it should be JSON with this and that content" thing, I'd prefer to follow my habits and intuitions on existing matchers, not learning the whole new (and incompatible) matcher library. About some of your particular examples: * `NullableOf` is `any_matcher.or be_nil` * `ArrayWithSize` is `be_an(Array).and have_attributes(size: 5)` * `ArrayOf` is `all (any other matcher)`, including long compositions like `all(be_an(Integer).or(eq 'DUMMY').or(be_nil)` You may argue that those are typically longer than your version, but the important thing is: they are working everywhere. And if you really find yourself to have "this class or nil" an important concept you are using frequently, you can just... RSpec::Matchers.define :be_nullable_of do |cls| match_unless_raises do |actual| expect(actual).to be_a(cls).or be_nil end end And it works everywhere: for single values check, for method arguments matcher, for deep things like `be_a hash_including(some_key: be_nullable_of(array_including(be_nullable_of(String)))` That's the point. Of your explanations, I slightly suspect (4) is the main one :)
Yep for the most part. If you want better code completion though, there is another extension to install: https://marketplace.visualstudio.com/items?itemName=castwide.solargraph
I start with SublimText, so this is my first love ! I'm like home in this IDE haha. But I tried VS code and RubyMine, RM is awesome but expensive and VS code is surrounded by a great active community. For Ruby expert I guess RM doesn't need tones of plugins like others and ready to rock easily :)
Thank you for this info!
I mean that you will (probably) need to write code to translate what's in your database to what's in your graphql API, and that code will be called A LOT so if it's not efficient, your app's speed and memory usage will suffer. One way to handle this is with custom scalar types; but then you need to figure out how to cleanly share the knowledge of how to decode and encode those. None of which is to suggest you shouldn't use it; just be aware that you'll maybe have to make some compromises at some point if you use Ruby for this. 
Sounds amazing. I couldn't find a registration page, though my understanding is that it opened yesterday. Have a link?
There's a link to sign up from the home page. It links to https://ti.to/codeforgood/rubyforgood
Yikes....Thank you! 
Yeah! I was actually going to look at some of the most popular systems that are on the market for the reef hobby, and reverse engineer their API's to be compatible. I want to try to make this as open source as possible, so that it can be added to, and people can create their own modules.
Yes, the idea is that you can send all the data needed within 1 request vs multiple requests. The client can request exactly what it needs instead of receiving data that it has no use for
This will obviously have an initial extra speed performance vs querying for one set of data and displaying something, then querying for another as you have to wait for all the requests to happen and form the data to be passed to the client
Sounds great! I'll definitely check this out.
I'm not worried about theming - I want to build the HTML and CSS bespoke. I was more concerned with config/page management/ folder structure, but it seems like Middleman is a great option for this that I wasn't aware of. 
this doesn't answer your question, but if you hate js but love ruby, try coffeescript.
Thanks, but I already know CoffeeScript and what I dislike in JS is still present with CoffeeScript. Opal looks amazing
Well, there's the framework Volt which uses Opal. Looks incredibly cool. I tried it but didn't manage to get it working, but possibly you'll have more success. I'm just curious though, what it is about JS you dislike so much?
Hi, I'm the author of opal-phaser, opal-pixi, three.rb, and a bunch of other Opal stuff. Opal is honestly absolutely awesome. I learned JS as my first language and learning Ruby afterwards was a breath of fresh air. I assumed that people must only use JS since it's the language of the browser. Then I discovered Opal. Never written more than a few lines of JS since. Yes, my company is using Opal. We have a startup in the works and we're planning on using some of my Opal libraries in it. I have used Opal in several live sites and it's 100% as reliable as any other ["compile to JS"](https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS) solution. In fact, it's more reliable than most of the others. The only thing Opal needs right now is a 1.0 tag, haha (they're currently at 0.11, which downplays its massive reliability). Also, I can honestly say that using Ruby as the language of the browser has *many* benefits. Ruby itself is a great language (coming from someone who knows C, Scheme, Forth, Lisp, JS, C#, Assembly, and some APL). Having it all across your project (i.e., the backend and the frontend) yields a great decrease in the cognitive load from context switching. Which is something our brains aren't great at. In any case, yes, try out Opal in your production project. It's more than ready and it's been used in the real world by lots of other people than myself and my company. It's certainly better than JS and its cousins ;)
Has one of the better interfaces to Github too.
In my company we have jekyll with webpack for a big corporate website, with s3_website to deploy on s3 and the website is served with cloudfront. Works wonders.
Volt is actually great and was really reliable in its time. Unfortunately, the developer had to stop developing it for a while since, in his own words, "it wasn't paying the bills." He's now working on his ["With Arsenal"](https://witharsenal.com/) project. He also recently said that he's coming back to Volt someday... so hopefully it will take the world by storm again.
&gt; what it is about JS you dislike so much? There are many things to dislike. Ugly syntax, murky language concepts, looking like C and acting like anything but (except that its type system is also very... uhm... manipulable). It's basically like [Self](https://en.wikipedia.org/wiki/Self_(programming_language)) but with far worse syntax. Heck, the man who wrote it was forced to write it in just over a week after having his idea of Scheme in the browser scrapped by his overseers. And yes, syntax *does* matter. In the words of Matz: &gt; You want to enjoy life, don't you? If you get your job done quickly and your job is fun, that's good isn't it? That's the purpose of life, partly. Your life is better. &gt; I want to solve problems I meet in the daily life by using computers, so I need to write programs. By using Ruby, I want to concentrate the things I do, not the magical rules of the language, like starting with public void something something something to say, "print hello world." I just want to say, "print this!" I don't want all the surrounding magic keywords. I just want to concentrate on the task. That's the basic idea. So I have tried to make Ruby code concise and succinct. 
for me, comparing coffeescript and ruby, the only thing i think ruby is better at is its standard library, and it's OOP stuff like classes/modules. For everything else coffeescript is just as terse if not more. 
This made it to HN [front page](https://news.ycombinator.com/item?id=16340126)
CS isn't *bad.* Although, I tend to agree with /u/Doc_CoBrA in that I dislike what JS is present in CS. It feels like CS is trying to mimic Ruby, but won't go the whole way. I don't see the point in that when you *can* go the whole way via Opal.
I get where you're coming from but coffeescript isn't just a ruby imitation. Javascript does have a better system of anonymous functions than Ruby and Coffeescript preserves that. Furthermore, Coffeescript has many syntactic sugars that ruby lacks, such as comma-less hashes and array comprehensions.
This is great help, thank you! I was able to refactor based off your advice.
I had thought about it, but I decided to iterate over each element of the DOM instead!
nice! and this is available for vs code, etc. 
&gt; Here at Skylight, we love all things open source It seems like they love all /other/ things open source. Skylight seems proprietary and non-open.
Damn capitalists, making money from the time and effort they put into building things.
Thank you for your feedback, it is really useful! I totally agree with you about the "brain switching" thing. Especially when the core concepts of the language differ. Plus, I am in love with Ruby, the community around it is powerful, it is elegant and pleasant to work with.
Thanks for the tips. I'll look into fixing it.
Actually there is a issue about just that: https://github.com/pawurb/lazyme/issues/1 . Looks like those variables are not accessible from Ruby process. Tips on how we could resolve it are welcome.
Unwinding some spaghetti that has accrued in cucumber test setups. 
Um... you know who‚Äôs behind Skylight right? I‚Äôm certain that you‚Äôve benefited from their many incredible open source efforts. http://www.tilde.io/about-us/
Effective and easily maintainable mocking and stubbing.
Testing things printed to the command line. For example, if I were to print a character to the command line and the text were colored, how would I test to make sure the text was colored correctly?
What /u/y3rsh said. Gemsets are *key* to being able to reproduce build environments, whether you use RVM or rbenv (which I've preferred for years). RSpec and Minitest both have ways for you to run a single test (Minitest through plugins); you'll find those insanely useful. The main takeaways ought to be * automate everything you can (Rake is useful here); and * be able to repeat anything on a whim, because necessity is whimsical.
Testing external services. Do I use external mocks and cover every potential return request, or do I cover the happy path and focus on only my business logic inside the app?
&gt; opal-pixi Is this still up-to-date? I've used Pixi.js, but I'm new to Ruby. Perhaps this is a dumb question, but is there any documentation on how to use it with Ruby syntax? 
If you are looking for a super fast Ruby web server gem check out Agoo. It's on rubygems.org. Related but very young is the WABuR framework.
Unfortunately, I haven't had the time to work on it for a while. It should work with older Pixi versions, but for newer ones I can't say. For documentation, the best thing that we have is [`opal-pixi-examples`.](https://github.com/ktec/opal-pixi-examples) I know it's not quite documentation, but I've found that learning by example is just as good or better in some cases.
In addition to what /u/nieuweyork said, it's also more expensive on the developer side. Reasoning about how to efficiently load data to generate responses, how to effectively limit the amount of data per request so you don't blow request timeouts, these are all a lot harder with GraphQL. REST's model is closer to one-size-fits-all, which makes a lot of those things significantly easier to get right. An API that can deliver just the data you want, but can't do it efficiently, isn't exactly helpful. I feel like a lot of the surface discussion of GraphQL ignores this side of the issue.
It's awesome to see ruby being used for UI development. Building off of pre-existing C/C++ toolkits however does make extending the toolkit a bit harder (to a lot harder in some cases). Anyone have any favorite GUI toolkits which are more focused on implementing as much as possible on the ruby side of things? I know there are a few out there like shoes, but there hasn't been much adoption (from what I've seen). My own take on the mostly Ruby GUI challenge has been through the [mruby-zest](https://github.com/mruby-zest) framework which currently is used by the [zyn-fusion](http://zynaddsubfx.sf.net) synthesizer.
Clearly hashes are slower than sorting an array for this sized input. To explain why you'd have to dig into the source code of MRI, but it doesn't particularly surprise me. Does it surprise you? The fact that you've written the algorithmic complexities next to the different algorithms makes me think you do and that you think the complexity tells you that. That's not how algorithmic complexity works. You can't look at the algorithmic complexity of two algorithms and say one will actually be faster than the other based on that. First of all, these algorithmic complexities deliberately ignore constant factors. The constant factors could be very significant. Second an algorithmic complexity like that doesn't take into account anything about how processors and software actually work. For example, how do you know what algorithm MRI is using in that sort operation? What if it's using bubble sort? And what about the effect of an array likely fitting into cache but the hash table likely being fragmented so not fitting into cache? Finally, use `benchmark/ips` rather than `benchmark` - it is more statistically rigorous.
It would be interesting to compare with https://github.com/ioquatix/mapping
Thanks, appreciate the explanation. 
The hashing algorithm for Hash takes considerably more time than a simple comparison. Also (1..1000).to_a is already sorted, making sorting faster.
And the same array is used on each benchmark iteration, so even it wasn't sorted the first time it would be for all the other iterations. Why is sorting an already sorted array faster, in case you or anyone else didn't know? You don't need to write anything - you just read, compare, and don't see any need to swap. Writing takes extra time.
&gt; CS isn't bad. Debatable: https://donatstudios.com/CoffeeScript-Madness
&gt; Javascript does have a better system of anonymous functions than Ruby What makes JS's anonymous functions better?
a few things. - the syntax is simpler, don't need to distinguish blocks/procs/lambas like in ruby - context binding via arrow functions - built-in async utils like then/catch and await In ruby most things are done synchronously so a lot of this stuff doesn't come up as much.
* Syntactically JS has at least 3 different ways to define a function, so it's on par with Ruby. Semantically procs (= blocks) and lambdas differ (`return`), so do arrow functions and `function` in JS (`this`). Seems about equally confusing to me. * Do you mean arrow functions are closures? If so, Ruby's procs and lambdas are closures as well. (closure = function + scope) * `async` is an orthogonal concept to anonymous functions, isn't it?
The input size is very small and Big-O notation doesn't necessarily play a big role. If you increase the input size the hash solution always takes the same amount of time while the runtime of the sorting solution will increase linearly with the input size (probably because sorting an already sorted list takes O(n)? Not sure which sorting algorithm MRI uses.)
Using a Gemfile IS the best way, but if you really don't want to, try require_relative instead of require
I know of several companies using the [Clearwater framework](https://github.com/clearwater-rb/clearwater) (runs on top of Opal) in production. - [Groupon](https://groupon.com): Real-time admin-facing order dashboard for one of their child companies. They ported over to it when their React+Backbone app could no longer keep up with the volume of data pouring in over the WebSocket. - [ArkivDigital](https://www.arkivdigital.net): Their entire product (behind a paywall) is a single-page Ruby app. - [Seven Sigma](http://www.seven-sigma.com): I don't remember what they use it for, but they've come to the [Clearwater Gitter channel](https://gitter.im/clearwater-rb/clearwater) to chat more about it. - [Krav Maga Worldwide](https://www.kravmaga.com): The instructor search is a Ruby app running in your browser If you're curious about running front-end Ruby stuff for anything from simple click counters to full-on SPAs, drop into the [Clearwater Gitter channel](https://gitter.im/clearwater-rb/clearwater) and we can chat about [Elm/Redux-style app state management](https://github.com/clearwater-rb/grand_central), [time-travel debugging](https://github.com/clearwater-rb/grand_central-dev_tools), [hot-loading code as you work in development](https://github.com/clearwater-rb/clearwater-hot_loader), [Ruby bindings for browser APIs](https://github.com/clearwater-rb/bowser), [talking over WebSockets](https://github.com/clearwater-rb/power_strip), [a JSBin-like app](https://clearwater-rb-playground.herokuapp.com) and a whole bunch of other projects that are fun to use without hurting your productivity later.
Hmm, I guess you're right. I forgot/didn't realize procs and lambdas had closure for the value of `self`. Still, the main outstanding difference remaining is that in in JS all funnctions are called the same way (exluding `apply` annd stuff). In JS `()` is used for all functions, anonymous or not, while in Ruby there's a different syntax for calling procs/lambdas (`.call` or `[]` or `.()`). I tend to feel a little less timid about making higher-order functions JS because of this. Also, to be fair, I am mainly a coffeescript user so that"s really what I'm thinking of, since the syntax is so terse: ``` nested = -&gt; -&gt; -&gt; -&gt; 1 ``` Granted it's not so differnent from ruby's lambda, except for the braces, and the uniform call signature I mentioned above.
That's an awesome comparison - yeah the transforms are explicit for performance reasons, but even then I'm not sure if performance is *THAT* good given that it's generating intermediate data structures. Did you ever consider stuff like http://json-schema.org ?
Setting up. To do a system test I need to set up rspec, capybara, faker, fabricator, add scripts to log the user in, install web driver successfully etc. I don‚Äôt do these often and it‚Äôs always a learning curve, always something new for the latest version of everything. I‚Äôd pay for a gem or a script to set most of these for me. 
To be frank 12ms is kind of slow (e.g. comparing to a compiled language). However, if it's fast enough, that's okay. I don't think the mapping gem is that fast either - it was designed to create an intermediate data structure which can then be fed to the client depending on the value of the `Accept:` header. Generating a large intermediate data structure is a killer. The best solution is to walk over the data structure and serialise directly to the output stream. Generating intermediate strings, data structures, etc all serves to increase latency, memory requirements, etc. For small amounts of data, programmer happiness is probably worth optimising for, but for some APIs you do need performance.
`require './path_to_folder'` This is the first place you're going wrong. You don't `require` a **directory**, you `require` a **file** (minus the `.rb` extension). Typically, the file you need is `&lt;gem_name&gt;/lib/&lt;gem_name&gt;.rb`. But if you look inside that file, you'll find that it requires all the other files that the gem consists of (see my blog post on [how to build a gem](https://ryanlue.com/posts/2017-02-18-how-to-publish-a-gem#everything-under-one-roof)). These require calls probably don't use `require_relative` or the `require './&lt;path&gt;'` syntax, so it's going to fail because the gem's `lib/` directory isn't on your `$LOAD_PATH`. So the naive solution would be to add it to your `$LOAD_PATH` and then require as normal: $LOAD_PATH.unshift('&lt;path_to_gem's_lib_directory&gt;') require '&lt;gem_name&gt;' But a better way would be to [use Bundler](http://bundler.io/v1.12/git.html): # Gemfile gem '&lt;gem_name&gt;', github: 'user/repo' and then when building/debugging/running your program, prefix every command with `bundle exec`.
It does fee up time, but in the long run, if you are using a massive app it could be a problem.
So what is left? Noko and OpenSSL is done. May be the only missing piece is install from RVM? I cant wait to see benchmarks of Truffle Ruby with SubstrateVM running the discourse benchmark.
Hello, Redditors, I'm excited to share that I'm writing an ebook about building GraphQL powered applications in Ruby On Rails. Please drop your email to receive regular updates on the book progress. I'll also share early drafts and chapters to get feedback from the people interested. Thanks, 
&gt; if you are using a massive app it could be a problem What sort of problems have you seen with Heroku + 'massive apps'? 
In addition to other answers: consider, also, that you're sorting an ordered array [(1..n).to_a) which will be O(n).
I intend to. The JSONAPI adapter was written all in one day (not long before I posted this, actually) and definitely needs some love internally. I mostly wrote it in response to a [discussion on Netflix‚Äôs `fast_jsonapi` gem](https://github.com/Netflix/fast_jsonapi/pull/42), where they said they‚Äôd prefer to keep with the JSONAPI spec.
To clarify, Primalize itself was not written that quickly and is based heavily on a pattern I put into production two years ago.
Yeah. I think the big thing right now is testing and community interaction and resolving some issues that are found by folks. Not this as I think it's a good example and even encompasses what you're saying: https://github.com/oracle/truffleruby/issues/1054 As far as RVM et al go [we have to kinda wait for Oracle legal dept I guess](https://github.com/oracle/truffleruby/issues/1062#issuecomment-363372972)...
Looks interesting! Just a note: &gt; Handling data creation &amp; updation "Updation" is not a word. Maybe just say something like "Handling data CRUD"?
From how it looks, I'd say it is not a "port", but an "imitation" (following Clojure's, not Ruby's, intuition and idioms). Nice exercise, but probably not really practical. 
Well, I am only passively familiar with CoffeeScript, so there you go. Another reason to use Opal, in my opinion ;)
Thanks for providing specifics, Jamie! I'm sure it helps people to see that Opal's not vaporware!
How the thing works: In "main" you can call or text your friends just as skype or icq. when you are in the app, you need to put informations in your profile about (age, gender, location, first language, second language, knowledge of). "notifications" is where you receive notifications ! it's a message. "people" is the list of all that are online Lets say have a question about nebuchadnezzar. You go to "people", use the filter and select "knowledge of history" after applying the filter, you find 32 000 matching people out of 500 000 online. you send a notification to them, they will receive the notification and will reply to you, also by notification or by instant message or by calling. From the 32 000 , there will be like 15 that know the subject very well. last step: call them and enjoy your instant answer ! 
This look pretty cool. pinging /u/mperham 
This is the second subreddit you've posted this in. This is not on topic for this sub unless you've already got ruby code working.
are you 15?
Great screenshot, looks lovely.
Late, so I'll take a proper look tomorrow, but at a glance (so apologies if I've misunderstood!) I love the way you can make multi-word message names and have the words split across arguments. Really makes the code look a lot more readable, and I'd bet that it would increase mental retention of library message names. Awesome idea!
I love Smalltalk-style method parameterization. I wish more languages did it like that.
Link to code and a description of the issue?
Hey, Thanks for pointing out the flaw in the content copy. I took a note of this and will update the content. Cheers :)
I have to create a "login" screen. Like put in username and password. That info has to match what is written in a file to gain access to next step in the program. This is what I got: f = File.new("users.txt", "a+") #Creating a file for passwords class Create def proceed @creating = Array.new end def createUser puts "Select desired username" niels=gets.chomp if File.read("users.txt").include?(niels) puts "Desired username is already in use. Please choose a new username" niels=gets.chomp @creating.push(niels) else @creating.push(niels) end puts "Please chose a desired password" pass=gets.chomp @creating.push(pass) end def addAccount File.open("users.txt", "a+") do | f | #saves files account to file f.puts @creating.to_s #write in the file end end end f.close Somehow when I try to run the code, there is no errors, however it puts nothing in the cmd when I run it. I am terrible at ruby and it surely is a noob mistake, but I just cant seem to identify it..
The file is just a plain text file. Think about how you want to format the usernames and passwords within the file. Then write some ‚Äúload existing usernames and passwords into a Hash‚Äù code instead of trying to compare a username directly with the file.
Can I manually write something within the file to make a user "log on"? Cause right now I have no idea on how to do it otherwise then 
I just want my program to say "Welcome, press 1 to log in" and then I can actually do that instead of the cmd returning nothing... 
&gt; Really makes the code look a lot more readable It makes it *look more like English*, but only at significant cost to its readability, as it's far, far harder to parse out what's a method/function call, what's a parameter, etc.
The benchmark was done on aws micro instance, which is inconsistent by definition and is bursting on occasions. I'm not saying this is 100% reason for it, but nobody runs a benchmark on a micro instance for this reason..
Awesome; thank you. 
@bascht Intriguing and addresses a lot of timely concerns with OOP in Ruby, and in general. I would really like it if you'd make a linked page detailing each of the benefits mentioned at the top of the intro: &gt; - Separation of identity and data (but not data and behavior) - Immutability and persistent data structures - Isolation of Side-Effects - Pattern matching
We'll see. At the moment there is no high activity around Ruby version. May be later it will be adapted more to Ruby idioms. I liked the parsing examples I got recently in my feeds and tried to implement them in Ruby and was positively amused.
no i'm in my twenties
Thanks :)
which type of instance would you recommend? i myself was sceptical so I ran benchmarks multiple times in different order and got same result each time
Thanks :) People have forgotten the idea of messaging and think of classes and inheritance first when hearing "OO"
Sorry :( The Try Out Page is a little overwhelmed right now :D But you can try it out locally, it's explained on the start page :)
&gt; `# Isn't sum(numbers_array) an array? ` No, the sum of an array of numbers is one number. &gt; there is no way for me to print that sum(numbers_array) value to my screen But you have this already - `p sum(numbers_array)`.
why don't you learn to code so you can create this app yourself?
Thank you. Also, inside the method body. Is there a way for me to see what is the value of that sum(numbers_array)?
why is it named Halunke? the translation doesn‚Äôt suggest anything nice. 
Would this still be called a recursive method? Also, the .tail method doesn't seem to work on my computer. I assume .last or numbers_array[-1] would be the same?
Halunke is German and means scoundrel. But that's probably not a good translation, because Halunke is a word that is only very rarely used in German nowadays. It would be something your grandma or grandpa would say when you did something naughty as a kid :) I also really like the sound of the word :) So it doesn't have a deep meaning to be honest ;)
&gt; Is there a way for me to see what is the value of that sum(numbers_array)? Yeah - `p sum(rest)`. Or if you are using your old technique of modifying the array then you need to do something like next_sum = sum(numbers_array) p next_sum return number + next_sum So that you don't run `sum` twice, where it was modifying your array.
My question is, why Ruby? I love Ruby, but the language is already very slow. If you went with a compiled variant like Crystal instead you'd see a huge performance increase.
fair enough. thought it was something downright rude. scoundrel is cute. :)
Thank you! this helped.
How about "scamp" as a translation?
Here's a sneak peek of /r/crystal_programming using the [top posts](https://np.reddit.com/r/crystal_programming/top/?sort=top&amp;t=year) of the year! \#1: [Crystal 0.24.1 is released](https://github.com/crystal-lang/crystal/releases/tag/v0.24.1) | [3 comments](https://np.reddit.com/r/crystal_programming/comments/7lvu8s/crystal_0241_is_released/) \#2: [Crystal 0.23 released!](https://github.com/crystal-lang/crystal/releases/tag/0.23.0) | [0 comments](https://np.reddit.com/r/crystal_programming/comments/6katow/crystal_023_released/) \#3: [We created the Crystal language, ask us anything!](https://dev.to/crystal-lang/we-created-the-crystal-language-ask-us-anything) | [34 comments](https://np.reddit.com/r/crystal_programming/comments/6yh5d8/we_created_the_crystal_language_ask_us_anything/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Node isn‚Äôt optimized for multithreaded processing out of the box, I suspect that there is a lot of extra overhead involved with each thread slowing things down.
In the PR about [isolating side effects](https://github.com/moonglum/halunke/issues/4) one of the rules is: &gt; Only a Schlawiner is allowed to send messages to another Schlawiners. Will this be statically checked? If so: How? Simply by disallowing it in the grammar? Btw. the word "Schlawiner" for side effects fits ridiculously well. Please keep it! ^^
This looks kind of like what you might get if you added Pony and Ruby... very interesting.
Call me old fashioned, but I would use a physical computer in my office.
That was what I was thinking: Simply scan for occurrences of *schlawiners* and @atoms :D I think this should work. Hehe :D Side Effects are the worst Schlawiners.
Thanks :) I'll keep it in mind if someone asks for a translation :)
E.X.A.C.T.L.Y. :D
I'm a native German speaker ‚Äì I'm not sure which English translation would be the most fitting :)
It is written in Ruby, because it is the language I'm most proficient in :) It is not the right language for a language implementation, because it requires people to have Ruby running (apart from being slow). But it was the right choice for me to get the prototype done within a weekend :) Crystal is definitely on the list of choices for a "real implementation" :) But I'll keep prototyping for a bit in Ruby, to find out if everything works well together.
if only i had a clean OS installed... I ran it on my macbook and the results were literally random
Right, it is pretty exciting to see this coming together and yes, I completely agree that installation is the real crux right now. I wish /u/chrisgseaton had an easier row to ho with these guys.
I don't like the pattern of using a class method to invoke the service -- it seems that this is designed to avoid ever using an instance of the service, which I'm guessing is because of the stated "one API method" per service rule. I agree an API for a service should be limited, but it would seem more straightforward to return true/false for `call`, and use another method to retrieve an error code in the event the service is not successful. Seems like this approach trades the simplicity of one API method for complexity in what it returns -- every service in an app only publicly responds to `call`, but can return who knows what. Does that make it simpler?
[Volt](voltframework.com). It's been in a little hiatus thanks to the developer having some [amazing success](https://www.kickstarter.com/projects/2092430307/arsenal-the-intelligent-camera-assistant-0/) in another startup, but it's not forgotten or dead. From what I'm understanding it's going to be back to full development status soon.
While I believe you got help solving your exact issue, it is worth exploring other possible solutions to your problem. In general recursion is not recommended for most problems since you are limited by Ruby's stack: the amount of function calls you can nest inside each other is comparatively small and finite. Luckily in your case 'reduce' is the perfect function that you can use that is native to Enumerable (checkout https://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-reduce). In fact you'll find that throughout your ruby experience reduce will be used quite regularly when dealing with arrays (arrays include the Enumerable class).
I just added a video for this tutorial as well.
We tried it that way for the first year or so that we wrote service objects in Ruby (at the time, Rails) apps, and quickly moved away from it. We find result objects (with a `#success?` flag method and others) helpful in ensuring that there is no mutable state hanging around between service invocations. You wind up with something like the following (though the original code this represents is structured slightly differently): module AcmeBlog module UseCases # Encapsulates domain logic to summarise aggregate article content. class SummariseContent DEFAULT_LIMIT = 10 def self.call(container:, current_user:, count_limit: DEFAULT_LIMIT) repository = container.resolve('repositories.articles') new(current_user, repository, count_limit).call end def call Result.new result_hash end protected def initialize(current_user, repository, count_limit) @current_user = current_user @repository = repository @count_limit = count_limit @articles = nil @errors = [] end private attr_reader :current_user, :errors, :repository, :count_limit def articles @articles ||= repository.articles(count_limit: count_limit) end # .... methods that access the repository elided... def result_hash { errors: errors, articles: articles, keywords_by_frequency: keywords_by_frequency, # ... } end # Report results of SummariseContent action (success, errors, etc.) class Result &lt; Dry::Struct::Value attribute :errors, Types::Strict::Array.member(Types::Strict::Hash) # :articles is not a Strict Array, since it can be an enumerator attribute :articles, Types::Array attribute :keywords_by_frequency, Types::Strict::Hash def success? errors.empty? end def failure? !success? end def to_hash super.merge(success?: success?) end end # class AcmeBlog::UseCases::SummariseContent::Result end # class AcmeBlog::UseCases::SummariseContent end end Straightforward to test and to work with. As long as one is familiar with the underlying tools (primarily [dry-rb](http://dry-rb.org/)) and the (typical) Repository interface that was written against (which has since been replaced by `Hanami::Model`), you're good to go. And since we use(d) those tools pervasively, anyone with access to our private repos *should* have that understanding. 
[Hyperloop](http://ruby-hyperloop.org/) - it's the closest thing to meteor and it is actively maintained. Reach out to the [gitter room](https://gitter.im/ruby-hyperloop/chat) for more info.
This is how smalltalk and ObjC work. 
I like this approach a lot. You are always returning a result_hash, which provides flexibility to interact with the result state, as opposed to returning an atomic value (i.e., a symbol) with no way to interact with the service after being invoked. Encourages single purpose for the service object as well. Thank you for sharing.
I was really excited about Volt back in the day. The last commit was 2 years ago. Volt predated ActionCable in Rails, and I feel that ActionCable may very well make Volt not that relevant anymore. You can do all the stuff that was uniquely available to Volt in Rails, with full support of all the databases that Rails can use. Volt, currently, only supports MongoDB.
1. `wrk` might have started all the threads, but it would probably perform better using a single thread (there‚Äôs only 1 CPU as it is, I doubt the micro CPU has more than 1 core or runs more than one thread at a time). 2. Thread per client using a thread pool will limit the overhead (as well as concurrent requests). Both `iodine` (Ruby) and `nginx` work wonderfully on a single thread (unless running blocking / slow applications, where a they work better by enabling their thread pool features). 3. Does EM close the connection? (I didn‚Äôt see that it does)... Does node.js? (Not that I can tell) .... your benchmarks might be unequal.
[Action Cable](http://edgeguides.rubyonrails.org/action_cable_overview.html) is part of Rails. But you might be able to use that gem on its own. In fact there is [this part of the docs](http://edgeguides.rubyonrails.org/action_cable_overview.html#running-standalone-cable-servers), that talks about running a standalone Cable server.
Still relevant and offers a different methodology compared to Rails. Also, as far DB support, [there's PGSQL](https://github.com/voltrb/volt-sql).
Unless I‚Äôm reading things wrong, it looks like the demo is running 100 threads in the node example, which would mean 100 different node apps all competing for processing time, without the benefit of a shared thread and all of the optimization that comes with a single app running. I wasn‚Äôt aware of the native C code in ruby event-machine, but honestly, ruby doesn‚Äôt suffer from the same performance costs that it did several years ago, it doesn‚Äôt surprise me to see better performance in some aspects 
Try running through the code yourself as if you were the computer, with an array of two or three elements. Or better yet, start with an array of one element. 
yeah you're right, thread pool must improve things significantly and wrk did influence benchmark after all: i was running it on the same machine as the servers and they all were competing for resources, which yielded incomprehensible results
Thanks for sharing. I have a couple of questions about this approach, which I will admit are pointed by my own opinions: 1. Why are `repository` and `count_limit` required by the constructor? What if I want to instantiate the class in an automated test, and I don't care to specify a repository or count limit? It seems like a default value would yield a better user experience. 2. I often do not need a return value at all for command objects, because only an exception could stop the operation from succeeding. In most other cases, a true/false value would suffice. However, when I'm writing web controllers, I often also need a list of errors in order to convey mistakes to the end user. Do you ever find value in returning result objects from commands outside the context of web request/response cycles? It seems like coupling to result objects would be undesirable unless absolutely necessary.
I played with Halunke and got some (very, very basic) web "framework" running. Something in the sense of Sinatra. Would be nice to work on that: https://github.com/railsbros-dirk/tausendsassa
The [Volt framework](https://github.com/voltrb/volt) is in much the same vein as Meteor. It even had some things that Meteor didn't, I think. Unfortunately, it hasn't been developed for a while since, in the developer's words, "it wasn't paying the bills." Hopefully it will come back again someday or someone else will take up the torch of maintainership.
when you are in the app, you need to put informations in your profile about (age, gender, location, first language, second language, knowledge of). "notifications" is where you receive notifications ! it's a message. "people" is the list of all that are online Lets say have a question about nebuchadnezzar. You go to "people", use the filter and select "knowledge of history" after applying the filter, you find 32 000 matching people out of 500 000 online. you send a notification to 100 of them, they will receive the notification and will reply to you, also by notification or by instant message or by calling. From the 100 people , there will be like: 60 don't know nebuchadnezzar. 10 know nebuchadnezzar somehow. 10 know him well. 10 know nebuchadnezzar quite well. 10 known nebuchadnezzar very well. last step: call them and enjoy your instant answer ! 
Unless I'm mistaken this spam was already spammed to this particular subreddit and deleted. I guess that means that the OP has gotten stuck in a loop.
Because world obviously NEEDS one more "5 lazy links from this very Reddit to get attention to our commercial we site" digest, right? 
Eh, I mean, I hear what you are saying. But I'm not going to get excited again until I see a year or more of consistent work on it.
Not Ruby but Phoenix is a fantastic framework for web sockets and pub sub. Elixir looks like Ruby but you‚Äôre still going to have to learn a new platform üòï
Have you ever considered writing this up in a series of blog posts? 
Thanks! Looking forward for any feedback
Thanks a lot for all the interesting comments. I will try to incorporate your tips into how I work with service objects.
I know! I‚Äôm giving you another word to consider / ask other people about. 
Can't include brackets in YouTube descriptions... :imap &lt;C-b&gt; &lt;Space&gt;{\|x\| }&lt;esc&gt;i
I was actually going to mention that. This is definitely a nice looking language, it'll be interesting to see where it goes.
Our infrastructure code is all Python. I did some simple, very narrowly-scoped OO stuff with it earlier no problem: pull from DB with select statements, write to file. An example I'm having to work with is extending Python's napalm to work with a lot of old network devices we have, and I am both overwhelmed and not motivated. 
My issue with python is white space mattering
Yeah. I especially hate how it comes into play when commenting blocks. 
Decorators are just "sugary" as compared to writing and using closures long hand every time. I don't think they're any less DRY than blocks, which is the closest equivalent I can think of (I might be misremembering the exact mechanics of decorators though, it's been a while since I've used them). Hope that the Python-ing gets easier. 
I have a blog post about this, kinda https://www.schneems.com/2017/10/17/i-know-how-to-code-i-can-code-in-anything/
Thanks for replying: 1. The `repository` is where articles are pulled from; my comment reading "methods that access the repository elided" replaces ~60 lines of methods that populate `result` fields (that you'll notice are also elided). I agree it's harder to understand without those true guts of the service, but I was trying to keep it shorter since Reddit; 2. We use this pattern *all the time,* including for services not inextricably tied to the Web. This was developed as an intermediate step away from Rails and the pure crack that is ActiveModel, particularly `ActiveModel::Errors`. We're starting to trust exceptions more, now that we're (mostly) working on apps that didn't originate in Rails and so able to fully ignore its conventions. We've not yet had problems that we can point to `Result` object coupling as even a contributing cause for, but I can see the possibility. **tl;dr** the service pulls articles out of a repository and does trivial analysis on them so, yeah, you kind of do need the repository; and exceptions *can* give you far richer, more flexible semantics, while motivating you to maximise test coverage. Thanks again!
Agreed! Thanks for the amazingly readable explanation.
Made the same switch... I'm with ya. At least with ruby, there's always the fallback of "it's an object". Python... Not so much. The rules don't hold up intuitively like ruby. That being said, chef is still quite common in certain devops shops... Python's a good pickup for the job, but don't forget ruby!
I just wish it was *more* strict. For example I'd want the following to be a parse error: if foo: bar baz While either of these should be valid: if foo: bar baz Or... if foo: bar baz Python code tends to include a lot of long procedures. I think it would visually break things up a bit but more importantly stop me from wondering if something was supposed to be nested or not and they forgot to indent.
I can't help, I'm afraid. I'm forced to use Python for Informatics training (this is a hobby, not a job) and it's forever frustrating. There are a few things I like, but... I wish Ruby had Python's list/sequence comprehensions. It's worth getting used to them. But yeah, not having map, select etc. as reasonable options (i.e. Method chaining) is a real pain.
I was in the same boat as you are and had to learn python at my current job after coming from a ruby shop. I‚Äôve consistently been writing it for a few months now and can honestly say it it definitely gets easier but still slightly frustrating at times. The way you manipulate objects is a little awkward compared to ruby, but you can still apply the same logic to get the job done. Map, reduce, select, reject, and collect all exist in python but not immediately obvious as methods for those objects. The confusing thing about python is figuring out which function is called via the dot method and which is called by wrapping your object. List and dict comprehensions ironically are less comprehensive when you read them compared to ruby and get to near Perl like mind fuckery as they get more complex. One liners begin to feel like pissing contests sacrificing readability for cleverness and it‚Äôs usually better to avoid them altogether. In the end, you have to adapt to your environment and use the right tool for the job. Don‚Äôt limit yourself to one language even if it feels like you are crawling instead of running. 
Give it time. You‚Äôll get use to it. A lot of people are saying map doesn‚Äôt exist in python. It does along with a lot of other powerful builtins. Also, white space errors should be easy to fix. You‚Äôll need a text editor that inserts spaces instead of tabs. I‚Äôm surprised to see so many people complaining about that here. I probably haven‚Äôt seen that error in over a year. 
Yeah. I think I should go back to a Chef/RoR/devops role. One of the better jobs I had in my previous lives.
That could be a way of getting around that. The popular vim plugins, etc I've worked with really force you into a particular way of coding and if you deviate from it you're going to have a bad time. Definitely something to be said about making time for your environment which I haven't quite had. 
Checkout pycharm for python development. Community version is free. Best IDE for python. It even shows you code that doesn‚Äôt conform to PEP8 and is extremely helpful in many ways. Today I wrote ‚Äòif not item in items‚Äô and it warned me the convention in python is actually ‚Äòif item not in items‚Äô. It will also suggest ‚Äòif 0 &lt;= x &lt; 10‚Äô instead of writing ‚Äòif x &gt;= 0 and x &lt; 10‚Äô to reduce code. I no longer write python without it even though I‚Äôm a huge vim user. 
Have you considered passing callback functions to the service objects instead of reading from a result data structure? I usually write something like `ServiceObject.new(repository: repository).run(first_arg, second_arg, success_callback, failure_callback)` with lambdas defined in the caller context. 
Lovely explanation and great effect.
[this](http://metalelf0.github.io/rails/2016/05/02/command-pattern.html) is a short writeup on the subject. It's not taken from a real app so it's a little too simple but it should be enough to get the idea.
I'm a ruby lover, I really think it's one of the best languages and I love the community around it. Had to get into python for a data-science product. Surprisingly i ended up really linking it too. I also love django &amp; rest api framework and even think it's better in some cases... I guess you'll just get used to it, give it some love!
It seem the next ruby version will bring some good performance improvements on the whole...
I like the explicitness and forced simplicity of python. It made me a better programmer when I first learned it. You kind of just have to do things differently. I have the same complaints though! List comprehensions are needlessly incomprehensible compared to functional operations in other languages. I can never remember what is a global function and what is a method. (I read an article on why it is like this, and I disagreed.) All the special underscore naming crap feels very legacy.
Yep. I have done both professionally and personally, both have their strengths and weaknesses.
Granted, I have no real experience with this, but wouldn‚Äôt dueling garbage collectors in a Go extension to Ruby be a *really* hard problem?
Yes, this is what I think. Let's see if we can get some feedback from someone who actually tried it.
Wouldn't you just apply two filters to the given collection of possible birthdays, one for day, one for month? Is there something more significant here? Is this a multi-processing problem and I'm missing the 'why' of it?
Also, no experience, but wouldn't the garbage collectors only apply to their own respective runtimes and not in fact be dueling at all?
The Python object model is not the same as Ruby or PHP. The day you get the object model and undersand Objects work like interfaces kindof you will love it! All operators can basically have a custom implementation, so you can do some random class like Vector and add two instances with + or multiply them with * etc. This is why some functions are not glued to the instance. its super powerfull when done right. importing stuff is also a good thing. You dont want random stuff in global scope (like PHP does)
I'd love more of these type of videos. It's interesting to hear another developer work through trade offs in code. I know for myself, I wouldn't have put that constant under private without `private_constant` as it's misleading, even if private is really just a suggestion in Ruby anyway (`#send` vs. `#public_send`, etc). I would be really interested to see how basecamp organizes more of their business rules, authorization, etc. I feel like DHH is middleman adverse, which goes against what most Ruby bloggers seem to be writing about the last half decade or so. Part of the reason I suspect is that Rails is his framework. He has less of a need to wrap dependencies to protect himself from change as he is the final say on changes anyway.
I get so excited for his blog posts. It's at a level that pushes me out of my comfort zone and I also get to drop a `tenderlovemaking.com` link into the group chat with project managers. 
I have done both. I prefer ruby, but I didn't get "disgusted" by python. I found some things that I liked in Python as well. I remember that configuring my editor to deal with both Python and Ruby was a bit of a pain, but it was worth it.
Dude, I'm in the exact same boat; rubyist writing python for devops role. You've hit the nail on the goddamned head :) I feel like I write python begrudgingly every time, haha. I'm constantly having the feeling "this would be so much cleaner, nicer, easier to read in ruby". But it's a Python shop; and for whatever reason all of the python folks look down on Ruby? Not sure why. About list comprehensions: I've found just avoiding it and writing a for loop is much more legible and "pythonic". Trying to achieve ruby's map/select/reduce in python just doesn't work that well. I had written a library to reproduce the functionality but my coworkers weren't thrilled with it, haha. I do admit I was just trying to make python more like ruby. I do actually like python's import system more than Ruby's (You get to decide the scope of how 'heavy' the import is), but actually trying to get things to import in a sane way is much harder. Gemfiles are so much better than requirements.txt. Dat global scope; ugh. Yeah I totally get the PHP feeling of that, haha. The crazy thing to me is that len(x) is just calling x.__len__() behind the scenes... the "magic" methods could just be "actual" methods and less global scope pollution. At the end of the day though, it's a job. Python on its own isn't that bad, I've just been really spoiled by Ruby. I think Python is more common "in the wild" so, it's a bit of an uphill battle. So, I don't have much good advice than that. 
Thanks for the reply! Yes, I did know that there were preexisting gems doing the same. I mainly wanted to gain more experience and force myself to follow TDD. 
If you have a Ruby object off to a piece of Go code, that objects lifetime inside Go needs to be accounted for in Ruby GC (i.e. don‚Äôt let Ruby delete objects that only Go is using). But, *Go* lifetimes are *also* managed by a GC, so informing Ruby when Go is done with an object seems a lot harder, and likely manual, which makes it easier to leak memory. 
Quite rarely in general, especially for RoR. Even rarely in the mature RoR project. I'd say sometimes in non RoR code, like tools, service scripts, etc. Rather often in writing own gems, e.g. building a custom API wrapper.
Yeah... about Gemfiles being better than requirements.txt: practically everything in Python that has a ruby equivalent just looks completely half-baked and limited. Case in point: ActiveRecord vs sqlalchemy/alembic.
Very extensively. One of the recent ruby projects that I worked on involved translating from QML (without the javascript) into ruby objects. There was plenty of instance_eval() in that process.
&gt;Python's preferred list comprehension is incomprehensible coming from select/map/inject/reduce/etc. *hugs* I am here with you. You are not alone.
I'm not sure how one decides what kind of ruby programming is "metaprogramming" and what kind isn't. 
I think Ruby/Rust is definitely the way to go, and I think that in the future we're going to see a lot more of that as opposed to future projects developing a Ruby/C system. But that's just my opinion. 
I mean if you even just require something innocent like `fileutils` from the standard library, you're actually running quite a lot of complex metaprogramming to build that module. https://github.com/ruby/ruby/blob/01a656c3fb1dd5fe8d3401880a2219221b252313/lib/fileutils.rb#L1576-L1580 'Anything' was of course hyperbole, but many standard libraries for basic things that aren't otherwise very 'meta' and you would have thought would be pure Ruby are actually running quite a lot of metaprogramming.
Ah, I gotcha, thanks for the example. I think there's some weird stuff in stdlib that could probably be beneficially written differently. But "metaprogramming" is certainly still "pure Ruby". 
Not using it directly but reading the source code to figure out what the heck was going. The gem was RSpec. It's a clusterfuck of metaprogramming.
Completed Part 2, building an application top-down testing! Excited to get some use out of the bisect flag and learning more uses for meta-tags. Appreciate any feedback.
To avoid repetition: def cleanup %w[foo bar baz].each do |name| puts "Cleaning #{name}" SomeNamespace.const_get(name.capitalize).clean_up end end Though my friend, who is not a fan of this sort of stuff, summed it up very well: &gt; The goal is to make maintainable code, not most compressed as possible Or (sometimes) in lieu of a case statement when defining a factory method. Basically dynamic constant lookup. Creating DSLs: * https://github.com/sshaw/class2 * https://github.com/sshaw/yymmdd * https://github.com/sshaw/optout 
Props to Shopify for this. If they could get rid of Neo Nazi‚Äôs on their platform they would be one of my favorite Ruby shops. 
Shoplift has a Neo Nazi problem? (Sincerely curious, a guy I know works there and I‚Äôve thought about joining his team a couple of times)
I think he meant neo nazis using Shopify not working there. The team seems really cool.
I understood that. If they‚Äôre happy with users running hate-speech related shops it would still impact my perception of them as an employer I was interested in associating with, personally. 
Breitbart Store runs on Shopify
Presumably if they keep allowing Neo Nazis who violate their AUP on their platform, then they have a Neo Nazi sympathizer problem somewhere in upper management. I cant imagine any other explanation.
&gt; without me being aware or have a chance to review it. They know perfectly fucking well: https://techcrunch.com/2017/02/09/shopify-ceo-attempts-to-defend-continued-hosting-of-breitbarts-online-store/
Limit the scope of your tasks to a certain number of records. Scale your jobs to many workers that have limits on the queries and persist the processed_at datetime.
I really don't like to get into politics, but I don't think you're being fair claiming there is likely a Neo Nazi in upper management. I don't know anything about them, but they did wrote about it, and if you read this I think it's obvious it's not as simple as someone at shopify is a Nazi. https://medium.com/@tobi/in-support-of-free-speech-275d62670203
&gt; My point is that kicking people off your platform for being the wrong shade of grey They have an AUP. They've made an exception for these neo-nazis. &gt; unless there‚Äôs clearly hateful, racist products being sold Stormfront is a brand of hate. If they had a store selling Stormfront branded merch, that merch itself would be hateful. Breitbart's brand is hate. By selling Breitbart merch, they're selling hateful items. Breitbart is the voice for neo-nazi's, which they've said time and time again. The people who work there, the people who run it. When someone tells me they're a neo-nazi, I believe them. I appreciate a healthy amount of skepticism, but your brand of "whataboutism" is completely inappropriate in this situation. It took you under an hour from finding out about this issue to posting a half page defense of Shopify? I've been on this train for OVER A YEAR. I've talked with Tobi about it directly both in public and private. I've spoken to a half dozen Shopify employees from literally all around the world. This isn't some random here-say thing I came up with. I've done my homework. You're welcome to your own, but I encourage you to dig a little deeper and ask a few more questions before jumping to conclusions. 
Call me crazy, but I‚Äôm fine with ‚Äúguilt by association‚Äù when it comes to deciding whether or not I want to work some place? I don‚Äôt require iron clad proof when I read glassdoor posts either ‚Äî it‚Äôs my career, if there‚Äôs a whiff of something off about a place, I‚Äôm fine with taking it elsewhere. No shortage of demand. 
&gt; The team seems really cool. I know a lot of people there and will confirm that many of them are amazing. They have some of the best minds in the Ruby world working for them too. 
&gt; Black lives matter incited hate crimes on both side liar.
The provision in their aup (https://www.shopify.com/legal/aup) says: &gt; Hateful Content: You may not offer goods or services, or post or upload Materials, that condone or promote violence against people based on race, ethnicity, color, national origin, religion, age, gender, sexual orientation, disability, medical condition or veteran status. Is Breitbart selling something that meet this condition? 
Their brand is hate. I talked a bit more about it on this thread https://www.reddit.com/r/ruby/comments/7xde6c/the_500_000_version_of_mruby_how_shopify_spent/du7uk8o/
Making money from neo-nazis is a form of free speech. - Toby (paraphrased) The thing is, people get riled up and the next day everybody is off hating on another new thing. What, did Shopify get boycotted? Stock doubled since the outrage happened. Nothing matters anymore. 
So the lesson is never try?
This guy is calling conservative news sources Nazi‚Äôs 
Nice try but you can‚Äôt just call newspapers you don‚Äôt like Nazi‚Äôs. What do you call Fox News?
Not sure how to respond to this. Are you being serious? Did you read my other replies on this page? What makes you think that Breitbart is not who they claim to be? 
I‚Äôm pretty sure that they never claimed to be Nazi‚Äôs 
And, well, forbes https://www.forbes.com/sites/janetwburns/2017/10/06/breitbart-emails-trace-neo-nazi-moves-of-steve-bannon-milo-yiannopoulos-report/
It‚Äôs a contributor blog post to Forbes. Notice how the article doesn‚Äôt cite any actual ‚Äúnazi‚Äù statements from Breitbart. All it does is reference cheap attempts at a smear campaign from buzzfeed ultra liberal Bernstein 
They wrote that article in 2013. You might be too young to remember or just willfully ignorant but alt-right is short for alternative right. Traditionally the term might anyone sort of right wing group that objected to social conservatism. This mainly included libertarians, anarcho-capitalists and all sorts of basket-cases. It wasn‚Äôt till the summer of 2016 that Hillary Clinton and the deplorable comment that the media swarmed on the alt-right and sort of redefined as a short hand for neo-nazi. Source: someone who has been involved in conservative politics and media for 30 years.
Just a disclaimer, I'm a Canadian who has lived in Canada all his life, so I didn't vote in the election obviously. Shopify is also Canadian. Could you please take your politics to another thread? 
This is precisely what I meant about the sensitivity of censoring, period. A contrived objection to illustrate a point gets me a personal character assassinating insult.
I was going to argue with you that alt right could mean many things. However those things seem to be fascists, nazis, and white supremacists so TIL Alt Right is the same as Neo Nazis.
It wasn‚Äôt for nothing. You read it. Have a pleasant night.
interesting that you make this comment on a site that allows alt right reddit‚Äôs to exist, but that doesn‚Äôt seem to deter anyone from using reddit. 
It's quite rare though I had to implement arbitrary forms with schema stored in database multiple times so I've created classes derived from ActiveModel in runtime.
Can we please not bring politics into /r/ruby? Also free speech is super important and I applaud Shopify for their policies (I come from a post-communist country and what I see in U.S. these days in terms of policing people-i-dont-agree-with kind of scares me).
I see some value in this gem (currying), but I think that overriding built in `#method` method is not a good idea.
Can you point me to which product on Breitbarts online stire violates this AUP from Shopify: &gt; You may not offer goods or services, or post or upload Materials, that condone or promote violence against people based on race, ethnicity, color, national origin, religion, age, gender, sexual orientation, disability, medical condition or veteran status The way I‚Äôm reading it, you‚Äôre conflating hateful media content with a product line that is at best alarmist and provocative. I‚Äôm no fan of Breitbart either, but planetofthemapes is right from my view. Unless you can point to a product that is explicitly hateful it‚Äôs difficult to regard the year of research you‚Äôve invested into this as amounting to much more than hyperbole. Suppression of speech is a slippery slope and while I think we all agree the world would be better off without Breitbart, it deeply concerns me that otherwise progressive minds are so quick to turn to totalitarian methods. Like the problems we deal with in our day-to-day, is the problem of hate in our world not better solved by addressing the root cause?
I agree with that. Our last project involved a lot of pain in overriding / avoiding #object, as that was also a field in a legacy DB
I do it now and then, most commonly to create an ActiveRecord macro, or some small DSL. (For example, a class method that defines an instance method.) Granted, it is better to solve the problem in an OO way first. Not everything needs to be a DSL or a macro. In ActiveRecord, I am just usually doing the same very specific things: normalizing and transforming data before it is saved to the database.
What a load of shit. Keep your bullshit political views out of here. 
False
You can‚Äôt make a true thing false by saying the word ‚Äúfalse‚Äù. They‚Äôve done both of these things, and much more. Go learn how to google. 
It‚Äôs not shorthand when people are walking around saying ‚Äúheil‚Äù, giving the Nazi salute, and calling for an ethno state. The term you‚Äôre looking for is Neo Nazi. It might have been a catch all phrase at one point but it was co-opted to mean a very specific group. Part of the people who did that work was Breitbart. If you don‚Äôt like it, do something to police your own people and work to turn the name around.
Hey genius they call **themselves** home for the alt right. 
And your point is? Alt right != nazi
You are afraid of a bogeyman. You are trying to group a few thousand bigots in with about 170 million conservative Americans. If any group needs policing it‚Äôs the left and their unabashedly violent rhetoric of the new antifa.
Yes it does 
The emails are tame and are far from the smoking gun you think it is. You can goto Breitbart.com right now and find me the nazi rhetoric 
Fascism does not know national boundaries. It needs to be confronted where it stands, not only where it is convenient.
And this is why Donald Trump won
Serious: Why use mruby when you could have containers like sandboxing and completely isolating your environment for you?
same stories from my father and grandfather on Germany in 39. We are not evil, free speech. etc. Same.
Why isn't the `&amp;method(:blah)` idiom more widely used now? If you are shy of using that idiom, would a different way of writing it change your mind?
Surprised my comment got so much engagement. It‚Äôs a shame when a companies‚Äô poor choices overshadow the good they‚Äôve done. Mruby is pretty cool, though most people have the wrong idea about its use cases. They think ‚Äúlike ruby but smaller‚Äù which is not always true. I‚Äôve seen mruby running the same code take up more RAM than MRI. A better comparison is ‚Äúlike lua, but Ruby syntax‚Äù. Its strength is it‚Äôs ability to be embedded. 
When did Breitbart go around carrying swastika flags and yelling ‚Äúblood and soil‚Äù? You seem to be confusing actual neo-Nazi‚Äôs with a large right leaning publication 
I really think the mods need to step in here. This is an obvious case of brigading from far-left wing activists 
Oh cmon, being against the alt-right is not being "far left wing activists" it's just being a person that understand what's tolerable bullshit and what's not.
No, see my comments above I addressed the issue you pretty clearly. They said they were the home of alternative right media. Aka libertarians, anarcho-capitalists, neo-reactionaries, etc. 
Allowing conservative media to sell hats and tshirts is almost certainly ‚Äútolerable bullshit‚Äù Not allowing that is fascist, that irony is of course lost on you though 
They don‚Äôt want you to work there 
If you really wanna hide behind the "we're just conservative media" argument, then I think the one who's lost is you buddy. But meh, I guess all discussions with fanatics end the same. In just a waste of time and reason. Hope you find comfort with your downvotes.
Oh right, I got confused. The people who were marching were not "alternative right", they were just a group of people who separate from the right, belong in an unnamed floating political space. My bad.
**Protected group** A protected group or protected class is a group of people qualified for special protection by a law, policy, or similar authority. In the United States, the term is frequently used in connection with employees and employment. Where discrimination on the basis of protected group status is concerned, a single act of discrimination may be based on membership in more than one protected group. For example, discrimination based on antisemitism may relate to religion, national origin, or both; discrimination against a pregnant woman might be based on sex, marital status, or both. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
If you didn‚Äôt notice, you‚Äôre the one not talking about Ruby in this thread. If you don‚Äôt like the topic, start a new one. Like my comment below about the merits of mruby. 
You only did after being called out for 12+ hours of political babel. Get out of this sub you partisan hack 
You‚Äôve gone from ‚ÄúRegulating hate speech by a company speech is a slippery slop‚Äù to ‚Äúmods ban this speech that I disagree with‚Äù. The irony is of course lost on you though. 
Downvoting this off topic comment (not ‚Äúyou‚Äù) makes it less visible in a thread dedicated to a topic. I understand that activism is important to you and you are trying to bring awareness to an issue. That issue is not the topic. 
The first four links are just links to *other* Ruby news digests üòÇ
I just learned about it through some recent `yield_self` examples and have been using it a little bit in some scripts. I personally dislike how there is a separation between the class and methods in some examples. For example, in `&amp;MyClass.method(:methodname)`, I dislike how detached `:methodname` is. In particular, not only is it separated by `.method()` from it's object, half of the expression is an actual class constant, where the method in question is a symbol arg. I wish it was all of one or the other: `&amp;:"MyClass.methodname"`, `&amp;:(obj.methodname)`, `&amp;MyClass.method` etc. 
How to mock using minitest
`pipenv` and `Pipfile`
What do you mean? Everything in Python is an object.
Yes, the global scope thing is a bit inconsistent, but convenient. Same with the casing of builtin types. And yes, you should import things explicitly. Autoloading can be evil. Did you come from Rails? Have you ever tried to do a decent module hierarchy in Rails, or was it all flat? I can't remember where some conflicting names, some from gems, came from, or how they resolve, but I can for Python because it's explicit. Stop grumbling about it and try and understand the rationale, and the limitations whence you came. Advantages are obvious if you're used to them. And was it plain `irb` or `pry`? IPython can be decently interactive if you are familiar with its reimplementation of `readline` line editing. The only thing I miss from `pry` is auto-paging.
Blocks can be more general, but decorators can often be more readable. And decorators don't have to decorate functions. They can add attributes to functions, register the function or class with something, etc. Try doing the last with a block. But you can't call that context manager twice like you can with blocks, nor pass it around.
Not the way they are in Ruby... the idiom of using unbound functions on objects to perform behavior that should be on the object - and is in Ruby - defeats the purpose of everything being an object. For instance: array = [] # valid in either lang len(array) #python array.size # ruby Now, if 'array' were a first-class object, it should IMHO be able to report its own size without some unbounded function. Ditto for converting to a string: i = 12345 str(i) # python i.to_s # ruby So Ruby treats its objects like first-class citizens, while Python forces objects to use helper methods... not really an OOP paradigm.
docker does not protect you the way you seem to believe it does.
Are they going to be able to compete with Graal though? Maybe this is a stopgap step but it seems like ultimately once Graal hits the JDK there doesn't appear to be a reason not to focus on pushing for it as the primary runtime. And as a bonus, you get the Java ecosystem + all the really nice Java GC algorithms.
Please explain
Would those change how you use it, though? Like, have you ever typed out that idiom, then switched to an equivalent explicit block even though the block was longer?
Matz has said that he is not willing to use a 3rd party JIT because it would tie Ruby to another project. What if at some point in the future that project decides to change directions, or just drops support completely. So the official JIT for Ruby needs to be something developed in house. And I agree with him. 
Sorry. Not strictly true, nor does it matter in practice. `i.__str__()` and `i.__len__()`. It is kind of helpful for use cases that require polymorphism. For example, do you want to `map(int.__str__, someForeignList)` or do you want to `map(str, someForeignList)`. Yes, they're legacy, but their importance is overstated in practice. Conversely, mapping some foreign object's method onto a collection of another is a bit awkward in Ruby. `myList.map foreigner.method(:whatever)`‚Ä¶ ugh.
Well, it's pretty new for me still (about a month?) As such, I still choose to use it because I am now familiar with it, and it feels too damned clever to pass up. On that same note, I work alone with private code and have read that generally people seem to be against this cleverness, since it's not well known and looks a bit clunky compared to slightly longer, but more explicit code. I think if there was a more explicit way to do the trick (as opposed to gluing two neat tricks together: `to_proc` and `obj.method(:lookup)`), maybe people wouldn't be as frowny on it. So, personally, I'm hesitant to use "the trick" in public code, but would be more confident if it had stronger support naturally.
Just to play devils advocate, using ! in a method name is one of the ways Ruby was build for the developer to be able to use an expressive programming dialect. If the community set a convention around it then it should be respected. That being said, I don‚Äôt use it due to the possible imbaguity of what ! _could_ represent. 
Very cool!
Fair enough. Oracle isn't always a great company to deal with so I could understand the hesitation getting in bed with them.
What did you not like about SQLAlchemy?
This. The Java community has recognised for a decade that they need a complete ecosystem independent of Oracle vendor dependencies, but Oracle has such a marketing lock on Big Corporate boardrooms (the funders of Java and source of profits for Oracle) that, no matter how actively and passionately the tech people hate Oracle (and that *cannot*, IME over decades, be overstated), Oracle will continue to have a stranglehold on Java and anything compatible with it. Seen in that light, Matz' attitude is sane and rational. Graal, wondrous though it is, can never be trustworthy technology so long as the vultures of Oracle are circling overhead.
I'm surprised at the suggestion this will be in 2.6. What would be a big enough to move call 3.0 if not this?
Keep in mind that you can and should now use Neovim! Also, you an easily make it look like the default atom https://github.com/joshdick/onedark.vim will give you the colors https://github.com/scrooloose/nerdtree will give you the file tree
I don't "think they think". I've been told so, by a lot of people on this very Reddit, and on Twitter, and my coworkers. I see where you are trying to lead ("syntax does not matter, you just use this idiom or not"), but I think you are wrong. Though I am not sure how either of points could be proven by anything except for thought experiments like "if X they will think Y but when Z everybody will do W".
Ruby versioning makes little sense. Don't make the (easy to do) mistake of thinking they follow Semantic Versioning
I feel like thats poor design... But then again im a Python user so im used to poor design like OOP seems easier/simpler in Ruby than Python.
Lol fucking white space... I started learning C in school, and the syntax is so old and obnoxious to use, but that C class really taught me about how computer languages are built, and how computers use memory. Then using Python was an awesome relief. I applied for a Ruby on Rails internship, while i really like ruby for its ease of use and feel its better in many ways, python is a very useful language that is easy to understand for many people.
If we'll compare 3 possible solutions: 1. No-idiom `urls.map { |u| Faraday.get(u) }` 2. Current `urls.map(&amp;Faraday.method(:get))` 3. One of proposed simplifications: `urls.map(&amp;Faraday.:get)` ...we can see that 1 &amp; 2 are a pretty equal trade: exactly same number of keystrokes, and speaking of cognitive load, 2 is DRY (no variable name repetitions), but at the price of more code objects: `method` method call, separate `get` symbol. That's why the only reason to use (2) is being more "functional" somehow (honestly, I like and use it). But if (3) or something like this would be accepted in language, I believe we'll see a lot of people using it, which eventually should lead to an overall shift to functional style, which is a good thing. But, returning to cause of current thread, I don't think `Faraday.method.get` is any cleaner (in fact, it is vice versa) 
You mean `MyList.map { |v| foreigner.whatever(v) }` ?
Are these interactive animations, or offline rendering? Look at the optcarrot NES emulator, written in Ruby. It has a variety of 'drivers' for output the video from the NES, including GIF files, piping to mplayer, SDL, and SFML. All these drivers allow you to draw whatever pixels you want, so you can adapt them pretty easily. If you want higher-level primitives for drawing lines and things, maybe look at ChunkyPNG.
Reddit hosts all kinds of nazi subreddits.
I think 'released' is a bit of an overstatement since it's not on RubyGems or the Rails website yet. 
offline rendering. I'll give it a look!
Also try ChunkyPNG then. And then use ffmpeg (the command line tool) to convert PNGs into a video (gets around the restriction of 256 colours in GIF and ChunkyPNG includes drawing operations). Let me know if you want your simulation to go faster! I research how to speed up this kind of workload in Ruby.
Thank you! Looks promising, I will look into it
`sequel` is the workhorse for those of us who want an ORM independent of the Rails way. it has migrations of course, and an extensive ecosystem of plugins to boot.
Unless the source is sorted you're basically stuck iterating over the set checking if x is in range and if x passes check y. If y passes the coordinate is added to the result. If either x or y isn't in range skip to the next
I thought that was the case. I sped up process by going through and only checking x and removing what didn't match. Then it's a smaller set to check y. I was trying to implement a merge-sort and then splice out the range, but I'm having some difficulty when sorting an array of arrays.
Interesting article. There was a point about microservices and "Monolith first" that I want to address. From the article: &gt; Now if ‚ÄòPayments‚Äô was its own Microservice we wouldn‚Äôt have this bug at all. The order.pay! part of the code would belong to the Payments Service, which means the two database transactions in the above code snippet would be independent of each other since they would be created by completely different processes running on separate boxes, thus automatically providing the necessary decoupling of the transactions. Beware. If all of these operations require a lock (i.e. a database transaction) in your monolith, they will never be able to be extracted out into separate microservices. If multiple independent microservices could safely coordinate this process without a transaction, then you could also safely remove the transaction from the monolith. In fact, code that depends on a single database transaction to coordinate updates to multiple tables can't _ever_ survive a transition to microservices, because service architectures offer no direct equivalent of SQL transactions. OTOH, there are approaches to coordinating multi-step processes that don't require transactions at all, and they work just as well in a services architecture as in a monolith. I would strongly recommend y'all investigate them if you ever want to implement microservices. I can provide resources if you're interested. Consider the code snippet from the article: def pay! paid = StripePaymentProcessor.charge(this, balance_due) payment_status = paid ? "successful" : "failed" order.payments.create(amount: charge.amount, status: payment_status) paid end Let me pose two questions: 1. What happens when `StripePaymentProcessor.charge` fails, because the HTTP response never arrives (for instance, a network split happens). How do you know if Stripe processed the charge or not? If you _can't_ know whether Stripe processed the charge or not, how do you handle a network error such that the user eventually winds up getting charged once (and only once)? 2. What happens if `order.payments.create` fails after we charged the customer via StripePaymentProcessor? We'd have no local record of the payment, so if we attempted to retry the whole logical operation, we would likely attempt to charge the customer _again_! The first question is really about the complexities of inter process communication, and it's exactly the sort of question you'll start having to ask about your own services if you ever attempt a service architecture. The second is about the notion of _authority_. Stripe is authoritative over who was charged what, since they actually collect money. Your internal records of payments is demonstrably non-authoritative, because it can quite easily become inconsistent with Stripe. A general rule of thumb that will almost universally hold is that business logic should never make use of non-authoritative data. All you'll do is bring pain upon yourself, as the code will appear to work fine as long and even survive rigorous testing, but the moment the production environment or network experiences a hiccup, you will be thrust into extremely difficult debugging sessions and even more complicated data cleanup operations. If you _ever_ want a services architecture, you must be extremely cautious about leveraging database transactions in order to maintain consistency in your monolithic database. If you want to exploit the unique features that monoliths offer, I suppose these transactions can simplify your implementation greatly, at the expense of being effectively impossible to scale after a certain point that you might not reach. Just don't be under the impression that you can ever get to microservices without knowing exactly what service architectures demand of your implementation. An ORM based monolith is extremely dissimilar to microservices. For instance: def checkout! Box.transaction do box.create_order! add_items_to_order raise ActiveRecord::Rollback unless box.order.pay! box.mark_as_paid end end The fact that `checkout!`, the method that kicks off the checkout process is on the `Box` model is an artifact of using an ORM. The fact that we have to jump from the `boxes` table to the `orders` table to charge the customer (i.e. `box.order.pay!`) is another tell; your ORM associations are _exactly_ what you can't bring with you when you build services. Instead, you'll need to introduce boundaries within your monolith. `box.order.pay!` is crossing from the Box model to the Order model -- that means there's no boundary between the two.
Yes. But blocks are not first-class citizens, and there's this weird block/proc split (I do understand very well, but find it just as unsatisfying as the previous posters those find those global functions in Python).
SSL is usually terminated at the web server (e.g. nginx). Search for ‚ÄúHeroku SSL‚Äù. A cursory search of my own showed that SSL is only available for paid dynos. Either way, his should be part of your Heroku config, not the application itself. 
Docker does not in any way completely sandbox your environment, with tremendous effort and attention to detail in both config and usage docker containers can provide a layer of resilience but for the most part it is trivial to escape a docker container given the ability to run code on that container. While the technology and details are different the irrational thought that containers are true sandbox/secure isolation is reminiscent of the same types of ill conceived feeling of security that old school chroot jails had early on in their usage. If you are allowing users to execute untrusted code you effectively are not much better off in a container vs outside of one. https://www.google.com/search?q=escape+docker+container&amp;oq=escape+docker+container https://sysdig.com/blog/7-docker-security-vulnerabilities/ Of note, the kernel is a vast attack surface area and even with a very controlled/tuned docker container/host system reliance on cgroups and namespaces you need to very much understand the weaknesses of the isolation model provided by docker as there ARE weaknesses and isolation is not complete. 
Another way is to use cloudfare and then point to your application.
Thanks! Will try this one too
So the first four links in this "top news" list go to *other* top news lists rather than actual Ruby related news.
If you skip to the next iteration as soon as you check x and it isn't within the range that is about as efficient as you can get since you're only iterating over a set once. You'll likely have an easier time storing your CSV data as a hash instead of an array of arrays if thats a possibility.
FYI: Trying to collect a list of Ruby 3x3 News &amp; Articles @ Planet Ruby, see https://planetruby.github.io/calendar/ruby3x3 Just added "Ruby's New JIT". Cheers. Prost.
Sorting is O(NlogN) while scanning is O(N) - you should scan, not sort. As specified, the most straightforward solution is to scan the array *once* and store the result as an array of references. I'm new to Ruby so I don't know how you do this in Ruby (I'm sure it's quite simple) but in Perl you would simply check the x and y values for each row of the CSV array and you would add a reference to that row in a new array if it is in the given bounds. In pseudo-code: j := 0 csv_array := [ [x0, y0, val0], [x1, y1, val1], [x2, y2, val2] ] csv_array.foreach(i): if(csv_array[i].x &lt; upper_x and csv_array[i].x &gt; lower_x and csv_array[i].y &lt; upper_y and csv_array[i].y &gt; lower_y) result[j] = ref csv_array[i] j+=1 endif endfor For absurdly large datasets (gigascale or more), there are faster approximate methods.
yep I can confirm this, all you need to do is point your DNS to Cloudflare DNS and boom you have free https for life
Bettercap is seriously underrated. With quite minimal Ruby knowledge, you can write this: https://github.com/evilsocket/bettercap-proxy-modules/blob/master/http/rickroll.rb
I used to use a gem for letsencrypt on heroku, but it is now unmaintained and not needed -- because heroku does it for you (I believe even via letsencrypt,although it's "white labeled"), for free. (Well, not a free dyno, but there was no way to get letsencrypt manually to work on a free dyno either). https://blog.heroku.com/announcing-automated-certificate-management 
Chief Programmer Worf would be a great novelty account, you might want to grab it if you haven't already. 
then just write SQL?
rom, mentioned by another user, is excellent for an extensive system because it enforces a good architecture. but sequel is ideal for one off tasks or smaller apps. i use it not only for web apps but also data munging tasks (ETL). 
It's going to be a good year for Ruby
Yep, it‚Äôs as simple as flipping a switch
There's also some pretty nice NETCONF libraries for network device (well, Juniper) config management https://github.com/Juniper/net-netconf
That's what I end up doing. Then again I wonder why I am using sequel at all rather than pg directly.
i agree that the dsl takes a bit of getting used to. but you‚Äôll likely end up reinventing migrations and model validation, at the very least, if you go the direct route. not to mention future proofing yourself by abstracting away database provider specifics.
I don't need model validation if I have constraints in the database.
Good reply thanks. I'm actually hoping to sell the rights to my app to shopify so this may be something I can skip for the time being. and look at using Rails Engine in the furture if I'm unable to coax a deal out of Shopify. 
Agreed, Bettercap is goddam amazing. 
https://gist.github.com/andydna/cc087ae31aa4e2623906779c69d682ee
One way is just to invoke the method: def ask question while true puts question end end ask "What's up?" $ ruby ./my-file.rb or invoke with arguments: def ask question while true puts question end end ask ARGV[0] $ ruby ./my-file.rb "What's up?" 
Thanks for that! Unfortunately, doesn't run still: MacUserComputer:Programs_Chris_Pine z$ ruby ask_chp9_pg68.rb "how are you" MacUserComputer:Programs_Chris_Pine z$ ask "whats up?" -bash: ask: command not found MacUserComputer:Programs_Chris_Pine z$ ruby ./ask_chp9_pg68.rb MacUserComputer:Programs_Chris_Pine z$ ruby ./ask_chp9_pg68.rb "hi you" MacUserComputer:Programs_Chris_Pine z$ 
Thanks for that! Unfortunately, doesn't run still: MacUserComputer:Programs_Chris_Pine z$ ruby ask_chp9_pg68.rb "how are you" MacUserComputer:Programs_Chris_Pine z$ ask "whats up?" -bash: ask: command not found MacUserComputer:Programs_Chris_Pine z$ ruby ./ask_chp9_pg68.rb MacUserComputer:Programs_Chris_Pine z$ ruby ./ask_chp9_pg68.rb "hi you" MacUserComputer:Programs_Chris_Pine z$ 
We wrote Ruby_SMB for Metasploit, but it's also useful in general: https://github.com/rapid7/ruby_smb
&gt; ask ARGV[0] Ah, that actually got it to run, but it won't take arguments yet. But its a step. I must be doing something wrong. 
I think it won't happen sooner than 2019. Let's hope I'm wrong. :)
You can also use Active Record outside of Rails. It supports explicit column type mappings, migrations, and filling your models with a junk drawer of methods you probably didn't want. 
Post your updated script and execution attempts.
I started this a couple of years ago. Welcome any suggestions! http://rubysecurity.info
practice
The *secret*
It's like in the movies. You just have to really want it. I write my best Ruby when grimacing really hard. You know that scene where the hero is in a plane about to crash, and they pull back on the stick, and it's not enough, so they pull back on the stick again but this time *grimace really hard*, and the plane miraculously responds? It's like that. 
Are there snakes on that plane?
that's php
You should add Arachni, a very good vulnerability scanner written in Ruby.
Haven't used pry-remote. Can you share a case where you felt the powers of pry-remote?
Practical Object-Oriented Design in Ruby: An Agile Primer by Sandi Metz taught me all the cool stuff to write dry code and utilize the magic of OOP.
&gt; Arachni Thanks, I'll add it to the list. 
Nice to see. But a number of those projects are pretty much dead, and even some of your links are broken. 
I have the Sandi Metz book and 99bottles. Can someone recommend some other good hands on books for practicing OOP?
&gt; 99bottles Dammit, I just bought POODR, does 99bottles make it irrelevant? Or do they sort of work together?
I had trouble reading poodr so I got 99 and am working on it now. It seems more hands on but it doesn't make poodr irrelevant.
Good to know!
Practice your Ruby and get to know the language very well. You‚Äôll learn methods and idioms that help you writing shorter code, while keeping it clean.
Really has been a great week for ruby devs. Glad to see all the activity (DHH series is great, ruby toolbox back, etc) :)
- https://github.com/rubygems/rubygems.org 
I could be a semi-professional developer but... Maybe it's because the mruby GitHub repository and homepage have always been missing the smallest example? I headed over mruby webpage dozens of times since I started learning about Ruby and every time I had to close it in confusion... - How do I use it? - What do I need to use it? - When do I need it? - ... - oh, thanks for making it look simple with a nice Lego brick pic while just getting me frustrated at the basics, bye And I am sure I'm not alone. 
I could be a semi-professional developer but... Maybe it's because the mruby GitHub repository and homepage have always been missing the smallest example? I headed over mruby webpage dozens of times since I started learning about Ruby and every time I had to close it in confusion... - How do I use it? - What do I need to use it? - When do I need it? - ... - oh, thanks for making it look simple with a nice Lego brick pic while just getting me frustrated at the basics, bye And I am sure I'm not alone. 
Being proficient with the debugger, byebug, pry, gdb, what ever, is one of those things that levels you up as a developer. 
I used Codewars to learn the "rubish" ways (is that the word) for my last job. Now I use Ruby for personal stuff, so I get a little wet now and then but I really enjoyed looking at the community's top voted best practice answers. Even for the most disgustingly simple golf-style one liners I saw some exceedingly Dry and OOPy code written. It was enlightening.
Clearly stating the problem in functional terms.
Wow, the alt reich have made it as far as r/ruby
try pry-byebug https://github.com/deivid-rodriguez/pry-byebug as well
I think so too. It has been a good week for ruby devs, good start for 2018
I read 2020 :/
Great question! Read up on SOLID, specifically SRP and probably encapsulation. Read up on the BDD/TDD cycles to help write code as simple as possible.
There are more or less obvious choices: * use some image processing library (full-featured one, like rmagick or ruby-vips, not chunky-png suggested above)... * ...then save frames of animations as separate images and have some external tools to make a video of them * ...or make an animated gif from them, rmagick is able to work with those; * use some 2D game library (they are not very numerous, but exist, for example long-present Gosu, or a new player named Ruby2D) and go with it for interactive animations. Hope this helps.
How do you get people to assign you project when you're just starting?
I don't think ChunkyPNG is a good first choice for drawing library, comparing to RMagick or ruby-vips.
Just [a few things](https://www.ruby-lang.org/en/downloads/releases/) :trollface: * keyword arguments; * refinements; * better work with encodings; * `%i[]` literal for a list of symbols; * `Module#prepend` * `&amp;.` operator * A lot of nice changes in core classes and standard library (can be backported though). You'll be missing whole geographical epochs, basically.
TDD helps a lot. Red, green, *refactor*. Then refactor some more. Then dream about it and implement those improvements. Then refactor some more. That test suite will have your back.
This looks like what web development should always have been like.
i don't write. no need to clean :P
Having good knowledge of the standard library, especially the `Enumerable` methods, really helped me write more elegant code.
*python, ftfy
1) Start with a turd 2) Polish 3) Repeat
We all know this can't be teach in a single comment. However, just to add a very easy tip: `gem install rubocop` `rubocop -a .` `rubocop .` Rubocop can teach you a lot.
To have access to the file's methods from irb you will need to `load` or `require` the file: irb(main):001:0&gt; load 'myfile.rb' irb(main):002:0&gt; require './myfile.rb' Then you can call the file's methods directly: irb(main):003:0&gt; ask_question 
I liked also Eloquent Ruby
 * Understand what you want to do on a more abstract level. There is quite a bit of code around that shows the author was not clear about his intentions. * Separate aspects and subtasks cleanly into separate programming artifacts (classes, methods).
About usability study guidelines, it's not so much that users don't have valuable things to say, more that listening to what they say is less reliable than observing what they do. Do you want to talk about observations you've made?
[like this?](http://blog.thibaultjanbeyer.com/wp-content/uploads/2016/05/polishing-1.gif)
Awesome, thanks!!! That worked irb(main):001:0&gt; load 'ask_chp9_pg68.rb' ask "how are you?" Please answer "yes" or "no". good Please answer "yes" or "no". no =&gt; true irb(main):002:0&gt; ask "Do you like pizza?" Do you like pizza? yes =&gt; true irb(main):003:0&gt; 
Not OP but you need pry-remote to attach to your server process if you‚Äôre using foreman. Otherwise you‚Äôll never hit your breakpoint. I‚Äôve been using Overmind recently (on mobile don‚Äôt have link handy) which has the ability to attach to any particular service in your Procfile in a different tab. 
Confident Ruby is particularly great.
Maybe redmine
Sequel is a true software masterpiece. While ruby is a beautiful language, for me it's Sequel that keeps me using ruby more than ruby itself. 
Refactoring: Ruby Edition 
Are you saying functional as in "how it should work business-rule-wise", or functional in a "functional programming" sense?
Understanding that focusing on writing DRY code and succinct code feels great but can often make your code a lot less clean (or at least, a lot harder to maintain.)
&gt;What mruby-zest is actually for? mruby-zest was built for the [ZynAddSubFX (aka zyn-fusion) software musical synthesizer](https://web.archive.org/web/20180129131639/http://zynaddsubfx.sourceforge.net/) (waybackmachine link as sourceforge is currently doing some maintenance) and has a few relatively unique characteristics. It: - Is easy to embed with audio plugins (VST/LV2/etc) - Uses code hotloading to speed up the GUI development loop - Uses QML's syntax to concisely express the widget definitions and configurations - Uses vector graphics via [nanovg](https://github.com/memononen/nanovg)/OpenGL to build interfaces which are easy to smoothly resize/rescale which tends to be a problem with existing toolkits for audio applications - Uses external metadata to communicate to the non-GUI code or separate process without repeating information about the data on the remote code - Has the majority of GUI code written in ruby with the remainder being in C for performance &gt; Is it a GUI library written in pure Ruby? Or what? It is a GUI framework with a majority of the code written in ruby (which is excellent when it comes to metaprogramming and the hotloading functionality) and it currently targets applications which need to embed their user interface (e.g. a plugin GUI in a child window of a DAW). Right now documentation is relatively sparse which is part of why I haven't advertised the GUI code a ton, though I'm currently writing a Linux Audio Conference paper to describe mruby-zest and associated modules.
The latter, but as it turns out, the latter also helps the former.
Right on, couldn't agree more.
Thanks, those links explain it very well
Based upon your past reddit/github activity I don't think that you're part of the target audience for mruby. I'm not saying that's a bad thing, it's just that most ruby users/devs/etc don't need mruby IMHO. &gt; always been missing the smallest example? Eh, it's not front and center embedded in the README, but they do have a [directory of examples](https://github.com/mruby/mruby/tree/master/examples) as well as a few [guides](https://github.com/mruby/mruby/tree/master/doc/guides). There's some external blog posts talking about various aspects of mruby as well. &gt; How do I use it? See above examples &gt; What do I need to use it? C compiler and ruby interpreter. &gt; When do I need it? This is the more interesting bit and the differentiator of mruby. You need mruby when you want to embed everything (C code, ruby code, ruby interpreter, etc) into a single reasonably portable and small binary. From their readme "mruby can be linked and embedded within your application.". This embedding is something which is very non-trivial to do with other implementations such as CRuby/MRI. For ruby applications embedded into spaces smaller than what mruby supports there is also [mrubyc](https://github.com/mrubyc/mrubyc), though mrubyc is considerably less mature. &gt; while just getting me frustrated at the basics If you don't need to embed ruby within applications or routinely compile all-included-single-binary images, then you're not going to gain a lot from mruby. For general everyday ruby it's not something that you likely need, but once you hit the right set of conditions mruby shines as a helpful tool.