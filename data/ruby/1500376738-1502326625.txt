The old syntax is still necessary, because it is possible to have **any** object (i.e. not just symbols) as a hash key. For example: { 123 =&gt; "this", [1,2,3] =&gt; "is", TrueClass =&gt; "all", false =&gt; "valid", Object.new =&gt; "syntax" } In reality, you rarely use anything besides symbols and strings for hash keys -- but even then, the "old" syntax is necessary to support strings! --- You **could** argue that the real "mistake" here was for ruby to introduce the new `{key: :value}` syntax in version `1.9`. However, in that case we'd still see tonnes of complaints that this (more 'universal') hash syntax *doesn't* exist in the language. [This StackOverflow documentation page](https://stackoverflow.com/documentation/ruby/288/hashes/1037/creating-a-hash#t=201707181117431461241) provides a fairly good overview of the available syntax.
This is a good point. I actually use objects as hash keys all the time. The group_by enumerator is magical.
Thank you, that's actually really helpful!
I've come across issues where I try to access a hash by string x["key"] Only to end up with an error. Something about not accessing it correctly if it was originally set with x[:key] Is there an easy way to figure out the *correct* way to access values? This is usually only an issue when using gems where it's not obvious how to access values.
Unfortunately not, symbols and strings are different. `"key" != :key` you can inspect the hash, and see what keys are in it through `{}.keys` Rails adds to the confusion by introducing the concept of `HashWithIndifferentAccess` which mashes strings and symbols together. A regular hash has to be accessed with the key you inserted it with. 
This isn't just syntactical is it? One is a string, one is a symbol.
Not in the example he gave I think since the {key: value} syntax converts key to a symbol no matter what the key is if I understand correctly
Ok, thanks! I actually should've read the [Stack Overflow](https://stackoverflow.com/documentation/ruby/288/hashes/1037/creating-a-hash#t=201707181117431461241) post that /u/tomthecool posted before asking...because that actually cleared up my understanding =)
`define_method` is used in the scope of the class to define instance methods. It is the equivalent of typing `def` but allows the method name and its block to be injected/interpolated. I have a small 5 email newsletter that would take you through using things like `define_method` to create instance methods in a class here: https://saturnflyer.activehosted.com/f/1012 maybe that will help too.
Yes. To use a string key, you must use the hash rocket.
Ah ok 
Thank you, I will have a look :)
LOL
Singleton methods are instance specific. Only one instance of a class has the methods. ~~Super Secret Methods can be defined on a class.~~ In this post it actually appears they are being defined on the Main Object, which actually is a Singleton, ~~but these declarations do not have to be~~.
WDYM? Isn't this a SM? secret = "hello" def secret.squirrel :shhh end secret.singleton_methods # =&gt; [:squirrel] (The code snippet is taken from the original blog post)
I was considering this book on Amazon, have you tried it before?
You are right, they are singleton methods. I was thinking you could do this at the class level, but then you create a singleton method on an instance of the Class class. For example: class Foo end define_method('Foo.do_something') do :class_definition end Foo.do_something send("Foo.do_something") 
I went through some of it and was able to put a snake game together pretty quickly. To be honest though I would recommend going with Phaser.js instead, though you'd need to be comfortable with Javascript. [Interphase](https://phaser.io/interphase) is a good book for Phaser. The benefit is that you're able to run your games in the browser (with WebGL, I might add). Not that Gosu is bad (it's still nice to know how it works, since many of the game concepts such as event loop, draw, update, and preload steps, will be common to most game frameworks)
I am going with: w = Wrapper(&lt;any object&gt;) w.f? #=&gt; @obj == false w.t? #=&gt; @obj == true w.v #=&gt; @obj (v== "the value") It still isn't transparent, but it minimizes the extra coding. 
I would like to see validations in Rails play nicer with constraints in the DB. In my ideal world the validations would have some flag like `db: true` and rather than imposing their own behavior such as querying to attempt to check for uniqueness, verify that the appropriate constraint exists and raise an exception otherwise. On the same note, the behavior of moving the checks to the DB changes somewhat, so it would be nice if the behavior could be the same for both DB constraints and rails `validations`. On another note: I think we should modify validations to not run unless the field they are validating changes. 
it's generally recommended to avoid single-letter variable / method names if you can help it, although we all can be a little sloppy sometimes. 
I suspect if you had removed the `case_insensitive: true` on your model-based validation, it also would have solved the problem. Although db-based constraint is better anyway. But your problem was the case_insensitive triggering a lower() meaning it couldn't use the index on that column, unless you had created an index for lower() on the column. You probably still will want to make sure to have an index on that column even with your db constraint. But it doens't need to be one accounting for lower() since you took that out. 
Agreed would be desirable if Rails would play nicer with constraints in the DB -- including making them trigger things in your `.errors` etc. I investigated doing this recently as a thought experiment... it gets tricky for all but the simplest validations. But uniqueness is one of the simplest it looked like it could easily work for, with some adapter-specific code in each adapter though. Of course, db-constraint "validations" wouldn't be triggered on `model.valid?`, you wouldn't find out about them until you tried to `save`. &gt; On another note: I think we should modify validations to not run unless the field they are validating changes. Eh, not as the default. It depends on the validation. Some validations may refer to other fields. You can write custom validations that do anything you want. Be careful abstracting from the frustrating problem you just had to what Rails should do as default, please. :) Also, in some cases depending on your rails config and what you're doing, you might not have access to what is changing... I think, maybe. Maybe not. Also validations that refer to other records (like uniqueness!) can stop being true _even if_ the record wasn't changed -- because another record was changed. Although I guess that's not true of uniqueness quite like that, it might be of others. But I think there's already an `only: :create` and `only: :update`, perhaps an `only: :changed`. But you'd still have to know to use it, wouldn't have saved you here when you didn't guess that validation would be a problem. 
the only reason I'm really using rails is for active record being setup by default. Sinatra would be a fun thing to transition to if I ever had time.
Well, that name tricks you. It seems you're defining that method on `Foo`, but in reality you're adding a method named `"Foo.do_something"` on the global scope. It's equivalent to: define_method("some_other_name") { :ok }
That's what I realized. I should have edited the comment to say that it 'avoids polluting the Class instance (Class as in object's class of Class) by polluting the global object (the object you should really worry about polluting).'
You can't really have a book definition of "good" or "bad" code. You can have better or worse code, but it's all relative to the goal and resources, not to mention language and time.... A programmer can recognise good or bad code, but it's something within the eyes of the beholder.
Curious if there is a reason not to use a `citext` for repo#name? Seems like that would have also avoided the issue, and removed the need for any manual processing unless desired.
&gt; citext That's not a standard column type so it's not supported out of the box (I don't think) via the ORM i'm using. I could of course manually write the migration. The reason I didn't use `citext` is that it's an oversight on my part. Good suggestion. While `citext` would avoid manual processing, I still need a constraint for the username/name combo. 
If you need a definition of "bad" code, I can share some of my old projects to be figures for the document.
Where does it say that this is related to Ruby codebases?
&gt; Eh, not as the default. It depends on the validation. Some validations may refer to other fields. You can write custom validations that do anything you want. Be careful abstracting from the frustrating problem you just had to what Rails should do as default, please. :) In this case the validation looks like this validates :name, uniqueness: {scope: :user_name, case_sensitive: false } So we know that either a change in `name` or `user_name` could make the validation fail, otherwise it can't. That being said sean mentioned getting this information at the right step might be hard. 
For uniqueness in particular, it's _probably_ do-able although hard. When you start thinking of other kinds of validations, it can get harder-to-infeasible. 
I believe ActiveRecord 4.2 added support for it. I've only used `citext` in a Sequel project but I do think AR supports it as well. 
On the third page of the survey. You have to give a bunch of identifying information prior to that page. Name, email, phone, DUNS, etc.
I never even heard of citext before! Gonna look it up. 
This is why /r/test/ exists.
I see. Here are the questions on the Google survey: &gt; Do you have familiarity with doing code reviews of Ruby-based codebases? &gt; Do you have expertise with developing Ruby-based projects? &gt; Do you believe using a style guide makes a code review easier or harder? &gt; What do you believe constitutes “best practices” for Ruby codebases? &gt; Do you prefer to perform a code review with detailed background information or only the bare essentials in regards to the purpose of the review? &gt; What are your preferred tools to perform a code review in general? &gt; What are your preferred tools to perform a code review on Ruby-based applications? &gt; What type of topics would your final report cover? &gt; How do you price your offering (e.g. by user, by number of lines of code, by system, etc.)? &gt; Anything else you think we should consider regarding code review? 
The person reviewing the code should really understand what each change does, and it's up to the original developer to package a change in the way that this is easily doable. E.g. adding comments in the code, writing tests, and packaging up commits into small, easily digestible blocks. 
Well, if you take the time to read *all* of my comments, you see where I asked what differentiates this from other gems that already do that, and list examples of those gems. In the future, read the entirety of the discussion before you run off to post your snarky response - otherwise you might end up looking foolish.
Link to previous year. https://2016.keeprubyweird.com
Lol There's not-as-good code though. But not completely bad.
This is the greatest conference
Caleb why do you keep trying to make my daughter weird? Can I not just have a normal damn baby?!
[This always makes me laugh.](https://www.youtube.com/watch?v=yuh9COzp5vo&amp;t=19m15s)
I actually like JS and was also looking to get back into it. I just couldn't find any cool projects to do and sort of forgot about it. I'd love to get back into games and JS. Can you run phaser.JS on Mac?
phaser can be run just by the browser, like many javascript libraries. It can probably also be made to produce a desktop game, but out the box it will work in the browser. You could optionally use some Node build system such as Webpack, but it's not necessary. 
Thanks! You got me interested 
you should look at their [examples](https://phaser.io/examples) page, lots of cool things. 
In all seriousness what is this conference about
It's about Ruby.
The example methods in the article are all defined on `Main`, just to keep them short, but it works on classes too. irb(main):001:0&gt; class X irb(main):002:1&gt; define_method('super.secret'){ :yep } irb(main):003:1&gt; end =&gt; :"super.secret" irb(main):004:0&gt; X.new.send('super.secret') =&gt; :yep
Awesome!
&gt; You probably still will want to make sure to have an index on that column even with your db constraint. I agree with most of your comment, but wanted to point out that Postgres [automatically creates an index](https://www.postgresql.org/docs/9.6/static/indexes-unique.html) when a unique constraint is created.
Damnit, I just moved out of Austin. Ritz is a sweet ass venue for a conference though. 
When a developer submits code for review. The code can be good bad or great, but if the person over viewing the code is not well informed on the changes being made or the best practices than all is lost. If you want good code, abstract away all complexity, write solid tests, and know your tools. 
Is it? Or is it about Rails?
Fundamentals never gets old. You can always read about new fancy stuff from the release notes of new version of the language.
&gt; I would like to see validations in Rails play nicer with constraints in the DB. Your ideal world already exists, if you replace ActiveRecord with Sequel ;) 
Puns?
OKD kad
The Ruby Cookbook's second edition is mostly the same as its first. That said, it's a good book and the language didn't change that much after version 2.0. 
Thanks. I guess my experience with the drastic ways JS and Python have been changing had me worried :)
Do you know if truffle will ever offer the ability to do something like this? Package all my code and gem dependencies with Ruby itself into an executable I can run on a bare Linux box? E.g. without a Ruby installed, for instance.
The Truffle core library is partially written in Ruby (using code from Rubinius) and we store this code as binary ASTs in the image so we don't need to parse or deserialise or anything. It would be possible to also embed user code in the same way - pre-parsed. And when you build a TruffleRuby native image it's also possible to partially run the program up to a point when you decide to freeze the state and compile. Then when you run the process continues from that point. So you can also run initialisation code at compile time.
Implementing a neural network in ruby: Step 1 - Install a gem to do it for you
Thank you, this was what I had in my head but wasn't able to express.
I daily use the Pickaxe for looking stuff up and really can recommend it. Little steep on the price but there are good examples and explanations in it. 
Looks like sequel doesn't enforce DB constraints either https://github.com/jeremyevans/sequel/blob/master/doc/validations.rdoc
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jeremyevans/sequel/.../**validations.rdoc** (master → bc38eb8)](https://github.com/jeremyevans/sequel/blob/bc38eb8a264cd4285ec9d7f0402f9054cd7f5386/doc/validations.rdoc) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkfj6r1.)^.
@schneems: Just wanted to tell you that your site is almost unusable on my browser in case you weren't aware and want to fix it. Its hiding text to the right and not offering a horizontal scroll bar. http://imgur.com/a/BdMOE
All that makes sense, and is very exciting. Are there any instructions for freezing the state within ruby, and then actuating the compilation?
Anything you read for introduction that is at least version 1.9 will mostly be the same as current implementation. When you get unexpected results in the interpreter, google the method and see if there's changes. Mostly everything works from 1.9 but there are convenient methods added.
I re-read these books all the time : Refactoring Pickaxe (have 2 copies) Poodr The Ruby Way Having said that.. I cannot stress enough that reading the Ruby docs themselves is about the most helpful thing you can do... especially the Enumerable / Array / Hash docs... learning to use iterators effectively like .select .reject .map .reduce will make you a MUCH better coder.
Not a *ton* has changed stylistically since Ruby 1.9. There are a variety of new methods that come in handy but nothing mind blowing. Bigger changes have occurred in the underlying implementation and some of the tooling choices in the community - two things books often don't cover anyway.
&gt; I would like to see validations in Rails play nicer with constraints in the DB. My thinking of late is that solution may actually be to stop writing data constraints in Rails and let the DB do its job. Validations too often are a muddy mixture of data constraints, UI constraints, UX concerns, and genuine business logic. Whilst 'the Rails way' makes it easier for the developer, I have seen it result in a great many very costly data integrity issues.
No sorry it's not ready for users yet and still very complicated to use. We'll be talking about it at RubyKaigi though.
Welp this website doesn't work on mobile too well. 
Most of the ways things have changed are related to syntactical shortcuts, so at worst, you are learning the slightly longer way to write things. Things that may have taken a few extra words to express before. The contents of the books are still quite legit. 
The problem with "just do it all in the DB" is that the database has no context. That's what we've got today. You also need interoperability between the DB and Ruby. For example if you try to create something with a duplicate name, then ruby needs to know WHY the save failed so it can show that in a UI, which currently doing only constraints in the DB do not allow. I think the best of both worlds is to have ruby double check that you did the right thing (TM) in the database, and then configure itself so that it plays nice with failure modes.
Thanks for letting me know! I just updated a bunch of CSS so some bugs are expected. I would like to try to fix this one. First for a work around try resizing your browser to be less wide, does that make the text pop back into the view?. I would really appreciate it if you have a second if you can go to http://whatsmy.browsersize.com/ and let me know what your dimensions are. Once I get dimensions I should be able to repro the behavior and I should be able to fix this in my CSS. Thanks again for letting me know!
Update, someone submitted a PR https://github.com/schneems/schneems/pull/14 should be fixed now 
That's fair. Is there a mailing list or chat group where interested third parties such as myself can track development more closely?
Or hugs?
&gt; "just do it all in the DB" I am not advocating for this - I mentioned specifically data constraints; its shape, size, consistency, type, range, etc etc. &gt; which currently doing only constraints in the DB do not allow. You are incorrect regarding context (unless I misunderstand your meaning). The constraint violated can be derived from the error, either the type or the message. &gt; ruby needs to know WHY the save failed so it can show that in a UI Again why I point to this 'muddy mixture' - UI/UX concerns as to failure affecting the approaches we take in storing data. You may be correct that a double layer of input validations and data validations are optimal (input validations allow us to reduce the DB workload) but I definitely find the Rails way lacking. Perhaps some kind of 'migrations for validations'? 
https://gitter.im/graalvm/graal-core http://mail.openjdk.java.net/mailman/listinfo/graal-dev They're not very high traffic but if you want to know more speak up on those channels.
Exactly what improves when we stop calling code "bad?"
Not much, just perception. If the code does its job, it can't be completely bad. The code isn't the best, it's inefficient, or maybe sloppy But not entirely bad
ah, right, good call! 
Works like a charm now!
Watched the first one that day but missed the rest. The links are dead. Are the videos available elsewhere?
Much of the Ruby ecosystem works like this so I wouldn't worry you are doing anything unusual. I think there may be shorter ways to write this though. For example how is `define_attribute_getter` different to just normal `attr_reader`? I'm not sure what you meaning about testing it. I don't think metaprogramming needs any kind of special consideration for testing. Just write tests that use this object as you would in your application.
`attr_reader` and `define_attribute_getter` are probably the same I just wanted to define attribute readers dynamically based on the API response. and about testing, i mean should i check if all metaprogramming stuff is generated probably or so? 
Sequel has [`auto_validations`](http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/AutoValidations.html) and [`constraint_validations`](http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/ConstraintValidations.html) plugins for generating model validations based on database constraints.
&gt; I just wanted to define attribute readers dynamically Right... but this is what `attr_reader` does. I mean your method may literally do exactly the same thing as `attr_reader`, so it's just wasted space. class Foo def initialize @ivar = 14 end def define_attribute_getter(attr_name) define_singleton_method(attr_name.to_s) do instance_variable_get("@#{attr_name}") end end end foo = Foo.new foo.define_attribute_getter(:ivar) p foo.ivar class Bar def initialize @ivar = 14 end def define_attribute_getter(attr_name) send(:singleton_class).send :attr_reader, attr_name end end bar = Bar.new bar.define_attribute_getter(:ivar) p bar.ivar 
I'd say Ruby books last much longer than Rails books. With Rails there's been some big changes. The basics stay the same, like where files go and what not, but a lot of things like strong params have been introduced. Even so, it's nothing like the mess that Swift was when I was trying to learn it. The language was changing, Xcode was changing, two month old tutorials wouldn't work. 
excuse me... your ~~balls~~ age is showing... I DO remember how awesome that was when it came out...
Oh yes, this was...15? years ago I was on that wagon. :)
Ideally I'd go with something that does ruby 2.0 for keyword arguments among other things. Something written for at least 2.0 shouldn't be hard to find though. The OP says "Most are at least up to date only for Ruby version 2.1". I agree, no problem with that. (Well, I've got a problem with that quoted sentence grammatically, but that's different, :) )
https://github.com/jeremyevans/sequel_postgresql_triggers . Thanks to sequel's plugin design, it's very easy to add database-specific enhancements, and this one in particular adds a lot of functionality implemented in db which ActiveRecord implements in Ruby (timestamps, counter caches, touch propagation). Also, from your link, "Data Integrity" paragraph: &gt; Data integrity is best handled by the database itself. As in, validations in sequel are not the most recommended approach, and the helpers in particular aren't part of core sequel (you have to load the plugin). 
&gt;learning to use iterators effectively like .select .reject .map .reduce will make you a MUCH better coder. These are used with blocks, correct? I just started learning how to use these in my current reading material, Head First Ruby. Just curious: if I had to choose just ONE of the books you mentioned as my second Ruby book, which would it be?
There is a ruby rouges podcast on this topic that was recorded recently. The guest even goes into his method of testing. 
I've done metaprogramming in prod and used a lot of libraries that use it and it can be a fucking headache if abused. It's really powerful, but so many people go apeshit with it and it can make debugging code a nightmare.
I don't know what fastlane is, but you're on the right track. The source would look something like, def lane(name, &amp;block) # ... end So yes, `lane` is a "function" (we call them methods over here)
Exception to note: Rails 3 is pretty similar to Rails 4, and Rails 4 is mostly similar to Rails 5. Rails 2 is obsolete. Rails 1 will be good for eBay in a hundred years.
`lane` is a method. `:beta` is a [symbol](https://ruby-doc.org/core/Symbol.html). `do; ...; end` is a block of code, that gets passed to the `lane` method. You can think of it as being a *bit* like a callback function - i.e. it's a chunk of code that the `lane` method can execute (or pass on to another method). This code is not defining the `lane`method; it is only invoking it. You shouldn't normally need to dig into the source code, but if you're interested I found the method definition [here](https://github.com/fastlane/fastlane/blob/65a0e08151f9c97ceae8b360018a8b8a15e8b376/fastlane/lib/fastlane/fast_file.rb#L70-L80). 
This is a bit more complex than one could think. When it comes to database constraints, it should be a no-brainer to use them. The problem is that existing solutions don’t provide any mechanisms that would ensure that proper database constraints are defined, based on validation rules. This could be easily done for some common cases, but a complete solution would be *really difficult* to achieve. At the moment I’m not sure if it’s worth the effort. When it comes to validation error messages, I (still) don’t think translating database exceptions caused by constraint violations into user-facing error messages is a good idea. Mostly because this approach means using exceptions for control-flow. It requires performing various application-level validations without touching the database first, and then *trying* to save/update something and potentially rescuing exceptions. As a result, this would halt processing on the first constraint violation, and you may not get all error messages, which doesn’t sound like a good UX to me. The application layer should do its best to make sure data is valid, and provide good feedback to the user. Using extra database queries to achieve that sounds like a good idea. If it starts causing performance issues, there are ways you can deal with this (adding better indices, tweaking query logic etc.), if nothing works, remove it and only rely on database constraints like /u/schneems did. I should also mention that in many cases you may have problems with performance just because validations are triggered in situations where you really don’t need them, but that’s just the nature of AR and centralized persistence/domain models.
FYI, if you want to copy code blocks to reddit, just add four spaces to the beginning of each line. Then, your code will come out like this: lane :beta do # things end Preserving the format of the code you're asking about makes it easier to understand. (For more about formatting text on reddit, see this [Markdown guide](https://www.reddit.com/r/reddit.com/comments/6ewgt/reddit_markdown_primer_or_how_do_you_do_all_that/c03nik6/).) But also, definitely try to give more context when you're asking for help. Like, what is fastlane, and what are you trying to do with it that you're struggling to interpret a language you have such little prior experience with?
Traveling Ruby doesn't support Windows.
IIRC OCRA doesn't do ahead of time compilation, so when you run a OCRA exe you will have your ruby source file lingering in your temp folder in clear. 
If you're using a nix terminal, should be `gem install &lt;gem&gt;` Or, install bundle this way, and in the root directory of your project make a file named 'Gemfile' with the gem names you need Ref: http://bundler.io/v1.5/gemfile.html
Alt f12 by default brings up the terminal window, or just look in the view menu for it. Then gem install as normal. If the project has a gemfile run bundle install from terminal, or if you have bundler installed you can do the same from the tools menu
&gt; used a lot of libraries that use it If you've used any of Ruby's standard library, or Rails, you're probably using a library that uses metaprogramming, so you can't really avoid that in Ruby.
Current plan is to have both ruby validations and db constraints. When we call `valid?` we don't hit the DB and only use the existing ruby validations. When we call `save` and it throws an exception we catch it, then replay all the ruby validations to figure out ALL of the problems with the object, not just the one that raised the exception. The benefit here is that if an object saves correctly, then it wouldn't need to trigger the ruby validations which for me were the expensive part. Also having some flag on the validation would check for presence of the constraint and throw an exception if it wasn't present. I'm sure there are cases we cannot map to ruby ruby to db constraints and vice versa, I still think that db constraints are best practice and we should be baking in features to encourage people to use them. 
&gt; I'm sure there are cases we cannot map to ruby ruby to db constraints and vice versa, I still think that db constraints are best practice and we should be baking in features to encourage people to use them. Yeah I wholeheartedly agree, question is: what kind of features?
Yes, they use blocks.. people seem to get stuck using .each for everything at first, and start re-inventing wheels creating their own versions of .select / .reject / .map / .reduce / etc... it does take a while to wrap your head around them, but just reading the docs : [Arrays](http://ruby-doc.org/core-2.4.1/Array.html) [Hashes](http://ruby-doc.org/core-2.4.1/Hash.html) [Enumerable](http://ruby-doc.org/core-2.4.1/Enumerable.html) would get them to the front of the pack MUCH quicker... &amp;nbsp; Having said that, if you must start with dead trees, in your case (being new) I would probably buy a used version of one that I did not mention... [Eloquent Ruby](https://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=sr_1_12?ie=UTF8&amp;qid=1500561503&amp;sr=8-12&amp;keywords=ruby+programming) which focuses on 'Idiomatic' Ruby... or the way most Ruby coders have decided to do things
Lane is a method that takes a single parameter and accepts a block. A block is a closure/chunk of code that lane can execute as it wishes to achieve some goal. Your confusion probably stems from familiarity with C-style syntax. Rewritten in Javascript, for example, this would look something like: this.lane('beta', function() { ... }); In Ruby, "this" or self is implied, methods do not require explicit parentheses around their arguments, and blocks (the do ... end bit) are used as small chunks of operations to be used by the method they're passed to. For example in this: [1,2,3].each do |num| puts num.to_s end The do...end bit is what should happen to each member of the array. #each takes each item of the array and executes the block, passing in the item as the num variable to the block. :beta is a symbol, which is basically a globally constant string used by Ruby to indicate that it represents a thing, rather than being a thing. You don't print or concatenate symbols, generally speaking, you use them to indicate a particular constant or key that you want to refer to. Very common as keys in hashes, for example: a_range = {:first =&gt; 5, :last =&gt; 20} Hope that helps!
I will use markdown next I'm sorry. Fast lane is a building tool for iOS app above is a snippet on their website which they don't bother elaborating on what the syntax does so I thought it's trivia and decided to ask here after unable to find answers
Thanks sir!! It explains well!!
NICE! I was looking for something like this, simple, straight forward, free of dependency burden, and just yesterday started to hack out my own solution after failing to find anything suitable for a simple rack application. :+100: for this! Are you using it in production? any gotchas or caveats to be aware of?
Thank you sir it makes sense down. But just want to be clear on language this is a method that takes 2 parameters First is the symbol Second is the block ? 
I hear that. I mentioned that in the article, that "it's tempting to use it all over the place"... There's a time and place for it, but sparingly, IMO
Any method can accept a block. They're a special Ruby construct. You can write a method to use a block like so: def foo yield 5 end foo do |num| puts (num + 5).to_s end # =&gt; '10' foo # LocalJumpError: no block given (yield) If you code the method up to use yield, you require a block or you'll error out. You can tell if a block has been given using #block_given? like so: def foo if block_given? yield 5 end end foo # =&gt; nil If you want to explicitly *do* something with a block, you can capture it to a variable like so: def foo(&amp;a_block) a_block.call end Sometimes, I'll write methods that capture a block and *save* it for later use! Can be useful when building a generic tool that needs some custom coding in certain cases, e.g.: def on_format(&amp;block) @formatter = block end def format_string(str) @formatter.call str end Which you could use like so: on_format do |str| "[" + Date.today.to_s + "] " + str end format_string 'Hi mom!' # =&gt; '[2017-07-20] Hi mom!' Cheers!
Oh wow thanks definitely need time to digest this appreciate such detailed explaination
As others have mentioned, there is nothing "special" about installing a gem when using Rubymine. Install a gem like you would with any other editor. Of course, as pointed out, you can bring up a terminal panel within the IDE. If you are using Bundler (you should be using Bundler), you can add the new gem to your Gemfile, then install it by going to `Tools &gt; Bundler &gt; Install`. However, I would just use the terminal.
If you want to reduce his code and keep dynamically changing at runtime, only attr_accessor is needed (if you really want both, attr_accessor everywhere is a whole nother topic). I think his reason for use of metaprogramming is to change the object at runtime, since he doesn't want to define every attr_accessor in his code like he stated. class Base def initialize(attrs = {}) setup_writers(attrs || {}) end private def setup_writers(args) args.each do |field, value| self.class.send(:attr_accessor, field.to_sym) instance_variable_set("@#{field}", value) end end end Security standpoint: Is this a good idea if you don't trust the source of the 'hash' being passed in? Nope: http://guides.rubyonrails.org/v3.2.8/security.html#mass-assignment Maintainability: Is it obvious whats going on? Well its metaprogramming, so you sacrifice it. As long as the next dev looks @ Base and sees the meta programming, he/she won't know where it's being created. It's up to you ! 
Thanks, I'll check it out!
Mine has a little '+' above the gem list that allows installs from that screen. Are you on the latest version?
What is Bundler?
It's a gem that manages gem versions, their dependencies and the environments &amp; platforms they are used in. It also allows you to update and install all the gems in your project together instead of one by one. 
I would def recommend bundles, helps with dependency management, collaboration (if others are working on the code too), and deploying. 
Not just wasted space, but opportunity to introduce bugs or performance problems that aren't in attr_reader, something that has been used by many many codebases over many years, and probably has been improved once or twice already. 
yup if you really want to do this (and I'm not sure it's a good idea), you can still just easily call it to the :attr_accessor (or :attr_reader or :attr_writer if you only need one) method, instead of re-implementing it yourself, as you've shown. 
No worries. For the future, it will also help others to know how much background you have with other programming languages (and which ones). Do they have to explain what a function is? or only tell you that in Ruby, functions are called methods? Good luck!
&gt; When we call save and it throws an exception we catch it, then replay all the ruby validations to figure out ALL of the problems with the object, not just the one that raised the exception. If `save` gets that far, presumably all of the Ruby validations have passed?
&gt; On another note: I think we should modify validations to not run unless the field they are validating changes. One quick technique is to add `if: :foo_changed?` to all the validations. But following through with this line of thinking has me currently experimenting with validating the request instead of the record. It's a pattern that transfers well to other web frameworks.
One good example might be validation logic triggered by updates in a state machine. When a blog post is published, it must have a body.
Not me. Have you tried searching for Ruby or programming meet-up groups in Winnipeg (at meetup.com)? You could ask folks there about the job market and which places run Ruby.
Oh, that's pretty neat.
The blog post referenced another Zendesk project, [Maxwell's Daemon](http://maxwells-daemon.io/), which seems interesting as a migration path for ORM-heavy monoliths to get to evented, stream oriented systems. I see that it is mysql only -- any chance it might become available for postgres as well? I like kafka as a high bandwidth stream processing engine, but not as storage for transactional data. I much prefer [Event Store](https://geteventstore.com) for a "log style" approach to application persistence.
Thread.new
Take a look at the concurrent-ruby gem, or celluloid. Both cover what you are looking for.
In this plan we wouldn't call ruby validations unless the save failed.
The easiest way is to use threads and then call join on all of them to wait for them all to complete before moving onto the next operation. Word of warning, you don't just want to spin out a limitless number of threads. Get a batch of 10 or 20 going. You wouldn't see much speedup from using more than that anyway. If you don't believe me try different batch sizes and profile the results. I feel confident you will reach the same conclusion. 
I mean, I don't want to be that guy, but *why* Winnipeg? I could be wrong, but I've never heard it mentioned in any conversations or on any job sites for its opportunities in dev. Leaving aside the other things we know of that city in comparison to others. Edit: as pointed out, I was quick to speak without thinking. As for help, have you checked indeed.ca? I did a quick search and there are 3 positions posted for ruby devs in Winnipeg. (One for WGI group, one for Farmers Edge, and one is a headhunting company).
Bad code: * does the wrong thing * is difficult to decipher * is expensive to run * is difficult to re-factor or upgrade * isn't properly tested And sometimes you get lucky and find code that's all of these things at the same time. In production. And sometimes you get even luckier and you find out that the aforementioned code took a long time to write
There you go file_paths.map do |file_path| Thread.new do Storage::S3.upload(file_path) end end.each(&amp;:join) Please note that neither the above code, nor your code, does any error handling. Have you given any thought to what should happen if one or more of these uploads fail?
Don't wanna answer for him but there might be more reasons to move other than job prospects. Maybe he has old parents in Winnipeg, maybe life is more affordable in Winnipeg, maybe he wants a new experience and Winnipeg is where he fell in love for the first time. Or maybe he thrives in cold climate, who knows.
Fair point, from the wording I just assumed it was a desire to work there (and just that). And we all know what assuming does.
Wait. You've witnessed code, in production, not even doing its most basic job?! I've never seen it *that* bad.
Cowboy edits and ninja deploys
The concurrent-ruby gem does this really well. thread_pool = Concurrent::ThreadPoolExecutor.new(max_threads: ENV.fetch("WEB_CONCURRENCY", 25)) file_paths.each do |file_path| thread_pool.post do Storage::S3.upload(file_path) # Takes a minute end end thread_pool.shutdown thread_pool.wait_for_termination ... more code, all uploads complete... Edit: Note about why you'd want to use concurrent-ruby instead of the native thread stuff mentioned in other posts -- limiting the number of active threads. Say `file_paths` returns 10_000 files, running this without a pool could be bad news. Additionally, if you're doing any DB access, you'll need to limit the number of threads to not overload your ActiveRecord connection pool.
What's a cowboy edit?
Let's suppose a User model with an email. We want to verify that the email contains `@`, and that it is unique in the database. If we implement this spec with a mixture of Ruby validations and DB constraints, then waiting to call Ruby validations until the save fails would mean that strings without an email format get saved to the database. Alternately, if we teach the database to care about both the format and the uniqueness, then we wouldn't get both error messages back. If getting all error messages back is a system design constraint, then maybe this could work: First, `valid?` checks the email format. If the format is invalid, then we additionally run a uniqueness query so that we return all errors. But if the format is valid, `save` attempts to insert into the database and catches uniqueness violations. This only omits the uniqueness query in situations where *all* data is valid. It's a less aggressive performance optimization, but it satisfies the UX constraint.
http://wiki.c2.com/?CowboyCoding Typically what happens is that a minor bug appears in production, but due to external factors (eager product owners, perhaps) a full release cycle or even a short hotfix cycle is too slow. So someone with access simply logs into the production server and makes code changes there. If it's a text change to fix misspelling or phrasing, then it's not a big deal. It's when functionality/business logic is introduced that it becomes a problem, largely because (by it's nature) cowboy code isn't tested.
You want the `parallel` gem. https://github.com/grosser/parallel#usage
Well, this is specific to my life. To be honest, there isn't much of an active Ruby community in Winnipeg anymore. The Ruby User Group rarely meets anymore, for example, and there aren't many Ruby gigs available in the city, as far as I know. But all is not lost! Do what I did: find a remote job.
I think that if you have a hard time testing something, then perhaps it is using too much meta programming. While you could argue that the testing functionality shouldn't hold back the application code, in many cases you can tweak your approach somewhat to make it more testable. Another issue is whether the code will be comprehendable to another developer. Say you have to pass off the entire codebase to someone else. You should be adding an entry to the docs for every abstraction, so you can decide whether or not the functionality is useful enough that it's worth doing so. For example on a previous project I worked on, I used a [Symbol#call](https://stackoverflow.com/a/23711606/2981429) which adds the `[1].map(&amp;:+.(1)) == [2]` syntax. However in retrospect I'm not sure I should have done so, because it might have been confusing when I passed off the project. Keeping things simple so they can be easily documented is a good practice, and while metaprogramming isn't contrary to this goal, it's worth considering whether the simplist solution isn't worth keeping for the sake that it's so simple. 
Can also use `value` to get the results: results = file_paths.map do |file_path| Thread.new(file_path) { |path| Storage::S3.upload(path) } end.map(&amp;:value) `results` will then be an array of the return values of `Storage::S3.upload(file_path)` which presumably would contain the success/failure info. It's also good hygiene to pass any needed data through `new` rather than creating a closure which the thread accesses when it runs. 
Just looking at the example they give here. If every class only delegates to a single other class (i.e. Order =&gt; OrderRequest), then the metaprogramming is only saving one method/attribute definition per class (e.g. Order could define def request as a pointer to the OrderRequest class). Granted, you'd have to add one of these for every class which includes the Protocol mixin. The issue is that now the mixin has a dependency you need to document. While not a big issue, way to get around this would be to make the Protocol, funny enough, a protocol. E.g. make the Protocol module define a default request_class method which raises an Error, and then expect classes including the Protocol to also define such a method. 
nice! I had no idea that `value` would implicitly call `join`!
http://winnipegrb.org/
yes?
+1 I'm pretty sure that my eyes bled reading that.
What if he was just making the gem for the shit of it?
Sweet Jesus that is elegant code.
I'll give another shout out to concurrent-ruby here. If you want to look at it, I have an example repo where I use it with Rails. https://gitlab.com/mwelke/rails-async-example
That is lovely. In a horrible way.
why using send(:singleton_class).send and not self.class.send? is there a difference?
actually, this is an api response wrapper so i believe i can trust the hash being passed as it's just json, anyways this is a neat solution thanks alot :)
why it's not a good idea?
the thing is metaprogramming is very tempting to use, i'm kinda new to it so i'm trying to approach it with caution, however, it saves alot of time, at least in my case as the simple replacement would be aloooot of code 
This is..... horrifying :&lt;
Then he could say that? That's not actually what he said though. How do _you_ evaluate what gems to use in your project? Do you decide "just for the shit of it" on professional projects? If I'm choosing a new gem over an older more established one, I want to know what the authors intended it to have to offer over the older one. If they did it "just for the shit of it", that's definitely going to effect my evaluation. "just for the shit of it" definitely sounds like the new one wouldn't be getting much maintenance from the original authors in the future. In this case it's unclear how much maintenance the old one is getting either. All things to compare and evaluate. That's why it "really matters", to me anyway. 
I said I wasn't sure, not that I was sure it wasn't. But is the decrease in maintainability worth some small convenience when writing the original code? If you judge the increase in convenience high and the decrease in maintainability low, then, sure, it is. 
Oh, yeesh.
I don't understand how this differs from my proposal. In my proposal `valid?` does not hit the database, because it cannot hit the database. In my proposal the unique queries only get run by ruby if a save fails. &gt; If we implement this spec with a mixture of Ruby validations and DB constraints, then waiting to call Ruby validations until the save fails would mean that strings without an email format get saved to the database. You still have to have validations that aren't DB based, you would only skip ones with something like `db_constraint: true`. So you wouldn't run into that situation. Happy cake day. 
What hath Kevin wrought?
In my proposal `valid?` still hits the database if at least one other validation fails, because in that scenario `save` would not execute and could not report the status of the uniqueness constraint. Also, if `save` only runs after the Ruby validations have passed, then there's no need to replay them after catching a constraint violation. There's only one error to report back in that outcome. If I misread your proposal and those cases are already covered, then there's nothing to see here!
Great, now we can have the readability and ease of use of JavaScript, with the performance of Ruby! ^(/s)
Thanks for the link! I couldn't find that on Google for some reason. 
Not bad idea. But the community seems to be small. Maybe it is hidden. 
My family moved there. Considering moving there. 
 ... Thread.new file_path, &amp;Storage::S3.method(:upload) ... this should work too 
I thought "Oh God why?", then I read the FAQ, then I laughed...and finally I cried because it's true and we need help. :)
Family. It is that simple. Wanna spend some family time. 
Thanks!
Thanks for this snippet!
Don't use it then *shrugs*
what point are you trying to make here?
or... space aliens?
 Sum = undefined
The bigger question I have is why has Kevin made *_site* the document root?
Sorry one more question In my example i am passing :beta as the symbol argument to the method, when do we prefer symbol over traditional parameter(one without the colon?)
&gt; I'd like to replicate JavaScript's Promise.all, which takes promises and resolves when all given promises are resolved. concurrent-ruby has [Promises](https://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Promise.html) and [Futures](https://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Future.html). e.g: uploads = file_paths.map do |file_path| Concurrent::Future.execute { Storage::S3.upload(file_path) } end uploads.each(&amp;:value) # resolve futures - you might make this an #all? to check the return value of the operation if uploads.any?(&amp;:rejected?) # check for any that raised an exception errors = uploads.select(&amp;:rejected?).map(&amp;:reason) # ... else handle_success end You may want to run them on a custom executor to limit concurrency - by default they run on concurrent-ruby's global thread pool. The [edge API](https://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Edge/FutureShortcuts.html) might also be of interest - it unifies futures, promises, etc in a more flexible structure.
Thank you for posting this on Friday. I needed that.
None at this point, I just keep seeing messages in my inbox
It's an old site on an old version of jekyll. I seem to recall having to do some hacks to get haml + sass working at the time that, after several rounds of yak-shaving, ended up with _site as a root. I thew up my hands, added a redirect from `/`, and called it a day. I imagine I could do better now, but redoing this site is not my top priority. :)
A symbol is a native value just like a string, integer, float, bool, etc. It's not used in *declaring* a method, it's a value *passed* to a method. So: # This is wrong: def some_method(:arg1) ... end # This is right val1 = :foo some_hash = {:alpha =&gt; 1, :beta =&gt; 2} some_method('a string', :a_symbol) So, why use a symbol over a string? There's really no strong reason. It's more intended as a code signal as to what kind of thing you're working with. The string "beta" refers to the characters b,e,t + a, will be used to display those characters, or send them to a database, or whatever. The *content* is important. the symbol :beta doesn't *have* characters. It's a single thing, conceptually, that is immutable. So it's used in the *code* rather than used by the end user. That's why symbols are so often passed to methods (as constants) or used as keys in hashes (to represent an index into the hash). Make sense?
[*citation needed*]
step 1: monkey-patch ruby method "def" step 2: (?) step 3: post to reddit! step 4: profit!
On the other hand, ruby disguised as javascript, so... free pass, eh.
Yes thanks again for explaining this I am not used to such concept need this to sink in 
Amazing post! We begin migration of our tech stack on Monday!
Good Anakin
Great to see another INI parser. Love the simple INI format. As an all ruby alternative may I highlight the [iniparser gem](https://github.com/datatxt/iniparser). Cheers.
Wow. Great awesome list. Thanks for highlighting all the great gems in ruby for data science (small and big). Still early might be of interest I’m assembling - The Small Data Handbook for Rubyists, see &lt;https://smalldatabook.github.io&gt;. Cheers.
I'm a bit of a newbie but isn't this exactly what encrypted secrets in 5.1 solves? Is there any reason to not use that over these methods?
A secret society of Rubyists? Awesome! :)
I'm at a loss as to why you would do this instead of just using a regular old helper. You're Allocating an Array, converting it to a string, sanitizing it, then parsing that string as JSON on almost every request (assuming breadcrumbs are present on almost every page). Why do this? It's slow and confusing.
You could definitely have a view helper method like this module ApplicationHelper def breadcrumbs_helper(breadcrumbs) html = '' html &lt;&lt; "&lt;nav class='breadcrumb'&gt;" html &lt;&lt; link_to(icon('home', 'Home'), root_path, class: 'breadcrumb-item') breadcrumbs.each do |item| case item.class.to_s when 'Array' string, link = item html &lt;&lt; link_to(string, link, class: "breadcrumb-item #{item.equal?(breadcrumbs.last) ? 'active' : nil}") when 'String' html &lt;&lt; content_tag(:span, item, class: "breadcrumb-item #{item.equal?(breadcrumbs.last) ? 'active' : nil}") end end html &lt;&lt; '&lt;/nav&gt;' html.html_safe end end and you will definitely get a similar result. However, this would require specific placement within the views whereas using `content_for` allow me to have the breadcrumb content in a later file/partial. You are correct, that the `content_for` method is slower since additional overhead is added. However, this can easily be mitigated via fragment caching if load testing proves it to be an issue.
&gt; and you will definitely get a similar result. However, this would require specific placement within the views whereas using content_for allow me to have the breadcrumb content in a later file/partial. `content_for :breadcrumbs, my_breadcrumbs_helper(whatever)` &gt; You are correct, that the content_for method is slower since additional overhead is added. However, this can easily be mitigated via fragment caching if load testing proves it to be an issue. You are allocating an array, relying on the `content_for` calling `to_s` on it's input internally, calling `sanitize` on this string (I don't know why), then relying on the output of `Array#to_s` happening to (in some cases) be valid JSON, parsing it as such, then iterating the result. This is insane, don't write insane code, don't rely on caching to fix insane code. 
"Should I use this in production? Absolutely. Please tell me how that goes." Love it!
Well, metaprogramming is usually only tempting when it is truly the simplest solution. A quick consideration of readability and lines of code helps. Will it drastically reduce LOC while maintaining conceptual clarity? A third point should also be considered, especially in architecture, that is performance. For instance, using #send(method), vs method_hash[:symbolic_ref_to_method].
&gt; Oh god why? Some devs just like to watch the world burn This is amazing. A fun read. Because why not.
&gt; The bootsnap gem helps to boot a Rails application faster, and the gem is now part of the Rails default Gemfile. I was surprised to click to go to bootsnap github, and see at the top: &gt; Beta-quality. See the last section of this README. Looks like any remaining concerns are mostly about use in production though. 
I've had issues with pry when using Bootsnap. Not surprising, but enough to make me not use it for development. It made pry completely useless.
that would def be a no-go for me too. 
Hello, I've put together the world's 1st office suite in ruby ;-) Let's welcome Office.TXT - The Free Writer’s Command Line Tool Suite. Use [`$ gem install officetxt`](https://github.com/officetxt/officetxt) to install the all-in-one office bundle. What's included? For now: - `journaltxt` - `jekyll` - `drjekyll` - `mrhyde` - `octopod` - `m2w` - `rougify` - `kramdown` - `quik` - and more. Anything missing? Let us know. Cheers.
this is cool. thanks
Kinda weird that another "speed up" gem is being introduced, in addition to Spring.
Anyone else see "bootsnap" and think WTF! Bootstrap in the default gems! 
A gem that makes pry completely useless is going to upset A LOT of people
&gt; The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming. &amp;mdash; Donald Knuth, [*Computer Programming as an Art*](http://www.paulgraham.com/knuth.html), 1974 [Turing Award](https://en.wikipedia.org/wiki/Turing_Award) acceptance speech. Guilty as charged; in recovery.
We finally tripped over Bootstrap thrice too often and are now happily using [Semantic UI](https://semantic-ui.com/) instead. Far more comprehensible; plays much nicer with other tools.
Are you focusing on solely text editing adjacent tools? There's a number of PIM-related CLI tools I could recommend. (i.e. you've replaced PowerPoint and Word - would you want to replace Outlook too?)
I've been using pry and bootsnap together for several weeks. No problems here.
No worries. Please tell us your (PIM-related) recommendations. Office.TXT is still version 0.1, that is, just getting started. One plan / idea is to add a RSS-to-IMAP server/service (addition to Pluto) so you can read your news (web feeds) with any email client, for example. 
Boots**n**ap, not boots**tr**ap
Some of those starting issues are quickly handled with rvm or rbenv. 
Indeed, I'd say a good half of them. In addition, I think it's more a matter of "getting back to Ruby". If the hacker was using Ruby daily, this wouldn't be a problem (this doesn't mean the situation shouldn't be improved, btw!). You'll see the same type of issues if you stop using pyenv or npm for six months, and especially if the versions are not properly pinned.
This doesn't sound like the kind of thing you can really do with regular expressions. And even if you somehow find a way to, it's almost certainly not the kind of thing you *should* do with regular expressions. ---- **Edit**: I thought about it a bit, and what do you know it *is* (nearly) possible. It's still gross, but this seems to almost work (warning: I haven't really tested this thoroughly, and there may be unhandled edge-cases *out the wazoo*): `/.{1,n}.*?(?:\b|$)/` What this does is: * Match between 1 and n of any character except a newline * **Non-greedy** matches 0 or more of any character after that * Until it hits a word boundary or the end of the string This almost does what you're after, but it has a (likely unavoidable) issue where after n characters it will continue to consume *any number* of spaces or non-word characters before continuing to the next match. Eg, if n==7 and the input string is `this•is•a•string•test••••••••••&lt;-BUG` (where • is a space character), it will return: * `this•is` * `•a•string` * `•test••••••••••&lt;-` * `BUG` instead of * `this•is` * `•a•string` * `•test••` * `•••••••` * `•&lt;-BUG`
How is RVM different from chruby that he's using?
Thank you! The project is pretty new and currently, I am only using it in a pet project, but since it is kept simple, I don't see any problems that would keep me from using it in other projects, too. I once built a project using react_on_rails, for which I would now totally use render_react, if I was to build it again
you can have multiple delegators, but you can only inherit from one class
&gt; quickly handled with rvm or rbenv. he's using chruby already, can't think of how the other 2 would help. 
I get it. That's what Vagrant is for (happy user here);)
this post is quite old. Working with ruby hasn't improved much since then (setup's still a drag), but a reasonably big project should have a env setup script and a small "How to" section in the README, otherwise you're doomed to relive this nightmare every single time. 
RVM will do both the install &amp; the version change by default, so I found that with beginners it works reasonably well (YMMV). I believe with chruby you have to add ruby-install or ruby-build to get that behaviour, so it's a bit more friction for newcomers.
I think it's a good read for newcomers but a few remarks if I may: * In the first picture `^` and `$` are described as line start/end (which is not really true, **edit:** for ruby it is) and later on you are going to label it correctly as input start/end * In 2.7 you list a lot of the reserved characters so that it seems to be a somewhat complete list, yet the most notable `()` are missing. * I would add a little paragraph to clarify which Regex Standard you are describing (PCRE I assume) and pointing out that most languages have some special quirks to them. Lookaheads/behinds sometimes work differently or don't work at all, Ruby for example has the very "dangerous" thing that the anchors `^$` actually match the line and the proper equivalent would be `\A\z` to match the whole input. And I guess Ruby isn't also the only language that allows for named matches, or is it?
I think you're basically on to something, delegating to all methods of the referred class and making all those methods public on the starting class doesn't really give you any more maintainance management than in inheritance. Delegation may be slightly easier to change later, and does let the starting class inherit from something else. With regard to this latter point, it actually makes it analagous to _multiple_ inheritance -- which isn't generally considered a maintenance advantage though. Delegation, not neccesarily with those stdlib libraries but just as a concept, can also be used more sparingly though, only delegating certain methods, sometimes only internally rather than exposed. In that case it can constrain your public API to make things more maintainable. In your case, it actually does do that to some extent. You are only delegating the `language` method, even though Product may have more methods -- or may come to have more methods in the future. With inheritance, if future edits to Product add more public methods, Book immediately has them too, for better or worse. With delegating only the `language` method, the entanglement is constrained. Some implementations of delegation also allow you to _change_ the referred object delegated to, at runtime, for a given object. You can't do that with inheritance. I've only needed to do that very occasionally, and it should probably be used sparingly. 
good point. workarounds on top of workarounds. I think if bootsnap is or becomes mature and reliable, it's probably a _better_ way to go than spring, if it can actually replace spring. 
Check this page: https://stackoverflow.com/questions/8714045/truncate-a-string-without-cut-in-the-middle-of-a-word-in-rails Has solutions for straight regex and a couple methods if you're using Rails. TruncateWords was added in 4.2 but you can do it yourself with regex in Ruby. 
This is exactly the thing you can do with regex. I come from a Perl background where the boundaries of what's possible with regex were often pushed but in this case you're merely detecting word boundaries and acting accordingly. Pretty straightforward. Link to solution in my other comment. 
I know I'll be burned at the stake, but our shop uses the Debian package for both Ruby and Bundler. Been doing it for years without issue.
Alternative title: Coming back to a react project after 48 hours.
Something like: https://github.com/dorkrawk/darwinning ?
I think that's just a ruby genetic algorithm implementation, not an ai programmer. Take a look at the ai-programmer readme to see the difference.
Some of the ["bonus" regexes](https://github.com/zeeshanu/learn-regex#bonus) are dubious to say the least... For example: &gt; "Valid URL": `^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$` There are many mistakes here. Here's my quick attempt to "fix" the regex: \A((http|https|ftp):\/\/)?[a-zA-Z0-9\-.]+\.[a-zA-Z0-9]{2,4}([a-zA-Z0-9\/+=%&amp;_.~?\-]*)\z ...but if you really want to be certain that a URL is valid, try *requesting it*! &gt; "Date (MM/DD/YYYY)": `^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$` This claims before 1900 or after 2099 are invalid. It also claims "31st February" ("02/31/2017") is valid. If you really want to be certain that a date is valid, try *parsing it*! &gt; "Phone with code": `^+?[\d\s]+[\d\s]{10,}$` This is making very strict assumptions about the number format (e.g the presence of country code, no brackets, no hyphens, no periods, etc), and very little validation about the number length. (zero digits and 1000 digits could both be valid!) If you really want to be certain that a phone number is valid, try *contacting it*. &gt; "email": `^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$` Again, this is making far too many assumptions. Why must [the TLD only be 2-4 characters long](http://data.iana.org/TLD/tlds-alpha-by-domain.txt)? Why can't the domain contain two `.` characters (i.e. a subdomain)? (For example, almost *every school email address in the UK* will contain **three** "." characters in the domain!! `my-name@school-name.county.sch.uk`) If you really want to be certain that an email address is valid, try *sending a confirmation email*. ---- TL;DR: There's a time and a place for regex, but don't get carried away with it. There are lot of problems that *shouldn't* be fully solved with a regex, no matter how clever you think it looks.
&gt; In the first picture ^ and $ are described as line start/end (which is not really true) and later on you are going to label it correctly as input start/end Start of input is \A and end of input is \z. ^ is beginning of line and $ is end of line. (In Ruby that is, but since the link was posted to r/ruby I have to assume it is about Ruby regexp.) &gt; I would add a little paragraph to clarify which Regex Standard you are describing Very important! Oh, and btw there are millions of regex tutorials out there already...
Never done em. Not my style. 
I knew a bit about each subject when I started them. I had a co-worker who was very new to OO doing them and some of it was confusing to him. I would say you need to at least understand objects a little to get the most out of them
The most confusing/powerful part about Legato ruby are the views. What dimensions and metrics do you want in your report? [Available dimensions/metrics](https://developers.google.com/analytics/devguides/reporting/core/dimsmets) e.g. by defining these two classes and extending legato model, I can build whatever reports I want. require 'legato' class DailyVisitors extend Legato::Model metrics :visitors dimensions :day, :campaign, :month filter(:for_path) { |url| substring(:full_referrer, url) } filter(:for_campaign) { |campaign| matches(:campaign, campaign) } end class LegatoCampaigns extend Legato::Model metrics :visitors dimensions :campaign end 
Thanks.
Dude, you're awesome - thank you! That was way easier than I originally thought. For anyone wondering who comes across this, you can add any of the goal/conversion fields from [that link above](https://developers.google.com/analytics/devguides/reporting/core/dimsmets) into your class and it will pull whatever conversion data you want. So my class ended up looking like this: class MyClass extend Legato::Model metrics :pageviews, :visitors, :sessions, :goalCompletionsAll, :goalConversionRateAll, :goal1Completions end Thank you!
Love ruby... but this... on the other hand... this is the main reason I dig into ruby more and more... so that I need fewer and fewer Gems... or dependencies in general... To be fair... most environments suffer the same madness... 
You're welcome! 
Good guide, but I still recommend people buy [Mastering Regular Expressions](http://regex.info/book.html)
You shouldn't use a regex for something like this, it can be done more simply and readably in plain code. Ruby has mutable strings, which means you can actually count through the string in steps of `n`, move to the next space, and mutate it to a newline. This is the simplest and most performant option I can think of. def add_newlines(string, max_length) index = max_length - 1 until index &gt;= string.length if string[index] == ' ' string[index] = "\n" index += max_length else index += 1 end end string end You could also split the string on whitespace, build up new lines one word at a time adding to an array when the line hits or exceeds `n` chars, and join the array with newline chars when the word list is exhausted. def add_newlines(string, max_length) words = string.split(' ') lines = [] current_line = '' until words.empty? current_line += " #{words.shift}" if current_line.length &gt;= max_length lines &lt;&lt; current_line current_line = '' end end lines.push(current_line).join("\n") end 
Oh its not that bad with RVM 1. .ruby-version to pin your project to one version 2. run the appropriate pre-build package installer (to catch those pesky native gems) listed here https://github.com/rbenv/ruby-build/wiki (so apt-get install build-essential etc... on debian derivs) 3. gem install bundler -v [whatever version is in your gemspec] 4. bundle install 5. irb/rails s/whatever
I dove into them immediately. Great way to learn
&gt; he's using chruby already, can't think of how the other 2 would help. "using" is generous, he seems to think the proper way to use it is to chruby to a different version than the application was written and tested on, see it fail then roll the app forward blindly to the version chruby is currently configured with then stumble over each failure cascade. 
 $ script/setup &lt;wait&gt; $ rake &lt;profit&gt;
Build stuff. That's pretty much the next step. Try creating tic tac toe, then submit the code for review here. We'll provide advice, which should lead to other things to learn. Along the way you'll have questions and get stuck, which will also provide opportunities to learn. But yeah, building something is the next step. I say tic tac toe as it's a beginner level project that's well defined and gets rid of the problem of coming up with your own idea. Let us know how it goes!
Oh I kinda missed the fact that this was posted in r/ruby my bad. But I think Ruby is very unique to that isn't it?
This is a good occasion to share one of my favorite Stack Overflow answers: https://stackoverflow.com/a/1732454
For your first fix: You forgot to add/copy or accidentally removed the escape for the dot in the subdomain part. Also for email: [relevant](http://emailregex.com/) but I have to wonder why the python one seems pretty simple and the one for Ruby looks like a total desaster (okay there is a simple version but still).
On the contrary... No I didn't ;) If placed within a character set: `[.]`, this just means a literal dot. The character loses its special meaning. 
Uh I never knew that :) Thanks for teaching me something new
thanks for the input. As soon as I power out my current course I'll start on that and follow up here!
you haven't answered my question, which was "how would chruby would better handle this". &gt; is to chruby to a different version than the application was written and tested on... Keyword here being "version that the application is written". Who's the owner of that information? The way I see it, there might be 2 sources: the .ruby-version that such tools as rvm, rbenv and yes, chruby, use to automatically switch to that version; and the version declared in the Gemfile. The weight of legacy in ruby. 
As much as I love chruby and avoid the other 2 like the plague, I have to admit that your way is and should be the one true way. At least for deployments. There is value in having a local version switcher if you're developing a library against multiple versions, but that's where the requirements should end. As a quick note, do you know of any light Docker image using that debian package?
I'd go a step further and try for an internship. Either that or go to meet ups and code with other people. As with just about everything else, doing it with a peer group and some social pressure/responsibility will speed progress. Learning enough that you can _get_ an internship is the obvious intermediate step. Knowing that your skills must be relevant should clarify what you ought to work on. 
Try out sinatra before rails
Well like you said, you have to learn enough to be able to get an internship first - so yeah, your next step is still to build something, even if you have a larger goal of getting an internship. I would actually be way more cautious about going to meetup events. Yes, the they are great for networking, for mentoring, for help on bugs, shared camaraderie, all of that. But it can be easy to just go to meetup events, and talk to people, and come up with project ideas, and learn about new technologies, but at the end of the day you haven't actually worked on your project. Going to meetup events isn't a substitute for actually coding, but I think that's a state people can easily fall into, especially as newer developers who still usually have very broad goals. That's why I specifically stated to build tic tac toe - so OP doesn't get into analysis paralysis, trying to decide between all of these different ideas. These are great additional goals; yes, you should consider these at some point. But that point should be later. Imo, when all you've done is go through a book, your next step has to be creating your own program: opening up a terminal and a text editor and getting to work.
I had come across a few mentions of that when searching for an answer to my question before posting here. I have it bookmarked and planned to check it out before diving into anything beyond ruby. I did not however know that I should look into it before rails so thats a good tidbit, and thank you for that! I also got a recommendation from a friend of mine who works in the field to check out FreeCodeCamp and that it would be a good place to move into for developing the skills. Unfortunately out of all of my close friends and acquaintances who work in the field or have compsci degrees none of them have ruby experience, but fortunately, it seems I have the wonderful community here to turn to!
Are you sure that's what you really want? That's not the typical word-wrapping algorithm. Usually you don't want to blindly accept whatever word is at the end. Instead you want to put a word on the new line if it goes over the line character limit.
Since no one has said it yet, go find a popular gem or two, go to GitHub, grab their source, and just read it. You'll hit language constructs you've never seen, be able to look at how unit and acceptance testing are done, get a feel for the flavor of the language. The reason I suggest gems vs. other projects is that gems tend to have a narrower focus, and tend to be more polished/documented/tested than say a big open-source e-commerce platform. Best of luck!
Taught myself ruby/programming last year. I'll echo the gem idea. Look up the awesome-ruby list. Find 3-4 things you think are interest or spark a project idea. Setup and customize each of those projects. When an area seems confusing or you want to expand even further, read the projects source code. This does two things. 1. It teaches you how to setup your environment, manage dependencies, and gets you reading Ruby. 2. You're exposed to different ruby design approaches and styles. This adds depth to your understanding. Some that come to mind: Lolcat: novelty command line parser. Fun and simple. Homebrew: write your own formula and learn how to manage system applications. SonicPi: creating music with code takes a certain creative thought that's sometimes lost on developers. Jekyll:. Simple website creation and hosting skills. Happy hunting.
Work through the logic. If ruby-version was set to an upreved ruby and a specific ruby lock was in the gemfile the error cascades experianced would have happened months ago when the author made the idiotic changes that conflicted with each other. More than likly the author did not bother setting .ruby-version, instead had a newer version of ruby installed via chruby and just ran forward with that version instead of configuring the proper version that was required and tested as listed in the Gemfile. 
Thanks for the amazing suggestion here. I doubt I ever would have stumbled across that idea myself haha
Ok, and just so I understand gems are just smaller chunks of code not like commands or I guess functions? obviously but programs that others have written? And thank you for the wish of luck!
ow did you solve it eventually? Got the same issue.
Gems are reusable mini-libraries that can provide anything from a single function to a full system like Rails, which is basically a set of gems bound together. You can find them listed at [RubyGems.org](https://rubygems.org/) Pick a small one, for example a gem I wrote to manage using constants as enumerated values: [iron-enum](https://github.com/irongaze/iron-enum) In a gem, the code lives in the /lib folder. Poke around, see what tricks are being played, look in the /spec folder for the RSpec-based unit tests. See if you can trace the execution flow. Watch how the code is structured. There's a lot to learn!
There are few quirks to character sets, like that... For example, normally in a (ruby) regex, `\b` means "word boundary". But if (and only if) placed within a character set (`[\b]`), it represents a [backspace character](https://en.wikipedia.org/wiki/Control_character#In_ASCII). Another quirk is that normally in a character set, `-` is used to dictate character ranges, e.g. `[a-z]`. Unless you escape it, *or* place the `-` at the start/end of the character set: `[-abc]`, `[a\-bc]`, `[abc-]`. Or another is that you can place character sets *within* character sets (giving them [an *implicit union*](http://www.rexegg.com/regex-class-operations.html#union)). So for example, `[ab[c]]` is (in ruby) equivalent to `[abc]`. Or yet another is that (although modern ruby will show a warning if you try this: `warning: character class has ']' without escape`) you can write `]` as the *first character* in a character set, without escaping it, and this will **not** close the group. I.e. `[]abc]` is equivalent to `[\]abc]`. If you place `]` later in the set, you'll see a slightly different warning: `regular expression has ']' without escape` - because the resulting regex is different. I.e. `[abc]]` is equivalent to `[abc]\]`, NOT `[abc\]]`. Regex get very complicated when you dig into it deeply :D [This library I wrote](https://github.com/tom-lord/regexp-examples) handles all of the above, and much much more. You can see some of my implementation for the above [here](https://github.com/tom-lord/regexp-examples/blob/7ae52785a6f5c9b266759d33881d9de409b50551/lib/regexp-examples/chargroup_parser.rb).
Follow the curriculum on Odin Project. It's what helped guide me to learning what I needed to get a job. I'm doing pretty well now - Ruby dev in a great team. Highly recommend. And it's free, so your only risk is time loss.
If it hasn't been done, then it is probably because Python and C-based languages may be more common in the research community.
Ok. That makes more sense. This is starting to seem daunting but hopefully once I get done going through my course I'll understand this a lot more before I dive in. 
This is great input. Thank you!
A separate project, [Bottled Water](https://github.com/confluentinc/bottledwater-pg), provides support for Postgres change capture.
Solved.
&gt; More than likly the author did not bother setting .ruby-version you can say that from every mistake outlined in the post. The real question is "why do I have to annotate the ruby version 2 times in two different unrelated places?". And yes, I'm aware that you can just `File.read('.ruby-version')` your way out of this situation. And if you're deploying using capistrano, you'll probably have to annotate your ruby version **again** in the capfile. It's just a drag. 
Many languages besides ruby support named capture groups. ^ $ \A \z have the same meaning in ruby as in many other languages, though not all.
&gt;I have to admit that your way is and should be the one true way. I've said this in this sub in the past and just get downvoted without comment. RVM and the like are so bizarre to me, but it's even more bizarre that people see them as a good thing and not a painful workaround to a non-existent problem. I agree that library developers need to test against multiple versions of ruby, but there are much better ways of solving that problem than with the methods utilized by these environment switchers. I forgot to mention that we run multiple (like 20) apps on the same vm/interpreter with Apache/Passenger doing the vhosting. I've only yesterday started messing with Docker and I used the official 'ruby' image. I saw people complaining about its size in the comments and someone else linked to another image that they said was lighter. I had to set BUNDLER_CONFIG in the env in order to get bundler to see/use my app/.bundle/config file in the official image, so I'll likely be looking elsewhere.
There is a pretty decent twitch gem, if you're able to use a gem for this sort of thing. It's called `kappa`. Here's some code I used at one point to do something similar: https://gist.github.com/thomasv314/81a5eeccfa1385fe685794f3b56ef07b
I'm trying to get a hold of someone within HeheStreams. Is there a good place to ask a question about re-subscribing, because I've tried every option (I can find) for almost a month, and haven't had any success with getting a response. Any help is appreciated, and I apologize for bothering you within this random comment thread.
Good article. In this part though: &gt;What that prior experience does bring though, is context. When my OS course was talking about the internal structure of processes and threads, I had an Aha! moment. I’ve been using these things for years, but knew how they worked. Does he mean to say, "didn't know how the worked"? Or am I misunderstanding what he's trying to say.
you can make an entity like RemoteUser or User or Post and separate methods for `index` vs `show`. which can call using the `client`. &gt; ``` class RemoteUser def index client.fetch('/users/', {latest: true}) end end ``` 
You mean like [ruby docs](http://ruby-doc.org/)?
The biggest thing for me is that an online degree requires resilience and perseverence. I had some great instructors but some were hell bent on making the online learning experience as frustrating as possible, including nitpicking APA formatting rather than the substance of the assignment itself. And my fellow students, especially when working in groups, were dumb as bricks. Ended up graduating in 6 semesters with my Master's.
I'd consider a more general book selection metaphor than just book IDs - what if your user wanted books published in 2007, or over a certain price? I'd also change :book_attributes to be :update (more clear, at least to me, what that hash does) and would allow say :return =&gt; [:amount, :price, :whatever] to allow returning the requested attributes or similar. Just some thoughts. :-)
That's a typo. I'll fix it.
seems reasonable. 
Personally, I prefer API wrappers that have classes for the various resources, so you can `User.get_users` or `user.get_posts` for instance. Those classes dispatch requests to a client class that isn't directly interacted with. Here's an [API gem I built for Strava](https://github.com/phoffer/strava), if you prefer seeing code example. It's not perfect, I wrote it because I wanted something more OO than the existing API gem.
Ruby-docs is great as far as it goes, but it feels like someone put together a site to get the Ruby docs online circa 2002, and has just been updating the version-specific content since then with no attention to design or supplemental material. I think OP was asking &gt; where's a one-stop site I can go to learn Ruby, that knows about and intelligently discusses the differences between their own and 'competing' platforms (Chrome/IE/Safari for Firefox; JRuby/Rubinius/mRuby for MRI), with not just truly exhaustive reference material, but tutorials and extended deep dives into everything from basics to some really esoteric details that you won't need 99.999% of the time, but when you *do* need them, you know where to find them? *That's* what MDN is, and I have yet to see a serious analogue for another language, *especially* Ruby. We can do better, but it'll take resources and effort (and therefore £$&amp;yen;) and coordination that nobody's *yet* stepped up for. Comparing Ruby-Docs to MDN is like comparing a [SPAD S.XIII](https://en.wikipedia.org/wiki/SPAD_S.XIII) to an F-15. Both entirely capable for their designed mission, but you wouldn't send one in place of the other.
I'd probably rename the action bulk_update so as not to confuse my future self. If things start to get messy in BooksController it's easy to refactor the bulk methods into their own class. It just depends on your preference absent other factors to sway the decision.
I'm not trying to be snarky, but have you tried any of the rules engines that come up when you google for it? If so, please mention how they don't meet your needs. Otherwise, those are my first recommendations.
Sounds like you might want to look at the "matcher" pattern, e.g. how the Mocha gem implements "parameter matchers".
Two libraries I have seen being used - 1. https://github.com/azach/rules 2. https://github.com/ulfurinn/wongi-engine
I think for the persistence thing, and online degree makes sense for someone that's already self taught. They're used to it. 
also: http://dry-rb.org/gems/dry-logic/
Very interesting article. FWIW, I'm doing a part-time BSc in Mathematics at a remote university now while still working full time. I can definitely echo some of the sentiments; I also have CS as a (small) minor and especially in the CS courses, it really does feel like professors don't know about industry practices. And yes, the grinding, unfortunately, and the focus on exams.
Couple of comments: - The author (Avdi Grimm) is definitely not a Ruby newbie, so when somebody so well known in the community points out deficiencies, we should listen to them - That said, some of these issues seem (to me) unavoidable given the complex systems that we have. When I first had to work on a python project, understanding how virtualenvs work (and the 300 different tools that you can use to manage them), how you have to use requirements.txt etc. didn't seem any simpler, in node.js people usually don't even specify the node version they're developing against, if you open up a Java project in the IDE, figuring out where you have to set the correct JDK version is not intuitive at all (I dare not even think about how to do this on the command line), etc. etc. I wonder if any language solved this in a better way. Setting up your test DB etc. seems to me to be even more complex in other languages than Ruby (unless you use something like sqlite or whatever). - That said, I would agree that the constant need for "bundle exec" is annoying. This should be baked in into Ruby - it should always execute things in the bundle context if a Gemfile is available, or something. I usually "solve" this issue by creating bundle binstubs and putting the binstub directory to the front of my path with [direnv](https://direnv.net/) - Having the .ruby-version and the Gemfile specify different Ruby versions is odd. Yes, it can technically happen since the version is duplicated (which, I agree, is not ideal), but I haven't seen that happen before - you cannot even run specs if you have this kind of mismatch, so I wonder how this situation happened in the first place. - some other things seem like project fuckups. Your specs should autoset the RACK_ENV for example. But yes, sometimes projects are in a bad shape. It happens. Don't know how this is specific to Ruby though. So yeah. Coming back to a poorly maintained project is painful; having to remember steps that you haven't used in a while (because you have been working on a different language? a different DB?) can be annoying (in the ideal case all these things are documented in the README). But I don't see it as avoidable; yes, you can technically put all the requirements in a Vagrantfile or Dockerfile or so... but, personally, I haven't ever seen this work reliably either, so whatever.
&gt; a painful workaround to a non-existent problem. I don't see how this is a "non-existent problem". You have, say, 200 applications. You want to upgrade to a new Ruby version (because of new features, because the support is running out, whatever). But it's unfeasible to switch over all applications at the same time. So you have to be able to develop some applications with the new Ruby version while keeping the old version for all the rest. There might be other reasons why different applications might require different Ruby versions. I don't understand how this is "a non-existent problem". I disagree about downvoting (with or without comment), but I wouldn't recommend your way of doing things. That said, I might be wrong or have a totally different situation that you do, so as always YMMV.
Cool article Appaloosa :) :jve_coucou:
&gt;have a totally different situation Yea, that's likely. I have some biases that are inherent in my line of thinking and my broad generalization is just as bad as the "ALWAYS USE RVM" mantra I see repeated so many times. Sorry about that. Thanks for your response. A better solution might be something like Docker. It provides a lot of benefits around isolation and version management that don't -- to me anyway -- seem quite so hacky and glib. Having said *that*, I'm a babe in the woods when it comes to Docker, so I might be completely full of shit, again.
Thanks, that was exactly what I meant. MDN is a great resource, perhaps the golden standard. 
It used to work back in Rspec 2, but there's issues with it: https://github.com/rspec/rspec-core/pull/857 but it's kinda confusing to do both they 'kinda' accomplish the same thing, but do it differently. Have you considered trying to use before(:each) instead? or are you trying to use before(:all) to "create the user only once" for a set of tests for efficiency? If that's the case , couldn't you do: let(:user) { create_user('Joe') }
I didn't know about "build_stubbed", cool. Also would not have predicted that logging would be such a time sink. 
ruby-docs is the closest analog to MDN for ruby I know of. I agree it could be better. I think ruby documentation (at least English-language) in general got sort of a handicap out of the gate because most of the core ruby devs were Japanese with limited English at the time. 
That's actually I think by design now. Here's the error message I'm getting: `let` and `subject` declarations are not intended to be called in a `before(:context)` hook, as they exist to define state that is reset between each example, while `before(:context)` exists to define state that is shared across examples in an example group. I can do as you mentioned, but I was checking couple of articles online and I was mentioned `before` should be used for ACTIONS where `let` is more of a state. In reality, the `before` method doing couple of things. Doing couple of actions inside `let` block feel un-natural? 
While docker sounds nice in theory, in practice I've found that it sometimes works (I've used it successfully for some heavier-weight things, like an XMPP server, where having to install all the requirements manually would have been insane), but sometimes also doesn't and brings its own sorts of complexities and problems (like breaking changes between docker versions, needing to understand how to work with filesystems and databases in a containerised setup, etc.), so... not sure it's always the best solution. In a lot of cases you'd probably also have to rearchitecture some things. But I also lack substantial experience with it.
sounds like a good approach to me. depending on how big the class get, you can always delegate some calls out to helper classes, but keep one gateway class as an entrypoint. I personally prefer this approach to mixing in the API logic with the domain logic as suggested in some other answers.
Yes big surprise for us. If you watch the conf I mention you will see very interesting result with FactoryProf.
Ooo I'm going to check this out. I currently use the other gem for my project, which I do not love.
[Here](https://github.com/LawKick/client_success_ruby_client) is an API wrapper I made for work. It tracks the pattern you describe -- the OpenApi acts as a surface area for accessing different areas of the Api. Those areas are broken into modules with logic relating to those requests. 
The Odin project
Oh cool! Let me know if you have any questions or would like any improvements! I tried to design it to be nice to use. It's annoying that Strava doesn't have a sandbox to use, so I could have some tests and real example usages. There are still some things to implement (mostly updating resources), but I'd be willing to add those if you want. I'd love if you had any feedback on the samples and README, it's a bit long but I try to explain some Strava concepts and also some of how the gem operates. It obviously makes sense to me but not necessarily to others. I will note, between me building it and actually committing/publishing, the other gem added some features, so there's more feature parity than when I started. Lastly, the other gem is fine but I really just don't care for the client centric pattern.
&gt; API gem I built for Strava Your gem looks pretty neat. As a runner, I wouldn't mind helping out with it. I saw your note on hitting their API preventing you from really testing. I could help write specs and setup VCR if you're interested! 
I'd love some help with it! I'd be interested in testing, but I do not plan on having any personal data (mine or anyone else's) in the tests. Therefore, even solutions like VCR (which is great, we use it at my job quite a bit), don't really fit well for testing. In theory, using VCR and then manually modifying the data would be possible, but I'm not sure it's worth the effort, since it would break if a cassette needed to be updated. So any ideas around that would be appreciated. I basically decided there wasn't a simple solution and then moved on. In a perfect world, they'd have a sandbox user that returned the same sample data that their API docs use. Also-- if you would just read through the README and maybe play around with it a little, feedback on the README and usability would be awesome!
I always joked with our test engineers about speeding up the test suite. Instead of using multiple cores and threads to run tests in parallel or improving the factory configurations, just delete the whole suite and you go from 30 minutes to 1 in one rm command. You just gotta keep it simple. 
somthing were you can show off your work to a small to nonexistant community
Your test suite would still take an entire minute even if you deleted it all? :O
Jenkins had to initialize something in order for it to give the go-ahead. =)
I would just put the `let` in each test. That, IMO, isn't the kind of code that you should worry about centralizing-- in unit tests, I try to keep the code as obvious as possible.
Me neither. Very niiiiice!
Excellent article.
You can also use the bang version of `let`, `let!` to eagerly evaluate for each test. I tend to use it where I might previously have used a `before` block. let(:some_name) { Faker.name } let!(:user) { create_user some_name } 
There's no best book and each book will add something, learnrubythehardway (the web site) is useful too - it's all abaout what works best for you
If you have a programming background I think the official Ruby docs are the best of any language I've seen. Just look down the sidebar of all the methods of the std lib objects. 
Just go with what you got. Even if it's out of date if you are just learning ruby and not rails you should be just fine.
I am a huge fan of Chris Pine's _Learn to Program._ It's the first programming book I ever picked up, after trying to learn online and not making any progress for a very long time. Some of the reviews on Amazon say it takes a leap into advanced-concepts-without-sufficient-explanation about halfway through, but I thought it was just the right balance between hand-holding and challenging.
If you do this in an ordinary `before do`, which means the same thing as `before(:each)`, I believe it'll work. Yes, it means the `create_user` will be done before every test. But if you have db cleanup running that runs after each test, as most of us do, that's what you need to do anyway. `before(:all)` actually means "just do this once before the whole context", as opposed to `before(:each)`, which is the default `before`. This is a bit confusing, becuase the word "all" could be interpreted either way. 
You could perhaps build that "God" object, and when it starts to get big and complicated, you could break it up into separate modules for the dofferent types of classes that it interfaces with. 
[Learn Ruby the Hard Way](https://learnrubythehardway.org/) 
Jenkin's whole preamble was a great chunk of our build times at one point. To be fair I was putting all manner of unholy nonsense up the poor man's pipeline, but that was no reason to take it's time with it.
I'd suggest using .update_all (https://apidock.com/rails/ActiveRecord/Relation/update_all) When using .update on N records you will get N-SELECT and N-UPDATE queries while with update_all you will get only two queries: SELECT and UPDATE. 
Omg,did you say bootstrap? In the default gemfile? This just shows the failure of capitalism in a diverse society. 
Definitely **The Well Grounded Rubyist**
Pickaxe 
Your solution doesn't actually handle returning several pieces.
IMO, the best advice for people in your situation is to pick whatever you have at hand and just _start_. Also, don't limit yourself to read, play with the language in the REPL, don't be afraid to make mistakes, and have fun.
&gt; But I think Ruby is very unique to that isn't it? [No](http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html).
It seems like service interfaces come in two flavors: client/server (synchronous request/response) and producer/consumer (messages over a durable queue). From a CAP theorem perspective, it seems clear that the producer/consumer approach offers much better availability, without sacrificing consistency -- as long as the working state for any operation carried out by a service remains within the service boundary. Localizing transaction state is a good idea anyways, since it's just encapsulation from OO. There's a reason actors are gaining traction; distributed objects will always be utterly broken, but distributed messaging isn't. gRPC, and by extension, this library, seems like a fantastic way to build an API on top of a producer/consumer (or pub/sub) approach to inter-service communication. As mentioned in the post, it can greatly reduce the cost of building language specific client libraries, and it offers a published contract (i.e. IDL) so that different teams or even organizations can integrate with the service without needing to communicate. Gruf looks like it can offer benefits under certain circumstances, but I'll offer the same caveat I always offer when request/response is introduced to service messaging: any SOA built on a client/server model of inter-service communication is standing on shaky grounds. You can layer request/response on top of producer/consumer easily enough, but the reverse isn't true at all, so buyer beware.
It's a good practice to create a wrapper over an API. If the API could potentially be changed out for another one, then it might be worth creating a protocol and a delegator.
How does your salary compare to others? Is that job offer fair? Does a candidate have reasonable pay expectations? Take this survey and let's find out together! After you've taken the survey, I'd really appreciate if you could share with your networks so that we get even more diversity in our responses.
For beginners, it seems like a reference book.
Most people in the US making 60-120k? That's practically poverty in many major cities. 
I found [this](https://www.tutorialspoint.com/ruby/index.htm) site, it's a little better than ruby-doc.org
You're getting downvoted. You might want to clarify your comment. Are you being sarcastic? Trying to make a joke maybe? I'm not quite sure.
No, definitely serious when it comes to major cities with higher cost of living. I'm sure that salary is "fine" if you live in a very cheap area, but that is basically broke in any major area. 
Eh, family of 4 at 60k is on the poorer end, but not bad for single. 120k should be a comfortable wage just about anywhere for single and will feel outright rich away from the most expensive 4-5 metros. It should be more than sufficient for family of 4 in most locations too. In fact, that sets you easily in the upper-middle class as a family.
The Odin project is a good place to look. Soft through their curriculum and you'll find things that they offer, and the code examples of people who have completed the projects previously
~70% of people in the US make less than 60K. 88% make less than $100K. 92% make less than $120K. If you make more than $120K, you make more than 92% of Americans. If that's "practically poverty", then 92% of Americans are in practical poverty. Which may be, but it would mean those not in "practical poverty" are a small elite. (And btw 80% of Americans live in urban areas, it's not that all those people are not living in urban areas. The median income in urban areas is only about 4% higher than in rural areas, that's it.). 
[This is cool!](https://www.theodinproject.com/) Thanks! 
Is it intentional that you can't take the survey without being logged into a google account? &gt; Sign in to your Google account to fill out this form &gt; This form contains features which require sign in. Your identity will not be revealed.
&gt; If that's "practically poverty", then 92% of Americans are in practical poverty. Which may be, but it would mean those not in "practical poverty" are a small elite. I agree. There isn't a middle class anymore by quality of life.
this is very cool too: http://exercism.io/
This is required if they're using Google forms and limiting responses to one per person.
ITT: Murrica problems 
Didn't know about this site. Thanks a lot !.
Latest commit 4 years ago?
Sadly, I have not found one that I like. I'm probably going to build my own. At least, not one that I can easily snap on to an existing project. 
Here's a playlist from a guy who wanted to learn Ruby on Rails. He made 12 different apps in 12 weeks, and has a screen capture for building each one. https://www.youtube.com/playlist?list=PL23ZvcdS3XPLNdRYB_QyomQsShx59tpc- Examples: - How to build a Reddit clone - How to build a blog - How to build a todo app - ... It's maybe more complex than what you're looking for (and he could definitely have explained more about what he's doing while he's doing it), but it's a pretty cool resource to learn from - if not now, then later on in your learning journey. 
Lol, and the original developer made it for educational purposes. I wonder if there's a bit that just randomly posts github repos. The title is the first sentence anyways...
You could build an engine for practice perhaps? 
Well, the Odin project will actually teach you rails, as opposed to ruby the hard way which will teach you ruby....
Ok, sure. I'm wondering if Ruby the Hard Way + [xyz Rails course] is a better way than Odin - maybe someone here has an experience or insight about it.
Wooo... didn't notice that. Fuck that noise. I don't mind filling out a survey anonymously, but fuck them if they're looking for confidential personal information that they can tie to a persistent online/offline identity. That's as sketchy as fuck.
&gt; I'm currently looking for a list of simple ruby programs to write Have you seen the [Ruby Quiz](http://rubyquiz.com/)?
Jekyll?
I'm gonna be that guy and say it all depends on the person. Some people learn better with a book, an online course that walks you through a bit more than a book, and some with videos. To learn Rails you need Ruby but I'm living proof that you can do both at the same time. It's been a while since I've looked at the Odin Project but it was solid when I last did some of it. I'd suggest taking a stab at it and seeing how it goes. Maybe supplement with the book when you're away from your computer. For accomplishing particular things and learning good habits, both GoRails and DriftingRuby are excellent resources. RailsCasts used to be the goto in the community and still has a lot of great info but not always up to date. The concepts are still valid though and often the code will work with minor tweaking. Lastly, Slack is a great place to get help. GoRails has a slack channel for site members and there's a few others for Rails as well. Google Rails Slack channel and you'll find some. Just don't be afraid to ask questions. We've all been at the beginning ourselves and Rails has a very friendly and welcoming community IMO. 
already saved it to favorites. However, what I'm looking for right now are pure Ruby programs, not RoR.
https://github.com/comfy/comfortable-mexican-sofa
&gt; Ruby Quiz Exactly what I was looking for. Also found the following book, which is compilation of quizzes https://pragprog.com/titles/fr_quiz/index.html
Middleman.
If you are a beginner to programming overall, I would focus on learning a language before learning a framework.
So Ruby, then Rails yes? AFAIK both the options from the question fit into this approach.
Cool, lots to check out here. Thanks! 
Yes. I did Hard Way years back. I hadn't heard of Odin Project until just now, but it looks like a good idea in the sense that it clearly outlines "what you need to know." Trigger warning: sports metaphor ahead. You can never practice the "fundamentals" enough. Your natural inclination is going to be to say, "Yes, yes, I know how to split strings, goddammit! Let's learn CSS!" No. String manipulation is so core to programming, it's like dribbling in basketball. To say "I am *capable of* dribbling" misses the point; you want to be *good* at it. To that end, reviewing the core Ruby documentation is time well-spent. Literally, go find the String documentation and learn every method. You'll forget what the more niche methods do, but that's totally fine. What you're really learning is how the methods are related to each other, which teaches you something about how the language designers-- elite programmers-- conceptualize the layout of the language itself. That's infinitely more valuable than CSS. So, recommendation: pick whatever you're going to pick, but devote a third of your practice time early on to reviewing the docs. Not just reading. Not just typing in their examples. When you say "I wonder...", don't just keep wondering. Test all those wonders out. 
I did both. The hard way series is fantastic. It was my very first programming resource and it taught me the fundamentals that I use on a every day basis. I cannot recommend it enough. Having said that, The Odin Project basically just points you to free available resources that introduce you to the world of web development. So HTML, CSS, Javascript, Ruby, and finally Rails. I would recommend, starting with the Odin project as it does a good job showing you how all of the different pieces fit. When it gets to the chapters on learning Ruby, that is when I would either replace the suggested resource with Learn Ruby The Hard Way, or do both. 
Plus staticman for user generated content. Static sites FTW.
I thought Spina looked nice.
I think this is a great course. The teachers are really good and you'll learn a lot more programming concepts than just Ruby. Its a ridiculously good deal. http://courses.rubylearning.org/catalog?new=true
Back in the 90s before the web had endless amounts of tutorials people learned to build things by hacking stuff together, they didn't spend month after month studying data structures. They learned the fundamentals and started playing with things. I had the same question recently and I realized since I just want to build something I think you're better off building things as soon as possible. I went through Chris Pine's Ruby book online and did all the exercises. And now I'm going through Learn Ruby the Hard Way. I think that's enough Ruby to learn Rails. Once I finish I'm going to jump into rails with Hartl's rails tutorial....build things while you are still hungry. You can study Ruby for years and never be an expert. So I guess the question is what is your motivation? Do you want to build things, or be a computer scientist? I think the key is to finish your tutorial, and not jump around. That's the benefit of going to school - you're forced to finish whatever track you started on. 
Ruby Koans are good practice.
I second Chris Pine's book. It's online, it's free and it's very well done. 100%. After that work thru Learn Ruby the Hard Way. Completing both of these should get you comfortable with Ruby. But whatever you start with - commit to finishing. Don't waste time jumping around. 
I was disappointed with the Ruby Docs. MDN for JavaScript is by far the best I've come across.
Haha, you've met a few book worms i guess. My motivation is building stuff, for sure, so your points are well received. I'm definitely in "learn the fundamentals" stage right now, so my question is pointed towards answering that, for that stage. Original question, put another way: *"What training will help me get through and past the basics stage most effectively and efficiently, so I know enough to tinker experiment and explore?"* I'll check out Chris Pine's book. I've heard a lot about it. Thanks for your thoughts.
https://en.m.wikipedia.org/wiki/Why%27s_(poignant)_Guide_to_Ruby Why Is why
**Why's (poignant) Guide to Ruby** why's (poignant) Guide to Ruby, sometimes called w(p)GtR or just "the poignant guide", is an introductory book to the Ruby programming language, written by why the lucky stiff. The book is distributed under the Creative Commons Attribution-ShareAlike license. The book is unusual among programming books in that it includes quite a lot of strange humor and narrative side tracks which are sometimes completely unrelated to the topic. Many motifs have become inside jokes in the Ruby community, such as references to the words "chunky bacon". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Non-Mobile link: https://en.wikipedia.org/wiki/Why%27s_(poignant)_Guide_to_Ruby *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^95812
If you want to get to building things with rails consider posting this question in r/rails and get some feedback from then guys doing it.
**Here's a sneak peek of /r/rails using the [top posts](https://np.reddit.com/r/rails/top/?sort=top&amp;t=year) of the year!** \#1: [Ryan Bates of Railscasts.com is getting married on Saturday. I'm going to speak at the reception. Do you have anything you'd like to share?](https://np.reddit.com/r/rails/comments/6ls2xn/ryan_bates_of_railscastscom_is_getting_married_on/) \#2: [19 Ruby on Rails Gems which Can Amaze](https://np.reddit.com/r/rails/comments/656fhc/19_ruby_on_rails_gems_which_can_amaze/) \#3: [My 'Learn Ruby on Rails' book now free on Google Play](https://np.reddit.com/r/rails/comments/5lqek4/my_learn_ruby_on_rails_book_now_free_on_google/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Nice approach. Thanks. Why would you prefer LRTHW over Odin for the Ruby part?
Do Ruby the hard way first. It's shorter than the Odin Project, which you can always do afterward.
I just really like the author Zed Shaw's approach with teaching you ruby. You build a text based game and it does a good job cementing the core programming concepts. I believe the Odin Project tells you to complete the Code Academy ruby courses. When I took those courses a couple years ago, I did not find them as thorough as LRTHW. It doesn't hurt to do both though, you will benefit in different ways from each resource.
Don't know of anything great. 
Why Why's?
Odin's curriculum fully encompasses start to finish what it takes to go from nothing to full stack programmer. It's a very nice program. 
I hope there are some good answers to this - never really found any. I have an immature project with big goals called [code connection](http://github.com/jemagee/code_connection/) that I could use some help (and motivation) with. Most of the people who expressed interest early on were javascript front end folk. I am motivated but often get paralyzed by what to do next, I have some ideas that would allow parallel working together, if that's such a thing - since it's in the beginning stages it needs a lot of foundation work to get to an MVP launch.
The person who created the form does not receive any identifying information about you other than what you enter into the form.
&gt; reviewing the core Ruby documentation is time well-spent I appreciate your saying that - it's something I've never seen addressed in all the intro tutorials I've started, but it seems like a really important ability to have to grow into an experienced/strong programmer. &gt; Literally, go find the String documentation and learn every method. You'll forget what the more niche methods do, but that's totally fine. What you're really learning is how the methods are related to each other, which teaches you something about how the language designers-- elite programmers-- conceptualize the layout of the language itself. That's infinitely more valuable than CSS. Would you recommend any other steps for learning the documentation? Like I said, never heard this goal of digging into documentation explained before, so would love to get an idea on how to approach it best. I get (and love) the hands-on, try-your-wonders-out-practically approach you suggested. I'm thinking I"ll keep a little journal/list with those wonders as I go along, then see what they can do. Any "milestone"-type goals/progression you'd suggest - like how you said to check out String documentation and learn the methods?
....but why?
Hmm. These are interesting questions. Unfortunately, like so many questions in programming, the answers are difficult to verbalize. I'm just going to talk, and the answers are going to be in there. Firstly, don't just do this with String, but don't do it with every fucking class, either. That's a waste of time. This fact is deceptively critical, actually. You need to learn what is and is not a waste of time. Problem: your intuitions vis-a-vis time wastage were developed in a world very unlike the world of information science. You progress toward goals, whether it's a road trip to Tuscon or learning Calculus, more directly. A friend of mine used to work at Geek Squad. He goes to this one guy's house to fix his computer. Takes him 15 minutes. The charge is $200. Guy says this is outrageous. $200 for 15 minutes of work? My buddy says, "You're not paying me for the 15 minutes. You're paying for the expertise that allowed me to do it in 15 minutes. If you tried to do it yourself, it would've taken you two weeks." You are building expertise. Generic programming expertise. ("Generic" has a positive connotation in programming. In the real world, it means bland. Here it means multi-use.) So when you go look at the Date class and see like four different styles of date output, each with its own method, don't learn exactly what each one is (waste of time), but do look and read the docs closely enough that you can confidently identify that fact. You want to be able to know exactly how much about the Date class you know. If there are methods out there doing things you don't know about, that's not good, but misunderstanding a method's purpose because you scanned too quickly is worse. Now you're operating on false information. That's kind of where the line is. If you only ever look for the method you need right this minute, you won't have a map of the language in your head. You won't know where things are. String, Integer, Array, Hash, and Enumerable are at the dead center of that map. When you've got those down, look at Class, Module, File, URI, and the aforementioned Date. This being your first time reading documentation, your first task will be to figure out what the little notations for method parameters mean. I myself brushed that off for too long, because it looks like gobbledygook, but you should not. Also, if the entry for a method has three different styles, then you have three different things to learn. The first is not the whole game. One thing I like to do is write my own, better examples than the ones they give in the docs. Like, if you look at String#insert, I don't like that example. I'd prefer a clearer connection between the number you're giving and what the output is. "----".insert 1, "+" # =&gt; "-+---" "----".insert 3, "+" # =&gt; "---+-" And I'd want an example with a number bigger than the string length. "----".insert 16, "+" IndexError: index 16 out of string ----- Can't think of any milestones at the moment, but I'll give it some thought and get back.
We couldn't find one either so built Rooftop CMS, a headless Wordpress, with excellent Ruby support. It's open source or we can host it for you. [https://www.rooftopcms.com/ruby](https://www.rooftopcms.com/ruby) 
Pick a gem that you use or find one that is related to a topic you're interested in, find its GitHub, look at the list of open issues, then try to make a pull request to fix it. Most gems are not so complicated that a "beginner-to-intermediate developer" couldn't help out. You would have more trouble finding a Rails project (as in an open-source website that uses Rails) to contribute to. They certainly exist, but find one you would care to contribute to and that would welcome your contribution may be difficult.
He is a genius, so the unorthodox method is actually super effective.
&gt; then try to make a pull request to fix it. It is much harder than it sounds now. You don't just have to find a gem, you have to understand how it works and how it has to be addressed. 
Try https://yourfirstpr.github.io/ and http://up-for-grabs.net/ - they list projects with issues that are good for people just getting involved.
thanks :)
Why hasn't anybody ported WordPress to rails yet 
I'm currently neck deep in my own project but sometimes it's great to shift gears and work on a second project so you stay fresh. I'm deff game to jump in on yours. Sounds like a fun project. I think the main thing is finding a project you'll enjoy working on and I think I'd be a good fit on yours. I commented on a couple of the open issues. :)
And that is a problem with many mature projects - the amount of time it takes to just research the history and learn everything can be VERY discouraging
The Odin project. I completed the Odin project in its entirety, and with some supplemental research and personal projects, I was able to land a rails internship and a full time back end Ruby job. You'll end up compiling a large portfolio of projects in the process and gain a good understanding of most of the tools you'll need to land a job. I would also recommend the MIT open courseware series for any and all CS subjects. They don't use Ruby, but the concepts are the same. If you have any questions about the Odin project, feel free to ask. I can't recommend it enough 
Which OS are you working on? And what steps did you follow?
Trust me anything worth contributing to won't have many low hanging fruit because they're low hanging anyone can fix or implement that fruit. 
I'm on the Mac. Followed the steps for Ruby 2.0 listed here: https://github.com/rubyide/vscode-ruby Then, for the hell of it, I also installed (which should be optional): rubocop ruby-lint reek fasterer debride Do I need a launch.json in each project directory?
I started with Mike Hartl's Rails Tutorial. He has a Ruby section, but I felt I didn't have enough of a foundation so I went and did the pragmatic programmers Ruby book. That helped tremendously and revisiting the Rails Tutorial afterwards was like looking at it from a whole new angle.
Bridge Troll is used to organize events that help women get into programming via teaching RoR. Check it out - https://github.com/railsbridge/bridge_troll - and contribute to a great cause!
https://community.c9.io/t/running-a-rails-app/1615 Does this help you at all?
That's the steps I initially followed. So I don't know why I'm getting the error :(
Try remove the '-' before '$IP' on ur startup command
Ohhh my god
Rofl
https://github.com/ReadyResponder/ReadyResponder is a great cause, fully open source, running in production, and also very beginner friendly
But that won't solve the problem I think? as the problem is me wanting the use a `let` variable inside a `before` block? The `let` will work anyhow inside each test? or am I'm missing something here? Thanks!
The code in `before` should actually be called just ONCE (therefore the `:all` flag). Using `let!` will create it over and over wont't it?
Uh, are you serious? I think if you're not working with advanced things like this at your job you probably don't have enough experience to make that statement. And if you are going to make it you should probably have some evidence to support it, though something makes me doubt that you have any. Don't listen to this guy.
Well, actually I don't want to run the `before` block every test. I guess I can, but as you mentioned - it will force me to use `truncate`. Creating the entry on the DB takes time, re-creating it every test, WILL make tests slower. I prefer to do it once, because - well, I only need to do it once :) Also, `database_cleaner` does not officially supports `Casandra`. I have to manually patch it up to work, and It's something I'm trying to avoid if I can. It's easier for me to just to use instance variable here and bypass this whole RSpec restriction. I was just wondering how other people do it as this seems to be a common scenario. 
I don't think you need more than what the github link tell. Yes, you need a launch.json on every project and make sure you set the proper [paths for debugging](http://i.imgur.com/8J5vPEs.png), VScode adds that file with default settings.
I think the most common scenario for using rspec is both avoiding `before(:all)` and cleaning up db after every spec. It does make things slower, but also ensures test isolation. Regardless, I think it is the most common scenario. I feel like I've seen some rspec docs suggesting it's best avoided, but I'm not finding it now. Anyway, that may be why you aren't finding much advice. 
What I was saying is that you don't need a `before` block at all. Either put the `create_user(user_name)` inside of each `it` OR, more in line with what, I think, most people do: let(:username} { 'joe'} let(:user} { create_user(username) } it '..' do login(user_name) end
The idea here is that each test gets a user factory (or model). Sharing the same instance of `user` would lead to side effects. If "test A" runs and that modifies the user, then "test B" runs it will share the now-modified version of the user. That's bad and will lead to confusion when tests fail randomly.
Oh, I see what you mean now. So people using let `let` instead of `before`. Well, I think most articles I was reading mention that `before` should be used for ACTIONS and `let` should be used for STATE only, but I believe using `let` for action, is still better then using instance variable. Thanks!
Well, perhaps I should be having another look into it. I don't think `before(:all)` hurt test isolation, as it's just a pre-condition that should be in all the test suites and does not strictly effecting the test object (but need to be there and can't be mocked). I will give it a try. Thanks :)
In this context, the user factory/model _IS_ state for the test.
Yes it will run once per test case, but it will always run before each example. If you're trying to for example, ensure something has happened before you start asserting. I also allows you to set preconditions without having to trigger them in each spec. context "bang" do let!(:user) { create(:user) } describe "a user is created" do expect(Users.count).to eq 1 # Passes end end context "non-bang" do let(:user) { create(:user) } describe "a user is created?" do # Fails expect(Users.count).to eq 1 end end context "manually triggering" do let(:user) { create(:user) } describe "a user is created?" do # Passes user expect(Users.count).to eq 1 end end 
I definitely see your point. I don't think it _practically_ hurts test isolation when used carefully, but it "theoretically" does. If each test is run starting on an empty db, then the tests are neccesarily isolated with regard to state in the db. If a record is created with before(:all), and something included in a test mutates that record, then you may have accidentally effected test isolation. Obviously the existence and state of that record you created effects the test _somehow_, or you wouldn't need to create it! But the cost of setting up the db over and over before every test can be a lot to bear, if you can't keep it cheap. Nevertheless, for better or worse, I believe it is the most common practice. 
Fair enough, that's a good tip. As always, thank you jrochkind :)
That's a valid point :-) Thanks!
Oooo.... this looks interesting. Thanks! 
That's interesting. **There is no difference**... are you sure you didnt change other places of your code or the file? What was the error you got with the first version?
Thank you for your quick reply. My error was *"can't convert nil into String (TypeError)"*. I'm 90 % sure I didn't change anything else.
We've made it headless and written client gems which is pretty close :-) [https://www.rooftopcms.com/ruby](https://www.rooftopcms.com/ruby) 
Then it was the other 10% chance haha
There is none. You missed something. BTW: `str = File.read 'file.txt'` And don't use camelCase for anything else than class names in Ruby. We do underscores. 
Here's my two cents of advice. I'll assume you've haven't really programmed much. So, you'll probably wan't to learn how to program first. I'd suggest starting with [Programming for Beginners](https://leanpub.com/programming-for-beginners) and following that up with [Learning to Program](https://pragprog.com/book/ltp2/learn-to-program). Alright, you now know Ruby's syntax and some programming. Now it's time to practice solving some problems with [Exercises for Programmers](https://pragprog.com/book/bhwb/exercises-for-programmers), work through the first 8 chapters. Finally, if you feel ready, move on to [Ruby on Rails Tutorial](https://www.railstutorial.org).
I feel like the majority of these are not very useful one-liners. I was hoping for tricks like `unlimited = Hash.new { |h, k| h[k] = Hash.new(&amp;h.default_proc) }` for unlimited nested hashes.
Parentheses are optional for function arguments in Ruby, you could completely omit them and your code would still work
Start a webserver and serve all files from a given directory one liner: ruby -rwebrick -e "WEBrick::HTTPServer.new(:Port =&gt; ENV['PORT'], :DocumentRoot =&gt; ENV['HOME']).start" 
What do you mean by the searchable block? I typically do searches in the controller using Postgres ILIKE.
If you want to have a search method/scope for all your models, then you can define it in ApplicationRecord. That was added to allow you to customize all models easily, similar to how ApplicationController is used for app wide controller helpers. 
Were you by any chance trying to pass nil to read? That's the only thing I can think of. Otherwise, you definitely had some issues elsewhere in the code. 
There is one situation in which there would be a difference, and that's if there was a variable with the same name as the method: def foo; 1; end foo = 2 foo # =&gt; 2 foo() # =&gt; 1 However in Ruby there aren't really object properties as in, say, Javascript, so `smallFile.read` is surely a method call. 
Well. I learned it at university, but here are some good resources. http://railsforzombies.org/ . very basic. For more in-depth learning i prefer https://teamtreehouse.com 25usd per month but very awesome guides. there is pure ruby course and complete ruby and ruby on rails track
And here I thought I'd see "Hey baby, I'm ready to bundle your gems."
Have your friend start off with [Programming for Beginners](https://leanpub.com/programming-for-beginners). Follow that up with [Learn to Program](https://pragprog.com/book/ltp2/learn-to-program). Consider picking up [Exercises for Programmers](https://pragprog.com/book/bhwb/exercises-for-programmers) after finishing the first two books. Edit: Outline https://gist.github.com/rby90/8988664a8b41b7ee251681aada4a4d6d
`ruby -run -e httpd . -p 5000` also works well for this
Start with [Codeacademy](https://www.codecademy.com/). This should teach all the basic concepts of programming in Ruby. It's also a bit gamified, so it can be fun. Then do the [Learn Ruby the Hard Way](https://learnrubythehardway.org/book/). Then I would try to do [Rubymonk](https://rubymonk.com/). All of these resources are free. You might also want to learn some command line first. I think the Learn Enough website has a free course on it. It also has the Michael Hartl Rails tutorial if you want to do that. The one thing I will say is that Ruby is really easy at first. I've been programming in it for a few years and am competent. However, it's super powerful if you dig deeply into it, which a lot of programmers tend not to do. The suggestions I mentioned above are for straight Ruby, not Rails. I think it's better to learn Ruby first. 
Wow, that's really cool. I had no idea about `require 'un'` For anyone else wondering, the reason this script works is `-r` requires the library so `-run` is the same as `require 'un'` and that has a method `httpd` that does this exact thing https://github.com/ruby/ruby/blob/84d83482c8ba1b8e7002ed8ff4c6a2c00fa4ce62/lib/un.rb
http://rubykoans.com/
I have a project called fuitter which converts fb page to website and currenlty as I am busy at my day job , I am unable to work on it. It would be great if you could contribute to it :) https://github.com/sushant12/fuitter
As some others said before I would first suggest something like http://tryruby.org/levels/1/challenges/0 and then https://learnrubythehardway.org/book/. I think these are good resources to learn Ruby. And you are right, Ruby is definitely a nice choice to start with!
I loved doing these when I learnt Ruby.
A book called [Ruby Under a Microscope](https://www.amazon.com/Ruby-Under-Microscope-Illustrated-Internals/dp/1593275277) is a great start to learning about the MRI internals.
They are different. The Odin Project is a complete path to web development. Learn Ruby The Hard Way is a path to know enough Ruby to start doing some small programs on your own. As you are interested in web development, then The Odin Project. By the way, in The Odin Project you also have to do Learn Ruby The Hard Way at some point (it's included in the curriculum).
For those who haven't seen this before, it's called [autovivification](https://en.wikipedia.org/wiki/Autovivification#Ruby).
**Autovivification: Ruby** Ruby hashes can take a block specifying an object to be returned for non-existing indexes. These can be used to implement autovivificious maps. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
When we are at it: There is a second situation and that is calling `super`. Just `super` calls the super method with _all_ the arguments and `super()` with none.
That's odd, actually. Just checked. The code you provided works as expected. I'm using ruby 2.4.1 (a bit modified) version of the code I'm running: class C def step a, b, c [a, b, c] end end def process # something a = 5 b = 6 c = 7 yield(a, b, c) if block_given? end c = C.new print(process(&amp;c.method(:step))) The output is pretty much what you'd expect: ─$ ruby test.rb [5, 6, 7] My guess: this chunk of code is not the problem. UPD: formatting
Me too. They introduce Ruby and testing simultaneously, which I think is useful. Coming from PHP, testing wasn't talked about much. 
You are correct, this piece of code was not the problem :/ That's what I get for oversimplification without actually testing it. In my actual code the `process` takes more arguments and call looked like process(from, to) &amp;c.method(:step) That was based on my assumption that I can just replace the block with the `&amp;c...` part. When I change it to process(from, to, &amp;c.method(:step)) it starts to work as expected. So thank you, you solved it for me :) The part that is interesting though, ruby didn't produce any warning or error in my original code. I wonder what it tried to do with it. 
If your doing searches on multiple models but not all, I would check out `concerns` and include them or create your own abstraction class like `UserModel &lt; SearchModel`. 
`let` creates a new instance each test though. If your going to use the same attributes for a model in a `context`, I prefer not to repeat that code. For reference: https://relishapp.com/rspec/rspec-core/v/2-5/docs/helper-methods/let-and-let
Is there still a possibility to join the mailing list?
Alternatively, you can call it with a `do...end` or `{}` block. def calculation(a, b) yield(a, b) end puts calculation(5, 6) { |a, b| a + b } # addition puts calculation(5, 6) { |a, b| a - b } # subtraction Source: http://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/18-blocks/lessons/54-yield
&gt; process(from, to) &amp;c.method(:step) it's doing this: a = process(from, to) b = c.method(:step) a &amp; b Where `&amp;` is the operator that provides a bitwise and on numbers (e.g. `(16 + 8 + 4 + 2 + 1) &amp; 35` evaluates to `3`)
Sounds like the file didn't exist the first time you did it.
Hello, I’ve updated the [/football.json](https://github.com/opendatajson/football.json) repo /service that offers (auto-)generated match schedules (fixtures and results) and club listings for the major football leagues e.g. English Premier League, Deutsche Bundesliga, Primera División, Italian Seria A, etc. See the [2017-18 season folder](https://github.com/opendatajson/football.json/tree/master/2017-18) for (static) JSON examples. No API key required ;-) All data public domain. Enjoy the beautiful game. Cheers. PS: Ruby works great for generating JSON; see the [json.rb script](https://github.com/yorobot/football.db/blob/master/scripts/up/json.rb) for the code.
Ah yes, the "I've been staring at this for 20 @*&amp;$%! minutes and I missed *that*?!" moment.
Maybe years back. Now I rarely miss phpunit in libs/projects. 
That's a good sign. I don't do much PHP now. 
True. I do cause of work. I still prefer Ruby for all my freelancing and private projects tho.
I used to always manually sort my Gemfile alphabetically. Then one day I ran in to this issue where two gems had to be in a certain order which was not alphabetical. It had something to do with rails mongoid and something else. So it may look nicer, but you may also run in to some issues. 
Thanks for the comment Jeremy. Do you happen to know which gems need to be in a particular order? Maybe we can skip sorting those so people would avoid issues early on :)
I don't remember exactly other than it had to do with mongoid. Basically, since the Gemfile will auto "require" the gems by default, if you have one gem that depends on another at require time, then that gem has to come first. If a gem can't be required unless Rails is already defined then rails would need to be required first. I like the idea of the sorting, but devs just need to be aware that there could potentially be issues. If you had a way to read all the gemspecs, you might be able to sort properly.
There aren't just two gems in the whole world that need to be in a particular order. I don't think hard-coding certain gem names in is probably the solution. Gems that extend other gems often need to be require'd after the gem they are extending. In a Rails app, gems are required in the order they are listed in the gem file (unless you put `require: false` and `require` them yourself elsewhere instead). I forget if bundler by default `require`s on gem load, I think it may not but Rails (and possibly other gem files) tell it to. 
&gt; If you had a way to read all the gemspecs, you might be able to sort properly. I guess, but only by trying to sort in dependency order instead of alphabetically! I don't think there will be any way to tell from a gemspec that order matters, just that if one gem depends on another, that other _might_ need to be loaded first. (But never vice versa? I think so? Unless there's a weird edge case?) Personally, I'm not interested in alphabetically sorting my gemfile. :)
I use what u define as "comment groups" allot but in that case it seems your plugin just provides an alias to :sort This got me thinking that it would be neat to generate and maintain these comment groups using the now defunct ruby toolbox tags
If you want quick results from small exercises, and immediate feedback, I second the tryruby website as well, as it introduces new concepts gradually. 
not saying this isn't ever an issue, but it shouldn't have to be, if gem authors properly included their dependencies in the gemspec.
This is a pretty useful pattern, it's the closest thing we have to a pipe method in ruby core, i think, e.g: [1].each &amp;method(:puts) # =&gt; prints 1 , returns [1] 1.tap &amp;method(:puts) # =&gt; prints 1, returns 1 # in ruby &gt; 2.5: 1.yield_self &amp;method(:puts) # =&gt; prints 1, returns nil Another handy thing is a curry / higher level function: def add(x) -&gt;(y) { x + y } end [1].map &amp;add(1) # =&gt; [2]
Go is a great language, but what does this have to do with Ruby?
Yeah, I should have added a bit of context. My executable/application was written in Ruby previously. I've ported it to a Golang binary (so my users can run it without needing a Ruby interpreter installed). This is a list of the things I learned while learning Golang, with a background in ruby and other dynamically typed languages. 
Totally agree. 
Depends. If its a CLI app, use a config file in `$XDG_CONFIG_HOME` (or `$HOME` or `~/.config/` if not set) with fallback to a file in `/etc`. If it's a tool à la Rubocop the config file would probably be relative to `$PWD` or some project root directory. If its something more like Rake/Guard, you'd configure it through an API (i.e. actual Ruby code). For data files you could use `$XDG_DATA_HOME`, `/usr/local/share/`, `/usr/share/`, or some other reliable directory. You'll have to provide more details on what your program is for better answers. What are these serialization files for? See [hier(7)](http://man7.org/linux/man-pages/man7/hier.7.html) and [XDG Base Dir Spec](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)
You don't want to put them in a special rvm directory, because not everyone uses rvm. I don't think there's any great way to do that with rubygems. I think editing the installed rubygems source in place is probably a bad idea. So, yeah, standard unix whatever. 
It might have slightly different behaviour, but RuboCop's OrderedGems cop can sort the Gemfile when run with the `--autocorrect` option. http://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Bundler/OrderedGems
Just putting that in file(s) in the home directory should suffice. Make a directory at one of: - `$XDG_CONFIG_HOME/name_of_app` &amp; `$XDG_DATA_HOME/name_of_app` - `~/.config/name_of_app` - `~/.name_of_app` to put your files in.
I'd also store downloaded files in `~/.cache/name_of_app/`.
[rubydoc.info](http://rubydoc.info/) provides Ruby documentation as well as docs for all released rubygems and even github repos.
This looks very interesting. thanks for sharing. Dota is a game like WoW right?
Dota 2 is the same genre as League of Legends. Also known as a MOBA (Multiplayer Online Battle Arena) game. 
I came to rails from Java and PHP about 7 years ago. Probably the trickiest part will be learning all the assumptions that Rails makes about how things are named and organized. This convention-over-configuration is great once you know it because every app is set up the same way, but it means you'll spend a lot of time looking for the right file. But if you're working in it every day the knowledge just soaks in. The other downside to that is that very few docs/resources/tutorials tell you why things arranged as they are, or what's going on behind the scenes to make it work. They just tell you what to type. I hope you'll be working with some other Rails devs as you learn - use the questions why and how a lot. Using an IDE like RubyMine can be a big help, giving you the ability to ctrl-click on class names and have it open the correct file. Plus full project text search and stuff like that. Best of luck. Feel free to ask followup questions.
Great stuff, thanks!
I use visual Studio code with the Ruby plug in, and it works great. F12 to peek class definition is awesome, coming from C# and intellisense it made me a little bit more happy devving in Ruby. 
Enumerable Ruby class is very powerful and easy to use. My personal favorite class
Thank you very much for the comment! Yes, it is a url shortening service. I purchased a book a while back, and it gives rough examples of how to code a url shortener, twitter, facebook, and one more. It doesn't walk you through testing, and I know I need to practice my testing. I'll get back to you once I've completed this part of the book or if I have anymore questions. Great advice, thank you. 
I also came from a C# background. The syntax was the weirdest thing to get used to at first. Use Rubymine. I personally prefer it even though I loved visual studio. You can also set up Rubymine to use visual studio keybinds (not recommended if you've jumped ship to a Mac). Use the Rubocop linter. It will guide you along the correct path. As an experienced Dev the last bit of advice you already know. Anything you don't understand Google, if Google isn't helping ask an experienced Dev on your team. Don't write bad Ruby code just because you were too afraid to ask where the right place to put it was or if there was a class or method to do that 6 line loop you wrote in one line. 
Get an upcase membership for a month or two and you'll be good to go
Damn, and I bought a pi to not have to dual boot. Very awesome. 
I really had to tune rubocop defaults a lot. Some of them are quite odd. Once I did it became a very valuable tool
Looking for any contributions/features in particular?
Oh thank jesus I don't have to make my own now. Time to make my website to make fun of my friend. Now I only there was an API to get me match data for CS:GO. 
Optional dependencies throw a wrench in this.
The following quote from Matz, the Ruby author, helped me the most out of everything I had to unlearn after programming for 20 years : Everyone has an individual background. Someone may come from Python, someone else may come from Perl, and they may be surprised by different aspects of the language. Then they come up to me and say, 'I was surprised by this feature of the language, so Ruby violates the principle of least surprise.' Wait. Wait. The principle of least surprise is not for you only. The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well. For example, I was a C++ programmer before I started designing Ruby. I programmed in C++ exclusively for two or three years. And after two years of C++ programming, it still surprises me.
My only issue with this is that it's done in Ruby. I'm thinking it may not matter since it's a simple thing but standard ls is written in C which is going to be about as fast as it can possibly be. Ruby isn't known for coming close to C performance. I love Ruby but I'm wondering if this would be better handled in a different language. Ideally as something that could be installed via Homebrew and Apt. 
And DHH announced 5.2 by the end of the year. ActiveStorage sounds pretty cool. 
Sound interesting, I was thinking about a similar feature. Whole motivation behind this gem is that I wanted to sort a Gemfile on my big Rails project and wanted to extract it to a gem :) It would be great if there would be more features, like grouping gems into named groups based on their use.
Wow, didn't know about that, I'll take a look! Thanks :) Have you tried it, is it any good? This gives me a bit of hope in this gem, if Rubocop is standing up for alphabetically sorted gems inside Gemfile then there's a reason to do it.
I should put somewhere in README that you should do bundle install with your new Gemfile to see if everything works :)
I feel what you're saying, but I haven't come across a case like this in while coding and adding gems to varios projects. I'd like ot wait and see if this really is a problem or not for some people. After all it's advised to do bundle install after you've ordered your Gemfile to see if something went wrong. Also, andyw8 pointed out that Rubocop has similar feature =&gt; http://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Bundler/OrderedGems
Wow. Solid answer. I really appreciate this and I'll get on it.
Nice. Glad to hear your path worked out for you. Thanks for the MIT OCW tip!
Since the release notes suck as usual, here's a quick summary of the "main" differences between `v5.1.2` and `v5.1.3rc3`: ## ActiveRecord: * `Relation#joins` is no longer affected by the target model's `current_scope`, with the exception of `unscoped`. * Previously, when building records using a `has_many :through` association, if the child records were deleted before the parent was saved, they would still be persisted. Now, if child records are deleted before the parent is saved on a `has_many :through` association, the child records will not be persisted. ## ActiveSupport: * Fix modulo operations involving durations # Pre-rails 5.1: 5.minutes % 2.minutes =&gt; 60 # Rails 5.1.0 - 5.1.2: 5.minutes % 2.minutes =&gt; -18000 minutes and 300 seconds (???!!!) # Now fixed properly in 5.1.3: 5.minutes % 2.minutes =&gt; 1 minute * Fix division where a duration is the denominator # Pre-rails 5.1: 60 / 1.minutes =&gt; 1 # Rails 5.1.0 - 5.1.2: 60 / 1.minutes =&gt; 60 minutes (???!!!) # Correct behaviour restored in 5.1.3: 60 / 1.minutes =&gt; 1 ## Railties: * Make Rails' test runner work better with minitest plugins - such as `pride` and `minitest-focus`. * Load environment file in `dbconsole` command. * Allow mounting the same engine several times in different locations. ...Or if you really prefer, feel free to [read each individual commit](https://github.com/rails/rails/compare/v5.1.2...v5.1.3.rc3).
Provocative. Way too provocative for my taste. Can't think of a case when you'd need to subclass an `action` though. Any examples?
Yep, fair enough, I didn't mean to critisize your effort. Lots of people are clearly interested. I'd be curious if anyone wants to explain why they want to alphabetize their Gemfile. 
Why not open a PR with a suggestion for a change instead of writing a bitchy blogpost? Hanami just reached 1.0. Were you around when Rails was 1.0? It had a lot of shit code and people made it better. Give Hanami some time (perhaps a couple of pull requests) and it will get better. 
"Because of this one thing Hanami is bad, but also rails is bad and I'm mad about how they're bad."
This is such clickbait. That headline is garbage and the article fails to defend the premise put forth by the title. The criticism around using `prepend` to control the return value of the `Action` is valid, even though it is complete bullshit as a comparison to rails magic. You can actually instantiate a `Hanami::Action`, go ahead and try instantiating a Rails controller. Take your time, I'll wait patiently. Anyways, an alternative interface could be a module level method on `Hanami::Action`. It would like this in a test: test "Response is successful" do response = Hanami::Action.call(action, params) assert(response[0] == 200) end `Hanami::Action.call` could take care of the web glue that is being prepended onto `Hanami::Action` instances via `Callable`. This is just one possible approach.
Forgive me for not understanding, but `prepend` is part of the language... what's wrong with using `prepend` if it achieves it's intended goal?
I use `prepend` from time to time and love it. However, I never use it in a way that allows return values of specialized methods to get ignored. A prepended method might _check_ that the return value of the specialized method meets some contract (in fact that can be a great use of `prepend`), or it might discard the return value entirely if the semantics of the method indicate that the method doesn't return a value at all. But it cannot take one useful return value from a specialized method and replace it with another useful return value. For a "command-pattern" oriented approach to the code, you'd have `.call` return nothing, and you'd _pass in_ a response object that the specialized action's `call` method operates upon. That's yet another approach to the problem that is valid.
I think the comments about the cycle of product maturity/developer attitude, are apt. The hot new thing won't be so hot and new as it matures and meets more use cases. 
That's... that's actually a pretty good summary of the article.
Off the top of my head, no, partially because I've never build a full-featured mature codebase built on Hanami, and partially because I'm not very smart. But it doesn't seem to be so much of a stretch to imagine that someone would want to do something along the lines of: class Create &lt; MyStandardBaseCreate include Web::Action def call(params) some_custom_thing_or_other super(params) end end It may not be pretty, and it may not be the Hanami way, but I don't think it's so outrageous that such an approach should be rendered impossible by the framework. As far as the provocativeness goes, well, any time I express an opinion on tech online I turn out to be wrong. So I might as well provoke some discussion when I express my opinions, so that that way I get to find out _why_ I'm wrong.
I agree that instantiating a Rails controller is hellish! I disagree that the article fails to defend the premise put forth by the title. If you look at the last paragraph, it does exactly and explicitly that. Of course, you have the right to assert that it doesn't defend the premise very _well_... I also like your suggestion for an alternative interface!
For me, the difficulty with `prepend` is that it does something unexpected, and it's hard to reason about unexpected things. [Code should be boring](http://thedailywtf.com/articles/Programming-Sucks!-Or-At-Least%2C-It-Ought-To-), and prepend is exciting. If it's the right tool for the job, though, fair enough, but it ought to be signposted. What's annoying for me about the code in question is that the use of `prepend` is buried inside framework code that the user of the framework doesn't get to see - all they get to see is the effects.
That's a very good question! Three reasons. First, I'm a terrible coder, and any PR I wrote would be so awful that even if the intentions behind it were good, people would be so put off by the execution they'd never notice. Second, my problem isn't with any particular line of code - it's with what seems to me to be an inconsistent ethos behind Hanami that gives rise to certain lines of code. A PR can't address an ethos. (To your point about Rails 1.0: I think Rails had such a clear and compelling philosophy behind it even in 1.0, and that gave people a _reason_ to fix the bad code.) Third, if my criticisms of Hanami are way off the mark for reasons I haven't spotted, writing a ~~bitchy~~ _provocative_ blog post and pointing a Ruby community at it will show me the error of my ways much faster than submitting a PR that will be largely ignored.
Thing is, there are plenty of seats at the webdev table. So we don't need new tools and new methods to unseat the old ones.
I have worked in Ruby for a long time and seen many people transition from Java/python/JavaScript/c. Some of the them have become exceptional developers and some of them have not. The main difference to my eye is that The ones who became exceptional learned to immerse themselves in Ruby. Just because A or B is the best way to do something in python doesn't make it the best way to do it in Ruby. Learn the language and adhere to it's norms and don't try and make it something it isn't and it's a wonderful language.
Inconsistent ethos? What? You include 1 (one!) example and extrapolate from that the entire ethos (whatever that means ?! we are talking about software) is sub par? What you are doing is not constructive, that's why I'm saying it's bitchy. Provocative would have been "here's a piece of code I don't like, here's my idea how to fix it" even if you don't include a PR. 
I utterly disagree that this isn't constructive. Look at the comments by /u/realntl - they've come up with a smart and succinct alternative interface (I'm more than happy for smarter people than me to come up with solutions like this) _and_ initiated a discussion on how to use `prepend` sensibly with /u/BoWild. That's... I mean that's literally what places like /r/ruby are _for_, no? This discussion _would not have happened_ if I hadn't kicked things off by stating an opinion for others to play with. Yes, I made a point extrapolating from one example. Because one example is all I needed in order to make my point. I'm sure someone could comb through the entire Hanami source code and enumerate every instance where they've strayed into magicky territory and could turn my argument into a lengthy dissertation with 12-page bibliography. But what _on earth_ would be the point?
When I first read the article, I thought about writing a comment on "this is pure bs." Changed my mind, though. I think I see your point. Or, at least, a part of it. Some programmers will indeed choose to use inheritance instead of (name a pattern you like), and they will fail. The *real* problem here is that they won't see what their mistake is. Exceptions will be useless, and docs do not cover the topic. And that is exactly what you (or anybody reading this) can change. Hanami docs are open-source. You can write docs on "How to reuse actions" and mention the dangers of inheritance. That would be AWESOME, I tells ya!
 &gt; This discussion would not have happened if I hadn't kicked things off by stating an opinion for others to play with. You can start a discussion without the flamebait title. It's called "constructive criticism."
Hey so out of curiosity what's your workflow - are you working on the Pi completely just to avoid windows? Or working on Windows and deploy to your Pi?
Hi! Are you starting totally from scratch, or do you know some programming already? If you're starting from nothing, I highly recommend Chris Pine's book Learn to Program, which is a primer on both programming and Ruby.
I always recommend Codecademy to start because it teaches syntax really quickly and efficiently...but leaves you hanging after that (I haven't been on it in a few years so maybe it's changed). Lynda.com had a good course a while ago called Ruby Essential training (not sure if it's been updated). Even if its outdated, a lot of the core Rubyisms are the same so it might not hurt to check it out. My preferred way to learn is with books. Courses have a hard time covering the depth that you can get in a book. The Well Grounded Rubyist is a good start, then check out the Pickaxe, Eloquent Ruby, and Practical Object Oriented Design in Ruby. At the end of the day, the most important thing is to actually use what you watch in videos and read about. Build things. Start with single file scripts and as you learn more about OOP and various gems, break things out and add more functionality.
Learned a bit of C++, but other than that totally from scratch... 
Cool. I did Learn to Program a few months ago and then moved onto the [Odin Project](https://www.theodinproject.com/), which is free and could use some improvements but hey, free. Code Academy is fine but the call-and-response interface didn't work for me. 
I always suggest starting with the lynda.com course on object oriented essentials - it's not a programming course but tries to lay out the basic principles of OOP and explain certain ideas (like APIE) without restricting them to a programming language - minimal code is provided as example but not for learning the code. Learn Ruby the Hardway (web site) is good Code Academy is Good Well Grounded Rubyist is Good Pickaxe Book is Good The best course is the one that works best for you 
Honestly, most websites **suck** at teaching programming. Books are almost always better for learning it.
Learn Ruby the Hard Way is a great resource https://learnrubythehardway.org/book/
This helped me. It's a great tutorial as it's step by step and detailed enough to know what to do. But unlike codeacademy you'll actually have to get ruby installed and working on your machine. So you'll write real code and run it. The author also has a sort of whimsical style of writing that is refreshing. https://learnrubythehardway.org/book/ 
&gt; I'd be curious if anyone wants to explain why they want to alphabetize their Gemfile. Minor OCD :D
Okay, Here is the list I would follow: **Basic**: - http://tryruby.org/ - Why's Poignant Guide to Ruby - Well-grounded Rubyist **Advanced**: - Refactoring Ruby - Design Patterns in Ruby **Extra**: - Ruby Koans - The Ruby Prog. Lang. By Matz 
Really good reading. Thanks for sharing.
Why's Poignant Guide is some of the most interesting reading, along with being a great Ruby tutorial. 
The only one I dislike is the "Use the return of the conditional for variable assignment" one. If you have a longish variable name or conditional it gives you very little room on the right side of your assignment for your expression.
I used books mostly, it's a long process when you want to learn something 'fully'. Be prepared for that. Videos can be helpful when concepts just aren't sticking. But I have to agree with some of the comments here, site like codecademy just aren't helpful for anything other than syntax. They can leave new students more frustrated than anything else. I found Well Grounded Rubyist to be a great resource, it covers OOP concepts as well. I used treehouse only for a little while because I found it never delved deeply enough. Why's poignant guide was an interesting read as well. I always gravitate to posts like this to learn about what has been working/not been working for most during their learning process. I am working on my own video series accompanied by a book and an exercise book. It will be free upon release, hopefully by the end of summer or early fall. Also in the works are versions for other languages. If you're interested I can send you the first version when I finish up. I'll be taking feedback directly from students and helping them wherever they become confused by my content. 
I use SublimeText/Atom and ConEmu on my Windows machine, I ssh to my Pi to run commands and code, WinSshfs manager to have windows pretend my Pi is just another drive on my Windows machine. 
Thanks for reading!
God that brick looks delicious
http://highscalability.com/blog/2012/10/4/linkedin-moved-from-rails-to-node-27-servers-cut-and-up-to-2.html maybe they were using webrick. 
I wouldn't be surprised if they were using something like thin which is actually single threaded. Also older versions of Rails had a locking middleware to prevent parallel execution via threads. Modern Rails works great with Threads.
Go order a pizza or something before you hurt yourself 😂
Posted this in another thread couple days ago. It is book based and should be followed in order. 1. [Programming for Beginners](https://leanpub.com/programming-for-beginners) 2. [Appendix A: Command Line Crash Course, Learn Ruby the Hard Way](https://learnrubythehardway.org/book/appendixa.html) 3. [Learn to Program](https://pragprog.com/book/ltp2/learn-to-program) 4. [Exercises for Programmers](https://pragprog.com/book/bhwb/exercises-for-programmers) Edit: fixed links.
The free introductory course at [Launch School](http://launchschool.com) is very good (and includes going through the excellent book by Chris Pine already mentioned in this thread).
Thailand!
nah webrick is better, node is only single-threaded /s
First bit of advice: learn how to search for answers. There's no way you'd be the first to ask this question, so...
Hello! We have [a particular place](https://discourse.hanamirb.org) for all ideas about hanami. You can write a new thread with your ideas or negative experience, and it will be constructive.
I started with Michael Hartl's Rails tutorial. Obviously it teaches rails rather than ruby but I learn quickly with practical applications. This quickly got me excited about Ruby and I learned a lot starting with his online book. I recommend it over Ruby tutorials as they are usually dry and contrived. 
&gt; I wouldn't be surprised if they were using something like thin Article mentions Mongrel. &gt; Modern Rails works great with Threads. Modern Rails came too late for them, apparently. The linked reply post also processes "often bloated up to 300mb of RAM each". He should see it now, 300mb, bloat, ahaha. 
Search bar is an amazing tool. But I learned pieces of rails first before I started really getting into actual Ruby. This was a poor way of doing things, but oh well. You should read a book or two, actually code the exercises in the books, and possibly add a little bit of your own flavor to those exercises. If you want to get into rails, the Odin project is great 
Mongrel, yikes. Those were dark days. &gt; any non-blocking approach would be a win Man, I remember that hype from 2012. Everything was "non-blocking" or "asynchronous".
Actually this strikes me as identical to the Bleacher Report case where they switched to Elixir/Phoenix. A full on rewrite can often yield huge performance improvements. But rewrites are only successfully sold to management when the blame is laid on the underlying language or runtime environment. A ruby to ruby rewrite would offer the same benefit IMO.
&gt; Mongrel, yikes. Those were dark days. Hey hey, no dissing the mogrel! It was absolutely awesome in its time. I think the mongrel ragel parser still lives as part of other servers.
Yes, from what Evan told me it was either the basis of the Puma parser or it's basically still the same one. There's a reason the parser lives on but not much else of it though, that was it's main innovation.
That's how I learned, but with lots of experimentation hours in the ruby console, and many more with practical work-related projects.
Do you publish the source code for your jekyll site?
Upvote for learn Ruby the hard way. 
Coraline Ehmke is a cancer in tech. A whiner, and a whinger. She needs to grow up and just get on with life. Get that stupid color out of her hair and act like an adult. She gets fired for being bitchy then blames it on others. What does she want now, 'intelligence shaming' to be a new hate crime? Needs a 'safe space' to be stupid? blargh.
I second this. 
A downvote (figuratively) for Learn Ruby the Hard Way. The author lacks a big picture understanding of where coding practices have come from, as evidenced by inane statements like this: &gt; Ruby programmers are very particular about how their for-loops are written and will declare you a bad programmer for simply using this one construct wrong. They went so far as to break the for-each version of looping so that there are problems with using it, forcing you to conform to their culture. Heed my warning that you should always use .each and never for-each for fear of being forever branded bad and shunned. Yes, it is as ridiculous as it sounds. This is an infantile and petulant explanation of Ruby's (and increasingly all new languages) preference for looping metaphors other than for-each. The authors do a disservice to the spirit of the language and community simply because they can't change their perspective.
John Elders intro to Ruby on udemy helped me a lot. He begins by not using technical jargon and introduces terminologies as he goes, breaking down technical with down to earth analogy.
I wonder if I could sue Google by claiming not hiring me was a hate crime.
We need to stop listening to the toxic ideology of this asshole. The idea that we should promote less competent people in front of more competent people because they belong to some ethnic or sexual trait is abhorrent. BTW why is everybody crying about diversity when it comes to women or trans people but not muslims, or Palestinians or mexicans, or scientologists, or left handed people or redheads and such. What if I made a rule that said for every Jewish person on your team you should have a Palestinian. How would you feel about that? Why are some minorities also judged to be more worthy than others. 
Hi all, Hanami creator here. It's not a mistery that I don't like Rails anymore, but I never dreamed to "unset" it with Hanami. I prefer to think at the code and offer a set of solutions that makes sense for me, for the team, and for the community. This leads us to the article, which is click-baity. The success of Hanami doesn't depend on a single interface, which works very well FWIW. For each feature we have to balance usefulness, extendibility, testability, because it's not just the code that matters, but how it "feels" to the people that look at it. Being unnecessarily verbose in the actions, like the article suggests, is a price to pay in terms of "ergonomics of the code". We simply assume that a response is successful if you don't specify otherwise. Conventions, right? 😉 The raising fear of Hanami is a good sign, because we're keeping the discussion on against the Rails monoculture.
Very handy for large apps! :thumbsup:
&gt; it turns out it has just as much annoying magic as Rails No, it does not. It doesn't even come close to the amount of magic that Rails has.
I challenge you to build a web framework using boring code. Seriously, good luck. The nature of libraries, and especially frameworks, is that they must use slightly more advanced programming techniques in order to provide good UX. It *especially applies to Ruby*, as we've created an entire generation of programmers who will not use a library if its API is too verbose.
Really nice reading! Thank you for the post /u/schneems
When I install a gem or any kind of software, I expect it to work as described and I don't care what the author does in the bedroom. That's all there is to it. 
What does this have to do with ruby?
Couldn't find a perfect time for this. TI7 almost started. Well done.
TL;DR Meritocracy is bad because the author prefers a caste system based on perceived victimhood points.
&gt; In the Ruby world, we insist that “Matz Is Nice And So We Are Nice,” [ignoring the sexist statements](https://twitter.com/yukihiro_matz/status/380394450746216448) he has made with regard to diversity outreach efforts. - from the article
I'm trying to go OpenSource more and more, but I find it difficult to gain interest even with a good project. Well, good, It's up to you, tell me if you find this useful and if I should continue the development. How do you manage to grow an OpenSource project without a full team of dev like the one in your company, I am alone and cannot afford to allocate too much time to each OpenSource project. Tell me in the comments :)
What does that have to do with Ruby? BTW anybody who calls Matz sexist because of that is insane. I mean mentally incapable of having rational thought. The programming community needs to evict this insane asshole from itself. She is toxic and hostile attacks anybody who says anything she doesn't like.
I came from .NET to Ruby, and for me the big realisation was that there is more coherent Ruby community, and you'll do better if you understand and embrace the community's way of thinking. A great place to start: Grok https://github.com/bbatsov/ruby-style-guide
Since replacing Webrick with Puma is as easy as adding it to Gemfile, I'd go with Puma. That being said - yes, overengineering is never good - you don't use a cannon (Passenger) for a fly (personal blog). 
If you're looking for static hosting that let's you enforce SSL, you might want to look at Firebase. It has everything it needs. SSL, redirects, CDN and CLI tool - everything on free tier. You must serve a lot data or store a lot of websites for any costs to kick in. 
Welp, the community has spoken: The article is bitchy clickbait. I have now substantially revised it to address some of the criticisms levelled here, and my apologies to anyone who was offended. I wanted to write an article about the dynamics of the Ruby web ecosystem, not have a dig at some Hanami code. I missed the mark.
I was under the assumption that WEBrick processed requests synchronously, and that you should always switch to a more performant webserver (such as thin or puma) in production. Maybe this isn't an issue until you hit a certain number of concurrent users.
&gt;@rubyconf is not a tool to solve our social problem. I can't believe he said that. I mean that's the most sexist thing I've ever heard.
Jekyll manually uses WEBrick instead of using a rack handler like Rails. While it's not that difficult to swap in Puma, it's more than changing a Gemfile.
There's so much pointless vitriol in LRtHW.
That's what upvotes are for.
WEBrick uses threads for concurrency. I got it to process 101 concurrent requests at the same time on my local machine. Puma is a good choice for concurrency. Thin is not concurrent at all and may actually be slower than WEBrick depending on your workload.
Right here https://github.com/schneems/schneems
I could have also proxied my Heroku site behind cloudflare with a simple DNS change. It was more fun this way ;)
I've always known WEBrick was pretty fast, and honestly wasn't quite sure why it wasn't considered fit for production -- and still am not sure! But it's not performance, I don't think. Although I wonder if it wouldn't perform quite so well with a Rails app as it does just fronting for middleman. Not sure what would make a difference, but something might. I guess it's probably missing some features you might want serving Rails. Streaming responses?
Really cool. I would be honored actually 
Back in the day Rails wasn't threadsafe so putting it behind WEBrick would mean it cannot handle concurrent requests &amp; it would be SLOW. Even today Puma is faster. Re: fit for production. The variance was still pretty high. When I used siege my max response time was a few seconds compared to puma which all requests were served under a second and it served higher RPM. I think people forgot "why" they weren't supposed to use WEBrick and instead just remembered "don't use webrick because it is slow". I'm honestly not sure about streaming responses, I don't know what is required of a webserver to support that. 
Love this post and discussion; as a [Database Admin working in the Ruby space](https://www.engineyard.com) validates_uniqueness_of is a recurring [bane](https://vignette1.wikia.nocookie.net/batman/images/e/e2/Bane_Empire_1.jpg/revision/latest?cb=20120128230019). If the database were MySQL you'd have additional concerns to contend with as well. Consider the original query: SELECT ? AS one FROM "repos" WHERE LOWER("repos"."name") = LOWER($1) AND ("repos"."id" != $2) AND "repos"."user_name" = $3 LIMIT $4 Against MySQL this search is likely to do a full table or sub-optimal row scan against `repos`. Supposing you actually had an index on `name`, MySQL wouldn't actually use it for the search because of the use of the `LOWER()` function wrapping the column name ("repos"."name"); if the index were unique it would still enforce the constraint for you. The real interesting thing about this is that the default collations of the common character sets (utf8 and latin1) are all case insensitive to begin with, making the inclusion of the `LOWER()` function extraneous and performance damaging in many cases. As for indexes on the other columns, the `id` column is not a great choice here since its basically saying search all the rows except the current one. The `user_name` might be an ok choice if a given user doesn't have a large number of repositories, but its going to make for a user experience that isn't consistently performant from user to user. In a different use case, this could easily be a very bad choice. Ultimately, moving the constraint to the database, removing the validation, and then handling the duplicate key error is usually the most efficient way to address this, and it helps get rid of some added query overhead.
Sorry, what I exactly meant was *static* hosting. Edited.
I'll be honest - I'm not really seeing how great this is. Can someone explain in more detail, with more code examples?
webrick has a few advantages: it's standard library (no need to download package, easens deployment), and it's standalone (puma requires rack). The rest is up to your requirements: if you require more throughput, use puma/unicorn behind a proper reverse-proxy (I recommend h2o). 
Why take risks without open source Ruby and community support?
&gt; But it's not performance, I don't think. It is. webrick uses a thread per request, but last time I checked it handled reading the request in the request thread, which means that the worker thread would block on I/O. It also parses HTTP in ruby with regexp and string API, which is slower and can't release the GVL (I think both the mongrel and the http_parser parser free it?). But since most ruby servers are behind a proxy and buffer requests, I'm not sure how relevant the first thing is. &gt; it's probably missing some features you might want serving Rails. Streaming responses? AFAIK none of the existing ruby servers support streaming requests/responses, at least efficiently and production-ready, without resorting to hacks involving the dreaded rack hijack. And webrick doesn't support rack hijack. Which is the reason why rails doesn't use it as default dev server (because of actioncable, which requires rack hijack support). 
I speak german. Directions unclear. Became intergalactic dictator.
Hey - so, ActiveRuby, like all the ActiveState language distros is built to work seamlessly with all community gems and initiatives - and you're always free to install/uninstall whatever you want, build/rebuild at will. You would still have full access to any community led support initiatives, and at the same time if you're a business, you can actually get commercial support for this distro. Hope that makes sense!
That is a pretty crazy setup haha. Better than a VM I imagine though.
&gt; webrick doesn't support rack hijack What does a server have to do to support rack hijack?
This is an article from 2015. Whether it's relevant or not, I can't help but to think posting it to reddit now is mere pot-stirring.
I swear there was a period of time where if you used any server *other* than Webrick, Rails removed the Rack::Lock middleware.
&gt; What does a server have to do to support rack hijack? http://old.blog.phusion.nl/2013/01/23/the-new-rack-socket-hijacking-api/ TL;DR - implement those 2/3 extra values in the `env`. And then [update the rack handler](https://github.com/rack/rack/blob/master/lib/rack/handler/webrick.rb#L73-L75). 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [rack/rack/.../**webrick.rb#L73-L75** (master → 8693330)](https://github.com/rack/rack/blob/8693330130b565ad68d9aed70a2ba6a45194795a/lib/rack/handler/webrick.rb#L73-L75) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dl2lmf4.)^.
Just no. Use keyword arguments, and write one value per line. Readable, maintainable, and no messy extra code like in Java.
Considering I don't have to install the software for a VM, let alone a whole other operating system :p. 
I was going to make a snarky remark about looking through commits and then I found this https://github.com/rails/rails/issues/20660#issuecomment-114159295 
yep, hacks involving the dreaded rack hijack is what we got, but we still need app server support for that too. I guess my vague memory was kinda right that webrick doesn't do it. 
1 tab = 2 spaces 
 User.new.tap do |user| user.name = 'John Doe' user.birthday = '1999-03-02' blah blah blah end 
It depends on a situation, `__dir__` isn't better than `__FILE__`. There is a simple example where `__dir__` is better than `__FILE__`: There is `app/` folder `app/` contains files: `Gemfile`, `Rakefile`, `app.rb` Imagine that you inside `Rakefile` and you need to get path to `Gemfile` Defining a path relative to a file name (__FILE__): File.expand_path("../Gemfile", __FILE__) # there is redundant "../" Defining a path to a dir (__dir__): File.expand_path("Gemfile", __dir__) Result is the same, but if we need number 5, we don't type 3+2 or 1+4 it is important don't do redundant things in a code. If you inside `Rakefile` and you need to get path to `Rakefile` then `__FILE__` is better than `File.expand_path("Rakefile", __dir__)` More about [\_\_FILE\_\_](https://docs.ruby-lang.org/en/2.4.0/keywords_rdoc.html) and [\_\_dir\_\_](https://docs.ruby-lang.org/en/2.4.0/Kernel.html#method-i-__dir__) [TIMTOWTDI](https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it)
Take a look https://github.com/rails/rails/pull/29176/files or https://www.reddit.com/r/ruby/comments/6r2fyk/with_dir_we_can_restore_order_in_the_universe/dl2tsmd/
Thanks. Yeah, in the future, please explain in the post why you use a particular method or whatever versus another. Otherwise, it's like this article where you recommend changing code and provide examples of doing so without really telling us why we should.
Oh please. You see, design patterns (such as builder) from the GoF book are here because *some language* lacks expressiveness and specific functionality. Ruby is not Java. It has some features that Java lacks. One of those features is `keyword arguments`. You don't need this kind of builder. You need to write idiomatic Ruby. Proper Ruby. This is not idiomatic Ruby. This. Is. Wrong. Also. This `set_` naming nonsense makes me wonder: have you actually seen Ruby? 
I agree with your critique of the article, but there are absolutely important use cases for the builder pattern (and most GoF patterns) that don't care what sort of language you're using. Builder objects can be supplied to multiple other objects to accumulate state that is necessary to eventually construct a given object. A good example would be an HTTP response. All sorts of code, at all layers of a web stack, want to control the eventual HTTP response. Sure, you could design your HTTP response object as a mutable data structure, and pass the response itself around -- in fact, most ruby web frameworks have taken this approach in practice. Nevertheless, the builder pattern *could* be employed to great effect for this purpose. And it's just one example. It's time we got a little more nuanced about design patterns than parroting trite catchphrases like "Ruby is not Java."
I receive this error with ruby 2.4.1 when trying to install your gem. `date requires Ruby version &gt;= 2.5.0dev.`
99% of the time what you do with `__FILE__` is not look for current file but current file's directory, and get some other files relative to that. `__dir__` saves you that step.
She got fired from Github for being an asshole so she needs to up her visibility I guess.
I removed the `date` and `fileutils` gem dependencies and the gem installed. Unfortunately, I'm on a mac which `xdg-open` won't work with. You could add something like this module OS def OS.windows? (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil end def OS.mac? (/darwin/ =~ RUBY_PLATFORM) != nil end def OS.unix? !OS.windows? end def OS.linux? OS.unix? and not OS.mac? end end And then in the `download` method use `open` if it's a mac and `xdg-open` for *nix. I'm not sure what it would be for Windows.
`darwin15.6.0`
Thanks for the explanation, friend!
Use smart tabs? Makes the tab key insert N spaces instead of a tab character.
Probably worth setting a sane user agent. The default is something like `Mechanize/2.7.3 Ruby/2.0.0p353` which you don't want, because it doesn't tell the site administrators what you're doing besides using an automated scraper on their site. Many of the private trackers I use will deny anything with `Mechanize` in the user agent string, but permit user created tools that specify a descriptive user agent.
Me too but we gotta play well with the others... :(
I agree with ya , just curious, I was interested in what 'ruby framework' you were talking about. So I came across this response_test with 'tap' (seems like it sort of uses 'builder' Only looked at tests though) : https://github.com/rails/rails/blob/b5db73076914e7103466bd76bec785cbcfe88875/actionpack/test/dispatch/response_test.rb#L456 Faraday and Net::HTTP seem to have the same pattern for creating requests / handling responses too (using class methods + blocks). It seems like a pretty widespread pattern in frameworks/libraries we use on a daily basis in Ruby right under our noses, can't dismiss it
The example I gave is very simple. Please remember - builder design pattern is not (or not only) about instantiating object - it's about separating it's creation from representation. It shows its power when you have more complex objects rather than just assigning values to attributes. Thank you for your input! It's very valuable to me.
You should feel bad
Good work.
&gt; Why take risks with open source Ruby and community support? Your business needs a Ruby distribution that has passed through a professional QA process and has regular security releases with quality commercial support. Join the millions of developers and Fortune 1000 companies who use ActiveState's language distributions--choose ActiveRuby for the development, management, and distribution solutions for Ruby. With that sort of positioning, no, people will not have access to community led support initiatives.
Thanks, I improved the post and explained: "Why is `__dir__` better than `__FILE__` for a definition of path?"
So rough trying to read this code haha
Please work with the ruby standards though. This is brutal to read. So much whitespace. 
I totally agree with you. The last sentence, couldn't agree more. I just want to make it clear that I'm not unhappy about the pattern itself or its applicability in Ruby. I'm furious mostly because this article teaches people to code builders *entirely* for the sake of using the design pattern. The author starts with a problem. We see a function with a long list of arguments, none of which are *keyword arguments*. The problems are obvious: * doesn't look professional * long list of parameters * we have to pass nil if we don't want a field empty * etc. The builder would be a good solution in Java, C++ or any language, but not in Ruby. Ruby has keyword arguments. Why don't we just use them and focus on better applications for the builder pattern? Your HTTP response example is amazing. It actually shows *why* we might need a builder. Sometimes, a simple hash is enough. Sometimes, you want something like `dry-struct` instead of a hash. It might look like that def some_request_handler(request, **params) ... { **request, status_code: :not_found } # or request.new(status_code: :not_found) if you fancy dry-struct end It's easy imagine a pain in the butt that comes with having to pass and retreive the object on each step. Railroad-oriented programming eases the pain, but it's a whole other story. Builders are helpful. They make our lives easier. Just not the builder in the article. 
You can also use gemstash to do this: https://github.com/bundler/gemstash/blob/master/docs/gemstash-private-gems.7.md
Hey so that is referring to commercial support which I mentioned and is offered for those in businesses that want or need that kind of support. If you are familiar with the RedHat model - this is basically the same model. There are community editions of every language which are free to use and there is nothing that excludes you from using any package out there - it is really for those who either need to have say a guaranteed response time for support inquiries, or may not actually be allowed to say post a question of StackOverflow for confidentiality reasons or whatever. Many of the business customers are very large organizations that have obviously different requirements than individual developers. However the goal here remains the same - make everyone's lives a little easier when working with Ruby! :) Hope that helps!
I have no problem with the Red Hat model -- it used to pay my salary -- but there are ways to advertise it without so directly maligning the community. Ultimately, I'm not the target market: I can't exactly vote with my wallet, so my opinion doesn't matter much. As long as ActiveState chooses to label me risky, though, anyone who supports them (say, by using their product) is unwelcome where I hold sway.
Hey - apologies that it comes across that way - I don't think the idea is to try to label the community as "risky" in a derogatory manner - and to be fair I will chat with marketing to look at changing the language because it truly isn't the intention. ActiveState he a long history of deep support for open source communities, contributing back and actively supporting, sponsoring and engaging with these communities as the strength and depth of these community initiatives is what makes open source solutions so powerful and popular. I think the intent with the copy there is to describe the value proposition for commercial support - but it could certainly do so without using that broad characterization and I will head back and work with them to update it.
Alt or Ctl + arrow? Not sure what shortcut in st is to jump by word.
:)
what would be the use case for this? Shift-tab might do it.
I believe useTabStops should be the correct setting. Set it to true and backspace should delete down to the next lower multiple of tabSize. E: I'm dumb. You're asking about left arrow and not backspace. My bad.
Read this page: https://learnxinyminutes.com/docs/ruby/ And then do some small projects.
nice. Not in a bundler release yet, I presume?
you can use the home key to go to the beginning of the line. I have a shortcut set to alt+left and alt+right because my home/end keys are awkwardly placed
oh i see what you mean. i don't really know what to tell you. Although I don't really see this as being super useful, if you think it is, then maybe it is worth using tabs as long as you get away with it (i.e. until an employer's style guide says you can't). Just be consistent, either tabs or spaces, but not both.
Not yet, but on master. Will be 1.16.0.
FYI - I checked in on this and this is from an old piece of copy that is no longer used since it doesn't accurately reflect the way ActiveState products fit into the ecosystem. Unfortunate that it ever went out to begin with, but this is no longer being used, nor will language like this appear moving forward for any of the language distributions.
i read the comments here first so i was expecting something of a rant, but i actually agree with your article. People choose Rails because of the magic, and because it does the most out the box. I prefer Sinatra for my hobby projects (Hanami would probably be good too) but I don't think Rails is going anywhere
I usually do this if the project is no longer maintained anymore: - Fork the github repo yourself (this could be more stable) or find a repo that already made the dependency change/bug fix/whatever - Add it to bundler via their github syntax I did a quick glance at the Github network and found a fork already with the updated rest-client: gem 'rspotify', :git =&gt; 'https://github.com/ekohe/rspotify.git', :branch =&gt; 'master', :ref =&gt; 'd2a506f' Obviously you need to trust github as a gem source. If you work at a large company, you might need to follow up with your security team if this is safe ;) 
if you're consistent about it, then it shouldn't be a big barrier. You could easily convert tabs to 2 spaces, or back to tabs if you wanted. I don't think it's that people in Ruby land hate tabs outright, but rather they hate when they are mixed with spaces, because it can cause the indentation to appear wrong sometimes. 
Awesome. In the past, attempts at bundler optimization have made it fail to find the 'best' resolution (sometimes in a regression from previous versions), and/or made `bundle update` come up with a different resolution than `bundle install` (which makes little sense and it ought not to), and/or made bundler fail to find a valid resolution when one existed. This frustrated me before, but your blog post helped me see how challenging this all is, balancing performance with correctness and optimal resolution (not supplying an older version of a dep when a newer version would resolve fine with all other deps being the same). I'm hoping these improvements don't involve any resolution regressions. :)
Ah, very helpful, thank you! Just curious, how did you find that fork on the github page? I'm looking at a few different links off the main rSpotify page but can't find anything mentioning ekohe's fork..
You're using two spaces, right? It shouldn't be much of a hassle to just hit left 1 more time.
yeah you gotta click "Contributors" then "Network" https://github.com/guilhermesad/rspotify/network I just came across it hovering over the graph being curious what people changed
I'm pretty confident the theory is solid for all the speedups, so we shouldn't see any regressions. I'll be on hand to fix them if we do, though.
Loving the metrics and analysis you put this through. I basically took the community at its word that WEBrick wasn't good enough; it's interesting to see that in this case at least it's a solid, zero work option.
Impressive, thank you!
Is there an active PR to look at?
Dependency resolution is an interesting problem. I wrote [`build-dependency`](https://github.com/ioquatix/build-dependency) which implements a dependency resolution algorithm as a gem. It doesn't support versions, as it wasn't necessary for my problem space. Supporting versions makes dependency resolution a harder problem.
Hey sounds good! I'll send you a message once more material is ready. 
you're my hero. 
* Learn NokoGiri * Learn regular expressions * Learn how to use curl. * Learn how to process JSOn * Learn patience cause sometimes parsing out how pages are set up especially deep JSONs can be a bear I have two partial projects, one scrapes nba.com and one scrapes nfl.com - still working on processing data and writing queries but the scraping works (or did a few months ago, nba.com has changed their site a few times so I had o rewrite the access) 
Google Nokogiri guides
http://www.espn.com/static/apis/devcenter/blog/read/publicretirement.html That sucks
Watir
&gt; Rodauth uses a completely separate table to store password hashes, and this table is not accessible to the rest of the application. It always intensely bugged me that Rails generally documented standard involved running your application as the database user that has full permissions on a db, right down to dropping it.
It truly depends what you need and how far you need to go, as was previously mentioned NokoGiri it's the best way to parse the HTML you get from the pages, but there are many steps before that. You can use Anemone as a way to scrape all the links of a webpage, or even Mechanize if you need some basic form fillings, however, scraping whole webpages with Ruby is a "little" slower than other languages such as Python.
They're all merged now, but the big ones are [here](https://github.com/CocoaPods/Molinillo/pull/69) and [here](https://github.com/CocoaPods/Molinillo/pull/73).
I second the other bits of advice given here. Let me add something though: an increasing number of websites require javascript to work properly. If you need to scrape such websites, then one way to do it is to use capybara, which in turns allow you to use various drivers (poltergeist, capybara-webkit, selenium etc, with advantages &amp; drawbacks for each) which all support javascript. You also have to make sure to be fairly defensive in your programming (= add assertions on what is expected by your scraper, in terms of elements &amp; data), because the websites tend to change quite a bit &amp; sometimes quite in subtile ways. With this in mind, you can actually write fairly solid data extractors (I have some [kiba-based](http://www.kiba-etl.org) data extractors which rely exactly on Capybara &amp; headless selenium currently in production to extract data from enterprise systems - with authorisation of course).
Mechanize + Nokogiri
Nice! If you haven't already, take a look at the architecture.md file in Molinillo for a good summary of the algorithm used there. Would highly recommend adding the same to build-dependency - it made it so much easier for me to reason about the logic in Molinillo when I first came to it, and updating it was a good exercise in making sure my changes were theoretically robust.
Thanks for checking it out! You are right - some of the logic is so complex in these tools, and if you get it wrong the upstream effect is pretty catastrophic. `build-dependency` does have a fair number of tests, but it could always be better. At this point, I don't think it will change too much, since it's doing almost exactly what I want. A novel feature of `build-dependency` is that it exposes private dependencies, and it separates dependencies from targets. A dependency graph is made up of packages. A package provides things and depends on things. These can be anything but are usually symbols or similar immutable data structures. Including a single package into the dependency resolution chain (my terminology) means that all the things it provides are now exposed. So, what you do is you have a package called `compiler-clang` and it exposes a target `:compiler`. You depend on `:compiler` and it's ultimately satisfied by either `compiler-clang` or `compiler-gcc`. `build-dependency` is used by teapot: https://teapot.nz
http://imgur.com/EZYNpvW Googling your exact title came back with some pretty good stuff
This is a great article, specially the part about mitigating DDoS account-based attacks. About the auth libraries, nothing new, but it hasn't been repeated that often, so it's fine. Devise is showing its age. Its greatest advantage is the seamless way it integrates with rails (just add the gem, 3/4 lines and boom). But it's only seamless if you use the defaults. As soon as you need to support multiple strategies, jwt token, maybe LDAP, phone number instead of email, etc... it stops being so simple. Extending Devise is particularly difficult IMO, and part of it rests on rails many extension point options. Rodauth is IMO the best of the bunch right now. Beyond the security features, it's very extendable, having an extension point on top of roda's. And some times you don't even need extensions: p.ex. adding LDAP integration is just a matter of redefining the method which matches the password and using some LDAP library to perform the call. 
Start with Mechanize. Here's a guide I wrote: https://readysteadycode.com/howto-scrape-websites-with-ruby-and-mechanize As thibaut_barrere points out an increasing number of websites use javascript, so if you need to execute javascript then try Watir or Poltergeist. These guides will get you started: https://readysteadycode.com/howto-scrape-websites-with-ruby-and-watir https://readysteadycode.com/howto-scrape-websites-with-ruby-and-poltergeist Beyond knowing your way around all these Ruby libraries web scraping involves a lot of debugging and reverse engineering, poking around the DOM and inspecting HTTP requests. So get comfortable with your browser development tools.
Watir is necessary if the page you're trying to scrape is doing JS/Ajax stuff. (It looks complicated, but I've got something I need to automate, and I'm going to have to figure it out soon.) If you're scraping straight HTML, avoid this, especially to start.
You seem experienced. In my current line of work I use expensive vendor software called Kapow. However, I've been learning Ruby for a while and have wanted to leverage that for certain jobs. Two questions (for anyone, really): - Would you be available for a little paid mentoring? (Specifically around structuring robust projects beyond simple one-off scripts) - Do you have experience working around Distil?
I agree with the article, and I've made the same sort of comment here before: there's still nothing that addresses the problems Rails was invented to address as well as it does. And DHH and the Rails devs are still keeping the platform moving forward with changing times (dropping JQuery as a requirement, et. al.). So I don't see the problem here. I think people just want to look cool by bashing on something that's 10 years old now. What are the alternatives? Microsoft web development, with their *terrible* EntityFramework, is a dumpster fire. React/Angular? I haven't created a project with them, but it seems like you need the backend of Rails or PHP to use them, and if you're already using Rails, why hassle with the overhead of an entirely separate frontend framework? PHP? People like to slag off on Ruby for the speed, and I know from personal experience how much faster PHP is, but by the time you put an MVC and templating stack on PHP, speed tests show (things like CakePHP) wind up suffering pretty badly (though I looked at this a LONG time ago, so things may have changed). Obviously, comments here will probably center on confirmation bias, but I'd love to hear opinions on what tool I should be learning next. It's just that I find I'm still really productive with Rails, and now, 10 years on, it's very mature, and my questions all have answers on SO.
I'll DM you to share more details.
I'm really enjoying using headless chrome for scraping lately. It deals with all of the JavaScript based stuff really well.
Does anyone else just use indent and that works well enough?
&gt;Does anyone else Probably
Yes I see things the same way, Rails is still very good it's just not cool anymore. "but I'd love to hear opinions on what tool I should be learning next": I'm leaning more and more towards learning the java stack as my second go to tool next to Rails . Just because java seems timeless and provides job security virtually everywhere. It's gonna be a time investment but I think it should be worth my while in the end.
And a great resource that I have bookmarked is https://jhawthorn.github.io/curl-to-ruby/ which converts a cURL request into a ruby net/http request.
Hey, I write ruby scrapers for a living. Here's our repo. Lots of different examples of HTML scraping, schema.org extraction, ICS/JSON/XML/RSS parsing. You name it. https://github.com/ElixirUK/TeSS_scrapers 
I don't think she posted this to reddit?
A builder would allow for a separate response object class to be defined whose construction _requires_ enough state for the response to be "ready to go." This might reduce the complexity of the framework itself, as all the code that makes use of an HTTP response object could assume that the response itself is complete (i.e. no `nil` values).
Interesting response, thanks!
I agree with /u/DunkirkReadOnly that Rails (or some other back end) is still needed for more frontend-centric frameworks, but I don't agree that you might as well _only_ use Rails because of that fact. I personally use Vue, but Angular and React are popular as well. I would say that Rails as a purely API server with a front end SPA would be worth learning. React seems to be the buzzword for hiring recently.
How do you know?
Okay sorry for the disappearing act, but I just renamed it [vim-fold-rspec](https://github.com/rlue/vim-fold-rspec) so that if I ever do more folding plugins down the line, they all sit next to each other alphabetically.
Hahaha this was way funnier the second time around.
I ran into a problem using Mechanize which may or may not have been related to Nokogiri underneath. It had to do with authenticating with an intranet site that uses Microsoft technology. It's broken and some Googling revealed they intend to drop support for it. At any rate, Watir waltzed right past the issue and there were plenty of examples of how to do the other things I needed it to do on Stackoverflow that just worked. I don't think that's what Watir was intended for (integration testing) and it may not be as fast, but it worked and I was able to use it to quickly solve the problem I was working on.
My code never used their API - I go directly to the source with the curb gem, at least I did. I'm a bit behind on working, it did work earlier this year...I had to rewrite it once. I never fully finished with all the available stuff (like shot location)
Look at js based solutions if you want to do scrapping only.
[God I love my RoR](https://youtu.be/bbQ853tgTrM?t=24m5s)
Cool thing they have a salary calculation. But the pay is not that great in my opinion ( for my location at least ) 
I work for [Citrusbyte](https://citrusbyte.com) remotely for over a year now. I like many things about that company, but one thing that stood out for me when I was applying was that they use Ruby but not Rails (my particular project is on Cuba). I don't know if that's something you're looking for, but it is what I was looking for.
You Need A Budget sounds like an awesome place to work. Dunno when they last hired a dev though. 
I'm pleasently surprised to see Cuba mentioned. I've been working on a personal project with it and love it. It's just so uncommon to hear about it more so than say it's fork roda or sinarta. Wish it would get more spotlight in the community. 
Because she would use her account?
&gt; I personally use Vue, but Angular and React are popular as well. I've been tempted to try putting React on Rails, but it's intimidating. This is the perfect point to ask: What are you getting from Vue that you don't feel is being served well with Rails' view templates? I really just need to do a test project to see it for myself, but an answer here could help me focus on what I should be seeing.
Why do people keep recommending Nokogiri when much better alternatives like Oga exist?
Username checks out...
&gt;Username checks out Because it's just a stupid and annoying bot.
&gt; What are you getting from Vue... A massive amount of client-side interactivity. It would take a lot of custom JS to have the nice native-feeling user interactions that a front end framework helps provide. Even simple things like having a displayed value change based on options selected/unselected can't be done without writing _some_ JavaScript, but when it gets more complex a framework makes these sorts of interfaces much easier and manageable. Rails 5 uses Webpack by default, and there is a generator that makes starting a Vue/React app as easy as running the cli task. Definitely take a look. Imo, Vue is easier to learn if you've never used a JS framework before.
Gitlab deleted prod database more than one time. Smh
`bundle exec rails new thread --without-confirmation-bias`
Why don't you give me some more background on what you're trying to do. Can you paste in the method that you're trying to build? There are generally accepted "better" ways to increment from a list of numbers that doesn't rely on you remembering what order the numbers are supposed to be in. That's it's own kind of annoying dependency that you're likely to forget or mess up at some point down the line.
I am aware of https://about.gitlab.com/2017/02/01/gitlab-dot-com-database-incident/ but what was the other? AFAIK GitLab.com has better uptime than GitHub. And you have the option of hosting it yourself. Even AWS has had its fair share of incidents. Like the deletion of ELB configuration https://aws.amazon.com/message/680587/
I've been with [Litmus](https://litmus.com), fully remote, for over four years now. It's been an absolute dream. We're a remote-first company (one of the founders [wrote an article about it](https://thinkgrowth.org/the-difference-between-remote-and-remote-first-7dd38458855f)) and employ great people all around the globe. We are actively looking for a [Ruby engineer](http://jobs.litmus.com/apply/fbXsX5/Ruby-On-Rails-Developer-Local-Or-Remote?source=Reddit)!
I would much prefer to pass in a hash of values than an array. I'd rather do something like: @a += values[:a] @b += values[:b] @c += values[:c] I think OP is running into a problem of bad design that no amount of clever syntax is going to fix.
GitHub as well
Github has also done the exact same db deletion mistake that Gitlab did, it was just longer ago. 
&gt; Gitlab deleted prod database more than one time It only happened once, don't spread nonsense.
Pretty sure they're all php or asp.net
have you used rodauth with rails, is it still pretty straightforward?
They were for sure Rails at one time and still employ a member of the Rails core team. Couldn't find any recent mention of Rails or that they've switched. 
Yep, you're right. https://stinklr.com/sufro4d
I don't think it's annoying. Does anyone else think it's stupid and annoying?
Stop saying that.
Why? Reddit frown on self submissions. She probably just made up a user name and submitted it. Remember she is a dishonest asshole. There is no reason to think she would act with integrity, in fact that would go against her character.
Very nice, have been close to needing something like this for a current project. Will certainly give it a look!
Use map to transform the values how you need and assign those.
And they had a mass assignment security flaw that allowed people to elevate their privileges to admin.
Without digging into the docs, but with plenty of experience with web APIs... you probably need to supply the API key in a header field or cookie. If it really is a GET param, are you certain it's named "APPID"? Are there possibly other required fields you haven't supplied?
I don't think "&lt;&lt;" is doing what you think it's doing. Why don't you just add all your parameters in the URL in one string I bet that will work. "&lt;&lt;" appends an item to an _array_ which I think HTTParty isn't treating correctly so you're not actually authenticating correctly.
Some of the best developers I know have deleted prod databases before. One could simply say Gitlab did it at scale.
You're missing the URI scheme. You need to prepend your URL with http:// or https://.
CoverMyMeds has a significant portion of the engineering staff who are full-time remote. We're mostly Ruby.
Webscale* FTFY
But it does do what I think it's doing, I'm just using &lt;&lt; to append &amp;APPID=XXXXXXXX to the end of the request URL. It works on strings as well as arrays. And I've tested the resulting URL after concatenation and it works in the browser.
You need to use quotes around the URL for your curl command. Your shell is seeing the `&amp;` as instructions to background the tasks. 
Thanks! This was the problem.
Oh woops, thanks it now works!
Once and they handled the mistakes well, don't be a dick
Been working with toptal.com for almost a year. Enjoying the flight so far. The company doesn't have an office, operating remotely through and through. Granted, I survived government jobs in exUSSR country, so take my satisfaction with a pinch of salt. And yeah, ~~dreddit is recruiting~~ [toptal is hiring](https://www.toptal.com/careers)
How would you iterate the instance variables in the map method ?.
Have you had steady work from Toptal? And do they pay well?
I worked at Litmus for 2 years and a half as first remote hire. Great experience. 👍
DNSimple. ~12 people, 4 countries, no office, no managers, no deadlines, great sense of ownership. https://dnsimple.com/jobs
 @x, @y, @z = @x+1, @y+2, @z+3
Is there a particular reason you need to do this using multiple assignment? If you're just trying to work this technique into your style for the heck of it or because you want to save two extra lines of code, my advice would be: don't. From the [ruby style guide](https://github.com/bbatsov/ruby-style-guide#parallel-assignment): &gt; Avoid the use of parallel assignment for defining variables. Parallel assignment is allowed when it is the return of a method call, used with the splat operator, or when used to swap variable assignment. Parallel assignment is less readable than separate assignment. &gt; &gt; # bad &gt; a, b, c, d = 'foo', 'bar', 'baz', 'foobar' &gt; &gt; # good &gt; a = 'foo' &gt; b = 'bar' &gt; c = 'baz' &gt; d = 'foobar'
I'm not sure what /u/jeremywoertink means, either. If you really had to do it this way, one approach might be: a, b, c = [a, b, c].zip([1, 2, 3]).map { |pair| pair.reduce(&amp;:+) } but that's a nightmare to read.
Ok well, the only other thing I can think is that all the examples for httparty have https or http in them first. You're omitting the protocol, and it may not be designed to compensate for that. Yeah that works in a browser because it _assumes_ http but in my experience Ruby libraries are picky about formatting. You still need to address that your api auth wasn't working in your first examples too. You got a 401 error
Good job, but your project can use a more informative readme. Why would I want to fold my rspec files, and why would I want to fold it differently from other Ruby files?
This looks like vector addition, so i searched for how to do that in ruby. It turns out there is standard lib support. require 'matrix' # initial values @a, @b, @c = 0, 0, 0 # do vector addition, convert to array, and assign back to vars @a, @b, @c = (Vector[@a, @b, @c] + Vector[1,2,3]).to_a puts @a, @b, @c # =&gt;123
i think there's a difference between whether a framework is trendy, and whether it's right for a particular job. It's mainly front-end stuff that is being hyped these days. Although node is very trendy, node is not a framework like rails, and neither is express, really. And there isn't a rails-like node framework that has the same degree of usage that rails does. Maybe people are avoiding rails-like frameworks, or just coalescing less around a single framework. 
vue and react are both "reactive" in that they automatically update the view whenever the data changes. another major benefit is organization. The alternative to using a front-end framework like this is usually doing things with just jQuery. This code tends to look a lot more soupy, and is more work in a lot of respects as well.
I've spent about 4 or 5 hours trying to get a working example of using React on Rails, and I have yet to get anything but the hello_react example (that comes with webpacker) working. I tried react-rails for awhile, since that seems to be really popular, but I couldn't get anything to work, even though I managed to clean up all the error messages in the browser console. So I switched to webpacker-react, and still can't get anything to render. I don't understand what's so hard about all this. I've followed the directions to the letter. Maybe I'm using the latest version, but the docs are for an older version? This bites me all the time in the Windows world. It's... frustrating, to say the least. And I *knew* it was going to be a giant hassle, which is why I've put this off for so long.
A couple things are missing here: 1) Heroku provides response buffering in it's network layer so the fact that WEBrick doesn't provide this isn't impacting your numbers. In other words these results aren't transferable to other deployments that aren't behind some sort of buffering reverse proxy already, e.g. Nginx. For those not familiar: Say you have a slow cellphone with a 0.5kb/sec network connection, WEBrick is going to tie up a thread until the entire response is downloaded by the client, most 'production' web servers will take the response from your App in full and deal with the slow client asynchronously to free App resources to handle other requests. 2) On the other side, WEBrick also doesn't provide request buffering, again this is somewhat handled by Heroku, although I don't think it's request buffer is very large. Again if you aren't on heroku and have a slow client, it's going to have very bad impacts on your app. The worst case here, and in #1 above, are large requests/response of which file upload / download are usually the worst case. These in combination with the way WEBrick created threads (new for every request) means it can hit really nasty runaway resource conditions very easily. tl;dr You aren't doing a fair test of WEBrick here, you're testing how WEBrick performs when already behind what is effectively a buffering reverse proxy in Heroku's request routing layer. You'd see vastly different results if you were hitting WEBrick directly with real world traffic. Also by testing with only very fast requests (basically static content), a lot of edge cases are ignored that will exist in most dynamic apps. Basically you should not use WEBrick in production unless it's already behind a buffering reverse proxy and then only if _all_ your requests are very fast in the app layer. If your app actually meets these constraints, then just toss a CDN in front of the whole thing and have a much better solution. EDIT: Also as I recall WEBrick creates a new thread as soon as the socket is opened...That means if you expose WEBrick directly I can probably DDoS your site with a single arduino.
The more idiomatic way to write: def breadcrumbs_helper(breadcrumbs) html = '' html &lt;&lt; "&lt;nav class='breadcrumb'&gt;" html &lt;&lt; link_to('Home', root_path, class: 'breadcrumb-item') breadcrumbs.each do |item| case item.class.to_s when 'Array' string, link = item html &lt;&lt; link_to(string, link, class: "breadcrumb-item #{item.equal?(breadcrumbs.last) ? 'active' : nil}") when 'String' html &lt;&lt; content_tag(:span, item, class: "breadcrumb-item #{item.equal?(breadcrumbs.last) ? 'active' : nil}") end end html &lt;&lt; '&lt;/nav&gt;' html.html_safe end Would be something like (untested): def breadcrumbs_helper(breadcrumbs) content_tag :nav, class: 'breadcrumb' do concat link_to('Home', root_path, class: 'breadcrumb-item') breadcrumbs.each do |item| klass = "breadcrumb-item #{item.equal?(breadcrumbs.last) ? 'active' : nil}" case item when Array string, link = item concat link_to(string, link, class: klass) when String concat content_tag(:span, item, class: klass) end end end end
It sounds like you read the article after it was heavily revised, according to the author's comment on here
How are you persisting the session? Are you using cookies or something else? Can you capture the response from Stripe for the first time you create an account and for subsequent times that do work and show me? Please remember to take out any personally sensitive keys or anything like that. Edit: In general, it sounds like whatever you're doing to persist the session is breaking at some point and seeing the response that's coming back from stripe would help eliminate that as potential issue.
I'm not working through them but for them, so the first question doesn't apply to me, I have work to do any day. As for the pay, I make more than Ukrainian outsources are comfortable discussing. Can't speak for other people, US corporation culture doesn't promote salaries sharing.
Hey, so I think I actually figured it out - the issue was related to ror's built in csrf protections. Thanks so much for taking the time to respond though!
[removed]
That makes sense. Glad you figured it out. :)
I have spent a good amount of time on this for a few projects that I have been working on in the past year. Web scraping is not ideal, it is error prone and if the site changes all of your work can be for nothing. I have found the importance in handling errors that way your script won't shut down completely if it come across an unexpected element. As others have noted you will most likely need to use something to make Ajax/Javascript requests. Here are some examples of what I have written: [Bulk of my webscraping logic](https://github.com/mjrode/check_the_lines/blob/master/app/interactions/games/fetch_wunder_data.rb) [Parsing the results of an Ajax request the site made](https://github.com/mjrode/check_the_lines/blob/master/app/interactions/games/fetch_massey_data.rb) [Base Class that makes the request](https://github.com/mjrode/check_the_lines/blob/master/app/interactions/games/fetch_html.rb)
For someone who is new to ruby (but not new to programming) can you explain where would this be useful?
`String#&lt;&lt;` is an alias for `String#concat`, which the docs for both say "Append". I think it should just be called `append`. Either way, `&lt;&lt;` is the most common way to append to a string that I've seen. 
(I was originally writing this as a response to https://www.reddit.com/r/ruby/comments/6ro80g/api_request_valid_but_not_working/dl6p3f7/ but I think it fits better as a top-level comment.) There are 2 libraries which can help you create query strings a little easier and more semantically. Given the following variables: endpoint_url = "https://api.openweathermap.org/data/2.5/weather" query = { lat: "1.23", long: "4.56", APPID: "abc123" } If you're already in Rails, or don't mind requiring ActiveSupport, you can use `Hash#to_query` to convert a hash to a URI query string: require 'active_support/core_ext/hash' request_url = "#{endpoint_url}?#{query.to_query}" puts request_url # https://api.openweathermap.org/data/2.5/weather?APPID=abc123&amp;lat=1.23&amp;long=4.56 You can also use Rack::Utils to generate query strings, which I think is more lightweight if you're not using Rails: require 'rack/utils' query_string = Rack::Utils.build_query(query) request_url = "#{endpoint_url}?#{query_string}" # https://api.openweathermap.org/data/2.5/weather?lat=1.23&amp;long=4.56&amp;APPID=abc123 Interestingly, ActiveSupport's `Hash#to_query` seems to sort the keys, whereas `Rack::Utils.build_query` preserves the original order in the hash literal. There are also ways to generate a URI by providing the hostname, scheme, path, etc but IMO it's overkill since you'll always have params for this use case (easy enough to interpolate with the question mark separating them).
I haven't had the pleasure, but [it is definitely possible](https://github.com/jeremyevans/rodauth#with-other-web-frameworks). https://github.com/jeremyevans/rodauth-demo-rails 
Rails concurrency history is a scary place. 
Btw, /r/schneems, I would love it if you did a writeup about how you deploy jekyll/middleman/static site to heroku with your somewhat hacky but it works setup. I have a static site that needs automated regular rebuilding that I'm trying to figure out how/where to deploy. 
Excellent. Thanks for providing more info on "Wait, why don't we use WEBrick in production again?" I knew there were reasons!
Don't see an open position for a Ruby dev?
&gt; "Wait, why don't we use WEBrick in production again?" Handling of slow clients is the prime reason you may choose any serving setup. Be it Nginx + WEBrick, thin, puma, or Nginx + unicorn (I don't think anyone would directly expose unicorn for similar reasons that you wouldn't directly expose WEBrick).
AdHawk is pretty awesome 😍
Their continued support of Ruby and Ruby on the web is also why I continue to support them as a customer. I also love their product 
Thanks for the input. I kept it sparse because I had originally intended to build a full-fledged test runner that it would be a small part of, but then I realized there are already other test runners out there made by much smarter people than I, so I went back and added a code sample to spruce it up a bit. What is your preferred way of folding ruby files? `foldmethod=syntax`? I find it's great up to the level of method definitions, but it can get very annoying beyond that (where every multi-line block is folded, and you have to dig deep to get to the code).
There may be soon.
I wish I were more confident in my abilities. That looks like a great company to work for
[@yukihiro_matz's latest tweet](http://i.imgur.com/8Lo4VqS.jpg) [@yukihiro_matz on Twitter](https://twitter.com/yukihiro_matz) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
+1 for the well grounded... book. I learned perl before but just as a hobby.
First, thanks for answering and referencing the guide which I handt had time to study yet. Yes, merely to write it differently, working with flashcards and the array deconstruction method came up.
I'm working for [Evil Martians](http://evilmartians.com) for about 2 years, and I like it more than any of my jobs since middle 90-th ~40 people with managers per developer rate less than 10% Remote-first, but we have offices in NY, Moscow and St.Petersburg just to enjoy a company of each other
&gt; Great awesome list. Thanks for highlighting all the great gems in ruby for data science Agreed! Python doesn't have to be the 'only choice' or the 'go to' programming language for data science/statistics. 
Stackoverflow has lots of remote offerings for different companies. 
Evil Martians is an amazing company! I don't have anything bad to say about them at all. 
Dunno about the Rails 4 one. We're on 5.1 and 5.2 will be out later this year. Also, GoRails and DriftingRuby are both excellent video resources for Rails. They should be mentioned. 
Heroku does not really protect you from slow clients. There is a bit of request buffering but Unicorn is still susceptible to a slow client attack and must be run behind NGINX. Puma mitigates slow client attacks very effectively, so you don't need NGINX. I think webrick would do better than Unicorn but worse than puma but I don't really know. I wrote all the slow client docs on Heroku for Ruby and did manual testing with slow client load generators. It seems like you're arguing that "webrick is not webscale" which was the core point of my argument. Webrick should not be used in production but it's not as bad as you would think for being "simple" or "slow". Given that it's not that bad other solutions such as Puma are pretty freaking good. 
Make sure that you have a `Gemfile`. Then add the `Procfile` that's in the post. Do a `git push heroku master` and you should be good to go. 
They cover basic fundamental concepts of Ruby programming though you're using any version of Ruby. Though video resources you mentioned has good content, do you recommend those video resources for the beginners, as I don't see them as well structured and organized to learn Ruby for beginners.
In the case of static blog content it's likely the requests/responses are fully buffered by Heroku so you are effectively protected against slow clients for this use case which is why WEBrick seems to perform decently. The request buffer is 1KB for the request body and there likely is never a request body on a static blog as all requests are GETs. The response buffer is 1MB which is also unlikely to ever be hit save possibly some un-optimized images. &gt; Webrick should not be used in production but it's not as bad as you would think for being "simple" or "slow". My point was that WEBrick _is_ as bad as everyone thinks, it's just that your test has a particular set of characteristics such that it happens to work alright, but only when run on Heroku or behind some other buffering reverse proxy. 
And don't ddos the site with eager threaded calls. Was my rookie mistake last time. 
[https://www.reddit.com/r/ruby/comments/6s0kvw/does_anyone_have_any_good_resources_for_learning/](https://www.reddit.com/r/ruby/comments/6s0kvw/does_anyone_have_any_good_resources_for_learning/)
Hahaha
+1 for CMM, we're very open to remote opportunities &amp; do enjoy our fair share of Ruby. Also, 👋 fellow CMM'er!
Khan academy has some pretty good exercises for recursive programming. JavaScript is used, but the principles are the same. I believe they're in the algorithms course.
Came here for this comment, was not disappointed.
Came here for this
Does WEBrick wait for the whole request body before spinning up a new thread? Or does it read the request in the thread? My tests with siege locally didn't use a proxy. 
Top 2 are on udemy. Infomercial for udemy.
But you got it to use puma somehow? What am i missing? 
Work through the first two chapters of [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/full-text/book/book.html). The text uses scheme, though you ought to be able to implement the examples in ruby.
Is it just me or do others find the first example to be easier to understand?
&gt;Is it just me Probably not
You're correct from the perspective that Drifting Ruby videos not meant for beginners. I started DR as a way for me to continue my self education/learning as well as documenting some stuff that rolls around in my head. I've been grateful for the Ruby community as a whole and it has been my way for the past years to contribute back. A lot of the videos can be followed through from an intermediate perspective, but the basic knowledge is a must. Though, I think that this does pose a good point that I should make some beginner level videos. My thought has always been that Mike Hartl and Daniel Kehoe paved the way for beginners and when you're needing something general-to-specific, DR is a good resource.
Thanks for the comment. It might be easier to understand, but it wouldn't allow other developers to inject adapters into framework. Without Inversion of control those 2 initially implemented adapters (Memory and Redis) would be all that framework could offer to devs. With Inversion of control developers can create any number of adapters they need. It is absolutely necessary feature that each framework should provide.
Perfect. 
Oh, the puma thing was a major hack. I had to build a `config.ru` file to serve the static pages. I only ever got that working locally for perf comparison testing. It was actually more work than using the nginx buildpack that I mentioned in the post. 
Does WEBrick wait for the whole request body before spinning up a new thread? Or does it read the request in the thread? My tests with siege locally didn't use a proxy. 
You fiend ;-)
Try and implement something like a Binary Tree, or a B-Tree: * https://en.wikipedia.org/wiki/Binary_tree * https://en.wikipedia.org/wiki/B-tree The same principles can be applied to other real world problems. 
**Binary tree** In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A recursive definition using just set theory notions is that a (non-empty) binary tree is a triple (L, S, R), where L and R are binary trees or the empty set and S is a singleton set. Some authors allow the binary tree to be the empty set as well. From a graph theory perspective, binary (and K-ary) trees as defined here are actually arborescences. *** **B-tree** In computer science, a B-tree is a self-balancing tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree is a generalization of a binary search tree in that a node can have more than two children (Comer 1979, p. 123). Unlike self-balancing binary search trees, the B-tree is optimized for systems that read and write large blocks of data. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Why not just pass in the adapter as a dependency? 
Also not Ruby specific, but neither is the concept of recursion -[The Little Schemer](https://www.goodreads.com/book/show/548914.The_Little_Schemer) is the best guide to thinking recursively I've ever come across, and absolutely applies. As in SICP (as another commenter suggested) Scheme is chosen because it's so minimal, no syntax or idiosyncrasies between you and the concepts. Bringing it over to Ruby is not difficult.
YES! Little Schemer blew my mind. I probably got 3/4ths of the way through it before I had to cut my losses because my brain was full. I keep meaning to come back to it though, because it's such a beautiful, elegant way to learn the subject. It's just a shame it's so expensive...
The last portion of the book is undeniably difficult but so so worthwhile :)
I promised myself I'd come back to it one of these days. I want to get to the point where I can do the Seasoned Schemer!
Thanks for question. It's a good idea, but one of the main benefits of dry-container is a lazy loading. Currently we have two adapters: memory and redis. If somebody is ok with using memory adapter, we don't want him to install redis-specific dependencies. Dry-struct allows us to resolve dependencies at the moment when developer wants to use specific adapter.
[relevant](https://www.reddit.com/r/ruby/comments/6s0kvw/does_anyone_have_any_good_resources_for_learning/dl9aqg0)
I've not tested it but my reading of the code indicates that it spins up a thread as soon as a socket connect occurs.
That was my read as well (though also haven't tested) if that's the case then the webrick should mitigate slow clients fairly well. While a slow client will consume an entire thread, it just spins up more threads for the next requests. 
Maybe it mitigates slow clients, but if openly exposed that means I can DDoS with a single arduino. I just have to open enough sockets to eat the servers memory which is pretty easy with a thread per socket and no queue / thread pool.
Yeah, totally. It's not DDoS safe at all. I just don't think slow clients are a good vector. Wasn't sure if I was missing something. 
Well, they are still a vector. If your blog was running on WEBrick directly without a request/response buffer in front then you'd probably just need a post to go a bit viral and you'd have enough slow clients from mobile devices to tie up enough threads to have the same effect.
Many languages (such as elixir) support pattern matching, which from personally experience makes recursive problems easier to reason about. I give this example whenever someone asks about recursion but here it is, fibonacci in elixir: defmodule Fib do def fib(0) do 0 end def fib(1) do 1 end def fib(n) do fib(n-1) + fib(n-2) end end there are no conditionals, each logic branch is split up into its own function clause.
If there was a rails like node framework,.. euguheeg
The code is definitely more difficult to follow since the bulk of it is abstracted away by `dry-container` which is a pretty uncommon gem that claims to contribute half of the functionality of an IoC container (which I don't want to get into since that's a discussion in and of itself). I don't think that lazy loading outweighs readable/understandable code. Besides, you could always extract the redis adapter into a separate gem, the ultimate form of lazy loading.
But you've forgotten the base case
I always thought that IoC was for more statically typed languages to grasp at some of the dynamicness that languages like Ruby get almost for free. With C++, a language I commonly use, patterns like the one shown here are common and require a great deal of boilerplate. This pattern would be useful because C++ has only minimal support for dynamic method dispatching at runtime. Either inheritance needs to be used or the class needs to know about some other classes and map some value onto the class. It makes sense to create extra structures to create the required level of flexibility, because there are few other options. There are even design patterns like the Strategy/Context pattern that do this (Which is close to this). When the C++ level of performance is required all this extra work might be justified. With Ruby since all methods are dispatched at run time, why aren't the required adapters simply passed in? Like this the code needs to know the actual classes and cannot easily and has maintenance cost similar to the C++ code but without the same performance. Or even when the symbol is passed in it is possible to check and see if there is a class of that name and make an instance of that. There are countless great ways to invert control in Ruby without strictly tying classes together.
Chris Pine's "[Learn to Program](https://pragprog.com/book/ltp2/learn-to-program)" has a chapter on Recursion, which happens to be written in Ruby. I like "The Little Schemer" as well, but since you're asking in /r/ruby, the former book may be more useful. Chris did worldgen stuff for Civilization III, so his recursion examples look at doing map generation using recursive code, it's pretty neat.
This explanation helped me a lot! https://stackoverflow.com/questions/717725/understanding-recursion
Let me start off with some encouragement. Recursion doesn't have many parallels to "real life" so it's frequently difficult to build the mental models necessary to build understanding. I really struggled with it in school; I hated it and would always use iterative approaches even when I knew it was better to use recursion. Eventually, after I had to use it professionally, I came to like it quite a bit and now I knock them out regularly (I deal with a lot of trees) Some of my favorite code I've written recently has been recursive in nature, so keep at it: it's worth learning. I would keep it really simple. Depth-first iteration of trees is your go-to. Find a good example of that and you should start to feel some changes in your brain. SICP and the little Schemer are serious business. I don't know if that's what you need. Yes, you HAVE to learn recursion in order to use Scheme/LISP, but It's a bit like you saying "I need to work on my grip strength, can you guys give me some exercises I should do" and getting "Hang a rope over the Grand Canyon then hold on as long as you can" as a suggested course. Just because X is required for Y, doesn't mean that X is the best way to learn Y.
I'm on mobile so this might be a bit short, but recursion is just control flow where a function calls itself. def rec() rec() end This just creates an infinite loop. Usually recursive functions have an escape latch, which is usually when the result of the function is basic. def factorial(n) if n&lt;2 1 else n * factorial(n - 1) end end Here we have a factorial function that returns 1 if the n is less than 2. This is the escape latch, or "base case". The other block is trying to reach the base one step at a time by calling itself again with a lower n. Once it reaches the base case, it stops calling itself and returns the base result (1), causing the loop to terminate and the function to return the result. 
I do a talk series at local Ruby groups called 'what computer scientists know', and recursion is one of the subjects. It was recorded here: https://m.youtube.com/watch?v=S4HqTYdIm9A I also teach computer science in high school. 
http://media.riffsy.com/images/1c50bdbc44d5433fa3c67758dde775d2/tenor.gif
Just ran it and it worked fine for me, weird o.o https://rubygems.org/gems/mysql2/versions/0.4.8 it's definitely there and like you said, a manual install works fine. Bundler wut u doin? unless maybe it's trying to grab the mswin32 one?
I get where you're coming from, but I disagree that The Little Schemer is anywhere close to the level of rigor SICP requires. I find it very accessible in the beginning regardless of your comfort level, and as long as you ensure you're actually following every single page and working the examples before reading the answer, it remains accessible throughout, albeit with some work on your part. You can't breeze through it, but you shouldn't be able to anyway. I would not even remotely say the same of SICP. Whole different league, not a beginner text.
SICP (scheme version), SICP (scheme version), SICP (scheme version). 3 times! You can not find better resouce, though I won't use scheme and I did not finish that book , but no one can explain recursion like that. 
bundler show mysql2 yields ==&gt; /usr/local/lib/ruby/gems/2.3.0/gems/mysql2-0.4.8 I already tried deleting the gemfile.lock and installing again.
you wrote `ruby 2.4.1p111 (2017-03-22 revision 58053) [x86_64-darwin15]` but got `/usr/local/lib/ruby/gems/2.3.0` you have ruby version mismatch
I temporarily changed the ruby version to 2.3.0. However, it keeps throwing the same error. Should I remove the mysql2 gem (using homebrew) and reinstall again ?
Thanks for the tip. I finally got it to work. I changed the ruby version to the latest AFTER I installed the gem. I removed mysql2. I reinstalled mysql2. One last question, do you have to reinstall ALL gems you need for a project if you change the ruby version you are using ? Can you install a gem just for a specific ruby version instead? 
Interesting. How does it compare to FPM?
Thanks for a good comment. It's really interesting to learn from people who use different languages. &gt; why aren't the required adapters simply passed in Yep, we could use basic Dependency Injection for `initialize` method. But as I mentioned in other comment, main reason for me was a 'lazy loading' for the code. If I want to use memory adapter, I shouldn't be required to install redis-specific things. It's a good way isolate dependencies and have flexible approach for injecting adapters from 'outside world' into framework. Also, we use dry-container not just for adapters, but for formatters that allow to list all events too. &gt; There are countless great ways to invert control in Ruby without strictly tying classes together. Exactly and we picked dry-container for that. I'm really happy to see this conversation here and listen to different opinions. Because it's an Open Source code and it can be changed by anyone who knows better way to implement this functionality :)
&gt; Puma is a good choice for concurrency. Thin is not concurrent at all and may actually be slower than WEBrick depending on your workload. Sorry for comming late to the party, but is this claim about Thin correct ? AFAIK Thin based on EventMachine supports both multiple threading and clustering. Protects from slow clients and hog in GILed ruby code does not prevent handling other requests by another instances.
Gems are usually per version, as in when you install them they install into the Ruby's version folder, so if you swap to a new version you'd need to copy/download them
Did not know that. So that means each time you work on a project with a different ruby version you MUST install all gems required, EVEN if you already downloaded them previously ?(different ruby version of course.). What would a best practice be in this case?. 1. Change ruby version globally with rbenv 2. Install gems
This can also be achieved with a plugin system. require 'redis' class SomeRedisAdapter include Events::Adapter def broadcast(event, **payload) # ... end def subscribe(event, **payload) # ... end end Events::Adapter.register(:redis, SomeRedisAdapter) In `Events`, you can use a factory method to allow for selecting the adapter via its name: class Events def self.build(adapter_name) instance = new instance.adapter = Adapter.get(adapter_name) instance end def adapter @adapter ||= Adapter::Substitute.new end attr_writer :adapter end In this case, `Events.new` would return an `Events` instance whose implementations of `broadcast` and `subscribe` essentially "no-op." This means that bare instances of `Events` would not impact the surrounding system, which is useful when `Events` is under test. `Events.build` would be useful for constructing "live" instances that would affect the rest of the system. Of course, this will immediately hearken back to the broader "are IoC containers helpful or harmful?" debate. I don't know that there's any end to that discussion, but I wanted to make sure this thread included an example of the proper alternative :-) Cheers.
mysql gem has it's own specific problems, as basically only native bindings to mysql client library those errors shouldn't really happen and are a corner case yeah normal way is to change ruby version and then install gems and it's not about already downloading a gem, there might be different versions of gems per ruby version, different dependencies etc, each ruby version should be treated as it's own ecosystem it's not like you will have 10 different rubies on one pc for that to make any problem
I would recommend you go with `File.join(__dir__, 'Gemfile')` as it's way more natural to read. The only reason anyone ever used `File.expand_path` was because they had to remove the "basename" part of `__FILE__`.
sails js? it only includes 5 top level boilerpplate folders as opposed to rails' 10, but still.
That was out of context a bit i guess. Thin does support threads, but it's not the default. Last time I checked it didn't support clustering, but i guess now it does? What config key is that `servers` ? You may remember "router gate" from years ago with Heroku. One of the issues was we were recommending thin because it was so fast for single threaded apps. I was part of the group that made an official recommendation. I tested out thin's concurrency at the time and it wasn't good enough, mostly I think that they had a clustering solution but it was a separate project and using it in threaded mode with rack lock wouldn't buy you anything. 
Its pretty different from FPM. FPM basically just generates os packages (like deb and rpm files) while CapsuleCD will help you create a language specific release package/library. 
That looks really promising. Thanks for the idea.
Ah, so it's like a common interface to language specific package managers?
yeah exactly. Its designed so that it follows the best practices of each language, but it follows a common series of customizable steps, with pre and post hooks that you can run your own code with. 
I've not read the Little Schemer, I just looked to verify that it was using Scheme. I believe you if you say it's significantly easier than SICP. Learning a different language in order to grasp a concept is not an efficient way to go about things, that's all I was trying to say. It'd be like asking for help with concurrency in Java and getting advice to learn Erlang. :)
You don't have hash maps on there. Ruby and Python (and JavaScript) often make a lot of use of maps, or other data structures that are effectively maps, such as objects with dynamic fields, so I think a good understanding of how and why a hash map works is a good idea for using these languages, but not as far as implementing them, for a general programmer.
I'd absolutely agree if it were any language other than Scheme - there's simply not much there to learn. In this context it's more of a formal notation for expressing computation than a programming language - you're literally manipulating the AST. That said, you may be right in that it's not necessary to make that leap just to wrap your head around the concept -but whereas hacking on trees in Ruby will help you think recursively about that domain, I still feel reading this book will help you think recursively in general, about any problem. EDIT: I actually would imagine you could work through it in Ruby, with some extra work.
Yeah, and using bundler ofc
Why were you downvoted?! I now completely disagree with you, but I am upvoting you to get you above 0 because nothing you said was offensive or rude and seem to be legitimately attempting to stand by technical merit. (That and you might change my mind, because I might be wrong) Passing in dependencies is a perfectly valid way of avoiding the loading of unwanted code and seems to be nearly idiomatic in Ruby. You simply wouldn't pass the redis dependency in if you didn't want to load it. You could even pass a block or lambda if you want to defer loading to some arbitrary point in the future. I still assert that code written the way in they are in the article are harder to test. Because this code specifically names redis, you must have redis to test it, or be able to carefully unload redis for tests and put a mock in its place. Even then to get full test coverage you would need to do this for each code path. If the dependency were passed then testing would be as simple as passing a mock object in.
not really. 
The language that you program in is mostly irrelevant to this question; it is only related because certain *types of programming* tend to use certain types of languages. In general, you won't need to implement any of those data structures or sorting algorithms. You will need to *use* them, and accordingly you should be familiar with their performance characteristics (in the language of your choice, since the standard library implementations are often smarter than the naive one you would create in an introductory cs course) and know how to choose the appropriate one for a situation. On that note, there are two ways to think about performance of a piece of code: * How long will it take during expected usage? * How will the performance change as we get more data? The first is done by benchmarking, the latter by big O analysis. You need to do them both together to get enough data to make a decision.
If you stick to your language's libraries for the heavy lifting, you will likely never need most of these. The great thing is that the language implementors already implemented any of the needed algorithms and structures behind the scenes and you get nice OO interfaces to them. &gt; Calculating Big O This one is important mostly in very basic applications of, say, why one approach would be linear vs another one quadratic run time. But yes, I think this one is used from time to time. &gt; Linked Lists Almost never used. The Array (a.k.a Vector) class in high-level languages (that are not trying for immutability) obviates linked lists. &gt; Stacks and Queues These are used quite frequently either in the language environment itself, or as in the case of queues, as external services. &gt; Trees Yes, although it is very rare to see the classic forms of binary, red-black, or b-trees. Usually tree structures are heterogenous nested structures like JSON, where knowledge of recursion will allow you to process them quickly and correctly. &gt; Heaps No. &gt; Graphs Unlikely, but knowledge of graph cycles and cycle detection can come up in practice. &gt; Binary search Also unlikely, as most searching is done in the database or on small in-memory data sets where binary search is not useful. &gt; Sorting algorithms You never roll these yourself. The library in your language is probably doing it better than you can, if for no other reason than it can be implemented in C. &gt; Bit Manipulation I have seen some use of bit positions for flags (e.g. Ruby's Regexp#options), but otherwise very rare. &gt; Dynamic Programming Since you specified "does not work with big data or data science," I will say this is essentially non existent in typical work. The only time I have used a dynamic programming technique was solving a very contrived programming challenge.
Squeaky, thanks for your comment) &gt; Why were you downvoted?! I don't know. I've been enjoying conversation that we have here and highly appreciate every opinion and suggestion that might influent future development of a gem, or at least my understanding of a problem. It's always good to have more options, share knowledge and learn from other people. Implementation of that gem has been changing almost every day, so it's possible that in couple months you'll see pure Dependency Injection and no dry-containers there. Or vice versa - more dry-containers. It depends on new challenges we will have and approach we pick. So far dry-container was a good option that worked well. Thanks again for your comment, a lot of good points there.
ri
\*yawn\*
They're allocated lazily. $ irb irb(main):001:0&gt; ObjectSpace.each_object(Class).count =&gt; 489 irb(main):002:0&gt; o = Object.new =&gt; #&lt;Object:0x007fa06882e938&gt; irb(main):003:0&gt; ObjectSpace.each_object(Class).count =&gt; 489 irb(main):004:0&gt; o.singleton_class =&gt; #&lt;Class:#&lt;Object:0x007fa06882e938&gt;&gt; irb(main):005:0&gt; ObjectSpace.each_object(Class).count =&gt; 490 irb(main):006:0&gt; o.singleton_class.singleton_class =&gt; #&lt;Class:#&lt;Class:#&lt;Object:0x007fa06882e938&gt;&gt;&gt; irb(main):007:0&gt; ObjectSpace.each_object(Class).count =&gt; 491
It has been like this since about forever. You want a job and are not located in SF or NYC? Learn C# or Java. 
&gt; needs to be surrounded by curly brackets Well, not really. You can use the `do...end` block syntax too. --- You can avoid your problem by putting your code inside the block. So instead of writing stuff like this: def my_method a = nil with_error_handling { a = 1 } puts a ... more code goes here end You write something like that: def my_method with_error_handling do a = 1 puts a ... more code goes here end end It will work well in most cases. I would actually love to hear examples when it won't. 
So I think the key here is in the first example, a is instantiated before the block so it lives until the end of the method definition. That's where a=nil line comes in.
Other relevant resources on the same topic: - [Serving your own Commercial Rubygems](http://www.mikeperham.com/2016/05/17/commercial-gems/) by Mike Perham - [PackageCloud](https://packagecloud.io), which I'm currently relying on for my [Kiba Pro](https://github.com/thbar/kiba/wiki#kiba-pro) commercial gem hosting. I'm glad to see more content on that topic, because it will encourage people to start commercial packages to sustain OSS if they want.
Nice walkthrough. Most people don't know this but custom Rubygems can be served as static files with Apache only. I wrote a post on how I serve my private gems: http://www.mikeperham.com/2016/05/17/commercial-gems/ With this, it's far easier to admin because you don't have to run and maintain a Ruby stack on the server: rails, puma, capistrano, etc.
Great article! A quick note: if your messages are quite bulky (e.g. whole files to process), Amazon S3 is also a great way to act as "large message passing" between various (Ruby or not) processes, in a way that scales nicely. You can build pretty nice workflows this way.
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/Muchaccho [What I Learned to Love About Ruby When I Switched to Python by Lauren Ellsworth](http://np.reddit.com/r/programming/comments/6sf9ze/what_i_learned_to_love_about_ruby_when_i_switched/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
tl;dw?
&gt; With this, it's far easier to admin because you don't have to run and maintain a Ruby stack on the server: Very true. Your post was in fact an inspiration for some work I did for my previous employer, where we were running our private gem server using geminabox, and wanted to have a cleaner deployment strategy for it. We just had to work around your idea regarding pushing gems, since your environment involved 1/2 gems and 3/4 collaborators, and ours was an enterprise environment with multiple organizations, and authorizing pushes required a mixed strategy involving an inhouse LDAP server for authentication and inhouse gitlab for authorization. However, apache has top support for cgi scripts, so we ended up writing ours in our system ruby (1.8, still useful in 2017) using only stdlib (no external deps) and the Rubygems API, to validate the gem push request, which is also just a **plain** HTTP POST request. Thanks for the inspiration, I don't think this would have been made without your post. P.S.: I don't for how long this apache way of serving gems will be valid though, as bundler 2.0 and the next rubygems will require a new API, and this might not be backwards-compatible. 
A working knowledge of all of these is important. No one area is more important than another - these are a basic toolbox which you might want to draw on at any time. Knowing that an algorithm is going to be O(n!) might be reason to spend time finding something more optimal or that you will never manage to scale it; understanding when one sorting algorithm might provide significant performance improvements over another due to the nature of your data might mean you use something other than the default; understanding that a tree or graph might have a significant impact on memory over a more naive algorithm might mean the difference between your server needing restarting daily or not. I often hear the argument that you don't really need to know these things as a developer and its true; you can spend your life mostly ignorant. However today I saw a file take an hour to process that should have taken minutes if not seconds because the developers don't care (or know) about these things. That can have a significant impact on a business or the resources necessary to support that business and, IMO, is the difference between good or bad software. 
There's still a buoyant usage of Ruby/Rails from the number of jobs on offer and I still consider it one of the best languages in terms of developer productivity. Very much we have more choices though in languages to apply to a project and as every good developer knows - use the right tool for the job. I won't be surprised to find myself still coding in Ruby in 20 years though.
Sorry OT - have you guys a date for the London workshop yet?
Do you have any tips / pointers on how the PackageCloud hosting works? I'd be curious to learn more as I'm already a customer of theirs. Edit: found this: https://packagecloud.io/docs#rubygems
&gt; tl; dw? It was all pretty reasonable in my opinion - mostly it came down to: * Least Surprise (if you knew to ask me to exit(), why did you not just do it?) * Python2 vs Python3 .. versions? SDLC?!? * Bad defaults * Who actually updates python code? * Did I mention bad defaults? * Lack of overall focus * Do it one way vs Do it how you love it
According to you - is it better to work for Toptal or as a freelancer using Toptal platform?
Thanks for your answer! 
First time seeing this article! Enjoyed the read!
&gt; Ruby also does not allow computer scientists to gain the same types of insight into their data as other languages do, said Karen Panetta, an IEEE fellow and associate dean for graduate education at Tufts University. "It might be a good language for if somebody wants to start out doing programming, but true computer scientists don't look at it as introducing the true paradigms of computer programming," Panetta said. "If you just want to get the job done, it's okay." That is idiotic. I have no idea what languages the speaker thinks "introduce the true paradigms of computer science", they could be going to "assembler and C", or they could be going the other direction to "scheme" (which has traditionally been popular in CS programs). But it's just silly. I suspect the speaker doesn't actually know much about ruby. 
No idea. I never worked as a freelancer anywhere.
Actually here in Sydney.. nearly everything on the LinkedIn board is Rails + React.
Meh. Ruby is faster than python for every script and benchmark I tried running myself. Gems and bundler are better than virtualenv. Plus I hate significant whitespace. 
Complaining about white spaces and python is like complaining about () and lisp... cheap shot, not really worth it..
Still valid, it breaks several otherwise decent patterns. Trying to create lambdas with this whitespace rule is a huge pain. It also makes me (and I am sure other devs) unsure of which block certain constructs are in. I am used to sane languages with brackets or keywords that delineate blocks clearly.
Hmm, there are a few Ruby ones. Spina looks pretty nice. I have to say I'm doubtful of a Sinatra based CMS - I'd think that you would have quite a few features in a basic CMS, to the point where you'd want to take advantage of Rails configuration.
I just think it's a crappy way to give a talk to go for such low hanging fruit.. really exit() vs exit? And white spaces in the first minutes 
It also makes it a pain in the ass to just copy something into a REPL to quickly evaluate. Say you have if read_file: with open('file.txt') as f: print(f.readlines()) and you just want to copy the two bottom lines and execute in a python console, without `IndentationError`. Super annoying, all for some slight gain in aesthetics. I don't mind indentation syntax that much in Haml or similar non-executed languages. But it bugs me a lot in Python.
Same in Stockholm, tons of Ruby/Rails positions, as well as an active Ruby Meetup group.
How does it compare to C# or Java positions?
What I found a bit confusing initially is the whole master/read token dance. As well something I haven't tried yet is verifying how a single Gemfile will work with 2 different packagecloud gems (with different tokens) - but I'll try that out. DM me if you need to bounce ideas!
Thanks for sharing the link..
True enough, that's a neat approach too. Gemstash suits our needs perfectly for the moment, but if we need to move to an approach like that, your post will be very handy indeed.
We did have a look at PackageCloud previously, however, we felt that it is much more cost-effective to self host, and self hosting obviously offers more control.
Yup, I can confirm that both Ruby and React are very popular in Sydney
Isn't that why %paste exists? https://stackoverflow.com/questions/10886946/how-does-ipythons-magic-paste-work
Amsterdam is mostly Python, but there are plenty of jobs in Rails too.
Thanks! Amazon S3 is the more modern, secure etc, version of sharing files via FTP, we used to do back in the day. BTW you can also configure S3 to trigger SNS, which can send messages to SQS. So every time you upload a file to S3, a worker can be triggered to process it (S3 =&gt; SNS =&gt; SQS).
white space complaints are old and somewhat tired, but still, when you actually go to use python, sure enough, significant white space is super fucking annoying.
If you program in ruby, I think you could write your own (and then share it) pretty straightforwardly, might be a fun project. Assuming you just need a script to download all the podcasts and generate a playlist, not actually to send to device. You might want to use [feedjira](https://github.com/feedjira/feedjira) as a start to get the feeds. 
So the language creators knew this was bad so they made a workaround rather than a sane solution? That is no the kind of engineering I want near my code most of the time. Why not just allow the first line to be intended at arbitrary levels?
I'd just put the `puts a` inside the block? Otherwise, if you put an `a = nil` outside the block, the variable will be in scope after the block too, it'll be the same variable. Otherwise, if you only need a single value, have the block return it, and the `with_error_handling` return what the block returned? a = with_error_handling { stuff } puts a I think those are your options. 
Is ruby dead again? Like COBOL? Maybe the best for all of us is to learn the beautiful, simple and fun of java
Even worse, iPython isn't Python's REPL, it's a separate product. It's like answering an `irb` complaint with "haven't you heard of feature X in `pry`?"
There oughta be a way to do this but you might need to dig through the Resque code to see exactly what it's workers are doing, and then emulate that in non-ruby code. But the basic part is just gonna be a redis operation, sure. Then there's dealing with queues. One non-obvious part that will non-trivial will be deciding what you want to do in error modes (the same as resque or otherwise). There might be other subtleties. I'd revere-engineer the Resque worker code, see what existing code has the right API for you to re-use, what you might need to re-implement in ruby or your external workers. You could also just have ordinary resque workers running and then immediately farming the work out to non-ruby processes. Again, error mode will be the tricky part. You could have a resque worker wait on the external process and look at exit code, or you could have the resque worker just send it out and say "all done", but then you got to think about failure modes in another way. I think using redis is a good idea. While a basic queue using redis is easy, there are plenty of tricks and edge-case gotchas for doing this reliably, which is why I'd start from reverse-engineering Resque (or Sidekiq), and trying to re-use as much of their already written code as you can. 
Your second solution is similar to what I was imagining. Except, instead of firing up a worker process, do you know if you can call similar code from within a normal app method? Something like in Sinatra: def get_a_job bum @job = Rescue::get_job_for bum erb :job end 
I do not know myself, but spending some time examining the Resque open source code to see, should reveal it, and show you other things Resque is doing that may be useful but not obvious. Looking at existing mature open source code is always a valuable learning experience. 
Thanks for the insight!
I tried writing a queuing library. If you really want you can try to write one but it can be a hassle to have something undependable in production. So, use Resque.
Following my own advice, cause I like reading code to learn what tools are doing too... Doesn't look like there's a totally simple way to do it, but I'd examine the worker.rb code to see what it's doing and why. Among other things, worker.rb registers when a worker is working on a job, and when it's done. Which of course doensn't quite match the architecture you are envisoning. https://github.com/resque/resque/blob/master/lib/resque/worker.rb#L689-L703 But here's the code that actually pulls a job off the queue: https://github.com/resque/resque/blob/master/lib/resque/worker.rb#L313-L320 So you could just do `job = Resque.reserve(queue)`, once you've figured out how to get a handle on the proper `queue` object. But if you just did that manually, you'd be losing all the stuff Resque is trying to do to keep track of what jobs are currently being worked on, what workers currently exist, possibly Resque's failure handling, etc. Your jobs would probably _not_ show up right or at all in resque dashboard, etc. If I were you, I think I'd look for an existing redis-based job queueing library in whatever language you want to write these external workers in. 
If you're wanting to avoid a WordPress because it's not fun the develop in, you might be interested in Rooftop CMS - open source headless Wordpress with a solid set of ruby gems for integration. It'll work great with Sinatra. [http://www.rooftopcms.com/ruby](http://www.rooftopcms.com/ruby) (I'm one of the founders)
Try doing heavy math and scientific code.
so, you're enqueueing work in ruby, but want to perform the work in some other non-ruby process. is that correct? it sounds from your question like you want the non-ruby worker to pull work off the queue, but a simpler way might be to push work to the non-ruby worker from ruby. so: * run a normal ruby resque worker * the ruby job pings the non-ruby process over http asking to perform work * the ruby job blocks on the http call, waiting for work to complete. the results of the http call determine if the job succeeds or fails this avoids having to integrate with Resque in a non-ruby process. you can control the parallelism by spinning up only the correct number of workers.
Fundamentally, Resque uses Redis' [BRPOP](https://redis.io/commands/brpop) function to perform a blocking pop off of a list. Redis is single-threaded, and clients are served in a first-come-first-served fashion, so if you have Ruby clients listening on a given list, you aren't guaranteed to be able to receive jobs to your non-Ruby worker (since they'll get spooled off and handed to the first waiting client). Fundamentally, all you need to be able to do is something like: # Produce jobs in your client redis_client.lpush("list_name", some_job.to_json) # Consume jobs in your worker (Ruby code, but you get the idea) while true job = JSON.parse(redis_client.brpop("list_name")) # Process your job end Redis deals only in primitives and strings, so the job is likely a string in some format. I'm not sure how Resque encodes its jobs - if it's encoded as JSON, then that's easy enough - just parse it in your receiving worker and decide how to handle it. If it's a marshaled Ruby object, then you're out of luck - it's nontrivial to unmarshal from non-Ruby. Personally, I wouldn't use Resque here since all you really want is an interface to LPUSH/BRPOP, and you plan to write the workers yourself, which is where the bulk of Resque's value will be. IMO, just use Redis directly.
Okay, great -- thank you. I have full control over how the interface interprets the data I send, so JSON works well. After reading about BRPOP, I get the impression that "if I ask for work to do on a list, my call doesn't get a response until there is work to do." And if I used RPOP, I'd get something like `nil`if there were no jobs -- is this accurate? Thank you for taking time to respond.
That's correct. The advantage of using BRPOP is that Redis will serve a job to the first waiting client as soon as it's available, and your client can sleep while waiting for data from the socket - effectively going idle while there is no work to be done (rather than running in a loop and continually polling for data). If you want to check multiple queues, you might use RPOP to iterate through them, or you might use a "signalling" design which would be something like: # Worker while true active_queue = client.brpop("active_queues") # Since we've passed the active_queues brpop, we can (probably) # expect there to be an element in this queue job = client.rpop(active_queue) process(job) unless job.nil? # In case another worker somehow got there before us end # Producer client.lpush("my_queue", job) client.lpush("active_queues", "my_queue") This would cause the worker to block on the `active_queues` list, waiting for input about which queue is ready for work, and then as soon as it receives that information, it can pop from the appropriate queue. Redis' PUBSUB functionality could serve a similar purpose, but isn't quite the same thing (since it's broadcast rather than serial). That said, I wouldn't bother with something like this until you have a need for it, since it would increase the design complexity a bit - you have some potential issues with desync between queues, jobs dropped due to network issues or exceptions, etc, and while they're all solvable issues, I'd go with the simplest solution first.
Great, thank you for this quick dive into redis and queues. I really appreciate it, and look forward to exploring this a little bit.
Thanks -- I agree, and may be able to test something like this. There is in fact a way to trigger jobs to the tool with REST requests, but the jobs are very long running (10 min to 10 hours) so we've avoided this afraid of stability issues, containing all of the firing mechanisms internal to the software's traditional scheduler. Because of this, we instead run the other direction, with the tools management system polling for new jobs to do every half hour or so. I wonder if we can break the jobs up smaller and lean on the REST mechanism harder... we haven't really tried. Then it would be as simple as making a worker.rb and calling the method as you suggest. Thanks, it's something to look into!
I've read a lot of your posts recently that you've been pushing to /r/ruby. I just wanted to give you a high five, I enjoy your writing style.
Thanks for reading!
A 'me too' here. &gt;For my website I prefer em and rem over pixels for measurements because I read once in a book that they were better or something. Refreshingly honest. 
Additionally: https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f
Lol. That was the line that inspired my desire to comment.
Are you asking how to write an XML **serializer**? Like with Rails' [build in methods](https://apidock.com/rails/ActiveRecord/XmlSerialization/to_xml), or a [third party library](https://github.com/rails/activemodel-serializers-xml)? Or if you are just dealing with `Struct`s, and always want to generate an XML element for each attribute, then you could just loop through them via `Struct#members`?
I was taken for a ride on my own train of thought... It felt like you were inside my head, haha.
I might if I ever have that need. I presume there are C libs for that stuff if not I know there are java libs I can call from jruby.
i'm curious if your opinion will remain the same if you try React, heh. 
But there are legitimate reasons to prefer em/rem over px.